{"docstring": "/* add a source directory to the list */\n", "func_signal": "static void\naddsrcdir(char *dir)", "code": "{\n\tstruct\tstat\tstatstruct;\n\n\t/* make sure it is a directory */\n\tif (lstat(compath(dir), &statstruct) == 0 && \n\t    S_ISDIR(statstruct.st_mode)) {\n\n\t\t/* note: there already is a source directory list */\n\t\tif (nsrcdirs == msrcdirs) {\n\t\t\tmsrcdirs += DIRINC;\n\t\t\tsrcdirs = myrealloc(srcdirs, msrcdirs * sizeof(char *));\n\t\t}\n\t\tsrcdirs[nsrcdirs++] = my_strdup(dir);\n\t}\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* scrollbar actions */\n", "func_signal": "static void\nscrollbar(MOUSE *p)", "code": "{\n    /* reposition list if it makes sense */\n    if (totallines == 0) {\n\treturn;\n    }\n    switch (p->percent) {\n\t\t\n    case 101: /* scroll down one page */\n\tif (nextline + mdisprefs > totallines) {\n\t    nextline = totallines - mdisprefs + 1;\n\t}\n\tbreak;\n\t\t\n    case 102: /* scroll up one page */\n\tnextline = topline - mdisprefs;\n\tif (nextline < 1) {\n\t    nextline = 1;\n\t}\n\tbreak;\n\n    case 103: /* scroll down one line */\n\tnextline = topline + 1;\n\tbreak;\n\t\t\n    case 104: /* scroll up one line */\n\tif (topline > 1) {\n\t    nextline = topline - 1;\n\t}\n\tbreak;\n    default:\n\tnextline = p->percent * totallines / 100;\n    }\n    seekline(nextline);\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* search for the file in the view path */\n", "func_signal": "char *\ninviewpath(char *file)", "code": "{\n    static char\tpath[PATHLEN + 1];\n    unsigned int i;\n\n    /* look for the file */\n    if (access(compath(file), READ) == 0) {\n\treturn(file);\n    }\n\n    /* if it isn't a full path name and there is a multi-directory\n     * view path */\n    if (*file != '/' && vpndirs > 1) {\n\tint file_len = strlen(file);\n\n\t/* compute its path from higher view path source dirs */\n\tfor (i = 1; i < nvpsrcdirs; ++i) {\n\t    sprintf(path, \"%.*s/%s\",\n\t\t    PATHLEN - 2 - file_len, srcdirs[i],\n\t\t    file);\n\t    if (access(compath(path), READ) == 0) {\n\t\treturn(path);\n\t    }\n\t}\n    }\n    return(NULL);\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* add a #include directory to the list */\n", "func_signal": "static void\naddincdir(char *name, char *path)", "code": "{\n\tstruct\tstat\tstatstruct;\n\n\t/* make sure it is a directory */\n\tif (lstat(compath(path), &statstruct) == 0 && \n\t    S_ISDIR(statstruct.st_mode)) {\n\t\tif (incdirs == NULL) {\n\t\t\tincdirs = mymalloc(mincdirs * sizeof(char *));\n\t\t\tincnames = mymalloc(mincdirs * sizeof(char *));\n\t\t} else if (nincdirs == mincdirs) {\n\t\t\tmincdirs += DIRINC;\n\t\t\tincdirs = myrealloc(incdirs, \n\t\t\t\tmincdirs * sizeof(char *));\n\t\t\tincnames = myrealloc(incnames, \n\t\t\t\tmincdirs * sizeof(char *));\n\t\t}\n\t\tincdirs[nincdirs] = my_strdup(path);\n\t\tincnames[nincdirs++] = my_strdup(name);\n\t}\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* add a #include directory to the list for each view path source directory */\n", "func_signal": "void\nincludedir(char *dirlist)", "code": "{\n    char    path[PATHLEN + 1];\n    char    *dir;\n    unsigned int i;\n\n    makevpsrcdirs();\t\t/* make the view source directory list */\n    dirlist = my_strdup(dirlist); /* don't change environment variable text */\n\t\n    /* parse the directory list */\n    dir = strtok(dirlist, DIRSEPS);\n    while (dir != NULL) {\n\tsize_t dir_len = strlen(dir);\n\n\taddincdir(dir, dir);\n\n\t/* if it isn't a full path name and there is a \n\t   multi-directory view path */\n\tif (*dirlist != '/' && vpndirs > 1) {\n\t\t\t\n\t    /* compute its path from higher view path source dirs */\n\t    for (i = 1; i < nvpsrcdirs; ++i) {\n\t\tsprintf(path, \"%.*s/%s\", \n\t\t\tPATHLEN - 2 - dir_len,\n\t\t\tsrcdirs[i], dir);\n\t\taddincdir(dir, path);\n\t    }\n\t}\n\tdir = strtok(NULL, DIRSEPS);\n    }\n    free(dirlist);\t\t\t/* HBB 20000421: avoid leaks */\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* count the references found */\n", "func_signal": "void\ncountrefs(void)", "code": "{\n    char    *subsystem;             /* OGS subsystem name */\n    char    *book;                  /* OGS book name */\n    char    file[PATHLEN + 1];      /* file name */\n    char    function[PATLEN + 1];   /* function name */\n    char    linenum[NUMLEN + 1];    /* line number */\n    int     i;\n\n    /* count the references found and find the length of the file,\n       function, and line number display fields */\n    subsystemlen = 9;\t/* strlen(\"Subsystem\") */\n    booklen = 4;\t\t/* strlen(\"Book\") */\n    filelen = 4;\t\t/* strlen(\"File\") */\n    fcnlen = 8;\t\t/* strlen(\"Function\") */\n    numlen = 0;\n    while ((i = fscanf(refsfound, \"%250s%250s%5s %5000[^\\n]\", file,\n\t\t       function, linenum, tempstring)) != EOF) {\n\tif (i != 4 ||\n\t    !isgraph((unsigned char) *file) ||\n\t    !isgraph((unsigned char) *function) ||\n\t    !isdigit((unsigned char) *linenum)) {\n\t    postmsg(\"File does not have expected format\");\n\t    totallines = 0;\n\t    disprefs = 0;\n\t    return;\n\t}\n\tif ((i = strlen(pathcomponents(file, dispcomponents))) > filelen) {\n\t    filelen = i;\n\t}\n\tif (ogs == YES) {\n\t    ogsnames(file, &subsystem, &book);\n\t    if ((i = strlen(subsystem)) > subsystemlen) {\n\t\tsubsystemlen = i;\n\t    }\n\t    if ((i = strlen(book)) > booklen) {\n\t\tbooklen = i;\n\t    }\n\t}\n\tif ((i = strlen(function)) > fcnlen) {\n\t    fcnlen = i;\n\t}\n\tif ((i = strlen(linenum)) > numlen) {\n\t    numlen = i;\n\t}\n\t++totallines;\n    }\n    rewind(refsfound);\n\n    /* restrict the width of displayed columns */\n    /* HBB FIXME 20060419: magic number alert! */ \n    i = (COLS - 5) / 3;\n    if (ogs == YES) {\n\ti = (COLS - 7) / 5;\n    }\n    if (filelen > i && i > 4) {\n\tfilelen = i;\n    }\n    if (subsystemlen > i && i > 9) {\n\tsubsystemlen = i;\n    }\n    if (booklen > i && i > 4) {\n\tbooklen = i;\n    }\n    if (fcnlen > i && i > 8) {\n\tfcnlen = i;\n    }\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* scan a directory (recursively?) for source files */\n", "func_signal": "static void\nscan_dir(const char *adir, BOOL recurse_dir)", "code": "{\n\tDIR\t*dirfile;\n\tint adir_len = strlen(adir);\n\n\t/* FIXME: no guards against adir_len > PATHLEN, yet */\n\n\tif ((dirfile = opendir(adir)) != NULL) {\n\t\tstruct dirent *entry;\n\t\tchar\tpath[PATHLEN + 1];\n\t\tchar\t*file;\n\n\t\twhile ((entry = readdir(dirfile)) != NULL) { \n\t\t\tif ((strcmp(\".\",entry->d_name) != 0)\n\t\t\t    && (strcmp(\"..\",entry->d_name) != 0)\n                ) {\n\t\t\t\tstruct stat buf;\n\n\t\t\t\tsprintf(path,\"%s/%.*s\", adir,\n\t\t\t\t\tPATHLEN - 2 - adir_len,\n\t\t\t\t\tentry->d_name);\n\n\t\t\t\tif (lstat(path,&buf) == 0) {\n\t\t\t\t\tfile = entry->d_name;\n\t\t\t\t\tif (recurse_dir && S_ISDIR(buf.st_mode) ) {\n\t\t\t\t\t\tscan_dir(path, recurse_dir);\n\t\t\t\t\t} else if (issrcfile(path)\n\t\t\t\t\t\t   && infilelist(path) == NO\n\t\t\t\t\t\t   && access(path, R_OK) == 0) {\n\t\t\t\t\t\taddsrcfile(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir(dirfile);\n\t}\n        return;\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* execute the command */\n", "func_signal": "BOOL\ncommand(int commandc)", "code": "{\n    char filename[PATHLEN + 1];\t/* file path name */\n    MOUSE *p;\t\t\t/* mouse data */\n    int\tc, i;\n    FILE *file;\n    struct cmd *curritem, *item;\t/* command history */\n    char *s;\n\n    switch (commandc) {\n    case ctrl('C'):\t/* toggle caseless mode */\n        if (caseless == NO) {\n            caseless = YES;\n            postmsg2(\"Caseless mode is now ON\");\n        } else {\n            caseless = NO;\n            postmsg2(\"Caseless mode is now OFF\");\n        }\n\tegrepcaseless(caseless);\t/* turn on/off -i flag */\n\treturn(NO);\n\n    case ctrl('R'):\t/* rebuild the cross reference */\n        if (isuptodate == YES) {\n            postmsg(\"The -d option prevents rebuilding the symbol database\");\n            return(NO);\n        }\n\texitcurses();\n\tfreefilelist();\t\t/* remake the source file list */\n\tmakefilelist();\n\trebuild();\n\tif (errorsfound == YES) {\n\t    errorsfound = NO;\n\t    askforreturn();\n\t}\t\t\n\tentercurses();\n\tclearmsg();\t\t/* clear any previous message */\n\ttotallines = 0;\n\tdisprefs = 0;\t\n\ttopline = nextline = 1;\n\tselecting = 0;\n\tbreak;\n\n#if UNIXPC\n    case ESC:\t/* possible unixpc mouse selection */\n#endif\n    case ctrl('X'):\t/* mouse selection */\n        if ((p = getmouseaction(DUMMYCHAR)) == NULL) {\n            return(NO);\t/* unknown control sequence */\n        }\n\t/* if the button number is a scrollbar tag */\n\tif (p->button == '0') {\n\t    scrollbar(p);\n\t    break;\n\t} \n\t/* ignore a sweep */\n\tif (p->x2 >= 0) {\n\t    return(NO);\n\t}\n\t/* if this is a line selection */\n\tif (p->y1 < FLDLINE) {\n\n\t    /* find the selected line */\n\t    /* note: the selection is forced into range */\n\t    for (i = disprefs - 1; i > 0; --i) {\n            if (p->y1 >= displine[i]) {\n                break;\n            }\n\t    }\n\t    /* display it in the file with the editor */\n\t    editref(i);\n\t} else {\t/* this is an input field selection */\n\t    field = p->y1 - FLDLINE;\n\t    /* force it into range */\n\t    if (field >= FIELDS) {\n            field = FIELDS - 1;\n\t    }\n\t    setfield();\n\t    resetcmd();\n\t    return(NO);\n\t}\n\tbreak;\n\n    case '\\t':\t/* go to next input field */\n        if (disprefs) {\n            selecting = !selecting;\n            if (selecting) {\n                move(displine[curdispline], 0);\n                refresh();\n            } else {\n                atfield();\n                resetcmd();\n            }\n        }\n        return(NO);\n\n#ifdef KEY_ENTER\n    case KEY_ENTER:\n#endif\n    case '\\r':\n    case '\\n':\t/* go to reference */\n        if (selecting) {\n            editref(curdispline);\n            return(YES);\n        }\n        /* FALLTHROUGH */\n\n    case ctrl('N'):\n#ifdef KEY_DOWN\n    case KEY_DOWN:\n#endif\t\t\n#ifdef KEY_RIGHT\n    case KEY_RIGHT:\n#endif\n        if (selecting) {\n            if ((curdispline + 1) < disprefs) {\n                move(displine[++curdispline], 0);\n                refresh();\n            }\n        } else {\n            field = (field + 1) % FIELDS;\n            setfield();\n            atfield();\n            resetcmd();\n        }\n\treturn(NO);\n\n    case ctrl('P'):\t/* go to previous input field */\n#ifdef KEY_UP\n    case KEY_UP:\n#endif\n#ifdef KEY_LEFT\t\t\n    case KEY_LEFT:\n#endif\n        if (selecting) {\n            if (curdispline) {\n                move(displine[--curdispline], 0);\n                refresh();\n            }\n        } else {\n            field = (field + (FIELDS - 1)) % FIELDS;\n            setfield();\n            atfield();\n            resetcmd();\n        }\n\treturn(NO);\n#ifdef KEY_HOME\n    case KEY_HOME:\t/* go to first input field */\n        if (selecting) {\n            curdispline = 0;\n            move(REFLINE, 0);\n            refresh();\n        } else {\n            field = 0;\n            setfield();\n            atfield();\n            resetcmd();\n        }\n        return(NO);\n#endif\n\n#ifdef KEY_LL\n    case KEY_LL:\t/* go to last input field */\n        if (selecting) {\n            move(displine[disprefs - 1], 0);\n            refresh();\n        } else {\n            field = FIELDS - 1;\n            setfield();\n            atfield();\n            resetcmd();\n        }\n        return(NO);\n#endif /* def(KEY_LL) */\n\n    case ' ':\t/* display next page */\n    case '+':\n    case ctrl('V'):\n#ifdef KEY_NPAGE\n    case KEY_NPAGE:\n#endif\n        /* don't redisplay if there are no lines */\n        if (totallines == 0) {\n            return(NO);\n        }\n        /* note: seekline() is not used to move to the next \n         * page because display() leaves the file pointer at\n         * the next page to optimize paging forward\n         */\n        curdispline = 0;\n        break;\n\n    case ctrl('H'):\n    case '-':\t/* display previous page */\n#ifdef KEY_PPAGE\n    case KEY_PPAGE:\n#endif\n        /* don't redisplay if there are no lines */\n        if (totallines == 0) {\n            return(NO);\n        }\n\n\tcurdispline = 0;\n\n\t/* if there are only two pages, just go to the other one */\n\tif (totallines <= 2 * mdisprefs) {\n\t    break;\n\t}\n\t/* if on first page but not at beginning, go to beginning */\n\tnextline -= mdisprefs;\t/* already at next page */\n\tif (nextline > 1 && nextline <= mdisprefs) {\n\t    nextline = 1;\n\t} else {\n\t    nextline -= mdisprefs;\n\t    if (nextline < 1) {\n            nextline = totallines - mdisprefs + 1;\n            if (nextline < 1) {\n                nextline = 1;\n            }\n\t    }\n\t}\n\tseekline(nextline);\n\tbreak;\n\n    case '>':\t/* write or append the lines to a file */\n        if (totallines == 0) {\n            postmsg(\"There are no lines to write to a file\");\n        } else {\t/* get the file name */\n            move(PRLINE, 0);\n            addstr(\"Write to file: \");\n            s = \"w\";\n            if ((c = mygetch()) == '>') {\n                move(PRLINE, 0);\n                addstr(appendprompt);\n                c = '\\0';\n                s = \"a\";\n            }\n            if (c != '\\r' && \n                mygetline(\"\", newpat,\n                          COLS - sizeof(appendprompt), c, NO) > 0\n                ) {\n                shellpath(filename, sizeof(filename), newpat);\n                if ((file = myfopen(filename, s)) == NULL) {\n                    cannotopen(filename);\n                } else {\n                    seekline(1);\n                    while ((c = getc(refsfound)) != EOF) {\n                        putc(c, file);\n                    }\n                    seekline(topline);\n                    fclose(file);\n                }\n            }\n            clearprompt();\n        }\n        return(NO);\t/* return to the previous field */\n\n    case '<':\t/* read lines from a file */\n        move(PRLINE, 0);\n        addstr(readprompt);\n        if (mygetline(\"\", newpat, COLS - sizeof(readprompt),\n                      '\\0', NO) > 0) {\n            clearprompt();\n            shellpath(filename, sizeof(filename), newpat);\n            if (readrefs(filename) == NO) {\n                postmsg2(\"Ignoring an empty file\");\n                return(NO);\n            }\n            return(YES);\n        }\n        clearprompt();\n        return(NO);\n\n    case '^':\t/* pipe the lines through a shell command */\n    case '|':\t/* pipe the lines to a shell command */\n        if (totallines == 0) {\n            postmsg(\"There are no lines to pipe to a shell command\");\n            return(NO);\n        }\n        /* get the shell command */\n        move(PRLINE, 0);\n        addstr(pipeprompt);\n        if (mygetline(\"\", newpat, COLS - sizeof(pipeprompt), '\\0', NO)\n            == 0) {\n            clearprompt();\n            return(NO);\n        }\n        /* if the ^ command, redirect output to a temp file */\n        if (commandc == '^') {\n            strcat(strcat(newpat, \" >\"), temp2);\n            /* HBB 20020708: somebody might have even\n             * their non-interactive default shells\n             * complain about clobbering\n             * redirections... --> delete before\n             * overwriting */\n            remove(temp2);\n        }\n        exitcurses();\n        if ((file = mypopen(newpat, \"w\")) == NULL) {\n            fprintf(stderr, \"\\\ncscope: cannot open pipe to shell command: %s\\n\", newpat);\n        } else {\n            seekline(1);\n            while ((c = getc(refsfound)) != EOF) {\n                putc(c, file);\n            }\n            seekline(topline);\n            mypclose(file);\n        }\n        if (commandc == '^') {\n            if (readrefs(temp2) == NO) {\n                postmsg(\"Ignoring empty output of ^ command\");\n            }\n        }\n        askforreturn();\n        entercurses();\n        break;\n#if defined(KEY_RESIZE) && !defined(__DJGPP__)\n    case KEY_RESIZE:\n        exitcurses();\n        initscr();\n        entercurses();\n#if TERMINFO\n        keypad(stdscr, TRUE);\t/* enable the keypad */\n#ifdef HAVE_FIXKEYPAD\n        fixkeypad();\t/* fix for getch() intermittently returning garbage */\n#endif\n#endif\n#if UNIXPC\n        standend();\t/* turn off reverse video */\n#endif\n        dispinit();\t/* initialize display parameters */\n        setfield();\t/* set the initial cursor position */\n        postmsg(\"\");\t/* clear any build progress message */\n        display();\t/* display the version number and input fields */\n        break;\n#endif\n\n    case ctrl('L'):\t/* redraw screen */\n#ifdef KEY_CLEAR\n    case KEY_CLEAR:\n#endif\n        clearmsg2();\n\tclearok(curscr, TRUE);\n\twrefresh(curscr);\n\tdrawscrollbar(topline, bottomline);\n\treturn(NO);\n    case ctrl('E'):\t/* edit all lines */\n        editall();\n\tbreak;\n    case '!':\t/* shell escape */\n        execute(shell, shell, NULL);\n        seekline(topline);\n        break;\n\n    case '?':\t/* help */\n        clear();\n        help(); \n        clear();\n        seekline(topline);\n        break;\n\n    case ctrl('A'):\t\t/* HBB 20050428: added alt. keymapping */\n    case ctrl('Y'):\t/* repeat last pattern */\n        if (*Pattern != '\\0') {\n            addstr(Pattern);\n            goto repeat;\n        }\n\tbreak;\n\n    case ctrl('B'):\t\t/* cmd history back */\n    case ctrl('F'):\t\t/* cmd history fwd */\n        if (selecting)\n            return(NO);\n\n\tcurritem = currentcmd();\n\titem = (commandc == ctrl('F')) ? nextcmd() : prevcmd();\n\tclearmsg2();\n\tif (curritem == item) {\t/* inform user that we're at history end */\n\t    postmsg2(\"End of input field and search pattern history\");\n\t}\n\tif (item) {\n\t    field = item->field;\n\t    setfield();\n\t    atfield();\n\t    addstr(item->text);\n\t    strcpy(Pattern, item->text);\n\t    switch (c = mygetch()) {\n\t    case '\\r':\n\t    case '\\n':\n            goto repeat;\n\t    case ctrl('F'):\n\t    case ctrl('B'):\n            myungetch(c);\n\t\tatfield();\n\t\tclrtoeol();\t/* clear current field */\n\t\tbreak;\n\t    default:\n            myungetch(c);\n            if (mygetline(Pattern, newpat, COLS - fldcolumn - 1, '\\0', caseless )) {\n                strcpy (Pattern, newpat);\n                resetcmd();\n            }\n            goto repeat;\n            break;\n\t    }\n\t}\n\treturn(NO);\n\n    case '\\\\':\t/* next character is not a command */\n        addch('\\\\');\t/* display the quote character */\n\n        /* get a character from the terminal */\n        if ((commandc = mygetch()) == EOF) {\n            return(NO);\t/* quit */\n        }\n        addstr(\"\\b \\b\");\t/* erase the quote character */\n        goto ispat;\n\n    case '.':\n        postmsg(\"The . command has been replaced by ^Y\");\n        atfield();\t/* move back to the input field */\n        /* FALLTHROUGH */\n    default:\n        if (selecting && !mouse) {\n            char\t\t*c;\n\n            if ((c = strchr(dispchars, commandc)))\n                editref(c - dispchars);\n\n            /* if this is the start of a pattern */\n        } else if (isprint(commandc)) {\n        ispat:\n            if (mygetline(\"\", newpat, COLS - fldcolumn - 1,\n                          commandc, caseless) > 0) {\n                strcpy(Pattern, newpat);\n                resetcmd();\t/* reset command history */\n            repeat:\n                addcmd(field, Pattern);\t/* add to command history */\n                if (field == CHANGE) {\n                    /* prompt for the new text */\n                    move(PRLINE, 0);\n                    addstr(toprompt);\n                    mygetline(\"\", newpat,\n                              COLS - sizeof(toprompt),\n                              '\\0', NO);\n                }\n                /* search for the pattern */\n                if (search() == YES) {\n                    curdispline = 0;\n                    ++selecting;\n\n                    switch (field) {\n                    case DEFINITION:\n                    case FILENAME:\n                        if (totallines > 1) {\n                            break;\n                        }\n                        topline = 1;\n                        editref(0);\n                        break;\n                    case CHANGE:\n                        return(changestring());\n                    }\n\n                } else if (field == FILENAME && \n                           access(newpat, READ) == 0) {\n                    /* try to edit the file anyway */\n                    edit(newpat, \"1\");\n                }\n            } else {\t/* no pattern--the input was erased */\n                return(NO);\n            }\n        } else {\t/* control character */\n            return(NO);\n        }\n\n    } /* switch(commandc) */\n    return(YES);\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* clear the prompt line */\n", "func_signal": "static void\nclearprompt(void)", "code": "{\n\tmove(PRLINE, 0);\n\tclrtoeol();\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* make the view source directory list */\n", "func_signal": "static void\nmakevpsrcdirs(void)", "code": "{\n\tint\ti;\n\n\t/* return if this function has already been called */\n\tif (nsrcdirs > 0) {\n\t\treturn;\n\t}\n\t/* get the current directory name */\n\tif (getcwd(currentdir, PATHLEN) == NULL) {\n\t\tfprintf(stderr, \"cscope: warning: cannot get current directory name\\n\");\n\t\tstrcpy(currentdir, \"<unknown>\");\n\t}\n\t/* see if there is a view path and this directory is in it */\n\tvpinit(currentdir);\n\tif (vpndirs > 1) {\n\t\tnsrcdirs = vpndirs;\n\t} else {\n\t\tnsrcdirs = 1;\n\t}\n\t/* create the source directory list */\n\tmsrcdirs = nsrcdirs + DIRINC;\n\tsrcdirs = mymalloc(msrcdirs * sizeof(char *));\n\t*srcdirs = \".\";\t/* first source dir is always current dir */\n\tfor (i = 1; i < vpndirs; ++i) {\n\t\tsrcdirs[i] = vpdirs[i];\n\t}\n\t/* save the number of original source directories in the view path */\n\tnvpsrcdirs = nsrcdirs;\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* number of directories in view path */\n", "func_signal": "void\nvpinit(char *current_dir)", "code": "{\n\tchar\t*suffix;\t/* path from view path node */\n\tchar\t*vpath;\t\t/* VPATH environment variable value */\n\tchar\tbuf[MAXPATH + 1];\n\tint\ti;\n\tchar\t*s;\n#if NOMALLOC\n\tchar\t*node;\t\t/* view path node */\n\tchar\tvpathbuf[MAXVPATH + 1];\n#endif\n\t\n\t/* if an existing directory list is to be updated, free it */\n\tif (current_dir != NULL && vpndirs > 0) {\n#if !NOMALLOC\n\t\tfor (i = 0; i < vpndirs; ++i) {\n\t\t\tfree(vpdirs[i]);\n\t\t}\n\t\tfree(vpdirs);\n#endif\n\t\tvpndirs = 0;\n\t}\n\t/* return if the directory list has been computed */\n\t/* or there isn't a view path environment variable */\n\tif (vpndirs > 0 || (vpath = getenv(\"VPATH\")) == NULL ||\n\t    *vpath == '\\0') {\n\t\treturn;\n\t}\n\t/* if not given, get the current directory name */\n\tif (current_dir == NULL && (current_dir = getcwd(buf, MAXPATH)) == NULL) {\n\t\t(void) fprintf(stderr, \"%s: cannot get current directory name\\n\", argv0);\n\t\treturn;\n\t}\n\t/* see if this directory is in the first view path node */\n\tfor (i = 0; vpath[i] == current_dir[i] && vpath[i] != '\\0'; ++i) {\n\t\t;\n\t}\n\tif ((vpath[i] != ':' && vpath[i] != '\\0') ||\n\t    (current_dir[i] != '/' && current_dir[i] != '\\0')) {\n\t\treturn;\n\t}\n\tsuffix = &current_dir[i];\n#if !NOMALLOC\n\n\t/* count the nodes in the view path */\n\tvpndirs = 1;\n\tfor (i = 0; vpath[i] != '\\0'; ++i) {\n\t\tif (vpath[i] == ':' && vpath[i + 1]) {\n\t\t\t++vpndirs;\n\t\t}\n\t}\n\t/* create the source directory list */\n\tvpdirs = mymalloc(vpndirs * sizeof(char *));\n\n\t/* don't change VPATH in the environment */\n\tvpath = my_strdup(vpath);\n\t\n\t/* split the view path into nodes */\n\tfor (i = 0, s = vpath; *s != '\\0'; ++i) {\n\t\tvpdirs[i] = s;\n\t\twhile (*s != '\\0' && *++s != ':') {\n\t\t\tif (*s == '\\n') {\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (*s != '\\0') {\n\t\t\t*s++ = '\\0';\n\t\t}\n\t}\n\t/* convert the view path nodes to directories */\n\tfor (i = 0; i < vpndirs; ++i) {\n\t\ts = mymalloc((strlen(vpdirs[i]) + strlen(suffix) + 1));\n\t\t(void) strcpy(s, vpdirs[i]);\n\t\t(void) strcat(s, suffix);\n\t\tvpdirs[i] = s;\n\t}\n\tfree(vpath);\n#else\n\t/* don't change VPATH in the environment */\n\tif (strlen(vpath) > MAXVPATH) {\n\t\t(void) fprintf(stderr, \"%s: VPATH is longer than %d characters: %s\\n\", argv0, MAXVPATH, vpath);\n\t\treturn;\n\t}\n\t(void) strcpy(vpathbuf, vpath);\n\ts = vpathbuf;\n\t\n\t/* convert the view path nodes to directories */\n\twhile (*s != '\\0') {\n\t\t\n\t\t/* get the next node */\n\t\tnode = s;\n\t\twhile (*s != '\\0' && *++s != ':') {\n\t\t\tif (*s == '\\n') {\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (*s != '\\0') {\n\t\t\t*s++ = '\\0';\n\t\t}\n\t\t/* ignore a directory that is too long */\n\t\tif (strlen(node) + strlen(suffix) > DIRLEN) {\n\t\t\t(void) fprintf(stderr, \"%s: VPATH directory is longer than %d characters: %s%s\\n\", argv0, DIRLEN, node, suffix);\n\t\t}\n\t\telse if (vpndirs >= MAXDIR) {\n\t\t\t(void) fprintf(stderr, \"%s: VPATH has more than %d nodes\\n\", argv0, vpndirs);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\t/* create the view path directory */\n\t\t\t(void) strcpy(vpdirs[vpndirs], node);\n\t\t\t(void) strcat(vpdirs[vpndirs], suffix);\n\t\t\t++vpndirs;\n\t\t}\n\t}\n#endif\n}", "path": "vpinit.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* see if the file is already in the list */\n", "func_signal": "BOOL\ninfilelist(char *path)", "code": "{\n    struct listitem *p;\n\n    for (p = srcnames[hash(compath(path)) % HASHMOD];\n\t p != NULL;\n\t p = p->next) {\n\tif (strequal(path, p->text)) {\n\t    return(YES);\n\t}\n    }\n    return(NO);\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* make the source file list */\n", "func_signal": "void\nmakefilelist(void)", "code": "{\n    static  BOOL    firstbuild = YES;       /* first time through */\n    FILE    *names;                 /* name file pointer */\n    char    dir[PATHLEN + 1];\n    char    path[PATHLEN + 1];\n    char    line[PATHLEN * 10];\n    char    *file;\n    char    *s;\n    unsigned int i;\n\n    makevpsrcdirs();\t/* make the view source directory list */\n\n    /* if -i was NOT given and there are source file arguments */\n    if (namefile == NULL && fileargc > 0) {\n\t\t\n\t/* put them in a list that can be expanded */\n\tfor (i = 0; i < fileargc; ++i) {\n\t    file = fileargv[i];\n\t    if (infilelist(file) == NO) {\n\t\tif ((s = inviewpath(file)) != NULL) {\n\t\t    addsrcfile(s);\n\t\t} else {\n\t\t    fprintf(stderr, \"cscope: cannot find file %s\\n\",\n\t\t\t\t   file);\n\t\t    errorsfound = YES;\n\t\t}\n\t    }\n\t}\n\treturn;\n    }\n\n    /* see if a file name file exists */\n    if (namefile == NULL && vpaccess(NAMEFILE, READ) == 0) {\n\tnamefile = NAMEFILE;\n    }\n\n    if (namefile == NULL) {\n\t/* No namefile --> make a list of all the source files\n\t * in the directories */\n\tfor (i = 0; i < nsrcdirs; ++i) {\n\t    scan_dir(srcdirs[i], recurse_dir);\n\t}\n\treturn;\n    }\n\n    /* Came here --> there is a file of source file names */\n\n    if (strcmp(namefile, \"-\") == 0)\n\tnames = stdin;\n    else if ((names = vpfopen(namefile, \"r\")) == NULL) {\n\tcannotopen(namefile);\n\tmyexit(1);\n    }\n\n    /* get the names in the file */\n    while (fgets(line, 10*PATHLEN, names) != NULL) {\n\tchar *point_in_line = line + (strlen(line) - 1);\n\tsize_t length_of_name = 0;\n\tint unfinished_option = 0;\n\tBOOL done = NO;\n\n\t/* Kill away \\n left at end of fgets()'d string: */\n\tif (*point_in_line == '\\n')\n\t    *point_in_line = '\\0';\n\t\t\t\n\t/* Parse whitespace-terminated strings in line: */\n\tpoint_in_line = line;\n\twhile (sscanf(point_in_line, \"%\" PATHLEN_STR \"s\", path) == 1) {\n\t    /* Have to store this length --- inviewpath() will\n\t     * modify path, later! */\n\t    length_of_name = strlen(path);\n\t\t\t  \n\t    if (*path == '-') {\t/* if an option */\n\t\tif (unfinished_option) {\n\t\t    /* Can't have another option directly after an\n\t\t     * -I or -p option with no name after it! */\n\t\t    fprintf(stderr, \"\\\ncscope: Syntax error in namelist file %s: unfinished -I or -p option\\n\", \n\t\t\t\t   namefile);\n\t\t    unfinished_option = 0;\n\t\t}\n\t\t\t\t\t\t\n\t\ti = path[1];\n\t\tswitch (i) {\n\t\tcase 'c':\t/* ASCII characters only in crossref */\n\t\t    compress = NO;\n\t\t    break;\n\t\tcase 'k':\t/* ignore DFLT_INCDIR */\n\t\t    kernelmode = YES;\n\t\t    break;\n\t\tcase 'q':\t/* quick search */\n\t\t    invertedindex = YES;\n\t\t    break;\n\t\tcase 'T':\t/* truncate symbols to 8 characters */\n\t\t    trun_syms = YES;\n\t\t    break;\n\t\tcase 'I':\t/* #include file directory */\n\t\tcase 'p':\t/* file path components to display */\n\t\t    s = path + 2;\t\t/* for \"-Ipath\" */\n\t\t    if (*s == '\\0') {\t/* if \"-I path\" */\n\t\t\tunfinished_option = i;\n\t\t\tbreak; \n\t\t    } \n\n\t\t    /* this code block used several times in here\n\t\t     * --> make it a macro to avoid unnecessary\n\t\t     * duplication */\n#define HANDLE_OPTION_ARGUMENT(i, s)\t\t\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tswitch (i) {\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tcase 'I':\t/* #include file directory */\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tif (firstbuild == YES) {\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t/* expand $ and ~ */\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\tshellpath(dir, sizeof(dir), (s));\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\tincludedir(dir);\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tunfinished_option = 0;\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tdone = YES;\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tcase 'p':\t/* file path components to display */\t\t\t\t\t\t   \\\n\t\t\t\t\t\tif (*(s) < '0' || *(s) > '9') {\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\tfprintf(stderr,\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t       \"cscope: -p option in file %s: missing or invalid numeric value\\n\", \\\n\t\t\t\t\t\t\t\t       namefile);\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tdispcomponents = atoi(s);\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tunfinished_option = 0;\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tdone = YES;\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tdone = NO;\t\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t} /* switch(i) */\n\n\t\t    /* ... and now call it for the first time */\n\t\t    HANDLE_OPTION_ARGUMENT(i, s)\n\t\t\tbreak;\n\t\tdefault:\n\t\t    fprintf(stderr, \"cscope: only -I, -c, -k, -p, and -T options can be in file %s\\n\", \n\t\t\t\t   namefile);\n\t\t} /* switch(i) */\n\t    } /* if('-') */\n\t    else if (*path == '\"') {\n\t\t/* handle quoted filenames... */\n\t\tsize_t in = 1, out = 0;\n\t\tchar *newpath = mymalloc(PATHLEN + 1);\n\n\t\twhile (in < PATHLEN && point_in_line[in] != '\\0') {\n\t\t    if (point_in_line[in] == '\"') {\n\t\t\tnewpath[out] = '\\0';\n\t\t\t/* Tell outer loop to skip over this entire quoted string */\n\t\t\tlength_of_name = in + 1;\n\t\t\tbreak;\t/* found end of quoted string */\n\t\t    } else if (point_in_line[in] == '\\\\'\n\t\t\t       && in < PATHLEN - 1\n\t\t\t       && (point_in_line[in + 1]== '\"'\n\t\t\t\t   || point_in_line[in + 1] == '\\\\')) {\n\t\t\t/* un-escape \\\" or \\\\ sequence */\n\t\t\tnewpath[out++] = point_in_line[in + 1];\n\t\t\tin += 2;\n\t\t    } else {\n\t\t\tnewpath[out++] = point_in_line[in++];\n\t\t    }\n\t\t} /* while(in) */ \n\t\tif (in >= PATHLEN) { /* safeguard against almost-overflow */\n\t\t    newpath[out]='\\0';\n\t\t}\n\n\t\t/* If an -I or -p arguments was missing before,\n\t\t * treat this name as the argument: */\n\t\tHANDLE_OPTION_ARGUMENT(unfinished_option, newpath);\n\t\tif (! done) {\n\t\t    if ((s = inviewpath(newpath)) != NULL) {\n\t\t\taddsrcfile(s);\n\t\t    } else {\n\t\t\tfprintf(stderr,\n\t\t\t\t       \"cscope: cannot find file %s\\n\",\n\t\t\t\t       newpath);\n\t\t\terrorsfound = YES;\n\t\t    }\n\t\t}\n\t    } /* if(quoted name) */\n\t    else {\n\t\t/* ... so this is an ordinary file name, unquoted */\n\n\t\t/* If an -I or -p arguments was missing before,\n\t\t * treat this name as the argument: */\n\t\tHANDLE_OPTION_ARGUMENT(unfinished_option, path);\n\t\tif (!done) {\n\t\t    if ((s = inviewpath(path)) != NULL) {\n\t\t\taddsrcfile(s);\n\t\t    } else {\n\t\t\tfprintf(stderr, \"cscope: cannot find file %s\\n\",\n\t\t\t\t       path);\n\t\t\terrorsfound = YES;\n\t\t    }\n\t\t}\n\t    } /* else(ordinary name) */\n\n\t    point_in_line += length_of_name;\n\t    while (isspace((unsigned char) *point_in_line))\n\t\tpoint_in_line ++;\n\t} /* while(sscanf(line)) */\n    } /* while(fgets(line)) */\n\n    if (names == stdin)\n\tclearerr(stdin);\n    else\n\tfclose(names);\n    firstbuild = NO;\n    return;\n\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* mark/unmark this displayed line to be changed */\n", "func_signal": "static void\nmark(unsigned int i)", "code": "{\n    unsigned int j;\n\t\n    j = i + topline - 1;\n    if (j < totallines) {\n\tmove(displine[i], 1);\n\n\tif (change[j] == NO) {\n\t    change[j] = YES;\n\t    addch('>');\n\t} else {\n\t    change[j] = NO;\n\t    addch(' ');\n\t}\n    }\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* HBB 20000421: new function, for avoiding leaks */\n/* free list of src directories */\n", "func_signal": "void\nfreesrclist()", "code": "{\n\tif (!srcdirs)\n\t\treturn;\n\twhile(nsrcdirs>1)\n\t\tfree(srcdirs[--nsrcdirs]);\n\tfree(srcdirs);\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* add a source directory to the list for each view path source directory */\n", "func_signal": "void\nsourcedir(char *dirlist)", "code": "{\n    char    path[PATHLEN + 1];\n    char    *dir;\n    unsigned int i;\n\n    makevpsrcdirs();\t\t/* make the view source directory list */\n    dirlist = my_strdup(dirlist); /* don't change environment variable text */\n\t\n    /* parse the directory list */\n    dir = strtok(dirlist, DIRSEPS);\n    while (dir != NULL) {\n\tint dir_len = strlen(dir);\n\n\taddsrcdir(dir);\n\n\t/* if it isn't a full path name and there is a \n\t   multi-directory view path */\n\tif (*dirlist != '/' && vpndirs > 1) {\n\t\t\t\n\t    /* compute its path from higher view path source dirs */\n\t    for (i = 1; i < nvpsrcdirs; ++i) {\n\t\tsprintf(path, \"%.*s/%s\",\n\t\t\tPATHLEN - 2 - dir_len,\n\t\t\tsrcdirs[i], dir);\n\t\taddsrcdir(path);\n\t    }\n\t}\n\tdir = strtok(NULL, DIRSEPS);\n    }\n    free(dirlist);\t\t/* HBB 20000421: avoid memory leaks */\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* add an include file to the source file list */\n", "func_signal": "void\nincfile(char *file, char *type)", "code": "{\n    char    name[PATHLEN + 1];\n    char    path[PATHLEN + 1];\n    char    *s;\n    unsigned int i;\n\n    /* see if the file is already in the source file list */\n    if (infilelist(file) == YES) {\n\treturn;\n    }\n    /* look in current directory if it was #include \"file\" */\n    if (type[0] == '\"' && (s = inviewpath(file)) != NULL) {\n\taddsrcfile(s);\n    } else {\n\tsize_t file_len = strlen(file);\n\n\t/* search for the file in the #include directory list */\n\tfor (i = 0; i < nincdirs; ++i) {\n\t    /* don't include the file from two directories */\n\t    sprintf(name, \"%.*s/%s\",\n\t\t    PATHLEN - 2 - file_len, incnames[i],\n\t\t    file);\n\t    if (infilelist(name) == YES) {\n\t\tbreak;\n\t    }\n\t    /* make sure it exists and is readable */\n\t    sprintf(path, \"%.*s/%s\",\n\t\t    PATHLEN - 2 - file_len, incdirs[i],\n\t\t    file);\n\t    if (access(compath(path), READ) == 0) {\n\t\taddsrcfile(path);\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* HBB 2000421: new function, for avoiding memory leaks */\n/* free the list of include files, if wanted */\n", "func_signal": "void\nfreeinclist()", "code": "{\n\tif (!incdirs)\t\n\t\treturn;\n\twhile(nincdirs>0) {\n\t\tfree(incdirs[--nincdirs]);\n\t\tfree(incnames[nincdirs]);\n\t}\n\tfree(incdirs);\n\tfree(incnames);\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* add a source file to the list */\n", "func_signal": "void\naddsrcfile(char *path)", "code": "{\n\tstruct\tlistitem *p;\n\tint\ti;\n\t\n\t/* make sure there is room for the file */\n\tif (nsrcfiles == msrcfiles) {\n\t\tmsrcfiles += SRCINC;\n\t\tsrcfiles = myrealloc(srcfiles, msrcfiles * sizeof(char *));\n\t}\n\t/* add the file to the list */\n\tsrcfiles[nsrcfiles++] = my_strdup(compath(path));\n\tp = mymalloc(sizeof(struct listitem));\n\tp->text = my_strdup(compath(path));\n\ti = hash(p->text) % HASHMOD;\n\tp->next = srcnames[i];\n\tsrcnames[i] = p;\n}", "path": "dir.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/* change one text string to another */\n", "func_signal": "static BOOL\nchangestring(void)", "code": "{\n    char    newfile[PATHLEN + 1];   /* new file name */\n    char    oldfile[PATHLEN + 1];   /* old file name */\n    char    linenum[NUMLEN + 1];    /* file line number */\n    char    msg[MSGLEN + 1];        /* message */\n    FILE    *script;                /* shell script file */\n    BOOL    anymarked = NO;         /* any line marked */\n    MOUSE *p;                       /* mouse data */\n    int     c;\n    unsigned int i;\n    char    *s;\n\n    /* open the temporary file */\n    if ((script = myfopen(temp2, \"w\")) == NULL) {\n\tcannotopen(temp2);\n\treturn(NO);\n    }\n    /* create the line change indicators */\n    change = mycalloc(totallines, sizeof(BOOL));\n    changing = YES;\n    mousemenu();\n\n    /* until the quit command is entered */\n    for (;;) {\n\t/* display the current page of lines */\n\tdisplay();\n    same:\n\tatchange();\n\t\t\n\t/* get a character from the terminal */\n\tif ((c = mygetch()) == EOF\n\t    || c == ctrl('D') \n\t    || c == ctrl('Z')) {\n\t    break;\t/* change lines */\n\t}\n\t/* see if the input character is a command */\n\tswitch (c) {\n\tcase ' ':\t/* display next page */\n\tcase '+':\n\tcase ctrl('V'):\n#ifdef KEY_NPAGE\n\tcase KEY_NPAGE:\n#endif\n\tcase '-':\t/* display previous page */\n#ifdef KEY_PPAGE\n\tcase KEY_PPAGE:\n#endif\n\tcase '!':\t/* shell escape */\n\tcase '?':\t/* help */\n\t    command(c);\n\t    break;\n\n\tcase ctrl('L'):\t/* redraw screen */\n#ifdef KEY_CLEAR\n\tcase KEY_CLEAR:\n#endif\n\t    command(c);\n\t    goto same;\n\n\tcase ESC:\t/* don't change lines */\n#if UNIXPC\n\t    if((p = getmouseaction(DUMMYCHAR)) == NULL) {\n\t\tgoto nochange;\t/* unknown escape sequence */\n\t    }\n\t    break;\n#endif\n\tcase ctrl('G'):\n\t    goto nochange;\n\n\tcase '*':\t/* mark/unmark all displayed lines */\n\t    for (i = 0; topline + i < nextline; ++i) {\n\t\tmark(i);\n\t    }\n\t    goto same;\n\n\tcase ctrl('A'):\t/* mark/unmark all lines */\n\t    for (i = 0; i < totallines; ++i) {\n\t\tif (change[i] == NO) {\n\t\t    change[i] = YES;\n\t\t} else {\n\t\t    change[i] = NO;\n\t\t}\n\t    }\n\t    /* show that all have been marked */\n\t    seekline(totallines);\n\t    break;\n\n\tcase ctrl('X'):\t/* mouse selection */\n\t    if ((p = getmouseaction(DUMMYCHAR)) == NULL) {\n\t\tgoto same;\t/* unknown control sequence */\n\t    }\n\t    /* if the button number is a scrollbar tag */\n\t    if (p->button == '0') {\n\t\tscrollbar(p);\n\t\tbreak;\n\t    }\n\t    /* find the selected line */\n\t    /* note: the selection is forced into range */\n\t    for (i = disprefs - 1; i > 0; --i) {\n\t\tif (p->y1 >= displine[i]) {\n\t\t    break;\n\t\t}\n\t    }\n\t    mark(i);\n\t    goto same;\n\n\tdefault:\n\t    {\n\t\t/* if a line was selected */\n\t\tchar\t\t*cc;\n\n\t\tif ((cc = strchr(dispchars, c)))\n\t\t    mark(cc - dispchars);\n\n\t\tgoto same;\n\t    } /* default case */\n\t} /* switch(change code character) */\n    } /* for(ever) */\n\n    /* for each line containing the old text */\n    fprintf(script, \"ed - <<\\\\!\\n\");\n    *oldfile = '\\0';\n    seekline(1);\n    for (i = 0; \n\t fscanf(refsfound, \"%\" PATHLEN_STR \"s%*s%\" NUMLEN_STR \"s%*[^\\n]\", newfile, linenum) == 2;\n\t ++i) {\n\t/* see if the line is to be changed */\n\tif (change[i] == YES) {\n\t    anymarked = YES;\n\t\t\n\t    /* if this is a new file */\n\t    if (strcmp(newfile, oldfile) != 0) {\n\t\t\t\t\n\t\t/* make sure it can be changed */\n\t\tif (access(newfile, WRITE) != 0) {\n\t\t    sprintf(msg, \"Cannot write to file %s\", newfile);\n\t\t    postmsg(msg);\n\t\t    anymarked = NO;\n\t\t    break;\n\t\t}\n\t\t/* if there was an old file */\n\t\tif (*oldfile != '\\0') {\n\t\t    fprintf(script, \"w\\n\");\t/* save it */\n\t\t}\n\t\t/* edit the new file */\n\t\tstrcpy(oldfile, newfile);\n\t\tfprintf(script, \"e %s\\n\", oldfile);\n\t    }\n\t    /* output substitute command */\n\t    fprintf(script, \"%ss/\", linenum);\t/* change */\n\t    for (s = Pattern; *s != '\\0'; ++s) {\n\t\t/* old text */\n\t\tif (strchr(\"/\\\\[.^*\", *s) != NULL) {\n\t\t    putc('\\\\', script);\n\t\t}\n\t\tif (caseless == YES && isalpha((unsigned char)*s)) {\n\t\t    putc('[', script);\n\t\t    if(islower((unsigned char)*s)) {\n\t\t\tputc(toupper((unsigned char)*s), script);\n\t\t\tputc(*s, script);\n\t\t    } else {\n\t\t\tputc(*s, script);\n\t\t\tputc(tolower((unsigned char)*s), script);\n\t\t    }\n\t\t    putc(']', script);\n\t\t} else\t\n\t\t    putc(*s, script);\n\t    }\n\t    putc('/', script);\t\t\t/* to */\n\t    for (s = newpat; *s != '\\0'; ++s) {\t/* new text */\n\t\tif (strchr(\"/\\\\&\", *s) != NULL) {\n\t\t    putc('\\\\', script);\n\t\t}\n\t\tputc(*s, script);\n\t    }\n\t    fprintf(script, \"/gp\\n\");\t/* and print */\n\t}\n    }\n    fprintf(script, \"w\\nq\\n!\\n\");\t/* write and quit */\n    fclose(script);\n\n    /* if any line was marked */\n    if (anymarked == YES) {\n\t\t\n\t/* edit the files */\n\tclearprompt();\n\trefresh();\n\tfprintf(stderr, \"Changed lines:\\n\\r\");\n\texecute(\"sh\", \"sh\", temp2, NULL);\n\taskforreturn();\n\tseekline(1);\n    } else {\n    nochange:\n\tclearprompt();\n    }\n    changing = NO;\n    mousemenu();\n    free(change);\n    return(anymarked);\n}", "path": "command.c", "repo_name": "abrady/ascope", "stars": 2, "license": "None", "language": "c", "size": 1196}
{"docstring": "/*\n * We're only doing type checking.  We could do constant folding\n * somewhere around here if we wanted.\n * TODO: write an int2float() and figure out where to call it\n */\n", "func_signal": "semrec_t *\narith_op_type_reduce (semrec_t * t1, semrec_t * t2)", "code": "{\n    semrec_t *ct = new_semrec (\"\");\n    ct->is_temp = TRUE;\n\n    /* set it to the \"shared\" type */\n    ct->type = t1->type;\n\n    if (FALSE == typecmp (t1->type, t2->type))\n    {\n        /*\n         * One float - one int\n         * Need to upconvert to float\n         */\n        ct->type = TYPE_FLOAT;\n\n        /* Binary conversion. */\n        if (TYPE_INT == t1->type)\n        {\n            t1->value.fval = t1->value.intval;\n            t1->type = TYPE_FLOAT;\n        }\n        else\n        {\n            t2->value.fval = t2->value.intval;\n            t2->type = TYPE_INT;\n        }\n    }\n\n    return ct;\n}", "path": "hw_04\\src\\ourtypes.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*\n * Here is where we save caller registers\n * as well as set up jump routines and such \n * for calling a function\n */\n", "func_signal": "var_ref *\ncheck_function (char *a, TypeList * b)", "code": "{\n    symtab *PST;\n    var_ref *PVR;\n    int i = 0;\n    TypeList *c = b;\n    while (c)\n    {\n        i++;\n        c = c->next;\n    }\n\n    PVR = Allocate (VAR_REF);\n\n    if ((PST = lookup (a)) == NULL)\n    {\n        printf (\"error %d: undefined function %s\\n\", linenumber, a);\n        PVR->type = ERROR_;\n        GLOBAL_ERROR = 1;\n    }\n    else if (PST->type != FUNC_)\n    {\n        printf (\"error %d: %s is not a function\\n\", linenumber, a);\n        PVR->type = ERROR_;\n        GLOBAL_ERROR = 1;\n    }\n    else if (i > PST->symtab_u.st_func->params)\n    {\n        printf (\"error %d: too many arguments to function %s\\n\", linenumber,\n                a);\n        PVR->type = ERROR_;\n        GLOBAL_ERROR = 1;\n    }\n    else if (i < PST->symtab_u.st_func->params)\n    {\n        printf (\"error %d: too few arguments to function %s\\n\", linenumber,\n                a);\n        PVR->type = ERROR_;\n        GLOBAL_ERROR = 1;\n    }\n    else if (0 == strcmp (a, \"read\"))\n    {\n        asm_emit_read ();\n        PVR->place = 2;\n        PVR->type = INT_;\n    }\n    else if (0 == strcmp (a, \"fread\"))\n    {\n\n        asm_emit_fread ();\n        PVR->place = 0;\n        PVR->type = FLOAT_;\n    }\n    else\n    {\n        var_ref *PVR1;\n        ST_func *x;\n        param_list *y;\n        x = PST->symtab_u.st_func;\n        y = x->PL;\n        i = 0;\n        PVR->type = PST->symtab_u.st_func->ret_type;\n        while (y)\n        {\n            PVR1 = b->P_var_r;\n            if ((y->PPAR == NULL) || (PVR1->type == ERROR_))\n            {\n                y = y->next;\n                b = b->next;\n                PVR->type = ERROR_;\n                i++;\n                continue;\n            }\n\n\n            switch (y->PPAR->type)\n            {\n            case INT_:\n            case FLOAT_:\n                if ((PVR1->type != INT_) && (PVR1->type != FLOAT_))\n                {\n                    printf\n                        (\"error %d: function arg %d, expects scalar, passed %s of type %s\\n\",\n                         linenumber, i, (PVR1->name) ? (PVR1->name) : \"\",\n                         printtype (PVR1->type));\n                    PVR->type = ERROR_;\n                }\n                break;\n            case ARR_:\n                if ((PVR1->type == INT_) || (PVR1->type == FLOAT_))\n                {\n                    printf\n                        (\"error %d: function arg %d, scalar %s passed, expects a %dD array\\n\",\n                         linenumber, i, (PVR1->name) ? (PVR1->name) : \"\",\n                         PST->symtab_u.st_arr->dim);\n                    PVR->type = ERROR_;\n                }\n                else if (PVR1->type == ARR_)\n                {\n                    if ((y->PPAR->arrtype !=\n                         PVR1->var_ref_u.arr_info->arrtype)\n                        || (y->PPAR->dim != PVR1->var_ref_u.arr_info->dim))\n                        printf\n                            (\"warning %d: passing arg %d of %s from incompatible pointer type\\n\",\n                             linenumber, i, a);\n                }\n                else\n                {\n                    printf\n                        (\"error %d: function arg %d, expects array, passed a struct %s\\n\",\n                         linenumber, i, (PVR1->name) ? (PVR1->name) : \"\");\n                    PVR->type = ERROR_;\n                }\n                break;\n            default:\n                break;\n            }\n            i++;\n            y = y->next;\n            b = b->next;\n        }\n    }\n\n    return PVR;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*****************************************************************************/\n", "func_signal": "struct hashtable *\ncreate_hashtable(unsigned int minsize,\n                 unsigned int (*hashf) (void*),\n                 int (*eqf) (void*,void*))", "code": "{\n    struct hashtable *h;\n    unsigned int pindex, size = primes[0];\n    /* Check requested hashtable isn't too large */\n    if (minsize > (1u << 30)) return NULL;\n    /* Enforce size as prime */\n    for (pindex=0; pindex < prime_table_length; pindex++) {\n        if (primes[pindex] > minsize) { size = primes[pindex]; break; }\n    }\n    h = (struct hashtable *)malloc(sizeof(struct hashtable));\n    if (NULL == h) return NULL; /*oom*/\n    h->table = (struct entry **)malloc(sizeof(struct entry*) * size);\n    if (NULL == h->table) { free(h); return NULL; } /*oom*/\n    memset(h->table, 0, size * sizeof(struct entry *));\n    h->tablelength  = size;\n    h->primeindex   = pindex;\n    h->entrycount   = 0;\n    h->hashfn       = hashf;\n    h->eqfn         = eqf;\n    h->loadlimit    = (unsigned int) ceil(size * max_load_factor);\n    return h;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* This is weird, don't touch */\n", "func_signal": "void\nbreak_from_symtab(int scope)", "code": "{\n    semrec_t *head = sym_table;\n    while (head->scope == scope)\n    {\n        head = sym_table->next;\n        if(sym_table->scope != scope){\n            sym_table->next = NULL;\n        }\n        sym_table = head;\n    }\n}", "path": "hw_04\\src\\ourtypes.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* returns value associated with key */\n", "func_signal": "hashtable_search(struct hashtable *h, void *k)", "code": "{\n    struct entry *e;\n    unsigned int hashvalue, index;\n    hashvalue = hash(h,k);\n    index = indexFor(h->tablelength,hashvalue);\n    e = h->table[index];\n    while (NULL != e)\n    {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) return e->v;\n        e = e->next;\n    }\n    return NULL;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* FIXME: fix the offsets here, don't handle variable length records */\n", "func_signal": "TYPE\ndecl_enter_ST (var_decl * a)", "code": "{\n    init_id *PII;\n    id_list *PIL;\n    symtab *symptr = NULL;\n    TYPE ret = ZERO_;\n    PIL = a->P_id_l;\n\n    if (a == NULL)\n        return ERROR_;\n\n    if (a->type == ERROR_)\n        return ERROR_;\n\n    if (PIL == NULL)\n        return ERROR_;\n\n    do\n    {\n        PII = PIL->P_ini_i;\n        switch (a->type)\n        {\n        case INT_:\n            if (PII->type == ARR_)\n            {\n                PII->init_id_u.P_arr_s->arr_info->arrtype = INT_;\n                symptr = chk_insert (PII->init_id_u.P_arr_s->name, ARR_,\n                                     PII->init_id_u.P_arr_s->arr_info, 0);\n                symptr->offset = PII->offset;\n            }\n            else\n            {\n                autocast (a->type, PII);\n                symptr = chk_insert (PII->init_id_u.name, INT_, PII, 0);\n                symptr->offset = PII->offset;\n            }\n            break;\n        case FLOAT_:\n            if (PII->type == ARR_)\n            {\n                PII->init_id_u.P_arr_s->arr_info->arrtype = FLOAT_;\n                symptr = chk_insert (PII->init_id_u.P_arr_s->name, ARR_,\n                                     PII->init_id_u.P_arr_s->arr_info, 0);\n                symptr->offset = PII->offset;\n            }\n            else\n            {\n                autocast (a->type, PII);\n                symptr = chk_insert (PII->init_id_u.name, FLOAT_, PII, 0);\n                symptr->offset = PII->offset;\n            }\n            break;\n        case STR_VAR_:\n        case STR_:\n            if (PII->type == ARR_)\n            {\n                PII->init_id_u.P_arr_s->arr_info->arrtype = STR_;\n                PII->init_id_u.P_arr_s->arr_info->type_name = a->type_name;\n                chk_insert (PII->init_id_u.P_arr_s->name, ARR_,\n                            PII->init_id_u.P_arr_s->arr_info, 0);\n            }\n            else\n                chk_insert (PII->init_id_u.name, STR_VAR_, a->type_name, 0);\n            break;\n        case ERROR_:\n            ret = ERROR_;\n            break;\n        default:\n            ret = ERROR_;\n            break;\n        }\n    }\n    while ((PIL = PIL->next));\n\n    return ret;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Unless global declarations exist, this function is not called. */\n", "func_signal": "void\nasm_emit_global_decls_start (void)", "code": "{\n    asm_out (\"# 'line #' comments printed at line endings correspond to\\n\");\n    asm_out (\"# the location in the original C-- source code when\\n\");\n    asm_out (\"# the line of MIPS assembly code was generated\\n\\n\");\n\n    asm_out (\".data\\t# line %d\\n\", linenumber);\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*****************************************************************************/\n", "func_signal": "unsigned int\nhash(struct hashtable *h, void *k)", "code": "{\n    /* Aim to protect against poor hash functions by adding logic here\n     * - logic taken from java 1.4 hashtable source */\n    unsigned int i = h->hashfn(k);\n    i += ~(i << 9);\n    i ^=  ((i >> 14) | (i << 18)); /* >>> */\n    i +=  (i << 4);\n    i ^=  ((i >> 10) | (i << 22)); /* >>> */\n    return i;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*we do not allocate the string for the lexeme here*/\n", "func_signal": "void *\nAllocate (ALL_TYPE type)", "code": "{\n    switch (type)\n    {\n    case STRING:\n        return (void *) malloc (sizeof (String));\n    case INTNUMBER:\n        return (void *) malloc (sizeof (int));\n    case TYPE_STRING:\n        return (void *) malloc (sizeof (Type_String));\n    case TYPELIST:\n        return (void *) malloc (sizeof (TypeList));\n    case STRINGLIST:\n        return (void *) malloc (sizeof (Stringlist));\n    case ARRAY_SEM:\n        return (void *) malloc (sizeof (array_semantic));\n    case STRUCT_SEM:\n        return (void *) malloc (sizeof (struct_semantic));\n    case ID_LIST:\n        return (void *) malloc (sizeof (id_list));\n    case VAR_DECL:\n        return (void *) malloc (sizeof (var_decl));\n    case INIT_ID:\n        return (void *) malloc (sizeof (init_id));\n    case DEF_LIST:\n        return (void *) malloc (sizeof (def_list));\n    case PARAM:\n        return (void *) malloc (sizeof (param));\n    case ST_ARR:\n        return (void *) malloc (sizeof (ST_arr));\n    case ST_FUNC:\n        return (void *) malloc (sizeof (ST_func));\n    case ST_STRUCT:\n        return (void *) malloc (sizeof (ST_struct));\n    case SYMTAB:\n        return (void *) malloc (sizeof (symtab));\n    case VAR_REF:\n        return (void *) malloc (sizeof (var_ref));\n    case TYPE_ARR:\n        return (void *) malloc (sizeof (Type_arr));\n    case PARAM_LIST:\n        return (void *) malloc (sizeof (param_list));\n    case CONST_REC:\n        return (void *) malloc (sizeof (CON_Type));\n    default:\n        return NULL;\n    }\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* returns register */\n", "func_signal": "int\nasm_emit_load_int(int reg, var_ref* v)", "code": "{\n    symtab* ptr = NULL;\n\n    if (NULL != v->name)\n    {\n        ptr = lookup (v->name);\n        assert (NULL != ptr);\n\n        /*  FIXME: I don't think this is right */\n        if (ptr->scope > 0)\n        {\n            asm_out (\"\\tlw\\t$%d, %d($fp)\\t# line %d\\n\", reg,\n                     ptr->offset, linenumber);\n        }\n        else\n        {\n            asm_out (\"\\tlw\\t$%d, _%s\\t# line %d\\n\", reg, v->name,\n                     linenumber);\n        }\n    }\n    else\n    {\n        if (0 == v->place)\n        {\n            asm_out (\"\\tli\\t$%d, %d\\t# line %d\\n\", reg,\n                     v->tmp_val_u.tmp_intval, linenumber);\n        }\n        else if (1 == v->is_return)\n        {\n            reg = v->place;\n        }\n        else\n        {\n            reg = v->place;\n        }\n    }\n\n    return reg;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*return 0 on error else return 1*/\n/* 0 means no entry added to symbol table*/\n", "func_signal": "int\nstruct_type_P (char *a, def_list * b)", "code": "{\n    struct_semantic *ret = NULL;\n    struct_semantic *PSS;\n\n    if (b == NULL)\n    {\n        printf (\"error %d: structure declaration with no members\\n\",\n                linenumber);\n        GLOBAL_ERROR = 1;\n        return 0;\n    }\n    if (check_duplicate (b))\n    {\n        GLOBAL_ERROR = 1;\n        return 0;\n    }\n\n    /*there are no duplicates in the structure */\n    /*we enter all the elements in the def_list even of they have errors */\n\n    do\n    {\n        var_decl *PVD = b->P_var_s;\n        TYPE type = PVD->type;\n        id_list *PIL = PVD->P_id_l;\n        do\n        {\n            init_id *PII = PIL->P_ini_i;\n            PSS = Allocate (STRUCT_SEM);\n            switch (type)\n            {\n            case INT_:\n            case FLOAT_:\n                switch (PII->type)\n                {\n                case ZERO_:\n                case ERROR_:\n                    PSS->struct_semantic_u.var_name = PII->init_id_u.name;\n                    PSS->type = type;\n                    break;\n                case ARR_:\n                    PSS->struct_semantic_u.arr_sem = PII->init_id_u.P_arr_s;\n                    PSS->type = ARR_;\n                    PII->init_id_u.P_arr_s->arr_info->arrtype = type;\n                    break;\n                default:\n                    break;\n                }\n                break;\n            case STR_VAR_:\n            case STR_:\n                switch (PII->type)\n                {\n                case ZERO_:\n                case ERROR_:\n                    PSS->type = type;\n                    PSS->struct_semantic_u.str_info.str_var_name =\n                        PII->init_id_u.name;\n                    PSS->struct_semantic_u.str_info.struct_type_name =\n                        PVD->type_name;\n                    break;\n                case ARR_:\n                    PSS->type = ARR_;\n                    PSS->struct_semantic_u.arr_sem = PII->init_id_u.P_arr_s;\n                    PII->init_id_u.P_arr_s->arr_info->arrtype = STR_;\n                    PII->init_id_u.P_arr_s->arr_info->type_name =\n                        PVD->type_name;\n                    break;\n                default:\n                    break;\n                }\n                break;\n            case ERROR_:\n                GLOBAL_ERROR = 1;\n                continue;\n            default:\n                GLOBAL_ERROR = 1;\n                continue;\n            }\n            if (!ret)\n            {\n                PSS->next = NULL;\n                ret = PSS;\n            }\n            else\n            {\n                PSS->next = ret;\n                ret = PSS;\n            }\n\n        }\n        while ((PIL = PIL->next));\n    }\n    while ((b = b->next));\n    insert (a, STR_, ret, 0);\n    return 1;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* returns value associated with key */\n", "func_signal": "hashtable_remove(struct hashtable *h, void *k)", "code": "{\n    /* TODO: consider compacting the table when the load factor drops enough,\n     *       or provide a 'compact' method. */\n\n    struct entry *e;\n    struct entry **pE;\n    void *v;\n    unsigned int hashvalue, index;\n\n    hashvalue = hash(h,k);\n    index = indexFor(h->tablelength,hash(h,k));\n    pE = &(h->table[index]);\n    e = *pE;\n    while (NULL != e)\n    {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k)))\n        {\n            *pE = e->next;\n            h->entrycount--;\n            v = e->v;\n            freekey(e->k);\n            free(e);\n            return v;\n        }\n        pE = &(e->next);\n        e = e->next;\n    }\n    return NULL;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*****************************************************************************/\n", "func_signal": "static int\nhashtable_expand(struct hashtable *h)", "code": "{\n    /* Double the size of the table to accomodate more entries */\n    struct entry **newtable;\n    struct entry *e;\n    struct entry **pE;\n    unsigned int newsize, i, index;\n    /* Check we're not hitting max capacity */\n    if (h->primeindex == (prime_table_length - 1)) return 0;\n    newsize = primes[++(h->primeindex)];\n\n    newtable = (struct entry **)malloc(sizeof(struct entry*) * newsize);\n    if (NULL != newtable)\n    {\n        memset(newtable, 0, newsize * sizeof(struct entry *));\n        /* This algorithm is not 'stable'. ie. it reverses the list\n         * when it transfers entries between the tables */\n        for (i = 0; i < h->tablelength; i++) {\n            while (NULL != (e = h->table[i])) {\n                h->table[i] = e->next;\n                index = indexFor(newsize,e->h);\n                e->next = newtable[index];\n                newtable[index] = e;\n            }\n        }\n        free(h->table);\n        h->table = newtable;\n    }\n    /* Plan B: realloc instead */\n    else \n    {\n        newtable = (struct entry **)\n                   realloc(h->table, newsize * sizeof(struct entry *));\n        if (NULL == newtable) { (h->primeindex)--; return 0; }\n        h->table = newtable;\n        memset(newtable[h->tablelength], 0, newsize - h->tablelength);\n        for (i = 0; i < h->tablelength; i++) {\n            for (pE = &(newtable[i]), e = *pE; e != NULL; e = *pE) {\n                index = indexFor(newsize,e->h);\n                if (index == i)\n                {\n                    pE = &(e->next);\n                }\n                else\n                {\n                    *pE = e->next;\n                    e->next = newtable[index];\n                    newtable[index] = e;\n                }\n            }\n        }\n    }\n    h->tablelength = newsize;\n    h->loadlimit   = (unsigned int) ceil(newsize * max_load_factor);\n    return -1;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Force variable type to match given type. */\n", "func_signal": "void\nautocast (TYPE type, init_id * PII)", "code": "{\n#if 0\n    fprintf (stderr, \"autocast: %s, %s intval=%d fval=%f\\n\", printtype (type),\n             PII->init_id_u.name, PII->val_u.intval, PII->val_u.fval);\n#endif\n    switch (type)\n    {\n    case INT_:\n        if (FLOAT_ == PII->type)\n            PII->val_u.intval = PII->val_u.fval;\n        break;\n    case FLOAT_:\n        if (INT_ == PII->type)\n            PII->val_u.fval = PII->val_u.intval;\n        break;\n    default:\n        fprintf (stderr, \"Cannot autocast given type: %s\\n\",\n                 printtype (type));\n        assert (0);\n    }\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Return value is the register holding the result of the expr */\n", "func_signal": "int\nasm_emit_expr (var_ref * a, var_ref * b, int opval)", "code": "{\n\n    int regA = get_reg (a);\n    int regB = get_reg (b);\n    int res_reg = get_result_reg ();\n\n    /* TODO: the parser enforces identical typing? */\n    if (INT_ == a->type)\n    {\n        regA = asm_emit_load_int(regA, a);\n\n        if (regB != regA)\n        {\n            regB = asm_emit_load_int(regB, b);\n        }\n    }\n    else\n    {   /* FLOAT_ */\n        regA = asm_emit_load_float(regA, a);\n        if(regB != regA){\n            regB = asm_emit_load_float(regB, b);\n        }\n    }\n\n    if (OP_PLUS == opval)\n    {\n        if (INT_ == a->type)\n        {\n            asm_out (\"\\tadd\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n        }\n        else\n        {\n            asm_out (\"\\tadd.s\\t$f%d, $f%d, $f%d\\t# line %d\\n\", res_reg, regA,\n                     regB, linenumber);\n        }\n    }\n    else if (OP_MINUS == opval)\n    {\n        if (INT_ == a->type)\n        {\n            asm_out (\"\\tsub\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n        }\n        else\n        {\n            asm_out (\"\\tsub.s\\t$f%d, $f%d, $f%d\\t# line %d\\n\", res_reg, regA,\n                     regB, linenumber);\n        }\n    }\n\n    free_reg (regA);\n    free_reg (regB);\n    save_reg (res_reg);\n    return res_reg;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int\nhashtable_insert(struct hashtable *h, void *k, void *v)", "code": "{\n    /* This method allows duplicate keys - but they shouldn't be used */\n    unsigned int index;\n    struct entry *e;\n    if (++(h->entrycount) > h->loadlimit)\n    {\n        /* Ignore the return value. If expand fails, we should\n         * still try cramming just this value into the existing table\n         * -- we may not have memory for a larger table, but one more\n         * element may be ok. Next time we insert, we'll try expanding again.*/\n        hashtable_expand(h);\n    }\n    e = (struct entry *)malloc(sizeof(struct entry));\n    if (NULL == e) { --(h->entrycount); return 0; } /*oom*/\n    e->h = hash(h,k);\n    index = indexFor(h->tablelength,e->h);\n    e->k = k;\n    e->v = v;\n    e->next = h->table[index];\n    h->table[index] = e;\n    return -1;\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Return value is the register holding the result of the expr */\n", "func_signal": "int\nasm_emit_relop_factor (var_ref * a, var_ref * b, int opval)", "code": "{\n    int regA = get_reg (a);\n    int regB = -9999;\n    int res_reg;\n\n    if (NULL == b)\n    {\n        res_reg = regA;\n    }\n    else\n    {\n        res_reg = get_result_reg ();\n        regB = get_reg (b);\n    }\n\n    /* TODO: the parser enforces identical typing? */\n    if (INT_ == a->type)\n    {\n        regA = asm_emit_load_int(regA, a);\n\n        /* if b is null, this is an expr-to-relop_factor reduction */\n        if (NULL != b)\n        {\n            regB = asm_emit_load_int(regB, b);\n        }\n    }\n    else\n    { /* FLOAT_ */\n        regA = asm_emit_load_float(regA, a);\n\n        /* if b is null, this is an expr-to-relop_factor reduction */\n        if (NULL != b)\n        {\n            regB = asm_emit_load_float(regB, b);\n        }\n    }\n\n    /* TODO: emit asm for comparisons */\n\n    if (NULL != b)\n    {\n        switch (opval)\n        {\n        case OP_GT:\n            asm_out (\"\\tsgt\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        case OP_GE:\n            asm_out (\"\\tsge\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        case OP_LT:\n            asm_out (\"\\tslt\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        case OP_LE:\n            asm_out (\"\\tsle\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        case OP_NE:\n            asm_out (\"\\tsne\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        case OP_EQ:\n            asm_out (\"\\tseq\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n            break;\n        default:\n            fprintf (stderr, \"don't know how to handle relop: %d\\n\", opval);\n            assert (0);\n        }\n    }\n\n\n    free_reg (regA);\n    if (-9999 != regB)\n        free_reg (regB);\n    save_reg (res_reg);\n\n    return res_reg;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Return value is the register holding the result of the expr */\n", "func_signal": "int\nasm_emit_term (var_ref * a, var_ref * b, int opval)", "code": "{\n\n    int regA = get_reg (a);\n    int regB = get_reg (b);\n    int res_reg = get_result_reg ();\n\n    /* TODO: the parser enforces identical typing? */\n    if (INT_ == a->type)\n    {\n        regA = asm_emit_load_int(regA, a);\n\n        if (regB != regA)\n        {\n            regB = asm_emit_load_int(regB, b);\n        }\n    }\n    else\n    { /* FLOAT_ */\n        regA = asm_emit_load_float(regA, a);\n\n        if (regB != regA)\n        {\n            regB = asm_emit_load_float(regB, b);\n        }\n    }\n\n    if (OP_TIMES == opval)\n    {\n        if (INT_ == a->type)\n        {\n            asm_out (\"\\tmul\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n        }\n        else\n        {\n            asm_out (\"\\tmul.s\\t$f%d, $f%d, $f%d\\t# line %d\\n\", res_reg, regA,\n                     regB, linenumber);\n        }\n    }\n    else if (OP_DIVIDE == opval)\n    {\n        if (INT_ == a->type)\n        {\n            asm_out (\"\\tdiv\\t$%d, $%d, $%d\\t# line %d\\n\", res_reg, regA, regB,\n                     linenumber);\n        }\n        else\n        {\n            asm_out (\"\\tdiv.s\\t$f%d, $f%d, $f%d\\t# line %d\\n\", res_reg, regA,\n                     regB, linenumber);\n        }\n    }\n\n    free_reg (regA);\n    free_reg (regB);\n    save_reg (res_reg);\n    return res_reg;\n}", "path": "hw_05\\src\\functions.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*\n * The most recent scope is always at the head\n * of the list\n */\n", "func_signal": "void\nfree_scope (int scope)", "code": "{\n    semrec_t *head = sym_table;\n    /* TODO: add check for existing symrec_ts with getsym */\n    while (head->scope == scope)\n    {\n        /* TODO: needs a better check for scoping */\n        head = sym_table->next;\n        if (sym_table->scope == scope)\n        {\n            sym_table->is_temp = TRUE;\n            our_free (sym_table);       /* only frees the head */\n        }\n        sym_table = head;\n    }\n}", "path": "hw_04\\src\\symtab.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/*****************************************************************************/\n/* destroy */\n", "func_signal": "void\nhashtable_destroy(struct hashtable *h, int free_values)", "code": "{\n    unsigned int i;\n    struct entry *e, *f;\n    struct entry **table = h->table;\n    if (free_values)\n    {\n        for (i = 0; i < h->tablelength; i++)\n        {\n            e = table[i];\n            while (NULL != e)\n            { f = e; e = e->next; freekey(f->k); free(f->v); free(f); }\n        }\n    }\n    else\n    {\n        for (i = 0; i < h->tablelength; i++)\n        {\n            e = table[i];\n            while (NULL != e)\n            { f = e; e = e->next; freekey(f->k); free(f); }\n        }\n    }\n    free(h->table);\n    free(h);\n}", "path": "hw_02\\src\\hashtable.c", "repo_name": "meonkeys/compilers", "stars": 3, "license": "None", "language": "c", "size": 562}
{"docstring": "/* Process the data from socket and pseudo tty */\n", "func_signal": "static int process_data(int fd)", "code": "{\n\tstruct pollfd p[2];\n\tchar buf[1024];\n\tint err, r;\n\n\tp[0].fd = 0;\n\tp[0].events = POLLIN | POLLERR | POLLHUP | POLLNVAL;\n\t\n\tp[1].fd = fd;\n\tp[1].events = POLLIN | POLLERR | POLLHUP | POLLNVAL;\n\n\terr = 0;\n\n\twhile (!__io_canceled) {\n\t\tp[0].revents = 0;\n\t\tp[1].revents = 0;\n\t\t\n\t\terr = poll(p, 2, -1);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = 0;\n\n\t\tif (p[0].revents) {\n\t\t\tif (p[0].revents & (POLLERR | POLLHUP | POLLNVAL))\n\t\t\t  break;\n\t\t\tr = read(0, buf, sizeof(buf));\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\terr = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = write_n(fd, buf, r);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (p[1].revents) {\n\t\t\tif (p[1].revents & (POLLERR | POLLHUP | POLLNVAL))\n\t\t\t\tbreak;\n\t\t\tr = read(fd, buf, sizeof(buf));\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\terr = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = write_n(1, buf, r);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}", "path": "tools\\ppporc.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * A simple function which returns the time of day in\n * seconds. Used for updating the service db state\n * attribute of the service record of the SDP server\n */\n", "func_signal": "uint32_t sdp_get_time()", "code": "{\n\t/*\n\t * To handle failure in gettimeofday, so an old\n\t * value is returned and service does not fail\n\t */\n\tstatic struct timeval tm;\n\n\tgettimeofday(&tm, NULL);\n\treturn (uint32_t) tm.tv_sec;\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Given a GstCaps, this will return a fixed GstCaps on sucessfull conversion.\n * If an error occurs, it will return NULL and error_message will contain the\n * error message.\n *\n * error_message must be passed NULL, if an error occurs, the caller has the\n * ownership of the error_message, it must be freed after use.\n */\n", "func_signal": "GstCaps *gst_sbc_util_caps_fixate(GstCaps *caps, gchar **error_message)", "code": "{\n\tGstCaps *result;\n\tGstStructure *structure;\n\tconst GValue *value;\n\tgboolean error = FALSE;\n\tgint temp, rate, channels, blocks, subbands, bitpool;\n\tconst gchar *allocation = NULL;\n\tconst gchar *mode = NULL;\n\n\tg_assert(*error_message == NULL);\n\n\tstructure = gst_caps_get_structure(caps, 0);\n\n\tif (!gst_structure_has_field(structure, \"rate\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no rate\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"rate\");\n\t\tif (GST_VALUE_HOLDS_LIST(value))\n\t\t\ttemp = gst_sbc_select_rate_from_list(value);\n\t\telse\n\t\t\ttemp = g_value_get_int(value);\n\t\trate = temp;\n\t}\n\n\tif (!gst_structure_has_field(structure, \"channels\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no channels\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"channels\");\n\t\tif (GST_VALUE_HOLDS_INT_RANGE(value))\n\t\t\ttemp = gst_sbc_select_channels_from_range(value);\n\t\telse\n\t\t\ttemp = g_value_get_int(value);\n\t\tchannels = temp;\n\t}\n\n\tif (!gst_structure_has_field(structure, \"blocks\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no blocks.\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"blocks\");\n\t\tif (GST_VALUE_HOLDS_LIST(value))\n\t\t\ttemp = gst_sbc_select_blocks_from_list(value);\n\t\telse\n\t\t\ttemp = g_value_get_int(value);\n\t\tblocks = temp;\n\t}\n\n\tif (!gst_structure_has_field(structure, \"subbands\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no subbands\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"subbands\");\n\t\tif (GST_VALUE_HOLDS_LIST(value))\n\t\t\ttemp = gst_sbc_select_subbands_from_list(value);\n\t\telse\n\t\t\ttemp = g_value_get_int(value);\n\t\tsubbands = temp;\n\t}\n\n\tif (!gst_structure_has_field(structure, \"bitpool\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no bitpool\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"bitpool\");\n\t\tif (GST_VALUE_HOLDS_INT_RANGE(value))\n\t\t\ttemp = gst_sbc_select_bitpool_from_range(value);\n\t\telse\n\t\t\ttemp = g_value_get_int(value);\n\t\tbitpool = temp;\n\t}\n\n\tif (!gst_structure_has_field(structure, \"allocation\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no allocation\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"allocation\");\n\t\tif (GST_VALUE_HOLDS_LIST(value))\n\t\t\tallocation = gst_sbc_get_allocation_from_list(value);\n\t\telse\n\t\t\tallocation = g_value_get_string(value);\n\t}\n\n\tif (!gst_structure_has_field(structure, \"mode\")) {\n\t\terror = TRUE;\n\t\t*error_message = g_strdup(\"no mode\");\n\t\tgoto error;\n\t} else {\n\t\tvalue = gst_structure_get_value(structure, \"mode\");\n\t\tif (GST_VALUE_HOLDS_LIST(value)) {\n\t\t\tmode = gst_sbc_get_mode_from_list(value, channels);\n\t\t} else\n\t\t\tmode = g_value_get_string(value);\n\t}\n\n\t/* perform validation\n\t * if channels is 1, we must have channel mode = mono\n\t * if channels is 2, we can't have channel mode = mono */\n\tif ( (channels == 1 && (strcmp(mode, \"mono\") != 0) ) ||\n\t\t\t( channels == 2 && ( strcmp(mode, \"mono\") == 0))) {\n\t\t*error_message = g_strdup_printf(\"Invalid combination of \"\n\t\t\t\t\t\"channels (%d) and channel mode (%s)\",\n\t\t\t\t\tchannels, mode);\n\t\terror = TRUE;\n\t}\n\nerror:\n\tif (error)\n\t\treturn NULL;\n\n\tresult = gst_caps_new_simple(\"audio/x-sbc\",\n\t\t\t\t\t\"rate\", G_TYPE_INT, rate,\n\t\t\t\t\t\"channels\", G_TYPE_INT, channels,\n\t\t\t\t\t\"mode\", G_TYPE_STRING, mode,\n\t\t\t\t\t\"blocks\", G_TYPE_INT, blocks,\n\t\t\t\t\t\"subbands\", G_TYPE_INT, subbands,\n\t\t\t\t\t\"allocation\", G_TYPE_STRING, allocation,\n\t\t\t\t\t\"bitpool\", G_TYPE_INT, bitpool,\n\t\t\t\t\tNULL);\n\n\treturn result;\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Selects one rate from a list of possible rates\n * TODO - use a better approach to this (it is selecting the last element)\n */\n", "func_signal": "gint gst_sbc_select_rate_from_list(const GValue *value)", "code": "{\n\tguint size = gst_value_list_get_size(value);\n\treturn g_value_get_int(gst_value_list_get_value(value, size-1));\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/* Read exactly len bytes (Signal safe)*/\n", "func_signal": "static inline int read_n(int fd, char *buf, int len)", "code": "{\n\tregister int t = 0, w;\n\n\twhile (!__io_canceled && len > 0) {\n\t\tif ((w = read(fd, buf, len)) < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!w)\n\t\t\treturn 0;\n\t\tlen -= w;\n\t\tbuf += w;\n\t\tt += w;\n\t}\n\n\treturn t;\n}", "path": "tools\\ppporc.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Remove a registered service record\n */\n", "func_signal": "int service_remove_req(sdp_req_t *req, sdp_buf_t *rsp)", "code": "{\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = ntohl(bt_get_unaligned((uint32_t *) p));\n\tsdp_record_t *rec;\n\tint status = 0;\n\n\t/* extract service record handle */\n\tp += sizeof(uint32_t);\n\n\trec = sdp_record_find(handle);\n\tif (rec) {\n\t\tsdp_svcdb_collect(rec);\n\t\tstatus = sdp_record_remove(handle);\n\t\tsdp_record_free(rec);\n\t\tif (status == 0) {\n\t\t\tupdate_db_timestamp();\n\t\t\tupdate_svclass_list(BDADDR_ANY);\n\t\t}\n\t} else {\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\t\tSDPDBG(\"Could not find record : 0x%x\", handle);\n\t}\n\n\tp = rsp->data;\n\tbt_put_unaligned(htons(status), (uint16_t *) p);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn status;\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Update a service record\n */\n", "func_signal": "int service_update_req(sdp_req_t *req, sdp_buf_t *rsp)", "code": "{\n\tsdp_record_t *orec;\n\tint status = 0, scanned = 0;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = ntohl(bt_get_unaligned((uint32_t *) p));\n\n\tSDPDBG(\"Svc Rec Handle: 0x%x\", handle);\n\n\tp += sizeof(uint32_t);\n\tbufsize -= sizeof(uint32_t);\n\n\torec = sdp_record_find(handle);\n\n\tSDPDBG(\"SvcRecOld: %p\", orec);\n\n\tif (orec) {\n\t\tsdp_record_t *nrec = extract_pdu_server(BDADDR_ANY, p, bufsize,\n\t\t\t\t\t\t\thandle, &scanned);\n\t\tif (nrec && handle == nrec->handle) {\n\t\t\tupdate_db_timestamp();\n\t\t\tupdate_svclass_list(BDADDR_ANY);\n\t\t} else {\n\t\t\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\t\t\tSDPDBG(\"SvcRecHandleNew : 0x%x\", nrec->handle);\n\t\t\tSDPDBG(\"SvcRecNew : %p\", nrec);\n\t\t\tSDPDBG(\"SvcRecOld : %p\", orec);\n\t\t\tSDPDBG(\"Failure to update, restore old value\");\n\n\t\t\tstatus = SDP_INVALID_SYNTAX;\n\t\t}\n\n\t\tif (nrec)\n\t\t\tsdp_record_free(nrec);\n\t} else\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\n\tp = rsp->data;\n\tbt_put_unaligned(htons(status), (uint16_t *) p);\n\trsp->data_size = sizeof(uint16_t);\n\treturn status;\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/* Create the RFCOMM connection */\n", "func_signal": "static int create_connection(bdaddr_t *bdaddr, uint8_t channel)", "code": "{\n\tstruct sockaddr_rc remote_addr, local_addr;\n\tint fd, err;\n\n\tif ((fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)) < 0)\n\t\treturn fd;\n\n\tmemset(&local_addr, 0, sizeof(local_addr));\n\tlocal_addr.rc_family = AF_BLUETOOTH;\n\tbacpy(&local_addr.rc_bdaddr, BDADDR_ANY);\n\tif ((err = bind(fd, (struct sockaddr *)&local_addr, sizeof(local_addr))) < 0) {\n\t\tclose(fd);\n\t\treturn err;\n\t}\n\n\tmemset(&remote_addr, 0, sizeof(remote_addr));\n\tremote_addr.rc_family = AF_BLUETOOTH;\n\tbacpy(&remote_addr.rc_bdaddr, bdaddr);\n\tremote_addr.rc_channel = channel;\n\tif ((err = connect(fd, (struct sockaddr *)&remote_addr, sizeof(remote_addr))) < 0) {\n\t\tclose(fd);\n\t\treturn err;\n\t}\n\n\tsyslog(LOG_INFO, \"RFCOMM channel %d connected\", channel);\n\n\treturn fd;\n}", "path": "tools\\ppporc.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * The SDP server must present its own service record to\n * the service repository. This can be accessed by service\n * discovery clients. This method constructs a service record\n * and stores it in the repository\n */\n", "func_signal": "void register_server_service(void)", "code": "{\n\tsdp_list_t *classIDList;\n\tuuid_t classID;\n\tvoid **versions, **versionDTDs;\n\tuint8_t dtd;\n\tsdp_data_t *pData;\n\tint i;\n\n\tserver = sdp_record_alloc();\n\tserver->pattern = NULL;\n\n\t/* Force the record to be SDP_SERVER_RECORD_HANDLE */\n\tserver->handle = SDP_SERVER_RECORD_HANDLE;\n\n\tsdp_record_add(BDADDR_ANY, server);\n\tsdp_attr_add(server, SDP_ATTR_RECORD_HANDLE,\n\t\t\t\tsdp_data_alloc(SDP_UINT32, &server->handle));\n\n\tsdp_uuid16_create(&classID, SDP_SERVER_SVCLASS_ID);\n\tclassIDList = sdp_list_append(0, &classID);\n\tsdp_set_service_classes(server, classIDList);\n\tsdp_list_free(classIDList, 0);\n\n\t/*\n\t * Set the version numbers supported, these are passed as arguments\n\t * to the server on command line. Now defaults to 1.0\n\t * Build the version number sequence first\n\t */\n\tversions = (void **)malloc(sdpServerVnumEntries * sizeof(void *));\n\tversionDTDs = (void **)malloc(sdpServerVnumEntries * sizeof(void *));\n\tdtd = SDP_UINT16;\n\tfor (i = 0; i < sdpServerVnumEntries; i++) {\n\t\tuint16_t *version = malloc(sizeof(uint16_t));\n\t\t*version = sdpVnumArray[i].major;\n\t\t*version = (*version << 8);\n\t\t*version |= sdpVnumArray[i].minor;\n\t\tversions[i] = version;\n\t\tversionDTDs[i] = &dtd;\n\t}\n\tpData = sdp_seq_alloc(versionDTDs, versions, sdpServerVnumEntries);\n\tfor (i = 0; i < sdpServerVnumEntries; i++)\n\t\tfree(versions[i]);\n\tfree(versions);\n\tfree(versionDTDs);\n\tsdp_attr_add(server, SDP_ATTR_VERSION_NUM_LIST, pData);\n\n\tupdate_db_timestamp();\n\tupdate_svclass_list(BDADDR_ANY);\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/* Write exactly len bytes (Signal safe)*/\n", "func_signal": "static inline int write_n(int fd, char *buf, int len)", "code": "{\n\tregister int t = 0, w;\n\n\twhile (!__io_canceled && len > 0) {\n\t\tif ((w = write(fd, buf, len)) < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!w)\n\t\t\treturn 0;\n\t\tlen -= w;\n\t\tbuf += w;\n\t\tt += w;\n\t}\n\n\treturn t;\n}", "path": "tools\\ppporc.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Selects one allocation mode from the ones on the list\n * TODO - use a better approach\n */\n", "func_signal": "const gchar *gst_sbc_get_allocation_from_list(const GValue *value)", "code": "{\n\tguint size = gst_value_list_get_size(value);\n\treturn g_value_get_string(gst_value_list_get_value(value, size-1));\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Add the newly created service record to the service repository\n */\n", "func_signal": "int service_register_req(sdp_req_t *req, sdp_buf_t *rsp)", "code": "{\n\tint scanned = 0;\n\tsdp_data_t *handle;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tsdp_record_t *rec;\n\n\treq->flags = *p++;\n\tif (req->flags & SDP_DEVICE_RECORD) {\n\t\tbacpy(&req->device, (bdaddr_t *) p);\n\t\tp += sizeof(bdaddr_t);\n\t\tbufsize -= sizeof(bdaddr_t);\n\t}\n\n\t// save image of PDU: we need it when clients request this attribute\n\trec = extract_pdu_server(&req->device, p, bufsize, 0xffffffff, &scanned);\n\tif (!rec)\n\t\tgoto invalid;\n\n\tif (rec->handle == 0xffffffff) {\n\t\trec->handle = sdp_next_handle();\n\t\tif (rec->handle < 0x10000) {\n\t\t\tsdp_record_free(rec);\n\t\t\tgoto invalid;\n\t\t}\n\t} else {\n\t\tif (sdp_record_find(rec->handle)) {\n\t\t\t/* extract_pdu_server will add the record handle\n\t\t\t * if it is missing. So instead of failing, skip\n\t\t\t * the record adding to avoid duplication. */\n\t\t\tgoto success;\n\t\t}\n\t}\n\n\tsdp_record_add(&req->device, rec);\n\tif (!(req->flags & SDP_RECORD_PERSIST))\n\t\tsdp_svcdb_set_collectable(rec, req->sock);\n\n\thandle = sdp_data_alloc(SDP_UINT32, &rec->handle);\n\tsdp_attr_replace(rec, SDP_ATTR_RECORD_HANDLE, handle);\n\nsuccess:\n\t/* if the browse group descriptor is NULL,\n\t * ensure that the record belongs to the ROOT group */\n\tif (sdp_data_get(rec, SDP_ATTR_BROWSE_GRP_LIST) == NULL) {\n\t\tuuid_t uuid;\n\t\tsdp_uuid16_create(&uuid, PUBLIC_BROWSE_GROUP);\n\t\tsdp_pattern_add_uuid(rec, &uuid);\n\t}\n\n\tupdate_db_timestamp();\n\tupdate_svclass_list(BDADDR_ANY);\n\n\t/* Build a rsp buffer */\n\tbt_put_unaligned(htonl(rec->handle), (uint32_t *) rsp->data);\n\trsp->data_size = sizeof(uint32_t);\n\n\treturn 0;\n\ninvalid:\n\tbt_put_unaligned(htons(SDP_INVALID_SYNTAX), (uint16_t *) rsp->data);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn -1;\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/**\n * Sets the string field_value to the  param \"field\" on the structure.\n * value is used to do the operation, it must be a uninitialized (zero-filled)\n * GValue, it will be left unitialized at the end of the function.\n */\n", "func_signal": "void gst_sbc_util_set_structure_string_param(GstStructure *structure,\n\t\t\tconst gchar *field, const gchar *field_value,\n\t\t\tGValue *value)", "code": "{\n\tvalue = g_value_init(value, G_TYPE_STRING);\n\tg_value_set_string(value, field_value);\n\tgst_structure_set_value(structure, field, value);\n\tg_value_unset(value);\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/* Bluetooth error codes to Unix errno mapping */\n", "func_signal": "int bt_error(uint16_t code)", "code": "{\n\tswitch (code) {\n\tcase 0:\n\t\treturn 0;\n\tcase HCI_UNKNOWN_COMMAND:\n\t\treturn EBADRQC;\n\tcase HCI_NO_CONNECTION:\n\t\treturn ENOTCONN;\n\tcase HCI_HARDWARE_FAILURE:\n\t\treturn EIO;\n\tcase HCI_PAGE_TIMEOUT:\n\t\treturn EHOSTDOWN;\n\tcase HCI_AUTHENTICATION_FAILURE:\n\t\treturn EACCES;\n\tcase HCI_PIN_OR_KEY_MISSING:\n\t\treturn EINVAL;\n\tcase HCI_MEMORY_FULL:\n\t\treturn ENOMEM;\n\tcase HCI_CONNECTION_TIMEOUT:\n\t\treturn ETIMEDOUT;\n\tcase HCI_MAX_NUMBER_OF_CONNECTIONS:\n\tcase HCI_MAX_NUMBER_OF_SCO_CONNECTIONS:\n\t\treturn EMLINK;\n\tcase HCI_ACL_CONNECTION_EXISTS:\n\t\treturn EALREADY;\n\tcase HCI_COMMAND_DISALLOWED:\n\tcase HCI_TRANSACTION_COLLISION:\n\tcase HCI_ROLE_SWITCH_PENDING:\n\t\treturn EBUSY;\n\tcase HCI_REJECTED_LIMITED_RESOURCES:\n\tcase HCI_REJECTED_PERSONAL:\n\tcase HCI_QOS_REJECTED:\n\t\treturn ECONNREFUSED;\n\tcase HCI_HOST_TIMEOUT:\n\t\treturn ETIMEDOUT;\n\tcase HCI_UNSUPPORTED_FEATURE:\n\tcase HCI_QOS_NOT_SUPPORTED:\n\tcase HCI_PAIRING_NOT_SUPPORTED:\n\tcase HCI_CLASSIFICATION_NOT_SUPPORTED:\n\tcase HCI_UNSUPPORTED_LMP_PARAMETER_VALUE:\n\tcase HCI_PARAMETER_OUT_OF_RANGE:\n\tcase HCI_QOS_UNACCEPTABLE_PARAMETER:\n\t\treturn EOPNOTSUPP;\n\tcase HCI_INVALID_PARAMETERS:\n\tcase HCI_SLOT_VIOLATION:\n\t\treturn EINVAL;\n\tcase HCI_OE_USER_ENDED_CONNECTION:\n\tcase HCI_OE_LOW_RESOURCES:\n\tcase HCI_OE_POWER_OFF:\n\t\treturn ECONNRESET;\n\tcase HCI_CONNECTION_TERMINATED:\n\t\treturn ECONNABORTED;\n\tcase HCI_REPEATED_ATTEMPTS:\n\t\treturn ELOOP;\n\tcase HCI_REJECTED_SECURITY:\n\tcase HCI_PAIRING_NOT_ALLOWED:\n\tcase HCI_INSUFFICIENT_SECURITY:\n\t\treturn EACCES;\n\tcase HCI_UNSUPPORTED_REMOTE_FEATURE:\n\t\treturn EPROTONOSUPPORT;\n\tcase HCI_SCO_OFFSET_REJECTED:\n\t\treturn ECONNREFUSED;\n\tcase HCI_UNKNOWN_LMP_PDU:\n\tcase HCI_INVALID_LMP_PARAMETERS:\n\tcase HCI_LMP_ERROR_TRANSACTION_COLLISION:\n\tcase HCI_LMP_PDU_NOT_ALLOWED:\n\tcase HCI_ENCRYPTION_MODE_NOT_ACCEPTED:\n\t\treturn EPROTO;\n\tdefault:\n\t\treturn ENOSYS;\n\t}\n}", "path": "lib\\bluetooth.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Selects one number of subbands from a list\n * TODO - use a better approach to this (it is selecting the last element)\n */\n", "func_signal": "gint gst_sbc_select_subbands_from_list(const GValue *value)", "code": "{\n\tguint size = gst_value_list_get_size(value);\n\treturn g_value_get_int(gst_value_list_get_value(value, size-1));\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/**\n * Sets the int field_value to the  param \"field\" on the structure.\n * value is used to do the operation, it must be a uninitialized (zero-filled)\n * GValue, it will be left unitialized at the end of the function.\n */\n", "func_signal": "void gst_sbc_util_set_structure_int_param(GstStructure *structure,\n\t\t\tconst gchar *field, gint field_value,\n\t\t\tGValue *value)", "code": "{\n\tvalue = g_value_init(value, G_TYPE_INT);\n\tg_value_set_int(value, field_value);\n\tgst_structure_set_value(structure, field, value);\n\tg_value_unset(value);\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Selects one mode from the ones on the list\n */\n", "func_signal": "const gchar *gst_sbc_get_mode_from_list(const GValue *list, gint channels)", "code": "{\n\tunsigned int i;\n\tconst GValue *value;\n\tconst gchar *aux;\n\tgboolean joint, stereo, dual, mono;\n\tguint size = gst_value_list_get_size(list);\n\n\tjoint = stereo = dual = mono = FALSE;\n\n\tfor (i = 0; i < size; i++) {\n\t\tvalue = gst_value_list_get_value(list, i);\n\t\taux = g_value_get_string(value);\n\t\tif (strcmp(\"joint\", aux) == 0)\n\t\t\tjoint = TRUE;\n\t\telse if (strcmp(\"stereo\", aux) == 0)\n\t\t\tstereo = TRUE;\n\t\telse if (strcmp(\"dual\", aux) == 0)\n\t\t\tdual = TRUE;\n\t\telse if (strcmp(\"mono\", aux) == 0)\n\t\t\tmono = TRUE;\n\t}\n\n\tif (channels == 1 && mono)\n\t\treturn \"mono\";\n\telse if (channels == 2) {\n\t\tif (joint)\n\t\t\treturn \"joint\";\n\t\telse if (stereo)\n\t\t\treturn \"stereo\";\n\t\telse if (dual)\n\t\t\treturn \"dual\";\n\t}\n\n\treturn NULL;\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Selects one number of blocks from a list of possible blocks\n * TODO - use a better approach to this (it is selecting the last element)\n */\n", "func_signal": "gint gst_sbc_select_blocks_from_list(const GValue *value)", "code": "{\n\tguint size = gst_value_list_get_size(value);\n\treturn g_value_get_int(gst_value_list_get_value(value, size-1));\n}", "path": "audio\\gstsbcutil.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/* FIXME: refactor for server-side */\n", "func_signal": "static sdp_record_t *extract_pdu_server(bdaddr_t *device, uint8_t *p,\n\t\t\t\t\tunsigned int bufsize,\n\t\t\t\t\tuint32_t handleExpected, int *scanned)", "code": "{\n\tint extractStatus = -1, localExtractedLength = 0;\n\tuint8_t dtd;\n\tint seqlen = 0;\n\tsdp_record_t *rec = NULL;\n\tuint16_t attrId, lookAheadAttrId;\n\tsdp_data_t *pAttr = NULL;\n\tuint32_t handle = 0xffffffff;\n\n\t*scanned = sdp_extract_seqtype(p, bufsize, &dtd, &seqlen);\n\tp += *scanned;\n\tbufsize -= *scanned;\n\n\tif (bufsize < sizeof(uint8_t) + sizeof(uint8_t)) {\n\t\tSDPDBG(\"Unexpected end of packet\");\n\t\treturn NULL;\n\t}\n\n\tlookAheadAttrId = ntohs(bt_get_unaligned((uint16_t *) (p + sizeof(uint8_t))));\n\n\tSDPDBG(\"Look ahead attr id : %d\", lookAheadAttrId);\n\n\tif (lookAheadAttrId == SDP_ATTR_RECORD_HANDLE) {\n\t\tif (bufsize < (sizeof(uint8_t) * 2) +\n\t\t\t\t\tsizeof(uint16_t) + sizeof(uint32_t)) {\n\t\t\tSDPDBG(\"Unexpected end of packet\");\n\t\t\treturn NULL;\n\t\t}\n\t\thandle = ntohl(bt_get_unaligned((uint32_t *) (p +\n\t\t\t\tsizeof(uint8_t) + sizeof(uint16_t) +\n\t\t\t\tsizeof(uint8_t))));\n\t\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\t\trec = sdp_record_find(handle);\n\t} else if (handleExpected != 0xffffffff)\n\t\trec = sdp_record_find(handleExpected);\n\n\tif (!rec) {\n\t\trec = sdp_record_alloc();\n\t\trec->attrlist = NULL;\n\t\tif (lookAheadAttrId == SDP_ATTR_RECORD_HANDLE) {\n\t\t\trec->handle = handle;\n\t\t\tsdp_record_add(device, rec);\n\t\t} else if (handleExpected != 0xffffffff) {\n\t\t\trec->handle = handleExpected;\n\t\t\tsdp_record_add(device, rec);\n\t\t}\n\t} else {\n\t\tsdp_list_free(rec->attrlist, (sdp_free_func_t) sdp_data_free);\n\t\trec->attrlist = NULL;\n\t}\n\n\twhile (localExtractedLength < seqlen) {\n\t\tint attrSize = sizeof(uint8_t);\n\t\tint attrValueLength = 0;\n\n\t\tif (bufsize < attrSize + sizeof(uint16_t)) {\n\t\t\tSDPDBG(\"Unexpected end of packet: Terminating extraction of attributes\");\n\t\t\tbreak;\n\t\t}\n\n\t\tSDPDBG(\"Extract PDU, sequenceLength: %d localExtractedLength: %d\",\n\t\t\t\t\t\t\tseqlen, localExtractedLength);\n\t\tdtd = *(uint8_t *) p;\n\n\t\tattrId = ntohs(bt_get_unaligned((uint16_t *) (p + attrSize)));\n\t\tattrSize += sizeof(uint16_t);\n\n\t\tSDPDBG(\"DTD of attrId : %d Attr id : 0x%x\", dtd, attrId);\n\n\t\tpAttr = sdp_extract_attr(p + attrSize, bufsize - attrSize,\n\t\t\t\t\t\t\t&attrValueLength, rec);\n\n\t\tSDPDBG(\"Attr id : 0x%x attrValueLength : %d\", attrId, attrValueLength);\n\n\t\tattrSize += attrValueLength;\n\t\tif (pAttr == NULL) {\n\t\t\tSDPDBG(\"Terminating extraction of attributes\");\n\t\t\tbreak;\n\t\t}\n\t\tlocalExtractedLength += attrSize;\n\t\tp += attrSize;\n\t\tbufsize -= attrSize;\n\t\tsdp_attr_replace(rec, attrId, pAttr);\n\t\textractStatus = 0;\n\t\tSDPDBG(\"Extract PDU, seqLength: %d localExtractedLength: %d\",\n\t\t\t\t\tseqlen, localExtractedLength);\n\t}\n\n\tif (extractStatus == 0) {\n\t\tSDPDBG(\"Successful extracting of Svc Rec attributes\");\n#ifdef SDP_DEBUG\n\t\tsdp_print_service_attr(rec->attrlist);\n#endif\n\t\t*scanned += seqlen;\n\t}\n\treturn rec;\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * The service database state is an attribute of the service record\n * of the SDP server itself. This attribute is guaranteed to\n * change if any of the contents of the service repository\n * changes. This function updates the timestamp of value of\n * the svcDBState attribute\n * Set the SDP server DB. Simply a timestamp which is the marker\n * when the DB was modified.\n */\n", "func_signal": "static void update_db_timestamp(void)", "code": "{\n\tuint32_t dbts = sdp_get_time();\n\tsdp_data_t *d = sdp_data_alloc(SDP_UINT32, &dbts);\n\tsdp_attr_replace(server, SDP_ATTR_SVCDB_STATE, d);\n}", "path": "src\\sdpd-service.c", "repo_name": "writefaruq/bluez-oob", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 5904}
{"docstring": "/*\n * Unfold current list of darts\n */\n", "func_signal": "static GSList*\ncartwheel_unfold(GSList* cartwheel, double edge)", "code": "{\n\tGSList *newcartwheel=NULL;\n\tstruct kite *kite;\n\n\twhile(cartwheel != NULL) {\n\t\tkite= (struct kite*)cartwheel->data;\n\t\tswitch(kite->type) {\n\t\tcase KITE:\n\t\t\tnewcartwheel= cartwheel_unfold_kite(newcartwheel, kite);\n\t\t\tbreak;\n\t\tcase DART:\n\t\t\tnewcartwheel= cartwheel_unfold_dart(newcartwheel, kite);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_debug(\"cartwheel_unfold: unknown kite type: %d\", kite->type);\n\t\t}\n\t\tg_free(kite);\n\t\tcartwheel= g_slist_delete_link(cartwheel, cartwheel);\n\t}\n\n\t/* get rid of repeated kites */\n\tseparate_distance= ((struct kite*)newcartwheel->data)->side/10.;\n\tseparate_distance*= separate_distance;\n\tnewcartwheel= trim_repeated_kites(newcartwheel);\n\n\t/* get rid of kites outside a certain radius */\n\tif (edge > 0)\n\t\tnewcartwheel= trim_outside_kites(newcartwheel, edge);\n\n\t/* debug: count number of kites in list */\n\tg_debug(\"kites in list: %d\", g_slist_length(newcartwheel));\n\n\treturn newcartwheel;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Build tri-hexagonal tile skeleton (no connections)\n */\n", "func_signal": "struct geometry*\nbuild_trihex_tile_skeleton(const struct gameinfo *info)", "code": "{\n\tstruct geometry *geo;\n\tint i, j;\n\tint dimx, dimy;\n\tdouble side;\n\tdouble xshift, yshift;\n\tdouble xoffset;\n\tint ntiles;\n\tint nvertex;\n\tint nlines;\n\tdouble x0;\n\tdouble y0;\n\tstruct point pos;\n\tconst int geo_params[5][3]= {\t/* num of tiles, vertex, lines for all sizes */\n\t\t{ 46,  42,  87},\n\t\t{ 96,  79, 174},\n\t\t{183, 143, 325},\n\t\t{277, 208, 484},\n\t\t{465, 338, 802}\n\t};\n\tint neighbor=0;\n\n\t/* size parameter determines number of symmetry units */\n\tg_assert(info->size >= 0 && info->size < 5);\n\tdimx= info->size + 2;\n\tdimy= dimx;\n\tif (info->size == 4) ++dimy;\n\n\t/* num of sides wide: info->size*(1 + sqrt(3)) + 1 */\n\tside= TRIHEX_GAME_SIZE/(dimx*(1.0 + sqrt(3.0)) + 1.0);\n\t/* num of sides tall: info->size*(sqrt(3)/2 + 1 + 1/2) + sqrt(3)/2 + 1/2 */\n\t/* NOTE: shameless reuse of variable yshift */\n\tyshift= TRIHEX_GAME_SIZE/(dimy*(sqrt(3.0) + 3.0)/2.0 + (sqrt(3.0) + 1.0)/2.0);\n\t/* choose xfit or yfit (see which produces smaller side -> more limiting) */\n\tif (yshift < side) side= yshift;\n\n\txshift= side*sqrt(3.0) + side;\n\tyshift= side*(sqrt(3.0) + 1.0)/2.0 + side;\n\n\t/* coordinates of unit on top left (center of unit coords) */\n\tx0= (dimx*(1.0 + sqrt(3.0)) + 1.0)*side;\n\tx0= (TRIHEX_BOARD_SIZE - x0)/2.0 + side*(1.0 + sqrt(3.0)/2.0);\n\ty0= (dimy*(3.0 + sqrt(3.0))/2.0 + (sqrt(3.0) + 1.0)/2.0)*side;\n\ty0= (TRIHEX_BOARD_SIZE - y0)/2.0 + (sqrt(3.0)/2.0 + 1.0)*side;\n\n\t/* create geometry with plenty of space for lines and vertex */\n\tntiles= geo_params[info->size][0];\n\tnvertex= geo_params[info->size][1];\n\tnlines= geo_params[info->size][2];\n\tgeo= geometry_create_new(ntiles, nvertex, nlines, 5);\n\tgeo->board_size= TRIHEX_BOARD_SIZE;\n\tgeo->board_margin= TRIHEX_BOARD_MARGIN;\n\tgeo->game_size= TRIHEX_BOARD_SIZE - 2*TRIHEX_BOARD_MARGIN;\n\tgeometry_set_distance_resolution(side/10.0);\n\n\t/* create units */\n\tgeo->ntiles= 0;\n\tgeo->nlines= 0;\n\tgeo->nvertex= 0;\n\tfor(j=0; j < dimy; ++j) {\n\t\tpos.y= y0 + j*yshift;\n\t\txoffset= ((j+1) % 2) * xshift/2.0;\n\t\tif (j > 0) neighbor= NEIGHBOR_NE;\n\t\tfor(i=0; i < dimx; ++i) {\n\t\t\tif (i == dimx - 1 && (j%2) == 0) break;\n\t\t\tif (j > 0) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tif ((j%2) == 0) neighbor|= NEIGHBOR_NW;\n\t\t\t\t} else {\n\t\t\t\t\tif ((j%2) == 1) neighbor|= NEIGHBOR_NW;\n\t\t\t\t}\n\t\t\t\tif (i == dimx - 1 && ((j%2) == 1)) neighbor&= ~(NEIGHBOR_NE);\n\t\t\t}\n\t\t\tif (i > 0) neighbor|= NEIGHBOR_W;\n\t\t\tpos.x= x0 + xoffset + i * xshift;\n\t\t\ttrihex_symmetry_unit(geo, &pos, side, neighbor);\n\t\t}\n\t}\n\n\t/* make sure we didn't underestimate max numbers */\n\tg_assert(geo->ntiles == ntiles);\n\tg_assert(geo->nvertex == nvertex);\n\tg_assert(geo->nlines == nlines);\n\n\treturn geo;\n}", "path": "src\\trihex-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Build tri-hexagonal tile geometry data\n */\n", "func_signal": "struct geometry*\nbuild_trihex_tile_geometry(const struct gameinfo *info)", "code": "{\n\tstruct geometry *geo;\n\n\t/* build geometry skeleton (no connections) */\n\tgeo= build_trihex_tile_skeleton(info);\n\n\t/* build inter-connections */\n\tgeometry_connect_skeleton(geo);\n\n\t/* define sizes of drawing bits */\n\ttrihex_calculate_sizes(geo, info->size);\n\n\treturn geo;\n}", "path": "src\\trihex-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Clean up things just before exiting\n */\n", "func_signal": "static void\nfences_exit_cleanup(struct board *board)", "code": "{\n\tgamedata_destroy_current_game(board);\n\tg_free(board->history);\n}", "path": "src\\main.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Eliminate kites outside a certain radius\n * Returns new trimmed list\n */\n", "func_signal": "static GSList *\ntrim_outside_kites(GSList *cartwheel, double radius)", "code": "{\n\tGSList *current;\n\tGSList *next;\n\tstruct kite *kite;\n\tstruct point vertex[4];\n\tdouble dist;\n\tint i;\n\tdouble center=CARTWHEEL_BOARD_SIZE/2.;\n\n\tcurrent= cartwheel;\n\twhile(current != NULL) {\n\t\tkite= (struct kite*) current->data;\n\n\t\tget_kite_vertices(kite, vertex);\n\t\tnext= g_slist_next(current);\n\t\tfor(i=0; i < 4; ++i) {\n\t\t\tvertex[i].x-= center;\n\t\t\tvertex[i].y-= center;\n\t\t\tdist= sqrt(vertex[i].x*vertex[i].x + vertex[i].y*vertex[i].y);\n\t\t\tif (dist > radius) {\n\t\t\t\tg_free(current->data);\n\t\t\t\tcartwheel= g_slist_delete_link(cartwheel, current);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcurrent= next;\n\t}\n\treturn cartwheel;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Return coordinates of vertices of kite\n */\n", "func_signal": "static void\nget_kite_vertices(struct kite *kite, struct point *vertex)", "code": "{\n\tdouble length;\n\n\tvertex[0].x= kite->pos.x;\n\tvertex[0].y= kite->pos.y;\n\tvertex[1].x= kite->pos.x + kite->side*cos(kite->angle - D2R(36));\n\tvertex[1].y= kite->pos.y + kite->side*sin(kite->angle - D2R(36));\n\tvertex[3].x= kite->pos.x + kite->side*cos(kite->angle + D2R(36));\n\tvertex[3].y= kite->pos.y + kite->side*sin(kite->angle + D2R(36));\n\tif (kite->type == KITE) {\n\t\tlength= kite->side*cos(D2R(36)) + kite->side/RATIO*sin(D2R(18));\n\t} else {\t\t// DART\n\t\tlength= kite->side*cos(D2R(36)) - kite->side/RATIO*sin(D2R(18));\n\t}\n\tvertex[2].x= kite->pos.x + length * cos(kite->angle);\n\tvertex[2].y= kite->pos.y + length * sin(kite->angle);\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Unfold a dart\n * Add new kites &darts to list newcartwheel and return it\n */\n", "func_signal": "static GSList*\ncartwheel_unfold_dart(GSList *newcartwheel, struct kite *dart)", "code": "{\n\tstruct kite *nkite;\n\tdouble nside=dart->side/RATIO;\n\tdouble middle=nside*cos(D2R(36));\n\n\tg_assert(dart->type == DART);\n\n\t/* create new kite 1/5 (at tip) */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= dart->pos.x;\n\tnkite->pos.y= dart->pos.y;\n\tnkite->side= nside;\n\tnkite->angle= dart->angle;\n\t//WRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* create new kite 2/5 (at tip) */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= dart->pos.x;\n\tnkite->pos.y= dart->pos.y;\n\tnkite->side= nside;\n\tnkite->angle= dart->angle - D2R(72);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* create new kite 3/5 (at tip) */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= dart->pos.x;\n\tnkite->pos.y= dart->pos.y;\n\tnkite->side= nside;\n\tnkite->angle= dart->angle + D2R(72);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next dart 4/5 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= DART;\n\tnkite->pos.x= dart->pos.x + dart->side * cos(dart->angle - D2R(36));\n\tnkite->pos.y= dart->pos.y + dart->side * sin(dart->angle - D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= dart->angle + D2R(90 + (90 - 36));\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle/2.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle/2.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next dart 5/5 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= DART;\n\tnkite->pos.x= dart->pos.x + dart->side * cos(dart->angle + D2R(36));\n\tnkite->pos.y= dart->pos.y + dart->side * sin(dart->angle + D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= dart->angle - D2R(90 + (90 - 36));\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle/2.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle/2.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\treturn newcartwheel;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n *\n */\n", "func_signal": "int\nmain (int argc, char *argv[])", "code": "{\n\tGtkWidget *window;\n\tstruct board *board;\n\n\n#ifdef ENABLE_NLS\n\tbindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);\n\tbind_textdomain_codeset (GETTEXT_PACKAGE, \"UTF-8\");\n\ttextdomain (GETTEXT_PACKAGE);\n#endif\n\n\t/* Initialize thread stuff to make gtk thread-aware */\n\tif (!g_thread_supported()) g_thread_init(NULL);\n\tgdk_threads_init();\n\t/* gtk_main must be between gdk_threads_enter and gdk_threads_leave */\n\tgdk_threads_enter();\n\n\t/* Init board */\n\tboard= initialize_board();\n\n\tgtk_set_locale ();\n\tgtk_init (&argc, &argv);\n\n\t/* create main window */\n\twindow= gui_setup_main_window(XML_FILE, board);\n\tgtk_widget_show (window);\n\n\t/* initialize gui */\n\tgui_initialize(board);\n\n\t/* start draw thread */\n\t//start_draw_thread(g_object_get_data(G_OBJECT(window), \"drawarea\"));\n\n\tgtk_main ();\n\tgdk_threads_leave();\n\n\t/* clean up */\n\tfences_exit_cleanup(board);\n\n\treturn 0;\n}", "path": "src\\main.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Build a cartwheel tile skeleton by unfolding kites and darts\n */\n", "func_signal": "struct geometry*\nbuild_cartwheel_tile_skeleton(const struct gameinfo *info)", "code": "{\n\tGSList *cartwheel=NULL;\n\tstruct geometry *geo;\n\tint i;\n\tdouble edge;\n\tint size_index=info->size;\n\tstruct puzzle_params params;\n\n\t/* get side size and number of folds */\n\tcartwheel_calculate_params(size_index, &params);\n\n\t/* Create the seed (increase size to account for foldings) */\n\tcartwheel= create_tile_seed(&params, size_index);\n\n\t/* unfold list of shapes */\n\tfor(i=0; i < params.nfolds; ++i) {\n\t\tif (i == params.nfolds - 1) edge= CARTWHEEL_GAME_SIZE/2.0;\n\t\telse if (i > 1 && i == params.nfolds - 2) edge= CARTWHEEL_GAME_SIZE/1.5;\n\t\telse edge= CARTWHEEL_GAME_SIZE;\n\t\tcartwheel= cartwheel_unfold(cartwheel, edge);\n\t}\n\n\t/* draw to file */\n\t//draw_cartwheel_tile(cartwheel);\n\n\t/* transform tile into geometry data (points, lines & tiles) */\n\tgeo= cartwheel_tile_to_skeleton(cartwheel, params.side);\n\n\t/* free dart and kites data */\n\twhile (cartwheel != NULL) {\n\t\tg_free(cartwheel->data);\n\t\tcartwheel= g_slist_delete_link(cartwheel, cartwheel);\n\t}\n\n\treturn geo;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Define seed to generate cartwheel tile\n * Input 'side' is size of initial kites and darts size\n */\n", "func_signal": "static GSList*\ncreate_tile_seed(struct puzzle_params *params, int size_index)", "code": "{\n\tGSList *cartwheel=NULL;\n\tstruct kite *kite;\n\tstruct point pos;\n\tint i;\n\n\tpos.x= params->pos.x;\n\tpos.y= params->pos.y;\n\n\tswitch (size_index) {\n\tcase 0:\n\t\tcartwheel= create_arrow_seed(&pos, 0.0, params->seed_side);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tfor(i=0; i < 5; ++i) {\n\t\t\tkite= (struct kite*)g_malloc(sizeof(struct kite));\n\t\t\tkite->type= params->seed_type;\n\t\t\tkite->side= params->seed_side;\n\t\t\tkite->angle= D2R(i*72-90);\n\t\t\tkite->pos.x= pos.x;\n\t\t\tkite->pos.y= pos.y;\n\t\t\tcartwheel= g_slist_prepend(cartwheel, kite);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tg_message(\"(create_tile_seed) unknown size_index %d\", size_index);\n\t}\n\n\treturn cartwheel;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Deallocate click mesh structure\n */\n", "func_signal": "void\nclick_mesh_destroy(struct click_mesh *click_mesh)", "code": "{\n\tint i;\n\n\tfor(i=0; i < click_mesh->ntiles; ++i) {\n\t\t/* free list of lines for tile i */\n\t\tg_slist_free(click_mesh->tiles[i]);\n\t}\n\tg_free(click_mesh->tiles);\n\tg_free(click_mesh);\n}", "path": "src\\click-mesh.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Unfold a kite\n * Add new kites & darts to list newcartwheel and return it\n */\n", "func_signal": "static GSList*\ncartwheel_unfold_kite(GSList *newcartwheel, struct kite *kite)", "code": "{\n\tstruct kite *nkite;\n\tdouble nside=kite->side/RATIO;\n\tdouble middle=nside*cos(D2R(36));\n\n\tg_assert(kite->type == KITE);\n\n\t/* create new dart 1/6 (at tip) */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= DART;\n\tnkite->pos.x= kite->pos.x;\n\tnkite->pos.y= kite->pos.y;\n\tnkite->side= nside;\n\tnkite->angle= kite->angle - D2R(36);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle/2.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle/2.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next dart kite 2/6 (at tip) */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= DART;\n\tnkite->pos.x= kite->pos.x;\n\tnkite->pos.y= kite->pos.y;\n\tnkite->side= nside;\n\tnkite->angle= kite->angle + D2R(36);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle/2.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle/2.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next kite (top) 3/6 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= kite->pos.x + kite->side * cos(kite->angle - D2R(36));\n\tnkite->pos.y= kite->pos.y + kite->side * sin(kite->angle - D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= kite->angle + D2R(90 + (90 - 72));\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next kite (top) 4/6 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= kite->pos.x + kite->side * cos(kite->angle - D2R(36));\n\tnkite->pos.y= kite->pos.y + kite->side * sin(kite->angle - D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= kite->angle + D2R(180);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next kite (bottom) 5/6 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= kite->pos.x + kite->side * cos(kite->angle + D2R(36));\n\tnkite->pos.y= kite->pos.y + kite->side * sin(kite->angle + D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= kite->angle - D2R(90 + (90 - 72));\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\t/* next kite (bottom) 6/6 */\n\tnkite= (struct kite *)g_malloc(sizeof(struct kite));\n\tnkite->type= KITE;\n\tnkite->pos.x= kite->pos.x + kite->side * cos(kite->angle + D2R(36));\n\tnkite->pos.y= kite->pos.y + kite->side * sin(kite->angle + D2R(36));\n\tnkite->side= nside;\n\tnkite->angle= kite->angle - D2R(180);\n\tWRAP(nkite->angle);\n\tnkite->center.x= nkite->pos.x + middle*3.0/4.0 * cos(nkite->angle);\n\tnkite->center.y= nkite->pos.y + middle*3.0/4.0 * sin(nkite->angle);\n\tnewcartwheel= g_slist_prepend(newcartwheel, nkite);\n\n\treturn newcartwheel;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Initialize click mesh (list of lines in each mesh tile):\n * The board is divided in NxN squares\n * on the game board\n */\n", "func_signal": "struct click_mesh*\nclick_mesh_setup(const struct geometry *geo)", "code": "{\n\tint l, b;\n\tstruct line *lin;\n\tstruct point edge[2];\n\tgboolean inside;\n\tstruct click_mesh *click_mesh;\n\tGSList **tiles;\n\n\t/* new click_mesh */\n\tclick_mesh= (struct click_mesh*)g_malloc(sizeof(struct click_mesh));\n\tclick_mesh->ntiles_side= WIDTH_MESH;\n\tclick_mesh->ntiles= click_mesh->ntiles_side * click_mesh->ntiles_side;\n\tclick_mesh->tile_size= geo->board_size / click_mesh->ntiles_side;\n\n\t/* Initialize line status vector */\n\ttiles= (GSList **) g_malloc0(click_mesh->ntiles * sizeof(GSList *));\n\t// **TODO** handle mem error\n\tclick_mesh->tiles= tiles;\n\n\t/* Iterate through the mesh: build list of lines in each tile */\n\tfor(b=0; b < SIZE_MESH; ++b) {\n\t\tedge[0].x= (b % click_mesh->ntiles_side) * click_mesh->tile_size;\n\t\tedge[0].y= (b / click_mesh->ntiles_side) * click_mesh->tile_size;\n\t\tedge[1].x= edge[0].x + click_mesh->tile_size;\n\t\tedge[1].y= edge[0].y + click_mesh->tile_size;\n\t\tlin= geo->lines;\n\t\tfor(l=0; l < geo->nlines; ++l) {\n\t\t\t/* check if line's area of influence intersects the box */\n\t\t\tinside= is_area_inside_box(lin->inf, edge);\n\t\t\tif (inside) {\n\t\t\t\t//printf(\"box %d (%lf,%lf;%lf,%lf): add line %d  (%lf,%lf)\\n\", b,\n\t\t\t\t//\t   edge[0].x,edge[0].y, edge[1].x, edge[1].y, l,\n\t\t\t\t//\t   lin->ends[0]->pos.x, lin->ends[0]->pos.y);\n\t\t\t\ttiles[b]= g_slist_prepend(tiles[b], lin);\n\t\t\t}\n\t\t\t++lin;\n\t\t}\n\t}\n\treturn click_mesh;\n}", "path": "src\\click-mesh.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Compute side and number of folds to produce a cartwheel\n * of the requested size index\n * Returns: number of folds\n *  side size is passed by pointer in '*side'\n */\n", "func_signal": "static void\ncartwheel_calculate_params(int size_index, struct puzzle_params *params)", "code": "{\n\t/*\n\t * radius of cartwheel tiling must be game_size/2\n\t *  game_size/2 = side * Factor\n\t * Factor is number of sides that fit in radius.\n\t *   Both kite & dart have 2 LONG and 2 SHORT sides\n\t *      LONG= 1   ;  SHORT= 1.0/RATIO\n\t *   Height of dart is == SHORT\n\t *   Heigth of kite is == LONG\n\t */\n\tparams->side= CARTWHEEL_GAME_SIZE/2.0;\n\tparams->pos.x= CARTWHEEL_BOARD_SIZE/2.;\n\tparams->pos.y= CARTWHEEL_BOARD_SIZE/2.;\n\tparams->seed_type= KITE;\t// only useful for some sizes\n\tswitch(size_index) {\n\tcase 0:\t\t/* small */\n\t\tparams->nfolds= 2;\n\t\tparams->side/= (4 + 2.0/RATIO)/2.0;\n\t\tparams->pos.x-= params->side*pow(RATIO, params->nfolds);\n\t\tbreak;\n\tcase 1:\t\t/* medium */\n\t\tparams->nfolds= 3;\n\t\tparams->side/= 2.0 + 2.0/RATIO;\n\t\tparams->seed_type= KITE;\n\t\t//params->pos.x+= 2.5*params->side;\n\t\t//params->pos.y-= params->side*13.0/16.0;\n\t\tbreak;\n\tcase 2:\t\t/* normal */\n\t\tparams->nfolds= 3;\n\t\tparams->side/= 3.0 + 2.0/RATIO;\n\t\tparams->seed_type= DART;\n\t\tbreak;\n\tcase 3:\t\t/* large */\n\t\tparams->nfolds= 4;\n\t\tparams->side/= 4.0 + 3.0/RATIO + 1.0/RATIO/2.0;\n\t\tparams->seed_type= DART;\n\t\tbreak;\n\tcase 4:\t\t/* huge */\n\t\tparams->nfolds= 4;\n\t\tparams->side/= 6.0 + 5.0/RATIO + 1.0/RATIO/2.0;\n\t\tparams->seed_type= KITE;\n\t\tbreak;\n\tdefault:\n\t\tg_message(\"(cartwheel_calculate_params) unknown cartwheel size: %d\", size_index);\n\t}\n\t/* calculate side of big seed */\n\tparams->seed_side= params->side*pow(RATIO, params->nfolds);\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Build a cartwheel tiling by unfolding kites and darts\n */\n", "func_signal": "struct geometry*\nbuild_cartwheel_tile_geometry(const struct gameinfo *info)", "code": "{\n\tstruct geometry *geo;\n\n\t/* build geometry skeleton (no connections) */\n\tgeo= build_cartwheel_tile_skeleton(info);\n\n\t/* finalize geometry data: tie everything together */\n\tgeometry_connect_skeleton(geo);\n\n\t/* define sizes of drawing bits */\n\tcartwheel_calculate_sizes(geo, info->size);\n\n\treturn geo;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Calculate sizes of drawing details\n */\n", "func_signal": "static void\ntrihex_calculate_sizes(struct geometry *geo, int dim)", "code": "{\n\tgeo->on_line_width= geo->game_size/(5.0 + dim*3.0)/15.0;\n\tgeo->off_line_width= geo->board_size/1000.;\n\tif (geo->on_line_width < 2*geo->off_line_width)\n\t\tgeo->on_line_width= 2*geo->off_line_width;\n\tgeo->cross_line_width= geo->off_line_width*2;\n\tgeo->cross_radius= geo->tile_width/10.0;\n\tgeo->font_scale= 0.8;\n}", "path": "src\\trihex-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Draw 12 sided round structure that repeats to form tile board\n */\n", "func_signal": "static void\ntrihex_symmetry_unit(struct geometry *geo, struct point *pos, double side,\n\t\t\t\t\t int neighbor)", "code": "{\n\tstruct point pts[4];\n\tdouble half_side;\n\tdouble height;\n\tdouble angle;\n\tdouble angle30;\n\tint i;\n\tint ringmask;\t\t/* mask with ring shapes to draw */\n\n\t/* set mask of ring shapes that are allowed to be drawn (according to neighbor).\n\t   First shape is right square and we go clockwise. */\n\tringmask= ~0;\n\tif (neighbor & NEIGHBOR_W) ringmask&= ~(0x00E0); // 0000 1110 0000\n\tif (neighbor & NEIGHBOR_NW) ringmask&= ~(0x0380);\t// 0011 1000 0000\n\tif (neighbor & NEIGHBOR_NE) ringmask&= ~(0x0E00);\t// 1110 0000 0000\n\n\t/* pos is central point of 12 sided structure */\n\theight= side * sqrt(3.0)/2.0;\n\thalf_side= side / 2.0;\n\tangle30= 30 * (M_PI/180.0);\n\n\t/* internal \"trivial pursuit\" pie region (inner triangles) */\n\tpts[0].x= pos->x;\n\tpts[0].y= pos->y;\n\tfor(i=0; i < 6; ++i) {\n\t\tangle= i * D2R(60);\n\t\tpts[1].x= pos->x + side*cos(angle - D2R(30));\n\t\tpts[1].y= pos->y + side*sin(angle - D2R(30));\n\t\tpts[2].x= pos->x + side*cos(angle + D2R(30));\n\t\tpts[2].y= pos->y + side*sin(angle + D2R(30));\n\t\tgeometry_add_tile(geo, pts, 3, NULL);\n\t}\n\n\t/* Outer ring of alternating squares and triangles */\n\t/* We need to pay attention to elements that may overlap with previously\n\t   drawn ones. We use ringmask to decide what we draw. */\n\tfor(i=0; i < 6; ++i) {\n\t\tangle= D2R(i * 60);\n\t\t/* square */\n\t\tif (ringmask & 1) {\n\t\t\tpts[0].x= pos->x + side*cos(angle + angle30);\n\t\t\tpts[0].y= pos->y + side*sin(angle + angle30);\n\t\t\tpts[1].x= pts[0].x + side*cos(angle - D2R(90));\n\t\t\tpts[1].y= pts[0].y + side*sin(angle - D2R(90));\n\t\t\tpts[2].x= pts[0].x + side*sqrt(2.0)*cos(angle - D2R(45));\n\t\t\tpts[2].y= pts[0].y + side*sqrt(2.0)*sin(angle - D2R(45));\n\t\t\tpts[3].x= pts[0].x + side*cos(angle);\n\t\t\tpts[3].y= pts[0].y + side*sin(angle);\n\t\t\tgeometry_add_tile(geo, pts, 4, NULL);\n\t\t}\n\t\t/* triangle */\n\t\tif (ringmask & 2) {\n\t\t\t/* pts[0]= square's pts[0] */\n\t\t\tpts[1].x= pts[0].x + side*cos(angle);\n\t\t\tpts[1].y= pts[0].y + side*sin(angle);\n\t\t\tpts[2].x= pts[0].x + side*cos(angle + D2R(60));\n\t\t\tpts[2].y= pts[0].y + side*sin(angle + D2R(60));\n\t\t\tgeometry_add_tile(geo, pts, 3, NULL);\n\t\t}\n\t\tringmask>>= 2;\n\t}\n}", "path": "src\\trihex-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Calculate sizes of drawing details\n */\n", "func_signal": "static void\ncartwheel_calculate_sizes(struct geometry *geo, int size_index)", "code": "{\n\tgeo->on_line_width= geo->board_size/(5.0 + size_index*3.0)/15.0;\n\tgeo->off_line_width= geo->board_size/1000.;\n\tif (geo->on_line_width < 2*geo->off_line_width)\n\t\tgeo->on_line_width= 2*geo->off_line_width;\n\tgeo->cross_line_width= geo->off_line_width*1.5;\n\tgeo->cross_radius= MIN(geo->tile_width, geo->tile_height)/10.;\n\tgeo->font_scale= 0.8;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Transform list of darts to geometry data\n */\n", "func_signal": "static struct geometry*\ncartwheel_tile_to_skeleton(GSList *cartwheel, double side)", "code": "{\n\tstruct geometry *geo;\n\tGSList *list;\n\tstruct point pts[4];\n\tint i;\n\tint ntiles;\n\tint nvertex;\n\tint nlines;\n\tstruct kite *kite;\n\n\t/* create new geometry (ntiles, nvertex, nlines) */\n\t/* NOTE: oversize nvertex and nlines. Will adjust below\n\t   Oversize factors determined by trial and error. */\n\tntiles= g_slist_length(cartwheel);\n\tnvertex= ntiles*4;//(int)(ntiles*1.5);\n\tnlines= ntiles*4;//(int)(ntiles*2.5);\n\tgeo= geometry_create_new(ntiles, nvertex, nlines, 4);\n\tgeo->board_size= CARTWHEEL_BOARD_SIZE;\n\tgeo->board_margin= CARTWHEEL_BOARD_MARGIN;\n\tgeo->game_size= geo->board_size - 2*geo->board_margin;\n\tgeometry_set_distance_resolution(side/10.0);\n\n\n\t/* iterate through tiles creating skeleton geometry\n\t   (skeleton geometry: lines hold all the topology info) */\n\tgeo->ntiles= 0;\n\tgeo->nlines= 0;\n\tgeo->nvertex= 0;\n\tlist= cartwheel;\n\tfor(i=0; i < ntiles; ++i) {\n\t\t/* get vertices of tile (rhomb) and add it to skeleton geometry */\n\t\tkite= (struct kite*)list->data;\n\t\tget_kite_vertices((struct kite*)list->data, pts);\n\t\tgeometry_add_tile(geo, pts, 4, &kite->center);\n\n\t\tlist= g_slist_next(list);\n\t}\n\n\t/* make sure we didn't underestimate max numbers */\n\tg_assert(geo->ntiles <= ntiles);\n\tg_assert(geo->nvertex <= nvertex);\n\tg_assert(geo->nlines <= nlines);\n\n\t/* realloc to actual number of vertices and lines */\n\tgeo->vertex= g_realloc(geo->vertex, geo->nvertex*sizeof(struct vertex));\n\tgeo->lines= g_realloc(geo->lines, geo->nlines*sizeof(struct line));\n\n\t/*printf(\"ntiles: %d (%d) %d\\n\", geo->ntiles, ntiles);\n\tprintf(\"nvertex: %d (%d) %d\\n\", geo->nvertex, nvertex);\n\tprintf(\"nlines: %d (%d) %d\\n\", geo->nlines, nlines);*/\n\n\treturn geo;\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Draw tile to png file (for debug purposes only)\n */\n", "func_signal": "static void\ndraw_cartwheel_tile(GSList *cartwheel)", "code": "{\n\tconst char filename[]=\"cartwheel.png\";\n\tconst int width=500;\n\tconst int height=500;\n\tcairo_surface_t *surf;\n\tcairo_t *cr;\n\tstruct kite *kite;\n\tstruct point pts[4];\n\tint i;\n\n\tsurf= cairo_image_surface_create(CAIRO_FORMAT_RGB24, width, height);\n\tcr= cairo_create(surf);\n\n\tcairo_set_source_rgb(cr, 1, 1, 1);\n\tcairo_paint(cr);\n\tcairo_scale (cr, width/(double)CARTWHEEL_BOARD_SIZE,\n\t\t     height/(double)CARTWHEEL_BOARD_SIZE);\n\tcairo_set_line_width (cr, 1/500.0*CARTWHEEL_BOARD_SIZE);\n\tcairo_set_source_rgb(cr, 0, 0, 0);\n\n\twhile(cartwheel != NULL) {\n\t\tkite= (struct kite*)cartwheel->data;\n\t\tget_kite_vertices(kite, pts);\n\t\tcairo_move_to(cr, pts[0].x, pts[0].y);\n\t\tfor(i= 1; i < 4 ; ++i) {\n\t\t\tcairo_line_to(cr, pts[i].x, pts[i].y);\n\t\t}\n\t\tcairo_line_to(cr, pts[0].x, pts[0].y);\n\t\tcairo_stroke(cr);\n\t\tcartwheel= g_slist_next(cartwheel);\n\t}\n\n\tcairo_destroy(cr);\n\t/* write png file */\n\tif (cairo_surface_write_to_png(surf, filename) != 0) {\n\t\tg_debug(\"draw_cartwheel_tile: error on write to png\");\n\t}\n\tprintf(\"File %s saved to disk.\\n\", filename);\n\n}", "path": "src\\cartwheel-tile.c", "repo_name": "jmarino/fences", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 556}
{"docstring": "/*\n * Get the maximum value\n */\n", "func_signal": "double max(double a, double b)", "code": "{\n\tif (a > b)\n\t\treturn a;\n\treturn b;\n}", "path": "experiments\\adaptatived\\util.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Update percentual\n * */\n", "func_signal": "void update_percentual_trained(void)", "code": "{\n\treset_percentual();\n\tcalculate_trained_percentual();\n\tupdate_percentualbox();\n\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Filter function used by scandir() function in get_procs() function\n */\n", "func_signal": "int filter(const struct dirent * entry)", "code": "{\n\tif ((*entry->d_name > '0') && (*entry->d_name <= '9'))\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "experiments\\adaptatived\\util.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Get the list of pids and command name\n * Return the size of list\n */\n", "func_signal": "int get_procs(struct proc *** list)", "code": "{\n\tstruct proc ** proclist;\n\tstruct dirent ** namelist;\n\tint i, n;\n\tchar filename[25];\n\tFILE * fp;\n\tssize_t bytes_read;\n\tsize_t len = 0;\n\tchar * line = NULL;\n\n\tn = scandir(\"/proc\", &namelist, filter, versionsort);\n\n\tproclist = malloc(n * sizeof(struct proc));\t\t\n\n\tif (n < 0) {\n\t\tfprintf(stderr, \"error scanning /proc: %s\\n\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\telse {\n\t\tfor(i=0; i<n; i++) {\n\t\t\tproclist[i] = (struct proc *)malloc(sizeof(struct proc));\n\t\t\tsscanf(namelist[i]->d_name, \"%u\", &proclist[i]->pid);\n\t\t\tfree(namelist[i]);\n\n\t\t\tsnprintf(filename,\n\t\t\t\t\tsizeof(filename),\n\t\t\t\t\t\"/proc/%d/status\",\n\t\t\t\t\tproclist[i]->pid);\n\n\t\t\tfp = fopen(filename, \"r\");\n\n\t\t\tif (fp == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"error opening file %s: %s\\n\",\n\t\t\t\t\t\tfilename, strerror(errno));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tbytes_read = getline(&line, &len, fp);\n\n\t\t\tif (bytes_read != -1)\n\t\t\t\tsscanf(line, \"Name: %s\", proclist[i]->cmd);\n\n\t\t\tif (fclose(fp)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"error closing file %s: %s\\n\",\n\t\t\t\t\t\tfilename, strerror(errno));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t\tfree(namelist);\n\t}\n\n\t*list = proclist;\n\treturn i;\n}", "path": "experiments\\adaptatived\\util.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n *  * Reset the gtk table\n *   */\n", "func_signal": "void reset_gtk_table(GtkWidget * table,\n\t\tGtkWidget * box)", "code": "{\n\tint i, j;\n\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\tcolor.red = (int)(grids[i][j]->weights[0] * 65535);\n\t\t\tcolor.blue = (int)(grids[i][j]->weights[1] * 65535);\n\t\t\tcolor.green = (int)(grids[i][j]->weights[2] * 65535);\n\n\t\t\t/* Modify the bg color of drawing area */\n\t\t\tgtk_widget_modify_bg(drawingarea[i][j],\n\t\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t\t&color);\n\n\t\t\tcolor.red = (int)65535;\n\t\t\tcolor.blue = (int)65535;\n\t\t\tcolor.green = (int)65535;\n\n\t\t\t/* Modify the bg color of drawing area */\n\t\t\tgtk_widget_modify_bg(drawingfreq[i][j],\n\t\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t\t&color);\n\n\t\t\t/* Modify the bg color of drawing area */\n\t\t\tgtk_widget_modify_bg(drawingsele[i][j],\n\t\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t\t&color);\n\t\t}\n\t}\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Update percentual box : update all progress bars on percentual box area using cararc vectors \n */\n", "func_signal": "void update_percentualbox(void)", "code": "{\n\tint i;\n\tunsigned long acu=0;\n\tfor (i=0; i<3; i++) {\n\t\tacu=acu+car_con[i]; \n\t}\n\tfor (i=0; i<3; i++) {\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(con[i]),((double)car_con[i]/acu)) ; \n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(con[i]),g_strdup_printf(\"%f %%\",100*((double)car_con[i]/acu)));\n\t\tprintf (\"size [%d]=%f %% \",i,100*((double)car_con[i]/acu)); \n\t}\n\twhile(g_main_context_iteration(NULL, FALSE));\n\n\tfor (i=0; i<6; i++) {\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(var[i]),((double)car_var[i]/acu));\n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(var[i]),g_strdup_printf(\"%f %%\",100*((double)car_var[i]/acu)));\n\t\tprintf (\"%f %% \",100*((double)car_var[i]/acu));\n\t\tprintf (\"MUV [%d]=%f %% \",i,100*((double)car_var[i]/acu));\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(tax[i]),((double)car_tax[i]/acu));\n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(tax[i]),g_strdup_printf(\"%f %%\",100*((double)car_tax[i]/acu)));\n\t\tprintf (\"%f %%\",100*((double)car_tax[i]/acu)); \n\t\tprintf (\"RMUV [%d]=%f %%\",i,100*((double)car_tax[i]/acu)); \n\t}\n\n\twhile(g_main_context_iteration(NULL, FALSE));\n\tprintf(\"\\n\");\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Training UI \n */\n", "func_signal": "void repaint_gtk_table(GtkWidget * widget, gpointer data)", "code": "{\n\tint i, j;\n\tint input_size;\n\n\tinput_size = read_som_input(inputs, INPUT_MAXSIZE);\n\n\ttrain(inputs, input_size);\n\n\tsave_trained_som(\"saved_som.txt\", grids);\n\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\tcolor.red = (int)(grids[i][j]->weights[0] * 65535);\n\t\t\tcolor.blue = (int)(grids[i][j]->weights[1] * 65535);\n\t\t\tcolor.green = (int)(grids[i][j]->weights[2] * 65535);\n\t\t\tgtk_widget_modify_bg(drawingarea[i][j], GTK_STATE_NORMAL, &color);\n\t\t}\n\t}\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/* \n * Close down and exit handler \n */\n", "func_signal": "gint destroy_window(GtkWidget * widget,\n\t\tGdkEvent  * event,\n\t\tgpointer    client_data)", "code": "{\n\tgtk_main_quit();\n\treturn TRUE;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Generate trained percentual\n */\n", "func_signal": "void calculate_trained_percentual(void)", "code": "{\n\n\tint x, y, z,i,j;\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\tx = undo_normalize(grids[i][j]->weights[0], MEM_MAX, MEM_MIN);\n\t\t\ty = undo_normalize(grids[i][j]->weights[1], VELOC_MAX, VELOC_MIN);\n\t\t\tz = undo_normalize(grids[i][j]->weights[2], ACEL_MAX, ACEL_MIN);\n\t\t\tcar_con[get_classposition(x, MEM_MAX, MEM_MIN)-3]++; \n\t\t\tcar_var[get_classposition(y, VELOC_MAX, VELOC_MIN)]++; \n\t\t\tcar_tax[get_classposition(z, ACEL_MAX, ACEL_MIN)]++;\n\t\t}\n\t}\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n *  * Print the data of a drawing area when clicked\n *   */\n", "func_signal": "gboolean button_press(GtkWidget *widget,\n\t\tGdkEventExpose *event,\n\t\tgpointer data)", "code": "{\n\tint x, y, z;\n\tchar mem[10];\n\tchar veloc[10];\n\tchar accel[10];\n\tstruct som_node * node = (struct som_node *)data;\n\tx = undo_normalize(node->weights[0], MEM_MAX, MEM_MIN);\n\ty = undo_normalize(node->weights[1], VELOC_MAX, VELOC_MIN);\n\tz = undo_normalize(node->weights[2], ACEL_MAX, ACEL_MIN);\n\tstatus_bar_push_item(g_strdup_printf(\"(%d, %d) [%d %d %d] [%s, %s, %s]\",\n\t\t\t\tnode->xp, node->yp,\n\t\t\t\tx, y, z,\n\t\t\t\tget_classname(x, MEM_MAX, MEM_MIN, mem),\n\t\t\t\tget_classname(y, VELOC_MAX, VELOC_MIN, veloc),\n\t\t\t\tget_classname(z, ACEL_MAX, ACEL_MIN, accel)\n\t\t\t\t)\n\t\t\t);\n\n\treturn TRUE;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Select file \n */\n", "func_signal": "void select_log_file(GtkWidget *widget, gint data)", "code": "{\n\n\t/* Radio button rblog selected */\n\t/* Filter for open dialog window*/\n\tgchar *mime[] = {\"*.log\", NULL};\n\n\n\t/* Return the filename by open dialog window */\n\tfilename = create_path_selection(\"Open log file\",\n\t\t\tMN_OPEN_DIALOG,\n\t\t\tmime,\n\t\t\tNULL,\n\t\t\tNULL);\n\n\t/* If filename was chosen in the open dialog window */\n\tif (filename != NULL) {\n\t\tstatus_bar_push_item(g_strdup_printf(\"RUNNING : %s\",filename));\t\n\t\trun();\n\t}\n\telse {\n\t\tstatus_bar_push_item(g_strdup_printf(\"WARNING : Select a log file \"));\n\t}\n\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Monitor the memory consumption pattern of application\n * in the trained SOM\n */\n", "func_signal": "void run(void)", "code": "{\n\treset_percentual();\n\tstop=0; \n\tGdkColormap *colormap; \n\tunsigned int current_rss = 0;\n\tunsigned int new_rss;\n\tint veloc = 0;\n\tint accel = 0;\n\tstruct som_node * bmu = NULL;\n\tint i, j;\n\tunsigned long x;\n\tunsigned long iterations;\n\tgchar *fullname;\n\n\tstruct rss_list * head = NULL;\n\tstruct rss_list * iterator = NULL;\n\n\tfullname=filename; \n\n\t/* Get the head pointer for rss_list */\n\thead = read_log_statm(fullname, &iterations);\n\titerator = head;\n\n\t/* Free memory */\n\tfree(fullname);\n\n\n\tint dx, dy, dz;\n\t/*\n\t   char mem_flag[10];\n\t   char veloc_flag[10];\n\t   char accel_flag[10];\n\t   */\n\n\tfor (x=0; x<iterations; x++) {\n\t\t/* Logfile radion button is active */\n\t\tnew_rss = iterator->rss_pages;\n\t\titerator = iterator->next;\n\n\t\t/* Get the closest bmu */\n\t\tbmu = get_bmu_xy(grids,\n\t\t\t\t&new_rss,\n\t\t\t\t&current_rss,\n\t\t\t\t&veloc,\n\t\t\t\t&accel);\n\n\t\t/*Percentual update*/\n\t\tdx = undo_normalize(bmu->weights[0], MEM_MAX, MEM_MIN);\n\t\tdy = undo_normalize(bmu->weights[1], VELOC_MAX, VELOC_MIN);\n\t\tdz = undo_normalize(bmu->weights[2], ACEL_MAX, ACEL_MIN);\n\t\tcar_con[get_classposition(dx, MEM_MAX, MEM_MIN)-3]++; \n\t\tcar_var[get_classposition(dy, VELOC_MAX, VELOC_MIN)]++; \n\t\tcar_tax[get_classposition(dz, ACEL_MAX, ACEL_MIN)]++;\n\n\t\ti = bmu->xp;\n\t\tj = bmu->yp;\n\n\t\t/* Set white color */\n\t\tcolor.red = (int)65535;\n\t\tcolor.blue = (int)65535;\n\t\tcolor.green = (int)65535;\n\t\t/* Paint the area with white color */\n\t\tgtk_widget_modify_bg(drawingarea[i][j],\n\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t&color);\n\t\twhile(g_main_context_iteration(NULL, FALSE));\n\t\tusleep(1000);\n\n\n\t\t/* Set black color */\n\t\tcolor.red = (int)0;\n\t\tcolor.blue = (int)0;\n\t\tcolor.green = (int)0;\n\t\t/* Paint the area with black color */\n\t\tgtk_widget_modify_bg(drawingarea[i][j],\n\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t&color);\n\t\t/* Run all pending events and high priority idle functions */\n\t\twhile(g_main_context_iteration(NULL, FALSE));\n\t\tusleep(1000);\n\n\n\t\t/*Freq table increment -- color decrement*/\n\t\tcolormap=gtk_widget_get_colormap(drawingfreq[i][j]); \n\t\tcolor=drawingfreq[i][j]->style->bg[0]; \n\t\tif(color.red>100) {\n\t\t\tcolor.red=color.red-100;\n\t\t\tcolor.green=color.green-100; \n\t\t\tcolor.blue=color.blue-100;\n\t\t}\n\t\t/* Paint the area on freq  */\n\t\tgtk_widget_modify_bg(drawingfreq[i][j],\n\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t&color);\n\t\twhile(g_main_context_iteration(NULL, FALSE));\n\t\tusleep(1000);\n\n\t\t/* Repaint the same are with original color */\n\t\tcolor.red = (int)(grids[i][j]->weights[0] * 65535);\n\t\tcolor.blue = (int)(grids[i][j]->weights[1] * 65535);\n\t\tcolor.green = (int)(grids[i][j]->weights[2] * 65535);\n\t\t/* Paint the area with original color */\n\t\tgtk_widget_modify_bg(drawingarea[i][j],\n\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t&color);\n\n\t\t/* Paint the sele area with original color */\n\t\tgtk_widget_modify_bg(drawingsele[i][j],\n\t\t\t\tGTK_STATE_NORMAL,\n\t\t\t\t&color);\n\n\t\twhile(g_main_context_iteration(NULL, FALSE));\n\t\tusleep(1000);\n\n\n\t\tupdate_percentualbox();\n\n\n\t\tif(stop){\n\t\t\tstop=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (head)\n\t\tfree_rss_list(head);\n\n\tstatus_bar_push_item(g_strdup_printf(\"Executation terminated : %s\",filename));\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Free the list of applications\n */\n", "func_signal": "void free_procs(struct proc *** list, int length)", "code": "{\n\tstruct proc ** proclist = *list;\n\tint i;\n\n\tfor (i=0; i<length; i++)\n\t\tfree(proclist[i]);\n\n\tfree(proclist);\n\n\t*list = NULL;\n}", "path": "experiments\\adaptatived\\util.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Trained percentual\n */\n", "func_signal": "void trained_percentual(GtkWidget * table,\n\t\tGtkWidget * box)", "code": "{\n\treset_percentual();\n\tcalculate_trained_percentual();\n\tupdate_percentualbox();\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Create sele table \n */\n", "func_signal": "GtkWidget * create_gtk_sele_table(GtkWidget * table,\n\t\tGtkWidget * box)", "code": "{\n\tint i, j;\n\n\ttable = gtk_table_new(GRIDS_YSIZE, GRIDS_XSIZE, TRUE);\n\n\t/* Put the table in the main window */\n\tgtk_box_pack_start(GTK_BOX(box), table, TRUE, FALSE, 0);\n\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\t/* Create drawingsele */\n\t\t\tdrawingsele[i][j] = gtk_drawing_area_new();\n\n\t\t\t/*Adding event to draw area */\n\t\t\tgtk_widget_add_events(drawingsele[i][j],\n\t\t\t\t\tGDK_BUTTON_PRESS_MASK);\n\t\t\tg_signal_connect(G_OBJECT(drawingsele[i][j]),\n\t\t\t\t\t\"button_press_event\",\n\t\t\t\t\tG_CALLBACK(button_press),\n\t\t\t\t\t(gpointer)grids[i][j]);\n\n\t\t\tcolor.red = (int)65535;\n\t\t\tcolor.blue = (int)65535;\n\t\t\tcolor.green = (int)65535;\n\n\t\t\tgtk_widget_modify_bg(drawingsele[i][j], GTK_STATE_NORMAL, &color);\n\n\t\t\t/* Set size of drawingarea */\n\t\t\tgtk_widget_set_size_request(GTK_WIDGET(drawingsele[i][j]), 10, 10);\n\n\t\t\t/* Insert drawing area into the upper left quadrant of the table */\n\t\t\tgtk_table_attach_defaults(GTK_TABLE(table), drawingsele[i][j], i, i+1, j, j+1);\n\n\t\t\tgtk_widget_show(drawingsele[i][j]);\n\t\t}\n\t}\n\n\treturn table;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Read the number of rss pages\n */\n", "func_signal": "unsigned int read_statm(pid_t pid)", "code": "{\n\tint fd;\n\tchar filename[25];\n\tchar statm[STATM_SIZE];\n\tsize_t length;\n\tunsigned int vm_pages, rss_pages;\n\n\tsnprintf(filename, sizeof(filename), \"/proc/%d/statm\", (int)pid);\n\n\tfd = open(filename, O_RDONLY);\n\n\tif (fd == -1) {\n\t\tfprintf(stderr,\n\t\t\t\t\"error opening file %s: %s\\n\",\n\t\t\t\tfilename, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlength = read(fd, statm, sizeof(statm));\n\tclose(fd);\n\n\tstatm[length] = '\\0';\n\n\tsscanf(statm, \"%u %u\", &vm_pages, &rss_pages);\n\n\treturn rss_pages;\n}", "path": "experiments\\adaptatived\\util.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Reset percentual\n */\n", "func_signal": "void reset_percentual(void)", "code": "{\n\n\tint i;\n\tfor (i=0; i<3; i++) {\n\t\tcar_con[i]=0;\n\n\t}\n\tfor (i=0; i<6; i++) {\n\t\tcar_var[i]=0;\n\t\tcar_tax[i]=0;\n\t}\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Create freq table \n */\n", "func_signal": "GtkWidget * create_gtk_freq_table(GtkWidget * table,\n\t\tGtkWidget * box)", "code": "{\n\tint i, j;\n\n\ttable = gtk_table_new(GRIDS_YSIZE, GRIDS_XSIZE, TRUE);\n\n\t/* Put the table in the main window */\n\tgtk_box_pack_start(GTK_BOX(box), table, TRUE, FALSE, 0);\n\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\t/* Create drawingarea */\n\t\t\tdrawingfreq[i][j] = gtk_drawing_area_new();\n\n\t\t\t/*Adding event to draw area */\n\t\t\tgtk_widget_add_events(drawingfreq[i][j],\n\t\t\t\t\tGDK_BUTTON_PRESS_MASK);\n\n\t\t\tg_signal_connect(G_OBJECT(drawingfreq[i][j]),\n\t\t\t\t\t\"button_press_event\",\n\t\t\t\t\tG_CALLBACK(button_press),\n\t\t\t\t\t(gpointer)grids[i][j]);\n\n\t\t\tcolor.red = (int)65535;\n\t\t\tcolor.blue = (int)65535;\n\t\t\tcolor.green = (int)65535;\n\n\t\t\tgtk_widget_modify_bg(drawingfreq[i][j], GTK_STATE_NORMAL, &color);\n\n\t\t\t/* Set size of drawingarea */\n\t\t\tgtk_widget_set_size_request(GTK_WIDGET(drawingfreq[i][j]), 10, 10);\n\n\t\t\t/* Insert drawing area into the upper left quadrant of the table */\n\t\t\tgtk_table_attach_defaults(GTK_TABLE(table), drawingfreq[i][j], i, i+1, j, j+1);\n\n\t\t\tgtk_widget_show(drawingfreq[i][j]);\n\t\t}\n\t}\n\n\treturn table;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Main \n */\n", "func_signal": "gint main(gint argc, gchar * argv[])", "code": "{\n\tGtkWidget *window;\n\tGtkWidget *tablebox;\n\tGtkWidget *table;\n\tGtkWidget *tableaccess;\n\tGtkWidget *tablecount;\n\tGtkWidget *separator;\n\tGtkWidget *mainbox;\n\tGtkWidget *tablesbox;\n\tGtkWidget *buttonbox;\n\tGtkWidget *button;\n\tGtkWidget *buttonrun;\n\tGtkWidget *buttonstop;\n\tGtkWidget *buttonreset;\n\tGtkWidget *buttontrainpercentual;\n\tGtkWidget *percentualbox;\n\tGtkWidget *conbox;\n\tGtkWidget *varbox;\n\tGtkWidget *taxbox;\n\n\t/*\n\t * Label objects \n\t * */\n\tGtkWidget *ltablebox; \n\tGtkWidget *labeltrained; \n\tGtkWidget *labelfrequen; \n\tGtkWidget *labelvisited; \n\tGtkWidget *labelconlow; \n\tGtkWidget *labelconmed; \n\tGtkWidget *labelconhig; \n\tGtkWidget *labelvarllow; \n\tGtkWidget *labelvarlmed; \n\tGtkWidget *labelvarlhig; \n\tGtkWidget *labelvarplow; \n\tGtkWidget *labelvarpmed; \n\tGtkWidget *labelvarphig; \n\tGtkWidget *labeltaxllow; \n\tGtkWidget *labeltaxlmed; \n\tGtkWidget *labeltaxlhig; \n\tGtkWidget *labeltaxplow; \n\tGtkWidget *labeltaxpmed; \n\tGtkWidget *labeltaxphig; \n\n\n\tstop=0; \n\tint i=0; \n\n\t/* Initiate grids */\n\ttrained=read_trained_som(\"saved_som.txt\", grids); \n\tif (!trained) {\n\t\tinit_grid(grids); \n\t}\n\n\n\t/* Initialize the toolkit, remove gtk-related commandline stuff */\n\tgtk_init(&argc, &argv);\n\n\t/* Create toplevel window, set title and policies */\n\twindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\tgtk_window_set_title(GTK_WINDOW(window), \"SOM - Self Organizing Maps\");\n\tgtk_container_set_border_width (GTK_CONTAINER (window), 4);\n\n\t/* Attach to the \"delete\" and \"destroy\" events so we can exit */\n\t/*g_signal_connect(GTK_OBJECT(window), \"delete_event\",\n\t  GTK_SIGNAL_FUNC(destroy_window), (gpointer)window);*/\n\n\t/*Mainbox - vbox */\n\tmainbox = gtk_vbox_new(FALSE, 5);\n\n\tgtk_container_add(GTK_CONTAINER(window), mainbox);\n\n\t/*Horizontal - hbox ltablebox*/\n\tltablebox = gtk_hbox_new(FALSE,5);\n\tgtk_box_pack_start(GTK_BOX(mainbox), ltablebox, TRUE, FALSE, 0);\n\t/*Defining labels*/\n\tlabeltrained=gtk_label_new(\"SOM visualization\"); \n\tgtk_container_add(GTK_CONTAINER(ltablebox), labeltrained);\n\tlabelfrequen=gtk_label_new(\"Frequence of visit\"); \n\tgtk_container_add(GTK_CONTAINER(ltablebox), labelfrequen);\n\tlabelvisited=gtk_label_new(\"Visited area\"); \n\tgtk_container_add(GTK_CONTAINER(ltablebox), labelvisited);\n\tgtk_widget_show(labeltrained);\n\tgtk_widget_show(labelfrequen);\n\tgtk_widget_show(labelvisited);\n\tgtk_widget_show(ltablebox); \n\n\n\n\t/*Horizontal - hbox*/\n\ttablesbox = gtk_hbox_new(FALSE,5);\n\n\tgtk_box_pack_start(GTK_BOX(mainbox), tablesbox, TRUE, FALSE, 0);\n\n\t/*Tablebox - vbox*/\n\ttablebox = gtk_vbox_new(FALSE, 0);\n\n\tgtk_box_pack_start(GTK_BOX(tablesbox), tablebox, TRUE, FALSE, 0);\n\n\t/* Create and initiate gtk table*/\n\n\ttable = create_gtk_table(table, tablesbox);\n\n\tgtk_widget_show(table);\n\n\ttableaccess = create_gtk_freq_table(tableaccess, tablesbox);\n\n\tgtk_widget_show(tableaccess);\n\n\ttablecount = create_gtk_sele_table(tablecount, tablesbox);\t\n\n\tgtk_widget_show(tablecount);\n\n\tgtk_widget_show(tablebox);\n\n\tgtk_widget_show(tablesbox);\n\n\n\t/*Statistic analyse*/\n\n\t/*Horizontal - hbox*/\n\tpercentualbox = gtk_hbox_new(FALSE,5);\n\n\tgtk_box_pack_start(GTK_BOX(mainbox), percentualbox, TRUE, FALSE, 0);\n\n\n\t/*Conbox - vbox */\n\tconbox = gtk_vbox_new(FALSE, 5);\n\n\tgtk_container_add(GTK_CONTAINER(percentualbox), conbox);\n\n\t/*Consumo : Progress bar */\n\tfor(i=0;i<3;i++){\n\t\t/*Defining labels*/\n\t\tif (i==0)\n\t\t{\n\t\t\tlabelconlow=gtk_label_new(\"size of physical usage: low\"); \n\t\t\tgtk_container_add(GTK_CONTAINER(conbox), labelconlow);\n\t\t\tgtk_widget_show(labelconlow);\n\t\t}\n\t\telse {\n\t\t\tif (i==1) {\n\t\t\t\tlabelconmed=gtk_label_new(\"size of physical usage: media\"); \n\t\t\t\tgtk_container_add(GTK_CONTAINER(conbox), labelconmed);\n\t\t\t\tgtk_widget_show(labelconmed); \n\t\t\t}\n\t\t\telse {\n\t\t\t\tlabelconhig=gtk_label_new(\"size of physical usage: high\"); \n\t\t\t\tgtk_container_add(GTK_CONTAINER(conbox), labelconhig);\n\t\t\t\tgtk_widget_show(labelconhig); \n\t\t\t}\n\t\t}\n\n\t\tcar_con[i]=0; \n\t\tcon[i] = gtk_progress_bar_new ();\n\n\t\tgtk_box_pack_start(GTK_BOX (conbox), con[i], TRUE, FALSE, 0);\n\n\t\tgtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(con[i]),GTK_PROGRESS_LEFT_TO_RIGHT); \n\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(con[i]),0.0); \n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(con[i]),\"0.0 %\"); \n\n\t\tgtk_widget_show(con[i]);\n\n\t}\n\n\t/*varbox - vbox */\n\tvarbox = gtk_vbox_new(FALSE, 5);\n\n\tgtk_container_add(GTK_CONTAINER(percentualbox), varbox);\n\n\t/*Variacao : Progress bar */\n\tfor(i=0;i<6;i++){\n\t\t/*Defining labels*/\n\t\tif (i==0) {\n\t\t\tlabelvarllow=gtk_label_new(\"Memory usage variation: -low\"); \n\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarllow);\n\t\t\tgtk_widget_show(labelvarllow);\n\t\t} else {\n\t\t\tif (i==1) {\n\t\t\t\tlabelvarlmed=gtk_label_new(\"Memory usage variation: -media\"); \n\t\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarlmed);\n\t\t\t\tgtk_widget_show(labelvarlmed); \n\t\t\t} else {\n\t\t\t\tif (i==2) {\n\t\t\t\t\tlabelvarlhig=gtk_label_new(\"Memory usage variation: -high\"); \n\t\t\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarlhig);\n\t\t\t\t\tgtk_widget_show(labelvarlhig); \n\n\t\t\t\t} else {\n\t\t\t\t\tif(i==3) {\n\t\t\t\t\t\tlabelvarplow=gtk_label_new(\"Memory usage variation: +low\"); \n\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarplow);\n\t\t\t\t\t\tgtk_widget_show(labelvarplow); \n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(i==4) {\n\t\t\t\t\t\t\tlabelvarpmed=gtk_label_new(\"Memory usage variation: +med\"); \n\t\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarpmed);\n\t\t\t\t\t\t\tgtk_widget_show(labelvarpmed); \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlabelvarphig=gtk_label_new(\"Memory usage variation: +high\"); \n\t\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(varbox), labelvarphig);\n\t\t\t\t\t\t\tgtk_widget_show(labelvarphig); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcar_var[i]=0; \n\t\tvar[i] = gtk_progress_bar_new ();\n\n\t\tgtk_box_pack_start(GTK_BOX (varbox), var[i], TRUE, FALSE, 0);\n\n\t\tgtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(var[i]),GTK_PROGRESS_LEFT_TO_RIGHT); \n\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(var[i]),0.0); \n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(var[i]),\"0.0 %\"); \n\n\t\tgtk_widget_show(var[i]);\n\n\t}\n\n\t/*Taxbox - vbox */\n\ttaxbox = gtk_vbox_new(FALSE, 5);\n\n\tgtk_container_add(GTK_CONTAINER(percentualbox), taxbox);\n\n\t/*Taxa : Progress bar */\n\tfor(i=0;i<6;i++){\n\t\t/*Defining labels*/\n\t\tif (i==0) {\n\t\t\tlabeltaxllow=gtk_label_new(\"Rate of memory usage variation: -low\"); \n\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxllow);\n\t\t\tgtk_widget_show(labeltaxllow);\n\t\t} else {\n\t\t\tif (i==1) {\n\t\t\t\tlabeltaxlmed=gtk_label_new(\"Rate of memory usage variation: -media\"); \n\t\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxlmed);\n\t\t\t\tgtk_widget_show(labeltaxlmed); \n\t\t\t} else {\n\t\t\t\tif (i==2) {\n\t\t\t\t\tlabeltaxlhig=gtk_label_new(\"Rate of memory usage variation: -high\"); \n\t\t\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxlhig);\n\t\t\t\t\tgtk_widget_show(labeltaxlhig); \n\n\t\t\t\t} else {\n\t\t\t\t\tif(i==3) {\n\t\t\t\t\t\tlabeltaxplow=gtk_label_new(\"Rate of memory usage variation:  +low\"); \n\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxplow);\n\t\t\t\t\t\tgtk_widget_show(labeltaxplow); \n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(i==4) {\n\t\t\t\t\t\t\tlabeltaxpmed=gtk_label_new(\"Rate of memory usage variation: +med\"); \n\t\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxpmed);\n\t\t\t\t\t\t\tgtk_widget_show(labeltaxpmed); \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlabeltaxphig=gtk_label_new(\"Rate of memory usage variation:  +high\"); \n\t\t\t\t\t\t\tgtk_container_add(GTK_CONTAINER(taxbox), labeltaxphig);\n\t\t\t\t\t\t\tgtk_widget_show(labeltaxphig); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcar_tax[i]=0;\n\n\t\ttax[i] = gtk_progress_bar_new ();\n\n\t\tgtk_box_pack_start(GTK_BOX (taxbox), tax[i], TRUE, FALSE, 0);\n\n\t\tgtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(tax[i]),GTK_PROGRESS_LEFT_TO_RIGHT); \n\n\t\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(tax[i]),0.0); \n\t\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(tax[i]),\"0.0 %\"); \n\n\t\tgtk_widget_show(tax[i]);\n\n\t}\n\n\tgtk_widget_show(conbox); \n\tgtk_widget_show(varbox); \n\tgtk_widget_show(taxbox); \n\tgtk_widget_show(percentualbox); \n\n\t/*Separator - hseparator*/\n\tseparator = gtk_hseparator_new ();\n\n\tgtk_widget_set_size_request (separator, 400, 5);\n\n\tgtk_box_pack_start(GTK_BOX (mainbox), separator, TRUE, FALSE, 0);\n\n\tgtk_widget_show(separator);\n\n\t/*ButtonBox - Horizontal */\n\n\tbuttonbox = gtk_hbox_new(FALSE, 0);\n\n\tgtk_box_pack_start(GTK_BOX(mainbox), buttonbox, TRUE, FALSE, 0);\n\n\t/*Training ...*/\n\tbutton = gtk_button_new_with_label(\"Training\");\n\n\tg_signal_connect(G_OBJECT(button), \"clicked\",\n\t\t\tG_CALLBACK(repaint_gtk_table), NULL);\n\n\tgtk_box_pack_start(GTK_BOX(buttonbox), button, TRUE, FALSE, 0);\n\n\tgtk_widget_show(button);\n\n\t/*Run...*/\n\tbuttonrun = gtk_button_new_with_label(\"Run logfile\");\n\n\tg_signal_connect(G_OBJECT(buttonrun), \"clicked\",\n\t\t\tG_CALLBACK(select_log_file), NULL);\n\n\tgtk_box_pack_start(GTK_BOX(buttonbox), buttonrun, TRUE, FALSE, 0);\n\n\tgtk_widget_show(buttonrun);\n\n\t/*Stop...*/\n\tbuttonstop = gtk_button_new_with_label(\"Stop logfile\");\n\n\tg_signal_connect(G_OBJECT(buttonstop), \"clicked\",\n\t\t\tG_CALLBACK(stop_logfile), NULL);\n\n\tgtk_box_pack_start(GTK_BOX(buttonbox), buttonstop, TRUE, FALSE, 0);\n\n\tgtk_widget_show(buttonstop);\n\n\t/*Reset...*/\n\tbuttonreset = gtk_button_new_with_label(\"Reset\");\n\n\tg_signal_connect(G_OBJECT(buttonreset), \"clicked\",\n\t\t\tG_CALLBACK(reset_gtk_table), NULL);\n\n\tgtk_box_pack_start(GTK_BOX(buttonbox), buttonreset, TRUE, FALSE, 0);\n\n\tgtk_widget_show(buttonreset);\n\n\t/*Show percentual training...*/\n\tbuttontrainpercentual = gtk_button_new_with_label(\"Trained %\");\n\n\tg_signal_connect(G_OBJECT(buttontrainpercentual), \"clicked\",\n\t\t\tG_CALLBACK(trained_percentual), NULL);\n\n\tgtk_box_pack_start(GTK_BOX(buttonbox), buttontrainpercentual, TRUE, FALSE, 0);\n\n\tgtk_widget_show(buttontrainpercentual);\n\n\tgtk_widget_show(buttonbox);\n\n\t/*Progress bar */\n\tpbar = gtk_progress_bar_new ();\n\n\tgtk_box_pack_start(GTK_BOX (mainbox), pbar, TRUE, FALSE, 0);\n\n\tgtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(pbar),GTK_PROGRESS_LEFT_TO_RIGHT); \n\n\tgtk_progress_bar_set_fraction (GTK_PROGRESS_BAR(pbar),0.0); \n\tgtk_progress_bar_set_text (GTK_PROGRESS_BAR(pbar),\"0.0 %\"); \n\n\tgtk_widget_show(pbar);\n\n\t/*Status bar */\n\tstatus_bar = gtk_statusbar_new ();\n\n\tgtk_box_pack_start(GTK_BOX (mainbox), status_bar, TRUE, FALSE, 0);\n\n\tgtk_widget_show(status_bar);\n\n\tcontext_id = gtk_statusbar_get_context_id(\n\t\t\tGTK_STATUSBAR (status_bar), \"Statusbar example\");\n\n\tgtk_widget_show(mainbox);\n\n\tgtk_widget_show(window);\n\n\t/* Enter the gtk main loop (this never returns) */\t\n\tgtk_main();\n\n\treturn 0;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*\n * Create gtk table \n */\n", "func_signal": "GtkWidget * create_gtk_table(GtkWidget * table,\n\t\tGtkWidget * box)", "code": "{\n\tint i, j;\n\n\ttable = gtk_table_new(GRIDS_YSIZE, GRIDS_XSIZE, TRUE);\n\n\t/* Put the table in the main window */\n\tgtk_box_pack_start(GTK_BOX(box), table, TRUE, FALSE, 0);\n\n\tfor (i=0; i<GRIDS_XSIZE; i++) {\n\t\tfor (j=0; j<GRIDS_YSIZE; j++) {\n\t\t\t/* Create drawingarea */\n\t\t\tdrawingarea[i][j] = gtk_drawing_area_new();\n\n\t\t\t/*Adding event to draw area */\n\t\t\tgtk_widget_add_events(drawingarea[i][j],\n\t\t\t\t\tGDK_BUTTON_PRESS_MASK);\n\n\t\t\tg_signal_connect(G_OBJECT(drawingarea[i][j]),\n\t\t\t\t\t\"button_press_event\",\n\t\t\t\t\tG_CALLBACK(button_press),\n\t\t\t\t\t(gpointer)grids[i][j]);\n\n\n\t\t\tcolor.red = (int)(grids[i][j]->weights[0] * 65535);\n\t\t\tcolor.blue = (int)(grids[i][j]->weights[1] * 65535);\n\t\t\tcolor.green = (int)(grids[i][j]->weights[2] * 65535);\n\n\t\t\tgtk_widget_modify_bg(drawingarea[i][j], GTK_STATE_NORMAL, &color);\n\n\t\t\t/* Set size of drawingarea */\n\t\t\tgtk_widget_set_size_request(GTK_WIDGET(drawingarea[i][j]), 10, 10);\n\n\t\t\t/* Insert drawing area into the upper left quadrant of the table */\n\t\t\tgtk_table_attach_defaults(GTK_TABLE(table), drawingarea[i][j], i, i+1, j, j+1);\n\n\t\t\tgtk_widget_show(drawingarea[i][j]);\n\t\t}\n\t}\n\n\treturn table;\n}", "path": "experiments\\adaptatived\\app_training.c", "repo_name": "briglia/dissertacao", "stars": 2, "license": "None", "language": "c", "size": 5440}
{"docstring": "/*                                          N\n * Evaluate polynomial when coefficient of x  is 1.0.\n * Otherwise same as polevl.\n */\n", "func_signal": "static double\np1evl(double x, const double coef[], int N)", "code": "{\n    double\t\tans;\n    const double\t*p;\n    int\t\t \ti;\n\n    p = coef;\n    ans = x + *p++;\n    i = N - 1;\n\n    do\n        ans = ans * x + *p++;\n    while (--i);\n\n    return (ans);\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* Same as Outline, but does not go through the external pager.\n * Used for the list of available subtopics because if it would be passed to\n * 'less' (for example), the list would not be displayed anymore after 'less'\n * has exited and the user is asked for a subtopic */\n", "func_signal": "void\nOutLine_InternalPager(const char *line)", "code": "{\n    int c;\t\t\t/* dummy input char */\n\n#if defined(PIPES)\n    if (outfile != stderr) {\n\t/* do not go through external pager */\n\tfputs(line, stderr);\n\treturn;\n    }\n#endif /* PIPES */\n\n    /* built-in dumb pager */\n    /* leave room for prompt line */\n    if (pagelines >= screensize - 2) {\n\tfputs(\"Press return for more: \", stderr);\n\tdo\n\t    c = getchar();\n\twhile (c != EOF && c != '\\n');\n\tpagelines = 0;\n    }\n    fputs(line, stderr);\n    pagelines++;\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/*\nCephes Math Library Release 2.1:  December, 1988\nCopyright 1984, 1987, 1988 by Stephen L. Moshier\nDirect inquiries to 30 Frost Street, Cambridge, MA 02140\n*/\n", "func_signal": "static double\npolevl(double x, const double coef[], int N)", "code": "{\n    double          ans;\n    int             i;\n    const double    *p;\n\n    p = coef;\n    ans = *p++;\n    i = N;\n\n    do\n        ans = ans * x + *p++;\n    while (--i);\n\n    return (ans);\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* we sort the keys so we can use binary search later */\n/* We have a linked list of keys and the number.\n * to sort them we need an array, so we reform them into an array,\n * and then throw away the list.\n */\n", "func_signal": "static void\nsortkeys()", "code": "{\n    LINKEY *p, *n;\t\t/* pointers to linked list */\n    int i;\t\t\t/* index into key array */\n\n    /* allocate the array */\n    keys = (KEY *) gp_alloc((keycount + 1) * sizeof(KEY), \"key array\");\n\n    /* copy info from list to array, freeing list */\n    for (p = keylist, i = 0; p != NULL; p = n, i++) {\n\tkeys[i].key = p->key;\n\tkeys[i].pos = p->pos;\n\tkeys[i].text = p->text;\n\tkeys[i].primary = p->primary;\n\tn = p->next;\n\tfree((char *) p);\n    }\n\n    /* a null entry to terminate subtopic searches */\n    keys[keycount].key = NULL;\n    keys[keycount].pos = 0;\n    keys[keycount].text = NULL;\n\n    /* sort the array */\n    /* note that it only moves objects of size (two pointers + long + int) */\n    /* it moves no strings */\n    /* HBB 20010720: removed superfluous, potentially dangerous casts */\n    qsort(keys, keycount, sizeof(KEY), keycomp);\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* atexit procedure */\n", "func_signal": "void\nWinExit()", "code": "{\n\tterm_reset();\n\n#ifndef __MINGW32__ /* HBB 980809: FIXME: doesn't exist for MinGW32. So...? */\n\tfcloseall();\n#endif\n\tif (graphwin.hWndGraph && IsWindow(graphwin.hWndGraph))\n\t\tGraphClose(&graphwin);\n#ifndef WGP_CONSOLE\n\tTextMessage();\t/* process messages */\n#endif\n \tWinHelp(textwin.hWndText,(LPSTR)winhelpname,HELP_QUIT,(DWORD)NULL);\n#ifndef WGP_CONSOLE\n\tTextMessage();\t/* process messages */\n#endif\n\treturn;\n}", "path": "src\\win\\winmain.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* ** ibeta.c\n *\n *   DESCRIBE  Approximate the incomplete beta function Ix(a, b).\n *\n *                           _\n *                          |(a + b)     /x  (a-1)         (b-1)\n *             Ix(a, b) = -_-------_--- * |  t     * (1 - t)     dt (a,b > 0)\n *                        |(a) * |(b)   /0\n *\n *\n *\n *   CALL      p = ibeta(a, b, x)\n *\n *             double    a    > 0\n *             double    b    > 0\n *             double    x    [0, 1]\n *\n *   WARNING   none\n *\n *   RETURN    double    p    [0, 1]\n *                            -1.0 on error condition\n *\n *   XREF      lngamma()\n *\n *   BUGS      none\n *\n *   REFERENCE The continued fraction expansion as given by\n *             Abramowitz and Stegun (1964) is used.\n *\n * Copyright (c) 1992 Jos van der Woude, jvdwoude@hut.nl\n *\n * Note: this function was translated from the Public Domain Fortran\n *       version available from http://lib.stat.cmu.edu/apstat/xxx\n *\n */\n", "func_signal": "static double\nibeta(double a, double b, double x)", "code": "{\n    /* Test for admissibility of arguments */\n    if (a <= 0.0 || b <= 0.0)\n\treturn -1.0;\n    if (x < 0.0 || x > 1.0)\n\treturn -1.0;;\n\n    /* If x equals 0 or 1, return x as prob */\n    if (x == 0.0 || x == 1.0)\n\treturn x;\n\n    /* Swap a, b if necessary for more efficient evaluation */\n    return a < x * (a + b) ? 1.0 - confrac(b, a, 1.0 - x) : confrac(a, b, x);\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/*                                                     erf.c\n *\n *      Error function\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, erf();\n *\n * y = erf( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * The integral is\n *\n *                           x\n *                            -\n *                 2         | |          2\n *   erf(x)  =  --------     |    exp( - t  ) dt.\n *              sqrt(pi)   | |\n *                          -\n *                           0\n *\n * The magnitude of x is limited to 9.231948545 for DEC\n * arithmetic; 1 or -1 is returned outside this range.\n *\n * For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise\n * erf(x) = 1 - erfc(x).\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    DEC       0,1         14000       4.7e-17     1.5e-17\n *    IEEE      0,1         30000       3.7e-16     1.0e-16\n *\n */\n", "func_signal": "static double\nerf(double x)", "code": "{\n\n# ifdef UNK\n    static const double   T[] = {\n\t9.60497373987051638749E0,\n\t9.00260197203842689217E1,\n\t2.23200534594684319226E3,\n\t7.00332514112805075473E3,\n\t5.55923013010394962768E4\n    };\n    static const double   U[] = {\n\t/* 1.00000000000000000000E0,*/\n\t3.35617141647503099647E1,\n\t5.21357949780152679795E2,\n\t4.59432382970980127987E3,\n\t2.26290000613890934246E4,\n\t4.92673942608635921086E4\n    };\n# endif\n\n# ifdef DEC\n    static const unsigned short T[] = {\n\t0041031, 0126770, 0170672, 0166101,\n\t0041664, 0006522, 0072360, 0031770,\n\t0043013, 0100025, 0162641, 0126671,\n\t0043332, 0155231, 0161627, 0076200,\n\t0044131, 0024115, 0021020, 0117343\n    };\n    static const unsigned short U[] = {\n\t/*0040200,0000000,0000000,0000000,*/\n\t0041406, 0037461, 0177575, 0032714,\n\t0042402, 0053350, 0123061, 0153557,\n\t0043217, 0111227, 0032007, 0164217,\n\t0043660, 0145000, 0004013, 0160114,\n\t0044100, 0071544, 0167107, 0125471\n    };\n# endif\n\n# ifdef IBMPC\n    static const unsigned short T[] = {\n\t0x5d88, 0x1e37, 0x35bf, 0x4023,\n\t0x067f, 0x4e9e, 0x81aa, 0x4056,\n\t0x35b7, 0xbcb4, 0x7002, 0x40a1,\n\t0xef90, 0x3c72, 0x5b53, 0x40bb,\n\t0x13dc, 0xa442, 0x2509, 0x40eb\n    };\n    static const unsigned short U[] = {\n\t/*0x0000,0x0000,0x0000,0x3ff0,*/\n\t0xa6ba, 0x3fef, 0xc7e6, 0x4040,\n\t0x3aee, 0x14c6, 0x4add, 0x4080,\n\t0xfd12, 0xe680, 0xf252, 0x40b1,\n\t0x7c0a, 0x0101, 0x1940, 0x40d6,\n\t0xf567, 0x9dc8, 0x0e6c, 0x40e8\n    };\n# endif\n\n# ifdef MIEEE\n    static const unsigned short T[] = {\n\t0x4023, 0x35bf, 0x1e37, 0x5d88,\n\t0x4056, 0x81aa, 0x4e9e, 0x067f,\n\t0x40a1, 0x7002, 0xbcb4, 0x35b7,\n\t0x40bb, 0x5b53, 0x3c72, 0xef90,\n\t0x40eb, 0x2509, 0xa442, 0x13dc\n    };\n    static const unsigned short U[] = {\n\t0x4040, 0xc7e6, 0x3fef, 0xa6ba,\n\t0x4080, 0x4add, 0x14c6, 0x3aee,\n\t0x40b1, 0xf252, 0xe680, 0xfd12,\n\t0x40d6, 0x1940, 0x0101, 0x7c0a,\n\t0x40e8, 0x0e6c, 0x9dc8, 0xf567\n    };\n# endif\n\n    double y, z;\n\n    if (fabs(x) > 1.0)\n        return (1.0 - erfc(x));\n    z = x * x;\n    y = x * polevl(z, T, 4) / p1evl(z, U, 5);\n    return (y);\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* Implementation of Lamberts W-function which is defined as\n * w(x)*e^(w(x))=x\n * Implementation by Gunter Kuhnle, gk@uni-leipzig.de\n * Algorithm originally developed by\n * KEITH BRIGGS, DEPARTMENT OF PLANT SCIENCES,\n * e-mail:kmb28@cam.ac.uk\n * http://epidem13.plantsci.cam.ac.uk/~kbriggs/W-ology.html */\n", "func_signal": "static double\nlambertw(double x)", "code": "{\n    double p, e, t, w, eps;\n    int i;\n\n    eps = MACHEPS;\n\n    if (x < -exp(-1))\n\treturn -1;              /* error, value undefined */\n\n    if (fabs(x) <= eps)\n\treturn x;\n\n    if (x < 1) {\n\tp = sqrt(2.0 * (exp(1.0) * x + 1.0));\n\tw = -1.0 + p - p * p / 3.0 + 11.0 / 72.0 * p * p * p;\n    } else {\n\tw = log(x);\n    }\n\n    if (x > 3) {\n\tw = w - log(w);\n    }\n    for (i = 0; i < 20; i++) {\n\te = gp_exp(w);\n\tt = w * e - x;\n\tt = t / (e * (w + 1.0) - 0.5 * (w + 2.0) * t / (w + 1.0));\n\tw = w - t;\n\tif (fabs(t) < eps * (1.0 + fabs(w)))\n\t    return w;\n    }\n    return -1;                 /* error: iteration didn't converge */\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* we only read the file once, into memory\n * except for DOS16 when we don't read all the file -\n * just the keys and location of the text\n */\n", "func_signal": "static int\nLoadHelp(char *path)", "code": "{\n    LINKEY *key = 0;\t\t/* this key */\n    long pos = 0;\t\t/* ftell location within help file */\n    char buf[BUFSIZ];\t\t/* line from help file */\n    LINEBUF *head;\t\t/* head of text list  */\n    LINEBUF *firsthead = NULL;\n    TBOOLEAN primary;\t\t/* first ? line of a set is primary */\n    TBOOLEAN flag;\n\n    if ((helpfp = fopen(path, \"r\")) == NULL) {\n\t/* can't open help file, so error exit */\n\treturn (H_ERROR);\n    }\n    /*\n     ** The help file is open.  Look in there for the keyword.\n     */\n    if (!fgets(buf, BUFSIZ - 1, helpfp) || *buf != KEYFLAG)\n\treturn (H_ERROR);\t/* it is probably not the .gih file */\n\n    while (!feof(helpfp)) {\n\t/*\n\t ** Make an entry for each synonym keyword\n\t */\n\tprimary = TRUE;\n\twhile (buf[0] == KEYFLAG) {\n\t    key = storekey(buf + 1);\t/* store this key */\n\t    key->primary = primary;\n\t    key->text = NULL;\t/* fill in with real value later */\n\t    key->pos = 0;\t/* fill in with real value later */\n\t    primary = FALSE;\n\t    pos = ftell(helpfp);\n\t    if (fgets(buf, BUFSIZ - 1, helpfp) == (char *) NULL)\n\t\tbreak;\n\t}\n\t/*\n\t ** Now store the text for this entry.\n\t ** buf already contains the first line of text.\n\t */\n#ifndef DOS16\n\tfirsthead = storeline(buf);\n\thead = firsthead;\n#endif\n\twhile ((fgets(buf, BUFSIZ - 1, helpfp) != (char *) NULL)\n\t       && (buf[0] != KEYFLAG)) {\n#ifndef DOS16\n\t    /* save text line */\n\t    head->next = storeline(buf);\n\t    head = head->next;\n#endif\n\t}\n\t/* make each synonym key point to the same text */\n\tdo {\n\t    key->pos = pos;\n\t    key->text = firsthead;\n\t    flag = key->primary;\n\t    key = key->next;\n\t} while (flag != TRUE && key != NULL);\n    }\n#ifndef DOS16\n    (void) fclose(helpfp);\n#endif\n\n    /* we sort the keys so we can use binary search later */\n    sortkeys();\n    return (H_FOUND);\t\t/* ok */\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* This function can be used to retrieve version information from\n * Window's Shell and common control libraries such (Comctl32.dll,\n * Shell32.dll, and Shlwapi.dll) The code was copied from the MSDN\n * article \"Shell and Common Controls Versions\" */\n", "func_signal": "DWORD\nGetDllVersion(LPCTSTR lpszDllName)", "code": "{\n    HINSTANCE hinstDll;\n    DWORD dwVersion = 0;\n\n    /* For security purposes, LoadLibrary should be provided with a \n       fully-qualified path to the DLL. The lpszDllName variable should be\n       tested to ensure that it is a fully qualified path before it is used. */\n    hinstDll = LoadLibrary(lpszDllName);\n\t\n    if (hinstDll) {\n        DLLGETVERSIONPROC pDllGetVersion;\n        pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstDll, \n                          \"DllGetVersion\");\n\n        /* Because some DLLs might not implement this function, you\n        must test for it explicitly. Depending on the particular \n        DLL, the lack of a DllGetVersion function can be a useful\n        indicator of the version. */\n        if (pDllGetVersion) {\n            DLLVERSIONINFO dvi;\n            HRESULT hr;\n\n            ZeroMemory(&dvi, sizeof(dvi));\n            dvi.cbSize = sizeof(dvi);\n            hr = (*pDllGetVersion)(&dvi);\n            if (SUCCEEDED(hr))\n               dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);\n        }\n        FreeLibrary(hinstDll);\n    }\n    return dwVersion;\n}", "path": "src\\win\\winmain.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* ----------------------------------------------------------------\n   Following to specfun.c made by John Grosh (jgrosh@arl.mil)\n   on 28 OCT 1992.\n   ---------------------------------------------------------------- */\n", "func_signal": "void\nf_normal(union argument *arg)", "code": "{\t\t\t\t/* Normal or Gaussian Probability Function */\n    struct value a;\n    double x;\n\n    /* ref. Abramowitz and Stegun 1964, \"Handbook of Mathematical\n       Functions\", Applied Mathematics Series, vol 55,\n       Chapter 26, page 934, Eqn. 26.2.29 and Jos van der Woude\n       code found above */\n\n    (void) arg;\t\t\t\t/* avoid -Wunused warning */\n    x = real(pop(&a));\n\n    x = 0.5 * SQRT_TWO * x;\n    x = 0.5 * erfc(-x);\t\t/* by using erfc instead of erf, we\n\t\t\t\t   can get accurate values for -38 <\n\t\t\t\t   arg < -8 */\n    push(Gcomplex(&a, x, 0.0));\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* Use only to observe the effect of a \"bad\" random number generator. */\n", "func_signal": "void f_rand(union argument *arg)", "code": "{\n    struct value a;\n\n    (void) arg;\t\t\t\t/* avoid -Wunused warning */\n    static unsigned int y = 0;\n    unsigned int maxran = 1000;\n\n    (void) real(pop(&a));\n    y = (781 * y + 387) % maxran;\n\n    push(Gcomplex(&a, (double) y / maxran, 0.0));\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* ----------------------------------------------------------------\n   Following function for the inverse error function is taken from\n   NIST on 16. May 2002.\n   Use Newton-Raphson correction also for range -1 to -y0 and\n   add 3rd cycle to improve convergence -  E A Merritt 21.10.2003\n   ----------------------------------------------------------------\n */\n", "func_signal": "static double\ninverse_error_func(double y)", "code": "{\n    double x = 0.0;    /* The output */\n    double z = 0.0;    /* Intermadiate variable */\n    double y0 = 0.7;   /* Central range variable */\n\n    /* Coefficients in rational approximations. */\n    static const double a[4] = {\n\t0.886226899, -1.645349621, 0.914624893, -0.140543331\n    };\n    static const double b[4] = {\n\t-2.118377725, 1.442710462, -0.329097515, 0.012229801\n    };\n    static const double c[4] = {\n\t-1.970840454, -1.624906493, 3.429567803, 1.641345311\n    };\n    static const double d[2] = {\n\t3.543889200, 1.637067800\n    };\n\n    if ((y < -1.0) || (1.0 < y)) {\n        printf(\"inverse_error_func: The value out of the range of the function\");\n        x = log(-1.0);\n\treturn (x);\n    } else if ((y == -1.0) || (1.0 == y)) {\n        x = -y * log(0.0);\n\treturn (x);\n    } else if ((-1.0 < y) && (y < -y0)) {\n        z = sqrt(-log((1.0 + y) / 2.0));\n        x = -(((c[3] * z + c[2]) * z + c[1]) * z + c[0]) / ((d[1] * z + d[0]) * z + 1.0);\n    } else {\n        if ((-y0 <= y) && (y <= y0)) {\n            z = y * y;\n            x = y * (((a[3] * z + a[2]) * z + a[1]) * z + a[0]) /\n                ((((b[3] * z + b[3]) * z + b[1]) * z + b[0]) * z + 1.0);\n        } else if ((y0 < y) && (y < 1.0)) {\n            z = sqrt(-log((1.0 - y) / 2.0));\n            x = (((c[3] * z + c[2]) * z + c[1]) * z + c[0]) / ((d[1] * z + d[0]) * z + 1.0);\n        }\n    }\n    /* Three steps of Newton-Raphson correction to full accuracy. OK - four */\n    x = x - (erf(x) - y) / (2.0 / sqrt(PI) * gp_exp(-x * x));\n    x = x - (erf(x) - y) / (2.0 / sqrt(PI) * gp_exp(-x * x));\n    x = x - (erf(x) - y) / (2.0 / sqrt(PI) * gp_exp(-x * x));\n    x = x - (erf(x) - y) / (2.0 / sqrt(PI) * gp_exp(-x * x));\n\n    return (x);\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* !GAMMA */\n", "func_signal": "void\nf_erf(union argument *arg)", "code": "{\n    struct value a;\n    double x;\n\n    (void) arg;\t\t\t\t/* avoid -Wunused warning */\n    x = real(pop(&a));\n    x = erf(x);\n    push(Gcomplex(&a, x, 0.0));\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* WGP_CONSOLE */\n", "func_signal": "DWORD WINAPI stdin_pipe_reader(LPVOID param)", "code": "{\n#if 0\n    HANDLE h = (HANDLE)_get_osfhandle(fileno(stdin));\n    char c;\n    DWORD cRead;\n\n    if (ReadFile(h, &c, 1, &cRead, NULL))\n        return c;\n#else\n    unsigned char c;\n    if (fread(&c, 1, 1, stdin) == 1)\n        return (DWORD)c;\n    return EOF;\n#endif\n}", "path": "src\\win\\winmain.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* StartOutput:\n * Open a file pointer to a pipe to user's $PAGER, if there is one,\n * otherwise use our own pager.\n */\n", "func_signal": "void\nStartOutput()", "code": "{\n    char *line_count = NULL;\n\n#if defined(PIPES)\n    char *pager_name = getenv(\"PAGER\");\n\n    if (pager_name != NULL && *pager_name != NUL)\n\tif ((outfile = popen(pager_name, \"w\")) != (FILE *) NULL)\n\t    return;\t\t/* success */\n    outfile = stderr;\n    /* fall through to built-in pager */\n#endif\n\n    /* buit-in dumb pager: use the line count provided by the terminal */\n    line_count = getenv(\"LINES\");\n\n    if (line_count != NULL)\n\tscreensize = (int) strtol(line_count, NULL, 0);\n    if (line_count == NULL || screensize < 3)\n\tscreensize = SCREENSIZE;\n\n    /* built-in pager */\n    pagelines = 0;\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* Add this keyword to the keys list, with the given text */\n", "func_signal": "static LINKEY *\nstorekey(char *key)", "code": "{\n    LINKEY *new;\n\n    key[strlen(key) - 1] = NUL;\t/* cut off \\n  */\n\n    new = (LINKEY *) gp_alloc(sizeof(LINKEY), \"new key list\");\n    if (key)\n\tnew->key = gp_strdup(key);\n\n    /* add to front of list */\n    new->next = keylist;\n    keylist = new;\n    keycount++;\n    return (new);\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* make a new line buffer and save this string there */\n", "func_signal": "static LINEBUF *\nstoreline(char *text)", "code": "{\n    LINEBUF *new;\n\n    new = (LINEBUF *) gp_alloc(sizeof(LINEBUF), \"new line buffer\");\n    if (text)\n\tnew->line = gp_strdup(text);\n    else\n\tnew->line = NULL;\n\n    new->next = NULL;\n\n    return (new);\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* ** igamma.c\n *\n *   DESCRIBE  Approximate the incomplete gamma function P(a, x).\n *\n *                         1     /x  -t   (a-1)\n *             P(a, x) = -_--- * |  e  * t     dt      (a > 0)\n *                       |(a)   /0\n *\n *   CALL      p = igamma(a, x)\n *\n *             double    a    >  0\n *             double    x    >= 0\n *\n *   WARNING   none\n *\n *   RETURN    double    p    [0, 1]\n *                            -1.0 on error condition\n *\n *   XREF      lngamma()\n *\n *   BUGS      Values 0 <= x <= 1 may lead to inaccurate results.\n *\n *   REFERENCE ALGORITHM AS239  APPL. STATIST. (1988) VOL. 37, NO. 3\n *\n * Copyright (c) 1992 Jos van der Woude, jvdwoude@hut.nl\n *\n * Note: this function was translated from the Public Domain Fortran\n *       version available from http://lib.stat.cmu.edu/apstat/239\n *\n */\n", "func_signal": "static double\nigamma(double a, double x)", "code": "{\n    double arg;\n    double aa;\n    double an;\n    double b;\n    int i;\n\n    /* Check that we have valid values for a and x */\n    if (x < 0.0 || a <= 0.0)\n\treturn -1.0;\n\n    /* Deal with special cases */\n    if (x == 0.0)\n\treturn 0.0;\n    if (x > XBIG)\n\treturn 1.0;\n\n    /* Check value of factor arg */\n    arg = a * log(x) - x - GAMMA(a + 1.0);\n    /* HBB 20031006: removed a spurious check here */\n    arg = gp_exp(arg);\n\n    /* Choose infinite series or continued fraction. */\n\n    if ((x > 1.0) && (x >= a + 2.0)) {\n\t/* Use a continued fraction expansion */\n\tdouble pn1, pn2, pn3, pn4, pn5, pn6;\n\tdouble rn;\n\tdouble rnold;\n\n\taa = 1.0 - a;\n\tb = aa + x + 1.0;\n\tpn1 = 1.0;\n\tpn2 = x;\n\tpn3 = x + 1.0;\n\tpn4 = x * b;\n\trnold = pn3 / pn4;\n\n\tfor (i = 1; i <= ITMAX; i++) {\n\n\t    aa++;\n\t    b += 2.0;\n\t    an = aa * (double) i;\n\n\t    pn5 = b * pn3 - an * pn1;\n\t    pn6 = b * pn4 - an * pn2;\n\n\t    if (pn6 != 0.0) {\n\n\t\trn = pn5 / pn6;\n\t\tif (fabs(rnold - rn) <= GPMIN(MACHEPS, MACHEPS * rn))\n\t\t    return 1.0 - arg * rn * a;\n\n\t\trnold = rn;\n\t    }\n\t    pn1 = pn3;\n\t    pn2 = pn4;\n\t    pn3 = pn5;\n\t    pn4 = pn6;\n\n\t    /* Re-scale terms in continued fraction if terms are large */\n\t    if (fabs(pn5) >= OFLOW) {\n\n\t\tpn1 /= OFLOW;\n\t\tpn2 /= OFLOW;\n\t\tpn3 /= OFLOW;\n\t\tpn4 /= OFLOW;\n\t    }\n\t}\n    } else {\n\t/* Use Pearson's series expansion. */\n\n\tfor (i = 0, aa = a, an = b = 1.0; i <= ITMAX; i++) {\n\n\t    aa++;\n\t    an *= x / aa;\n\t    b += an;\n\t    if (an < b * MACHEPS)\n\t\treturn arg * b;\n\t}\n    }\n    return -1.0;\n}", "path": "src\\specfun.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/* Ambiguous:\n * Check the key for ambiguity up to the given length.\n * It is ambiguous if it is not a complete string and there are other\n * keys following it with the same leading substring.\n */\n", "func_signal": "static TBOOLEAN\nAmbiguous(KEY *key, size_t len)", "code": "{\n    char *first;\n    char *prev;\n    TBOOLEAN status = FALSE;\t/* assume not ambiguous */\n    int compare;\n    size_t sublen;\n\n    if (key->key[len] == NUL)\n\treturn (FALSE);\n\n    for (prev = first = key->key, compare = 0, key++;\n\t key->key != NULL && compare == 0; key++) {\n\tcompare = strncmp(first, key->key, len);\n\tif (compare == 0) {\n\t    /* So this key matches the first one, up to len.\n\t     * But is it different enough from the previous one\n\t     * to bother printing it as a separate choice?\n\t     */\n\t    sublen = strcspn(prev + len, \" \");\n\t    if (strncmp(key->key, prev, len + sublen) != 0) {\n\t\t/* yup, this is different up to the next space */\n\t\tif (!status) {\n\t\t    /* first one we have printed is special */\n\t\t    fprintf(stderr,\n\t\t\t    \"Ambiguous request '%.*s'; possible matches:\\n\",\n\t\t\t    (int)len, first);\n\t\t    fprintf(stderr, \"\\t%s\\n\", prev);\n\t\t    status = TRUE;\n\t\t}\n\t\tfprintf(stderr, \"\\t%s\\n\", key->key);\n\t\tprev = key->key;\n\t    }\n\t}\n    }\n\n    return (status);\n}", "path": "src\\help.c", "repo_name": "zsx/gnuplot", "stars": 2, "license": "other", "language": "c", "size": 18212}
{"docstring": "/**\n * This callback is called on any response message in the lifespan of\n * the dialog. The callback is called just before the message is\n * copied to pkg memory so it is still mutable.\n *\n * @param did - The dialog structure. The pointer is used as an ID.\n * @param type - The reason for the callback. DLGCB_CONFIRMED\n * @param msg - The SIP message that causes the callback.\n * @param param - The sst information\n */\n", "func_signal": "static void sst_dialog_response_fwded_CB(struct dlg_cell* did, int type,\n\t\tstruct sip_msg* msg, void** param)", "code": "{\n\t/*\n\t * This test to see if the message is a response sould ALWAYS be\n\t * true. This callback should not get called for requests. But\n\t * lets be safe.\n\t */\n\tif (msg->first_line.type == SIP_REPLY) {\n\t\tsst_msg_info_t minfo = {0,0,0,0};\n\t\tsst_info_t *info = (sst_info_t *)*param;\n\n\t\tLM_DBG(\"Dialog seen REPLY %d %.*s\\n\", \n\t\t\t\tmsg->first_line.u.reply.statuscode,\n\t\t\t\tmsg->first_line.u.reply.reason.len, \n\t\t\t\tmsg->first_line.u.reply.reason.s);\n\t\t/*\n\t\t * Need to check to see if it is a 422 response. If it is,\n\t\t * make sure our Min-SE: for this dialog is set at least as\n\t\t * large as in the Min-SE: in the reply 422 message. If not,\n\t\t * we will create an INVITE, 422 loop.\n\t\t */\n\t\tif (msg->first_line.u.reply.statuscode == 422) {\n\t\t\tif (parse_msg_for_sst_info(msg, &minfo)) {\n\t\t\t\tLM_ERR(\"failed to prase sst information for thr 422 reply\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Make sure we do not try to use anything smaller */\n\t\t\tinfo->interval = MAX(info->interval, minfo.min_se);\n\t\t\treturn; /* There is nothing else to do with this */\n\t\t}\n\t\t/*\n\t\t * We need to get the method this reply is for from the CSEQ\n\t\t * body. The RFC states we can only play with 2XX from the\n\t\t * INVITE or reINVTE/UPDATE.\n\t\t */\n\t\tif (!msg->cseq && ((parse_headers(msg, HDR_CSEQ_F, 0) == -1) || !msg->cseq)) {\n\t\t\tLM_ERR(\"failed to parse CSeq\\n\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t/* 2XX replies to INVITES only !*/\n\t\tif (msg->first_line.u.reply.statuscode > 199 &&\n\t\t\t\tmsg->first_line.u.reply.statuscode < 300 &&\n\t\t\t\t(get_cseq(msg)->method_id == METHOD_INVITE ||\n\t\t\t\t\t\tget_cseq(msg)->method_id == METHOD_UPDATE)) {\n\t\t\tif (parse_msg_for_sst_info(msg, &minfo)) {\n\t\t\t\tLM_ERR(\"failed to parse sst information for the 2XX reply\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (minfo.se != 0) {\n\t\t\t\tif (set_timeout_avp(msg, info->interval)) {\n\t\t\t\t\t// FIXME: need an error message here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* no se header found, we want to resquest it. */\n\t\t\t\tif (info->requester == SST_PXY || info->supported == SST_UAC) {\n\t\t\t\t\tchar se_buf[80];\n\t\t\t\t\t\n\t\t\t\t\tLM_DBG(\"appending the Session-Expires: header to the 2XX reply.\"\n\t\t\t\t\t\t\t\" UAC will deal with it.\\n\");\n\t\t\t\t\t/*\n\t\t\t\t\t * GOOD! we can just insert the Session-Expires:\n\t\t\t\t\t * header and forward back to the UAC and it will\n\t\t\t\t\t * deal with refreshing the session.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(se_buf, 80, \"Session-Expires: %d;refresher=uac\\r\\n\", \n\t\t\t\t\t\t\tinfo->interval);\n\t\t\t\t\tif (append_header(msg, se_buf)) {\n\t\t\t\t\t\tLM_ERR(\"failed to append Session-Expires header\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t/* Set the dialog timeout HERE */\n\t\t\t\t\tif (set_timeout_avp(msg, info->interval)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* We are sunk, uac did not request it, and it\n\t\t\t\t\t * does not support it */\n\t\t\t\t\tLM_DBG(\"UAC and UAS do not support timers!\"\n\t\t\t\t\t\t\t\" No session timers for this session.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} /* End of 2XX for an INVITE */\n\t} /* If the msg is a repsonse and not a request */\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* return system version (major.minor.minor2) as\n *  (major<<16)|(minor)<<8|(minor2)\n * (if some of them are missing, they are set to 0)\n * if the parameters are not null they are set to the coresp. part \n */\n", "func_signal": "static unsigned int get_sys_version(int* major, int* minor, int* minor2)", "code": "{\n\tstruct utsname un;\n\tint m1;\n\tint m2;\n\tint m3;\n\tchar* p;\n\t\n\tmemset (&un, 0, sizeof(un));\n\tm1=m2=m3=0;\n\t/* get sys version */\n\tuname(&un);\n\tm1=strtol(un.release, &p, 10);\n\tif (*p=='.'){\n\t\tp++;\n\t\tm2=strtol(p, &p, 10);\n\t\tif (*p=='.'){\n\t\t\tp++;\n\t\t\tm3=strtol(p, &p, 10);\n\t\t}\n\t}\n\tif (major) *major=m1;\n\tif (minor) *minor=m2;\n\tif (minor2) *minor2=m3;\n\treturn ((m1<<16)|(m2<<8)|(m3));\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/*\n * returns 0 on success, and an error message on error\n */\n", "func_signal": "char* check_poll_method(enum poll_types poll_method)", "code": "{\n\tchar* ret;\n\tunsigned int os_ver;\n\n\tret=0;\n\tos_ver=get_sys_version(0,0,0);\t\n\tswitch(poll_method){\n\t\tcase POLL_NONE:\n\t\t\tbreak;\n\t\tcase POLL_POLL:\n\t\t\t/* always supported */\n\t\t\tbreak;\n\t\tcase POLL_SELECT:\n\t\t\t/* should be always supported */\n#ifndef HAVE_SELECT\n\t\t\tret=\"select not supported, try re-compiling with -DHAVE_SELECT\";\n#endif\n\t\t\tbreak;\n\t\tcase POLL_EPOLL_LT:\n\t\tcase POLL_EPOLL_ET:\n#ifndef HAVE_EPOLL\n\t\t\tret=\"epoll not supported, try re-compiling with -DHAVE_EPOLL\";\n#else\n\t\t\t/* only on 2.6 + */\n\t\t\tif (os_ver<0x020542) /* if ver < 2.5.66 */\n\t\t\t \tret=\"epoll not supported on kernels < 2.6\";\n#endif\n\t\t\tbreak;\n\t\tcase POLL_SIGIO_RT:\n#ifndef HAVE_SIGIO_RT\n\t\t\tret=\"sigio_rt not supported, try re-compiling with\"\n\t\t\t\t\" -DHAVE_SIGIO_RT\";\n#else\n\t\t\t/* only on 2.2 +  ?? */\n\t\t\tif (os_ver<0x020200) /* if ver < 2.2.0 */\n\t\t\t \tret=\"epoll not supported on kernels < 2.2 (?)\";\n#endif\n\t\t\tbreak;\n\t\tcase POLL_KQUEUE:\n#ifndef HAVE_KQUEUE\n\t\t\tret=\"kqueue not supported, try re-compiling with -DHAVE_KQUEUE\";\n#else\n\t\t/* only in FreeBSD 4.1, NETBSD 2.0, OpenBSD 2.9, Darwin */\n\t#ifdef __OS_freebsd\n\t\t\tif (os_ver<0x0401) /* if ver < 4.1 */\n\t\t\t\tret=\"kqueue not supported on FreeBSD < 4.1\";\n\t#elif defined (__OS_netbsd)\n\t\t\tif (os_ver<0x020000) /* if ver < 2.0 */\n\t\t\t\tret=\"kqueue not supported on NetBSD < 2.0\";\n\t#elif defined (__OS_openbsd)\n\t\t\tif (os_ver<0x0209) /* if ver < 2.9 ? */\n\t\t\t\tret=\"kqueue not supported on OpenBSD < 2.9 (?)\";\n\t#endif /* assume that the rest support kqueue ifdef HAVE_KQUEUE */\n#endif\n\t\t\tbreak;\n\t\tcase POLL_DEVPOLL:\n#ifndef HAVE_DEVPOLL\n\t\t\tret=\"/dev/poll not supported, try re-compiling with\"\n\t\t\t\t\t\" -DHAVE_DEVPOLL\";\n#else\n\t/* only in Solaris >= 7.0 (?) */\n\t#ifdef __OS_solaris\n\t\tif (os_ver<0x0507) /* ver < 5.7 */\n\t\t\tret=\"/dev/poll not supported on Solaris < 7.0 (SunOS 5.7)\";\n\t#endif\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret=\"unknown not supported method\";\n\t}\n\treturn ret;\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Given some header text, append it to the passed in message.\n *\n * @param msg The message to append the header text to.\n * @param header The header text to append.\n *\n * @return 0 on success, non-zero on failure.\n */\n", "func_signal": "static int append_header(struct sip_msg *msg, const char *header)", "code": "{\n\tstruct lump* anchor = NULL;\n\tchar *s = NULL;\n\tint len = 0;\n\n\tLM_DBG(\"Appending header: %s\", header);\n\n\tif (parse_headers(msg, HDR_EOH_F, 0) == -1) {\n\t\tLM_ERR(\"failed to parse headers in message.\\n\");\n\t\treturn(1);\n\t}\n\n\tif ((anchor = anchor_lump(msg, msg->unparsed - msg->buf, 0, 0)) == 0) {\n\t\tLM_ERR(\"failed to get anchor to append header\\n\");\n\t\treturn(1);\n\t}\n\tlen = strlen(header);\n\tif ((s = (char *)pkg_malloc(len)) == 0) {\n\t\tLM_ERR(\"No more pkg memory. (size requested = %d)\\n\", len);\n\t\treturn(1);\n\t}\n\tmemcpy(s, header, len);\n\tif (insert_new_lump_before(anchor, s, len, 0) == 0) {\n\t\tLM_ERR(\"failed to insert lump\\n\");\n\t\tpkg_free(s);\n\t\treturn(1);\n\t}\n\tLM_DBG(\"Done appending header successfully.\\n\");\n\treturn(0);\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* sigio specific destroy */\n", "func_signal": "static void destroy_sigio(io_wait_h* h)", "code": "{\n\tif (h->signo){\n\t\tsigprocmask(SIG_UNBLOCK, &h->sset, 0);\n\t\tsigemptyset(&h->sset);\n\t\tsigdelset(&_sigio_rtsig_used, h->signo);\n\t\th->signo=0;\n\t}\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Send a reply (response) to the passed in SIP request messsage with\n * the code and reason. If the header is not NULL (and header_len !=\n * 0) the add the header to the reply message.\n *\n * @param request The SIP request message to build the reply from.\n * @param code The response code. i.e 200\n * @param reason The response reason. i.e. \"OK\"\n * @param header the header block to add to the reply.\n * @param header_len The length of the header block. (header)\n *\n * @return 0 on success, none-zero on an error.\n */\n", "func_signal": "static int send_response(struct sip_msg *request, int code, str *reason,\n\t\tchar *header, int header_len)", "code": "{\n\n\tif (slb.reply != 0) {\n\t\t/* Add new headers if not null or zero length */\n\t\tif ((header) && (header_len)) {\n\t\t\tif (add_lump_rpl(request, header, header_len, LUMP_RPL_HDR) == 0) {\n\t\t\t\t/* An error with adding the lump */\n\t\t\t\tLM_ERR(\"unable to append header.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* Now using the sl function, send the reply/response */\n\t\tif (slb.reply(request, code, reason) < 0) {\n\t\t\tLM_ERR(\"Unable to sent reply.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\treturn(0);\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * This callback is called when ever a dialog is terminated. The cause\n * of the termination can be normal, failed call, or expired. It is\n * the expired dialog we are really interested in.\n *\n * @param did - The Dialog ID / structure pointer. Used as an ID only.\n * @param type - The termination cause/reason.\n * @param msg - The pointer to the SIP message. On an DLGCB_EXPIRED type, the\n *              message is a FAKED_REPLY (-1) and cannot be looked at safely.\n * @param param - Not used\n */\n", "func_signal": "static void sst_dialog_terminate_CB(struct dlg_cell* did, int type,\n\t\tstruct sip_msg* msg, void** param)", "code": "{\n\tswitch (type) {\n\t\tcase DLGCB_FAILED:\n\t\t\tLM_ERR(\"DID %p failed (canceled). \"\n\t\t\t\t\t\"Terminating session.\\n\", did);\n\t\t\tbreak;\n\t\tcase DLGCB_EXPIRED:\n\t\t\t/* In the case of expired, the msg is pointing at a\n\t\t\t * FAKED_REPLY (-1)\n\t\t\t */\n\t\t\tLM_ERR(\"Terminating session.\\n\");\n\t\t\tbreak;\n\t\tdefault: /* Normal termination. */\n\t\t\tLM_DBG(\"Terminating DID %p session\\n\", did);\n\t\t\tbreak;\n\t}\n\t/*\n\t * Free the param sst_info_t memory\n\t */\n\tif (*param) {\n\t\tLM_DBG(\"freeing the sst_info_t from dialog %p\\n\", did);\n\t\tshm_free(*param);\n\t\t*param = NULL;\n\t}\n\treturn;\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* initializes the static vars/arrays\n * params:      h - pointer to the io_wait_h that will be initialized\n *         max_fd - maximum allowed fd number\n *         poll_m - poll method (0 for automatic best fit)\n */\n", "func_signal": "int init_io_wait(io_wait_h* h, int max_fd, enum poll_types poll_method)", "code": "{\n\tchar * poll_err;\n\t\n\tmemset(h, 0, sizeof(*h));\n\th->max_fd_no=max_fd;\n#ifdef HAVE_EPOLL\n\th->epfd=-1;\n#endif\n#ifdef HAVE_KQUEUE\n\th->kq_fd=-1;\n#endif\n#ifdef HAVE_DEVPOLL\n\th->dpoll_fd=-1;\n#endif\n\tpoll_err=check_poll_method(poll_method);\n\t\n\t/* set an appropiate poll method */\n\tif (poll_err || (poll_method==0)){\n\t\tpoll_method=choose_poll_method();\n\t\tif (poll_err){\n\t\t\tLM_ERR(\"%s, using %s instead\\n\",\n\t\t\t\t\tpoll_err, poll_method_str[poll_method]);\n\t\t}else{\n\t\t\tLM_INFO(\"using %s as the io watch method\"\n\t\t\t\t\t\" (auto detected)\\n\", poll_method_str[poll_method]);\n\t\t}\n\t}\n\t\n\th->poll_method=poll_method;\n\t\n\t/* common stuff, everybody has fd_hash */\n\th->fd_hash=local_malloc(sizeof(*(h->fd_hash))*h->max_fd_no);\n\tif (h->fd_hash==0){\n\t\tLM_CRIT(\"could not alloc fd hashtable (%ld bytes)\\n\",\n\t\t\t\t\t(long)sizeof(*(h->fd_hash))*h->max_fd_no );\n\t\tgoto error;\n\t}\n\tmemset((void*)h->fd_hash, 0, sizeof(*(h->fd_hash))*h->max_fd_no);\n\t\n\tswitch(poll_method){\n\t\tcase POLL_POLL:\n#ifdef HAVE_SELECT\n\t\tcase POLL_SELECT:\n#endif\n#ifdef HAVE_SIGIO_RT\n\t\tcase POLL_SIGIO_RT:\n#endif\n#ifdef HAVE_DEVPOLL\n\t\tcase POLL_DEVPOLL:\n#endif\n\t\t\th->fd_array=local_malloc(sizeof(*(h->fd_array))*h->max_fd_no);\n\t\t\tif (h->fd_array==0){\n\t\t\t\tLM_CRIT(\"could not alloc fd array (%ld bytes)\\n\",\n\t\t\t\t\t\t\t(long)sizeof(*(h->fd_hash))*h->max_fd_no);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset((void*)h->fd_array, 0, sizeof(*(h->fd_array))*h->max_fd_no);\n#ifdef HAVE_SIGIO_RT\n\t\t\tif ((poll_method==POLL_SIGIO_RT) && (init_sigio(h, 0)<0)){\n\t\t\t\tLM_CRIT(\"sigio init failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n#endif\n#ifdef HAVE_DEVPOLL\n\t\t\tif ((poll_method==POLL_DEVPOLL) && (init_devpoll(h)<0)){\n\t\t\t\tLM_CRIT(\"/dev/poll init failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n#endif\n#ifdef HAVE_SELECT\n\t\t\tif ((poll_method==POLL_SELECT) && (init_select(h)<0)){\n\t\t\t\tLM_CRIT(\"select init failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n#endif\n\t\t\t\n\t\t\tbreak;\n#ifdef HAVE_EPOLL\n\t\tcase POLL_EPOLL_LT:\n\t\tcase POLL_EPOLL_ET:\n\t\t\th->ep_array=local_malloc(sizeof(*(h->ep_array))*h->max_fd_no);\n\t\t\tif (h->ep_array==0){\n\t\t\t\tLM_CRIT(\"could not alloc epoll array\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset((void*)h->ep_array, 0, sizeof(*(h->ep_array))*h->max_fd_no);\n\t\t\tif (init_epoll(h)<0){\n\t\t\t\tLM_CRIT(\"epoll init failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef HAVE_KQUEUE\n\t\tcase POLL_KQUEUE:\n\t\t\th->kq_array=local_malloc(sizeof(*(h->kq_array))*h->max_fd_no);\n\t\t\tif (h->kq_array==0){\n\t\t\t\tLM_CRIT(\"could not alloc kqueue event array\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\th->kq_changes_size=KQ_CHANGES_ARRAY_SIZE;\n\t\t\th->kq_changes=local_malloc(sizeof(*(h->kq_changes))*\n\t\t\t\t\t\t\t\t\t\th->kq_changes_size);\n\t\t\tif (h->kq_changes==0){\n\t\t\t\tLM_CRIT(\"could not alloc kqueue changes array\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\th->kq_nchanges=0;\n\t\t\tmemset((void*)h->kq_array, 0, sizeof(*(h->kq_array))*h->max_fd_no);\n\t\t\tmemset((void*)h->kq_changes, 0,\n\t\t\t\t\t\tsizeof(*(h->kq_changes))* h->kq_changes_size);\n\t\t\tif (init_kqueue(h)<0){\n\t\t\t\tLM_CRIT(\"kqueue init failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tLM_CRIT(\"unknown/unsupported poll method %s (%d)\\n\",\n\t\t\t\t\t\tpoll_method_str[poll_method], poll_method);\n\t\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* destroys everything init_io_wait allocated */\n", "func_signal": "void destroy_io_wait(io_wait_h* h)", "code": "{\n\tswitch(h->poll_method){\n#ifdef HAVE_EPOLL\n\t\tcase POLL_EPOLL_LT:\n\t\tcase POLL_EPOLL_ET:\n\t\t\tdestroy_epoll(h);\n\t\t\tif (h->ep_array){\n\t\t\t\tlocal_free(h->ep_array);\n\t\t\t\th->ep_array=0;\n\t\t\t}\n\t\tbreak;\n#endif\n#ifdef HAVE_KQUEUE\n\t\tcase POLL_KQUEUE:\n\t\t\tdestroy_kqueue(h);\n\t\t\tif (h->kq_array){\n\t\t\t\tlocal_free(h->kq_array);\n\t\t\t\th->kq_array=0;\n\t\t\t}\n\t\t\tif (h->kq_changes){\n\t\t\t\tlocal_free(h->kq_changes);\n\t\t\t\th->kq_changes=0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef HAVE_SIGIO_RT\n\t\tcase POLL_SIGIO_RT:\n\t\t\tdestroy_sigio(h);\n\t\t\tbreak;\n#endif\n#ifdef HAVE_DEVPOLL\n\t\tcase POLL_DEVPOLL:\n\t\t\tdestroy_devpoll(h);\n\t\t\tbreak;\n#endif\n\t\tdefault: /*do  nothing*/\n\t\t\t;\n\t}\n\t\tif (h->fd_array){\n\t\t\tlocal_free(h->fd_array);\n\t\t\th->fd_array=0;\n\t\t}\n\t\tif (h->fd_hash){\n\t\t\tlocal_free(h->fd_hash);\n\t\t\th->fd_hash=0;\n\t\t}\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * This is not a public API. This function is called when the module\n * is loaded from the mod_init() function in sst.c to initialize the\n * callback handlers and local variables.\n *\n * @param timeout_avp_p - The pointer to the dialog modules timeout\n *                        AVP.\n * @param minSE - The minimum session expire value allowed by this\n *                PROXY.\n */\n", "func_signal": "void sst_handler_init(pv_spec_t *timeout_avp_p, unsigned int min_se, \n\t\tint flag, unsigned int reject)", "code": "{\n\ttimeout_avp = timeout_avp_p;\n\tsst_min_se = min_se;\n\tsst_flag = 1 << flag;\n\tsst_reject = reject;\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* kqueue specific init\n * returns -1 on error, 0 on success */\n", "func_signal": "static int init_kqueue(io_wait_h* h)", "code": "{\nagain:\n\th->kq_fd=kqueue();\n\tif (h->kq_fd==-1){\n\t\tif (errno==EINTR) goto again;\n\t\tLM_ERR(\"kqueue: %s [%d]\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* converts a string into a poll_method\n * returns POLL_NONE (0) on error, else the corresponding poll type */\n", "func_signal": "enum poll_types get_poll_type(char* s)", "code": "{\n\tint r;\n\tunsigned int l;\n\t\n\tl=strlen(s);\n\tfor (r=POLL_END-1; r>POLL_NONE; r--)\n\t\tif ((strlen(poll_method_str[r])==l) &&\n\t\t\t(strncasecmp(poll_method_str[r], s, l)==0))\n\t\t\tbreak;\n\treturn r; \n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Callback from the dialog module when the dialog is being updated in\n * its life span. We are only interested in the INVITE or UPDATE if\n * SST is supported and active for this dialog. In this case, we need\n * to update the expire time for the dialog based on the\n * Session-Expires: header in the reINVITE/UPDATE request.\n *\n * When this callback returns control to the dialog module it WILL\n * reset the timeout of the dialog. We need to make sure we set the\n * AVP here or the dialog timeout will be reset to the DEFAULT value\n * if this is a different transaction. (so the AVP value is gone)\n *\n * @param did - The dialog structure. The pointer is used as an ID.\n * @param type - The reason for the callback. DLGCB_REQ_WITHIN\n * @param msg - The SIP message that causes the callback.\n * @param param - The sst information\n */\n", "func_signal": "static void sst_dialog_request_within_CB(struct dlg_cell* did, int type,\n\t\tstruct sip_msg* msg, void** param)", "code": "{\n\tsst_info_t *info = (sst_info_t *)*param;\n\tsst_msg_info_t minfo = {0,0,0,0};\n\n\tif (msg->first_line.type == SIP_REQUEST) {\n\t\tif ((msg->first_line.u.request.method_value == METHOD_INVITE ||\n\t\t\t\t\t\tmsg->first_line.u.request.method_value == METHOD_UPDATE)) {\n\n\t\t\tLM_DBG(\"Update by a REQUEST. %.*s\\n\", \n\t\t\t\t\tmsg->first_line.u.request.method.len, \n\t\t\t\t\tmsg->first_line.u.request.method.s);\n\t\t\tif (parse_msg_for_sst_info(msg, &minfo)) {\n\t\t\t\t// FIXME: need an error message here\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Early resetting of the value here */\n\t\t\tset_timeout_avp(msg, minfo.se);\n\t\t\tinfo->interval = minfo.se;\n\t\t}\n\t\telse if (msg->first_line.u.request.method_value == METHOD_PRACK) {\n\t\t\t/* Special case here. The PRACK will cause the dialog\n\t\t\t * module to reset the timeout value to the ldg->lifetime\n\t\t\t * value and look for the new AVP value bound to the\n\t\t\t * 1XX/PRACK/200OK/ACK transaction and not to the\n\t\t\t * INVITE/200OK avp value. So we need to set the AVP\n\t\t\t * again! I think this is a bug in the dialog module,\n\t\t\t * either it should ignore PRACK like it ignored ACK, or\n\t\t\t * the setting of the timeout value when returning to the\n\t\t\t * confiremed callback code should look for the new AVP\n\t\t\t * value, which is does not.\n\t\t\t */\n\t\t\tLM_DBG(\"PRACK workaround applied!\\n\");\n\t\t\tset_timeout_avp(msg, info->interval);\n\t\t}\n\t}\n\telse if (msg->first_line.type == SIP_REPLY) {\n\t\tif ((msg->first_line.u.reply.statuscode > 199 &&\n\t\t\t\t\t\tmsg->first_line.u.reply.statuscode < 300)) {\n\t\t\t/*\n\t\t\t * To spec (RFC) the internal time out value so not be reset\n\t\t\t * until here.\n\t\t\t */\n\t\t\tLM_DBG(\"Update by a REPLY %d %.*s\\n\", \n\t\t\t\t\tmsg->first_line.u.reply.statuscode,\n\t\t\t\t\tmsg->first_line.u.reply.reason.len, \n\t\t\t\t\tmsg->first_line.u.reply.reason.s);\n\t\t\tif (parse_msg_for_sst_info(msg, &minfo)) {\n\t\t\t\t// FIXME: need an error message here\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_timeout_avp(msg, minfo.se);\n\t\t\tinfo->interval = minfo.se;\n\t\t}\n\t}\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* /dev/poll specific init\n * returns -1 on error, 0 on success */\n", "func_signal": "static int init_devpoll(io_wait_h* h)", "code": "{\nagain:\n\th->dpoll_fd=open(\"/dev/poll\", O_RDWR);\n\tif (h->dpoll_fd==-1){\n\t\tif (errno==EINTR) goto again;\n\t\tLM_ERR(\"open: %s [%d]\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Add the Min-SE: header and send a reply 422.\n *\n * @param msg The message to opperate on.\n * @param min_se The Min-SE: value to use in the heaader.\n *\n * @return 0 on success, -1 on error.\n */\n", "func_signal": "static int send_reject(struct sip_msg *msg, unsigned int min_se)", "code": "{\n\tchar tmp[2]; /* to find the length */\n\tint hdr_len = 0;\n\tchar *minse_hdr = NULL;\n\n\thdr_len = snprintf(tmp, 2, \"%s %d\", \"MIN-SE:\", min_se);\n\tif ((minse_hdr = pkg_malloc(hdr_len+1)) != NULL) {\n\t\tmemset(minse_hdr, 0, hdr_len+1);\n\t\tsnprintf(minse_hdr, hdr_len+1, \"%s %d\", \"MIN-SE:\", min_se);\n\t\tif (send_response(msg, 422, &sst_422_rpl, minse_hdr, hdr_len)) {\n\t\t\tLM_ERR(\"Error sending 422 reply.\\n\");\n\t\t\treturn(-1);\n\t\t}\n\t\tpkg_free(minse_hdr);\n\t\tLM_DBG(\"Send reject reply 422 with Min-SE: %d\\n\", min_se);\n\t\treturn(0);\n\t}\n\treturn(-1);\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Gether the message information about SST from the current message\n * being processed.\n *\n * @param msg The current message to parse.\n * @param minfo The SST information found in the message.\n *\n * @return 0 on success, -1 on a parsing error.\n */\n", "func_signal": "static int parse_msg_for_sst_info(struct sip_msg *msg, sst_msg_info_t *minfo)", "code": "{\n\tint rtn = 0;\n\tstruct session_expires se = {0,0};\n\n\tif (!msg || !minfo) {\n\t\treturn (-1);\n\t}\n\t\n\t/* \n\t * parse the supported infor\n\t */\n\tminfo->supported = 0; /*Clear it */\n\tminfo->se = 0;\n\tminfo->refresher = sst_refresher_unspecified;\n\tminfo->min_se = 0;\n\n\t/*\n\t * The parse_supported() will return 0 if found and parsed OK, -1\n\t * if not found or an error parsing the one it did find! So assume\n\t * it is not found if unsuccessfull.\n\t */\n\tif ((rtn = parse_supported(msg)) == 0) {\n\t\tif ((((struct supported_body*)msg->supported->parsed)->supported_all\n\t\t\t\t\t\t& F_SUPPORTED_TIMER)) {\n\t\t\tminfo->supported = 1;\n\t\t}\n\t}\n\t/*\n\t * Parse the Min-SE: header next.\n\t */\n\tminfo->min_se = 0;\n\tif ((rtn = parse_min_se(msg, &minfo->min_se)) != parse_sst_success) {\n\t\tminfo->min_se = 0; /* Make sure it statys clean */\n\t}\n\tminfo->se = 0;\n\tif ((rtn = parse_session_expires(msg, &se)) == parse_sst_success) {\n\t\tminfo->se = se.interval;\n\t\tminfo->refresher = se.refresher;\n\t}\n\treturn(0);\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Remove a header from a message if found.\n *\n * @param msg The message to look for the header to remove.\n * @param header The header name: text.\n *\n * @return 0 if the header was not found, >0 is successful, -1 on an\n *         error.\n */\n", "func_signal": "static int remove_header(struct sip_msg *msg, const char *header)", "code": "{\n\tstruct lump* anchor = NULL;\n\tstruct hdr_field *hf = NULL;\n\tint cnt = 0;\n\tint len = strlen(header);\n\n\tif (parse_headers(msg, HDR_EOH_F, 0) == -1) {\n\t\tLM_ERR(\"failed to parse headers in message.\\n\");\n\t\treturn(-1);\n\t}\n\t\n\tfor (hf = msg->headers; hf; hf = hf->next) {\n\t\tif (hf->name.len != len) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(hf->name.s, header, hf->name.len) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tanchor = del_lump(msg, hf->name.s-msg->buf, hf->len, 0);\n\t\tif (anchor == 0) {\n\t\t\tLM_ERR(\"no more pkg memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tcnt++;\n\t}\n\treturn cnt;\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/**\n * Play time. Please ignore this call.\n */\n", "func_signal": "static void sst_dialog_confirmed_CB(struct dlg_cell *did, int type,\n\t\tstruct sip_msg* msg, void** param)", "code": "{\n\tLM_DBG(\"confirmed dialog CB %p\\n\", did);\n\tDLOGMSG(msg);\n}", "path": "modules\\sst\\sst_handlers.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* epoll specific init\n * returns -1 on error, 0 on success */\n", "func_signal": "static int init_epoll(io_wait_h* h)", "code": "{\nagain:\n\th->epfd=epoll_create(h->max_fd_no);\n\tif (h->epfd==-1){\n\t\tif (errno==EINTR) goto again;\n\t\tLM_ERR(\"epoll_create: %s [%d]\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "io_wait.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/*\n * Convert in argument string each LFLF to CRLF and return length of\n * the string not including the terminating `\\0' character.\n * This is a hack that is needed as long as Abyss XML-RPC server \"normalizes\"\n * CRLF to LF in XML-RPC strings. \n */\n", "func_signal": "int lflf_to_crlf_hack(char *s)", "code": "{\n\n    unsigned int len;\n\n    len = 0;\n\n    while (*s) {\n\tif (*(s + 1) && (*s == '\\n') && *(s + 1) == '\\n') {\n\t    *s = '\\r';\n\t    s = s + 2;\n\t    len = len + 2;\n\t} else {\n\t    s++;\n\t    len++;\n\t}\n    }\n\n    return len;\n}", "path": "modules\\mi_xmlrpc\\xr_parser.c", "repo_name": "eliasbaixas/openser-xmlrpc", "stars": 3, "license": "other", "language": "c", "size": 6864}
{"docstring": "/* Returns debugging information about the value as a string of comma-separated\n * values in angle brackets with a leading #:\n *\n * BigDecimal.new(\"1234.5678\").inspect ->\n * \"#<BigDecimal:b7ea1130,'0.12345678E4',8(12)>\"\n *\n * The first part is the address, the second is the value as a string, and\n * the final part ss(mm) is the current number of significant digits and the\n * maximum number of significant digits, respectively.\n */\n", "func_signal": "static VALUE\nBigDecimal_inspect(VALUE self)", "code": "{\n    ENTER(5);\n    Real *vp;\n    volatile VALUE obj;\n    unsigned int nc;\n    char *psz, *tmp;\n\n    GUARD_OBJ(vp,GetVpValue(self,1));\n    nc = VpNumOfChars(vp,\"E\");\n    nc +=(nc + 9) / 10;\n\n    obj = rb_str_new(0, nc+256);\n    psz = RSTRING_PTR(obj);\n    sprintf(psz,\"#<BigDecimal:%lx,'\",self);\n    tmp = psz + strlen(psz);\n    VpToString(vp, tmp, 10, 0);\n    tmp += strlen(tmp);\n    sprintf(tmp,\"',%lu(%lu)>\",VpPrec(vp)*VpBaseFig(),VpMaxPrec(vp)*VpBaseFig());\n    rb_str_resize(obj, strlen(psz));\n    return obj;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* If exponent overflows,then raise exception or returns 0 */\n", "func_signal": "static int\nAddExponent(Real *a,S_INT n)", "code": "{\n    S_INT e = a->exponent;\n    S_INT m = e+n;\n    S_INT eb,mb;\n    if(e>0) {\n        if(n>0) {\n            mb = m*BASE_FIG;\n            eb = e*BASE_FIG;\n            if(mb<eb) goto overflow;\n        }\n    } else if(n<0) {\n        mb = m*BASE_FIG;\n        eb = e*BASE_FIG;\n        if(mb>eb) goto underflow;\n    }\n    a->exponent = m;\n    return 1;\n\n/* Overflow/Underflow ==> Raise exception or returns 0 */\nunderflow:\n    VpSetZero(a,VpGetSign(a));\n    return VpException(VP_EXCEPTION_UNDERFLOW,\"Exponent underflow\",0);\n\noverflow:\n    VpSetInf(a,VpGetSign(a));\n    return VpException(VP_EXCEPTION_OVERFLOW,\"Exponent overflow\",0);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* call-seq:\n * precs\n *\n * Returns an Array of two Integer values.\n *\n * The first value is the current number of significant digits in the \n * BigDecimal. The second value is the maximum number of significant digits\n * for the BigDecimal.\n */\n", "func_signal": "static VALUE\nBigDecimal_prec(VALUE self)", "code": "{\n    ENTER(1);\n    Real *p;\n    VALUE obj;\n\n    GUARD_OBJ(p,GetVpValue(self,1));\n    obj = rb_assoc_new(INT2NUM(p->Prec*VpBaseFig()),\n\t\t       INT2NUM(p->MaxPrec*VpBaseFig()));\n    return obj;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n * m <- d\n */\n", "func_signal": "VP_EXPORT void\nVpDtoV(Real *m, double d)", "code": "{\n    U_LONG i, ind_m, mm;\n    U_LONG ne;\n    double  val, val2;\n\n    if(isnan(d)) {\n        VpSetNaN(m);\n        goto Exit;\n    }\n    if(isinf(d)) {\n        if(d>0.0) VpSetPosInf(m);\n        else   VpSetNegInf(m);\n        goto Exit;\n    }\n\n    if(d == 0.0) {\n        VpSetZero(m,1);\n        goto Exit;\n    }\n    val =(d > 0.) ? d :(-d);\n    ne = 0;\n    if(val >= 1.0) {\n        while(val >= 1.0) {\n            val /=(double)((S_INT)BASE);\n            ++ne;\n        }\n    } else {\n        val2 = 1.0 /(double)((S_INT)BASE);\n        while(val < val2) {\n            val *=(double)((S_INT)BASE);\n            --ne;\n        }\n    }\n    /* Now val = 0.xxxxx*BASE**ne */\n\n    mm = m->MaxPrec;\n    memset(m->frac, 0, mm * sizeof(U_LONG));\n    for(ind_m = 0;val > 0.0 && ind_m < mm;ind_m++) {\n        val *=(double)((S_INT)BASE);\n        i =(U_LONG) val;\n        val -=(double)((S_INT)i);\n        m->frac[ind_m] = i;\n    }\n    if(ind_m >= mm) ind_m = mm - 1;\n    if(d > 0.0) {\n        VpSetSign(m, (S_INT)1);\n    } else {\n        VpSetSign(m,-(S_INT)1);\n    }\n    m->Prec = ind_m + 1;\n    m->exponent = ne;\n\n    VpInternalRound(m,0,(m->Prec>0)?m->frac[m->Prec-1]:0,\n                      (U_LONG)(val*((double)((S_INT)BASE))));\n\nExit:\n#ifdef _DEBUG\n    if(gfDebug) {\n        printf(\"VpDtoV d=%30.30e\\n\", d);\n        VPrint(stdout, \"  m=%\\n\", m);\n    }\n#endif /* _DEBUG */\n    return;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* Returns True if the value is Not a Number */\n", "func_signal": "static VALUE\nBigDecimal_IsNaN(VALUE self)", "code": "{\n    Real *p = GetVpValue(self,1);\n    if(VpIsNaN(p))  return Qtrue;\n    return Qfalse;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* Returns the value as an integer (Fixnum or Bignum).\n *\n * If the BigNumber is infinity or NaN, returns nil.\n */\n", "func_signal": "static VALUE\nBigDecimal_to_i(VALUE self)", "code": "{\n    ENTER(5);\n    int e,n,i,nf;\n    U_LONG v,b,j;\n    volatile VALUE str;\n    char *psz,*pch;\n    Real *p;\n\n    GUARD_OBJ(p,GetVpValue(self,1));\n    BigDecimal_check_num(p);\n\n    e = VpExponent10(p);\n    if(e<=0) return INT2FIX(0);\n    nf = VpBaseFig();\n    if(e<=nf) {\n        e = VpGetSign(p)*p->frac[0];\n        return INT2FIX(e);\n    }\n    str = rb_str_new(0, e+nf+2);\n    psz = RSTRING_PTR(str);\n\n    n = (e+nf-1)/nf;\n    pch = psz;\n    if(VpGetSign(p)<0) *pch++ = '-';\n    for(i=0;i<n;++i) {\n        b = VpBaseVal()/10;\n        if(i>=(int)p->Prec) {\n            while(b) {\n                *pch++ = '0';\n                b /= 10;\n            }\n            continue;\n        }\n        v = p->frac[i];\n        while(b) {\n            j = v/b;\n            *pch++ = (char)(j + '0');\n            v -= j*b;\n            b /= 10;\n        }\n    }\n    *pch++ = 0;\n    return rb_cstr2inum(psz,10);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n * [Input]\n *   *m  ... Real\n * [Output]\n *   *d  ... fraction part of m(d = 0.xxxxxxx). where # of 'x's is fig.\n *   *e  ... U_LONG,exponent of m.\n * DBLE_FIG ... Number of digits in a double variable.\n *\n *  m -> d*10**e, 0<d<BASE\n * [Returns]\n *   0 ... Zero\n *   1 ... Normal\n *   2 ... Infinity\n *  -1 ... NaN\n */\n", "func_signal": "VP_EXPORT int\nVpVtoD(double *d, S_LONG *e, Real *m)", "code": "{\n    U_LONG ind_m, mm, fig;\n    double div;\n    int    f = 1;\n\n    if(VpIsNaN(m)) {\n        *d = VpGetDoubleNaN();\n        *e = 0;\n        f = -1; /* NaN */\n        goto Exit;\n    } else\n    if(VpIsPosZero(m)) {\n        *d = 0.0;\n        *e = 0;\n        f  = 0;\n        goto Exit;\n    } else\n    if(VpIsNegZero(m)) {\n        *d = VpGetDoubleNegZero();\n        *e = 0;\n        f  = 0;\n        goto Exit;\n    } else\n    if(VpIsPosInf(m)) {\n        *d = VpGetDoublePosInf();\n        *e = 0;\n        f  = 2;\n        goto Exit;\n    } else\n    if(VpIsNegInf(m)) {\n        *d = VpGetDoubleNegInf();\n        *e = 0;\n        f  = 2;\n        goto Exit;\n    }\n    /* Normal number */\n    fig =(DBLE_FIG + BASE_FIG - 1) / BASE_FIG;\n    ind_m = 0;\n    mm = Min(fig,(m->Prec));\n    *d = 0.0;\n    div = 1.;\n    while(ind_m < mm) {\n        div /=(double)((S_INT)BASE);\n        *d = *d +((double) ((S_INT)m->frac[ind_m++])) * div;\n    }\n    *e = m->exponent * ((S_INT)BASE_FIG);\n    *d *= VpGetSign(m);\n\nExit:\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \" VpVtoD: m=%\\n\", m);\n        printf(\"   d=%e * 10 **%ld\\n\", *d, *e);\n        printf(\"   DBLE_FIG = %ld\\n\", DBLE_FIG);\n    }\n#endif /*_DEBUG */\n    return f;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* call-seq:\n * truncate(n)\n *\n * Truncate to the nearest 1, returning the result as a BigDecimal.\n *\n * BigDecimal('3.14159').truncate -> 3\n *\n * BigDecimal('8.7').truncate -> 8\n *\n * If n is specified and positive, the fractional part of the result has no\n * more than that many digits. \n *\n * If n is specified and negative, at least that many digits to the left of the\n * decimal point will be 0 in the result.\n *\n * BigDecimal('3.14159').truncate(3) -> 3.141\n *\n * BigDecimal('13345.234').truncate(-2) -> 13300.0\n */\n", "func_signal": "static VALUE\nBigDecimal_truncate(int argc, VALUE *argv, VALUE self)", "code": "{\n    ENTER(5);\n    Real *c, *a;\n    int iLoc;\n    U_LONG mx;\n    VALUE vLoc;\n    U_LONG pl = VpSetPrecLimit(0);\n\n    if(rb_scan_args(argc,argv,\"01\",&vLoc)==0) {\n        iLoc = 0;\n    } else {\n        Check_Type(vLoc, T_FIXNUM);\n        iLoc = FIX2INT(vLoc);\n    }\n\n    GUARD_OBJ(a,GetVpValue(self,1));\n    mx = a->Prec *(VpBaseFig() + 1);\n    GUARD_OBJ(c,VpCreateRbObject(mx, \"0\"));\n    VpSetPrecLimit(pl);\n    VpActiveRound(c,a,VP_ROUND_DOWN,iLoc); /* 0: truncate */\n    return ToValue(c);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     rsa.to_der -> aString\n *\n */\n", "func_signal": "static VALUE\nossl_rsa_to_der(VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n    int (*i2d_func)_((const RSA*, unsigned char**));\n    unsigned char *p;\n    long len;\n    VALUE str;\n\n    GetPKeyRSA(self, pkey);\n    if(RSA_HAS_PRIVATE(pkey->pkey.rsa))\n\ti2d_func = i2d_RSAPrivateKey;\n    else\n\ti2d_func = i2d_RSAPublicKey;\n    if((len = i2d_func(pkey->pkey.rsa, NULL)) <= 0)\n\tossl_raise(eRSAError, NULL);\n    str = rb_str_new(0, len);\n    p = (unsigned char *)RSTRING_PTR(str);\n    if(i2d_func(pkey->pkey.rsa, &p) < 0)\n\tossl_raise(eRSAError, NULL);\n    ossl_str_adjust(str, p);\n\n    return str;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* call-seq:\n  * sub(value, digits)\n  *\n  * Subtract the specified value. \n  *\n  * e.g.\n  *   c = a.sub(b,n)\n  *   c = a - b\n  *\n  * digits:: If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.\n  */\n", "func_signal": "static VALUE\nBigDecimal_sub(VALUE self, VALUE r)", "code": "{\n    ENTER(5);\n    Real *c, *a, *b;\n    U_LONG mx;\n\n    GUARD_OBJ(a,GetVpValue(self,1));\n    b = GetVpValue(r,0);\n    if(!b) return DoSomeOne(self,r,'-');\n    SAVE(b);\n\n    if(VpIsNaN(b)) return b->obj;\n    if(VpIsNaN(a)) return a->obj;\n\n    mx = GetAddSubPrec(a,b);\n    if(mx==(-1L)) {\n        GUARD_OBJ(c,VpCreateRbObject(VpBaseFig() + 1, \"0\"));\n        VpAddSub(c, a, b, -1);\n    } else {\n        GUARD_OBJ(c,VpCreateRbObject(mx *(VpBaseFig() + 1), \"0\"));\n        if(!mx) {\n            VpSetInf(c,VpGetSign(a));\n        } else {\n            VpAddSub(c, a, b, -1);\n        }\n    }\n    return ToValue(c);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     rsa.public_encrypt(string [, padding]) -> aString\n *\n */\n", "func_signal": "static VALUE\nossl_rsa_public_encrypt(int argc, VALUE *argv, VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n    int buf_len, pad;\n    VALUE str, buffer, padding;\n\n    GetPKeyRSA(self, pkey);\n    rb_scan_args(argc, argv, \"11\", &buffer, &padding);\n    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);\n    StringValue(buffer);\n    str = rb_str_new(0, ossl_rsa_buf_size(pkey));\n    buf_len = RSA_public_encrypt(RSTRING_LEN(buffer), (unsigned char *)RSTRING_PTR(buffer),\n\t\t\t\t (unsigned char *)RSTRING_PTR(str), pkey->pkey.rsa,\n\t\t\t\t pad);\n    if (buf_len < 0) ossl_raise(eRSAError, NULL);\n    rb_str_set_len(str, buf_len);\n\n    return str;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n * Addition of two variable precisional variables\n * a and b assuming abs(a)>abs(b).\n *   c = abs(a) + abs(b) ; where |a|>=|b|\n */\n", "func_signal": "static U_LONG\nVpAddAbs(Real *a, Real *b, Real *c)", "code": "{\n    U_LONG word_shift;\n    U_LONG carry;\n    U_LONG ap;\n    U_LONG bp;\n    U_LONG cp;\n    U_LONG a_pos;\n    U_LONG b_pos;\n    U_LONG c_pos;\n    U_LONG av, bv, mrv;\n\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \"VpAddAbs called: a = %\\n\", a);\n        VPrint(stdout, \"     b = %\\n\", b);\n    }\n#endif /* _DEBUG */\n\n    word_shift = VpSetPTR(a, b, c, &ap, &bp, &cp, &av, &bv);\n    a_pos = ap;\n    b_pos = bp;\n    c_pos = cp;\n    if(word_shift==-1L) return 0; /* Overflow */\n    if(b_pos == -1L) goto Assign_a;\n\n    mrv = av + bv; /* Most right val. Used for round. */\n\n    /* Just assign the last few digits of b to c because a has no  */\n    /* corresponding digits to be added. */\n    while(b_pos + word_shift > a_pos) {\n        --c_pos;\n        if(b_pos > 0) {\n            c->frac[c_pos] = b->frac[--b_pos];\n        } else {\n            --word_shift;\n            c->frac[c_pos] = 0;\n        }\n    }\n\n    /* Just assign the last few digits of a to c because b has no */\n    /* corresponding digits to be added. */\n    bv = b_pos + word_shift;\n    while(a_pos > bv) {\n        c->frac[--c_pos] = a->frac[--a_pos];\n    }\n    carry = 0;    /* set first carry be zero */\n\n    /* Now perform addition until every digits of b will be */\n    /* exhausted. */\n    while(b_pos > 0) {\n        c->frac[--c_pos] = a->frac[--a_pos] + b->frac[--b_pos] + carry;\n        if(c->frac[c_pos] >= BASE) {\n            c->frac[c_pos] -= BASE;\n            carry = 1;\n        } else {\n            carry = 0;\n        }\n    }\n\n    /* Just assign the first few digits of a with considering */\n    /* the carry obtained so far because b has been exhausted. */\n    while(a_pos > 0) {\n        c->frac[--c_pos] = a->frac[--a_pos] + carry;\n        if(c->frac[c_pos] >= BASE) {\n            c->frac[c_pos] -= BASE;\n            carry = 1;\n        } else {\n            carry = 0;\n        }\n    }\n    if(c_pos) c->frac[c_pos - 1] += carry;\n    goto Exit;\n\nAssign_a:\n    VpAsgn(c, a, 1);\n    mrv = 0;\n\nExit:\n\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \"VpAddAbs exit: c=% \\n\", c);\n    }\n#endif /* _DEBUG */\n    return mrv;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     RSA.new([size | encoded_key] [, pass]) -> rsa\n *\n *  === Parameters\n *  * +size+ is an integer representing the desired key size.\n *  * +encoded_key+ is a string containing PEM or DER encoded key.\n *  * +pass+ is an optional string with the password to decrypt the encoded key.\n *\n *  === Examples\n *  * RSA.new(2048) -> rsa \n *  * RSA.new(File.read(\"rsa.pem\")) -> rsa\n *  * RSA.new(File.read(\"rsa.pem\"), \"mypassword\") -> rsa\n */\n", "func_signal": "static VALUE\nossl_rsa_initialize(int argc, VALUE *argv, VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n    RSA *rsa;\n    BIO *in;\n    char *passwd = NULL;\n    VALUE arg, pass;\n\t\n    GetPKey(self, pkey);\n    if(rb_scan_args(argc, argv, \"02\", &arg, &pass) == 0) {\n\trsa = RSA_new();\n    }\n    else if (FIXNUM_P(arg)) {\n\trsa = rsa_generate(FIX2INT(arg), NIL_P(pass) ? RSA_F4 : NUM2INT(pass));\n\tif (!rsa) ossl_raise(eRSAError, NULL);\n    }\n    else {\n\tif (!NIL_P(pass)) passwd = StringValuePtr(pass);\n\targ = ossl_to_der_if_possible(arg);\n\tin = ossl_obj2bio(arg);\n\trsa = PEM_read_bio_RSAPrivateKey(in, NULL, ossl_pem_passwd_cb, passwd);\n\tif (!rsa) {\n\t    (void)BIO_reset(in);\n\t    rsa = PEM_read_bio_RSAPublicKey(in, NULL, NULL, NULL);\n\t}\n\tif (!rsa) {\n\t    (void)BIO_reset(in);\n\t    rsa = PEM_read_bio_RSA_PUBKEY(in, NULL, NULL, NULL);\n\t}\n\tif (!rsa) {\n\t    (void)BIO_reset(in);\n\t    rsa = d2i_RSAPrivateKey_bio(in, NULL);\n\t}\n\tif (!rsa) {\n\t    (void)BIO_reset(in);\n\t    rsa = d2i_RSAPublicKey_bio(in, NULL);\n\t}\n\tif (!rsa) {\n\t    (void)BIO_reset(in);\n\t    rsa = d2i_RSA_PUBKEY_bio(in, NULL);\n\t}\n\tBIO_free(in);\n\tif (!rsa) ossl_raise(eRSAError, \"Neither PUB key nor PRIV key:\");\n    }\n    if (!EVP_PKEY_assign_RSA(pkey, rsa)) {\n\tRSA_free(rsa);\n\tossl_raise(eRSAError, NULL);\n    }\n\n    return self;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *   c = a + b  when operation =  1 or 2\n *  = a - b  when operation = -1 or -2.\n *   Returns number of significant digits of c\n */\n", "func_signal": "VP_EXPORT int\nVpAddSub(Real *c, Real *a, Real *b, int operation)", "code": "{\n    S_INT sw, isw;\n    Real *a_ptr, *b_ptr;\n    U_LONG n, na, nb, i;\n    U_LONG mrv;\n\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \"VpAddSub(enter) a=% \\n\", a);\n        VPrint(stdout, \"     b=% \\n\", b);\n        printf(\" operation=%d\\n\", operation);\n    }\n#endif /* _DEBUG */\n\n    if(!VpIsDefOP(c,a,b,(operation>0)?1:2)) return 0; /* No significant digits */\n\n    /* check if a or b is zero  */\n    if(VpIsZero(a)) {\n        /* a is zero,then assign b to c */\n        if(!VpIsZero(b)) {\n            VpAsgn(c, b, operation);\n        } else {\n            /* Both a and b are zero. */\n            if(VpGetSign(a)<0 && operation*VpGetSign(b)<0) {\n                /* -0 -0 */\n                VpSetZero(c,-1);\n            } else {\n                VpSetZero(c,1);\n            }\n            return 1; /* 0: 1 significant digits */\n        }\n        return c->Prec*BASE_FIG;\n    }\n    if(VpIsZero(b)) {\n        /* b is zero,then assign a to c. */\n        VpAsgn(c, a, 1);\n        return c->Prec*BASE_FIG;\n    }\n\n    if(operation < 0) sw = -1;\n    else              sw =  1;\n\n    /* compare absolute value. As a result,|a_ptr|>=|b_ptr| */\n    if(a->exponent > b->exponent) {\n        a_ptr = a;\n        b_ptr = b;\n    }         /* |a|>|b| */\n    else if(a->exponent < b->exponent) {\n        a_ptr = b;\n        b_ptr = a;\n    }                /* |a|<|b| */\n    else {\n        /* Exponent part of a and b is the same,then compare fraction */\n        /* part */\n        na = a->Prec;\n        nb = b->Prec;\n        n = Min(na, nb);\n        for(i=0;i < n; ++i) {\n            if(a->frac[i] > b->frac[i]) {\n                a_ptr = a;\n                b_ptr = b;\n                goto end_if;\n            } else if(a->frac[i] < b->frac[i]) {\n                a_ptr = b;\n                b_ptr = a;\n                goto end_if;\n            }\n        }\n        if(na > nb) {\n         a_ptr = a;\n            b_ptr = b;\n            goto end_if;\n        } else if(na < nb) {\n            a_ptr = b;\n            b_ptr = a;\n            goto end_if;\n        }\n        /* |a| == |b| */\n        if(VpGetSign(a) + sw *VpGetSign(b) == 0) {\n            VpSetZero(c,1);        /* abs(a)=abs(b) and operation = '-'  */\n            return c->Prec*BASE_FIG;\n        }\n        a_ptr = a;\n        b_ptr = b;\n    }\n\nend_if:\n    isw = VpGetSign(a) + sw *VpGetSign(b);\n    /*\n     *  isw = 0 ...( 1)+(-1),( 1)-( 1),(-1)+(1),(-1)-(-1)\n     *      = 2 ...( 1)+( 1),( 1)-(-1)\n     *      =-2 ...(-1)+(-1),(-1)-( 1)\n     *   If isw==0, then c =(Sign a_ptr)(|a_ptr|-|b_ptr|)\n     *              else c =(Sign ofisw)(|a_ptr|+|b_ptr|)\n    */\n    if(isw) {            /* addition */\n        VpSetSign(c,(S_INT)1);\n        mrv = VpAddAbs(a_ptr, b_ptr, c);\n        VpSetSign(c,isw / 2);\n    } else {            /* subtraction */\n        VpSetSign(c,(S_INT)1);\n        mrv = VpSubAbs(a_ptr, b_ptr, c);\n        if(a_ptr == a) {\n            VpSetSign(c,VpGetSign(a));\n        } else    {\n            VpSetSign(c,VpGetSign(a_ptr) * sw);\n        }\n    }\n    VpInternalRound(c,0,(c->Prec>0)?c->frac[c->Prec-1]:0,mrv);\n\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \"VpAddSub(result) c=% \\n\", c);\n        VPrint(stdout, \"     a=% \\n\", a);\n        VPrint(stdout, \"     b=% \\n\", b);\n        printf(\" operation=%d\\n\", operation);\n    }\n#endif /* _DEBUG */\n    return c->Prec*BASE_FIG;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     rsa.private? -> true | false\n *\n */\n", "func_signal": "static VALUE\nossl_rsa_is_private(VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n\t\n    GetPKeyRSA(self, pkey);\n    \n    return (RSA_PRIVATE(self, pkey->pkey.rsa)) ? Qtrue : Qfalse;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     rsa.params -> hash\n *\n * Stores all parameters of key to the hash\n * INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!\n * Don't use :-)) (I's up to you)\n */\n", "func_signal": "static VALUE\nossl_rsa_get_params(VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n    VALUE hash;\n\n    GetPKeyRSA(self, pkey);\n\n    hash = rb_hash_new();\n\n    rb_hash_aset(hash, rb_str_new2(\"n\"), ossl_bn_new(pkey->pkey.rsa->n));\n    rb_hash_aset(hash, rb_str_new2(\"e\"), ossl_bn_new(pkey->pkey.rsa->e));\n    rb_hash_aset(hash, rb_str_new2(\"d\"), ossl_bn_new(pkey->pkey.rsa->d));\n    rb_hash_aset(hash, rb_str_new2(\"p\"), ossl_bn_new(pkey->pkey.rsa->p));\n    rb_hash_aset(hash, rb_str_new2(\"q\"), ossl_bn_new(pkey->pkey.rsa->q));\n    rb_hash_aset(hash, rb_str_new2(\"dmp1\"), ossl_bn_new(pkey->pkey.rsa->dmp1));\n    rb_hash_aset(hash, rb_str_new2(\"dmq1\"), ossl_bn_new(pkey->pkey.rsa->dmq1));\n    rb_hash_aset(hash, rb_str_new2(\"iqmp\"), ossl_bn_new(pkey->pkey.rsa->iqmp));\n    \n    return hash;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* Throw exception or returns 0,when resulting c is Inf or NaN */\n/*  sw=1:+ 2:- 3:* 4:/ */\n", "func_signal": "static int\nVpIsDefOP(Real *c,Real *a,Real *b,int sw)", "code": "{\n    if(VpIsNaN(a) || VpIsNaN(b)) {\n        /* at least a or b is NaN */\n        VpSetNaN(c);\n        goto NaN;\n    }\n\n    if(VpIsInf(a)) {\n        if(VpIsInf(b)) {\n            switch(sw)\n            {\n            case 1: /* + */\n                if(VpGetSign(a)==VpGetSign(b)) {\n                    VpSetInf(c,VpGetSign(a));\n                    goto Inf;\n                } else {\n                    VpSetNaN(c);\n                    goto NaN;\n                }\n            case 2: /* - */\n                if(VpGetSign(a)!=VpGetSign(b)) {\n                    VpSetInf(c,VpGetSign(a));\n                    goto Inf;\n                } else {\n                    VpSetNaN(c);\n                    goto NaN;\n                }\n                break;\n            case 3: /* * */\n                VpSetInf(c,VpGetSign(a)*VpGetSign(b));\n                goto Inf;\n                break;\n            case 4: /* / */\n                VpSetNaN(c);\n                goto NaN;\n            }\n            VpSetNaN(c);\n            goto NaN;\n        }\n        /* Inf op Finite */\n        switch(sw)\n        {\n        case 1: /* + */\n        case 2: /* - */\n                VpSetInf(c,VpGetSign(a));\n                break;\n        case 3: /* * */\n                if(VpIsZero(b)) {\n                    VpSetNaN(c);\n                    goto NaN;\n                }\n                VpSetInf(c,VpGetSign(a)*VpGetSign(b));\n                break;\n        case 4: /* / */\n                VpSetInf(c,VpGetSign(a)*VpGetSign(b));\n        }\n        goto Inf;\n    }\n\n    if(VpIsInf(b)) {\n        switch(sw)\n        {\n        case 1: /* + */\n                VpSetInf(c,VpGetSign(b));\n                break;\n        case 2: /* - */\n                VpSetInf(c,-VpGetSign(b));\n                break;\n        case 3: /* * */\n                if(VpIsZero(a)) {\n                    VpSetNaN(c);\n                    goto NaN;\n                }\n                VpSetInf(c,VpGetSign(a)*VpGetSign(b));\n                break;\n        case 4: /* / */\n                VpSetZero(c,VpGetSign(a)*VpGetSign(b));\n        }\n        goto Inf;\n    }\n    return 1; /* Results OK */\n\nInf:\n    return VpException(VP_EXCEPTION_INFINITY,\"Computation results to 'Infinity'\",0);\nNaN:\n    return VpException(VP_EXCEPTION_NaN,\"Computation results to 'NaN'\",0);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  VpComp = 0  ... if a=b,\n *   Pos  ... a>b,\n *   Neg  ... a<b.\n *   999  ... result undefined(NaN)\n */\n", "func_signal": "VP_EXPORT int\nVpComp(Real *a, Real *b)", "code": "{\n    int val;\n    U_LONG mx, ind;\n    int e;\n    val = 0;\n    if(VpIsNaN(a)||VpIsNaN(b)) return 999;\n    if(!VpIsDef(a)) {\n        if(!VpIsDef(b)) e = a->sign - b->sign;\n        else             e = a->sign;\n        if(e>0)   return  1;\n        else if(e<0) return -1;\n        else   return  0;\n    }\n    if(!VpIsDef(b)) {\n        e = -b->sign;\n        if(e>0) return  1;\n        else return -1;\n    }\n    /* Zero check */\n    if(VpIsZero(a)) {\n        if(VpIsZero(b))      return 0; /* both zero */\n        val = -VpGetSign(b);\n        goto Exit;\n    }\n    if(VpIsZero(b)) {\n        val = VpGetSign(a);\n        goto Exit;\n    }\n\n    /* compare sign */\n    if(VpGetSign(a) > VpGetSign(b)) {\n        val = 1;        /* a>b */\n        goto Exit;\n    }\n    if(VpGetSign(a) < VpGetSign(b)) {\n        val = -1;        /* a<b */\n        goto Exit;\n    }\n\n    /* a and b have same sign, && signe!=0,then compare exponent */\n    if((a->exponent) >(b->exponent)) {\n        val = VpGetSign(a);\n        goto Exit;\n    }\n    if((a->exponent) <(b->exponent)) {\n        val = -VpGetSign(b);\n        goto Exit;\n    }\n\n    /* a and b have same exponent, then compare significand. */\n    mx =((a->Prec) <(b->Prec)) ?(a->Prec) :(b->Prec);\n    ind = 0;\n    while(ind < mx) {\n        if((a->frac[ind]) >(b->frac[ind])) {\n            val = VpGetSign(a);\n         goto Exit;\n        }\n        if((a->frac[ind]) <(b->frac[ind])) {\n            val = -VpGetSign(b);\n            goto Exit;\n        }\n        ++ind;\n    }\n    if((a->Prec) >(b->Prec)) {\n        val = VpGetSign(a);\n    } else if((a->Prec) <(b->Prec)) {\n        val = -VpGetSign(b);\n    }\n\nExit:\n    if  (val> 1) val =  1;\n    else if(val<-1) val = -1;\n\n#ifdef _DEBUG\n    if(gfDebug) {\n        VPrint(stdout, \" VpComp a=%\\n\", a);\n        VPrint(stdout, \"  b=%\\n\", b);\n        printf(\"  ans=%d\\n\", val);\n    }\n#endif /* _DEBUG */\n    return (int)val;\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/*\n *  call-seq:\n *     rsa.private_encrypt(string [, padding]) -> aString\n *\n */\n", "func_signal": "static VALUE\nossl_rsa_private_encrypt(int argc, VALUE *argv, VALUE self)", "code": "{\n    EVP_PKEY *pkey;\n    int buf_len, pad;\n    VALUE str, buffer, padding;\n\n    GetPKeyRSA(self, pkey);\n    if (!RSA_PRIVATE(self, pkey->pkey.rsa)) {\n\tossl_raise(eRSAError, \"private key needed.\");\n    }\t\n    rb_scan_args(argc, argv, \"11\", &buffer, &padding);\n    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);\n    StringValue(buffer);\n    str = rb_str_new(0, ossl_rsa_buf_size(pkey));\n    buf_len = RSA_private_encrypt(RSTRING_LEN(buffer), (unsigned char *)RSTRING_PTR(buffer),\n\t\t\t\t  (unsigned char *)RSTRING_PTR(str), pkey->pkey.rsa,\n\t\t\t\t  pad);\n    if (buf_len < 0) ossl_raise(eRSAError, NULL);\n    rb_str_set_len(str, buf_len);\n    \n    return str;\n}", "path": "ext\\openssl\\ossl_pkey_rsa.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* Return the fractional part of the number.\n */\n", "func_signal": "static VALUE\nBigDecimal_frac(VALUE self)", "code": "{\n    ENTER(5);\n    Real *c, *a;\n    U_LONG mx;\n\n    GUARD_OBJ(a,GetVpValue(self,1));\n    mx = a->Prec *(VpBaseFig() + 1);\n    GUARD_OBJ(c,VpCreateRbObject(mx, \"0\"));\n    VpFrac(c, a);\n    return ToValue(c);\n}", "path": "ext\\bigdecimal\\bigdecimal.c", "repo_name": "mas454/spcamp-ruby", "stars": 2, "license": "other", "language": "c", "size": 24272}
{"docstring": "/* This function can be used to check the arity (number of arguments)\n   a proc or method can take.  Usually used in a %typecheck.\n   Valid arities will be that equal to minimal or those < 0\n   which indicate a variable number of parameters at the end.\n */\n", "func_signal": "SWIGINTERN\nint SWIG_Ruby_arity( VALUE proc, int minimal )", "code": "{\n  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )\n    {\n      VALUE num = rb_funcall( proc, swig_arity_id, 0 );\n      int arity = NUM2INT(num);\n      if ( arity < 0 && (arity+1) < -minimal ) return 1;\n      if ( arity == minimal ) return 1;\n      return 1;\n    }\n  return 0;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* This function is called when an overloaded method fails */\n", "func_signal": "SWIGINTERN \nvoid Ruby_Format_OverloadedError(\n\t\t\t\t const int argc,\n\t\t\t\t const int maxargs,\n\t\t\t\t const char* method, \n\t\t\t\t const char* prototypes \n\t\t\t\t )", "code": "{\n  const char* msg = \"Wrong # of arguments\";\n  if ( argc <= maxargs ) msg = \"Wrong arguments\";\n  rb_raise(rb_eArgError,\"%s for overloaded method '%s'.\\n\"  \n\t   \"Possible C/C++ prototypes are:\\n%s\",\n\t   msg, method, prototypes);\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* \n   Pack binary data into a string\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz)", "code": "{\n  static const char hex[17] = \"0123456789abcdef\";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* \n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (int)((l1 - f1) - (l2 - f2));\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Check convert */\n", "func_signal": "SWIGRUNTIMEINLINE int\nSWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)", "code": "{\n  char *c = SWIG_MangleStr(obj);\n  if (!c) return 0;\n  return SWIG_TypeCheck(c,ty) != 0;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)", "code": "{\n  int own =  flags & SWIG_POINTER_OWN; \n  int track;\n  char *klass_name;\n  swig_class *sklass;\n  VALUE klass;\n  VALUE obj;\n  \n  if (!ptr)\n    return Qnil;\n  \n  if (type->clientdata) {\n    sklass = (swig_class *) type->clientdata;\n\t\t\n    /* Are we tracking this class and have we already returned this Ruby object? */\n    track = sklass->trackObjects;\n    if (track) {\n      obj = SWIG_RubyInstanceFor(ptr);\n      \n      /* Check the object's type and make sure it has the correct type.\n        It might not in cases where methods do things like \n        downcast methods. */\n      if (obj != Qnil) {\n        VALUE value = rb_iv_get(obj, \"@__swigtype__\");\n        char* type_name = RSTRING_PTR(value);\n\t\t\t\t\n        if (strcmp(type->name, type_name) == 0) {\n          return obj;\n        }\n      }\n    }\n\n    /* Create a new Ruby object */\n    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), \n\t\t\t   ( own ? VOIDFUNC(sklass->destroy) : \n\t\t\t     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )\n\t\t\t     ), ptr);\n\n    /* If tracking is on for this class then track this object. */\n    if (track) {\n      SWIG_RubyAddTracking(ptr, obj);\n    }\n  } else {\n    klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n    sprintf(klass_name, \"TYPE%s\", type->name);\n    klass = rb_const_get(_mSWIG, rb_intern(klass_name));\n    free((void *) klass_name);\n    obj = Data_Wrap_Struct(klass, 0, 0, ptr);\n  }\n  rb_iv_set(obj, \"@__swigtype__\", rb_str_new2(type->name));\n  \n  return obj;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* This code checks to see if the Ruby object being raised as part\n   of an exception inherits from the Ruby class Exception.  If so,\n   the object is simply returned.  If not, then a new Ruby exception\n   object is created and that will be returned to Ruby.*/\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj)", "code": "{\n  VALUE exceptionClass = getExceptionClass();\n  if (rb_obj_is_kind_of(obj, exceptionClass)) {\n    return obj;\n  }  else {\n    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));\n  }\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Create a new class instance (always owned) */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)", "code": "{\n  VALUE obj;\n  swig_class *sklass = (swig_class *) type->clientdata;\n  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);\n  rb_iv_set(obj, \"@__swigtype__\", rb_str_new2(type->name));\n  return obj;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* \n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n  \n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }    \n    cast = cast->next;\n  }\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n\n  if (init_run) return;\n  init_run = 1;\n\n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeCompare(const char *nb, const char *tb)", "code": "{\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Define Ruby class for C type */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_define_class(swig_type_info *type)", "code": "{\n  VALUE klass;\n  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n  sprintf(klass_name, \"TYPE%s\", type->name);\n  if (NIL_P(_cSWIG_Pointer)) {\n    _cSWIG_Pointer = rb_define_class_under(_mSWIG, \"Pointer\", rb_cObject);\n    rb_undef_method(CLASS_OF(_cSWIG_Pointer), \"new\");\n  }\n  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);\n  free((void *) klass_name);\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start, \n                            swig_module_info *end, \n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1; \n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\t    \n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Remove a Tracking from a C/C++ struct to a Ruby object.  It\n   is very important to remove objects once they are destroyed\n   since the same memory address may be reused later to create\n   a new object. */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr)", "code": "{\n  /* Get a reference to the pointer as a Ruby number */\n  VALUE key = SWIG_RubyPtrToReference(ptr);\n\n  /* Delete the object from the hash table by calling Ruby's\n     do this we need to call the Hash.delete method.*/\n  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* \n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr)", "code": "{\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* This is a helper method that unlinks a Ruby object from its\n   underlying C++ object.  This is needed if the lifetime of the\n   Ruby object is longer than the C++ object */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr)", "code": "{\n  VALUE object = SWIG_RubyInstanceFor(ptr);\n\n  if (object != Qnil) {\n    DATA_PTR(object) = 0;\n  }\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start, \n                     swig_module_info *end, \n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n  \n  /* neither found a match */\n  return 0;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)", "code": "{\n  char *c;\n  swig_cast_info *tc;\n  void *vptr = 0;\n\n  /* Grab the pointer */\n  if (NIL_P(obj)) {\n    *ptr = 0;\n    return SWIG_OK;\n  } else {\n    if (TYPE(obj) != T_DATA) {\n      return SWIG_ERROR;\n    }\n    Data_Get_Struct(obj, void, vptr);\n  }\n  \n  if (own) *own = RDATA(obj)->dfree;\n    \n  /* Check to see if the input object is giving up ownership\n     of the underlying C struct or C++ object.  If so then we\n     need to reset the destructor since the Ruby object no \n     longer owns the underlying C++ object.*/ \n  if (flags & SWIG_POINTER_DISOWN) {\n    /* Is tracking on for this class? */\n    int track = 0;\n    if (ty && ty->clientdata) {\n      swig_class *sklass = (swig_class *) ty->clientdata;\n      track = sklass->trackObjects;\n    }\n\t\t\n    if (track) {\n      /* We are tracking objects for this class.  Thus we change the destructor\n       * to SWIG_RubyRemoveTracking.  This allows us to\n       * remove the mapping from the C++ to Ruby object\n       * when the Ruby object is garbage collected.  If we don't\n       * do this, then it is possible we will return a reference \n       * to a Ruby object that no longer exists thereby crashing Ruby. */\n      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;\n    } else {    \n      RDATA(obj)->dfree = 0;\n    }\n  }\n\n  /* Do type-checking if type info was provided */\n  if (ty) {\n    if (ty->clientdata) {\n      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {\n        if (vptr == 0) {\n          /* The object has already been deleted */\n          return SWIG_ObjectPreviouslyDeletedError;\n        }\n        *ptr = vptr;\n        return SWIG_OK;\n      }\n    }\n    if ((c = SWIG_MangleStr(obj)) == NULL) {\n      return SWIG_ERROR;\n    }\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) {\n      return SWIG_ERROR;\n    }\n    *ptr = SWIG_TypeCast(tc, vptr);\n  } else {\n    *ptr = vptr;\n  }\n  \n  return SWIG_OK;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty)", "code": "{\n  swig_cast_info *tc;\n  const char  *c;\n\n  if (TYPE(obj) != T_STRING) goto type_error;\n  c = StringValuePtr(obj);\n  /* Pointer values must start with leading underscore */\n  if (*c != '_') goto type_error;\n  c++;\n  c = SWIG_UnpackData(c, ptr, sz);\n  if (ty) {\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) goto type_error;\n  }\n  return SWIG_OK;\n\n type_error:\n  return SWIG_ERROR;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/*@SWIG@*/\n", "func_signal": "SWIGINTERN int\nSWIG_AsVal_long (VALUE obj, long* val)", "code": "{\n  VALUE type = TYPE(obj);\n  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {\n    long v;\n    VALUE a[2];\n    a[0] = obj;\n    a[1] = (VALUE)(&v);\n    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {\n      if (val) *val = v;\n      return SWIG_OK;\n    }\n  }\n  return SWIG_TypeError;\n}", "path": "swig\\narray\\test6_wrap.c", "repo_name": "rust/study-ruby-extlib", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/**\tRemoves the process (specified by the process id) from the physical memory\n\t@param pid The ID of the process to be removed from memory\n*/\n", "func_signal": "void freeProc(int *pid)", "code": "{\n\tfor(int i=0;i<50;i++) {\n\t\tif(paget[i][0] == *pid) {\n\t\t\tfreeFrame(i);\n\t\t}\n\t}\n\tprintf(\"Freed Process %d Upon Completion\\n\",*pid);\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tReads the contents of the input file into an unsorted array of process structures\n\t@param \tfilename The string representing the name of the input file\n\t@param \tlength A counter that records the number of jobs present in the input file\n\t@param \tmode The program mode. 0 represents Scheduler mode, 1 represents Virtual Memory mode\n\t@return The array of a processes\n*/\n", "func_signal": "process **readFile(char * filename,int *length,int *mode)", "code": "{\n\t//try to open the file\n\tFILE * file;\n  \tfile = fopen (filename,\"r\");\n  \tif(file==NULL) {\n    \tprintf(\"Input file '%s' failed to open, or does not exist! Exiting Program..\\n\",filename);\n\t\texit(EXIT_FAILURE);\n  \t}\t\n\n\t//allocate memory for the initial pointer array\n  \tprocess **proc = malloc(1*sizeof(process*)); //n.b. size of process structure is 72\n\t\n\t//read the processes into the next 'process' structure in the 'proc' array. reallocates for the next structure\n\t*length = 0;\n\tchar tempc[1024]; //buffer to read the string into\n\tchar tempstr[1024];\n\t\n\twhile(fgets(tempc,sizeof(tempc),file) != NULL) {\n\t\t//malloc for current structure\n\t\tproc[*length] = malloc(sizeof(process));\n\t\tif(*mode == 0) {\n\t\t\t\n\t\t\t//scan data to structure\n\t\t\tif(sscanf(tempc,\"%s%d%d\",tempstr,&proc[*length]->start,&proc[*length]->duration) != 3) {\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\t//add the name to the structure. strdup automatically mallocs for the size of the string\n\t\t\t\tproc[*length]->name = strdup(tempstr);\n\t\t\t\n\t\t\t\t//reallocate for the next structure to be filled, and adjust length variable\n\t\t\t\t(*length)++;\n\t\t\t\tproc = (process**) realloc(proc,(*length+1)*sizeof(process*));\n\t\t\t}\n\t\t}else if(*mode == 1) {\n\t\t\t//set up the virtual memory\n\t\t\tinitMemory();\n\t\t\t//scan data to structure\n\t\t\tif(sscanf(tempc,\"%s%d%d%d\",tempstr,&proc[*length]->start,&proc[*length]->duration,&proc[*length]->pages) != 4) {\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\t//if too much memory is required\n\t\t\t\tif(proc[*length]->pages > 50 || proc[*length]->pages < 1) {\n\t\t\t\t\tprintf(\"Invalid Page Size For %s, Must Be Within The Range (1-50)\\n\",tempstr); \n\t\t\t\t\texit(EXIT_FAILURE); \n\t\t\t\t}\n\t\t\t\t//add the name to the structure. strdup automatically mallocs for the size of the string\n\t\t\t\tproc[*length]->name = strdup(tempstr);\n\t\t\t\n\t\t\t\t//reallocate for the next structure to be filled, and adjust length variable\n\t\t\t\t(*length)++;\n\t\t\t\tproc = (process**) realloc(proc,(*length+1)*sizeof(process*));\n\t\t\t}\n\t\t}\n\t}\n  \tfclose(file);\n  \treturn proc;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** Initialises an empty virtual memory block, with each slot having space for four characters.\n*/\n", "func_signal": "void initMemory()", "code": "{\n\t//set all pages in memory to 0, indicating 'free' status. also set \"last-used\" time to -1 and adjust the page table accordingly.\n\tfor(int i=0;i<50;i++) {\n\t\tmem[i] = malloc(4*sizeof(char) +1);\n\t\tmem[i][0] = '0';\n\t\tmem[i][1] = '\\0';\n\t\t\n\t\tpaget[i][0] = -1;\n\t\tpaget[i][1] = -1;\n\t\tpaget[i][2] = -1;\n\t}\n\tfor(int i=0;i<150;i++) {\n\t\tswap[i] = malloc(4*sizeof(char) +1);\n\t\tswap[i][0] = '0';\n\t\tswap[i][1] = '\\0';\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tHandles the command line input using the getopt() library\n\t@param argc The number of arguments passed\n\t@param argv The array of string arguments passed\n*/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\n\tstruct gengetopt_args_info args_info;\n\n\tprintf(\"Prosim simulator\\n\");\n\t\n\tif(cmdline_parser(argc, argv, &args_info) != 0)\n\t{\t\n\t\texit(1);\n\t}\n\n#ifdef debug\t\n\tif( args_info.input_given)\n\t{\n\t\tprintf(\"Input filename: %s\\n\", args_info.input_arg);\n\t}\n\t\n\tif(args_info.quantum_given)\n\t{\n\t\tprintf(\"Quantum specified: %d\\n\", args_info.quantum_arg);\n\t}\n\n\tif(args_info.expire_given)\n\t{\n\t\tprintf(\"Expire specified: %d\\n\", args_info.expire_arg);\n\t}\n\n\tif(args_info.algorithm_given)\n\t{\n\t\tprintf(\"Algorithm specified: %s\\n\", args_info.algorithm_arg);\n\t}\n#endif\n\t\n\tint *q; // Quantum\n\tint *e; // Exit point\n\tchar **a; // Algorithm\n\tint expire;\n\tint mode;\n\n\tif(args_info.scheduler_given)\n\t{\n#ifdef debug\n\t\tprintf(\"Running scheduler\\n\");\n#endif\n\t\tq = &args_info.quantum_arg;\n\t\t\n\t\ta = &args_info.algorithm_arg;\n\t\t\n\t\texpire = -1;\n\t\t\n\t\tmode = 0;\n\n\t\tif( *q <= 0) {\n\t\t\tprintf(\"q out of range: -h for usage\\n\");\n\t\t\treturn 1;\n\t\t}\t\n\n\t\tscheduler(&args_info.input_arg, a, q, &expire, &mode);\n\t\t\n\t} \n\telse if(args_info.virtualmem_given)\n\t{\n#ifdef debug\n\t\tprintf(\"Running virtualmem\\n\");\n#endif\n\t\tq = &args_info.quantum_arg;\n\t\t\n\t\ta = &args_info.algorithm_arg;\n\n\t\texpire = args_info.expire_arg;\n\t\t\n\t\tmode = 1;\n\n\t\tif(*q <= 0 || expire <= 0) {\n\t\t\tprintf(\"x or q out of range: -h for usage\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tscheduler(&args_info.input_arg, a, q, &expire, &mode);\n\t}\n\n\tcmdline_parser_free(&args_info);\n\n\treturn 0;\n\n}", "path": "prosimCLI\\src\\main.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** Gets the access time of the first valid process listed\n\t@return The access time of the first valid process within the page table\n*/\n", "func_signal": "int getFirstAge()", "code": "{\n\tint index = 0;\n\twhile(true) {\n\t\tif(paget[index][0] != -1) {\n\t\t\treturn paget[index][1];\n\t\t}\n\t\tindex++;\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tGenerates the process name (integer), to be stored in the page table\n\t@param proc The process with which to generate the name\n\t@return The integer representing the process id\n*/\n", "func_signal": "int getName(process *proc)", "code": "{\n\tchar *name = malloc(2*sizeof(char)+1);\n\tint pid;\n\tif(strlen(proc->name) == 4) {\n\t\tname[0] = proc->name[3];\n\t\tname[1] = '\\0';\t\t\n\t}else if (strlen(proc->name) == 5) {\n\t\tname[0] = proc->name[3];\n\t\tname[1] = proc->name[4];\n\t\tname[2] = '\\0';\t\n\t}else{\n\t\tprintf(\"ERROR: Job Name '%s' Is Not In Valid Numerical Range (0 - 99)\\n\",proc->name);\n\t\texit(EXIT_FAILURE);\n\t}\n\tpid = atoi(name);\n\treturn pid;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tHandles the algorithm selection, depending on which scheduling method was specified via the command line\n\t@param\tinputfile The name of the input file containing the processes\n\t@param\talgorithm The desired schedulaing algorithm\n\t@param\tquantum\tThe desired time quantum (for round robin scheduling only)\n\t@param \texpire The time at which the memory state is cloned for printing to the output file\n\t@param \tmode The program mode. 0 represents Scheduler mode, 1 represents Virtual Memory mode\t\n*/\n", "func_signal": "void scheduler(char **inputfile, char **algorithm, int *quantum, int *expire,int *mode)", "code": "{\n\tint length;\n\n\tprocess **proc = readFile(*inputfile, &length, mode);\n\n\t// Sort the processes and enqueue.\n\tQUEUE *pqueue = sort(proc, length);\n\t\n\t// Prepare and output file.\n\tFILE *file;\n\tif((file = fopen(\"out.file\",\"w\")) == NULL)\n\t{\n\t\tprintf(\"Failed to create/open the file\\n\");\n\t\treturn;\n\t}\n\t\n\t// Algorithm selection\n\tif(strcmp(*algorithm, \"FCFS\") == 0) \n\t{\n\t\tfirstCome(pqueue,expire,mode);\n\t}\n\telse if(strcmp(*algorithm, \"RR\") == 0)\n\t{\n\t\troundRobin(pqueue, *quantum,expire,mode);\n\t}\n\telse if(strcmp(*algorithm, \"SRT\") == 0)\n\t{\n\t\tshortestRemaining(pqueue,expire,mode);\n\t}\n\telse if(strcmp(*algorithm, \"SPN\") == 0)\n\t{\n\t\tshortestNext(pqueue,expire,mode);\n\t}\n\t\n\t//prepare and print to the memory output file if the mode suggests to do so\n\tif(*mode == 1) {\n\t\t//append all virtual memory and page table data to the file\n\t\tprintPage();\n\t}\n\t\n\tfclose(file);\t\n\treturn;\n}", "path": "prosimCLI\\src\\handler.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tGenerates the 4 digit, double concatenated process name (integer), to be stored in the  virtual memory.\n\t@param proc The process with which to generate the name\n\t@return The 4 digit integer representing the process id\n*/\n", "func_signal": "char * getNameQuad(process *proc)", "code": "{\n\tchar *str = malloc(4*sizeof(char) +1);\n\tint length = strlen(proc->name);\n\n\tif(length == 4) {\n\t\tstr[0] = '0';\n\t\tstr[1] = proc->name[3];\n\t\tstr[2] = '0';\n\t\tstr[3] = proc->name[3];\n\t\tstr[4] = '\\0';\n\t}else if(length == 5) {\n\t\tstr[0] = proc->name[3];\n\t\tstr[1] = proc->name[4];\n\t\tstr[2] = proc->name[3];\n\t\tstr[3] = proc->name[4];\n\t\tstr[4] = '\\0';\n\t}\n\treturn str;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tSimulates the Shortest Remaining Time scheduling algorithm.\n\t@param pqueue The queue of all available processes\n\t@param expire The time at which the memory state is cloned for printing to the output file\n\t@param mode The program mode. 0 represents Scheduler mode, 1 represents Virtual Memory mode\t\n*/\n", "func_signal": "void shortestRemaining(QUEUE *pqueue,int *expire, int *mode)", "code": "{\n\tvoid *temp;\t\t\t\t\t\t//pointer to the current process\n\tQUEUE *ready = init(\"ready\");\t//queue holding all ready processes at the given time cycle\n\tsize_t sizetemp = 0;\t\t\t//size of the current element being peeked at or dequeued\t\n\tint time_cycle = 0;\t\t\t\t//counter representing cpu ticks (Hz)\n\tint counter = 0;\t\t\t\t//records the process cpu access count\n\tint *data;\t\t\t\t\t\t//holds the start time and duration of each cycle of each process\n\tint pid;\t\t\t\t\t\t//the process name as an integer. used to reference the page table to determine whether the process is cached\n\tprocess *last = NULL;\t\t\t//pos of the last process to access the cpu, when it changes it triggers a file write operation\n\tint success = 1;\t\t\t\t//indicates whether the process was successfully cached\n\tint state_clone = 0;\t\t\t//indicates whether the memory state has already been cloned\n\t\n\t//simulate time cycles with a loop and for each cycle, queue the available processes in a new queue (ready queue)\n\twhile(!isEmpty(pqueue) || !isEmpty(ready)) {\n\t\t//find the ready processes given the current time cycle, and sort by remaing time\n\t\tgetReady(pqueue,ready,time_cycle);\n\t\tsortSPN(ready);\n\t\t\n\t\t//if there are processes ready, sort them by duration and grant access to the first (shortest)\n\t\tif(!isEmpty(ready)) {\n\t\t\t//grab the process\n\t\t\tpeek(ready, &temp, &sizetemp);\n\t\t\tprocess *proc = temp;\n\t\t\tsuccess = 1;\n\t\t\t\n\t\t\t//load the process into memory, if not already there\n\t\t\tif(*mode == 1) {\n\t\t\t\tpid = getName(proc);\n\t\t\t\tif(!isCached(pid)) {\n\t\t\t\t\tsuccess = cache(proc,&pid,&time_cycle);\n\t\t\t\t}else {\n\t\t\t\t\tupdateTime(&pid,&time_cycle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//if the process using the cpu has changed, store the access data from the last process\n\t\t\tif(last != NULL && last != proc && last->duration != 0) {\n\t\t\t\t//add the processing data to the 'run' queue in the process structure\n\t\t\t\tdata = malloc(2*sizeof(int));\n\t\t\t\tdata[0] = time_cycle-counter;\n\t\t\t\tdata[1] = counter;\n\t\t\t\tenqueue(last->run,(void*)data,sizeof(data));\n\t\t\t\tcounter=0;\n\t\t\t}\n\t\t\t\n\t\t\t///simulate cpu access if the mode is scheduler, or if the mode is memory and the process IS cached\n\t\t\t//if the process has not been cached it cannot be processed, so another must be found for the current cycle\n\t\t\tif(success == 1) {\n\t\t\t\tlast = proc;\n\t\t\t\tproc->duration--;\n\t\t\t\tprintf(\"Processing %s\\n\",proc->name);\n\t\t\t\tcounter++;\n\t\t\t\ttime_cycle++;\n\t\t\t}else {\n\t\t\t\t//add any full-system shuffle algs here\n\t\t\t\t//add current process to back of the queue (cycles through processes in the case of a bloated system)\n\t\t\t\tdequeue(ready,&temp,&sizetemp);\n\t\t\t\tenqueue(ready,(process*)temp,sizetemp);\n\t\t\t}\n\t\t\t\n\t\t\t//if the process terminates, reset the count and dequeue the process\n\t\t\tif(proc->duration == 0) {\n\t\t\t\tprintf(\"Completed  %s at t=%d\\n\",proc->name,time_cycle); \n\t\t\t\t//add the processing data to the 'run' queue in the process structure\n\t\t\t\tdata = malloc(2*sizeof(int));\n\t\t\t\tdata[0] = time_cycle-counter;\n\t\t\t\tdata[1] = counter;\n\t\t\t\tenqueue(proc->run,(void*)data,sizeof(data));\n\t\t\t\t//print the process data to the output file\n\t\t\t\toutput((process*)temp);\n\t\t\t\t//free virtual memory\n\t\t\t   \tif(*mode == 1) {\n\t\t\t   \t\tfreeProc(&pid);\t\n\t\t\t   \t}\n\t\t\t\t//dequeue and free the finished process\n\t\t\t    dequeue(ready, &temp, &sizetemp);\n\t\t\t    free(temp);\n\t\t\t    //reset the access counter\n\t\t\t\tcounter = 0;\n\t\t\t    //reset the last process logger\n\t\t\t\tlast=NULL;\n\t\t\t}\n\t\t\t//handle the memory save\n\t\t\tif(*mode == 1 && time_cycle == *expire && state_clone == 0) {state_clone = clonePage(expire);}\n\t\t}else{\n\t\t\ttime_cycle++;\n\t\t}\n\t}\n\t//if the expire time is larger than the required completion time, let the output string represent the final memory state\n\tif(*mode == 1 && *expire > time_cycle) {\n\t\tclonePage(expire);\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tAppends all available processes at the given time to the ready queue.\n\t@param pqueue The queue of all available processes\n\t@param ready The queue of all ready processes\n\t@param time_cycle The current time cycle of the processor\n*/\n", "func_signal": "void getReady(QUEUE *pqueue, QUEUE *ready, int time_cycle)", "code": "{\n\tvoid *temp;\n\tsize_t sizetemp = 0;\n\twhile(!isEmpty(pqueue)) {\n\t\t//find the ready processes given the current time cycle\n\t\tpeek(pqueue, &temp, &sizetemp);\n\t\tprocess *proc = temp;\n\t\tif(proc->start==time_cycle) {\n\t\t\t//dequeue from the process queue and enqueue in the ready queue\n\t\t\tdequeue(pqueue, &temp, &sizetemp);\n\t\t\tprocess *proc = temp;\n\t\t\tenqueue(ready,proc,sizeof(process));\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tCopies the current memory and page table states to respective strings for printing at endtime.\n\t@param\texpire The time at which the memory clone is taking place. Used for time stamping the output file.\n\t@return 1 if the clone is successful, 0 otherwise\n*/\n", "func_signal": "int clonePage(int *expire)", "code": "{\n\t//malloc for the first part of the page table header\n\tpage_out = malloc(20*sizeof(char)+1);\n\tstrcat(page_out,\"<-- Page Table At t=\");\n\n\t//malloc for the header of the physical memory string\n\tmem_out = malloc(25*sizeof(char)+1);\n\tstrcat(mem_out,\"<-- Physical Memory At t=\");\n\t\n\t//malloc for the header of the virtual memory string\n\tswap_out = malloc(24*sizeof(char)+1);\n\tstrcat(swap_out,\"<-- Virtual Memory At t=\");\n\t\t\n\t//get the expire time as a string\n\tchar buffer[4*sizeof(int)+1];\n\tsprintf(buffer,\"%d\",*expire);\n\t\n\t//realloc for time and end characters. +7 for the string ' -->\\n\\n' and the nullbyte\n\tmem_out = (char*) realloc(mem_out, (strlen(mem_out)*sizeof(char)) + (strlen(buffer)*sizeof(char)) + 7);\n\tstrcat(mem_out,buffer);\n\tstrcat(mem_out,\" -->\\n\\n\");\n\t\n\tswap_out = (char*) realloc(swap_out, (strlen(swap_out)*sizeof(char)) + (strlen(buffer)*sizeof(char)) + 7);\n\tstrcat(swap_out,buffer);\n\tstrcat(swap_out,\" -->\\n\\n\");\n\n\tpage_out = (char*) realloc(page_out, (strlen(page_out)*sizeof(char)) + (strlen(buffer)*sizeof(char)) + 7);\n\tstrcat(page_out,buffer);\n\tstrcat(page_out,\" -->\\n\\n\");\n\t\n\t\n\tchar i_buffer[4*sizeof(int)+1];\n\tchar access_buffer[4*sizeof(int)+1];\n\t\n\tfor(int i=0;i<50;i++) {\n\t\t//convert the name and position into strings\n\t\tsprintf(buffer,\"%d \",paget[i][0]);\n\t\tsprintf(access_buffer,\"%d\\n\",paget[i][1]);\n\t\tsprintf(i_buffer,\"%d\",i);\n\t\t\n\t\t//append to the page table string. +11 is for the strings \"Frame \" & \" -- \" and the nullbyte\n\t\tpage_out = (char*) realloc(page_out, (strlen(page_out)*sizeof(char)) + (strlen(i_buffer)*sizeof(char)) +11);\n\t\tstrcat(page_out,\"Frame \");\n\t\tstrcat(page_out,i_buffer);\n\t\tstrcat(page_out,\" -- \");\n\t\t\n\t\t//if the page is used, print the job. +5 for the strings \"Job \" plus the nullbyte\n\t\tif(strcmp(buffer,\"-1 \") != 0) {\n\t\t\tpage_out = (char*) realloc(page_out, (strlen(page_out)*sizeof(char)) + (strlen(buffer)*sizeof(char)) + (strlen(access_buffer)*sizeof(char)) +5);\n\t\t\tstrcat(page_out,\"Job \");\n\t\t\tstrcat(page_out,buffer);\n\t\t\tstrcat(page_out,access_buffer);\n\t\t}else{\n\t\t\t//else page is empty, so print empty. +7 for the string \"Empty\\n\" and the nullbyte\n\t\t\tpage_out = (char*) realloc(page_out, (strlen(page_out)*sizeof(char)) + 7);\n\t\t\tstrcat(page_out,\"Empty\\n\");\n\t\t}\n\t\t\n\t\t//fill memory string. +2 for the newline and the nullbyte\n\t\tmem_out = (char*) realloc(mem_out, (strlen(mem_out)*sizeof(char)) + (strlen(mem[i])*sizeof(char)) + 2);\n\t\tstrcat(mem_out,mem[i]);\n\t\tstrcat(mem_out,\"\\n\");\n\t}\n\t\n\tfor(int i=0;i<150;i++) {\n\t\t//fill swap string. +2 for the newline and the nullbyte\n\t\tswap_out = (char*) realloc(swap_out, (strlen(swap_out)*sizeof(char)) + (strlen(swap[i])*sizeof(char)) + 2);\n\t\tstrcat(swap_out,swap[i]);\n\t\tstrcat(swap_out,\"\\n\");\n\t}\n\treturn 1;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** Writes the process's cpu access history to the output file\n\t@param proc The process that has just completed/terminated\n*/\n", "func_signal": "void output(process *proc)", "code": "{\n\t//create the output file for writing to\t\n\tFILE *file;\n\tif ((file = fopen(\"out.file\",\"a\")) == NULL) {\n\t\tprintf(\"Failed to create/open the file\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tfprintf(file,\"%s \",proc->name);\n\tvoid *vp;\n\tsize_t sizetemp;\n\tint *ip;\n\twhile(!isEmpty(proc->run)) {\n\t\tdequeue(proc->run,&vp,&sizetemp);\n\t\tip = vp;\n\t\tfprintf(file,\"(%d,%d) \",*ip,*(ip+1));\n\t\tfree(vp);\n\t}\n\tfprintf(file,\"\\n\");\n\tfflush(file);\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tSimulates the Shortest Process Next scheduling algorithm.\n\t@param pqueue The queue of all available processes\n\t@param expire The time at which the memory state is cloned for printing to the output file\n\t@param mode The program mode. 0 represents Scheduler mode, 1 represents Virtual Memory mode\n*/\n", "func_signal": "void shortestNext(QUEUE *pqueue,int *expire, int *mode)", "code": "{\n\tvoid *temp;\t\t\t\t\t\t//pointer to the current process\n\tQUEUE *ready = init(\"ready\");\t//queue holding all ready processes at the given time cycle\n\tsize_t sizetemp = 0;\t\t\t//size of the current element being peeked at or dequeued\t\n\tint time_cycle = 0;\t\t\t\t//counter representing cpu ticks (Hz)\n\tint counter = 0;\t\t\t\t//records the process cpu access count\n\tint *data;\t\t\t\t\t\t//holds the start time and duration of each cycle of each process\n\tint pid;\t\t\t\t\t\t//the process name as an integer. used to reference the page table to determine whether the process is cached\n\tbool running = true;\t\t\t//flag that indicates whether a process is accessing the cpu. Dictates whether the ready queue is sorted or not. \n\tint success = 1;\t\t\t\t//indicates whether the process was successfully cached\n\tint state_clone = 0;\t\t\t//indicates whether the memory state has already been cloned\n\t\n\t//simulate time cycles with a loop and for each cycle, queue the available processes in a new queue (ready queue)\n\twhile(!isEmpty(pqueue) || !isEmpty(ready)) {\n\t\t//find the ready processes given the current time cycle\n\t\tgetReady(pqueue,ready,time_cycle);\n\t\t\n\t\t//if there are processes ready, sort them by duration and grant access to the first (shortest)\n\t\tif(!isEmpty(ready)) {\n\t\t\t//sort the ready queue if need be. Only need to sort when awaiting a change (new process). ie when no process in currently accessing the cpu\n\t\t\tif(running == false)\n\t\t\t{\n\t\t\t\tsortSPN(ready);\n\t\t\t\trunning = true; \n\t\t\t}\n\t\t\t\n\t\t\t//grab the process\n\t\t\tpeek(ready, &temp, &sizetemp);\n\t\t\tprocess *proc = temp;\n\t\t\tsuccess = 1;\n\t\t\t\n\t\t\t//load the process into memory, if not already there\n\t\t\tif(*mode == 1) {\n\t\t\t\tpid = getName(proc);\n\t\t\t\tif(!isCached(pid)) {\n\t\t\t\t\tsuccess = cache(proc,&pid,&time_cycle);\n\t\t\t\t}else {\n\t\t\t\t\tupdateTime(&pid,&time_cycle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//simulate cpu access if the mode is scheduler, or if the mode is memory and the process IS cached\n\t\t\t//if the process has not been cached it cannot be processed, so another must be found for the current cycle\n\t\t\tif(success == 1) {\n\t\t\t\tproc->duration--;\n\t\t\t\tprintf(\"Processing %s\\n\",proc->name);\n\t\t\t\tcounter++;\n\t\t\t\ttime_cycle++;\n\t\t\t}else {\n\t\t\t\t//add any full-system shuffle algs here\n\t\t\t\t//add current process to back of the queue (cycles through processes in the case of a bloated system)\n\t\t\t\tdequeue(ready,&temp,&sizetemp);\n\t\t\t\tenqueue(ready,(process*)temp,sizetemp);\n\t\t\t}\n\t\t\t\n\t\t\t//if the process terminates, reset the count and dequeue the process\n\t\t\tif(proc->duration == 0) {\n\t\t\t\tprintf(\"Completed  %s at t=%d\\n\",proc->name,time_cycle); \n\t\t\t\t//add the processing data to the 'run' queue in the process structure\n\t\t\t\tdata = malloc(2*sizeof(int));\n\t\t\t\tdata[0] = time_cycle-counter;\n\t\t\t\tdata[1] = counter;\n\t\t\t\tenqueue(proc->run,(void*)data,sizeof(data));\n\t\t\t\t//print the process data to the output file\n\t\t\t\toutput((process*)temp);\n\t\t\t\t//free virtual memory\n\t\t\t   \tif(*mode == 1) {\n\t\t\t   \t\tfreeProc(&pid);\t\n\t\t\t   \t}\n\t\t\t\t//dequeue and free the finished process\n\t\t\t    dequeue(ready, &temp, &sizetemp);\n\t\t\t    free(temp);\n\t\t\t    //reset the access counter\n\t\t\t\tcounter = 0;\n\t\t\t    //reset the run flag\n\t\t\t  \trunning = false;\n\t\t\t}\n\t\t\t//handle the memory save\n\t\t\tif(*mode == 1 && time_cycle == *expire && state_clone == 0) {state_clone = clonePage(expire);}\n\t\t}else{\n\t\t\ttime_cycle++;\n\t\t}\n\t}\n\t//if the expire time is larger than the required completion time, let the output string represent the final memory state\n\tif(*mode == 1 && *expire > time_cycle) {\n\t\tclonePage(expire);\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** Checks whether the indicated process is currently in memory by scanning the page table.\n\t@param pid The name of the process\n\t@return true if the process is found in memory, false otherwise\n*/\n", "func_signal": "bool isCached(int pid)", "code": "{\n\tfor(int i=0;i<50;i++) {\n\t\tif(paget[i][0] == pid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tAdds an element to the back of the queue\n\t@param queue The queue that will be added to\n\t@param data Void pointer that holds the location of the payload item to be added\n\t@param size Stores the size of the payload item to be added\n\t@return 0 if the operation is successful, 1 otherwise\n*/\n", "func_signal": "int enqueue(QUEUE* queue, void* data, size_t size)", "code": "{\n\tLINK* newLink;\n\tnewLink = (LINK *) malloc(sizeof (LINK));\n\tif(newLink == NULL)\n\t{\n\t\treturn 1;\n\t}\n\tnewLink->size = size;\n\tnewLink->payload = data;\n\t\n\tqueue->end->successor->next = newLink;\n\tnewLink->next = queue->end;\n\tqueue->end->successor = newLink;\n\treturn 0;\n}", "path": "prosimCLI\\src\\queue.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** @brief replacement of strdup, which is not standard */\n", "func_signal": "char *\ngengetopt_strdup (const char *s)", "code": "{\n  char *result = NULL;\n  if (!s)\n    return result;\n\n  result = (char*)malloc(strlen(s) + 1);\n  if (result == (char*)0)\n    return (char*)0;\n  strcpy(result, s);\n  return result;\n}", "path": "prosimCLI\\src\\cmdline.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tSorts the initial process array by start time,then enqueues the processes into the process queue\n\t@param proc The array of processes read from the input file\n\t@param length The number of processes\n\t@return The (sorted) process queue\n*/\n", "func_signal": "QUEUE * sort(process **proc, int length)", "code": "{\n\tint swap_count;\n\tQUEUE *pqueue = init(\"pqueue\");\n\t\n\t//sort the processes within the array\n\twhile(true) {\n\t\tswap_count = 0;\n\t\tfor(int i =0;i<length-1;i++) {\n\t\t\tif(proc[i]->start > proc[i+1]->start) {\n\t\t\t\tprocess *temp = proc[i];\t\n\t\t\t\tproc[i] = proc[i+1];\n\t\t\t\tproc[i+1] = temp;\n\t\t\t\tswap_count++;\n\t\t\t}\n\t\t}\n\t\tif(swap_count==0) {break;}\n\t}\n\t\n\t//enqueue the processes whilst initialising their 'run' queues (to store process run-time information)\n\tfor(int i=0;i<length;i++) {\n\t\tproc[i]->run = init(\"run\");\n\t\tenqueue(pqueue,proc[i],sizeof(proc[i]));\n\t}\n\treturn pqueue;\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/** Updates the time stamp within the page table for the desired process.\n\t@param pid The process id of the process to be modified within the page table\n\t@param time_cycle The new access time\n*/\n", "func_signal": "void updateTime(int *pid,int *time_cycle)", "code": "{\n\tfor(int i=0;i<50;i++) {\n\t\tif(paget[i][0] == *pid) {\n\t\t\tpaget[i][1] = *time_cycle;\t\n\t\t}\t\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tDebug method for printing the unsorted array of processes, taken fro the input file.\n\t@param proc The array of processes read from the input file\n\t@param length The number of processes\n*/\n", "func_signal": "void print(process *proc,int length)", "code": "{\n\tint cur=0;\n  \twhile(cur < length) {\n  \t\tprintf(\"read '%s %d %d'\\n\",proc[cur].name,proc[cur].start,proc[cur].duration);\n  \t\tcur++;\n  \t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/**\tSorts the ready queue by process duration, shortest process first.\n\t@param ready The queue of ready processes \n*/\n", "func_signal": "void sortSPN(QUEUE * ready)", "code": "{\n\tint swap_count;\t//counter that indicates whether a change was made to the queue in the last pass. Used for termination of sorting loop.\n\tLINK *link = ready->start->next;\n\tint duration1;\n\tint duration2;\n\tprocess *proc;\n\t//sort the processes\n\twhile(true) {\n\t\tswap_count = 0;\n\t\tlink = ready->start->next;\n\t\twhile(link->next != ready->end) {\n\t\t\t\n\t\t\t//find duration of the current and next processes (within the current and next links)\n\t\t\tduration1 = ((process*)link->payload)->duration;\n\t\t\tduration2 = ((process*)link->next->payload)->duration;\n\t\t\tif(duration2 < duration1) {\n\t\t\t\t//swap the processes within the links (ie do not change queue structure)\n\t\t\t\tproc = (process*)link->payload;\n\t\t\t\tlink->payload = link->next->payload;\n\t\t\t\tlink->next->payload = proc;\n\t\t\t\tswap_count++;\n\t\t\t}\n\t\t\tlink = link->next;\n\t\t}\n\t\tif(swap_count==0) {break;}\n\t}\n}", "path": "prosimCLI\\src\\reader.c", "repo_name": "yoda/Scheduler", "stars": 2, "license": "None", "language": "c", "size": 6388}
{"docstring": "/* Translate target's address to host's address.  */\n", "func_signal": "static void *\nt2h_addr (host_callback *cb, struct cb_syscall *sc,\n          unsigned long taddr)", "code": "{\n  extern sim_core_trans_addr (SIM_DESC, sim_cpu *, unsigned, address_word);\n  void *addr;\n  SIM_DESC sd = (SIM_DESC) sc->p1;\n  SIM_CPU *cpu = (SIM_CPU *) sc->p2;\n\n  if (taddr == 0)\n    return NULL;\n\n  return sim_core_trans_addr (sd, cpu, read_map, taddr);\n}", "path": "sim\\m32r\\traps-linux.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* MEM format.  */\n/* Returns instruction length: 4 or 8.  */\n", "func_signal": "static int\nmem (bfd_vma memaddr, unsigned long word1, unsigned long word2, int noprint)", "code": "{\n  int i, j;\n  int len;\n  int mode;\n  int offset;\n  const char *reg1, *reg2, *reg3;\n\n  /* This lookup table is too sparse to make it worth typing in, but not\n     so large as to make a sparse array necessary.  We create the table\n     at runtime.  */\n\n  /* NOTE: In this table, the meaning of 'numops' is:\n      1: single operand\n      2: 2 operands, load instruction\n     -2: 2 operands, store instruction.  */\n  static struct tabent *mem_tab;\n  /* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */\n#define MEM_MIN\t0x80\n#define MEM_MAX\t0xcf\n#define MEM_SIZ\t( * sizeof(struct tabent))\n\n  static const struct sparse_tabent mem_init[] = {\n    { 0x80,\t\"ldob\",\t 2 },\n    { 0x82,\t\"stob\",\t-2 },\n    { 0x84,\t\"bx\",\t 1 },\n    { 0x85,\t\"balx\",\t 2 },\n    { 0x86,\t\"callx\", 1 },\n    { 0x88,\t\"ldos\",\t 2 },\n    { 0x8a,\t\"stos\",\t-2 },\n    { 0x8c,\t\"lda\",\t 2 },\n    { 0x90,\t\"ld\",\t 2 },\n    { 0x92,\t\"st\",\t-2 },\n    { 0x98,\t\"ldl\",\t 2 },\n    { 0x9a,\t\"stl\",\t-2 },\n    { 0xa0,\t\"ldt\",\t 2 },\n    { 0xa2,\t\"stt\",\t-2 },\n    { 0xac,\t\"dcinva\", 1 },\n    { 0xb0,\t\"ldq\",\t 2 },\n    { 0xb2,\t\"stq\",\t-2 },\n    { 0xc0,\t\"ldib\",\t 2 },\n    { 0xc2,\t\"stib\",\t-2 },\n    { 0xc8,\t\"ldis\",\t 2 },\n    { 0xca,\t\"stis\",\t-2 },\n    { 0,\tNULL,\t0 }\n  };\n  static struct tabent mem_tab_buf[MEM_MAX - MEM_MIN + 1];\n\n  if (mem_tab == NULL)\n    {\n      mem_tab = mem_tab_buf;\n\n      for (i = 0; mem_init[i].opcode != 0; i++)\n\t{\n\t  j = mem_init[i].opcode - MEM_MIN;\n\t  mem_tab[j].name = mem_init[i].name;\n\t  mem_tab[j].numops = mem_init[i].numops;\n\t}\n    }\n\n  i = ((word1 >> 24) & 0xff) - MEM_MIN;\n  mode = (word1 >> 10) & 0xf;\n\n  if ((mem_tab[i].name != NULL)\t\t/* Valid instruction */\n      && ((mode == 5) || (mode >= 12)))\n    /* With 32-bit displacement.  */\n    len = 8;\n  else\n    len = 4;\n\n  if (noprint)\n    return len;\n\n  if ((mem_tab[i].name == NULL) || (mode == 6))\n    {\n      invalid (word1);\n      return len;\n    }\n\n  (*info->fprintf_func) (stream, \"%s\\t\", mem_tab[i].name);\n\n  reg1 = reg_names[ (word1 >> 19) & 0x1f ];\t/* MEMB only */\n  reg2 = reg_names[ (word1 >> 14) & 0x1f ];\n  reg3 = reg_names[ word1 & 0x1f ];\t\t/* MEMB only */\n  offset = word1 & 0xfff;\t\t\t\t/* MEMA only  */\n\n  switch (mem_tab[i].numops)\n    {\n    case 2: /* LOAD INSTRUCTION */\n      if (mode & 4)\n\t{\t\t\t/* MEMB FORMAT */\n\t  ea (memaddr, mode, reg2, reg3, word1, word2);\n\t  (*info->fprintf_func) (stream, \",%s\", reg1);\n\t}\n      else\n\t{\t\t\t\t/* MEMA FORMAT */\n\t  (*info->fprintf_func) (stream, \"0x%x\", (unsigned) offset);\n\n\t  if (mode & 8)\n\t    (*info->fprintf_func) (stream, \"(%s)\", reg2);\n\n\t  (*info->fprintf_func)(stream, \",%s\", reg1);\n\t}\n      break;\n\n    case -2: /* STORE INSTRUCTION */\n      if (mode & 4)\n\t{\n\t  /* MEMB FORMAT */\n\t  (*info->fprintf_func) (stream, \"%s,\", reg1);\n\t  ea (memaddr, mode, reg2, reg3, word1, word2);\n\t}\n      else\n\t{\n\t  /* MEMA FORMAT */\n\t  (*info->fprintf_func) (stream, \"%s,0x%x\", reg1, (unsigned) offset);\n\n\t  if (mode & 8)\n\t    (*info->fprintf_func) (stream, \"(%s)\", reg2);\n\t}\n      break;\n\n    case 1: /* BX/CALLX INSTRUCTION */\n      if (mode & 4)\n\t{\n\t  /* MEMB FORMAT */\n\t  ea (memaddr, mode, reg2, reg3, word1, word2);\n\t}\n      else\n\t{\n\t  /* MEMA FORMAT */\n\t  (*info->fprintf_func) (stream, \"0x%x\", (unsigned) offset);\n\t  if (mode & 8)\n\t    (*info->fprintf_func) (stream, \"(%s)\", reg2);\n\t}\n      break;\n    }\n\n  return len;\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Read/write functions for system call interface.  */\n", "func_signal": "static int\nsyscall_read_mem (host_callback *cb, struct cb_syscall *sc,\n\t\t  unsigned long taddr, char *buf, int bytes)", "code": "{\n  SIM_DESC sd = (SIM_DESC) sc->p1;\n  SIM_CPU *cpu = (SIM_CPU *) sc->p2;\n\n  return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);\n}", "path": "sim\\m32r\\traps-linux.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Print an error message and bump the error count.  LINE is the line\n   number where we detected the error, ERRMSG is the error to\n   print.  */\n", "func_signal": "static void\nerror (int line, const char *errmsg)", "code": "{\n  fprintf (stderr, \"test-pexecute:%d: %s\\n\", line, errmsg);\n  ++error_count;\n}", "path": "libiberty\\testsuite\\test-pexecute.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Check a line in a file.  */\n", "func_signal": "static void\ncheck_line (int line, FILE *e, const char *str)", "code": "{\n  const char *p;\n  int c;\n  char buf[1000];\n\n  p = str;\n  while (1)\n    {\n      c = getc (e);\n\n      if (*p == '\\0')\n\t{\n\t  if (c != '\\n')\n\t    {\n\t      snprintf (buf, sizeof buf, \"got '%c' when expecting newline\", c);\n\t      fatal_error (line, buf, 0);\n\t    }\n\t  c = getc (e);\n\t  if (c != EOF)\n\t    {\n\t      snprintf (buf, sizeof buf, \"got '%c' when expecting EOF\", c);\n\t      fatal_error (line, buf, 0);\n\t    }\n\t  return;\n\t}\n\n      if (c != *p)\n\t{\n\t  snprintf (buf, sizeof buf, \"expected '%c', got '%c'\", *p, c);\n\t  fatal_error (line, buf, 0);\n\t}\n\n      ++p;\n    }\n}", "path": "libiberty\\testsuite\\test-pexecute.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* read and write */\n", "func_signal": "static int\ndecode_addr (struct hw *me,\n\t     struct mn103iop *io_port,\n\t     unsigned_word address)", "code": "{\n  unsigned_word offset;\n  offset = address - io_port->block[0].base;\n  switch (offset)\n    {\n    case 0x00: return P0OUT;\n    case 0x01: return P1OUT;\n    case 0x04: return P2OUT;\n    case 0x05: return P3OUT;\n    case 0x20: return P0MD;\n    case 0x21: return P1MD;\n    case 0x24: return P2MD;\n    case 0x25: return P3MD;\n    case 0x44: return P2SS;\n    case 0x48: return P4SS;\n    case 0x60: return P0DIR;\n    case 0x61: return P1DIR;\n    case 0x64: return P2DIR;\n    case 0x65: return P3DIR;\n    case 0x80: return P0IN;\n    case 0x81: return P1IN;\n    case 0x84: return P2IN;\n    case 0x85: return P3IN;\n    default: \n      {\n\thw_abort (me, \"bad address\");\n\treturn -1;\n      }\n    }\n}", "path": "sim\\mn10300\\dv-mn103iop.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* REG format.  */\n", "func_signal": "static void\nreg (unsigned long word1)", "code": "{\n  int i, j;\n  int opcode;\n  int fp;\n  int m1, m2, m3;\n  int s1, s2;\n  int src, src2, dst;\n  char *mnemp;\n\n  /* This lookup table is too sparse to make it worth typing in, but not\n     so large as to make a sparse array necessary.  We create the table\n     at runtime.  */\n\n  /* NOTE: In this table, the meaning of 'numops' is:\n\t 1: single operand, which is NOT a destination.\n\t-1: single operand, which IS a destination.\n\t 2: 2 operands, the 2nd of which is NOT a destination.\n\t-2: 2 operands, the 2nd of which IS a destination.\n\t 3: 3 operands\n\n\tIf an opcode mnemonic begins with \"F\", it is a floating-point\n\topcode (the \"F\" is not printed).  */\n\n  static struct tabent *reg_tab;\n  static const struct sparse_tabent reg_init[] =\n  {\n#define REG_MIN\t0x580\n    { 0x580,\t\"notbit\",\t3 },\n    { 0x581,\t\"and\",\t\t3 },\n    { 0x582,\t\"andnot\",\t3 },\n    { 0x583,\t\"setbit\",\t3 },\n    { 0x584,\t\"notand\",\t3 },\n    { 0x586,\t\"xor\",\t\t3 },\n    { 0x587,\t\"or\",\t\t3 },\n    { 0x588,\t\"nor\",\t\t3 },\n    { 0x589,\t\"xnor\",\t\t3 },\n    { 0x58a,\t\"not\",\t\t-2 },\n    { 0x58b,\t\"ornot\",\t3 },\n    { 0x58c,\t\"clrbit\",\t3 },\n    { 0x58d,\t\"notor\",\t3 },\n    { 0x58e,\t\"nand\",\t\t3 },\n    { 0x58f,\t\"alterbit\",\t3 },\n    { 0x590,\t\"addo\",\t\t3 },\n    { 0x591,\t\"addi\",\t\t3 },\n    { 0x592,\t\"subo\",\t\t3 },\n    { 0x593,\t\"subi\",\t\t3 },\n    { 0x594,\t\"cmpob\",\t2 },\n    { 0x595,\t\"cmpib\",\t2 },\n    { 0x596,\t\"cmpos\",\t2 },\n    { 0x597,\t\"cmpis\",\t2 },\n    { 0x598,\t\"shro\",\t\t3 },\n    { 0x59a,\t\"shrdi\",\t3 },\n    { 0x59b,\t\"shri\",\t\t3 },\n    { 0x59c,\t\"shlo\",\t\t3 },\n    { 0x59d,\t\"rotate\",\t3 },\n    { 0x59e,\t\"shli\",\t\t3 },\n    { 0x5a0,\t\"cmpo\",\t\t2 },\n    { 0x5a1,\t\"cmpi\",\t\t2 },\n    { 0x5a2,\t\"concmpo\",\t2 },\n    { 0x5a3,\t\"concmpi\",\t2 },\n    { 0x5a4,\t\"cmpinco\",\t3 },\n    { 0x5a5,\t\"cmpinci\",\t3 },\n    { 0x5a6,\t\"cmpdeco\",\t3 },\n    { 0x5a7,\t\"cmpdeci\",\t3 },\n    { 0x5ac,\t\"scanbyte\",\t2 },\n    { 0x5ad,\t\"bswap\",\t-2 },\n    { 0x5ae,\t\"chkbit\",\t2 },\n    { 0x5b0,\t\"addc\",\t\t3 },\n    { 0x5b2,\t\"subc\",\t\t3 },\n    { 0x5b4,\t\"intdis\",\t0 },\n    { 0x5b5,\t\"inten\",\t0 },\n    { 0x5cc,\t\"mov\",\t\t-2 },\n    { 0x5d8,\t\"eshro\",\t3 },\n    { 0x5dc,\t\"movl\",\t\t-2 },\n    { 0x5ec,\t\"movt\",\t\t-2 },\n    { 0x5fc,\t\"movq\",\t\t-2 },\n    { 0x600,\t\"synmov\",\t2 },\n    { 0x601,\t\"synmovl\",\t2 },\n    { 0x602,\t\"synmovq\",\t2 },\n    { 0x603,\t\"cmpstr\",\t3 },\n    { 0x604,\t\"movqstr\",\t3 },\n    { 0x605,\t\"movstr\",\t3 },\n    { 0x610,\t\"atmod\",\t3 },\n    { 0x612,\t\"atadd\",\t3 },\n    { 0x613,\t\"inspacc\",\t-2 },\n    { 0x614,\t\"ldphy\",\t-2 },\n    { 0x615,\t\"synld\",\t-2 },\n    { 0x617,\t\"fill\",\t\t3 },\n    { 0x630,\t\"sdma\",\t\t3 },\n    { 0x631,\t\"udma\",\t\t0 },\n    { 0x640,\t\"spanbit\",\t-2 },\n    { 0x641,\t\"scanbit\",\t-2 },\n    { 0x642,\t\"daddc\",\t3 },\n    { 0x643,\t\"dsubc\",\t3 },\n    { 0x644,\t\"dmovt\",\t-2 },\n    { 0x645,\t\"modac\",\t3 },\n    { 0x646,\t\"condrec\",\t-2 },\n    { 0x650,\t\"modify\",\t3 },\n    { 0x651,\t\"extract\",\t3 },\n    { 0x654,\t\"modtc\",\t3 },\n    { 0x655,\t\"modpc\",\t3 },\n    { 0x656,\t\"receive\",\t-2 },\n    { 0x658,\t\"intctl\",\t-2 },\n    { 0x659,\t\"sysctl\",\t3 },\n    { 0x65b,\t\"icctl\",\t3 },\n    { 0x65c,\t\"dcctl\",\t3 },\n    { 0x65d,\t\"halt\",\t\t0 },\n    { 0x660,\t\"calls\",\t1 },\n    { 0x662,\t\"send\",\t\t3 },\n    { 0x663,\t\"sendserv\",\t1 },\n    { 0x664,\t\"resumprcs\",\t1 },\n    { 0x665,\t\"schedprcs\",\t1 },\n    { 0x666,\t\"saveprcs\",\t0 },\n    { 0x668,\t\"condwait\",\t1 },\n    { 0x669,\t\"wait\",\t\t1 },\n    { 0x66a,\t\"signal\",\t1 },\n    { 0x66b,\t\"mark\",\t\t0 },\n    { 0x66c,\t\"fmark\",\t0 },\n    { 0x66d,\t\"flushreg\",\t0 },\n    { 0x66f,\t\"syncf\",\t0 },\n    { 0x670,\t\"emul\",\t\t3 },\n    { 0x671,\t\"ediv\",\t\t3 },\n    { 0x673,\t\"ldtime\",\t-1 },\n    { 0x674,\t\"Fcvtir\",\t-2 },\n    { 0x675,\t\"Fcvtilr\",\t-2 },\n    { 0x676,\t\"Fscalerl\",\t3 },\n    { 0x677,\t\"Fscaler\",\t3 },\n    { 0x680,\t\"Fatanr\",\t3 },\n    { 0x681,\t\"Flogepr\",\t3 },\n    { 0x682,\t\"Flogr\",\t3 },\n    { 0x683,\t\"Fremr\",\t3 },\n    { 0x684,\t\"Fcmpor\",\t2 },\n    { 0x685,\t\"Fcmpr\",\t2 },\n    { 0x688,\t\"Fsqrtr\",\t-2 },\n    { 0x689,\t\"Fexpr\",\t-2 },\n    { 0x68a,\t\"Flogbnr\",\t-2 },\n    { 0x68b,\t\"Froundr\",\t-2 },\n    { 0x68c,\t\"Fsinr\",\t-2 },\n    { 0x68d,\t\"Fcosr\",\t-2 },\n    { 0x68e,\t\"Ftanr\",\t-2 },\n    { 0x68f,\t\"Fclassr\",\t1 },\n    { 0x690,\t\"Fatanrl\",\t3 },\n    { 0x691,\t\"Flogeprl\",\t3 },\n    { 0x692,\t\"Flogrl\",\t3 },\n    { 0x693,\t\"Fremrl\",\t3 },\n    { 0x694,\t\"Fcmporl\",\t2 },\n    { 0x695,\t\"Fcmprl\",\t2 },\n    { 0x698,\t\"Fsqrtrl\",\t-2 },\n    { 0x699,\t\"Fexprl\",\t-2 },\n    { 0x69a,\t\"Flogbnrl\",\t-2 },\n    { 0x69b,\t\"Froundrl\",\t-2 },\n    { 0x69c,\t\"Fsinrl\",\t-2 },\n    { 0x69d,\t\"Fcosrl\",\t-2 },\n    { 0x69e,\t\"Ftanrl\",\t-2 },\n    { 0x69f,\t\"Fclassrl\",\t1 },\n    { 0x6c0,\t\"Fcvtri\",\t-2 },\n    { 0x6c1,\t\"Fcvtril\",\t-2 },\n    { 0x6c2,\t\"Fcvtzri\",\t-2 },\n    { 0x6c3,\t\"Fcvtzril\",\t-2 },\n    { 0x6c9,\t\"Fmovr\",\t-2 },\n    { 0x6d9,\t\"Fmovrl\",\t-2 },\n    { 0x6e1,\t\"Fmovre\",\t-2 },\n    { 0x6e2,\t\"Fcpysre\",\t3 },\n    { 0x6e3,\t\"Fcpyrsre\",\t3 },\n    { 0x701,\t\"mulo\",\t\t3 },\n    { 0x708,\t\"remo\",\t\t3 },\n    { 0x70b,\t\"divo\",\t\t3 },\n    { 0x741,\t\"muli\",\t\t3 },\n    { 0x748,\t\"remi\",\t\t3 },\n    { 0x749,\t\"modi\",\t\t3 },\n    { 0x74b,\t\"divi\",\t\t3 },\n    { 0x780,\t\"addono\",\t3 },\n    { 0x781,\t\"addino\",\t3 },\n    { 0x782,\t\"subono\",\t3 },\n    { 0x783,\t\"subino\",\t3 },\n    { 0x784,\t\"selno\",\t3 },\n    { 0x78b,\t\"Fdivr\",\t3 },\n    { 0x78c,\t\"Fmulr\",\t3 },\n    { 0x78d,\t\"Fsubr\",\t3 },\n    { 0x78f,\t\"Faddr\",\t3 },\n    { 0x790,\t\"addog\",\t3 },\n    { 0x791,\t\"addig\",        3 },\n    { 0x792,\t\"subog\",\t3 },\n    { 0x793,\t\"subig\",\t3 },\n    { 0x794,\t\"selg\",\t\t3 },\n    { 0x79b,\t\"Fdivrl\",\t3 },\n    { 0x79c,\t\"Fmulrl\",\t3 },\n    { 0x79d,\t\"Fsubrl\",\t3 },\n    { 0x79f,\t\"Faddrl\",\t3 },\n    { 0x7a0,\t\"addoe\",\t3 },\n    { 0x7a1,\t\"addie\",        3 },\n    { 0x7a2,\t\"suboe\",\t3 },\n    { 0x7a3,\t\"subie\",\t3 },\n    { 0x7a4,\t\"sele\",\t\t3 },\n    { 0x7b0,\t\"addoge\",\t3 },\n    { 0x7b1,\t\"addige\",\t3 },\n    { 0x7b2,\t\"suboge\",\t3 },\n    { 0x7b3,\t\"subige\",\t3 },\n    { 0x7b4,\t\"selge\",\t3 },\n    { 0x7c0,\t\"addol\",\t3 },\n    { 0x7c1,\t\"addil\",\t3 },\n    { 0x7c2,\t\"subol\",\t3 },\n    { 0x7c3,\t\"subil\",\t3 },\n    { 0x7c4,\t\"sell\",\t\t3 },\n    { 0x7d0,\t\"addone\",\t3 },\n    { 0x7d1,\t\"addine\",\t3 },\n    { 0x7d2,\t\"subone\",\t3 },\n    { 0x7d3,\t\"subine\",\t3 },\n    { 0x7d4,\t\"selne\",\t3 },\n    { 0x7e0,\t\"addole\",\t3 },\n    { 0x7e1,\t\"addile\",\t3 },\n    { 0x7e2,\t\"subole\",\t3 },\n    { 0x7e3,\t\"subile\",\t3 },\n    { 0x7e4,\t\"selle\",\t3 },\n    { 0x7f0,\t\"addoo\",\t3 },\n    { 0x7f1,\t\"addio\",\t3 },\n    { 0x7f2,\t\"suboo\",\t3 },\n    { 0x7f3,\t\"subio\",\t3 },\n    { 0x7f4,\t\"selo\",\t\t3 },\n#define REG_MAX 0x7f4\n    { 0,\tNULL,\t\t0 }\n  };\n  static struct tabent reg_tab_buf[REG_MAX - REG_MIN + 1];\n\n  if (reg_tab == NULL)\n    {\n      reg_tab = reg_tab_buf;\n\n      for (i = 0; reg_init[i].opcode != 0; i++)\n\t{\n\t  j = reg_init[i].opcode - REG_MIN;\n\t  reg_tab[j].name = reg_init[i].name;\n\t  reg_tab[j].numops = reg_init[i].numops;\n\t}\n    }\n\n  opcode = ((word1 >> 20) & 0xff0) | ((word1 >> 7) & 0xf);\n  i = opcode - REG_MIN;\n\n  if ((opcode<REG_MIN) || (opcode>REG_MAX) || (reg_tab[i].name==NULL))\n    {\n      invalid (word1);\n      return;\n    }\n\n  mnemp = reg_tab[i].name;\n  if (*mnemp == 'F')\n    {\n      fp = 1;\n      mnemp++;\n    }\n  else\n    {\n      fp = 0;\n    }\n\n  (*info->fprintf_func) (stream, mnemp);\n\n  s1   = (word1 >> 5)  & 1;\n  s2   = (word1 >> 6)  & 1;\n  m1   = (word1 >> 11) & 1;\n  m2   = (word1 >> 12) & 1;\n  m3   = (word1 >> 13) & 1;\n  src  =  word1        & 0x1f;\n  src2 = (word1 >> 14) & 0x1f;\n  dst  = (word1 >> 19) & 0x1f;\n\n  if  (reg_tab[i].numops != 0)\n    {\n      (*info->fprintf_func) (stream, \"\\t\");\n\n    switch (reg_tab[i].numops)\n      {\n      case 1:\n\tregop (m1, s1, src, fp);\n\tbreak;\n      case -1:\n\tdstop (m3, dst, fp);\n\tbreak;\n      case 2:\n\tregop (m1, s1, src, fp);\n\t(*info->fprintf_func) (stream, \",\");\n\tregop (m2, s2, src2, fp);\n\tbreak;\n      case -2:\n\tregop (m1, s1, src, fp);\n\t(*info->fprintf_func) (stream, \",\");\n\tdstop (m3, dst, fp);\n\tbreak;\n      case 3:\n\tregop (m1, s1, src, fp);\n\t(*info->fprintf_func) (stream, \",\");\n\tregop (m2, s2, src2, fp);\n\t(*info->fprintf_func) (stream, \",\");\n\tdstop (m3, dst, fp);\n\tbreak;\n      }\n    }\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Execute one of the special testing commands.  */\n", "func_signal": "static void\ndo_cmd (int argc, char **argv)", "code": "{\n  const char *s;\n\n  /* Try to prevent generating a core dump.  */\n#ifdef RLIMIT_CORE\n {\n   struct rlimit r;\n\n   r.rlim_cur = 0;\n   r.rlim_max = 0;\n   setrlimit (RLIMIT_CORE, &r);\n }\n#endif\n\n  s = argv[1];\n  if (strcmp (s, \"exit\") == 0)\n    exit (EXIT_SUCCESS);\n  else if (strcmp (s, \"echo\") == 0)\n    {\n      int i;\n\n      for (i = 2; i < argc; ++i)\n\t{\n\t  if (i > 2)\n\t    putchar (' ');\n\t  fputs (argv[i], stdout);\n\t}\n      putchar ('\\n');\n      exit (EXIT_SUCCESS);\n    }\n  else if (strcmp (s, \"echoerr\") == 0)\n    {\n      int i;\n\n      for (i = 2; i < argc; ++i)\n\t{\n\t  if (i > 3)\n\t    putc (' ', (i & 1) == 0 ? stdout : stderr);\n\t  fputs (argv[i], (i & 1) == 0 ? stdout : stderr);\n\t}\n      putc ('\\n', stdout);\n      putc ('\\n', stderr);\n      exit (EXIT_SUCCESS);\n    }\n  else if (strcmp (s, \"error\") == 0)\n    exit (EXIT_FAILURE);\n  else if (strcmp (s, \"abort\") == 0)\n    abort ();\n  else if (strcmp (s, \"copy\") == 0)\n    {\n      int c;\n\n      while ((c = getchar ()) != EOF)\n\tputchar (c);\n      exit (EXIT_SUCCESS);\n    }\n  else if (strcmp (s, \"write\") == 0)\n    {\n      FILE *e;\n      int c;\n\n      e = fopen (argv[2], \"w\");\n      if (e == NULL)\n\tFATAL_ERROR (\"fopen for write failed\", errno);\n      while ((c = getchar ()) != EOF)\n\tputc (c, e);\n      if (fclose (e) != 0)\n\tFATAL_ERROR (\"fclose for write failed\", errno);\n      exit (EXIT_SUCCESS);\n    }\n  else\n    {\n      char buf[1000];\n\n      snprintf (buf, sizeof buf, \"unrecognized command %s\", argv[1]);\n      FATAL_ERROR (buf, 0);\n    }\n\n  exit (EXIT_FAILURE);\n}", "path": "libiberty\\testsuite\\test-pexecute.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* CTRL format.. */\n", "func_signal": "static void\nctrl (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)", "code": "{\n  int i;\n  static const struct tabent ctrl_tab[] = {\n    { NULL,\t\t0, },\t/* 0x00 */\n    { NULL,\t\t0, },\t/* 0x01 */\n    { NULL,\t\t0, },\t/* 0x02 */\n    { NULL,\t\t0, },\t/* 0x03 */\n    { NULL,\t\t0, },\t/* 0x04 */\n    { NULL,\t\t0, },\t/* 0x05 */\n    { NULL,\t\t0, },\t/* 0x06 */\n    { NULL,\t\t0, },\t/* 0x07 */\n    { \"b\",\t\t1, },\t/* 0x08 */\n    { \"call\",\t\t1, },\t/* 0x09 */\n    { \"ret\",\t\t0, },\t/* 0x0a */\n    { \"bal\",\t\t1, },\t/* 0x0b */\n    { NULL,\t\t0, },\t/* 0x0c */\n    { NULL,\t\t0, },\t/* 0x0d */\n    { NULL,\t\t0, },\t/* 0x0e */\n    { NULL,\t\t0, },\t/* 0x0f */\n    { \"bno\",\t\t1, },\t/* 0x10 */\n    { \"bg\",\t\t1, },\t/* 0x11 */\n    { \"be\",\t\t1, },\t/* 0x12 */\n    { \"bge\",\t\t1, },\t/* 0x13 */\n    { \"bl\",\t\t1, },\t/* 0x14 */\n    { \"bne\",\t\t1, },\t/* 0x15 */\n    { \"ble\",\t\t1, },\t/* 0x16 */\n    { \"bo\",\t\t1, },\t/* 0x17 */\n    { \"faultno\",\t0, },\t/* 0x18 */\n    { \"faultg\",\t\t0, },\t/* 0x19 */\n    { \"faulte\",\t\t0, },\t/* 0x1a */\n    { \"faultge\",\t0, },\t/* 0x1b */\n    { \"faultl\",\t\t0, },\t/* 0x1c */\n    { \"faultne\",\t0, },\t/* 0x1d */\n    { \"faultle\",\t0, },\t/* 0x1e */\n    { \"faulto\",\t\t0, },\t/* 0x1f */\n  };\n\n  i = (word1 >> 24) & 0xff;\n  if ((ctrl_tab[i].name == NULL) || ((word1 & 1) != 0))\n    {\n      invalid (word1);\n      return;\n    }\n\n  (*info->fprintf_func) (stream, ctrl_tab[i].name);\n  if (word1 & 2)\n    /* Predicts branch not taken.  */\n    (*info->fprintf_func) (stream, \".f\");\n\n  if (ctrl_tab[i].numops == 1)\n    {\n      /* Extract displacement and convert to address.  */\n      word1 &= 0x00ffffff;\n\n      if (word1 & 0x00800000)\n\t{\n\t  /* Sign bit is set.  */\n\t  word1 |= (-1 & ~0xffffff);\t/* Sign extend.  */\n\t}\n\n      (*info->fprintf_func) (stream, \"\\t\");\n      print_addr (word1 + memaddr);\n    }\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Register Instruction Destination Operand.  */\n", "func_signal": "static void\ndstop (int mode, int reg, int fp)", "code": "{\n  /* 'dst' operand can't be a literal. On non-FP instructions,  register\n     mode is assumed and \"m3\" acts as if were \"s3\";  on FP-instructions,\n     sf registers are not allowed so m3 acts normally.  */\n  if (fp)\n    regop (mode, 0, reg, fp);\n  else\n    regop (0, mode, reg, fp);\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* The semantic code invokes this for invalid (unrecognized) instructions.  */\n", "func_signal": "SEM_PC\nsim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC vpc)", "code": "{\n  SIM_DESC sd = CPU_STATE (current_cpu);\n\n#if 0\n  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n    {\n      h_bsm_set (current_cpu, h_sm_get (current_cpu));\n      h_bie_set (current_cpu, h_ie_get (current_cpu));\n      h_bcond_set (current_cpu, h_cond_get (current_cpu));\n      /* sm not changed */\n      h_ie_set (current_cpu, 0);\n      h_cond_set (current_cpu, 0);\n\n      h_bpc_set (current_cpu, cia);\n\n      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,\n\t\t\t  EIT_RSVD_INSN_ADDR);\n    }\n  else\n#endif\n    sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);\n  return vpc;\n}", "path": "sim\\m32r\\traps-linux.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Print out effective address for memb instructions.  */\n", "func_signal": "static void\nea (bfd_vma memaddr, int mode, const char *reg2, const char *reg3, int word1,\n    unsigned int word2)", "code": "{\n  int scale;\n  static const int scale_tab[] = { 1, 2, 4, 8, 16 };\n\n  scale = (word1 >> 7) & 0x07;\n\n  if ((scale > 4) || (((word1 >> 5) & 0x03) != 0))\n    {\n      invalid (word1);\n      return;\n    }\n  scale = scale_tab[scale];\n\n  switch (mode)\n    {\n    case 4:\t\t\t\t\t\t/* (reg) */\n      (*info->fprintf_func)( stream, \"(%s)\", reg2 );\n      break;\n    case 5:\t\t\t\t\t\t/* displ+8(ip) */\n      print_addr (word2 + 8 + memaddr);\n      break;\n    case 7:\t\t\t\t\t\t/* (reg)[index*scale] */\n      if (scale == 1)\n\t(*info->fprintf_func) (stream, \"(%s)[%s]\", reg2, reg3);\n      else\n\t(*info->fprintf_func) (stream, \"(%s)[%s*%d]\", reg2, reg3, scale);\n      break;\n    case 12:\t\t\t\t\t/* displacement */\n      print_addr ((bfd_vma) word2);\n      break;\n    case 13:\t\t\t\t\t/* displ(reg) */\n      print_addr ((bfd_vma) word2);\n      (*info->fprintf_func) (stream, \"(%s)\", reg2);\n      break;\n    case 14:\t\t\t\t\t/* displ[index*scale] */\n      print_addr ((bfd_vma) word2);\n      if (scale == 1)\n\t(*info->fprintf_func) (stream, \"[%s]\", reg3);\n      else\n\t(*info->fprintf_func) (stream, \"[%s*%d]\", reg3, scale);\n      break;\n    case 15:\t\t\t\t/* displ(reg)[index*scale] */\n      print_addr ((bfd_vma) word2);\n      if (scale == 1)\n\t(*info->fprintf_func) (stream, \"(%s)[%s]\", reg2, reg3);\n      else\n\t(*info->fprintf_func) (stream, \"(%s)[%s*%d]\", reg2, reg3, scale);\n      break;\n    default:\n      invalid (word1);\n      return;\n    }\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Main function for the pexecute tester.  Run the tests.  */\n", "func_signal": "int\nmain (int argc, char **argv)", "code": "{\n  int trace;\n  struct pex_obj *test_pex_tmp;\n  int test_pex_status;\n  FILE *test_pex_file;\n  struct pex_obj *pex1;\n  char *subargv[10];\n  int status;\n  FILE *e;\n  int statuses[10];\n\n  trace = 0;\n  if (argc > 1 && strcmp (argv[1], \"-t\") == 0)\n    {\n      trace = 1;\n      --argc;\n      ++argv;\n    }\n\n  if (argc > 1)\n    do_cmd (argc, argv);\n\n#define TEST_PEX_INIT(FLAGS, TEMPBASE)\t\t\t\t\t\\\n  (((test_pex_tmp = pex_init (FLAGS, \"test-pexecute\", TEMPBASE))\t\\\n    != NULL)\t\t\t\t\t\t\t\t\\\n   ? test_pex_tmp\t\t\t\t\t\t\t\\\n   : (FATAL_ERROR (\"pex_init failed\", 0), NULL))\n\n#define TEST_PEX_RUN(PEXOBJ, FLAGS, EXECUTABLE, ARGV, OUTNAME, ERRNAME)\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      int err;\t\t\t\t\t\t\t\t\\\n      const char *pex_run_err;\t\t\t\t\t\t\\\n      if (trace)\t\t\t\t\t\t\t\\\n\tfprintf (stderr, \"Line %d: running %s %s\\n\",\t\t\t\\\n\t\t __LINE__, EXECUTABLE, ARGV[0]);\t\t\t\\\n      pex_run_err = pex_run (PEXOBJ, FLAGS, EXECUTABLE, ARGV, OUTNAME,\t\\\n\t\t\t     ERRNAME, &err);\t\t\t\t\\\n      if (pex_run_err != NULL)\t\t\t\t\t\t\\\n\tFATAL_ERROR (pex_run_err, err);\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n#define TEST_PEX_GET_STATUS_1(PEXOBJ)\t\t\t\t\t\\\n  (pex_get_status (PEXOBJ, 1, &test_pex_status)\t\t\t\t\\\n   ? test_pex_status\t\t\t\t\t\t\t\\\n   : (FATAL_ERROR (\"pex_get_status failed\", errno), 1))\n\n#define TEST_PEX_GET_STATUS(PEXOBJ, COUNT, VECTOR)\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (!pex_get_status (PEXOBJ, COUNT, VECTOR))\t\t\t\\\n\tFATAL_ERROR (\"pex_get_status failed\", errno);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n#define TEST_PEX_READ_OUTPUT(PEXOBJ)\t\t\t\t\t\\\n  ((test_pex_file = pex_read_output (PEXOBJ, 0)) != NULL\t\t\\\n   ? test_pex_file\t\t\t\t\t\t\t\\\n   : (FATAL_ERROR (\"pex_read_output failed\", errno), NULL))\n\n  remove (\"temp.x\");\n  remove (\"temp.y\");\n\n  memset (subargv, 0, sizeof subargv);\n\n  subargv[0] = \"./test-pexecute\";\n\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n  subargv[1] = \"exit\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, NULL);\n  status = TEST_PEX_GET_STATUS_1 (pex1);\n  if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n    ERROR (\"exit failed\");\n  pex_free (pex1);\n\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n  subargv[1] = \"error\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, NULL);\n  status = TEST_PEX_GET_STATUS_1 (pex1);\n  if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_FAILURE)\n    ERROR (\"error test failed\");\n  pex_free (pex1);\n\n  /* We redirect stderr to a file to avoid an error message which is\n     printed on mingw32 when the child calls abort.  */\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n  subargv[1] = \"abort\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, \"temp.z\");\n  status = TEST_PEX_GET_STATUS_1 (pex1);\n  if (!WIFSIGNALED (status) || WTERMSIG (status) != SIGABRT)\n    ERROR (\"abort failed\");\n  pex_free (pex1);\n  remove (\"temp.z\");\n\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n  subargv[1] = \"echo\";\n  subargv[2] = \"foo\";\n  subargv[3] = NULL;\n  TEST_PEX_RUN (pex1, 0, \"./test-pexecute\", subargv, NULL, NULL);\n  e = TEST_PEX_READ_OUTPUT (pex1);\n  CHECK_LINE (e, \"foo\");\n  if (TEST_PEX_GET_STATUS_1 (pex1) != 0)\n    ERROR (\"echo exit status failed\");\n  pex_free (pex1);\n\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n  subargv[1] = \"echo\";\n  subargv[2] = \"bar\";\n  subargv[3] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n  subargv[1] = \"copy\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n  e = TEST_PEX_READ_OUTPUT (pex1);\n  CHECK_LINE (e, \"bar\");\n  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n    ERROR (\"copy exit status failed\");\n  pex_free (pex1);\n  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n    ERROR (\"temporary files exist\");\n\n  pex1 = TEST_PEX_INIT (0, \"temp\");\n  subargv[1] = \"echo\";\n  subargv[2] = \"bar\";\n  subargv[3] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n  subargv[1] = \"copy\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n  e = TEST_PEX_READ_OUTPUT (pex1);\n  CHECK_LINE (e, \"bar\");\n  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n    ERROR (\"copy exit status failed\");\n  pex_free (pex1);\n  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n    ERROR (\"temporary files exist\");\n\n  pex1 = TEST_PEX_INIT (PEX_SAVE_TEMPS, \"temp\");\n  subargv[1] = \"echo\";\n  subargv[2] = \"quux\";\n  subargv[3] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n  subargv[1] = \"copy\";\n  subargv[2] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n  e = TEST_PEX_READ_OUTPUT (pex1);\n  CHECK_LINE (e, \"quux\");\n  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n    ERROR (\"copy temp exit status failed\");\n  e = fopen (\"temp.x\", \"r\");\n  if (e == NULL)\n    FATAL_ERROR (\"fopen temp.x failed in copy temp\", errno);\n  CHECK_LINE (e, \"quux\");\n  fclose (e);\n  e = fopen (\"temp.y\", \"r\");\n  if (e == NULL)\n    FATAL_ERROR (\"fopen temp.y failed in copy temp\", errno);\n  CHECK_LINE (e, \"quux\");\n  fclose (e);\n  pex_free (pex1);\n  remove (\"temp.x\");\n  remove (\"temp.y\");\n\n  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n  subargv[1] = \"echoerr\";\n  subargv[2] = \"one\";\n  subargv[3] = \"two\";\n  subargv[4] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", \"temp2.x\");\n  subargv[1] = \"write\";\n  subargv[2] = \"temp2.y\";\n  subargv[3] = NULL;\n  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n    ERROR (\"echoerr exit status failed\");\n  pex_free (pex1);\n  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n    ERROR (\"temporary files exist\");\n  e = fopen (\"temp2.x\", \"r\");\n  if (e == NULL)\n    FATAL_ERROR (\"fopen temp2.x failed in echoerr\", errno);\n  CHECK_LINE (e, \"two\");\n  fclose (e);\n  e = fopen (\"temp2.y\", \"r\");\n  if (e == NULL)\n    FATAL_ERROR (\"fopen temp2.y failed in echoerr\", errno);\n  CHECK_LINE (e, \"one\");\n  fclose (e);\n  remove (\"temp2.x\");\n  remove (\"temp2.y\");\n\n  /* Test the old pexecute interface.  */\n  {\n    int pid1, pid2;\n    char *errmsg_fmt;\n    char *errmsg_arg;\n    char errbuf1[1000];\n    char errbuf2[1000];\n\n    subargv[1] = \"echo\";\n    subargv[2] = \"oldpexecute\";\n    subargv[3] = NULL;\n    pid1 = pexecute (\"./test-pexecute\", subargv, \"test-pexecute\", \"temp\",\n\t\t     &errmsg_fmt, &errmsg_arg, PEXECUTE_FIRST);\n    if (pid1 < 0)\n      {\n\tsnprintf (errbuf1, sizeof errbuf1, errmsg_fmt, errmsg_arg);\n\tsnprintf (errbuf2, sizeof errbuf2, \"pexecute 1 failed: %s\", errbuf1);\n\tFATAL_ERROR (errbuf2, 0);\n      }\n\n    subargv[1] = \"write\";\n    subargv[2] = \"temp.y\";\n    subargv[3] = NULL;\n    pid2 = pexecute (\"./test-pexecute\", subargv, \"test-pexecute\", \"temp\",\n\t\t     &errmsg_fmt, &errmsg_arg, PEXECUTE_LAST);\n    if (pid2 < 0)\n      {\n\tsnprintf (errbuf1, sizeof errbuf1, errmsg_fmt, errmsg_arg);\n\tsnprintf (errbuf2, sizeof errbuf2, \"pexecute 2 failed: %s\", errbuf1);\n\tFATAL_ERROR (errbuf2, 0);\n      }\n\n    if (pwait (pid1, &status, 0) < 0)\n      FATAL_ERROR (\"write pwait 1 failed\", errno);\n    if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n      ERROR (\"write exit status 1 failed\");\n\n    if (pwait (pid2, &status, 0) < 0)\n      FATAL_ERROR (\"write pwait 1 failed\", errno);\n    if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n      ERROR (\"write exit status 2 failed\");\n\n    e = fopen (\"temp.y\", \"r\");\n    if (e == NULL)\n      FATAL_ERROR (\"fopen temp.y failed in copy temp\", errno);\n    CHECK_LINE (e, \"oldpexecute\");\n    fclose (e);\n\n    remove (\"temp.y\");\n  }\n\n  if (trace)\n    fprintf (stderr, \"Exiting with status %d\\n\", error_count);\n\n  return error_count;\n}", "path": "libiberty\\testsuite\\test-pexecute.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Register Instruction Operand.  */\n", "func_signal": "static void\nregop (int mode, int spec, int reg, int fp)", "code": "{\n  if (fp)\n    {\n      /* Floating point instruction.  */\n      if (mode == 1)\n\t{\n\t  /* FP operand.  */\n\t  switch (reg)\n\t    {\n\t    case 0:  (*info->fprintf_func) (stream, \"fp0\");\n\t      break;\n\t    case 1:  (*info->fprintf_func) (stream, \"fp1\");\n\t      break;\n\t    case 2:  (*info->fprintf_func) (stream, \"fp2\");\n\t      break;\n\t    case 3:  (*info->fprintf_func) (stream, \"fp3\");\n\t      break;\n\t    case 16: (*info->fprintf_func) (stream, \"0f0.0\");\n\t      break;\n\t    case 22: (*info->fprintf_func) (stream, \"0f1.0\");\n\t      break;\n\t    default: (*info->fprintf_func) (stream, \"?\");\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  /* Non-FP register.  */\n\t  (*info->fprintf_func) (stream, reg_names[reg]);\n\t}\n    }\n  else\n    {\n      /* Not floating point.  */\n      if (mode == 1)\n\t{\n\t  /* Literal.  */\n\t  (*info->fprintf_func) (stream, \"%d\", reg);\n\t}\n      else\n\t{\n\t  /* Register.  */\n\t  if (spec == 0)\n\t    (*info->fprintf_func) (stream, reg_names[reg]);\n\t  else\n\t    (*info->fprintf_func) (stream, \"sf%d\", reg);\n\t}\n    }\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Process an address exception.  */\n", "func_signal": "void\nm32r_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,\n\t\t  unsigned int map, int nr_bytes, address_word addr,\n\t\t  transfer_type transfer, sim_core_signals sig)", "code": "{\n  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n    {\n      m32rbf_h_cr_set (current_cpu, H_CR_BBPC,\n                       m32rbf_h_cr_get (current_cpu, H_CR_BPC));\n      if (MACH_NUM (CPU_MACH (current_cpu)) == MACH_M32R)\n        {\n          m32rbf_h_bpsw_set (current_cpu, m32rbf_h_psw_get (current_cpu));\n          /* sm not changed */\n          m32rbf_h_psw_set (current_cpu, m32rbf_h_psw_get (current_cpu) & 0x80);\n        }\n      else if (MACH_NUM (CPU_MACH (current_cpu)) == MACH_M32RX)\n        {\n          m32rxf_h_bpsw_set (current_cpu, m32rxf_h_psw_get (current_cpu));\n          /* sm not changed */\n          m32rxf_h_psw_set (current_cpu, m32rxf_h_psw_get (current_cpu) & 0x80);\n        }\n      else\n        {\n          m32r2f_h_bpsw_set (current_cpu, m32r2f_h_psw_get (current_cpu));\n          /* sm not changed */\n          m32r2f_h_psw_set (current_cpu, m32r2f_h_psw_get (current_cpu) & 0x80);\n        }\n      m32rbf_h_cr_set (current_cpu, H_CR_BPC, cia);\n\n      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,\n                          EIT_ADDR_EXCP_ADDR);\n    }\n  else\n    sim_core_signal (sd, current_cpu, cia, map, nr_bytes, addr,\n                     transfer, sig);\n}", "path": "sim\\m32r\\traps-linux.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* COBR format.  */\n", "func_signal": "static void\ncobr (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)", "code": "{\n  int src1;\n  int src2;\n  int i;\n\n  static const struct tabent cobr_tab[] = {\n    { \"testno\",\t1, },\t/* 0x20 */\n    { \"testg\",\t1, },\t/* 0x21 */\n    { \"teste\",\t1, },\t/* 0x22 */\n    { \"testge\",\t1, },\t/* 0x23 */\n    { \"testl\",\t1, },\t/* 0x24 */\n    { \"testne\",\t1, },\t/* 0x25 */\n    { \"testle\",\t1, },\t/* 0x26 */\n    { \"testo\",\t1, },\t/* 0x27 */\n    { NULL,\t0, },\t/* 0x28 */\n    { NULL,\t0, },\t/* 0x29 */\n    { NULL,\t0, },\t/* 0x2a */\n    { NULL,\t0, },\t/* 0x2b */\n    { NULL,\t0, },\t/* 0x2c */\n    { NULL,\t0, },\t/* 0x2d */\n    { NULL,\t0, },\t/* 0x2e */\n    { NULL,\t0, },\t/* 0x2f */\n    { \"bbc\",\t3, },\t/* 0x30 */\n    { \"cmpobg\",\t3, },\t/* 0x31 */\n    { \"cmpobe\",\t3, },\t/* 0x32 */\n    { \"cmpobge\",3, },\t/* 0x33 */\n    { \"cmpobl\",\t3, },\t/* 0x34 */\n    { \"cmpobne\",3, },\t/* 0x35 */\n    { \"cmpoble\",3, },\t/* 0x36 */\n    { \"bbs\",\t3, },\t/* 0x37 */\n    { \"cmpibno\",3, },\t/* 0x38 */\n    { \"cmpibg\",\t3, },\t/* 0x39 */\n    { \"cmpibe\",\t3, },\t/* 0x3a */\n    { \"cmpibge\",3, },\t/* 0x3b */\n    { \"cmpibl\",\t3, },\t/* 0x3c */\n    { \"cmpibne\",3, },\t/* 0x3d */\n    { \"cmpible\",3, },\t/* 0x3e */\n    { \"cmpibo\",\t3, },\t/* 0x3f */\n  };\n\n  i = ((word1 >> 24) & 0xff) - 0x20;\n  if (cobr_tab[i].name == NULL)\n    {\n      invalid (word1);\n      return;\n    }\n\n  (*info->fprintf_func) (stream, cobr_tab[i].name);\n\n  /* Predicts branch not taken.  */\n  if (word1 & 2)\n    (*info->fprintf_func) (stream, \".f\");\n\n  (*info->fprintf_func) (stream, \"\\t\");\n\n  src1 = (word1 >> 19) & 0x1f;\n  src2 = (word1 >> 14) & 0x1f;\n\n  if (word1 & 0x02000)\n    /* M1 is 1 */\n    (*info->fprintf_func) (stream, \"%d\", src1);\n  else\n    (*info->fprintf_func) (stream, reg_names[src1]);\n\n  if (cobr_tab[i].numops > 1)\n    {\n      if (word1 & 1)\n\t/* S2 is 1.  */\n\t(*info->fprintf_func) (stream, \",sf%d,\", src2);\n      else\n\t/* S1 is 0.  */\n\t(*info->fprintf_func) (stream, \",%s,\", reg_names[src2]);\n\n      /* Extract displacement and convert to address.  */\n      word1 &= 0x00001ffc;\n      if (word1 & 0x00001000)\n\t/* Negative displacement.  */\n\tword1 |= (-1 & ~0x1fff);\t/* Sign extend.  */\n\n      print_addr (memaddr + word1);\n    }\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Print the i960 instruction at address 'memaddr' in debugged memory,\n   on INFO->STREAM.  Returns length of the instruction, in bytes.  */\n", "func_signal": "int\nprint_insn_i960 (bfd_vma memaddr, struct disassemble_info *info_arg)", "code": "{\n  unsigned int word1, word2 = 0xdeadbeef;\n  bfd_byte buffer[8];\n  int status;\n\n  info = info_arg;\n  stream = info->stream;\n\n  /* Read word1.  Only read word2 if the instruction\n     needs it, to prevent reading past the end of a section.  */\n\n  status = (*info->read_memory_func) (memaddr, (bfd_byte *) buffer, 4, info);\n  if (status != 0)\n    {\n      (*info->memory_error_func) (status, memaddr, info);\n      return -1;\n    }\n\n  word1 = bfd_getl32 (buffer);\n\n  /* Divide instruction set into classes based on high 4 bits of opcode.  */\n  switch ( (word1 >> 28) & 0xf )\n    {\n    default:\n      break;\n    case 0x8:\n    case 0x9:\n    case 0xa:\n    case 0xb:\n    case 0xc:\n      /* Read word2.  */\n      status = (*info->read_memory_func)\n\t(memaddr + 4, (bfd_byte *) (buffer + 4), 4, info);\n      if (status != 0)\n\t{\n\t  (*info->memory_error_func) (status, memaddr, info);\n\t  return -1;\n\t}\n      word2 = bfd_getl32 (buffer + 4);\n      break;\n    }\n\n  return pinsn( memaddr, word1, word2 );\n}", "path": "opcodes\\i960-dis.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Print a fatal error and exit.  LINE is the line number where we\n   detected the error, ERRMSG is the error message to print, and ERR\n   is 0 or an errno value to print.  */\n", "func_signal": "static void\nfatal_error (int line, const char *errmsg, int err)", "code": "{\n  fprintf (stderr, \"test-pexecute:%d: %s\", line, errmsg);\n  if (errno != 0)\n    fprintf (stderr, \": %s\", xstrerror (err));\n  fprintf (stderr, \"\\n\");\n  exit (EXIT_FAILURE);\n}", "path": "libiberty\\testsuite\\test-pexecute.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* Trap support.\n   The result is the pc address to continue at.\n   Preprocessing like saving the various registers has already been done.  */\n", "func_signal": "USI\nm32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)", "code": "{\n  SIM_DESC sd = CPU_STATE (current_cpu);\n  host_callback *cb = STATE_CALLBACK (sd);\n\n#ifdef SIM_HAVE_BREAKPOINTS\n  /* Check for breakpoints \"owned\" by the simulator first, regardless\n     of --environment.  */\n  if (num == TRAP_BREAKPOINT)\n    {\n      /* First try sim-break.c.  If it's a breakpoint the simulator \"owns\"\n\t it doesn't return.  Otherwise it returns and let's us try.  */\n      sim_handle_breakpoint (sd, current_cpu, pc);\n      /* Fall through.  */\n    }\n#endif\n\n  switch (num)\n    {\n    case TRAP_ELF_SYSCALL :\n      {\n        CB_SYSCALL s;\n \n        CB_SYSCALL_INIT (&s);\n        s.func = m32rbf_h_gr_get (current_cpu, 0);\n        s.arg1 = m32rbf_h_gr_get (current_cpu, 1);\n        s.arg2 = m32rbf_h_gr_get (current_cpu, 2);\n        s.arg3 = m32rbf_h_gr_get (current_cpu, 3);\n \n        if (s.func == TARGET_SYS_exit)\n          {\n            sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, s.arg1);\n          }\n \n        s.p1 = (PTR) sd;\n        s.p2 = (PTR) current_cpu;\n        s.read_mem = syscall_read_mem;\n        s.write_mem = syscall_write_mem;\n        cb_syscall (cb, &s);\n        m32rbf_h_gr_set (current_cpu, 2, s.errcode);\n        m32rbf_h_gr_set (current_cpu, 0, s.result);\n        m32rbf_h_gr_set (current_cpu, 1, s.result2);\n        break;\n      }\n\n    case TRAP_LINUX_SYSCALL :\n      {\n\tCB_SYSCALL s;\n        unsigned int func, arg1, arg2, arg3, arg4, arg5, arg6, arg7;\n        int result, result2, errcode;\n\n        if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n          {\n            /* The new pc is the trap vector entry.\n               We assume there's a branch there to some handler.\n\t       Use cr5 as EVB (EIT Vector Base) register.  */\n            USI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n            return new_pc;\n          }\n\n\tfunc = m32rbf_h_gr_get (current_cpu, 7);\n\targ1 = m32rbf_h_gr_get (current_cpu, 0);\n\targ2 = m32rbf_h_gr_get (current_cpu, 1);\n\targ3 = m32rbf_h_gr_get (current_cpu, 2);\n\targ4 = m32rbf_h_gr_get (current_cpu, 3);\n\targ5 = m32rbf_h_gr_get (current_cpu, 4);\n\targ6 = m32rbf_h_gr_get (current_cpu, 5);\n\targ7 = m32rbf_h_gr_get (current_cpu, 6);\n\n        CB_SYSCALL_INIT (&s);\n        s.func = func;\n        s.arg1 = arg1;\n        s.arg2 = arg2;\n        s.arg3 = arg3;\n\n        s.p1 = (PTR) sd;\n        s.p2 = (PTR) current_cpu;\n        s.read_mem = syscall_read_mem;\n        s.write_mem = syscall_write_mem;\n\n        result = 0;\n        result2 = 0;\n        errcode = 0;\n\n        switch (func)\n          {\n          case __NR_exit:\n\t    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, arg1);\n            break;\n\n          case __NR_read:\n            result = read(arg1, t2h_addr(cb, &s, arg2), arg3);\n            errcode = errno;\n            break;\n\n          case __NR_write:\n            result = write(arg1, t2h_addr(cb, &s, arg2), arg3);\n            errcode = errno;\n            break;\n\n          case __NR_open:\n            result = open((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_close:\n            result = close(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_creat:\n            result = creat((char *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_link:\n            result = link((char *) t2h_addr(cb, &s, arg1),\n                          (char *) t2h_addr(cb, &s, arg2));\n            errcode = errno;\n            break;\n\n          case __NR_unlink:\n            result = unlink((char *) t2h_addr(cb, &s, arg1));\n            errcode = errno;\n            break;\n\n          case __NR_chdir:\n            result = chdir((char *) t2h_addr(cb, &s, arg1));\n            errcode = errno;\n            break;\n\n          case __NR_time:\n            {\n              time_t t;\n\n              if (arg1 == 0)\n                {\n                  result = (int) time(NULL);\n                  errcode = errno;\n                }\n              else\n                {\n                  result = (int) time(&t);\n                  errcode = errno;\n\n                  if (result != 0)\n                    break;\n\n                  translate_endian((void *) &t, sizeof(t));\n                  if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n                    {\n                      result = -1;\n                      errcode = EINVAL;\n                    }\n                }\n            }\n            break;\n\n          case __NR_mknod:\n            result = mknod((char *) t2h_addr(cb, &s, arg1),\n                           (mode_t) arg2, (dev_t) arg3);\n            errcode = errno;\n            break;\n\n          case __NR_chmod:\n            result = chmod((char *) t2h_addr(cb, &s, arg1), (mode_t) arg2);\n            errcode = errno;\n            break;\n\n          case __NR_lchown32:\n          case __NR_lchown:\n            result = lchown((char *) t2h_addr(cb, &s, arg1),\n                            (uid_t) arg2, (gid_t) arg3);\n            errcode = errno;\n            break;\n\n          case __NR_lseek:\n            result = (int) lseek(arg1, (off_t) arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_getpid:\n            result = getpid();\n            errcode = errno;\n            break;\n\n          case __NR_getuid32:\n          case __NR_getuid:\n            result = getuid();\n            errcode = errno;\n            break;\n\n          case __NR_utime:\n            {\n              struct utimbuf buf;\n\n              if (arg2 == 0)\n                {\n                  result = utime((char *) t2h_addr(cb, &s, arg1), NULL);\n                  errcode = errno;\n                }\n              else\n                {\n                  buf = *((struct utimbuf *) t2h_addr(cb, &s, arg2));\n                  translate_endian((void *) &buf, sizeof(buf));\n                  result = utime((char *) t2h_addr(cb, &s, arg1), &buf);\n                  errcode = errno;\n                }\n            }\n            break;\n\n          case __NR_access:\n            result = access((char *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_ftime:\n            {\n              struct timeb t;\n\n              result = ftime(&t);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              t.time = conv_endian(t.time);\n              t.millitm = conv_endian16(t.millitm);\n              t.timezone = conv_endian16(t.timezone);\n              t.dstflag = conv_endian16(t.dstflag);\n              if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n                  != sizeof(t))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n\n          case __NR_sync:\n            sync();\n            result = 0;\n            break;\n\n          case __NR_rename:\n            result = rename((char *) t2h_addr(cb, &s, arg1),\n                            (char *) t2h_addr(cb, &s, arg2));\n            errcode = errno;\n            break;\n\n          case __NR_mkdir:\n            result = mkdir((char *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_rmdir:\n            result = rmdir((char *) t2h_addr(cb, &s, arg1));\n            errcode = errno;\n            break;\n\n          case __NR_dup:\n            result = dup(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_brk:\n            result = brk((void *) arg1);\n            errcode = errno;\n            //result = arg1;\n            break;\n\n          case __NR_getgid32:\n          case __NR_getgid:\n            result = getgid();\n            errcode = errno;\n            break;\n\n          case __NR_geteuid32:\n          case __NR_geteuid:\n            result = geteuid();\n            errcode = errno;\n            break;\n\n          case __NR_getegid32:\n          case __NR_getegid:\n            result = getegid();\n            errcode = errno;\n            break;\n\n          case __NR_ioctl:\n            result = ioctl(arg1, arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_fcntl:\n            result = fcntl(arg1, arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_dup2:\n            result = dup2(arg1, arg2);\n            errcode = errno;\n            break;\n\n          case __NR_getppid:\n            result = getppid();\n            errcode = errno;\n            break;\n\n          case __NR_getpgrp:\n            result = getpgrp();\n            errcode = errno;\n            break;\n\n          case __NR_getrlimit:\n            {\n              struct rlimit rlim;\n\n              result = getrlimit(arg1, &rlim);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &rlim, sizeof(rlim));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n                  != sizeof(rlim))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_getrusage:\n            {\n              struct rusage usage;\n\n              result = getrusage(arg1, &usage);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &usage, sizeof(usage));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n                  != sizeof(usage))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_gettimeofday:\n            {\n              struct timeval tv;\n              struct timezone tz;\n              \n              result = gettimeofday(&tv, &tz);\n              errcode = errno;\n              \n              if (result != 0)\n                break;\n\n              translate_endian((void *) &tv, sizeof(tv));\n              if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n                  != sizeof(tv))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n\n              translate_endian((void *) &tz, sizeof(tz));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n                  != sizeof(tz))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_getgroups32:\n          case __NR_getgroups:\n            {\n              gid_t *list;\n\n              if (arg1 > 0)\n                list = (gid_t *) malloc(arg1 * sizeof(gid_t));\n\n              result = getgroups(arg1, list);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) list, arg1 * sizeof(gid_t));\n              if (arg1 > 0)\n                if ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n                    != arg1 * sizeof(gid_t))\n                  {\n                    result = -1;\n                     errcode = EINVAL;\n                  }\n            }\n            break;\n\n          case __NR_select:\n            {\n              int n;\n              fd_set readfds;\n              fd_set *treadfdsp;\n              fd_set *hreadfdsp;\n              fd_set writefds;\n              fd_set *twritefdsp;\n              fd_set *hwritefdsp;\n              fd_set exceptfds;\n              fd_set *texceptfdsp;\n              fd_set *hexceptfdsp;\n              struct timeval *ttimeoutp;\n              struct timeval timeout;\n              \n              n = arg1;\n\n              treadfdsp = (fd_set *) arg2;\n              if (treadfdsp != NULL)\n                {\n                  readfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) treadfdsp));\n                  translate_endian((void *) &readfds, sizeof(readfds));\n                  hreadfdsp = &readfds;\n                }\n              else\n                hreadfdsp = NULL;\n              \n              twritefdsp  = (fd_set *) arg3;\n              if (twritefdsp != NULL)\n                {\n                  writefds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) twritefdsp));\n                  translate_endian((void *) &writefds, sizeof(writefds));\n                  hwritefdsp = &writefds;\n                }\n              else\n                hwritefdsp = NULL;\n              \n              texceptfdsp = (fd_set *) arg4;\n              if (texceptfdsp != NULL)\n                {\n                  exceptfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) texceptfdsp));\n                  translate_endian((void *) &exceptfds, sizeof(exceptfds));\n                  hexceptfdsp = &exceptfds;\n                }\n              else\n                hexceptfdsp = NULL;\n              \n              ttimeoutp = (struct timeval *) arg5;\n              timeout = *((struct timeval *) t2h_addr(cb, &s, (unsigned int) ttimeoutp));\n              translate_endian((void *) &timeout, sizeof(timeout));\n\n              result = select(n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              if (treadfdsp != NULL)\n                {\n                  translate_endian((void *) &readfds, sizeof(readfds));\n                  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n                       (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n                    {\n                      result = -1;\n                      errcode = EINVAL;\n                    }\n                }\n\n              if (twritefdsp != NULL)\n                {\n                  translate_endian((void *) &writefds, sizeof(writefds));\n                  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n                       (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n                    {\n                      result = -1;\n                      errcode = EINVAL;\n                    }\n                }\n\n              if (texceptfdsp != NULL)\n                {\n                  translate_endian((void *) &exceptfds, sizeof(exceptfds));\n                  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n                       (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n                    {\n                      result = -1;\n                      errcode = EINVAL;\n                    }\n                }\n\n              translate_endian((void *) &timeout, sizeof(timeout));\n              if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n                   (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_symlink:\n            result = symlink((char *) t2h_addr(cb, &s, arg1),\n                             (char *) t2h_addr(cb, &s, arg2));\n            errcode = errno;\n            break;\n\n          case __NR_readlink:\n            result = readlink((char *) t2h_addr(cb, &s, arg1),\n                              (char *) t2h_addr(cb, &s, arg2),\n                              arg3);\n            errcode = errno;\n            break;\n\n          case __NR_readdir:\n            result = (int) readdir((DIR *) t2h_addr(cb, &s, arg1));\n            errcode = errno;\n            break;\n\n#if 0\n          case __NR_mmap:\n            {\n              result = (int) mmap((void *) t2h_addr(cb, &s, arg1),\n                                  arg2, arg3, arg4, arg5, arg6);\n              errcode = errno;\n\n              if (errno == 0)\n                {\n                  sim_core_attach (sd, NULL,\n                                   0, access_read_write_exec, 0,\n                                   result, arg2, 0, NULL, NULL);\n                }\n            }\n            break;\n#endif\n          case __NR_mmap2:\n            {\n              void *addr;\n              size_t len;\n              int prot, flags, fildes;\n              off_t off;\n              \n              addr   = (void *)  t2h_addr(cb, &s, arg1);\n              len    = arg2;\n              prot   = arg3;\n              flags  = arg4;\n              fildes = arg5;\n              off    = arg6 << 12;\n\n\t      result = (int) mmap(addr, len, prot, flags, fildes, off);\n              errcode = errno;\n              if (result != -1)\n                {\n                  char c;\n\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n                    sim_core_attach (sd, NULL,\n                                     0, access_read_write_exec, 0,\n                                     result, len, 0, NULL, NULL);\n                }\n            }\n            break;\n\n          case __NR_mmap:\n            {\n              void *addr;\n              size_t len;\n              int prot, flags, fildes;\n              off_t off;\n              \n              addr   = *((void **)  t2h_addr(cb, &s, arg1));\n              len    = *((size_t *) t2h_addr(cb, &s, arg1 + 4));\n              prot   = *((int *)    t2h_addr(cb, &s, arg1 + 8));\n              flags  = *((int *)    t2h_addr(cb, &s, arg1 + 12));\n              fildes = *((int *)    t2h_addr(cb, &s, arg1 + 16));\n              off    = *((off_t *)  t2h_addr(cb, &s, arg1 + 20));\n\n              addr   = (void *) conv_endian((unsigned int) addr);\n              len    = conv_endian(len);\n              prot   = conv_endian(prot);\n              flags  = conv_endian(flags);\n              fildes = conv_endian(fildes);\n              off    = conv_endian(off);\n\n              //addr   = (void *) t2h_addr(cb, &s, (unsigned int) addr);\n              result = (int) mmap(addr, len, prot, flags, fildes, off);\n              errcode = errno;\n\n              //if (errno == 0)\n              if (result != -1)\n                {\n                  char c;\n\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n                    sim_core_attach (sd, NULL,\n                                     0, access_read_write_exec, 0,\n                                     result, len, 0, NULL, NULL);\n                }\n            }\n            break;\n\n          case __NR_munmap:\n            {\n            result = munmap((void *)arg1, arg2);\n            errcode = errno;\n            if (result != -1)\n              {\n                sim_core_detach (sd, NULL, 0, arg2, result);\n              }\n            }\n            break;\n\n          case __NR_truncate:\n            result = truncate((char *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_ftruncate:\n            result = ftruncate(arg1, arg2);\n            errcode = errno;\n            break;\n\n          case __NR_fchmod:\n            result = fchmod(arg1, arg2);\n            errcode = errno;\n            break;\n\n          case __NR_fchown32:\n          case __NR_fchown:\n            result = fchown(arg1, arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_statfs:\n            {\n              struct statfs statbuf;\n\n              result = statfs((char *) t2h_addr(cb, &s, arg1), &statbuf);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &statbuf, sizeof(statbuf));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n                  != sizeof(statbuf))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_fstatfs:\n            {\n              struct statfs statbuf;\n\n              result = fstatfs(arg1, &statbuf);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &statbuf, sizeof(statbuf));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n                  != sizeof(statbuf))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_syslog:\n            result = syslog(arg1, (char *) t2h_addr(cb, &s, arg2));\n            errcode = errno;\n            break;\n\n          case __NR_setitimer:\n            {\n              struct itimerval value, ovalue;\n\n              value = *((struct itimerval *) t2h_addr(cb, &s, arg2));\n              translate_endian((void *) &value, sizeof(value));\n\n              if (arg2 == 0)\n                {\n                  result = setitimer(arg1, &value, NULL);\n                  errcode = errno;\n                }\n              else\n                {\n                  result = setitimer(arg1, &value, &ovalue);\n                  errcode = errno;\n\n                  if (result != 0)\n                    break;\n\n                  translate_endian((void *) &ovalue, sizeof(ovalue));\n                  if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n                      != sizeof(ovalue))\n                    {\n                      result = -1;\n                      errcode = EINVAL;\n                    }\n                }\n            }\n            break;\n\n          case __NR_getitimer:\n            {\n              struct itimerval value;\n\n              result = getitimer(arg1, &value);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &value, sizeof(value));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n                  != sizeof(value))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_stat:\n            {\n              char *buf;\n              int buflen;\n              struct stat statbuf;\n\n              result = stat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n              errcode = errno;\n              if (result < 0)\n                break;\n\n              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n              buf = xmalloc (buflen);\n              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n                {\n                  /* The translation failed.  This is due to an internal\n                     host program error, not the target's fault.  */\n                  free (buf);\n                  result = -1;\n                  errcode = ENOSYS;\n                  break;\n                }\n              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n                {\n                  free (buf);\n                  result = -1;\n                  errcode = EINVAL;\n                  break;\n                }\n              free (buf);\n            }\n            break;\n\n          case __NR_lstat:\n            {\n              char *buf;\n              int buflen;\n              struct stat statbuf;\n\n              result = lstat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n              errcode = errno;\n              if (result < 0)\n                break;\n\n              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n              buf = xmalloc (buflen);\n              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n                {\n                  /* The translation failed.  This is due to an internal\n                     host program error, not the target's fault.  */\n                  free (buf);\n                  result = -1;\n                  errcode = ENOSYS;\n                  break;\n                }\n              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n                {\n                  free (buf);\n                  result = -1;\n                  errcode = EINVAL;\n                  break;\n                }\n              free (buf);\n            }\n            break;\n\n          case __NR_fstat:\n            {\n              char *buf;\n              int buflen;\n              struct stat statbuf;\n\n              result = fstat(arg1, &statbuf);\n              errcode = errno;\n              if (result < 0)\n                break;\n\n              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n              buf = xmalloc (buflen);\n              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n                {\n                  /* The translation failed.  This is due to an internal\n                     host program error, not the target's fault.  */\n                  free (buf);\n                  result = -1;\n                  errcode = ENOSYS;\n                  break;\n                }\n              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n                {\n                  free (buf);\n                  result = -1;\n                  errcode = EINVAL;\n                  break;\n                }\n              free (buf);\n            }\n            break;\n\n          case __NR_sysinfo:\n            {\n              struct sysinfo info;\n\n              result = sysinfo(&info);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              info.uptime    = conv_endian(info.uptime);\n              info.loads[0]  = conv_endian(info.loads[0]);\n              info.loads[1]  = conv_endian(info.loads[1]);\n              info.loads[2]  = conv_endian(info.loads[2]);\n              info.totalram  = conv_endian(info.totalram);\n              info.freeram   = conv_endian(info.freeram);\n              info.sharedram = conv_endian(info.sharedram);\n              info.bufferram = conv_endian(info.bufferram);\n              info.totalswap = conv_endian(info.totalswap);\n              info.freeswap  = conv_endian(info.freeswap);\n              info.procs     = conv_endian16(info.procs);\n#if LINUX_VERSION_CODE >= 0x20400\n              info.totalhigh = conv_endian(info.totalhigh);\n              info.freehigh  = conv_endian(info.freehigh);\n              info.mem_unit  = conv_endian(info.mem_unit);\n#endif\n              if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n                  != sizeof(info))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n#if 0\n          case __NR_ipc:\n            {\n              result = ipc(arg1, arg2, arg3, arg4,\n                           (void *) t2h_addr(cb, &s, arg5), arg6);\n              errcode = errno;\n            }\n            break;\n#endif\n\n          case __NR_fsync:\n            result = fsync(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_uname:\n            /* utsname contains only arrays of char, so it is not necessary\n               to translate endian. */\n            result = uname((struct utsname *) t2h_addr(cb, &s, arg1));\n            errcode = errno;\n            break;\n\n          case __NR_adjtimex:\n            {\n              struct timex buf;\n\n              result = adjtimex(&buf);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &buf, sizeof(buf));\n              if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n                  != sizeof(buf))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_mprotect:\n            result = mprotect((void *) arg1, arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_fchdir:\n            result = fchdir(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_setfsuid32:\n          case __NR_setfsuid:\n            result = setfsuid(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_setfsgid32:\n          case __NR_setfsgid:\n            result = setfsgid(arg1);\n            errcode = errno;\n            break;\n\n#if 0\n          case __NR__llseek:\n            {\n              loff_t buf;\n\n              result = _llseek(arg1, arg2, arg3, &buf, arg5);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &buf, sizeof(buf));\n              if ((s.write_mem) (cb, &s, t2h_addr(cb, &s, arg4),\n                                 (char *) &buf, sizeof(buf)) != sizeof(buf))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_getdents:\n            {\n              struct dirent dir;\n\n              result = getdents(arg1, &dir, arg3);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              dir.d_ino = conv_endian(dir.d_ino);\n              dir.d_off = conv_endian(dir.d_off);\n              dir.d_reclen = conv_endian16(dir.d_reclen);\n              if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n                  != sizeof(dir))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n#endif\n\n          case __NR_flock:\n            result = flock(arg1, arg2);\n            errcode = errno;\n            break;\n\n          case __NR_msync:\n            result = msync((void *) arg1, arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_readv:\n            {\n              struct iovec vector;\n\n              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n              translate_endian((void *) &vector, sizeof(vector));\n\n              result = readv(arg1, &vector, arg3);\n              errcode = errno;\n            }\n            break;\n\n          case __NR_writev:\n            {\n              struct iovec vector;\n\n              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n              translate_endian((void *) &vector, sizeof(vector));\n\n              result = writev(arg1, &vector, arg3);\n              errcode = errno;\n            }\n            break;\n\n          case __NR_fdatasync:\n            result = fdatasync(arg1);\n            errcode = errno;\n            break;\n\n          case __NR_mlock:\n            result = mlock((void *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_munlock:\n            result = munlock((void *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_nanosleep:\n            {\n              struct timespec req, rem;\n\n              req = *((struct timespec *) t2h_addr(cb, &s, arg2));\n              translate_endian((void *) &req, sizeof(req));\n\n              result = nanosleep(&req, &rem);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              translate_endian((void *) &rem, sizeof(rem));\n              if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n                  != sizeof(rem))\n                {\n                  result = -1;\n                  errcode = EINVAL;\n                }\n            }\n            break;\n\n          case __NR_mremap: /* FIXME */\n            result = (int) mremap((void *) t2h_addr(cb, &s, arg1), arg2, arg3, arg4); \n            errcode = errno;\n            break;\n\n          case __NR_getresuid32:\n          case __NR_getresuid:\n            {\n              uid_t ruid, euid, suid;\n\n              result = getresuid(&ruid, &euid, &suid);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              *((uid_t *) t2h_addr(cb, &s, arg1)) = conv_endian(ruid);\n              *((uid_t *) t2h_addr(cb, &s, arg2)) = conv_endian(euid);\n              *((uid_t *) t2h_addr(cb, &s, arg3)) = conv_endian(suid);\n            }\n            break;\n\n          case __NR_poll:\n            {\n              struct pollfd ufds;\n\n              ufds = *((struct pollfd *) t2h_addr(cb, &s, arg1));\n              ufds.fd = conv_endian(ufds.fd);\n              ufds.events = conv_endian16(ufds.events);\n              ufds.revents = conv_endian16(ufds.revents);\n\n              result = poll(&ufds, arg2, arg3);\n              errcode = errno;\n            }\n            break;\n\n          case __NR_getresgid32:\n          case __NR_getresgid:\n            {\n              uid_t rgid, egid, sgid;\n\n              result = getresgid(&rgid, &egid, &sgid);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              *((uid_t *) t2h_addr(cb, &s, arg1)) = conv_endian(rgid);\n              *((uid_t *) t2h_addr(cb, &s, arg2)) = conv_endian(egid);\n              *((uid_t *) t2h_addr(cb, &s, arg3)) = conv_endian(sgid);\n            }\n            break;\n\n          case __NR_pread:\n            result =  pread(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n            errcode = errno;\n            break;\n\n          case __NR_pwrite:\n            result =  pwrite(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n            errcode = errno;\n            break;\n\n          case __NR_chown32:\n          case __NR_chown:\n            result = chown((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n            errcode = errno;\n            break;\n\n          case __NR_getcwd:\n            result = (int) getcwd((char *) t2h_addr(cb, &s, arg1), arg2);\n            errcode = errno;\n            break;\n\n          case __NR_sendfile:\n            {\n              off_t offset;\n\n              offset = *((off_t *) t2h_addr(cb, &s, arg3));\n              offset = conv_endian(offset);\n\n              result = sendfile(arg1, arg2, &offset, arg3);\n              errcode = errno;\n\n              if (result != 0)\n                break;\n\n              *((off_t *) t2h_addr(cb, &s, arg3)) = conv_endian(offset);\n            }\n            break;\n\n          default:\n            result = -1;\n            errcode = ENOSYS;\n            break;\n          }\n        \n        if (result == -1)\n\t  m32rbf_h_gr_set (current_cpu, 0, -errcode);\n        else\n\t  m32rbf_h_gr_set (current_cpu, 0, result);\n\tbreak;\n      }\n\n    case TRAP_BREAKPOINT:\n      sim_engine_halt (sd, current_cpu, NULL, pc,\n\t\t       sim_stopped, SIM_SIGTRAP);\n      break;\n\n    case TRAP_FLUSH_CACHE:\n      /* Do nothing.  */\n      break;\n\n    default :\n      {\n\t/* Use cr5 as EVB (EIT Vector Base) register.  */\n        USI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n\treturn new_pc;\n      }\n    }\n\n  /* Fake an \"rte\" insn.  */\n  /* FIXME: Should duplicate all of rte processing.  */\n  return (pc & -4) + 4;\n}", "path": "sim\\m32r\\traps-linux.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "/* not ASCII */\n", "func_signal": "void\nhex_init (void)", "code": "{\n#ifndef HEX_TABLE_INITIALIZED\n  int i;\n\n  for (i=0; i<_hex_array_size; i++)\n    {\n      switch (i)\n\t{\n\tcase '0': _hex_value[i] = 0; break;\n\tcase '1': _hex_value[i] = 1; break;\n\tcase '2': _hex_value[i] = 2; break;\n\tcase '3': _hex_value[i] = 3; break;\n\tcase '4': _hex_value[i] = 4; break;\n\tcase '5': _hex_value[i] = 5; break;\n\tcase '6': _hex_value[i] = 6; break;\n\tcase '7': _hex_value[i] = 7; break;\n\tcase '8': _hex_value[i] = 8; break;\n\tcase '9': _hex_value[i] = 9; break;\n\n\tcase 'a': case 'A': _hex_value[i] = 10; break;\n\tcase 'b': case 'B': _hex_value[i] = 11; break;\n\tcase 'c': case 'C': _hex_value[i] = 12; break;\n\tcase 'd': case 'D': _hex_value[i] = 13; break;\n\tcase 'e': case 'E': _hex_value[i] = 14; break;\n\tcase 'f': case 'F': _hex_value[i] = 15; break;\n\n\tdefault:\n\t  _hex_value[i] = _hex_bad;\n\t  break;\n\t}\n    }\n#endif\n}", "path": "libiberty\\hex.c", "repo_name": "sergiodj/gdb-sergio", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 84172}
{"docstring": "//! I2C (TWI) interrupt service routine\n", "func_signal": "SIGNAL(SIG_2WIRE_SERIAL)", "code": "{\n\t// read status bits\n\tu08 status = inb(TWSR) & TWSR_STATUS_MASK;\n\n\tswitch(status)\n\t{\n\t// Master General\n\tcase TW_START:\t\t\t\t\t\t// 0x08: Sent start condition\n\tcase TW_REP_START:\t\t\t\t\t// 0x10: Sent repeated start condition\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: M->START\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// send device address\n\t\ti2cSendByte(I2cDeviceAddrRW);\n\t\tbreak;\n\t\n\t// Master Transmitter & Receiver status codes\n\tcase TW_MT_SLA_ACK:\t\t\t\t\t// 0x18: Slave address acknowledged\n\tcase TW_MT_DATA_ACK:\t\t\t\t// 0x28: Data acknowledged\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MT->SLA_ACK or DATA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\tif(I2cSendDataIndex < I2cSendDataLength)\n\t\t{\n\t\t\t// send data\n\t\t\ti2cSendByte( I2cSendData[I2cSendDataIndex++] );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// transmit stop condition, enable SLA ACK\n\t\t\ti2cSendStop();\n\t\t\t// set state\n\t\t\tI2cState = I2C_IDLE;\n\t\t}\n\t\tbreak;\n\tcase TW_MR_DATA_NACK:\t\t\t\t// 0x58: Data received, NACK reply issued\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MR->DATA_NACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// store final received data byte\n\t\tI2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);\n\t\t// continue to transmit STOP condition\n\tcase TW_MR_SLA_NACK:\t\t\t\t// 0x48: Slave address not acknowledged\n\tcase TW_MT_SLA_NACK:\t\t\t\t// 0x20: Slave address not acknowledged\n\tcase TW_MT_DATA_NACK:\t\t\t\t// 0x30: Data not acknowledged\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MTR->SLA_NACK or MT->DATA_NACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// transmit stop condition, enable SLA ACK\n\t\ti2cSendStop();\n\t\t// set state\n\t\tI2cState = I2C_IDLE;\n\t\tbreak;\n\tcase TW_MT_ARB_LOST:\t\t\t\t// 0x38: Bus arbitration lost\n\t//case TW_MR_ARB_LOST:\t\t\t\t// 0x38: Bus arbitration lost\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MT->ARB_LOST\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// release bus\n\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));\n\t\t// set state\n\t\tI2cState = I2C_IDLE;\n\t\t// release bus and transmit start when bus is free\n\t\t//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));\n\t\tbreak;\n\tcase TW_MR_DATA_ACK:\t\t\t\t// 0x50: Data acknowledged\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MR->DATA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// store received data byte\n\t\tI2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);\n\t\t// fall-through to see if more bytes will be received\n\tcase TW_MR_SLA_ACK:\t\t\t\t\t// 0x40: Slave address acknowledged\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: MR->SLA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\tif(I2cReceiveDataIndex < (I2cReceiveDataLength-1))\n\t\t\t// data byte will be received, reply with ACK (more bytes in transfer)\n\t\t\ti2cReceiveByte(TRUE);\n\t\telse\n\t\t\t// data byte will be received, reply with NACK (final byte in transfer)\n\t\t\ti2cReceiveByte(FALSE);\n\t\tbreak;\n\n\t// Slave Receiver status codes\n\tcase TW_SR_SLA_ACK:\t\t\t\t\t// 0x60: own SLA+W has been received, ACK has been returned\n\tcase TW_SR_ARB_LOST_SLA_ACK:\t\t// 0x68: own SLA+W has been received, ACK has been returned\n\tcase TW_SR_GCALL_ACK:\t\t\t\t// 0x70:     GCA+W has been received, ACK has been returned\n\tcase TW_SR_ARB_LOST_GCALL_ACK:\t\t// 0x78:     GCA+W has been received, ACK has been returned\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: SR->SLA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// we are being addressed as slave for writing (data will be received from master)\n\t\t// set state\n\t\tI2cState = I2C_SLAVE_RX;\n\t\t// prepare buffer\n\t\tI2cReceiveDataIndex = 0;\n\t\t// receive data byte and return ACK\n\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t\tbreak;\n\tcase TW_SR_DATA_ACK:\t\t\t\t// 0x80: data byte has been received, ACK has been returned\n\tcase TW_SR_GCALL_DATA_ACK:\t\t\t// 0x90: data byte has been received, ACK has been returned\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: SR->DATA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// get previously received data byte\n\t\tI2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);\n\t\t// check receive buffer status\n\t\tif(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)\n\t\t{\n\t\t\t// receive data byte and return ACK\n\t\t\ti2cReceiveByte(TRUE);\n\t\t\t//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// receive data byte and return NACK\n\t\t\ti2cReceiveByte(FALSE);\n\t\t\t//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));\n\t\t}\n\t\tbreak;\n\tcase TW_SR_DATA_NACK:\t\t\t\t// 0x88: data byte has been received, NACK has been returned\n\tcase TW_SR_GCALL_DATA_NACK:\t\t\t// 0x98: data byte has been received, NACK has been returned\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: SR->DATA_NACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// receive data byte and return NACK\n\t\ti2cReceiveByte(FALSE);\n\t\t//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));\n\t\tbreak;\n\tcase TW_SR_STOP:\t\t\t\t\t// 0xA0: STOP or REPEATED START has been received while addressed as slave\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: SR->SR_STOP\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// switch to SR mode with SLA ACK\n\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t\t// i2c receive is complete, call i2cSlaveReceive\n\t\tif(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);\n\t\t// set state\n\t\tI2cState = I2C_IDLE;\n\t\tbreak;\n\n\t// Slave Transmitter\n\tcase TW_ST_SLA_ACK:\t\t\t\t\t// 0xA8: own SLA+R has been received, ACK has been returned\n\tcase TW_ST_ARB_LOST_SLA_ACK:\t\t// 0xB0:     GCA+R has been received, ACK has been returned\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: ST->SLA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// we are being addressed as slave for reading (data must be transmitted back to master)\n\t\t// set state\n\t\tI2cState = I2C_SLAVE_TX;\n\t\t// request data from application\n\t\tif(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);\n\t\t// reset data index\n\t\tI2cSendDataIndex = 0;\n\t\t// fall-through to transmit first data byte\n\tcase TW_ST_DATA_ACK:\t\t\t\t// 0xB8: data byte has been transmitted, ACK has been received\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: ST->DATA_ACK\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// transmit data byte\n\t\toutb(TWDR, I2cSendData[I2cSendDataIndex++]);\n\t\tif(I2cSendDataIndex < I2cSendDataLength)\n\t\t\t// expect ACK to data byte\n\t\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t\telse\n\t\t\t// expect NACK to data byte\n\t\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));\n\t\tbreak;\n\tcase TW_ST_DATA_NACK:\t\t\t\t// 0xC0: data byte has been transmitted, NACK has been received\n\tcase TW_ST_LAST_DATA:\t\t\t\t// 0xC8:\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: ST->DATA_NACK or LAST_DATA\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// all done\n\t\t// switch to open slave\n\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t\t// set state\n\t\tI2cState = I2C_IDLE;\n\t\tbreak;\n\n\t// Misc\n\tcase TW_NO_INFO:\t\t\t\t\t// 0xF8: No relevant state information\n\t\t// do nothing\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: NO_INFO\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\tbreak;\n\tcase TW_BUS_ERROR:\t\t\t\t\t// 0x00: Bus error due to illegal start or stop condition\n\t\t#ifdef I2C_DEBUG\n\t\trprintfInit(uart1AddToTxBuffer);\n\t\trprintf(\"I2C: BUS_ERROR\\r\\n\");\n\t\trprintfInit(uart1SendByte);\n\t\t#endif\n\t\t// reset internal hardware and release bus\n\t\toutb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));\n\t\t// set state\n\t\tI2cState = I2C_IDLE;\n\t\tbreak;\n\t}\n}", "path": "master\\i2c.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// slave operations\n", "func_signal": "void i2cSlaveReceiveService(uint8_t receiveDataLength, uint8_t* receiveData)", "code": "{\n\tuint8_t i;\n\t// this function will run when a master somewhere else on the bus\n\t// addresses us and wishes to write data to us\n\t\n\tcbi(PORTB, PB6);\n\n\t// copy the received data to a local buffer\n\tfor(i=0; i<receiveDataLength; i++)\n\t\tlocalBuffer[i] = *receiveData++;\n\n\tadd_message_cmd *am;\n\tadd_image_cmd *ai;\n\tpong_cmd *p;\n\n\tswitch (localBuffer[0]) {\n\tcase FRAME_CMD:\n\t\tframe = ((frame_cmd*) localBuffer)->frame;\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase SHOW_CMD:\n\t\texclusivelyShow(((id_cmd*) localBuffer)->id);\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase ADD_MESSAGE_CMD:\n\t\tam = (add_message_cmd*) localBuffer;\n\t\taddMessage(am->id, am->message, am->rStart, am->rStep, am->rStop, am->cStart, am->cStep, am->cStop, am->loop); \n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase DELETE_CMD:\n\t\tremoveDisplayable(((id_cmd*) localBuffer)->id);\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase ENABLE_CMD:\n\t\tchangeVisibility(((id_cmd*) localBuffer)->id, true);\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase DISABLE_CMD:\n\t\tchangeVisibility(((id_cmd*) localBuffer)->id, false);\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase ADD_IMAGE_CMD:\n\t\tai = (add_image_cmd*) localBuffer;\n\t\t// only process valid pattern image ids\n\t\tif (ai->imageID >= TOTALPATTERNS || ai->imageID < 0) break; \n\t\taddImage(ai->id, patternList[ai->imageID], ai->rStart, ai->rStep, ai->rStop, ai->cStart, ai->cStep, ai->cStop, ai->loop);\n\t\tupdateOffsets();\n\t\tdraw();\n\t\tbreak;\n\tcase PONG_CMD:\n\t\tp = (pong_cmd*) localBuffer;\n\t\tdrawPong(p->paddle1_y, p->paddle2_y, p->ball_x, p->ball_y);\n\t\tbreak;\n\tcase TEST_CMD:\n\t\ttest();\n\t\tbreak;\n\tdefault:\n\t\tPORTB = 0x00;\n\t\tPORTD = 0x00;\n\t\tPORTA = 0x00;\n\t\tbreak;\n\t}\n\n\tlocalBufferLength = receiveDataLength;\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Should be called after setting frame. Calculates row and col offsets based on frame number. */\n", "func_signal": "void updateOffsets(void)", "code": "{\n\t// use frame to calculate offsets for all patterns in the display list.\n\tdisplayable_t *current;\n\tint32_t frameDiff;\n\tfor (uint8_t i = 0; i < listSize; i++) {\n\t\tcurrent = displayList[i];\n\t\tif (\t(current->rowOffsetStep < 0 && current->rowOffset <= current->endRowOffset && !current->loop) ||\n\t\t\t\t(current->rowOffsetStep > 0 && current->rowOffset >= current->endRowOffset && !current->loop)\t)\n\t\t\tcontinue;\n\t\tframeDiff = current->endRowOffset - current->startRowOffset;\n\t\tif (frameDiff < 0) frameDiff = -frameDiff;\n\t\tcurrent->rowOffset = current->startRowOffset + (frame % frameDiff) * current->rowOffsetStep; \n\t}\t\n\tfor (uint8_t i = 0; i < listSize; i++) {\n\t\tcurrent = displayList[i];\n\t\tif (\t(current->colOffsetStep < 0 && current->colOffset <= current->endColOffset && !current->loop) ||\n\t\t\t\t(current->colOffsetStep > 0 && current->colOffset >= current->endColOffset && !current->loop)\t)\n\t\t\tcontinue;\n\t\tframeDiff = current->endColOffset - current->startColOffset;\n\t\tif (frameDiff < 0) frameDiff = -frameDiff;\n\t\tcurrent->colOffset = current->startColOffset + (frame % frameDiff) * current->colOffsetStep; \n\t}\t\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// functions\n", "func_signal": "void i2cInit(void)", "code": "{\n\t// set pull-up resistors on I2C bus pins\n\t// TODO: should #ifdef these\n\tsbi(PORTC, 0);\t// i2c SCL on ATmega163,323,16,32,etc\n\tsbi(PORTC, 1);\t// i2c SDA on ATmega163,323,16,32,etc\n\tsbi(PORTD, 0);\t// i2c SCL on ATmega128,64\n\tsbi(PORTD, 1);\t// i2c SDA on ATmega128,64\n\n\t// clear SlaveReceive and SlaveTransmit handler to null\n\ti2cSlaveReceive = 0;\n\ti2cSlaveTransmit = 0;\n\t// set i2c bit rate to 100KHz\n\ti2cSetBitrate(100);\n\t// enable TWI (two-wire interface)\n\tsbi(TWCR, TWEN);\n\t// set state\n\tI2cState = I2C_IDLE;\n\t// enable TWI interrupt and slave address ACK\n\tsbi(TWCR, TWIE);\n\tsbi(TWCR, TWEA);\n\t//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));\n\t// enable interrupts\n\tsei();\n}", "path": "master\\i2c.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// enable and initialize the uart\n", "func_signal": "void uartInit(void)", "code": "{\n\t// initialize the buffers\n\tuartInitBuffers();\n\t// initialize user receive handler\n\tUartRxFunc = 0;\n\n\t// enable RxD/TxD and interrupts\n\toutb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));\n\n\t// set default baud rate\n\tuartSetBaudRate(UART_DEFAULT_BAUD_RATE);  \n\t// initialize states\n\tuartReadyTx = TRUE;\n\tuartBufferedTx = FALSE;\n\t// clear overflow count\n\tuartRxOverflow = 0;\n\t// enable interrupts\n\tsei();\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Actually changes the LEDs on the board to reflect the displayables in the display list. */\n", "func_signal": "void draw(void)", "code": "{\n\tuint32_t row, col;\n#if ROW == 0\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\trow = ROWOFFSET + i;\n\t\tcol = COLOFFSET;\n\t\tPORTB = 0x01 << i;\n\t\tPORTA = getCombinedLine(row, col);\n\t\t_delay_ms(0.1);\n\t\tPORTB = 0;\n\t\t//PORTA = 0xff;\n\t\t_delay_ms(0.1);\n\t}\n\tfor (uint8_t i = 8; i < 16; i++) {\n\t\trow = ROWOFFSET + i;\n\t\tcol = COLOFFSET;\n\t\tPORTD = 0x01 << (i - 8);\n\t\tPORTA = getCombinedLine(row, col);\n\t\t_delay_ms(0.1);\n\t\tPORTD = 0;\n\t\t//PORTA = 0xff;\n\t\t_delay_ms(0.1);\n\t}\n#else\n\t// bottom\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\trow = ROWOFFSET + i;\n\t\tcol = COLOFFSET;\n\t\tPORTD = 0x01 << (7 - i);\n\t\tPORTA = reversed(getCombinedLine(row, col));\n\t\t_delay_ms(0.1);\n\t\tPORTD = 0;\n\t\t//PORTA = 0xff;\n\t\t_delay_ms(0.1);\n\t}\n\tfor (uint8_t i = 8; i < 16; i++) {\n\t\trow = ROWOFFSET + i;\n\t\tcol = COLOFFSET;\n\t\tPORTB = 0x01 << (15 - i);\n\t\tPORTA = reversed(getCombinedLine(row, col));\n\t\t_delay_ms(0.1);\n\t\tPORTB = 0;\n\t\t//PORTA = 0xff;\n\t\t_delay_ms(0.1);\n\t}\n#endif\t\t\t\t\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// transmit nBytes from buffer out the uart\n", "func_signal": "u08 uartSendBuffer(char *buffer, u16 nBytes)", "code": "{\n\tregister u08 first;\n\tregister u16 i;\n\n\t// check if there's space (and that we have any bytes to send at all)\n\tif((uartTxBuffer.datalength + nBytes < uartTxBuffer.size) && nBytes)\n\t{\n\t\t// grab first character\n\t\tfirst = *buffer++;\n\t\t// copy user buffer to uart transmit buffer\n\t\tfor(i = 0; i < nBytes-1; i++)\n\t\t{\n\t\t\t// put data bytes at end of buffer\n\t\t\tbufferAddToEnd(&uartTxBuffer, *buffer++);\n\t\t}\n\n\t\t// send the first byte to get things going by interrupts\n\t\tuartBufferedTx = TRUE;\n\t\tuartSendByte(first);\n\t\t// return success\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\t// return failure\n\t\treturn FALSE;\n\t}\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Make id visible and turn all others off. Good for switching between patterns. */\n", "func_signal": "void exclusivelyShow(uint8_t id)", "code": "{\n\tfor (uint8_t i = 0; i < listSize; i++) {\n\t\tif (displayList[i]->id == id) {\n\t\t\tdisplayList[i]->visible = true;\n\t\t}\n\t\telse {\n\t\t\tdisplayList[i]->visible = false;\n\t\t}\n\t}\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Enable or disable a displayable. It remains in the display list but doesn't draw. */\n", "func_signal": "void changeVisibility(uint8_t id, bool visible)", "code": "{\n\tfor (uint8_t i = 0; i < listSize; i++) {\n\t\tif (id == displayList[i]->id) {\n\t\t\tdisplayList[i]->visible = visible;\n\t\t}\n\t}\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// set the uart baud rate\n", "func_signal": "void uartSetBaudRate(u32 baudrate)", "code": "{\n\t// calculate division factor for requested baud rate, and set it\n\tu16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);\n\toutb(UBRRL, bauddiv);\n\t#ifdef UBRRH\n\toutb(UBRRH, bauddiv>>8);\n\t#endif\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// UART Receive Complete Interrupt Handler\n", "func_signal": "UART_INTERRUPT_HANDLER(SIG_UART_RECV)", "code": "{\n\tu08 c;\n\t\n\t// get received char\n\tc = inb(UDR);\n\n\t// if there's a user function to handle this receive event\n\tif(UartRxFunc)\n\t{\n\t\t// call it and pass the received data\n\t\tUartRxFunc(c);\n\t}\n\telse\n\t{\n\t\t// otherwise do default processing\n\t\t// put received char in buffer\n\t\t// check if there's space\n\t\tif( !bufferAddToEnd(&uartRxBuffer, c) )\n\t\t{\n\t\t\t// no space in buffer\n\t\t\t// count overflow\n\t\t\tuartRxOverflow++;\n\t\t}\n\t}\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/*\n// transmit nBytes from buffer out the uart\nu08 uartSendBuffer(char *buffer, u16 nBytes)\n{\n\tregister u08 first;\n\tregister u16 i;\n\n\t// check if there's space (and that we have any bytes to send at all)\n\tif((uartTxBuffer.datalength + nBytes < uartTxBuffer.size) && nBytes)\n\t{\n\t\t// grab first character\n\t\tfirst = *buffer++;\n\t\t// copy user buffer to uart transmit buffer\n\t\tfor(i = 0; i < nBytes-1; i++)\n\t\t{\n\t\t\t// put data bytes at end of buffer\n\t\t\tbufferAddToEnd(&uartTxBuffer, *buffer++);\n\t\t}\n\n\t\t// send the first byte to get things going by interrupts\n\t\tuartBufferedTx = TRUE;\n\t\tuartSendByte(first);\n\t\t// return success\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\t// return failure\n\t\treturn FALSE;\n\t}\n}\n*/\n// UART Transmit Complete Interrupt Handler\n", "func_signal": "UART_INTERRUPT_HANDLER(SIG_UART_TRANS)", "code": "{\n\t// check if buffered tx is enabled\n\tif(uartBufferedTx)\n\t{\n\t\t// check if there's data left in the buffer\n\t\tif(uartTxBuffer.datalength)\n\t\t{\n\t\t\t// send byte from top of buffer\n\t\t\toutb(UDR, bufferGetFromFront(&uartTxBuffer));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no data left\n\t\t\tuartBufferedTx = FALSE;\n\t\t\t// return to ready state\n\t\t\tuartReadyTx = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// we're using single-byte tx mode\n\t\t// indicate transmit complete, back to ready\n\t\tuartReadyTx = TRUE;\n\t}\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Test pattern */\n", "func_signal": "void test(void)", "code": "{\n\t// turn all lights on - 10s\n\tallOn();\n\t_delay_ms(10000);\n\tclear();\n\t// cycle through a test pattern\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int column = 0; column < 16; column++) {\n\t\t\tclear();\n\t\t\tif (column < 8)\t{\n\t\t\t\tPORTB = 0x01 << column;\n\t\t\t\tPORTD = 0x00;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPORTD = 0x01 << (column - 8);\n\t\t\t\tPORTB = 0x00;\n\t\t\t}\n\t\t\tPORTA = 0x00;\n\t\t\t_delay_ms(50);\n\t\t}\n\t}\n\tfor(int i = 0; i < 5; i++) {\n\t\tfor(int j = 0; j < 8; j++) {\n\t\t\tclear();\n\t\t\tfor (int column = 0; column < 16; column++) {\n\t\t\t\tif (column < 8)\t{\n\t\t\t\t\tPORTB = 0x01<<column;\n\t\t\t\t\tPORTD = 0x00;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tPORTD = 0x01 << (column - 8);\n\t\t\t\t\tPORTB = 0x00;\n\t\t\t\t}\n\t\t\t\tPORTA = ~(0x01 << j);\n\t\t\t\t_delay_ms(1);\n\t\t\t}\n\t\t\t_delay_ms(200);\n\t\t}\n\t}\n\t// turn all on again - 10s\n\tallOn();\n\t_delay_ms(10000);\n\tclear();\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// gets a byte (if available) from the uart receive buffer\n", "func_signal": "u08 uartReceiveByte(u08* rxData)", "code": "{\n\t// make sure we have a receive buffer\n\tif(uartRxBuffer.size)\n\t{\n\t\t// make sure we have data\n\t\tif(uartRxBuffer.datalength)\n\t\t{\n\t\t\t// get byte from beginning of buffer\n\t\t\t*rxData = bufferGetFromFront(&uartRxBuffer);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no data\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// no buffer\n\t\treturn FALSE;\n\t}\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* Combines the overlapping line patterns in the display list. */\n", "func_signal": "uint8_t getCombinedLine(int32_t row, int32_t col)", "code": "{\n\tuint8_t line = 0xff;\n\tuint8_t temp;\n\tfor (uint8_t d = 0; d < listSize; d++) {\n\t\tif (!displayList[d]->visible) continue;\n\t\ttemp = getDisplayableLine(displayList[d], row, col);\n\t\tif (displayList[d]->invert) temp = ~temp;\n\t\tline &= (uint8_t) temp;\n\t}\n\treturn line;\n}", "path": "slave\\slave.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// gets a single byte from the uart receive buffer (getchar-style)\n", "func_signal": "int uartGetByte(void)", "code": "{\n\tu08 c;\n\tif(uartReceiveByte(&c))\n\t\treturn c;\n\telse\n\t\treturn -1;\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// start transmission of the current uart Tx buffer contents\n", "func_signal": "void uartSendTxBuffer(void)", "code": "{\n\t// turn on buffered transmit\n\tuartBufferedTx = TRUE;\n\t// send the first byte to get things going by interrupts\n\tuartSendByte(bufferGetFromFront(&uartTxBuffer));\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// return true if uart receive buffer is empty\n", "func_signal": "u08 uartReceiveBufferIsEmpty(void)", "code": "{\n\tif(uartRxBuffer.datalength == 0)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// transmits a byte over the uart\n", "func_signal": "void uartSendByte(u08 txData)", "code": "{\n\t// wait for the transmitter to be ready\n\twhile(!uartReadyTx);\n\t// send byte\n\toutb(UDR, txData);\n\t// set ready state to FALSE\n\tuartReadyTx = FALSE;\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "// create and initialize the uart transmit and receive buffers\n", "func_signal": "void uartInitBuffers(void)", "code": "{\n\t#ifndef UART_BUFFERS_EXTERNAL_RAM\n\t\t// initialize the UART receive buffer\n\t\tbufferInit(&uartRxBuffer, uartRxData, UART_RX_BUFFER_SIZE);\n\t\t// initialize the UART transmit buffer\n\t\tbufferInit(&uartTxBuffer, uartTxData, UART_TX_BUFFER_SIZE);\n\t#else\n\t\t// initialize the UART receive buffer\n\t\tbufferInit(&uartRxBuffer, (u08*) UART_RX_BUFFER_ADDR, UART_RX_BUFFER_SIZE);\n\t\t// initialize the UART transmit buffer\n\t\tbufferInit(&uartTxBuffer, (u08*) UART_TX_BUFFER_ADDR, UART_TX_BUFFER_SIZE);\n\t#endif\n}", "path": "master\\uart.c", "repo_name": "mattdudys/lighted-pathway", "stars": 3, "license": "None", "language": "c", "size": 148}
{"docstring": "/* This function gets the X Display and global info about it. Everything is\n   stored in our object and will be cleaned when the object is disposed. Note\n   here that caps for supported format are generated without any window or\n   image creation */\n", "func_signal": "GstXContext *\nximageutil_xcontext_get (GstElement * parent, const gchar * display_name)", "code": "{\n  GstXContext *xcontext = NULL;\n  XPixmapFormatValues *px_formats = NULL;\n  gint nb_formats = 0, i;\n\n  xcontext = g_new0 (GstXContext, 1);\n\n  xcontext->disp = XOpenDisplay (display_name);\n  GST_DEBUG_OBJECT (parent, \"opened display %p\", xcontext->disp);\n  if (!xcontext->disp) {\n    g_free (xcontext);\n    return NULL;\n  }\n  xcontext->screen = DefaultScreenOfDisplay (xcontext->disp);\n  xcontext->screen_num = DefaultScreen (xcontext->disp);\n  xcontext->visual = DefaultVisual (xcontext->disp, xcontext->screen_num);\n  xcontext->root = DefaultRootWindow (xcontext->disp);\n  xcontext->white = XWhitePixel (xcontext->disp, xcontext->screen_num);\n  xcontext->black = XBlackPixel (xcontext->disp, xcontext->screen_num);\n  xcontext->depth = DefaultDepthOfScreen (xcontext->screen);\n\n  xcontext->width = DisplayWidth (xcontext->disp, xcontext->screen_num);\n  xcontext->height = DisplayHeight (xcontext->disp, xcontext->screen_num);\n\n  xcontext->widthmm = DisplayWidthMM (xcontext->disp, xcontext->screen_num);\n  xcontext->heightmm = DisplayHeightMM (xcontext->disp, xcontext->screen_num);\n\n  xcontext->caps = NULL;\n\n  GST_DEBUG_OBJECT (parent, \"X reports %dx%d pixels and %d mm x %d mm\",\n      xcontext->width, xcontext->height, xcontext->widthmm, xcontext->heightmm);\n  ximageutil_calculate_pixel_aspect_ratio (xcontext);\n\n  /* We get supported pixmap formats at supported depth */\n  px_formats = XListPixmapFormats (xcontext->disp, &nb_formats);\n\n  if (!px_formats) {\n    XCloseDisplay (xcontext->disp);\n    g_free (xcontext);\n    return NULL;\n  }\n\n  /* We get bpp value corresponding to our running depth */\n  for (i = 0; i < nb_formats; i++) {\n    if (px_formats[i].depth == xcontext->depth)\n      xcontext->bpp = px_formats[i].bits_per_pixel;\n  }\n\n  XFree (px_formats);\n\n  xcontext->endianness =\n      (ImageByteOrder (xcontext->disp) ==\n      LSBFirst) ? G_LITTLE_ENDIAN : G_BIG_ENDIAN;\n\n#ifdef HAVE_XSHM\n  /* Search for XShm extension support */\n  if (XShmQueryExtension (xcontext->disp) &&\n      ximageutil_check_xshm_calls (xcontext)) {\n    xcontext->use_xshm = TRUE;\n    GST_DEBUG (\"ximageutil is using XShm extension\");\n  } else {\n    xcontext->use_xshm = FALSE;\n    GST_DEBUG (\"ximageutil is not using XShm extension\");\n  }\n#endif /* HAVE_XSHM */\n\n  /* our caps system handles 24/32bpp RGB as big-endian. */\n  if ((xcontext->bpp == 24 || xcontext->bpp == 32) &&\n      xcontext->endianness == G_LITTLE_ENDIAN) {\n    xcontext->endianness = G_BIG_ENDIAN;\n    xcontext->r_mask_output = GUINT32_TO_BE (xcontext->visual->red_mask);\n    xcontext->g_mask_output = GUINT32_TO_BE (xcontext->visual->green_mask);\n    xcontext->b_mask_output = GUINT32_TO_BE (xcontext->visual->blue_mask);\n    if (xcontext->bpp == 24) {\n      xcontext->r_mask_output >>= 8;\n      xcontext->g_mask_output >>= 8;\n      xcontext->b_mask_output >>= 8;\n    }\n  } else {\n    xcontext->r_mask_output = xcontext->visual->red_mask;\n    xcontext->g_mask_output = xcontext->visual->green_mask;\n    xcontext->b_mask_output = xcontext->visual->blue_mask;\n  }\n\n  return xcontext;\n}", "path": "sys\\ximage\\ximageutil.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/**\n * gst_avi_subtitle_title_tag:\n * @sub: subtitle element\n * @title: the title of this subtitle stream\n *\n * Send an event to the srcpad of the @sub element with the title\n * of the subtitle stream as a GST_TAG_TITLE\n */\n", "func_signal": "static void\ngst_avi_subtitle_title_tag (GstAviSubtitle * sub, gchar * title)", "code": "{\n  GstTagList *temp_list = gst_tag_list_new ();\n\n  gst_tag_list_add (temp_list, GST_TAG_MERGE_APPEND, GST_TAG_TITLE, title,\n      NULL);\n  gst_pad_push_event (sub->src, gst_event_new_tag (temp_list));\n}", "path": "gst\\avi\\gstavisubtitle.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* A DV frame consists of a bunch of 80-byte DIF blocks.\n * Each DIF block contains a 3-byte header telling where in the DV frame the\n * DIF block should go. We use this information to calculate its position.\n */\n", "func_signal": "static guint\ncalculate_difblock_location (guint8 * block)", "code": "{\n  gint block_type, dif_sequence, dif_block;\n  guint location;\n\n  block_type = block[0] >> 5;\n  dif_sequence = block[1] >> 4;\n  dif_block = block[2];\n\n  switch (block_type) {\n    case 0:                    /* Header block */\n      location = dif_sequence * 150 * 80;\n      break;\n    case 1:                    /* Subcode block */\n      location = dif_sequence * 150 * 80 + (1 + dif_block) * 80;\n      break;\n    case 2:                    /* VAUX block */\n      location = dif_sequence * 150 * 80 + (3 + dif_block) * 80;\n      break;\n    case 3:                    /* Audio block */\n      location = dif_sequence * 150 * 80 + (6 + dif_block * 16) * 80;\n      break;\n    case 4:                    /* Video block */\n      location = dif_sequence * 150 * 80 +\n          (7 + (dif_block / 15) + dif_block) * 80;\n      break;\n    default:                   /* Something bogus */\n      GST_DEBUG (\"UNKNOWN BLOCK\");\n      location = -1;\n      break;\n  }\n  return location;\n}", "path": "gst\\rtp\\gstrtpdvdepay.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* outputs the cmml head element and send TITLE and CMML_HEAD tags.\n * This callback is registered with dec->parser. It is called when the\n * head element is parsed.\n */\n", "func_signal": "static void\ngst_cmml_dec_parse_head (GstCmmlDec * dec, GstCmmlTagHead * head)", "code": "{\n  GstTagList *tags;\n  GValue str_val = { 0 }, title_val = {\n  0};\n  guchar *head_str;\n  GstBuffer *buffer;\n\n  GST_DEBUG_OBJECT (dec, \"found CMML head (title: %s base: %s)\",\n      head->title, head->base);\n\n  /* create the GST_TAG_TITLE tag */\n  g_value_init (&str_val, G_TYPE_STRING);\n  g_value_init (&title_val, gst_tag_get_type (GST_TAG_TITLE));\n  g_value_set_string (&str_val, (gchar *) head->title);\n  g_value_transform (&str_val, &title_val);\n\n  tags = gst_tag_list_new ();\n  gst_tag_list_add_values (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_TITLE, &title_val, NULL);\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND, GST_TAG_CMML_HEAD, head, NULL);\n  gst_element_found_tags_for_pad (GST_ELEMENT (dec), dec->srcpad, tags);\n\n  g_value_unset (&str_val);\n  g_value_unset (&title_val);\n\n  head_str = gst_cmml_parser_tag_head_to_string (dec->parser, head);\n\n  dec->flow_return = gst_cmml_dec_new_buffer (dec,\n      head_str, strlen ((gchar *) head_str), &buffer);\n  g_free (head_str);\n  if (dec->flow_return == GST_FLOW_OK)\n    dec->flow_return = gst_pad_push (dec->srcpad, buffer);\n  if (dec->flow_return == GST_FLOW_NOT_LINKED)\n    dec->flow_return = GST_FLOW_OK;     /* Ignore NOT_LINKED */\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* Process one RTP packet. Accumulate RTP payload in the proper place in a DV\n * frame, and return that frame if we detect a new frame, or NULL otherwise.\n * We assume a DV frame is 144000 bytes. That should accomodate PAL as well as\n * NTSC.\n */\n", "func_signal": "static GstBuffer *\ngst_rtp_dv_depay_process (GstBaseRTPDepayload * base, GstBuffer * in)", "code": "{\n  GstBuffer *out = NULL;\n  guint8 *payload;\n  guint32 rtp_ts;\n  guint payload_len, location;\n  GstRTPDVDepay *dvdepay = GST_RTP_DV_DEPAY (base);\n  gboolean marker;\n\n  marker = gst_rtp_buffer_get_marker (in);\n\n  /* Check if the received packet contains (the start of) a new frame, we do\n   * this by checking the RTP timestamp. */\n  rtp_ts = gst_rtp_buffer_get_timestamp (in);\n\n  /* we cannot copy the packet yet if the marker is set, we will do that below\n   * after taking out the data */\n  if (dvdepay->prev_ts != -1 && rtp_ts != dvdepay->prev_ts && !marker) {\n    /* the timestamp changed */\n    GST_DEBUG_OBJECT (dvdepay, \"new frame with ts %u, old ts %u\", rtp_ts,\n        dvdepay->prev_ts);\n\n    /* return copy of accumulator. */\n    out = gst_buffer_copy (dvdepay->acc);\n  }\n\n  /* Extract the payload */\n  payload_len = gst_rtp_buffer_get_payload_len (in);\n  payload = gst_rtp_buffer_get_payload (in);\n\n  /* copy all DIF chunks in their place. */\n  while (payload_len >= 80) {\n    /* Calculate where in the frame the payload should go */\n    location = calculate_difblock_location (payload);\n\n    /* Check if we received a header. We will not pass on frames until\n     * we've received a header, otherwise the DV decoder goes wacko. */\n    if (location == 0)\n      dvdepay->have_header = TRUE;\n\n    /* And copy it in, provided the location is sane. */\n    if (location >= 0 && location <= dvdepay->frame_size - 80)\n      memcpy (GST_BUFFER_DATA (dvdepay->acc) + location, payload, 80);\n\n    payload += 80;\n    payload_len -= 80;\n  }\n\n  if (marker) {\n    /* The marker marks the end of a frame that we need to push. The next frame\n     * will change the timestamp but we won't copy the accumulator again because\n     * we set the prev_ts to -1. */\n    out = gst_buffer_copy (dvdepay->acc);\n    GST_DEBUG_OBJECT (dvdepay, \"marker bit complete frame %u\", rtp_ts);\n    dvdepay->prev_ts = -1;\n  } else {\n    /* save last timestamp */\n    dvdepay->prev_ts = rtp_ts;\n  }\n  return out;\n}", "path": "gst\\rtp\\gstrtpdvdepay.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* This function destroys a GstXImageBuffer handling XShm availability */\n", "func_signal": "void\ngst_ximageutil_ximage_destroy (GstXContext * xcontext,\n    GstXImageSrcBuffer * ximage)", "code": "{\n  /* We might have some buffers destroyed after changing state to NULL */\n  if (!xcontext)\n    goto beach;\n\n  g_return_if_fail (ximage != NULL);\n\n#ifdef HAVE_XSHM\n  if (xcontext->use_xshm) {\n    if (ximage->SHMInfo.shmaddr != ((void *) -1)) {\n      XShmDetach (xcontext->disp, &ximage->SHMInfo);\n      XSync (xcontext->disp, 0);\n      shmdt (ximage->SHMInfo.shmaddr);\n    }\n    if (ximage->ximage)\n      XDestroyImage (ximage->ximage);\n\n  } else\n#endif /* HAVE_XSHM */\n  {\n    if (ximage->ximage) {\n      XDestroyImage (ximage->ximage);\n    }\n  }\n\n  XSync (xcontext->disp, FALSE);\nbeach:\n  if (ximage->parent) {\n    /* Release the ref to our parent */\n    gst_object_unref (ximage->parent);\n    ximage->parent = NULL;\n  }\n\n  return;\n}", "path": "sys\\ximage\\ximageutil.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* decode a clip tag\n * this callback is registered with dec->parser. It is called whenever a\n * clip is parsed.\n */\n", "func_signal": "static void\ngst_cmml_dec_parse_clip (GstCmmlDec * dec, GstCmmlTagClip * clip)", "code": "{\n  GstCmmlTagClip *prev_clip;\n\n  dec->flow_return = GST_FLOW_OK;\n\n  if (clip->empty)\n    GST_INFO_OBJECT (dec, \"parsing empty clip\");\n  else\n    GST_INFO_OBJECT (dec, \"parsing clip (id: %s)\", clip->id);\n\n  clip->start_time = dec->timestamp;\n  if (clip->start_time == GST_CLOCK_TIME_NONE) {\n    GST_ELEMENT_ERROR (dec, STREAM, DECODE,\n        (NULL), (\"invalid clip start time\"));\n\n    dec->flow_return = GST_FLOW_ERROR;\n    return;\n  }\n\n  /* get the last clip in the current track */\n  prev_clip = gst_cmml_track_list_get_track_last_clip (dec->tracks,\n      (gchar *) clip->track);\n  if (prev_clip) {\n    /* output the previous clip */\n    if (clip->empty)\n      /* the current clip marks the end of the previous one */\n      prev_clip->end_time = clip->start_time;\n\n    gst_cmml_dec_push_clip (dec, prev_clip);\n  }\n\n  if (dec->wait_clip_end) {\n    /* now it's time to send the tag for the previous clip */\n    if (prev_clip) {\n      prev_clip->end_time = clip->start_time;\n      gst_cmml_dec_send_clip_tag (dec, prev_clip);\n    }\n  } else if (!clip->empty) {\n    /* send the tag for the current clip */\n    gst_cmml_dec_send_clip_tag (dec, clip);\n  }\n\n  if (prev_clip)\n    gst_cmml_track_list_del_clip (dec->tracks, prev_clip);\n\n  if (!clip->empty)\n    if (!gst_cmml_track_list_has_clip (dec->tracks, clip))\n      gst_cmml_track_list_add_clip (dec->tracks, clip);\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* This function checks that it is actually really possible to create an image\n   using XShm */\n", "func_signal": "gboolean\nximageutil_check_xshm_calls (GstXContext * xcontext)", "code": "{\n  XImage *ximage;\n  XShmSegmentInfo SHMInfo;\n  size_t size;\n  int (*handler) (Display *, XErrorEvent *);\n  gboolean result = FALSE;\n  gboolean did_attach = FALSE;\n\n  g_return_val_if_fail (xcontext != NULL, FALSE);\n\n  /* Sync to ensure any older errors are already processed */\n  XSync (xcontext->disp, FALSE);\n\n  /* Set defaults so we don't free these later unnecessarily */\n  SHMInfo.shmaddr = ((void *) -1);\n  SHMInfo.shmid = -1;\n\n  /* Setting an error handler to catch failure */\n  error_caught = FALSE;\n  handler = XSetErrorHandler (ximageutil_handle_xerror);\n\n  /* Trying to create a 1x1 ximage */\n  GST_DEBUG (\"XShmCreateImage of 1x1\");\n\n  ximage = XShmCreateImage (xcontext->disp, xcontext->visual,\n      xcontext->depth, ZPixmap, NULL, &SHMInfo, 1, 1);\n\n  /* Might cause an error, sync to ensure it is noticed */\n  XSync (xcontext->disp, FALSE);\n  if (!ximage || error_caught) {\n    GST_WARNING (\"could not XShmCreateImage a 1x1 image\");\n    goto beach;\n  }\n  size = ximage->height * ximage->bytes_per_line;\n\n  SHMInfo.shmid = shmget (IPC_PRIVATE, size, IPC_CREAT | 0777);\n  if (SHMInfo.shmid == -1) {\n    GST_WARNING (\"could not get shared memory of %\" G_GSIZE_FORMAT \" bytes\",\n        size);\n    goto beach;\n  }\n\n  SHMInfo.shmaddr = shmat (SHMInfo.shmid, 0, 0);\n  if (SHMInfo.shmaddr == ((void *) -1)) {\n    GST_WARNING (\"Failed to shmat: %s\", g_strerror (errno));\n    goto beach;\n  }\n\n  /* Delete the SHM segment. It will actually go away automatically\n   * when we detach now */\n  shmctl (SHMInfo.shmid, IPC_RMID, 0);\n\n  ximage->data = SHMInfo.shmaddr;\n  SHMInfo.readOnly = FALSE;\n\n  if (XShmAttach (xcontext->disp, &SHMInfo) == 0) {\n    GST_WARNING (\"Failed to XShmAttach\");\n    goto beach;\n  }\n\n  /* Sync to ensure we see any errors we caused */\n  XSync (xcontext->disp, FALSE);\n\n  if (!error_caught) {\n    did_attach = TRUE;\n    /* store whether we succeeded in result */\n    result = TRUE;\n  }\nbeach:\n  /* Sync to ensure we swallow any errors we caused and reset error_caught */\n  XSync (xcontext->disp, FALSE);\n  error_caught = FALSE;\n  XSetErrorHandler (handler);\n\n  if (did_attach) {\n    XShmDetach (xcontext->disp, &SHMInfo);\n    XSync (xcontext->disp, FALSE);\n  }\n  if (SHMInfo.shmaddr != ((void *) -1))\n    shmdt (SHMInfo.shmaddr);\n  if (ximage)\n    XDestroyImage (ximage);\n  return result;\n}", "path": "sys\\ximage\\ximageutil.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* yuk */\n", "func_signal": "static void\nhresamplecpy1 (guint8 * dest, const guint8 * src, guint len)", "code": "{\n  gint i;\n\n  for (i = 0; i < len; ++i) {\n    /* equivalent to: dest[i] = src[i << 1] */\n    *dest = *src;\n    ++dest;\n    ++src;\n    ++src;\n  }\n}", "path": "ext\\jpeg\\gstjpegdec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* parses the first CMML packet (the ident header)\n */\n", "func_signal": "static void\ngst_cmml_dec_parse_ident_header (GstCmmlDec * dec, GstBuffer * buffer)", "code": "{\n  guint8 *data = GST_BUFFER_DATA (buffer);\n\n  /* the ident header has a fixed length */\n  if (GST_BUFFER_SIZE (buffer) != CMML_IDENT_HEADER_SIZE) {\n    GST_ELEMENT_ERROR (dec, STREAM, DECODE,\n        (NULL), (\"wrong ident header size: %d\", GST_BUFFER_SIZE (buffer)));\n    dec->flow_return = GST_FLOW_ERROR;\n\n    return;\n  }\n\n  data += 8;\n  dec->major = GST_READ_UINT16_LE (data);\n  data += 2;\n  dec->minor = GST_READ_UINT16_LE (data);\n  data += 2;\n  dec->granulerate_n = GST_READ_UINT64_LE (data);\n  data += 8;\n  dec->granulerate_d = GST_READ_UINT64_LE (data);\n  data += 8;\n  dec->granuleshift = GST_READ_UINT8 (data);\n\n  GST_INFO_OBJECT (dec, \"bitstream initialized \"\n      \"(major: %\" G_GINT16_FORMAT \" minor: %\" G_GINT16_FORMAT\n      \" granulerate_n: %\" G_GINT64_FORMAT \" granulerate_d: %\" G_GINT64_FORMAT\n      \" granuleshift: %d)\",\n      dec->major, dec->minor,\n      dec->granulerate_n, dec->granulerate_d, dec->granuleshift);\n\n  dec->flow_return = GST_FLOW_OK;\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* Perform qos calculations before decoding the next frame. Returns TRUE if the\n * frame should be decoded, FALSE if the frame can be dropped entirely */\n", "func_signal": "static gboolean\ngst_jpeg_dec_do_qos (GstJpegDec * dec, GstClockTime timestamp)", "code": "{\n  GstClockTime qostime, earliest_time;\n  gdouble proportion;\n\n  /* no timestamp, can't do QoS => decode frame */\n  if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (timestamp))) {\n    GST_LOG_OBJECT (dec, \"invalid timestamp, can't do QoS, decode frame\");\n    return TRUE;\n  }\n\n  /* get latest QoS observation values */\n  gst_jpeg_dec_read_qos (dec, &proportion, &earliest_time);\n\n  /* skip qos if we have no observation (yet) => decode frame */\n  if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (earliest_time))) {\n    GST_LOG_OBJECT (dec, \"no observation yet, decode frame\");\n    return TRUE;\n  }\n\n  /* qos is done on running time */\n  qostime = gst_segment_to_running_time (&dec->segment, GST_FORMAT_TIME,\n      timestamp);\n\n  /* see how our next timestamp relates to the latest qos timestamp */\n  GST_LOG_OBJECT (dec, \"qostime %\" GST_TIME_FORMAT \", earliest %\"\n      GST_TIME_FORMAT, GST_TIME_ARGS (qostime), GST_TIME_ARGS (earliest_time));\n\n  if (qostime != GST_CLOCK_TIME_NONE && qostime <= earliest_time) {\n    GST_DEBUG_OBJECT (dec, \"we are late, drop frame\");\n    return FALSE;\n  }\n\n  GST_LOG_OBJECT (dec, \"decode frame\");\n  return TRUE;\n}", "path": "ext\\jpeg\\gstjpegdec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* returns image length in bytes if parsed \n * successfully, otherwise 0 */\n", "func_signal": "static guint\ngst_jpeg_dec_parse_image_data (GstJpegDec * dec)", "code": "{\n  guint8 *start, *data, *end;\n  guint size;\n\n  size = GST_BUFFER_SIZE (dec->tempbuf);\n  start = GST_BUFFER_DATA (dec->tempbuf);\n  end = start + size;\n  data = start;\n\n  g_return_val_if_fail (is_jpeg_start_marker (data), 0);\n\n  GST_DEBUG (\"Parsing jpeg image data (%u bytes)\", size);\n\n  /* skip start marker */\n  data += 2;\n\n  while (1) {\n    guint frame_len;\n    gboolean resync;\n\n    /* do we need to resync? */\n    resync = (*data != 0xff);\n    if (resync) {\n      GST_DEBUG (\"Lost sync at 0x%08x, resyncing\", data - start);\n      /* at the very least we expect 0xff 0xNN, thus end-1 */\n      while (*data != 0xff && data < end - 1)\n        ++data;\n    }\n    /* Skip over extra 0xff */\n    while (*data == 0xff && data < end)\n      ++data;\n    /* enough bytes left for marker? (we need 0xNN after the 0xff) */\n    if (data >= end) {\n      GST_DEBUG (\"at end of input and no EOI marker found, need more data\");\n      return 0;\n    }\n\n    if (*data == 0xd9) {\n      GST_DEBUG (\"0x%08x: EOI marker\", data - start);\n      return (data - start + 1);\n    }\n\n    if (*data >= 0xd0 && *data <= 0xd7)\n      frame_len = 0;\n    else if (data >= end - 2)\n      return 0;\n    else\n      frame_len = GST_READ_UINT16_BE (data + 1);\n    GST_DEBUG (\"0x%08x: tag %02x, frame_len=%u\", data - start - 1, *data,\n        frame_len);\n    /* the frame length includes the 2 bytes for the length; here we want at\n     * least 2 more bytes at the end for an end marker, thus end-2 */\n    if (data + 1 + frame_len >= end - 2) {\n      if (resync) {\n        GST_DEBUG (\"not a valid sync (not enough data).\");\n        /* Since *data != 0xff, the next iteration will go into resync again. */\n        continue;\n      }\n      /* theoretically we could have lost sync and not really need more\n       * data, but that's just tough luck and a broken image then */\n      GST_DEBUG (\"at end of input and no EOI marker found, need more data\");\n      return 0;\n    }\n\n    if (gst_jpeg_dec_parse_tag_has_entropy_segment (*data)) {\n      guint8 *d2 = data + 1 + frame_len;\n      guint eseglen = 0;\n\n      GST_DEBUG (\"0x%08x: finding entropy segment length\", data - start - 1);\n      while (1) {\n        if (d2[eseglen] == 0xff && d2[eseglen + 1] != 0x00)\n          break;\n        if (d2 + eseglen >= end - 1)\n          return 0;             /* need more data */\n        ++eseglen;\n      }\n      frame_len += eseglen;\n      GST_DEBUG (\"entropy segment length=%u => frame_len=%u\", eseglen,\n          frame_len);\n    }\n    if (resync) {\n      /* check if we will still be in sync if we interpret\n       * this as a sync point and skip this frame */\n      if (data[2 + frame_len] != 0xff) {\n        /* ignore and continue resyncing until we hit the end\n         * of our data or find a sync point that looks okay */\n        continue;\n      }\n      GST_DEBUG (\"found sync at %p\", data - size);\n    }\n\n    data += 1 + frame_len;\n  }\n}", "path": "ext\\jpeg\\gstjpegdec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* feeds data into the cmml parser.\n */\n", "func_signal": "static void\ngst_cmml_dec_parse_xml (GstCmmlDec * dec, guchar * data, guint size)", "code": "{\n  GError *err = NULL;\n\n  if (!gst_cmml_parser_parse_chunk (dec->parser, (gchar *) data, size, &err)) {\n    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), (err->message));\n    g_error_free (err);\n    dec->flow_return = GST_FLOW_ERROR;\n  }\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* send a TAG_MESSAGE event for a clip */\n", "func_signal": "static void\ngst_cmml_dec_send_clip_tag (GstCmmlDec * dec, GstCmmlTagClip * clip)", "code": "{\n  GstTagList *tags;\n\n  GST_DEBUG_OBJECT (dec, \"sending clip tag %s\", clip->id);\n\n  tags = gst_tag_list_new ();\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND, GST_TAG_CMML_CLIP, clip, NULL);\n  gst_element_found_tags_for_pad (GST_ELEMENT (dec), dec->srcpad, tags);\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* push the string representation of a clip */\n", "func_signal": "static void\ngst_cmml_dec_push_clip (GstCmmlDec * dec, GstCmmlTagClip * clip)", "code": "{\n  GstBuffer *buffer;\n  guchar *clip_str;\n\n  GST_DEBUG_OBJECT (dec, \"pushing clip %s\", clip->id);\n\n  clip_str = gst_cmml_parser_tag_clip_to_string (dec->parser, clip);\n  dec->flow_return = gst_cmml_dec_new_buffer (dec,\n      clip_str, strlen ((gchar *) clip_str), &buffer);\n  if (dec->flow_return == GST_FLOW_OK)\n    dec->flow_return = gst_pad_push (dec->srcpad, buffer);\n  if (dec->flow_return == GST_FLOW_NOT_LINKED)\n    dec->flow_return = GST_FLOW_OK;     /* Ignore NOT_LINKED */\n\n  g_free (clip_str);\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* parses the first secondary header.\n * the first secondary header contains the xml version, the doctype and the\n * optional \"cmml\" processing instruction.\n */\n", "func_signal": "static void\ngst_cmml_dec_parse_first_header (GstCmmlDec * dec, GstBuffer * buffer)", "code": "{\n  gst_cmml_dec_parse_xml (dec,\n      GST_BUFFER_DATA (buffer), GST_BUFFER_SIZE (buffer));\n\n  /* if there is a processing instruction, gst_cmml_dec_parse_preamble\n   * will be triggered. Otherwise we need to call it manually.\n   */\n  if (!GST_FLOW_IS_FATAL (dec->flow_return) && !dec->sent_root) {\n    guchar *preamble = (guchar *) g_strndup ((gchar *) GST_BUFFER_DATA (buffer),\n        GST_BUFFER_SIZE (buffer));\n\n    gst_cmml_dec_parse_preamble (dec, preamble, (guchar *) \"<cmml>\");\n    g_free (preamble);\n  }\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* finds the packet type of the buffer\n */\n", "func_signal": "static GstCmmlPacketType\ngst_cmml_dec_parse_packet_type (GstCmmlDec * dec, GstBuffer * buffer)", "code": "{\n  GstCmmlPacketType packet_type = GST_CMML_PACKET_UNKNOWN;\n  gchar *data = (gchar *) GST_BUFFER_DATA (buffer);\n  guint size = GST_BUFFER_SIZE (buffer);\n\n  if (size >= 8 && !memcmp (data, \"CMML\\0\\0\\0\\0\", 8)) {\n    packet_type = GST_CMML_PACKET_IDENT_HEADER;\n  } else if (size >= 5) {\n    if (!strncmp (data, \"<?xml\", 5))\n      packet_type = GST_CMML_PACKET_FIRST_HEADER;\n    else if (!strncmp (data, \"<head\", 5))\n      packet_type = GST_CMML_PACKET_SECOND_HEADER;\n    else if (!strncmp (data, \"<clip\", 5))\n      packet_type = GST_CMML_PACKET_CLIP;\n  }\n\n  return packet_type;\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* initialize the plugin's class */\n", "func_signal": "static void\ngst_rtp_dv_depay_class_init (GstRTPDVDepayClass * klass)", "code": "{\n  GstElementClass *gstelement_class = (GstElementClass *) klass;\n  GstBaseRTPDepayloadClass *gstbasertpdepayload_class =\n      (GstBaseRTPDepayloadClass *) klass;\n\n  gstelement_class->change_state =\n      GST_DEBUG_FUNCPTR (gst_rtp_dv_depay_change_state);\n\n  gstbasertpdepayload_class->process =\n      GST_DEBUG_FUNCPTR (gst_rtp_dv_depay_process);\n  gstbasertpdepayload_class->set_caps =\n      GST_DEBUG_FUNCPTR (gst_rtp_dv_depay_setcaps);\n\n  GST_DEBUG_CATEGORY_INIT (rtpdvdepay_debug, \"rtpdvdepay\", 0,\n      \"DV RTP Depayloader\");\n}", "path": "gst\\rtp\\gstrtpdvdepay.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* This function calculates the pixel aspect ratio based on the properties\n * in the xcontext structure and stores it there. */\n", "func_signal": "void\nximageutil_calculate_pixel_aspect_ratio (GstXContext * xcontext)", "code": "{\n  gint par[][2] = {\n    {1, 1},                     /* regular screen */\n    {16, 15},                   /* PAL TV */\n    {11, 10},                   /* 525 line Rec.601 video */\n    {54, 59}                    /* 625 line Rec.601 video */\n  };\n  gint i;\n  gint index;\n  gdouble ratio;\n  gdouble delta;\n\n#define DELTA(idx) (ABS (ratio - ((gdouble) par[idx][0] / par[idx][1])))\n\n  /* first calculate the \"real\" ratio based on the X values;\n   * which is the \"physical\" w/h divided by the w/h in pixels of the display */\n  ratio = (gdouble) (xcontext->widthmm * xcontext->height)\n      / (xcontext->heightmm * xcontext->width);\n\n  /* DirectFB's X in 720x576 reports the physical dimensions wrong, so\n   * override here */\n  if (xcontext->width == 720 && xcontext->height == 576) {\n    ratio = 4.0 * 576 / (3.0 * 720);\n  }\n  GST_DEBUG (\"calculated pixel aspect ratio: %f\", ratio);\n\n  /* now find the one from par[][2] with the lowest delta to the real one */\n  delta = DELTA (0);\n  index = 0;\n\n  for (i = 1; i < sizeof (par) / (sizeof (gint) * 2); ++i) {\n    gdouble this_delta = DELTA (i);\n\n    if (this_delta < delta) {\n      index = i;\n      delta = this_delta;\n    }\n  }\n\n  GST_DEBUG (\"Decided on index %d (%d/%d)\", index,\n      par[index][0], par[index][1]);\n\n  if (xcontext->par)\n    g_free (xcontext->par);\n  xcontext->par = g_new0 (GValue, 1);\n  g_value_init (xcontext->par, GST_TYPE_FRACTION);\n  gst_value_set_fraction (xcontext->par, par[index][0], par[index][1]);\n  GST_DEBUG (\"set xcontext PAR to %d/%d\\n\",\n      gst_value_get_fraction_numerator (xcontext->par),\n      gst_value_get_fraction_denominator (xcontext->par));\n}", "path": "sys\\ximage\\ximageutil.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* creates a new buffer and sets caps and timestamp on it\n */\n", "func_signal": "static GstFlowReturn\ngst_cmml_dec_new_buffer (GstCmmlDec * dec,\n    guchar * data, gint size, GstBuffer ** buffer)", "code": "{\n  GstFlowReturn res;\n\n  res = gst_pad_alloc_buffer (dec->srcpad, GST_BUFFER_OFFSET_NONE,\n      size, gst_static_pad_template_get_caps (&gst_cmml_dec_src_factory),\n      buffer);\n\n  if (res == GST_FLOW_OK) {\n    if (data)\n      memcpy (GST_BUFFER_DATA (*buffer), data, size);\n    GST_BUFFER_TIMESTAMP (*buffer) = dec->timestamp;\n  } else if (res == GST_FLOW_NOT_LINKED) {\n    GST_DEBUG_OBJECT (dec, \"alloc function return NOT-LINKED, ignoring\");\n  } else {\n    GST_WARNING_OBJECT (dec, \"alloc function returned error %s\",\n        gst_flow_get_name (res));\n  }\n\n  return res;\n}", "path": "ext\\annodex\\gstcmmldec.c", "repo_name": "roopar/gst-plugins-good", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 11648}
{"docstring": "/* Blinkin' LEDS for Robert.\n*/\n", "func_signal": "void\nshow_activity(int flag)", "code": "{\n\tvolatile uint *blatch;\n\n\tif (next_led_update > get_ticks())\n\t\treturn;\n\n\tblatch = (volatile uint *)CFG_LBC_CFGLATCH_BASE;\n\n\tled_bit >>= 1;\n\tif (led_bit == 0)\n\t\tled_bit = 0x08;\n\t*blatch = (0xc0 | led_bit);\n\teieio();\n\tnext_led_update += (get_tbclk() / 4);\n}", "path": "board\\stxssa\\stxssa.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* \"long\" version, uses 32bit words */\n", "func_signal": "int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)", "code": "{\n\tulong cp, wp;\n\tulong data;\n\tint l;\n\tint i, rc;\n\n\twp = (addr & ~3);\t/* get lower word aligned address */\n\n\t/*\n\t * handle unaligned start bytes\n\t */\n\tif ((l = addr - wp) != 0) {\n\t\tdata = 0;\n\t\tfor (i=0, cp=wp; i<l; ++i, ++cp) {\n\t\t\tdata = (data >> 8) | (*(uchar *)cp << 24);\n\t\t}\n\t\tfor (; i<4 && cnt>0; ++i) {\n\t\t\tdata = (data >> 8) | (*src++ << 24);\n\t\t\t--cnt;\n\t\t\t++cp;\n\t\t}\n\t\tfor (; cnt==0 && i<4; ++i, ++cp) {\n\t\t\tdata = (data >> 8) | (*(uchar *)cp << 24);\n\t\t}\n\n\t\tif ((rc = write_long(info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 4;\n\t}\n\n\t/*\n\t * handle word aligned part\n\t */\n\twhile (cnt >= 4) {\n\t\tdata = *((ulong*)src);\n\t\tif ((rc = write_long(info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\tsrc += 4;\n\t\twp  += 4;\n\t\tcnt -= 4;\n\t}\n\n\tif (cnt == 0) return ERR_OK;\n\n\t/*\n\t * handle unaligned tail bytes\n\t */\n\tdata = 0;\n\tfor (i=0, cp=wp; i<4 && cnt>0; ++i, ++cp) {\n\t\tdata = (data >> 8) | (*src++ << 24);\n\t\t--cnt;\n\t}\n\tfor (; i<4; ++i, ++cp) {\n\t\tdata = (data >> 8) | (*(uchar *)cp << 24);\n\t}\n\n\treturn write_long(info, wp, data);\n}", "path": "board\\csb226\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "unsigned long\nflash_init (void)", "code": "{\n\tunsigned int i;\n\tunsigned long size_b0 = 0, size_b1 = 0;\n\tunsigned long base, flash_size;\n\n\t/* Init: no FLASHes known */\n\tfor (i=0; i<CFG_MAX_FLASH_BANKS; ++i) {\n\t\tflash_info[i].flash_id = FLASH_UNKNOWN;\n\t}\n\n\t/* the boot flash */\n\tbase = CFG_FLASH_BASE;\n#ifndef CFG_BOOT_FLASH_WIDTH\n#define CFG_BOOT_FLASH_WIDTH\t1\n#endif\n\tsize_b0 = flash_get_size(CFG_BOOT_FLASH_WIDTH, (vu_long *)base,\n\t                         &flash_info[0]);\n\n#ifndef CONFIG_P3G4\n\tprintf(\"[\");\n\tprint_size (size_b0, \"\");\n\tprintf(\"@%08lX] \", base);\n#endif\n\n\tif (flash_info[0].flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"## Unknown FLASH at %08lx: Size = 0x%08lx = %ld MB\\n\",\n\t\t\tbase, size_b0, size_b0<<20);\n\t}\n\n\tbase = memoryGetDeviceBaseAddress(CFG_EXTRA_FLASH_DEVICE);\n\tfor(i=1;i<CFG_MAX_FLASH_BANKS;i++) {\n\t    unsigned long size = flash_get_size(CFG_EXTRA_FLASH_WIDTH, (vu_long *)base, &flash_info[i]);\n\n#ifndef CONFIG_P3G4\n\t    printf(\"[\");\n\t    print_size (size, \"\");\n\t    printf(\"@%08lX] \", base);\n#endif\n\n\t    if (flash_info[i].flash_id == FLASH_UNKNOWN) {\n\t\tif(i==1) {\n\t\t    printf (\"## Unknown FLASH at %08lx: Size = 0x%08lx = %ld MB\\n\",\n\t\t\t    base, size_b1, size_b1<<20);\n\t\t}\n\t\tbreak;\n\t    }\n\t    size_b1+=size;\n\t    base+=size;\n\t}\n\n#if CFG_MONITOR_BASE >= CFG_FLASH_BASE\n\t/* monitor protection ON by default */\n\tflash_protect(FLAG_PROTECT_SET,\n\t              CFG_MONITOR_BASE,\n\t              CFG_MONITOR_BASE + monitor_flash_len - 1,\n\t              flash_get_info(CFG_MONITOR_BASE));\n#endif\n\n#ifdef  CFG_ENV_IS_IN_FLASH\n\t/* ENV protection ON by default */\n\tflash_protect(FLAG_PROTECT_SET,\n\t              CFG_ENV_ADDR,\n\t              CFG_ENV_ADDR + CFG_ENV_SIZE - 1,\n\t              flash_get_info(CFG_ENV_ADDR));\n#endif\n\n\tflash_size = size_b0 + size_b1;\n\treturn flash_size;\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*\n * The following code cannot be run from FLASH!\n */\n", "func_signal": "static ulong flash_get_size_2(vu_long * addr, flash_info_t * info)", "code": "{\n\tshort i;\n\tCFG_FLASH_CHAR_SIZE value;\n\tulong base = (ulong) addr;\n\tvolatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;\n\n\tDEBUGF(\"FLASH ADDR: %08x\\n\", (unsigned)addr);\n\n\t/* Write auto select command: read Manufacturer ID */\n\taddr2[CFG_FLASH_CHAR_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;\n\taddr2[CFG_FLASH_CHAR_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;\n\taddr2[CFG_FLASH_CHAR_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;\n\tudelay(1000);\n\n\tvalue = (CFG_FLASH_CHAR_SIZE)addr2[0];\n\tDEBUGF(\"FLASH MANUFACT: %x\\n\", value);\n\n\tswitch (value) {\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_MANUFACT:\n\t\tinfo->flash_id = FLASH_MAN_AMD;\n\t\tbreak;\n\tcase (CFG_FLASH_CHAR_SIZE) FUJ_MANUFACT:\n\t\tinfo->flash_id = FLASH_MAN_FUJ;\n\t\tbreak;\n\tcase (CFG_FLASH_CHAR_SIZE) SST_MANUFACT:\n\t\tinfo->flash_id = FLASH_MAN_SST;\n\t\tbreak;\n\tcase (CFG_FLASH_CHAR_SIZE) STM_MANUFACT:\n\t\tinfo->flash_id = FLASH_MAN_STM;\n\t\tbreak;\n\tdefault:\n\t\tinfo->flash_id = FLASH_UNKNOWN;\n\t\tinfo->sector_count = 0;\n\t\tinfo->size = 0;\n\t\treturn 0;\t\t/* no or unknown flash */\n\t}\n\n\tvalue = (CFG_FLASH_CHAR_SIZE)addr2[2];\t/* device ID */\n\tDEBUGF(\"\\nFLASH DEVICEID: %x\\n\", value);\n\n\tswitch (value) {\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV040B:\n\t\tinfo->flash_id += FLASH_AM040;\n\t\tinfo->sector_count = 8;\n\t\tinfo->size = 0x0080000;\t/* => 512 ko */\n\t\tbreak;\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_F040B:\n\t\tinfo->flash_id += FLASH_AM040;\n\t\tinfo->sector_count = 8;\n\t\tinfo->size = 0x0080000;\t/* => 512 ko */\n\t\tbreak;\n\n\tcase (CFG_FLASH_CHAR_SIZE) STM_ID_M29W040B:\n\t\tinfo->flash_id += FLASH_AM040;\n\t\tinfo->sector_count = 8;\n\t\tinfo->size = 0x0080000;\t/* => 512 ko */\n\t\tbreak;\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_F016D:\n\t\tinfo->flash_id += FLASH_AMD016;\n\t\tinfo->sector_count = 32;\n\t\tinfo->size = 0x00200000;\n\t\tbreak;\t\t\t/* => 2 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV033C:\n\t\tinfo->flash_id += FLASH_AMDLV033C;\n\t\tinfo->sector_count = 64;\n\t\tinfo->size = 0x00400000;\n\t\tbreak;\t\t\t/* => 4 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV400T:\n\t\tinfo->flash_id += FLASH_AM400T;\n\t\tinfo->sector_count = 11;\n\t\tinfo->size = 0x00080000;\n\t\tbreak;\t\t\t/* => 0.5 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV400B:\n\t\tinfo->flash_id += FLASH_AM400B;\n\t\tinfo->sector_count = 11;\n\t\tinfo->size = 0x00080000;\n\t\tbreak;\t\t\t/* => 0.5 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV800T:\n\t\tinfo->flash_id += FLASH_AM800T;\n\t\tinfo->sector_count = 19;\n\t\tinfo->size = 0x00100000;\n\t\tbreak;\t\t\t/* => 1 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV800B:\n\t\tinfo->flash_id += FLASH_AM800B;\n\t\tinfo->sector_count = 19;\n\t\tinfo->size = 0x00100000;\n\t\tbreak;\t\t\t/* => 1 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV160T:\n\t\tinfo->flash_id += FLASH_AM160T;\n\t\tinfo->sector_count = 35;\n\t\tinfo->size = 0x00200000;\n\t\tbreak;\t\t\t/* => 2 MB */\n\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_LV160B:\n\t\tinfo->flash_id += FLASH_AM160B;\n\t\tinfo->sector_count = 35;\n\t\tinfo->size = 0x00200000;\n\t\tbreak;\t\t\t/* => 2 MB */\n\tcase (CFG_FLASH_CHAR_SIZE) AMD_ID_MIRROR:\n\t\tif ((CFG_FLASH_CHAR_SIZE)addr2[0x1c] == (CFG_FLASH_CHAR_SIZE)AMD_ID_LV128U_2\n\t\t\t\t&& (CFG_FLASH_CHAR_SIZE)addr2[0x1e] ==  (CFG_FLASH_CHAR_SIZE)AMD_ID_LV128U_3) {\n\t\t\tinfo->flash_id += FLASH_AMLV128U;\n\t\t\tinfo->sector_count = 256;\n\t\t\tinfo->size = 0x01000000;\n\t\t} else if ((CFG_FLASH_CHAR_SIZE)addr2[0x1c] == (CFG_FLASH_CHAR_SIZE)AMD_ID_GL128N_2\n\t\t\t\t&& (CFG_FLASH_CHAR_SIZE)addr2[0x1e] ==  (CFG_FLASH_CHAR_SIZE)AMD_ID_GL128N_3 ) {\n\t\t\tinfo->flash_id += FLASH_S29GL128N;\n\t\t\tinfo->sector_count = 128;\n\t\t\tinfo->size = 0x01000000;\n\t\t}\n\t\telse\n\t\t\tinfo->flash_id = FLASH_UNKNOWN;\n\t\tbreak;\t\t\t/* => 2 MB */\n\n\tdefault:\n\t\tinfo->flash_id = FLASH_UNKNOWN;\n\t\treturn 0;\t\t/* => no or unknown flash */\n\t}\n\n\t/* set up sector start address table */\n\tif (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||\n\t    ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||\n\t    ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016)) {\n\t\tfor (i = 0; i < info->sector_count; i++)\n\t\t\tinfo->start[i] = base + (i * 0x00010000);\n\t} else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMLV128U) {\n\t\tfor (i = 0; i < info->sector_count; i++)\n\t\t\tinfo->start[i] = base + (i * 0x00010000);\n\t} else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_S29GL128N ) {\n\t\tfor (i = 0; i < info->sector_count; i++)\n\t\t\tinfo->start[i] = base + (i * 0x00020000);\n\t} else {\n\t\tif (info->flash_id & FLASH_BTYPE) {\n\t\t\t/* set sector offsets for bottom boot block type */\n\t\t\tinfo->start[0] = base + 0x00000000;\n\t\t\tinfo->start[1] = base + 0x00004000;\n\t\t\tinfo->start[2] = base + 0x00006000;\n\t\t\tinfo->start[3] = base + 0x00008000;\n\t\t\tfor (i = 4; i < info->sector_count; i++) {\n\t\t\t\tinfo->start[i] =\n\t\t\t\t    base + (i * 0x00010000) - 0x00030000;\n\t\t\t}\n\t\t} else {\n\t\t\t/* set sector offsets for top boot block type */\n\t\t\ti = info->sector_count - 1;\n\t\t\tinfo->start[i--] = base + info->size - 0x00004000;\n\t\t\tinfo->start[i--] = base + info->size - 0x00006000;\n\t\t\tinfo->start[i--] = base + info->size - 0x00008000;\n\t\t\tfor (; i >= 0; i--) {\n\t\t\t\tinfo->start[i] = base + i * 0x00010000;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for protected sectors */\n\tfor (i = 0; i < info->sector_count; i++) {\n\t\t/* read sector protection at sector address, (A7 .. A0) = 0x02 */\n\t\t/* D0 = 1 if protected */\n\t\taddr2 = (volatile CFG_FLASH_WORD_SIZE *)(info->start[i]);\n\n\t\t/* For AMD29033C flash we need to resend the command of *\n\t\t * reading flash protection for upper 8 Mb of flash     */\n\t\tif (i == 32) {\n\t\t\taddr2[CFG_FLASH_CHAR_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;\n\t\t\taddr2[CFG_FLASH_CHAR_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;\n\t\t\taddr2[CFG_FLASH_CHAR_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;\n\t\t}\n\n\t\tif ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)\n\t\t\tinfo->protect[i] = 0;\n\t\telse\n\t\t\tinfo->protect[i] = (CFG_FLASH_CHAR_SIZE)addr2[4] & 1;\n\t}\n\n\t/* issue bank reset to return to read mode */\n\taddr2[0] = (CFG_FLASH_WORD_SIZE) 0xF0F0F0F0;\n\treturn info->size;\n}", "path": "board\\amcc\\taihu\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/**\n * write_long: - copy memory to flash, assume a bank of 2 devices with 16bit each\n */\n", "func_signal": "static int write_long (flash_info_t *info, ulong dest, ulong data)", "code": "{\n\tu32 * volatile addr = (u32 * volatile)dest, val;\n\tint rc = ERR_OK;\n\tint flag;\n\n\t/* read array command - just for the case... */\n\t*addr = 0x00FF00FF;\n\n\t/* Check if Flash is (sufficiently) erased */\n\tif ((*addr & data) != data) return ERR_NOT_ERASED;\n\n\t/*\n\t * Disable interrupts which might cause a timeout\n\t * here. Remember that our exception vectors are\n\t * at address 0 in the flash, and we don't want a\n\t * (ticker) exception to happen while the flash\n\t * chip is in programming mode.\n\t */\n\tflag = disable_interrupts();\n\n\t/* clear status register command */\n\t*addr = 0x00500050;\n\n\t/* program set-up command */\n\t*addr = 0x00400040;\n\n\t/* latch address/data */\n\t*addr = data;\n\n\t/* arm simple, non interrupt dependent timer */\n\treset_timer_masked();\n\n\t/* wait while polling the status register */\n\twhile(((val = *addr) & 0x00800080) != 0x00800080) {\n\t\tif (get_timer_masked() > CFG_FLASH_WRITE_TOUT) {\n\t\t\trc = ERR_TIMOUT;\n\t\t\t/* suspend program command */\n\t\t\t*addr = 0x00B000B0;\n\t\t\tgoto outahere;\n\t\t}\n\t}\n\n\t/* check for errors */\n\tif(val & 0x001A001A) {\n\t\tprintf(\"\\nFlash write error %02x at address %08lx\\n\",\n\t\t\t(int)val, (unsigned long)dest);\n\t\tif(val & 0x00080008) {\n\t\t\tprintf(\"Voltage range error.\\n\");\n\t\t\trc = ERR_PROG_ERROR;\n\t\t\tgoto outahere;\n\t\t}\n\t\tif(val & 0x00020002) {\n\t\t\tprintf(\"Device protect error.\\n\");\n\t\t\trc = ERR_PROTECTED;\n\t\t\tgoto outahere;\n\t\t}\n\t\tif(val & 0x00100010) {\n\t\t\tprintf(\"Programming error.\\n\");\n\t\t\trc = ERR_PROG_ERROR;\n\t\t\tgoto outahere;\n\t\t}\n\t\trc = ERR_PROG_ERROR;\n\t\tgoto outahere;\n\t}\n\noutahere:\n\t/* read array command */\n\t*addr = 0x00FF00FF;\n\tif (flag) enable_interrupts();\n\n\treturn rc;\n}", "path": "board\\csb226\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n * Write a word to Flash, returns:\n * 0 - OK\n * 1 - write timeout\n * 2 - Flash not erased\n */\n/* broken for 2x16: TODO */\n", "func_signal": "static int\nwrite_word (flash_info_t *info, ulong dest, ulong data)", "code": "{\n\tvolatile unsigned char *addr = (uchar *)(info->start[0]);\n\tulong start;\n\tint flag, i;\n\n\tif(info->portwidth==4) return 1;\n\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_ROM) return 1;\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_RAM) {\n\t    *(unsigned long *)dest=data;\n\t    return 0;\n\t}\n\tif ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)  {\n\t\tunsigned short low = data & 0xffff;\n\t\tunsigned short hi  = (data >> 16) & 0xffff;\n\t\tint ret = write_word_intel((bank_addr_t)dest, hi);\n\n\t\tif (!ret) ret = write_word_intel((bank_addr_t)(dest+2), low);\n\n\t\treturn ret;\n\t}\n\n\t/* Check if Flash is (sufficiently) erased */\n\tif ((*((vu_long *)dest) & data) != data) {\n\t\treturn (2);\n\t}\n\t/* Disable interrupts which might cause a timeout here */\n\tflag = disable_interrupts();\n\n\t/* first, perform an unlock bypass command to speed up flash writes */\n\taddr[0x555] = 0xAA;\n\taddr[0x2AA] = 0x55;\n\taddr[0x555] = 0x20;\n\n\t/* write each byte out */\n\tfor (i = 0; i < 4; i++) {\n\t\tchar *data_ch = (char *)&data;\n\t\taddr[0] = 0xA0;\n\t\t*(((char *)dest)+i) = data_ch[i];\n\t\tudelay(10); /* XXX */\n\t}\n\n\t/* we're done, now do an unlock bypass reset */\n\taddr[0] = 0x90;\n\taddr[0] = 0x00;\n\n\t/* re-enable interrupts if necessary */\n\tif (flag)\n\t\tenable_interrupts();\n\n\t/* data polling for D7 */\n\tstart = get_timer (0);\n\twhile ((*((vu_long *)dest) & 0x00800080) != (data & 0x00800080)) {\n\t\tif (get_timer(start) > CFG_FLASH_WRITE_TOUT) {\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "unsigned long flash_init (void)", "code": "{\n\tunsigned long size_b0;\n\tint i;\n\tuint pbcr;\n\tunsigned long base_b0;\n\tint size_val = 0;\n\n\t/* Init: no FLASHes known */\n\tfor (i=0; i<CFG_MAX_FLASH_BANKS; ++i) {\n\t\tflash_info[i].flash_id = FLASH_UNKNOWN;\n\t}\n\n\t/* Static FLASH Bank configuration here - FIXME XXX */\n\n\tsize_b0 = flash_get_size((vu_long *)FLASH_BASE0_PRELIM, &flash_info[0]);\n\n\tif (flash_info[0].flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"## Unknown FLASH on Bank 0 - Size = 0x%08lx = %ld MB\\n\",\n\t\t\tsize_b0, size_b0<<20);\n\t}\n\n\t/* Setup offsets */\n\tflash_get_offsets (-size_b0, &flash_info[0]);\n\n\t/* Re-do sizing to get full correct info */\n\tmtdcr(ebccfga, pb0cr);\n\tpbcr = mfdcr(ebccfgd);\n\tmtdcr(ebccfga, pb0cr);\n\tbase_b0 = -size_b0;\n\tswitch (size_b0) {\n\tcase 1 << 20:\n\t\tsize_val = 0;\n\t\tbreak;\n\tcase 2 << 20:\n\t\tsize_val = 1;\n\t\tbreak;\n\tcase 4 << 20:\n\t\tsize_val = 2;\n\t\tbreak;\n\tcase 8 << 20:\n\t\tsize_val = 3;\n\t\tbreak;\n\tcase 16 << 20:\n\t\tsize_val = 4;\n\t\tbreak;\n\t}\n\tpbcr = (pbcr & 0x0001ffff) | base_b0 | (size_val << 17);\n\tmtdcr(ebccfgd, pbcr);\n\n\t/* Monitor protection ON by default */\n\t(void)flash_protect(FLAG_PROTECT_SET,\n\t\t\t    -CFG_MONITOR_LEN,\n\t\t\t    0xffffffff,\n\t\t\t    &flash_info[0]);\n\n\tflash_info[0].size = size_b0;\n\n\treturn (size_b0);\n}", "path": "board\\esd\\cms700\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/**\n * flash_erase: - erase flash sectors\n */\n", "func_signal": "int flash_erase(flash_info_t *info, int s_first, int s_last)", "code": "{\n\tint flag, prot, sect;\n\tint rc = ERR_OK;\n\n\tif (info->flash_id == FLASH_UNKNOWN)\n\t\treturn ERR_UNKNOWN_FLASH_TYPE;\n\n\tif ((s_first < 0) || (s_first > s_last)) {\n\t\treturn ERR_INVAL;\n\t}\n\n\tif ((info->flash_id & FLASH_VENDMASK) != (INTEL_MANUFACT & FLASH_VENDMASK))\n\t\treturn ERR_UNKNOWN_FLASH_VENDOR;\n\n\tprot = 0;\n\tfor (sect=s_first; sect<=s_last; ++sect) {\n\t\tif (info->protect[sect]) prot++;\n\t}\n\n\tif (prot) return ERR_PROTECTED;\n\n\t/*\n\t * Disable interrupts which might cause a timeout\n\t * here. Remember that our exception vectors are\n\t * at address 0 in the flash, and we don't want a\n\t * (ticker) exception to happen while the flash\n\t * chip is in programming mode.\n\t */\n\n\tflag = disable_interrupts();\n\n\t/* Start erase on unprotected sectors */\n\tfor (sect = s_first; sect<=s_last && !ctrlc(); sect++) {\n\n\t\tprintf(\"Erasing sector %2d ... \", sect);\n\n\t\t/* arm simple, non interrupt dependent timer */\n\t\treset_timer_masked();\n\n\t\tif (info->protect[sect] == 0) { /* not protected */\n\t\t\tu32 * volatile addr = (u32 * volatile)(info->start[sect]);\n\n\t\t\t/* erase sector:\t\t\t\t    */\n\t\t\t/* The strata flashs are aligned side by side on    */\n\t\t\t/* the data bus, so we have to write the commands   */\n\t\t\t/* to both chips here:\t\t\t\t    */\n\n\t\t\t*addr = 0x00200020;\t/* erase setup */\n\t\t\t*addr = 0x00D000D0;\t/* erase confirm */\n\n\t\t\twhile ((*addr & 0x00800080) != 0x00800080) {\n\t\t\t\tif (get_timer_masked() > CFG_FLASH_ERASE_TOUT) {\n\t\t\t\t\t*addr = 0x00B000B0; /* suspend erase*/\n\t\t\t\t\t*addr = 0x00FF00FF; /* read mode    */\n\t\t\t\t\trc = ERR_TIMOUT;\n\t\t\t\t\tgoto outahere;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*addr = 0x00500050; /* clear status register cmd.   */\n\t\t\t*addr = 0x00FF00FF; /* reset to read mode\t    */\n\t\t}\n\t\tprintf(\"ok.\\n\");\n\t}\n\tif (ctrlc()) printf(\"User Interrupt!\\n\");\n\noutahere:\n\t/* allow flash to settle - wait 10 ms */\n\tudelay_masked(10000);\n\n\tif (flag) enable_interrupts();\n\n\treturn rc;\n}", "path": "board\\csb226\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*\n * The following code cannot be run from FLASH!\n */\n", "func_signal": "static inline void flash_cmd(int width, volatile unsigned char *addr, int offset, unsigned char cmd)", "code": "{\n\t/* supports 1x8, 1x16, and 2x16 */\n\t/* 2x8 and 4x8 are not supported */\n\tif(width==4) {\n\t    /* assuming chips are in 16 bit mode */\n\t    /* 2x16 */\n\t    unsigned long cmd32=(cmd<<16)|cmd;\n\t    *(volatile unsigned long *)(addr+offset*2)=cmd32;\n\t} else if (width == 2) {\n\t    /* 1x16 */\n\t    *(volatile unsigned short *)((unsigned short*)addr+offset)=cmd;\n\t} else {\n\t    /* 1x8 */\n\t    *(volatile unsigned char *)(addr+offset)=cmd;\n\t}\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "static void\nflash_get_offsets (ulong base, flash_info_t *info)", "code": "{\n\tint i;\n\tint sector_size;\n\n\tif(!info->sector_count) return;\n\n\t/* set up sector start address table */\n\tswitch(info->flash_id & FLASH_TYPEMASK) {\n\t    case FLASH_AM040:\n\t    case FLASH_28F128J3A:\n\t    case FLASH_28F640J3A:\n\t    case FLASH_RAM:\n\t\t/* this chip has uniformly spaced sectors */\n\t\tsector_size=info->size/info->sector_count;\n\t\tfor (i = 0; i < info->sector_count; i++)\n\t\t\tinfo->start[i] = base + (i * sector_size);\n\t\tbreak;\n\t    default:\n\t\tif (info->flash_id & FLASH_BTYPE) {\n\t\t    /* set sector offsets for bottom boot block type\t*/\n\t\t    info->start[0] = base + 0x00000000;\n\t\t    info->start[1] = base + 0x00008000;\n\t\t    info->start[2] = base + 0x0000C000;\n\t\t    info->start[3] = base + 0x00010000;\n\t\t    for (i = 4; i < info->sector_count; i++) {\n\t\t\t    info->start[i] = base + (i * 0x00020000) - 0x00060000;\n\t\t    }\n\t\t} else {\n\t\t    /* set sector offsets for top boot block type\t\t*/\n\t\t    i = info->sector_count - 1;\n\t\t    info->start[i--] = base + info->size - 0x00008000;\n\t\t    info->start[i--] = base + info->size - 0x0000C000;\n\t\t    info->start[i--] = base + info->size - 0x00010000;\n\t\t    for (; i >= 0; i--) {\n\t\t\t    info->start[i] = base + i * 0x00020000;\n\t\t    }\n\t\t}\n\t}\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/**\n * flash_print_info: - print information about the flash situation\n */\n", "func_signal": "void flash_print_info  (flash_info_t *info)", "code": "{\n\tint i, j;\n\n\tfor (j=0; j<CFG_MAX_FLASH_BANKS; j++) {\n\n\t\tswitch (info->flash_id & FLASH_VENDMASK) {\n\t\tcase (INTEL_MANUFACT & FLASH_VENDMASK):\n\t\t\tprintf (\"Intel: \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"Unknown Vendor \");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (info->flash_id & FLASH_TYPEMASK) {\n\t\tcase (INTEL_ID_28F128J3 & FLASH_TYPEMASK):\n\t\t\tprintf(\"28F128J3 (128Mbit)\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Unknown Chip Type\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(\"  Size: %ld MB in %d Sectors\\n\",\n\t\t\tinfo->size >> 20, info->sector_count);\n\n\t\tprintf(\"  Sector Start Addresses:\");\n\t\tfor (i = 0; i < info->sector_count; i++) {\n\t\t\tif ((i % 5) == 0) printf (\"\\n\t\");\n\n\t\t\tprintf (\" %08lX%s\", info->start[i],\n\t\t\t\tinfo->protect[i] ? \" (RO)\" : \"\t   \");\n\t\t}\n\t\tprintf (\"\\n\");\n\t\tinfo++;\n\t}\n}", "path": "board\\csb226\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "void\nflash_print_info  (flash_info_t *info)", "code": "{\n\tint i;\n\n\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"missing or unknown FLASH type\\n\");\n\t\treturn;\n\t}\n\n\tswitch (info->flash_id & FLASH_VENDMASK) {\n\tcase FLASH_MAN_AMD:\tprintf (\"AMD \");\t\tbreak;\n\tcase FLASH_MAN_FUJ:\tprintf (\"FUJITSU \");\t\tbreak;\n\tcase FLASH_MAN_INTEL:\tprintf (\"INTEL \");\t\tbreak;\n\tdefault:\t\tprintf (\"Unknown Vendor \");\tbreak;\n\t}\n\n\tswitch (info->flash_id & FLASH_TYPEMASK) {\n\tcase FLASH_AM040:\n\t\tprintf (\"AM29LV040B (4 Mbit, bottom boot sect)\\n\");\n\t\tbreak;\n\tcase FLASH_AM400B:\n\t\tprintf (\"AM29LV400B (4 Mbit, bottom boot sect)\\n\");\n\t\tbreak;\n\tcase FLASH_AM400T:\n\t\tprintf (\"AM29LV400T (4 Mbit, top boot sector)\\n\");\n\t\tbreak;\n\tcase FLASH_AM800B:\n\t\tprintf (\"AM29LV800B (8 Mbit, bottom boot sect)\\n\");\n\t\tbreak;\n\tcase FLASH_AM800T:\n\t\tprintf (\"AM29LV800T (8 Mbit, top boot sector)\\n\");\n\t\tbreak;\n\tcase FLASH_AM160B:\n\t\tprintf (\"AM29LV160B (16 Mbit, bottom boot sect)\\n\");\n\t\tbreak;\n\tcase FLASH_AM160T:\n\t\tprintf (\"AM29LV160T (16 Mbit, top boot sector)\\n\");\n\t\tbreak;\n\tcase FLASH_AM320B:\n\t\tprintf (\"AM29LV320B (32 Mbit, bottom boot sect)\\n\");\n\t\tbreak;\n\tcase FLASH_AM320T:\n\t\tprintf (\"AM29LV320T (32 Mbit, top boot sector)\\n\");\n\t\tbreak;\n\tcase FLASH_28F640J3A:\n\t\tprintf (\"28F640J3A (64 Mbit)\\n\");\n\t\tbreak;\n\tcase FLASH_28F128J3A:\n\t\tprintf (\"28F128J3A (128 Mbit)\\n\");\n\t\tbreak;\n\tcase FLASH_ROM:\n\t\tprintf (\"ROM\\n\");\n\t\tbreak;\n\tcase FLASH_RAM:\n\t\tprintf (\"RAM\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Unknown Chip Type\\n\");\n\t\tbreak;\n\t}\n\n\tputs (\"  Size: \");\n\tprint_size (info->size, \"\");\n\tprintf (\" in %d Sectors\\n\", info->sector_count);\n\n\tprintf (\"  Sector Start Addresses:\");\n\tfor (i=0; i<info->sector_count; ++i) {\n\t\tif ((i % 5) == 0)\n\t\t\tprintf (\"\\n   \");\n\t\tprintf (\" %08lX%s\",\n\t\t\tinfo->start[i],\n\t\t\tinfo->protect[i] ? \" (RO)\" : \"     \"\n\t\t);\n\t}\n\tprintf (\"\\n\");\n\treturn;\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* broken for 2x16: TODO */\n", "func_signal": "int\nwrite_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)", "code": "{\n\tulong cp, wp, data;\n\tint i, l, rc;\n\n\tif(info->portwidth==4) return 1;\n\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_ROM) return 0;\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_RAM) {\n\t    memcpy((void *)addr, src, cnt);\n\t    return 0;\n\t}\n\n\twp = (addr & ~3);\t/* get lower word aligned address */\n\n\t/*\n\t * handle unaligned start bytes\n\t */\n\tif ((l = addr - wp) != 0) {\n\t\tdata = 0;\n\t\tfor (i=0, cp=wp; i<l; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *)cp);\n\t\t}\n\t\tfor (; i<4 && cnt>0; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t\t--cnt;\n\t\t\t++cp;\n\t\t}\n\t\tfor (; cnt==0 && i<4; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *)cp);\n\t\t}\n\n\t\tif ((rc = write_word(info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 4;\n\t}\n\n\t/*\n\t * handle word aligned part\n\t */\n\twhile (cnt >= 4) {\n\t\tdata = 0;\n\t\tfor (i=0; i<4; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t}\n\t\tif ((rc = write_word(info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp  += 4;\n\t\tcnt -= 4;\n\t}\n\n\tif (cnt == 0) {\n\t\treturn (0);\n\t}\n\n\t/*\n\t * handle unaligned tail bytes\n\t */\n\tdata = 0;\n\tfor (i=0, cp=wp; i<4 && cnt>0; ++i, ++cp) {\n\t\tdata = (data << 8) | *src++;\n\t\t--cnt;\n\t}\n\tfor (; i<4; ++i, ++cp) {\n\t\tdata = (data << 8) | (*(uchar *)cp);\n\t}\n\n\treturn (write_word(info, wp, data));\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* Returns length of decompressed data. */\n", "func_signal": "int cramfs_uncompress_block (void *dst, void *src, int srclen)", "code": "{\n\tint err;\n\n\tinflateReset (&stream);\n\n\tstream.next_in = src;\n\tstream.avail_in = srclen;\n\n\tstream.next_out = dst;\n\tstream.avail_out = 4096 * 2;\n\n\terr = inflate (&stream, Z_FINISH);\n\n\tif (err != Z_STREAM_END)\n\t\tgoto err;\n\treturn stream.total_out;\n\n      err:\n\t/*printf (\"Error %d while decompressing!\\n\", err); */\n\t/*printf (\"%p(%d)->%p\\n\", src, srclen, dst); */\n\treturn -1;\n}", "path": "fs\\cramfs\\uncompress.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* TODO: 2x16 unsupported */\n", "func_signal": "int\nflash_erase (flash_info_t *info, int s_first, int s_last)", "code": "{\n\tvolatile unsigned char *addr = (uchar *)(info->start[0]);\n\tint flag, prot, sect, l_sect;\n\tulong start, now, last;\n\n\t/* TODO: 2x16 unsupported */\n\tif(info->portwidth==4) return 1;\n\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_ROM) return 1;\n\tif((info->flash_id & FLASH_TYPEMASK) == FLASH_RAM) {\n\t    for (sect = s_first; sect<=s_last; sect++) {\n\t\tint sector_size=info->size/info->sector_count;\n\t\taddr = (uchar *)(info->start[sect]);\n\t\tmemset((void *)addr, 0, sector_size);\n\t    }\n\t    return 0;\n\t}\n\n\tif ((s_first < 0) || (s_first > s_last)) {\n\t\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\t\tprintf (\"- missing\\n\");\n\t\t} else {\n\t\t\tprintf (\"- no sectors to erase\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((info->flash_id&FLASH_VENDMASK) == FLASH_MAN_INTEL)  {\n\t\treturn flash_erase_intel(info,\n\t\t\t\t(unsigned short)s_first,\n\t\t\t\t(unsigned short)s_last);\n\t}\n\n#if 0\n\tif ((info->flash_id == FLASH_UNKNOWN) ||\n\t    (info->flash_id > FLASH_AMD_COMP)) {\n\t\tprintf (\"Can't erase unknown flash type %08lx - aborted\\n\",\n\t\t\tinfo->flash_id);\n\t\treturn 1;\n\t}\n#endif\n\n\tprot = 0;\n\tfor (sect=s_first; sect<=s_last; ++sect) {\n\t\tif (info->protect[sect]) {\n\t\t\tprot++;\n\t\t}\n\t}\n\n\tif (prot) {\n\t\tprintf (\"- Warning: %d protected sectors will not be erased!\\n\",\n\t\t\tprot);\n\t} else {\n\t\tprintf (\"\\n\");\n\t}\n\n\tl_sect = -1;\n\n\t/* Disable interrupts which might cause a timeout here */\n\tflag = disable_interrupts();\n\n\tflash_cmd(info->portwidth,addr,0x555,0xAA);\n\tflash_cmd(info->portwidth,addr,0x2AA,0x55);\n\tflash_cmd(info->portwidth,addr,0x555,0x80);\n\tflash_cmd(info->portwidth,addr,0x555,0xAA);\n\tflash_cmd(info->portwidth,addr,0x2AA,0x55);\n\n\t/* Start erase on unprotected sectors */\n\tfor (sect = s_first; sect<=s_last; sect++) {\n\t\tif (info->protect[sect] == 0) {\t/* not protected */\n\t\t\taddr = (uchar *)(info->start[sect]);\n\t\t\tflash_cmd(info->portwidth,addr,0,0x30);\n\t\t\tl_sect = sect;\n\t\t}\n\t}\n\n\t/* re-enable interrupts if necessary */\n\tif (flag)\n\t\tenable_interrupts();\n\n\t/* wait at least 80us - let's wait 1 ms */\n\tudelay (1000);\n\n\t/*\n\t * We wait for the last triggered sector\n\t */\n\tif (l_sect < 0)\n\t\tgoto DONE;\n\n\tstart = get_timer (0);\n\tlast  = start;\n\taddr = (volatile unsigned char *)(info->start[l_sect]);\n\t/* broken for 2x16: TODO */\n\twhile ((addr[0] & 0x80) != 0x80) {\n\t\tif ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {\n\t\t\tprintf (\"Timeout\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* show that we're waiting */\n\t\tif ((now - last) > 1000) {\t/* every second */\n\t\t\tputc ('.');\n\t\t\tlast = now;\n\t\t}\n\t}\n\nDONE:\n\t/* reset to read mode */\n\taddr = (volatile unsigned char *)info->start[0];\n\tflash_cmd(info->portwidth,addr,0,0xf0);\n\tflash_cmd(info->portwidth,addr,0,0xf0);\n\n\tprintf (\" done\\n\");\n\treturn 0;\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/**\n * flash_init: - initialize data structures for flash chips\n *\n * @return: size of the flash\n */\n", "func_signal": "ulong flash_init(void)", "code": "{\n\tint i, j;\n\tulong size = 0;\n\n\tfor (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {\n\t\tulong flashbase = 0;\n\t\tflash_info[i].flash_id =\n\t\t\t(INTEL_MANUFACT & FLASH_VENDMASK) |\n\t\t\t(INTEL_ID_28F128J3 & FLASH_TYPEMASK);\n\t\tflash_info[i].size = FLASH_BANK_SIZE;\n\t\tflash_info[i].sector_count = CFG_MAX_FLASH_SECT;\n\t\tmemset(flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tflashbase = PHYS_FLASH_1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"configured too many flash banks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < flash_info[i].sector_count; j++) {\n\t\t\tflash_info[i].start[j] = flashbase + j*MAIN_SECT_SIZE;\n\t\t}\n\t\tsize += flash_info[i].size;\n\t}\n\n\t/* Protect monitor and environment sectors */\n\tflash_protect(FLAG_PROTECT_SET,\n\t\t\tCFG_FLASH_BASE,\n\t\t\tCFG_FLASH_BASE + monitor_flash_len - 1,\n\t\t\t&flash_info[0]);\n\n\tflash_protect(FLAG_PROTECT_SET,\n\t\t\tCFG_ENV_ADDR,\n\t\t\tCFG_ENV_ADDR + CFG_ENV_SIZE - 1,\n\t\t\t&flash_info[0]);\n\n\treturn size;\n}", "path": "board\\csb226\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* w7o_env_init() */\n", "func_signal": "int misc_init_r (void)", "code": "{\n\tVPD vpd;\t\t/* VPD information */\n\n#if defined(CONFIG_W7OLMG)\n\tunsigned long greg;\t/* GPIO Register */\n\n\tgreg = in32 (PPC405GP_GPIO0_OR);\n\n\t/*\n\t * XXX - Unreset devices - this should be moved into VxWorks driver code\n\t */\n\tgreg |= 0x41800000L;\t/* SAM, PHY, Galileo */\n\n\tout32 (PPC405GP_GPIO0_OR, greg);\t/* set output pins to default */\n#endif /* CONFIG_W7OLMG */\n\n\t/*\n\t * Initialize W7O environment variables\n\t */\n\tw7o_env_init (&vpd);\n\n\t/*\n\t * Initialize the FPGA(s).\n\t */\n\tif (init_fpga () == 0)\n\t\ttest_fpga ((unsigned short *) CONFIG_FPGAS_BASE);\n\n\t/* More POST testing. */\n\tpost2 ();\n\n\t/* Done with hardware initialization and POST. */\n\tlog_stat (ERR_POSTOK);\n\n\t/* Call silly, fail safe boot init routine */\n\tinit_fsboot ();\n\n\treturn (0);\n}", "path": "board\\w7o\\w7o.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n * Copy memory to flash, returns:\n * 0 - OK\n * 1 - write timeout\n * 2 - Flash not erased\n */\n", "func_signal": "int write_buff(flash_info_t * info, uchar * src, ulong addr, ulong cnt)", "code": "{\n\tulong cp, wp, data;\n\tint i, l, rc;\n\n\twp = (addr & ~3);\t/* get lower word aligned address */\n\n\t/*\n\t * handle unaligned start bytes\n\t */\n\tif ((l = addr - wp) != 0) {\n\t\tdata = 0;\n\t\tfor (i = 0, cp = wp; i < l; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *) cp);\n\t\t}\n\t\tfor (; i < 4 && cnt > 0; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t\t--cnt;\n\t\t\t++cp;\n\t\t}\n\t\tfor (; cnt == 0 && i < 4; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *) cp);\n\t\t}\n\n\t\tif ((rc = write_word(info, wp, data)) != 0) {\n\t\t\treturn rc;\n\t\t}\n\t\twp += 4;\n\t}\n\n\t/*\n\t * handle word aligned part\n\t */\n\twhile (cnt >= 4) {\n\t\tdata = 0;\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t}\n\t\tif ((rc = write_word(info, wp, data)) != 0) {\n\t\t\treturn rc;\n\t\t}\n\t\twp += 4;\n\t\tcnt -= 4;\n\t}\n\n\tif (cnt == 0) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * handle unaligned tail bytes\n\t */\n\tdata = 0;\n\tfor (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {\n\t\tdata = (data << 8) | *src++;\n\t\t--cnt;\n\t}\n\tfor (; i < 4; ++i, ++cp) {\n\t\tdata = (data << 8) | (*(uchar *) cp);\n\t}\n\n\treturn (write_word(info, wp, data));\n}", "path": "board\\amcc\\taihu\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* CONFIG_PCI */\n", "func_signal": "void\npci_init_board(void)", "code": "{\n#ifdef CONFIG_PCI\n\textern void pci_mpc85xx_init(struct pci_controller *hose);\n\n\tpci_mpc85xx_init(hose);\n#endif /* CONFIG_PCI */\n}", "path": "board\\stxssa\\stxssa.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "static flash_info_t *flash_get_info(ulong base)", "code": "{\n\tint i;\n\tflash_info_t * info;\n\n\tfor (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {\n\t\tinfo = & flash_info[i];\n\t\tif (info->start[0] <= base && base <= info->start[0] + info->size - 1)\n\t\t\tbreak;\n\t}\n\n\treturn i == CFG_MAX_FLASH_BANKS ? 0 : info;\n}", "path": "board\\evb64260\\flash.c", "repo_name": "zhoukejun/u-boot-1.3.4-yf255", "stars": 2, "license": "other", "language": "c", "size": 11276}
{"docstring": "/* Format is just date, 20061201. */\n", "func_signal": "gchar *\nempathy_log_manager_get_date_readable (const gchar *date)", "code": "{\n\ttime_t t;\n\n\tt = empathy_time_parse (date);\n\n\treturn empathy_time_to_string_local (t, \"%a %d %b %Y\");\n}", "path": "libempathy\\empathy-log-manager.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_ft_manager_get_dialog:\n * @ft_manager: an #EmpathyFTManager\n *\n * Returns the #GtkWidget of @ft_manager.\n *\n * Returns: the dialog\n */\n", "func_signal": "GtkWidget *\nempathy_ft_manager_get_dialog (EmpathyFTManager *ft_manager)", "code": "{\n  g_return_val_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager), NULL);\n\n  return ft_manager->priv->window;\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/*\n * API to save/load and parse the chatrooms file.\n */\n", "func_signal": "static gboolean\nchatroom_manager_get_all (EmpathyChatroomManager *manager)", "code": "{\n\tEmpathyChatroomManagerPriv *priv;\n\n\tpriv = GET_PRIV (manager);\n\n\t/* read file in */\n\tif (g_file_test (priv->file, G_FILE_TEST_EXISTS) &&\n\t    !chatroom_manager_file_parse (manager, priv->file))\n    return FALSE;\n\n\treturn TRUE;\n}", "path": "libempathy\\empathy-chatroom-manager.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* public methods */\n", "func_signal": "GtkWidget *\nempathy_contact_selector_new (EmpathyContactList *contact_list)", "code": "{\n  g_return_val_if_fail (EMPATHY_IS_CONTACT_LIST (contact_list), NULL);\n\n  return GTK_WIDGET (g_object_new (EMPATHY_TYPE_CONTACT_SELECTOR,\n      \"contact-list\", contact_list, NULL));\n}", "path": "libempathy-gtk\\empathy-contact-selector.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Takes care of moving the window to the current workspace. */\n", "func_signal": "void\nempathy_window_present (GtkWindow *window,\n\t\t\tgboolean   steal_focus)", "code": "{\n\tguint32 timestamp;\n\n\tg_return_if_fail (GTK_IS_WINDOW (window));\n\n\t/* There are three cases: hidden, visible, visible on another\n\t * workspace.\n\t */\n\n\tif (!empathy_window_get_is_visible (window)) {\n\t\t/* Hide it so present brings it to the current workspace. */\n\t\tgtk_widget_hide (GTK_WIDGET (window));\n\t}\n\n\ttimestamp = gtk_get_current_event_time ();\n\tgtk_window_set_skip_taskbar_hint (window, FALSE);\n\tgtk_window_present_with_time (window, timestamp);\n\t/* FIXME: This shouldn't be required as gtk_window_present's doc says\n\t *        it deiconify automatically. */\n\tgtk_window_deiconify (window);\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Sending files with the file chooser */\n", "func_signal": "static void\nfile_manager_send_file_request_cb (EmpathyDispatchOperation *operation,\n\t\t\t\t   const GError *error, gpointer user_data)", "code": "{\n\tGFile *file = (GFile *)user_data;\n\tEmpathyTpFile *tp_file;\n\n\tif (error != NULL) {\n\t\tDEBUG (\"Couldn't request channel: %s\", error->message);\n\t\tg_object_unref (file);\n\t\treturn;\n\t}\n\n\tDEBUG (\"Starting to send file\");\n\n\ttp_file = EMPATHY_TP_FILE (\n\t\tempathy_dispatch_operation_get_channel_wrapper (operation));\n\n\tempathy_tp_file_offer (tp_file, file, NULL);\n\n\tg_object_unref (file);\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* HAVE_ENCHANT */\n", "func_signal": "void\nempathy_spell_free_suggestions (GList *suggestions)", "code": "{\n\tg_list_foreach (suggestions, (GFunc) g_free, NULL);\n\tg_list_free (suggestions);\n}", "path": "libempathy-gtk\\empathy-spell.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Pads a pixbuf to the specified size, by centering it in a larger transparent\n * pixbuf. Returns a new ref.\n */\n", "func_signal": "static GdkPixbuf *\ntheme_boxes_pad_to_size (GdkPixbuf *pixbuf,\n\t\t\t gint       width,\n\t\t\t gint       height,\n\t\t\t gint       extra_padding_right)", "code": "{\n\tgint       src_width, src_height;\n\tGdkPixbuf *padded;\n\tgint       x_offset, y_offset;\n\n\tsrc_width = gdk_pixbuf_get_width (pixbuf);\n\tsrc_height = gdk_pixbuf_get_height (pixbuf);\n\n\tx_offset = (width - src_width) / 2;\n\ty_offset = (height - src_height) / 2;\n\n\tpadded = gdk_pixbuf_new (gdk_pixbuf_get_colorspace (pixbuf),\n\t\t\t\t TRUE, /* alpha */\n\t\t\t\t gdk_pixbuf_get_bits_per_sample (pixbuf),\n\t\t\t\t width + extra_padding_right,\n\t\t\t\t height);\n\n\tgdk_pixbuf_fill (padded, 0);\n\n\tgdk_pixbuf_copy_area (pixbuf,\n\t\t\t      0, /* source coords */\n\t\t\t      0,\n\t\t\t      src_width,\n\t\t\t      src_height,\n\t\t\t      padded,\n\t\t\t      x_offset, /* dest coords */\n\t\t\t      y_offset);\n\n\treturn padded;\n}", "path": "libempathy-gtk\\empathy-theme-boxes.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Returns whether or not the operation was successfully claimed */\n", "func_signal": "gboolean\nempathy_dispatch_operation_claim (EmpathyDispatchOperation *operation)", "code": "{\n  EmpathyDispatchOperationPriv *priv;\n\n  g_return_val_if_fail (EMPATHY_IS_DISPATCH_OPERATION (operation), FALSE);\n\n  priv = GET_PRIV (operation);\n\n  if (priv->status == EMPATHY_DISPATCHER_OPERATION_STATE_CLAIMED)\n    return FALSE;\n\n  empathy_dispatch_operation_set_status (operation,\n    EMPATHY_DISPATCHER_OPERATION_STATE_CLAIMED);\n\n  g_signal_emit (operation, signals[CLAIMED], 0);\n\n  return TRUE;\n}", "path": "libempathy\\empathy-dispatch-operation.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* this function acts like g_utf8_offset_to_pointer() except that if it finds a\n * decomposable character it consumes the decomposition length from the given\n * offset.  So it's useful when the offset was calculated for the normalized\n * version of str, but we need a pointer to str itself. */\n", "func_signal": "static const gchar *\npointer_from_offset_skipping_decomp (const gchar *str, gint offset)", "code": "{\n\tgchar *casefold, *normal;\n\tconst gchar *p, *q;\n\n\tp = str;\n\twhile (offset > 0)\n\t{\n\t\tq = g_utf8_next_char (p);\n\t\tcasefold = g_utf8_casefold (p, q - p);\n\t\tnormal = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\t\toffset -= g_utf8_strlen (normal, -1);\n\t\tg_free (casefold);\n\t\tg_free (normal);\n\t\tp = q;\n\t}\n\treturn p;\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* strsplit () that retains the delimiter as part of the string. */\n", "func_signal": "static gchar **\nstrbreakup (const char *string,\n\t    const char *delimiter,\n\t    gint        max_tokens)", "code": "{\n\tGSList *string_list = NULL, *slist;\n\tgchar **str_array, *s, *casefold, *new_string;\n\tguint i, n = 1;\n\n\tg_return_val_if_fail (string != NULL, NULL);\n\tg_return_val_if_fail (delimiter != NULL, NULL);\n\n\tif (max_tokens < 1)\n\t\tmax_tokens = G_MAXINT;\n\n\ts = strstr (string, delimiter);\n\tif (s)\n\t{\n\t\tguint delimiter_len = strlen (delimiter);\n\n\t\tdo\n\t\t{\n\t\t\tguint len;\n\n\t\t\tlen = s - string + delimiter_len;\n\t\t\tnew_string = g_new (gchar, len + 1);\n\t\t\tstrncpy (new_string, string, len);\n\t\t\tnew_string[len] = 0;\n\t\t\tcasefold = g_utf8_casefold (new_string, -1);\n\t\t\tg_free (new_string);\n\t\t\tnew_string = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\t\t\tg_free (casefold);\n\t\t\tstring_list = g_slist_prepend (string_list, new_string);\n\t\t\tn++;\n\t\t\tstring = s + delimiter_len;\n\t\t\ts = strstr (string, delimiter);\n\t\t} while (--max_tokens && s);\n\t}\n\n\tif (*string)\n\t{\n\t\tn++;\n\t\tcasefold = g_utf8_casefold (string, -1);\n\t\tnew_string = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\t\tg_free (casefold);\n\t\tstring_list = g_slist_prepend (string_list, new_string);\n\t}\n\n\tstr_array = g_new (gchar*, n);\n\n\ti = n - 1;\n\n\tstr_array[i--] = NULL;\n\tfor (slist = string_list; slist; slist = slist->next)\n\t\tstr_array[i--] = slist->data;\n\n\tg_slist_free (string_list);\n\n\treturn str_array;\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* The code that handles single-instance and startup notification is\n * copied from gedit.\n *\n * Copyright (C) 2005 - Paolo Maggi \n */\n", "func_signal": "static void\non_bacon_message_received (const char *message,\n\t\t\t   gpointer    data)", "code": "{\n\tGtkWidget *window = data;\n\tguint32    startup_timestamp;\n\n\tg_return_if_fail (message != NULL);\n\n\tDEBUG (\"Other instance launched, presenting the main window. message='%s'\",\n\t\tmessage);\n\n\tif (strcmp (message, \"accounts\") == 0) {\n\t\t/* accounts dialog requested */\n\t\tempathy_accounts_dialog_show (GTK_WINDOW (window), NULL);\n\t} else {\n\t\tstartup_timestamp = atoi (message);\n\n\t\t/* Set the proper interaction time on the window.\n\t\t * Fall back to roundtripping to the X server when we\n\t\t * don't have the timestamp, e.g. when launched from\n\t\t * terminal. We also need to make sure that the window\n\t\t * has been realized otherwise it will not work. lame. */\n\t\tif (startup_timestamp == 0) {\n\t\t\t/* Work if launched from the terminal */\n\t\t\tDEBUG (\"Using X server timestamp as a fallback\");\n\n\t\t\tif (!GTK_WIDGET_REALIZED (window)) {\n\t\t\t\tgtk_widget_realize (GTK_WIDGET (window));\n\t\t\t}\n\n\t\t\tstartup_timestamp = gdk_x11_get_server_time (window->window);\n\t\t}\n\n\t\tgtk_window_present_with_time (GTK_WINDOW (window), startup_timestamp);\n\t}\n}", "path": "src\\empathy.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/*\n * Accels\n */\n", "func_signal": "static void\nmain_window_accels_load (void)", "code": "{\n\tgchar *filename;\n\n\tfilename = g_build_filename (g_get_home_dir (), \".gnome2\", PACKAGE_NAME, ACCELS_FILENAME, NULL);\n\tif (g_file_test (filename, G_FILE_TEST_EXISTS)) {\n\t\tDEBUG (\"Loading from:'%s'\", filename);\n\t\tgtk_accel_map_load (filename);\n\t}\n\n\tg_free (filename);\n}", "path": "src\\empathy-main-window.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_irc_network_dialog_show:\n * @network: the #EmpathyIrcNetwork to configure\n * @parent: the parent of this dialog\n *\n * Display a dialog to configure a given #EmpathyIrcNetwork.\n * This function is a singleton so if a configuration dialog already\n * exists we use this one to edit the network.\n *\n * Returns: The displayed #GtkDialog\n */\n", "func_signal": "GtkWidget *\nempathy_irc_network_dialog_show (EmpathyIrcNetwork *network,\n                                 GtkWidget *parent)", "code": "{\n  static EmpathyIrcNetworkDialog *dialog = NULL;\n  GladeXML *glade;\n  GtkListStore *store;\n  GtkCellRenderer *renderer;\n  GtkAdjustment *adjustment;\n  GtkTreeSelection *selection;\n  GtkTreeViewColumn *column;\n  gchar *filename;\n\n  g_return_val_if_fail (network != NULL, NULL);\n\n  if (dialog != NULL)\n    {\n      change_network (dialog, network);\n      gtk_window_present (GTK_WINDOW (dialog->dialog));\n\n      return dialog->dialog;\n    }\n\n  dialog = g_slice_new0 (EmpathyIrcNetworkDialog);\n\n  dialog->network = network;\n  g_object_ref (dialog->network);\n\n  filename = empathy_file_lookup (\"empathy-account-widget-irc.glade\",\n      \"libempathy-gtk\");\n  glade = empathy_glade_get_file (filename,\n      \"irc_network_dialog\",\n      NULL,\n      \"irc_network_dialog\", &dialog->dialog,\n      \"button_close\", &dialog->button_close,\n      \"entry_network\", &dialog->entry_network,\n      \"combobox_charset\", &dialog->combobox_charset,\n      \"treeview_servers\", &dialog->treeview_servers,\n      \"button_add\", &dialog->button_add,\n      \"button_remove\", &dialog->button_remove,\n      \"button_up\", &dialog->button_up,\n      \"button_down\", &dialog->button_down,\n      NULL);\n  g_free (filename);\n\n  store = gtk_list_store_new (4, G_TYPE_OBJECT, G_TYPE_STRING,\n      G_TYPE_UINT, G_TYPE_BOOLEAN);\n  gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->treeview_servers),\n      GTK_TREE_MODEL (store));\n  g_object_unref (store);\n\n  /* address */\n  renderer = gtk_cell_renderer_text_new ();\n  g_object_set (renderer, \"editable\", TRUE, NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_address_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Server\"), renderer, \"text\", COL_ADR,\n      NULL);\n\n  /* port */\n  adjustment = (GtkAdjustment *) gtk_adjustment_new (6667, 1, G_MAXUINT16,\n      1, 10, 0);\n  renderer = gtk_cell_renderer_spin_new ();\n  g_object_set (renderer,\n      \"editable\", TRUE, \n      \"adjustment\", adjustment,\n      NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_port_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Port\"), renderer, \"text\", COL_PORT,\n      NULL);\n  column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->treeview_servers),\n      1);\n  gtk_tree_view_column_set_expand (column, TRUE);\n\n  /* SSL */\n  renderer = gtk_cell_renderer_toggle_new ();\n  g_object_set (renderer, \"activatable\", TRUE, NULL);\n  g_signal_connect (renderer, \"toggled\",\n      G_CALLBACK (irc_network_dialog_ssl_toggled_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"SSL\"), renderer, \"active\", COL_SSL,\n      NULL);\n\n  selection = gtk_tree_view_get_selection (\n      GTK_TREE_VIEW (dialog->treeview_servers));\n  gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);\n\n  /* charset */\n  totem_subtitle_encoding_init (GTK_COMBO_BOX (dialog->combobox_charset));\n\n  irc_network_dialog_setup (dialog);\n\n  empathy_glade_connect (glade, dialog,\n      \"irc_network_dialog\", \"destroy\", irc_network_dialog_destroy_cb,\n      \"button_close\", \"clicked\", irc_network_dialog_close_clicked_cb,\n      \"entry_network\", \"focus-out-event\", irc_network_dialog_network_focus_cb,\n      \"button_add\", \"clicked\", irc_network_dialog_button_add_clicked_cb,\n      \"button_remove\", \"clicked\", irc_network_dialog_button_remove_clicked_cb,\n      \"button_up\", \"clicked\", irc_network_dialog_button_up_clicked_cb,\n      \"button_down\", \"clicked\", irc_network_dialog_button_down_clicked_cb,\n      \"combobox_charset\", \"changed\", irc_network_dialog_combobox_charset_changed_cb,\n      NULL);\n\n  g_object_unref (glade);\n\n  g_object_add_weak_pointer (G_OBJECT (dialog->dialog),\n      (gpointer) &dialog);\n\n  g_signal_connect (selection, \"changed\",\n      G_CALLBACK (irc_network_dialog_selection_changed_cb),\n      dialog);\n\n  gtk_window_set_transient_for (GTK_WINDOW (dialog->dialog),\n      GTK_WINDOW (parent));\n  gtk_window_set_modal (GTK_WINDOW (dialog->dialog), TRUE);\n\n  irc_network_dialog_network_update_buttons (dialog);\n\n  return dialog->dialog;\n}", "path": "libempathy-gtk\\empathy-irc-network-dialog.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* The URL opening code can't handle schemeless strings, so we try to be\n * smart and add http if there is no scheme or doesn't look like a mail\n * address. This should work in most cases, and let us click on strings\n * like \"www.gnome.org\".\n */\n", "func_signal": "static gchar *\nfixup_url (const gchar *url)", "code": "{\n\tif (g_str_has_prefix (url, \"ghelp:\") ||\n\t    g_str_has_prefix (url, \"mailto:\") ||\n\t    strstr (url, \":/\")) {\n\t\treturn NULL;\n\t}\n\n\tif (strstr (url, \"@\")) {\n\t\treturn g_strdup_printf (\"mailto:%s\", url);\n\t}\n\n\treturn g_strdup_printf (\"http://%s\", url);\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_account_manager_get_count:\n * @manager: a #EmpathyAccountManager\n *\n * Get the number of accounts.\n *\n * Returns: the number of accounts.\n **/\n", "func_signal": "int\nempathy_account_manager_get_count (EmpathyAccountManager *manager)", "code": "{\n  EmpathyAccountManagerPriv *priv;\n\n  g_return_val_if_fail (EMPATHY_IS_ACCOUNT_MANAGER (manager), 0);\n\n  priv = GET_PRIV (manager);\n\n  return g_hash_table_size (priv->accounts);\n}", "path": "libempathy\\empathy-account-manager.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_ft_manager_add_tp_file:\n * @ft_manager: an #EmpathyFTManager\n * @ft: an #EmpathyFT\n *\n * Adds a file transfer to the file transfer manager dialog @ft_manager.\n * The manager dialog then shows the progress and other information about\n * @ft.\n */\n", "func_signal": "void\nempathy_ft_manager_add_tp_file (EmpathyFTManager *ft_manager,\n                                EmpathyTpFile *tp_file)", "code": "{\n  TpFileTransferState state;\n\n  g_return_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager));\n  g_return_if_fail (EMPATHY_IS_TP_FILE (tp_file));\n\n  state = empathy_tp_file_get_state (tp_file, NULL);\n\n  DEBUG (\"Adding a file transfer: contact=%s, filename=%s, state=%d\",\n      empathy_contact_get_name (empathy_tp_file_get_contact (tp_file)),\n      empathy_tp_file_get_filename (tp_file), state);\n\n  if (state == TP_FILE_TRANSFER_STATE_PENDING &&\n      empathy_tp_file_is_incoming (tp_file))\n    ft_manager_display_accept_dialog (ft_manager, tp_file);\n  else\n    ft_manager_add_tp_file_to_list (ft_manager, tp_file);\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Returns the window to open a new tab in if there is only one window\n * visble, otherwise, returns NULL indicating that a new window should\n * be added.\n */\n", "func_signal": "EmpathyChatWindow *\nempathy_chat_window_get_default (void)", "code": "{\n\tGList    *l;\n\tgboolean  separate_windows = TRUE;\n\n\tempathy_conf_get_bool (empathy_conf_get (),\n\t\t\t      EMPATHY_PREFS_UI_SEPARATE_CHAT_WINDOWS,\n\t\t\t      &separate_windows);\n\n\tif (separate_windows) {\n\t\t/* Always create a new window */\n\t\treturn NULL;\n\t}\n\n\tfor (l = chat_windows; l; l = l->next) {\n\t\tEmpathyChatWindow *chat_window;\n\t\tGtkWidget         *dialog;\n\n\t\tchat_window = l->data;\n\n\t\tdialog = empathy_chat_window_get_dialog (chat_window);\n\t\tif (empathy_window_get_is_visible (GTK_WINDOW (dialog))) {\n\t\t\t/* Found a visible window on this desktop */\n\t\t\treturn chat_window;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "src\\empathy-chat-window.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_account_widget_sip_new:\n * @account: the #McAccount to configure\n *\n * Creates a new SIP account widget to configure a given #McAccount\n *\n * Returns: The toplevel container of the configuration widget\n */\n", "func_signal": "GtkWidget *\nempathy_account_widget_sip_new (McAccount *account)", "code": "{\n  EmpathyAccountWidgetSip *settings;\n  GladeXML *glade;\n  gchar *filename;\n\n  settings = g_slice_new0 (EmpathyAccountWidgetSip);\n  settings->account = g_object_ref (account);\n\n  filename = empathy_file_lookup (\"empathy-account-widget-sip.glade\",\n      \"libempathy-gtk\");\n  glade = empathy_glade_get_file (filename,\n      \"vbox_sip_settings\",\n      NULL,\n      \"vbox_sip_settings\", &settings->vbox_settings,\n      \"entry_stun-server\", &settings->entry_stun_server,\n      \"spinbutton_stun-port\", &settings->spinbutton_stun_part,\n      \"checkbutton_discover-stun\", &settings->checkbutton_discover_stun,\n      NULL);\n  g_free (filename);\n\n  empathy_account_widget_handle_params (account, glade,\n      \"entry_userid\", \"account\",\n      \"entry_password\", \"password\",\n      \"checkbutton_discover-stun\", \"discover-stun\",\n      \"entry_stun-server\", \"stun-server\",\n      \"spinbutton_stun-port\", \"stun-port\",\n      NULL);\n\n  empathy_account_widget_add_forget_button (account, glade,\n                                            \"button_forget\",\n                                            \"entry_password\");\n\n  account_widget_sip_discover_stun_toggled_cb (settings->checkbutton_discover_stun,\n                                               settings);\n\n  empathy_glade_connect (glade, settings,\n      \"vbox_sip_settings\", \"destroy\", account_widget_sip_destroy_cb,\n      \"checkbutton_discover-stun\", \"toggled\", account_widget_sip_discover_stun_toggled_cb,\n      NULL);\n\n  g_object_unref (glade);\n\n  return settings->vbox_settings;\n}", "path": "libempathy-gtk\\empathy-account-widget-sip.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/**\n * empathy_irc_server_new:\n * @address: the address\n * @port: the port\n * @ssl: %TRUE if the server needs a SSL connection\n *\n * Creates a new #EmpathyIrcServer\n *\n * Returns: a new #EmpathyIrcServer\n */\n", "func_signal": "EmpathyIrcServer *\nempathy_irc_server_new (const gchar *address,\n                        guint port,\n                        gboolean ssl)", "code": "{\n  return g_object_new (EMPATHY_TYPE_IRC_SERVER,\n      \"address\", address,\n      \"port\", port,\n      \"ssl\", ssl,\n      NULL);\n}", "path": "libempathy\\empathy-irc-server.c", "repo_name": "Elleo/empathy", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 5968}
{"docstring": "/* Read all values inside given time region. */\n", "func_signal": "size_t HFSread_item_str (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, hfs_time_t from, hfs_time_t to, hfs_item_str_value_t **result)", "code": "{\n\tint len = 0, fd, eof = 0;\n\thfs_time_t clock;\n\tchar* p_name = get_name (hfs_base_dir, siteid, itemid, NK_ItemString);\n\tsize_t count = 0;\n\thfs_item_str_value_t* tmp;\n\tstruct __attribute__ ((packed)) {\n\t\tint len;\n\t\thfs_time_t clock;\n\t\tint len2;\n\t} tmp_str;\n\n\t*result = NULL;\n\n\tif ((fd = open (p_name, O_RDONLY)) == -1) {\n\t\tzabbix_log (LOG_LEVEL_DEBUG, \"HFSread_item_str: Canot open file %s\", p_name);\n\t\tfree (p_name);\n\t\treturn 0;\n\t}\n\n\tfree (p_name);\n\n\t/* search for start position */\n\twhile (1) {\n\t\tif (read (fd, &clock, sizeof (clock)) != sizeof (clock)) {\n\t\t\teof = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if we run out of data, exit */\n\t\tif (clock > to) {\n\t\t\teof = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip string value */\n\t\tif (read (fd, &len, sizeof (len)) != sizeof (len)) {\n\t\t\teof = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* we find it */\n\t\tif (clock >= from)\n\t\t\tbreak;\n\n\t\tif (lseek (fd, len + (len ? 1 : 0) + sizeof (len), SEEK_CUR) == (off_t)-1) {\n\t\t\teof = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!eof) {\n\t\t/* read values */\n\t\twhile (1) {\n\t\t\tcount++;\n\t\t\ttmp = (hfs_item_str_value_t*)realloc (*result, count * sizeof (hfs_item_str_value_t));\n\n\t\t\t/* we have no memory for this, return as is */\n\t\t\tif (!tmp) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*result = tmp;\n\t\t\ttmp[count-1].clock = clock;\n\t\t\tif (len) {\n\t\t\t\ttmp[count-1].value = (char*)malloc (len+1);\n\n\t\t\t\tif (!tmp[count-1].value)\n\t\t\t\t\tbreak;\n\t\t\t\tif (read (fd, tmp[count-1].value, len+1) != len+1) {\n\t\t\t\t\tfree (tmp[count-1].value);\n\t\t\t\t\tcount--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\ttmp[count-1].value = NULL;\n\n\t\t\t/* read metadata of next string */\n\t\t\tif (read (fd, &tmp_str, sizeof (tmp_str)) != sizeof (tmp_str))\n\t\t\t\tbreak;\n\n\t\t\tclock = tmp_str.clock;\n\t\t\tlen = tmp_str.len2;\n\t\t\tif (clock > to)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose (fd);\n\n\treturn count;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* optimized routines which get latest values */\n", "func_signal": "double\t\tHFS_get_item_last_dbl (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, char** stderr)", "code": "{\n#ifdef HAVE_MEMCACHE\n\thfs_time_t lastclock;\n\tdouble prev, last, prevorg, res = 0.0;\n\t*stderr = NULL;\n\tif (HFS_get_item_values_dbl (hfs_base_dir, siteid, itemid, &lastclock, &prev, &last, &prevorg, stderr))\n\t\tres = last;\n\treturn res;\n#else\n    char *p_data;\n    int fd;\n    hfs_off_t ofs;\n    double res;\n\n    p_data = get_name (hfs_base_dir, siteid, itemid, NK_ItemData);\n    if ((fd = open (p_data, O_RDONLY)) == -1) {\n\tfree (p_data);\n\treturn 0.0;\n    }\n    free (p_data);\n\n    ofs = lseek (fd, 0, SEEK_END);\n    ofs -= sizeof (res);\n    lseek (fd, ofs, SEEK_SET);\n\n    if (read (fd, &res, sizeof (res)) != sizeof (res))\n\t    res = 0.0;\n    close (fd);\n\n    return res;\n#endif\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n   Performs folding on values from specified time interval\n */\n", "func_signal": "int HFSread_interval(const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, hfs_time_t from, hfs_time_t to, void* init_res, read_count_fn_t fn)", "code": "{\n    char *p_data;\n    hfs_meta_t* meta;\n    hfs_off_t ofs;\n    int fd, block;\n    item_value_u value;\n    hfs_time_t ts;\n    int count = 0, total = 0;\n\n    zabbix_log(LOG_LEVEL_DEBUG, \"HFSread_interval (%s, %llu, %lld, %lld)\", hfs_base_dir, itemid, from, to);\n\n    meta = read_meta (hfs_base_dir, siteid, itemid, 0);\n    if (!meta)\n\treturn count;\n\n    if (!meta->blocks) {\n\tfree_meta (meta);\n\treturn count;\n    }\n\n    /* open data file and count amount of valid items */\n    p_data = get_name (hfs_base_dir, siteid, itemid, NK_ItemData);\n\n    if ((fd = open (p_data, O_RDONLY)) == -1) {\n\tfree_meta (meta);\n\tfree (p_data);\n\treturn count;\n    }\n    free (p_data);\n\n    ofs = find_meta_ofs (from, meta, &block);\n\n    if (ofs != -1) {\n\t    /* find correct timestamp */\n\t    ts = meta->meta[block].start + ((ofs - meta->meta[block].ofs) / sizeof (double)) * meta->meta[block].delay;\n\t    lseek (fd, ofs, SEEK_SET);\n\n\t    while (read (fd, &value, sizeof (value)) > 0) {\n\t\t    if (is_valid_val (&value, sizeof (value))) {\n\t\t\t    fn (meta->meta[block].type, value, ts, init_res);\n\t\t\t    count++;\n\t\t\t    total++;\n\t\t    }\n\t\t    ts += meta->meta[block].delay;\n\n\t\t    if (ts >= to)\n\t\t\t    break;\n\n\t\t    if (ts >= meta->meta[block].end) {\n\t\t\t    block++;\n\t\t\t    if (block >= meta->blocks)\n\t\t\t\t    break;\n\t\t    }\n\t    }\n    }\n\n    free_meta (meta);\n    close (fd);\n    return count;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n  Routine adds double value to HistoryFS storage.\n*/\n", "func_signal": "void HFSadd_history (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, unsigned int delay, double value, hfs_time_t clock)", "code": "{\n    zabbix_log(LOG_LEVEL_DEBUG, \"In HFSadd_history()\");\n    store_values (hfs_base_dir, siteid, itemid, clock, delay, &value, sizeof (double), 1, IT_DOUBLE);\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*------------------------------------------------------------------------\n *\n * Function\t:  str_base64_decode\n *\n * Purpose\t:  Decode a base64 string into a string\n *\n * Parameters\t:  p_b64str (in)\t- the base64 string to decode\n *\t\t   p_str (out)\t\t- the encoded str to return\n *\t\t   p_out_size (out)\t- the size (len) of the str decoded\n *\n * Returns\t:  \n *\n * Comments\t:\n *\n *----------------------------------------------------------------------*/\n", "func_signal": "void str_base64_decode(const char *p_b64str, char *p_str, int *p_out_size)", "code": "{\n\tint i;\n\tint j = 0;\n\tint\tin_size;\n\tchar from1='A',from2='A',from3='A',from4='A';\n\tunsigned char to1=0,to2=0,to3=0,to4=0;\n\tchar\tstr_clean[MAX_B64_SIZE];/* str_clean is the string \n\t\t\t\t\t* after removing the non-base64 \n\t\t\t\t\t* characters\n\t\t\t\t\t*/\n\tassert(p_b64str);\n\tassert(p_str);\n\tassert(p_out_size);\n\n\tin_size = (int)strlen(p_b64str);\n\tmemset(str_clean, 0, sizeof(str_clean));\n\t*p_out_size = 0;\n\t\n\t/* Clean-up input string */\n\tfor ( i=0; i < in_size; i++ )\n\t{\n\t\tif (is_base64(p_b64str[i]))\n\t\t{\n\t\t\tstr_clean[j++] = p_b64str[i];\n\t\t}\n\t}\n\t\n\t/* Re-define in_size after clean-up */\n\tin_size = (int)strlen(str_clean);\n\t\n\tif ( 0 == in_size )\n\t{\n\t\treturn;\n\t}\n\n\tfor ( i=0; i < in_size ;i+=4)\n\t{\t\n\t\tfrom1 = from2 = from3 = from4 = 'A';\n\t\tfrom1 = str_clean[i];\n\t\tif ( i+1 < in_size )\n\t\t{\n\t\t\tfrom2 = str_clean[i+1];\n\t\t}\t\t\n\t\tif ( i+2 < in_size )\n\t\t{\n\t\t\tfrom3 = str_clean[i+2];\n\t\t}\n\t\tif ( i+3 < in_size )\n\t\t{\n\t\t\tfrom4 = str_clean[i+3];\n\t\t};\n\n\t\tto1 = to2 = to3 = to4 = 0;\n\t\tto1 = char_base64_decode(from1);\n\t\tto2 = char_base64_decode(from2);\n\t\tto3 = char_base64_decode(from3);\n\t\tto4 = char_base64_decode(from4);\n\n\t\t*(p_str++) = ( (to1<<2)|(to2>>4) );\n\t\t(*p_out_size)++;\n\t\tif (from3 != '=')\n\t\t{\n\t\t\t*(p_str++) = ( ((to2&0xf)<<4)|(to3>>2) );\n\t\t\t(*p_out_size)++;\n\t\t}\n\t\tif (from4 != '=')\n\t\t{\n\t\t\t*(p_str++) =  ( ((to3&0x3)<<6)|to4 );\n\t\t\t(*p_out_size)++;\n\t\t}\n\t}\n\t\n\treturn;\n}", "path": "src\\libs\\zbxcrypto\\base64.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n  Routine adds array of double values to HistoryFS storage.\n*/\n", "func_signal": "void HFSadd_history_vals (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, unsigned int delay,\n\t\t\t  double* values, int count, hfs_time_t clock)", "code": "{\n    zabbix_log(LOG_LEVEL_DEBUG, \"In HFSadd_history()\");\n    store_values (hfs_base_dir, siteid, itemid, clock, delay, values, sizeof (double), count, IT_DOUBLE);\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* Example check_service[ssh], check_service[smtp,29],check_service[ssh,127.0.0.1,22]*/\n/* check_service[ssh,127.0.0.1,ssh] */\n", "func_signal": "int\tCHECK_SERVICE_PERF(const char *cmd, const char *param, unsigned flags, AGENT_RESULT *result)", "code": "{\n\tunsigned short\tport=0;\n\tchar\tservice[MAX_STRING_LEN];\n\tchar\tip[MAX_STRING_LEN];\n\tchar\tstr_port[MAX_STRING_LEN];\n\n\tdouble\tstart_time = 0;\n\n\tint\tret\t= SYSINFO_RET_OK;\n\tint\tvalue_int;\n\n        assert(result);\n\n\tinit_result(result);\n\n\tstart_time = zbx_time();\n\n        if(num_param(param) > 3)\n        {\n                return SYSINFO_RET_FAIL;\n        }\n        \n\tif(get_param(param, 1, service, MAX_STRING_LEN) != 0)\n        {\n                return SYSINFO_RET_FAIL;\n        }\n\n\tif(get_param(param, 2, ip, MAX_STRING_LEN) != 0)\n        {\n                ip[0] = '\\0';\n        }\n\n\tif(ip[0] == '\\0')\n\t{\n\t\tstrscpy(ip, \"127.0.0.1\");\n\t}\n\n\tif(get_param(param, 3, str_port, MAX_STRING_LEN) != 0)\n        {\n                str_port[0] = '\\0';\n        }\n\t\n\tif(str_port[0] != '\\0')\n\t{\n\t\tport = atoi(str_port);\n\t}\n\telse\n\t{\n\t\tport = 0;\n\t}\n\n/*\tprintf(\"IP:[%s]\",ip);\n\tprintf(\"Service:[%s]\",service);\n\tprintf(\"Port:[%d]\",port);*/\n\n\tif(strcmp(service,\"ssh\") == 0)\n\t{\n\t\tif(port == 0)\tport=22;\n\t\tret=check_ssh(ip,port,&value_int);\n\t}\n#ifdef HAVE_LDAP\n\telse if(strcmp(service,\"ldap\") == 0)\n\t{\n\t\tif(port == 0)   port=389;\n\t\tret=check_ldap(ip,port,&value_int);\n\t}\n#endif\n\telse if(strcmp(service,\"smtp\") == 0)\n\t{\n\t\tif(port == 0)\tport=25;\n\t\tret=tcp_expect(ip,port,NULL,\"220\",\"QUIT\\n\",&value_int);\n\t}\n\telse if(strcmp(service,\"ftp\") == 0)\n\t{\n\t\tif(port == 0)\tport=21;\n\t\tret=tcp_expect(ip,port,NULL,\"220\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"http\") == 0)\n\t{\n\t\tif(port == 0)\tport=80;\n\t\tret=tcp_expect(ip,port,NULL,NULL,\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"pop\") == 0)\n\t{\n\t\tif(port == 0)\tport=110;\n\t\tret=tcp_expect(ip,port,NULL,\"+OK\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"nntp\") == 0)\n\t{\n\t\tif(port == 0)\tport=119;\n/* 220 is incorrect */\n/*\t\tret=tcp_expect(ip,port,\"220\",\"\");*/\n\t\tret=tcp_expect(ip,port,NULL,\"200\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"imap\") == 0)\n\t{\n\t\tif(port == 0)\tport=143;\n\t\tret=tcp_expect(ip,port,NULL,\"* OK\",\"a1 LOGOUT\\n\",&value_int);\n\t}\n\telse if(strcmp(service,\"tcp\") == 0)\n\t{\n\t\tif(port == 0)\tport=80;\n\t\tret=tcp_expect(ip,port,NULL,NULL,\"\",&value_int);\n\t}\n\telse\n\t{\n\t\treturn SYSINFO_RET_FAIL;\n\t}\n\n\tif(SYSINFO_RET_OK == ret)\n\t{\n\t\tif(value_int)\n\t\t{\n\t\t\tSET_DBL_RESULT(result, zbx_time() - start_time);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSET_DBL_RESULT(result, 0.0);\n\t\t}\n\t}\n\t\n\n\treturn ret;\n}", "path": "src\\libs\\zbxsysinfo\\simple\\simple.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n   Stores host availability in FS.\n */\n", "func_signal": "void HFS_update_host_availability (const char* hfs_base_dir, const char* siteid, zbx_uint64_t hostid, int available, hfs_time_t clock, const char* error)", "code": "{\n\tchar* name = get_name (hfs_base_dir, siteid, hostid, NK_HostState);\n\tint fd;\n\n\tif (!name)\n\t\treturn;\n\n\t/* open file for writing */\n\tfd = xopen (name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (fd < 0) {\n\t\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS_update_host_availability: open(): %s: %s\", name, strerror(errno));\n\t\txfree (name);\n\t\treturn;\n\t}\n\txfree (name);\n\n\tlseek (fd, (sizeof (available) + sizeof (clock))*hostid, SEEK_SET);\n\tif (write (fd, &available, sizeof (available)) == -1 ||\n\t    write (fd, &clock, sizeof (clock)) == -1)\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS_update_host_availability: write(): %s\",  strerror(errno));\n\n\tclose (fd);\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "//!!!!!!\n", "func_signal": "size_t HFSread_item (const char *hfs_base_dir, const char* siteid,\n                     int is_trend,             zbx_uint64_t itemid,\n                     size_t sizex,\n                     hfs_time_t graph_from_ts, hfs_time_t graph_to_ts,\n                     hfs_time_t from_ts,       hfs_time_t to_ts,\n                     hfs_item_value_t **result)", "code": "{\n\tvoid \t\t*val;\n\titem_value_u \t val_history;\n\thfs_trend_t  \t val_trends;\n\thfs_trend_t  \t val_temp;\n\n\thfs_time_t ts = from_ts;\n\tsize_t val_len, items = 0, result_size = 0;\n\tint finish_loop = 0;\n\tlong count = 0, cur_group, group = -1;\n\tlong z, p, x;\n\n\tint block, fd = -1;\n\tchar *p_data = NULL;\n\thfs_meta_t *meta = NULL;\n\thfs_off_t ofs;\n\thfs_meta_item_t *ip;\n\n\tchar* buffer = NULL;\n\tconst int buf_size = 1024; /* amount of items can be stored in buffer */\n\tint buf_items;             /* amount of items read from file */\n\tint i;\n\n\tp = (graph_to_ts - graph_from_ts);\n\tz = (p - graph_from_ts % p);\n\tx = (sizex - 1);\n\n\tzabbix_log(LOG_LEVEL_DEBUG,\n\t\t\"In HFSread_item(hfs_base_dir=%s, trend=%d, itemid=%lld, sizex=%d, graph_from=%lld, graph_to=%lld, from=%lld, to=%lld)\\n\",\n\t\thfs_base_dir, is_trend, itemid, x, graph_from_ts, graph_to_ts, from_ts, to_ts);\n\n\tzabbix_log(LOG_LEVEL_DEBUG,\n\t\t\"HFS: HFSread_item: Magic numbers: p=%d, z=%d, x=%d\\n\",\n\t\tp, z, x);\n\n\tif (is_trend == 0) {\n\t\tval = &val_history;\n\t\tval_len = sizeof(val_history);\n\t}\n\telse {\n\t\tval = &val_trends;\n\t\tval_len = sizeof(val_trends);\n\t}\n\n\tbuffer = (char*)malloc (buf_size * val_len);\n        if (!buffer) {\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS: memory allocation error\");\n\t\treturn 0;\n\t}\n\n\tif ((block = HFS_find_meta(hfs_base_dir, siteid, is_trend, itemid, ts, &meta)) == -1) {\n\t\tzabbix_log(LOG_LEVEL_WARNING, \"HFS: unable to find position in metafile\");\n\t\treturn 0;\n\t}\n\n\tip = meta->meta + block;\n\n\tif (graph_to_ts < ip->start) {\n\t\t/*      graph_from_ts   graph_to_ts\n\t\t   ----|---------------|----------------> Time\n\t\t                            ^ ip->start\n\t\t*/\n\t\tfree_meta(meta);\n\t\treturn 0;\n\t}\n\n\tif (ip->start > ts) {\n\t\t/*          graph_from_ts   graph_to_ts\n\t\t   --------|---------------|------------> Time\n\t\t\t^ ip->start\n\t\t*/\n\t\tts = ip->start;\n\t}\n\n\tif ((p_data = get_name (hfs_base_dir, siteid, itemid, is_trend ? NK_TrendItemData : NK_ItemData)) == NULL) {\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS: unable to get datafile\");\n\t\tfree_meta(meta);\n\t\treturn 0;\n\t}\n\n\tif ((fd = open (p_data, O_RDONLY)) == -1) {\n\t\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS: %s: file open failed: %s\", p_data, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tif ((ofs = find_meta_ofs (ts, meta, NULL)) == -1) {\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS: %s: %lld: unable to get offset in file\", p_data, ts);\n\t\tgoto out;\n\t}\n\n\tif (lseek (fd, ofs, SEEK_SET) == -1) {\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS: %s: unable to change file offset: %s\", p_data, strerror(errno));\n\t\tgoto out;\n\t}\n\n\twhile ((buf_items = read (fd, buffer, buf_size * val_len)) > 0) {\n\t\tbuf_items /= val_len;\n\n\t\tfor (i = 0; i < buf_items; i++) {\n\t\t\tval = buffer + i * val_len;\n\n\t\t\tcur_group = (long) (x * ((ts + z) % p) / p);\n\t\t\tif (group == -1)\n\t\t\t\tgroup = cur_group;\n\n\t\t\tts += ip->delay;\n\n\t\t\tif (!is_valid_val(val, val_len))\n\t\t\t\tcontinue;\n\n\t\t\tif (result_size <= items) {\n\t\t\t\tresult_size += alloc_item_values;\n\t\t\t\t*result = (hfs_item_value_t *) realloc(*result, (sizeof(hfs_item_value_t) * result_size));\n\t\t\t\tHFS_init_trend_value(is_trend, ip->type, val, &((*result)[items].value));\n\t\t\t}\n\n\t\t\tif (group != cur_group) {\n\t\t\t\t(*result)[items].type  = ip->type;\n\t\t\t\t(*result)[items].group = cur_group;\n\t\t\t\t(*result)[items].count = count;\n\t\t\t\t(*result)[items].clock = ts;\n\n\t\t\t\tgroup = cur_group;\n\t\t\t\tcount = 0;\n\t\t\t\titems++;\n\n\t\t\t\tif (result_size <= items) {\n\t\t\t\t\tresult_size += alloc_item_values;\n\t\t\t\t\t*result = (hfs_item_value_t *) realloc(*result, (sizeof(hfs_item_value_t) * result_size));\n\t\t\t\t}\n\n\t\t\t\tHFS_init_trend_value(is_trend, ip->type, val, &((*result)[items].value));\n\t\t\t}\n\n\t\t\tif (count > 0) {\n\t\t\t\tHFS_init_trend_value(is_trend, ip->type, val, &val_temp);\n\t\t\t\trecalculate_trend(&val_temp,\n\t\t\t\t\t\t  (*result)[items].value,\n\t\t\t\t\t\t  ip->type);\n\t\t\t\t(*result)[items].value = val_temp;\n\t\t\t}\n\n\t\t\tif (ts >= to_ts)\n\t\t\t\tgoto out;\n\n\t\t\tif (ts >= ip->end) {\n\t\t\t\tblock++;\n\n\t\t\t\tif (block >= meta->blocks)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tip = meta->meta + block;\n\t\t\t}\n\n\t\t\tcount++;\n\t\t}\n\t}\n\nout:\n\tfree_meta (meta);\n\txfree(p_data);\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\tif (result_size > items)\n\t\t*result = (hfs_item_value_t *) realloc(*result, (sizeof(hfs_item_value_t) * items));\n\tif (buffer)\n\t\tfree (buffer);\n\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS: HFSread_item: Out items=%d\\n\", items);\n\n\treturn items;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* \n *  0- NOT OK\n *  1 - OK\n * */\n", "func_signal": "static int\tcheck_ssh(const char *host, unsigned short port, int *value_int)", "code": "{\n\tint ret;\n\n\tzbx_sock_t\ts;\n\n\tchar\t\n\t\tsend_buf[MAX_BUF_LEN],\n\t\t*recv_buf,\n\t\t*ssh_server, \n\t\t*ssh_proto;\n\n\tassert(value_int);\n\n\t*value_int = 0;\n\tif (SUCCEED == (ret = zbx_tcp_connect(&s, host, port, 0, NULL))) {\n\t\tif( SUCCEED == (ret = zbx_tcp_recv(&s, &recv_buf)) )\n\t\t{\n\t\t\tif ( 0 == strncmp(recv_buf, \"SSH\", 3) )\n\t\t\t{\n\t\t\t\tssh_server = ssh_proto = recv_buf + 4;\n\t\t\t\tssh_server += strspn (ssh_proto, \"0123456789-. \") ;\n\t\t\t\tssh_server[-1] = '\\0';\n\n\t\t\t\tzbx_snprintf(send_buf,sizeof(send_buf),\"SSH-%s-%s\\n\", ssh_proto, \"zabbix_agent\");\n\t\t\t\t*value_int = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzbx_snprintf(send_buf,sizeof(send_buf),\"0\\n\");\n\t\t\t}\n\t\t\tret = zbx_tcp_send_raw(&s, send_buf);\n\t\t}\n\t}\n\tzbx_tcp_close(&s);\n\n\tif( FAIL == ret )\n\t{\n\t\tzabbix_log(LOG_LEVEL_DEBUG, \"SSH check error: %s\", zbx_tcp_strerror());\n\t}\n\n\treturn\tSYSINFO_RET_OK;\n}", "path": "src\\libs\\zbxsysinfo\\simple\\simple.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n  Routine adds uint64 value to HistoryFS storage.\n*/\n", "func_signal": "void HFSadd_history_uint (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, unsigned int delay, zbx_uint64_t value, hfs_time_t clock)", "code": "{\n    zabbix_log(LOG_LEVEL_DEBUG, \"In HFSadd_history_uint()\");   \n    store_values (hfs_base_dir, siteid, itemid, clock, delay, &value, sizeof (zbx_uint64_t), 1, IT_UINT64);\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* _WINDOWS */\n", "func_signal": "static\tchar\t*zbx_regexp(const char *string, const char *pattern, int *len, int flags)", "code": "{ \n\tchar\t*c = NULL;\n\n\tregex_t\tre;\n\tregmatch_t match;\n\n\tif(len) *len = 0;\n\n\tif( string && string[0] )\n\t{\n\t\tif ( 0 == regcomp(&re, pattern, flags) )\n\t\t{\n\t\t\tif( 0 == regexec(&re, string, (size_t) 1, &match, 0) )\n\t\t\t{ /* Matched */\n\t\t\t\tc=(char *)string+match.rm_so;\n\t\t\t\tif(len) *len = match.rm_eo - match.rm_so;\n\t\t\t\n\t\t\t}\n\n\t\t\tregfree(&re);\n\t\t}\n\t}\n\treturn\tc;\n}", "path": "src\\libs\\zbxcommon\\regexp.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* Obtain host attributes stored in HFS. If successfull, return 1. If something goes wrong, return 0. */\n", "func_signal": "int HFS_get_host_availability (const char* hfs_base_dir, const char* siteid, zbx_uint64_t hostid, int* available, hfs_time_t* clock, char** error)", "code": "{\n\tchar* name = get_name (hfs_base_dir, siteid, hostid, NK_HostState);\n\tint fd;\n\n\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS_get_host_availability entered\");\n\n\tif (!name)\n\t\treturn 0;\n\n\t/* open file for reading */\n\tfd = open (name, O_RDONLY);\n\n\tif (fd < 0) {\n\t\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS_get_host_availability: open(): %s: %s\", name, strerror(errno));\n\t\tfree (name);\n\t\treturn 0;\n\t}\n\tfree (name);\n\t\n\t/* reading data */\n\tlseek (fd, (sizeof (*available) + sizeof (*clock))*hostid, SEEK_SET);\n\tif (read (fd, available, sizeof (*available)) == -1 ||\n\t    read (fd, clock, sizeof (*clock)) == -1)\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS_get_host_availability: read(): %s\", strerror(errno));\n\t*error = NULL;\n\n\t/* release read lock */\n\tif (close (fd) == -1)\n\t\tzabbix_log(LOG_LEVEL_CRIT, \"HFS_get_host_availability: close(): %s\", strerror(errno));\n\n\tzabbix_log(LOG_LEVEL_DEBUG, \"HFS_get_host_availability leave\");\n\treturn 1;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* serialize metafile */\n/* Write metafile. If extra argument passed, it also will be\n   written. Warning! If extra is not NULL, meta->blocks must be\n   already incremented.  */\n", "func_signal": "char* buffer_metafile (hfs_meta_t* meta, hfs_meta_item_t* extra, int* length)", "code": "{\n\tint len, i;\n\tchar* buf = NULL, *p;\n\n\tlen = sizeof (hfs_meta_t) - sizeof (meta->meta) - sizeof (hfs_time_t) + meta->blocks * sizeof (hfs_meta_item_t);\n\tbuf = (unsigned char*)malloc (len);\n\n\tif (!buf)\n\t\treturn NULL;\n\n\t*length = len;\n\n\tmemcpy (buf, meta, sizeof (hfs_meta_t) - sizeof (meta->meta) - sizeof (hfs_time_t));\n\tp = buf + sizeof (hfs_meta_t) - sizeof (meta->meta) - sizeof (hfs_time_t);\n\n\tfor (i = 0; i < meta->blocks - (extra ? 1 : 0); i++) {\n\t\tmemcpy (p, meta->meta+i, sizeof (hfs_meta_item_t));\n\t\tp += sizeof (hfs_meta_item_t);\n\t}\n\n\tif (extra)\n\t\tmemcpy (p, extra, sizeof (hfs_meta_item_t));\n\n\treturn buf;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n  Performs folding of values of historical data into some state. We filter values according to count of values.\n*/\n", "func_signal": "void foldl_count (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, hfs_time_t count, void* init_res, fold_fn_t fn)", "code": "{\n    char *p_data;\n    int fd;\n    hfs_time_t ts = time (NULL)-1;\n    zbx_uint64_t value;\n    hfs_off_t ofs;\n\n    zabbix_log(LOG_LEVEL_DEBUG, \"HFS_foldl_count (%s, %llu, %lld)\", hfs_base_dir, itemid, count);\n\n    p_data = get_name (hfs_base_dir, siteid, itemid, NK_ItemData);\n    fd = open (p_data, O_RDONLY);\n    free (p_data);\n\n    if (fd < 0)\n        return;\n\n    ofs = lseek (fd, 0, SEEK_END);\n\n    while (ofs && count > 0) {\n        ofs = lseek (fd, ofs - sizeof (double), SEEK_SET);\n        read (fd, &value, sizeof (value));\n        if (is_valid_val (&value, sizeof (value))) {\n\t    fn (&value, init_res);\n\t    count--;\n\t}\n    }\n\n/*     release_lock (fd, 0); */\n    close (fd);\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* trying to convert string value to apropriate value */\n", "func_signal": "int HFS_convert_function_str2val (const char* value, hfs_function_value_t* result)", "code": "{\n\tint dig = 0, dots = 0, sign = 0, space = 0, other = 0;\n\tconst char* p = value;\n\n\t/* empty value */\n\tif (!value || !value[0]) {\n\t\tresult->type = FVT_NULL;\n\t\tresult->value.d = 0;\n\t\treturn 1;\n\t}\n\n\twhile (*p) {\n\t\tif (isspace (*p))\n\t\t\tspace++;\n\t\telse if (isdigit (*p))\n\t\t\tdig++;\n\t\telse if (*p == '.')\n\t\t\tdots++;\n\t\telse if (*p == '+' || *p == '-')\n\t\t\tsign++;\n\t\telse\n\t\t\tother++;\n\t\tp++;\n\t}\n\n\t/* this is an integer value */\n\tif (!dots && !sign && !other) {\n\t\tresult->type = FVT_UINT64;\n\t\tZBX_STR2UINT64 (result->value.l, value);\n\t\treturn 1;\n\t}\n\n\tif (!other) {\n\t\tresult->type = FVT_DOUBLE;\n\t\tresult->value.d = atof (value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*------------------------------------------------------------------------\n *\n * Function\t:  str_base64_encode\n *\n * Purpose\t:  Encode a string into a base64 string\n *\n * Parameters\t:  p_str (in)\t\t- the string to encode\n *\t\t   p_b64str (out)\t- the encoded str to return\n *\t\t   in_size (in)\t\t- size (length) of input str\n * Returns\t:  \n *\n * Comments\t:\n *\n *----------------------------------------------------------------------*/\n", "func_signal": "void str_base64_encode(const char *p_str, char *p_b64str, int in_size)", "code": "{\n\tint \ti;\n\tunsigned char from1=0,from2=0,from3=0;\n\tunsigned char to1=0,to2=0,to3=0,to4=0;\n\n\tif ( 0 == in_size )\n\t{\n\t\treturn;\n\t};\n\n\tassert(p_str);\n\tassert(p_b64str);\n\n\tfor ( i = 0; i < in_size ; i += 3 )\n\t{\n\t\tfrom1 = from2 = from3 = 0;\n\t\tfrom1 = p_str[i];\n\t\tif (i+1 < in_size)\n\t\t{\n\t\t\tfrom2 = p_str[i+1];\n\t\t}\n\t\tif (i+2 < in_size)\n\t\t{\n\t\t\tfrom3 = p_str[i+2];\n\t\t}\n\n\t\tto1 = to2 = to3 = to4 = 0;\n\t\tto1 = (from1>>2) & 0x3f;\n\t\tto2 = ((from1&0x3)<<4)|(from2>>4);\n\t\tto3 = ((from2&0xf)<<2)|(from3>>6);\n\t\tto4 = from3&0x3f;\n\n\t\t*(p_b64str++) = char_base64_encode(to1);\n\t\t*(p_b64str++) = char_base64_encode(to2);\n\n\t\tif (i+1 < in_size)\n\t\t{\n\t\t\t*(p_b64str++) = char_base64_encode(to3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*(p_b64str++) = '=';\t/* Padding */\n\t\t}\n\t\tif (i+2 < in_size)\n\t\t{\n\t\t\t*(p_b64str++) = char_base64_encode(to4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*(p_b64str++) = '=';\t/* Padding */\n\t\t};\n\n/*\t\tif ( i % (76/4*3) == 0)\n\t\t{\n\t\t\t*(p_b64str++) = '\\r';\n\t\t\t*(p_b64str++) = '\\n';\n\t\t}*/\n\t};\n\t\n\t*p_b64str = '\\0';\n\treturn;\n}", "path": "src\\libs\\zbxcrypto\\base64.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* Example check_service[ssh], check_service[smtp,29],check_service[ssh,127.0.0.1,22]*/\n/* check_service[ssh,127.0.0.1,ssh] */\n", "func_signal": "int\tCHECK_SERVICE(const char *cmd, const char *param, unsigned flags, AGENT_RESULT *result)", "code": "{\n\tunsigned short\tport=0;\n\tchar\tservice[MAX_STRING_LEN];\n\tchar\tip[MAX_STRING_LEN];\n\tchar\tstr_port[MAX_STRING_LEN];\n\n\tint\tret;\n\tint\tvalue_int = 0;\n\n        assert(result);\n\n        init_result(result);\n\t\n        if(num_param(param) > 3)\n        {\n                return SYSINFO_RET_FAIL;\n        }\n        \n\tif(get_param(param, 1, service, MAX_STRING_LEN) != 0)\n        {\n                return SYSINFO_RET_FAIL;\n        }\n\n\tif(get_param(param, 2, ip, MAX_STRING_LEN) != 0)\n        {\n                ip[0] = '\\0';\n        }\n\n\tif(ip[0] == '\\0')\n\t{\n\t\tstrscpy(ip, \"127.0.0.1\");\n\t}\n\n\tif(get_param(param, 3, str_port, MAX_STRING_LEN) != 0)\n        {\n                str_port[0] = '\\0';\n        }\n\t\n\tif(str_port[0] != '\\0')\n\t{\n\t\tport = atoi(str_port);\n\t}\n\telse\n\t{\n\t\tport = 0;\n\t}\n\n/*\tprintf(\"IP:[%s]\",ip);\n\tprintf(\"Service:[%s]\",service);\n\tprintf(\"Port:[%d]\",port);*/\n\n\tif(strcmp(service,\"ssh\") == 0)\n\t{\n\t\tif(port == 0)\tport=22;\n\t\tret=check_ssh(ip,port,&value_int);\n\t}\n\telse if(strcmp(service,\"service.ntp\") == 0)\n\t{\n\t\tif(port == 0)\tport=123;\n\t\tret=check_ntp(ip,port,&value_int);\n\t}\n#ifdef HAVE_LDAP\n\telse if(strcmp(service,\"ldap\") == 0)\n\t{\n\t\tif(port == 0)   port=389;\n\t\tret=check_ldap(ip,port,&value_int);\n\t}\n#endif\n\telse if(strcmp(service,\"smtp\") == 0)\n\t{\n\t\tif(port == 0)\tport=25;\n\t\tret=tcp_expect(ip,port,NULL,\"220\",\"QUIT\\n\",&value_int);\n\t}\n\telse if(strcmp(service,\"ftp\") == 0)\n\t{\n\t\tif(port == 0)\tport=21;\n\t\tret=tcp_expect(ip,port,NULL,\"220\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"http\") == 0)\n\t{\n\t\tif(port == 0)\tport=80;\n\t\tret=tcp_expect(ip,port,NULL,NULL,\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"pop\") == 0)\n\t{\n\t\tif(port == 0)\tport=110;\n\t\tret=tcp_expect(ip,port,NULL,\"+OK\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"nntp\") == 0)\n\t{\n\t\tif(port == 0)\tport=119;\n/* 220 is incorrect */\n/*\t\tret=tcp_expect(ip,port,\"220\",\"\");*/\n\t\tret=tcp_expect(ip,port,NULL,\"200\",\"\",&value_int);\n\t}\n\telse if(strcmp(service,\"imap\") == 0)\n\t{\n\t\tif(port == 0)\tport=143;\n\t\tret=tcp_expect(ip,port,NULL,\"* OK\",\"a1 LOGOUT\\n\",&value_int);\n\t}\n\telse if(strcmp(service,\"tcp\") == 0)\n\t{\n\t\tif(port == 0)\tport=80;\n\t\tret=tcp_expect(ip,port,NULL,NULL,\"\",&value_int);\n\t}\n\telse\n\t{\n\t\treturn SYSINFO_RET_FAIL;\n\t}\n\n\tif(SYSINFO_RET_OK == ret)\n\t{\n\t\tSET_UI64_RESULT(result, value_int);\n\t}\n\n\treturn ret;\n}", "path": "src\\libs\\zbxsysinfo\\simple\\simple.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/*\n   fcntl wrappers\n */\n", "func_signal": "int obtain_lock (int fd, int write)", "code": "{\n\tstruct flock fls;\n\n\tfls.l_type = write ? F_WRLCK : F_RDLCK;\n\tfls.l_whence = SEEK_SET;\n\tfls.l_start = 0;\n\tfls.l_len = 0;\n\n\twhile (1) {\n\t\tif (fcntl (fd, write ? F_SETLKW : F_SETLK, &fls) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tzabbix_log(LOG_LEVEL_ERR, \"HFS_obtain_lock: fcntl(): %s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/* routine appends string to item's  string table */\n", "func_signal": "void HFSadd_history_str (const char* hfs_base_dir, const char* siteid, zbx_uint64_t itemid, hfs_time_t clock, const char* value)", "code": "{\n\tint len = 0, buf_len, fd;\n\tchar* p_name = get_name (hfs_base_dir, siteid, itemid, NK_ItemString);\n\tchar *buf, *p;\n\n\tif (value)\n\t\tlen = strlen (value);\n\n\tif ((fd = xopen (p_name, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1) {\n\t\tzabbix_log (LOG_LEVEL_DEBUG, \"Canot open file %s\", p_name);\n\t\tfree (p_name);\n\t\treturn;\n\t}\n\n\tlseek (fd, 0, SEEK_END);\n\tfree (p_name);\n\n\tbuf_len = sizeof (clock) + str_buffer_length (value) + sizeof (len);\n\tbuf = (char*)malloc (buf_len);\n\n\t*(hfs_time_t*)buf = clock;\n\tp = buffer_str (buf+sizeof (clock), value, buf_len - sizeof (clock));\n\tif (!p) {\n\t\tfree (buf);\n\t\tclose (fd);\n\t\treturn;\n\t}\n\t\n\t*(int*)p = len;\n\twrite (fd, buf, buf_len);\n\tfree (buf);\n\tclose (fd);\n\treturn;\n}", "path": "src\\libs\\zbxdbhigh\\hfs.c", "repo_name": "Shmuma/z", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 8740}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tAddIconManager - add a window to an icon manager\n *\n *  Inputs:\n *\ttmp_win\t- the TwmWindow structure\n *\n ***********************************************************************\n */\n", "func_signal": "WList *\nAddIconManager(TwmWindow * tmp_win)", "code": "{\n  WList *tmp;\n  int h;\n  unsigned long valuemask;\t/* mask for create windows */\n  XSetWindowAttributes attributes;\t/* attributes for create windows */\n  IconMgr *ip;\n\n  tmp_win->list = NULL;\n\n  if (Scr->StrictIconManager)\n  {\n    if (tmp_win->icon || (!tmp_win->iconified &&\n\t\t\t  (tmp_win->wmhints &&\n\t\t\t   (tmp_win->wmhints->flags & StateHint) && tmp_win->wmhints->initial_state == IconicState)))\n      ;\n    else\n      return NULL;\n  }\n\n  if (tmp_win->iconmgr || tmp_win->transient || Scr->NoIconManagers)\n    return NULL;\n\n  if (LookInList(Scr->IconMgrNoShow, tmp_win->full_name, &tmp_win->class))\n    return NULL;\n  if (Scr->IconManagerDontShow && !LookInList(Scr->IconMgrShow, tmp_win->full_name, &tmp_win->class))\n    return NULL;\n  if ((ip = (IconMgr *) LookInList(Scr->IconMgrs, tmp_win->full_name, &tmp_win->class)) == NULL)\n    ip = &Scr->iconmgr;\n\n  tmp = (WList *) malloc(sizeof(WList));\n  tmp->iconmgr = ip;\n  tmp->next = NULL;\n  tmp->active = FALSE;\n  tmp->down = FALSE;\n\n  InsertInIconManager(ip, tmp, tmp_win);\n\n  tmp->twm = tmp_win;\n\n  tmp->cp.fore = Scr->IconManagerC.fore;\n  tmp->cp.back = Scr->IconManagerC.back;\n\n  tmp->highlight = Scr->IconManagerHighlight;\n\n  GetColorFromList(Scr->IconManagerFL, tmp_win->full_name, &tmp_win->class, &tmp->cp.fore);\n  GetColorFromList(Scr->IconManagerBL, tmp_win->full_name, &tmp_win->class, &tmp->cp.back);\n\n  GetColorFromList(Scr->IconManagerHighlightL, tmp_win->full_name, &tmp_win->class, &tmp->highlight);\n\n  if (!Scr->BeNiceToColormap)\n    GetShadeColors(&tmp->cp);\n  tmp->iconifypm = GetImage(Scr->iconMgrIconName, iconifybox_width, iconifybox_height, 0, tmp->cp);\n\n  h = ComputeIconMgrWindowHeight(ip);\n\n  ip->height = h * ip->count;\n  tmp->me = ip->count;\n  tmp->x = -1;\n  tmp->y = -1;\n\n  valuemask = (CWBackPixel | CWBorderPixel | CWEventMask | CWCursor);\n\n  attributes.background_pixel = tmp->cp.back;\n  attributes.border_pixel = tmp->cp.back;\n\n  attributes.event_mask = (KeyPressMask | ButtonPressMask | ButtonReleaseMask | ExposureMask | EnterWindowMask | LeaveWindowMask);\n  attributes.cursor = Scr->IconMgrCursor;\n\n  if (Scr->BackingStore)\n  {\n    attributes.backing_store = WhenMapped;\n    valuemask |= CWBackingStore;\n  }\n\n  tmp->w.win = XCreateWindow(dpy, ip->w, 0, 0, (unsigned int)1,\n\t\t\t     (unsigned int)h, (unsigned int)0,\n\t\t\t     CopyFromParent, (unsigned int)CopyFromParent, (Visual *) CopyFromParent, valuemask, &attributes);\n\n#ifdef TWM_USE_XFT\n  if (Scr->use_xft > 0)\n  {\n    tmp->w.xft = MyXftDrawCreate(tmp->w.win);\n    CopyPixelToXftColor(tmp->cp.fore, &tmp->cp.xft);\n  }\n#endif\n\n  valuemask = (CWBackPixel | CWBorderPixel | CWEventMask | CWCursor);\n\n  attributes.background_pixel = tmp->cp.back;\n\n  attributes.border_pixel = Scr->Black;\n  attributes.event_mask = (ButtonReleaseMask | ButtonPressMask | ExposureMask);\n  attributes.cursor = Scr->ButtonCursor;\n\n  if (!iconmgr_iconx)\n  {\n\n    if (Scr->IconMgrBevelWidth > 0)\n      iconmgr_iconx = Scr->IconMgrBevelWidth + 5;\n    else\n      iconmgr_iconx = Scr->BorderWidth + 5;\n    iconmgr_textx = iconmgr_iconx + xiconify_width + 5;\n  }\n\n  tmp->icon = XCreateWindow(dpy, tmp->w.win, iconmgr_iconx, (int)(h - xiconify_height) / 2,\n\t\t\t    (unsigned int)xiconify_width,\n\t\t\t    (unsigned int)xiconify_height,\n\t\t\t    (unsigned int)0, CopyFromParent,\n\t\t\t    (unsigned int)CopyFromParent, (Visual *) CopyFromParent, valuemask, &attributes);\n\n  ip->count += 1;\n  PackIconManager(ip);\n  XMapWindow(dpy, tmp->w.win);\n\n  XSaveContext(dpy, tmp->w.win, IconManagerContext, (caddr_t) tmp);\n  XSaveContext(dpy, tmp->w.win, TwmContext, (caddr_t) tmp_win);\n  XSaveContext(dpy, tmp->w.win, ScreenContext, (caddr_t) Scr);\n  XSaveContext(dpy, tmp->icon, TwmContext, (caddr_t) tmp_win);\n  XSaveContext(dpy, tmp->icon, ScreenContext, (caddr_t) Scr);\n  tmp_win->list = tmp;\n\n  if (!ip->twm_win->icon)\n  {\n    XMapWindow(dpy, ip->w);\n    XMapWindow(dpy, ip->twm_win->frame);\n  }\n\n  else\n    XMapWindow(dpy, ip->twm_win->icon_w.win);\n\n  return (tmp);\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      DoResize - move the rubberband around.  This is called for\n *                 each motion event when we are resizing\n *\n *  Inputs:\n *      x_root  - the X corrdinate in the root window\n *      y_root  - the Y corrdinate in the root window\n *      tmp_win - the current twm window\n *\n ***********************************************************************\n */\n", "func_signal": "void\nDoResize(int x_root, int y_root, TwmWindow * tmp_win)", "code": "{\n  int action;\n\n  action = 0;\n\n  x_root -= clampDX;\n  y_root -= clampDY;\n\n  if (clampTop)\n  {\n    int delta = y_root - dragy;\n\n    if (dragHeight - delta < MINHEIGHT)\n    {\n      delta = dragHeight - MINHEIGHT;\n      clampTop = 0;\n    }\n    dragy += delta;\n    dragHeight -= delta;\n    action = 1;\n  }\n  else if (y_root <= dragy)\n  {\n    dragy = y_root;\n    dragHeight = origy + origHeight - y_root;\n    clampBottom = 0;\n    clampTop = 1;\n    clampDY = 0;\n    action = 1;\n  }\n  if (clampLeft)\n  {\n    int delta = x_root - dragx;\n\n    if (dragWidth - delta < MINWIDTH)\n    {\n      delta = dragWidth - MINWIDTH;\n      clampLeft = 0;\n    }\n    dragx += delta;\n    dragWidth -= delta;\n    action = 1;\n  }\n  else if (x_root <= dragx)\n  {\n    dragx = x_root;\n    dragWidth = origx + origWidth - x_root;\n    clampRight = 0;\n    clampLeft = 1;\n    clampDX = 0;\n    action = 1;\n  }\n  if (clampBottom)\n  {\n    int delta = y_root - dragy - dragHeight;\n\n    if (dragHeight + delta < MINHEIGHT)\n    {\n      delta = MINHEIGHT - dragHeight;\n      clampBottom = 0;\n    }\n    dragHeight += delta;\n    action = 1;\n  }\n  else if (y_root >= dragy + dragHeight - 1)\n  {\n    dragy = origy;\n    dragHeight = 1 + y_root - dragy;\n    clampTop = 0;\n    clampBottom = 1;\n    clampDY = 0;\n    action = 1;\n  }\n  if (clampRight)\n  {\n    int delta = x_root - dragx - dragWidth;\n\n    if (dragWidth + delta < MINWIDTH)\n    {\n      delta = MINWIDTH - dragWidth;\n      clampRight = 0;\n    }\n    dragWidth += delta;\n    action = 1;\n  }\n  else if (x_root >= dragx + dragWidth - 1)\n  {\n    dragx = origx;\n    dragWidth = 1 + x_root - origx;\n    clampLeft = 0;\n    clampRight = 1;\n    clampDX = 0;\n    action = 1;\n  }\n\n  if (action)\n  {\n    ConstrainSize(tmp_win, &dragWidth, &dragHeight);\n    if (clampLeft)\n      dragx = origx + origWidth - dragWidth;\n    if (clampTop)\n      dragy = origy + origHeight - dragHeight;\n\n    if (tmp_win->opaque_resize)\n    {\n      SetupWindow(tmp_win, dragx - tmp_win->frame_bw, dragy - tmp_win->frame_bw, dragWidth, dragHeight, -1);\n\n      /* force the redraw of a door - djhjr - 2/28/99 */\n      {\n\tTwmDoor *door;\n\n\tif (XFindContext(dpy, tmp_win->w, DoorContext, (caddr_t *) & door) != XCNOENT)\n\t  RedoDoorName(tmp_win, door);\n      }\n\n      /* force the redraw of the desktop - djhjr - 2/28/99 */\n      if (!strcmp(tmp_win->class.res_class, VTWM_DESKTOP_CLASS))\n      {\n\tResizeDesktopDisplay(dragWidth, dragHeight);\n\n\tDraw3DBorder(Scr->VirtualDesktopDisplayOuter, 0, 0,\n\t\t     Scr->VirtualDesktopMaxWidth + (Scr->VirtualDesktopBevelWidth * 2),\n\t\t     Scr->VirtualDesktopMaxHeight + (Scr->VirtualDesktopBevelWidth * 2),\n\t\t     Scr->VirtualDesktopBevelWidth, Scr->VirtualC, off, False, False);\n      }\n\n      /* force the redraw of an icon manager - djhjr - 3/1/99 */\n      if (tmp_win->iconmgr)\n      {\n\tstruct WList *list;\n\tint ncols = tmp_win->iconmgrp->cur_columns;\n\n\tif (ncols == 0)\n\t  ncols = 1;\n\n\ttmp_win->iconmgrp->width = (int)(((dragWidth - 2 * tmp_win->frame_bw3D) * (long)tmp_win->iconmgrp->columns) / ncols);\n\tPackIconManager(tmp_win->iconmgrp);\n\n\tlist = tmp_win->iconmgrp->first;\n\twhile (list)\n\t{\n\t  RedoListWindow(list->twm);\n\t  list = list->next;\n\t}\n      }\n\n      PaintBorderAndTitlebar(tmp_win);\n\n      if (!Scr->NoGrabServer && !resizing_window)\n      {\n\t/* these let the application window be drawn - djhjr - 4/14/98 */\n\tXUngrabServer(dpy);\n\tXSync(dpy, 0);\n\tXGrabServer(dpy);\n      }\n    }\n    else\n      MoveOutline(Scr->Root,\n\t\t  dragx - tmp_win->frame_bw,\n\t\t  dragy - tmp_win->frame_bw,\n\t\t  dragWidth + 2 * tmp_win->frame_bw,\n\t\t  dragHeight + 2 * tmp_win->frame_bw, tmp_win->frame_bw, tmp_win->title_height + tmp_win->frame_bw3D);\n\n    if (Scr->VirtualReceivesMotionEvents)\n      DoVirtualMoveResize(tmp_win, dragx, dragy, dragWidth, dragHeight);\n  }\n\n  DisplaySize(tmp_win, dragWidth, dragHeight);\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tMoveIconManager - move the pointer around in an icon manager\n *\n *  Inputs:\n *\tdir\t- one of the following:\n *\t\t\tF_FORWICONMGR\t- forward in the window list\n *\t\t\tF_BACKICONMGR\t- backward in the window list\n *\t\t\tF_UPICONMGR\t- up one row\n *\t\t\tF_DOWNICONMGR\t- down one row\n *\t\t\tF_LEFTICONMGR\t- left one column\n *\t\t\tF_RIGHTICONMGR\t- right one column\n *\n *  Special Considerations:\n *\tnone\n *\n ***********************************************************************\n */\n", "func_signal": "void\nMoveIconManager(int dir)", "code": "{\n  IconMgr *ip;\n  WList *tmp = NULL;\n  int cur_row, cur_col, new_row, new_col;\n  int row_inc, col_inc;\n  int got_it;\n\n  if (!Active)\n    return;\n\n  cur_row = Active->row;\n  cur_col = Active->col;\n  ip = Active->iconmgr;\n\n  row_inc = 0;\n  col_inc = 0;\n  got_it = FALSE;\n\n  switch (dir)\n  {\n  case F_FORWICONMGR:\n    if ((tmp = Active->next) == NULL)\n      tmp = ip->first;\n    got_it = TRUE;\n    break;\n\n  case F_BACKICONMGR:\n    if ((tmp = Active->prev) == NULL)\n      tmp = ip->last;\n    got_it = TRUE;\n    break;\n\n  case F_UPICONMGR:\n    row_inc = -1;\n    break;\n\n  case F_DOWNICONMGR:\n    row_inc = 1;\n    break;\n\n  case F_LEFTICONMGR:\n    col_inc = -1;\n    break;\n\n  case F_RIGHTICONMGR:\n    col_inc = 1;\n    break;\n  }\n\n  /* If got_it is FALSE ast this point then we got a left, right,\n   * up, or down, command.  We will enter this loop until we find\n   * a window to warp to.\n   */\n  new_row = cur_row;\n  new_col = cur_col;\n\n  while (!got_it)\n  {\n    new_row += row_inc;\n    new_col += col_inc;\n    if (new_row < 0)\n      new_row = ip->cur_rows - 1;\n    if (new_col < 0)\n      new_col = ip->cur_columns - 1;\n    if (new_row >= ip->cur_rows)\n      new_row = 0;\n    if (new_col >= ip->cur_columns)\n      new_col = 0;\n\n    /* Now let's go through the list to see if there is an entry with this\n     * new position\n     */\n    for (tmp = ip->first; tmp != NULL; tmp = tmp->next)\n    {\n      if (tmp->row == new_row && tmp->col == new_col)\n      {\n\tgot_it = TRUE;\n\tbreak;\n      }\n    }\n  }\n\n  if (!got_it)\n  {\n    fprintf(stderr, \"%s:  unable to find window (%d, %d) in icon manager\\n\", ProgramName, new_row, new_col);\n    return;\n  }\n\n  if (tmp == NULL)\n    return;\n\n  /* raise the frame so the icon manager is visible */\n  if (ip->twm_win->mapped)\n  {\n    XRaiseWindow(dpy, ip->twm_win->frame);\n\n    WarpInIconMgr(tmp, ip->twm_win);\n  }\n  else\n  {\n    RaiseStickyAbove();\n    RaiseAutoPan();\n\n    WarpToWindow(tmp->twm);\n  }\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tPackIconManager - pack the icon manager windows following\n *\t\tan addition or deletion\n *\n *  Inputs:\n *\tip\t- a pointer to the icon manager struture\n *\n ***********************************************************************\n */\n", "func_signal": "void\nPackIconManager(IconMgr * ip)", "code": "{\n  int newwidth, i, row, col, maxcol, colinc, rowinc, wheight, wwidth;\n  int new_x, new_y;\n  int savewidth;\n  WList *tmp;\n\n  wheight = ComputeIconMgrWindowHeight(ip);\n\n  wwidth = ip->width / ip->columns;\n\n  rowinc = wheight;\n  colinc = wwidth;\n\n  row = 0;\n  col = ip->columns;\n  maxcol = 0;\n  for (i = 0, tmp = ip->first; tmp != NULL; i++, tmp = tmp->next)\n  {\n    tmp->me = i;\n    if (++col >= ip->columns)\n    {\n      col = 0;\n      row += 1;\n    }\n    if (col > maxcol)\n      maxcol = col;\n\n    new_x = col * colinc;\n    new_y = (row - 1) * rowinc;\n\n    /* if the position or size has not changed, don't touch it */\n    if (tmp->x != new_x || tmp->y != new_y || tmp->width != wwidth || tmp->height != wheight)\n    {\n      XMoveResizeWindow(dpy, tmp->w.win, new_x, new_y, wwidth, wheight);\n\n      tmp->row = row - 1;\n      tmp->col = col;\n      tmp->x = new_x;\n      tmp->y = new_y;\n      tmp->width = wwidth;\n      tmp->height = wheight;\n    }\n  }\n  maxcol += 1;\n\n  ip->cur_rows = row;\n  ip->cur_columns = maxcol;\n  ip->height = row * rowinc;\n  if (ip->height == 0)\n    ip->height = rowinc;\n  newwidth = maxcol * colinc;\n  if (newwidth == 0)\n    newwidth = colinc;\n\n  XResizeWindow(dpy, ip->w, newwidth, ip->height);\n\n  savewidth = ip->width;\n  if (ip->twm_win)\n  {\n\n    /* limit the min and max sizes of an icon manager - djhjr - 3/1/99 */\n    ip->twm_win->hints.flags |= (PMinSize | PMaxSize);\n    ip->twm_win->hints.min_width = maxcol * (2 * iconmgr_iconx + xiconify_width);\n    ip->twm_win->hints.min_height = ip->height;\n    ip->twm_win->hints.max_width = Scr->MyDisplayWidth;\n    ip->twm_win->hints.max_height = ip->height;\n\n    SetupWindow(ip->twm_win,\n\t\tip->twm_win->frame_x, ip->twm_win->frame_y,\n\t\tnewwidth + 2 * ip->twm_win->frame_bw3D, ip->height + ip->twm_win->title_height + 2 * ip->twm_win->frame_bw3D, -1);\n  }\n\n  ip->width = savewidth;\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/*\n * rename a door from cut buffer 0\n *\n * adapted from VTWM-5.2b - djhjr - 4/20/98\n */\n", "func_signal": "void\ndoor_paste_name(Window w, TwmDoor * d)", "code": "{\n  int width, height, count;\n  char *ptr;\n  int bw = 0;\n\n  if (Scr->BorderBevelWidth)\n    bw = Scr->BorderWidth;\n\n  if (!d)\n    if (XFindContext(dpy, w, DoorContext, (caddr_t *) & d) == XCNOENT)\n      return;\n\n  if (!(ptr = XFetchBytes(dpy, &count)) || count == 0)\n    return;\n  if (count > 128)\n    count = 128;\n\n  if (d->name)\n    d->name = realloc(d->name, count + 1);\n  else\n    d->name = malloc(count + 1);\n\n  sprintf(d->name, \"%*s\", count, ptr);\n  XFree(ptr);\n\n  XClearWindow(dpy, d->w.win);\n\n  width = MyFont_TextWidth(&Scr->DoorFont, d->name, count) + SIZE_HINDENT + (Scr->DoorBevelWidth * 2);\n  height = Scr->DoorFont.height + SIZE_VINDENT + (Scr->DoorBevelWidth * 2);\n\n  /* limit the size of a door - djhjr - 3/1/99 */\n  d->twin->hints.flags |= PMinSize;\n  d->twin->hints.min_width = width;\n  d->twin->hints.min_height = height;\n\n  SetupWindow(d->twin, d->twin->frame_x, d->twin->frame_y, width + 2 * bw, height + d->twin->title_height + 2 * bw, -1);\n\n  HandleExpose();\n}", "path": "doors.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tInsertInIconManager - put an allocated entry into an icon\n *\t\tmanager\n *\n *  Inputs:\n *\tip\t- the icon manager pointer\n *\ttmp\t- the entry to insert\n *\n ***********************************************************************\n */\n", "func_signal": "void\nInsertInIconManager(IconMgr * ip, WList * tmp, TwmWindow * tmp_win)", "code": "{\n  WList *tmp1;\n  int added;\n  int (*compar) (const char *a, const char *b) = (Scr->CaseSensitive ? strcmp : XmuCompareISOLatin1);\n\n  added = FALSE;\n  if (ip->first == NULL)\n  {\n    ip->first = tmp;\n    tmp->prev = NULL;\n    ip->last = tmp;\n    added = TRUE;\n  }\n  else if (Scr->SortIconMgr)\n  {\n    for (tmp1 = ip->first; tmp1 != NULL; tmp1 = tmp1->next)\n    {\n      if ((*compar) (tmp_win->icon_name, tmp1->twm->icon_name) < 0)\n      {\n\ttmp->next = tmp1;\n\ttmp->prev = tmp1->prev;\n\ttmp1->prev = tmp;\n\tif (tmp->prev == NULL)\n\t  ip->first = tmp;\n\telse\n\t  tmp->prev->next = tmp;\n\tadded = TRUE;\n\tbreak;\n      }\n    }\n  }\n\n  if (!added)\n  {\n    ip->last->next = tmp;\n    tmp->prev = ip->last;\n    ip->last = tmp;\n  }\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      AddEndResize - finish the resize operation for AddWindow\n *\n ***********************************************************************\n */\n", "func_signal": "void\nAddEndResize(TwmWindow * tmp_win)", "code": "{\n\n#ifdef DEBUG\n  fprintf(stderr, \"AddEndResize\\n\");\n#endif\n\n  MoveOutline(Scr->Root, 0, 0, 0, 0, 0, 0);\n  XUnmapWindow(dpy, Scr->SizeWindow.win);\n\n  ConstrainSize(tmp_win, &dragWidth, &dragHeight);\n  AddingX = dragx;\n  AddingY = dragy;\n  AddingW = dragWidth + (2 * tmp_win->frame_bw);\n  AddingH = dragHeight + (2 * tmp_win->frame_bw);\n\n  EndResizeAdjPointer(tmp_win);\n\n  if (dragWidth != tmp_win->frame_width || dragHeight != tmp_win->frame_height)\n    tmp_win->zoomed = ZOOM_NONE;\n\n  resizing_window = 0;\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      ConstrainSize - adjust the given width and height to account for the\n *              constraints imposed by size hints\n *\n *      The general algorithm, especially the aspect ratio stuff, is\n *      borrowed from uwm's CheckConsistency routine.\n *\n ***********************************************************************/\n", "func_signal": "void\nConstrainSize(TwmWindow * tmp_win, int *widthp, int *heightp)", "code": "{\n#define makemult(a,b) ((b==1) ? (a) : (((int)((a)/(b))) * (b)) )\n#define _min(a,b) (((a) < (b)) ? (a) : (b))\n\n  int minWidth, minHeight, maxWidth, maxHeight, xinc, yinc, delta;\n  int baseWidth, baseHeight;\n  int dwidth = *widthp, dheight = *heightp;\n\n\n  dwidth -= 2 * tmp_win->frame_bw3D;\n  dheight -= (tmp_win->title_height + 2 * tmp_win->frame_bw3D);\n\n  if (tmp_win->hints.flags & PMinSize)\n  {\n    minWidth = tmp_win->hints.min_width;\n    minHeight = tmp_win->hints.min_height;\n  }\n  else if (tmp_win->hints.flags & PBaseSize)\n  {\n    minWidth = tmp_win->hints.base_width;\n    minHeight = tmp_win->hints.base_height;\n  }\n  else\n    minWidth = minHeight = 1;\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    minWidth = SCALE_D(minWidth);\n    minHeight = SCALE_D(minHeight);\n  }\n\n  if (tmp_win->hints.flags & PBaseSize)\n  {\n    baseWidth = tmp_win->hints.base_width;\n    baseHeight = tmp_win->hints.base_height;\n  }\n  else if (tmp_win->hints.flags & PMinSize)\n  {\n    baseWidth = tmp_win->hints.min_width;\n    baseHeight = tmp_win->hints.min_height;\n  }\n  else\n    baseWidth = baseHeight = 0;\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    baseWidth = SCALE_D(baseWidth);\n    baseHeight = SCALE_D(baseHeight);\n  }\n\n  if (tmp_win->hints.flags & PMaxSize)\n  {\n    maxWidth = _min(Scr->MaxWindowWidth, tmp_win->hints.max_width);\n    maxHeight = _min(Scr->MaxWindowHeight, tmp_win->hints.max_height);\n  }\n  else\n  {\n    maxWidth = Scr->MaxWindowWidth;\n    maxHeight = Scr->MaxWindowHeight;\n  }\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    maxWidth = SCALE_D(maxWidth);\n    maxHeight = SCALE_D(maxHeight);\n  }\n\n  if (tmp_win->hints.flags & PResizeInc)\n  {\n    xinc = tmp_win->hints.width_inc;\n    yinc = tmp_win->hints.height_inc;\n  }\n  else\n    xinc = yinc = 1;\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    xinc = SCALE_D(xinc);\n    yinc = SCALE_D(yinc);\n  }\n\n  /*\n   * First, clamp to min and max values\n   */\n  if (dwidth < minWidth)\n    dwidth = minWidth;\n  if (dheight < minHeight)\n    dheight = minHeight;\n\n  if (dwidth > maxWidth)\n    dwidth = maxWidth;\n  if (dheight > maxHeight)\n    dheight = maxHeight;\n\n\n  /*\n   * Second, fit to base + N * inc\n   */\n  dwidth = ((dwidth - baseWidth) / xinc * xinc) + baseWidth;\n  dheight = ((dheight - baseHeight) / yinc * yinc) + baseHeight;\n\n\n  /*\n   * Third, adjust for aspect ratio\n   */\n#define maxAspectX tmp_win->hints.max_aspect.x\n#define maxAspectY tmp_win->hints.max_aspect.y\n#define minAspectX tmp_win->hints.min_aspect.x\n#define minAspectY tmp_win->hints.min_aspect.y\n  /*\n   * The math looks like this:\n   *\n   * minAspectX    dwidth     maxAspectX\n   * ---------- <= ------- <= ----------\n   * minAspectY    dheight    maxAspectY\n   *\n   * If that is multiplied out, then the width and height are\n   * invalid in the following situations:\n   *\n   * minAspectX * dheight > minAspectY * dwidth\n   * maxAspectX * dheight < maxAspectY * dwidth\n   *\n   */\n\n  if (tmp_win->hints.flags & PAspect)\n  {\n    if (minAspectX * dheight > minAspectY * dwidth)\n    {\n      delta = makemult(minAspectX * dheight / minAspectY - dwidth, xinc);\n      if (dwidth + delta <= maxWidth)\n\tdwidth += delta;\n      else\n      {\n\tdelta = makemult(dheight - dwidth * minAspectY / minAspectX, yinc);\n\tif (dheight - delta >= minHeight)\n\t  dheight -= delta;\n      }\n    }\n\n    if (maxAspectX * dheight < maxAspectY * dwidth)\n    {\n      delta = makemult(dwidth * maxAspectY / maxAspectX - dheight, yinc);\n      if (dheight + delta <= maxHeight)\n\tdheight += delta;\n      else\n      {\n\tdelta = makemult(dwidth - maxAspectX * dheight / maxAspectY, xinc);\n\tif (dwidth - delta >= minWidth)\n\t  dwidth -= delta;\n      }\n    }\n  }\n\n\n  /*\n   * Fourth, account for border width and title height\n   */\n  *widthp = dwidth + 2 * tmp_win->frame_bw3D;\n  *heightp = dheight + tmp_win->title_height + 2 * tmp_win->frame_bw3D;\n\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/*\n * go into a door\n */\n", "func_signal": "void\ndoor_enter(Window w, TwmDoor * d)", "code": "{\n  int snapon;\t\t\t/* doors override real screen snapping - djhjr - 2/5/99 */\n\n  if (!d)\n    /* find the door */\n    if (XFindContext(dpy, w, DoorContext, (caddr_t *) & d) == XCNOENT)\n      /* not a door ! */\n      return;\n\n  /* go to it */\n  snapon = (int)Scr->snapRealScreen;\n  Scr->snapRealScreen = FALSE;\n  SetRealScreen(d->goto_x, d->goto_y);\n  Scr->snapRealScreen = (snapon) ? TRUE : FALSE;\n}", "path": "doors.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/*\n * create a new door on the fly\n */\n", "func_signal": "void\ndoor_new(void)", "code": "{\n  TwmDoor *d;\n  char name[256];\n\n  sprintf(name, \"+%d+%d\", Scr->VirtualDesktopX, Scr->VirtualDesktopY);\n\n  d = door_add_internal(name, -1, -1, -1, -1, Scr->VirtualDesktopX, Scr->VirtualDesktopY);\n\n  door_open(d);\n}", "path": "doors.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tSortIconManager - sort the dude\n *\n *  Inputs:\n *\tip\t- a pointer to the icon manager struture\n *\n ***********************************************************************\n */\n", "func_signal": "void\nSortIconManager(IconMgr * ip)", "code": "{\n  WList *tmp1, *tmp2;\n  int done;\n  int (*compar) (const char *a, const char *b) = (Scr->CaseSensitive ? strcmp : XmuCompareISOLatin1);\n\n  if (ip == NULL)\n    ip = Active->iconmgr;\n\n  done = FALSE;\n  do\n  {\n    for (tmp1 = ip->first; tmp1 != NULL; tmp1 = tmp1->next)\n    {\n      if ((tmp2 = tmp1->next) == NULL)\n      {\n\tdone = TRUE;\n\tbreak;\n      }\n      if ((*compar) (tmp1->twm->icon_name, tmp2->twm->icon_name) > 0)\n      {\n\t/* take it out and put it back in */\n\tRemoveFromIconManager(ip, tmp2);\n\tInsertInIconManager(ip, tmp2, tmp2->twm);\n\tbreak;\n      }\n    }\n  }\n  while (!done);\n  PackIconManager(ip);\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tJumpIconManager - jump from one icon manager to another,\n *\t\tpossibly even on another screen\n *\n *  Inputs:\n *\tdir\t- one of the following:\n *\t\t\tF_NEXTICONMGR\t- go to the next icon manager\n *\t\t\tF_PREVICONMGR\t- go to the previous one\n *\n ***********************************************************************\n */\n", "func_signal": "void\nJumpIconManager(register int dir)", "code": "{\n  IconMgr *ip, *tmp_ip = NULL;\n  int got_it = FALSE;\n  ScreenInfo *sp;\n  int screen;\n\n  if (!Active)\n    return;\n\n\n#define ITER(i) (dir == F_NEXTICONMGR ? (i)->next : (i)->prev)\n#define IPOFSP(sp) (dir == F_NEXTICONMGR ? &(sp->iconmgr) : sp->iconmgr.lasti)\n#define TEST(ip) if ((ip)->count != 0 && (ip)->twm_win->mapped) \\\n\t\t { got_it = TRUE; break; }\n\n  ip = Active->iconmgr;\n  for (tmp_ip = ITER(ip); tmp_ip; tmp_ip = ITER(tmp_ip))\n  {\n    TEST(tmp_ip);\n  }\n\n  if (!got_it)\n  {\n    int origscreen = ip->scr->screen;\n    int inc = (dir == F_NEXTICONMGR ? 1 : -1);\n\n    for (screen = origscreen + inc;; screen += inc)\n    {\n      if (screen >= NumScreens)\n\tscreen = 0;\n      else if (screen < 0)\n\tscreen = NumScreens - 1;\n\n      sp = ScreenList[screen];\n      if (sp)\n      {\n\tfor (tmp_ip = IPOFSP(sp); tmp_ip; tmp_ip = ITER(tmp_ip))\n\t{\n\t  TEST(tmp_ip);\n\t}\n      }\n      if (got_it || screen == origscreen)\n\tbreak;\n    }\n  }\n\n#undef ITER\n#undef IPOFSP\n#undef TEST\n\n  if (!got_it)\n  {\n    DoAudible();\n    return;\n  }\n\n  /* raise the frame so it is visible */\n  XRaiseWindow(dpy, tmp_ip->twm_win->frame);\n\n  if (tmp_ip->active)\n    WarpInIconMgr(tmp_ip->active, tmp_ip->twm_win);\n  else\n  {\n    RaiseStickyAbove();\n    RaiseAutoPan();\n\n    WarpToWindow(tmp_ip->twm_win);\n  }\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tAllocateIconManager - allocate a new icon manager\n *\n *  Inputs:\n *\tname\t- the name of this icon manager\n *\ticon_name - the name of the associated icon\n *\tgeom\t- a geometry string to eventually parse\n *\tcolumns\t- the number of columns this icon manager has\n *\n ***********************************************************************\n */\n", "func_signal": "IconMgr *\nAllocateIconManager(char *name, char *icon_name, char *geom, int columns)", "code": "{\n  IconMgr *p;\n\n#ifdef DEBUG_ICONMGR\n  fprintf(stderr, \"AllocateIconManager\\n\");\n  fprintf(stderr, \"  name=\\\"%s\\\" icon_name=\\\"%s\\\", geom=\\\"%s\\\", col=%d\\n\", name, icon_name, geom, columns);\n#endif\n\n  if (Scr->NoIconManagers)\n    return NULL;\n\n  p = (IconMgr *) malloc(sizeof(IconMgr));\n  p->name = name;\n  p->icon_name = icon_name;\n  p->geometry = geom;\n  p->columns = columns;\n  p->first = NULL;\n  p->last = NULL;\n  p->active = NULL;\n  p->scr = Scr;\n  p->count = 0;\n  p->x = 0;\n  p->y = 0;\n  p->width = 150;\n  p->height = 10;\n\n  Scr->iconmgr.lasti->next = p;\n  p->prev = Scr->iconmgr.lasti;\n  Scr->iconmgr.lasti = p;\n  p->next = NULL;\n\n  return (p);\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tFindBitmap - read in a bitmap file and return size\n *\n *  Returned Value:\n *\tthe pixmap associated with the bitmap\n *      widthp\t- pointer to width of bitmap\n *      heightp\t- pointer to height of bitmap\n *\n *  Inputs:\n *\tname\t- the filename to read\n *\n ***********************************************************************\n */\n", "func_signal": "Pixmap\nFindBitmap(char *name, unsigned int *widthp, unsigned int *heightp)", "code": "{\n  char *bigname;\n  Pixmap pm;\n\n  if (!name)\n    return None;\n\n  /*\n   * Generate a full pathname if any special prefix characters (such as ~)\n   * are used.  If the bigname is different from name, bigname will need to\n   * be freed.\n   */\n  bigname = ExpandFilename(name);\n  if (!bigname)\n    return None;\n\n  /*\n   * look along bitmapFilePath resource same as toolkit clients\n   */\n  pm = XmuLocateBitmapFile(ScreenOfDisplay(dpy, Scr->screen), bigname, NULL, 0, (int *)widthp, (int *)heightp, &HotX, &HotY);\n  if (pm == None && Scr->IconDirectory && bigname[0] != '/')\n  {\n    if (bigname != name)\n      free(bigname);\n    /*\n     * Attempt to find icon in old IconDirectory (now obsolete)\n     */\n    bigname = (char *)malloc(strlen(name) + strlen(Scr->IconDirectory) + 2);\n    if (!bigname)\n    {\n      fprintf(stderr, \"%s:  unable to allocate memory for \\\"%s/%s\\\"\\n\", ProgramName, Scr->IconDirectory, name);\n      return None;\n    }\n    (void)sprintf(bigname, \"%s/%s\", Scr->IconDirectory, name);\n    if (XReadBitmapFile(dpy, Scr->Root, bigname, widthp, heightp, &pm, &HotX, &HotY) != BitmapSuccess)\n    {\n      pm = None;\n    }\n  }\n  if (bigname != name)\n    free(bigname);\n\n#ifdef DEBUG\n  if (pm == None)\n  {\n    fprintf(stderr, \"%s:  unable to find bitmap \\\"%s\\\"\\n\", ProgramName, name);\n  }\n#endif\n\n  return pm;\n}", "path": "image_formats.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      DisplaySize - display the size in the dimensions window\n *\n *  Inputs:\n *      tmp_win - the current twm window\n *      width   - the width of the rubber band\n *      height  - the height of the rubber band\n *\n ***********************************************************************\n */\n", "func_signal": "void\nDisplaySize(TwmWindow * tmp_win, int width, int height)", "code": "{\n  char str[100];\n  int i, dwidth, dheight;\n\n  if (last_width == width && last_height == height)\n    return;\n\n  last_width = width;\n  last_height = height;\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    dheight = SCALE_U(height) - tmp_win->title_height;\n    dwidth = SCALE_U(width);\n  }\n  else\n  {\n    dheight = height - tmp_win->title_height - 2 * tmp_win->frame_bw3D;\n    dwidth = width - 2 * tmp_win->frame_bw3D;\n\n  }\n\n  /*\n   * ICCCM says that PMinSize is the default is no PBaseSize is given,\n   * and vice-versa.\n   * Don't adjust if window is the virtual desktop - djhjr - 9/13/02\n   */\n  if (tmp_win->hints.flags & (PMinSize | PBaseSize) && tmp_win->hints.flags & PResizeInc)\n  {\n    if (tmp_win->hints.flags & PBaseSize)\n    {\n      dwidth -= tmp_win->hints.base_width;\n      dheight -= tmp_win->hints.base_height;\n    }\n    else if (strcmp(tmp_win->class.res_class, VTWM_DESKTOP_CLASS) != 0)\n    {\n      dwidth -= tmp_win->hints.min_width;\n      dheight -= tmp_win->hints.min_height;\n    }\n  }\n\n  if (tmp_win->hints.flags & PResizeInc)\n  {\n    dwidth /= tmp_win->hints.width_inc;\n    dheight /= tmp_win->hints.height_inc;\n  }\n\n/*\n * Non-SysV systems - specifically, BSD-derived systems - return a\n * pointer to the string, not its length. Submitted by Goran Larsson\n */\n  sprintf(str, \"%5d x %-5d\", dwidth, dheight);\n  i = strlen(str);\n\n  XRaiseWindow(dpy, Scr->SizeWindow.win);\n  MyFont_DrawImageString(dpy, &Scr->SizeWindow, &Scr->SizeFont,\n\t\t\t &Scr->DefaultC, (Scr->SizeStringWidth - MyFont_TextWidth(&Scr->SizeFont, str, i)) / 2,\n\t\t\t /* was 'Scr->use3Dborders' - djhjr - 8/11/98 */\n\t\t\t Scr->SizeFont.ascent + SIZE_VINDENT + ((Scr->InfoBevelWidth > 0) ? Scr->InfoBevelWidth : 0), str, i);\n\n  /* I know, I know, but the above code overwrites it... djhjr - 5/9/96 */\n  if (Scr->InfoBevelWidth > 0)\n    Draw3DBorder(Scr->SizeWindow.win, 0, 0,\n\t\t Scr->SizeStringWidth,\n\t\t (unsigned int)(Scr->SizeFont.height + SIZE_VINDENT * 2) +\n\t\t ((Scr->InfoBevelWidth > 0) ? 2 * Scr->InfoBevelWidth : 0), Scr->InfoBevelWidth, Scr->DefaultC, off, False, False);\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      EndResize - finish the resize operation\n *\n ***********************************************************************\n */\n", "func_signal": "void\nEndResize(void)", "code": "{\n  TwmWindow *tmp_win;\n\n#ifdef DEBUG\n  fprintf(stderr, \"EndResize\\n\");\n#endif\n\n  if (resize_context == C_VIRTUAL_WIN)\n    MoveOutline(Scr->VirtualDesktopDisplay, 0, 0, 0, 0, 0, 0);\n  else\n    MoveOutline(Scr->Root, 0, 0, 0, 0, 0, 0);\n  XUnmapWindow(dpy, Scr->SizeWindow.win);\n\n  XFindContext(dpy, ResizeWindow, TwmContext, (caddr_t *) & tmp_win);\n\n  if (resize_context == C_VIRTUAL_WIN)\n  {\n    /* scale up */\n    dragWidth = SCALE_U(dragWidth);\n    dragHeight = SCALE_U(dragHeight);\n    dragx = SCALE_U(dragx);\n    dragy = SCALE_U(dragy);\n  }\n\n  ConstrainSize(tmp_win, &dragWidth, &dragHeight);\n\n  if (dragWidth != tmp_win->frame_width || dragHeight != tmp_win->frame_height)\n    tmp_win->zoomed = ZOOM_NONE;\n\n  SetupWindow(tmp_win, dragx - tmp_win->frame_bw, dragy - tmp_win->frame_bw, dragWidth, dragHeight, -1);\n\n  EndResizeAdjPointer(tmp_win);\n\n  /* added test for opaque resizing - djhjr - 2/28/99, 3/1/99 */\n  if (!tmp_win->opaque_resize)\n  {\n    ResizeTwmWindowContents(tmp_win, dragWidth, dragHeight);\n  }\n\n  ResizeWindow = None;\n\n  resizing_window = 0;\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/*\n * adjust contents of iconmgrs, doors and the desktop - djhjr - 9/10/99\n */\n", "func_signal": "void\nResizeTwmWindowContents(TwmWindow * tmp_win, int width, int height)", "code": "{\n  TwmDoor *door;\n  int ncols;\n\n  if (tmp_win->iconmgr)\n  {\n    ncols = tmp_win->iconmgrp->cur_columns;\n    if (ncols == 0)\n      ncols = 1;\n\n    tmp_win->iconmgrp->width = (int)(((width - 2 * tmp_win->frame_bw3D) * (long)tmp_win->iconmgrp->columns) / ncols);\n    PackIconManager(tmp_win->iconmgrp);\n  }\n  else if (tmp_win->w == Scr->VirtualDesktopDisplayOuter)\n    ResizeDesktopDisplay(width, height);\n  else if (XFindContext(dpy, tmp_win->w, DoorContext, (caddr_t *) & door) != XCNOENT)\n    RedoDoorName(tmp_win, door);\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *\tRemoveIconManager - remove a window from the icon manager\n *\n *  Inputs:\n *\ttmp_win\t- the TwmWindow structure\n *\n ***********************************************************************\n */\n", "func_signal": "void\nRemoveIconManager(TwmWindow * tmp_win)", "code": "{\n  IconMgr *ip;\n  WList *tmp;\n\n  if (tmp_win->list == NULL)\n    return;\n\n  tmp = tmp_win->list;\n\n  if (Active == tmp)\n    Active = NULL;\n\n  /*\n   * Believe it or not, the kludge in events.c:HandleKeyPress() needs\n   * this, or a window that's been destroyed still registers there,\n   * even though the whole mess gets freed in just a few microseconds!\n   */\n  /*\n   * Somehwere alone the line, whatever it was got fixed, and this is\n   * needed again - djhjr - 5/27/03\n   */\n  tmp->active = FALSE;\n  tmp->iconmgr->active = NULL;\n\n  tmp_win->list = NULL;\n  ip = tmp->iconmgr;\n\n  RemoveFromIconManager(ip, tmp);\n\n  XDeleteContext(dpy, tmp->icon, TwmContext);\n  XDeleteContext(dpy, tmp->icon, ScreenContext);\n  XDestroyWindow(dpy, tmp->icon);\n#ifdef TWM_USE_XFT\n  if (Scr->use_xft > 0)\n    MyXftDrawDestroy(tmp->w.xft);\n#endif\n  XDeleteContext(dpy, tmp->w.win, IconManagerContext);\n  XDeleteContext(dpy, tmp->w.win, TwmContext);\n  XDeleteContext(dpy, tmp->w.win, ScreenContext);\n  XDestroyWindow(dpy, tmp->w.win);\n  ip->count -= 1;\n\n  free((char *)tmp);\n\n  PackIconManager(ip);\n\n  if (ip->count == 0)\n  {\n    if (ip->twm_win->icon)\n      XUnmapWindow(dpy, ip->twm_win->icon_w.win);\n    else\n\n      XUnmapWindow(dpy, ip->twm_win->frame);\n  }\n\n}", "path": "iconmgr.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/***********************************************************************\n *\n *  Procedure:\n *      AddStartResize - begin a windorew resize operation from AddWindow\n *\n *  Inputs:\n *      tmp_win - the TwmWindow pointer\n *\n ***********************************************************************\n */\n", "func_signal": "void\nAddStartResize(TwmWindow * tmp_win, int x, int y, int w, int h)", "code": "{\n  resize_context = C_WINDOW;\n\n  SetVirtualDesktopIncrs(tmp_win);\n\n  if (!tmp_win->opaque_resize)\n    XGrabServer(dpy);\n\n  XGrabPointer(dpy, Scr->Root, True,\n\t       ButtonReleaseMask | ButtonMotionMask | PointerMotionHintMask,\n\t       GrabModeAsync, GrabModeAsync, Scr->Root, Scr->ResizeCursor, CurrentTime);\n\n  dragx = x + tmp_win->frame_bw;\n  dragy = y + tmp_win->frame_bw;\n  origx = dragx;\n  origy = dragy;\n  dragWidth = origWidth = w - 2 * tmp_win->frame_bw;\n  dragHeight = origHeight = h - 2 * tmp_win->frame_bw;\n  clampTop = clampBottom = clampLeft = clampRight = clampDX = clampDY = 0;\n  last_width = 0;\n  last_height = 0;\n  DisplaySize(tmp_win, origWidth, origHeight);\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "/*\n * Attention: in the following tiled screen Zoom functions 'top-edge'\n * is not towards the upper edge of the monitor but the edge having\n * greater y-coordinate.  I.e. in fact, it is towards the 'lower-edge'.\n * Imagine 'bot' having y0 and 'top' the y1 Cartesian coordinate,\n * and y0 <= y1 imposed.\n *\n * (Thinking of Lft/Bot/Rht/Top-edges as x0/y0/x1/y1-edges instead\n * is correct and probably less confusing.)\n */\n", "func_signal": "static int\nFindAreaIntersection(int a[4], int b[4])", "code": "{\n  int dx, dy;\n\n  dx = Distance1D(Lft(a), Rht(a), Lft(b), Rht(b));\n  dy = Distance1D(Bot(a), Top(a), Bot(b), Top(b));\n  return Distance2D(dx,dy);\n}", "path": "resize.c", "repo_name": "SethRobertson/vtwm-dev", "stars": 3, "license": "None", "language": "c", "size": 2208}
{"docstring": "// *** rprintfu32 ***\n// prints an unsigned 32-bit number in hex (8 digits)\n", "func_signal": "void rprintfu32(unsigned long data)", "code": "{\n\t// print 32-bit hex value\n\trprintfu16(data>>16);\n\trprintfu16(data);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// return true if uart receive buffer is empty\n", "func_signal": "u08 uartReceiveBufferIsEmpty(void)", "code": "{\n\tif(uartRxBuffer.datalength == 0)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfu16 ***\n// prints an unsigned 16-bit number in hex (4 digits)\n", "func_signal": "void rprintfu16(unsigned short data)", "code": "{\n\t// print 16-bit hex value\n\trprintfu08(data>>8);\n\trprintfu08(data);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfChar ***\n// send a character/byte to the current output device\n", "func_signal": "void rprintfChar(unsigned char c)", "code": "{\n\t// do LF -> CR/LF translation\n\tif(c == '\\n')\n\t\trputchar('\\r');\n\t// send character\n\trputchar(c);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfFloat ***\n// floating-point print\n", "func_signal": "void rprintfFloat(char numDigits, double x)", "code": "{\n\tunsigned char firstplace = FALSE;\n\tunsigned char negative;\n\tunsigned char i, digit;\n\tdouble place = 1.0;\n\t\n\t// save sign\n\tnegative = (x<0);\n\t// convert to absolute value\n\tx = (x>0)?(x):(-x);\n\t\n\t// find starting digit place\n\tfor(i=0; i<15; i++)\n\t{\n\t\tif((x/place) < 10.0)\n\t\t\tbreak;\n\t\telse\n\t\t\tplace *= 10.0;\n\t}\n\t// print polarity character\n\tif(negative)\n\t\trprintfChar('-');\n\telse\n\t\trprintfChar('+');\n\n\t// print digits\n\tfor(i=0; i<numDigits; i++)\n\t{\n\t\tdigit = (x/place);\n\n\t\tif(digit | firstplace | (place == 1.0))\n\t\t{\n\t\t\tfirstplace = TRUE;\n\t\t\trprintfChar(digit+0x30);\n\t\t}\n\t\telse\n\t\t\trprintfChar(' ');\n\t\t\n\t\tif(place == 1.0)\n\t\t{\n\t\t\trprintfChar('.');\n\t\t}\n\t\t\n\t\tx -= (digit*place);\n\t\tplace /= 10.0;\n\t}\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfu08 ***\n// prints an unsigned 8-bit number in hex (2 digits)\n", "func_signal": "void rprintfu08(unsigned char data)", "code": "{\n\t// print 8-bit hex value\n\trprintfu04(data>>4);\n\trprintfu04(data);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// enable and initialize the uart\n", "func_signal": "void uartInit(void)", "code": "{\n\t// initialize the buffers\n\tuartInitBuffers();\n\t// initialize user receive handler\n\tUartRxFunc = 0;\n\n\t// enable RxD/TxD and interrupts\n\toutb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));\n\n\t// set default baud rate\n\tuartSetBaudRate(UART_DEFAULT_BAUD_RATE);  \n\t// initialize states\n\tuartReadyTx = TRUE;\n\tuartBufferedTx = FALSE;\n\t// clear overflow count\n\tuartRxOverflow = 0;\n\t// enable interrupts\n\tsei();\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "/*\n// transmit nBytes from buffer out the uart\nu08 uartSendBuffer(char *buffer, u16 nBytes)\n{\n\tregister u08 first;\n\tregister u16 i;\n\n\t// check if there's space (and that we have any bytes to send at all)\n\tif((uartTxBuffer.datalength + nBytes < uartTxBuffer.size) && nBytes)\n\t{\n\t\t// grab first character\n\t\tfirst = *buffer++;\n\t\t// copy user buffer to uart transmit buffer\n\t\tfor(i = 0; i < nBytes-1; i++)\n\t\t{\n\t\t\t// put data bytes at end of buffer\n\t\t\tbufferAddToEnd(&uartTxBuffer, *buffer++);\n\t\t}\n\n\t\t// send the first byte to get things going by interrupts\n\t\tuartBufferedTx = TRUE;\n\t\tuartSendByte(first);\n\t\t// return success\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\t// return failure\n\t\treturn FALSE;\n\t}\n}\n*/\n// UART Transmit Complete Interrupt Handler\n", "func_signal": "UART_INTERRUPT_HANDLER(SIG_UART_TRANS)", "code": "{\n\t// check if buffered tx is enabled\n\tif(uartBufferedTx)\n\t{\n\t\t// check if there's data left in the buffer\n\t\tif(uartTxBuffer.datalength)\n\t\t{\n\t\t\t// send byte from top of buffer\n\t\t\toutb(UDR, bufferGetFromFront(&uartTxBuffer));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no data left\n\t\t\tuartBufferedTx = FALSE;\n\t\t\t// return to ready state\n\t\t\tuartReadyTx = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// we're using single-byte tx mode\n\t\t// indicate transmit complete, back to ready\n\t\tuartReadyTx = TRUE;\n\t}\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// gets a byte (if available) from the uart receive buffer\n", "func_signal": "u08 uartReceiveByte(u08* rxData)", "code": "{\n\t// make sure we have a receive buffer\n\tif(uartRxBuffer.size)\n\t{\n\t\t// make sure we have data\n\t\tif(uartRxBuffer.datalength)\n\t\t{\n\t\t\t// get byte from beginning of buffer\n\t\t\t*rxData = bufferGetFromFront(&uartRxBuffer);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no data\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// no buffer\n\t\treturn FALSE;\n\t}\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// create and initialize the uart transmit and receive buffers\n", "func_signal": "void uartInitBuffers(void)", "code": "{\n\t#ifndef UART_BUFFERS_EXTERNAL_RAM\n\t\t// initialize the UART receive buffer\n\t\tbufferInit(&uartRxBuffer, uartRxData, UART_RX_BUFFER_SIZE);\n\t\t// initialize the UART transmit buffer\n\t\tbufferInit(&uartTxBuffer, uartTxData, UART_TX_BUFFER_SIZE);\n\t#else\n\t\t// initialize the UART receive buffer\n\t\tbufferInit(&uartRxBuffer, (u08*) UART_RX_BUFFER_ADDR, UART_RX_BUFFER_SIZE);\n\t\t// initialize the UART transmit buffer\n\t\tbufferInit(&uartTxBuffer, (u08*) UART_TX_BUFFER_ADDR, UART_TX_BUFFER_SIZE);\n\t#endif\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// UART Receive Complete Interrupt Handler\n", "func_signal": "UART_INTERRUPT_HANDLER(SIG_UART_RECV)", "code": "{\n\tu08 c;\n\t\n\t// get received char\n\tc = inb(UDR);\n\n\t// if there's a user function to handle this receive event\n\tif(UartRxFunc)\n\t{\n\t\t// call it and pass the received data\n\t\tUartRxFunc(c);\n\t}\n\telse\n\t{\n\t\t// otherwise do default processing\n\t\t// put received char in buffer\n\t\t// check if there's space\n\t\tif( !bufferAddToEnd(&uartRxBuffer, c) )\n\t\t{\n\t\t\t// no space in buffer\n\t\t\t// count overflow\n\t\t\tuartRxOverflow++;\n\t\t}\n\t}\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfProgStr ***\n// prints a null-terminated string stored in program ROM\n", "func_signal": "void rprintfProgStr(const prog_char str[])", "code": "{\n\t// print a string stored in program memory\n\tregister char c;\n\n\t// check to make sure we have a good pointer\n\tif (!str) return;\n\t\n\t// print the string until the null-terminator\n\twhile((c = pgm_read_byte(str++)))\n\t\trprintfChar(c);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfNum ***\n// special printf for numbers only\n// see formatting information below\n//\tPrint the number \"n\" in the given \"base\"\n//\tusing exactly \"numDigits\"\n//\tprint +/- if signed flag \"isSigned\" is TRUE\n//\tuse the character specified in \"padchar\" to pad extra characters\n//\n//\tExamples:\n//\tuartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  \" +1234\"\n//\tuartPrintfNum(10, 6, FALSE, '0',   1234);  -->  \"001234\"\n//\tuartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  \"..5AA5\"\n", "func_signal": "void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)", "code": "{\n\t// define a global HexChars or use line below\n\t//static char HexChars[16] = \"0123456789ABCDEF\";\n\tchar *p, buf[32];\n\tunsigned long x;\n\tunsigned char count;\n\n\t// prepare negative number\n\tif( isSigned && (n < 0) )\n\t{\n\t\tx = -n;\n\t}\n\telse\n\t{\n\t \tx = n;\n\t}\n\n\t// setup little string buffer\n\tcount = (numDigits-1)-(isSigned?1:0);\n  \tp = buf + sizeof (buf);\n  \t*--p = '\\0';\n\t\n\t// force calculation of first digit\n\t// (to prevent zero from not printing at all!!!)\n\t*--p = hexchar(x%base); x /= base;\n\t// calculate remaining digits\n\twhile(count--)\n\t{\n\t\tif(x != 0)\n\t\t{\n\t\t\t// calculate next digit\n\t\t\t*--p = hexchar(x%base); x /= base;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no more digits left, pad out to desired length\n\t\t\t*--p = padchar;\n\t\t}\n\t}\n\n\t// apply signed notation if requested\n\tif( isSigned )\n\t{\n\t\tif(n < 0)\n\t\t{\n   \t\t\t*--p = '-';\n\t\t}\n\t\telse if(n > 0)\n\t\t{\n\t   \t\t*--p = '+';\n\t\t}\n\t\telse\n\t\t{\n\t   \t\t*--p = ' ';\n\t\t}\n\t}\n\n\t// print the string right-justified\n\tcount = numDigits;\n\twhile(count--)\n\t{\n\t\trprintfChar(*p++);\n\t}\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintf2RamRom ***\n// called by rprintf() - does a more powerful printf (supports %d, %u, %o, %x, %c, %s)\n// Supports:\n// %d - decimal\n// %u - unsigned decimal\n// %o - octal\n// %x - hex\n// %c - character\n// %s - strings\n// and the width,precision,padding modifiers\n// **this printf does not support floating point numbers\n", "func_signal": "int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)", "code": "{\n\tregister unsigned char *f, *bp;\n\tregister long l;\n\tregister unsigned long u;\n\tregister int i;\n\tregister int fmt;\n\tregister unsigned char pad = ' ';\n\tint flush_left = 0, f_width = 0, prec = INF, hash = 0, do_long = 0;\n\tint sign = 0;\n\n\tva_list ap;\n\tva_start(ap, sfmt);\n\n\tf = (unsigned char *) sfmt;\n\n\tfor (; READMEMBYTE(stringInRom,f); f++)\n\t{\n\t\tif (READMEMBYTE(stringInRom,f) != '%')\n\t\t{\t// not a format character\n\t\t\t// then just output the char\n\t\t\trprintfChar(READMEMBYTE(stringInRom,f));\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf++;\t\t\t\t\t\t// if we have a \"%\" then skip it\n\t\t\tif (READMEMBYTE(stringInRom,f) == '-')\n\t\t\t{\n\t\t\t\tflush_left = 1;\t// minus: flush left\n\t\t\t\tf++;\n\t\t\t}\n            if (READMEMBYTE(stringInRom,f) == '0'\n\t\t\t\t || READMEMBYTE(stringInRom,f) == '.')\n\t\t\t\t{\n\t\t\t\t\t// padding with 0 rather than blank\n\t\t\t\t\tpad = '0';\n\t\t\t\t\tf++;\n            }\n            if (READMEMBYTE(stringInRom,f) == '*')\n\t\t\t\t{\t// field width\n\t\t\t\t\tf_width = va_arg(ap, int);\n\t\t\t\t\tf++;\n            }\n            else if (Isdigit(READMEMBYTE(stringInRom,f)))\n\t\t\t\t{\n\t\t\t\t\tf_width = atoiRamRom(stringInRom, (char *) f);\n\t\t\t\t\twhile (Isdigit(READMEMBYTE(stringInRom,f)))\n\t\t\t\t\t\tf++;        // skip the digits\n            }\n            if (READMEMBYTE(stringInRom,f) == '.')\n\t\t\t\t{\t// precision\n\t\t\t\t\tf++;\n\t\t\t\t\tif (READMEMBYTE(stringInRom,f) == '*')\n\t\t\t\t\t{\n\t\t\t\t\t\tprec = va_arg(ap, int);\n\t\t\t\t\t\tf++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Isdigit(READMEMBYTE(stringInRom,f)))\n\t\t\t\t\t{\n\t\t\t\t\t\tprec = atoiRamRom(stringInRom, (char *) f);\n\t\t\t\t\t\twhile (Isdigit(READMEMBYTE(stringInRom,f)))\n\t\t\t\t\t\t\tf++;    // skip the digits\n\t\t\t\t\t}\n\t\t\t\t}\n            if (READMEMBYTE(stringInRom,f) == '#')\n\t\t\t\t{\t// alternate form\n\t\t\t\t\thash = 1;\n\t\t\t\t\tf++;\n            }\n            if (READMEMBYTE(stringInRom,f) == 'l')\n\t\t\t\t{\t// long format\n\t\t\t\t\tdo_long = 1;\n\t\t\t\t\tf++;\n            }\n\n\t\t\t\tfmt = READMEMBYTE(stringInRom,f);\n\t\t\t\tbp = buf;\n\t\t\t\tswitch (fmt) {\t\t// do the formatting\n\t\t\t\tcase 'd':\t\t\t// 'd' signed decimal\n\t\t\t\t\tif (do_long)\n\t\t\t\t\t\tl = va_arg(ap, long);\n\t\t\t\t\telse\n\t\t\t\t\t\tl = (long) (va_arg(ap, int));\n\t\t\t\t\tif (l < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsign = 1;\n\t\t\t\t\t\tl = -l;\n\t\t\t\t\t}\n\t\t\t\t\tdo\t{\n\t\t\t\t\t\t*bp++ = l % 10 + '0';\n\t\t\t\t\t} while ((l /= 10) > 0);\n\t\t\t\t\tif (sign)\n\t\t\t\t\t\t*bp++ = '-';\n\t\t\t\t\tf_width = f_width - (bp - buf);\n\t\t\t\t\tif (!flush_left)\n\t\t\t\t\t\twhile (f_width-- > 0)\n\t\t\t\t\t\t\trprintfChar(pad);\n\t\t\t\t\tfor (bp--; bp >= buf; bp--)\n\t\t\t\t\t\trprintfChar(*bp);\n\t\t\t\t\tif (flush_left)\n\t\t\t\t\t\twhile (f_width-- > 0)\n\t\t\t\t\t\t\trprintfChar(' ');\n\t\t\t\t\tbreak;\n            case 'o':\t\t\t// 'o' octal number\n            case 'x':\t\t\t// 'x' hex number\n            case 'u':\t\t\t// 'u' unsigned decimal\n\t\t\t\t\tif (do_long)\n\t\t\t\t\t\tu = va_arg(ap, unsigned long);\n\t\t\t\t\telse\n\t\t\t\t\t\tu = (unsigned long) (va_arg(ap, unsigned));\n\t\t\t\t\tif (fmt == 'u')\n\t\t\t\t\t{\t// unsigned decimal\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t*bp++ = u % 10 + '0';\n\t\t\t\t\t\t} while ((u /= 10) > 0);\n\t\t\t\t\t}\n\t\t\t\t\telse if (fmt == 'o')\n\t\t\t\t\t{  // octal\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t*bp++ = u % 8 + '0';\n\t\t\t\t\t\t} while ((u /= 8) > 0);\n\t\t\t\t\t\tif (hash)\n\t\t\t\t\t\t\t*bp++ = '0';\n\t\t\t\t\t}\n\t\t\t\t\telse if (fmt == 'x')\n\t\t\t\t\t{\t// hex\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ti = u % 16;\n\t\t\t\t\t\t\tif (i < 10)\n\t\t\t\t\t\t\t\t*bp++ = i + '0';\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t*bp++ = i - 10 + 'a';\n\t\t\t\t\t\t} while ((u /= 16) > 0);\n\t\t\t\t\t\tif (hash)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*bp++ = 'x';\n\t\t\t\t\t\t\t*bp++ = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = f_width - (bp - buf);\n\t\t\t\t\tif (!flush_left)\n\t\t\t\t\t\twhile (i-- > 0)\n\t\t\t\t\t\t\trprintfChar(pad);\n\t\t\t\t\tfor (bp--; bp >= buf; bp--)\n\t\t\t\t\t\trprintfChar((int) (*bp));\n\t\t\t\t\tif (flush_left)\n\t\t\t\t\t\twhile (i-- > 0)\n\t\t\t\t\t\t\trprintfChar(' ');\n\t\t\t\t\tbreak;\n            case 'c':\t\t\t// 'c' character\n\t\t\t\t\ti = va_arg(ap, int);\n\t\t\t\t\trprintfChar((int) (i));\n\t\t\t\t\tbreak;\n            case 's':\t\t\t// 's' string\n\t\t\t\t\tbp = va_arg(ap, unsigned char *);\n\t\t\t\t\tif (!bp)\n\t\t\t\t\t\tbp = (unsigned char *) \"(nil)\";\n\t\t\t\t\tf_width = f_width - strlen((char *) bp);\n\t\t\t\t\tif (!flush_left)\n\t\t\t\t\t\twhile (f_width-- > 0)\n\t\t\t\t\t\t\trprintfChar(pad);\n\t\t\t\t\tfor (i = 0; *bp && i < prec; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\trprintfChar(*bp);\n\t\t\t\t\t\tbp++;\n\t\t\t\t\t}\n\t\t\t\t\tif (flush_left)\n\t\t\t\t\t\twhile (f_width-- > 0)\n\t\t\t\t\t\t\trprintfChar(' ');\n\t\t\t\t\tbreak;\n            case '%':\t\t\t// '%' character\n\t\t\t\t\trprintfChar('%');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflush_left = 0, f_width = 0, prec = INF, hash = 0, do_long = 0;\n\t\t\tsign = 0;\n\t\t\tpad = ' ';\n\t\t}\n\t}\n\n\tva_end(ap);\n\treturn 0;\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfStr ***\n// prints a null-terminated string stored in RAM\n", "func_signal": "void rprintfStr(char str[])", "code": "{\n\t// send a string stored in RAM\n\t// check to make sure we have a good pointer\n\tif (!str) return;\n\n\t// print the string until a null-terminator\n\twhile (*str)\n\t\trprintfChar(*str++);\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// start transmission of the current uart Tx buffer contents\n", "func_signal": "void uartSendTxBuffer(void)", "code": "{\n\t// turn on buffered transmit\n\tuartBufferedTx = TRUE;\n\t// send the first byte to get things going by interrupts\n\tuartSendByte(bufferGetFromFront(&uartTxBuffer));\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// transmit nBytes from buffer out the uart\n", "func_signal": "u08 uartSendBuffer(char *buffer, u16 nBytes)", "code": "{\n\tregister u08 first;\n\tregister u16 i;\n\n\t// check if there's space (and that we have any bytes to send at all)\n\tif((uartTxBuffer.datalength + nBytes < uartTxBuffer.size) && nBytes)\n\t{\n\t\t// grab first character\n\t\tfirst = *buffer++;\n\t\t// copy user buffer to uart transmit buffer\n\t\tfor(i = 0; i < nBytes-1; i++)\n\t\t{\n\t\t\t// put data bytes at end of buffer\n\t\t\tbufferAddToEnd(&uartTxBuffer, *buffer++);\n\t\t}\n\n\t\t// send the first byte to get things going by interrupts\n\t\tuartBufferedTx = TRUE;\n\t\tuartSendByte(first);\n\t\t// return success\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\t// return failure\n\t\treturn FALSE;\n\t}\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// *** rprintfStrLen ***\n// prints a section of a string stored in RAM\n// begins printing at position indicated by <start>\n// prints number of characters indicated by <len>\n", "func_signal": "void rprintfStrLen(char str[], unsigned int start, unsigned int len)", "code": "{\n\tregister int i=0;\n\n\t// check to make sure we have a good pointer\n\tif (!str) return;\n\t// spin through characters up to requested start\n\t// keep going as long as there's no null\n\twhile((i++<start) && (*str++));\n//\tfor(i=0; i<start; i++)\n//\t{\n//\t\t// keep steping through string as long as there's no null\n//\t\tif(*str) str++;\n//\t}\n\n\t// then print exactly len characters\n\tfor(i=0; i<len; i++)\n\t{\n\t\t// print data out of the string as long as we haven't reached a null yet\n\t\t// at the null, start printing spaces\n\t\tif(*str)\n\t\t\trprintfChar(*str++);\n\t\telse\n\t\t\trprintfChar(' ');\n\t}\n\n}", "path": "rprintf.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// gets a single byte from the uart receive buffer (getchar-style)\n", "func_signal": "int uartGetByte(void)", "code": "{\n\tu08 c;\n\tif(uartReceiveByte(&c))\n\t\treturn c;\n\telse\n\t\treturn -1;\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "// set the uart baud rate\n", "func_signal": "void uartSetBaudRate(u32 baudrate)", "code": "{\n\t// calculate division factor for requested baud rate, and set it\n\tu16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);\n\toutb(UBRRL, bauddiv);\n\t#ifdef UBRRH\n\toutb(UBRRH, bauddiv>>8);\n\t#endif\n}", "path": "uart.c", "repo_name": "Br3nda/temp_sens", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 1400}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC3EF08_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4-R6,LR}\\n\"\n                \"LDR     R5, =0x2BA0\\n\"\n                \"MOV     R6, R0\\n\"\n                \"LDR     R0, [R5,#0x10]\\n\"\n                \"CMP     R0, #0\\n\"\n                \"MOVNE   R0, #1\\n\"\n                \"LDMNEFD SP!, {R4-R6,PC}\\n\"\n                \"MOV     R0, #0x17\\n\"\n                \"MUL     R1, R0, R6\\n\"\n                \"LDR     R0, =0x11800\\n\"\n                \"ADD     R4, R0, R1,LSL#2\\n\"\n                \"LDR     R0, [R4,#0x38]\\n\"\n                \"MOV     R1, R6\\n\"\n                \"BL      sub_FFC3EDA0_my\\n\"        //    continue to SDHC-hook here!\n                \"CMP     R0, #0\\n\"\n                \"LDMEQFD SP!, {R4-R6,PC}\\n\"\n                \"LDR     R0, [R4,#0x38]\\n\"\n                \"MOV     R1, R6\\n\"\n                \"BL      sub_FFC3F77C\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDMEQFD SP!, {R4-R6,PC}\\n\"\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC3E8BC\\n\"\n                \"CMP     R0, #0\\n\"\n                \"MOVNE   R1, #1\\n\"\n                \"STRNE   R1, [R5,#0x10]\\n\"\n                \"LDMFD   SP!, {R4-R6,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "/*\n * Operating system has died. Known functions will be killed\n * after memmove.\n *\n * Make sure stack is not used.\n */\n", "func_signal": "void __attribute__((noreturn)) copy_and_restart(void *dst_void, const void *src_void, long length)", "code": "{\n\n        {\n                char *dst = dst_void;\n                const char *src = src_void;\n\n                if (src < dst && dst < src + length)\n                {\n                        /* Have to copy backwards */\n                        src += length;\n                        dst += length;\n                        while (length--)\n                        {\n                                *--dst = *--src;\n                        }\n                }\n                else\n                {\n                        while (length--)\n                        {\n                                *dst++ = *src++;\n                        }\n                }\n        }\n\n        // from 0xFF82940C (sub_FF8293DC, via call to _sub_???__ADCScn.c__214)\n        asm volatile (\n                 \"MRS     R0, CPSR\\n\"\n                 \"BIC     R0, R0, #0x3F\\n\"\n                 \"ORR     R0, R0, #0xD3\\n\"\n                 \"MSR     CPSR, R0\\n\"\n                 \"LDR     R1, =0xC0200000\\n\"\n                 \"MVN     R0, #0\\n\"\n                 \"STR     R0, [R1,#0x10C]\\n\"\n                 \"STR     R0, [R1,#0xC]\\n\"\n                 \"STR     R0, [R1,#0x1C]\\n\"\n                 \"STR     R0, [R1,#0x2C]\\n\"\n                 \"STR     R0, [R1,#0x3C]\\n\"\n                 \"STR     R0, [R1,#0x4C]\\n\"\n                 \"STR     R0, [R1,#0x5C]\\n\"\n                 \"STR     R0, [R1,#0x6C]\\n\"\n                 \"STR     R0, [R1,#0x7C]\\n\"\n                 \"STR     R0, [R1,#0x8C]\\n\"\n                 \"STR     R0, [R1,#0x9C]\\n\"\n                 \"STR     R0, [R1,#0xAC]\\n\"\n                 \"STR     R0, [R1,#0xBC]\\n\"\n                 \"STR     R0, [R1,#0xCC]\\n\"\n                 \"STR     R0, [R1,#0xDC]\\n\"\n                 \"STR     R0, [R1,#0xEC]\\n\"\n                 \"CMP     R4, #7\\n\"\n                 \"STR     R0, [R1,#0xFC]\\n\"\n                 \"LDMEQFD SP!, {R4,PC}\\n\"\n                 \"MOV     R0, #0x78\\n\"\n                 \"MCR     p15, 0, R0,c1,c0\\n\"\n                 \"MOV     R0, #0\\n\"\n                 \"MCR     p15, 0, R0,c7,c10, 4\\n\"\n                 \"MCR     p15, 0, R0,c7,c5\\n\"\n                 \"MCR     p15, 0, R0,c7,c6\\n\"\n                 \"MOV     R0, #0x80000006\\n\"\n                 \"MCR     p15, 0, R0,c9,c1\\n\"\n                 \"MCR     p15, 0, R0,c9,c1, 1\\n\"\n                 \"MRC     p15, 0, R0,c1,c0\\n\"\n                 \"ORR     R0, R0, #0x50000\\n\"\n                 \"MCR     p15, 0, R0,c1,c0\\n\"\n                 \"LDR     R0, =0x12345678\\n\"\n                 \"MOV     R1, #0x80000000\\n\"\n                 \"STR     R0, [R1,#0xFFC]\\n\"\n              // \"LDR     R0, =loc_FF810000\\n\"\n                 \"MOV     R0, %0\\n\"              // new jump-vector\n                 \"LDMFD   SP!, {R4,LR}\\n\"\n                 \"BX      R0\\n\"\n                 : : \"r\"(dst_void) : \"memory\",\"r0\",\"r1\",\"r2\",\"r3\",\"r4\");\n\n        // needed in case call BX R0 \"returns\"? (note that LR is set, but to what?)\n\n        *((volatile long *) 0xC0223030) = 0x46;\n        while(1);\n}", "path": "loader\\ixus870_sd880\\resetcode\\main.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC00FB8_my()", "code": "{ //#fs \n        asm volatile (\n              //\"STR     LR, [SP,#0xFFFFFFFC]!\\n\"\n              \"STR     LR, [SP,#-4]!\\n\"         // inspired by original CHDK-code\n              \"SUB     SP, SP, #0x74\\n\"\n              \"MOV     R0, SP\\n\"\n              \"MOV     R1, #0x74\\n\"\n              \"BL      sub_FFE3B620\\n\"\n              \"MOV     R0, #0x53000\\n\"\n              \"STR     R0, [SP,#0x74-0x70]\\n\"\n        );\n//              \"LDR     R0, =0xDD024\\n\"          // 0x9d024 + 0x40000, note: 0x20000 *should* have been enough, but our code was overwritten...\n                                                // ...thus we push the memory pool a little more up (0x30000 = 192k)\n        asm volatile (\n              \"LDR     R0, =new_sa\\n\"\n              \"LDR     R0, [R0]\\n\"\n        );\n        asm volatile (\n              \"LDR     R2, =0x2ABC00\\n\"\n              \"LDR     R1, =0x2A4968\\n\"\n              \"STR     R0, [SP,#0x74-0x6C]\\n\"\n              \"SUB     R0, R1, R0\\n\"\n              \"ADD     R3, SP, #0x74-0x68\\n\"\n              \"STR     R2, [SP,#0x74-0x74]\\n\"\n              \"STMIA   R3, {R0-R2}\\n\"\n              \"MOV     R0, #0x22\\n\"\n              \"STR     R0, [SP,#0x74-0x5C]\\n\"\n              \"MOV     R0, #0x68\\n\"\n              \"STR     R0, [SP,#0x74-0x58]\\n\"\n              \"LDR     R0, =0x19B\\n\"\n              \"MOV     R1, #0x64\\n\"\n              //\"STRD     R0, [SP,#0x74-0x54]\\n\"        // \"strd not supported by cpu\" claims gcc\n              \"STR      R0, [SP,#0x74-0x54]\\n\"          // split in two single-word STRs\n              \"STR      R1, [SP,#0x74-0x50]\\n\"\n\n              \"MOV     R0, #0x78\\n\"\n              //\"STRD     R0, [SP,#0x74-0x4C]\\n\"        // \"strd not supported by cpu\" claims gcc\n              \"STR      R0, [SP,#0x74-0x4C]\\n\"          // split in two single-word STRs\n              \"STR      R1, [SP,#0x74-0x48]\\n\"\n\n              \"MOV     R0, #0\\n\"\n              \"STR     R0, [SP,#0x74-0x44]\\n\"\n              \"STR     R0, [SP,#0x74-0x40]\\n\"\n              \"MOV     R0, #0x10\\n\"\n              \"STR     R0, [SP,#0x74-0x18]\\n\"\n              \"MOV     R0, #0x800\\n\"\n              \"STR     R0, [SP,#0x74-0x14]\\n\"\n              \"MOV     R0, #0xA0\\n\"\n              \"STR     R0, [SP,#0x74-0x10]\\n\"\n              \"MOV     R0, #0x280\\n\"\n              \"STR     R0, [SP,#0x74-0x0C]\\n\"\n\n              //\"LDR     R1, =0xFFC04DBC\\n\"         // uHwSetup = 0xFFC04DBC\n              \"LDR     R1, =uHwSetup_my\\n\"         // followup to own function\n\n              \"MOV     R0, SP\\n\"\n              \"MOV     R2, #0\\n\"\n              \"BL      sub_FFC02D70\\n\"\n              \"ADD     SP, SP, #0x74\\n\"\n              \"LDR     PC, [SP],#4\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "// init\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC001a4_my()", "code": "{ //#fs \n        asm volatile (\n                \"LDR     R0, =0xFFC0021C\\n\"\n                \"MOV     R1, #0\\n\"\n                \"LDR     R3, =0xFFC00254\\n\"\n\n        \"loc_FFC001B0:\\n\"\n                \"CMP     R0, R3\\n\"\n                \"LDRCC   R2, [R0],#4\\n\"\n                \"STRCC   R2, [R1],#4\\n\"\n                \"BCC     loc_FFC001B0\\n\"\n\n                \"LDR     R0, =0xFFC00254\\n\"\n                \"MOV     R1, #0x4B0\\n\"\n                \"LDR     R3, =0xFFC00468\\n\"\n\n        \"loc_FFC001CC:\\n\"\n                \"CMP     R0, R3\\n\"\n                \"LDRCC   R2, [R0],#4\\n\"\n                \"STRCC   R2, [R1],#4\\n\"\n                \"BCC     loc_FFC001CC\\n\"\n                \"MOV     R0, #0xD2\\n\"\n                \"MSR     CPSR_cxsf, R0\\n\"\n                \"MOV     SP, #0x1000\\n\"\n                \"MOV     R0, #0xD3\\n\"\n                \"MSR     CPSR_cxsf, R0\\n\"\n                \"MOV     SP, #0x1000\\n\"\n                \"LDR     R0, =0x6C4\\n\"\n                \"LDR     R2, =0xEEEEEEEE\\n\"\n                \"MOV     R3, #0x1000\\n\"\n\n        \"loc_FFC00200:\\n\"\n                \"CMP     R0, R3\\n\"\n                \"STRCC   R2, [R0],#4\\n\"\n                \"BCC     loc_FFC00200\\n\"\n\n                //\"BL      sub_FFC00FB8\\n\"\n                \"BL      sub_FFC00FB8_my\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC5A4E8_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"BL      sub_FFC3F0CC_my\\n\"    // continue to SDHC-hook here!\n                \"LDR     R4, =0x58D0\\n\"\n                \"LDR     R0, [R4,#4]\\n\"\n                \"CMP     R0, #0\\n\"\n                \"BNE     loc_FFC5A518\\n\"\n                \"BL      sub_FFC674CC\\n\"\n                \"BL      sub_FFCDCA24\\n\"\n                \"BL      sub_FFC674CC\\n\"\n                \"BL      sub_FFCE6504\\n\"\n                \"BL      sub_FFC674DC\\n\"\n                \"BL      sub_FFCDCAC4\\n\"\n                \"loc_FFC5A518:\\n\"\n                \"MOV     R0, #1\\n\"\n                \"STR     R0, [R4]\\n\"\n                \"LDMFD   SP!, {R4,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC5F410_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4-R6,LR}\\n\"\n                \"MOVS    R4, R0\\n\"\n                \"MOV     R0, #1\\n\"\n                \"MOV     R5, R1\\n\"\n                \"BNE     loc_FFC5F450\\n\"\n                \"MOV     R1, #0\\n\"\n                \"MOV     R0, #0\\n\"\n                \"BL      sub_FFC5CB88\\n\"\n                \"BL      sub_FFC1C854\\n\"\n                \"SUB     R12, R0, #0x1000\\n\"\n                \"SUBS    R12, R12, #0x5B\\n\"\n                \"BNE     loc_FFC5F448\\n\"\n        \"loc_FFC5F440:\\n\"\n                \"BL      sub_FFC5F338\\n\"\n                \"B       loc_FFC5F458\\n\"\n        \"loc_FFC5F448:\\n\"\n                \"BL      sub_FFC5F398\\n\"\n                \"B       loc_FFC5F458\\n\"\n        \"loc_FFC5F450:\\n\"\n                \"CMP     R4, #5\\n\"\n                \"BEQ     loc_FFC5F440\\n\"\n        \"loc_FFC5F458:\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDREQ   R5, =0x1162\\n\"\n                \"MOVEQ   R4, #2\\n\"\n                \"MOV     R0, R4\\n\"\n                \"MOV     R1, R5\\n\"\n                \"LDMFD   SP!, {R4-R6,LR}\\n\"\n                \"B       sub_FFC5E6C0_my\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC4CDC0_my()", "code": "{ //#fs  // CreateTask_CaptSeqTask\n        asm volatile (\n                \"STMFD   SP!, {R3-R5,LR}\\n\"\n                \"LDR     R2, =0x1921C\\n\"\n                \"MOV     R0, #0\\n\"\n                \"MOV     R1, #0\\n\"\n        \"loc_FFC4CDD0:\\n\"\n                \"ADD     R3, R2, R0,LSL#4\\n\"\n                \"ADD     R0, R0, #1\\n\"\n                \"CMP     R0, #5\\n\"\n                \"STR     R1, [R3,#8]\\n\"\n                \"BCC     loc_FFC4CDD0\\n\"\n                \"BL      sub_FFD091E8\\n\"\n                \"BL      sub_FFD0AE64\\n\"\n                \"MOV     R1, #5\\n\"\n                \"MOV     R0, #0\\n\"\n                \"BL      sub_FFC0BECC\\n\"\n                \"LDR     R4, =0x5680\\n\"\n                \"LDR     R1, =0x1001FF\\n\"\n                \"STR     R0, [R4,#8]\\n\"\n                \"MOV     R0, #0\\n\"\n                \"BL      sub_FFC0BEF0\\n\"\n                \"STR     R0, [R4,#4]\\n\"\n                \"MOV     R3, #0\\n\"\n                //\"STR     R3, [SP,#0x10+var_10]\\n\"\n                \"STR     R3, [SP]\\n\"\n                //\"LDR     R3, =0xFFC4CB64\\n\"           // task_CaptSeqTask\n                \"LDR     R3, =task_CaptSeqTask_my\\n\"            // task_CaptSeqTask\n                \"LDR     R0, =0xFFC4CECC\\n\"             // aCaptseqtask ; \"CaptSeqTask\"\n                \"MOV     R2, #0x1000\\n\"\n                \"MOV     R1, #0x17\\n\"\n                \"BL      sub_FFC0BE98\\n\"                // uKernelMiscCreateTask o. CreateTaskStrict\n                \"LDMFD   SP!, {R3-R5,PC}\\n\"\n        \".ltorg\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) task_Startup_my()", "code": "{ //#fs \n        \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"BL      sub_FFC051CC\\n\"  // uRegClockSave\n                \"BL      sub_FFC13FA8\\n\"\n                \"BL      sub_FFC10EA4\\n\"\n                \"BL      sub_FFC1B9FC\\n\"\n                \"BL      sub_FFC1BB9C\\n\"\n                //\"BL      sub_FFC1BA84\\n\"  // StartDiskboot\n        );\n\n        CreateTask_spytask();\n\n        asm volatile (\n                \"BL      sub_FFC1BD64\\n\"\n                \"BL      sub_FFC1BBEC\\n\"        \n\n                \"BL      sub_FFC18A8C\\n\"\n                \"BL      sub_FFC1BD68\\n\"\n        );\n\n        CreateTask_PhySw();\n\n        asm volatile (\n                //\"BL      sub_FFC12DAC\\n\"        // CreateTask_PhySw - checks buttons and acts accordingly\n\n                \"BL      sub_FFC15BC8_my\\n\"        // divert to intercept task_ShootSeqTask\n                \"BL      sub_FFC1BD80\\n\"\n                //\"BL      nullsub_2\\n\"\n                \"BL      sub_FFC1213C\\n\"\n                \"BL      sub_FFC1B768\\n\"\n                \"BL      sub_FFC128D8\\n\"\n                \"BL      sub_FFC12048\\n\"\n                //\"BL      sub_FFC1C6C4\\n\"\n                \"BL      sub_FFC1C6C4_my\\n\"     // divert for SDHC-bootdisk-support\n                \"BL      sub_FFC12004\\n\"\n\n                // modification: BL instead of B to last function to control action after its return\n                \"BL       sub_FFC05088\\n\"\n                \"LDMFD   SP!, {R4,PC}\\n\"        // restore stack to PC instead of LR to return to caller\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//  fe50 10-Aug-2008\n", "func_signal": "void ubasic_set_led(int led, int state, int bright)", "code": "{\n\t// \"brigth\" not implemented\n\t// YELLOW not available\n\t// TIMER -> LED_AF\n\tint leds[] = {106,12,0,103,0,12132,12132};  //  green | yellow | not used | orange | blue | af beam | timer\n\tif(led < 4 || led > 10 || led == 6) return; //  return on invalid params;  no extra TIMER LED (is same as AF)\n\tvolatile long *p=(void*)LED_PR + leds[led-4];\n\tif (state)\n\t\tp[0]=0x46;\n\telse\n\t\tp[0]=0x44;\n}", "path": "platform\\ixus860_sd870\\lib.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC4BDD8_my()", "code": "{ //#fs \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"LDR     R4, =0x5630\\n\"\n                \"LDR     R0, [R4,#8]\\n\"\n                \"CMP     R0, #0\\n\"\n                \"BNE     loc_FFC4BE44\\n\"\n                //\"BL      nullsub_30\\n\"\n                \"MOV     R1, #1\\n\"\n                \"MOV     R0, #0\\n\"\n                \"BL      sub_FFC0BF14\\n\"\n                \"STR     R0, [R4,#0x1C]\\n\"\n                \"MOV     R0, #0\\n\"\n                \"MOV     R1, #0\\n\"\n                \"BL      sub_FFC0BEF0\\n\"\n                \"STR     R0, [R4,#0x20]\\n\"\n                \"BL      sub_FFC4C1B0\\n\"\n                \"BL      sub_FFC4BFF4\\n\"   // continue here for task_ShootSeqTask (this is nonsense. We just need CaptSeqTask)\n                \"MOV     R0, #0\\n\"\n                \"STR     R0, [R4,#0x18]\\n\"\n                \"ADD     R0, R4, #0x24\\n\"\n                \"MOV     R1, #0\\n\"\n                \"STR     R1, [R0],#4\\n\"\n                \"STR     R1, [R0]\\n\"\n                \"BL      sub_FFC4C554\\n\"\n                \"BL      sub_FFC500DC\\n\"\n                \"BL      sub_FFC4E4F8\\n\"\n                \"BL      sub_FFC4CDC0_my\\n\"     // continue here for task_CaptSeqTask\n                \"BL      sub_FFC4DFF4\\n\"\n        \"loc_FFC4BE44:\\n\"\n                \"MOV     R0, #1\\n\"\n                \"STR     R0, [R4,#8]\\n\"\n                \"LDMFD   SP!, {R4,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC1C294_my()", "code": "{ //#fs  \n        asm volatile (\n                //\"B sub_FFC1C294\\n\" // test: branch to original function\n                \"STMFD   SP!, {R3-R11,LR}\\n\"\n                \"LDR     R6, =0x1DCC\\n\"\n                \"MOV     R5, R3\\n\"\n                \"LDR     R0, [R6,#0x14]\\n\"\n                \"MOV     R4, R1\\n\"\n                \"CMP     R0, #1\\n\"\n                \"BNE     loc_FFC1C2B8\\n\"\n                \"BL      sub_FFC5D36C\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C2B8:\\n\"\n                \"LDR     R11, =0x1167\\n\"\n                \"MOV     R7, #0\\n\"\n                \"SUB     R12, R11, #5\\n\"\n                \"CMP     R4, R12\\n\"\n                \"MOV     R9, #1\\n\"\n                \"BEQ     loc_FFC1C5EC\\n\"\n                \"BGT     loc_FFC1C3E8\\n\"\n                \"LDR     R0, =0x1061\\n\"\n                \"ORR     R12, R0, R0,ASR#11\\n\"\n                \"CMP     R4, R12\\n\"\n                \"ADD     R1, R0, #4\\n\"\n                \"BEQ     loc_FFC1C684\\n\"\n                \"BGT     loc_FFC1C374\\n\"\n                \"LDR     R12, =0x1056\\n\"\n                \"CMP     R4, R12\\n\"\n                \"BEQ     loc_FFC1C684\\n\"\n                \"BGT     loc_FFC1C350\\n\"\n                \"SUB     R12, R4, #0x800\\n\"\n                \"SUBS    R12, R12, #3\\n\"\n                \"BEQ     loc_FFC1C508\\n\"\n                \"SUB     R12, R4, #0x800\\n\"\n                \"SUBS    R12, R12, #0x158\\n\"\n                \"BEQ     loc_FFC1C6A0\\n\"\n                \"SUB     R12, R4, #0x900\\n\"\n                \"SUBS    R12, R12, #0xA3\\n\"\n                \"SUBNE   R12, R4, #0x900\\n\"\n                \"SUBNES  R12, R12, #0xA5\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"LDR     R0, [R6,#0xC]\\n\"\n                \"SUB     R12, R0, #0x8000\\n\"\n                \"SUBS    R12, R12, #2\\n\"\n                \"BEQ     loc_FFC1C348\\n\"\n                \"LDR     R0, =0x10A5\\n\"\n                \"BL      sub_FFC5BC60\\n\"        // IsControlEventActive\n                \"CMP     R0, #0\\n\"\n                \"BEQ     loc_FFC1C6BC\\n\"\n        \"loc_FFC1C348:\\n\"\n                \"MOV     R0, #0\\n\"\n                \"LDMFD   SP!, {R3-R11,PC}\\n\"\n        \"loc_FFC1C350:\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0x5B\\n\"\n                \"SUBNE   R12, R4, #0x1000\\n\"\n                \"SUBNES  R12, R12, #0x5E\\n\"\n                \"CMPNE   R4, R0\\n\"\n                \"SUBNE   R12, R4, #0x1000\\n\"\n                \"SUBNES  R12, R12, #0x62\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"B       loc_FFC1C684\\n\"\n        \"loc_FFC1C374:\\n\"\n                \"LDR     R12, =0x10AE\\n\"\n                \"CMP     R4, R12\\n\"\n                \"BEQ     loc_FFC1C620\\n\"\n                \"BGT     loc_FFC1C3B8\\n\"\n                \"CMP     R4, R1\\n\"\n                \"BEQ     loc_FFC1C684\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"LDR     R0, =0x10A3\\n\"\n                \"SUBS    R12, R12, #0xA9\\n\"\n                \"BEQ     loc_FFC1C5FC\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0xAA\\n\"\n                \"BEQ     loc_FFC1C614\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0xAD\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"B       loc_FFC1C608\\n\"\n        \"loc_FFC1C3B8:\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0xAF\\n\"\n                \"BEQ     loc_FFC1C608\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0xB0\\n\"\n                \"BEQ     loc_FFC1C620\\n\"\n                \"SUB     R12, R4, #0x1000\\n\"\n                \"SUBS    R12, R12, #0xB2\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"LDR     R0, =0x1008\\n\"\n                \"MOV     R1, R5\\n\"\n                \"B       loc_FFC1C5E4\\n\"\n        \"loc_FFC1C3E8:\\n\"\n                \"LDR     R10, =0x201B\\n\"\n                \"LDR     R0, =0x1DCC\\n\"\n                \"CMP     R4, R10\\n\"\n                \"LDR     R2, [R0,#0x10]!\\n\"\n                \"LDR     R1, [R0,#0x10]\\n\"\n                \"SUB     R8, R10, #0x17\\n\"\n                \"BEQ     loc_FFC1C5C0\\n\"\n                \"BGT     loc_FFC1C4A4\\n\"\n                \"LDR     R10, =0x116A\\n\"\n                \"CMP     R4, R10\\n\"\n                \"BEQ     loc_FFC1C5AC\\n\"\n                \"BGT     loc_FFC1C460\\n\"\n                \"SUB     R12, R4, #0x1100\\n\"\n                \"SUBS    R12, R12, #0x63\\n\"\n                \"MOVEQ   R1, #0\\n\"\n                \"MOVEQ   R0, #0x82\\n\"\n                \"BEQ     loc_FFC1C5D8\\n\"\n                \"SUB     R12, R4, #0x1100\\n\"\n                \"SUBS    R12, R12, #0x65\\n\"\n                \"BEQ     loc_FFC1C5D0\\n\"\n                \"LDR     R5, =0x1168\\n\"\n                \"CMP     R4, R11\\n\"\n                \"CMPNE   R4, R5\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"STR     R9, [R6,#0x10]\\n\"\n                \"LDR     R6, =0x4508\\n\"\n                \"CMP     R1, #0\\n\"\n                \"BEQ     loc_FFC1C594\\n\"\n                \"BL      sub_FFC5D3A0\\n\"\n                \"B       loc_FFC1C5A0\\n\"\n        \"loc_FFC1C460:\\n\"\n                \"SUB     R12, R4, #0x2000\\n\"\n                \"SUBS    R12, R12, #2\\n\"\n                \"BEQ     loc_FFC1C650\\n\"\n                \"CMP     R4, R8\\n\"\n                \"MOV     R0, R8\\n\"\n                \"BEQ     loc_FFC1C65C\\n\"\n                \"SUB     R12, R4, #0x2000\\n\"\n                \"SUBS    R12, R12, #5\\n\"\n                \"BEQ     loc_FFC1C650\\n\"\n                \"SUB     R12, R4, #0x2000\\n\"\n                \"SUBS    R12, R12, #0x19\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"CMP     R1, #0\\n\"\n                \"BEQ     loc_FFC1C348\\n\"\n                \"CMP     R2, #0\\n\"\n                \"BNE     loc_FFC1C348\\n\"\n                \"B       loc_FFC1C698\\n\"\n        \"loc_FFC1C4A4:\\n\"\n                \"LDR     R12, =0x3111\\n\"\n                \"CMP     R4, R12\\n\"\n                \"BEQ     loc_FFC1C624\\n\"\n                \"BGT     loc_FFC1C4E4\\n\"\n                \"SUB     R12, R4, #0x2000\\n\"\n                \"SUBS    R12, R12, #0x1D\\n\"\n                \"BEQ     loc_FFC1C650\\n\"\n                \"LDR     R0, =0x2027\\n\"\n                \"CMP     R4, R0\\n\"\n                \"BEQ     loc_FFC1C62C\\n\"\n                \"SUB     R12, R4, #0x3000\\n\"\n                \"SUBS    R12, R12, #6\\n\"\n                \"SUBNE   R12, R4, #0x3000\\n\"\n                \"SUBNES  R12, R12, #0x110\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"B       loc_FFC1C624\\n\"\n        \"loc_FFC1C4E4:\\n\"\n                \"CMP     R4, #0x3140\\n\"\n                \"BEQ     loc_FFC1C678\\n\"\n                \"SUB     R12, R4, #0x3200\\n\"\n                \"SUBS    R12, R12, #1\\n\"\n                \"BEQ     loc_FFC1C6BC\\n\"\n                \"SUB     R12, R4, #0x3200\\n\"\n                \"SUBS    R12, R12, #2\\n\"\n                \"BNE     loc_FFC1C6BC\\n\"\n                \"B       loc_FFC1C624\\n\"\n        \"loc_FFC1C508:\\n\"\n                \"MOV     R4, #1\\n\"\n                \"MOV     R0, #2\\n\"\n                \"BL      sub_FFC5CBF8\\n\"\n                \"CMP     R0, #1\\n\"\n                \"MOVEQ   R4, #2\\n\"\n                \"MOV     R0, R4\\n\"\n                \"BL      sub_FFC124B4\\n\"        // uLoadTest1\n                \"CMP     R0, #0\\n\"\n                \"STRNE   R9, [R6,#0x14]\\n\"\n                \"BNE     loc_FFC1C560\\n\"\n                \"BL      sub_FFC620DC\\n\"\n                \"BL      sub_FFC600F8\\n\"\n                \"BL      sub_FFC60C54\\n\"\n                \"BL      sub_FFC5FB20\\n\"\n                \"BL      sub_FFC611F8\\n\"\n                \"CMP     R0, #0\\n\"\n                \"BEQ     loc_FFC1C568\\n\"\n                \"BL      sub_FFC1BFB8\\n\"\n                \"BL      sub_FFC6115C\\n\"\n                \"MOV     R1, R0\\n\"\n                \"MOV     R0, R11\\n\"\n                \"BL      sub_FFC5B69C\\n\"\n        \"loc_FFC1C560:\\n\"\n                \"MOV     R0, R7\\n\"\n                \"LDMFD   SP!, {R3-R11,PC}\\n\"\n        \"loc_FFC1C568:\\n\"\n                \"BL      sub_FFC16188\\n\"\n                \"CMP     R0, #1\\n\"\n                \"LDRNE   R0, =0x310B\\n\"\n                \"LDREQ   R0, =0x310C\\n\"\n                \"MOV     R1, #0\\n\"\n                \"BL      sub_FFC5B69C\\n\"\n                \"BL      sub_FFC5F474_my\\n\"        // Continue here (possibility 1) for SDHC-boot\n                \"B       loc_FFC1C560\\n\"\n        \"loc_FFC1C588:\\n\"\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC4A858\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C594:\\n\"\n                \"BL      sub_FFC6039C\\n\"\n                \"BL      sub_FFC60300\\n\"\n                \"BL      sub_FFC15EF0\\n\"\n        \"loc_FFC1C5A0:\\n\"\n                \"CMP     R4, R5\\n\"\n                \"BNE     loc_FFC1C348\\n\"\n                \"B       loc_FFC1C588\\n\"\n        \"loc_FFC1C5AC:\\n\"\n                \"MOV     R0, #1\\n\"\n                \"BL      sub_FFC5D4CC\\n\"\n                \"LDR     R0, =0x1005\\n\"\n                \"MOV     R1, R10\\n\"\n                \"B       loc_FFC1C5E4\\n\"\n        \"loc_FFC1C5C0:\\n\"\n                \"CMP     R2, #1\\n\"\n                \"BNE     loc_FFC1C624\\n\"\n                \"BL      sub_FFC5D3A0\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C5D0:\\n\"\n                \"MOV     R1, #0\\n\"\n                \"MOV     R0, #0x83\\n\"\n        \"loc_FFC1C5D8:\\n\"\n                \"BL      sub_FFC60D1C\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C5E0:\\n\"\n                \"MOV     R0, R4\\n\"\n        \"loc_FFC1C5E4:\\n\"\n                \"BL      sub_FFC5E6C0_my\\n\"        // Continue here (possibility 2) for SDHC-boot\n                \"LDMFD   SP!, {R3-R11,PC}\\n\"\n        \"loc_FFC1C5EC:\\n\"\n                \"BL      sub_FFC64100\\n\"\n                \"CMP     R0, #0\\n\"\n                \"BLNE    sub_FFC63060\\n\"\n                \"B       loc_FFC1C624\\n\"\n        \"loc_FFC1C5FC:\\n\"\n                \"BL      sub_FFC5BC60\\n\"        // IsControlEventActive\n                \"CMP     R0, #0\\n\"\n                \"BNE     loc_FFC1C348\\n\"\n        \"loc_FFC1C608:\\n\"\n                \"MOV     R0, R4\\n\"\n                \"BL      sub_FFC1C084\\n\"\n                \"LDMFD   SP!, {R3-R11,PC}\\n\"\n        \"loc_FFC1C614:\\n\"\n                \"BL      sub_FFC5BC60\\n\"        // IsControlEventActive\n                \"CMP     R0, #0\\n\"\n                \"BNE     loc_FFC1C348\\n\"\n        \"loc_FFC1C620:\\n\"\n                \"BL      sub_FFC1CAC0\\n\"\n        \"loc_FFC1C624:\\n\"\n                \"MOV     R1, R5\\n\"\n                \"B       loc_FFC1C5E0\\n\"\n        \"loc_FFC1C62C:\\n\"\n                \"MOV     R1, #0\\n\"\n                \"BL      sub_FFC5E6C0_my\\n\"        // Continue here (possibility 2) for SDHC-boot\n                \"MOV     R1, #0\\n\"\n                \"MOV     R0, R10\\n\"\n                \"BL      sub_FFC5E6C0_my\\n\"        // Continue here (possibility 2) for SDHC-boot\n                \"MOV     R1, #0\\n\"\n                \"MOV     R0, R8\\n\"\n        \"loc_FFC1C648:\\n\"\n                \"BL      sub_FFC5E6C0_my\\n\"        // Continue here (possibility 2) for SDHC-boot\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C650:\\n\"\n                \"STR     R7, [R6,#0x20]\\n\"\n                \"BL      sub_FFC1C888\\n\"\n                \"B       loc_FFC1C624\\n\"\n        \"loc_FFC1C65C:\\n\"\n                \"STR     R7, [R6,#0x20]\\n\"\n                \"BL      sub_FFC1C888\\n\"\n                \"LDR     R0, [R6,#0x10]\\n\"\n                \"CMP     R0, #1\\n\"\n                \"BNE     loc_FFC1C624\\n\"\n                \"BL      sub_FFC5D3E4\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C678:\\n\"\n                \"CMP     R1, #0\\n\"\n                \"BLEQ    sub_FFC1C888\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C684:\\n\"\n                \"CMP     R4, R0\\n\"\n                \"BEQ     loc_FFC1C698\\n\"\n                \"CMP     R4, R1\\n\"\n                \"MVNNE   R0, #0\\n\"\n                \"MOVEQ   R0, R1\\n\"\n        \"loc_FFC1C698:\\n\"\n                \"MOV     R1, #0\\n\"\n                \"B       loc_FFC1C648\\n\"\n        \"loc_FFC1C6A0:\\n\"\n                \"TST     R5, #0x80000000\\n\"\n                \"MOVNE   R0, #1\\n\"\n                \"LDMNEFD SP!, {R3-R11,PC}\\n\"\n                \"BL      sub_FFC65400\\n\"\n                \"CMP     R0, #0\\n\"\n                \"BLEQ    sub_FFC18934\\n\"\n                \"B       loc_FFC1C348\\n\"\n        \"loc_FFC1C6BC:\\n\"\n                \"MOV     R1, #0\\n\"\n                \"B       loc_FFC1C5E0\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "// Checked for the SD750 v1.02A\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFB0D94C_my(long p)", "code": "{\n    asm volatile (\n                \n\t\t\t\t\t\t\t\"STMFD   SP!, {R4,LR}\\n\"\n\t\t\t\t\t\t\t\"MOV     R4, R0\\n\"\n\t\t\t\t\t\t\t\"SUB     SP, SP, #0xC\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FFB0E3BC\\n\"\n\t\t\t\t\t\t\t\"MVN     R1, #0\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FFB1EB2C\\n\"\t\t// ClearEventFlag\n\t\t\t\t\t\t\t\"MOV     R0, #0x8A\\n\"\n\t\t\t\t\t\t\t\"ADD     R1, SP, #4\\n\"\n\t\t\t\t\t\t\t\"MOV     R2, #4\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FF81BCAC\\n\"\n\t\t\t\t\t\t\t\"TST     R0, #1\\n\"\n\t\t\t\t\t\t\t\"BEQ     loc_FFB0D98C\\n\"\n\t\t\t\t\t\t\t\"MOV     R1, #0x1D0\\n\"\n\t\t\t\t\t\t\t\"LDR     R0, =0xFFB0D7D0\\n\"\t\t// aSscaptureseq_c\n\t\t\t\t\t\t\t\"ADD     R1, R1, #2\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FFB2C1B8\\n\"\t\t// DebugAssert\n\"loc_FFB0D98C:\\n\"\n\t\t\t\t\t\t\t\"LDR     R3, =0xBE160\\n\"\n\t\t\t\t\t\t\t\"LDR     R2, =0xBE220\\n\"\n\t\t\t\t\t\t\t\"LDR     R0, [R3,#0x7C]\\n\"\n\t\t\t\t\t\t\t\"LDRSH   R1, [R2,#0xE]\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FFA44DE0\\n\"\n\t\t\t\t\t\t\t\"MOV     R0, R4\\n\"\n\t\t\t\t\t\t\t\"BL      sub_FFB0D754\\n\"\n\t\t\t\t\t\t\t\"BL      capt_seq_hook_set_nr\\n\"  // +\n\t\t\t\t\t\t\t\"LDR     R3, =0xCF78\\n\"\n\t\t\t\t\t\t\t\"LDR     R0, [R3]\\n\"\n\t\t\t\t\t\t\t\"B       sub_FFB0D9B0\\n\"\n    );\n}", "path": "platform\\ixus75_sd750\\sub\\102a\\capt_seq.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "// -----------------\n// SDHC-Boot-Support\n// -----------------\n// Required subs:\n//   Startup -> FFC1C6C4 -> FFC1C294 ->           FFC5E6C0 -> uAC_Boot -> CreateTask_InitFileModules -> task_InitFileModules -> FFC5A4E8 -> FFC3F0CC -> FFC3EF08 -> FFC3EDA0\n//                           \\->FFC5F474 -> FFC5F410 ->/|\n//                   -> StartFactoryModeController =>||\n//\n// uAC_Boot:                   FFC5E06C\n// CreateTask_InitFileModules: FFC5F7A4 \n// task_InitFileModules:       FFC5F754 \n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC1C6C4_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"BL      sub_FFC5CB64\\n\"\n                \"BL      sub_FFC3A27C\\n\"    // IsFactoryMode\"\n                \"CMP     R0, #1\\n\"\n                \"BNE     loc_FFC1C6E4\\n\"\n                \"BL      sub_FFC5F8B0\\n\"\n                \"LDMFD   SP!, {R4,LR}\\n\"\n                \"B       sub_FFC3A2BC\\n\"    // StartFactoryModeController\"\n                \"loc_FFC1C6E4:\\n\"\n                \"BL      sub_FFC5E998\\n\"\n                \"LDR     R4, =0x1DCC\\n\"\n                \"LDR     R0, [R4,#4]\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDMNEFD SP!, {R4,PC}\\n\"\n                \"MOV     R1, #0\\n\"\n                \"LDR     R0, =sub_FFC1C294_my\\n\"        // continue here for SDHC-boot-support\n                \"BL      sub_FFC5AEA0\\n\"    // CreateController\"\n                \"STR     R0, [R4,#4]\\n\"\n                \"LDMFD   SP!, {R4,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC3F0CC_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4-R6,LR}\\n\"\n                \"MOV     R6, #0\\n\"\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC3EC9C\\n\"\n                \"LDR     R4, =0x11800\\n\"\n                \"MOV     R5, #0\\n\"\n                \"LDR     R0, [R4,#0x38]\\n\"\n                \"BL      sub_FFC3F664\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDREQ   R0, =0x2BA0\\n\"\n                \"STREQ   R5, [R0,#0xC]\\n\"\n                \"STREQ   R5, [R0,#0x10]\\n\"\n                \"STREQ   R5, [R0,#0x14]\\n\"\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC3ECDC\\n\"        // uMounter (u=unknown, just to prevent misunderstandings)\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC3EF08_my\\n\"    // continue to SDHC-hook here!\n                \"MOV     R5, R0\\n\"\n                \"MOV     R0, R6\\n\"\n                \"BL      sub_FFC3EF74\\n\"\n                \"LDR     R1, [R4,#0x3C]\\n\"\n                \"AND     R2, R5, R0\\n\"\n                \"CMP     R1, #0\\n\"\n                \"MOV     R0, #0\\n\"\n                \"MOVEQ   R0, #0x80000001\\n\"\n                \"BEQ     loc_FFC3F160\\n\"\n                \"LDR     R3, [R4,#0x2C]\\n\"\n                \"CMP     R3, #2\\n\"\n                \"MOVEQ   R0, #4\\n\"\n                \"CMP     R1, #5\\n\"\n                \"ORRNE   R0, R0, #1\\n\"\n                \"BICEQ   R0, R0, #1\\n\"\n                \"CMP     R2, #0\\n\"\n                \"BICEQ   R0, R0, #2\\n\"\n                \"ORREQ   R0, R0, #0x80000000\\n\"\n                \"BICNE   R0, R0, #0x80000000\\n\"\n                \"ORRNE   R0, R0, #2\\n\"\n        \"loc_FFC3F160:\\n\"\n                \"STR     R0, [R4,#0x40]\\n\"\n                \"LDMFD   SP!, {R4-R6,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC5F7A4_my()", "code": "{ //#fs  CreateTask_InitFileModules\n        asm volatile (\n                \"LDR     R0, =0x5AB4\\n\"\n                \"STMFD   SP!, {R3,LR}\\n\"\n                \"LDR     R1, [R0,#4]\\n\"\n                \"CMP     R1, #0\\n\"\n                \"BNE     locret_FFC5F7DC\\n\"\n                \"MOV     R1, #1\\n\"\n                \"STR     R1, [R0,#4]\\n\"\n                \"MOV     R3, #0\\n\"\n                \"STR     R3, [SP]\\n\"\n                \"LDR     R3, =task_InitFileModules_my\\n\"        // continue for SDHC-boot (orig: FFC5F754)\n                \"MOV     R1, #0x19\\n\"\n                \"LDR     R0, =0xFFC5F908\\n\"     // aInitfilemodule ; \"InitFileModules\"\n                \"MOV     R2, #0x1000\\n\"\n                \"BL      sub_FFC0BBC0\\n\"         // CreateTask, 0xFFC0BBC0\n        \"locret_FFC5F7DC:\\n\"\n                \"LDMFD   SP!, {R12,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC15BC8_my()", "code": "{ //#fs \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"LDR     R4, =0x1CB8\\n\"\n                \"MOV     R0, #0\\n\"\n                \"MOV     R1, #4\\n\"\n                \"STR     R0, [R4,#8]\\n\"\n                \"BL      sub_FFC0BEF0\\n\"\n                \"STR     R0, [R4]\\n\"\n                \"MOV     R0, #0\\n\"\n                \"MOV     R1, #1\\n\"\n                \"BL      sub_FFC0BF14\\n\"\n                \"STR     R0, [R4,#4]\\n\"\n                \"BL      sub_FFC4FC68\\n\"\n                \"BL      sub_FFC4EB50\\n\"\n                \"BL      sub_FFC4BDD8_my\\n\"     // divert this for ShootSeqTask\n                \"BL      sub_FFC4FF30\\n\"\n                \"LDR     R0, [R4]\\n\"\n                \"LDMFD   SP!, {R4,LR}\\n\"\n                \"MOV     R1, #0x1000\\n\"\n                \"B       sub_FFC18DEC\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "// strerror exists on vxworks cams, \n// but it does about the same thing as this\n", "func_signal": "const char *strerror(int en)", "code": "{\n#if !CAM_DRYOS\n    static char msg[20];\n    sprintf(msg,\"errno 0x%X\",en);\n    return msg;\n#else\n    return \"error\";\n#endif\n}", "path": "platform\\generic\\wrappers.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) task_InitFileModules_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4-R6,LR}\\n\"\n                \"BL      sub_FFC5A4BC\\n\"\n                \"LDR     R5, =0x5006\\n\"\n                \"MOVS    R4, R0\\n\"\n                \"MOVNE   R1, #0\\n\"\n                \"MOVNE   R0, R5\\n\"\n                \"BLNE    sub_FFC5B69C\\n\"\n                \"BL      sub_FFC5A4E8_my\\n\"    // continue to SDHC-hook here!\n\n                \"BL      core_spytask_can_start\\n\"      // CHDK: Set \"it's-save-to-start\"-Flag for spytask\n\n                \"CMP     R4, #0\\n\"\n                \"MOVEQ   R0, R5\\n\"\n                \"LDMEQFD SP!, {R4-R6,LR}\\n\"\n                \"MOVEQ   R1, #0\\n\"\n                \"BEQ     sub_FFC5B69C\\n\"        // cameralog \"LogicalEvent...\", it's save to run this after spytask has started\n                \"LDMFD   SP!, {R4-R6,PC}\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "/*************************************************************/\n", "func_signal": "void __attribute__((naked,noinline)) exp_drv_task()", "code": "{\n asm volatile(\n                 \"STMFD   SP!, {R4-R8,LR}\\n\"\n                 \"SUB     SP, SP, #0x20\\n\"\n                 \"ADD     R7, SP, #4\\n\"\n                 \"B       loc_FF96AD00\\n\"\n \"loc_FF96A800:\\n\"\n                 \"CMP     R2, #0x22\\n\"\n                 \"BNE     loc_FF96A818\\n\"\n                 \"LDR     R0, [R12,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R12,#0x88]\\n\"\n                 \"B       loc_FF96A87C\\n\"\n \"loc_FF96A818:\\n\"\n                 \"CMP     R2, #0x1D\\n\"\n                 \"BNE     loc_FF96A82C\\n\"\n                 \"MOV     R0, R12\\n\"\n                 \"BL      sub_FF96A6C0\\n\"\n                 \"B       loc_FF96A86C\\n\"\n \"loc_FF96A82C:\\n\"\n                 \"CMP     R2, #0x1E\\n\"\n                 \"BNE     loc_FF96A840\\n\"\n                 \"MOV     R0, R12\\n\"\n                 \"BL      sub_FF96A71C\\n\"\n                 \"B       loc_FF96A86C\\n\"\n \"loc_FF96A840:\\n\"\n                 \"SUB     R3, R2, #0x1F\\n\"\n                 \"CMP     R3, #1\\n\"\n                 \"BHI     loc_FF96A858\\n\"\n                 \"MOV     R0, R12\\n\"\n                 \"BL      sub_FF96A778\\n\"\n                 \"B       loc_FF96A86C\\n\"\n \"loc_FF96A858:\\n\"\n                 \"CMP     R2, #0x21\\n\"\n                 \"BNE     loc_FF96A888\\n\"\n                 \"BL      sub_FF93087C\\n\"\n                 \"BL      sub_FF9339B4\\n\"\n                 \"BL      sub_FF932BEC\\n\"\n \"loc_FF96A86C:\\n\"\n                 \"LDR     R3, [SP,#4]\\n\"\n                 \"LDR     R0, [R3,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R3,#0x88]\\n\"\n \"loc_FF96A87C:\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF9661BC\\n\"\n                 \"B       loc_FF96AD00\\n\"\n \"loc_FF96A888:\\n\"\n                 \"CMP     R2, #0xD\\n\"\n                 \"MOV     R8, #1\\n\"\n                 \"BNE     loc_FF96A8F8\\n\"\n                 \"LDR     R1, [R12,#0x7C]\\n\"\n                 \"ADD     R1, R1, R1,LSL#1\\n\"\n                 \"ADD     R1, R12, R1,LSL#2\\n\"\n                 \"ADD     R6, SP, #0x14\\n\"\n                 \"SUB     R1, R1, #8\\n\"\n                 \"MOV     R2, #0xC\\n\"\n                 \"MOV     R0, R6\\n\"\n                 \"BL      sub_FF9183F4\\n\" //memcpy\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF968C6C\\n\"\n                 \"LDR     R3, [SP,#4]\\n\"\n                 \"LDR     R1, [R3,#0x7C]\\n\"\n                 \"LDR     R2, [R3,#0x8C]\\n\"\n                 \"ADD     R0, R3, #4\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R3,#0x88]\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF968F3C\\n\"\n                 \"LDR     R3, [SP,#4]\\n\"\n                 \"ADD     R0, R3, #4\\n\"\n                 \"LDR     R1, [R3,#0x7C]\\n\"\n                 \"LDR     R2, [R3,#0x94]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R3,#0x90]\\n\"\n                 \"B       loc_FF96AC48\\n\"\n \"loc_FF96A8F8:\\n\"\n                 \"SUB     R3, R2, #0xE\\n\"\n                 \"CMP     R3, #1\\n\"\n                 \"BHI     loc_FF96A9B4\\n\"\n                 \"ADD     R6, SP, #0x14\\n\"\n                 \"ADD     R5, SP, #8\\n\"\n                 \"MOV     R0, R12\\n\"\n                 \"MOV     R1, R6\\n\"\n                 \"MOV     R2, R5\\n\"\n                 \"BL      sub_FF969030\\n\"\n                 \"MOV     R4, R0\\n\"\n                 \"CMP     R4, #5\\n\"\n                 \"CMPNE   R4, #1\\n\"\n                 \"BNE     loc_FF96A94C\\n\"\n                 \"LDR     R12, [SP,#4]\\n\"\n                 \"MOV     R0, R5\\n\"\n                 \"LDR     R1, [R12,#0x7C]\\n\"\n                 \"MOV     R2, R4\\n\"\n                 \"LDR     R3, [R12,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R12,#0x88]\\n\"\n                 \"B       loc_FF96A984\\n\"\n \"loc_FF96A94C:\\n\"\n                 \"CMP     R4, #6\\n\"\n                 \"CMPNE   R4, #2\\n\"\n                 \"BNE     loc_FF96A994\\n\"\n                 \"LDR     R12, [SP,#4]\\n\"\n                 \"MOV     R0, R5\\n\"\n                 \"MOV     R1, R8\\n\"\n                 \"MOV     R2, R4\\n\"\n                 \"LDR     R3, [R12,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R12,#0x88]\\n\"\n                 \"MOV     R1, R6\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"MOV     R2, R5\\n\"\n                 \"BL      sub_FF96A2F0\\n\"\n \"loc_FF96A984:\\n\"\n                 \"MOV     R1, R4\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF96A654\\n\"\n                 \"B       loc_FF96AC48\\n\"\n \"loc_FF96A994:\\n\"\n                 \"LDR     R12, [SP,#4]\\n\"\n                 \"MOV     R2, R4\\n\"\n                 \"ADD     R0, R12, #4\\n\"\n                 \"LDR     R1, [R12,#0x7C]\\n\"\n                 \"LDR     R3, [R12,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R12,#0x88]\\n\"\n                 \"B       loc_FF96AC48\\n\"\n \"loc_FF96A9B4:\\n\"\n                 \"SUB     R3, R2, #0x19\\n\"\n                 \"CMP     R3, #1\\n\"\n                 \"BHI     loc_FF96AA0C\\n\"\n                 \"LDR     R1, [R12,#0x7C]\\n\"\n                 \"ADD     R1, R1, R1,LSL#1\\n\"\n                 \"ADD     R1, R12, R1,LSL#2\\n\"\n                 \"ADD     R6, SP, #0x14\\n\"\n                 \"SUB     R1, R1, #8\\n\"\n                 \"MOV     R2, #0xC\\n\"\n                 \"MOV     R0, R6\\n\"\n                 \"BL      sub_FF9183F4\\n\" //memcpy\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF968120\\n\"\n                 \"LDR     R3, [SP,#4]\\n\"\n                 \"ADD     R0, R3, #4\\n\"\n                 \"LDR     R1, [R3,#0x7C]\\n\"\n                 \"LDR     R2, [R3,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R3,#0x88]\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"BL      sub_FF968440\\n\"\n                 \"B       loc_FF96AC48\\n\"\n \"loc_FF96AA0C:\\n\"\n                 \"ADD     R6, SP, #0x14\\n\"\n                 \"ADD     R1, R12, #4\\n\"\n                 \"MOV     R2, #0xC\\n\"\n                 \"MOV     R0, R6\\n\"\n                 \"BL      sub_FF9183F4\\n\" //memcpy\n                 \"LDR     R12, [SP,#4]\\n\"\n                 \"LDR     R3, [R12]\\n\"\n                 \"MOV     R2, R12\\n\"\n                 \"CMP     R3, #0x1C\\n\"\n                 \"LDRLS   PC, [PC,R3,LSL#2]\\n\"\n                 \"B       loc_FF96AC34\\n\"\n                 \".long loc_FF96AAAC\\n\" //jump table for switch statement\n                 \".long loc_FF96AAB8\\n\"\n                 \".long loc_FF96AAC4\\n\"\n                 \".long loc_FF96AAC4\\n\"\n                 \".long loc_FF96AAAC\\n\"\n                 \".long loc_FF96AAB8\\n\"\n                 \".long loc_FF96AAC4\\n\"\n                 \".long loc_FF96AAC4\\n\"\n                 \".long loc_FF96AAE8\\n\"\n                 \".long loc_FF96AAE8\\n\"\n                 \".long loc_FF96AC08\\n\"\n                 \".long loc_FF96AC14\\n\"\n                 \".long loc_FF96AC24\\n\"\n                 \".long loc_FF96AC34\\n\"\n                 \".long loc_FF96AC34\\n\"\n                 \".long loc_FF96AC34\\n\"\n                 \".long loc_FF96AAD0\\n\"\n                 \".long loc_FF96AADC\\n\"\n                 \".long loc_FF96AAF8\\n\"\n                 \".long loc_FF96AB04\\n\"\n                 \".long loc_FF96AB3C\\n\"\n                 \".long loc_FF96AB74\\n\"\n                 \".long loc_FF96ABAC\\n\"\n                 \".long loc_FF96ABE4\\n\"\n                 \".long loc_FF96ABE4\\n\"\n                 \".long loc_FF96AC34\\n\"\n                 \".long loc_FF96AC34\\n\"\n                 \".long loc_FF96ABF0\\n\"\n                 \".long loc_FF96ABFC\\n\"\n \"loc_FF96AAAC:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF966B1C\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AAB8:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF966DC0\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AAC4:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF967034\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AAD0:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF967330\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AADC:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF967598\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AAE8:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF967798_my\\n\"  //------------->\n                 \"MOV     R8, #0\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AAF8:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF9678F8\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AB04:\\n\"\n                 \"LDRH    R1, [R2,#4]\\n\"\n                 \"LDR     R3, =0x2C298\\n\"\n                 \"STRH    R1, [SP,#0x14]\\n\"\n                 \"LDRH    R1, [R3,#6]\\n\"\n                 \"STRH    R1, [SP,#0x1A]\\n\"\n                 \"LDRH    R1, [R3,#2]\\n\"\n                 \"STRH    R1, [SP,#0x16]\\n\"\n                 \"LDRH    R3, [R3,#4]\\n\"\n                 \"STRH    R3, [SP,#0x18]\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"LDRH    R2, [R2,#0xC]\\n\"\n                 \"STRH    R2, [SP,#0x1C]\\n\"\n                 \"BL      sub_FF967BF0\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AB3C:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"LDRH    R2, [R2,#4]\\n\"\n                 \"LDR     R3, =0x2C298\\n\"\n                 \"STRH    R2, [SP,#0x14]\\n\"\n                 \"LDRH    R2, [R3,#8]\\n\"\n                 \"STRH    R2, [SP,#0x1C]\\n\"\n                 \"LDRH    R1, [R3,#2]\\n\"\n                 \"STRH    R1, [SP,#0x16]\\n\"\n                 \"LDRH    R2, [R3,#4]\\n\"\n                 \"STRH    R2, [SP,#0x18]\\n\"\n                 \"LDRH    R3, [R3,#6]\\n\"\n                 \"STRH    R3, [SP,#0x1A]\\n\"\n                 \"BL      sub_FF967D18\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AB74:\\n\"\n                 \"LDR     R3, =0x2C298\\n\"\n                 \"LDRH    R1, [R3]\\n\"\n                 \"STRH    R1, [SP,#0x14]\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"LDRH    R2, [R2,#6]\\n\"\n                 \"STRH    R2, [SP,#0x16]\\n\"\n                 \"LDRH    R2, [R3,#8]\\n\"\n                 \"STRH    R2, [SP,#0x1C]\\n\"\n                 \"LDRH    R1, [R3,#4]\\n\"\n                 \"STRH    R1, [SP,#0x18]\\n\"\n                 \"LDRH    R3, [R3,#6]\\n\"\n                 \"STRH    R3, [SP,#0x1A]\\n\"\n                 \"BL      sub_FF967DDC\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96ABAC:\\n\"\n                 \"LDR     R3, =0x2C298\\n\"\n                 \"LDRH    R1, [R3,#6]\\n\"\n                 \"STRH    R1, [SP,#0x1A]\\n\"\n                 \"LDRH    R1, [R3]\\n\"\n                 \"STRH    R1, [SP,#0x14]\\n\"\n                 \"LDRH    R1, [R3,#2]\\n\"\n                 \"STRH    R1, [SP,#0x16]\\n\"\n                 \"LDRH    R3, [R3,#4]\\n\"\n                 \"STRH    R3, [SP,#0x18]\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"LDRH    R2, [R2,#0xC]\\n\"\n                 \"STRH    R2, [SP,#0x1C]\\n\"\n                 \"BL      sub_FF967E94\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96ABE4:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF967F44\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96ABF0:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF96858C\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96ABFC:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF968788\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AC08:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"BL      sub_FF968944\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AC14:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"MOV     R1, #0\\n\"\n                 \"BL      sub_FF968B2C\\n\"\n                 \"B       loc_FF96AC30\\n\"\n \"loc_FF96AC24:\\n\"\n                 \"MOV     R0, R2\\n\"\n                 \"MOV     R1, #1\\n\"\n                 \"BL      sub_FF968B2C\\n\"\n \"loc_FF96AC30:\\n\"\n                 \"LDR     R12, [SP,#4]\\n\"\n \"loc_FF96AC34:\\n\"\n                 \"ADD     R0, R12, #4\\n\"\n                 \"LDR     R1, [R12,#0x7C]\\n\"\n                 \"LDR     R2, [R12,#0x8C]\\n\"\n                 \"MOV     LR, PC\\n\"\n                 \"LDR     PC, [R12,#0x88]\\n\"\n \"loc_FF96AC48:\\n\"\n                 \"CMP     R8, #1\\n\"\n                 \"BNE     loc_FF96AC70\\n\"\n                 \"LDR     R1, [SP,#4]\\n\"\n                 \"LDR     R3, [R1,#0x7C]\\n\"\n                 \"ADD     R3, R3, R3,LSL#1\\n\"\n                 \"ADD     R1, R1, R3,LSL#2\\n\"\n                 \"MOV     R0, R6\\n\"\n                 \"SUB     R1, R1, #8\\n\"\n                 \"BL      sub_FF9667D4\\n\"\n                 \"B       loc_FF96ACEC\\n\"\n \"loc_FF96AC70:\\n\"\n                 \"LDR     R3, [SP,#4]\\n\"\n                 \"LDR     R2, [R3]\\n\"\n                 \"CMP     R2, #9\\n\"\n                 \"BNE     loc_FF96ACB8\\n\"\n                 \"MOV     R4, #0\\n\"\n                 \"MOV     R1, #1\\n\"\n                 \"MOV     R2, R1\\n\"\n                 \"MOV     R3, R1\\n\"\n                 \"MOV     R0, R4\\n\"\n                 \"STR     R4, [SP]\\n\"\n                 \"BL      sub_FF966718\\n\"\n                 \"MOV     R1, #1\\n\"\n                 \"MOV     R0, R4\\n\"\n                 \"MOV     R2, R1\\n\"\n                 \"MOV     R3, R1\\n\"\n                 \"STR     R4, [SP]\\n\"\n                 \"BL      sub_FF966970\\n\"\n                 \"B       loc_FF96ACEC\\n\"\n \"loc_FF96ACB8:\\n\"\n                 \"MOV     R4, #1\\n\"\n                 \"MOV     R0, R4\\n\"\n                 \"MOV     R1, R4\\n\"\n                 \"MOV     R2, R4\\n\"\n                 \"MOV     R3, R4\\n\"\n                 \"STR     R4, [SP]\\n\"\n                 \"BL      sub_FF966718\\n\"\n                 \"MOV     R0, R4\\n\"\n                 \"MOV     R1, R0\\n\"\n                 \"MOV     R2, R0\\n\"\n                 \"MOV     R3, R0\\n\"\n                 \"STR     R4, [SP]\\n\"\n                 \"BL      sub_FF966970\\n\"\n \"loc_FF96ACEC:\\n\"\n                 \"LDR     R2, =0x2C2E4\\n\"\n                 \"MOV     R3, #0\\n\"\n                 \"LDR     R0, [SP,#4]\\n\"\n                 \"STR     R3, [R2]\\n\"\n                 \"BL      sub_FF9661BC\\n\"\n \"loc_FF96AD00:\\n\"\n                 \"LDR     R3, =0x2C28C\\n\"\n                 \"MOV     R2, #0\\n\"\n                 \"LDR     R0, [R3]\\n\"\n                 \"MOV     R1, R7\\n\"\n                 \"BL      sub_FFB13518\\n\" //ReceiveMessageQueue\n                 \"LDR     R12, [SP,#4]\\n\"\n                 \"LDR     R2, [R12]\\n\"\n                 \"CMP     R2, #0x23\\n\"\n                 \"BNE     loc_FF96A800\\n\"\n                 \"MOV     R0, R12\\n\"\n                 \"BL      sub_FF9661BC\\n\"\n                 \"LDR     R3, =0x2C288\\n\"\n                 \"MOV     R1, #1\\n\"\n                 \"LDR     R0, [R3]\\n\"\n                 \"BL      sub_FFB12E00\\n\" //SetEventFlag\n                 \"BL      sub_FFB14ADC\\n\"\n                 \"ADD     SP, SP, #0x20\\n\"\n                 \"LDMFD   SP!, {R4-R8,PC}\\n\"\n );\n}", "path": "platform\\ixus70_sd1000\\sub\\100c\\capt_seq.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "//#fe\n", "func_signal": "void __attribute__((naked,noinline)) sub_FFC5F474_my()", "code": "{ //#fs  \n        asm volatile (\n                \"STMFD   SP!, {R4,LR}\\n\"\n                \"BL      sub_FFC1C83C\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDRNE   R0, =0x1061\\n\"\n                \"BNE     loc_FFC5F49C\\n\"\n                \"BL      sub_FFC1C824\\n\"\n                \"CMP     R0, #0\\n\"\n                \"LDRNE   R0, =0x105B\\n\"\n                \"BNE     loc_FFC5F49C\\n\"\n                \"BL      sub_FFC1C854\\n\"\n        \"loc_FFC5F49C:\\n\"\n                \"MOV     R4, R0\\n\"\n                \"BL      sub_FFC5F608\\n\"\n                \"MOV     R0, R4\\n\"\n                \"BL      sub_FFC5F6A8\\n\"\n                \"BL      sub_FFC1C854\\n\"\n                \"MOV     R4, R0\\n\"\n                \"LDR     R0, =0x5AA8\\n\"\n                \"LDR     R0, [R0]\\n\"\n                \"TST     R0, #1\\n\"\n                \"TSTEQ   R0, #0x10\\n\"\n                \"BEQ     loc_FFC5F4D4\\n\"\n        \"loc_FFC5F4C8:\\n\"\n                \"MOV     R1, R4\\n\"\n                \"MOV     R0, #2\\n\"\n                \"B       loc_FFC5F518\\n\"\n        \"loc_FFC5F4D4:\\n\"\n                \"TST     R0, #0x40\\n\"\n                \"BEQ     loc_FFC5F4E8\\n\"\n        \"loc_FFC5F4DC:\\n\"\n                \"MOV     R1, R4\\n\"\n                \"MOV     R0, #1\\n\"\n                \"B       loc_FFC5F518\\n\"\n        \"loc_FFC5F4E8:\\n\"\n                \"TST     R0, #0x20\\n\"\n                \"BEQ     loc_FFC5F504\\n\"\n                \"TST     R0, #0x4000\\n\"\n                \"BNE     loc_FFC5F504\\n\"\n        \"loc_FFC5F4F8:\\n\"\n                \"MOV     R1, R4\\n\"\n                \"MOV     R0, #0\\n\"\n                \"B       loc_FFC5F518\\n\"\n        \"loc_FFC5F504:\\n\"\n                \"LDR     R1, =0x102\\n\"\n                \"BICS    R1, R1, R0\\n\"\n                \"BNE     loc_FFC5F520\\n\"\n                \"MOV     R1, R4\\n\"\n                \"MOV     R0, #6\\n\"\n        \"loc_FFC5F518:\\n\"\n                \"LDMFD   SP!, {R4,LR}\\n\"\n                \"B       sub_FFC5F410_my\\n\"        // cont. for SDHC-boot\n        \"loc_FFC5F520:\\n\"\n                \"TST     R0, #0x100\\n\"\n                \"BNE     loc_FFC5F4C8\\n\"\n                \"TST     R0, #0x400\\n\"\n                \"BNE     loc_FFC5F4DC\\n\"\n                \"TST     R0, #0x200\\n\"\n                \"TSTEQ   R0, #2\\n\"\n                \"BNE     loc_FFC5F4F8\\n\"\n                \"TST     R0, #0x40000\\n\"\n                \"BEQ     loc_FFC5F4C8\\n\"\n                \"TST     R0, #0x200000\\n\"\n                \"MOVEQ   R1, R4\\n\"\n                \"MOVEQ   R0, #1\\n\"\n                \"BLEQ    sub_FFC5F410_my\\n\"        // cont. for SDHC-boot\n                \"B       loc_FFC5F4C8\\n\"\n        );\n}", "path": "platform\\a720\\sub\\100c\\boot.c", "repo_name": "barryk/CHDK-SD1200", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 2324}
{"docstring": "/*\n * State dispatcher.\n */\n", "func_signal": "static int\nyaml_emitter_state_machine(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    switch (emitter->state)\n    {\n        case YAML_EMIT_STREAM_START_STATE:\n            return yaml_emitter_emit_stream_start(emitter, event);\n\n        case YAML_EMIT_FIRST_DOCUMENT_START_STATE:\n            return yaml_emitter_emit_document_start(emitter, event, 1);\n\n        case YAML_EMIT_DOCUMENT_START_STATE:\n            return yaml_emitter_emit_document_start(emitter, event, 0);\n\n        case YAML_EMIT_DOCUMENT_CONTENT_STATE:\n            return yaml_emitter_emit_document_content(emitter, event);\n\n        case YAML_EMIT_DOCUMENT_END_STATE:\n            return yaml_emitter_emit_document_end(emitter, event);\n\n        case YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:\n            return yaml_emitter_emit_flow_sequence_item(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE:\n            return yaml_emitter_emit_flow_sequence_item(emitter, event, 0);\n\n        case YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:\n            return yaml_emitter_emit_flow_mapping_key(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_MAPPING_KEY_STATE:\n            return yaml_emitter_emit_flow_mapping_key(emitter, event, 0);\n\n        case YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:\n            return yaml_emitter_emit_flow_mapping_value(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_MAPPING_VALUE_STATE:\n            return yaml_emitter_emit_flow_mapping_value(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:\n            return yaml_emitter_emit_block_sequence_item(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE:\n            return yaml_emitter_emit_block_sequence_item(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:\n            return yaml_emitter_emit_block_mapping_key(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_MAPPING_KEY_STATE:\n            return yaml_emitter_emit_block_mapping_key(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:\n            return yaml_emitter_emit_block_mapping_value(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_MAPPING_VALUE_STATE:\n            return yaml_emitter_emit_block_mapping_value(emitter, event, 0);\n\n        case YAML_EMIT_END_STATE:\n            return EMITTER_ERROR_INIT(emitter,\n                    \"expected nothing after STREAM-END\");\n\n        default:\n            assert(0);      /* Invalid state. */\n    }\n\n    return 0;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Write a scalar.\n */\n", "func_signal": "static int\nyaml_emitter_process_scalar(yaml_emitter_t *emitter)", "code": "{\n    switch (emitter->scalar_data.style)\n    {\n        case YAML_PLAIN_SCALAR_STYLE:\n            return yaml_emitter_write_plain_scalar(emitter,\n                    emitter->scalar_data.value, emitter->scalar_data.length,\n                    !emitter->is_simple_key_context);\n\n        case YAML_SINGLE_QUOTED_SCALAR_STYLE:\n            return yaml_emitter_write_single_quoted_scalar(emitter,\n                    emitter->scalar_data.value, emitter->scalar_data.length,\n                    !emitter->is_simple_key_context);\n\n        case YAML_DOUBLE_QUOTED_SCALAR_STYLE:\n            return yaml_emitter_write_double_quoted_scalar(emitter,\n                    emitter->scalar_data.value, emitter->scalar_data.length,\n                    !emitter->is_simple_key_context);\n\n        case YAML_LITERAL_SCALAR_STYLE:\n            return yaml_emitter_write_literal_scalar(emitter,\n                    emitter->scalar_data.value, emitter->scalar_data.length);\n\n        case YAML_FOLDED_SCALAR_STYLE:\n            return yaml_emitter_write_folded_scalar(emitter,\n                    emitter->scalar_data.value, emitter->scalar_data.length);\n\n        default:\n            assert(0);      /* Impossible. */\n    }\n\n    return 0;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if a %TAG directive is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_tag_directive(yaml_emitter_t *emitter,\n        yaml_tag_directive_t tag_directive)", "code": "{\n    yaml_istring_t handle = ISTRING(tag_directive.handle,\n            strlen((char *)tag_directive.handle));\n    yaml_istring_t prefix = ISTRING(tag_directive.prefix,\n            strlen((char *)tag_directive.prefix));\n\n    if (!yaml_emitter_valid_utf8(emitter, handle)) {\n        return EMITTER_ERROR_INIT(emitter,\n                \"tag handle is not a valid UTF-8 string\");\n    }\n\n    if (!yaml_emitter_valid_utf8(emitter, prefix)) {\n        return EMITTER_ERROR_INIT(emitter,\n                \"tag prefix is not a valid UTF-8 string\");\n    }\n\n    if (!handle.length) {\n        return EMITTER_ERROR_INIT(emitter, \"tag handle must not be empty\");\n    }\n\n    if (handle.buffer[0] != '!') {\n        return EMITTER_ERROR_INIT(emitter, \"tag handle must start with '!'\");\n    }\n\n    if (handle.buffer[handle.length-1] != '!') {\n        return EMITTER_ERROR_INIT(emitter, \"tag handle must end with '!'\");\n    }\n\n    handle.pointer ++;\n\n    while (handle.pointer < handle.length-1) {\n        if (!IS_ALPHA(handle)) {\n            return EMITTER_ERROR_INIT(emitter,\n                    \"tag handle must contain alphanumerical characters only\");\n        }\n        MOVE(handle);\n    }\n\n    if (!prefix.length) {\n        return EMITTER_ERROR_INIT(emitter, \"tag prefix must not be empty\");\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Emit an event.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_emitter_emit_event(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!ENQUEUE(emitter, emitter->events, *event)) {\n        yaml_event_destroy(event);\n        return 0;\n    }\n\n    while (!yaml_emitter_need_more_events(emitter)) {\n        if (!yaml_emitter_analyze_event(emitter,\n                    emitter->events.list + emitter->events.head))\n            return 0;\n        if (!yaml_emitter_state_machine(emitter,\n                    emitter->events.list + emitter->events.head))\n            return 0;\n        yaml_event_destroy(&DEQUEUE(emitter, emitter->events));\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if the next events represent an empty sequence.\n */\n", "func_signal": "static int\nyaml_emitter_check_empty_sequence(yaml_emitter_t *emitter)", "code": "{\n    if (emitter->events.tail - emitter->events.head < 2)\n        return 0;\n\n    return (emitter->events.list[emitter->events.head].type\n                            == YAML_SEQUENCE_START_EVENT &&\n            emitter->events.list[emitter->events.head+1].type\n                            == YAML_SEQUENCE_END_EVENT);\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if an anchor is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_anchor(yaml_emitter_t *emitter,\n        yaml_char_t *anchor, int is_alias)", "code": "{\n    yaml_istring_t string = ISTRING(anchor, strlen((char *)anchor));\n\n    if (!yaml_emitter_valid_utf8(emitter, string)) {\n        return EMITTER_ERROR_INIT(emitter, is_alias ?\n                \"alias value is not a valid UTF-8 string\" :\n                \"anchor value is not a valid UTF-8 string\");\n    }\n\n    if (!string.length) {\n        return EMITTER_ERROR_INIT(emitter, is_alias ?\n                \"alias value must not be empty\" :\n                \"anchor value must not be empty\");\n    }\n\n    while (string.pointer < string.length) {\n        if (!IS_ALPHA(string)) {\n            return EMITTER_ERROR_INIT(emitter, is_alias ?\n                    \"alias value must contain alphanumerical characters only\" :\n                    \"anchor value must contain alphanumerical characters only\");\n        }\n        MOVE(string);\n    }\n\n    emitter->anchor_data.anchor = string.buffer;\n    emitter->anchor_data.anchor_length = string.length;\n    emitter->anchor_data.is_alias = is_alias;\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect the root node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_document_content(yaml_emitter_t *emitter,\n        yaml_event_t *event)", "code": "{\n    if (!PUSH(emitter, emitter->states, YAML_EMIT_DOCUMENT_END_STATE))\n        return 0;\n\n    return yaml_emitter_emit_node(emitter, event, 1, 0, 0, 0);\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Append a directive to the directives stack.\n */\n", "func_signal": "static int\nyaml_emitter_append_tag_directive(yaml_emitter_t *emitter,\n        yaml_tag_directive_t value, int allow_duplicates)", "code": "{\n    int idx;\n    yaml_tag_directive_t copy = { NULL, NULL };\n\n    for (idx = 0; idx < emitter->tag_directives.length; idx ++) {\n        yaml_tag_directive_t *tag_directive = emitter->tag_directives.list+idx;\n        if (strcmp((char *)value.handle, (char *)tag_directive->handle) == 0) {\n            if (allow_duplicates)\n                return 1;\n            return EMITTER_ERROR_INIT(emitter, \"duplicate %TAG directive\");\n        }\n    }\n\n    copy.handle = yaml_strdup(value.handle);\n    copy.prefix = yaml_strdup(value.prefix);\n    if (!copy.handle || !copy.prefix) {\n        MEMORY_ERROR_INIT(emitter);\n        goto error;\n    }\n\n    if (!PUSH(emitter, emitter->tag_directives, copy))\n        goto error;\n\n    return 1;\n\nerror:\n    yaml_free(copy.handle);\n    yaml_free(copy.prefix);\n    return 0;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect DOCUMENT-START or STREAM-END.\n */\n", "func_signal": "static int\nyaml_emitter_emit_document_start(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (event->type == YAML_DOCUMENT_START_EVENT)\n    {\n        yaml_tag_directive_t default_tag_directives[] = {\n            {(yaml_char_t *)\"!\", (yaml_char_t *)\"!\"},\n            {(yaml_char_t *)\"!!\", (yaml_char_t *)\"tag:yaml.org,2002:\"},\n            {NULL, NULL}\n        };\n        yaml_tag_directive_t *tag_directive;\n        int is_implicit;\n        int idx;\n\n        if (event->data.document_start.version_directive) {\n            if (!yaml_emitter_analyze_version_directive(emitter,\n                        *event->data.document_start.version_directive))\n                return 0;\n        }\n\n        for (idx = 0; idx < event->data.document_start.tag_directives.length; idx++) {\n            tag_directive = event->data.document_start.tag_directives.list+idx;\n            if (!yaml_emitter_analyze_tag_directive(emitter, *tag_directive))\n                return 0;\n            if (!yaml_emitter_append_tag_directive(emitter, *tag_directive, 0))\n                return 0;\n        }\n\n        for (tag_directive = default_tag_directives;\n                tag_directive->handle; tag_directive ++) {\n            if (!yaml_emitter_append_tag_directive(emitter, *tag_directive, 1))\n                return 0;\n        }\n\n        is_implicit = event->data.document_start.is_implicit;\n        if (!first || emitter->is_canonical) {\n            is_implicit = 0;\n        }\n\n        if (event->data.document_start.version_directive) {\n            is_implicit = 0;\n            if (!yaml_emitter_write_indicator(emitter, \"%YAML\", 1, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indicator(emitter, \"1.1\", 1, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        \n        if (event->data.document_start.tag_directives.length) {\n            is_implicit = 0;\n            for (idx = 0; idx < event->data.document_start.tag_directives.length;\n                    idx++) {\n                tag_directive = event->data.document_start.tag_directives.list+idx;\n                if (!yaml_emitter_write_indicator(emitter, \"%TAG\", 1, 0, 0))\n                    return 0;\n                if (!yaml_emitter_write_tag_handle(emitter, tag_directive->handle,\n                            strlen((char *)tag_directive->handle)))\n                    return 0;\n                if (!yaml_emitter_write_tag_content(emitter, tag_directive->prefix,\n                            strlen((char *)tag_directive->prefix), 1))\n                    return 0;\n                if (!yaml_emitter_write_indent(emitter))\n                    return 0;\n            }\n        }\n\n        if (yaml_emitter_check_empty_document(emitter)) {\n            is_implicit = 0;\n        }\n\n        if (!is_implicit) {\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n            if (!yaml_emitter_write_indicator(emitter, \"---\", 1, 0, 0))\n                return 0;\n            if (emitter->is_canonical) {\n                if (!yaml_emitter_write_indent(emitter))\n                    return 0;\n            }\n        }\n\n        emitter->state = YAML_EMIT_DOCUMENT_CONTENT_STATE;\n\n        return 1;\n    }\n\n    else if (event->type == YAML_STREAM_END_EVENT)\n    {\n        if (!yaml_emitter_flush(emitter))\n            return 0;\n\n        emitter->state = YAML_EMIT_END_STATE;\n\n        return 1;\n    }\n\n    return EMITTER_ERROR_INIT(emitter, \"expected DOCUMENT-START or STREAM-END\");\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect a block value node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_block_mapping_value(yaml_emitter_t *emitter,\n        yaml_event_t *event, int simple)", "code": "{\n    if (simple) {\n        if (!yaml_emitter_write_indicator(emitter, \":\", 0, 0, 0))\n            return 0;\n    }\n    else {\n        if (!yaml_emitter_write_indent(emitter))\n            return 0;\n        if (!yaml_emitter_write_indicator(emitter, \":\", 1, 0, 1))\n            return 0;\n    }\n    if (!PUSH(emitter, emitter->states,\n                YAML_EMIT_BLOCK_MAPPING_KEY_STATE))\n        return 0;\n\n    return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect SCALAR.\n */\n", "func_signal": "static int\nyaml_emitter_emit_scalar(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_select_scalar_style(emitter, event))\n        return 0;\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n    if (!yaml_emitter_increase_indent(emitter, 1, 0))\n        return 0;\n    if (!yaml_emitter_process_scalar(emitter))\n        return 0;\n    emitter->indent = POP(emitter, emitter->indents);\n    emitter->state = POP(emitter, emitter->states);\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if the event data is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_event(yaml_emitter_t *emitter,\n        yaml_event_t *event)", "code": "{\n    emitter->anchor_data.anchor = NULL;\n    emitter->anchor_data.anchor_length = 0;\n    emitter->tag_data.handle = NULL;\n    emitter->tag_data.handle_length = 0;\n    emitter->tag_data.suffix = NULL;\n    emitter->tag_data.suffix_length = 0;\n    emitter->scalar_data.value = NULL;\n    emitter->scalar_data.length = 0;\n\n    switch (event->type)\n    {\n        case YAML_ALIAS_EVENT:\n            if (!yaml_emitter_analyze_anchor(emitter,\n                        event->data.alias.anchor, 1))\n                return 0;\n            return 1;\n\n        case YAML_SCALAR_EVENT:\n            if (event->data.scalar.anchor) {\n                if (!yaml_emitter_analyze_anchor(emitter,\n                            event->data.scalar.anchor, 0))\n                    return 0;\n            }\n            if (event->data.scalar.tag && (emitter->is_canonical ||\n                        (!event->data.scalar.is_plain_nonspecific\n                         && !event->data.scalar.is_quoted_nonspecific))) {\n                if (!yaml_emitter_analyze_tag(emitter, event->data.scalar.tag))\n                    return 0;\n            }\n            if (!yaml_emitter_analyze_scalar(emitter,\n                        event->data.scalar.value, event->data.scalar.length))\n                return 0;\n            return 1;\n\n        case YAML_SEQUENCE_START_EVENT:\n            if (event->data.sequence_start.anchor) {\n                if (!yaml_emitter_analyze_anchor(emitter,\n                            event->data.sequence_start.anchor, 0))\n                    return 0;\n            }\n            if (event->data.sequence_start.tag && (emitter->is_canonical ||\n                        !event->data.sequence_start.is_nonspecific)) {\n                if (!yaml_emitter_analyze_tag(emitter,\n                            event->data.sequence_start.tag))\n                    return 0;\n            }\n            return 1;\n\n        case YAML_MAPPING_START_EVENT:\n            if (event->data.mapping_start.anchor) {\n                if (!yaml_emitter_analyze_anchor(emitter,\n                            event->data.mapping_start.anchor, 0))\n                    return 0;\n            }\n            if (event->data.mapping_start.tag && (emitter->is_canonical ||\n                        !event->data.mapping_start.is_nonspecific)) {\n                if (!yaml_emitter_analyze_tag(emitter,\n                            event->data.mapping_start.tag))\n                    return 0;\n            }\n            return 1;\n\n        default:\n            return 1;\n    }\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect a flow value node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_flow_mapping_value(yaml_emitter_t *emitter,\n        yaml_event_t *event, int simple)", "code": "{\n    if (simple) {\n        if (!yaml_emitter_write_indicator(emitter, \":\", 0, 0, 0))\n            return 0;\n    }\n    else {\n        if (emitter->is_canonical || emitter->column > emitter->best_width) {\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_write_indicator(emitter, \":\", 1, 0, 0))\n            return 0;\n    }\n    if (!PUSH(emitter, emitter->states, YAML_EMIT_FLOW_MAPPING_KEY_STATE))\n        return 0;\n    return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if the next events represent an empty mapping.\n */\n", "func_signal": "static int\nyaml_emitter_check_empty_mapping(yaml_emitter_t *emitter)", "code": "{\n    if (emitter->events.tail - emitter->events.head < 2)\n        return 0;\n\n    return (emitter->events.list[emitter->events.head].type\n                            == YAML_MAPPING_START_EVENT &&\n            emitter->events.list[emitter->events.head+1].type\n                            == YAML_MAPPING_END_EVENT);\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if a %YAML directive is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_version_directive(yaml_emitter_t *emitter,\n        yaml_version_directive_t version_directive)", "code": "{\n    if (version_directive.major != 1 || version_directive.minor != 1) {\n        return EMITTER_ERROR_INIT(emitter, \"incompatible %YAML directive\");\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect a flow key node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_flow_mapping_key(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (first)\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"{\", 1, 1, 0))\n            return 0;\n        if (!yaml_emitter_increase_indent(emitter, 1, 0))\n            return 0;\n        emitter->flow_level ++;\n    }\n\n    if (event->type == YAML_MAPPING_END_EVENT)\n    {\n        emitter->flow_level --;\n        emitter->indent = POP(emitter, emitter->indents);\n        if (emitter->is_canonical && !first) {\n            if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_write_indicator(emitter, \"}\", 0, 0, 0))\n            return 0;\n        emitter->state = POP(emitter, emitter->states);\n\n        return 1;\n    }\n\n    if (!first) {\n        if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n            return 0;\n    }\n    if (emitter->is_canonical || emitter->column > emitter->best_width) {\n        if (!yaml_emitter_write_indent(emitter))\n            return 0;\n    }\n\n    if (!emitter->is_canonical && yaml_emitter_check_simple_key(emitter))\n    {\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 1);\n    }\n    else\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"?\", 1, 0, 0))\n            return 0;\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_FLOW_MAPPING_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n    }\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect SEQUENCE-START.\n */\n", "func_signal": "static int\nyaml_emitter_emit_sequence_start(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n\n    if (emitter->flow_level || emitter->is_canonical\n            || event->data.sequence_start.style == YAML_FLOW_SEQUENCE_STYLE\n            || yaml_emitter_check_empty_sequence(emitter)) {\n        emitter->state = YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE;\n    }\n    else {\n        emitter->state = YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE;\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Write a tag.\n */\n", "func_signal": "static int\nyaml_emitter_process_tag(yaml_emitter_t *emitter)", "code": "{\n    if (!emitter->tag_data.handle && !emitter->tag_data.suffix)\n        return 1;\n\n    if (emitter->tag_data.handle)\n    {\n        if (!yaml_emitter_write_tag_handle(emitter, emitter->tag_data.handle,\n                    emitter->tag_data.handle_length))\n            return 0;\n        if (emitter->tag_data.suffix) {\n            if (!yaml_emitter_write_tag_content(emitter, emitter->tag_data.suffix,\n                        emitter->tag_data.suffix_length, 0))\n                return 0;\n        }\n    }\n    else\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"!<\", 1, 0, 0))\n            return 0;\n        if (!yaml_emitter_write_tag_content(emitter, emitter->tag_data.suffix,\n                    emitter->tag_data.suffix_length, 0))\n            return 0;\n        if (!yaml_emitter_write_indicator(emitter, \">\", 0, 0, 0))\n            return 0;\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Check if the next node can be expressed as a simple key.\n */\n", "func_signal": "static int\nyaml_emitter_check_simple_key(yaml_emitter_t *emitter)", "code": "{\n    yaml_event_t *event = emitter->events.list + emitter->events.head;\n    size_t length = 0;\n\n    switch (event->type)\n    {\n        case YAML_ALIAS_EVENT:\n            length += emitter->anchor_data.anchor_length;\n            break;\n\n        case YAML_SCALAR_EVENT:\n            if (emitter->scalar_data.is_multiline)\n                return 0;\n            length += emitter->anchor_data.anchor_length\n                + emitter->tag_data.handle_length\n                + emitter->tag_data.suffix_length\n                + emitter->scalar_data.length;\n            break;\n\n        case YAML_SEQUENCE_START_EVENT:\n            if (!yaml_emitter_check_empty_sequence(emitter))\n                return 0;\n            length += emitter->anchor_data.anchor_length\n                + emitter->tag_data.handle_length\n                + emitter->tag_data.suffix_length;\n            break;\n\n        case YAML_MAPPING_START_EVENT:\n            if (!yaml_emitter_check_empty_sequence(emitter))\n                return 0;\n            length += emitter->anchor_data.anchor_length\n                + emitter->tag_data.handle_length\n                + emitter->tag_data.suffix_length;\n            break;\n\n        default:\n            return 0;\n    }\n\n    if (length > 128)\n        return 0;\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * Expect MAPPING-START.\n */\n", "func_signal": "static int\nyaml_emitter_emit_mapping_start(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n\n    if (emitter->flow_level || emitter->is_canonical\n            || event->data.mapping_start.style == YAML_FLOW_MAPPING_STYLE\n            || yaml_emitter_check_empty_mapping(emitter)) {\n        emitter->state = YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE;\n    }\n    else {\n        emitter->state = YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE;\n    }\n\n    return 1;\n}", "path": "src\\emitter.c", "repo_name": "ingydotnet/libyaml-mirror", "stars": 3, "license": "mit", "language": "c", "size": 294}
{"docstring": "/*\n * These are the binary operators that are supported by the expression\n * evaluator. Note that if support for division is added then we also\n * need short-circuiting booleans because of divide-by-zero.\n */\n", "func_signal": "static int op_lt(int a, int b)", "code": "{ return (a < b); }\nstatic int op_gt(int a, int b) { return (a > b); }\nstatic int op_le(int a, int b) { return (a <= b); }\nstatic int op_ge(int a, int b) { return (a >= b); }\nstatic int op_eq(int a, int b) { return (a == b); }\nstatic int op_ne(int a, int b) { return (a != b); }\nstatic int op_or(int a, int b) { return (a || b); }\nstatic int op_and(int a, int b) { return (a && b); }\n\n/*\n * An evaluation function takes three arguments, as follows: (1) a pointer to\n * an element of the precedence table which lists the operators at the current\n * level of precedence; (2) a pointer to an integer which will receive the\n * value of the expression; and (3) a pointer to a char* that points to the\n * expression to be evaluated and that is updated to the end of the expression\n * when evaluation is complete. The function returns LT_FALSE if the value of\n * the expression is zero, LT_TRUE if it is non-zero, or LT_IF if the\n * expression could not be evaluated.\n */\nstruct ops;\n\ntypedef Linetype eval_fn(const struct ops *, int *, const char **);\n\nstatic eval_fn eval_table, eval_unary;\n\n/*\n * The precedence table. Expressions involving binary operators are evaluated\n * in a table-driven way by eval_table. When it evaluates a subexpression it\n * calls the inner function with its first argument pointing to the next\n * element of the table. Innermost expressions have special non-table-driven\n * handling.\n */\nstatic const struct ops {\n\teval_fn *inner;\n\tstruct op {\n\t\tconst char *str;\n\t\tint (*fn)(int, int);\n\t} op[5];\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Add a symbol to the symbol table.\n */\n", "func_signal": "static void\naddsym(bool ignorethis, bool definethis, char *sym)", "code": "{\n\tint symind;\n\tchar *val;\n\n\tsymind = findsym(sym);\n\tif (symind < 0) {\n\t\tif (nsyms >= MAXSYMS)\n\t\t\terrx(2, \"too many symbols\");\n\t\tsymind = nsyms++;\n\t}\n\tsymname[symind] = sym;\n\tignore[symind] = ignorethis;\n\tval = sym + (skipsym(sym) - sym);\n\tif (definethis) {\n\t\tif (*val == '=') {\n\t\t\tvalue[symind] = val+1;\n\t\t\t*val = '\\0';\n\t\t} else if (*val == '\\0')\n\t\t\tvalue[symind] = \"\";\n\t\telse\n\t\t\tusage();\n\t} else {\n\t\tif (*val != '\\0')\n\t\t\tusage();\n\t\tvalue[symind] = NULL;\n\t}\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/**\n * Initialize framebuffer\n */\n", "func_signal": "static int preinit(const char *arg)", "code": "{\n    opt_t subopts[] = {\n        {\"fb_overlay_only\", OPT_ARG_BOOL, &fb_overlay_only, NULL},\n        {\"dbl_buffer\", OPT_ARG_BOOL, &dbl_buffer, NULL},\n        {NULL}\n    };\n\n    if (subopt_parse(arg, subopts) != 0) {\n        mp_msg(MSGT_VO, MSGL_FATAL, \"[omapfb] unknown suboptions: %s\\n\", arg);\n        return -1;\n    }\n\n    getPrimaryPlaneInfo();\n    dev_fd = open(\"/dev/fb1\", O_RDWR);\n\n    if (dev_fd == -1) {\n        mp_msg(MSGT_VO, MSGL_FATAL, \"[omapfb] Error /dev/fb1\\n\");\n        return -1;\n    }\n\n    ioctl(dev_fd, FBIOGET_VSCREENINFO, &sinfo);\n    ioctl(dev_fd, OMAPFB_QUERY_PLANE, &pinfo);\n    ioctl(dev_fd, OMAPFB_QUERY_MEM, &minfo);\n\n    if (!fb_overlay_only && !vo_init())\n    {\n        mp_msg(MSGT_VO, MSGL_FATAL, \"[omapfb] Could not open X, overlay only...\\n\");        \n        fb_overlay_only = 1;\n    }\n\n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_omapfb.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Look for the symbol in the symbol table. If is is found, we return\n * the symbol table index, else we return -1.\n */\n", "func_signal": "static int\nfindsym(const char *str)", "code": "{\n\tconst char *cp;\n\tint symind;\n\n\tcp = skipsym(str);\n\tif (cp == str)\n\t\treturn (-1);\n\tif (symlist) {\n\t\tprintf(\"%.*s\\n\", (int)(cp-str), str);\n\t\t/* we don't care about the value of the symbol */\n\t\treturn (0);\n\t}\n\tfor (symind = 0; symind < nsyms; ++symind) {\n\t\tif (strlcmp(symname[symind], str, cp-str) == 0) {\n\t\t\tdebug(\"findsym %s %s\", symname[symind],\n\t\t\t    value[symind] ? value[symind] : \"\");\n\t\t\treturn (symind);\n\t\t}\n\t}\n\treturn (-1);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "//***************************************************************************\n/**\n*\n*   Sets the I2C address that we'll be communicating with, as well as whether\n*   the device uses smbus PEC (CRC).\n*/\n", "func_signal": "void I2cSetSlaveAddress( int i2cDev, I2C_Addr_t i2cAddr, int useCrc )", "code": "{\n    gI2cAddr = i2cAddr;\n    gUseCrc  = useCrc;\n\n    LogDebug( \"----- I2cSetSlaveAddress i2cAddr:0x%02x useCrc:%d -----\\n\",\n              i2cAddr, useCrc );\n\n    // Indicate which slave we wish to speak to\n\n    if ( ioctl( i2cDev, I2C_SLAVE, gI2cAddr ) < 0 )\n    {\n        LogError( \"I2cSetSlaveAddress: Error trying to set slave address to 0x%02x (%d %s)\\n\", \n                  gI2cAddr, errno, strerror( errno ));\n    }\n\n    // We do the CRC calculation ourself, so we don't need to tell the driver\n    // that we're using it.\n\n#if 0\n    // Indicate that we use PEC (aka CRCs)\n\n    if ( ioctl( i2cDev, I2C_PEC, 1 ) < 0 )\n    {\n        LogError( \"I2cSetSlaveAddress: Error trying to set PEC mode\\n\" );\n    }\n#endif\n\n}", "path": "recipes\\i2c\\files\\i2c-api.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/**\n * Function to get the offset to be used when in windowed mode\n * or when using -wid option\n */\n", "func_signal": "static void x11_get_window_abs_position(Display *display, Window window,\n                                             int *wx, int *wy, int *ww, int *wh)", "code": "{\n    Window root, parent;\n    Window *child;\n    unsigned int n_children;\n    XWindowAttributes attribs;\n\n    /* Get window attributes */\n    XGetWindowAttributes(display, window, &attribs);\n\n    /* Get relative position of given window */\n    *wx = attribs.x;\n    *wy = attribs.y;\n    if (ww)\n        *ww = attribs.width;\n    if (wh)\n        *wh = attribs.height;\n\n    /* Query window tree information */\n    XQueryTree(display, window, &root, &parent, &child, &n_children);\n    if (parent)\n    {\n      int x, y;\n      /* If we have a parent we must go there and discover his position*/\n      x11_get_window_abs_position(display, parent, &x, &y, NULL, NULL);\n      *wx += x;\n      *wy += y;\n    }\n\n    /* If we had children, free it */\n    if(n_children)\n        XFree(child);\n}", "path": "recipes\\mplayer\\files\\vo_omapfb.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Skip over an identifier.\n */\n", "func_signal": "static const char *\nskipsym(const char *cp)", "code": "{\n\twhile (!endsym(*cp))\n\t\t++cp;\n\treturn (cp);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * State machine utility functions\n */\n", "func_signal": "static void\ndone(void)", "code": "{\n\tif (incomment)\n\t\terror(\"EOF in comment\");\n\texit(exitstat);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Skip over comments, strings, and character literals and stop at the\n * next character position that is not whitespace. Between calls we keep\n * the comment state in the global variable incomment, and we also adjust\n * the global variable linestate when we see a newline.\n * XXX: doesn't cope with the buffer splitting inside a state transition.\n */\n", "func_signal": "static const char *\nskipcomment(const char *cp)", "code": "{\n\tif (text || ignoring[depth]) {\n\t\tfor (; isspace((unsigned char)*cp); cp++)\n\t\t\tif (*cp == '\\n')\n\t\t\t\tlinestate = LS_START;\n\t\treturn (cp);\n\t}\n\twhile (*cp != '\\0')\n\t\t/* don't reset to LS_START after a line continuation */\n\t\tif (strncmp(cp, \"\\\\\\n\", 2) == 0)\n\t\t\tcp += 2;\n\t\telse switch (incomment) {\n\t\tcase NO_COMMENT:\n\t\t\tif (strncmp(cp, \"/\\\\\\n\", 3) == 0) {\n\t\t\t\tincomment = STARTING_COMMENT;\n\t\t\t\tcp += 3;\n\t\t\t} else if (strncmp(cp, \"/*\", 2) == 0) {\n\t\t\t\tincomment = C_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"//\", 2) == 0) {\n\t\t\t\tincomment = CXX_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"\\'\", 1) == 0) {\n\t\t\t\tincomment = CHAR_LITERAL;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strncmp(cp, \"\\\"\", 1) == 0) {\n\t\t\t\tincomment = STRING_LITERAL;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tlinestate = LS_START;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strchr(\" \\t\", *cp) != NULL) {\n\t\t\t\tcp += 1;\n\t\t\t} else\n\t\t\t\treturn (cp);\n\t\t\tcontinue;\n\t\tcase CXX_COMMENT:\n\t\t\tif (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tlinestate = LS_START;\n\t\t\t}\n\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase CHAR_LITERAL:\n\t\tcase STRING_LITERAL:\n\t\t\tif ((incomment == CHAR_LITERAL && cp[0] == '\\'') ||\n\t\t\t    (incomment == STRING_LITERAL && cp[0] == '\\\"')) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else if (cp[0] == '\\\\') {\n\t\t\t\tif (cp[1] == '\\0')\n\t\t\t\t\tcp += 1;\n\t\t\t\telse\n\t\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tif (incomment == CHAR_LITERAL)\n\t\t\t\t\terror(\"unterminated char literal\");\n\t\t\t\telse\n\t\t\t\t\terror(\"unterminated string literal\");\n\t\t\t} else\n\t\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase C_COMMENT:\n\t\t\tif (strncmp(cp, \"*\\\\\\n\", 3) == 0) {\n\t\t\t\tincomment = FINISHING_COMMENT;\n\t\t\t\tcp += 3;\n\t\t\t} else if (strncmp(cp, \"*/\", 2) == 0) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else\n\t\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase STARTING_COMMENT:\n\t\t\tif (*cp == '*') {\n\t\t\t\tincomment = C_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else if (*cp == '/') {\n\t\t\t\tincomment = CXX_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase FINISHING_COMMENT:\n\t\t\tif (*cp == '/') {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else\n\t\t\t\tincomment = C_COMMENT;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tabort(); /* bug */\n\t\t}\n\treturn (cp);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/**************************************************************************/\n/**\n*   Dumps a page of output for debugging purposes.\n*/\n", "func_signal": "void DumpMem( const char *prefix, unsigned address, const void *inData, unsigned numBytes )", "code": "{\n    const uint8_t  *data = (const uint8_t *)inData;\n    unsigned        byteOffset;\n\n    if ( numBytes == 0 )\n    {\n        Log( \"%s: No data\\n\", prefix );\n        return;\n    }\n\n#define LINE_WIDTH  16\n\n    for ( byteOffset = 0; byteOffset < numBytes; byteOffset += LINE_WIDTH ) \n    {\n        unsigned    i;\n\n        Log( \"%s: %04x: \", prefix, address + byteOffset );\n\n        for ( i = 0; i < LINE_WIDTH; i++ ) \n        {\n            if (( byteOffset + i ) < numBytes )\n            {\n                Log( \"%02.2X \", data[ byteOffset + i ] );\n            }\n            else\n            {\n                Log( \"   \" );\n            }\n        }\n        for ( i = 0; i < LINE_WIDTH; i++ ) \n        {\n            if (( byteOffset + i ) < numBytes )\n            {\n                unsigned char ch = data[ byteOffset + i ];\n                if (( ch < ' ' ) || ( ch > '~' ))\n                {\n                    Log( \".\" );\n                }\n                else\n                {\n                    Log( \"%c\", ch );\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n        Log( \"\\n\" );\n    }\n\n}", "path": "recipes\\i2c\\files\\DumpMem.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Set up a packet.  Returns the length of the ICMP portion.\n */\n", "func_signal": "int initpacket(char *buf, int querytype, struct in_addr fromaddr)", "code": "{\n   struct ip *ip = (struct ip *)buf;\n   struct icmp *icmp = (struct icmp *)(ip + 1);\n\n   /* things we customize */\n   int icmplen = 0;\n\n   ip->ip_src = fromaddr;\t/* if 0,  have kernel fill in */\n   ip->ip_v = 4;\t\t/* Always use ipv4 for now */\n   ip->ip_hl = sizeof *ip >> 2;\n   ip->ip_tos = 0;\n   ip->ip_id = htons(4321);\n   ip->ip_ttl = 255;\n   ip->ip_p = 1;\n   ip->ip_sum = 0;                 /* kernel fills in */\n\n   icmp->icmp_seq = 1;\n   icmp->icmp_cksum = 0;\n   icmp->icmp_type = querytype;\n   icmp->icmp_code = 0;\n\n   switch(querytype) {\n   case ICMP_TSTAMP:\n\t   gettimeofday( (struct timeval *)(icmp+8), NULL);\n\t   bzero( icmp+12, 8);\n\t   icmplen = 20;\n\t   break;\n   case ICMP_MASKREQ:\n\t   *((char *)(icmp+8)) = 255;\n\t   icmplen = 12;\n\t   break;\n   default:\n\t   fprintf(stderr, \"eek: unknown query type\\n\");\n\t   exit(0);\n   }\n   ip->ip_len = sizeof(struct ip) + icmplen;\n   return icmplen;\n}", "path": "recipes\\icmpquery\\files\\icmpquery.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/***************************************************************************/\n/**\n*   Thread which processes the incoming serial data.\n*/\n", "func_signal": "void *ReaderThread( void *param )", "code": "{\n    while ( 1 )\n    {\n        char    ch;\n        int     bytesRead;\n\n        if (( bytesRead  = read( gPortFd, &ch, 1 )) < 0 )\n        {\n            fprintf( stderr, \"Serial port read failed: %s\\n\", strerror( errno ));\n            exit( 1 );\n        }\n\n        if ( gDebug )\n        {\n            if (( ch < ' ' ) || ( ch > '~' ))\n            {\n                fprintf( stderr, \"Serial Read: 0x%02x '.'\\n\", ch );\n            }\n            else\n            {\n                fprintf( stderr, \"Serial Read: 0x%02x '%c'\\n\", ch, ch );\n            }\n\n        }\n\n        putc( ch, stdout );\n    }\n\n    return 0;\n\n}", "path": "recipes\\robostix-utils\\robostix-sertest\\sertest.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/* report an error */\n", "func_signal": "static void Eelif (void)", "code": "{ error(\"Inappropriate #elif\"); }\nstatic void Eelse (void) { error(\"Inappropriate #else\"); }\nstatic void Eendif(void) { error(\"Inappropriate #endif\"); }\nstatic void Eeof  (void) { error(\"Premature EOF\"); }\nstatic void Eioccc(void) { error(\"Obfuscated preprocessor control line\"); }\n/* plain line handling */\nstatic void print (void) { flushline(true); }\nstatic void drop  (void) { flushline(false); }\n/* output lacks group's start line */\nstatic void Strue (void) { drop();  ignoreoff(); state(IS_TRUE_PREFIX); }\nstatic void Sfalse(void) { drop();  ignoreoff(); state(IS_FALSE_PREFIX); }\nstatic void Selse (void) { drop();               state(IS_TRUE_ELSE); }\n/* print/pass this block */\nstatic void Pelif (void) { print(); ignoreoff(); state(IS_PASS_MIDDLE); }\nstatic void Pelse (void) { print();              state(IS_PASS_ELSE); }\nstatic void Pendif(void) { print(); unnest(); }\n/* discard this block */\nstatic void Dfalse(void) { drop();  ignoreoff(); state(IS_FALSE_TRAILER); }\nstatic void Delif (void) { drop();  ignoreoff(); state(IS_FALSE_MIDDLE); }\nstatic void Delse (void) { drop();               state(IS_FALSE_ELSE); }\nstatic void Dendif(void) { drop();  unnest(); }\n/* first line of group */\nstatic void Fdrop (void) { nest();  Dfalse(); }\nstatic void Fpass (void) { nest();  Pelif(); }\nstatic void Ftrue (void) { nest();  Strue(); }\nstatic void Ffalse(void) { nest();  Sfalse(); }\n/* variable pedantry for obfuscated lines */\nstatic void Oiffy (void) { if (!iocccok) Eioccc(); Fpass(); ignoreon(); }\nstatic void Oif   (void) { if (!iocccok) Eioccc(); Fpass(); }\nstatic void Oelif (void) { if (!iocccok) Eioccc(); Pelif(); }\n/* ignore comments in this block */\nstatic void Idrop (void) { Fdrop();  ignoreon(); }\nstatic void Itrue (void) { Ftrue();  ignoreon(); }\nstatic void Ifalse(void) { Ffalse(); ignoreon(); }\n/* edit this line */\nstatic void Mpass (void) { strncpy(keyword, \"if  \", 4); Pelif(); }\nstatic void Mtrue (void) { keywordedit(\"else\\n\");  state(IS_TRUE_MIDDLE); }\nstatic void Melif (void) { keywordedit(\"endif\\n\"); state(IS_FALSE_TRAILER); }\nstatic void Melse (void) { keywordedit(\"endif\\n\"); state(IS_FALSE_ELSE); }\n\nstatic state_fn * const trans_table[IS_COUNT][LT_COUNT] = {\n/* IS_OUTSIDE */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Eendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eendif,\n  print, done },\n/* IS_FALSE_PREFIX */\n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Strue, Sfalse,Selse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Eioccc,Eioccc,Eioccc,Eioccc,\n  drop,  Eeof },\n/* IS_TRUE_PREFIX */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Dfalse,Dfalse,Dfalse,Delse, Dendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,\n  print, Eeof },\n/* IS_PASS_MIDDLE */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Pelif, Mtrue, Delif, Pelse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Pelif, Oelif, Oelif, Pelse, Pendif,\n  print, Eeof },\n/* IS_FALSE_MIDDLE */\n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Pelif, Mtrue, Delif, Pelse, Pendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,\n  drop,  Eeof },\n/* IS_TRUE_MIDDLE */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Melif, Melif, Melif, Melse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Pendif,\n  print, Eeof },\n/* IS_PASS_ELSE */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Pendif,\n  print, Eeof },\n/* IS_FALSE_ELSE */\n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Eioccc,\n  drop,  Eeof },\n/* IS_TRUE_ELSE */\n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Dendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eioccc,\n  print, Eeof },\n/* IS_FALSE_TRAILER */\n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Eioccc,\n  drop,  Eeof }\n/*TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF\n  TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF (DODGY)\n  PLAIN  EOF */\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/***************************************************************************\n*\n*  Usage\n*\n****************************************************************************/\n", "func_signal": "void Usage()", "code": "{\n    fprintf( stderr, \"Usage: sertest [option(s)]\\n\" );\n    fprintf( stderr, \"  Download a program via serial/i2c\\n\" );\n    fprintf( stderr, \"\\n\" );\n    fprintf( stderr, \"  -b, --baud=baud   Set the baudrate used\\n\" );\n    fprintf( stderr, \"  -d, --debug       Turn on debug output\\n\" );\n    fprintf( stderr, \"  -h, --help        Display this message\\n\" );\n    fprintf( stderr, \"  -p, --port=port   Set the I/O port\\n\" );\n    fprintf( stderr, \"  -v, --verbose     Turn on verbose messages\\n\" );\n\n}", "path": "recipes\\robostix-utils\\robostix-sertest\\sertest.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Function for evaluating the innermost parts of expressions,\n * viz. !expr (expr) defined(symbol) symbol number\n * We reset the keepthis flag when we find a non-constant subexpression.\n */\n", "func_signal": "static Linetype\neval_unary(const struct ops *ops, int *valp, const char **cpp)", "code": "{\n\tconst char *cp;\n\tchar *ep;\n\tint sym;\n\n\tcp = skipcomment(*cpp);\n\tif (*cp == '!') {\n\t\tdebug(\"eval%d !\", ops - eval_ops);\n\t\tcp++;\n\t\tif (eval_unary(ops, valp, &cp) == LT_IF)\n\t\t\treturn (LT_IF);\n\t\t*valp = !*valp;\n\t} else if (*cp == '(') {\n\t\tcp++;\n\t\tdebug(\"eval%d (\", ops - eval_ops);\n\t\tif (eval_table(eval_ops, valp, &cp) == LT_IF)\n\t\t\treturn (LT_IF);\n\t\tcp = skipcomment(cp);\n\t\tif (*cp++ != ')')\n\t\t\treturn (LT_IF);\n\t} else if (isdigit((unsigned char)*cp)) {\n\t\tdebug(\"eval%d number\", ops - eval_ops);\n\t\t*valp = strtol(cp, &ep, 0);\n\t\tcp = skipsym(cp);\n\t} else if (strncmp(cp, \"defined\", 7) == 0 && endsym(cp[7])) {\n\t\tcp = skipcomment(cp+7);\n\t\tdebug(\"eval%d defined\", ops - eval_ops);\n\t\tif (*cp++ != '(')\n\t\t\treturn (LT_IF);\n\t\tcp = skipcomment(cp);\n\t\tsym = findsym(cp);\n\t\tif (sym < 0)\n\t\t\treturn (LT_IF);\n\t\t*valp = (value[sym] != NULL);\n\t\tcp = skipsym(cp);\n\t\tcp = skipcomment(cp);\n\t\tif (*cp++ != ')')\n\t\t\treturn (LT_IF);\n\t\tkeepthis = false;\n\t} else if (!endsym(*cp)) {\n\t\tdebug(\"eval%d symbol\", ops - eval_ops);\n\t\tsym = findsym(cp);\n\t\tif (sym < 0)\n\t\t\treturn (LT_IF);\n\t\tif (value[sym] == NULL)\n\t\t\t*valp = 0;\n\t\telse {\n\t\t\t*valp = strtol(value[sym], &ep, 0);\n\t\t\tif (*ep != '\\0' || ep == value[sym])\n\t\t\t\treturn (LT_IF);\n\t\t}\n\t\tcp = skipsym(cp);\n\t\tkeepthis = false;\n\t} else {\n\t\tdebug(\"eval%d bad expr\", ops - eval_ops);\n\t\treturn (LT_IF);\n\t}\n\n\t*cpp = cp;\n\tdebug(\"eval%d = %d\", ops - eval_ops, *valp);\n\treturn (*valp ? LT_TRUE : LT_FALSE);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/***************************************************************************\n*\n*  main\n*\n****************************************************************************/\n", "func_signal": "int main( int argc, char **argv )", "code": "{\n    int         rc;\n    int         opt;\n    char        devName[ 40 ];\n    const char *baudStr = NULL;\n    const char *portStr = \"ttyS2\";\n    speed_t     baudRate;\n    pthread_t   readerThreadId;\n\n    struct termios attr;\n\n    // Parse the command line options\n\n    while (( opt = getopt_long( argc, argv, \"b:dhp:v\", gLongOption, NULL )) > 0 )\n    {\n        switch ( opt )\n        {\n            case 'b':\n            {\n                baudStr = optarg;\n                break;\n            }\n\n            case 'd':\n            {\n                gDebug = 1;\n                break;\n            }\n\n            case 'p':\n            {\n                portStr = optarg;\n                break;\n            }\n\n            case 'v':\n            {\n                gVerbose = 1;\n                break;\n            }\n            case '?':\n            case 'h':\n            {\n                Usage();\n                return 1;\n            }\n        }\n    }\n\n    devName[ 0 ] = '\\0';\n    if ( portStr[ 0 ] != '/' )\n    {\n        StrMaxCpy( devName, \"/dev/\", sizeof( devName ));\n    }\n    StrMaxCat( devName, portStr, sizeof( devName ));\n\n\n    baudRate = B0;\n    if ( baudStr == NULL )\n    {\n        baudRate = B9600;\n    }\n    else\n    {\n        int baudIdx;\n        int testBaud = atoi( baudStr );\n\n        for ( baudIdx = 0; baudIdx < ARRAY_LEN( gBaudTable ); baudIdx++ ) \n        {\n            if ( gBaudTable[ baudIdx ].baudRate == testBaud )\n            {\n                baudRate = gBaudTable[ baudIdx ].speed;\n                break;\n            }\n        }\n\n        if ( baudRate == B0 )\n        {\n            fprintf( stderr, \"Unrecognized baud rate: '%s'\\n\", baudStr );\n            exit( 1 );\n        }\n    }\n\n    if (( gPortFd = open( devName, O_RDWR | O_EXCL )) < 0 )\n    {\n        fprintf( stderr, \"Unable to open serial port '%s': %s\\n\", devName, strerror( errno ));\n        exit( 2 );\n    }\n\n    if ( tcgetattr( gPortFd, &attr ) < 0 )\n    {\n        fprintf( stderr, \"Call to tcgetattr failed: %s\\n\", strerror( errno ));\n        exit( 3 );\n    }\n\n    attr.c_iflag = 0;\n    attr.c_oflag = 0;\n    attr.c_cflag = CLOCAL | CREAD | CS8;\n    attr.c_lflag = 0;\n    attr.c_cc[ VTIME ] = 0; // timeout in tenths of a second\n    attr.c_cc[ VMIN ] = 1;  // Only wait for a single char\n\n    cfsetispeed( &attr, baudRate );\n    cfsetospeed( &attr, baudRate );\n\n    if ( tcsetattr( gPortFd, TCSAFLUSH, &attr ) < 0 )\n    {\n        fprintf( stderr, \"Call to tcsetattr failed: %s\\n\", strerror( errno ));\n        exit( 4 );\n    }\n\n    // Put stdin & stdout in unbuffered mode.\n\n    setbuf( stdin, NULL );\n    setbuf( stdout, NULL );\n\n    // Put stdin in raw mode (i.e. turn off canonical mode). Canonical mode\n    // causes the driver to wait for the RETURN character so that line editing\n    // can take place. We also want to turn off ECHO.\n\n    {\n        struct termios tio;\n\n        if ( tcgetattr( fileno( stdin ), &tio ) < 0 )\n        {\n            fprintf( stderr, \"Unable to retrieve terminal settings: %s\\n\", strerror( errno ));\n            exit( 5 );\n        }\n\n        tio.c_lflag &= ~( ICANON | ECHO );\n        tio.c_cc[VTIME] = 0;\n        tio.c_cc[VMIN] = 1;\n\n        if ( tcsetattr( fileno( stdin ), TCSANOW, &tio ) < 0 )\n        {\n            fprintf( stderr, \"Unable to update terminal settings: %s\\n\", strerror( errno ));\n            exit( 6 );\n        }\n    }\n\n    // Kick off the serial port reader thread.\n\n    rc = pthread_create( &readerThreadId, NULL, ReaderThread, NULL );\n    if ( rc != 0 )\n    {\n        fprintf( stderr, \"Error creating ReaderThread: %s\\n\", strerror( rc ));\n        exit( 7 );\n    }\n\n    // Read stdin and send rcvd chars to the serial port\n\n    while ( 1 )\n    {\n        char    ch;\n        int     chInt = fgetc( stdin );\n        if ( chInt < 0 )\n        {\n            fprintf( stderr, \"Exiting...\\n\" );\n            break;\n        }\n        ch = (char)chInt;\n\n        if ( gDebug )\n        {\n            if (( ch < ' ' ) || ( ch > '~' ))\n            {\n                fprintf( stderr, \"stdin Read: 0x%02x '.'\\n\", ch );\n            }\n            else\n            {\n                fprintf( stderr, \"stdin Read: 0x%02x '%c'\\n\", ch, ch );\n            }\n\n        }\n\n        if ( write( gPortFd, &ch, 1 ) != 1 )\n        {\n            fprintf( stderr, \"write to serial port failed: %s\\n\", strerror( errno ));\n            break;\n        }\n    }\n\n\n    close( gPortFd );\n\n    exit( 0 );\n    return 0;   // Get rid of warning about not returning anything\n}", "path": "recipes\\robostix-utils\\robostix-sertest\\sertest.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*  device table entries take the form of:\n    <path>\t<type> <mode>\t<uid>\t<gid>\t<major>\t<minor>\t<start>\t<inc>\t<count>\n    /dev/mem    c      640      0       0       1       1       0        0        -\n\n    type can be one of: \n\tf\tA regular file\n\td\tDirectory\n\tc\tCharacter special device file\n\tb\tBlock special device file\n\tp\tFifo (named pipe)\n\n    I don't bother with symlinks (permissions are irrelevant), hard\n    links (special cases of regular files), or sockets (why bother).\n\n    Regular files must exist in the target root directory.  If a char,\n    block, fifo, or directory does not exist, it will be created.\n*/\n", "func_signal": "static int interpret_table_entry(char *line)", "code": "{\n\tchar *name;\n\tchar path[4096], type;\n\tunsigned long mode = 0755, uid = 0, gid = 0, major = 0, minor = 0;\n\tunsigned long start = 0, increment = 1, count = 0;\n\n\tif (0 > sscanf(line, \"%40s %c %lo %lu %lu %lu %lu %lu %lu %lu\", path,\n\t\t    &type, &mode, &uid, &gid, &major, &minor, &start,\n\t\t    &increment, &count)) \n\t{\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(path, \"/\")) {\n\t\terror_msg_and_die(\"Device table entries require absolute paths\");\n\t}\n\tname = xstrdup(path + 1);\n\tsprintf(path, \"%s/%s\\0\", rootdir, name);\n\n\tswitch (type) {\n\tcase 'd':\n\t\tmode |= S_IFDIR;\n\t\tadd_new_directory(name, path, uid, gid, mode);\n\t\tbreak;\n\tcase 'f':\n\t\tmode |= S_IFREG;\n\t\tadd_new_file(name, path, uid, gid, mode);\n\t\tbreak;\n\tcase 'p':\n\t\tmode |= S_IFIFO;\n\t\tadd_new_fifo(name, path, uid, gid, mode);\n\t\tbreak;\n\tcase 'c':\n\tcase 'b':\n\t\tmode |= (type == 'c') ? S_IFCHR : S_IFBLK;\n\t\tif (count > 0) {\n\t\t\tint i;\n\t\t\tdev_t rdev;\n\t\t\tchar buf[80];\n\n\t\t\tfor (i = start; i < count; i++) {\n\t\t\t\tsprintf(buf, \"%s%d\", name, i);\n\t\t\t\t/* FIXME:  MKDEV uses illicit insider knowledge of kernel \n\t\t\t\t * major/minor representation...  */\n\t\t\t\trdev = MKDEV(major, minor + (i * increment - start));\n\t\t\t\tadd_new_device(buf, path, uid, gid, mode, rdev);\n\t\t\t}\n\t\t} else {\n\t\t\t/* FIXME:  MKDEV uses illicit insider knowledge of kernel \n\t\t\t * major/minor representation...  */\n\t\t\tdev_t rdev = MKDEV(major, minor);\n\n\t\t\tadd_new_device(name, path, uid, gid, mode, rdev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror_msg_and_die(\"Unsupported file type\");\n\t}\n\tif (name) free(name);\n\treturn 0;\n}", "path": "recipes\\makedevs\\makedevs-1.0.0\\makedevs.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Compare s with n characters of t.\n * The same as strncmp() except that it checks that s[n] == '\\0'.\n */\n", "func_signal": "static int\nstrlcmp(const char *s, const char *t, size_t n)", "code": "{\n\twhile (n-- && *t != '\\0')\n\t\tif (*s != *t)\n\t\t\treturn ((unsigned char)*s - (unsigned char)*t);\n\t\telse\n\t\t\t++s, ++t;\n\treturn ((unsigned char)*s);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/* argv[1] packet name\n    argv[2] upk descpription\n    argv[3] u-env image\n    argv[4] u-boot image\n    argv[5] kernel image\n    argv[5] rootfs image*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    FILE *fp_w;\n    uint32 hw_len = 0;\n    package_header_t *phd = &p_head;\n    struct stat buf;\n\n    printf(\"\\npackage tool version %s \\n\", VERSION);\n\n    strncpy((char *)phd->p_name, argv[1], NAMELEN-1);\n    if ((fp_w = fopen((char *)phd->p_name, \"wb+\")) == NULL)\n    {\n        printf(\"Can't open %s\\n\",phd->p_name);\n        return(-1);\n    }\n\n    /* packet firmware to package */\n    if (pack_firmware(fp_w, hw_len, argc - 3, &argv[3]) != 0)\n        return(-1);\n    /* packet upk_desc and version info */\n    if (pack_ver_info(fp_w, hw_len+phd->p_headsize, argv[2]) != 0)\n        return(-1);\n\n    fclose(fp_w);\n\n    stat((char *)phd->p_name, &buf);\n    if (buf.st_size > SAFE_SIZE)\n    {\n        printf(\"Warning!!!!! The upk size is larger than the safe size\\n\");\n    }\n\n    return 0;\n}", "path": "recipes\\neuros-pkggen\\files\\package.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*\n * Parse a line and determine its type. We keep the preprocessor line\n * parser state between calls in the global variable linestate, with\n * help from skipcomment().\n */\n", "func_signal": "static Linetype\nparseline(void)", "code": "{\n\tconst char *cp;\n\tint cursym;\n\tint kwlen;\n\tLinetype retval;\n\tComment_state wascomment;\n\n\tif (fgets(tline, MAXLINE, input) == NULL)\n\t\treturn (LT_EOF);\n\tretval = LT_PLAIN;\n\twascomment = incomment;\n\tcp = skipcomment(tline);\n\tif (linestate == LS_START) {\n\t\tif (*cp == '#') {\n\t\t\tlinestate = LS_HASH;\n\t\t\tcp = skipcomment(cp + 1);\n\t\t} else if (*cp != '\\0')\n\t\t\tlinestate = LS_DIRTY;\n\t}\n\tif (!incomment && linestate == LS_HASH) {\n\t\tkeyword = tline + (cp - tline);\n\t\tcp = skipsym(cp);\n\t\tkwlen = cp - keyword;\n\t\t/* no way can we deal with a continuation inside a keyword */\n\t\tif (strncmp(cp, \"\\\\\\n\", 2) == 0)\n\t\t\tEioccc();\n\t\tif (strlcmp(\"ifdef\", keyword, kwlen) == 0 ||\n\t\t    strlcmp(\"ifndef\", keyword, kwlen) == 0) {\n\t\t\tcp = skipcomment(cp);\n\t\t\tif ((cursym = findsym(cp)) < 0)\n\t\t\t\tretval = LT_IF;\n\t\t\telse {\n\t\t\t\tretval = (keyword[2] == 'n')\n\t\t\t\t    ? LT_FALSE : LT_TRUE;\n\t\t\t\tif (value[cursym] == NULL)\n\t\t\t\t\tretval = (retval == LT_TRUE)\n\t\t\t\t\t    ? LT_FALSE : LT_TRUE;\n\t\t\t\tif (ignore[cursym])\n\t\t\t\t\tretval = (retval == LT_TRUE)\n\t\t\t\t\t    ? LT_TRUEI : LT_FALSEI;\n\t\t\t}\n\t\t\tcp = skipsym(cp);\n\t\t} else if (strlcmp(\"if\", keyword, kwlen) == 0)\n\t\t\tretval = ifeval(&cp);\n\t\telse if (strlcmp(\"elif\", keyword, kwlen) == 0)\n\t\t\tretval = ifeval(&cp) - LT_IF + LT_ELIF;\n\t\telse if (strlcmp(\"else\", keyword, kwlen) == 0)\n\t\t\tretval = LT_ELSE;\n\t\telse if (strlcmp(\"endif\", keyword, kwlen) == 0)\n\t\t\tretval = LT_ENDIF;\n\t\telse {\n\t\t\tlinestate = LS_DIRTY;\n\t\t\tretval = LT_PLAIN;\n\t\t}\n\t\tcp = skipcomment(cp);\n\t\tif (*cp != '\\0') {\n\t\t\tlinestate = LS_DIRTY;\n\t\t\tif (retval == LT_TRUE || retval == LT_FALSE ||\n\t\t\t    retval == LT_TRUEI || retval == LT_FALSEI)\n\t\t\t\tretval = LT_IF;\n\t\t\tif (retval == LT_ELTRUE || retval == LT_ELFALSE)\n\t\t\t\tretval = LT_ELIF;\n\t\t}\n\t\tif (retval != LT_PLAIN && (wascomment || incomment)) {\n\t\t\tretval += LT_DODGY;\n\t\t\tif (incomment)\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t}\n\t\t/* skipcomment should have changed the state */\n\t\tif (linestate == LS_HASH)\n\t\t\tabort(); /* bug */\n\t}\n\tif (linestate == LS_DIRTY) {\n\t\twhile (*cp != '\\0')\n\t\t\tcp = skipcomment(cp + 1);\n\t}\n\tdebug(\"parser %s comment %s line\",\n\t    comment_name[incomment], linestate_name[linestate]);\n\treturn (retval);\n}", "path": "recipes\\unifdef\\files\\unifdef.c", "repo_name": "nzjrs/overo-openembedded", "stars": 2, "license": "mit", "language": "c", "size": 113912}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned createCookie(char *username, char *cookie, char *Ip)", "code": "{\nFILE *arquivo;\n\tunsigned returnCode;\n\tchar cookiePath[strlen(COOKIES_PATH)+MAX_LENGTH_USERNAME+1];\n\t/*time_t expiration;*/\n\t\n\t/* Validating inputs */\n\tif((!(username)) || (!(Ip)))\n\t\treturn(NULL_POINTER);\n\tif((returnCode=validateField(username,VALID_CHARS_USERNAME,MIN_LENGTH_USERNAME,MAX_LENGTH_USERNAME))!=OK)\n\t\treturn(returnCode);\n\tif((returnCode=validateField(Ip,VALID_CHARS_IP,MIN_LENGTH_IP,MAX_LENGTH_IP))!=OK)\n\t\treturn(returnCode);\n\t\t\n\tif((returnCode=createRandomString(LENGTH_COOKIE_VALUE,VALID_CHARS_COOKIE,cookie))!=OK)\n\t\treturn(returnCode);\n\tif(!(arquivo=fopen(strncat(strcpy(cookiePath,COOKIES_PATH),username,strlen(username)),\"w\")))\n\t\treturn(ERROR_OPENING_FILE);\n\t\t\n\t/*expiration=time(NULL)+1800;*/\n\tIp[strlen(Ip)]='\\0';\n\tcookie[LENGTH_COOKIE_VALUE]='\\0';\n\t/*fwrite(&expiration,1,sizeof(time_t),arquivo);*/\n\tfwrite(cookie,1,LENGTH_COOKIE_VALUE+1,arquivo);\n\tfwrite(Ip,1,strlen(Ip)+1,arquivo);\t\nfclose(arquivo);\nreturn(OK);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "//#define XML_TEMP_FILE \"./xml/TempPacientesGuadalupe.xml\"\n", "func_signal": "void usualFreeMemory (xmlDocPtr doc)", "code": "{\n\tcgi_end();\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\txmlCleanupParser();\n\txmlMemoryDump();\n}", "path": "src\\ntbCgiEditPatient.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned getCookie(char *name, char *value)", "code": "{\nchar cookie[MAX_LENGTH_USERNAME+LENGTH_COOKIE_VALUE+1+1];\nunsigned indice;\n\nindice=0;\nstrcpy(cookie,getenv(\"HTTP_COOKIE\"));\nif (!(strlen(cookie)) || !(cookie) )\n\t{\n\treturn(NO_COOKIE);\n\t}\n\t/*if (strlen(cookie)>MAX_LENGTH_USERNAME+LENGTH_COOKIE_VALUE+1)\n\t\treturn(INVALID_COOKIE_LENGTH);*/\n\t\t/*if ((strchr(cookie, ';')) != NULL)\n\t\t\treturn(INVALID_COOKIE);*/\n\n\t\twhile (cookie[indice] != '=')\n\t\t\tindice++;\n\n\tif(indice>MAX_LENGTH_USERNAME)\n\t\treturn(INVALID_COOKIE_NAME_LENGTH);\n\tstrncpy(name, cookie, indice);\n\tstrncpy(value, &cookie[indice+1], LENGTH_COOKIE_VALUE);\nreturn(OK);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\nunsigned lerPosto(const char*, char*);\nunsigned lerPosto(const char *path, char *posto)\n{\n\tFILE *users;\n\tchar line[128+1];\n\tchar *aux;\n\t\n\tif (!(users=fopen(path,\"r\")))\n\t\treturn(ERROR_OPENING_FILE);\n\twhile (fgets(line,128+1,users))\n\t{\n\t\tif ((aux=strstr(line,\"usuarios \")))\n\t\t{\n\t\t\taux=strchr(aux,'\\\"');\n\t\t\taux++;\n\t\t\tstrncpy(posto,aux,strchr(aux,'\\\"')-aux);\n\t\t\tposto[strchr(aux,'\\\"')-aux]='\\0';\n\t\t\treturn(OK);\n\t\t}\n\t}\n\treturn(WRONG_XML_ROOT);\n}\n*/\n", "func_signal": "int main (int argc, char *argv[])", "code": "{\n\tFILE *xml, *backup;\n\tchar date[DATE_LENGTH+1];\n\tchar backupPath[strlen(XML_NAME)+32+1+1+strlen(XML_BACKUP_PATH)+1+DATE_LENGTH+1];\n\tchar posto[32+1], path[strlen(XML_DIR_PATH)+1+MAX_LENGTH_HEALTH_CENTER+1+strlen(XML_GENERIC_NAME)+1];\n\tint ch;\n\ttime_t seg;\n\tstruct tm *tempo;\n\t\n\ttime(&seg);\n\ttempo=localtime(&seg);\n\tsnprintf (date,DATE_LENGTH+1,\"%04i-%02i-%02i_%02i-%02i-%02i\",1900+tempo->tm_year,tempo->tm_mon+1,tempo->tm_mday,tempo->tm_hour,tempo->tm_min,tempo->tm_sec);\n\t//lerPosto(USERS_DATA_PATH,posto);\n\tstrcpy(backupPath,\"\");\n\tsnprintf (path,strlen(XML_DIR_PATH)+1+MAX_LENGTH_HEALTH_CENTER+1+strlen(XML_GENERIC_NAME),\"%spacientesGuadalupe.xml\",XML_DIR_PATH);\n\tsnprintf (backupPath,strlen(XML_NAME)+strlen(XML_BACKUP_PATH)+DATE_LENGTH+strlen(posto)+1+1+1+1,\"%s%s-pacientesGuadalupe.xml\",XML_BACKUP_PATH,date);\n\tif (!(xml=fopen(path, \"r\")))\n\t{\n\t\tprintf(\"Content-Type: text/html\\r\\n\\r\\n\");\n\t\tprintf(\"%s\",path);\n\t\tprintf(\"<html><head><title>Erro</title></head><body>Erro abrindo arquivo de usu&aacute;rios</body></html>\");\n\t\texit(0);\n\t}\n\tif (!(backup=fopen(backupPath, \"w\")))\n\t{\n\t\tprintf(\"Content-Type: text/html\\r\\n\\r\\n\");\n\t\tfclose(xml);\n\t\tprintf(\"<html><head><title>Erro</title></head><body>Erro abrindo arquivo de Backup</body></html>\");\n\t\texit(0);\n\t}\n\tprintf(\"Content-Type: application/force-download\\r\\n\");\n\tprintf(\"Content-Disposition: attachment; filename=Guadalupe_%s_backup.xml\\r\\n\\r\\n\",date);\t\n\twhile((ch=getc(xml)) != EOF)\n\t{\n\t\tprintf(\"%c\",ch);\n\t\tfputc(ch,backup);\n\t}\n\tfclose(xml);\n\tfclose(backup);\n\n\texit(0);\n}", "path": "src\\backup.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/**\n * Convert a string from ISO-8859-1 to UTF-8\n * Allocates double of ISO string size for UTF-8 string size\n * Input\n *\t@strISO: a pointer to an array of ISO Latin 1 chars\n * Output\n *\t@*strUTF: a pointer to an array of UTF-8 chars\n *\n * Returns:\n * -2 if any of char pointers are NULL\n * Otherwise, returns isolat1ToUTF8 return\n * Notes: strUTF may be freed by the caller if return >= 0\n */\n", "func_signal": "int convertISO88591toUTF8 (unsigned char *strISO, unsigned char **strUTF)", "code": "{\t\n\tint lenISO, lenUTF, rc;\n\t\n\tif (strISO == NULL || strUTF == NULL)\n\t\treturn(-2);\n\t\n\tlenISO = strlen((char *)strISO);\n\tlenUTF = 2 * lenISO;\n\t*strUTF = BAD_CAST malloc ((size_t) (lenUTF + 1));\n\t\n\trc = isolat1ToUTF8 (*strUTF, &lenUTF, strISO, &lenISO);\n\t(*strUTF)[lenUTF] = '\\0';\n\t\n\tif (rc < 0)\n\t\tfree(*strUTF);\n\t\n\treturn rc;\n}", "path": "src\\ntbFunctions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/\n", "func_signal": "int main (int argc, char **argv)", "code": "{\n\tchar *username;\n\t//CGI process\n\t\n\tcgi_init();\n\tcgi_process_form();\n//\tusername = cgi_param(\"uid\");\n\n\tif(!(username= getenv(\"REMOTE_USER\"))) //verifica se string lida  null\n\t  {\n\t\tprintf(\"Content-type: text/html\\n\\n\");\n\t\tprintf(\"<html>\\n\");\n\t\tprintf(\"<head>\\n\");\n\t\tprintf(\"<title>Resultado</title>\\n\");\n\t\tprintf(\"</head>\\n\");\n\t\tprintf(\"<body>\\n\");\n    printf(\"Erro ao verificar o usurio.\");\n\t\tprintf(\"</body>\\n\");\n\t\tprintf(\"</html>\\n\");\n\t\texit(0);\n\t\t}\n\n\tcgi_init_headers();\n\t\n/************** pagina html busca ********************/\n\nprintf(\"<html>\\n\");\nprintf(\"<head>\\n\");\nprintf(\"\t<title>Neural TB - Lista de Pacientes</title>\\n\");\nprintf(\"\t<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"css/main.css\\\" />\\n\");\nprintf(\"\t<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"css/menu.css\\\" />\\n\");\nprintf(\"\t<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"css/form.css\\\" />\\n\");\nprintf(\"\t<script charset=\\\"ISO-8859-1\\\" language=javascript src=\\\"js/funcoes.js\\\"></script>\\n\");\nprintf(\"\\n\");\nprintf(\"\t<style>\\n\");\nprintf(\"\t\tiframe {width: 100%%; min-width: 800px; height:500px}\\n\");\nprintf(\"\t</style>\\n\");\nprintf(\"</head>\\n\");\nprintf(\"\\n\");\nprintf(\"<body>\\n\");\nprintf(\"\\n\");\n\nshowMenu(\"listar\",username);\n\nprintf(\"\\n\");\nprintf(\"<table border=\\\"0\\\">\\n\");\nprintf(\"<tr>\\n\");\nprintf(\"\t<td class=\\\"under_menu\\\">\\n\");\nprintf(\"\t\t<div align=\\\"center\\\">\\n\");\nprintf(\"\t\t<table border=\\\"0\\\" style=\\\"width: 100%%\\\" cellspacing=\\\"0\\\" cellpadding=\\\"0\\\">\t\\n\");\nprintf(\"\\n\");\nprintf(\"\t\t<tr>\\n\");\nprintf(\"\t\t\t<td><iframe src=\\\"listPatients.cgi?uid=%s\\\" frameborder=\\\"0\\\" name=\\\"resultado\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" style=\\\"width: 100%%\\\"></iframe></td>\\n\",username);\nprintf(\"\t\t</tr>\\n\");\nprintf(\"\\n\");\nprintf(\"\t\t</table>\\n\");\nprintf(\"\t\t</div>\\n\");\nprintf(\"\t</td>\\n\");\nprintf(\"</tr>\\n\");\nprintf(\"</table>\\n\");\nprintf(\"</body>\\n\");\nprintf(\"</html>\\n\");\n\n/*****************************************************/\n\n\tcgi_end();\n\t\n\treturn 0;\n}", "path": "src\\ntbCgiListar.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\n\tConvert lowercase letters to uppercase in a string\n\tReturns the new string keeping the original one intact\n\t\n\tA void function that replace the original string with the uppercase one\n\tis easily achieved by removing malloc and its error treatment.\n*/\n", "func_signal": "char *to_uppercase (char *str)", "code": "{\n\tint i, len;\n\tchar *STR;\n\t\n\ti=0;\n\tlen = strlen (str);\n\tSTR = (char *) malloc(len +1);\n\tif (!STR)\n\t\treturn NULL;\n\t\n\twhile (i < len)\n\t{\n\t\tSTR[i] = (char) toupper (str[i]);\n\t\ti++;\n\t}\n\t\n\tSTR[i] = '\\0';\n\t\n\treturn STR;\n}", "path": "src\\ntbFunctions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned checkCookie(char *value, char *ip, char *name)", "code": "{\nFILE *ArquivoCookie;\nchar ReadIp[MAX_LENGTH_IP+1], ReadCookieValue[LENGTH_COOKIE_VALUE+1];\n/*time_t expiration;*/\n/*size_t lidos;*/\n\nif(!(ArquivoCookie=fopen(name,\"r\")))\n\treturn(INVALID_COOKIE);\n\n/*fread(&expiration,1,sizeof(time_t),ArquivoCookie);*/\n\nfread(ReadCookieValue,1,LENGTH_COOKIE_VALUE+1,ArquivoCookie);\nfread(ReadIp,1,MAX_LENGTH_IP+1,ArquivoCookie);\n\n\t\tif(ferror(ArquivoCookie))\n\t\t\t{\n\t\t\tfclose(ArquivoCookie);\n\t\t\treturn(ERROR_READING_FILE);\n\t\t\t}\n\nfclose(ArquivoCookie);\n\n\t/*if (expiration<time(NULL))\n\t\treturn(_COOKIE_EXPIRED);*/\n\tif (strcmp(value,ReadCookieValue)) /*Check if the values match*/\n\t\treturn(INVALID_COOKIE_VALUE);\n\tif (strcmp(ip,ReadIp))\n\t\treturn(INVALID_COOKIE_IP);\t\t\t\n\nreturn(OK);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\n\tIt gets the tag name and the text content between 2 tags.\n\t\n\tThis is not a general parsing function.\n\tIt does not verify several conditions to avoid unexpected behaviors,\n\tlike checking if end of string was reached.\n\tThus, it is a custom-made for a specific xml doc, which must contain\n\tin a line a starting tag and at least another starting tag, where it\n\twill stop getting text content. The tag name returned belongs to the\n\tfirst starting tag found.\n\tIn the future, this may disappear to make way for an expat function.\n\t\n\tExpat is a C library for XML manipulation\n*/\n", "func_signal": "void getTagNameAndTextContent (char *str, parsedvars *parsed)", "code": "{\n\tint i,j;\n\t\n\tfor (i=0; str[i] != '<'; i++);\n\t\n\ti++;\n\tfor (j=0; ((str[i] != ' ') && (str[i] != '>')); i++, j++)\n\t\tparsed->name[j] = str[i];\n\t\n\tparsed->name[j] = '\\0';\n\t\n\tif (str[i] == ' ')\n\t\tfor ( ; str[i] != '>'; i++);\t//skipping attributes\n\t\n\ti++;\n\tfor (j=0; ((str[i] != '<') && (str[i] != '\\0') && (str[i] != '\\n')); i++, j++)\n\t\tparsed->text[j] = str[i];\n\t\n\tparsed->text[j] = '\\0';\n\t\n\treturn;\n}", "path": "src\\ntbFunctions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\nGets current-user's public html path\n*/\n", "func_signal": "void getUserPublicPath (char *address)", "code": "{\n\tconst char* path = getenv(\"SCRIPT_FILENAME\");\n\tchar* pos = strrchr(path, '/');\n\t\n\tstrncpy(address,path,(size_t)(pos - path));\n\taddress[(size_t)(pos - path)]=0;\n\t\n//\treturn;\n}", "path": "src\\ntbFunctions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned getSpecificCookie(const char *name, char *value)", "code": "{\nchar *cookie;\nunsigned indice;\nif (!(name))\n\treturn(NULL_POINTER);\n\nindice=0;\n/*strcpy(cookie,getenv(\"HTTP_COOKIE\"));*/\ncookie=getenv(\"HTTP_COOKIE\");\nif (!(strstr(cookie,name)))\n\treturn(COOKIE_NAME_NOT_FOUND);\ncookie=strstr(cookie,name);\nif (!(strlen(cookie)) || !(cookie) )\n\t{\n\treturn(NO_COOKIE);\n\t}\n\t/*if (strlen(cookie)>MAX_LENGTH_USERNAME+LENGTH_COOKIE_VALUE+1)\n\t\treturn(INVALID_COOKIE_LENGTH);*/\n\t\t/*if ((strchr(cookie, ';')) != NULL)\n\t\t\treturn(INVALID_COOKIE);*/\n\n\t\twhile (cookie[indice] != '=')\n\t\t\tindice++;\n\n\tif(indice>MAX_LENGTH_USERNAME)\n\t\treturn(INVALID_COOKIE_NAME_LENGTH);\n\t/*strncpy(name, cookie, indice);*/\n\tstrncpy(value, &cookie[indice+1], LENGTH_COOKIE_VALUE);\nreturn(OK);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "void trocaEnter(char* strInicio, char* strFinal)", "code": "{\nint i, j;\n\n\ti=j=0;\n\twhile(i<strlen(strInicio))\n\t{\n\t\tif \t(strInicio[i] == 13)\n\t\t{\n\t\t\tstrFinal[j] = '\\\\';\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t\tstrFinal[j] = 'n';\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\telse if (strInicio[i] == '\\n')\n\t\t\ti++;\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\telse\n\t\t{\n\t\t\tstrFinal[j] = strInicio[i];\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tstrFinal[j]='\\0';\n\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "//modificaoes xsltproc\n//#define PATHFILE \"xml/xsl/resultado.xsl\"\n", "func_signal": "void printError (char *msg)", "code": "{\n\tcgi_init_headers();\n\t\n\tprintf (\"<html><head><title>Erro</title></head><body><h2>%s</h2></body></html>\", msg);\n}", "path": "src\\ntbCgiImprimir.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "//modificaoes xsltproc\n//#define PATHFILE \"xml/xsl/resultado.xsl\"\n", "func_signal": "void printError (char *msg)", "code": "{\n\tcgi_init_headers();\n\t\n\tprintf (\"<html><head><title>Erro</title></head><body><h2>%s</h2></body></html>\", msg);\n}", "path": "src\\ntbCgiFormsStatus.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\nint getUsername(char*, char*);\nint getUsername(char *conteudo, char *username)\n{\n\tlong unsigned indice, indiceAux;\n\tif (!(conteudo))\n\t\treturn(1);\n\tindice=indiceAux=0;\n\twhile ((conteudo[indice] != '=') && (indice<=9))\n\t\tindice++;\n\tif(!(strncmp(\"username\",conteudo,indice)))\n\t{\n\t\tindice++;\n\t\twhile ((indice<=9+MAX_LENGTH_USERNAME)) //while ((conteudo[indice] != '&') && (indice<=9+MAX_LENGTH_USERNAME))\n\t\t{\n\t\t\tusername[indiceAux]=conteudo[indice];\n\t\t\tindice++;\n\t\t\tindiceAux++;\t\n\t\t}\n\t\tusername[indiceAux]='\\0';\n\t}\n\t\n\telse\n\t\treturn(WRONG_FIELD_NAME);\n\n\treturn(0);\n}\n*/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tprintf(\"Content-Type: text/html\\r\\n\");\n\tprintf(\"Location: login.html\\r\\n\");\n\tprintf(\"\\r\\n\");\n\t\n\treturn (ok);\n}", "path": "src\\ntbCgiLogout.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned authenticateUser (char *username, char *password, unsigned *group)", "code": "{\n\tchar passwordFound[MAX_LENGTH_PASSWORD+1];\n\tunsigned returnCode;\n\n\n\tif (!username)\n\t\treturn (NULL_POINTER);\n\tif (!password)\n\t\treturn (NULL_POINTER);\n\tif ((returnCode = searchUser(username, passwordFound, group)) != OK)\n\t\treturn (returnCode);\n\tif (!passwordFound)\n\t\treturn (NULL_POINTER);\n\tif (!(strcmp(password,passwordFound)))\n\t\treturn (OK);\n\t\n\treturn(WRONG_PASSWORD);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/**\n * Check if a string is an UTF-8.\n * If it is, a new string, copy of @in, is returned.\n * If not, a conversion is made from ISO Latin 1 to UTF-8 and the new string is\n * returned.\n * That's because an enconding detection is not performed and the former has\n * a large use in web.\n * This routine is intended to make use of the same variable whether it was\n * converted or not.\n *\n * Input\n *\t@in: a pointer to an array of ISO Latin 1 chars\n * Output\n *\t-\n * Returns:\n *\tNULL in case of error\n *\tA new string if success\n *\n * Notes: Returned string may be freed by the caller if != NULL\n *\n * use:\n *\tchar *str_in, *str_out;\n *\tstr_out = fixCgiStr (str_in); \n */\n", "func_signal": "xmlChar *fixCgiStr (xmlChar *in)", "code": "{\n\tint utf8;\n\txmlChar *out = NULL;\n\t\n\tif (in == NULL) return NULL;\n\t\n\tutf8 = xmlCheckUTF8 (in);\n\tif (!utf8)\n\t{\n\t\tif (convertISO88591toUTF8(in, &out) < 0)\n\t\t\treturn NULL;\n\t\treturn (out);\n\t}\n\t\n\treturn (xmlStrdup(in));\n}", "path": "src\\ntbFunctions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "void trocaAspas(char* strInicio, char* strFinal)", "code": "{\nint i, j;\n\n\tj=0;\n\t/*if (strlen(strInicio)>=FIELD_MAX)\n\t\tmax = FIELD_MAX-1;\n\telse\n\t\tmax = strlen(strInicio);*/\n\t\n\tfor (i=0; i<strlen(strInicio); i++)\n\t{\n\t\tif (strInicio[i] == '\"')\n\t\t{\n\t\t\tstrFinal[j] = '\\\\';\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t\tstrFinal[j]=strInicio[i];\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrFinal[j] = strInicio[i];\n\t\t\t//printf(\"//%i: %c //%i:%c\\n\",i,strInicio[i],j,strFinal[j]);\n\t\t\tj++;\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tstrFinal[j]='\\0';\n\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*-----------------------------------------------------------------*/\n", "func_signal": "unsigned validateField(char *Field, char *ValidChars, unsigned MinLenght, unsigned MaxLenght)", "code": "{\n\nunsigned Indice=0;\n\nif ((Field==NULL) || (ValidChars==NULL) || (!(strchr(Field,'\\0'))) || (!(strchr(ValidChars,'\\0'))))\n        return(NULL_POINTER);\n\n\nif ((strlen(Field) < MinLenght) || (strlen(Field) > MaxLenght))\n        return(INVALID_FIELD_LENGTH);\n\nwhile(Indice < strlen(Field))\n        {       \n                if ((!(strchr(ValidChars,Field[Indice]))) && (Field[Indice]!='\\n'))\n                return(INVALID_FIELD_CHAR);\n        Indice++;      \n        }\nreturn (OK);\n}", "path": "src\\functions.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "//#define PATHFILE \"xml/xsl/filtro.xsl\"\n//#define PATHFILE2 \"xml/xsl/resultado.xsl\"\n", "func_signal": "void printError (char *msg)", "code": "{\n\tcgi_init_headers();\n\t\n\tprintf (\"<html><head><title>Erro</title></head><body><h2>%s</h2></body></html>\", msg);\n}", "path": "src\\ntbCgiSearchPatient.c", "repo_name": "igorBraganca/projetotb", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*\nstatic void initHandle( RGBHandle * handle )\n{\n\n\thandle->mine.red = rnd( 65536 );\n\thandle->mine.green = rnd( 65536 );\n\thandle->mine.blue = rnd( 65536 );\n\thandle->rwant = rnd( 65536 );\n\thandle->gwant = rnd( 65536 );\n\thandle->bwant = rnd( 65536 );\n\n}\n*/\n", "func_signal": "static void initXColor( XColor * color )", "code": "{\n\tcolor->red = rnd( 50000 ) + 10000;\n\tcolor->blue = rnd( 50000 ) + 10000;\n\tcolor->green = rnd( 50000 ) + 10000;\n}", "path": "hacks\\wormhole.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Draws meters along the diagonal for the y velocity.\n   Is there some way to make draw_meter_x and draw_meter_y \n   one function instead of two without making them completely unreadable?\n*/\n", "func_signal": "static void \ndraw_meter_y (Display *dpy, Window window, struct state *st, int i, int alone)", "code": "{\n  XWindowAttributes xgwa;\n  int y1,y2,x,h1,h2,w;\n  XGetWindowAttributes (dpy, window, &xgwa);\n\n  if(xgwa.height < BAR_SIZE*st->npoints){  /*needs to be height still */\n    x = i*(xgwa.height/st->npoints);\n    w = (xgwa.height/st->npoints) - 2;\n  }\n  else{\n    x = BAR_SIZE*i;\n    w = BAR_SIZE - 2;\n  }\n\n  if(alone)\n    {\n      y1 = xgwa.height/2;\n      y2 = y1;\n    }\n  else\n    {\n      y1 = i*(w+2);\n      if(y1 < i)\n        y1 = i;\n      y2 = y1;\n    }\n\n  if(x < 1) x = i;  \n  if(w < 1) w = 1;\n\n  h1 = (int)(20*st->y_vels[i]);\n  h2 = (int)(20*st->balls[i].vy);\n  st->y_vels[i] = st->balls[i].vy; \n\n  if (h1<0) {\n    h1=-h1;\n    y1=y1-h1;\n  }\n  if (h2<0) {\n    h2=-h2;\n    y2=y2-h2;\n  }\n  XDrawRectangle(dpy,window,st->erase_gc,x,y1+(w+2)/2,w,h1);\n  XDrawRectangle(dpy,window,st->draw_gc,x,y2+(w+2)/2,w,h2);\n}", "path": "hacks\\attraction.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Returns a mask of the bit or bits of a KeyPress event that mean \"meta\". \n */\n", "func_signal": "static unsigned int\nmeta_modifier (p_state *state)", "code": "{\n  if (!state->meta_done_once)\n    {\n      /* Really, we are supposed to recompute this if a KeymapNotify\n         event comes in, but fuck it. */\n      state->meta_done_once = True;\n      state->meta_mask = do_icccm_meta_key_stupidity (state->dpy);\n    }\n  return state->meta_mask;\n}", "path": "hacks\\phosphor.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* ensure transparent components are at the end */\n", "func_signal": "static void reorder(Component *c[])", "code": "{\n  int i, j, k;\n  Component *c1[MAX_COMPONENTS];\n  Component *c2[MAX_COMPONENTS];\n\n  j = 0;\n  for (i = 0 ; i < maxparts ; i++) { /* clear old matrix */\n    c1[i] = NULL;\n    c2[i] = NULL;\n  }\n  for (i = 0 ; i < maxparts ; i++) {\n    if (c[i] == NULL) continue;\n    if (c[i]->alpha) { /* transparent parts go to c1 */\n      c1[j] = c[i];\n      j++;\n    } else { /* opaque parts go to c2 */\n      c2[i] = c[i];\n    }\n  }\n  for (i = 0 ; i < maxparts ; i++) { /* clear old matrix */\n    c[i] = NULL;\n  }\n  k = 0;\n  for (i = 0 ; i < maxparts ; i++) { /* insert opaque part */\n    if (c2[i] != NULL) {\n      c[k] = c2[i];\n      k++;\n    }\n  }\n  for (i = 0 ; i < j ; i++) { /* insert transparent parts */\n    c[k] = c1[i];\n    k++;\n  }\n}", "path": "hacks\\glx\\circuit.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* The interpretation of the ModN modifiers is dependent on what keys\n   are bound to them: Mod1 does not necessarily mean \"meta\".  It only\n   means \"meta\" if Meta_L or Meta_R are bound to it.  If Meta_L is on\n   Mod5, then Mod5 is the one that means Meta.  Oh, and Meta and Alt\n   aren't necessarily the same thing.  Icepicks in my forehead!\n */\n", "func_signal": "static unsigned int\ndo_icccm_meta_key_stupidity (Display *dpy)", "code": "{\n  unsigned int modbits = 0;\n# ifndef HAVE_COCOA\n  int i, j, k;\n  XModifierKeymap *modmap = XGetModifierMapping (dpy);\n  for (i = 3; i < 8; i++)\n    for (j = 0; j < modmap->max_keypermod; j++)\n      {\n        int code = modmap->modifiermap[i * modmap->max_keypermod + j];\n        KeySym *syms;\n        int nsyms = 0;\n        if (code == 0) continue;\n        syms = XGetKeyboardMapping (dpy, code, 1, &nsyms);\n        for (k = 0; k < nsyms; k++)\n          if (syms[k] == XK_Meta_L || syms[k] == XK_Meta_R ||\n              syms[k] == XK_Alt_L  || syms[k] == XK_Alt_R)\n            modbits |= (1 << i);\n        XFree (syms);\n      }\n  XFreeModifiermap (modmap);\n# endif /* HAVE_COCOA */\n  return modbits;\n}", "path": "hacks\\phosphor.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Re-query the window size and update the internal character grid if changed.\n */\n", "func_signal": "static void\nresize_grid (p_state *state)", "code": "{\n  int ow = state->grid_width;\n  int oh = state->grid_height;\n  p_cell *ocells = state->cells;\n  int x, y;\n\n  XGetWindowAttributes (state->dpy, state->window, &state->xgwa);\n\n  state->grid_width = state->xgwa.width   /(state->char_width  * state->scale);\n  state->grid_height = state->xgwa.height /(state->char_height * state->scale);\n\n  if (ow == state->grid_width &&\n      oh == state->grid_height)\n    return;\n\n  state->cells = (p_cell *) calloc (sizeof(p_cell),\n                                    state->grid_width * state->grid_height);\n\n  for (y = 0; y < state->grid_height; y++)\n    {\n      for (x = 0; x < state->grid_width; x++)\n        {\n          p_cell *ncell = &state->cells [state->grid_width * y + x];\n          if (x < ow && y < oh)\n            *ncell = ocells [ow * y + x];\n          ncell->changed = True;\n        }\n    }\n\n  if (state->cursor_x >= state->grid_width)\n    state->cursor_x = state->grid_width-1;\n  if (state->cursor_y >= state->grid_height)\n    state->cursor_y = state->grid_height-1;\n\n  free (ocells);\n}", "path": "hacks\\phosphor.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Standard reshape function */\n", "func_signal": "ENTRYPOINT void\nreshape_pulsar(ModeInfo *mi, int width, int height)", "code": "{\n  glViewport( 0, 0, MI_WIDTH(mi), MI_HEIGHT(mi) );\n  resetProjection();\n}", "path": "hacks\\glx\\pulsar.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* draw a resistor */\n", "func_signal": "static int DrawResistor(Circuit *ci, Resistor *r)", "code": "{\n  int polys = 0;\n  int i;\n  GLfloat col[] = {0.74, 0.62, 0.46, 1.0};\n  GLfloat spec[] = {0.8, 0.8, 0.8, 1.0};\n  GLfloat shine = 30;\n\n   glTranslatef(-4, 0, 0);\n   polys += wire(ci, 3);\n   glTranslatef(3, 0, 0);\n   glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, col);\n   glMaterialfv(GL_FRONT, GL_SPECULAR, spec);\n   glMaterialfv(GL_FRONT, GL_SHININESS, &shine);\n   polys += createCylinder(ci, 1.8, 0.4, 1, 0);\n   glPushMatrix();\n   for (i = 0 ; i < 4 ; i++) {\n     glTranslatef(0.35, 0, 0);\n     glCallList(ci->band_list[r->b[i]]);\n     polys += ci->band_list_polys[r->b[i]];\n   }\n   glPopMatrix();\n   glTranslatef(1.8, 0, 0);\n   polys += wire(ci, 3);\n   return polys;\n}", "path": "hacks\\glx\\circuit.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Draws meters of the total speed of the balls */\n", "func_signal": "static void\ndraw_meter_speed (Display *dpy, Window window, struct state *st, int i)", "code": "{\n  XWindowAttributes xgwa;\n  int y,x1,x2,h,w1,w2;\n  XGetWindowAttributes (dpy, window, &xgwa);\n\n  if(xgwa.height < BAR_SIZE*st->npoints)\n    {\n      y = i*(xgwa.height/st->npoints);\n      h = (xgwa.height/st->npoints) - 2;\n    }\n  else{\n    y = BAR_SIZE*i;\n    h = BAR_SIZE - 2;\n  }\n\n  x1 = 0;\n  x2 = x1;\n\n  if(y < 1) y = i;  \n  if(h < 1) h = 1;\n\n  w1 = (int)(5*st->speeds[i]);\n  w2 = (int)(5*(st->balls[i].vy*st->balls[i].vy+st->balls[i].vx*st->balls[i].vx));\n  st->speeds[i] =    st->balls[i].vy*st->balls[i].vy+st->balls[i].vx*st->balls[i].vx;\n\n  XDrawRectangle(dpy,window,st->erase_gc,x1,y,w1,h);\n  XDrawRectangle(dpy,window,st->draw_gc, x2,y,w2,h);\n}", "path": "hacks\\attraction.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* alpha blended point drawing -- this is Not Right and will likely fail on \n * non-intel platforms as it is now, needs fixing */\n", "func_signal": "static inline unsigned long trans_point(int x1, int y1, unsigned long myc, double a, \n\t\t\t\t struct field *f)", "code": "{\n    if (a >= 1.0) \n    {\n\tref_pixel(f, x1, y1) = myc;\n\treturn myc;\n    } \n    else \n    {\n\tint or=0, og=0, ob=0;\n\tint r=0, g=0, b=0;\n\tint nr, ng, nb;\n\tunsigned long c;\n\n\tc = ref_pixel(f, x1, y1);\n\n\tpoint2rgb(f->visdepth, c, &or, &og, &ob);\n\tpoint2rgb(f->visdepth, myc, &r, &g, &b);\n\n\tnr = or + (r - or) * a;\n\tng = og + (g - og) * a;\n\tnb = ob + (b - ob) * a;\n\n\tc = rgb2point(f->visdepth, nr, ng, nb);\n\n\tref_pixel(f, x1, y1) = c;\n\n\treturn c;\n    }\n}", "path": "hacks\\interaggregate.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/*\nstatic void moveRGBHandle( RGBHandle * handle, int min, int max )\n{\n\n\tunsigned short * want[ 3 ];\n\tint q;\n\tint cy = 0;\n\twant[0] = &(handle->rwant);\n\twant[1] = &(handle->gwant);\n\twant[2] = &(handle->bwant);\n\n\tfor ( q = 0; q < 10; q++ ){\n\t\tchangeColor( &( handle->mine.red ), &handle->rwant, min, max );\n\t\tchangeColor( &( handle->mine.green ), &handle->gwant, min, max );\n\t\tchangeColor( &( handle->mine.blue ), &handle->bwant, min, max );\n\t}\n\t\n\tfor ( q = 0; q < 3; q++ )\n\t\tcy = cy || (*(want[q]) >= min && *(want[q]) <= max);\n\tif ( !cy ) *(want[rnd(3)]) = rnd(max-min)+min;\n\tcy = 1;\n\tfor ( q = 0; q < 3; q++ )\n\t\tcy = cy && *(want[q]) == 0;\n\tif ( cy ) *(want[rnd(3)]) = rnd(max-min)+min;\n\n\tif ( rnd( 30 ) == rnd( 30 ) )\n\t\t*(want[rnd(3)]) = rnd(max-min)+min;\n\n}\n*/\n", "func_signal": "static void moveColorChanger( color_changer * ch )", "code": "{\n\n\t/* int q; */\n\n\tif ( ch->min < ch->min_want ){\n\t\tch->min++;\n\t\tch->max++;\n\t}\n\tif ( ch->min > ch->min_want ) {\n\t\tch->min--;\n\t\tch->max--;\n\t}\n\tif ( ch->min == ch->min_want )\n\t\tch->min_want = rnd( ch->shade_max - ch->shade_use );\n\n\t/*\n\tfor ( q = 0; q < ch->max; q++ )\n\t\tXFreeColors( st->dpy, *cmap, &( ch->shade[q].pixel ), 1, 0 );\n\n\tmoveRGBHandle( &( ch->handle_begin ), 5000, 65500 );\n\tmoveRGBHandle( &( ch->handle_end ), 5000, 65500 );\n\t\n\tblend_palette( ch->shade, ch->max, &(ch->handle_begin.mine), &(ch->handle_end.mine) );\n\tfor ( q = 0; q < ch->max; q++ )\n\t\tXAllocColor( st->dpy, *cmap, &( ch->shade[q] ) );\n\t*/\n\n}", "path": "hacks\\wormhole.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* all sorts of nice cleanup code should go here! */\n", "func_signal": "ENTRYPOINT void release_pulsar(ModeInfo * mi)", "code": "{\n  int screen;\n  if (Pulsar != NULL) {\n\tfor (screen = 0; screen < MI_NUM_SCREENS(mi); screen++) {\n\t  pulsarstruct *gp = &Pulsar[screen];\n      free(gp->quads);\n\t}\n\t(void) free((void *) Pulsar);\n\tPulsar = NULL;\n  }\n  FreeAllGL(mi);\n}", "path": "hacks\\glx\\pulsar.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Subprocess.\n */\n", "func_signal": "static void\nsubproc_cb (XtPointer closure, int *source, XtInputId *id)", "code": "{\n  p_state *state = (p_state *) closure;\n  state->input_available_p = True;\n}", "path": "hacks\\phosphor.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/*\nstatic void eraseWormhole( Display * display, Window * st->window, wormhole * worm ){\n\tstarline * current;\n\tint i;\n\tXColor * xcol;\n\tfor ( i = 0; i < worm->num_stars; i++ )\n\t\tif ( worm->stars[i] != NULL ){\n\t\t\txcol = &worm->black;\n\t\t\tcurrent = worm->stars[i];\n\t\t\tXSetForeground( st->dpy, *gc, xcol->pixel );\n\t\t\tXDrawLine( st->dpy, st->window, *gc, current->begin.calc_x, current->begin.calc_y, current->end.calc_x, current->end.calc_y );\n\t\t}\n}\n*/\n", "func_signal": "static void *\nwormhole_init (Display *dpy, Window window)", "code": "{\n\tstruct state *st = (struct state *) calloc (1, sizeof(*st));\n  \tXGCValues gcv;\n\tXWindowAttributes attr;\n\n\tst->dpy = dpy;\n\tst->window = window;\n\tst->delay = get_integer_resource(st->dpy,  \"delay\", \"Integer\" );\n\tst->make_stars = get_integer_resource(st->dpy,  \"stars\", \"Integer\" );\n\tst->z_speed = get_integer_resource(st->dpy,  \"zspeed\", \"Integer\" );\n\n\tinitWormhole( st, &st->worm, st->dpy, st->window );\n\n\tst->gc = XCreateGC( st->dpy, st->window, 0, &gcv );\n\tXGetWindowAttributes( st->dpy, st->window, &attr );\n\tst->cmap = attr.colormap;\n\n        return st;\n}", "path": "hacks\\wormhole.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* IC pins */\n", "func_signal": "static int ICLeg(GLfloat x, GLfloat y, GLfloat z, int dir)", "code": "{\n  int polys = 0;\n  if (dir) {\n    polys += Rect(x-0.1, y, z, 0.1, 0.1, 0.02);\n    polys += Rect(x-0.1, y, z, 0.02, 0.1, 0.1);\n    polys += Rect(x-0.1, y+0.03, z-0.1, 0.02, 0.05, 0.3);\n  } else {\n    polys += Rect(x, y, z, 0.1, 0.1, 0.02);\n    polys += Rect(x+0.8*0.1, y, z, 0.02, 0.1, 0.1);\n    polys += Rect(x+0.8*0.1, y+0.03, z-0.1, 0.02, 0.05, 0.3);\n  }\n  return polys;\n}", "path": "hacks\\glx\\circuit.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* 7 segment display */\n", "func_signal": "static Disp *NewDisp(Circuit *ci)", "code": "{\n  Disp *d;\n\n  d = malloc(sizeof(Disp));\n  if (seven)\n    d->value = 7;\n  else\n    d->value = RAND_RANGE(0, 10);\n  return d;\n}", "path": "hacks\\glx\\circuit.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* used when the window is resized */\n", "func_signal": "static void build_img(struct field *f)", "code": "{\n    if (f->off_img) {\n        free(f->off_img);\n        f->off_img = NULL;\n    }\n\n    f->off_img = (unsigned long *) calloc(f->width * f->height,\n\t\t\t\t\t  sizeof(unsigned long));\n\t\t\t\t\t   \n\n    if ( f->off_img == NULL )\n    {\n        fprintf(stderr, \"%s: Failed to allocate off_img\\n\",\n                progname);\n\texit(1);\n    }\n\n    memset(f->off_img, f->bgcolor, \n\t   sizeof(unsigned long) * f->width * f->height);\n}", "path": "hacks\\interaggregate.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Create a texture in OpenGL.  First an image is loaded \n   and stored in a raster buffer, then it's  */\n", "func_signal": "static void Create_Texture(ModeInfo *mi, const char *filename)", "code": "{\n  int height, width;\n  GLubyte *image;\n  int format;\n\n  if ( !strncmp(filename, \"BUILTIN\", 7))\n    image = Generate_Image(&width, &height, &format);\n  else\n    {\n      XImage *ximage = xpm_file_to_ximage (MI_DISPLAY (mi), MI_VISUAL (mi),\n                                           MI_COLORMAP (mi), filename);\n      image  = (GLubyte *) ximage->data;\n      width  = ximage->width;\n      height = ximage->height;\n      format = GL_RGBA;\n    }\n\n  /* GL_MODULATE or GL_DECAL depending on what you want */\n  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n  /* perhaps we can edge a bit more speed at the expense of quality */\n  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);\n\n  if (do_texture_quality) {\n\t/* with texture_quality, the min and mag filters look *much* nice but are *much* slower */\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n  }\n  else {\n\t/* default is to do it quick and dirty */\n\t/* if you have mipmaps turned on, but not texture quality, nothing will happen! */\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n  }\n\n  /* mipmaps make the image look much nicer */\n  if (do_mipmap)\n    {\n      int status;\n      clear_gl_error();\n      status = gluBuild2DMipmaps(GL_TEXTURE_2D, 3, width, height, format,\n                                 GL_UNSIGNED_BYTE, image);\n      if (status)\n        {\n          const char *s = (char *) gluErrorString (status);\n          fprintf (stderr, \"%s: error mipmapping %dx%d texture: %s\\n\",\n                   progname, width, height,\n                   (s ? s : \"(unknown)\"));\n          exit (1);\n        }\n      check_gl_error(\"mipmapping\");\n    }\n  else\n    {\n      clear_gl_error();\n      glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0,\n                   format, GL_UNSIGNED_BYTE, image);\n      check_gl_error(\"texture\");\n    }\n}", "path": "hacks\\glx\\pulsar.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* we use trig tables to speed things up - 200 calls to sin()\n in one frame can be a bit harsh..\n*/\n", "func_signal": "static void make_tables(Circuit *ci)", "code": "{\nint i;\nfloat f;\n\n  f = 360 / (M_PI * 2);\n  for (i = 0 ; i < 720 ; i++) {\n    ci->sin_table[i] = sin(i/f);\n  }\n  for (i = 0 ; i < 720 ; i++) {\n    ci->cos_table[i] = cos(i/f);\n  }\n  for (i = 0 ; i < 720 ; i++) {\n    ci->tan_table[i] = tan(i/f);\n  }\n}", "path": "hacks\\glx\\circuit.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/* Draws meters along the diagonal for the x velocity */\n", "func_signal": "static void \ndraw_meter_x(Display *dpy, Window window, struct state *st, int i, int alone)", "code": "{\n  XWindowAttributes xgwa;\n  int x1,x2,y,w1,w2,h;\n  XGetWindowAttributes (dpy, window, &xgwa);\n\n  /* set the width of the bars to use */\n  if(xgwa.height < BAR_SIZE*st->npoints)\n    {\n      y = i*(xgwa.height/st->npoints);\n      h = (xgwa.height/st->npoints) - 2;\n    }\n  else\n    {\n      y = BAR_SIZE*i;\n      h = BAR_SIZE - 2;\n    }\n  \n  if(alone)\n    {\n      x1 = xgwa.width/2;\n      x2 = x1;\n    }\n  else\n    {\n      x1 = i*(h+2);\n      if(x1 < i) \n        x1 = i;\n      x2 = x1;\n    }\n\n  if(y<1) y=i;  \n  if(h<1) h=1;\n\n  w1 = (int)(20*st->x_vels[i]);\n  w2 = (int)(20*st->balls[i].vx);\n  st->x_vels[i] = st->balls[i].vx; \n\n  if (w1<0) {\n    w1=-w1;\n    x1=x1-w1;\n  }\n  if (w2<0) {\n    w2=-w2;\n    x2=x2-w2;\n  }\n  XDrawRectangle(dpy,window,st->erase_gc,x1+(h+2)/2,y,w1,h);\n  XDrawRectangle(dpy,window,st->draw_gc,x2+(h+2)/2,y,w2,h);\n}", "path": "hacks\\attraction.c", "repo_name": "guerrerocarlos/deb-xscreensaver", "stars": 2, "license": "None", "language": "c", "size": 6152}
{"docstring": "/*\n * type\t\t->\tVOID\n *\t\t\t\t|\t\tINT\n */\n", "func_signal": "int Type(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Type +++\\n\");\n\n\tswitch(*tok) {\n\t\tcase VOID:\n\t\tcase INT:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tacc = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\tprintf(\"\\n--- Type (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * factors\t->\tMULOP fac factors\n *\t\t\t\t\t|\t\tDIVOP fac factors\n *\t\t\t\t\t|\t\te\n */\n", "func_signal": "int Factors(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Factors +++\\n\");\n\tswitch(*tok) {\n\t\tcase MULTOP:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(!Fac(tok, val))\n\t\t\t\tacc = FALSE;\n\t\t\telse {\n\t\t\t\tacc = Factors(tok, val);\n\t\t\t\tfprintf(gfile, \"*\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DIVOP:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(!Fac(tok, val))\n\t\t\t\t\tacc = FALSE;\n\t\t\telse {\n\t\t\t\tacc = Factors(tok, val);\n\t\t\t\tfprintf(gfile, \"/\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Factors (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * decl\t\t->\tINT ID decls decl\n *\t\t\t\t|\t\te\n */\n", "func_signal": "int Decl(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Decl +++\\n\");\n\tswitch(*tok) {\n\t\tcase INT:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == ID) {\n\t\t\t\tfprintf(gfile, \"declare %s\\n\", gstring);\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tif(Decls(tok, val)) {\n\t\t\t\t\tacc = Decl(tok, val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tacc = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tacc = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = TRUE; // Not a declaration (matches epsilon)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Decl (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/**\n * Check if the char is a letter\n */\n", "func_signal": "int isAlpha(char arg)", "code": "{\n\tif((arg > 64 && arg < 91) || (arg > 96 && arg < 123))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "lab1\\scanner.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * term\t\t->\tfactor terms\n */\n", "func_signal": "int Term(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Term +++\\n\");\n\tif(Factor(tok, val))\n\t\tacc = Terms(tok, val);\n\telse\n\t\tacc = FALSE;\n\n\tprintf(\"\\n--- Term (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/* --------- Local functions: */\n", "func_signal": "static void destroy_records(t_record *r, void (*user_data_destroy)(void *data))", "code": "{\n   if (r) {\n      if (user_data_destroy) {\n         user_data_destroy(r->data);\n      }\n      destroy_records(r->next, user_data_destroy);\n      free(r);\n   }\n}", "path": "lab3\\src\\llist.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * call\t\t->\t( expr optexpr )\n *\t\t\t\t|\t\t( )\n *\t\t\t\t|\t\tASSIGNOP expr\n */\n", "func_signal": "int Call(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Call +++\\n\");\n\tswitch(*tok) {\n\t\tcase LEFTPARENTHESIS:\n\t\t\tfprintf(gfile, \"push 0\\n\");\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tswitch(*tok) {\n\t\t\t\tcase RIGHTPARENTHESIS:\n\t\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\t\tacc = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(!Expr(tok, val)) {\n\t\t\t\t\t\tacc = FALSE;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(!(acc = Optexpr(tok, val))) {\n\t\t\t\t\t\t\tacc = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(*tok != RIGHTPARENTHESIS) {\n\t\t\t\t\t\t\tacc = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ASSIGNOP:\n\t\t\tfprintf(gfile, \"lvalue %s\\n\", gassign);\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tacc = Expr(tok, val);\n\t\t\tif(acc)\n\t\t\t\tacc = ACK_IDENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Call (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * fac\t->\t! fac\n *\t\t\t|\t\tID call\n *\t\t\t|\t\tNUM\n *\t\t\t|\t\t( expr )\n */\n", "func_signal": "int Fac(int *tok, int *val)", "code": "{\n\tint acc;\n\tchar tmp[64];\n\n\tprintf(\"+++ Fac +++\\n\");\n\tswitch(*tok) {\n\t\tcase NOTOP:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tacc = Fac(tok, val);\n\t\t\tfprintf(gfile, \"not\\n\");\n\t\t\tbreak;\n\t\tcase ID:\n\t\t\tstrncpy(tmp, gstring, 64);\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == LEFTPARENTHESIS || *tok == ASSIGNOP){\n\t\t\t\tacc = Call(tok, val);\n\t\t\t\tif(acc == ACK_IDENT) // hotfix to determine 'assign' or 'call'\n\t\t\t\t\tfprintf(gfile, \":=\\n\");\n\t\t\t\telse\n\t\t\t\t\tfprintf(gfile, \"call %s\\n\", tmp);\n\t\t\t\t\tfprintf(gfile, \"pop %d\\n\", acc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(gfile, \"rvalue %s\\n\", tmp);\n\t\t\t\tacc = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NUM:\n\t\t\tfprintf(gfile, \"push %d\\n\", *val);\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tacc = TRUE;\n\t\t\tbreak;\n\t\tcase LEFTPARENTHESIS:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(!Expr(tok, val))\n\t\t\t\tacc = FALSE;\n\t\t\telse if(*tok == RIGHTPARENTHESIS) {\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tacc = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- fac (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * Handler for a file pointer\n */\n", "func_signal": "FILE * globalFile(int cmd, char * file)", "code": "{\n\tstatic FILE * fp;\n\tswitch (cmd){\n\t\tcase SCAN_INIT:\n\t\t\tfp = fopen(file, \"r\");\n\t\t\tif(fp == NULL)\n\t\t\t\tfprintf(stderr, \"Can't open %s\\n\", file);\n\t\t\treturn fp;\n\t\tcase SCAN_GET:\n\t\t\treturn fp;\n\t}\n\treturn NULL;\n}", "path": "lab1\\scanner.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * optpar\t->\t, INT ID optpar\n *\t\t\t\t|\t\t)\n */\n", "func_signal": "int Optparams(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Optparams +++\\n\");\n\tswitch(*tok) {\n\t\tcase RIGHTPARENTHESIS:\n\t\t\tacc = TRUE;\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tbreak;\n\t\tcase COMMA:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == INT) {\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tif(*tok == ID) {\n\t\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\t\tOptparams(tok, val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tacc = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tacc = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Optparams (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * stmts\t->\tstmt stmts\n *\t\t\t\t|\t\tstmt }\n */\n", "func_signal": "int Stmts(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Stmts +++\\n\");\n\tif(Stmt(tok, val)) {\n\t\tswitch(*tok) {\n\t\t\tcase RIGHTBRACE:\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tacc = TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tacc = Stmts(tok, val);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tacc = FALSE;\n\t}\n\n\tprintf(\"\\n--- Stmts (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * decls\t->\t, ID decls\n * \t\t\t\t|\t\t;\n */\n", "func_signal": "int Decls(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Decls +++\\n\");\n\tswitch(*tok) {\n\t\tcase COMMA:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == ID) {\n\t\t\t\tfprintf(gfile, \"declare %s\\n\", gstring);\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tacc = Decls(tok, val);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tacc = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEMICOLON:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tacc = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Decls (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/* Adds the symrec (the first parameter) to the hash table of the symbol table of that symrec. If hash\n   insert fails (the name of the symrec already exists) it will return 0 and set the integer pointed to\n   by the second parameter to 0. */\n", "func_signal": "static int add_to_hash_table(void *list_data, void *ok)", "code": "{\n   t_symrec *symrec=list_data;\n   if (hash_insert(symrec->symtab->lookup_table, symrec->s, symrec) == 0) {\n      *(int*)ok = 0;\n      return 0;\n   } else {\n      return 1;\n   }\n}", "path": "lab3\\src\\symbol.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * Read next from file\n */\n", "func_signal": "char readNext(FILE *fp)", "code": "{\n\tchar ret;\n\tif(fread(&ret, 1, 1, fp));\n\telse\n\t\tret = '\\004';\n\treturn ret;\n}", "path": "lab1\\scanner.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * params\t->\tVOID )\n *\t\t\t\t|\t\tINT ID optpar\n */\n", "func_signal": "int Params(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Params +++\\n\");\n\tswitch(*tok) {\n\t\tcase VOID:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == RIGHTPARENTHESIS) {\n\t\t\t\tacc = TRUE;\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tacc = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INT:\n\t\t\tgetNextToken(tok, val, gstring);\n\t\t\tif(*tok == ID) {\n\t\t\t\tgetNextToken(tok, val, gstring);\n\t\t\t\tacc = Optparams(tok, val);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacc = FALSE;\n\t\t\tbreak;\n\t}\n\n\tprintf(\"\\n--- Params (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * Check if the char is a numeric value\n */\n", "func_signal": "int isNumeric(char arg)", "code": "{\n\tif(arg > 47 && arg < 58)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "lab1\\scanner.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * expr\t\t->\tterm exprs\n */\n", "func_signal": "int Expr(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Expr +++\\n\");\n\tif(Term(tok, val))\n\t\tacc = Exprs(tok, val);\n\telse\n\t\tacc = FALSE;\n\n\tprintf(\"\\n--- Expr (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * prog\t\t->\tfunc funclst\n */\n", "func_signal": "int Prog(char *filename)", "code": "{\n\tint acc;\n\tint tok, val;\n\n\tif(filename == NULL) {\n\t\treturn -1;\n\t}\n\n\tgfile = fopen(filename, \"w\");\n\n\tprintf(\"+++ Prog +++\\n\");\n\tgetNextToken(&tok, &val, gstring);\n\tif((acc = Func(&tok, &val))) {\n\t\tacc = Funclst(&tok, &val);\n\t}\n\tprintf(\"\\n--- Prog (%d) ---\\n\", acc  );\n\tfclose(gfile);\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * Match an Integer.\n */\n", "func_signal": "char * matchNum(char c)", "code": "{\n\tchar * buf = (char *)malloc(sizeof(char)*20);\n\tFILE * fp = globalFile(SCAN_GET, \"\");\n\tchar tmp;\n\tint pos = 0;\n\tbuf[pos] = c;\n\tpos++;\n\twhile(1){\n\t\ttmp = readNext(fp);\n\t\tif(isNumeric(tmp)){\n\t\t\tbuf[pos] = tmp;\n\t\t\tpos++;\n\t\t}\n\t\telse{\n\t\t\tungetc(tmp, fp);\n\t\t\tbuf[pos] = '\\0';\n\t\t\treturn buf;\n\t\t}\n\t}\n}", "path": "lab1\\scanner.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/*\n * factor\t->\tfac\tfactors\n */\n", "func_signal": "int Factor(int *tok, int *val)", "code": "{\n\tint acc;\n\n\tprintf(\"+++ Factor +++\\n\");\n\tif(!Fac(tok, val))\n\t\tacc = FALSE;\n\telse\n\t\tacc = Factors(tok, val);\n\n\tprintf(\"\\n--- Factors (%d) ---\\n\", acc  );\n\treturn acc;\n}", "path": "lab1\\parser.c", "repo_name": "ostmackan/cdt301", "stars": 3, "license": "None", "language": "c", "size": 1836}
{"docstring": "/* Calculate number of actual lines (with wraps), to set adj->lower. *\n * This should only be called when the window resizes.               */\n", "func_signal": "static void\ngtk_xtext_calc_lines (xtext_buffer *buf, int fire_signal)", "code": "{\n\ttextentry *ent;\n\tint width;\n\tint height;\n\tint lines;\n\n\tgdk_drawable_get_size (GTK_WIDGET (buf->xtext)->window, &width, &height);\n\twidth -= MARGIN;\n\n\tif (width < 30 || height < buf->xtext->fontsize || width < buf->indent + 30)\n\t\treturn;\n\n\tlines = 0;\n\tent = buf->text_first;\n\twhile (ent)\n\t{\n\t\tent->lines_taken = gtk_xtext_lines_taken (buf, ent);\n\t\tlines += ent->lines_taken;\n\t\tent = ent->next;\n\t}\n\n\tbuf->pagetop_ent = NULL;\n\tbuf->num_lines = lines;\n\tgtk_xtext_adjustment_set (buf, fire_signal);\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* render enta (or an inclusive range enta->entb) */\n", "func_signal": "static int\ngtk_xtext_render_ents (GtkXText * xtext, textentry * enta, textentry * entb)", "code": "{\n\ttextentry *ent, *orig_ent, *tmp_ent;\n\tint line;\n\tint lines_max;\n\tint width;\n\tint height;\n\tint subline;\n\tint drawing = FALSE;\n\n\tif (xtext->buffer->indent < MARGIN)\n\t\txtext->buffer->indent = MARGIN;\t  /* 2 pixels is our left margin */\n\n\tgdk_drawable_get_size (GTK_WIDGET (xtext)->window, &width, &height);\n\twidth -= MARGIN;\n\n\tif (width < 32 || height < xtext->fontsize || width < xtext->buffer->indent + 30)\n\t\treturn 0;\n\n\tlines_max = ((height + xtext->pixel_offset) / xtext->fontsize) + 1;\n\tline = 0;\n\torig_ent = xtext->buffer->pagetop_ent;\n\tsubline = xtext->buffer->pagetop_subline;\n\n\t/* used before a complete page is in buffer */\n\tif (orig_ent == NULL)\n\t\torig_ent = xtext->buffer->text_first;\n\n\t/* check if enta is before the start of this page */\n\tif (entb)\n\t{\n\t\ttmp_ent = orig_ent;\n\t\twhile (tmp_ent)\n\t\t{\n\t\t\tif (tmp_ent == enta)\n\t\t\t\tbreak;\n\t\t\tif (tmp_ent == entb)\n\t\t\t{\n\t\t\t\tdrawing = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_ent = tmp_ent->next;\n\t\t}\n\t}\n\n\tent = orig_ent;\n\twhile (ent)\n\t{\n\t\tif (entb && ent == enta)\n\t\t\tdrawing = TRUE;\n\n\t\tif (drawing || ent == entb || ent == enta)\n\t\t{\n\t\t\tgtk_xtext_reset (xtext, FALSE, TRUE);\n\t\t\tline += gtk_xtext_render_line (xtext, ent, line, lines_max,\n\t\t\t\t\t\t\t\t\t\t\t\t\t subline, width);\n\t\t\tsubline = 0;\n\t\t\txtext->jump_in_offset = 0;\t/* jump_in_offset only for the 1st */\n\t\t} else\n\t\t{\n\t\t\tif (ent == orig_ent)\n\t\t\t{\n\t\t\t\tline -= subline;\n\t\t\t\tsubline = 0;\n\t\t\t}\n\t\t\tline += ent->lines_taken;\n\t\t}\n\n\t\tif (ent == entb)\n\t\t\tbreak;\n\n\t\tif (line >= lines_max)\n\t\t\tbreak;\n\n\t\tent = ent->next;\n\t}\n\n\t/* space below last line */\n\treturn (xtext->fontsize * line) - xtext->pixel_offset;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* slow generic routine, for the depths/bpp we don't know about */\n", "func_signal": "static void\nshade_ximage_generic (GdkVisual *visual, XImage *ximg, int bpl, int w, int h, int rm, int gm, int bm, int bg)", "code": "{\n\tint x, y;\n\tint bgr = (256 - rm) * (bg & visual->red_mask);\n\tint bgg = (256 - gm) * (bg & visual->green_mask);\n\tint bgb = (256 - bm) * (bg & visual->blue_mask);\n\n\tfor (x = 0; x < w; x++)\n\t{\n\t\tfor (y = 0; y < h; y++)\n\t\t{\n\t\t\tunsigned long pixel = XGetPixel (ximg, x, y);\n\t\t\tint r, g, b;\n\n\t\t\tr = rm * (pixel & visual->red_mask) + bgr;\n\t\t\tg = gm * (pixel & visual->green_mask) + bgg;\n\t\t\tb = bm * (pixel & visual->blue_mask) + bgb;\n\n\t\t\tXPutPixel (ximg, x, y,\n\t\t\t\t\t\t\t((r >> 8) & visual->red_mask) |\n\t\t\t\t\t\t\t((g >> 8) & visual->green_mask) |\n\t\t\t\t\t\t\t((b >> 8) & visual->blue_mask));\n\t\t}\n\t}\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* render a single line, which WONT wrap, and parse mIRC colors */\n", "func_signal": "static int\ngtk_xtext_render_str (GtkXText * xtext, int y, textentry * ent,\n\t\t\t\t\t\t\t unsigned char *str, int len, int win_width, int indent,\n\t\t\t\t\t\t\t int line, int left_only)", "code": "{\n\tGdkGC *gc;\n\tint i = 0, x = indent, j = 0;\n\tunsigned char *pstr = str;\n\tint col_num, tmp;\n\tint offset;\n\tint mark = FALSE;\n\tint ret = 1;\n\n\txtext->in_hilight = FALSE;\n\n\toffset = str - ent->str;\n\n\tif (line < 255 && line >= 0)\n\t\txtext->buffer->grid_offset[line] = offset;\n\n\tgc = xtext->fgc;\t\t\t\t  /* our foreground GC */\n\n\tif (ent->mark_start != -1 &&\n\t\t ent->mark_start <= i + offset && ent->mark_end > i + offset)\n\t{\n\t\txtext_set_bg (xtext, gc, XTEXT_MARK_BG);\n\t\txtext_set_fg (xtext, gc, XTEXT_MARK_FG);\n\t\txtext->backcolor = TRUE;\n\t\tmark = TRUE;\n\t}\n#ifdef MOTION_MONITOR\n\tif (xtext->hilight_ent == ent &&\n\t\t xtext->hilight_start <= i + offset && xtext->hilight_end > i + offset)\n\t{\n\t\tif (!xtext->un_hilight)\n\t\t{\n#ifdef COLOR_HILIGHT\n\t\t\txtext_set_bg (xtext, gc, 2);\n#else\n\t\t\txtext->underline = TRUE;\n#endif\n\t\t}\n\t\txtext->in_hilight = TRUE;\n\t}\n#endif\n\n\tif (!xtext->skip_border_fills && !xtext->dont_render)\n\t{\n\t\t/* draw background to the left of the text */\n\t\tif (str == ent->str && indent > MARGIN && xtext->buffer->time_stamp)\n\t\t{\n\t\t\t/* don't overwrite the timestamp */\n\t\t\tif (indent > xtext->stamp_width)\n\t\t\t{\n\t\t\t\txtext_draw_bg (xtext, xtext->stamp_width, y - xtext->font->ascent,\n\t\t\t\t\t\t\t\t\tindent - xtext->stamp_width, xtext->fontsize);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\t/* fill the indent area with background gc */\n\t\t\tif (indent >= xtext->clip_x)\n\t\t\t{\n\t\t\t\txtext_draw_bg (xtext, 0, y - xtext->font->ascent,\n\t\t\t\t\t\t\t\t\tMIN (indent, xtext->clip_x2), xtext->fontsize);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (xtext->jump_in_offset > 0 && offset < xtext->jump_in_offset)\n\t\txtext->dont_render2 = TRUE;\n\n\twhile (i < len)\n\t{\n\n#ifdef MOTION_MONITOR\n\t\tif (xtext->hilight_ent == ent && xtext->hilight_start == (i + offset))\n\t\t{\n\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tpstr += j;\n\t\t\tj = 0;\n\t\t\tif (!xtext->un_hilight)\n\t\t\t{\n#ifdef COLOR_HILIGHT\n\t\t\t\txtext_set_bg (xtext, gc, 2);\n#else\n\t\t\t\txtext->underline = TRUE;\n#endif\n\t\t\t}\n\n\t\t\txtext->in_hilight = TRUE;\n\t\t}\n#endif\n\n\t\tif ((xtext->parsing_color && isdigit (str[i]) && xtext->nc < 2) ||\n\t\t\t (xtext->parsing_color && str[i] == ',' && isdigit (str[i+1]) && xtext->nc < 3))\n\t\t{\n\t\t\tpstr++;\n\t\t\tif (str[i] == ',')\n\t\t\t{\n\t\t\t\txtext->parsing_backcolor = TRUE;\n\t\t\t\tif (xtext->nc)\n\t\t\t\t{\n\t\t\t\t\txtext->num[xtext->nc] = 0;\n\t\t\t\t\txtext->nc = 0;\n\t\t\t\t\tcol_num = atoi (xtext->num);\n\t\t\t\t\tif (col_num == 99)\t/* mIRC lameness */\n\t\t\t\t\t\tcol_num = XTEXT_FG;\n\t\t\t\t\telse\n\t\t\t\t\t\tcol_num = col_num % XTEXT_MIRC_COLS;\n\t\t\t\t\txtext->col_fore = col_num;\n\t\t\t\t\tif (!mark)\n\t\t\t\t\t\txtext_set_fg (xtext, gc, col_num);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\txtext->num[xtext->nc] = str[i];\n\t\t\t\tif (xtext->nc < 7)\n\t\t\t\t\txtext->nc++;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tif (xtext->parsing_color)\n\t\t\t{\n\t\t\t\txtext->parsing_color = FALSE;\n\t\t\t\tif (xtext->nc)\n\t\t\t\t{\n\t\t\t\t\txtext->num[xtext->nc] = 0;\n\t\t\t\t\txtext->nc = 0;\n\t\t\t\t\tcol_num = atoi (xtext->num);\n\t\t\t\t\tif (xtext->parsing_backcolor)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col_num == 99)\t/* mIRC lameness */\n\t\t\t\t\t\t\tcol_num = XTEXT_BG;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcol_num = col_num % XTEXT_MIRC_COLS;\n\t\t\t\t\t\tif (col_num == XTEXT_BG)\n\t\t\t\t\t\t\txtext->backcolor = FALSE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txtext->backcolor = TRUE;\n\t\t\t\t\t\tif (!mark)\n\t\t\t\t\t\t\txtext_set_bg (xtext, gc, col_num);\n\t\t\t\t\t\txtext->col_back = col_num;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col_num == 99)\t/* mIRC lameness */\n\t\t\t\t\t\t\tcol_num = XTEXT_FG;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcol_num = col_num % XTEXT_MIRC_COLS;\n\t\t\t\t\t\tif (!mark)\n\t\t\t\t\t\t\txtext_set_fg (xtext, gc, col_num);\n\t\t\t\t\t\txtext->col_fore = col_num;\n\t\t\t\t\t}\n\t\t\t\t\txtext->parsing_backcolor = FALSE;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t/* got a \\003<non-digit>... i.e. reset colors */\n\t\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\t\tpstr += j;\n\t\t\t\t\tj = 0;\n\t\t\t\t\tgtk_xtext_reset (xtext, mark, FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (str[i])\n\t\t\t{\n\t\t\tcase '\\n':\n\t\t\t/*case ATTR_BEEP:*/\n\t\t\t\tbreak;\n\t\t\tcase ATTR_REVERSE:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\ttmp = xtext->col_fore;\n\t\t\t\txtext->col_fore = xtext->col_back;\n\t\t\t\txtext->col_back = tmp;\n\t\t\t\tif (!mark)\n\t\t\t\t{\n\t\t\t\t\txtext_set_fg (xtext, gc, xtext->col_fore);\n\t\t\t\t\txtext_set_bg (xtext, gc, xtext->col_back);\n\t\t\t\t}\n\t\t\t\tif (xtext->col_back != XTEXT_BG)\n\t\t\t\t\txtext->backcolor = TRUE;\n\t\t\t\telse\n\t\t\t\t\txtext->backcolor = FALSE;\n\t\t\t\tbreak;\n\t\t\tcase ATTR_BOLD:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\txtext->bold = !xtext->bold;\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\tbreak;\n\t\t\tcase ATTR_UNDERLINE:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\txtext->underline = !xtext->underline;\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\tbreak;\n\t\t\tcase ATTR_ITALICS:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\txtext->italics = !xtext->italics;\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\tbreak;\n\t\t\tcase ATTR_RESET:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\tgtk_xtext_reset (xtext, mark, !xtext->in_hilight);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_COLOR:\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\txtext->parsing_color = TRUE;\n\t\t\t\tpstr += j + 1;\n\t\t\t\tj = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp = charlen (str + i);\n\t\t\t\t/* invalid utf8 safe guard */\n\t\t\t\tif (tmp + i > len)\n\t\t\t\t\ttmp = len - i;\n\t\t\t\tj += tmp;\t/* move to the next utf8 char */\n\t\t\t}\n\t\t}\n\t\ti += charlen (str + i);\t/* move to the next utf8 char */\n\t\t/* invalid utf8 safe guard */\n\t\tif (i > len)\n\t\t\ti = len;\n\n\t\t/* Separate the left part, the space and the right part\n\t\t   into separate runs, and reset bidi state inbetween.\n\t\t   Perform this only on the first line of the message.\n                */\n\t\tif (offset == 0)\n\t\t{\n\t\t\t/* we've reached the end of the left part? */\n\t\t\tif ((pstr-str)+j == ent->left_len)\n\t\t\t{\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\tpstr += j;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\telse if ((pstr-str)+j == ent->left_len+1)\n\t\t\t{\n\t\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\t\tpstr += j;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* have we been told to stop rendering at this point? */\n\t\tif (xtext->jump_out_offset > 0 && xtext->jump_out_offset <= (i + offset))\n\t\t{\n\t\t\tgtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tret = 0;\t/* skip the rest of the lines, we're done. */\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (xtext->jump_in_offset > 0 && xtext->jump_in_offset == (i + offset))\n\t\t{\n\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tpstr += j;\n\t\t\tj = 0;\n\t\t\txtext->dont_render2 = FALSE;\n\t\t}\n\n#ifdef MOTION_MONITOR\n\t\tif (xtext->hilight_ent == ent && xtext->hilight_end == (i + offset))\n\t\t{\n\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tpstr += j;\n\t\t\tj = 0;\n#ifdef COLOR_HILIGHT\n\t\t\tif (mark)\n\t\t\t{\n\t\t\t\txtext_set_bg (xtext, gc, XTEXT_MARK_BG);\n\t\t\t\txtext->backcolor = TRUE;\n\t\t\t} else\n\t\t\t{\n\t\t\t\txtext_set_bg (xtext, gc, xtext->col_back);\n\t\t\t\tif (xtext->col_back != XTEXT_BG)\n\t\t\t\t\txtext->backcolor = TRUE;\n\t\t\t\telse\n\t\t\t\t\txtext->backcolor = FALSE;\n\t\t\t}\n#else\n\t\t\txtext->underline = FALSE;\n#endif\n\t\t\txtext->in_hilight = FALSE;\n\t\t\tif (xtext->render_hilights_only)\n\t\t\t{\n\t\t\t\t/* stop drawing this ent */\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (!mark && ent->mark_start == (i + offset))\n\t\t{\n\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tpstr += j;\n\t\t\tj = 0;\n\t\t\txtext_set_bg (xtext, gc, XTEXT_MARK_BG);\n\t\t\txtext_set_fg (xtext, gc, XTEXT_MARK_FG);\n\t\t\txtext->backcolor = TRUE;\n\t\t\tmark = TRUE;\n\t\t}\n\n\t\tif (mark && ent->mark_end == (i + offset))\n\t\t{\n\t\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\t\t\tpstr += j;\n\t\t\tj = 0;\n\t\t\txtext_set_bg (xtext, gc, xtext->col_back);\n\t\t\txtext_set_fg (xtext, gc, xtext->col_fore);\n\t\t\tif (xtext->col_back != XTEXT_BG)\n\t\t\t\txtext->backcolor = TRUE;\n\t\t\telse\n\t\t\t\txtext->backcolor = FALSE;\n\t\t\tmark = FALSE;\n\t\t}\n\n\t}\n\n\tif (j)\n\t\tx += gtk_xtext_render_flush (xtext, x, y, pstr, j, gc, ent->mb);\n\n\tif (mark)\n\t{\n\t\txtext_set_bg (xtext, gc, xtext->col_back);\n\t\txtext_set_fg (xtext, gc, xtext->col_fore);\n\t\tif (xtext->col_back != XTEXT_BG)\n\t\t\txtext->backcolor = TRUE;\n\t\telse\n\t\t\txtext->backcolor = FALSE;\n\t}\n\n\t/* draw background to the right of the text */\n\tif (!left_only && !xtext->dont_render)\n\t{\n\t\t/* draw separator now so it doesn't appear to flicker */\n\t\tgtk_xtext_draw_sep (xtext, y - xtext->font->ascent);\n\t\tif (!xtext->skip_border_fills && xtext->clip_x2 >= x)\n\t\t{\n\t\t\tint xx = MAX (x, xtext->clip_x);\n\n\t\t\txtext_draw_bg (xtext,\n\t\t\t\t\t\t\t\txx,\t/* x */\n\t\t\t\t\t\t\t\ty - xtext->font->ascent, /* y */\n\t\t\t\tMIN (xtext->clip_x2 - xx, (win_width + MARGIN) - xx), /* width */\n\t\t\t\t\t\t\t\txtext->fontsize);\t\t/* height */\n\t\t}\n\t}\n\n\txtext->dont_render2 = FALSE;\n\n\treturn ret;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* another program is asking for our selection */\n", "func_signal": "static void\ngtk_xtext_selection_get (GtkWidget * widget,\n\t\t\t\t\t\t\t\t GtkSelectionData * selection_data_ptr,\n\t\t\t\t\t\t\t\t guint info, guint time)", "code": "{\n\tGtkXText *xtext = GTK_XTEXT (widget);\n\tchar *stripped;\n\tguchar *new_text;\n\tint len;\n\tgsize glen;\n\n\tstripped = gtk_xtext_selection_get_text (xtext, &len);\n\tif (!stripped)\n\t\treturn;\n\n\tswitch (info)\n\t{\n\tcase TARGET_UTF8_STRING:\n\t\t/* it's already in utf8 */\n\t\tgtk_selection_data_set_text (selection_data_ptr, stripped, len);\n\t\tbreak;\n\tcase TARGET_TEXT:\n\tcase TARGET_COMPOUND_TEXT:\n\t\t{\n\t\t\tGdkAtom encoding;\n\t\t\tgint format;\n\t\t\tgint new_length;\n\n#if (GTK_MAJOR_VERSION == 2) && (GTK_MINOR_VERSION == 0)\n\t\t\tgdk_string_to_compound_text (\n#else\n\t\t\tgdk_string_to_compound_text_for_display (\n\t\t\t\t\t\t\t\t\t\t\t\tgdk_drawable_get_display (widget->window),\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\tstripped, &encoding, &format, &new_text,\n\t\t\t\t\t\t\t\t\t\t\t\t&new_length);\n\t\t\tgtk_selection_data_set (selection_data_ptr, encoding, format,\n\t\t\t\t\t\t\t\t\t\t\tnew_text, new_length);\n\t\t\tgdk_free_compound_text (new_text);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnew_text = g_locale_from_utf8 (stripped, len, NULL, &glen, NULL);\n\t\tgtk_selection_data_set (selection_data_ptr, GDK_SELECTION_TYPE_STRING,\n\t\t\t\t\t\t\t\t\t\t8, new_text, glen);\n\t\tg_free (new_text);\n\t}\n\n\tfree (stripped);\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* find the n-th line in the linked list, this includes wrap calculations */\n", "func_signal": "static textentry *\ngtk_xtext_nth (GtkXText *xtext, int line, int *subline)", "code": "{\n\tint lines = 0;\n\ttextentry *ent;\n\n\tent = xtext->buffer->text_first;\n\n\t/* -- optimization -- try to make a short-cut using the pagetop ent */\n\tif (xtext->buffer->pagetop_ent)\n\t{\n\t\tif (line == xtext->buffer->pagetop_line)\n\t\t{\n\t\t\t*subline = xtext->buffer->pagetop_subline;\n\t\t\treturn xtext->buffer->pagetop_ent;\n\t\t}\n\t\tif (line > xtext->buffer->pagetop_line)\n\t\t{\n\t\t\t/* lets start from the pagetop instead of the absolute beginning */\n\t\t\tent = xtext->buffer->pagetop_ent;\n\t\t\tlines = xtext->buffer->pagetop_line - xtext->buffer->pagetop_subline;\n\t\t}\n\t\telse if (line > xtext->buffer->pagetop_line - line)\n\t\t{\n\t\t\t/* move backwards from pagetop */\n\t\t\tent = xtext->buffer->pagetop_ent;\n\t\t\tlines = xtext->buffer->pagetop_line - xtext->buffer->pagetop_subline;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (lines <= line)\n\t\t\t\t{\n\t\t\t\t\t*subline = line - lines;\n\t\t\t\t\treturn ent;\n\t\t\t\t}\n\t\t\t\tent = ent->prev;\n\t\t\t\tif (!ent)\n\t\t\t\t\tbreak;\n\t\t\t\tlines -= ent->lines_taken;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* -- end of optimization -- */\n\n\twhile (ent)\n\t{\n\t\tlines += ent->lines_taken;\n\t\tif (lines > line)\n\t\t{\n\t\t\t*subline = ent->lines_taken - (lines - line);\n\t\t\treturn ent;\n\t\t}\n\t\tent = ent->next;\n\t}\n\treturn 0;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* another program has claimed the selection */\n", "func_signal": "static gboolean\ngtk_xtext_selection_kill (GtkXText *xtext, GdkEventSelection *event)", "code": "{\n#ifndef WIN32\n\tif (xtext->buffer->last_ent_start)\n\t\tgtk_xtext_unselect (xtext);\n#endif\n\treturn TRUE;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* actually draw text to screen (one run with the same color/attribs) */\n", "func_signal": "static int\ngtk_xtext_render_flush (GtkXText * xtext, int x, int y, unsigned char *str,\n\t\t\t\t\t\t\t\tint len, GdkGC *gc, int is_mb)", "code": "{\n\tint str_width, dofill;\n\tGdkDrawable *pix = NULL;\n\tint dest_x, dest_y;\n\n\tif (xtext->dont_render || len < 1)\n\t\treturn 0;\n\n\tstr_width = backend_get_text_width (xtext, str, len, is_mb);\n\n\tif (xtext->dont_render2)\n\t\treturn str_width;\n\n\t/* roll-your-own clipping (avoiding XftDrawString is always good!) */\n\tif (x > xtext->clip_x2 || x + str_width < xtext->clip_x)\n\t\treturn str_width;\n\tif (y - xtext->font->ascent > xtext->clip_y2 || (y - xtext->font->ascent) + xtext->fontsize < xtext->clip_y)\n\t\treturn str_width;\n\n\tif (xtext->render_hilights_only)\n\t{\n\t\tif (!xtext->in_hilight)\t/* is it a hilight prefix? */\n\t\t\treturn str_width;\n#ifndef COLOR_HILIGHT\n\t\tif (!xtext->un_hilight)\t/* doing a hilight? no need to draw the text */\n\t\t\tgoto dounder;\n#endif\n\t}\n\n#ifdef USE_DB\n#ifdef WIN32\n\tif (!xtext->transparent)\n#endif\n\t{\n\t\tpix = gdk_pixmap_new (xtext->draw_buf, str_width, xtext->fontsize, xtext->depth);\n\t\tif (pix)\n\t\t{\n#ifdef USE_XFT\n\t\t\tXftDrawChange (xtext->xftdraw, GDK_WINDOW_XWINDOW (pix));\n#endif\n\t\t\tdest_x = x;\n\t\t\tdest_y = y - xtext->font->ascent;\n\n\t\t\tgdk_gc_set_ts_origin (xtext->bgc, xtext->ts_x - x, xtext->ts_y - dest_y);\n\n\t\t\tx = 0;\n\t\t\ty = xtext->font->ascent;\n\t\t\txtext->draw_buf = pix;\n\t\t}\n\t}\n#endif\n\n\tdofill = TRUE;\n\n\t/* backcolor is always handled by XDrawImageString */\n\tif (!xtext->backcolor && xtext->pixmap)\n\t{\n\t/* draw the background pixmap behind the text - CAUSES FLICKER HERE!! */\n\t\txtext_draw_bg (xtext, x, y - xtext->font->ascent, str_width,\n\t\t\t\t\t\t\txtext->fontsize);\n\t\tdofill = FALSE;\t/* already drawn the background */\n\t}\n\n\tbackend_draw_text (xtext, dofill, gc, x, y, str, len, str_width, is_mb);\n\n#ifdef USE_DB\n\tif (pix)\n\t{\n\t\tGdkRectangle clip;\n\t\tGdkRectangle dest;\n\n\t\tgdk_gc_set_ts_origin (xtext->bgc, xtext->ts_x, xtext->ts_y);\n\t\txtext->draw_buf = GTK_WIDGET (xtext)->window;\n#ifdef USE_XFT\n\t\tXftDrawChange (xtext->xftdraw, GDK_WINDOW_XWINDOW (xtext->draw_buf));\n#endif\n#if 0\n\t\tgdk_draw_drawable (xtext->draw_buf, xtext->bgc, pix, 0, 0, dest_x,\n\t\t\t\t\t\t\t\t dest_y, str_width, xtext->fontsize);\n#else\n\t\tclip.x = xtext->clip_x;\n\t\tclip.y = xtext->clip_y;\n\t\tclip.width = xtext->clip_x2 - xtext->clip_x;\n\t\tclip.height = xtext->clip_y2 - xtext->clip_y;\n\n\t\tdest.x = dest_x;\n\t\tdest.y = dest_y;\n\t\tdest.width = str_width;\n\t\tdest.height = xtext->fontsize;\n\n\t\tif (gdk_rectangle_intersect (&clip, &dest, &dest))\n\t\t\t/* dump the DB to window, but only within the clip_x/x2/y/y2 */\n\t\t\tgdk_draw_drawable (xtext->draw_buf, xtext->bgc, pix,\n\t\t\t\t\t\t\t\t\t dest.x - dest_x, dest.y - dest_y,\n\t\t\t\t\t\t\t\t\t dest.x, dest.y, dest.width, dest.height);\n#endif\n\t\tg_object_unref (pix);\n\t}\n#endif\n\n\tif (xtext->underline)\n\t{\n#ifdef USE_XFT\n\t\tGdkColor col;\n#endif\n\n#ifndef COLOR_HILIGHT\ndounder:\n#endif\n\n#ifdef USE_XFT\n\t\tcol.pixel = xtext->xft_fg->pixel;\n\t\tgdk_gc_set_foreground (gc, &col);\n#endif\n\t\tif (pix)\n\t\t\ty = dest_y + xtext->font->ascent + 1;\n\t\telse\n\t\t{\n\t\t\ty++;\n\t\t\tdest_x = x;\n\t\t}\n\t\t/* draw directly to window, it's out of the range of our DB */\n\t\tgdk_draw_line (xtext->draw_buf, gc, dest_x, y, dest_x + str_width - 1, y);\n\t}\n\n\treturn str_width;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* GeEkMaN: converts mIRC control codes to literal control codes */\n", "func_signal": "static char *\ngtk_xtext_conv_color (unsigned char *text, int len, int *newlen)", "code": "{\n\tint i, j = 2;\n\tchar cchar = 0;\n\tchar *new_str;\n\tint mbl;\n\n\tfor (i = 0; i < len;)\n\t{\n\t\tswitch (text[i])\n\t\t{\n\t\tcase ATTR_COLOR:\n\t\tcase ATTR_RESET:\n\t\tcase ATTR_REVERSE:\n\t\tcase ATTR_BOLD:\n\t\tcase ATTR_UNDERLINE:\n\t\tcase ATTR_ITALICS:\n\t\t\tj += 3;\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmbl = charlen (text + i);\n\t\t\tj += mbl;\n\t\t\ti += mbl;\n\t\t}\n\t}\n\n\tnew_str = malloc (j);\n\tj = 0;\n\n\tfor (i = 0; i < len;)\n\t{\n\t\tswitch (text[i])\n\t\t{\n\t\tcase ATTR_COLOR:\n\t\t\tcchar = 'C';\n\t\t\tbreak;\n\t\tcase ATTR_RESET:\n\t\t\tcchar = 'O';\n\t\t\tbreak;\n\t\tcase ATTR_REVERSE:\n\t\t\tcchar = 'R';\n\t\t\tbreak;\n\t\tcase ATTR_BOLD:\n\t\t\tcchar = 'B';\n\t\t\tbreak;\n\t\tcase ATTR_UNDERLINE:\n\t\t\tcchar = 'U';\n\t\t\tbreak;\n\t\tcase ATTR_ITALICS:\n\t\t\tcchar = 'I';\n\t\t\tbreak;\n\t\tcase ATTR_BEEP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmbl = charlen (text + i);\n\t\t\tif (mbl == 1)\n\t\t\t{\n\t\t\t\tnew_str[j] = text[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t/* invalid utf8 safe guard */\n\t\t\t\tif (i + mbl > len)\n\t\t\t\t\tmbl = len - i;\n\t\t\t\tmemcpy (new_str + j, text + i, mbl);\n\t\t\t\tj += mbl;\n\t\t\t\ti += mbl;\n\t\t\t}\n\t\t}\n\t\tif (cchar != 0)\n\t\t{\n\t\t\tnew_str[j++] = '%';\n\t\t\tnew_str[j++] = cchar;\n\t\t\tcchar = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tnew_str[j] = 0;\n\t*newlen = j;\n\n\treturn new_str;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* remove the topline from the list */\n", "func_signal": "static void\ngtk_xtext_remove_top (xtext_buffer *buffer)", "code": "{\n\ttextentry *ent;\n\n\tent = buffer->text_first;\n\tif (!ent)\n\t\treturn;\n\tbuffer->num_lines -= ent->lines_taken;\n\tbuffer->pagetop_line -= ent->lines_taken;\n\tbuffer->last_pixel_pos -= (ent->lines_taken * buffer->xtext->fontsize);\n\tbuffer->text_first = ent->next;\n\tbuffer->text_first->prev = NULL;\n\n\tbuffer->old_value -= ent->lines_taken;\n\tif (buffer->xtext->buffer == buffer)\t/* is it the current buffer? */\n\t{\n\t\tbuffer->xtext->adj->value -= ent->lines_taken;\n\t\tbuffer->xtext->select_start_adj -= ent->lines_taken;\n\t}\n\n\tif (ent == buffer->pagetop_ent)\n\t\tbuffer->pagetop_ent = NULL;\n\n\tif (ent == buffer->last_ent_start)\n\t\tbuffer->last_ent_start = ent->next;\n\n\tif (ent == buffer->last_ent_end)\n\t{\n\t\tbuffer->last_ent_start = NULL;\n\t\tbuffer->last_ent_end = NULL;\n\t}\n\n\tif (buffer->marker_pos == ent) buffer->marker_pos = NULL;\n\n\tfree (ent);\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* render a selection that has extended or contracted upward */\n", "func_signal": "static void\ngtk_xtext_selection_up (GtkXText *xtext, textentry *start, textentry *end,\n\t\t\t\t\t\t\t\tint start_offset)", "code": "{\n\t/* render all the complete lines */\n\tif (start->next == end)\n\t\tgtk_xtext_render_ents (xtext, end, NULL);\n\telse\n\t\tgtk_xtext_render_ents (xtext, start->next, end);\n\n\t/* now the incomplete upper line */\n\tif (start == xtext->buffer->last_ent_start)\n\t\txtext->jump_in_offset = xtext->buffer->last_offset_start;\n\telse\n\t\txtext->jump_in_offset = start_offset;\n\tgtk_xtext_render_ents (xtext, start, NULL);\n\txtext->jump_in_offset = 0;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* Clear current list of players */\n", "func_signal": "void clear_player_list(void)", "code": "{\n\tGtkWidget *store = ggz_lookup_widget(player_list, \"player_list_store\");\n\n        gtk_list_store_clear(GTK_LIST_STORE(store));\n}", "path": "dependencies\\ggz-gtk\\playerlist.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* walk through str until this line doesn't fit anymore */\n", "func_signal": "static int\nfind_next_wrap (GtkXText * xtext, textentry * ent, unsigned char *str,\n\t\t\t\t\t int win_width, int indent)", "code": "{\n\tunsigned char *last_space = str;\n\tunsigned char *orig_str = str;\n\tint str_width = indent;\n\tint col = FALSE;\n\tint nc = 0;\n\tint mbl;\n\tint ret;\n\tint limit_offset = 0;\n\n\t/* single liners */\n\tif (win_width >= ent->str_width + ent->indent)\n\t\treturn ent->str_len;\n\n\t/* it does happen! */\n\tif (win_width < 1)\n\t{\n\t\tret = ent->str_len - (str - ent->str);\n\t\tgoto done;\n\t}\n\n\twhile (1)\n\t{\n\t\tif ((col && isdigit (*str) && nc < 2) ||\n\t\t\t (col && *str == ',' && isdigit (*(str+1)) && nc < 3))\n\t\t{\n\t\t\tnc++;\n\t\t\tif (*str == ',')\n\t\t\t\tnc = 0;\n\t\t\tlimit_offset++;\n\t\t\tstr++;\n\t\t} else\n\t\t{\n\t\t\tcol = FALSE;\n\t\t\tswitch (*str)\n\t\t\t{\n\t\t\tcase ATTR_COLOR:\n\t\t\t\tcol = TRUE;\n\t\t\t\tnc = 0;\n\t\t\tcase ATTR_BEEP:\n\t\t\tcase ATTR_RESET:\n\t\t\tcase ATTR_REVERSE:\n\t\t\tcase ATTR_BOLD:\n\t\t\tcase ATTR_UNDERLINE:\n\t\t\tcase ATTR_ITALICS:\n\t\t\t\tlimit_offset++;\n\t\t\t\tstr++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_width += backend_get_char_width (xtext, str, &mbl);\n\t\t\t\tif (str_width > win_width)\n\t\t\t\t{\n\t\t\t\t\tif (xtext->wordwrap)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str - last_space > WORDWRAP_LIMIT + limit_offset)\n\t\t\t\t\t\t\tret = str - orig_str; /* fall back to character wrap */\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (*last_space == ' ')\n\t\t\t\t\t\t\t\tlast_space++;\n\t\t\t\t\t\t\tret = last_space - orig_str;\n\t\t\t\t\t\t\tif (ret == 0) /* fall back to character wrap */\n\t\t\t\t\t\t\t\tret = str - orig_str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tret = str - orig_str;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* keep a record of the last space, for wordwrapping */\n\t\t\t\tif (is_del (*str))\n\t\t\t\t{\n\t\t\t\t\tlast_space = str;\n\t\t\t\t\tlimit_offset = 0;\n\t\t\t\t}\n\n\t\t\t\t/* progress to the next char */\n\t\t\t\tstr += mbl;\n\n\t\t\t}\n\t\t}\n\n\t\tif (str >= ent->str + ent->str_len)\n\t\t{\n\t\t\tret = str - orig_str;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\n\t/* must make progress */\n\tif (ret < 1)\n\t\tret = 1;\n\n\treturn ret;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* RGB 24 */\n", "func_signal": "static void\nshade_ximage_24 (void *data, int bpl, int w, int h, int rm, int gm, int bm, int bg)", "code": "{\n\t/* 24 has to be a special case, there's no guint24, or 24bit MOV :) */\n\tunsigned char *ptr;\n\tint x, y;\n\tint bgr = (256 - rm) * ((bg & 0xff0000) >> 16);\n\tint bgg = (256 - gm) * ((bg & 0xff00) >> 8);\n\tint bgb = (256 - bm) * (bg & 0xff);\n\n\tptr = (unsigned char *) data + (w * 3);\n\tfor (y = h; --y >= 0;)\n\t{\n\t\tfor (x = -(w * 3); x < 0; x += 3)\n\t\t{\n\t\t\tint r, g, b;\n\n#if (G_BYTE_ORDER == G_BIG_ENDIAN)\n\t\t\tr = (ptr[x + 0] * rm + bgr) >> 8;\n\t\t\tg = (ptr[x + 1] * gm + bgg) >> 8;\n\t\t\tb = (ptr[x + 2] * bm + bgb) >> 8;\n\t\t\tptr[x + 0] = r;\n\t\t\tptr[x + 1] = g;\n\t\t\tptr[x + 2] = b;\n#else\n\t\t\tr = (ptr[x + 2] * rm + bgr) >> 8;\n\t\t\tg = (ptr[x + 1] * gm + bgg) >> 8;\n\t\t\tb = (ptr[x + 0] * bm + bgb) >> 8;\n\t\t\tptr[x + 2] = r;\n\t\t\tptr[x + 1] = g;\n\t\t\tptr[x + 0] = b;\n#endif\n\t\t}\n\t\tptr += bpl;\n\t}\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* gives width of a 8bit string - with no mIRC codes in it */\n", "func_signal": "static int\ngtk_xtext_text_width_8bit (GtkXText *xtext, unsigned char *str, int len)", "code": "{\n\tint width = 0;\n\n\twhile (len)\n\t{\n\t\twidth += xtext->fontwidth[*str];\n\t\tstr++;\n\t\tlen--;\n\t}\n\n\treturn width;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* find the offset, in bytes, that wrap number 'line' starts at */\n", "func_signal": "static int\ngtk_xtext_find_subline (GtkXText *xtext, textentry *ent, int line)", "code": "{\n\tint win_width;\n\tunsigned char *str;\n\tint indent, str_pos, line_pos, len;\n\n\tif (ent->lines_taken < 2 || line < 1)\n\t\treturn 0;\n\n\t/* we record the first 4 lines' wraps, so take a shortcut */\n\tif (line <= RECORD_WRAPS)\n\t\treturn ent->wrap_offset[line - 1];\n\n\tgdk_drawable_get_size (GTK_WIDGET (xtext)->window, &win_width, 0);\n\twin_width -= MARGIN;\n\n/*\tindent = ent->indent;\n\tstr = ent->str;\n\tline_pos = str_pos = 0;*/\n\n\t/* start from the last recorded wrap, and move forward */\n\tindent = xtext->buffer->indent;\n\tstr_pos = ent->wrap_offset[RECORD_WRAPS-1];\n\tstr = str_pos + ent->str;\n\tline_pos = RECORD_WRAPS;\n\n\tdo\n\t{\n\t\tlen = find_next_wrap (xtext, ent, str, win_width, indent);\n\t\tindent = xtext->buffer->indent;\n\t\tstr += len;\n\t\tstr_pos += len;\n\t\tline_pos++;\n\t\tif (line_pos >= line)\n\t\t\treturn str_pos;\n\t}\n\twhile (str < ent->str + ent->str_len);\n\n\treturn 0;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* !USE_PANGO */\n", "func_signal": "static void\nxtext_set_fg (GtkXText *xtext, GdkGC *gc, int index)", "code": "{\n\tGdkColor col;\n\n\tcol.pixel = xtext->palette[index];\n\tgdk_gc_set_foreground (gc, &col);\n\n#ifdef USE_XFT\n\tif (gc == xtext->fgc)\n\t\txtext->xft_fg = &xtext->color[index];\n\telse\n\t\txtext->xft_bg = &xtext->color[index];\n#endif\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* Spectate is 1 if we're spectating; 0 if we're playing. */\n", "func_signal": "int game_initialize(int spectate)", "code": "{\n\tGGZRoom *room;\n\tGGZGameType *gt;\n\tGGZModule *module = NULL;\n\n\t/* Make sure we aren't already in a game */\n\tif (game) {\n\t\tmsgbox(_(\"You can only play one game at a time.\"),\n\t\t       _(\"Game Error\"), MSGBOX_OKONLY, MSGBOX_INFO,\n\t\t       MSGBOX_NORMAL);\n\t\treturn -1;\n\t}\n\n\t/* Make sure we're actually in a room and not already at a table */\n\tif (ggzcore_server_get_state(server) != GGZ_STATE_IN_ROOM) {\n\t\tmsgbox(_(\"You're still at a table.\"),\n\t\t       _(\"Game Error\"), MSGBOX_OKONLY, MSGBOX_INFO,\n\t\t       MSGBOX_NORMAL);\n\t\treturn -1;\n\t}\n\n\t/* Make sure we're in a room */\n\troom = ggzcore_server_get_cur_room(server);\n\tif (!room) {\n\t\tmsgbox(_(\"You must be in a room to launch a game.\\n\"\n\t\t\t \"Launch aborted\"),\n\t\t       _(\"Launch Error\"), MSGBOX_OKONLY, MSGBOX_STOP,\n\t\t       MSGBOX_NORMAL);\n\t\treturn -1;\n\t}\n\n\t/* Get game type for this room */\n\tgt = ggzcore_room_get_gametype(room);\n\tif (!gt) {\n\t\tmsgbox(_(\"No game types defined for this server.\\n\"\n\t\t\t \"Launch aborted.\"),\n\t\t       _(\"Launch Error\"), MSGBOX_OKONLY, MSGBOX_STOP,\n\t\t       MSGBOX_NORMAL);\n\t\treturn -1;\n\t}\n\n\t/* In principle this should have been checked earlier, but we didn't\n\t   know the game type then. */\n\tif (spectate && !ggzcore_gametype_get_spectators_allowed(gt)) {\n\t\tmsgbox(_(\"This game doesn't support spectators.\"),\n\t\t       _(\"Launch Error\"),\n\t\t       MSGBOX_OKONLY, MSGBOX_INFO, MSGBOX_NORMAL);\n\t\treturn -1;\n\t}\n\n\tif (embedded_protocol_engine && embedded_protocol_version) {\n\t\tconst char *engine = ggzcore_gametype_get_prot_engine(gt);\n\t\tconst char *version = ggzcore_gametype_get_prot_version(gt);\n\n\t\tmodule = NULL;\n\t\tif (strcmp(engine, embedded_protocol_engine) != 0\n\t\t    || strcmp(version, embedded_protocol_version) != 0) {\n\t\t  printf(\"%s %s vs %s %s\\n\", engine, version,\n\t\t\t embedded_protocol_engine, embedded_protocol_version);\n\t\t\tmsgbox(_(\"You need to launch the GGZ client directly\\n\"\n\t\t\t\t \"to be able to play this game.\"),\n\t\t\t       _(\"Launch Error\"),\n\t\t\t       MSGBOX_OKONLY, MSGBOX_STOP, MSGBOX_NORMAL);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tmodule = pick_module(gt);\n\t\tif (!module)\n\t\t\treturn -1;\n\t}\n\n\t/* Create new game using this module */\n\tgame = ggzcore_game_new();\n\tggzcore_game_init(game, server, module);\n\n\t/* Register callbacks */\n\tgame_register(game);\n\n\treturn 0;\n}", "path": "dependencies\\ggz-gtk\\game.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* simplified version of gdk_draw_layout_line_with_colors() */\n", "func_signal": "static void \nxtext_draw_layout_line (GdkDrawable      *drawable,\n\t\t\t\t\t\t\t\tGdkGC            *gc,\n\t\t\t\t\t\t\t\tgint              x, \n\t\t\t\t\t\t\t\tgint              y,\n\t\t\t\t\t\t\t\tPangoLayoutLine  *line)", "code": "{\n\tGSList *tmp_list = line->runs;\n\tPangoRectangle logical_rect;\n\tgint x_off = 0;\n\n\twhile (tmp_list)\n\t{\n\t\tPangoLayoutRun *run = tmp_list->data;\n\n\t\tpango_glyph_string_extents (run->glyphs, run->item->analysis.font,\n\t\t\t\t\t\t\t\t\t\t\t NULL, &logical_rect);\n\n\t\tgdk_draw_glyphs (drawable, gc, run->item->analysis.font,\n\t\t\t\t\t\t\t  x + x_off / PANGO_SCALE, y, run->glyphs);\n\n\t\tx_off += logical_rect.width;\n\t\ttmp_list = tmp_list->next;\n\t}\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/* strip MIRC colors and other attribs. */\n", "func_signal": "static unsigned char *\ngtk_xtext_strip_color (unsigned char *text, int len, unsigned char *outbuf,\n\t\t\t\t\t\t\t  int *newlen, int *mb_ret)", "code": "{\n\tint nc = 0;\n\tint i = 0;\n\tint col = FALSE;\n\tunsigned char *new_str;\n\tint mb = FALSE;\n\n\tif (outbuf == NULL)\n\t\tnew_str = malloc (len + 2);\n\telse\n\t\tnew_str = outbuf;\n\n\twhile (len > 0)\n\t{\n\t\tif (*text >= 128)\n\t\t\tmb = TRUE;\n\n\t\tif ((col && isdigit (*text) && nc < 2) ||\n\t\t\t (col && *text == ',' && isdigit (*(text+1)) && nc < 3))\n\t\t{\n\t\t\tnc++;\n\t\t\tif (*text == ',')\n\t\t\t\tnc = 0;\n\t\t} else\n\t\t{\n\t\t\tcol = FALSE;\n\t\t\tswitch (*text)\n\t\t\t{\n\t\t\tcase ATTR_COLOR:\n\t\t\t\tcol = TRUE;\n\t\t\t\tnc = 0;\n\t\t\t\tbreak;\n\t\t\tcase ATTR_BEEP:\n\t\t\tcase ATTR_RESET:\n\t\t\tcase ATTR_REVERSE:\n\t\t\tcase ATTR_BOLD:\n\t\t\tcase ATTR_UNDERLINE:\n\t\t\tcase ATTR_ITALICS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnew_str[i] = *text;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\ttext++;\n\t\tlen--;\n\t}\n\n\tnew_str[i] = 0;\n\n\tif (newlen != NULL)\n\t\t*newlen = i;\n\n\tif (mb_ret != NULL)\n\t\t*mb_ret = mb;\n\n\treturn new_str;\n}", "path": "dependencies\\ggz-gtk\\xtext.c", "repo_name": "diega/gnobots2-clutter", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 71952}
{"docstring": "/*\n** Close a cursor.  The read lock on the database file is released\n** when the last cursor is closed.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor *pCur)", "code": "{\n  Btree *pBtree = pCur->pBtree;\n  if( pBtree ){\n    int i;\n    BtShared *pBt = pCur->pBt;\n    sqlite3BtreeEnter(pBtree);\n    sqlite3BtreeClearCursor(pCur);\n    if( pCur->pPrev ){\n      pCur->pPrev->pNext = pCur->pNext;\n    }else{\n      pBt->pCursor = pCur->pNext;\n    }\n    if( pCur->pNext ){\n      pCur->pNext->pPrev = pCur->pPrev;\n    }\n    for(i=0; i<=pCur->iPage; i++){\n      releasePage(pCur->apPage[i]);\n    }\n    unlockBtreeIfUnused(pBt);\n    invalidateOverflowCache(pCur);\n    /* sqlite3_free(pCur); */\n    sqlite3BtreeLeave(pBtree);\n  }\n  return SQLITE_OK;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Create a new mask for cursor iCursor.\n**\n** There is one cursor per table in the FROM clause.  The number of\n** tables in the FROM clause is limited by a test early in the\n** sqlite3WhereBegin() routine.  So we know that the pMaskSet->ix[]\n** array will never overflow.\n*/\n", "func_signal": "static void createMask(WhereMaskSet *pMaskSet, int iCursor)", "code": "{\n  assert( pMaskSet->n < ArraySize(pMaskSet->ix) );\n  pMaskSet->ix[pMaskSet->n++] = iCursor;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Function to query the hash-table of tokenizers (see README.tokenizers).\n*/\n", "func_signal": "static int queryTestTokenizer(\n  sqlite3 *db, \n  const char *zName,  \n  const sqlite3_tokenizer_module **pp\n)", "code": "{\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSql[] = \"SELECT fts3_tokenizer(?)\";\n\n  *pp = 0;\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){\n      memcpy(pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));\n    }\n  }\n\n  return sqlite3_finalize(pStmt);\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Allocate a new page object initially associated with cache pCache.\n*/\n", "func_signal": "static PgHdr1 *pcache1AllocPage(PCache1 *pCache)", "code": "{\n  int nByte = sizeof(PgHdr1) + pCache->szPage;\n  void *pPg = pcache1Alloc(nByte);\n  PgHdr1 *p;\n  if( pPg ){\n    p = PAGE_TO_PGHDR1(pCache, pPg);\n    if( pCache->bPurgeable ){\n      pcache1.nCurrentPage++;\n    }\n  }else{\n    p = 0;\n  }\n  return p;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Try to increase the size of the parser stack.\n*/\n", "func_signal": "static void yyGrowStack(yyParser *p)", "code": "{\n  int newSize;\n  yyStackEntry *pNew;\n\n  newSize = p->yystksz*2 + 100;\n  pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));\n  if( pNew ){\n    p->yystack = pNew;\n    p->yystksz = newSize;\n#ifndef NDEBUG\n    if( yyTraceFILE ){\n      fprintf(yyTraceFILE,\"%sStack grows to %d entries!\\n\",\n              yyTracePrompt, p->yystksz);\n    }\n#endif\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Page pParent is an internal (non-leaf) tree page. This function \n** asserts that page number iChild is the left-child if the iIdx'th\n** cell in page pParent. Or, if iIdx is equal to the total number of\n** cells in pParent, that page number iChild is the right-child of\n** the page.\n*/\n", "func_signal": "static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild)", "code": "{\n  assert( iIdx<=pParent->nCell );\n  if( iIdx==pParent->nCell ){\n    assert( get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild );\n  }else{\n    assert( get4byte(findCell(pParent, iIdx))==iChild );\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Lower the locking level on file descriptor pFile to locktype.  locktype\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\n", "func_signal": "static int flockUnlock(sqlite3_file *id, int locktype)", "code": "{\n  unixFile *pFile = (unixFile*)id;\n  \n  assert( pFile );\n  OSTRACE5(\"UNLOCK  %d %d was %d pid=%d\\n\", pFile->h, locktype,\n           pFile->locktype, getpid());\n  assert( locktype<=SHARED_LOCK );\n  \n  /* no-op if possible */\n  if( pFile->locktype==locktype ){\n    return SQLITE_OK;\n  }\n  \n  /* shared can just be set because we always have an exclusive */\n  if (locktype==SHARED_LOCK) {\n    pFile->locktype = locktype;\n    return SQLITE_OK;\n  }\n  \n  /* no, really, unlock. */\n  int rc = flock(pFile->h, LOCK_UN);\n  if (rc) {\n    int r, tErrno = errno;\n    r = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n    if( IS_LOCK_ERROR(r) ){\n      pFile->lastErrno = tErrno;\n    }\n#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n    if( (r & SQLITE_IOERR) == SQLITE_IOERR ){\n      r = SQLITE_BUSY;\n    }\n#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */\n    \n    return r;\n  } else {\n    pFile->locktype = NO_LOCK;\n    return SQLITE_OK;\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Set the i-th bit.  Return 0 on success and an error code if\n** anything goes wrong.\n**\n** This routine might cause sub-bitmaps to be allocated.  Failing\n** to get the memory needed to hold the sub-bitmap is the only\n** that can go wrong with an insert, assuming p and i are valid.\n**\n** The calling function must ensure that p is a valid Bitvec object\n** and that the value for \"i\" is within range of the Bitvec object.\n** Otherwise the behavior is undefined.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i)", "code": "{\n  u32 h;\n  if( p==0 ) return SQLITE_OK;\n  assert( i>0 );\n  assert( i<=p->iSize );\n  i--;\n  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    if( p->u.apSub[bin]==0 ){\n      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );\n      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM;\n    }\n    p = p->u.apSub[bin];\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));\n    return SQLITE_OK;\n  }\n  h = BITVEC_HASH(i++);\n  /* if there wasn't a hash collision, and this doesn't */\n  /* completely fill the hash, then just add it without */\n  /* worring about sub-dividing and re-hashing. */\n  if( !p->u.aHash[h] ){\n    if (p->nSet<(BITVEC_NINT-1)) {\n      goto bitvec_set_end;\n    } else {\n      goto bitvec_set_rehash;\n    }\n  }\n  /* there was a collision, check to see if it's already */\n  /* in hash, if not, try to find a spot for it */\n  do {\n    if( p->u.aHash[h]==i ) return SQLITE_OK;\n    h++;\n    if( h>=BITVEC_NINT ) h = 0;\n  } while( p->u.aHash[h] );\n  /* we didn't find it in the hash.  h points to the first */\n  /* available free spot. check to see if this is going to */\n  /* make our hash too \"full\".  */\nbitvec_set_rehash:\n  if( p->nSet>=BITVEC_MXHASH ){\n    unsigned int j;\n    int rc;\n    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));\n    if( aiValues==0 ){\n      return SQLITE_NOMEM;\n    }else{\n      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n      memset(p->u.apSub, 0, sizeof(p->u.apSub));\n      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;\n      rc = sqlite3BitvecSet(p, i);\n      for(j=0; j<BITVEC_NINT; j++){\n        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);\n      }\n      sqlite3StackFree(0, aiValues);\n      return rc;\n    }\n  }\nbitvec_set_end:\n  p->nSet++;\n  p->u.aHash[h] = i;\n  return SQLITE_OK;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Reset the aggregate accumulator.\n**\n** The aggregate accumulator is a set of memory cells that hold\n** intermediate results while calculating an aggregate.  This\n** routine simply stores NULLs in all of those memory cells.\n*/\n", "func_signal": "static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo)", "code": "{\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  if( pAggInfo->nFunc+pAggInfo->nColumn==0 ){\n    return;\n  }\n  for(i=0; i<pAggInfo->nColumn; i++){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pAggInfo->aCol[i].iMem);\n  }\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pFunc->iMem);\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = keyInfoFromExprList(pParse, pE->x.pList);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO_HANDOFF);\n      }\n    }\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Unlock the database file. This function is a no-op if the pager\n** is in exclusive mode.\n**\n** If the pager is currently in error state, discard the contents of \n** the cache and reset the Pager structure internal state. If there is\n** an open journal-file, then the next time a shared-lock is obtained\n** on the pager file (by this or any other process), it will be\n** treated as a hot-journal and rolled back.\n*/\n", "func_signal": "static void pager_unlock(Pager *pPager)", "code": "{\n  if( !pPager->exclusiveMode ){\n    int rc;                      /* Return code */\n\n    /* Always close the journal file when dropping the database lock.\n    ** Otherwise, another connection with journal_mode=delete might\n    ** delete the file out from under us.\n    */\n    sqlite3OsClose(pPager->jfd);\n    sqlite3BitvecDestroy(pPager->pInJournal);\n    pPager->pInJournal = 0;\n    releaseAllSavepoints(pPager);\n\n    /* If the file is unlocked, somebody else might change it. The\n    ** values stored in Pager.dbSize etc. might become invalid if\n    ** this happens. TODO: Really, this doesn't need to be cleared\n    ** until the change-counter check fails in PagerSharedLock().\n    */\n    pPager->dbSizeValid = 0;\n\n    rc = osUnlock(pPager->fd, NO_LOCK);\n    if( rc ){\n      pPager->errCode = rc;\n    }\n    IOTRACE((\"UNLOCK %p\\n\", pPager))\n\n    /* If Pager.errCode is set, the contents of the pager cache cannot be\n    ** trusted. Now that the pager file is unlocked, the contents of the\n    ** cache can be discarded and the error code safely cleared.\n    */\n    if( pPager->errCode ){\n      if( rc==SQLITE_OK ){\n        pPager->errCode = SQLITE_OK;\n      }\n      pager_reset(pPager);\n    }\n\n    pPager->changeCountDone = 0;\n    pPager->state = PAGER_UNLOCK;\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** This function is also used as part of assert() statements only. It \n** returns true if there exist one or more cursors open on the table \n** with root page iRoot that do not belong to either connection pBtree \n** or some other connection that has the read-uncommitted flag set.\n**\n** For example, before writing to page iRoot:\n**\n**    assert( !hasReadConflicts(pBtree, iRoot) );\n*/\n", "func_signal": "static int hasReadConflicts(Btree *pBtree, Pgno iRoot)", "code": "{\n  BtCursor *p;\n  for(p=pBtree->pBt->pCursor; p; p=p->pNext){\n    if( p->pgnoRoot==iRoot \n     && p->pBtree!=pBtree\n     && 0==(p->pBtree->db->flags & SQLITE_ReadUncommitted)\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/* Accumulate the union of *acc and *pData into *acc. */\n", "func_signal": "static void docListAccumulateUnion(DataBuffer *acc,\n                                   const char *pData, int nData)", "code": "{\n  DataBuffer tmp = *acc;\n  dataBufferInit(acc, tmp.nData+nData);\n  docListUnion(tmp.pData, tmp.nData, pData, nData, acc);\n  dataBufferDestroy(&tmp);\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\n", "func_signal": "SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...)", "code": "{\n  va_list ap;\n  char *z;\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  return z;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Make sure the given Mem is \\u0000 terminated.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem *pMem)", "code": "{\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  if( (pMem->flags & MEM_Term)!=0 || (pMem->flags & MEM_Str)==0 ){\n    return SQLITE_OK;   /* Nothing to do */\n  }\n  if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){\n    return SQLITE_NOMEM;\n  }\n  pMem->z[pMem->n] = 0;\n  pMem->z[pMem->n+1] = 0;\n  pMem->flags |= MEM_Term;\n  return SQLITE_OK;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** This function is called while stepping or preparing a statement \n** associated with connection db. The operation will return SQLITE_LOCKED\n** to the user because it requires a lock that will not be available\n** until connection pBlocker concludes its current transaction.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker)", "code": "{\n  enterMutex();\n  if( db->pBlockingConnection==0 && db->pUnlockConnection==0 ){\n    addToBlockedList(db);\n  }\n  db->pBlockingConnection = pBlocker;\n  leaveMutex();\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** This routine is used to check if the UTF-8 string zName is a legal\n** unqualified name for a new schema object (table, index, view or\n** trigger). All names are legal except those that begin with the string\n** \"sqlite_\" (in upper, lower or mixed case). This portion of the namespace\n** is reserved for internal use.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *pParse, const char *zName)", "code": "{\n  if( !pParse->db->init.busy && pParse->nested==0 \n          && (pParse->db->flags & SQLITE_WriteSchema)==0\n          && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7) ){\n    sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\", zName);\n    return SQLITE_ERROR;\n  }\n  return SQLITE_OK;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Implementation of the sqlite3_pcache.xCachesize method. \n**\n** Configure the cache_size limit for a cache.\n*/\n", "func_signal": "static void pcache1Cachesize(sqlite3_pcache *p, int nMax)", "code": "{\n  PCache1 *pCache = (PCache1 *)p;\n  if( pCache->bPurgeable ){\n    pcache1EnterMutex();\n    pcache1.nMaxPage += (nMax - pCache->nMax);\n    pCache->nMax = nMax;\n    pcache1EnforceMaxPage();\n    pcache1LeaveMutex();\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** The table object reference passed as the second argument to this function\n** must represent a virtual table. This function invokes the xBestIndex()\n** method of the virtual table with the sqlite3_index_info pointer passed\n** as the argument.\n**\n** If an error occurs, pParse is populated with an error message and a\n** non-zero value is returned. Otherwise, 0 is returned and the output\n** part of the sqlite3_index_info structure is left populated.\n**\n** Whether or not an error is returned, it is the responsibility of the\n** caller to eventually free p->idxStr if p->needToFreeIdxStr indicates\n** that this is required.\n*/\n", "func_signal": "static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p)", "code": "{\n  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\n  int i;\n  int rc;\n\n  (void)sqlite3SafetyOff(pParse->db);\n  WHERETRACE((\"xBestIndex for %s\\n\", pTab->zName));\n  TRACE_IDX_INPUTS(p);\n  rc = pVtab->pModule->xBestIndex(pVtab, p);\n  TRACE_IDX_OUTPUTS(p);\n  (void)sqlite3SafetyOn(pParse->db);\n\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM ){\n      pParse->db->mallocFailed = 1;\n    }else if( !pVtab->zErrMsg ){\n      sqlite3ErrorMsg(pParse, \"%s\", sqlite3ErrStr(rc));\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s\", pVtab->zErrMsg);\n    }\n  }\n  sqlite3DbFree(pParse->db, pVtab->zErrMsg);\n  pVtab->zErrMsg = 0;\n\n  for(i=0; i<p->nConstraint; i++){\n    if( !p->aConstraint[i].usable && p->aConstraintUsage[i].argvIndex>0 ){\n      sqlite3ErrorMsg(pParse, \n          \"table %s: xBestIndex returned an invalid plan\", pTab->zName);\n    }\n  }\n\n  return pParse->nErr;\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** The Table structure pTable is really a VIEW.  Fill in the names of\n** the columns of the view in the pTable structure.  Return the number\n** of errors.  If an error is seen leave an error message in pParse->zErrMsg.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable)", "code": "{\n  Table *pSelTab;   /* A fake table from which we get the result set */\n  Select *pSel;     /* Copy of the SELECT that implements the view */\n  int nErr = 0;     /* Number of errors encountered */\n  int n;            /* Temporarily holds the number of cursors assigned */\n  sqlite3 *db = pParse->db;  /* Database connection for malloc errors */\n  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);\n\n  assert( pTable );\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( sqlite3VtabCallConnect(pParse, pTable) ){\n    return SQLITE_ERROR;\n  }\n  if( IsVirtual(pTable) ) return 0;\n#endif\n\n#ifndef SQLITE_OMIT_VIEW\n  /* A positive nCol means the columns names for this view are\n  ** already known.\n  */\n  if( pTable->nCol>0 ) return 0;\n\n  /* A negative nCol is a special marker meaning that we are currently\n  ** trying to compute the column names.  If we enter this routine with\n  ** a negative nCol, it means two or more views form a loop, like this:\n  **\n  **     CREATE VIEW one AS SELECT * FROM two;\n  **     CREATE VIEW two AS SELECT * FROM one;\n  **\n  ** Actually, the error above is now caught prior to reaching this point.\n  ** But the following test is still important as it does come up\n  ** in the following:\n  ** \n  **     CREATE TABLE main.ex1(a);\n  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n  **     SELECT * FROM temp.ex1;\n  */\n  if( pTable->nCol<0 ){\n    sqlite3ErrorMsg(pParse, \"view %s is circularly defined\", pTable->zName);\n    return 1;\n  }\n  assert( pTable->nCol>=0 );\n\n  /* If we get this far, it means we need to compute the table names.\n  ** Note that the call to sqlite3ResultSetOfSelect() will expand any\n  ** \"*\" elements in the results set of the view and will assign cursors\n  ** to the elements of the FROM clause.  But we do not want these changes\n  ** to be permanent.  So the computation is done on a copy of the SELECT\n  ** statement that defines the view.\n  */\n  assert( pTable->pSelect );\n  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);\n  if( pSel ){\n    u8 enableLookaside = db->lookaside.bEnabled;\n    n = pParse->nTab;\n    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);\n    pTable->nCol = -1;\n    db->lookaside.bEnabled = 0;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    xAuth = db->xAuth;\n    db->xAuth = 0;\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);\n    db->xAuth = xAuth;\n#else\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);\n#endif\n    db->lookaside.bEnabled = enableLookaside;\n    pParse->nTab = n;\n    if( pSelTab ){\n      assert( pTable->aCol==0 );\n      pTable->nCol = pSelTab->nCol;\n      pTable->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      sqlite3DeleteTable(pSelTab);\n      pTable->pSchema->flags |= DB_UnresetViews;\n    }else{\n      pTable->nCol = 0;\n      nErr++;\n    }\n    sqlite3SelectDelete(db, pSel);\n  } else {\n    nErr++;\n  }\n#endif /* SQLITE_OMIT_VIEW */\n  return nErr;  \n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "/*\n** Routines used to compute the sum, average, and total.\n**\n** The SUM() function follows the (broken) SQL standard which means\n** that it returns NULL if it sums over no inputs.  TOTAL returns\n** 0.0 in that case.  In addition, TOTAL always returns a float where\n** SUM might return an integer if it never encounters a floating point\n** value.  TOTAL never fails, but SUM might through an exception if\n** it overflows an integer.\n*/\n", "func_signal": "static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv)", "code": "{\n  SumCtx *p;\n  int type;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  type = sqlite3_value_numeric_type(argv[0]);\n  if( p && type!=SQLITE_NULL ){\n    p->cnt++;\n    if( type==SQLITE_INTEGER ){\n      i64 v = sqlite3_value_int64(argv[0]);\n      p->rSum += v;\n      if( (p->approx|p->overflow)==0 ){\n        i64 iNewSum = p->iSum + v;\n        int s1 = (int)(p->iSum >> (sizeof(i64)*8-1));\n        int s2 = (int)(v       >> (sizeof(i64)*8-1));\n        int s3 = (int)(iNewSum >> (sizeof(i64)*8-1));\n        p->overflow = ((s1&s2&~s3) | (~s1&~s2&s3))?1:0;\n        p->iSum = iNewSum;\n      }\n    }else{\n      p->rSum += sqlite3_value_double(argv[0]);\n      p->approx = 1;\n    }\n  }\n}", "path": "sqlite3.c", "repo_name": "salva/my-p5-DBD-SQLite", "stars": 3, "license": "None", "language": "c", "size": 3192}
{"docstring": "//* Function used for sort plugins with priorities *//\n", "func_signal": "int sort_plugins(gconstpointer a, gconstpointer b)", "code": "{\n\tconst plugin_t *pa = a;\n\tconst plugin_t *pb = b;\n\treturn (pa->priority - pb->priority);\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Load next plugin *//\n", "func_signal": "int show_help(GtkWidget *w, gpointer user_data)", "code": "{\n\tif((plugin_active->load_help_widget) != NULL)\n\t{\n\t\n\t\tGtkWidget *helpwidget = plugin_active->load_help_widget();\n\t\t\n\t\tGtkWidget *pBoite = gtk_dialog_new_with_buttons(_(\"Plugin help\"),\n        \t\t\t\tGTK_WINDOW(assistant),\n        \t\t\t\tGTK_DIALOG_MODAL,\n        \t\t\t\tGTK_STOCK_OK,GTK_RESPONSE_OK,\n        \t\t\t\tNULL);\n\n\t\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(pBoite)->vbox), helpwidget, TRUE, TRUE, 5);\n\n    \t\tgtk_widget_show_all(GTK_DIALOG(pBoite)->vbox);\n\n    \t\tgtk_dialog_run(GTK_DIALOG(pBoite));\n\t\tgtk_widget_destroy(pBoite);\n    \t}\n\telse\n\t{\n\t\tfwife_error(_(\"No help available for this plugin\"));\n\t}\n    \t\n\treturn 0;\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Load main widget *//\n", "func_signal": "GtkWidget *load_gtk_widget()", "code": "{\n\tGtkWidget *vboxmode = gtk_vbox_new(FALSE,5);\n\tbasicmode = getBasicModeWidget();\n\texpertmode = getExpertModeWidget();\n\tgtk_box_pack_start(GTK_BOX(vboxmode), expertmode, TRUE, TRUE, 0);\n\tgtk_box_pack_start(GTK_BOX(vboxmode), basicmode, TRUE, TRUE, 0);\n\n\treturn vboxmode;\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* get a gtk tree list for categories *//\n", "func_signal": "GtkWidget *getcategorieslist()", "code": "{\n\tGtkListStore *store;\n\tGtkTreeModel *model;\n\tGtkTreeViewColumn *col;\n\tGtkCellRenderer *renderer;\n\tGtkWidget *pScrollbar;\n\tGtkTreeSelection *selection;\t\n\n\tstore = gtk_list_store_new(3, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING);\n\tmodel = GTK_TREE_MODEL(store);\n\t\n\tcategories = gtk_tree_view_new_with_model(model);\n\tg_object_unref (model);\n\t\t\n\trenderer = gtk_cell_renderer_toggle_new ();\n\tg_signal_connect (renderer, \"toggled\", G_CALLBACK (fixed_toggled_cat), model);\n\tcol = gtk_tree_view_column_new_with_attributes (_(\"Install?\"), renderer, \"active\", USE_COLUMN, NULL);\n\tgtk_tree_view_append_column(GTK_TREE_VIEW(categories), col);\n\t\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes (_(\"Groups\"), renderer, \"text\", CAT_COLUMN, NULL);\n\tgtk_tree_view_column_set_expand (col, TRUE);\n\tgtk_tree_view_append_column(GTK_TREE_VIEW(categories), col);\n\t\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes (_(\"Size\"), renderer, \"text\", SIZE_COLUMN, NULL);\n\tgtk_tree_view_append_column(GTK_TREE_VIEW(categories), col);\t\n\n\tgtk_tree_selection_set_mode (gtk_tree_view_get_selection (GTK_TREE_VIEW (categories)), GTK_SELECTION_SINGLE);\n\t\n\tselection = gtk_tree_view_get_selection (GTK_TREE_VIEW (categories));\n        g_signal_connect (selection, \"changed\", G_CALLBACK (categorie_changed), NULL);\n\t\n\tpScrollbar = gtk_scrolled_window_new(NULL, NULL);\n\t\n\tgtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(pScrollbar), categories);\n\tgtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(pScrollbar), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);\n\t\n\treturn pScrollbar;\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Open a file plugin and add it into list *//\n", "func_signal": "int fwife_add_plugins(char *filename)", "code": "{\n    \tvoid *handle;\n\tvoid *(*infop) (void);\n\n\tif ((handle = dlopen(filename, RTLD_NOW)) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s\", dlerror());\n\t\treturn(1);\n\t}\n\n\tif ((infop = dlsym(handle, \"info\")) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s\", dlerror());\n\t\treturn(1);\n\t}\n\tplugin_t *plugin = infop();\n\tplugin->handle = handle;\n\tplugin_list = g_list_append(plugin_list, plugin);\n\n\treturn(0);\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* set up group when selected or unselected *//\n", "func_signal": "void basicmode_change(GtkWidget *button, gpointer data)", "code": "{\n\tchar *lang = strdup(getenv(\"LANG\"));\n\tchar *ptr = rindex(lang, '_');\n\t*ptr = '\\0';\n\t\n\tif(!strcmp((char*)data, \"NET\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t\tselectcat(\"network\", 1);\n\t\telse\n\t\t\tselectcat(\"network\", 0);\n\t}\n\telse if(!strcmp((char*)data, \"NETEX\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t\tselectcat(\"network-extra\", 1);\n\t\telse\n\t\t\tselectcat(\"network-extra\", 0);\n\t}\n\telse if(!strcmp((char*)data, \"MUL\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"multimedia\", 1);\n\t\t\tselectcat(\"xmultimedia\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"multimedia\", 0);\n\t\t\tselectcat(\"xmultimedia\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"MULEX\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"multimedia-extra\", 1);\n\t\t\tselectcat(\"xmultimedia-extra\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"multimedia-extra\", 0);\n\t\t\tselectcat(\"xmultimedia-extra\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"DEV\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"devel\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"devel\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"DEVEX\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"devel-extra\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"devel-extra\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"CONS\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"apps\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"apps\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"CONSEX\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"apps-extra\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"apps-extra\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"XAPP\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectallfiles(\"xapps\", \"openoffice.org\", 1);\n\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"firefox-%s\", lang), 1);\n\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"thunderbird-%s\", lang), 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectallfiles(\"xapps\", \"openoffice.org\", 0);\n\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"firefox-%s\", lang), 0);\n\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"thunderbird-%s\", lang), 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"XAPPEX\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"xapps-extra\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"xapps-extra\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"GAME\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectcat(\"games-extra\", 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectcat(\"games-extra\", 0);\n\t\t}\n\t}\n\telse if(!strcmp((char*)data, \"BUR\"))\n\t{\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == TRUE)\n\t\t{\n\t\t\tselectfile(\"xapps\", \"openoffice.org\", 1);\n\t\t\tif(strcmp(lang ,\"en\"))\n\t\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"openoffice.org-i18n-%s\", lang), 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectfile(\"xapps\", \"openoffice.org\", 0);\n\t\t\tchar *lang = strdup(getenv(\"LANG\"));\n\t\t\tchar *ptr = rindex(lang, '_');\n\t\t\t*ptr = '\\0';\n\t\t\tif(strcmp(lang ,\"en\"))\n\t\t\t\tselectfile(\"locale-extra\", g_strdup_printf(\"openoffice.org-i18n-%s\", lang), 0);\n\t\t}\n\t}\n\t\n\treturn;\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Find dynamic plugins and add them *//\n", "func_signal": "int fwife_load_plugins(char *dirname)", "code": "{\n    char *filename, *ext;\n\tDIR *dir;\n\tstruct dirent *ent;\n\tstruct stat statbuf;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t{\n\t\tperror(dirname);\n\t\treturn(1);\n\t}\n\t// remenber that asklang is now special plugin\n\twhile ((ent = readdir(dir)) != NULL)\n\t{\n\t\tfilename = g_strdup_printf(\"%s/%s\", dirname, ent->d_name);\n\t\tif (!stat(filename, &statbuf) && S_ISREG(statbuf.st_mode) &&\n\t\t\t\t(ext = strrchr(ent->d_name, '.')) != NULL)\n\t\t\tif (!strcmp(ext, SHARED_LIB_EXT) && strcmp(ent->d_name, \"asklang.so\"))\n\t\t\t\tfwife_add_plugins(filename);\t\t\n\t\tfree(filename);\n\n\t}\n\tclosedir(dir);\n\treturn(0);\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Select all file in a categorie *//\n", "func_signal": "void selectallfiles(char *cat, char *exception, int bool)", "code": "{\n\tint i;\n\tGList *lispack;\n\t\n\tif(allpackets)\n\t{\n\t\tlispack = (GList*)data_get(allpackets, cat);\n\t\t\n\t\tif(exception == NULL)\n\t\t{\n\t\t\tfor(i=0; i<g_list_length(lispack); i+=4)\n\t\t\t{\n\t\t\t\tg_list_nth(lispack, i+3)->data = GINT_TO_POINTER(bool);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=0; i<g_list_length(lispack); i+=4)\n\t\t\t{\n\t\t\t\tif(strcmp(g_list_nth_data(lispack, i), exception))\n\t\t\t\t\tg_list_nth(lispack, i+3)->data = GINT_TO_POINTER(bool);\n\t\t\t}\n\t\t}\n\t}\t\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Packet selection have changed, update description *//\n", "func_signal": "void packet_changed(GtkTreeSelection *selection, gpointer data)", "code": "{\n\tGtkTreeView *treeview;\n\tGtkTreeModel *model;\n\tGtkTreeIter iter;\n\tchar *selected;\n\tgint i;\n\t\n\ttreeview = gtk_tree_selection_get_tree_view (selection);\n\t\n\tif (gtk_tree_selection_get_selected (selection, &model, &iter))\n\t{\n\t\tGtkTreePath *path = gtk_tree_model_get_path(model, &iter);\n\t\ti = gtk_tree_path_get_indices (path)[0];\n\t\tgtk_tree_model_get (model, &iter, 1, &selected, -1);\n\t\tgtk_label_set_label(GTK_LABEL(packetinfo), (char*)g_list_nth_data(packets_current, i*4+2));\n\t}\t\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* A categorie as been toggled *//\n", "func_signal": "static void fixed_toggled_cat (GtkCellRendererToggle *cell,gchar *path_str, gpointer data)", "code": "{\n\tGtkTreeModel *model = (GtkTreeModel *)data;\n\tGtkTreeIter  iter;\n\tGtkTreePath *path = gtk_tree_path_new_from_string (path_str);\n\tgboolean fixed;\n\tgchar *name;\n\t\n\t/* get toggled iter */\n\tgtk_tree_model_get_iter (model, &iter, path);\n\tgtk_tree_model_get (model, &iter, 0, &fixed, -1);\n\tgtk_tree_model_get (model, &iter, 1, &name, -1);\n\t\t\n\tgint i = gtk_tree_path_get_indices (path)[0];\n  \n\t/* do something with the value */\n\tfixed ^= 1;\n\t\n\tif(fixed == FALSE)\n\t{\n\t\tGList *elem = g_list_nth(cats, i*3+2);\n\t\telem->data = GINT_TO_POINTER(0);\n\t\tg_object_set (packetlist, \"sensitive\", FALSE, NULL);\n\t}\n\telse\n\t{\n\t\tGList *elem = g_list_nth(cats, i*3+2);\n\t\telem->data = GINT_TO_POINTER(1);\n\t\tg_object_set (packetlist, \"sensitive\", TRUE, NULL);\n\t}\n\t\n\t/* set new value */\n\tgtk_list_store_set (GTK_LIST_STORE (model), &iter, 0, fixed, -1);\n\n\t/* clean up */\n\tgtk_tree_path_free (path);\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* A basic question *//\n", "func_signal": "int fwife_question(char* msg_str)", "code": "{\n\tGtkWidget *pQuestion;\n\n\tpQuestion = gtk_message_dialog_new (GTK_WINDOW(assistant),\n\t\t\t\t\tGTK_DIALOG_MODAL,\n       \t\t\t\t\tGTK_MESSAGE_QUESTION,\n       \t\t\t\t\tGTK_BUTTONS_YES_NO,\n       \t\t\t\t\tmsg_str);\n\tint rep = gtk_dialog_run(GTK_DIALOG(pQuestion));\n\tgtk_widget_destroy(pQuestion);\n\treturn(rep);\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Asklang is now a special plugin loaded before all others plugins *//\n", "func_signal": "int ask_language()", "code": "{\n\tvoid *handle;\n\tvoid *(*infop) (void);\n\t\n\tchar *ptr = g_strdup_printf(\"%s/%s\", PLUGINDIR, \"asklang.so\");\n\tif ((handle = dlopen(ptr, RTLD_NOW)) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s\", dlerror());\n\t\tFREE(ptr);\n\t\treturn(1);\n\t}\n\tFREE(ptr);\n\n\tif ((infop = dlsym(handle, \"info\")) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s\", dlerror());\n\t\treturn(1);\n\t}\n\tplugin_t *pluginlang = infop();\n\tpluginlang->handle = handle;\n\t\n\tGtkWidget *pBoite = gtk_dialog_new_with_buttons(\"Language selection (default : en_US)\",\n\t\t\tNULL,\n\t\t\tGTK_DIALOG_MODAL,\n       \t\t\tGTK_STOCK_OK,GTK_RESPONSE_OK,\n       \t\t\tNULL);\n\tgtk_widget_set_size_request (pBoite, 800, 600);\n\tgtk_window_set_deletable ( GTK_WINDOW ( pBoite ), FALSE );\n\n\t\n\tGdkPixbuf *pixbuf = gdk_pixbuf_new_from_file (g_strdup_printf(\"%s/headlogo.png\", IMAGEDIR), NULL);\n\tif(!pixbuf) \n\t{\n\t\tfprintf(stdout, \"error message: can't load images/headlogo.png\\n\");\n\t}\n\telse\n\t{\n\t\t/* Set it as icon window */\n\t\tgtk_window_set_icon(GTK_WINDOW (pBoite),pixbuf);\n\t}\n\tg_object_unref(pixbuf);\n\n\tGtkWidget *langtab = pluginlang->load_gtk_widget();\n\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(pBoite)->vbox), langtab, TRUE, TRUE, 5);\n\n\tgtk_widget_show_all(GTK_DIALOG(pBoite)->vbox);\n\n\tgtk_dialog_run(GTK_DIALOG(pBoite));\n\tpluginlang->run(&config);\n\tgtk_widget_destroy(pBoite);\n\treturn 0;\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Fatal error : quit fwife *//\n", "func_signal": "void fwife_fatal_error(char* error_str)", "code": "{\n\tGtkWidget *error_dlg = NULL;\n\tif (!strlen(error_str))\n\t    return;\n\terror_dlg = gtk_message_dialog_new (GTK_WINDOW(assistant),\n                                         GTK_DIALOG_DESTROY_WITH_PARENT,\n                                         GTK_MESSAGE_ERROR,\n                                         GTK_BUTTONS_OK,\n                                         \"%s\",\n                                         error_str);\n\n    \tgtk_window_set_resizable (GTK_WINDOW(error_dlg), FALSE);\n    \tgtk_window_set_title (GTK_WINDOW(error_dlg), _(\"Fwife error\"));\n\n\tgtk_dialog_run (GTK_DIALOG(error_dlg));\n\n   \t gtk_widget_destroy (error_dlg);\n    \n   \t fwife_exit();\n\n    \treturn;\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* select a categorie *//\n", "func_signal": "void selectcat(char *name, int bool)", "code": "{\n\tint i;\n\tfor(i=0; i<g_list_length(cats); i+=3)\n\t{\n\t\tif(!strcmp(g_list_nth_data(cats, i), name))\n\t\t{\n\t\t\tg_list_nth(cats, i+2)->data = GINT_TO_POINTER(bool);\n\t\t\treturn;\n\t\t}\n\t}\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Dialog box for quit the installation *//\n", "func_signal": "void cancel_install(GtkWidget *w, gpointer user_data)", "code": "{\n   int result = fwife_question(_(\"Are you sure you want to exit from the installer?\\n\"));\n   if(result == GTK_RESPONSE_YES)\n   {\n        fwife_exit();\n   }   \n    return;\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* set up desktop configuration *//\n", "func_signal": "void configuredesktop()", "code": "{\n\tGSList *pList;\n\tchar *seldesk = NULL;\n\t\n\tpList = gtk_radio_button_get_group(GTK_RADIO_BUTTON(pRadioKDE));\n\t\n\t//* Fix locale dependency *//\n\tchar *lang = strdup(getenv(\"LANG\"));\n\tchar *ptr = rindex(lang, '_');\n\t*ptr = '\\0';\n\tif(strcmp(lang ,\"en\"))\n\t{\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"eric-i18n-%s\", lang), 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"eric4-i18n-%s\", lang), 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"hunspell-%s\", lang), 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"koffice-l10n-%s\", lang), 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"mbrola-%s\", lang), 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"kde-i18n-%s\", lang), 0);\n\t}\n\n\t/* Parcours de la liste */\n\twhile(pList)\n\t{\n\t\t/* button selected? */\n\t\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pList->data)))\n\t\t{\n\t\t\t/* get button label */\n\t\t\tseldesk = strdup((char*)gtk_button_get_label(GTK_BUTTON(pList->data)));\n\t\t\t/* Get out */\t\t\t\n\t\t\tpList = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* next button */\n\t\t\tpList = g_slist_next(pList);\n\t\t}\n\t}\n\t\n\tif(!strcmp(seldesk, \"KDE\"))\n\t{\n\t\tselectcat(\"gnome\", 0);\n\t\tselectcat(\"xfce4\", 0);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"koffice-l10n-%s\", lang), 1);\n\t\tselectfile(\"locale-extra\", g_strdup_printf(\"kde-i18n-%s\", lang), 1);\n\t}\n\telse if(!strcmp(seldesk, \"Gnome\"))\n\t{\n\t\tselectcat(\"kde\", 0);\n\t\tselectcat(\"xfce4\", 0);\n\t}\n\telse if(!strcmp(seldesk, \"XFCE\"))\n\t{\n\t\tselectcat(\"kde\", 0);\n\t\tselectcat(\"gnome\", 0);\n\t}\n\telse if(!strcmp(seldesk, \"LXDE\"))\n\t{\n\t\tselectcat(\"kde\", 0);\n\t\tselectcat(\"gnome\", 0);\n\t\tselectcat(\"xfce4\", 0);\n\t\tselectcat(\"lxde-desktop\", 1);\n\t\tselectallfiles(\"lxde-desktop\", NULL, 1);\n\t}\n\t\n\tFREE(lang);\t\n\treturn;\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Dialog Box when instllation finished *//\n", "func_signal": "void close_install(GtkWidget *w, gpointer user_data)", "code": "{\n   fwife_info(_(\"Frugalware installation completed.\\n You can now reboot your computer\"));\n   plugin_active->run(&config); //run finish plugin\n   fwife_exit();\n   \n   return;\n}", "path": "src\\fwife.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Packet toggled *//\n", "func_signal": "static void fixed_toggled_pack (GtkCellRendererToggle *cell,gchar *path_str, gpointer data)", "code": "{\n\tGtkTreeModel *model = (GtkTreeModel *)data;\n\tGtkTreeIter  iter;\n\tGtkTreePath *path = gtk_tree_path_new_from_string (path_str);\n\tgboolean fixed;\n\tgchar *name;\n\tgint i;\n\n\t/* get toggled iter */\n\tgtk_tree_model_get_iter (model, &iter, path);\n\tgtk_tree_model_get (model, &iter, 0, &fixed, -1);\n\tgtk_tree_model_get (model, &iter, 1, &name, -1);\n  \n\t/* do something with the value */\n\tfixed ^= 1;\n\t\n\ti = gtk_tree_path_get_indices (path)[0];\n\t\n\tGList *elem = g_list_nth(packets_current, i*4+3);\n\t\n\tif(fixed == TRUE)\n\t\telem->data = GINT_TO_POINTER(1);\n\telse\n\t\telem->data = GINT_TO_POINTER(0);\n\t\n\t/* set new value */\n\tgtk_list_store_set (GTK_LIST_STORE (model), &iter, 0, fixed, -1);\n\n\t/* clean up */\n\tgtk_tree_path_free (path);\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* select (or unselect) a file 'name' in categorie 'cat' *//\n", "func_signal": "void selectfile(char *cat, char* name, int bool)", "code": "{\n\tint i;\n\tGList *lispack;\n\n\tif(allpackets)\n\t{\n\t\tlispack = (GList*)data_get(allpackets, cat);\n\t\t\n\t\tif(lispack)\n\t\t{\n\t\t\tfor(i=0; i<g_list_length(lispack); i+=4)\n\t\t\t{\n\t\t\t\tif(!strcmp(name, (char *)g_list_nth_data(lispack, i)))\n\t\t\t\t{\n\t\t\t\t\tg_list_nth(lispack, i+3)->data = GINT_TO_POINTER(bool);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "src\\plugins\\select.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "//* Need to have one selected - disable next button if unselected *//\n", "func_signal": "void selection_changed(GtkTreeSelection *selection, gpointer data)", "code": "{\n\tGtkTreeIter iter;\n\tGtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(viewlayout));\n\tchar *ptr, *layout, *variante;\n\t\n\tif (gtk_tree_selection_get_selected (selection, NULL, &iter))\n\t{\n\t\tgtk_tree_model_get (model, &iter, 1, &layout, -1);\n\t\tgtk_tree_model_get (model, &iter, 2, &variante, -1);\n\t\t\n\t\tif(!strcmp(variante, \"default\"))\n\t\t{\n\t\t\tptr = g_strdup_printf(\"setxkbmap -layout %s\", layout);\n\t\t\tfw_system(ptr);\n\t\t\tFREE(ptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tptr = g_strdup_printf(\"setxkbmap -layout %s -variant %s\", layout, variante);\n\t\t\tfw_system(ptr);\n\t\t\tFREE(ptr);\n\t\t}\n\t\tset_page_completed();\n\t}\n\telse\n\t{\n\t\tset_page_incompleted();\n\t}\n}", "path": "src\\plugins\\layout.c", "repo_name": "Elentir/fwife", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 960}
{"docstring": "/**\n * @brief Increments the reference counter\n * @param capabilities The pointer to a capabilities object\n */\n", "func_signal": "OSyncCapabilities *osync_capabilities_ref(OSyncCapabilities *capabilities)", "code": "{\n  osync_assert(capabilities);\n\t\n  g_atomic_int_inc(&(capabilities->ref_count));\n\n  return capabilities;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Get the cached capabilities of a member. The cache capabilities is stored as\n *        \"capabilities.xml\" in the member directory. This function should be only used\n *        internal. To get the current capabilities of a member please use:\n *        osync_member_get_capabilities()\n *\n * @param member The pointer to a member object\n * @param error The error which will hold the info in case of an error\n * @return The objtype of the xmlformat\n */\n", "func_signal": "OSyncCapabilities* osync_capabilities_member_get_capabilities(OSyncMember *member, OSyncError** error)", "code": "{\n  unsigned int size;\n  char* buffer, *filename;\n  OSyncCapabilities *capabilities;\n  osync_bool res;\n\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p)\", __func__, member, error);\n  osync_assert(member);\n\t\n  filename = g_strdup_printf(\"%s%ccapabilities.xml\", osync_member_get_configdir(member), G_DIR_SEPARATOR);\n  res = osync_file_read(filename, &buffer, &size, error);\n  g_free(filename);\n\t\n  if(!res) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n\t\n  capabilities = osync_capabilities_parse(buffer, size, error);\n  g_free(buffer);\n  if(!capabilities) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n\n  /* Sort capabilities, to avoid user modified unsorted capalities: #813 */\n  osync_capabilities_sort(capabilities);\n\t\n  osync_trace(TRACE_EXIT, \"%s: %p\", __func__, capabilities);\n  return capabilities;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Apply stylesheet on configuration.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param config Path to configuration which gets processed \n * @param stylesheet Path to stylesheet which gets invoked \n * @param error Pointer to OSyncError which get stacked\n * @returns TRUE on success, FALSE on error. \n */\n", "func_signal": "static osync_bool osync_updater_stylesheet_process(OSyncUpdater *updater, const char *config, const char *stylesheet, OSyncError **error)", "code": "{\n  xmlDocPtr result = NULL, doc = NULL, style = NULL;\n  xsltTransformContextPtr ctxt = NULL;\n  xsltStylesheetPtr cur = NULL;\n\n  osync_assert(updater);\n  osync_assert(config);\n  osync_assert(stylesheet);\n  osync_trace(TRACE_ENTRY, \"%s(%p, %s, %s, %p)\", __func__, updater, config, stylesheet, error);\n\n  /* Register EXSLT extension.\n     Required for exslt:node-set($rtf) */\n  exsltRegisterAll();\n\n  style = xmlReadFile(stylesheet, NULL, XSLT_PARSE_OPTIONS);\n  if (!style) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not read update stylesheet file: %s\", stylesheet);\n    goto error;\n  }\n\n  doc = xmlReadFile(config, NULL, XSLT_PARSE_OPTIONS);\n  if (!doc) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not read update stylesheet file: %s\", config);\n    goto error;\n  }\n\n  cur = xsltParseStylesheetDoc(style);\n  if (!cur || cur->errors) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not load update stylesheet.\");\n    goto error;\n  }\n\n  ctxt = xsltNewTransformContext(cur, doc);\n  if (!ctxt) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Failed creating the XSLT context. Run out of memory?\");\n    goto error;\n  }\n\n  result = xsltApplyStylesheetUser(cur, doc, NULL, NULL, NULL, ctxt);\n  osync_xml_free_doc(doc);\n\n  if (!result || ctxt->state != XSLT_STATE_OK) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Applying the stylesheet failed.\");\n    goto error;\n  }\n\n  xsltSaveResultToFilename(config, result, cur, 0);\n\n  osync_xml_free_doc(result);\n  xsltFreeStylesheet(cur);\n\n  /* FIXME: Review; This got freed by xsltFreeStylesheet?!\n     osync_xml_free_doc(style);\n  */\n\n  xsltFreeTransformContext(ctxt);\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  return TRUE;\n error:\n\n  if (cur)\n    xsltFreeStylesheet(cur);\n\n  /* FIXME: Review; This got freed by xsltFreeStylesheet?!\n     if (style)\n     osync_xml_free_doc(style);\n  */\n\n  if (result)\n    osync_xml_free_doc(result);\n\n  if (ctxt)\n    xsltFreeTransformContext(ctxt);\n\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(error));\n  return FALSE;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Updater thread function \n *\n *  #1 Lock group\n *  #2 Check version of group configuration\n *  #3 Create group backup\n *  #4 Process Member configurations\n *  #5 Process Group configuration\n *  #6 Unlock group\n *\n *  On any error (expect locked group) restore backup and unlock group.\n *\n * @param userdata Pointer to the OSyncUpdater \n * @returns return code of thread as pointer \n */\n", "func_signal": "static void *osync_updater_run(void *userdata)", "code": "{\n  OSyncUpdater *updater = (OSyncUpdater *) userdata;\n  OSyncError *error = NULL;\n  int i, num_members;\n  char *backup_dir = NULL;\n\n  osync_trace(TRACE_ENTRY, \"%s(%p)\", __func__, userdata);\n\n  /* #1 Lock group */\n  if (osync_group_lock(updater->group) == OSYNC_LOCKED) {\n    osync_error_set(&error, OSYNC_ERROR_GENERIC, \"Group is locked. Can not process update on this group.\");\n    goto error;\n  }\n\n  /* #2 Check version of group configuration */\n  if (!osync_updater_action_required(updater)) {\n    osync_error_set(&error, OSYNC_ERROR_GENERIC, \"No update required for this group. Aborting Update.\");\n    goto error_and_unlock;\n  }\n\n  /* #3 Create backup of group, before performing any update! */\n  if (!(backup_dir = osync_updater_create_backup(updater, &error)))\n    goto error_and_unlock;\n\n  /* #4 Process Member configurations */\n  num_members = osync_group_num_members(updater->group);\n  for (i=0; i < num_members; i++) {\n    if (!osync_updater_process_member(updater, i, &error))\n      goto error_and_restore;\n\n    /* TODO: Emit updater member X signal */\n  }\n\n  /* #5 Process Group configuration */\n  if (!osync_updater_process_group(updater, &error))\n    goto error_and_restore;\n\n  /* #6 Unlock group */\n  osync_group_unlock(updater->group);\n\n  g_mutex_lock(updater->updating_mutex);\n  g_cond_signal(updater->updating);\n  g_mutex_unlock(updater->updating_mutex);\n\n  osync_free(backup_dir);\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  osync_thread_exit(updater->thread, 0);\n  return 0;\n\n error_and_restore:\n  osync_updater_restore_backup(updater, backup_dir);\n error_and_unlock:\n  osync_group_unlock(updater->group);\n error:\n\n  if (backup_dir)\n    osync_free(backup_dir);\n\n  /* TODO: Emit error signal */\n  osync_updater_set_error(updater, error);\n\n  g_mutex_lock(updater->updating_mutex);\n  g_cond_signal(updater->updating);\n  g_mutex_unlock(updater->updating_mutex);\n\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(&error));\n\n  osync_thread_exit(updater->thread, 0);\n  return 0;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Process update on member configuration.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param member Pointer to OSyncMember who gets updated\n * @param error Pointer to OSyncError which get stacked\n * @returns TRUE on success, FALSE on error. \n */\n", "func_signal": "static osync_bool osync_updater_process_member_config(OSyncUpdater *updater, OSyncMember *member, OSyncError **error)", "code": "{\n  const char *configdir;\n  char *member_config = NULL;\n  char *update_stylesheet = NULL;\n\n  osync_assert(updater);\n  osync_assert(member);\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p, %p)\", __func__, updater, member, error);\n\n  /* Member configuration directory */\n  configdir = osync_member_get_configdir(member);\n  if (!configdir) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Couldnot find member configuration directory.\");\n    goto error;\n  }\n\n  member_config = osync_strdup_printf(\"%s%csyncmember.conf\", configdir, G_DIR_SEPARATOR);\n  if (!member_config) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build member configuration path.\");\n    goto error;\n  }\n\n  if (!g_file_test(member_config, G_FILE_TEST_IS_REGULAR)) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find member configuration file %s\", member_config);\n    goto error;\n  }\n\n  update_stylesheet = osync_strdup_printf(\"%s%c%s-%u%s\", updater->updatesdir, \n                                      G_DIR_SEPARATOR, \"syncmember\",\n                                      updater->member_version, OSYNC_UPDATER_SUFFIX);\n\n  if (!update_stylesheet) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build member configuration update stylesheet path.\");\n    goto error;\n  }\n\n  if (!g_file_test(update_stylesheet, G_FILE_TEST_IS_REGULAR)) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find update stylesheet for member configuration in directory: %s\", updater->updatesdir);\n    goto error;\n  }\n\n  /* Perform member update */\n  if (!osync_updater_stylesheet_process(updater, member_config, update_stylesheet, error))\n    goto error;\n\n  osync_free(member_config);\n  osync_free(update_stylesheet);\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  return TRUE;\n error:\t\n  if (member_config)\n    osync_free(member_config);\n\n  if (update_stylesheet)\n    osync_free(update_stylesheet);\n\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(error));\n  return FALSE;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Check if an update is required for the group\n * \n * @param updater Pointer to the updater \n * @returns TRUE if update is required on that group, FALSE if no update is required.\n * \n */\n", "func_signal": "osync_bool osync_updater_action_required(OSyncUpdater *updater)", "code": "{\n  int i, num_members;\n  osync_assert(updater);\n  osync_trace(TRACE_ENTRY, \"%s(%p)\", __func__, updater);\n\n  if (!osync_group_is_uptodate(updater->group)) {\n    osync_trace(TRACE_EXIT, \"%s: The group requires action.\", __func__);\n    return TRUE;\n  }\n\n  /* TODO: Update check magic */\n  num_members = osync_group_num_members(updater->group);\n  for (i=0; i < num_members; i++) {\n    OSyncMember *member = osync_group_nth_member(updater->group, i);\n    if (!osync_member_config_is_uptodate(member)) {\n      osync_trace(TRACE_EXIT, \"%s: #%i Member config requires action.\", __func__, i);\n      return TRUE;\n    }\n\n    if (!osync_member_plugin_is_uptodate(member)) {\n      osync_trace(TRACE_EXIT, \"%s: #%i Member plugin requires action.\", __func__, i);\n      return TRUE;\n    }\n  }\n\n  osync_trace(TRACE_EXIT, \"%s: Everything up to date\", __func__);\n  return FALSE;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Set the capabilities of a member. The capabilities get cached in the member directory\n *        as \"capabilities.xml\". This function should be only used internal. To set member\n *        capabilities, please use:\n *        osync_member_set_capabilities()\n *\n * @param member The pointer to a member object\n * @param capabilities The pointer to a capabilities object\n * @param error The error which will hold the info in case of an error\n * @return TRUE on success otherwise FALSE\n */\n", "func_signal": "osync_bool osync_capabilities_member_set_capabilities(OSyncMember *member, OSyncCapabilities* capabilities, OSyncError** error)", "code": "{\n  int size;\n  char* buffer, *filename;\n  osync_bool res;\n\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p, %p)\", __func__, member, capabilities, error);\n  osync_assert(member);\n  osync_assert(capabilities);\n\t\n  osync_capabilities_assemble(capabilities, &buffer, &size);\n  filename = g_strdup_printf(\"%s%ccapabilities.xml\", osync_member_get_configdir(member), G_DIR_SEPARATOR);\n  res = osync_file_write(filename, buffer, size, 0600, error);\n  g_free(filename);\n  g_free(buffer);\n  if(!res) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return FALSE;\n  }\n\t\n  osync_trace(TRACE_EXIT, \"%s: %i\", __func__, res);\n  return res;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Checks if the capabilities are already cached \n * @param member The member which should be tested for cached capabilities\n * @return TRUE if the capabilities for this member are cached otherwise FALSE\n */\n", "func_signal": "osync_bool osync_capabilities_member_has_capabilities(OSyncMember *member)", "code": "{\n  char *filename = NULL;\n  gboolean res = FALSE;\n\n  osync_trace(TRACE_ENTRY, \"%s(%p)\", __func__, member);\n  osync_assert(member);\n\t\n  filename = g_strdup_printf(\"%s%ccapabilities.xml\", osync_member_get_configdir(member), G_DIR_SEPARATOR);\n  res = g_file_test(filename, G_FILE_TEST_IS_REGULAR);\n  g_free(filename);\n\t\n  osync_trace(TRACE_EXIT, \"%s: %i\", __func__, res);\n  return res;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Get the first capabilitiesobjtype for a given objtype from the capabilities\n * @param capabilities The pointer to a capabilities object\n * @param objtype The name of the objtype (e.g.: contact)\n * @return The capabilitiesobjtype for a given objtype from the capabilities\n */\n", "func_signal": "OSyncCapabilitiesObjType *osync_capabilitiesobjtype_get(OSyncCapabilities *capabilities, const char *objtype)", "code": "{\n  OSyncCapabilitiesObjType *tmp = NULL;\n  osync_assert(capabilities);\n  osync_assert(objtype);\n\t\n  tmp = capabilities->first_objtype;\n  for(; tmp != NULL; tmp = tmp->next) {\n    if(!strcmp((const char *)tmp->node->name, objtype))\n      break;\n  }\t\n  return tmp;\t\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Load a capabilities object from a prepackaged file \n * @param file The name of the file\n * @param error The error which will hold the info in case of an error\n * @return The pointer to the newly allocated capabilities object or NULL in case of error\n */\n", "func_signal": "OSyncCapabilities *osync_capabilities_load(const char *file, OSyncError **error)", "code": "{\n  unsigned int size;\n  char *buffer, *filename;\n  OSyncCapabilities *capabilities;\n  osync_bool b;\n\n  osync_trace(TRACE_ENTRY, \"%s(%s, %p)\", __func__, file, error);\n  osync_assert(file);\n\t\n  filename = g_strdup_printf(\"%s%c%s\", OPENSYNC_CAPABILITIESDIR, G_DIR_SEPARATOR, file);\n\t\n  b = osync_file_read(filename, &buffer, &size, error);\n  g_free(filename);\n  if(!b) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n\t\n  capabilities = osync_capabilities_parse(buffer, size, error);\n  g_free(buffer);\n  if(!capabilities) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n\t\n  osync_trace(TRACE_EXIT, \"%s: %p\", __func__, capabilities);\n  return capabilities;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Process update on plugin configuration of a certain member.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param member Pointer to OSyncMember who gets updated\n * @param error Pointer to OSyncError which get stacked\n * @returns TRUE on success, FALSE on error. \n */\n", "func_signal": "static osync_bool osync_updater_process_plugin_config(OSyncUpdater *updater, OSyncMember *member, OSyncError **error)", "code": "{\n  const char *configdir;\n  char *plugin_config = NULL;\n  char *update_stylesheet = NULL;\n\n  osync_assert(updater);\n  osync_assert(member);\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p, %p)\", __func__, updater, member, error);\n\n  /* Member configuration directory */\n  configdir = osync_member_get_configdir(member);\n  if (!configdir) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find member configuration directory.\");\n    goto error;\n  }\n\n  plugin_config = osync_strdup_printf(\"%s%c%s.conf\", \n                                  configdir, G_DIR_SEPARATOR,\n                                  osync_member_get_pluginname(member));\n\n  if (!plugin_config) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build plugin configuration path.\");\n    goto error;\n  }\n\n  /* Plugin configuration is optional. So tolerate if none is present.\n     If so - nothing to do. Skip the update process. */\n  if (!g_file_test(plugin_config, G_FILE_TEST_IS_REGULAR))\n    goto end;\n\n  update_stylesheet = osync_strdup_printf(\"%s%c%s-%u%s\", updater->updatesdir, \n                                      G_DIR_SEPARATOR, osync_member_get_pluginname(member),\n                                      updater->plugin_version, OSYNC_UPDATER_SUFFIX);\n\n  if (!update_stylesheet) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build plugin update stylesheet path.\");\n    goto error;\n  }\n\n  if (!g_file_test(update_stylesheet, G_FILE_TEST_IS_REGULAR)) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find update stylesheet for \\\"%s\\\" plugin in directory: %s\", osync_member_get_pluginname(member), updater->updatesdir);\n    goto error;\n  }\n\n  /* Perform plugin update */\n  if (!osync_updater_stylesheet_process(updater, plugin_config, update_stylesheet, error))\n    goto error;\n\n  osync_free(update_stylesheet);\n end:\n  osync_free(plugin_config);\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  return TRUE;\n error:\t\n  if (plugin_config)\n    osync_free(plugin_config);\n\n  if (update_stylesheet)\n    osync_free(update_stylesheet);\n\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(error));\n  return FALSE;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Increase the reference count on a plugin\n * \n * @param updater Pointer to the plugin\n * \n */\n", "func_signal": "OSyncUpdater *osync_updater_ref(OSyncUpdater *updater)", "code": "{\n  osync_assert(updater);\n\t\n  g_atomic_int_inc(&(updater->ref_count));\n\n  return updater;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Dump the capabilities into the memory.\n * @param capabilities The pointer to a capabilities object \n * @param buffer The pointer to the buffer which will hold the xml document\n * @param size The pointer to the buffer which will hold the size of the xml document\n * @return The xml document and the size of it. It's up to the caller to free\n *  the buffer. Always it return TRUE.\n */\n", "func_signal": "osync_bool osync_capabilities_assemble(OSyncCapabilities *capabilities, char **buffer, int *size)", "code": "{\n  osync_assert(capabilities);\n  osync_assert(buffer);\n  osync_assert(size);\n\t\n  xmlDocDumpFormatMemoryEnc(capabilities->doc, (xmlChar **) buffer, size, NULL, 1);\n  return TRUE;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Set path of Updates directory, which inlcudes the update stylesheets. \n * \n * @param updater Pointer to the updater \n * @param path Path to updates directory \n * \n */\n", "func_signal": "void osync_updater_set_updates_directory(OSyncUpdater *updater, const char *path)", "code": "{\n  osync_assert(updater);\n  osync_assert(path);\n\n  if (updater->updatesdir)\n    osync_free(updater->updatesdir);\n\n  updater->updatesdir = osync_strdup(path);\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/* FIXME: timeout */\n", "func_signal": "START_TEST (commit_error_modify)", "code": "{\n\tchar *testbed = setup_testbed(\"multisync_easy_new\");\n\tchar *formatdir = g_strdup_printf(\"%s/formats\", testbed);\n\tchar *plugindir = g_strdup_printf(\"%s/plugins\", testbed);\n\t\n\tOSyncError *error = NULL;\n\tOSyncGroup *group = osync_group_new(&error);\n\tosync_group_set_schemadir(group, testbed);\n\tosync_group_load(group, \"configs/group\", &error);\n\tfail_unless(error == NULL, NULL);\n\n\tOSyncEngine *engine = osync_engine_new(group, &error);\n\tfail_unless(engine != NULL, NULL);\n\tfail_unless(error == NULL, NULL);\n\n\tosync_engine_set_schemadir(engine, testbed);\n\tosync_engine_set_plugindir(engine, plugindir);\n\tosync_engine_set_formatdir(engine, formatdir);\n\n\tdiscover_all_once(engine, &error);\n\n\tosync_engine_set_memberstatus_callback(engine, member_status, GINT_TO_POINTER(1));\n\tosync_engine_set_enginestatus_callback(engine, engine_status, GINT_TO_POINTER(1));\n\tosync_engine_set_changestatus_callback(engine, entry_status, GINT_TO_POINTER(1));\n\tosync_engine_set_mappingstatus_callback(engine, mapping_status, GINT_TO_POINTER(1));\n\tosync_engine_set_conflict_callback(engine, conflict_handler_choose_modified, GINT_TO_POINTER(3));\n\n\tfail_unless(osync_engine_initialize(engine, &error), NULL);\n\tfail_unless(error == NULL, NULL);\n\n\tfail_unless(synchronize_once(engine, &error), NULL);\n\tfail_unless(error == NULL, NULL);\n\tfail_unless(!osync_error_is_set(&error), NULL);\n\t\n\tg_setenv(\"COMMIT_TIMEOUT\", \"2\", TRUE);\n\tg_setenv(\"COMMIT_ERROR\", \"4\", TRUE);\n\n\tsleep(2);\n\t\n\tif (system(\"cp newdata2 data1/testdata\"))\n\t\tabort();\n\t\n\tfail_unless(!synchronize_once(engine, &error), NULL);\n\tfail_unless(osync_error_is_set(&error), NULL);\n\t\n\tosync_error_unref(&error);\n\tosync_engine_finalize(engine, &error);\n\tosync_engine_unref(engine);\n\t\n\tfail_unless(num_client_errors == 0, NULL);\n\tfail_unless(num_client_connected == 3, NULL);\n\tfail_unless(num_client_disconnected == 3, NULL);\n\tfail_unless(num_client_written == 3, NULL);\n\tfail_unless(num_change_read == 1, NULL);\n\tfail_unless(num_change_written == 0, NULL);\n\tfail_unless(num_change_error == 2, NULL);\n\tfail_unless(num_mapping_errors == 2, NULL);\n\tfail_unless(num_mapping_conflicts == 0, NULL);\n\tfail_unless(num_engine_errors == 1, NULL);\n\tfail_unless(num_engine_successful == 0, NULL);\n\t\n\tfail_unless(!system(\"test \\\"x$(diff -x \\\".*\\\" data1 data2)\\\" != \\\"x\\\"\"), NULL);\n\tfail_unless(!system(\"test \\\"x$(diff -x \\\".*\\\" data1 data3)\\\" != \\\"x\\\"\"), NULL);\n\tfail_unless(osync_testing_diff(\"data2\", \"data3\"));\n\n\tg_free(formatdir);\n\tg_free(plugindir);\n\t\n\tdestroy_testbed(testbed);\n}", "path": "tests\\engine-tests\\check_engine_error.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Process update on group configuration.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param error Pointer to OSyncError which get stacked\n * @returns TRUE on success, FALSE on error. \n */\n", "func_signal": "static osync_bool osync_updater_process_group(OSyncUpdater *updater, OSyncError **error)", "code": "{\n  const char *configdir;\n  char *group_config = NULL;\n  char *update_stylesheet = NULL;\n\n  osync_assert(updater);\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p)\", __func__, updater, error);\n\n  /* Group configuration directory */\n  configdir = osync_group_get_configdir(updater->group);\n  if (!configdir) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find group configuration directory.\");\n    goto error;\n  }\n\n  group_config = osync_strdup_printf(\"%s%c%s\", configdir, G_DIR_SEPARATOR, \"syncgroup.conf\");\n  if (!group_config) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build group configuration path.\");\n    goto error;\n  }\n\n  if (!g_file_test(group_config, G_FILE_TEST_IS_REGULAR)) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find group configuration file: %s\", group_config);\n    goto error;\n  }\n\n  update_stylesheet = osync_strdup_printf(\"%s%c%s-%u%s\", updater->updatesdir, \n                                      G_DIR_SEPARATOR, \"syncgroup\",\n                                      updater->group_version, OSYNC_UPDATER_SUFFIX);\n\n  if (!update_stylesheet) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not get enough memory to build group update stylesheet path.\");\n    goto error;\n  }\n\n  if (!g_file_test(update_stylesheet, G_FILE_TEST_IS_REGULAR)) {\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not find update stylesheet for group configuration in directory: %s\", updater->updatesdir);\n    goto error;\n  }\n\n  /* Perform group update */\n  if (!osync_updater_stylesheet_process(updater, group_config, update_stylesheet, error))\n    goto error;\n\n  osync_free(group_config);\n  osync_free(update_stylesheet);\n\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  return TRUE;\n error:\n\n  if (group_config)\n    osync_free(group_config);\n\n  if (update_stylesheet)\n    osync_free(update_stylesheet);\n\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(error));\n  return FALSE;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Change version of member configuration. Only for testing.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param major Major Version number to set\n */\n", "func_signal": "void osync_updater_set_member_version(OSyncUpdater *updater, int major)", "code": "{\n  osync_assert(updater);\n  updater->member_version = major;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Change version of plugin configuration. Only for testing.\n *\n * @param updater Pointer to the OSyncUpdater \n * @param major Major Version number to set\n */\n", "func_signal": "void osync_updater_set_plugin_version(OSyncUpdater *updater, int major)", "code": "{\n  osync_assert(updater);\n  updater->plugin_version = major;\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/*! @brief Process update on the group. This function is not blocking. \n * \n * @param updater Pointer to the updater \n * @param error Pointer to OSyncError\n * @returns TRUE if updating process started successfully, FALSE on error.\n * \n */\n", "func_signal": "osync_bool osync_updater_process(OSyncUpdater *updater, OSyncError **error)", "code": "{\n  osync_assert(updater);\n  osync_trace(TRACE_ENTRY, \"%s(%p, %p)\", __func__, updater, error);\n\n  updater->thread = osync_thread_create(osync_updater_run, updater, error);\n  if (!updater->thread)\n    goto error;\n\n  osync_updater_ref(updater);\n\n  osync_trace(TRACE_EXIT, \"%s\", __func__);\n  return TRUE;\n\n error:\n  osync_trace(TRACE_EXIT_ERROR, \"%s: %s\", __func__, osync_error_print(error));\n  return FALSE;\n\n}", "path": "opensync\\group\\opensync_updater.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/**\n * @brief Creates a new capabilities object from a xml document. \n * @param buffer The pointer to the xml document\n * @param size The size of the xml document\n * @param error The error which will hold the info in case of an error\n * @return The pointer to the newly allocated capabilities object or NULL in case of error\n */\n", "func_signal": "OSyncCapabilities *osync_capabilities_parse(const char *buffer, unsigned int size, OSyncError **error)", "code": "{\n  OSyncCapabilities *capabilities = NULL;\n  xmlNodePtr cur = NULL;\n  osync_trace(TRACE_ENTRY, \"%s(%p, %u, %p)\", __func__, buffer, size, error);\n  osync_assert(buffer);\n\t\n  capabilities = osync_try_malloc0(sizeof(OSyncCapabilities), error);\n  if(!capabilities) {\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n\n  capabilities->ref_count = 1;\n  capabilities->first_objtype = NULL;\n  capabilities->last_objtype = NULL;\t\n  capabilities->doc = xmlReadMemory(buffer, size, NULL, NULL, XML_PARSE_NOBLANKS);\n  if(capabilities->doc == NULL) {\n    g_free(capabilities);\n    osync_error_set(error, OSYNC_ERROR_GENERIC, \"Could not parse XML.\");\n    osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n    return NULL;\n  }\n  capabilities->doc->_private = capabilities;\n\t\n  cur = xmlDocGetRootElement(capabilities->doc);\n  cur = cur->children;\n  for(; cur != NULL; cur = cur->next) {\n    OSyncCapabilitiesObjType *capabilitiesobjtype = osync_capabilitiesobjtype_new(capabilities, cur, error);\n    xmlNodePtr tmp =NULL;\n    if(!capabilitiesobjtype) {\n      osync_capabilities_unref(capabilities);\n      osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n      return NULL;\n    }\n\t\t\n    tmp = cur->children;\n    for(; tmp != NULL; tmp = tmp->next) {\n      OSyncCapability *capability = NULL;\n      /* TODO: its to slow to check the name */\n      /* Skip nodes which are comments to keep the capabilities sorted. */\n      if (!strcmp((const char *) tmp->name, \"comment\"))\n        continue;\n\n      capability = osync_capability_new_node(capabilitiesobjtype, tmp, error);\n      if(!capability) {\n        osync_capabilities_unref(capabilities);\n        osync_trace(TRACE_EXIT_ERROR, \"%s: %s\" , __func__, osync_error_print(error));\n        return NULL;\n      }\n    }\n  }\n\t\n  osync_trace(TRACE_EXIT, \"%s: %p\", __func__, capabilities);\n  return capabilities;\n}", "path": "opensync\\merger\\opensync_capabilities.c", "repo_name": "ianmartin/opensync", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 5988}
{"docstring": "/* Kernel main */\n", "func_signal": "void _main(void *mb_data, unsigned int mb_magic)", "code": "{\n\tinit(mb_data);\n\t/* Spin on the halt, doing nothing whatsoever except handle interrupts */\n\twhile(1)\n\t{\n\t\thlt();\n\t}\n}", "path": "src\\main.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Reserve or free an area of physical memory in the bitmap */\n", "func_signal": "void pmem_set_area(long offset, long len, char free)", "code": "{\n\t// Convert offset and len to pages, and do some sanity checking\n\toffset >>= PAGE_BIT;\n\tif(offset >= bitmap_pages)\n\t\treturn;\n\n\talign_to_page(&len);\n\tlen >>= PAGE_BIT;\n\tif((offset + len) > bitmap_pages)\n\t{\n\t\tlen = bitmap_pages - offset - 1;\n\t\tputs(\"TOO BIG\");\n\t}\n\n\t// Initialize cell and bit offset\n\tlong curr_cell = offset >> CELL_BIT;\n\tlong curr_bit = (offset & (CELL_SIZE-1));\n\n\t// Fill up the starting bits of the first partial cell, if any\n\tif(curr_bit != 0)\n\t{\n\t\t// Modify len so that we can easily extract trailing bits later\n\t\tlen -= CELL_SIZE - curr_bit;\n\t\tfor(;curr_bit < CELL_SIZE; curr_bit++)\n\t\t\tpmem_set_bit(curr_cell, curr_bit, free);\n\n\t\tcurr_bit = 0;\n\t\tcurr_cell++;\n\t}\n\n\t// Fill full 32bit cells\n\tfor(; len >= CELL_SIZE; len -= CELL_SIZE)\n\t{\n\t\tpmem_set_cell(curr_cell, free);\n\t\tcurr_cell++;\n\t}\n\n\t// Fill the trailing bits\n\tfor(curr_bit = 0; curr_bit < len; curr_bit++)\n\t\tpmem_set_bit(curr_cell, curr_bit, free);\n\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Remap the two PICs to new interrupt offsets */\n", "func_signal": "void pic_remap(unsigned int int_off1, unsigned int int_off2)", "code": "{\n\tunsigned char mask1, mask2;\n\tasm(\"cli\");\n\t/* Save masks */\n\tmask1 = inb(PIC_MASTER_DATA);\n\tmask2 = inb(PIC_SLAVE_DATA);\n\n\t/* INIT master */\n\toutb(PIC_MASTER_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);\n\n\t/* master starts at off1 */\n\toutb(PIC_MASTER_DATA, int_off1);\n\n\t/* Master has slave at IN2 */\n\toutb(PIC_MASTER_DATA, 1<<2);\n\n\t/* Set 8086 mode */\n\toutb(PIC_MASTER_DATA, PIC_ICW4_8086);\n\n\t/* INIT slave */\n\toutb(PIC_SLAVE_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);\n\n\t/* slave starts at off2 */\n\toutb(PIC_SLAVE_DATA, int_off2);\n\n\t/* Slave connects to IN2 of master */\n\toutb(PIC_SLAVE_DATA, 2);\n\n\t/* Set 8086 mode */\n\toutb(PIC_SLAVE_DATA, PIC_ICW4_8086);\n\n\t/* Restore masks */\n\toutb(PIC_MASTER_DATA, mask1);\n\toutb(PIC_SLAVE_DATA, mask2);\n\tasm(\"sti\");\n}", "path": "src\\pic.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Get the page table at the given page directory index, creating it if it\n * doesn't exist\n */\n", "func_signal": "void *get_page_table(long pdir_index)", "code": "{\n\tlong *page_table = (long*)kernel_page_dir[pdir_index];\n\tif(page_table == 0)\n\t{\n\t\tpage_table = get_page();\n\t\tkernel_page_dir[pdir_index] = (long)page_table;\n\t\tlong page = 0;\n\t\tfor(; page < 1024; page++)\n\t\t\tpage_table[page] = 0;\n\t}\n\treturn page_table;\n}", "path": "src\\paging.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Put a single character in the current color to the current screen position */\n", "func_signal": "void inline putch(char chr)", "code": "{\n\tif(chr == '\\n')\n\t{\n\t\tset_cursor(0, cursor_y+1);\n\t\treturn;\n\t}\n\tscreen[cursor_idx] = chr | color << 8;\n\tset_cursor(cursor_x+1, cursor_y);\n\t//cursor_idx++;\n\t//cursor_x++;\n\t//if(cursor_x == WIDTH)\n\t//{\n\t\t//set_cursor(0, cursor_y+1);\n\t//}\n}", "path": "src\\screen.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Helper method to get the hex equivalent of a 4bit number */\n", "func_signal": "char get_hex(char num)", "code": "{\n\tif(num >= 0 && num <= 9)\n\t\treturn '0' + num;\n\telse if(num >= 10 && num <= 16)\n\t\treturn 'A' + (num-10);\n\telse\n\t\treturn 'a' + (num-10);\n}", "path": "src\\screen.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Generic IRQ handler, is bounced to from interrupt handlers 32-47 */\n", "func_signal": "void k_irq_handler(unsigned int irq)", "code": "{\n\tif(irq == 1)\n\t{\n\t\tkeyboard_handler();\n\t}\n\telse if(irq > 1)\n\t{\n\t\tset_cursor(0, 0);\n\t\tputch('I');\n\t\tputch('R');\n\t\tputch('Q');\n\t\tputch(' ');\n\t\tprint_hex_char(irq);\n\t}\n\tpic_signal_eoi(irq);\n}", "path": "src\\main.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Reserve or free the page of physical memory given by cell[bit] */\n", "func_signal": "void pmem_set_bit(long cell, char bit, char free)", "code": "{\n\tif(!free)\n\t{\n\t\tpage_bitmap[cell] |= (1<<bit);\n\t\tnum_pages--;\n\t}\n\telse\n\t{\n\t\tpage_bitmap[cell] &= ~(1<<bit);\n\t\tnum_pages++;\n\t}\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Free the page pointed to by the page_addr by converting it to a cell/bit pair\n * in the bitmap and setting that to be open. Also updates the earliest free\n * cell if needed.\n *\n * TODO: For now is lenient and allows the address to be in the middle of a\n * page, but should probably be more strict about it later, as it is most likely\n * indicative of an error somewhere\n */\n", "func_signal": "void free_page(void* page_addr)", "code": "{\n\tlong page_offset = (long)page_addr >> PAGE_BIT;\n\tlong cell = page_offset >> CELL_BIT;\n\tlong bit = page_offset & (CELL_SIZE - 1);\n\n\tpage_bitmap[cell] &= ~(1<<bit);\n\n\tif(cell < earliest_free_cell)\n\t\tearliest_free_cell = cell;\n\n\n\tprint_hex((long)page_addr);\n\tputs(\" freed\");\n\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Put a full string and go to next line */\n", "func_signal": "void puts(const char *string)", "code": "{\n\twhile(*string)\n\t{\n\t\tputch(*string);\n\t\tstring++;\n\t}\n\tset_cursor(0, cursor_y+1);\n}", "path": "src\\screen.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Map the physical memory starting at pm_start to the virtual address vm_start,\n * for length bytes\n *\n * Assumes that the physical memory is already allocated\n */\n", "func_signal": "void map_area(void *pm_start, void *vm_start, long length)", "code": "{\n\t/* First find the page directory entries we will be using */\n\tlong pdir_entry = (long)vm_start >> 22;\n\tlong pdir_end = ((long)vm_start + length) >> 22;\n\tlong *page_table = 0;\n\tvoid *pm_ptr = (void*)((long)pm_start & (PAGE_SIZE-1));\n\n\t/* Amount of pages we need to map */\n\tlength = (length + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);\n\n\tprint_hex(length);\n\tputs(\" pages mapped\");\n\n\t/* Walk through page directory entries */\n\tfor(;pdir_entry <= pdir_end; pdir_entry++)\n\t{\n\t\tpage_table = get_page_table(pdir_entry);\n\n\t\t/* Find the index into the page table */\n\t\tlong page = ((long)pm_ptr >> 12) & 0x3FF;\n\n\t\t/* Map as many pages as we need to */\n\t\tfor(; page < 1024 && length > 0; length -= PAGE_SIZE, page++, pm_ptr += PAGE_SIZE)\n\t\t{\n\t\t\tpage_table[page] = (long)pm_ptr | 0x3;\n\t\t}\n\t}\n}", "path": "src\\paging.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Set a single entry in the GDT, we hate the format :/\n * Params:\n *  num    - The entry to set\n *  base   - The address the segment starts with\n *  limit  - The size of the segment\n *  access - Access bits\n *  gran   - Granularity of segment (set in upper nibble)\n */\n", "func_signal": "void gdt_set_entry(int num, unsigned long base, unsigned long limit, unsigned char access, unsigned char gran)", "code": "{\n\tgdt[num].base_low = (base & 0xFFFF);\n\tgdt[num].base_middle = (base >> 16) & 0xFF;\n\tgdt[num].base_high = (base >> 24) & 0xFF;\n\n\tgdt[num].limit_low = (limit & 0xFFFF);\n\tgdt[num].granularity = ((limit >> 16) & 0x0F);\n\n\tgdt[num].granularity |= (gran & 0xF0);\n\tgdt[num].access = access;\n}", "path": "src\\init.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Find an open page in the bitmap at the cell offset given.\n * Assumes that the given cell actually has an open page\n */\n", "func_signal": "int get_page_in_cell(long cell)", "code": "{\n\tchar curr_bit = 0;\n\tlong bitmap_cell = page_bitmap[cell];\n\tfor(; curr_bit < CELL_SIZE; curr_bit++)\n\t{\n\t\tif((bitmap_cell & (1<<curr_bit)) == 0)\n\t\t{\n\t\t\t/* Set page to reserved */\n\t\t\tpage_bitmap[cell] |= (1<<curr_bit);\n\t\t\t// Keep track of which cell in the bitmap has the first free page\n\t\t\tif(cell == earliest_free_cell && page_bitmap[cell] == ~0)\n\t\t\t\tearliest_free_cell = cell + 1;\n\n\t\t\treturn (cell<<CELL_BIT) + curr_bit;\n\t\t}\n\t}\n\n\t// XXX: what else can we do? :/\n\treturn 0;\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Initialize kernel, doing these steps:\n *  - Set up GDT\n *  - Set up IDT\n *  - Remap PIC\n *  - Set up physical allocator\n *  - Make a page directory that maps the kernel 1:1, as well as other things\n *  - Set up paging\n */\n", "func_signal": "void init(long *mb_data)", "code": "{\n\t/* Screen needs to work while we're in our trick segment */\n\tscreen_set_base((void*)DE_SEGMENT(0xB8000));\n\tcls();\n\n\t/* Fix up MultiBoot data so that it can be used in our trick segmentation */\n\tmb_data = (long*) DE_SEGMENT(mb_data);\n\tmb_data[12] = (long) DE_SEGMENT(mb_data[12]);\n\n\t/* Check if memory size is present in mb_data and save it for our own use */\n\tif((mb_data[0] & 1) == 1)\n\t{\n\t\tphys_memory_size = (mb_data[2] + 1024) * 1024;\n\t}\n\telse\n\t{\n\t\tputs(\"OH FUCK\");\n\t}\n\n\n\tkernel_size = &_end - &_start;\n\n\tset_color(2);\n\tkernel_size = init_palloc(phys_memory_size, kernel_size, mb_data);\n\tputs(\"Pagestack set up\");\n\n\tset_color(3);\n\tsetup_idt();\n\tputs(\"Set up IDT\");\n\n\tset_color(4);\n\tinit_paging(&_phys_start, kernel_size);\n\tputs(\"Paging\");\n\n\tset_color(5);\n\tgdt_install();\n\tprint_hex(kernel_page_dir[0]);\n\tputs(\" is the first MB!\");\n\tprint_hex(page_base[256]);\n\tputs(\" is also the first MB\");\n\tscreen_set_base((void*)0xB8000);\n\tputs(\"Initialized GDT\");\n\n\n\tpic_remap(32, 32+8);\n\tset_color(6);\n\tputs(\"Remapped PIC\");\n\tsti();\n\n\tset_color(7);\n\n}", "path": "src\\main.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Initialize the physical memory allocator\n * Set up the bitmap to fill the available physical memory space,\n * and reserve space for the memory areas given by GRUB as reserved, as well as\n * kernel space.\n */\n", "func_signal": "unsigned long init_palloc(long phys_memory_size, long kernel_size, long* mb_data)", "code": "{\n\t// Bitmap starts right after the end of the kernel code\n\tpage_bitmap = &_end;\n\n\t/* Reserve memory for kernel and page stack in physical memory */\n\n\t// How many pages is there in total?\n\tlong reserve = (phys_memory_size / PAGE_SIZE);\n\tbitmap_pages = reserve;\n\tnum_pages = reserve;\n\t\n\t// Get the amount of cells the bitmap will contain, aligned to full cells\n\treserve = (reserve >> CELL_BIT) + ((reserve & (CELL_SIZE-1)) != 0);\n\tbitmap_cells = reserve;\n\n\t// Make into bytes and add the size of the kernel to get the reserved kernel\n\t// space\n\treserve = kernel_size + (reserve*4);\n\talign_to_page(&reserve);\n\n\tprint_hex(reserve);\n\tputs(\" bytes of reserved memory\");\n\n\t// Start by marking every bit of memory as taken\n\tpmem_set_area(0, phys_memory_size, 0);\n\n\t// Parse the memory map to re-open the usable memory space\n\tparse_memory_map(mb_data);\n\n\t// Then reserve kernel space\n\tpmem_set_area((long)&_phys_start, reserve, 0);\n\n\tprint_hex(num_pages);\n\tputs(\" pages available for allocation\");\n\n\t/* Print memory map */\n\tputs(\"Memory map\");\n\tint i = 0;\n\tfor(; i < bitmap_cells; i++)\n\t{\n\t\tif(page_bitmap[i])\n\t\t{\n\t\t\tprint_hex(i);\n\t\t\tputch(' ');\n\t\t\tprint_hex(page_bitmap[i]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\treturn reserve;\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Print a 32 bit number as hex (with 0x prefix) */\n", "func_signal": "void print_hex(unsigned long num)", "code": "{\n\tputch('0');\n\tputch('x');\n\tconst char* ptr = (const char*)&num;\n\tint i = 0;\n\tfor(; i < 4; i++)\n\t{\n\t\tprint_hex_char(ptr[3-i]);\n\t}\n}", "path": "src\\screen.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Clear screen and reset cursor */\n", "func_signal": "void cls()", "code": "{\n\tint i = 0;\n\tfor(;i < (WIDTH*HEIGHT/2); i++)\n\t\t*(((long*)screen)+i) = 0;\n\tcursor_x = 0;\n\tcursor_y = 0;\n\tcursor_idx = 0;\n}", "path": "src\\screen.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Get a free page of physical memory\n *\n * Walks through the cells of the bitmap, starting at the cell with the earliest\n * recorded free page, checks if they have all bits set (i.e. equal to ~0).\n * Then walk through the individual bits to find the free page, and convert the\n * index to a physical memory access\n */\n", "func_signal": "void *get_page()", "code": "{\n\tlong curr_cell = earliest_free_cell;\n\tvoid *address = (void*)0;\n\n\t/* First loop through on a cell-level, looking for cells with free pages,\n\t * i.e. any cell that does not have all its bits set\n\t */\n\tfor(;curr_cell < bitmap_cells; curr_cell++)\n\t{\n\t\tif(page_bitmap[curr_cell] != ~0l)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Find the open page and convert it to an address */\n\tlong page = get_page_in_cell(curr_cell);\n\taddress = (void*)(page << PAGE_BIT);\n\n\tprint_hex((long)address);\n\tputs(\" allocated\");\n\n\treturn address;\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Parse the memory map given by GRUB and free up usable memory areas in the\n * bitmap\n */\n", "func_signal": "void parse_memory_map(long *mb_data)", "code": "{\n\t// Is there a memory map?\n\tif((mb_data[0] & 1<<6))\n\t{\n\t\t/* Point to the memory map */\n\t\tlong mmap_length = mb_data[11];\n\t\tvoid *mmap_end = (void*)mb_data[12] + mmap_length;\n\t\tmem_map_t *map_ptr = (mem_map_t *)mb_data[12];\n\n\t\t// This is just for sake of reporting at the end\n\t\tlong usable_mem_size = 0;\n\t\tlong full_mem_size = 0;\n\n\t\tfor(;(void*)map_ptr < mmap_end;)\n\t\t{\n\t\t\t// Type 1 means usable memory\n\t\t\tif(map_ptr->type == 1)\n\t\t\t{\n\t\t\t\tpmem_set_area(map_ptr->addr_low, map_ptr->length_low, 1);\n\t\t\t\tusable_mem_size += map_ptr->length_low;\n\t\t\t}\n\n\t\t\tfull_mem_size += map_ptr->length_low;\n\n\t\t\t// Move ahead size + sizeof(size) bytes, as the size of size is not\n\t\t\t// included in size. Yes, I did that on purpose.\n\t\t\tmap_ptr = ((void*)map_ptr) + map_ptr->size + sizeof(map_ptr->size);\n\t\t}\n\n\t\t// Print utterly useless status information\n\t\tprint_hex(usable_mem_size);\n\t\tputch(' ');\n\t\tputch('/');\n\t\tputch(' ');\n\t\tprint_hex(full_mem_size);\n\t\tputs(\" B of usable memory\");\n\t}\n\telse\n\t{\n\t\t// XXX: Panic should be done here\n\t\tputs(\"No memory map info\");\n\t}\n}", "path": "src\\mem.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* Set up and install our three segments */\n", "func_signal": "void gdt_install()", "code": "{\n\tgp.limit = (sizeof(struct gdt_entry) * 3) - 1;\n\tgp.base = (unsigned long)&gdt;\n\n\tgdt_set_entry(0, 0, 0, 0, 0);\n\tgdt_set_entry(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);\n\tgdt_set_entry(2, 0, 0xFFFFFFFF, 0x92, 0xCF);\n\n\tgdt_set();\n}", "path": "src\\init.c", "repo_name": "ircubic/micro_os", "stars": 2, "license": "None", "language": "c", "size": 96}
{"docstring": "/* used for dcload-ip + lwIP\n * assumes fs_dcload_init() was previously called\n */\n", "func_signal": "int fs_dcload_init_lwip(void *p)", "code": "{\n    /* Check for combination of KOS networking and dcload-ip */\n    if ((dcload_type == DCLOAD_TYPE_IP) && (__kos_init_flags & INIT_NET)) {\n\tlwip_dclsc = p;\n\n\tdbglog(DBG_INFO, \"dc-load console support enabled (lwIP)\\n\");\n    } else\n\treturn -1;\n\n    /* Register with VFS */\n    return nmmgr_handler_add(&vh.nmmgr);\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/**\n * Bind an UDP PCB.\n *\n * @param pcb UDP PCB to be bound with a local address ipaddr and port.\n * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to\n * bind to all local interfaces.\n * @param port local UDP port to bind with.\n *\n * @return lwIP error code.\n * - ERR_OK. Successful. No error occured.\n * - ERR_USE. The specified ipaddr and port are already bound to by\n * another UDP PCB.\n * \n * @see udp_disconnect()\n */\n", "func_signal": "err_t\nudp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)", "code": "{\n  struct udp_pcb *ipcb;\n  u8_t rebind;\n  DEBUGF(UDP_DEBUG | DBG_TRACE | 3, (\"udp_bind(ipaddr = %lx, port = %u)\\n\", ipaddr->addr, port));\n  rebind = 0;\n  /* Check for double bind and rebind of the same pcb */\n  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {\n    /* is this UDP PCB already on active list? */ \n    if (pcb == ipcb) {\n      /* pcb may occur at most once in active list */\n      LWIP_ASSERT(\"rebind == 0\", rebind == 0);\n      /* pcb already in list, just rebind */\n\t    rebind = 1;\n    }\n/* this code does not allow upper layer to share a UDP port for\n   listening to broadcast or multicast traffic (See SO_REUSE_ADDR and\n   SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR\n   combine with implementation of UDP PCB flags. Leon Woestenberg. */\n#if 0 \n    /* port matches that of PCB in list? */\n    else if ((ipcb->local_port == port) &&\n       /* IP address matches, or one is IP_ADDR_ANY? */\n       (ip_addr_isany(&(ipcb->local_ip)) ||\n\t     ip_addr_isany(ipaddr) ||\n\t     ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {\n      /* other PCB already binds to this local IP and port */\n      DEBUGF(UDP_DEBUG, (\"udp_bind: local port %u already bound by another pcb\\n\", port));\n      return ERR_USE;\t   \n    }\n#endif\n  }\n  /* bind local address */\n  ip_addr_set(&pcb->local_ip, ipaddr);\n  /* no port specified? */\n  if (port == 0) {\n#ifndef UDP_LOCAL_PORT_RANGE_START\n#define UDP_LOCAL_PORT_RANGE_START 4096\n#define UDP_LOCAL_PORT_RANGE_END   0x7fff\n#endif\n    port = UDP_LOCAL_PORT_RANGE_START;\n    ipcb = udp_pcbs;\n    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {\n      if (ipcb->local_port == port) {\n        port++;\n        ipcb = udp_pcbs;\n      } else\n  \t    ipcb = ipcb->next;\n    }\n    if (ipcb != NULL) {\n      /* no more ports available in local range */\n      DEBUGF(UDP_DEBUG, (\"udp_bind: out of free UDP ports\\n\"));\n      return ERR_USE;\n    }\t\n  }\n  pcb->local_port = port;\n  /* pcb not active yet? */\n  if (rebind == 0) {\n    /* place the PCB on the active list if not already there */\n    pcb->next = udp_pcbs;\n    udp_pcbs = pcb;\n  }  \n  DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, (\"udp_bind: bound to %u.%u.%u.%u, port %u\\n\",\n   (u8_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),\n   (u8_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),\n   (u8_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),\n   (u8_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));\n  return ERR_OK;\n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Printk replacement */\n", "func_signal": "int dcload_write_buffer(const char *str, int len, int xlat)", "code": "{\n  int oldirq = 0;\n\n  spinlock_lock(&mutex);\n  STOPIRQ;\n  len = dcloadsyscall(DCLOAD_WRITE, 1, str, len);\n  STARTIRQ;\n  spinlock_unlock(&mutex);\n  return len;\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/**\n * Connect an UDP PCB.\n *\n * This will associate the UDP PCB with the remote address.\n *\n * @param pcb UDP PCB to be connected with remote address ipaddr and port.\n * @param ipaddr remote IP address to connect with.\n * @param port remote UDP port to connect with.\n *\n * @return lwIP error code\n * \n * @see udp_disconnect()\n */\n", "func_signal": "err_t\nudp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)", "code": "{\n  struct udp_pcb *ipcb;\n\n  if (pcb->local_port == 0) {\n    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);\n    if (err != ERR_OK)\n      return err;\n  }\n\n  ip_addr_set(&pcb->remote_ip, ipaddr);\n  pcb->remote_port = port;\n  pcb->flags |= UDP_FLAGS_CONNECTED;\n/** TODO: this functionality belongs in upper layers */\n#if 0\n  /* Nail down local IP for netconn_addr()/getsockname() */\n  if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) { \n    struct netif *netif;\n\n    if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {\n    \tDEBUGF(UDP_DEBUG, (\"udp_connect: No route to 0x%lx\\n\", pcb->remote_ip.addr));\n#ifdef UDP_STATS\n        ++lwip_stats.udp.rterr;\n#endif /* UDP_STATS */\n    \treturn ERR_RTE;\n    }\n    /** TODO: this will bind the udp pcb locally, to the interface which\n        is used to route output packets to the remote address. However, we\n        might want to accept incoming packets on any interface! */\n    pcb->local_ip = netif->ip_addr;\n  } else if (ip_addr_isany(&pcb->remote_ip)) { \n    pcb->local_ip.addr = 0;\n  }\n#endif\n  DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, (\"udp_connect: connected to %u.%u.%u.%u, port %u\\n\",\n   (u8_t)(ntohl(pcb->remote_ip.addr) >> 24 & 0xff),\n   (u8_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),\n   (u8_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),\n   (u8_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));\n\n  /* Insert UDP PCB into the list of active UDP PCBs. */\n  for(ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {\n    if (pcb == ipcb) {\n      /* already on the list, just return */\n      return ERR_OK;\n    }\n  }\n  /* PCB not yet on the list, add PCB now */\n  pcb->next = udp_pcbs;\n  udp_pcbs = pcb;\n  return ERR_OK;\n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Do a stack trace from the given frame pointer (useful for things like\n   tracing from an ISR); leave off the first n frames. */\n", "func_signal": "void arch_stk_trace_at(uint32 fp, int n)", "code": "{\n\tuint32 foo = fp + 5;\n\tdbgio_printf(\"%d\\n\", foo);\n#ifdef FRAME_POINTERS\n\tdbgio_printf(\"-------- Stack Trace (innermost first) ---------\\n\");\n\tdbgio_printf(\"-------------- End Stack Trace -----------------\\n\");\n#else\n\tdbgio_printf(\"Stack Trace: frame pointers not enabled!\\n\");\n#endif\n}", "path": "kernel\\arch\\ia32\\kernel\\stack.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* fairly straight threshhold-by-band based until we find something\n   that works better and isn't patented. */\n", "func_signal": "static int _ve_amp(envelope_lookup *ve,\n\t\t   vorbis_info_psy_global *gi,\n\t\t   float *data,\n\t\t   envelope_band *bands,\n\t\t   envelope_filter_state *filters,\n\t\t   long pos)", "code": "{\n  long n=ve->winlength;\n  int ret=0;\n  long i,j;\n  float decay;\n\n  /* we want to have a 'minimum bar' for energy, else we're just\n     basing blocks on quantization noise that outweighs the signal\n     itself (for low power signals) */\n\n  float minV=ve->minenergy;\n  float *vec=alloca(n*sizeof(*vec));\n\n  /* stretch is used to gradually lengthen the number of windows\n     considered prevoius-to-potential-trigger */\n  int stretch=max(VE_MINSTRETCH,ve->stretch/2);\n  float penalty=gi->stretch_penalty-(ve->stretch/2-VE_MINSTRETCH);\n  if(penalty<0.f)penalty=0.f;\n  if(penalty>gi->stretch_penalty)penalty=gi->stretch_penalty;\n  \n  /*_analysis_output_always(\"lpcm\",seq2,data,n,0,0,\n    totalshift+pos*ve->searchstep);*/\n  \n /* window and transform */\n  for(i=0;i<n;i++)\n    vec[i]=data[i]*ve->mdct_win[i];\n  mdct_forward(&ve->mdct,vec,vec);\n  \n  /*_analysis_output_always(\"mdct\",seq2,vec,n/2,0,1,0); */\n\n  /* near-DC spreading function; this has nothing to do with\n     psychoacoustics, just sidelobe leakage and window size */\n  {\n    float temp=vec[0]*vec[0]+.7*vec[1]*vec[1]+.2*vec[2]*vec[2];\n    int ptr=filters->nearptr;\n\n    /* the accumulation is regularly refreshed from scratch to avoid\n       floating point creep */\n    if(ptr==0){\n      decay=filters->nearDC_acc=filters->nearDC_partialacc+temp;\n      filters->nearDC_partialacc=temp;\n    }else{\n      decay=filters->nearDC_acc+=temp;\n      filters->nearDC_partialacc+=temp;\n    }\n    filters->nearDC_acc-=filters->nearDC[ptr];\n    filters->nearDC[ptr]=temp;\n\n    decay*=(1./(VE_NEARDC+1));\n    filters->nearptr++;\n    if(filters->nearptr>=VE_NEARDC)filters->nearptr=0;\n    decay=todB(&decay)*.5-15.f;\n  }\n  \n  /* perform spreading and limiting, also smooth the spectrum.  yes,\n     the MDCT results in all real coefficients, but it still *behaves*\n     like real/imaginary pairs */\n  for(i=0;i<n/2;i+=2){\n    float val=vec[i]*vec[i]+vec[i+1]*vec[i+1];\n    val=todB(&val)*.5f;\n    if(val<decay)val=decay;\n    if(val<minV)val=minV;\n    vec[i>>1]=val;\n    decay-=8.;\n  }\n\n  /*_analysis_output_always(\"spread\",seq2++,vec,n/4,0,0,0);*/\n  \n  /* perform preecho/postecho triggering by band */\n  for(j=0;j<VE_BANDS;j++){\n    float acc=0.;\n    float valmax,valmin;\n\n    /* accumulate amplitude */\n    for(i=0;i<bands[j].end;i++)\n      acc+=vec[i+bands[j].begin]*bands[j].window[i];\n   \n    acc*=bands[j].total;\n\n    /* convert amplitude to delta */\n    {\n      int p,this=filters[j].ampptr;\n      float postmax,postmin,premax=-99999.f,premin=99999.f;\n      \n      p=this;\n      p--;\n      if(p<0)p+=VE_AMP;\n      postmax=max(acc,filters[j].ampbuf[p]);\n      postmin=min(acc,filters[j].ampbuf[p]);\n      \n      for(i=0;i<stretch;i++){\n\tp--;\n\tif(p<0)p+=VE_AMP;\n\tpremax=max(premax,filters[j].ampbuf[p]);\n\tpremin=min(premin,filters[j].ampbuf[p]);\n      }\n      \n      valmin=postmin-premin;\n      valmax=postmax-premax;\n\n      /*filters[j].markers[pos]=valmax;*/\n      filters[j].ampbuf[this]=acc;\n      filters[j].ampptr++;\n      if(filters[j].ampptr>=VE_AMP)filters[j].ampptr=0;\n    }\n\n    /* look at min/max, decide trigger */\n    if(valmax>gi->preecho_thresh[j]+penalty){\n      ret|=1;\n      ret|=4;\n    }\n    if(valmin<gi->postecho_thresh[j]-penalty)ret|=2;\n  }\n \n  return(ret);\n}", "path": "addons\\liboggvorbis\\liboggvorbis\\libvorbis\\lib\\envelope.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Auto-init stuff: comment out here if you don't like this stuff\n   to be running in your build, and also below in arch_main() */\n", "func_signal": "int arch_auto_init()", "code": "{\n\n\tfs_init();\t\t\t/* VFS */\n//\tfs_ramdisk_init();\t\t/* Ramdisk */\n\tfs_romdisk_init();\t\t/* Romdisk */\n\n\tif (__kos_romdisk != NULL) {\n\t\tfs_romdisk_mount(\"/rd\", __kos_romdisk, 0);\n\t}\n\t\n\treturn 0;\n}", "path": "kernel\\arch\\gba\\kernel\\main.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Your program's main entry point */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tuint8 * b;\n\tint i;\n\t\n\t/* The requisite line */\n\tprintf(\"\\nHello world!\\n\\n\");\n\n\t/* Exercise the malloc/free calls a bit */\n\tprintf(\"Allocating some ram:\\n\");\n\tb = malloc(64*1024);\n\tprintf(\"Allocated 64k at %p\\n\", b);\n\n\tfor (i=0; i<64*1024; i++)\n\t\tb[i] = i & 255;\n\n\tfor (i=0; i<64*1024; i++)\n\t\tif (b[i] != (i & 255))\n\t\t\tprintf(\"mismatch at %d\\n\", i);\n\n\tprintf(\"Memory block checked ok, freeing\\n\");\n\tfree(b);\n\n\t/* Manually cause an interrupt to test IRQs */\n\tprintf(\"Doing syscall...\\n\");\n\tasm(\"syscall\\n nop\\n\");\n\n\t/* Print a banner so we know we succeeded */\n\tprintf(\"Done!\\n\");\n\n\treturn 0;\n}", "path": "examples\\ps2\\basic\\hello\\hello.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nudp_recv(struct udp_pcb *pcb,\n\t void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,\n\t\t       struct ip_addr *addr, u16_t port),\n\t void *recv_arg)", "code": "{\n  /* remember recv() callback and user data */\n  pcb->recv = recv;\n  pcb->recv_arg = recv_arg;\n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* This is the entry point inside the C program */\n", "func_signal": "int arch_main()", "code": "{\n\n\tif (mm_init() < 0)\n\t\treturn 0;\n\t\t\n\tarch_auto_init();\n\n\treturn main(0, NULL);\n}", "path": "kernel\\arch\\gba\\kernel\\main.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Call this before arch_init_all (or any call to dbgio_*) to use dcload's\n   console output functions. */\n", "func_signal": "void fs_dcload_init_console()", "code": "{\n    /* Setup our dbgio handler */\n    memcpy(&dbgio_dcload, &dbgio_null, sizeof(dbgio_dcload));\n    dbgio_dcload.detected = fs_dcload_detected;\n    dbgio_dcload.write_buffer = dcload_write_buffer;\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* $$$ ben : used sign for testing dcload direct handle or\n   bufferised access. */\n", "func_signal": "static void dcload_close_handler(uint32 hnd)", "code": "{\n  int oldirq = 0;\n  dcload_handler_t *dh;\n\n  if (!hnd) {\n    return;\n  }\n  dh = dcload_get_buffer_handler(hnd);\n  if (dh) {\n    hnd = dh->hdl;\n    free(dh);\n  }\n\n  if (hnd > 100) { /* hack */\n    STOPIRQ;\n    dcloadsyscall(DCLOAD_CLOSEDIR, hnd);\n    STARTIRQ;\n  } else {\n    hnd--; /* KOS uses 0 for error, not -1 */\n    STOPIRQ;\n    dcloadsyscall(DCLOAD_CLOSE, hnd);\n    STARTIRQ;\n  }\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Program entry */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\t/* Do basic setup */\n\tpvr_init_defaults();\n\n\t/* Initialize oggvorbis player thread */\n\tsndoggvorbis_init();\n\n\t/* Setup the mouse/font texture */\n\tsetup_util_texture();\n\n\t/* Setup background display */\n\tbkg_setup();\n\n\twhile (!check_start()) {\n\t\tpvr_wait_ready();\n\t\tpvr_scene_begin();\n\t\tpvr_list_begin(PVR_LIST_OP_POLY);\n\n\t\t/* Opaque list *************************************/\n\t\tbkg_render();\n\n\t\t/* End of opaque list */\n\t\tpvr_list_finish();\n\t\tpvr_list_begin(PVR_LIST_TR_POLY);\n\n\t\t/* Translucent list ********************************/\n\n\t\t/* Top Banner */\n\t\tdraw_poly_box(0.0f, 10.0f, 640.0f, 20.0f+(24.0f*2.0f)+10.0f, 90.0f, \n\t\t\t0.3f, 0.2f, 0.5f, 0.0f, 0.5f, 0.1f, 0.8f, 0.2f);\n\t\tdraw_poly_strf(5.0f, 20.0f, 100.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\"      GhettoPlay  (C)2000-2002 by Dan Potter      \");\n\t\tdraw_poly_strf(5.0f, 48.0f, 100.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\"      sndoggvorbis (C)2001 by Thorsten Titze      \");\n\n\t\t/* Song menu */\n\t\tsong_menu_render();\n\t\t\n\t\t/* File Information */\n\t\tdraw_poly_box(20.0f, 440.0f-96.0f+4, 640.0f-20.0f, 440.0f, 90.0f, \n\t\t\t0.3f, 0.2f, 0.5f, 0.0f, 0.5f, 0.1f, 0.8f, 0.2f);\n\t\t\n\t\tdraw_poly_strf(30.0f,440.0f-96.0f+6,100.0f,1.0f,1.0f,1.0f,1.0f,\"File Information:\");\n\t\tdraw_poly_strf(640.0f-180.0f-12.0f+(6*12.0f),440.0f-96.0f+6,100.0f,1.0f,1.0f,1.0f,1.0f,\"bit/s\");\n\t\tdraw_poly_strf(30.0f,440.0f-96.0f+6+24.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,\"Author:\");\n\t\tdraw_poly_strf(30.0f,440.0f-96.0f+6+48.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,\"Title:\");\n\t\tdraw_poly_strf(320.0f,440.0f-96.0f+6+24.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,\"Genre:\");\n\n\t\t/* If we're playing a file fill out the File information */\n\t\tif(sndoggvorbis_isplaying())\n\t\t{\n\t\t\tchar bitrate[6];\n\t\t\tlong bitrateval=sndoggvorbis_getbitrate();\n\t\t\tsprintf(bitrate,\"%6ld\",bitrateval);\n\t\t\tchar * artist, * title, * genre;\n\n\t\t\tartist = sndoggvorbis_getartist(); if (!artist) artist = \"[none]\";\n\t\t\ttitle = sndoggvorbis_gettitle(); if (!title) title = \"[none]\";\n\t\t\tgenre = sndoggvorbis_getgenre(); if (!genre) genre = \"[none]\";\n\t\t\n\t\t\tdraw_poly_strf(640.0f-180.0f-12.0f -12.0f, 440.0f-96.0f+6, 100.0f, 1.0f, 1.0f, 1.0f, 1.0f,bitrate);\n\t\t\tdraw_poly_strf(30.0f+(12.0f*7),440.0f-96.0f+6+24.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,artist);\n\t\t\tdraw_poly_strf(30.0f+(12.0f*6),440.0f-96.0f+6+48.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,title);\n\t\t\tdraw_poly_strf(320.0f+(12.0f*6),440.0f-96.0f+6+24.0f+10.0f,100.0f,1.0f,1.0f,1.0f,1.0f,genre);\n\t\t}\n\n\t\t/* Render the mouse if they move it.. it doesn't do anything\n\t\t   but it's cool looking ^_^ */\n\t\tmouse_render();\n\n\t\t/* End of translucent list */\n\t\tpvr_list_finish();\n\n\t\t/* Finish the frame *******************************/\n\t\tpvr_scene_finish();\n\t\t\n\t\t/* Update the VMU LCD */\n\t\tvmu_lcd_update();\n\t}\n\t\n\tsndoggvorbis_shutdown();\n\n\t/* Stop the sound */\n\tspu_disable();\n\n\treturn 0;\n}", "path": "examples\\dreamcast\\sound\\ghettoplay-vorbis\\ghettoplay.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/**\n * Send data using UDP. \n *\n * @param pcb UDP PCB used to send the data.\n * @param pbuf chain of pbuf's to be sent.\n *\n * @return lwIP error code.\n * - ERR_OK. Successful. No error occured.\n * - ERR_MEM. Out of memory.\n * - ERR_USE. The specified ipaddr and port are already bound to by\n * another UDP PCB.\n * \n * @see udp_disconnect()\n */\n", "func_signal": "err_t\nudp_send(struct udp_pcb *pcb, struct pbuf *p)", "code": "{\n  struct udp_hdr *udphdr;\n  struct netif *netif;\n  struct ip_addr *src_ip;\n  err_t err;\n  struct pbuf *q; /* q will be sent down the stack */\n\n  DEBUGF(UDP_DEBUG | DBG_TRACE | 3, (\"udp_send\\n\"));\n\n  /* if the PCB is not yet bound to a port, bind it here */\n  if (pcb->local_port == 0) {\n    DEBUGF(UDP_DEBUG | DBG_TRACE | 2, (\"udp_send: not yet bound to a port, binding now\\n\"));\n    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);\n    if (err != ERR_OK) {\n      DEBUGF(UDP_DEBUG | DBG_TRACE | 2, (\"udp_send: forced port bind failed\\n\"));\n      return err;\n    }\n  }\n\n  /* not enough space to add an UDP header to first pbuf in given p chain? */\n  if (pbuf_header(p, UDP_HLEN)) {\n    /* allocate header in new pbuf */\n    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);\n    /* new header pbuf could not be allocated? */\n    if (q == NULL) {\n      DEBUGF(UDP_DEBUG | DBG_TRACE | 2, (\"udp_send: could not allocate header\\n\"));\n      return ERR_MEM;\n    }\n    /* chain header q in front of given pbuf p */\n    pbuf_chain(q, p);\n    /* { first pbuf q points to header pbuf } */\n    DEBUGF(UDP_DEBUG, (\"udp_send: added header pbuf %p before given pbuf %p\\n\", (void *)q, (void *)p));\n  /* adding a header within p succeeded */\n  }\telse {\n    /* first pbuf q equals given pbuf */\n    q = p;\n    DEBUGF(UDP_DEBUG, (\"udp_send: added header in given pbuf %p\\n\", (void *)p));\n  }\n\n  udphdr = q->payload;\n  udphdr->src = htons(pcb->local_port);\n  udphdr->dest = htons(pcb->remote_port);\n  udphdr->chksum = 0x0000;\n\n  if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {\n    DEBUGF(UDP_DEBUG | 1, (\"udp_send: No route to 0x%lx\\n\", pcb->remote_ip.addr));\n#ifdef UDP_STATS\n    ++lwip_stats.udp.rterr;\n#endif /* UDP_STATS */\n    return ERR_RTE;\n  }\n  /* using IP_ANY_ADDR? */\n  if (ip_addr_isany(&pcb->local_ip)) {\n    /* use outgoing network interface IP address as source address */\n    src_ip = &(netif->ip_addr);\n  } else {\n    /* use UDP PCB local IP address as source address */\n    src_ip = &(pcb->local_ip);\n  }\n  \n  DEBUGF(UDP_DEBUG, (\"udp_send: sending datagram of length %lu\\n\", q->tot_len));\n  \n  /* UDP Lite protocol? */\n  if (pcb->flags & UDP_FLAGS_UDPLITE) {\n    DEBUGF(UDP_DEBUG, (\"udp_send: UDP LITE packet length %lu\\n\", q->tot_len));\n    /* set UDP message length in UDP header */\n    udphdr->len = htons(pcb->chksum_len);\n    /* calculate checksum */\n    udphdr->chksum = inet_chksum_pseudo(q, src_ip, &(pcb->remote_ip),\n\t\t\t\t\tIP_PROTO_UDP, pcb->chksum_len);\n    /* chksum zero must become 0xffff, as zero means 'no checksum' */\n    if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;\n    /* output to IP */\n    err = ip_output_if (q, src_ip, &pcb->remote_ip, UDP_TTL, IP_PROTO_UDPLITE, netif);    \n    snmp_inc_udpoutdatagrams();\n  } else {\n    DEBUGF(UDP_DEBUG, (\"udp_send: UDP packet length %lu\\n\", q->tot_len));\n    udphdr->len = htons(q->tot_len);\n    /* calculate checksum */\n    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {\n      udphdr->chksum = inet_chksum_pseudo(q, src_ip, &pcb->remote_ip, IP_PROTO_UDP, q->tot_len);\n      /* chksum zero must become 0xffff, as zero means 'no checksum' */\n      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;\n    }\n    DEBUGF(UDP_DEBUG, (\"udp_send: UDP checksum 0x%04x\\n\", udphdr->chksum));\n    snmp_inc_udpoutdatagrams();\n    DEBUGF(UDP_DEBUG, (\"udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\\n\"));\n    /* output to IP */\n    err = ip_output_if (q, src_ip, &pcb->remote_ip, UDP_TTL, IP_PROTO_UDP, netif);    \n  }\n\n  /* did we chain a header earlier? */\n  if (q != p) {\n    /* free the header */\n    pbuf_free(q);\n  }\n    \n#ifdef UDP_STATS\n  ++lwip_stats.udp.xmit;\n#endif /* UDP_STATS */\n  return err;\n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Printk replacement */\n", "func_signal": "int dcload_write_buffer(const uint8 *data, int len, int xlat)", "code": "{\n    if (lwip_dclsc && irq_inside_int()) {\n\terrno = EAGAIN;\n\treturn -1;\n    }\n    spinlock_lock(&mutex);\n    dclsc(DCLOAD_WRITE, 1, data, len);\n    spinlock_unlock(&mutex);\n\n    return len;\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/**\n * Create a UDP PCB.\n *\n * @return The UDP PCB which was created. NULL if the PCB data structure\n * could not be allocated.\n * \n * @see udp_remove()\n */\n", "func_signal": "struct udp_pcb *\nudp_new(void)", "code": "{\n  struct udp_pcb *pcb;\n  pcb = memp_malloc(MEMP_UDP_PCB);\n  /* could allocate UDP PCB? */\n  if (pcb != NULL) {\n    /* initialize PCB to all zeroes */\n    memset(pcb, 0, sizeof(struct udp_pcb));\n  }\n  return pcb;\n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Call this before arch_init_all (or any call to dbgio_*) to use dcload's\n   console output functions. */\n", "func_signal": "void fs_dcload_init_console()", "code": "{\n    /* Setup our dbgio handler */\n    memcpy(&dbgio_dcload, &dbgio_null, sizeof(dbgio_dcload));\n    dbgio_dcload.detected = fs_dcload_detected;\n    dbgio_dcload.write_buffer = dcload_write_buffer;\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* Call fs_dcload_init_console() before calling fs_dcload_init() */\n", "func_signal": "int fs_dcload_init()", "code": "{\n    \n    /* Check for dcload */\n    if (*DCLOADMAGICADDR != DCLOADMAGICVALUE)\n\treturn -1;\n\n    /* Give dcload the 64k it needs to compress data (if on serial) */\n    dcload_wrkmem = malloc(65536);\n    if (dcload_wrkmem) {\n    \tif (dclsc(DCLOAD_ASSIGNWRKMEM, dcload_wrkmem) == -1) {\n    \t    free(dcload_wrkmem);\n    \t    dcload_type = DCLOAD_TYPE_IP;\n    \t    dcload_wrkmem = NULL;\n    \t} else {\n    \t    dcload_type = DCLOAD_TYPE_SER;\n    \t}\n    }\n\n    /* Check for combination of KOS networking and dcload-ip */\n    if ((dcload_type == DCLOAD_TYPE_IP) && (__kos_init_flags & INIT_NET)) {\n\tdbglog(DBG_INFO, \"dc-load console+kosnet, will switch to internal ethernet\\n\");\n\treturn -1;\n\t/* if (old_printk) {\n\t    dbgio_set_printk(old_printk);\n\t    old_printk = 0;\n\t}\n\treturn -1; */\n    }\n\n    /* Register with VFS */\n    return nmmgr_handler_add(&vh.nmmgr);\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/**\n * Remove an UDP PCB.\n *\n * @param pcb UDP PCB to be removed. The PCB is removed from the list of\n * UDP PCB's and the data structure is freed from memory.\n * \n * @see udp_new()\n */\n", "func_signal": "void\nudp_remove(struct udp_pcb *pcb)", "code": "{\n  struct udp_pcb *pcb2;\n  /* pcb to be removed is first in list? */\n  if (udp_pcbs == pcb) {\n    /* make list start at 2nd pcb */\n    udp_pcbs = udp_pcbs->next;\n  /* pcb not 1st in list */\n  } else for(pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {\n    /* find pcb in udp_pcbs list */\n    if (pcb2->next != NULL && pcb2->next == pcb) {\n      /* remove pcb from list */\n      pcb2->next = pcb->next;\n    }\n  }\n  memp_free(MEMP_UDP_PCB, pcb);  \n}", "path": "addons\\lwip\\lwip\\src\\core\\udp.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/* used for dcload-ip + lwIP\n * assumes fs_dcload_init() was previously called\n */\n", "func_signal": "int fs_dcload_init_lwip(void *p)", "code": "{\n    /* Check for combination of KOS networking and dcload-ip */\n    if ((dcload_type == DCLOAD_TYPE_IP) && (__kos_init_flags & INIT_NET)) {\n\tlwip_dclsc = p;\n\n\tdbglog(DBG_INFO, \"dc-load console support enabled (lwIP)\\n\");\n    } else\n\treturn -1;\n\n    /* Register with VFS */\n    return nmmgr_handler_add(&vh.nmmgr);\n}", "path": "kernel\\arch\\dreamcast\\fs\\fs_dcload.c", "repo_name": "zig/kos-dcplaya", "stars": 2, "license": "None", "language": "c", "size": 3056}
{"docstring": "/*\n * Set up the char_dev structure for this device.\n */\n", "func_signal": "static void scull_setup_cdev(struct scull_dev *dev, int index)", "code": "{\n\tint err, devno = MKDEV(scull_major, scull_minor + index);\n    \n\tcdev_init(&dev->cdev, &scull_fops);\n\tdev->cdev.owner = THIS_MODULE;\n\tdev->cdev.ops = &scull_fops;\n\terr = cdev_add (&dev->cdev, devno, 1);\n\t/* Fail gracefully if need be */\n\tif (err)\n\t\tprintk(KERN_NOTICE \"Error %d adding scull%d\", err, index);\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/* use proc only if debugging */\n/*\n * The proc filesystem: function to read and entry\n */\n", "func_signal": "int scull_read_procmem(char *buf, char **start, off_t offset,\n                   int count, int *eof, void *data)", "code": "{\n\tint i, j, len = 0;\n\tint limit = count - 80; /* Don't print more than this */\n\n\tfor (i = 0; i < scull_nr_devs && len <= limit; i++) {\n\t\tstruct scull_dev *d = &scull_devices[i];\n\t\tstruct scull_qset *qs = d->data;\n\t\tif (down_interruptible(&d->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tlen += sprintf(buf+len,\"\\nDevice %i: qset %i, q %i, sz %li\\n\",\n\t\t\t\ti, d->qset, d->quantum, d->size);\n\t\tfor (; qs && len <= limit; qs = qs->next) { /* scan the list */\n\t\t\tlen += sprintf(buf + len, \"  item at %p, qset at %p\\n\",\n\t\t\t\t\tqs, qs->data);\n\t\t\tif (qs->data && !qs->next) /* dump only the last item */\n\t\t\t\tfor (j = 0; j < d->qset; j++) {\n\t\t\t\t\tif (qs->data[j])\n\t\t\t\t\t\tlen += sprintf(buf + len,\n\t\t\t\t\t\t\t\t\"    % 4i: %8p\\n\",\n\t\t\t\t\t\t\t\tj, qs->data[j]);\n\t\t\t\t}\n\t\t}\n\t\tup(&scull_devices[i].sem);\n\t}\n\t*eof = 1;\n\treturn len;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/* How much space is free? */\n", "func_signal": "static int spacefree(struct scull_pipe *dev)", "code": "{\n\tif (dev->rp == dev->wp)\n\t\treturn dev->buffersize - 1;\n\treturn ((dev->rp + dev->buffersize - dev->wp) % dev->buffersize) - 1;\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/* Wait for space for writing; caller must hold device semaphore.  On\n * error the semaphore will be released before returning. */\n", "func_signal": "static int scull_getwritespace(struct scull_pipe *dev, struct file *filp)", "code": "{\n\twhile (spacefree(dev) == 0) { /* full */\n\t\tDEFINE_WAIT(wait);\n\t\t\n\t\tup(&dev->sem);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tPDEBUG(\"\\\"%s\\\" writing: going to sleep\\n\",current->comm);\n\t\tprepare_to_wait(&dev->outq, &wait, TASK_INTERRUPTIBLE);\n\t\tif (spacefree(dev) == 0)\n\t\t\tschedule();\n\t\tfinish_wait(&dev->outq, &wait);\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS; /* signal: tell the fs layer to handle it */\n\t\tif (down_interruptible(&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\treturn 0;\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * This is called by cleanup_module or on failure.\n * It is required to never fail, even if nothing was initialized first\n */\n", "func_signal": "void scull_access_cleanup(void)", "code": "{\n\tstruct scull_listitem *lptr, *next;\n\tint i;\n\n\t/* Clean up the static devs */\n\tfor (i = 0; i < SCULL_N_ADEVS; i++) {\n\t\tstruct scull_dev *dev = scull_access_devs[i].sculldev;\n\t\tcdev_del(&dev->cdev);\n\t\tscull_trim(scull_access_devs[i].sculldev);\n\t}\n\n    \t/* And all the cloned devices */\n\tlist_for_each_entry_safe(lptr, next, &scull_c_list, list) {\n\t\tlist_del(&lptr->list);\n\t\tscull_trim(&(lptr->device));\n\t\tkfree(lptr);\n\t}\n\n\t/* Free up our number space */\n\tunregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);\n\treturn;\n}", "path": "src\\access.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Data management: read and write\n */\n", "func_signal": "static ssize_t scull_p_read (struct file *filp, char __user *buf, size_t count,\n                loff_t *f_pos)", "code": "{\n\tstruct scull_pipe *dev = filp->private_data;\n\n\tif (down_interruptible(&dev->sem))\n\t\treturn -ERESTARTSYS;\n\n\twhile (dev->rp == dev->wp) { /* nothing to read */\n\t\tup(&dev->sem); /* release the lock */\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tPDEBUG(\"\\\"%s\\\" reading: going to sleep\\n\", current->comm);\n\t\tif (wait_event_interruptible(dev->inq, (dev->rp != dev->wp)))\n\t\t\treturn -ERESTARTSYS; /* signal: tell the fs layer to handle it */\n\t\t/* otherwise loop, but first reacquire the lock */\n\t\tif (down_interruptible(&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\t/* ok, data is there, return something */\n\tif (dev->wp > dev->rp)\n\t\tcount = min(count, (size_t)(dev->wp - dev->rp));\n\telse /* the write pointer has wrapped, return data up to dev->end */\n\t\tcount = min(count, (size_t)(dev->end - dev->rp));\n\tif (copy_to_user(buf, dev->rp, count)) {\n\t\tup (&dev->sem);\n\t\treturn -EFAULT;\n\t}\n\tdev->rp += count;\n\tif (dev->rp == dev->end)\n\t\tdev->rp = dev->buffer; /* wrapped */\n\tup (&dev->sem);\n\n\t/* finally, awake any writers and return */\n\twake_up_interruptible(&dev->outq);\n\tPDEBUG(\"\\\"%s\\\" did read %li bytes\\n\",current->comm, (long)count);\n\treturn count;\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Here are our sequence iteration methods.  Our \"position\" is\n * simply the device number.\n */\n", "func_signal": "static void *scull_seq_start(struct seq_file *s, loff_t *pos)", "code": "{\n\tif (*pos >= scull_nr_devs)\n\t\treturn NULL;   /* No more to read */\n\treturn scull_devices + *pos;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * The ioctl() implementation\n */\n", "func_signal": "int scull_ioctl(struct inode *inode, struct file *filp,\n                 unsigned int cmd, unsigned long arg)", "code": "{\n\n\tint err = 0, tmp;\n\tint retval = 0;\n    \n\t/*\n\t * extract the type and number bitfields, and don't decode\n\t * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()\n\t */\n\tif (_IOC_TYPE(cmd) != SCULL_IOC_MAGIC) return -ENOTTY;\n\tif (_IOC_NR(cmd) > SCULL_IOC_MAXNR) return -ENOTTY;\n\n\t/*\n\t * the direction is a bitmask, and VERIFY_WRITE catches R/W\n\t * transfers. `Type' is user-oriented, while\n\t * access_ok is kernel-oriented, so the concept of \"read\" and\n\t * \"write\" is reversed\n\t */\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\terr = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\terr =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));\n\tif (err) return -EFAULT;\n\n\tswitch(cmd) {\n\n\t  case SCULL_IOCRESET:\n\t\tscull_quantum = SCULL_QUANTUM;\n\t\tscull_qset = SCULL_QSET;\n\t\tbreak;\n        \n\t  case SCULL_IOCSQUANTUM: /* Set: arg points to the value */\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tretval = __get_user(scull_quantum, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCTQUANTUM: /* Tell: arg is the value */\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tscull_quantum = arg;\n\t\tbreak;\n\n\t  case SCULL_IOCGQUANTUM: /* Get: arg is pointer to result */\n\t\tretval = __put_user(scull_quantum, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCQQUANTUM: /* Query: return it (it's positive) */\n\t\treturn scull_quantum;\n\n\t  case SCULL_IOCXQUANTUM: /* eXchange: use arg as pointer */\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttmp = scull_quantum;\n\t\tretval = __get_user(scull_quantum, (int __user *)arg);\n\t\tif (retval == 0)\n\t\t\tretval = __put_user(tmp, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCHQUANTUM: /* sHift: like Tell + Query */\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttmp = scull_quantum;\n\t\tscull_quantum = arg;\n\t\treturn tmp;\n        \n\t  case SCULL_IOCSQSET:\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tretval = __get_user(scull_qset, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCTQSET:\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tscull_qset = arg;\n\t\tbreak;\n\n\t  case SCULL_IOCGQSET:\n\t\tretval = __put_user(scull_qset, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCQQSET:\n\t\treturn scull_qset;\n\n\t  case SCULL_IOCXQSET:\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttmp = scull_qset;\n\t\tretval = __get_user(scull_qset, (int __user *)arg);\n\t\tif (retval == 0)\n\t\t\tretval = put_user(tmp, (int __user *)arg);\n\t\tbreak;\n\n\t  case SCULL_IOCHQSET:\n\t\tif (! capable (CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttmp = scull_qset;\n\t\tscull_qset = arg;\n\t\treturn tmp;\n\n        /*\n         * The following two change the buffer size for scullpipe.\n         * The scullpipe device uses this same ioctl method, just to\n         * write less code. Actually, it's the same driver, isn't it?\n         */\n\n\t  case SCULL_P_IOCTSIZE:\n\t\tscull_p_buffer = arg;\n\t\tbreak;\n\n\t  case SCULL_P_IOCQSIZE:\n\t\treturn scull_p_buffer;\n\n\n\t  default:  /* redundant, as cmd was checked against MAXNR */\n\t\treturn -ENOTTY;\n\t}\n\treturn retval;\n\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Data management: read and write\n */\n", "func_signal": "ssize_t scull_read(struct file *filp, char __user *buf, size_t count,\n                loff_t *f_pos)", "code": "{\n\tstruct scull_dev *dev = filp->private_data; \n\tstruct scull_qset *dptr;\t/* the first listitem */\n\tint quantum = dev->quantum, qset = dev->qset;\n\tint itemsize = quantum * qset; /* how many bytes in the listitem */\n\tint item, s_pos, q_pos, rest;\n\tssize_t retval = 0;\n\n\tif (down_interruptible(&dev->sem))\n\t\treturn -ERESTARTSYS;\n\tif (*f_pos >= dev->size)\n\t\tgoto out;\n\tif (*f_pos + count > dev->size)\n\t\tcount = dev->size - *f_pos;\n\n\t/* find listitem, qset index, and offset in the quantum */\n\titem = (long)*f_pos / itemsize;\n\trest = (long)*f_pos % itemsize;\n\ts_pos = rest / quantum; q_pos = rest % quantum;\n\n\t/* follow the list up to the right position (defined elsewhere) */\n\tdptr = scull_follow(dev, item);\n\n\tif (dptr == NULL || !dptr->data || ! dptr->data[s_pos])\n\t\tgoto out; /* don't fill holes */\n\n\t/* read only up to the end of this quantum */\n\tif (count > quantum - q_pos)\n\t\tcount = quantum - q_pos;\n\n\tif (copy_to_user(buf, dptr->data[s_pos] + q_pos, count)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\t*f_pos += count;\n\tretval = count;\n\n  out:\n\tup(&dev->sem);\n\treturn retval;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * This is called by cleanup_module or on failure.\n * It is required to never fail, even if nothing was initialized first\n */\n", "func_signal": "void scull_p_cleanup(void)", "code": "{\n\tint i;\n\n#ifdef SCULL_DEBUG\n\tremove_proc_entry(\"scullpipe\", NULL);\n#endif\n\n\tif (!scull_p_devices)\n\t\treturn; /* nothing else to release */\n\n\tfor (i = 0; i < scull_p_nr_devs; i++) {\n\t\tcdev_del(&scull_p_devices[i].cdev);\n\t\tkfree(scull_p_devices[i].buffer);\n\t}\n\tkfree(scull_p_devices);\n\tunregister_chrdev_region(scull_p_devno, scull_p_nr_devs);\n\tscull_p_devices = NULL; /* pedantic */\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * The \"extended\" operations -- only seek\n */\n", "func_signal": "loff_t scull_llseek(struct file *filp, loff_t off, int whence)", "code": "{\n\tstruct scull_dev *dev = filp->private_data;\n\tloff_t newpos;\n\n\tswitch(whence) {\n\t  case 0: /* SEEK_SET */\n\t\tnewpos = off;\n\t\tbreak;\n\n\t  case 1: /* SEEK_CUR */\n\t\tnewpos = filp->f_pos + off;\n\t\tbreak;\n\n\t  case 2: /* SEEK_END */\n\t\tnewpos = dev->size + off;\n\t\tbreak;\n\n\t  default: /* can't happen */\n\t\treturn -EINVAL;\n\t}\n\tif (newpos < 0) return -EINVAL;\n\tfilp->f_pos = newpos;\n\treturn newpos;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Open and close\n */\n", "func_signal": "static int scull_p_open(struct inode *inode, struct file *filp)", "code": "{\n\tstruct scull_pipe *dev;\n\n\tdev = container_of(inode->i_cdev, struct scull_pipe, cdev);\n\tfilp->private_data = dev;\n\n\tif (down_interruptible(&dev->sem))\n\t\treturn -ERESTARTSYS;\n\tif (!dev->buffer) {\n\t\t/* allocate the buffer */\n\t\tdev->buffer = kmalloc(scull_p_buffer, GFP_KERNEL);\n\t\tif (!dev->buffer) {\n\t\t\tup(&dev->sem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tdev->buffersize = scull_p_buffer;\n\tdev->end = dev->buffer + dev->buffersize;\n\tdev->rp = dev->wp = dev->buffer; /* rd and wr from the beginning */\n\n\t/* use f_mode,not  f_flags: it's cleaner (fs/open.c tells why) */\n\tif (filp->f_mode & FMODE_READ)\n\t\tdev->nreaders++;\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tdev->nwriters++;\n\tup(&dev->sem);\n\n\treturn nonseekable_open(inode, filp);\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Open and close\n */\n", "func_signal": "int scull_open(struct inode *inode, struct file *filp)", "code": "{\n\tstruct scull_dev *dev; /* device information */\n\n\tdev = container_of(inode->i_cdev, struct scull_dev, cdev);\n\tfilp->private_data = dev; /* for other methods */\n\n\t/* now trim to 0 the length of the device if open was write-only */\n\tif ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (down_interruptible(&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tscull_trim(dev); /* ignore errors */\n\t\tup(&dev->sem);\n\t}\n\treturn 0;          /* success */\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Set up a cdev entry.\n */\n", "func_signal": "static void scull_p_setup_cdev(struct scull_pipe *dev, int index)", "code": "{\n\tint err, devno = scull_p_devno + index;\n    \n\tcdev_init(&dev->cdev, &scull_pipe_fops);\n\tdev->cdev.owner = THIS_MODULE;\n\terr = cdev_add (&dev->cdev, devno, 1);\n\t/* Fail gracefully if need be */\n\tif (err)\n\t\tprintk(KERN_NOTICE \"Error %d adding scullpipe%d\", err, index);\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * The cleanup function is used to handle initialization failures as well.\n * Thefore, it must be careful to work correctly even if some of the items\n * have not been initialized\n */\n", "func_signal": "void scull_cleanup_module(void)", "code": "{\n\tint i;\n\tdev_t devno = MKDEV(scull_major, scull_minor);\n\n\t/* Get rid of our char dev entries */\n\tif (scull_devices) {\n\t\tfor (i = 0; i < scull_nr_devs; i++) {\n\t\t\tscull_trim(scull_devices + i);\n\t\t\tcdev_del(&scull_devices[i].cdev);\n\t\t}\n\t\tkfree(scull_devices);\n\t}\n\n#ifdef SCULL_DEBUG /* use proc only if debugging */\n\tscull_remove_proc();\n#endif\n\n\t/* cleanup_module is never called if registering failed */\n\tunregister_chrdev_region(devno, scull_nr_devs);\n\n\t/* and call the cleanup functions for friend devices */\n\tscull_p_cleanup();\n\tscull_access_cleanup();\n\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Follow the list\n */\n", "func_signal": "struct scull_qset *scull_follow(struct scull_dev *dev, int n)", "code": "{\n\tstruct scull_qset *qs = dev->data;\n\n        /* Allocate first qset explicitly if need be */\n\tif (! qs) {\n\t\tqs = dev->data = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);\n\t\tif (qs == NULL)\n\t\t\treturn NULL;  /* Never mind */\n\t\tmemset(qs, 0, sizeof(struct scull_qset));\n\t}\n\n\t/* Then follow the list */\n\twhile (n--) {\n\t\tif (!qs->next) {\n\t\t\tqs->next = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);\n\t\t\tif (qs->next == NULL)\n\t\t\t\treturn NULL;  /* Never mind */\n\t\t\tmemset(qs->next, 0, sizeof(struct scull_qset));\n\t\t}\n\t\tqs = qs->next;\n\t\tcontinue;\n\t}\n\treturn qs;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Set up a single device.\n */\n", "func_signal": "static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)", "code": "{\n\tstruct scull_dev *dev = devinfo->sculldev;\n\tint err;\n\n\t/* Initialize the device structure */\n\tdev->quantum = scull_quantum;\n\tdev->qset = scull_qset;\n\tinit_MUTEX(&dev->sem);\n\n\t/* Do the cdev stuff. */\n\tcdev_init(&dev->cdev, devinfo->fops);\n\tkobject_set_name(&dev->cdev.kobj, devinfo->name);\n\tdev->cdev.owner = THIS_MODULE;\n\terr = cdev_add (&dev->cdev, devno, 1);\n        /* Fail gracefully if need be */\n\tif (err) {\n\t\tprintk(KERN_NOTICE \"Error %d adding %s\\n\", err, devinfo->name);\n\t\tkobject_put(&dev->cdev.kobj);\n\t} else\n\t\tprintk(KERN_NOTICE \"%s registered at %x\\n\", devinfo->name, devno);\n}", "path": "src\\access.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Initialize the pipe devs; return how many we did.\n */\n", "func_signal": "int scull_p_init(dev_t firstdev)", "code": "{\n\tint i, result;\n\n\tresult = register_chrdev_region(firstdev, scull_p_nr_devs, \"scullp\");\n\tif (result < 0) {\n\t\tprintk(KERN_NOTICE \"Unable to get scullp region, error %d\\n\", result);\n\t\treturn 0;\n\t}\n\tscull_p_devno = firstdev;\n\tscull_p_devices = kmalloc(scull_p_nr_devs * sizeof(struct scull_pipe), GFP_KERNEL);\n\tif (scull_p_devices == NULL) {\n\t\tunregister_chrdev_region(firstdev, scull_p_nr_devs);\n\t\treturn 0;\n\t}\n\tmemset(scull_p_devices, 0, scull_p_nr_devs * sizeof(struct scull_pipe));\n\tfor (i = 0; i < scull_p_nr_devs; i++) {\n\t\tinit_waitqueue_head(&(scull_p_devices[i].inq));\n\t\tinit_waitqueue_head(&(scull_p_devices[i].outq));\n\t\tinit_MUTEX(&scull_p_devices[i].sem);\n\t\tscull_p_setup_cdev(scull_p_devices + i, i);\n\t}\n#ifdef SCULL_DEBUG\n\tcreate_proc_read_entry(\"scullpipe\", 0, NULL, scull_read_p_mem, NULL);\n#endif\n\treturn scull_p_nr_devs;\n}", "path": "src\\pipe.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Empty out the scull device; must be called with the device\n * semaphore held.\n */\n", "func_signal": "int scull_trim(struct scull_dev *dev)", "code": "{\n\tstruct scull_qset *next, *dptr;\n\tint qset = dev->qset;   /* \"dev\" is not-null */\n\tint i;\n\n\tfor (dptr = dev->data; dptr; dptr = next) { /* all the list items */\n\t\tif (dptr->data) {\n\t\t\tfor (i = 0; i < qset; i++)\n\t\t\t\tkfree(dptr->data[i]);\n\t\t\tkfree(dptr->data);\n\t\t\tdptr->data = NULL;\n\t\t}\n\t\tnext = dptr->next;\n\t\tkfree(dptr);\n\t}\n\tdev->size = 0;\n\tdev->quantum = scull_quantum;\n\tdev->qset = scull_qset;\n\tdev->data = NULL;\n\treturn 0;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * Actually create (and remove) the /proc file(s).\n */\n", "func_signal": "static void scull_create_proc(void)", "code": "{\n\tstruct proc_dir_entry *entry;\n\tcreate_proc_read_entry(\"scullmem\", 0 /* default mode */,\n\t\t\tNULL /* parent dir */, scull_read_procmem,\n\t\t\tNULL /* client data */);\n\tentry = create_proc_entry(\"scullseq\", 0, NULL);\n\tif (entry)\n\t\tentry->proc_fops = &scull_proc_ops;\n}", "path": "src\\main.c", "repo_name": "synfin/scull", "stars": 3, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * call-seq:\n *    conn.get_result() -> PGresult\n *\n * Blocks waiting for the next result from a call to\n * +PGconn#send_query+ (or another asynchronous command), and returns\n * it. Returns +nil+ if no more results are available.\n *\n * Note: call this function repeatedly until it returns +nil+, or else\n * you will not be able to issue further commands.\n */\n", "func_signal": "static VALUE\npgconn_get_result(VALUE self)", "code": "{\n\tPGconn *conn = get_pgconn(self);\n\tPGresult *result;\n\tVALUE rb_pgresult;\n\n\tresult = PQgetResult(conn);\n\tif(result == NULL)\n\t\treturn Qnil;\n\trb_pgresult = new_pgresult(result);\n\tif (rb_block_given_p()) {\n\t\treturn rb_ensure(yield_pgresult, rb_pgresult,\n\t\t\tpgresult_clear, rb_pgresult);\n\t}\n\treturn rb_pgresult;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    PGconn.connect_start(connection_hash) -> PGconn\n *    PGconn.connect_start(connection_string) -> PGconn\n *    PGconn.connect_start(host, port, options, tty, dbname, login, password) ->  PGconn\n *\n * This is an asynchronous version of PGconn.connect().\n *\n * Use PGconn#connect_poll to poll the status of the connection.\n */\n", "func_signal": "static VALUE\npgconn_s_connect_start(int argc, VALUE *argv, VALUE self)", "code": "{\n\tPGconn *conn = NULL;\n\tVALUE rb_conn;\n\tVALUE conninfo;\n\tVALUE error;\n\n\t/*\n\t * PGconn.connect_start must act as both alloc() and initialize()\n\t * because it is not invoked by calling new().\n\t */\n\trb_conn = pgconn_alloc(rb_cPGconn);\n\n\tconninfo = parse_connect_args(argc, argv, self);\n\tconn = PQconnectdb(StringValuePtr(conninfo));\n\n\tif(conn == NULL)\n\t\trb_raise(rb_ePGError, \"PQconnectStart() unable to allocate structure\");\n\tif (PQstatus(conn) == CONNECTION_BAD) {\n\t\terror = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));\n\t\trb_iv_set(error, \"@connection\", self);\n\t\trb_exc_raise(error);\n\t}\n\n\tCheck_Type(rb_conn, T_DATA);\n\tDATA_PTR(rb_conn) = conn;\n\n\tif (rb_block_given_p()) {\n\t\treturn rb_ensure(rb_yield, self, pgconn_finish, self);\n\t}\n\treturn rb_conn;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.get_last_result( ) -> PGresult\n *\n * This function retrieves all available results\n * on the current connection (from previously issued\n * asynchronous commands like +send_query()+) and\n * returns the last non-NULL result, or +nil+ if no\n * results are available.\n *\n * This function is similar to +PGconn#get_result+\n * except that it is designed to get one and only\n * one result.\n */\n", "func_signal": "static VALUE\npgconn_get_last_result(VALUE self)", "code": "{\n\tVALUE ret, result;\n\tret = Qnil;\n\twhile((result = pgconn_get_result(self)) != Qnil) {\n\t\tret = result;\n\t}\n\tpgresult_check(self, ret);\n\treturn ret;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.lo_creat( [mode] ) -> Fixnum\n *\n * Creates a large object with mode _mode_. Returns a large object Oid.\n * On failure, it raises PGError exception.\n */\n", "func_signal": "static VALUE\npgconn_locreat(int argc, VALUE *argv, VALUE self)", "code": "{\n\tOid lo_oid;\n\tint mode;\n\tVALUE nmode;\n\tPGconn *conn = get_pgconn(self);\n\n\tif (rb_scan_args(argc, argv, \"01\", &nmode) == 0)\n\t\tmode = INV_READ;\n\telse\n\t\tmode = NUM2INT(nmode);\n\n\tlo_oid = lo_creat(conn, mode);\n\tif (lo_oid == 0)\n\t\trb_raise(rb_ePGError, \"lo_creat failed\");\n\n\treturn INT2FIX(lo_oid);\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res.fname( index ) -> String\n *\n * Returns the name of the column corresponding to _index_.\n */\n", "func_signal": "static VALUE\npgresult_fname(VALUE self, VALUE index)", "code": "{\n\tPGresult *result;\n\tint i = NUM2INT(index);\n\n\tresult = get_pgresult(self);\n\tif (i < 0 || i >= PQnfields(result)) {\n\t\trb_raise(rb_eArgError,\"invalid field number %d\", i);\n\t}\n\treturn rb_tainted_str_new2(PQfname(result, i));\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res[ n ] -> Hash\n *\n * Returns tuple _n_ as a hash. \n */\n", "func_signal": "static VALUE\npgresult_aref(VALUE self, VALUE index)", "code": "{\n\tPGresult *result = get_pgresult(self);\n\tint tuple_num = NUM2INT(index);\n\tint field_num;\n\tVALUE fname,val;\n\tVALUE tuple;\n\n\tif(tuple_num >= PQntuples(result))\n\t\trb_raise(rb_eIndexError, \"Index %d is out of range\", tuple_num);\n\ttuple = rb_hash_new();\n\tfor(field_num = 0; field_num < PQnfields(result); field_num++) {\n\t\tfname = rb_tainted_str_new2(PQfname(result,field_num));\n\t\tif(PQgetisnull(result, tuple_num, field_num)) {\n\t\t\trb_hash_aset(tuple, fname, Qnil);\n\t\t}\n\t\telse {\n\t\t\tval = rb_tainted_str_new(PQgetvalue(result, tuple_num, field_num),\n\t\t\t\tPQgetlength(result, tuple_num, field_num));\n\t\t\trb_hash_aset(tuple, fname, val);\n\t\t}\n\t}\n\treturn tuple;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.user()\n *\n * Returns the authenticated user name.\n */\n", "func_signal": "static VALUE\npgconn_user(VALUE self)", "code": "{\n\tchar *user = PQuser(get_pgconn(self));\n\tif (!user) return Qnil;\n\treturn rb_tainted_str_new2(user);\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.reset_start() -> nil\n *\n * Initiate a connection reset in a nonblocking manner.\n * This will close the current connection and attempt to\n * reconnect using the same connection parameters.\n * Use PGconn#reset_poll to check the status of the \n * connection reset.\n */\n", "func_signal": "static VALUE\npgconn_reset_start(VALUE self)", "code": "{\n\tif(PQresetStart(get_pgconn(self)) == 0)\n\t\trb_raise(rb_ePGError, \"reset has failed\");\n\treturn Qnil;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n *\t\tPQescapeBytea\t- converts from binary string to the\n *\t\tminimal encoding necessary to include the string in an SQL\n *\t\tINSERT statement with a bytea type column as the target.\n *\n *\t\tThe following transformations are applied\n *\t\t'\\0' == ASCII  0 == \\\\000\n *\t\t'\\'' == ASCII 39 == \\'\n *\t\t'\\\\' == ASCII 92 == \\\\\\\\\n *\t\tanything < 0x20, or > 0x7e ---> \\\\ooo\n *\t\t\t\t\t\t\t\t\t\t(where ooo is an octal expression)\n */\n", "func_signal": "unsigned char *\nPQescapeBytea(const unsigned char *bintext, size_t binlen, size_t *bytealen)", "code": "{\n\tconst unsigned char *vp;\n\tunsigned char *rp;\n\tunsigned char *result;\n\tsize_t\t\ti;\n\tsize_t\t\tlen;\n\n\t/*\n\t * empty string has 1 char ('\\0')\n\t */\n\tlen = 1;\n\n\tvp = bintext;\n\tfor (i = binlen; i > 0; i--, vp++)\n\t{\n\t\tif (*vp < 0x20 || *vp > 0x7e)\n\t\t\tlen += 5;\t\t\t/* '5' is for '\\\\ooo' */\n\t\telse if (*vp == '\\'')\n\t\t\tlen += 2;\n\t\telse if (*vp == '\\\\')\n\t\t\tlen += 4;\n\t\telse\n\t\t\tlen++;\n\t}\n\n\trp = result = (unsigned char *) malloc(len);\n\tif (rp == NULL)\n\t\treturn NULL;\n\n\tvp = bintext;\n\t*bytealen = len;\n\n\tfor (i = binlen; i > 0; i--, vp++)\n\t{\n\t\tif (*vp < 0x20 || *vp > 0x7e)\n\t\t{\n\t\t\t(void) sprintf(rp, \"\\\\\\\\%03o\", *vp);\n\t\t\trp += 5;\n\t\t}\n\t\telse if (*vp == '\\'')\n\t\t{\n\t\t\trp[0] = '\\\\';\n\t\t\trp[1] = '\\'';\n\t\t\trp += 2;\n\t\t}\n\t\telse if (*vp == '\\\\')\n\t\t{\n\t\t\trp[0] = '\\\\';\n\t\t\trp[1] = '\\\\';\n\t\t\trp[2] = '\\\\';\n\t\t\trp[3] = '\\\\';\n\t\t\trp += 4;\n\t\t}\n\t\telse\n\t\t\t*rp++ = *vp;\n\t}\n\t*rp = '\\0';\n\n\treturn result;\n}", "path": "ext\\compat.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.notifies()\n *\n * Returns an array of the unprocessed notifiers.\n * If there is no unprocessed notifier, it returns +nil+.\n */\n", "func_signal": "static VALUE\npgconn_notifies(VALUE self)", "code": "{\n\tPGconn* conn = get_pgconn(self);\n\tPGnotify *notify;\n\tVALUE hash;\n\tVALUE sym_relname, sym_be_pid, sym_extra;\n\tVALUE relname, be_pid, extra;\n\n\tsym_relname = ID2SYM(rb_intern(\"relname\"));\n\tsym_be_pid = ID2SYM(rb_intern(\"be_pid\"));\n\tsym_extra = ID2SYM(rb_intern(\"extra\"));\n\n\tnotify = PQnotifies(conn);\n\tif (notify == NULL) {\n\t\treturn Qnil;\n\t}\n\t\n\thash = rb_hash_new();\n\trelname = rb_tainted_str_new2(notify->relname);\n\tbe_pid = INT2NUM(notify->be_pid);\n\textra = rb_tainted_str_new2(PGNOTIFY_EXTRA(notify));\n\t\n\trb_hash_aset(hash, sym_relname, relname);\n\trb_hash_aset(hash, sym_be_pid, be_pid);\n\trb_hash_aset(hash, sym_extra, extra);\n\n\tPQfreemem(notify);\n\treturn hash;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res.fsize( index )\n *\n * Returns the size of the field type in bytes.  Returns <tt>-1</tt> if the field is variable sized.\n *\n *   res = conn.exec(\"SELECT myInt, myVarChar50 FROM foo\")\n *   res.size(0) => 4\n *   res.size(1) => -1\n */\n", "func_signal": "static VALUE\npgresult_fsize(VALUE self, VALUE index)", "code": "{\n\tPGresult *result;\n\tint i = NUM2INT(index);\n\n\tresult = get_pgresult(self);\n\tif (i < 0 || i >= PQnfields(result)) {\n\t\trb_raise(rb_eArgError,\"invalid field number %d\", i);\n\t}\n\treturn INT2NUM(PQfsize(result, i));\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.parameter_status( param_name ) -> String\n *\n * Returns the setting of parameter _param_name_, where\n * _param_name_ is one of\n * * +server_version+\n * * +server_encoding+\n * * +client_encoding+ \n * * +is_superuser+\n * * +session_authorization+\n * * +DateStyle+\n * * +TimeZone+\n * * +integer_datetimes+\n * * +standard_conforming_strings+\n * \n * Returns nil if the value of the parameter is not known.\n */\n", "func_signal": "static VALUE\npgconn_parameter_status(VALUE self, VALUE param_name)", "code": "{\n\tconst char *ret = PQparameterStatus(get_pgconn(self), \n\t\t\tStringValuePtr(param_name));\n\tif(ret == NULL)\n\t\treturn Qnil;\n\telse\n\t\treturn rb_tainted_str_new2(ret);\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res.fformat( column_number ) -> Fixnum\n *\n * Returns the format (0 for text, 1 for binary) of column\n * _column_number_.\n * \n * Raises ArgumentError if _column_number_ is out of range.\n */\n", "func_signal": "static VALUE\npgresult_fformat(VALUE self, VALUE column_number)", "code": "{\n\tPGresult *result = get_pgresult(self);\n\tint fnumber = NUM2INT(column_number);\n\tif (fnumber >= PQnfields(result)) {\n\t\trb_raise(rb_eArgError, \"Column number is out of range: %d\", \n\t\t\tfnumber);\n\t}\n\treturn INT2FIX(PQfformat(result, fnumber));\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.set_client_encoding( encoding )\n * \n * Sets the client encoding to the _encoding_ String.\n */\n", "func_signal": "static VALUE\npgconn_set_client_encoding(VALUE self, VALUE str)", "code": "{\n\tCheck_Type(str, T_STRING);\n\tif ((PQsetClientEncoding(get_pgconn(self), StringValuePtr(str))) == -1){\n\t\trb_raise(rb_ePGError, \"invalid encoding name: %s\",StringValuePtr(str));\n\t}\n\treturn Qnil;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.prepare(stmt_name, sql [, param_types ] ) -> PGresult\n *\n * Prepares statement _sql_ with name _name_ to be executed later.\n * Returns a PGresult instance on success.\n * On failure, it raises a PGError exception.\n *\n * +param_types+ is an optional parameter to specify the Oids of the \n * types of the parameters.\n *\n * If the types are not specified, they will be inferred by PostgreSQL.\n * Instead of specifying type oids, it's recommended to simply add\n * explicit casts in the query to ensure that the right type is used.\n *\n * For example: \"SELECT $1::int\"\n * \n * PostgreSQL bind parameters are represented as $1, $1, $2, etc.,\n * inside the SQL query.\n */\n", "func_signal": "static VALUE\npgconn_prepare(int argc, VALUE *argv, VALUE self)", "code": "{\n\tPGconn *conn = get_pgconn(self);\n\tPGresult *result = NULL;\n\tVALUE rb_pgresult;\n\tVALUE name, command, in_paramtypes;\n\tVALUE param;\n\tint i = 0;\n\tint nParams = 0;\n\tOid *paramTypes = NULL;\n\n\trb_scan_args(argc, argv, \"21\", &name, &command, &in_paramtypes);\n\tCheck_Type(name, T_STRING);\n\tCheck_Type(command, T_STRING);\n\n\tif(! NIL_P(in_paramtypes)) {\n\t\tCheck_Type(in_paramtypes, T_ARRAY);\n\t\tnParams = RARRAY_LEN(in_paramtypes);\n\t\tparamTypes = ALLOC_N(Oid, nParams); \n\t\tfor(i = 0; i < nParams; i++) {\n\t\t\tparam = rb_ary_entry(in_paramtypes, i);\n\t\t\tCheck_Type(param, T_FIXNUM);\n\t\t\tif(param == Qnil)\n\t\t\t\tparamTypes[i] = 0;\n\t\t\telse\n\t\t\t\tparamTypes[i] = NUM2INT(param);\n\t\t}\n\t}\n\tresult = PQprepare(conn, StringValuePtr(name), StringValuePtr(command),\n\t\t\tnParams, paramTypes);\n\n\txfree(paramTypes);\n\n\trb_pgresult = new_pgresult(result);\n\tpgresult_check(self, rb_pgresult);\n\treturn rb_pgresult;\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res.getvalue( tup_num, field_num )\n *\n * Returns the value in tuple number _tup_num_, field _field_num_,\n * or +nil+ if the field is +NULL+.\n */\n", "func_signal": "static VALUE\npgresult_getvalue(VALUE self, VALUE tup_num, VALUE field_num)", "code": "{\n\tPGresult *result;\n\tint i = NUM2INT(tup_num);\n\tint j = NUM2INT(field_num);\n\n\tresult = get_pgresult(self);\n\tif(i < 0 || i >= PQntuples(result)) {\n\t\trb_raise(rb_eArgError,\"invalid tuple number %d\", i);\n\t}\n\tif(j < 0 || j >= PQnfields(result)) {\n\t\trb_raise(rb_eArgError,\"invalid field number %d\", j);\n\t}\n\tif(PQgetisnull(result, i, j))\n\t\treturn Qnil;\n\treturn rb_tainted_str_new(PQgetvalue(result, i, j), \n\t\t\t\tPQgetlength(result, i, j));\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.socket() -> Fixnum\n *\n * Returns the socket's file descriptor for this connection.\n */\n", "func_signal": "static VALUE\npgconn_socket(VALUE self)", "code": "{\n\tint sd;\n\tif( (sd = PQsocket(get_pgconn(self))) < 0)\n\t\trb_raise(rb_ePGError, \"Can't get socket descriptor\");\n\treturn INT2NUM(sd);\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    conn.host()\n *\n * Returns the connected server name.\n */\n", "func_signal": "static VALUE\npgconn_host(VALUE self)", "code": "{\n\tchar *host = PQhost(get_pgconn(self));\n\tif (!host) return Qnil;\n\treturn rb_tainted_str_new2(host);\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n *\t\tPQunescapeBytea - converts the null terminated string representation\n *\t\tof a bytea, strtext, into binary, filling a buffer. It returns a\n *\t\tpointer to the buffer (or NULL on error), and the size of the\n *\t\tbuffer in retbuflen. The pointer may subsequently be used as an\n *\t\targument to the function free(3). It is the reverse of PQescapeBytea.\n *\n *\t\tThe following transformations are made:\n *\t\t\\\\\t == ASCII 92 == \\\n *\t\t\\ooo == a byte whose value = ooo (ooo is an octal number)\n *\t\t\\x\t == x (x is any character not matched by the above transformations)\n */\n", "func_signal": "unsigned char *\nPQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)", "code": "{\n\tsize_t\t\tstrtextlen,\n\t\t\t\tbuflen;\n\tunsigned char *buffer,\n\t\t\t   *tmpbuf;\n\tsize_t\t\ti,\n\t\t\t\tj;\n\n\tif (strtext == NULL)\n\t\treturn NULL;\n\n\tstrtextlen = strlen(strtext);\n\n\t/*\n\t * Length of input is max length of output, but add one to avoid\n\t * unportable malloc(0) if input is zero-length.\n\t */\n\tbuffer = (unsigned char *) malloc(strtextlen + 1);\n\tif (buffer == NULL)\n\t\treturn NULL;\n\n\tfor (i = j = 0; i < strtextlen;)\n\t{\n\t\tswitch (strtext[i])\n\t\t{\n\t\t\tcase '\\\\':\n\t\t\t\ti++;\n\t\t\t\tif (strtext[i] == '\\\\')\n\t\t\t\t\tbuffer[j++] = strtext[i++];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((ISFIRSTOCTDIGIT(strtext[i])) &&\n\t\t\t\t\t\t(ISOCTDIGIT(strtext[i + 1])) &&\n\t\t\t\t\t\t(ISOCTDIGIT(strtext[i + 2])))\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tbyte;\n\n\t\t\t\t\t\tbyte = OCTVAL(strtext[i++]);\n\t\t\t\t\t\tbyte = (byte << 3) + OCTVAL(strtext[i++]);\n\t\t\t\t\t\tbyte = (byte << 3) + OCTVAL(strtext[i++]);\n\t\t\t\t\t\tbuffer[j++] = byte;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: if we see '\\' followed by something that isn't a\n\t\t\t\t * recognized escape sequence, we loop around having done\n\t\t\t\t * nothing except advance i.  Therefore the something will\n\t\t\t\t * be emitted as ordinary data on the next cycle. Corner\n\t\t\t\t * case: '\\' at end of string will just be discarded.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbuffer[j++] = strtext[i++];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbuflen = j;\t\t\t\t\t/* buflen is the length of the dequoted\n\t\t\t\t\t\t\t\t * data */\n\n\t/* Shrink the buffer to be no larger than necessary */\n\t/* +1 avoids unportable behavior when buflen==0 */\n\ttmpbuf = realloc(buffer, buflen + 1);\n\n\t/* It would only be a very brain-dead realloc that could fail, but... */\n\tif (!tmpbuf)\n\t{\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\n\t*retbuflen = buflen;\n\treturn tmpbuf;\n}", "path": "ext\\compat.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/*\n * call-seq:\n *    res.nparams() -> Fixnum\n *\n * Returns the number of parameters of a prepared statement.\n * Only useful for the result returned by conn.describePrepared\n */\n", "func_signal": "static VALUE\npgresult_nparams(VALUE self)", "code": "{\n\tPGresult *result;\n\n\tresult = get_pgresult(self);\n\treturn INT2FIX(PQnparams(result));\n}", "path": "ext\\pg.c", "repo_name": "miyucy/ruby-pg", "stars": 2, "license": "other", "language": "c", "size": 308}
{"docstring": "/**\n * myClear \u2014 clear buffers to preset values\n *\n * mask - Bitwise OR of masks that indicate the buffers to be cleared.\n *\tThe four masks are\n *\t\tGL_COLOR_BUFFER_BIT,\n *\t\tGL_DEPTH_BUFFER_BIT,\n *\t\tGL_ACCUM_BUFFER_BIT, and\n *\t\tGL_STENCIL_BUFFER_BIT.\n *\n * For this implementation, only GL_COLOR_BUFFER_BIT need be considered.\n */\n", "func_signal": "void myClear(GLbitfield mask)", "code": "{\n\tcolor c;\n\tswitch(mask) {\n\tcase GL_COLOR_BUFFER_BIT:\n\t\tc = getclearcolor();\n\t\tbreak;\n\t}\n\tfor(int x=0;x<screenWidth;x++)\n\t\tfor(int y=0;y<screenHeight;y++)\n\t\t\tsetPixel(x,y,c.r,c.g,c.b);\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myLoadIdentityCurrent - load the \n * identity matrix into whatever matrix\n * is currently set\n */\n", "func_signal": "void myLoadIdentityCurrent()", "code": "{\n\tassert(currentmatrix != 0);\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<4;j++)\n\t\t\t(*currentmatrix)(i,j) = (i==j) ? 1.0 : 0;\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myLoadIdentity \u2014 replace the current matrix with the identity matrix.\n *\n * For this implementation, it is assumed that the current matrix is the\n * transformation (MODELVIEW) matrix.\n */\n", "func_signal": "void myLoadIdentity( void)", "code": "{\n\tmyMatrixMode (GL_MODELVIEW);\n\tmyLoadIdentityCurrent();\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*\n * Callback for keystrokes\n */\n", "func_signal": "void key (unsigned char key, int x, int y)", "code": "{\n\tif ((key == 'C') || (key == 'c')) displayNumber = 2; // clip\n\tif ((key == 'P') || (key == 'p')) displayNumber = 1; // polygon\n\tif ((key == 'T') || (key == 't')) displayNumber = 3; // transform\n\tif ((key == 'V') || (key == 'v')) displayNumber = 0; // viewport\n\t\n\tif ((key == 'Q') || (key == 'q')) exit(0); // quit\n\n\t\n\tglutPostRedisplay();\n}", "path": "main.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myOrtho2D \u2014 define a 2D orthographic projection matrix\n *\n * left, right - Specify the coordinates for the left and right vertical clipping \n * planes.\n * \n * bottom, top - Specify the coordinates for the bottom and top horizontal clipping planes.\n *\n */\n", "func_signal": "void myOrtho2D(\tdouble left, double right, double bottom, double top)", "code": "{\n\t// create matrix to normalize coords\n\tmatrix_normalize(0,0) = 2.0/(right-left);\n\tmatrix_normalize(1,1) = 2.0/(top-bottom);\n\tmatrix_normalize(0,3) = -(right+left)/(right-left);\n\tmatrix_normalize(1,3) = -(top+bottom)/(top-bottom);\n\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * clip vertices in inv against edge clip\n */\n", "func_signal": "vector<Matrix> clipAgainst (vector<Matrix> inv,enum clip_plane clip)", "code": "{\n\tvector<Matrix> outv;\n\n\tint in = inv.size();\n\tif(in<=0) return outv;\n\tPoint S(inv.at(inv.size()-1));\n\n\tfor(int i=0;i<in;i++) {\n\t\tPoint P(inv[i]);\n\t\tif(P.inside(clip)) { // right edge\n\t\t\tif(!(S.inside(clip))) { \n\t\t\t\t// compute intersection S, P\n\t\t\t\tPoint Q = S.moveIn(P,clip);\n\t\t\t\toutv.push_back(Q.matrix());\n\t\t\t}\n\t\t\t// output P\n\t\t\toutv.push_back(P.matrix());\n\t\t} else if(S.inside(clip)) {\n\t\t\t// compute intersection P, S\n\t\t\tPoint Q = P.moveIn(S,clip);\n\t\t\toutv.push_back(Q.matrix());\n\t\t}\n\t\tS = P;\n\t}\n\n\treturn outv;\n}", "path": "clipPolygon.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * clip a polygon against all 4 edges,\n * 1 at a time.\n */\n", "func_signal": "vector<Matrix> clipper(vector <Matrix> v)", "code": "{\n\tv = clipAgainst(v,RIGHT);\n\tv = clipAgainst(v,TOP);\n\tv = clipAgainst(v,BOTTOM);\n\tv = clipAgainst(v,LEFT);\n\treturn v;\n}", "path": "clipPolygon.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "// compare 2 buckets by dereferencing the pointers\n", "func_signal": "bool cmpbucketptr(Bucket *a, Bucket *b)", "code": "{\n\tassert(a!=0);\n\tassert(b!=0);\n\treturn a->x < b->x;\n}", "path": "drawPolygon.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/* This will display the original world when the displaynumber is\n* odd and an altered world when it is even.  \"gluOrtho2D\" is used\n* to determine which portion of the world is displayed. \"glViewport\"\n* is used to determine WHERE the selected portion will be displayed.\n*/\n", "func_signal": "void display( void )", "code": "{\n\t\n\t/* \n\t* Set clear color to gray \n     */\n    myClearColor ( 0.8, 0.8, 0.8, 0.0 );\n\t\n    /* \n\t* Clear screen window \n     */\n    myClear( GL_COLOR_BUFFER_BIT );\n\t\t\n\t\n\t/* \n\t * plain old polygon test\n\t */\n\tif ( (displayNumber % 4) == 1) {\n\t\t\n\t\t/* default clipping */\n\t\tmyOrtho2D( -100.0, 100.0, -100.0, 100.0 );\n\t\t\n\t\t/* default viewport */\n\t\tmyViewport( 0, 0, screenWidth, screenHeight );\n\n\t\t/* draw the polys */\n\t\tdrawPolys();\n\t}\n\telse if ( (displayNumber % 4) == 2) {\n\t\t\n\t\t/* clipping test */\n\t\tmyOrtho2D( -65.0, 75.0, -80.0, 65.0 );\n\t\t\n\t\t/* default viewport */\n\t\tmyViewport( 0, 0, screenWidth, screenHeight );\n\t\t\n\t\t/* draw the polys */\n\t\tdrawPolys();\n\t\t\n    }\n\telse if ( (displayNumber % 4) == 3) {\n\t\t\n\t\t/* default clipping */\n\t\tmyOrtho2D( -100.0, 100.0, -100.0, 100.0 );\n\t\t\n\t\t/* default viewport */\n\t\tmyViewport( 0, 0, screenWidth, screenHeight );\n\t\t\n\t\t/* draw the tranformed polys */\n\t\tdrawTPolys();\n\t}\n\t\n\telse /* displayNumber == 0 */ {\n\t\t\n\t\t/* default clipping */\n\t\tmyOrtho2D( -100.0, 100.0, -100.0, 100.0 );\n\t\t\n\t\t/* have some fun with the view port */\n\t\tint wdiff = screenWidth / 5;\n\t\tint hdiff = screenHeight / 5;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint i,j;\n\t\tfor (i=0; i < 5; i++) {\n\t\t\t\tmyViewport (x, y, wdiff, hdiff);\n\t\t\t\tdrawPolys();\n\t\t\t\ty+= hdiff;\n\t\t\t\tx+= wdiff;\n\t\t}\n\t}\n\t\n\t/* \n     * Flush GL buffers to the display   \n     */\n    glFlush( );\n\t\n}", "path": "main.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/* \n* Callback function for mouse interaction \n */\n", "func_signal": "void mouse( int button, int state, int x, int y )", "code": "{\n\t\n\t/* \n    * If state is not checked, we get two events for each mouse button\n\t * usage, one for pressing it, one for releasing it \n\t */\n\tif ( state==GLUT_UP ) {\n\t\tdisplayNumber++;\n\t\tglutPostRedisplay();\n\t}\n\t\n}", "path": "main.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myPopMatrix\n * change currentmatrix to matrix on top\n * of matrix stack\n */\n", "func_signal": "void myPopMatrix()", "code": "{\n\tassert(matrixstack.size());\n\tassert(currentmatrix != 0);\n\t*currentmatrix = matrixstack.top();\n\tmatrixstack.pop();\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myPushMatrix\n * push currentmatrix to top of matrix stack\n */\n", "func_signal": "void myPushMatrix()", "code": "{\n\tassert(currentmatrix != 0);\n\tmatrixstack.push(*currentmatrix);\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/* \n* Function that draws the entire contents of the modeled world.\n * Used in the \"display\" callback function.\n */\n", "func_signal": "void drawPolys( void )", "code": "{\n\t\n\t/* \n    * Draw a red triangle\n\t*/\n\tmyLoadIdentity();\n\tmyBegin( GL_POLYGON );\n\tmyColor3f( 1.0, 0.0, 0.0 );\n\tmyVertex2f( -75.0, 25.0 );\n\tmyVertex2f( -25.0, 25.0 );\n\tmyVertex2f( -50, 75.0 );\n\tmyEnd();\n\t\n\t/* \n\t * Draw a white square \t \n\t */\n\tmyBegin( GL_POLYGON );\n\tmyColor3f( 1.0, 1.0, 1.0 );\n\tmyVertex2f( 25.0, 25.0 );\n\tmyVertex2f( 75.0, 25.0 );\n\tmyVertex2f( 75.0, 75.0 );\n\tmyVertex2f( 25.0, 75.0 );\n\tmyEnd();\n\t\n\t/* \n\t * Draw a blue otcagon\n\t */\n\tmyBegin( GL_POLYGON );\n\tmyColor3f( 0.0, 0.0, 1.0 );\n\tmyVertex2f( -75.0, -75.0 );\n\tmyVertex2f( -65.0, -85.0 );\n\tmyVertex2f( -45.0, -85.0 );\n\tmyVertex2f( -25.0, -75.0 );\n\tmyVertex2f( -25.0, -45.0 );\n\tmyVertex2f( -45.0, -25.0 );\n\tmyVertex2f( -65.0, -25.0 );\n\tmyVertex2f( -75.0, -45.0 );\n\tmyEnd();\n\t\n\t/* \n\t\t* Draw a green star\n\t * .1, .1 \n\t */\n\tmyBegin( GL_POLYGON );\n\tmyColor3f( 0.0, 1.0, 0.0 );\n\tmyVertex2f( 50.0, -10.0 );\n\tmyVertex2f( 40.0, -35.0 );\n\tmyVertex2f( 10.0, -35.0 );\n\tmyVertex2f( 40.0, -60.0 );\n\tmyVertex2f( 10.0, -90.0 );\n\tmyVertex2f( 50.0, -75.0 );\n\tmyVertex2f( 90.0, -90.0 );\n\tmyVertex2f( 60.0, -60.0 );\n\tmyVertex2f( 90.0, -35.0 );\n\tmyVertex2f( 60.0, -35.0 );\n\tmyEnd();\n\t\n}", "path": "main.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "// draw a polygon!\n", "func_signal": "void drawPolygon(vector<Matrix> vertex)", "code": "{\n\tint n = vertex.size();\n\tBucket *edgetable[SCR_HEIGHT];\n\tfor(int i=0;i<SCR_HEIGHT;i++) \n\t\tedgetable[i] = 0; \n\t// fill ET\n\tint y0,y1,x0,x1;\n\tfor(int i=0;i<n;i++) {\n\t\ty0 = vertex[i](1,0);\n\t\ty1 = vertex[(i+1)%n](1,0);\n\t\tx0 = vertex[i](0,0);\n\t\tx1 = vertex[(i+1)%n](0,0);\n\t\tif(y1 < y0) { // swap points\n\t\t\tint swap;\t\n\t\t\tswap = y0; y0 = y1; y1 = swap;\t\n\t\t\tswap = x0; x0 = x1; x1 = swap;\t\n\t\t}\n\t\t\n\t\t// toss out horizontal edges\n\t\tif(y1==y0) continue;\n\t\t\n\t\t// make a bucket for current edge\n\t\tBucket *edge = new Bucket(\n\t\t\ty1,x0,(float)(x1-x0)/(float)(y1-y0));\n\t\tif(y0 < 0 || y0 >= screenHeight) {\n\t\t\t// now that this code is working,\n\t\t\t// we should never get here.\n\t\t\tcerr << \"oops, y0=\" << y0 << \"!\" << endl;\n\t\t\tcontinue; \n\t\t}\n\t\tif(edgetable[y0] == 0) {\n\t\t\t// first edge bucket for this y\n\t\t\tedgetable[y0] = edge;\n\t\t} else {\n\t\t\t// current bucket is first in table\n\t\t\tBucket *curbucket = edgetable[y0];\n\t\t\t// that if statement passed so this should...\n\t\t\tassert(curbucket!=0 && edge!=0);\n\t\t\tif(curbucket->x > edge->x) {\n\t\t\t\t// add this bucket first\n\t\t\t\tedgetable[y0] = edge;\n\t\t\t\tedge->next = curbucket;\t\n\t\t\t} else {\n\t\t\t\t// add the bucket where it \n\t\t\t\t// should be so that the edge table entries\n\t\t\t\t// remain sorted by x\n\t\t\t\tBucket *prevbucket;\n\t\t\t\tdo {\n\t\t\t\tprevbucket = curbucket;\n\t\t\t\tcurbucket = curbucket->next;\n\t\t\t\tif(curbucket==0 || curbucket->x > edge->x) {\n\t\t\t\t\tprevbucket->next = edge;\n\t\t\t\t\tedge->next = curbucket;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tassert(curbucket!=0);\n\t\t\t\t} while(1);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t// the amazing active edge table\n\tvector<Bucket *> aet;\n\n\tfor(int y=0;y<SCR_HEIGHT;y++) {\n\t\tfor(vector<Bucket *>::iterator iter = aet.begin();\n\t\t    iter != aet.end();iter++) {\n\t\t\tif((*iter)->ymax <= y) {\n\t\t\t\taet.erase(iter);\n\t\t\t\titer--;\n\t\t\t}\n\t\t}\n\t\twhile(edgetable[y] != 0) {\n\t\t\taet.push_back(edgetable[y]);\n\t\t\tedgetable[y] = edgetable[y]->next;\n\t\t}\n\t\tsort(aet.begin(), aet.end(), cmpbucketptr);\n\t\tvector<Bucket *>::iterator iter = aet.begin();\n\t\tbool draw = false;\n\t\tfor(int x=0;x<SCR_WIDTH;x++) {\n\t\t\twhile(iter != aet.end() && \n\t\t\t      *iter != 0 && \n\t\t\t      int((*iter)->x) == x) { \n\t\t\t\tdraw = !draw; iter++; \n\t\t\t}\n\t\t\tif(y >= 0 && y <SCR_HEIGHT)\n\t\t\t\tif(draw) setPixel(x,y);\n\t\t}\t\n\t\tfor(iter = aet.begin();iter!=aet.end();iter++) {\n\t\t\t(*iter)->x += (*iter)->xinc;\n\t\t}\n\t}\n}", "path": "drawPolygon.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myTranslatef \u2014 multiply the current matrix by a translation matrix.\n *\n * x, y - Specify the x, y, and z coordinates of a translation vector.\n * No translation in the z direction for now.\n * \n * For this implementation, it is assumed that the current matrix is the \n * transformation (MODELVIEW) matrix.\n */\n", "func_signal": "void myTranslatef(float x, float y)", "code": "{\n\tmyMatrixMode(GL_MODELVIEW);\n\tMatrix translate;\n\ttranslate(0,0) = translate(1,1) = 1.0;\n\ttranslate(2,2) = translate(3,3) = 1.0;\n\ttranslate(0,3) = x;\n\ttranslate(1,3) = y;\n\ttranslate(2,3) = 1.0;\n\t(*currentmatrix) = (*currentmatrix) * translate;\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/* \n* Main routine - GLUT setup and initialization \n */\n", "func_signal": "int main( int argc, char** argv )", "code": "{\n\t\n\t/* \n    * Initialize mode and open a window in upper \n\t * left corner of screen \n\t */\n\t\n\tglutInit( &argc, argv ); \n\tglutInitDisplayMode( GLUT_SINGLE | GLUT_RGB );\n\tglutInitWindowSize( screenWidth, screenHeight );\n\tglutInitWindowPosition( 0, 0 );\n\tglutCreateWindow( \"Draw World\" ); \n\t\n\tglutMouseFunc( mouse );\n\tglutKeyboardFunc ( key );\n\tglutDisplayFunc( display );\n\t\n\tglutMainLoop();\n\t\n\treturn 0;\n\t\n}", "path": "main.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myEnd - delimit the vertices of a primitive or a group of like primitives.  \n * Closes a myBegin() statement.\n *\n * This routine will initiate the processing and drawing of a polygon.\n */\n", "func_signal": "void myEnd()", "code": "{\n\tswitch(vertexmode) {\n\tcase GL_POLYGON:\t\n\t\t// clip normalized vertices\n\t\tvertices = clipper(vertices);\n\t\t// transform into screen coords\n\t\tvertices = matrix_viewport * vertices;\n\t\t// draw polygon\n\t\tdrawPolygon(vertices);\n\t\tbreak;\n\t}\n\treturn;\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * set current drawing color\n */\n", "func_signal": "void setcolor(float r,float g,float b)", "code": "{\n\tcurrentcolor.r=r;\n\tcurrentcolor.g=g;\n\tcurrentcolor.b=b;\n}", "path": "color.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * set current clear color\n */\n", "func_signal": "void setclearcolor(float r,float g,float b)", "code": "{\n\tclearcolor.r=r;\n\tclearcolor.g=g;\n\tclearcolor.b=b;\n}", "path": "color.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/**\n * myMatrixMode\n * switch to a new matrix mode:\n * only projection and modelview are supported\n */\n", "func_signal": "void myMatrixMode(GLenum mode)", "code": "{\n\tswitch(mode) {\n\tcase GL_PROJECTION:\n\t\tcurrentmatrix = &matrix_projection;\n\t\tbreak;\n\tcase GL_MODELVIEW:\n\t\tcurrentmatrix = &matrix_modelview;\n\t\tbreak;\n\t}\n}", "path": "myFunctions.c", "repo_name": "jamesl/cg1_pipeline2d", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Put socket into blocking mode\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "void socket_setblocking(p_socket ps)", "code": "{\n    u_long argp = 0;\n    ioctlsocket(*ps, FIONBIO, &argp);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*=========================================================================*\\\n* Lua methods\n\\*=========================================================================*/\n/*-------------------------------------------------------------------------*\\\n* Just call buffered IO methods\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_send(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkclass(L, \"unix{client}\", 1);\n    return buffer_meth_send(L, &un->buf);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Shuts the connection down partially\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_shutdown(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkclass(L, \"unix{client}\", 1);\n    const char *how = luaL_optstring(L, 2, \"both\");\n    switch (how[0]) {\n        case 'b':\n            if (strcmp(how, \"both\")) goto error;\n            socket_shutdown(&un->sock, 2);\n            break;\n        case 's':\n            if (strcmp(how, \"send\")) goto error;\n            socket_shutdown(&un->sock, 1);\n            break;\n        case 'r':\n            if (strcmp(how, \"receive\")) goto error;\n            socket_shutdown(&un->sock, 0);\n            break;\n    }\n    lua_pushnumber(L, 1);\n    return 1;\nerror:\n    luaL_argerror(L, 2, \"invalid shutdown method\");\n    return 0;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*=========================================================================*\\\n* Library functions\n\\*=========================================================================*/\n/*-------------------------------------------------------------------------*\\\n* Creates a master unix object \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int global_create(lua_State *L)", "code": "{\n    t_socket sock;\n    int err = socket_create(&sock, AF_UNIX, SOCK_STREAM, 0);\n    /* try to allocate a system socket */\n    if (err == IO_DONE) { \n        /* allocate unix object */\n        p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));\n        /* set its type as master object */\n        auxiliar_setclass(L, \"unix{master}\", -1);\n        /* initialize remaining structure fields */\n        socket_setnonblocking(&sock);\n        un->sock = sock;\n        io_init(&un->io, (p_send) socket_send, (p_recv) socket_recv, \n                (p_error) socket_ioerror, &un->sock);\n        timeout_init(&un->tm, -1, -1);\n        buffer_init(&un->buf, &un->io, &un->tm);\n        return 1;\n    } else {\n        lua_pushnil(L);\n        lua_pushstring(L, socket_strerror(err));\n        return 2;\n    }\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Receive with timeout\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_recv(p_socket ps, char *data, size_t count, size_t *got, p_timeout tm)", "code": "{\n    int err;\n    *got = 0;\n    if (*ps == SOCKET_INVALID) return IO_CLOSED;\n    for ( ;; ) {\n        int taken = recv(*ps, data, (int) count, 0);\n        if (taken > 0) {\n            *got = taken;\n            return IO_DONE;\n        }\n        if (taken == 0) return IO_CLOSED;\n        err = WSAGetLastError();\n        if (err != WSAEWOULDBLOCK) return err;\n        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;\n    }\n    return IO_UNKNOWN;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Initializes module\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int luaopen_socket_unix(lua_State *L)", "code": "{\n    /* create classes */\n    auxiliar_newclass(L, \"unix{master}\", un);\n    auxiliar_newclass(L, \"unix{client}\", un);\n    auxiliar_newclass(L, \"unix{server}\", un);\n    /* create class groups */\n    auxiliar_add2group(L, \"unix{master}\", \"unix{any}\");\n    auxiliar_add2group(L, \"unix{client}\", \"unix{any}\");\n    auxiliar_add2group(L, \"unix{server}\", \"unix{any}\");\n    /* make sure the function ends up in the package table */\n    luaL_openlib(L, \"socket\", func, 0);\n    /* return the function instead of the 'socket' table */\n    lua_pushstring(L, \"unix\");\n    lua_gettable(L, -2);\n    return 1;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Closes socket used by object \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_close(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkgroup(L, \"unix{any}\", 1);\n    socket_destroy(&un->sock);\n    lua_pushnumber(L, 1);\n    return 1;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "void socket_shutdown(p_socket ps, int how)", "code": "{\n    socket_setblocking(ps);\n    shutdown(*ps, how);\n    socket_setnonblocking(ps);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Creates and sets up a socket\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_create(p_socket ps, int domain, int type, int protocol)", "code": "{\n    *ps = socket(domain, type, protocol);\n    if (*ps != SOCKET_INVALID) return IO_DONE;\n    else return WSAGetLastError();\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Accept with timeout\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_accept(p_socket ps, p_socket pa, SA *addr, socklen_t *len, \n        p_timeout tm)", "code": "{\n    SA daddr;\n    socklen_t dlen = sizeof(daddr);\n    if (*ps == SOCKET_INVALID) return IO_CLOSED;\n    if (!addr) addr = &daddr;\n    if (!len) len = &dlen;\n    for ( ;; ) {\n        int err;\n        /* try to get client socket */\n        if ((*pa = accept(*ps, addr, len)) != SOCKET_INVALID) return IO_DONE;\n        /* find out why we failed */\n        err = WSAGetLastError(); \n        /* if we failed because there was no connectoin, keep trying */\n        if (err != WSAEWOULDBLOCK && err != WSAECONNABORTED) return err;\n        /* call select to avoid busy wait */\n        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;\n    } \n    /* can't reach here */\n    return IO_UNKNOWN; \n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Close module \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_close(void)", "code": "{\n    WSACleanup();\n    return 1;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Send with timeout\n* On windows, if you try to send 10MB, the OS will buffer EVERYTHING \n* this can take an awful lot of time and we will end up blocked. \n* Therefore, whoever calls this function should not pass a huge buffer.\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_send(p_socket ps, const char *data, size_t count, \n        size_t *sent, p_timeout tm)", "code": "{\n    int err;\n    *sent = 0;\n    /* avoid making system calls on closed sockets */\n    if (*ps == SOCKET_INVALID) return IO_CLOSED;\n    /* loop until we send something or we give up on error */\n    for ( ;; ) {\n        /* try to send something */\n\t\tint put = send(*ps, data, (int) count, 0);\n        /* if we sent something, we are done */\n        if (put > 0) {\n            *sent = put;\n            return IO_DONE;\n        }\n        /* deal with failure */\n        err = WSAGetLastError(); \n        /* we can only proceed if there was no serious error */\n        if (err != WSAEWOULDBLOCK) return err;\n        /* avoid busy wait */\n        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;\n    } \n    /* can't reach here */\n    return IO_UNKNOWN;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_listen(p_socket ps, int backlog)", "code": "{\n    int err = IO_DONE;\n    socket_setblocking(ps);\n    if (listen(*ps, backlog) < 0) err = WSAGetLastError();\n    socket_setnonblocking(ps);\n    return err;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Binds or returns error message\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_bind(p_socket ps, SA *addr, socklen_t len)", "code": "{\n    int err = IO_DONE;\n    socket_setblocking(ps);\n    if (bind(*ps, addr, len) < 0) err = WSAGetLastError();\n    socket_setnonblocking(ps);\n    return err;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Select with int timeout in ms\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_select(t_socket n, fd_set *rfds, fd_set *wfds, fd_set *efds, \n        p_timeout tm)", "code": "{\n    struct timeval tv; \n    double t = timeout_get(tm);\n    tv.tv_sec = (int) t;\n    tv.tv_usec = (int) ((t - tv.tv_sec) * 1.0e6);\n    if (n <= 0) {\n        Sleep((DWORD) (1000*t));\n        return 0;\n    } else return select(0, rfds, wfds, efds, t >= 0.0? &tv: NULL);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* DNS helpers \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_gethostbyaddr(const char *addr, socklen_t len, struct hostent **hp)", "code": "{\n    *hp = gethostbyaddr(addr, len, AF_INET);\n    if (*hp) return IO_DONE;\n    else return WSAGetLastError();\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Put socket into non-blocking mode\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "void socket_setnonblocking(p_socket ps)", "code": "{\n    u_long argp = 1;\n    ioctlsocket(*ps, FIONBIO, &argp);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Sendto with timeout\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "int socket_sendto(p_socket ps, const char *data, size_t count, size_t *sent, \n        SA *addr, socklen_t len, p_timeout tm)", "code": "{\n    int err;\n    *sent = 0;\n    if (*ps == SOCKET_INVALID) return IO_CLOSED;\n    for ( ;; ) {\n        int put = sendto(*ps, data, (int) count, 0, addr, len);\n        if (put > 0) {\n            *sent = put;\n            return IO_DONE;\n        }\n        err = WSAGetLastError(); \n        if (err != WSAEWOULDBLOCK) return err;\n        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;\n    } \n    return IO_UNKNOWN;\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Just call tm methods\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_settimeout(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkgroup(L, \"unix{any}\", 1);\n    return timeout_meth_settimeout(L, &un->tm);\n}", "path": "src\\libraries\\luasocket\\libluasocket\\unix.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Close and inutilize socket\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "void socket_destroy(p_socket ps)", "code": "{\n    if (*ps != SOCKET_INVALID) {\n        socket_setblocking(ps); /* close can take a long time on WIN32 */\n        closesocket(*ps);\n        *ps = SOCKET_INVALID;\n    }\n}", "path": "src\\libraries\\luasocket\\libluasocket\\wsocket.c", "repo_name": "JackDanger/love", "stars": 2, "license": "zlib", "language": "c", "size": 20200}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_set(struct array* a, unsigned int i, void* v)", "code": "{\n\tif (a == NULL) {\n\t\treturn EINVAL;\n\t}\n\tif (i >= a->num) {\n\t\treturn EINVAL;\n\t}\n\n\ta->a[i] = v;\n\treturn 0;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_reserve(struct array* a, unsigned int sz)", "code": "{\n\tvoid** newa;\n\tunsigned int nsz;\n\n\tif (!a) {\n\t\treturn EINVAL;\n\t}\n\n\tif (a->sz >= sz) {\n\t\treturn 0;\n\t} \n\t\n\tnsz = a->sz ? a->sz : 1;\n\n\twhile (nsz < sz) {\n\t\tnsz <<= 1;\n\t}\n\n\tnewa = realloc(a->a, nsz * sizeof(void*));\n\n\tif (!newa) {\n\t\treturn ENOMEM;\n\t}\n\n\ta->a = newa;\n\ta->sz = nsz;\n\n\treturn 0;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_append(struct array* a, void* v)", "code": "{\n\tif (a == NULL) {\n\t\treturn EINVAL;\n\t}\n\n\treturn array_insert(a, v, a->num);\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_insert(struct array* a, void* v, unsigned int i)", "code": "{\n\tint result;\n\n\tif (a == NULL) {\n\t\treturn EINVAL;\n\t}\n\tif (i > a->num) {\n\t\treturn EINVAL;\n\t}\n\n\tif ((result = array_resize(a, a->num + 1))) {\n\t\treturn result;\n\t}\n\n\tmemmove(&a->a[i + 1], &a->a[i], (a->num - i - 1) * sizeof(void*));\n\n\ta->a[i] = v;\n\n\treturn 0;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void* pqueue_peek(const struct pqueue* q)", "code": "{\n\tassert(q != NULL);\n\tassert(q->s != 0);\n\n\treturn q->a[0];\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_destroy(struct array* a)", "code": "{\n\tif (!a) {\n\t\treturn EINVAL;\n\t}\n\n\tif (a->a) {\n\t\tfree(a->a);\n\t}\n\tfree(a);\n\n\treturn 0;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/******************************************************************************/\n", "func_signal": "unsigned int array_size(const struct array* a)", "code": "{\n\tif (!a) {\n\t\treturn 0;\n\t}\n\n\treturn a->num;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int pqueue_insert(struct pqueue* q, void* v)", "code": "{\n\tassert(q != NULL);\n\n\tif (q->n == q->s) {\n\t\tvoid** a = realloc(q->a, q->s * 2 * sizeof(void*));\n\n\t\tif (!a) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tq->a = a;\n\t\tq->s *= 2;\n\t}\n\n\tq->a[q->n] = v;\n\tq->n++;\n\n\tpqueue_bubble_up(q);\n\n\treturn 0;\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int queue_destroy(struct queue* q)", "code": "{\n\tif (!q) {\n\t\treturn EINVAL;\n\t}\n\n\tif (q->a) {\n\t\tfree(q->a);\n\t}\n\tfree(q);\n\n\treturn 0;\n}", "path": "lib\\queue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void* pqueue_pop(struct pqueue* q)", "code": "{\n\tassert(q != NULL);\n\tassert(q->s != 0);\n\n\tq->n--;\n\n\tSWAP(0, q->n);\n\n\tpqueue_trickle_down(q);\n\t\n\treturn q->a[q->n];\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int queue_is_empty(struct queue* q)", "code": "{\n\tif (q == NULL) {\n\t\treturn 1;\n\t}\n\tif (q->num == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "lib\\queue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int array_get(const struct array* a, unsigned int i, void** ret)", "code": "{\n\tif (ret == NULL) {\n\t\treturn EINVAL;\n\t}\n\n\t*ret = NULL;\n\n\tif (a == NULL) {\n\t\treturn EINVAL;\n\t}\n\tif (i >= a->num) {\n\t\treturn EINVAL;\n\t}\n\n\t*ret = a->a[i];\n\n\treturn 0;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "struct pqueue* pqueue_create(pqueue_compare f)", "code": "{\n\tstruct pqueue* q = malloc(sizeof(struct pqueue));\n\n\tassert(q != NULL);\n\n\tq->f = f;\n\tq->n = 0;\n\tq->s = 4;\n\tq->a = malloc(sizeof(void*) * q->s);\n\t\n\tassert(q->a != NULL);\n\n\treturn q;\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int queue_peek(struct queue* q, void** ret)", "code": "{\n\tif (ret == NULL) {\n\t\treturn EINVAL;\n\t}\n\t\n\t*ret = NULL;\n\n\tif (q == NULL) {\n\t\treturn EINVAL;\n\t}\n\tif (queue_is_empty(q)) {\n\t\treturn EINVAL;\n\t}\n\n\t*ret = q->a[q->idx];\n\n\treturn 0;\n}", "path": "lib\\queue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "struct queue* queue_create()", "code": "{\n\tstruct queue* q = malloc(sizeof(struct queue));\n\n\tif (!q) {\n\t\treturn NULL;\n\t}\n\n\tq->a = NULL;\n\tq->sz = q->num = q->idx = 0;\n\n\treturn q;\n}", "path": "lib\\queue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "struct array* array_create()", "code": "{\n\tstruct array* a = malloc(sizeof(struct array));\n\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\n\ta->a = NULL;\n\ta->sz = a->num = 0;\n\n\treturn a;\n}", "path": "lib\\array.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "static void pqueue_trickle_down(struct pqueue* q)", "code": "{\n\tunsigned long i = 0;\n\n\twhile (LC(i) < q->n) {\n\t\tunsigned long wc = LC(i);\n\t\tif (RC(i) < q->n && q->f(q->a[RC(i)], q->a[LC(i)])) {\n\t\t\twc = RC(i);\n\t\t}\n\t\tif (q->f(q->a[wc], q->a[i])) {\n\t\t\tSWAP(wc, i);\n\t\t\ti = wc;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int queue_pop(struct queue* q, void** ret)", "code": "{\n\tif (ret == NULL) {\n\t\treturn EINVAL;\n\t}\n\n\t*ret = NULL;\n\n\tif (q == NULL) {\n\t\treturn EINVAL;\n\t}\n\tif (queue_is_empty(q)) {\n\t\treturn EINVAL;\n\t}\n\n\t*ret = q->a[q->idx];\n\n\tq->idx++;\n\tq->idx %= q->sz;\n\tq->num--;\n\n\treturn 0;\n}", "path": "lib\\queue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void pqueue_destroy(struct pqueue* q)", "code": "{\n\tif (!q) {\n\t\treturn;\n\t}\n\tif (q->a) {\n\t\tfree(q->a);\n\t}\n\tfree(q);\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/*****************************************************************************/\n", "func_signal": "int pqueue_is_empty(const struct pqueue* q)", "code": "{\n\tassert(q != NULL);\n\n\treturn q->n == 0;\n}", "path": "lib\\pqueue.c", "repo_name": "m3lawren/libm3", "stars": 2, "license": "None", "language": "c", "size": 148}
{"docstring": "/**\n* @brief Wrapper for all plataform IO cleaning\n*\n* @return 0 on success. Otherwise error. \n*\n* Cleans the General Inputs, General Outputs and FPGA-GPIO peripherals\n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int pio_clean_all()", "code": "{\n    int res; \n    \n    if( (res = gpio_clean(&pio_geninputs)) <0 )\n\t    goto uncleaned_all;\n    \n    if( (res = gpio_clean(&pio_genoutputs)) < 0 )\n\t    goto uncleaned_gout;\n    \n/*    if( (res = gpio_clean(&pio_fpgagpio)) < 0 )\n\t    goto uncleaned_fpga;*/\n    \n    return 0; \n    \nuncleaned_all:\n   util_pdbg(DBG_WARN, \"PIO: Error cleaning \\\"General Inputs\\\" GPIO. None could be cleaned. Error:%d \\n\", res);\nuncleaned_gout:\n   util_pdbg(DBG_WARN, \"PIO: Error cleaning \\\"General Outputs\\\". \\\"General Inputs\\\" could be cleaned.\\n \", res);\n// uncleaned_fpga:\n//    util_pdbg(DBG_WARN, \"PIO: Error cleaning GPIOs. \\\"General Inputs/Outputs\\\" could be cleaned. \\n\", res);\n\n   return res; \n}", "path": "src\\platform_io.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Wrapper for General Inputs GPIO initialization\n*\n* @param fisr Pointer to the Interrupt Service Routine (NULL if no interrupt support)\n* @return 0 on success. Otherwise error. \n*\n* Initializes the FPGA-GPIO peripheral\n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int pio_init_fpgagpio(void (*fisr)(void*))", "code": "{\n    int err;\n    \n    err = gpio_init(&pio_fpgagpio, FPGA_GPIO8_BASE, FPGA_GPIO8_END, \n\t\t    FPGA_GPIO8_NUM_OF_CHAN , GPIO_FLAGS_INPUT | GPIO_FLAGS_OUTPUT, FPGA_GPIO8_IRQ_NO, \n\t\t    fisr, FPGA_GPIO8_IRQ_PRIO);\n\n    gpio_set_dir(&pio_fpgagpio,~0,0,~0); // all inputs by default\n\n    return err; \n}", "path": "src\\platform_io.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Wrapper for General Inputs GPIO initialization\n*\n* @param fisr Pointer to the Interrupt Service Routine (NULL if no interrupt support)\n* @return 0 on success. Otherwise error. \n*\n* Initializes the General Inputs GPIO peripheral\n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int pio_init_geninputs(void (*fisr)(void*))", "code": "{\n    int err; \n    \n    err = gpio_init(&pio_geninputs, GENERAL_INPUTS_BASE, GENERAL_INPUTS_END, \n\t\t    GENERAL_INPUTS_NUM_OF_CHAN , GPIO_FLAGS_INPUT | GPIO_IRQ_CHANNEL1, GENERAL_INPUTS_IRQ_NO, \n\t\t    fisr, GENERAL_INPUTS_IRQ_PRIO); \n\t\t    \n    gpio_set_dir(&pio_geninputs,~0,0,~0); // all inputs\n    \n    return err; \n}", "path": "src\\platform_io.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Write for 8bits commands\n*\n* @param adc MAX1231 device to clena\n* @param tx TX buffer for the max1231\n* @param sleep \n* @return 0 on success. Otherwise error. \n*\n* Low level write for 8bits to support general commands\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int adc_ll_write8(MAX1231* adc, uint8_t tx, int sleep)", "code": "{\n    int err;\n\n    UTIL_MUTEX_ACQUIRE(\"MAX1231\",&(adc->mutex),TM_INFINITE);\n    \n    err = spi_half_transfer(adc->xspi, &tx , 1 );\n\t\t\t     \n    UTIL_MUTEX_RELEASE(\"MAX1231\",&(adc->mutex));\n\n    if ( err < 0 ){\n\tutil_pdbg(DBG_WARN, \"MAX1231: Error writing to device %s\\n\",(adc->xspi)->device); \n\treturn -EIO;\n    }\n\n    //TODO: Calculate properly\n    __usleep(sleep);\n\n    return 0;    \n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Cleans the MAX1231 device\n*\n* @param adc MAX1231 device to clena\n* @return 0 on success. Otherwise error. \n*\n* Cleans structure and Mutex\n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int max1231_clean(MAX1231* adc)", "code": "{\n    int err; \n\n    util_pdbg(DBG_INFO, \"Cleaning the MAX1231 ADC...\\n\");\n    \n    adc->xspi = NULL;\n    \n    UTIL_MUTEX_DELETE(\"MAX1231\", &(adc->mutex));\n    \n    return err; \n\n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Configs the MAX1231 device\n*\n* @param adc MAX1231 device to clena\n* @return 0 on success. Otherwise error. \n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int max1231_config(MAX1231* adc)", "code": "{\n    int err,i; \n    // sanity check? \n    uint8_t tx[8] = {0, }; // clock config + unipolar config + 16 SCK clocks + clock config + bipolar config + 16 SCK clocks\n    uint8_t rx[ARRAY_SIZE(tx)] = {0, };  \n    tx[0] = adc->clock | MAX1231_SETUP_UNIDIFF; \n    tx[4] = adc->clock | MAX1231_SETUP_BIPDIFF; \n\n    for( i = 0 ; i < 8 ; i++ )\n    {\n      if((adc->pairs[i] & MAX1231_CONF_BIPDIFF_MASK) != 0 )\n\t  tx[5] = adc->pairs[i] >> 1 ; //i/2\n      if((adc->pairs[i] & MAX1231_CONF_UNIDIFF_MASK) != 0 ) // By Spec, Unipolar take predecence over bipolar, there is no need of sanity check here\n\t  tx[1] = adc->pairs[i] >> 1 ; //i/2\n     }\n     \n    if( (err = spi_full_transfer(adc->xspi, tx, rx, ARRAY_SIZE(tx))) < 0 )\n    {\n\tutil_pdbg(DBG_WARN, \"MAX1231: Can't config MAX1231\");\n\treturn err; \n    }\n\t\n    return 0; \n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Write to I2C device ( Special 1 command version ) \n*\n* @param i2c I2C peripheral\n* @param address Address of the slave ( 3 - 0x77 ) \n* @param arg1 Command\n* @return read value. Negative values (int) should be considered as errors.  \n*\n* Special I2C functions for write with 1 parameters(see HMC6352)\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int i2c_set_1com( I2CDEV* i2c, uint8_t address, uint8_t arg1)", "code": "{\n    int res,err;\n\n    if (address > 0x7f) {\n\tutil_pdbg(DBG_WARN , \"I2C: Chip address invalid!\\n\");\n\treturn -EADDRNOTAVAIL;\n    }\n\n    UTIL_MUTEX_ACQUIRE(\"I2C\",&(i2c->mutex),TM_INFINITE);\n\n    set_slave_addr(i2c->file, address, 0);\n    res = i2c_smbus_write_byte(i2c->file,arg1);\n    \n    UTIL_MUTEX_RELEASE(\"I2C\",&(i2c->mutex));\n\n    if( (err = rt_mutex_release(&(i2c->mutex))) < 0 ){\n\tutil_pdbg(DBG_WARN, \"I2C: Couldn't release mutex . Error : %d \\n\", err);\n\treturn err; \n    }\n    \n    if( res < 0 )\n\treturn -EIO;\t\t\n\n    #ifdef DBG_LL_I2C\n    util_pdbg(DBG_DEBG, \"Written 0x%x on address:0x%x\\n\",address,arg1);\n    #endif\n    \n    return 0;\n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/*\n * marvell_phy_link_status:\n * Returns 0 if LINK is UP\n * Returns -1 if LINK is DOWN\n */\n", "func_signal": "int marvell_phy_link_status (void *phy_inst, uint32_t PhyAddress)", "code": "{\n    uint16_t val;\n\n    if (PhyRead_fp == NULL) {\n        printf(\"ERROR: PHY accessor vectors not set.\\n\\r\");\n        return -1;\n    }\n\n    (*PhyRead_fp)(phy_inst, PhyAddress, MPHY_SPCFC_STATUS_REG, &val);\n    if (val & MPHY_SPCFC_STAT_LINK_RT) {\n        return 0;\n    }\n    return -1;\n}", "path": "etherlite_fix\\marvell_88e1111.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/* Dirt log functions */\n", "func_signal": "void slog(char *fmt, ...)", "code": "{ \n    va_list args_ptr;\n    static char buf[80];\n    va_start(args_ptr,fmt);\n    vsprintf(buf, fmt, args_ptr);\n    va_end(args_ptr);\n    if (dbool)\n\tsyslog(LOG_INFO, \"%s\", buf);    \n    else{\n\tprintf(\"%s\",buf);\n\tfflush(NULL);\n    }\n}", "path": "lcd_daemon\\lcd_daemon.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Read from IO device I2C device\n*\n* @param i2c I2C peripheral\n* @param address Address of the slave ( 3 - 0x77 ) \n* @param daddress Address of the internal memory register\n* @param csize Size of data to read ( 'w' = word ; 'b' = byte ) \n* @return Read value. Negative values (int) should be considered as errors\n* @note; Return value should be masked according to csize\n*\n* SMBus I2C functions for read/write\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking and might take significant time to complete\n*\n*/\n", "func_signal": "int i2c_get( I2CDEV* i2c, uint8_t address, uint8_t daddress, char csize)", "code": "{\n    int res,err;\t    \n   \n    if ( address < 3 || address > 0x77) {\n\tutil_pdbg(DBG_WARN , \"I2C: Chip address invalid!\\n\");\n\treturn -EADDRNOTAVAIL;\n    }\n\n    UTIL_MUTEX_ACQUIRE(\"I2C\",&(i2c->mutex),TM_INFINITE);\n \n    set_slave_addr(i2c->file, address, 0);\n   \n    switch (csize)\n    {\n\tcase 'b': //I2C_SMBUS_BYTE\n\t    res = i2c_smbus_read_byte_data(i2c->file, daddress);\n\t    break;\n\tcase 'w': //I2C_SMBUS_WORD_DATA; \n\t    res = i2c_smbus_read_word_data(i2c->file, daddress);\n\t    break;\n\tcase 'c': // I2C_SMBUS_BYTE_DATA \n\t    res = i2c_smbus_read_byte_data(i2c->file, daddress);\n\t    break;\n\tdefault: \n\t    res = -1; // INVALID DATA SIZE\n    }\n    \n    UTIL_MUTEX_RELEASE(\"I2C\",&(i2c->mutex));\n    \n    if (res < 0) {\n\t    fprintf(stderr, \"Error: Read failed\\n\");\n\t    return -EIO;\n    }\n    \n    #ifdef DBG_LL_I2C\n    util_pdbg(DBG_DEBG, \"0x%0*x\\n\", csize == 'w' ? 4 : 2, res);    \n    #endif\n    \n    return res;\n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/*\n * marvell_phy_display_status:\n */\n", "func_signal": "void marvell_phy_display_status (void *phy_inst, uint32_t PhyAddress)", "code": "{\n    uint16_t val, speed_status;\n\n    if (PhyRead_fp == NULL) {\n        printf(\"ERROR: PHY accessor vectors not set.\\n\\r\");\n        return;\n    }\n\n    (*PhyRead_fp)(phy_inst, PhyAddress, MPHY_SPCFC_STATUS_REG, &val);\n    if (val & MPHY_SPCFC_STAT_LINK_RT) {\n        printf(\"PHY Status: LINK_OK \");\n    } else {\n        printf(\"PHY Status: LINK_DOWN\\n\\r\");\n        return;\n    }\n\n    speed_status = val >> MPHY_SPCFC_STAT_SPD_SHIFT;\n    switch (speed_status) {\n    case MPHY_SPCFC_STAT_SPD_RESVD:\n        printf(\"SPEED-RESERVED \");\n        break;\n    case MPHY_SPCFC_STAT_SPD_1000:\n        printf(\"SPEED-1000MB \");\n        break;\n    case MPHY_SPCFC_STAT_SPD_100:\n        printf(\"SPEED-100MB \");\n        break;\n    case MPHY_SPCFC_STAT_SPD_10:\n        printf(\"SPEED-10MB \");\n        break;\n    }\n\n    if (val & MPHY_SPCFC_STAT_DUPLEX) {\n        printf(\"FULL-DUPLEX \");\n    } else {\n        printf(\"HALF-DUPLEX \");\n    }\n\n    if (val & MPHY_SPCFC_STAT_SPD_DUP_RSLVD) {\n        printf(\"SPD_DPLX_RSLVD \");\n    } else {\n        printf(\"SPD_DPLX_NOT_RSLVD \");\n    }\n\n    if (val & MPHY_SPCFC_STAT_MDIX) { \n        printf(\"MDIX \");\n    } else {\n        printf(\"MDI \");\n    }\n\n    printf(\"\\n\");\n}", "path": "etherlite_fix\\marvell_88e1111.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Reads the temperature from the MAX1231\n*\n* @param adc MAX1231 device to clena\n* @param n Channel number\n* @param dest Destination array\n* @return 0 on success. Otherwise error. \n*\n* Reads the temperature from the internal sensor in the MAX1231\n* Simplify reading of temperature and returns value in degrees\n*\n* @note Needs to downscale(divide) by 8 afterwards\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int adc_get_temperature(MAX1231* adc, int* ret)", "code": "{\n    int err;\n    \n    if((err= adc_read_one_once( adc, 16, ret))<0){\n\tutil_pdbg(DBG_INFO, \"MAX1231: Couldn't get temperature . Error : %d \\n\", err);\n\treturn err;\n    }\n    \n    return 0;\n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Write to I2C device\n*\n* @param i2c I2C peripheral\n* @param address Address of the slave ( 3 - 0x77 ) \n* @param daddress Address of the internal memory register\n* @param csize Size of data to read ( 'w' = word ; 'b' = byte ) \n* @param value Value to write into the register\n* @return read value. Negative values (int) should be considered as errors.  \n*\n* SMBus I2C functions for read/write\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int i2c_set(I2CDEV* i2c, uint8_t address, uint8_t daddress, char csize, unsigned value)", "code": "{\n    int res,err;\n    \n    if (address > 0x7f) {\n\tutil_pdbg(DBG_WARN , \"I2C: Chip address invalid!\\n\");\n\treturn -EADDRNOTAVAIL;\n    }\n\n    UTIL_MUTEX_ACQUIRE(\"I2C\",&(i2c->mutex),TM_INFINITE);\n    \n    set_slave_addr(i2c->file, address, 0);\n\n    if (csize == 'w')\n\tres = i2c_smbus_write_word_data(i2c->file, daddress, value & 0xffff);\n    else \n\tres = i2c_smbus_write_byte_data(i2c->file, daddress, value & 0xff);\n    \n    UTIL_MUTEX_RELEASE(\"I2C\",&(i2c->mutex));    \n    \n    if (res < 0) {\n\tutil_pdbg(DBG_WARN,  \"Error: Write failed\\n\");\n\treturn -EIO;\t\t\n    }\n    \n    #ifdef DBG_LL_I2C\n    util_pdbg(DBG_DEBG, \"Written 0x%x on daddress:0x%x\\n\",value, daddress);\n    #endif\n    \n    return 0; \n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Initialization for the I2C device\n*\n* @param i2c I2C peripheral to init\n* @param bus Bus number to assign ( i2c-0, i2c-1, ... )\n* @return 0 on success. Otherwise error. \n*\n* Initizializes the structure and creates corresponding mutex \n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int i2c_init(I2CDEV* i2c, uint8_t bus)", "code": "{\n    int err; \n    \n    util_pdbg(DBG_DEBG, \"I2C: Initializing I2C Device...\\n\");\n\n    if (bus > 0x3f) {\n\tfprintf(stderr, \"I2C: I2CBUS argument invalid!\\n\");\n\treturn -ENODEV;\n    }\n    \n    i2c->i2cbus = bus; \n    \n    if( (i2c->file = open_i2c_dev(i2c->i2cbus, i2c->filename, 0)) < 0 ){\n\tutil_pdbg(DBG_WARN, \"I2C: File descriptor could not be allocated. Error %d\\n\", i2c->file);\n\treturn -ENODEV; \n    }\n\n    util_pdbg(DBG_INFO, \"I2C: Succesfully open file in %s on bus %d\\n\",i2c->filename,i2c->i2cbus);\n\n    UTIL_MUTEX_CREATE(\"I2C\",&(i2c->mutex),NULL);\n   \n    return 0; \n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Reads from MAX1231\n*\n* @param adc MAX1231 device to clena\n* @param convbyte Conversion byte \n* @param dest_array Destination array for readings\n* @param len Length of dest_array\n* @return 0 on success. Otherwise error. \n*\n* Reads an array of 'len' bytes to 'dest_array'\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int adc_read(MAX1231* adc,uint8_t convbyte,uint8_t* dest_array, int len)", "code": "{\n    int err,err2;\n    #ifdef DBG_LL_SPI\n    int i ; \n    #endif\n\n    UTIL_MUTEX_ACQUIRE(\"MAX1231\",&(adc->mutex),TM_INFINITE);\n\n    err = spi_half_transfer(adc->xspi, &convbyte , 1 );\n    \n    //Check times in a look-up table according to len \n    if( convbyte & MAX1231_CONV_TEMP )\n\t__usleep( dtable[(len>>1)] + MAX1231_DELAY_TEMP );\n    else \n\t__usleep( dtable[(len>>1)] );\n\n    // -- !!!!TODO: REMOVE!\n    __usleep(200); // should be less \n    // -- \n    \n    err2 = spi_half_read(adc->xspi , dest_array, len);\n\n    UTIL_MUTEX_RELEASE(\"MAX1231\",&(adc->mutex));\n    \n    if ( err2 < 0 || err < 0 ){\n\tutil_pdbg(DBG_WARN,\"MAX1231: Error reading/writing from/to device %s. Read:%d Write:%d\\n\",(adc->xspi)->device,err2,err); \n\treturn -EIO;\n    }\n\n    #ifdef DBG_LL_SPI\n     for( i = 0 ; i < len ; i ++){\n \tutil_pdbg(DBG_DEBG, \"Read[%d]: 0x%x\\n\", i, dest_array[i]);\n     }\n    #endif\n    \n    return 0; \n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Reads one measure MAX1231\n*\n* @param adc MAX1231 device to clena\n* @param n Channel number\n* @param ret Read value\n* @return 0 on success. Otherwise error. \n*\n* Read one 16 bit ( actual 12 ) measure from the ADC\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int adc_read_one_once(MAX1231* adc, uint8_t n, int* ret)", "code": "{\n    int err; \n    uint8_t convbyte;\n    uint8_t dest[2];\n\n    if( n > 16) \n\t    return -1; // out of bounds\n\n    if( n == 16 ) //temperature \n\tconvbyte = 0x80 | ( n << 3 ) | MAX1231_CONV_SINGLE_READ | MAX1231_CONV_TEMP ; \n    else \n\tconvbyte = 0x80 | ( n << 3 ) | MAX1231_CONV_SINGLE_READ ;\n    \n                \n    if ((err = adc_read(adc, convbyte, dest, 2 )) < 0 ){\n\tutil_pdbg(DBG_WARN, \"MAX1231:Error reading from device %s. Error: %d\\n\",adc->xspi->device, err); \n\treturn -EIO;\n    }\n    \n    *ret = ( (int)(dest[0] << 8 ) | (int)dest[1] ); \n    \n    return 0;\n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Reads n measures from 0 to n\n*\n* @param adc MAX1231 device to clena\n* @param n Channel number\n* @param dest Destination array\n* @return 0 on success. Otherwise error. \n*\n* Reads in Scan mode from byte 0 to N\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int adc_read_scan_0_N(MAX1231* adc, uint8_t* dest, uint8_t n)", "code": "{\n    int len = ((n & 0x0f) << 1) + 2; // n*2 + 2\n    uint8_t convbyte;\n\n    if( n > 15) \n\treturn -1; // out of bounds\n\n    convbyte = 0x80 | ( (n & 0x0f)  << 3 ) | MAX1231_CONV_SCAN_00_N ;\n\n//     return adc_read(adc, convbyte, adc->dest, len );\n    return adc_read(adc, convbyte, dest, len );\n}", "path": "src\\max1231adc.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Read from I2C device ( Special 3 command version ) \n*\n* @param i2c I2C peripheral\n* @param address Address of the slave ( 3 - 0x77 ) \n* @param arg1 First parameter\n* @param arg2 Second parameter\n* @return read value. Negative values (int) should be considered as errors.  \n*\n* Special I2C functions for read/write with 3 parameters(see HMC6352)\n*\n* @note This function is \\b thread-safe.\n* @note This function is \\b blocking. \n*\n*/\n", "func_signal": "int i2c_get_3com( I2CDEV* i2c, uint8_t address, uint8_t arg1, uint8_t arg2)", "code": "{\n    int err,res;\t        \n\n    UTIL_MUTEX_ACQUIRE(\"I2C\",&(i2c->mutex),TM_INFINITE);\n \n    // Write 3 arguments on the i2c bus\n    i2c_set(i2c,address,arg1,'b', arg2);    \n    set_slave_addr(i2c->file, address, 0);      \n    res = i2c_smbus_read_byte(i2c->file);\n\n    UTIL_MUTEX_RELEASE(\"I2C\",&(i2c->mutex));\n    \n    return 0;\n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief I2C device clean\n*\n* @param i2c I2C peripheral to clean\n* @return 0 on success. Otherwise error. \n*\n* Cleans the structure and deletes the corresponding mutex \n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int i2c_clean(I2CDEV* i2c)", "code": "{\n    int err;\n\n    util_pdbg(DBG_DEBG, \"I2C: Cleaning I2C Device...\\n\");\n\n    UTIL_MUTEX_DELETE(\"I2C\",&(i2c->mutex));\n    \n    if( ( err = close(i2c->file)) < 0 )\n\treturn err; \n    \n    return 0;\n}", "path": "src\\i2ctools.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/**\n* @brief Wrapper for all plataform IO initialization\n*\n* @param isr_ginputs Pointer to the Interrupt Service Routine for the General Inputs peripheral (NULL if no interrupt support)\n* @param isr_fpga Pointer to the Interrupt Service Routine for the GPIO-FPGA peripheral (NULL if no interrupt support)\n* @return 0 on success. Otherwise error. \n*\n* Initializes the General Inputs, General Outputs and FPGA-GPIO peripherals\n*\n* @note This function is \\b NOT thread-safe. The user should guarantee somewhere else that is not called in several instances\n*       for the same resource. \n*\n*/\n", "func_signal": "int pio_init_all(void (*isr_ginputs)(void*), void (*isr_fpga)(void*))", "code": "{\n    int res ; \n    \n    if( (res = pio_init_geninputs(isr_ginputs)) <0 )\n\t    goto uninit_any;\n    \n    if( (res = pio_init_genoutputs()) < 0 )\n\t    goto uninit_go_fpga;\n    \n/*    if( (res = pio_init_fpgagpio(isr_fpga)) < 0 )\n\t    goto uninit_fpga;*/\n    \n    return 0;\n    \n// uninit_fpga:    \n//     gpio_clean(&pio_geninputs);\n//     gpio_clean(&pio_genoutputs);\n//     util_pdbg(DBG_WARN, \"PIO: GPIO FPGA_GPIO8 could not be initialized. Cleaning previosly initialized. Error:%d\\n\", res);\nuninit_go_fpga:    \n    gpio_clean(&pio_geninputs);\n    util_pdbg(DBG_WARN, \"PIO: GPIO \\\"General Outputs\\\" could not be initialized. Cleaning previosly initialized. Error:%d\\n\", res);\nuninit_any:    \n    util_pdbg(DBG_WARN, \"PIO: GPIO \\\"General Inputs\\\" could not be initialized. Error:%d\\n\", res);\n    return res;\n}", "path": "src\\platform_io.c", "repo_name": "jssdn/RRCon-Robotlib", "stars": 2, "license": "None", "language": "c", "size": 264}
{"docstring": "/*---------------------------------------------------*/\n/*--- Processing of complete files and streams    ---*/\n/*---------------------------------------------------*/\n", "func_signal": "thread getAndCompressBlock(FILE* stream, shared UInt32 combinedCRC, shared Bool lastBlock)", "code": "{\n\n   //TODO: sync 1: read shared1\n   UInt32 blockCRC;\n   UInt32 combinedCRCTmp;\n   Bool lastBlockLast;\n\n   lastBlockLast = lastBlock;\n   if (lastBlockLast) {\n      lastBlock = lastBlockLast;\n      combinedCRCTmp = combinedCRC;\n      combinedCRC = combinedCRCTmp;\n      return;\n   }\n\n\n   BlockData *bd = (BlockData*)malloc(sizeof(BlockData));\n   if (bd == NULL) {\n      fprintf(stderr, \"bd GAGAL!\\n\");\n      fflush(stderr);\n   }\n   allocateCompressStructures(bd);\n\n   //blockNo++;\n   initialiseCRC ();\n   loadAndRLEsource ( bd, stream );\n   ERROR_IF_NOT_ZERO ( ferror(stream) );\n   if (bd->last == -1) {\n      lastBlockLast = True;\n   }\n\n   lastBlock = lastBlockLast;\n   if (lastBlockLast) {\n      combinedCRCTmp = combinedCRC;\n      combinedCRC = combinedCRCTmp;\n      return;\n   }\n\n   //TODO: sync 1: write shared1\n\n   blockCRC = getFinalCRC ();\n\n   /*== Parallel Begin ==*/\n\n   /*-- sort the block and establish posn of original string --*/\n   doReversibleTransformation ( bd );\n\n   /*--\n     A 6-byte block header, the value chosen arbitrarily\n     as 0x314159265359 :-).  A 32 bit value does not really\n     give a strong enough guarantee that the value will not\n     appear by chance in the compressed datastream.  Worst-case\n     probability of this event, for a 900k block, is about\n     2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.\n     For a compressed file of size 100Gb -- about 100000 blocks --\n     only a 48-bit marker will do.  NB: normal compression/\n     decompression do *not* rely on these statistical properties.\n     They are only important when trying to recover blocks from\n     damaged files.\n   --*/\n   pbsPutUChar ( bd, 0x31 ); pbsPutUChar ( bd, 0x41 );\n   pbsPutUChar ( bd, 0x59 ); pbsPutUChar ( bd, 0x26 );\n   pbsPutUChar ( bd, 0x53 ); pbsPutUChar ( bd, 0x59 );\n\n   /*-- Now the block's CRC, so it is in a known place. --*/\n   pbsPutUInt32 ( bd, blockCRC );\n\n   /*-- Now a single bit indicating randomisation. --*/\n   if (bd->blockRandomised) {\n      pbsW(bd,1,1);\n   } else\n      pbsW(bd,1,0);\n\n   /*-- Finally, block's contents proper. --*/\n   moveToFrontCodeAndSend ( bd );\n\n   /*== Parallel End ==*/\n\n   //TODO: sync 2: read shared2\n\n   combinedCRCTmp = combinedCRC;\n   \n   pbsFlush( bd );\n\n   combinedCRCTmp = (combinedCRCTmp << 1) | (combinedCRCTmp >> 31);\n   combinedCRCTmp ^= blockCRC;\n   combinedCRC = combinedCRCTmp;\n\n   //TODO: sync 2: write shared2\n\n   //deallocateCompressStructure( bd );\n   //destroyBlockData( bd );\n\n   //ERROR_IF_NOT_ZERO ( ferror(zStream) );\n\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void cleanUpAndFail ( Int32 ec )", "code": "{\n   IntNative retVal;\n\n   if ( srcMode == SM_F2F && opMode != OM_TEST ) {\n      fprintf ( stderr, \"%s: Deleting output file %s, if it exists.\\n\",\n                progName,\n                outName==NULL ? \"(null)\" : outName );\n      if (outputHandleJustInCase != NULL)\n         fclose ( outputHandleJustInCase );\n      retVal = remove ( outName );\n      if (retVal != 0)\n         fprintf ( stderr,\n                   \"%s: WARNING: deletion of output file (apparently) failed.\\n\",\n                   progName );\n   }\n   if (numFileNames > 0 && numFilesProcessed < numFileNames) {\n      fprintf ( stderr, \n                \"%s: WARNING: some files have not been processed:\\n\"\n                \"\\t%d specified on command line, %d not processed yet.\\n\\n\",\n                progName, numFileNames, \n                          numFileNames - numFilesProcessed );\n   }\n   exit ( ec );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void cadvise ( void )", "code": "{\n   fprintf (\n      stderr,\n      \"\\nIt is possible that the compressed file(s) have become corrupted.\\n\"\n        \"You can use the -tvv option to test integrity of such files.\\n\\n\"\n        \"You can use the `bzip2recover' program to *attempt* to recover\\n\"\n        \"data from undamaged sections of corrupted files.\\n\\n\"\n    );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void panic ( Char* s )", "code": "{\n   fprintf ( stderr,\n             \"\\n%s: PANIC -- internal consistency error:\\n\"\n             \"\\t%s\\n\"\n             \"\\tThis is a BUG.  Please report it to me at:\\n\"\n             \"\\tjseward@acm.org\\n\",\n             progName, s );\n   showFileNames();\n   cleanUpAndFail( 3 );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "INLINE UInt32 bsR ( Int32 n )", "code": "{\n   UInt32 v;\n   bsNEEDR ( n );\n   v = (bsBuff >> (bsLive-n)) & ((1 << n)-1);\n   bsLive -= n;\n   return v;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "Int32 bsGetUInt32 ( void )", "code": "{\n   UInt32 u;\n   u = 0;\n   u = (u << 8) | bsR(8);\n   u = (u << 8) | bsR(8);\n   u = (u << 8) | bsR(8);\n   u = (u << 8) | bsR(8);\n   return u;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void pbsFlush( BlockData *bd )", "code": "{\n   int i, len;\n\n   len = bd->bsBufferLength;\n   for (i=0; i<len; i++) {\n      bsPutUChar( bd->bsBuffer[i] );\n   }\n   bd->bsBufferLength = 0;\n\n   while (bd->bsLive >= 8) {\n      bsPutUChar( (UChar)(bd->bsBuff >> 24) );\n      bd->bsBuff <<= 8;\n      bd->bsLive -= 8;\n      bytesOut++;\n   }\n\n   if (bd->bsLive > 0) {\n      bd->bsBuff >>= (32 - bd->bsLive);\n      bsW( bd->bsLive, bd->bsBuff );\n   }\n\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void compressStream ( FILE *stream, FILE *zStream )", "code": "{\n   IntNative  retVal;\n   UInt32     blockCRC, combinedCRC;\n   Int32      blockNo;\n   Bool lastBlock;\n   family fid;\n\n   blockNo  = 0;\n   bytesIn  = 0;\n   bytesOut = 0;\n   nBlocksRandomised = 0;\n\n   SET_BINARY_MODE(stream);\n   SET_BINARY_MODE(zStream);\n\n   ERROR_IF_NOT_ZERO ( ferror(stream) );\n   ERROR_IF_NOT_ZERO ( ferror(zStream) );\n\n   bsSetStream ( zStream, True );\n\n   /*--- Write `magic' bytes B and Z,\n         then h indicating file-format == huffmanised,\n         followed by a digit indicating blockSize100k.\n   ---*/\n   bsPutUChar ( 'B' );\n   bsPutUChar ( 'Z' );\n   bsPutUChar ( 'h' );\n   bsPutUChar ( '0' + blockSize100k );\n\n   combinedCRC = 0;\n\n   if (verbosity >= 2) fprintf ( stderr, \"\\n\" );\n\n   while (True) {\n      //TODO: parallelize this\n      lastBlock = False;\n      create (fid;;0;4;1;;;) getAndCompressBlock(stream, combinedCRC, lastBlock);\n      sync(fid);\n\n      if (lastBlock) {\n         break;\n      }\n   }\n\n   if (verbosity >= 2 && nBlocksRandomised > 0)\n      fprintf ( stderr, \"    %d block%s needed randomisation\\n\", \n                        nBlocksRandomised,\n                        nBlocksRandomised == 1 ? \"\" : \"s\" );\n\n   /*--\n      Now another magic 48-bit number, 0x177245385090, to\n      indicate the end of the last block.  (sqrt(pi), if\n      you want to know.  I did want to use e, but it contains\n      too much repetition -- 27 18 28 18 28 46 -- for me\n      to feel statistically comfortable.  Call me paranoid.)\n   --*/\n\n   bsPutUChar ( 0x17 ); bsPutUChar ( 0x72 );\n   bsPutUChar ( 0x45 ); bsPutUChar ( 0x38 );\n   bsPutUChar ( 0x50 ); bsPutUChar ( 0x90 );\n\n   bsPutUInt32 ( combinedCRC );\n   if (verbosity >= 2)\n      fprintf ( stderr, \"    final combined CRC = 0x%x\\n   \", combinedCRC );\n\n   /*-- Close the files in an utterly paranoid way. --*/\n   bsFinishedWithStream ();\n\n   ERROR_IF_NOT_ZERO ( ferror(zStream) );\n   retVal = fflush ( zStream );\n   ERROR_IF_EOF ( retVal );\n   retVal = fclose ( zStream );\n   ERROR_IF_EOF ( retVal );\n\n   ERROR_IF_NOT_ZERO ( ferror(stream) );\n   retVal = fclose ( stream );\n   ERROR_IF_EOF ( retVal );\n\n   if (bytesIn == 0) bytesIn = 1;\n   if (bytesOut == 0) bytesOut = 1;\n\n   if (verbosity >= 1)\n      fprintf ( stderr, \"%6.3f:1, %6.3f bits/byte, \"\n                        \"%5.2f%% saved, %d in, %d out.\\n\",\n                (float)bytesIn / (float)bytesOut,\n                (8.0 * (float)bytesOut) / (float)bytesIn,\n                100.0 * (1.0 - (float)bytesOut / (float)bytesIn),\n                bytesIn,\n                bytesOut\n              );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void pad ( Char *s )", "code": "{\n   Int32 i;\n   if ( (Int32)strlen(s) >= longestFileName ) return;\n   for (i = 1; i <= longestFileName - (Int32)strlen(s); i++)\n      fprintf ( stderr, \" \" );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void badBlockHeader ()", "code": "{\n   fprintf ( stderr,\n             \"\\n%s: bad block header in the compressed file,\\n\"\n             \"\\twhich probably means it is corrupted.\\n\",\n             progName );\n   showFileNames();\n   cadvise();\n   cleanUpAndFail( 2 );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "INLINE void pbsW ( BlockData *bd, Int32 n, UInt32 v )", "code": "{\n   pbsNEEDW ( bd, n );\n   bd->bsBuff |= (v << (32 - bd->bsLive - n));\n   bd->bsLive += n;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "Bool containsDubiousChars ( Char* name )", "code": "{\n   Bool cdc = False;\n   for (; *name != '\\0'; name++)\n      if (*name == '?' || *name == '*') cdc = True;\n   return cdc;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "INLINE Int32 indexIntoF ( Int32 indx, Int32 *cftab )", "code": "{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void bsFinishedWithStream ( void )", "code": "{\n   if (bsWriting)\n      while (bsLive > 0) {\n         //fputc ( (UChar)(bsBuff >> 24), bsStream );\n         cout << (UChar)(bsBuff >> 24);\n         bsBuff <<= 8;\n         bsLive -= 8;\n         bytesOut++;\n      }\n   bsStream = NULL;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void loadAndRLEsource ( BlockData *bd, FILE* src )", "code": "{\n   Int32 ch, allowableBlockSize, i;\n\n   bd->last = -1;\n   ch   = 0;\n\n   for (i = 0; i < 256; i++) bd->inUse[i] = False;\n\n   /*--- 20 is just a paranoia constant ---*/\n   allowableBlockSize = 100000 * blockSize100k - 20;\n\n   while (bd->last < allowableBlockSize && ch != MY_EOF) {\n      Int32 rlePair, runLen;\n      rlePair = getRLEpair ( src );\n      ch      = rlePair & 0xFFFF;\n      runLen  = (UInt32)rlePair >> 16;\n\n      #if DEBUG\n         assert (runLen >= 1 && runLen <= 255);\n      #endif\n\n      if (ch != MY_EOF) {\n         bd->inUse[ch] = True;\n         switch (runLen) {\n            case 1:\n               bd->last++; bd->block[bd->last] = (UChar)ch; break;\n            case 2:\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch; break;\n            case 3:\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch; break;\n            default:\n               bd->inUse[runLen-4] = True;\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)ch;\n               bd->last++; bd->block[bd->last] = (UChar)(runLen-4); break;\n         }\n      }\n   }\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void pbsPutUInt32 ( BlockData *bd, UInt32 u )", "code": "{\n   pbsW ( bd, 8, (u >> 24) & 0xffL );\n   pbsW ( bd, 8, (u >> 16) & 0xffL );\n   pbsW ( bd, 8, (u >>  8) & 0xffL );\n   pbsW ( bd, 8,  u        & 0xffL );\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void mySIGSEGVorSIGBUScatcher ( IntNative n )", "code": "{\n   if (opMode == OM_Z)\n      fprintf ( stderr,\n                \"\\n%s: Caught a SIGSEGV or SIGBUS whilst compressing,\\n\"\n                \"\\twhich probably indicates a bug in bzip2.  Please\\n\"\n                \"\\treport it to me at: jseward@acm.org\\n\",\n                progName );\n      else\n      fprintf ( stderr,\n                \"\\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing,\\n\"\n                \"\\twhich probably indicates that the compressed data\\n\"\n                \"\\tis corrupted.\\n\",\n                progName );\n\n   showFileNames();\n   if (opMode == OM_Z)\n      cleanUpAndFail( 3 ); else\n      { cadvise(); cleanUpAndFail( 2 ); }\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "Cell *mkCell ( void )", "code": "{\n   Cell *c;\n\n   c = (Cell*) myMalloc ( sizeof ( Cell ) );\n   c->name = NULL;\n   c->link = NULL;\n   return c;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "Bool testStream ( FILE *zStream )", "code": "{\n   UChar      magic1, magic2, magic3, magic4;\n   UChar      magic5, magic6;\n   UInt32     storedBlockCRC, storedCombinedCRC;\n   UInt32     computedBlockCRC, computedCombinedCRC;\n   Int32      currBlockNo;\n   IntNative  retVal;\n\n   BlockData *bd;\n\n   SET_BINARY_MODE(zStream);\n   ERROR_IF_NOT_ZERO ( ferror(zStream) );\n\n   bsSetStream ( zStream, False );\n\n   magic1 = bsGetUChar ();\n   magic2 = bsGetUChar ();\n   magic3 = bsGetUChar ();\n   magic4 = bsGetUChar ();\n   if (magic1 != 'B' ||\n       magic2 != 'Z' ||\n       magic3 != 'h' ||\n       magic4 < '1'  ||\n       magic4 > '9') {\n     bsFinishedWithStream();\n     fclose ( zStream );\n     fprintf ( stderr, \"\\n%s: bad magic number (ie, not created by bzip2)\\n\",\n                       inName );\n     return False;\n   }\n\n   smallMode = True;\n   setDecompressStructureSizes ( magic4 - '0' );\n   computedCombinedCRC = 0;\n\n   if (verbosity >= 2) fprintf ( stderr, \"\\n\" );\n   currBlockNo = 0;\n\n   while (True) {\n      magic1 = bsGetUChar ();\n      magic2 = bsGetUChar ();\n      magic3 = bsGetUChar ();\n      magic4 = bsGetUChar ();\n      magic5 = bsGetUChar ();\n      magic6 = bsGetUChar ();\n      if (magic1 == 0x17 && magic2 == 0x72 &&\n          magic3 == 0x45 && magic4 == 0x38 &&\n          magic5 == 0x50 && magic6 == 0x90) break;\n\n      currBlockNo++;\n      if (magic1 != 0x31 || magic2 != 0x41 ||\n          magic3 != 0x59 || magic4 != 0x26 ||\n          magic5 != 0x53 || magic6 != 0x59) {\n         bsFinishedWithStream();\n         fclose ( zStream );\n         fprintf ( stderr,\n                   \"\\n%s, block %d: bad header (not == 0x314159265359)\\n\",\n                   inName, currBlockNo );\n         return False;\n      }\n      storedBlockCRC = bsGetUInt32 ();\n\n      if (bsR(1) == 1)\n         bd->blockRandomised = True; else\n         bd->blockRandomised = False;\n\n      if (verbosity >= 2)\n         fprintf ( stderr, \"    block [%d: huff+mtf \", currBlockNo );\n      getAndMoveToFrontDecode ( bd );\n      ERROR_IF_NOT_ZERO ( ferror(zStream) );\n\n      initialiseCRC();\n      if (verbosity >= 2) fprintf ( stderr, \"rt+rld\" );\n      undoReversibleTransformation_small ( bd, NULL );\n\n      computedBlockCRC = getFinalCRC();\n      if (verbosity >= 3)\n         fprintf ( stderr, \" {0x%x, 0x%x}\", storedBlockCRC, computedBlockCRC );\n      if (verbosity >= 2) fprintf ( stderr, \"] \" );\n\n      if (storedBlockCRC != computedBlockCRC) {\n         bsFinishedWithStream();\n         fclose ( zStream );\n         fprintf ( stderr, \"\\n%s, block %d: computed CRC does not match stored one\\n\",\n                           inName, currBlockNo );\n         return False;\n      }\n\n      if (verbosity >= 2) fprintf ( stderr, \"ok\\n\" );\n      computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);\n      computedCombinedCRC ^= computedBlockCRC;\n   };\n\n   storedCombinedCRC  = bsGetUInt32 ();\n   if (verbosity >= 2)\n      fprintf ( stderr,\n                \"    combined CRCs: stored = 0x%x, computed = 0x%x\\n    \",\n                storedCombinedCRC, computedCombinedCRC );\n   if (storedCombinedCRC != computedCombinedCRC) {\n      bsFinishedWithStream();\n      fclose ( zStream );\n      fprintf ( stderr, \"\\n%s: computed CRC does not match stored one\\n\",\n                        inName );\n      return False;\n   }\n\n   bsFinishedWithStream ();\n   ERROR_IF_NOT_ZERO ( ferror(zStream) );\n   retVal = fclose ( zStream );\n   ERROR_IF_EOF ( retVal );\n   return True;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "void bsSetStream ( FILE* f, Bool wr )", "code": "{\n   if (bsStream != NULL) panic ( \"bsSetStream\" );\n   bsStream = f;\n   bsLive = 0;\n   bsBuff = 0;\n   bytesOut = 0;\n   bytesIn = 0;\n   bsWriting = wr;\n}", "path": "utcbzip2.c", "repo_name": "fajran/utcbzip2", "stars": 2, "license": "None", "language": "c", "size": 120}
{"docstring": "/* calculate c = a**b  using a square-multiply algorithm */\n", "func_signal": "int mp_expt_d (mp_int * a, mp_digit b, mp_int * c)", "code": "{\n  int     res, x;\n  mp_int  g;\n\n  if ((res = mp_init_copy (&g, a)) != MP_OKAY) {\n    return res;\n  }\n\n  /* set initial result */\n  mp_set (c, 1);\n\n  for (x = 0; x < (int) DIGIT_BIT; x++) {\n    /* square */\n    if ((res = mp_sqr (c, c)) != MP_OKAY) {\n      mp_clear (&g);\n      return res;\n    }\n\n    /* if the bit is set multiply */\n    if ((b & (mp_digit) (((mp_digit)1) << (DIGIT_BIT - 1))) != 0) {\n      if ((res = mp_mul (c, &g, c)) != MP_OKAY) {\n         mp_clear (&g);\n         return res;\n      }\n    }\n\n    /* shift to next bit */\n    b <<= 1;\n  }\n\n  mp_clear (&g);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_expt_d.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* pre-calculate the value required for Barrett reduction\n * For a given modulus \"b\" it calulates the value required in \"a\"\n */\n", "func_signal": "int mp_reduce_setup (mp_int * a, mp_int * b)", "code": "{\n  int     res;\n  \n  if ((res = mp_2expt (a, b->used * 2 * DIGIT_BIT)) != MP_OKAY) {\n    return res;\n  }\n  return mp_div (a, b, a, NULL);\n}", "path": "vendor\\libtommath-0.41\\bn_mp_reduce_setup.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* shift left a certain amount of digits */\n", "func_signal": "int mp_lshd (mp_int * a, int b)", "code": "{\n  int     x, res;\n\n  /* if its less than zero return */\n  if (b <= 0) {\n    return MP_OKAY;\n  }\n\n  /* grow to fit the new digits */\n  if (a->alloc < a->used + b) {\n     if ((res = mp_grow (a, a->used + b)) != MP_OKAY) {\n       return res;\n     }\n  }\n\n  {\n    register mp_digit *top, *bottom;\n\n    /* increment the used by the shift amount then copy upwards */\n    a->used += b;\n\n    /* top */\n    top = a->dp + a->used - 1;\n\n    /* base */\n    bottom = a->dp + a->used - 1 - b;\n\n    /* much like mp_rshd this is implemented using a sliding window\n     * except the window goes the otherway around.  Copying from\n     * the bottom to the top.  see bn_mp_rshd.c for more info.\n     */\n    for (x = a->used - 1; x >= b; x--) {\n      *top-- = *bottom--;\n    }\n\n    /* zero the lower digits */\n    top = a->dp;\n    for (x = 0; x < b; x++) {\n      *top++ = 0;\n    }\n  }\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_lshd.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* makes a pseudo-random int of a given size */\n", "func_signal": "int\nmp_rand (mp_int * a, int digits)", "code": "{\n  int     res;\n  mp_digit d;\n\n  mp_zero (a);\n  if (digits <= 0) {\n    return MP_OKAY;\n  }\n\n  /* first place a random non-zero digit */\n  do {\n    d = ((mp_digit) abs (rand ())) & MP_MASK;\n  } while (d == 0);\n\n  if ((res = mp_add_d (a, d, a)) != MP_OKAY) {\n    return res;\n  }\n\n  while (--digits > 0) {\n    if ((res = mp_lshd (a, 1)) != MP_OKAY) {\n      return res;\n    }\n\n    if ((res = mp_add_d (a, ((mp_digit) abs (rand ())), a)) != MP_OKAY) {\n      return res;\n    }\n  }\n\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_rand.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* b = |a| \n *\n * Simple function copies the input and fixes the sign to positive\n */\n", "func_signal": "int\nmp_abs (mp_int * a, mp_int * b)", "code": "{\n  int     res;\n\n  /* copy a to b */\n  if (a != b) {\n     if ((res = mp_copy (a, b)) != MP_OKAY) {\n       return res;\n     }\n  }\n\n  /* force the sign of b to positive */\n  b->sign = MP_ZPOS;\n\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_abs.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* this is a modified version of fast_s_mul_digs that only produces\n * output digits *above* digs.  See the comments for fast_s_mul_digs\n * to see how it works.\n *\n * This is used in the Barrett reduction since for one of the multiplications\n * only the higher digits were needed.  This essentially halves the work.\n *\n * Based on Algorithm 14.12 on pp.595 of HAC.\n */\n", "func_signal": "int fast_s_mp_mul_high_digs (mp_int * a, mp_int * b, mp_int * c, int digs)", "code": "{\n  int     olduse, res, pa, ix, iz;\n  mp_digit W[MP_WARRAY];\n  mp_word  _W;\n\n  /* grow the destination as required */\n  pa = a->used + b->used;\n  if (c->alloc < pa) {\n    if ((res = mp_grow (c, pa)) != MP_OKAY) {\n      return res;\n    }\n  }\n\n  /* number of output digits to produce */\n  pa = a->used + b->used;\n  _W = 0;\n  for (ix = digs; ix < pa; ix++) { \n      int      tx, ty, iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially its \n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += ((mp_word)*tmpx++)*((mp_word)*tmpy--);\n      }\n\n      /* store term */\n      W[ix] = ((mp_digit)_W) & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> ((mp_word)DIGIT_BIT);\n  }\n  \n  /* setup dest */\n  olduse  = c->used;\n  c->used = pa;\n\n  {\n    register mp_digit *tmpc;\n\n    tmpc = c->dp + digs;\n    for (ix = digs; ix < pa; ix++) {\n      /* now extract the previous digit [below the carry] */\n      *tmpc++ = W[ix];\n    }\n\n    /* clear unused digits [that existed in the old copy of c] */\n    for (; ix < olduse; ix++) {\n      *tmpc++ = 0;\n    }\n  }\n  mp_clamp (c);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_fast_s_mp_mul_high_digs.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* init an mp_init for a given size */\n", "func_signal": "int mp_init_size (mp_int * a, int size)", "code": "{\n  int x;\n\n  /* pad size so there are always extra digits */\n  size += (MP_PREC * 2) - (size % MP_PREC);\t\n  \n  /* alloc mem */\n  a->dp = OPT_CAST(mp_digit) XMALLOC (sizeof (mp_digit) * size);\n  if (a->dp == NULL) {\n    return MP_MEM;\n  }\n\n  /* set the members */\n  a->used  = 0;\n  a->alloc = size;\n  a->sign  = MP_ZPOS;\n\n  /* zero the digits */\n  for (x = 0; x < size; x++) {\n      a->dp[x] = 0;\n  }\n\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_init_size.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* reads a unsigned char array, assumes the msb is stored first [big endian] */\n", "func_signal": "int mp_read_unsigned_bin (mp_int * a, const unsigned char *b, int c)", "code": "{\n  int     res;\n\n  /* make sure there are at least two digits */\n  if (a->alloc < 2) {\n     if ((res = mp_grow(a, 2)) != MP_OKAY) {\n        return res;\n     }\n  }\n\n  /* zero the int */\n  mp_zero (a);\n\n  /* read the bytes in */\n  while (c-- > 0) {\n    if ((res = mp_mul_2d (a, 8, a)) != MP_OKAY) {\n      return res;\n    }\n\n#ifndef MP_8BIT\n      a->dp[0] |= *b++;\n      a->used += 1;\n#else\n      a->dp[0] = (*b & MP_MASK);\n      a->dp[1] |= ((*b++ >> 7U) & 1);\n      a->used += 2;\n#endif\n  }\n  mp_clamp (a);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_read_unsigned_bin.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* Store non-zero to ret if arg is square, and zero if not */\n", "func_signal": "int mp_is_square(mp_int *arg,int *ret)", "code": "{\n  int           res;\n  mp_digit      c;\n  mp_int        t;\n  unsigned long r;\n\n  /* Default to Non-square :) */\n  *ret = MP_NO; \n\n  if (arg->sign == MP_NEG) {\n    return MP_VAL;\n  }\n\n  /* digits used?  (TSD) */\n  if (arg->used == 0) {\n     return MP_OKAY;\n  }\n\n  /* First check mod 128 (suppose that DIGIT_BIT is at least 7) */\n  if (rem_128[127 & DIGIT(arg,0)] == 1) {\n     return MP_OKAY;\n  }\n\n  /* Next check mod 105 (3*5*7) */\n  if ((res = mp_mod_d(arg,105,&c)) != MP_OKAY) {\n     return res;\n  }\n  if (rem_105[c] == 1) {\n     return MP_OKAY;\n  }\n\n\n  if ((res = mp_init_set_int(&t,11L*13L*17L*19L*23L*29L*31L)) != MP_OKAY) {\n     return res;\n  }\n  if ((res = mp_mod(arg,&t,&t)) != MP_OKAY) {\n     goto ERR;\n  }\n  r = mp_get_int(&t);\n  /* Check for other prime modules, note it's not an ERROR but we must\n   * free \"t\" so the easiest way is to goto ERR.  We know that res\n   * is already equal to MP_OKAY from the mp_mod call \n   */ \n  if ( (1L<<(r%11)) & 0x5C4L )             goto ERR;\n  if ( (1L<<(r%13)) & 0x9E4L )             goto ERR;\n  if ( (1L<<(r%17)) & 0x5CE8L )            goto ERR;\n  if ( (1L<<(r%19)) & 0x4F50CL )           goto ERR;\n  if ( (1L<<(r%23)) & 0x7ACCA0L )          goto ERR;\n  if ( (1L<<(r%29)) & 0xC2EDD0CL )         goto ERR;\n  if ( (1L<<(r%31)) & 0x6DE2B848L )        goto ERR;\n\n  /* Final check - is sqr(sqrt(arg)) == arg ? */\n  if ((res = mp_sqrt(arg,&t)) != MP_OKAY) {\n     goto ERR;\n  }\n  if ((res = mp_sqr(&t,&t)) != MP_OKAY) {\n     goto ERR;\n  }\n\n  *ret = (mp_cmp_mag(&t,arg) == MP_EQ) ? MP_YES : MP_NO;\nERR:mp_clear(&t);\n  return res;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_is_square.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* find the n'th root of an integer \n *\n * Result found such that (c)**b <= a and (c+1)**b > a \n *\n * This algorithm uses Newton's approximation \n * x[i+1] = x[i] - f(x[i])/f'(x[i]) \n * which will find the root in log(N) time where \n * each step involves a fair bit.  This is not meant to \n * find huge roots [square and cube, etc].\n */\n", "func_signal": "int mp_n_root (mp_int * a, mp_digit b, mp_int * c)", "code": "{\n  mp_int  t1, t2, t3;\n  int     res, neg;\n\n  /* input must be positive if b is even */\n  if ((b & 1) == 0 && a->sign == MP_NEG) {\n    return MP_VAL;\n  }\n\n  if ((res = mp_init (&t1)) != MP_OKAY) {\n    return res;\n  }\n\n  if ((res = mp_init (&t2)) != MP_OKAY) {\n    goto LBL_T1;\n  }\n\n  if ((res = mp_init (&t3)) != MP_OKAY) {\n    goto LBL_T2;\n  }\n\n  /* if a is negative fudge the sign but keep track */\n  neg     = a->sign;\n  a->sign = MP_ZPOS;\n\n  /* t2 = 2 */\n  mp_set (&t2, 2);\n\n  do {\n    /* t1 = t2 */\n    if ((res = mp_copy (&t2, &t1)) != MP_OKAY) {\n      goto LBL_T3;\n    }\n\n    /* t2 = t1 - ((t1**b - a) / (b * t1**(b-1))) */\n    \n    /* t3 = t1**(b-1) */\n    if ((res = mp_expt_d (&t1, b - 1, &t3)) != MP_OKAY) {   \n      goto LBL_T3;\n    }\n\n    /* numerator */\n    /* t2 = t1**b */\n    if ((res = mp_mul (&t3, &t1, &t2)) != MP_OKAY) {    \n      goto LBL_T3;\n    }\n\n    /* t2 = t1**b - a */\n    if ((res = mp_sub (&t2, a, &t2)) != MP_OKAY) {  \n      goto LBL_T3;\n    }\n\n    /* denominator */\n    /* t3 = t1**(b-1) * b  */\n    if ((res = mp_mul_d (&t3, b, &t3)) != MP_OKAY) {    \n      goto LBL_T3;\n    }\n\n    /* t3 = (t1**b - a)/(b * t1**(b-1)) */\n    if ((res = mp_div (&t2, &t3, &t3, NULL)) != MP_OKAY) {  \n      goto LBL_T3;\n    }\n\n    if ((res = mp_sub (&t1, &t3, &t2)) != MP_OKAY) {\n      goto LBL_T3;\n    }\n  }  while (mp_cmp (&t1, &t2) != MP_EQ);\n\n  /* result can be off by a few so check */\n  for (;;) {\n    if ((res = mp_expt_d (&t1, b, &t2)) != MP_OKAY) {\n      goto LBL_T3;\n    }\n\n    if (mp_cmp (&t2, a) == MP_GT) {\n      if ((res = mp_sub_d (&t1, 1, &t1)) != MP_OKAY) {\n         goto LBL_T3;\n      }\n    } else {\n      break;\n    }\n  }\n\n  /* reset the sign of a first */\n  a->sign = neg;\n\n  /* set the result */\n  mp_exch (&t1, c);\n\n  /* set the sign of the result */\n  c->sign = neg;\n\n  res = MP_OKAY;\n\nLBL_T3:mp_clear (&t3);\nLBL_T2:mp_clear (&t2);\nLBL_T1:mp_clear (&t1);\n  return res;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_n_root.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* low level subtraction (assumes |a| > |b|), HAC pp.595 Algorithm 14.9 */\n", "func_signal": "int\ns_mp_sub (mp_int * a, mp_int * b, mp_int * c)", "code": "{\n  int     olduse, res, min, max;\n\n  /* find sizes */\n  min = b->used;\n  max = a->used;\n\n  /* init result */\n  if (c->alloc < max) {\n    if ((res = mp_grow (c, max)) != MP_OKAY) {\n      return res;\n    }\n  }\n  olduse = c->used;\n  c->used = max;\n\n  {\n    register mp_digit u, *tmpa, *tmpb, *tmpc;\n    register int i;\n\n    /* alias for digit pointers */\n    tmpa = a->dp;\n    tmpb = b->dp;\n    tmpc = c->dp;\n\n    /* set carry to zero */\n    u = 0;\n    for (i = 0; i < min; i++) {\n      /* T[i] = A[i] - B[i] - U */\n      *tmpc = *tmpa++ - *tmpb++ - u;\n\n      /* U = carry bit of T[i]\n       * Note this saves performing an AND operation since\n       * if a carry does occur it will propagate all the way to the\n       * MSB.  As a result a single shift is enough to get the carry\n       */\n      u = *tmpc >> ((mp_digit)(CHAR_BIT * sizeof (mp_digit) - 1));\n\n      /* Clear carry from T[i] */\n      *tmpc++ &= MP_MASK;\n    }\n\n    /* now copy higher words if any, e.g. if A has more digits than B  */\n    for (; i < max; i++) {\n      /* T[i] = A[i] - U */\n      *tmpc = *tmpa++ - u;\n\n      /* U = carry bit of T[i] */\n      u = *tmpc >> ((mp_digit)(CHAR_BIT * sizeof (mp_digit) - 1));\n\n      /* Clear carry from T[i] */\n      *tmpc++ &= MP_MASK;\n    }\n\n    /* clear digits above used (since we may not have grown result above) */\n    for (i = c->used; i < olduse; i++) {\n      *tmpc++ = 0;\n    }\n  }\n\n  mp_clamp (c);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_s_mp_sub.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* high level subtraction (handles signs) */\n", "func_signal": "int\nmp_sub (mp_int * a, mp_int * b, mp_int * c)", "code": "{\n  int     sa, sb, res;\n\n  sa = a->sign;\n  sb = b->sign;\n\n  if (sa != sb) {\n    /* subtract a negative from a positive, OR */\n    /* subtract a positive from a negative. */\n    /* In either case, ADD their magnitudes, */\n    /* and use the sign of the first number. */\n    c->sign = sa;\n    res = s_mp_add (a, b, c);\n  } else {\n    /* subtract a positive from a positive, OR */\n    /* subtract a negative from a negative. */\n    /* First, take the difference between their */\n    /* magnitudes, then... */\n    if (mp_cmp_mag (a, b) != MP_LT) {\n      /* Copy the sign from the first */\n      c->sign = sa;\n      /* The first has a larger or equal magnitude */\n      res = s_mp_sub (a, b, c);\n    } else {\n      /* The result has the *opposite* sign from */\n      /* the first number. */\n      c->sign = (sa == MP_ZPOS) ? MP_NEG : MP_ZPOS;\n      /* The second has a larger magnitude */\n      res = s_mp_sub (b, a, c);\n    }\n  }\n  return res;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_sub.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* the jist of squaring...\n * you do like mult except the offset of the tmpx [one that \n * starts closer to zero] can't equal the offset of tmpy.  \n * So basically you set up iy like before then you min it with\n * (ty-tx) so that it never happens.  You double all those \n * you add in the inner loop\n\nAfter that loop you do the squares and add them in.\n*/\n", "func_signal": "int fast_s_mp_sqr (mp_int * a, mp_int * b)", "code": "{\n  int       olduse, res, pa, ix, iz;\n  mp_digit   W[MP_WARRAY], *tmpx;\n  mp_word   W1;\n\n  /* grow the destination as required */\n  pa = a->used + a->used;\n  if (b->alloc < pa) {\n    if ((res = mp_grow (b, pa)) != MP_OKAY) {\n      return res;\n    }\n  }\n\n  /* number of output digits to produce */\n  W1 = 0;\n  for (ix = 0; ix < pa; ix++) { \n      int      tx, ty, iy;\n      mp_word  _W;\n      mp_digit *tmpy;\n\n      /* clear counter */\n      _W = 0;\n\n      /* get offsets into the two bignums */\n      ty = MIN(a->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = a->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MIN(a->used-tx, ty+1);\n\n      /* now for squaring tx can never equal ty \n       * we halve the distance since they approach at a rate of 2x\n       * and we have to round because odd cases need to be executed\n       */\n      iy = MIN(iy, (ty-tx+1)>>1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += ((mp_word)*tmpx++)*((mp_word)*tmpy--);\n      }\n\n      /* double the inner product and add carry */\n      _W = _W + _W + W1;\n\n      /* even columns have the square term in them */\n      if ((ix&1) == 0) {\n         _W += ((mp_word)a->dp[ix>>1])*((mp_word)a->dp[ix>>1]);\n      }\n\n      /* store it */\n      W[ix] = (mp_digit)(_W & MP_MASK);\n\n      /* make next carry */\n      W1 = _W >> ((mp_word)DIGIT_BIT);\n  }\n\n  /* setup dest */\n  olduse  = b->used;\n  b->used = a->used+a->used;\n\n  {\n    mp_digit *tmpb;\n    tmpb = b->dp;\n    for (ix = 0; ix < pa; ix++) {\n      *tmpb++ = W[ix] & MP_MASK;\n    }\n\n    /* clear unused digits [that existed in the old copy of c] */\n    for (; ix < olduse; ix++) {\n      *tmpb++ = 0;\n    }\n  }\n  mp_clamp (b);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_fast_s_mp_sqr.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* shift left by a certain bit count */\n", "func_signal": "int mp_mul_2d (mp_int * a, int b, mp_int * c)", "code": "{\n  mp_digit d;\n  int      res;\n\n  /* copy */\n  if (a != c) {\n     if ((res = mp_copy (a, c)) != MP_OKAY) {\n       return res;\n     }\n  }\n\n  if (c->alloc < (int)(c->used + b/DIGIT_BIT + 1)) {\n     if ((res = mp_grow (c, c->used + b / DIGIT_BIT + 1)) != MP_OKAY) {\n       return res;\n     }\n  }\n\n  /* shift by as many digits in the bit count */\n  if (b >= (int)DIGIT_BIT) {\n    if ((res = mp_lshd (c, b / DIGIT_BIT)) != MP_OKAY) {\n      return res;\n    }\n  }\n\n  /* shift any bit count < DIGIT_BIT */\n  d = (mp_digit) (b % DIGIT_BIT);\n  if (d != 0) {\n    register mp_digit *tmpc, shift, mask, r, rr;\n    register int x;\n\n    /* bitmask for carries */\n    mask = (((mp_digit)1) << d) - 1;\n\n    /* shift for msbs */\n    shift = DIGIT_BIT - d;\n\n    /* alias */\n    tmpc = c->dp;\n\n    /* carry */\n    r    = 0;\n    for (x = 0; x < c->used; x++) {\n      /* get the higher bits of the current word */\n      rr = (*tmpc >> shift) & mask;\n\n      /* shift the current word and OR in the carry */\n      *tmpc = ((*tmpc << d) | r) & MP_MASK;\n      ++tmpc;\n\n      /* set the carry to the carry bits of the current word */\n      r = rr;\n    }\n    \n    /* set final carry */\n    if (r != 0) {\n       c->dp[(c->used)++] = r;\n    }\n  }\n  mp_clamp (c);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_mul_2d.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* creates \"a\" then copies b into it */\n", "func_signal": "int mp_init_copy (mp_int * a, mp_int * b)", "code": "{\n  int     res;\n\n  if ((res = mp_init (a)) != MP_OKAY) {\n    return res;\n  }\n  return mp_copy (b, a);\n}", "path": "vendor\\libtommath-0.41\\bn_mp_init_copy.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* LibTomMath, multiple-precision integer library -- Tom St Denis\n *\n * LibTomMath is a library that provides multiple-precision\n * integer arithmetic as well as number theoretic functionality.\n *\n * The library was designed directly after the MPI library by\n * Michael Fromberger but has been written from scratch with\n * additional optimizations in place.\n *\n * The library is free for all purposes without any express\n * guarantee it works.\n *\n * Tom St Denis, tomstdenis@gmail.com, http://libtom.org\n */\n", "func_signal": "int mp_fwrite(mp_int *a, int radix, FILE *stream)", "code": "{\n   char *buf;\n   int err, len, x;\n   \n   if ((err = mp_radix_size(a, radix, &len)) != MP_OKAY) {\n      return err;\n   }\n\n   buf = OPT_CAST(char) XMALLOC (len);\n   if (buf == NULL) {\n      return MP_MEM;\n   }\n   \n   if ((err = mp_toradix(a, buf, radix)) != MP_OKAY) {\n      XFREE (buf);\n      return err;\n   }\n   \n   for (x = 0; x < len; x++) {\n       if (fputc(buf[x], stream) == EOF) {\n          XFREE (buf);\n          return MP_VAL;\n       }\n   }\n   \n   XFREE (buf);\n   return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_fwrite.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* Greatest Common Divisor using the binary method */\n", "func_signal": "int mp_gcd (mp_int * a, mp_int * b, mp_int * c)", "code": "{\n  mp_int  u, v;\n  int     k, u_lsb, v_lsb, res;\n\n  /* either zero than gcd is the largest */\n  if (mp_iszero (a) == MP_YES) {\n    return mp_abs (b, c);\n  }\n  if (mp_iszero (b) == MP_YES) {\n    return mp_abs (a, c);\n  }\n\n  /* get copies of a and b we can modify */\n  if ((res = mp_init_copy (&u, a)) != MP_OKAY) {\n    return res;\n  }\n\n  if ((res = mp_init_copy (&v, b)) != MP_OKAY) {\n    goto LBL_U;\n  }\n\n  /* must be positive for the remainder of the algorithm */\n  u.sign = v.sign = MP_ZPOS;\n\n  /* B1.  Find the common power of two for u and v */\n  u_lsb = mp_cnt_lsb(&u);\n  v_lsb = mp_cnt_lsb(&v);\n  k     = MIN(u_lsb, v_lsb);\n\n  if (k > 0) {\n     /* divide the power of two out */\n     if ((res = mp_div_2d(&u, k, &u, NULL)) != MP_OKAY) {\n        goto LBL_V;\n     }\n\n     if ((res = mp_div_2d(&v, k, &v, NULL)) != MP_OKAY) {\n        goto LBL_V;\n     }\n  }\n\n  /* divide any remaining factors of two out */\n  if (u_lsb != k) {\n     if ((res = mp_div_2d(&u, u_lsb - k, &u, NULL)) != MP_OKAY) {\n        goto LBL_V;\n     }\n  }\n\n  if (v_lsb != k) {\n     if ((res = mp_div_2d(&v, v_lsb - k, &v, NULL)) != MP_OKAY) {\n        goto LBL_V;\n     }\n  }\n\n  while (mp_iszero(&v) == 0) {\n     /* make sure v is the largest */\n     if (mp_cmp_mag(&u, &v) == MP_GT) {\n        /* swap u and v to make sure v is >= u */\n        mp_exch(&u, &v);\n     }\n     \n     /* subtract smallest from largest */\n     if ((res = s_mp_sub(&v, &u, &v)) != MP_OKAY) {\n        goto LBL_V;\n     }\n     \n     /* Divide out all factors of two */\n     if ((res = mp_div_2d(&v, mp_cnt_lsb(&v), &v, NULL)) != MP_OKAY) {\n        goto LBL_V;\n     } \n  } \n\n  /* multiply by 2**k which we divided out at the beginning */\n  if ((res = mp_mul_2d (&u, k, c)) != MP_OKAY) {\n     goto LBL_V;\n  }\n  c->sign = MP_ZPOS;\n  res = MP_OKAY;\nLBL_V:mp_clear (&u);\nLBL_U:mp_clear (&v);\n  return res;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_gcd.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* returns # of RM trials required for a given bit size */\n", "func_signal": "int mp_prime_rabin_miller_trials(int size)", "code": "{\n   int x;\n\n   for (x = 0; x < (int)(sizeof(sizes)/(sizeof(sizes[0]))); x++) {\n       if (sizes[x].k == size) {\n          return sizes[x].t;\n       } else if (sizes[x].k > size) {\n          return (x == 0) ? sizes[0].t : sizes[x - 1].t;\n       }\n   }\n   return sizes[x-1].t + 1;\n}", "path": "vendor\\libtommath-0.41\\bn_mp_prime_rabin_miller_trials.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* multiplies |a| * |b| and only computes upto digs digits of result\n * HAC pp. 595, Algorithm 14.12  Modified so you can control how \n * many digits of output are created.\n */\n", "func_signal": "int s_mp_mul_digs (mp_int * a, mp_int * b, mp_int * c, int digs)", "code": "{\n  mp_int  t;\n  int     res, pa, pb, ix, iy;\n  mp_digit u;\n  mp_word r;\n  mp_digit tmpx, *tmpt, *tmpy;\n\n  /* can we use the fast multiplier? */\n  if (((digs) < MP_WARRAY) &&\n      MIN (a->used, b->used) < \n          (1 << ((CHAR_BIT * sizeof (mp_word)) - (2 * DIGIT_BIT)))) {\n    return fast_s_mp_mul_digs (a, b, c, digs);\n  }\n\n  if ((res = mp_init_size (&t, digs)) != MP_OKAY) {\n    return res;\n  }\n  t.used = digs;\n\n  /* compute the digits of the product directly */\n  pa = a->used;\n  for (ix = 0; ix < pa; ix++) {\n    /* set the carry to zero */\n    u = 0;\n\n    /* limit ourselves to making digs digits of output */\n    pb = MIN (b->used, digs - ix);\n\n    /* setup some aliases */\n    /* copy of the digit from a used within the nested loop */\n    tmpx = a->dp[ix];\n    \n    /* an alias for the destination shifted ix places */\n    tmpt = t.dp + ix;\n    \n    /* an alias for the digits of b */\n    tmpy = b->dp;\n\n    /* compute the columns of the output and propagate the carry */\n    for (iy = 0; iy < pb; iy++) {\n      /* compute the column as a mp_word */\n      r       = ((mp_word)*tmpt) +\n                ((mp_word)tmpx) * ((mp_word)*tmpy++) +\n                ((mp_word) u);\n\n      /* the new column is the lower part of the result */\n      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));\n\n      /* get the carry word from the result */\n      u       = (mp_digit) (r >> ((mp_word) DIGIT_BIT));\n    }\n    /* set carry if it is placed below digs */\n    if (ix + iy < digs) {\n      *tmpt = u;\n    }\n  }\n\n  mp_clamp (&t);\n  mp_exch (&t, c);\n\n  mp_clear (&t);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_s_mp_mul_digs.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/* low level squaring, b = a*a, HAC pp.596-597, Algorithm 14.16 */\n", "func_signal": "int s_mp_sqr (mp_int * a, mp_int * b)", "code": "{\n  mp_int  t;\n  int     res, ix, iy, pa;\n  mp_word r;\n  mp_digit u, tmpx, *tmpt;\n\n  pa = a->used;\n  if ((res = mp_init_size (&t, 2*pa + 1)) != MP_OKAY) {\n    return res;\n  }\n\n  /* default used is maximum possible size */\n  t.used = 2*pa + 1;\n\n  for (ix = 0; ix < pa; ix++) {\n    /* first calculate the digit at 2*ix */\n    /* calculate double precision result */\n    r = ((mp_word) t.dp[2*ix]) +\n        ((mp_word)a->dp[ix])*((mp_word)a->dp[ix]);\n\n    /* store lower part in result */\n    t.dp[ix+ix] = (mp_digit) (r & ((mp_word) MP_MASK));\n\n    /* get the carry */\n    u           = (mp_digit)(r >> ((mp_word) DIGIT_BIT));\n\n    /* left hand side of A[ix] * A[iy] */\n    tmpx        = a->dp[ix];\n\n    /* alias for where to store the results */\n    tmpt        = t.dp + (2*ix + 1);\n    \n    for (iy = ix + 1; iy < pa; iy++) {\n      /* first calculate the product */\n      r       = ((mp_word)tmpx) * ((mp_word)a->dp[iy]);\n\n      /* now calculate the double precision result, note we use\n       * addition instead of *2 since it's easier to optimize\n       */\n      r       = ((mp_word) *tmpt) + r + r + ((mp_word) u);\n\n      /* store lower part */\n      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));\n\n      /* get carry */\n      u       = (mp_digit)(r >> ((mp_word) DIGIT_BIT));\n    }\n    /* propagate upwards */\n    while (u != ((mp_digit) 0)) {\n      r       = ((mp_word) *tmpt) + ((mp_word) u);\n      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));\n      u       = (mp_digit)(r >> ((mp_word) DIGIT_BIT));\n    }\n  }\n\n  mp_clamp (&t);\n  mp_exch (&t, b);\n  mp_clear (&t);\n  return MP_OKAY;\n}", "path": "vendor\\libtommath-0.41\\bn_s_mp_sqr.c", "repo_name": "copiousfreetime/ruby-libtommath", "stars": 3, "license": "bsd-3-clause", "language": "c", "size": 1024}
{"docstring": "/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\n", "func_signal": "static const char *generic_reader (lua_State *L, void *ud, size_t *size)", "code": "{\n  (void)ud;  /* to avoid warnings */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    *size = 0;\n    return NULL;\n  }\n  else if (lua_isstring(L, -1)) {\n    lua_replace(L, 3);  /* save string in a reserved stack slot */\n    return lua_tolstring(L, 3, size);\n  }\n  else luaL_error(L, \"reader function must return a string\");\n  return NULL;  /* to avoid warnings */\n}", "path": "src\\lua\\lbaselib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n * Loads the given filename and register it in OpenGL.  Returns the\n * representatio of OpenGL or -2 if loading failed.\n */\n", "func_signal": "GLint texturepoolLoadImage(char *filename)", "code": "{\n\tSDL_Surface *img = IMG_Load(filename);\n\tGLuint index;\n\tif (img == NULL)\n\t\treturn -2;\n\n\t/* TODO: Convert pixel data */\n\t\n\tglGenTextures(1, &index);\n\tglBindTexture(GL_TEXTURE_2D, index);\n\tswitch (glGetError()) {\n\tcase GL_INVALID_ENUM:\n\t\tprintf(\"Invalid enum\\n\");\n\t\tbreak;\n\tcase GL_INVALID_OPERATION:\n\t\tprintf(\"Invalid operation\\n\");\n\t\tbreak;\n\t} \t\n\t\n\tgluBuild2DMipmaps(GL_TEXTURE_2D, 3, img->w, img->h, GL_RGBA,\n\t\t\t  GL_UNSIGNED_BYTE, img->pixels);\n\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, \n\t\t\tGL_LINEAR_MIPMAP_LINEAR); \n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\treturn index;\n}", "path": "src\\texturepool.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* \n * Looks this texture is alreade loaded.  If not it will load and insert\n * it automatically. \n * Returns an integer which OpenGL represents as the texture\n */\n", "func_signal": "GLint texturepoolGet(char *filename)", "code": "{\n\tGLint tex = texturepoolSearch(filename);\n\treturn (tex < 0)? texturepoolInsert(filename): tex;\n}", "path": "src\\texturepool.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** The next function tells whether a key or value can be cleared from\n** a weak table. Non-collectable objects are never removed from weak\n** tables. Strings behave as `values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for userdata\n** being finalized, keep them in keys, but not in values\n*/\n", "func_signal": "static int iscleared (const TValue *o, int iskey)", "code": "{\n  if (!iscollectable(o)) return 0;\n  if (ttisstring(o)) {\n    stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */\n    return 0;\n  }\n  return iswhite(gcvalue(o)) ||\n    (ttisuserdata(o) && (!iskey && isfinalized(uvalue(o))));\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* only ANSI way to check whether a pointer points to an array */\n", "func_signal": "static int isinstack (CallInfo *ci, const TValue *o)", "code": "{\n  StkId p;\n  for (p = ci->base; p < ci->top; p++)\n    if (o == p) return 1;\n  return 0;\n}", "path": "src\\lua\\ldebug.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* \n * Search in texturepool for the given filename.\n * Return the integer opengl represents as this texture or -1 if the file\n * is not loaded.\n */\n", "func_signal": "GLint texturepoolSearch(char *filename)", "code": "{\n\tTexturepoolElem *telem;\n\t\n\tfor (telem = texturepool; telem->filename != NULL; telem++)\n\t\tif (strcmp(telem->filename, filename) == 0)\n\t\t\treturn telem->index;\n\treturn -1;\n}", "path": "src\\texturepool.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** dump Lua function as precompiled chunk\n*/\n", "func_signal": "int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)", "code": "{\n DumpState D;\n D.L=L;\n D.writer=w;\n D.data=data;\n D.strip=strip;\n D.status=0;\n DumpHeader(&D);\n DumpFunction(f,NULL,&D);\n return D.status;\n}", "path": "src\\lua\\ldump.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void auxopen (lua_State *L, const char *name,\n                     lua_CFunction f, lua_CFunction u)", "code": "{\n  lua_pushcfunction(L, u);\n  lua_pushcclosure(L, f, 1);\n  lua_setfield(L, -2, name);\n}", "path": "src\\lua\\lbaselib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** Call all GC tag methods\n*/\n", "func_signal": "void luaC_callGCTM (lua_State *L)", "code": "{\n  while (G(L)->tmudata)\n    GCTM(L);\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n * Insert a texture file into the texturepool.\n * Return the representation of OpenGL.\n */\n", "func_signal": "GLint texturepoolInsert(char *filename)", "code": "{\n\tGLint index = texturepoolLoadImage(filename);\n\ttexturepool[entries].filename = filename;\n\ttexturepool[entries].index = index;\n\tentries++;\n\ttexturepool[entries].filename = NULL;\n\treturn index;\n}", "path": "src\\texturepool.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\n", "func_signal": "static int gctm (lua_State *L)", "code": "{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}", "path": "src\\lua\\loadlib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** traverse one gray object, turning it to black.\n** Returns `quantity' traversed.\n*/\n", "func_signal": "static l_mem propagatemark (global_State *g)", "code": "{\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (o->gch.tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2h(o);\n      g->gray = h->gclist;\n      if (traversetable(g, h))  /* table is weak? */\n        black2gray(o);  /* keep it gray */\n      return sizeof(Table) + sizeof(TValue) * h->sizearray +\n                             sizeof(Node) * sizenode(h);\n    }\n    case LUA_TFUNCTION: {\n      Closure *cl = gco2cl(o);\n      g->gray = cl->c.gclist;\n      traverseclosure(g, cl);\n      return (cl->c.isC) ? sizeCclosure(cl->c.nupvalues) :\n                           sizeLclosure(cl->l.nupvalues);\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;\n      th->gclist = g->grayagain;\n      g->grayagain = o;\n      black2gray(o);\n      traversestack(g, th);\n      return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n                                 sizeof(CallInfo) * th->size_ci;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;\n      traverseproto(g, p);\n      return sizeof(Proto) + sizeof(Instruction) * p->sizecode +\n                             sizeof(Proto *) * p->sizep +\n                             sizeof(TValue) * p->sizek + \n                             sizeof(int) * p->sizelineinfo +\n                             sizeof(LocVar) * p->sizelocvars +\n                             sizeof(TString *) * p->sizeupvalues;\n    }\n    default: lua_assert(0); return 0;\n  }\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_ref (lua_State *L, int t)", "code": "{\n  int ref;\n  t = abs_index(L, t);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* `nil' has a unique fixed reference */\n  }\n  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */\n  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */\n  lua_pop(L, 1);  /* remove it from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */\n  }\n  else {  /* no free elements */\n    ref = (int)lua_objlen(L, t);\n    ref++;  /* create new reference */\n  }\n  lua_rawseti(L, t, ref);\n  return ref;\n}", "path": "src\\lua\\lauxlib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,\n                                 const char *const lst[])", "code": "{\n  const char *name = (def) ? luaL_optstring(L, narg, def) :\n                             luaL_checkstring(L, narg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, narg,\n                       lua_pushfstring(L, \"invalid option \" LUA_QS, name));\n}", "path": "src\\lua\\lauxlib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** clear collected entries from weaktables\n*/\n", "func_signal": "static void cleartable (GCObject *l)", "code": "{\n  while (l) {\n    Table *h = gco2h(l);\n    int i = h->sizearray;\n    lua_assert(testbit(h->marked, VALUEWEAKBIT) ||\n               testbit(h->marked, KEYWEAKBIT));\n    if (testbit(h->marked, VALUEWEAKBIT)) {\n      while (i--) {\n        TValue *o = &h->array[i];\n        if (iscleared(o, 0))  /* value was collected? */\n          setnilvalue(o);  /* remove value */\n      }\n    }\n    i = sizenode(h);\n    while (i--) {\n      Node *n = gnode(h, i);\n      if (!ttisnil(gval(n)) &&  /* non-empty entry? */\n          (iscleared(key2tval(n), 1) || iscleared(gval(n), 0))) {\n        setnilvalue(gval(n));  /* remove value ... */\n        removeentry(n);  /* remove entry from table */\n      }\n    }\n    l = h->gclist;\n  }\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n** All marks are conditional because a GC may happen while the\n** prototype is still being created\n*/\n", "func_signal": "static void traverseproto (global_State *g, Proto *f)", "code": "{\n  int i;\n  if (f->source) stringmark(f->source);\n  for (i=0; i<f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i=0; i<f->sizeupvalues; i++) {  /* mark upvalue names */\n    if (f->upvalues[i])\n      stringmark(f->upvalues[i]);\n  }\n  for (i=0; i<f->sizep; i++) {  /* mark nested protos */\n    if (f->p[i])\n      markobject(g, f->p[i]);\n  }\n  for (i=0; i<f->sizelocvars; i++) {  /* mark local-variable names */\n    if (f->locvars[i].varname)\n      stringmark(f->locvars[i].varname);\n  }\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* mark root set */\n", "func_signal": "static void markroot (lua_State *L)", "code": "{\n  global_State *g = G(L);\n  g->gray = NULL;\n  g->grayagain = NULL;\n  g->weak = NULL;\n  markobject(g, g->mainthread);\n  /* make global table be traversed before main stack */\n  markvalue(g, gt(g->mainthread));\n  markvalue(g, registry(L));\n  markmt(g);\n  g->gcstate = GCSpropagate;\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* move `dead' udata that need finalization to list `tmudata' */\n", "func_signal": "size_t luaC_separateudata (lua_State *L, int all)", "code": "{\n  global_State *g = G(L);\n  size_t deadmem = 0;\n  GCObject **p = &g->mainthread->next;\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    if (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))\n      p = &curr->gch.next;  /* don't bother with them */\n    else if (fasttm(L, gco2u(curr)->metatable, TM_GC) == NULL) {\n      markfinalized(gco2u(curr));  /* don't need finalization */\n      p = &curr->gch.next;\n    }\n    else {  /* must call its gc method */\n      deadmem += sizeudata(gco2u(curr));\n      markfinalized(gco2u(curr));\n      *p = curr->gch.next;\n      /* link `curr' at the end of `tmudata' list */\n      if (g->tmudata == NULL)  /* list is empty? */\n        g->tmudata = curr->gch.next = curr;  /* creates a circular list */\n      else {\n        curr->gch.next = g->tmudata->gch.next;\n        g->tmudata->gch.next = curr;\n        g->tmudata = curr;\n      }\n    }\n  }\n  return deadmem;\n}", "path": "src\\lua\\lgc.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize)", "code": "{\n  (void)ud;\n  (void)osize;\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}", "path": "src\\lua\\lauxlib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,\n                                                               const char *r)", "code": "{\n  const char *wild;\n  size_t l = strlen(p);\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(&b, s, wild - s);  /* push prefix */\n    luaL_addstring(&b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after `p' */\n  }\n  luaL_addstring(&b, s);  /* push last suffix */\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}", "path": "src\\lua\\lauxlib.c", "repo_name": "neosam/lisp3d", "stars": 2, "license": "None", "language": "c", "size": 300}
{"docstring": "/*\n * Processes the player position and determines if any percepts fire.\n * This checks the map given the player's current position and sets all flags\n * as appropriate. The only flag not set is the PERCEPT_BUMP flag which _must_\n * be set by the action_move() function since the player cannot occupy the\n * same square as the wall.\n */\n", "func_signal": "void process_percepts()", "code": "{\n  int x = game.x, y = game.y, flags = 0;\n  char north = game.map[x][y - 1], south = game.map[x][y + 1];\n  char east = game.map[x + 1][y], west = game.map[x - 1][y];\n  \n  /* the move function sets this percept */\n  int bumped = game.percepts & PERCEPT_BUMP;\n  if(bumped)\n    flags |= PERCEPT_BUMP;\n  /* see if the player is dead, first */\n  if(game.map[x][y] == MAP_PIT || game.map[x][y] == MAP_WUMPUS ||\n     (game.map[x][y] == MAP_SUPMUW && game.supmuw_neighbors_wumpus))\n  {\n    flags |= PERCEPT_DEAD;\n    add_score(SCORE_DEATH);\n    if(game.map[x][y] == MAP_PIT)\n      printf(\"You have fallen into a pit!\\n\");\n    else\n      printf(\"You have been consumed by the beast!\\n\");\n  }\n  if(north == MAP_WUMPUS ||\n     south == MAP_WUMPUS ||\n     east == MAP_WUMPUS ||\n     west == MAP_WUMPUS)\n    flags |= PERCEPT_SMELL;\n  if(north == MAP_PIT ||\n     south == MAP_PIT ||\n     east == MAP_PIT ||\n     west == MAP_PIT)\n    flags |= PERCEPT_BREEZE;\n  if(north == MAP_SUPMUW ||\n     south == MAP_SUPMUW ||\n     east == MAP_SUPMUW ||\n     west == MAP_SUPMUW)\n    flags |= PERCEPT_MOO;\n  if(game.map[x][y] == MAP_GOLD)\n    flags |= PERCEPT_GLITTER;\n  if(flags & PERCEPT_MOO && game.supmuw_neighbors_wumpus)\n    flags |= PERCEPT_SMELL;\n  game.percepts = flags;\n  if(game.use_agent)\n    kb_tell();\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* shoots arrows. requires a direction */\n", "func_signal": "void action_shoot(int direction)", "code": "{\n  int x2 = game.x, y2 = game.y;\n\n  if(!game.arrows)\n  {\n    printf(\"You are out of arrows!\\n\");\n    return;\n  }\n  \n  printf(\"Shooting %s\\n\", delta_coordinates(&x2, &y2, direction));\n  add_score(SCORE_SHOOT);\n  game.arrows--;\n  if(game.map[x2][y2] == MAP_WUMPUS || game.map[x2][y2] == MAP_SUPMUW)\n  {\n    add_score(SCORE_KILL);\n    printf(\"You hear a deafening scream as you slay the beast.\\n\");\n    game.map[x2][y2] = MAP_EMPTY;\n    /* regardless of who you kill, the supmuw does not neighbor wumpus */\n    game.supmuw_neighbors_wumpus = 0;\n\n    /* tell the agent that the thing was killed */    \n    if(game.use_agent)\n    {\n      /* only one of these will be removed */\n      kb_delete(PERCEPT_WUMPUS, x2, y2);\n      kb_delete(PERCEPT_SUPMUW, x2, y2);\n      /* remove the smells, too */\n      kb_delete(PERCEPT_SMELL, x2 - 1, y2);\n      kb_delete(PERCEPT_SMELL, x2 + 1, y2);\n      kb_delete(PERCEPT_SMELL, x2, y2 - 1);\n      kb_delete(PERCEPT_SMELL, x2, y2 + 1);\n    }\n  }\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* get user defined inputs */\n", "func_signal": "void user_input()", "code": "{\n  char choice;\n  printf(\"Enter a Command (?): \");\n  scanf(\"%1s\", &choice);\n  process_player_command(choice);\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/*\n * sets a bee-line destination for the agent to navigate to this point.\n * I use destinations to force the agent to explore more of the map. It is the\n * sai-yu-sanji-kuyah (top priority) next to gold. You set a destination and the\n * agent goes there. Because i always require a coordinate in the KB for each\n * percept saved, i use (0, 0) as the coordinate in the database and keep the\n * real coordinates in the WUMPLUS struct. This simplifies many things about\n * the SQL code and prevents me from having to write another function just to\n * pull the two coordinates out.\n */\n", "func_signal": "void set_destination(int x, int y)", "code": "{\n  kb_insert(PERCEPT_DESTINATION, 0, 0);\n  game.dest_x = x;\n  game.dest_y = y;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* quits the game and returns to the OS */\n", "func_signal": "void action_quit()", "code": "{\n  printf(\"\\nFinal Analysis of gameplay\\n\");\n  /* show the final map */\n  print_map();\n  /* show the final set of percepts */\n  print_percepts();\n  \n  /* one last chance to make fun of the player */\n  if(has_lost())\n    printf(\"Apparently you are not a winner. That would make you a loser.\\n\");\n  if(player_dead())\n    printf(\"You have died. Indiana Jones would be ashamed.\\n\");\n  if(has_won())\n    printf(\"You have won, the plantation is saved. Glory! Glory!\\n\");\n  \n  /* final score */\n  print_score();\n  \n  /* cleanup for agent */\n  if(game.use_agent)\n  {\n    /* dumps the contents of the knowledge base to stderr */\n    kb_dump();\n    kb_close();\n  }\n  exit(0);\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* Intialize map with randomly placed obstackles */\n", "func_signal": "void init_game()", "code": "{\n  int i, j, num_pits, num_walls, x, y;\n  \n  /* flag for determining if the supmuw is next to the wumpus. */\n  game.supmuw_neighbors_wumpus = 0;\n  \n  /* First create a Clean Slate */\n  for(j = 0; j < MAP_SIZE; j++)\n    for(i = 0; i < MAP_SIZE; i++)\n      game.map[i][j] = MAP_EMPTY;\n  \n  /* Place player at (1,1) */\n  game.x = 1;\n  game.y = 1;\n  game.has_food = 0;\n  game.has_gold = 0;\n  game.arrows = 1;\n  game.percepts = 0;\n  game.score = 0;\n  game.steps_taken = 0;\n  game.dest_x = -1;\n  game.dest_y = -1;\n  \n  /* Create walls around perimeter of map. one loop. figure it out. */\n  for(i = 0; i < MAP_SIZE; i++)\n  {\n    game.map[i][0] = MAP_WALL;\n    game.map[i][MAP_SIZE - 1] = MAP_WALL;\n    game.map[0][i] = MAP_WALL;\n    game.map[MAP_SIZE - 1][i] = MAP_WALL;\n  }\n  \n  /* I maximize the number of pits to be 15% the size of the map */\n  num_pits = (rand() % (int)(MAP_SIZE * MAP_SIZE * .15)) + 1;\n  for(i = 0; i < num_pits; i++)\n  {\n    random_map_x_y(&x, &y);\n    game.map[x][y] = MAP_PIT;\n  }\n  \n  /* set up the interior walls in random locations. max 10% of mapsize */\n  num_walls = (rand() % (int)(MAP_SIZE * MAP_SIZE * .10)) + 1;\n  for(i = 0; i < num_walls; i++)\n  {\n    random_map_x_y(&x, &y);\n    game.map[x][y] = MAP_WALL;\n  }\n  \n  /* Create Wumpus at Random Location */\n  random_map_x_y(&x, &y);\n  game.map[x][y] = MAP_WUMPUS;\n  \n  /* Randomly place a pot - o - gold */\n  random_map_x_y(&x, &y);\n  game.map[x][y] = MAP_GOLD;\n  \n  /* Place the Supmuw (wumpus cousin) */\n  random_map_x_y(&x, &y);\n  game.map[x][y] = MAP_SUPMUW;\n  /* check to see if the supmuw neighbors the wumpus, used for percepts */\n  if(game.map[x][y + 1] == MAP_WUMPUS ||\n     game.map[x][y - 1] == MAP_WUMPUS ||\n     game.map[x + 1][y] == MAP_WUMPUS ||\n     game.map[x - 1][y] == MAP_WUMPUS)\n  {\n    game.supmuw_neighbors_wumpus = 1;\n  }\n  \n  /* set up the database for the KB */\n  if(game.use_agent)\n  {\n    kb_init();\n    /* let the kb know about the outside walls. */\n    for(i = 0; i < MAP_SIZE; i++)\n    {\n      kb_insert(PERCEPT_BUMP, i, 0);\n      kb_insert(PERCEPT_BUMP, i, MAP_SIZE - 1);\n      kb_insert(PERCEPT_BUMP, 0, i);\n      kb_insert(PERCEPT_BUMP, MAP_SIZE - 1, i);\n    }\n  }\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* removes a statement from the database */\n", "func_signal": "void kb_delete(int sentence, int x, int y)", "code": "{\n  int res = 0;\n  char query[128], *err_msg;\n  if(!kb_found(sentence, x, y))\n    return;\n  \n  sprintf(query, \"DELETE FROM KB WHERE sentence = %d AND x = %d AND y = %d;\",\n    sentence, x, y);\n  res = sqlite3_exec(game.db, query, NULL, 0, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"KB_DELETE: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n  }\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* returns a direction to the requested square from the relative player pos. */\n", "func_signal": "char relative_direction(int x, int y)", "code": "{\n  if(x == game.x)\n    return (game.y < y ? 's' : 'n');\n  if(y == game.y)\n    return (game.x < x ? 'e' : 'w');\n  return 'q';\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* initialize the knowledge base. builds an sqlite3 RAM db and build tables */\n", "func_signal": "void kb_init()", "code": "{\n  char *err_msg;\n  int res = 0;\n  \n  /* make db */\n  res = sqlite3_open(\":memory:\", &game.db);\n  if(res)\n  {\n    fprintf(stderr, \"KB_INIT: %s\\n\",\n      sqlite3_errmsg(game.db));\n    sqlite3_close(game.db);\n    exit(1);\n  }\n  \n  /* create the knowledge base table */\n  res = sqlite3_exec(game.db,\n    /* no primary key, you get locking errors if you do... */\n    \"CREATE TABLE kb (sentence INT, x INT, y INT);\",\n    NULL, 0, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"KB_INIT: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n  \n  /* create the queue table */\n  res = sqlite3_exec(game.db,\n    \"CREATE TABLE queue (id INTEGER PRIMARY KEY, name VARCHAR, x INT, y INT);\",\n    NULL, 0, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"KB_INIT: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* private callback for printing out each row of the knowledge base */\n", "func_signal": "static int kb_dump_callback(void *x, int argc, char **argv, char **cols)", "code": "{\n  fprintf(stderr, \"%4d: %7s: (%2d, %2d)\\n\", *((int *)x),\n    (argv[0] ? word_from_percept(atoi(argv[0])) : \"NULL\"),\n    atoi(argv[1]), atoi(argv[2]));\n  *((int *)x) = *((int *)x) + 1;\n  return 0;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* private callback to check if the number of items in a queue is empty */\n", "func_signal": "static int queue_empty_callback(void *empty, int argc, char **argv, char **cols)", "code": "{\n  int result = atoi(argv[0]);\n  if(result > 0)\n    *((int *)empty) = 0;\n  return 0;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* Randomly places the coordinate pair to an empty spot in the map */\n", "func_signal": "void random_map_x_y(int *map_x, int *map_y)", "code": "{\n  int x = 0, y = 0;\n  do {\n    x = random_map_coordinate(); y = random_map_coordinate();\n  } while((x == 1 && y == 1) || game.map[x][y] != MAP_EMPTY);\n  *map_x = x; *map_y = y;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* private callback for dequeue to return the coordinate */\n", "func_signal": "static int dequeue_callback(void *coord, int argc, char **argv, char **cols)", "code": "{\n  coordinate *mycoord = (coordinate *)coord;\n  mycoord->x = atoi(argv[2]);\n  mycoord->y = atoi(argv[3]);\n  return 0;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* prints out the player's score */\n", "func_signal": "void print_score()", "code": "{\n  printf(\"Score: %5d\\tSteps Taken: %3d/%d\\n\", game.score, game.steps_taken,\n    MAP_MAXSTEPS);\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* finds a random unvisited safe square and sets the destination thusly */\n", "func_signal": "int has_unvisited_safe_squares()", "code": "{\n  int res = 0, found = 0;\n  char query[128], *err_msg;\n  \n  sprintf(query, \"SELECT * FROM kb WHERE sentence = %d ORDER BY random();\",\n    PERCEPT_SAFE);\n  res = sqlite3_exec(game.db, query, huss_callback, &found, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"HAS_UNVISITED_SAFE_SQUARES: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n  }\n  return found;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* prints help for a user */\n", "func_signal": "void print_help()", "code": "{\n  printf(\"Usable commands:\\n\");\n  printf(\" n,s,e,w    Move in direction given (also VI keybindings)\\n\");\n  printf(\" N,S,E,W    Shoot in direction given\\n\");\n  printf(\" g          Grab gold\\n\");\n  printf(\" q          Quit\\n\");\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/*\n * tell the knowledge base about your percepts. this is a lot like processing\n * the percepts, only now we are telling the kb about what we see using only\n * the percepts.\n */\n", "func_signal": "void kb_tell()", "code": "{\n  kb_insert(PERCEPT_VISITED, game.x, game.y);\n  if(!(game.percepts & PERCEPT_DEAD))\n    kb_insert(PERCEPT_SAFE, game.x, game.y);\n  if(game.percepts & PERCEPT_SMELL)\n    kb_insert(PERCEPT_SMELL, game.x, game.y);\n  if(game.percepts & PERCEPT_BREEZE)\n    kb_insert(PERCEPT_BREEZE, game.x, game.y);\n  if(game.percepts & PERCEPT_MOO)\n    kb_insert(PERCEPT_MOO, game.x, game.y);\n  if(game.percepts & PERCEPT_GLITTER)\n    kb_insert(PERCEPT_GLITTER, game.x, game.y);\n  if(!(game.percepts & PERCEPT_SMELL) &&\n     !(game.percepts & PERCEPT_BREEZE))\n  {\n    /*\n     * this is useful to expand the number of squares we can access after each\n     * move.\n     */\n    kb_insert(PERCEPT_SAFE, game.x - 1, game.y);\n    kb_insert(PERCEPT_SAFE, game.x + 1, game.y);\n    kb_insert(PERCEPT_SAFE, game.x, game.y - 1);\n    kb_insert(PERCEPT_SAFE, game.x, game.y + 1);\n  }\n  \n  /*\n   * now lets make some inferrances.\n   * this process is mostly the same, so just use the same function.\n   */\n  kb_inferrances(PERCEPT_SMELL, PERCEPT_WUMPUS);\n  kb_inferrances(PERCEPT_BREEZE, PERCEPT_PIT);\n  kb_inferrances(PERCEPT_MOO, PERCEPT_SUPMUW);\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/*\n * determines if two squares are neighbors.\n * returns a boolean if the delta between the two coordinates is one.\n */\n", "func_signal": "int neighbors(int x1, int y1, int x2, int y2)", "code": "{\n  int xd = abs(x2 - x1), yd = abs(y2 - y1);\n  if(xd > 1 || yd > 1 || xd + yd > 1 || xd + xd == 0)\n    return 0;\n  return 1;\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/*\n * check for something at each corner around where the player sits. This only\n * checks the diagonals around the player position. the general form to check\n * the squares immediately accessible to the player require three pieces of\n * information and only in the rarest of cases can you not determine this\n * otherwise. A specific situation is like this:\n *\n * ..P.\n * PPP.\n *\n * The agent does not seem to notice the middle P in the bottom row, but really\n * the agent will not maneuver to that square anyways. Not a big deal, really.\n *\n * This function requires the 'maybe' percept and the percept to tell the KB\n * that you 'found' the obstackle in question.\n */\n", "func_signal": "void kb_inferrances(int percept, int known)", "code": "{\n  if(!kb_found(percept, game.x, game.y))\n    return;\n  \n  /* check north west corner above player */\n  check_corner(percept, known, -1, -1);\n  \n  /* check north east corner above player */\n  check_corner(percept, known, 1, -1);\n  \n  /* check south west corner below player */\n  check_corner(percept, known, -1, 1);\n  \n  /* check south east corner below player */\n  check_corner(percept, known, 1, 1);\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/* removes an item from the queue and returns the values into *result */\n", "func_signal": "void queue_dequeue(const char *mylist, coordinate *result)", "code": "{\n  int res = 0;\n  char query[128], *err_msg;\n  \n  sprintf(query,\n    \"SELECT * FROM queue WHERE name = '%s' ORDER BY id ASC LIMIT 1;\",\n    mylist);\n  res = sqlite3_exec(game.db, query, dequeue_callback, result, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"QUEUE_DEQUEUE: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n  }\n  \n  sprintf(query,\n    \"DELETE FROM queue WHERE name = '%s' AND x = %d AND y = %d;\",\n    mylist, result->x, result->y);\n  res = sqlite3_exec(game.db, query, NULL, 0, &err_msg);\n  if(res != SQLITE_OK)\n  {\n    fprintf(stderr, \"QUEUE_DEQUEUE: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n  }\n}", "path": "wumpus.c", "repo_name": "penguincoder/wumpus-agent", "stars": 3, "license": "None", "language": "c", "size": 84}
{"docstring": "/**\n *\tata_port_abort - abort all qc's on the port\n *\t@ap: ATA port to abort qc's for\n *\n *\tAbort all active qc's of @ap and schedule EH.\n *\n *\tLOCKING:\n *\tspin_lock_irqsave(host lock)\n *\n *\tRETURNS:\n *\tNumber of aborted qc's.\n */\n", "func_signal": "int ata_port_abort(struct ata_port *ap)", "code": "{\n\tint tag, nr_aborted = 0;\n\n\tWARN_ON(!ap->ops->error_handler);\n\n\tfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\n\t\tstruct ata_queued_cmd *qc = ata_qc_from_tag(ap, tag);\n\n\t\tif (qc) {\n\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_aborted++;\n\t\t}\n\t}\n\n\tif (!nr_aborted)\n\t\tata_port_schedule_eh(ap);\n\n\treturn nr_aborted;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_speed_down - record error and speed down if necessary\n *\t@dev: Failed device\n *\t@is_io: Did the device fail during normal IO?\n *\t@err_mask: err_mask of the error\n *\n *\tRecord error and examine error history to determine whether\n *\tadjusting transmission speed is necessary.  It also sets\n *\ttransmission limits appropriately if such adjustment is\n *\tnecessary.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n *\n *\tRETURNS:\n *\t0 on success, -errno otherwise\n */\n", "func_signal": "static int ata_eh_speed_down(struct ata_device *dev, int is_io,\n\t\t\t     unsigned int err_mask)", "code": "{\n\tif (!err_mask)\n\t\treturn 0;\n\n\t/* record error and determine whether speed down is necessary */\n\tata_ering_record(&dev->ering, is_io, err_mask);\n\n\tif (!ata_eh_speed_down_needed(dev))\n\t\treturn 0;\n\n\t/* speed down SATA link speed if possible */\n\tif (sata_down_spd_limit(dev->ap) == 0)\n\t\treturn ATA_EH_HARDRESET;\n\n\t/* lower transfer mode */\n\tif (ata_down_xfermask_limit(dev, 0) == 0)\n\t\treturn ATA_EH_SOFTRESET;\n\n\tata_dev_printk(dev, KERN_ERR,\n\t\t       \"speed down requested but no transfer mode left\\n\");\n\treturn 0;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_handle_port_resume - perform port resume operation\n *\t@ap: port to resume\n *\n *\tResume @ap.\n *\n *\tThis function also waits upto one second until all devices\n *\thanging off this port requests resume EH action.  This is to\n *\tprevent invoking EH and thus reset multiple times on resume.\n *\n *\tOn DPM resume, where some of devices might not be resumed\n *\ttogether, this may delay port resume upto one second, but such\n *\tDPM resumes are rare and 1 sec delay isn't too bad.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n */\n", "func_signal": "static void ata_eh_handle_port_resume(struct ata_port *ap)", "code": "{\n\tunsigned long timeout;\n\tunsigned long flags;\n\tint i, rc = 0;\n\n\t/* are we resuming? */\n\tspin_lock_irqsave(ap->lock, flags);\n\tif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\n\t    ap->pm_mesg.event != PM_EVENT_ON) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t/* spurious? */\n\tif (!(ap->pflags & ATA_PFLAG_SUSPENDED))\n\t\tgoto done;\n\n\tif (ap->ops->port_resume)\n\t\trc = ap->ops->port_resume(ap);\n\n\t/* give devices time to request EH */\n\ttimeout = jiffies + HZ; /* 1s max */\n\twhile (1) {\n\t\tfor (i = 0; i < ATA_MAX_DEVICES; i++) {\n\t\t\tstruct ata_device *dev = &ap->device[i];\n\t\t\tunsigned int action = ata_eh_dev_action(dev);\n\n\t\t\tif ((dev->flags & ATA_DFLAG_SUSPENDED) &&\n\t\t\t    !(action & ATA_EH_RESUME))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ATA_MAX_DEVICES || time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n done:\n\tspin_lock_irqsave(ap->lock, flags);\n\tap->pflags &= ~(ATA_PFLAG_PM_PENDING | ATA_PFLAG_SUSPENDED);\n\tif (ap->pm_result) {\n\t\t*ap->pm_result = rc;\n\t\tap->pm_result = NULL;\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_speed_down_needed - Determine wheter speed down is necessary\n *\t@dev: Device of interest\n *\n *\tThis function examines error ring of @dev and determines\n *\twhether speed down is necessary.  Speed down is necessary if\n *\tthere have been more than 3 of Cat-1 errors or 10 of Cat-2\n *\terrors during last 15 minutes.\n *\n *\tCat-1 errors are ATA_BUS, TIMEOUT for any command and HSM\n *\tviolation for known supported commands.\n *\n *\tCat-2 errors are unclassified DEV error for known supported\n *\tcommand.\n *\n *\tLOCKING:\n *\tInherited from caller.\n *\n *\tRETURNS:\n *\t1 if speed down is necessary, 0 otherwise\n */\n", "func_signal": "static int ata_eh_speed_down_needed(struct ata_device *dev)", "code": "{\n\tconst u64 interval = 15LLU * 60 * HZ;\n\tstatic const int err_limits[3] = { -1, 3, 10 };\n\tstruct speed_down_needed_arg arg;\n\tstruct ata_ering_entry *ent;\n\tint err_cat;\n\tu64 j64;\n\n\tent = ata_ering_top(&dev->ering);\n\tif (!ent)\n\t\treturn 0;\n\n\terr_cat = ata_eh_categorize_ering_entry(ent);\n\tif (err_cat == 0)\n\t\treturn 0;\n\n\tmemset(&arg, 0, sizeof(arg));\n\n\tj64 = get_jiffies_64();\n\tif (j64 >= interval)\n\t\targ.since = j64 - interval;\n\telse\n\t\targ.since = 0;\n\n\tata_ering_map(&dev->ering, speed_down_needed_cb, &arg);\n\n\treturn arg.nr_errors[err_cat] > err_limits[err_cat];\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_port_freeze - abort & freeze port\n *\t@ap: ATA port to freeze\n *\n *\tAbort and freeze @ap.\n *\n *\tLOCKING:\n *\tspin_lock_irqsave(host lock)\n *\n *\tRETURNS:\n *\tNumber of aborted commands.\n */\n", "func_signal": "int ata_port_freeze(struct ata_port *ap)", "code": "{\n\tint nr_aborted;\n\n\tWARN_ON(!ap->ops->error_handler);\n\n\tnr_aborted = ata_port_abort(ap);\n\t__ata_port_freeze(ap);\n\n\treturn nr_aborted;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_read_log_10h - Read log page 10h for NCQ error details\n *\t@dev: Device to read log page 10h from\n *\t@tag: Resulting tag of the failed command\n *\t@tf: Resulting taskfile registers of the failed command\n *\n *\tRead log page 10h to obtain NCQ error details and clear error\n *\tcondition.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n *\n *\tRETURNS:\n *\t0 on success, -errno otherwise.\n */\n", "func_signal": "static int ata_eh_read_log_10h(struct ata_device *dev,\n\t\t\t       int *tag, struct ata_taskfile *tf)", "code": "{\n\tu8 *buf = dev->ap->sector_buf;\n\tunsigned int err_mask;\n\tu8 csum;\n\tint i;\n\n\terr_mask = ata_read_log_page(dev, ATA_LOG_SATA_NCQ, buf, 1);\n\tif (err_mask)\n\t\treturn -EIO;\n\n\tcsum = 0;\n\tfor (i = 0; i < ATA_SECT_SIZE; i++)\n\t\tcsum += buf[i];\n\tif (csum)\n\t\tata_dev_printk(dev, KERN_WARNING,\n\t\t\t       \"invalid checksum 0x%x on log page 10h\\n\", csum);\n\n\tif (buf[0] & 0x80)\n\t\treturn -ENOENT;\n\n\t*tag = buf[0] & 0x1f;\n\n\ttf->command = buf[2];\n\ttf->feature = buf[3];\n\ttf->lbal = buf[4];\n\ttf->lbam = buf[5];\n\ttf->lbah = buf[6];\n\ttf->device = buf[7];\n\ttf->hob_lbal = buf[8];\n\ttf->hob_lbam = buf[9];\n\ttf->hob_lbah = buf[10];\n\ttf->nsect = buf[12];\n\ttf->hob_nsect = buf[13];\n\n\treturn 0;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_port_wait_eh - Wait for the currently pending EH to complete\n *\t@ap: Port to wait EH for\n *\n *\tWait until the currently pending EH is complete.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n */\n", "func_signal": "void ata_port_wait_eh(struct ata_port *ap)", "code": "{\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\n retry:\n\tspin_lock_irqsave(ap->lock, flags);\n\n\twhile (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {\n\t\tprepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t}\n\tfinish_wait(&ap->eh_wait_q, &wait);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t/* make sure SCSI EH is complete */\n\tif (scsi_host_in_recovery(ap->scsi_host)) {\n\t\tmsleep(10);\n\t\tgoto retry;\n\t}\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_handle_port_suspend - perform port suspend operation\n *\t@ap: port to suspend\n *\n *\tSuspend @ap.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n */\n", "func_signal": "static void ata_eh_handle_port_suspend(struct ata_port *ap)", "code": "{\n\tunsigned long flags;\n\tint rc = 0;\n\n\t/* are we suspending? */\n\tspin_lock_irqsave(ap->lock, flags);\n\tif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\n\t    ap->pm_mesg.event == PM_EVENT_ON) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tWARN_ON(ap->pflags & ATA_PFLAG_SUSPENDED);\n\n\t/* suspend */\n\tata_eh_freeze_port(ap);\n\n\tif (ap->ops->port_suspend)\n\t\trc = ap->ops->port_suspend(ap, ap->pm_mesg);\n\n\t/* report result */\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tap->pflags &= ~ATA_PFLAG_PM_PENDING;\n\tif (rc == 0)\n\t\tap->pflags |= ATA_PFLAG_SUSPENDED;\n\telse\n\t\tata_port_schedule_eh(ap);\n\n\tif (ap->pm_result) {\n\t\t*ap->pm_result = rc;\n\t\tap->pm_result = NULL;\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\t__ata_port_freeze - freeze port\n *\t@ap: ATA port to freeze\n *\n *\tThis function is called when HSM violation or some other\n *\tcondition disrupts normal operation of the port.  Frozen port\n *\tis not allowed to perform any operation until the port is\n *\tthawed, which usually follows a successful reset.\n *\n *\tap->ops->freeze() callback can be used for freezing the port\n *\thardware-wise (e.g. mask interrupt and stop DMA engine).  If a\n *\tport cannot be frozen hardware-wise, the interrupt handler\n *\tmust ack and clear interrupts unconditionally while the port\n *\tis frozen.\n *\n *\tLOCKING:\n *\tspin_lock_irqsave(host lock)\n */\n", "func_signal": "static void __ata_port_freeze(struct ata_port *ap)", "code": "{\n\tWARN_ON(!ap->ops->error_handler);\n\n\tif (ap->ops->freeze)\n\t\tap->ops->freeze(ap);\n\n\tap->pflags |= ATA_PFLAG_FROZEN;\n\n\tDPRINTK(\"ata%u port frozen\\n\", ap->id);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_freeze_port - EH helper to freeze port\n *\t@ap: ATA port to freeze\n *\n *\tFreeze @ap.\n *\n *\tLOCKING:\n *\tNone.\n */\n", "func_signal": "void ata_eh_freeze_port(struct ata_port *ap)", "code": "{\n\tunsigned long flags;\n\n\tif (!ap->ops->error_handler)\n\t\treturn;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t__ata_port_freeze(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_do_eh - do standard error handling\n *\t@ap: host port to handle error for\n *\t@prereset: prereset method (can be NULL)\n *\t@softreset: softreset method (can be NULL)\n *\t@hardreset: hardreset method (can be NULL)\n *\t@postreset: postreset method (can be NULL)\n *\n *\tPerform standard error handling sequence.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n */\n", "func_signal": "void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,\n\t       ata_reset_fn_t softreset, ata_reset_fn_t hardreset,\n\t       ata_postreset_fn_t postreset)", "code": "{\n\tata_eh_autopsy(ap);\n\tata_eh_report(ap);\n\tata_eh_recover(ap, prereset, softreset, hardreset, postreset);\n\tata_eh_finish(ap);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_done - EH action complete\n *\t@ap: target ATA port\n *\t@dev: target ATA dev for per-dev action (can be NULL)\n *\t@action: action just completed\n *\n *\tCalled right after performing EH actions to clear related bits\n *\tin @ap->eh_context.\n *\n *\tLOCKING:\n *\tNone.\n */\n", "func_signal": "static void ata_eh_done(struct ata_port *ap, struct ata_device *dev,\n\t\t\tunsigned int action)", "code": "{\n\t/* if reset is complete, clear all reset actions & reset modifier */\n\tif (action & ATA_EH_RESET_MASK) {\n\t\taction |= ATA_EH_RESET_MASK;\n\t\tap->eh_context.i.flags &= ~ATA_EHI_RESET_MODIFIER_MASK;\n\t}\n\n\tata_eh_clear_action(dev, &ap->eh_context.i, action);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_autopsy - analyze error and determine recovery action\n *\t@ap: ATA port to perform autopsy on\n *\n *\tAnalyze why @ap failed and determine which recovery action is\n *\tneeded.  This function also sets more detailed AC_ERR_* values\n *\tand fills sense data for ATAPI CHECK SENSE.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n */\n", "func_signal": "static void ata_eh_autopsy(struct ata_port *ap)", "code": "{\n\tstruct ata_eh_context *ehc = &ap->eh_context;\n\tunsigned int all_err_mask = 0;\n\tint tag, is_io = 0;\n\tu32 serror;\n\tint rc;\n\n\tDPRINTK(\"ENTER\\n\");\n\n\tif (ehc->i.flags & ATA_EHI_NO_AUTOPSY)\n\t\treturn;\n\n\t/* obtain and analyze SError */\n\trc = sata_scr_read(ap, SCR_ERROR, &serror);\n\tif (rc == 0) {\n\t\tehc->i.serror |= serror;\n\t\tata_eh_analyze_serror(ap);\n\t} else if (rc != -EOPNOTSUPP)\n\t\tehc->i.action |= ATA_EH_HARDRESET;\n\n\t/* analyze NCQ failure */\n\tata_eh_analyze_ncq_error(ap);\n\n\t/* any real error trumps AC_ERR_OTHER */\n\tif (ehc->i.err_mask & ~AC_ERR_OTHER)\n\t\tehc->i.err_mask &= ~AC_ERR_OTHER;\n\n\tall_err_mask |= ehc->i.err_mask;\n\n\tfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\n\t\tstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\n\n\t\tif (!(qc->flags & ATA_QCFLAG_FAILED))\n\t\t\tcontinue;\n\n\t\t/* inherit upper level err_mask */\n\t\tqc->err_mask |= ehc->i.err_mask;\n\n\t\t/* analyze TF */\n\t\tehc->i.action |= ata_eh_analyze_tf(qc, &qc->result_tf);\n\n\t\t/* DEV errors are probably spurious in case of ATA_BUS error */\n\t\tif (qc->err_mask & AC_ERR_ATA_BUS)\n\t\t\tqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_MEDIA |\n\t\t\t\t\t  AC_ERR_INVALID);\n\n\t\t/* any real error trumps unknown error */\n\t\tif (qc->err_mask & ~AC_ERR_OTHER)\n\t\t\tqc->err_mask &= ~AC_ERR_OTHER;\n\n\t\t/* SENSE_VALID trumps dev/unknown error and revalidation */\n\t\tif (qc->flags & ATA_QCFLAG_SENSE_VALID) {\n\t\t\tqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_OTHER);\n\t\t\tehc->i.action &= ~ATA_EH_REVALIDATE;\n\t\t}\n\n\t\t/* accumulate error info */\n\t\tehc->i.dev = qc->dev;\n\t\tall_err_mask |= qc->err_mask;\n\t\tif (qc->flags & ATA_QCFLAG_IO)\n\t\t\tis_io = 1;\n\t}\n\n\t/* enforce default EH actions */\n\tif (ap->pflags & ATA_PFLAG_FROZEN ||\n\t    all_err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT))\n\t\tehc->i.action |= ATA_EH_SOFTRESET;\n\telse if (all_err_mask)\n\t\tehc->i.action |= ATA_EH_REVALIDATE;\n\n\t/* if we have offending qcs and the associated failed device */\n\tif (ehc->i.dev) {\n\t\t/* speed down */\n\t\tehc->i.action |= ata_eh_speed_down(ehc->i.dev, is_io,\n\t\t\t\t\t\t   all_err_mask);\n\n\t\t/* perform per-dev EH action only on the offending device */\n\t\tehc->i.dev_action[ehc->i.dev->devno] |=\n\t\t\tehc->i.action & ATA_EH_PERDEV_MASK;\n\t\tehc->i.action &= ~ATA_EH_PERDEV_MASK;\n\t}\n\n\tDPRINTK(\"EXIT\\n\");\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_analyze_tf - analyze taskfile of a failed qc\n *\t@qc: qc to analyze\n *\t@tf: Taskfile registers to analyze\n *\n *\tAnalyze taskfile of @qc and further determine cause of\n *\tfailure.  This function also requests ATAPI sense data if\n *\tavaliable.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n *\n *\tRETURNS:\n *\tDetermined recovery action\n */\n", "func_signal": "static unsigned int ata_eh_analyze_tf(struct ata_queued_cmd *qc,\n\t\t\t\t      const struct ata_taskfile *tf)", "code": "{\n\tunsigned int tmp, action = 0;\n\tu8 stat = tf->command, err = tf->feature;\n\n\tif ((stat & (ATA_BUSY | ATA_DRQ | ATA_DRDY)) != ATA_DRDY) {\n\t\tqc->err_mask |= AC_ERR_HSM;\n\t\treturn ATA_EH_SOFTRESET;\n\t}\n\n\tif (!(qc->err_mask & AC_ERR_DEV))\n\t\treturn 0;\n\n\tswitch (qc->dev->class) {\n\tcase ATA_DEV_ATA:\n\t\tif (err & ATA_ICRC)\n\t\t\tqc->err_mask |= AC_ERR_ATA_BUS;\n\t\tif (err & ATA_UNC)\n\t\t\tqc->err_mask |= AC_ERR_MEDIA;\n\t\tif (err & ATA_IDNF)\n\t\t\tqc->err_mask |= AC_ERR_INVALID;\n\t\tbreak;\n\n\tcase ATA_DEV_ATAPI:\n#if defined(__VMKLNX__)\n\t\t/*\n\t\t * Our module heap is guaranteed contiguous so we know we don't\n\t\t * need multiple SGEs to express the sense_buffer.\n\t\t */\n\t\tqc->sense_buffer = kmalloc(sizeof(qc->scsicmd->sense_buffer),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (qc->sense_buffer == NULL) {\n\t\t\tprintk(\"%s: error allocating sense buffer\\n\", __FUNCTION__);\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = atapi_eh_request_sense(qc->dev, qc->sense_buffer);\n\t\tif (!tmp)\n\t\t\tmemcpy(qc->scsicmd->sense_buffer, qc->sense_buffer,\n\t\t\t       sizeof(qc->scsicmd->sense_buffer));\n\t\tkfree(qc->sense_buffer);\n\t\tqc->sense_buffer = NULL;\n#else /* !defined(__VMKLNX__) */\n\t\ttmp = atapi_eh_request_sense(qc->dev,\n\t\t\t\t\t     qc->scsicmd->sense_buffer);\n#endif /* defined(__VMKLNX__) */\n\t\tif (!tmp) {\n\t\t\t/* ATA_QCFLAG_SENSE_VALID is used to tell\n\t\t\t * atapi_qc_complete() that sense data is\n\t\t\t * already valid.\n\t\t\t *\n\t\t\t * TODO: interpret sense data and set\n\t\t\t * appropriate err_mask.\n\t\t\t */\n\t\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\t\t} else\n\t\t\tqc->err_mask |= tmp;\n\t}\n\n\tif (qc->err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT | AC_ERR_ATA_BUS))\n\t\taction |= ATA_EH_SOFTRESET;\n\n\treturn action;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_eh_about_to_do - about to perform eh_action\n *\t@ap: target ATA port\n *\t@dev: target ATA dev for per-dev action (can be NULL)\n *\t@action: action about to be performed\n *\n *\tCalled just before performing EH actions to clear related bits\n *\tin @ap->eh_info such that eh actions are not unnecessarily\n *\trepeated.\n *\n *\tLOCKING:\n *\tNone.\n */\n", "func_signal": "static void ata_eh_about_to_do(struct ata_port *ap, struct ata_device *dev,\n\t\t\t       unsigned int action)", "code": "{\n\tunsigned long flags;\n\tstruct ata_eh_info *ehi = &ap->eh_info;\n\tstruct ata_eh_context *ehc = &ap->eh_context;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t/* Reset is represented by combination of actions and EHI\n\t * flags.  Suck in all related bits before clearing eh_info to\n\t * avoid losing requested action.\n\t */\n\tif (action & ATA_EH_RESET_MASK) {\n\t\tehc->i.action |= ehi->action & ATA_EH_RESET_MASK;\n\t\tehc->i.flags |= ehi->flags & ATA_EHI_RESET_MODIFIER_MASK;\n\n\t\t/* make sure all reset actions are cleared & clear EHI flags */\n\t\taction |= ATA_EH_RESET_MASK;\n\t\tehi->flags &= ~ATA_EHI_RESET_MODIFIER_MASK;\n\t}\n\n\tata_eh_clear_action(dev, ehi, action);\n\n\tif (!(ehc->i.flags & ATA_EHI_QUIET))\n\t\tap->pflags |= ATA_PFLAG_RECOVERED;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_read_log_page - read a specific log page\n *\t@dev: target device\n *\t@page: page to read\n *\t@buf: buffer to store read page\n *\t@sectors: number of sectors to read\n *\n *\tRead log page using READ_LOG_EXT command.\n *\n *\tLOCKING:\n *\tKernel thread context (may sleep).\n *\n *\tRETURNS:\n *\t0 on success, AC_ERR_* mask otherwise.\n */\n", "func_signal": "static unsigned int ata_read_log_page(struct ata_device *dev,\n\t\t\t\t      u8 page, void *buf, unsigned int sectors)", "code": "{\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\tDPRINTK(\"read log page - page %d\\n\", page);\n\n\tata_tf_init(dev, &tf);\n\ttf.command = ATA_CMD_READ_LOG_EXT;\n\ttf.lbal = page;\n\ttf.nsect = sectors;\n\ttf.hob_nsect = sectors >> 8;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_LBA48 | ATA_TFLAG_DEVICE;\n\ttf.protocol = ATA_PROT_PIO;\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_FROM_DEVICE,\n\t\t\t\t     buf, sectors * ATA_SECT_SIZE);\n\n\tDPRINTK(\"EXIT, err_mask=%x\\n\", err_mask);\n\treturn err_mask;\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_err_string - convert err_mask to descriptive string\n *\t@err_mask: error mask to convert to string\n *\n *\tConvert @err_mask to descriptive string.  Errors are\n *\tprioritized according to severity and only the most severe\n *\terror is reported.\n *\n *\tLOCKING:\n *\tNone.\n *\n *\tRETURNS:\n *\tDescriptive string for @err_mask\n */\n", "func_signal": "static const char * ata_err_string(unsigned int err_mask)", "code": "{\n\tif (err_mask & AC_ERR_HOST_BUS)\n\t\treturn \"host bus error\";\n\tif (err_mask & AC_ERR_ATA_BUS)\n\t\treturn \"ATA bus error\";\n\tif (err_mask & AC_ERR_TIMEOUT)\n\t\treturn \"timeout\";\n\tif (err_mask & AC_ERR_HSM)\n\t\treturn \"HSM violation\";\n\tif (err_mask & AC_ERR_SYSTEM)\n\t\treturn \"internal error\";\n\tif (err_mask & AC_ERR_MEDIA)\n\t\treturn \"media error\";\n\tif (err_mask & AC_ERR_INVALID)\n\t\treturn \"invalid argument\";\n\tif (err_mask & AC_ERR_DEV)\n\t\treturn \"device error\";\n\treturn \"unknown error\";\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_scsi_error - SCSI layer error handler callback\n *\t@host: SCSI host on which error occurred\n *\n *\tHandles SCSI-layer-thrown error events.\n *\n *\tLOCKING:\n *\tInherited from SCSI layer (none, can sleep)\n *\n *\tRETURNS:\n *\tZero.\n */\n", "func_signal": "void ata_scsi_error(struct Scsi_Host *host)", "code": "{\n\tstruct ata_port *ap = ata_shost_to_port(host);\n\tint i, repeat_cnt = ATA_EH_MAX_REPEAT;\n\tunsigned long flags;\n\n\tDPRINTK(\"ENTER\\n\");\n\n\t/* synchronize with port task */\n\tata_port_flush_task(ap);\n\n\t/* synchronize with host lock and sort out timeouts */\n\n\t/* For new EH, all qcs are finished in one of three ways -\n\t * normal completion, error completion, and SCSI timeout.\n\t * Both cmpletions can race against SCSI timeout.  When normal\n\t * completion wins, the qc never reaches EH.  When error\n\t * completion wins, the qc has ATA_QCFLAG_FAILED set.\n\t *\n\t * When SCSI timeout wins, things are a bit more complex.\n\t * Normal or error completion can occur after the timeout but\n\t * before this point.  In such cases, both types of\n\t * completions are honored.  A scmd is determined to have\n\t * timed out iff its associated qc is active and not failed.\n\t */\n\tif (ap->ops->error_handler) {\n\t\tstruct scsi_cmnd *scmd, *tmp;\n\t\tint nr_timedout = 0;\n\n\t\tspin_lock_irqsave(ap->lock, flags);\n\n\t\tlist_for_each_entry_safe(scmd, tmp, &host->eh_cmd_q, eh_entry) {\n\t\t\tstruct ata_queued_cmd *qc;\n\n\t\t\tfor (i = 0; i < ATA_MAX_QUEUE; i++) {\n\t\t\t\tqc = __ata_qc_from_tag(ap, i);\n\t\t\t\tif (qc->flags & ATA_QCFLAG_ACTIVE &&\n\t\t\t\t    qc->scsicmd == scmd)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i < ATA_MAX_QUEUE) {\n\t\t\t\t/* the scmd has an associated qc */\n\t\t\t\tif (!(qc->flags & ATA_QCFLAG_FAILED)) {\n\t\t\t\t\t/* which hasn't failed yet, timeout */\n\t\t\t\t\tqc->err_mask |= AC_ERR_TIMEOUT;\n\t\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t\t\t\tnr_timedout++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Normal completion occurred after\n\t\t\t\t * SCSI timeout but before this point.\n\t\t\t\t * Successfully complete it.\n\t\t\t\t */\n\t\t\t\tscmd->retries = scmd->allowed;\n\t\t\t\tscsi_eh_finish_cmd(scmd, &ap->eh_done_q);\n\t\t\t}\n\t\t}\n\n\t\t/* If we have timed out qcs.  They belong to EH from\n\t\t * this point but the state of the controller is\n\t\t * unknown.  Freeze the port to make sure the IRQ\n\t\t * handler doesn't diddle with those qcs.  This must\n\t\t * be done atomically w.r.t. setting QCFLAG_FAILED.\n\t\t */\n\t\tif (nr_timedout)\n\t\t\t__ata_port_freeze(ap);\n\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t} else\n\t\tspin_unlock_wait(ap->lock);\n\n repeat:\n\t/* invoke error handler */\n\tif (ap->ops->error_handler) {\n\t\t/* process port resume request */\n\t\tata_eh_handle_port_resume(ap);\n\n\t\t/* fetch & clear EH info */\n\t\tspin_lock_irqsave(ap->lock, flags);\n\n\t\tmemset(&ap->eh_context, 0, sizeof(ap->eh_context));\n\t\tap->eh_context.i = ap->eh_info;\n\t\tmemset(&ap->eh_info, 0, sizeof(ap->eh_info));\n\n\t\tap->pflags |= ATA_PFLAG_EH_IN_PROGRESS;\n\t\tap->pflags &= ~ATA_PFLAG_EH_PENDING;\n\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t\t/* invoke EH, skip if unloading or suspended */\n\t\tif (!(ap->pflags & (ATA_PFLAG_UNLOADING | ATA_PFLAG_SUSPENDED)))\n\t\t\tap->ops->error_handler(ap);\n\t\telse\n\t\t\tata_eh_finish(ap);\n\n\t\t/* process port suspend request */\n\t\tata_eh_handle_port_suspend(ap);\n\n\t\t/* Exception might have happend after ->error_handler\n\t\t * recovered the port but before this point.  Repeat\n\t\t * EH in such case.\n\t\t */\n\t\tspin_lock_irqsave(ap->lock, flags);\n\n\t\tif (ap->pflags & ATA_PFLAG_EH_PENDING) {\n\t\t\tif (--repeat_cnt) {\n\t\t\t\tata_port_printk(ap, KERN_INFO,\n\t\t\t\t\t\"EH pending after completion, \"\n\t\t\t\t\t\"repeating EH (cnt=%d)\\n\", repeat_cnt);\n\t\t\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tata_port_printk(ap, KERN_ERR, \"EH pending after %d \"\n\t\t\t\t\t\"tries, giving up\\n\", ATA_EH_MAX_REPEAT);\n\t\t}\n\n\t\t/* this run is complete, make sure EH info is clear */\n\t\tmemset(&ap->eh_info, 0, sizeof(ap->eh_info));\n\n\t\t/* Clear host_eh_scheduled while holding ap->lock such\n\t\t * that if exception occurs after this point but\n\t\t * before EH completion, SCSI midlayer will\n\t\t * re-initiate EH.\n\t\t */\n\t\thost->host_eh_scheduled = 0;\n\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t} else {\n\t\tWARN_ON(ata_qc_from_tag(ap, ap->active_tag) == NULL);\n\t\tap->ops->eng_timeout(ap);\n\t}\n\n\t/* finish or retry handled scmd's and clean up */\n\tWARN_ON(host->host_failed || !list_empty(&host->eh_cmd_q));\n\n\tscsi_eh_flush_done_q(&ap->eh_done_q);\n\n\t/* clean up */\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tif (ap->pflags & ATA_PFLAG_LOADING)\n\t\tap->pflags &= ~ATA_PFLAG_LOADING;\n\telse if (ap->pflags & ATA_PFLAG_SCSI_HOTPLUG)\n\t\tqueue_work(ata_aux_wq, &ap->hotplug_task);\n\n\tif (ap->pflags & ATA_PFLAG_RECOVERED)\n\t\tata_port_printk(ap, KERN_INFO, \"EH complete\\n\");\n\n\tap->pflags &= ~(ATA_PFLAG_SCSI_HOTPLUG | ATA_PFLAG_RECOVERED);\n\n\t/* tell wait_eh that we're done */\n\tap->pflags &= ~ATA_PFLAG_EH_IN_PROGRESS;\n\twake_up_all(&ap->eh_wait_q);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tDPRINTK(\"EXIT\\n\");\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_port_schedule_eh - schedule error handling without a qc\n *\t@ap: ATA port to schedule EH for\n *\n *\tSchedule error handling for @ap.  EH will kick in as soon as\n *\tall commands are drained.\n *\n *\tLOCKING:\n *\tspin_lock_irqsave(host lock)\n */\n", "func_signal": "void ata_port_schedule_eh(struct ata_port *ap)", "code": "{\n\tWARN_ON(!ap->ops->error_handler);\n\n\tap->pflags |= ATA_PFLAG_EH_PENDING;\n\tscsi_schedule_eh(ap->scsi_host);\n\n\tDPRINTK(\"port EH scheduled\\n\");\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/**\n *\tata_qc_schedule_eh - schedule qc for error handling\n *\t@qc: command to schedule error handling for\n *\n *\tSchedule error handling for @qc.  EH will kick in as soon as\n *\tother commands are drained.\n *\n *\tLOCKING:\n *\tspin_lock_irqsave(host lock)\n */\n", "func_signal": "void ata_qc_schedule_eh(struct ata_queued_cmd *qc)", "code": "{\n\tstruct ata_port *ap = qc->ap;\n\n\tWARN_ON(!ap->ops->error_handler);\n\n\tqc->flags |= ATA_QCFLAG_FAILED;\n\tqc->ap->pflags |= ATA_PFLAG_EH_PENDING;\n\n\t/* The following will fail if timeout has already expired.\n\t * ata_scsi_error() takes care of such scmds on EH entry.\n\t * Note that ATA_QCFLAG_FAILED is unconditionally set after\n\t * this function completes.\n\t */\n\tscsi_req_abort_cmd(qc->scsicmd);\n}", "path": "vmkdrivers\\src26\\drivers\\ata\\libata-eh.c", "repo_name": "loginab/esxdrivers", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 8927}
{"docstring": "/* Returns the front element in LIST.\n   Undefined behavior if LIST is empty. */\n", "func_signal": "struct list_elem *\nlist_front (struct list *list)", "code": "{\n  assert (!list_empty (list));\n  return list->head.next;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Sorts LIST according to LESS given auxiliary data AUX, using a\n   natural iterative merge sort that runs in O(n lg n) time and\n   O(1) space in the number of elements in LIST. */\n", "func_signal": "void\nlist_sort (struct list *list, list_less_func *less, void *aux)", "code": "{\n  size_t output_run_cnt;        /* Number of runs output in current pass. */\n\n  assert (list != NULL);\n  assert (less != NULL);\n\n  /* Pass over the list repeatedly, merging adjacent runs of\n     nondecreasing elements, until only one run is left. */\n  do\n    {\n      struct list_elem *a0;     /* Start of first run. */\n      struct list_elem *a1b0;   /* End of first run, start of second. */\n      struct list_elem *b1;     /* End of second run. */\n\n      output_run_cnt = 0;\n      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)\n        {\n          /* Each iteration produces one output run. */\n          output_run_cnt++;\n\n          /* Locate two adjacent runs of nondecreasing elements\n             A0...A1B0 and A1B0...B1. */\n          a1b0 = find_end_of_run (a0, list_end (list), less, aux);\n          if (a1b0 == list_end (list))\n            break;\n          b1 = find_end_of_run (a1b0, list_end (list), less, aux);\n\n          /* Merge the runs. */\n          inplace_merge (a0, a1b0, b1, less, aux);\n        }\n    }\n  while (output_run_cnt > 1);\n\n  assert (is_sorted (list_begin (list), list_end (list), less, aux));\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Removes the back element from LIST and returns it.\n   Undefined behavior if LIST is empty before removal. */\n", "func_signal": "struct list_elem *\nlist_pop_back (struct list *list)", "code": "{\n  struct list_elem *back = list_back (list);\n  list_remove (back);\n  return back;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/*\n * For now session_setlink assumes that path is a valid, checked NULL\n * terminated string\n */\n", "func_signal": "int session_setlink (sid_t sid, lid_t lid, const char * path)", "code": "{\n  struct list_elem *e;\n  session_t * session = NULL;\n  link_t * link = NULL;\n\n  pthread_mutex_lock (&session_mutex);\n\n  for (e = list_begin (&session_list); e != list_end (&session_list);\n       e = list_next (e))\n    {\n      session_t *s = list_entry (e, session_t, elem);\n      if (s->sid == sid)\n\t  session = s;\n    }\n\n  if (session == NULL) {\n    pthread_mutex_unlock (&session_mutex);\n    return SES_SID_NOT_FOUND;\n  }\n  \n  for (e = list_begin (&session->link_list); e != list_end (&session->link_list);\n       e = list_next (e))\n    {\n      link_t *l = list_entry (e, link_t, elem);\n      if (l->lid == lid)\n\t  link = l;\n    }\n\n  if (link == NULL) {\n    pthread_mutex_unlock (&session_mutex);\n    return SES_LID_NOT_FOUND;\n  }\n\n  pthread_mutex_lock (&link->mutex);\n  pthread_mutex_unlock (&session_mutex);\n\n  if (link->path != NULL) {\n    pthread_mutex_unlock (&link->mutex);\n    return SES_LINK_PATH_SET; \n  }\n  \n  link->path = (char *) malloc (strlen (path) + 1);\n\n  if (link->path == NULL) {\n    pthread_mutex_unlock (&link->mutex);\n    return SES_MALLOC;\n  }\n  \n  memset (link->path, 0, strlen (path) + 1);\n  strncpy (link->path, path, strlen (path));\n\n  pthread_cond_broadcast (&link->cond_set);\n  pthread_mutex_unlock (&link->mutex);\n\n  return 0;\n}", "path": "src\\session.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Merges A0 through A1B0 (exclusive) with A1B0 through B1\n   (exclusive) to form a combined range also ending at B1\n   (exclusive).  Both input ranges must be nonempty and sorted in\n   nondecreasing order according to LESS given auxiliary data\n   AUX.  The output range will be sorted the same way. */\n", "func_signal": "static void\ninplace_merge (struct list_elem *a0, struct list_elem *a1b0,\n               struct list_elem *b1,\n               list_less_func *less, void *aux)", "code": "{\n  assert (a0 != NULL);\n  assert (a1b0 != NULL);\n  assert (b1 != NULL);\n  assert (less != NULL);\n  assert (is_sorted (a0, a1b0, less, aux));\n  assert (is_sorted (a1b0, b1, less, aux));\n\n  while (a0 != a1b0 && a1b0 != b1)\n    if (!less (a1b0, a0, aux)) \n      a0 = list_next (a0);\n    else \n      {\n        a1b0 = list_next (a1b0);\n        list_splice (a0, list_prev (a1b0), a1b0);\n      }\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Finds a run, starting at A and ending not after B, of list\n   elements that are in nondecreasing order according to LESS\n   given auxiliary data AUX.  Returns the (exclusive) end of the\n   run.\n   A through B (exclusive) must form a non-empty range. */\n", "func_signal": "static struct list_elem *\nfind_end_of_run (struct list_elem *a, struct list_elem *b,\n                 list_less_func *less, void *aux)", "code": "{\n  assert (a != NULL);\n  assert (b != NULL);\n  assert (less != NULL);\n  assert (a != b);\n  \n  do \n    {\n      a = list_next (a);\n    }\n  while (a != b && !less (a, list_prev (a), aux));\n  return a;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Swaps the `struct list_elem *'s that A and B point to. */\n", "func_signal": "static void\nswap (struct list_elem **a, struct list_elem **b)", "code": "{\n  struct list_elem *t = *a;\n  *a = *b;\n  *b = t;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns LIST's tail.\n\n   list_end() is often used in iterating through a list from\n   front to back.  See the big comment at the top of list.h for\n   an example. */\n", "func_signal": "struct list_elem *\nlist_end (struct list *list)", "code": "{\n  assert (list != NULL);\n  return &list->tail;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Initializes LIST as an empty list. */\n", "func_signal": "void\nlist_init (struct list *list)", "code": "{\n  assert (list != NULL);\n  list->head.prev = NULL;\n  list->head.next = &list->tail;\n  list->tail.prev = &list->head;\n  list->tail.next = NULL;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns the beginning of LIST.  */\n", "func_signal": "struct list_elem *\nlist_begin (struct list *list)", "code": "{\n  assert (list != NULL);\n  return list->head.next;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns the element before ELEM in its list.  If ELEM is the\n   first element in its list, returns the list head.  Results are\n   undefined if ELEM is itself a list head. */\n", "func_signal": "struct list_elem *\nlist_prev (struct list_elem *elem)", "code": "{\n  assert (is_interior (elem) || is_tail (elem));\n  return elem->prev;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Removes the front element from LIST and returns it.\n   Undefined behavior if LIST is empty before removal. */\n", "func_signal": "struct list_elem *\nlist_pop_front (struct list *list)", "code": "{\n  struct list_elem *front = list_front (list);\n  list_remove (front);\n  return front;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Return's LIST's tail. */\n", "func_signal": "struct list_elem *\nlist_tail (struct list *list)", "code": "{\n  assert (list != NULL);\n  return &list->tail;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns the element in LIST with the largest value according\n   to LESS given auxiliary data AUX.  If there is more than one\n   maximum, returns the one that appears earlier in the list.  If\n   the list is empty, returns its tail. */\n", "func_signal": "struct list_elem *\nlist_max (struct list *list, list_less_func *less, void *aux)", "code": "{\n  struct list_elem *max = list_begin (list);\n  if (max != list_end (list)) \n    {\n      struct list_elem *e;\n      \n      for (e = list_next (max); e != list_end (list); e = list_next (e))\n        if (less (max, e, aux))\n          max = e; \n    }\n  return max;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Iterates through LIST and removes all but the first in each\n   set of adjacent elements that are equal according to LESS\n   given auxiliary data AUX.  If DUPLICATES is non-null, then the\n   elements from LIST are appended to DUPLICATES. */\n", "func_signal": "void\nlist_unique (struct list *list, struct list *duplicates,\n             list_less_func *less, void *aux)", "code": "{\n  struct list_elem *elem, *next;\n\n  assert (list != NULL);\n  assert (less != NULL);\n  if (list_empty (list))\n    return;\n\n  elem = list_begin (list);\n  while ((next = list_next (elem)) != list_end (list))\n    if (!less (elem, next, aux) && !less (next, elem, aux)) \n      {\n        list_remove (next);\n        if (duplicates != NULL)\n          list_push_back (duplicates, next);\n      }\n    else\n      elem = next;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Reverses the order of LIST. */\n", "func_signal": "void\nlist_reverse (struct list *list)", "code": "{\n  if (!list_empty (list)) \n    {\n      struct list_elem *e;\n\n      for (e = list_begin (list); e != list_end (list); e = e->prev)\n        swap (&e->prev, &e->next);\n      swap (&list->head.next, &list->tail.prev);\n      swap (&list->head.next->prev, &list->tail.prev->next);\n    }\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Removes elements FIRST though LAST (exclusive) from their\n   current list, then inserts them just before BEFORE, which may\n   be either an interior element or a tail. */\n", "func_signal": "void\nlist_splice (struct list_elem *before,\n             struct list_elem *first, struct list_elem *last)", "code": "{\n  assert (is_interior (before) || is_tail (before));\n  if (first == last)\n    return;\n  last = list_prev (last);\n\n  assert (is_interior (first));\n  assert (is_interior (last));\n\n  /* Cleanly remove FIRST...LAST from its current list. */\n  first->prev->next = last->next;\n  last->next->prev = first->prev;\n\n  /* Splice FIRST...LAST into new list. */\n  first->prev = before->prev;\n  last->next = before;\n  before->prev->next = first;\n  before->prev = last;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns the number of elements in LIST.\n   Runs in O(n) in the number of elements. */\n", "func_signal": "size_t\nlist_size (struct list *list)", "code": "{\n  struct list_elem *e;\n  size_t cnt = 0;\n\n  for (e = list_begin (list); e != list_end (list); e = list_next (e))\n    cnt++;\n  return cnt;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns the element after ELEM in its list.  If ELEM is the\n   last element in its list, returns the list tail.  Results are\n   undefined if ELEM is itself a list tail. */\n", "func_signal": "struct list_elem *\nlist_next (struct list_elem *elem)", "code": "{\n  assert (is_head (elem) || is_interior (elem));\n  return elem->next;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* Returns true only if the list elements A through B (exclusive)\n   are in order according to LESS given auxiliary data AUX. */\n", "func_signal": "static bool\nis_sorted (struct list_elem *a, struct list_elem *b,\n           list_less_func *less, void *aux)", "code": "{\n  if (a != b)\n    while ((a = list_next (a)) != b) \n      if (less (a, list_prev (a), aux))\n        return false;\n  return true;\n}", "path": "src\\list.c", "repo_name": "spolu/waitfs", "stars": 3, "license": "gpl-3.0", "language": "c", "size": 136}
{"docstring": "/* duplicate atom list */\n", "func_signal": "p_atom *atom_dup(p_atom *atom)", "code": "{\n  static p_atom **list;\n    list = (p_atom **)calloc(1, sizeof(p_atom *));\n    *list = NULL;\n\n  while(atom) {\n    atom_append(list, make_atom(atom->type, atom->name, atom->value));\n    atom = (p_atom *)atom->next;\n  }\n\n  return *list;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* set atom by name */\n", "func_signal": "void atom_setname(p_atom **list, p_atom *new)", "code": "{\n  p_atom *atom = atom_getname(*list, new->name);\n  if(!atom) {\n    atom_append(list, new);\n  } else {\n    atom->type = new->type;\n    atom->value = new->value;\n  }\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* create an atom */\n", "func_signal": "p_atom *make_atom(p_type type, const char *name, void *value)", "code": "{\n  p_atom *atom = (p_atom *)calloc(1, sizeof(p_atom));\n    atom->type = type;\n    atom->name = name ? strdup(name) : NULL;\n    atom->value = value;\n    atom->next = NULL;\n  return atom;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* get the atom corresponding to an index */\n", "func_signal": "p_atom *atom_getindex(p_atom *atom, unsigned int index)", "code": "{\n  static unsigned int i;\n  i = 0;\n  for(i = 0;\n      i < index;\n      i++) {\n    ATOM_NEXT(atom);\n  }\n  return atom;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/*\n * check argument types (primitive)\n *\n * 0 to end list\n */\n", "func_signal": "void check_argt(const char *func, p_atom *args, ...)", "code": "{\n  va_list ap;\n  static p_type type;\n    type = 0;\n  static size_t i;\n    i = 0;\n\n  va_start(ap, args);\n  while(1) {\n    type = va_arg(ap, p_type);\n    if(type == 0) {\n      break;\n    }\n    \n    if(args->type != type && type != P_ANY) {\n      func_err(func, vafmt(\"incorrect type '%s' for argument %ld (should be '%s')\", \n            prim_type_name(args->type), i + 1, prim_type_name(type)));\n    }\n\n    ATOM_NEXT(args);\n    i++;\n  }\n  va_end(ap);\n}", "path": "helpers.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* \n * replace substring\n *\n * This function is probably f'ing hideous.\n */\n", "func_signal": "char *str_replace(const char *target, const char *search, const char *replace,\n    unsigned int start)", "code": "{\n  char *result, *left, *right;\n  int pos;\n\n  asprintf(&result, \"%s\", target);\n  for(; (pos = str_pos(result, search, start)) != -1; ) {\n    left = (char *)calloc(start + pos + 1, sizeof(char));\n    right = (char *)calloc((strlen(result) - pos - strlen(search)) + 1, sizeof(char));\n\n    strncpy(left, result, pos);\n    strncpy(right, result + pos + strlen(search), strlen(result) - pos - strlen(search));\n    asprintf(&result, \"%s%s%s\", left, replace, right);\n\n    free(left);\n    free(right);\n\n    start = pos + strlen(replace);\n  }\n\n  return result;\n}", "path": "string.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* create a p_utype* and return as void* */\n", "func_signal": "void *make_utype(const char *type, void *value)", "code": "{\n  p_utype *rval = (p_utype *)calloc(1, sizeof(p_utype));\n    rval->type = strdup(type);\n    rval->value = value;\n  return (void *)rval;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* find position of substring */\n", "func_signal": "int str_pos(const char *target, const char *search, unsigned int start)", "code": "{\n  char *pos;\n\n  if(strlen(search) == 0) { return -1; }\n  pos = strstr(target + start, search);\n  if(!pos) { return -1; }\n\n  return pos - target;\n}", "path": "string.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* like (a)sprintf, but return the result */\n", "func_signal": "char *vafmt(const char *fmt, ...)", "code": "{\n  va_list ap;\n  char *result;\n\n  va_start(ap, fmt);\n  vasprintf(&result, fmt, ap);\n  va_end(ap);\n\n  return result;\n}", "path": "string.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* parse basic tokens into more complex ones */\n", "func_signal": "p_atom *parse_tokens(p_atom *tokens)", "code": "{\n  p_atom *code = NULL, *list = NULL;\n  static unsigned int level;\n\n  while(tokens) {\n    if(tokens->type == P_NUM) {\n      atom_append(&code, make_atom(P_NUM, NULL, atom_dupnum(*(p_num *)tokens->value)));\n    } else if(tokens->type == P_STR) {\n      atom_append(&code, make_atom(P_STR, NULL, (void *)strdup((char *)tokens->value)));\n    } else if(tokens->type == P_SYM) {\n      atom_append(&code, make_atom(P_SYM, NULL, tokens->value));\n    /* it's an expression */\n    } else if(tokens->type == PT_PARENL) {\n      tokens = (p_atom *)tokens->next;\n      if(!tokens ) { break; }\n\n      list = NULL;\n      level = 1;\n      while(tokens) {\n        if(tokens->type == PT_PARENL) { level++; }\n        else if(tokens->type == PT_PARENR) { level--; }\n        if(level <= 0) { break; }\n\n        atom_append(&list, make_atom(tokens->type, NULL, tokens->value));\n        tokens = (p_atom *)tokens->next;\n      }\n      atom_append(&code, make_atom(PT_EXP, NULL, parse_tokens(list)));\n    /* it's a literal something-or-other */\n    } else if(tokens->type == PT_QUOTE) {\n      tokens = (p_atom *)tokens->next;\n      if(!tokens) { break; }\n\n      /* it's a block: .( ... ) */\n      else if(tokens->type == PT_PARENL) {\n        tokens = (p_atom *)tokens->next;\n        if(!tokens) { break; }\n\n        list = NULL;\n        level = 1;\n        while(tokens) {\n          if(tokens->type == PT_PARENL) { level++; }\n          else if(tokens->type == PT_PARENR) { level--; }\n          if(level <= 0) { break; }\n\n          atom_append(&list, make_atom(tokens->type, NULL, tokens->value));\n          tokens = (p_atom *)tokens->next;\n        }\n        atom_append(&code, make_atom(P_BLOCK, NULL, parse_tokens(list)));\n\n      /* it's a quoted symbol: .something */\n      } else if(tokens->type == P_SYM) {\n        atom_append(&code, make_atom(PT_LITSYM, NULL, tokens->value));\n      }\n    }\n    if(tokens) { tokens = (p_atom *)tokens->next; }\n  }\n\n  return code;\n}", "path": "engine.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* like Lisp's */\n", "func_signal": "MFUNC_PROTO(cond)", "code": "{\n  while(args) {\n    if(args->type != P_BLOCK) {\n      fprintf(stderr, \"cond: clause must be block\\n\");\n      exit(1);\n    } else if(atom_len((p_atom *)args->value) != 2) {\n      fprintf(stderr, \"cond: clause must contain exactly 2 exps\\n\");\n      exit(1);\n    }\n\n    if(atom_true(run_exp((p_atom *)args->value, vars))) {\n      return run_exp(atom_getindex((p_atom *)args->value, 1), vars);\n    }\n\n    args = (p_atom *)args->next;\n  }\n  return NIL_ATOM;\n}", "path": "modules\\flow\\flow.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* get an atom by name */\n", "func_signal": "p_atom *atom_getname(p_atom *atom, const char *name)", "code": "{\n  if(!name) {\n    return NULL;\n  }\n  while(atom) {\n    if(atom->name && !strcmp(atom->name, name)) {\n      return atom;\n    }\n    ATOM_NEXT(atom);\n  }\n  return NULL;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* length of a linked list */\n", "func_signal": "unsigned int atom_len(p_atom *atom)", "code": "{\n  static int i;\n  for(i = 0; atom; i++) {\n    ATOM_NEXT(atom);\n  }\n  return i;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/*\n * check argument types (user-defined)\n *\n * \"\" to skip, NULL to end list\n */\n", "func_signal": "void check_argu(const char *func, p_atom *args, ...)", "code": "{\n  va_list ap;\n  static char *type;\n    type = \"\";\n  static size_t i;\n    i = 0;\n\n  va_start(ap, args);\n  while(1) {\n    type = va_arg(ap, char *);\n    /*\n     * order of these two is very important, as strlen() segfaults\n     * if NULL\n     *\n     */\n    if(!type) { break; }\n    else if(strlen(type) == 0) { continue; }\n\n    if(args->type != P_UTYPE || strcmp(UTYPE(args)->type, type)) {\n      func_err(func, vafmt(\"incorrect type '%s' for argument %ld (should be '%s')\",\n            (args->type != P_UTYPE) ? prim_type_name(args->type) : UTYPE(args)->type,\n            i + 1, type));\n    }\n\n    ATOM_NEXT(args);\n    i++;\n  }\n}", "path": "helpers.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* get primitive type name */\n", "func_signal": "char *prim_type_name(p_type type)", "code": "{\n  switch(type) {\n    case P_NIL:\n      return \"nil\";\n      break;\n    case P_NUM:\n      return \"number\";\n      break;\n    case P_STR:\n      return \"string\";\n      break;\n    case P_LIST:\n      return \"list\";\n      break;\n    case P_SYM:\n      return \"symbol\";\n      break;\n    case P_BLOCK:\n      return \"block\";\n      break;\n    case P_MFUNC:\n      return \"module_function\";\n      break;\n    case P_FUNC:\n      return \"function\";\n      break;\n    case P_UTYPE:\n      return \"custom\";\n      break;\n    default:\n      return \"undefined_type\";\n      break;\n  }\n}", "path": "helpers.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* duplicate a p_num */\n", "func_signal": "void *atom_dupnum(p_num num)", "code": "{\n  p_num *rval = (p_num *)calloc(1, sizeof(p_num));\n  *rval = num;\n  return (void *)rval;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* tokenizes the file pointed to by an open FILE* */\n", "func_signal": "p_atom *tokenize_fp(FILE *fp)", "code": "{\n  p_atom *tokens = NULL;\n  const unsigned int blocksize = 4096;\n  char *str = \"\", *read = \"\";\n\n  while(!feof(fp)) {\n    read = (char *)calloc(blocksize + 1, sizeof(char));\n    fgets(read, blocksize, fp);\n    asprintf(&str, \"%s%s\", str, read);\n    free(read);\n  }\n  \n  tokens = tokenize_str(str);\n  free(str);\n\n  return tokens;\n}", "path": "tokenizer.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* tokenizes a string */\n", "func_signal": "p_atom *tokenize_str(const char *str)", "code": "{\n  p_atom *tokens = NULL;\n  static size_t i, bsc, level;\n  char *strv;\n\n  for(i = 0; i < strlen(str); i++) {\n    switch(str[i]) {\n      case '#':\n        for(; i < strlen(str) && str[i] != '\\n'; i++);\n        break;\n      case '[':\n        for(i++, level = 1; i < strlen(str); i++) {\n          if(str[i] == '[') { level++; }\n          else if(str[i] == ']') { level--; }\n          if(level <= 0) { break; }\n        }\n        break;\n      case '(':\n        atom_append(&tokens, make_atom(PT_PARENL, NULL, NULL));\n        break;\n      case ')':\n        atom_append(&tokens, make_atom(PT_PARENR, NULL, NULL));\n        break;\n      case '.':\n        atom_append(&tokens, make_atom(PT_QUOTE, NULL, NULL));\n        break;\n      case '\\'':\n        /* FIXME: string parsing code is ugly and inefficient */\n\n        strv = \"\";\n        bsc = 0;\n        /*\n         * bsc: backslash count\n         * if even, quote has not been escaped\n         * if odd, quote has been escaped\n         */\n        \n        for(i++; i < strlen(str); i++) {\n          if(str[i] == '\\'' && bsc % 2 == 0) { break; }\n          else if(str[i] == '\\\\') {\n            asprintf(&strv, \"%s\\\\\", strv);\n            bsc ++;\n          } else {\n            if(str[i] == 'n' && bsc % 2 > 0) {\n              asprintf(&strv, \"%s\\n\", strv);\n            } else {\n              asprintf(&strv, \"%s%c\", strv, str[i]);\n            }\n            bsc = 0;\n          }\n        }\n        \n        /* remove leftover backslashes */\n        strv = str_replace(strv, \"\\\\\\\\\", \"\\\\\", 0);\n        strv = str_replace(strv, \"\\\\'\", \"'\", 0);\n        strv = str_replace(strv, \"\\\\\\n\", \"\\n\", 0);\n\n        atom_append(&tokens, make_atom(P_STR, NULL, (void *)strdup(strv)));\n        free(strv);\n        break;\n      case '\"':\n        strv = \"\";\n        for(i++; i < strlen(str) && str[i] != '\"'; i++) {\n          asprintf(&strv, \"%s%c\", strv, str[i]);\n        }\n        atom_append(&tokens, make_atom(P_STR, NULL, (void *)strdup(strv)));\n        break;\n      default:\n        /* it seems to be a number */\n        if(isdigit(str[i]) || strchr(\"-\", str[i])) {\n          strv = (char *)calloc(2, sizeof(char));\n          strv[0] = str[i];\n\n          for(i++; isdigit(str[i]) || str[i] == '.'; i++) {\n            asprintf(&strv, \"%s%c\", strv, str[i]);\n          }\n          i--; /* might've overrun something important */\n          \n          atom_append(&tokens, make_atom(P_NUM, NULL, atom_dupnum(strtod(strv, NULL))));\n          free(strv);\n        /* TODO: allow non-alphanumeric characters */\n        } else if(IS_SYMBOL_CHAR(str[i])) {\n          strv = (char *)calloc(2, sizeof(char));\n          strv[0] = str[i];\n\n          for(i++; IS_SYMBOL_CHAR(str[i]); i++) {\n            asprintf(&strv, \"%s%c\", strv, str[i]);\n          }\n          i--;\n\n          atom_append(&tokens, make_atom(P_SYM, NULL, (void *)strdup(strv)));\n          free(strv);\n        }\n        break;\n    }\n  }\n\n  return tokens;\n}", "path": "tokenizer.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* append an atom [list] to another atom [list] */\n", "func_signal": "void atom_append(p_atom **target, p_atom *new)", "code": "{\n  if(!*target) {\n    *target = new;\n  } else {\n    atom_tail(*target)->next = (struct p_atom *)new;\n  }\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/* return tail end of a list of atoms */\n", "func_signal": "p_atom *atom_tail(p_atom *atom)", "code": "{\n  if(!atom) { return NIL_ATOM; }\n  while(atom->next) {\n    /*\n     * FIXME: w/o cast, gcc throws 'assignment from incompatible pointer type'\n     * This is due to ->next being 'struct p_atom *' and atom being 'p_atom *'.\n     */\n    atom = (p_atom *)atom->next;\n  }\n  return atom;\n}", "path": "atom.c", "repo_name": "peasantoid/punt", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 336}
{"docstring": "/*\n** Locate and return an entry from the db.aCollSeq hash table. If the entry\n** specified by zName and nName is not found and parameter 'create' is\n** true, then create a new entry. Otherwise return NULL.\n**\n** Each pointer stored in the sqlite3.aCollSeq hash table contains an\n** array of three CollSeq structures. The first is the collation sequence\n** prefferred for UTF-8, the second UTF-16le, and the third UTF-16be.\n**\n** Stored immediately after the three collation sequences is a copy of\n** the collation sequence name. A pointer to this string is stored in\n** each collation sequence structure.\n*/\n", "func_signal": "static CollSeq *findCollSeqEntry(\n  sqlite3 *db,\n  const char *zName,\n  int nName,\n  int create\n)", "code": "{\n  CollSeq *pColl;\n  if( nName<0 ) nName = sqlite3Strlen(db, zName);\n  pColl = sqlite3HashFind(&db->aCollSeq, zName, nName);\n\n  if( 0==pColl && create ){\n    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1 );\n    if( pColl ){\n      CollSeq *pDel = 0;\n      pColl[0].zName = (char*)&pColl[3];\n      pColl[0].enc = SQLITE_UTF8;\n      pColl[1].zName = (char*)&pColl[3];\n      pColl[1].enc = SQLITE_UTF16LE;\n      pColl[2].zName = (char*)&pColl[3];\n      pColl[2].enc = SQLITE_UTF16BE;\n      memcpy(pColl[0].zName, zName, nName);\n      pColl[0].zName[nName] = 0;\n      pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl);\n\n      /* If a malloc() failure occured in sqlite3HashInsert(), it will \n      ** return the pColl pointer to be deleted (because it wasn't added\n      ** to the hash table).\n      */\n      assert( pDel==0 || pDel==pColl );\n      if( pDel!=0 ){\n        db->mallocFailed = 1;\n        sqlite3DbFree(db, pDel);\n        pColl = 0;\n      }\n    }\n  }\n  return pColl;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Read part of the data associated with cursor pCur.  Exactly\n** \"amt\" bytes will be transfered into pBuf[].  The transfer\n** begins at \"offset\".\n**\n** Return SQLITE_OK on success or an error code if anything goes\n** wrong.  An error is returned if \"offset+amt\" is larger than\n** the available payload.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf)", "code": "{\n  int rc;\n\n#ifndef SQLITE_OMIT_INCRBLOB\n  if ( pCur->eState==CURSOR_INVALID ){\n    return SQLITE_ABORT;\n  }\n#endif\n\n  assert( cursorHoldsMutex(pCur) );\n  rc = restoreCursorPosition(pCur);\n  if( rc==SQLITE_OK ){\n    assert( pCur->eState==CURSOR_VALID );\n    assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] );\n    assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );\n    rc = accessPayload(pCur, offset, amt, pBuf, 1, 0);\n  }\n  return rc;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Save the positions of all cursors except pExcept open on the table \n** with root-page iRoot. Usually, this is called just before cursor\n** pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).\n*/\n", "func_signal": "static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept)", "code": "{\n  BtCursor *p;\n  assert( sqlite3_mutex_held(pBt->mutex) );\n  assert( pExcept==0 || pExcept->pBt==pBt );\n  for(p=pBt->pCursor; p; p=p->pNext){\n    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) && \n        p->eState==CURSOR_VALID ){\n      int rc = saveCursorPosition(p);\n      if( SQLITE_OK!=rc ){\n        return rc;\n      }\n    }\n  }\n  return SQLITE_OK;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** This function registered all of the above C functions as SQL\n** functions.  This should be the only routine in this file with\n** external linkage.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(sqlite3 *db)", "code": "{\n#ifndef SQLITE_OMIT_ALTERTABLE\n  sqlite3AlterFunctions(db);\n#endif\n#ifndef SQLITE_OMIT_PARSER\n  sqlite3AttachFunctions(db);\n#endif\n  if( !db->mallocFailed ){\n    int rc = sqlite3_overload_function(db, \"MATCH\", 2);\n    assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );\n    if( rc==SQLITE_NOMEM ){\n      db->mallocFailed = 1;\n    }\n  }\n#ifdef SQLITE_SSE\n  (void)sqlite3SseFunctions(db);\n#endif\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Find the first alphanumeric token in the string zIn.  Null-terminate\n** this token.  Remove any quotation marks.  And return a pointer to\n** the result.\n*/\n", "func_signal": "static char *firstToken(char *zIn, char **pzTail)", "code": "{\n  int n, ttype;\n  while(1){\n    n = ftsGetToken(zIn, &ttype);\n    if( ttype==TOKEN_SPACE ){\n      zIn += n;\n    }else if( ttype==TOKEN_EOF ){\n      *pzTail = zIn;\n      return 0;\n    }else{\n      zIn[n] = 0;\n      *pzTail = &zIn[1];\n      dequoteString(zIn);\n      return zIn;\n    }\n  }\n  /*NOTREACHED*/\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Append N space characters to the given string buffer.\n*/\n", "func_signal": "static void appendSpace(StrAccum *pAccum, int N)", "code": "{\n  static const char zSpaces[] = \"                             \";\n  while( N>=sizeof(zSpaces)-1 ){\n    sqlite3StrAccumAppend(pAccum, zSpaces, sizeof(zSpaces)-1);\n    N -= sizeof(zSpaces)-1;\n  }\n  if( N>0 ){\n    sqlite3StrAccumAppend(pAccum, zSpaces, N);\n  }\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Return non-zero if a statement transaction is active.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIsInStmt(Btree *p)", "code": "{\n  assert( sqlite3BtreeHoldsMutex(p) );\n  return (p->pBt && p->pBt->inStmt);\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Return the size of the database file in pages.  Or return -1 if\n** there is any kind of error.\n*/\n", "func_signal": "static int pagerPagecount(Pager *pPager)", "code": "{\n  int rc;\n  int nPage;\n  rc = sqlite3PagerPagecount(pPager, &nPage);\n  return (rc==SQLITE_OK?nPage:-1);\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Initialize this module.\n*/\n", "func_signal": "static int memsys5Init(void *NotUsed)", "code": "{\n  int ii;\n  int nByte = sqlite3GlobalConfig.nHeap;\n  u8 *zByte = (u8 *)sqlite3GlobalConfig.pHeap;\n  int nMinLog;                 /* Log of minimum allocation size in bytes*/\n  int iOffset;\n\n  if( !zByte ){\n    return SQLITE_ERROR;\n  }\n\n  nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);\n  mem5.nAtom = (1<<nMinLog);\n  while( sizeof(Mem5Link)>mem5.nAtom ){\n    mem5.nAtom = mem5.nAtom << 1;\n  }\n\n  mem5.nBlock = (nByte / (mem5.nAtom+sizeof(u8)));\n  mem5.zPool = zByte;\n  mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.nAtom];\n\n  for(ii=0; ii<=LOGMAX; ii++){\n    mem5.aiFreelist[ii] = -1;\n  }\n\n  iOffset = 0;\n  for(ii=LOGMAX; ii>=0; ii--){\n    int nAlloc = (1<<ii);\n    if( (iOffset+nAlloc)<=mem5.nBlock ){\n      mem5.aCtrl[iOffset] = ii | CTRL_FREE;\n      memsys5Link(iOffset, ii);\n      iOffset += nAlloc;\n    }\n    assert((iOffset+nAlloc)>mem5.nBlock);\n  }\n\n  return SQLITE_OK;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Convert a UTF-8 filename into whatever form the underlying\n** operating system wants filenames in.  Space to hold the result\n** is obtained from malloc and must be freed by the calling\n** function.\n*/\n", "func_signal": "static void *convertUtf8Filename(const char *zFilename)", "code": "{\n  void *zConverted = 0;\n  if( isNT() ){\n    zConverted = utf8ToUnicode(zFilename);\n  }else{\n    zConverted = utf8ToMbcs(zFilename);\n  }\n  /* caller will handle out of memory */\n  return zConverted;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** The hex() function.  Interpret the argument as a blob.  Return\n** a hexadecimal rendering as text.\n*/\n", "func_signal": "static void hexFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  int i, n;\n  const unsigned char *pBlob;\n  char *zHex, *z;\n  assert( argc==1 );\n  pBlob = sqlite3_value_blob(argv[0]);\n  n = sqlite3_value_bytes(argv[0]);\n  assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */\n  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);\n  if( zHex ){\n    for(i=0; i<n; i++, pBlob++){\n      unsigned char c = *pBlob;\n      *(z++) = hexdigits[(c>>4)&0xf];\n      *(z++) = hexdigits[c&0xf];\n    }\n    *z = 0;\n    sqlite3_result_text(context, zHex, n*2, sqlite3_free);\n  }\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate that\n** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()\n** indicates that subsequent malloc failures are non-benign.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void)", "code": "{\n  wsdHooksInit;\n  if( wsdHooks.xBenignBegin ){\n    wsdHooks.xBenignBegin();\n  }\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Configuration settings for an individual database connection\n*/\n", "func_signal": "SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...)", "code": "{\n  va_list ap;\n  int rc;\n  va_start(ap, op);\n  switch( op ){\n    case SQLITE_DBCONFIG_LOOKASIDE: {\n      void *pBuf = va_arg(ap, void*);\n      int sz = va_arg(ap, int);\n      int cnt = va_arg(ap, int);\n      rc = setupLookaside(db, pBuf, sz, cnt);\n      break;\n    }\n    default: {\n      rc = SQLITE_ERROR;\n      break;\n    }\n  }\n  va_end(ap);\n  return rc;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Sleep for a little while.  Return the amount of time slept.\n** The argument is the number of microseconds we want to sleep.\n** The return value is the number of microseconds of sleep actually\n** requested from the underlying operating system, a number which\n** might be greater than or equal to the argument, but not less\n** than the argument.\n*/\n", "func_signal": "static int unixSleep(sqlite3_vfs *pVfs, int microseconds)", "code": "{\n#if defined(HAVE_USLEEP) && HAVE_USLEEP\n  usleep(microseconds);\n  return microseconds;\n#else\n  int seconds = (microseconds+999999)/1000000;\n  sleep(seconds);\n  return seconds*1000000;\n#endif\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Based on the number and size of the currently allocated chunks, return\n** the size of the next chunk to allocate, in bytes.\n*/\n", "func_signal": "static int nextChunkSize(void)", "code": "{\n  int iTotal = MIN_CHUNKSIZE;\n  Mem6Chunk *p;\n  for(p=mem6.pChunk; p; p=p->pNext){\n    iTotal = iTotal*2;\n  }\n  return iTotal;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Translate from TK_xx operator to WO_xx bitmask.\n*/\n", "func_signal": "static int operatorMask(int op)", "code": "{\n  int c;\n  assert( allowedOp(op) );\n  if( op==TK_IN ){\n    c = WO_IN;\n  }else if( op==TK_ISNULL ){\n    c = WO_ISNULL;\n  }else{\n    c = WO_EQ<<(op-TK_EQ);\n  }\n  assert( op!=TK_ISNULL || c==WO_ISNULL );\n  assert( op!=TK_IN || c==WO_IN );\n  assert( op!=TK_EQ || c==WO_EQ );\n  assert( op!=TK_LT || c==WO_LT );\n  assert( op!=TK_LE || c==WO_LE );\n  assert( op!=TK_GT || c==WO_GT );\n  assert( op!=TK_GE || c==WO_GE );\n  return c;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Invoke the given busy handler.\n**\n** This routine is called when an operation failed with a lock.\n** If this routine returns non-zero, the lock is retried.  If it\n** returns 0, the operation aborts with an SQLITE_BUSY error.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p)", "code": "{\n  int rc;\n  if( NEVER(p==0) || p->xFunc==0 || p->nBusy<0 ) return 0;\n  rc = p->xFunc(p->pArg, p->nBusy);\n  if( rc==0 ){\n    p->nBusy = -1;\n  }else{\n    p->nBusy++;\n  }\n  return rc; \n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** This routine installs a default busy handler that waits for the\n** specified number of milliseconds before returning 0.\n*/\n", "func_signal": "SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms)", "code": "{\n  if( ms>0 ){\n    db->busyTimeout = ms;\n    sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db);\n  }else{\n    sqlite3_busy_handler(db, 0, 0);\n  }\n  return SQLITE_OK;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** Compare the values pointed to by the PLReaders passed as arguments. \n** Return -1 if the value pointed to by pLeft is considered less than\n** the value pointed to by pRight, +1 if it is considered greater\n** than it, or 0 if it is equal. i.e.\n**\n**     (*pLeft - *pRight)\n**\n** A PLReader that is in the EOF condition is considered greater than\n** any other. If neither argument is in EOF state, the return value of\n** plrColumn() is used. If the plrColumn() values are equal, the\n** comparison is on the basis of plrPosition().\n*/\n", "func_signal": "static int plrCompare(PLReader *pLeft, PLReader *pRight)", "code": "{\n  assert(!plrAtEnd(pLeft) || !plrAtEnd(pRight));\n\n  if( plrAtEnd(pRight) || plrAtEnd(pLeft) ){\n    return (plrAtEnd(pRight) ? -1 : 1);\n  }\n  if( plrColumn(pLeft)!=plrColumn(pRight) ){\n    return ((plrColumn(pLeft)<plrColumn(pRight)) ? -1 : 1);\n  }\n  if( plrPosition(pLeft)!=plrPosition(pRight) ){\n    return ((plrPosition(pLeft)<plrPosition(pRight)) ? -1 : 1);\n  }\n  return 0;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n** This procedure attempts to determine whether or not threads\n** can override each others locks then sets the \n** threadsOverrideEachOthersLocks variable appropriately.\n*/\n", "func_signal": "static void testThreadLockingBehavior(int fd_orig)", "code": "{\n  int fd;\n  struct threadTestData d[2];\n  pthread_t t[2];\n\n  fd = dup(fd_orig);\n  if( fd<0 ) return;\n  memset(d, 0, sizeof(d));\n  d[0].fd = fd;\n  d[0].lock.l_type = F_RDLCK;\n  d[0].lock.l_len = 1;\n  d[0].lock.l_start = 0;\n  d[0].lock.l_whence = SEEK_SET;\n  d[1] = d[0];\n  d[1].lock.l_type = F_WRLCK;\n  pthread_create(&t[0], 0, threadLockingTest, &d[0]);\n  pthread_create(&t[1], 0, threadLockingTest, &d[1]);\n  pthread_join(t[0], 0);\n  pthread_join(t[1], 0);\n  close(fd);\n  threadsOverrideEachOthersLocks =  d[0].result==0 && d[1].result==0;\n}", "path": "sqlite\\sqlite3.c", "repo_name": "GreyTeardrop/foo_playback_log", "stars": 2, "license": "None", "language": "c", "size": 3800}
{"docstring": "/*\n * Perform a call on res_query on the concatenation of name and domain,\n * removing a trailing dot from name if domain is NULL.\n */\n", "func_signal": "int res_querydomain(const char *name, const char *domain, int class, int type,\n\t\t\tu_char *answer, int anslen)", "code": "{\n\tchar nbuf[MAXDNAME];\n\tconst char *longname = nbuf;\n\tsize_t n, d;\n#ifdef DEBUG\n\tuint32_t _res_options;\n#endif\n\n\tif (!name || !answer) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\tif (_res_options & RES_DEBUG)\n\t\tprintf(\";; res_querydomain(%s, %s, %d, %d)\\n\",\n\t\t\t   name, (domain ? domain : \"<Nil>\"), class, type);\n#endif\n\tif (domain == NULL) {\n\t\t/*\n\t\t * Check for trailing '.';\n\t\t * copy without '.' if present.\n\t\t */\n\t\tn = strlen(name);\n\t\tif (n + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0 && name[--n] == '.') {\n\t\t\tstrncpy(nbuf, name, n);\n\t\t\tnbuf[n] = '\\0';\n\t\t} else\n\t\t\tlongname = name;\n\t} else {\n\t\tn = strlen(name);\n\t\td = strlen(domain);\n\t\tif (n + 1 + d + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s.%s\", name, domain);\n\t}\n\treturn res_query(longname, class, type, answer, anslen);\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/*\n * ns_name_ntop(src, dst, dstsiz)\n *      Convert an encoded domain name to printable ascii as per RFC1035.\n * return:\n *      Number of bytes written to buffer, or -1 (with errno set)\n * notes:\n *      The root is returned as \".\"\n *      All other domains are returned in non absolute form\n */\n", "func_signal": "int ns_name_ntop(const u_char *src, char *dst, size_t dstsiz)", "code": "{\n\tstatic const char digits[] = \"0123456789\";\n\n\tconst u_char *cp;\n\tchar *dn, *eom;\n\tu_char c;\n\tu_int n;\n\n\tcp = src;\n\tdn = dst;\n\teom = dst + dstsiz;\n\n\twhile ((n = *cp++) != 0) {\n\t\tif ((n & NS_CMPRSFLGS) != 0) {\n\t\t\t/* Some kind of compression pointer. */\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dn != dst) {\n\t\t\tif (dn >= eom) {\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*dn++ = '.';\n\t\t}\n\t\tif (dn + n >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (; n > 0; n--) {\n\t\t\tc = *cp++;\n\t\t\tif (special(c)) {\n\t\t\t\tif (dn + 1 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = (char)c;\n\t\t\t} else if (!printable(c)) {\n\t\t\t\tif (dn + 3 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = digits[c / 100];\n\t\t\t\t*dn++ = digits[(c % 100) / 10];\n\t\t\t\t*dn++ = digits[c % 10];\n\t\t\t} else {\n\t\t\t\tif (dn >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = (char)c;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn == dst) {\n\t\tif (dn >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\t*dn++ = '.';\n\t}\n\tif (dn >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t*dn++ = '\\0';\n\treturn (dn - dst);\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* On entry:\n *  a.buf(len) = auxiliary buffer for IP addresses after first one\n *  a.add_count = how many additional addresses are there already\n *  outpacket = where to save ptr to raw packet? can be NULL\n * On exit:\n *  ret < 0: error, all other data is not valid\n *  ret >= 0: length of reply packet\n *  a.add_count & a.buf: updated\n *  a.rdlength: length of addresses (4 bytes for IPv4)\n *  *outpacket: updated (packet is malloced, you need to free it)\n *  a.rdata: points into *outpacket to 1st IP addr\n *      NB: don't pass outpacket == NULL if you need to use a.rdata!\n *  a.atype: type of query?\n *  a.dotted: which name we _actually_ used. May contain search domains\n *      appended. (why the filed is called \"dotted\" I have no idea)\n *      This is a malloced string. May be NULL because strdup failed.\n */\n", "func_signal": "int attribute_hidden __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a)", "code": "{\n\t/* Protected by __resolv_lock: */\n\tstatic int last_ns_num = 0;\n\tstatic uint16_t last_id = 1;\n\n\tint i, j, fd, rc;\n\tint packet_len;\n\tint name_len;\n#ifdef USE_SELECT\n\tstruct timeval tv;\n\tfd_set fds;\n#else\n\tstruct pollfd fds;\n#endif\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tstruct resolv_answer ma;\n\tbool first_answer = 1;\n\tint retries_left;\n\tunsigned char *packet = malloc(PACKETSZ);\n\tchar *lookup;\n\tint variant = -1;  /* search domain to append, -1: none */\n\tint local_ns_num = -1; /* Nth server to use */\n\tint local_id = local_id; /* for compiler */\n\tint sdomains;\n\tbool ends_with_dot;\n\tsockaddr46_t sa;\n\n\tfd = -1;\n\tlookup = NULL;\n\tname_len = strlen(name);\n\tif ((unsigned)name_len >= MAXDNAME - MAXLEN_searchdomain - 2)\n\t\tgoto fail; /* paranoia */\n\tlookup = malloc(name_len + 1/*for '.'*/ + MAXLEN_searchdomain + 1);\n\tif (!packet || !lookup || !name[0])\n\t\tgoto fail;\n\tends_with_dot = (name[name_len - 1] == '.');\n\t/* no strcpy! paranoia, user might change name[] under us */\n\tmemcpy(lookup, name, name_len);\n\n\tDPRINTF(\"Looking up type %d answer for '%s'\\n\", type, name);\n\tretries_left = 0; /* for compiler */\n\tdo {\n\t\tint pos;\n\t\tunsigned reply_timeout;\n\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\n\t\t/* Mess with globals while under lock */\n\t\t/* NB: even data *pointed to* by globals may vanish\n\t\t * outside the locks. We should assume any and all\n\t\t * globals can completely change between locked\n\t\t * code regions. OTOH, this is rare, so we don't need\n\t\t * to handle it \"nicely\" (do not skip servers,\n\t\t * search domains, etc), we only need to ensure\n\t\t * we do not SEGV, use freed+overwritten data\n\t\t * or do other Really Bad Things. */\n\t\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t\t__open_nameservers();\n\t\tsdomains = __searchdomains;\n\t\tlookup[name_len] = '\\0';\n\t\tif ((unsigned)variant < sdomains) {\n\t\t\t/* lookup is name_len + 1 + MAXLEN_searchdomain + 1 long */\n\t\t\t/* __searchdomain[] is not bigger than MAXLEN_searchdomain */\n\t\t\tlookup[name_len] = '.';\n\t\t\tstrcpy(&lookup[name_len + 1], __searchdomain[variant]);\n\t\t}\n\t\t/* first time? pick starting server etc */\n\t\tif (local_ns_num < 0) {\n\t\t\tlocal_id = last_id;\n/*TODO: implement /etc/resolv.conf's \"options rotate\"\n (a.k.a. RES_ROTATE bit in _res.options)\n\t\t\tlocal_ns_num = 0;\n\t\t\tif (_res.options & RES_ROTATE) */\n\t\t\t\tlocal_ns_num = last_ns_num;\n/*TODO: use _res.retry */\n\t\t\tretries_left = __nameservers * RES_DFLRETRY;\n\t\t}\n\t\tretries_left--;\n\t\tif (local_ns_num >= __nameservers)\n\t\t\tlocal_ns_num = 0;\n\t\tlocal_id++;\n\t\tlocal_id &= 0xffff;\n\t\t/* write new values back while still under lock */\n\t\tlast_id = local_id;\n\t\tlast_ns_num = local_ns_num;\n\t\t/* struct copy */\n\t\t/* can't just take a pointer, __nameserver[x]\n\t\t * is not safe to use outside of locks */\n\t\tsa = __nameserver[local_ns_num];\n\t\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\t\tmemset(packet, 0, PACKETSZ);\n\t\tmemset(&h, 0, sizeof(h));\n\n\t\t/* encode header */\n\t\th.id = local_id;\n\t\th.qdcount = 1;\n\t\th.rd = 1;\n\t\tDPRINTF(\"encoding header\\n\", h.rd);\n\t\ti = __encode_header(&h, packet, PACKETSZ);\n\t\tif (i < 0)\n\t\t\tgoto fail;\n\n\t\t/* encode question */\n\t\tDPRINTF(\"lookup name: %s\\n\", lookup);\n\t\tq.dotted = lookup;\n\t\tq.qtype = type;\n\t\tq.qclass = C_IN; /* CLASS_IN */\n\t\tj = __encode_question(&q, packet+i, PACKETSZ-i);\n\t\tif (j < 0)\n\t\t\tgoto fail;\n\t\tpacket_len = i + j;\n\n\t\t/* send packet */\n\t\tDPRINTF(\"On try %d, sending query to port %d\\n\",\n\t\t\t\tretries_left, NAMESERVER_PORT);\n\t\tfd = socket(sa.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\t\tif (fd < 0) /* paranoia */\n\t\t\tgoto try_next_server;\n\t\trc = connect(fd, &sa.sa, sizeof(sa));\n\t\tif (rc < 0) {\n\t\t\t/*if (errno == ENETUNREACH) { */\n\t\t\t\t/* routing error, presume not transient */\n\t\t\t\tgoto try_next_server;\n\t\t\t/*} */\n/*For example, what transient error this can be? Can't think of any */\n\t\t\t/* retry */\n\t\t\t/*continue; */\n\t\t}\n\t\tDPRINTF(\"Xmit packet len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\t/* no error check - if it fails, we time out on recv */\n\t\tsend(fd, packet, packet_len, 0);\n\n#ifdef USE_SELECT\n/*TODO: use _res.retrans*/\n\t\treply_timeout = RES_TIMEOUT;\n wait_again:\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fd, &fds);\n\t\ttv.tv_sec = reply_timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (select(fd + 1, &fds, NULL, NULL, &tv) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\treply_timeout--;\n#else\n\t\treply_timeout = RES_TIMEOUT * 1000;\n wait_again:\n\t\tfds.fd = fd;\n\t\tfds.events = POLLIN;\n\t\tif (poll(&fds, 1, reply_timeout) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n/*TODO: better timeout accounting?*/\n\t\treply_timeout -= 1000;\n#endif\n\n/* vda: a bogus response seen in real world (caused SEGV in uclibc):\n * \"ping www.google.com\" sending AAAA query and getting\n * response with one answer... with answer part missing!\n * Fixed by thorough checks for not going past the packet's end.\n */\n#ifdef DEBUG\n\t\t{\n\t\t\tstatic const char test_query[32] = \"\\0\\2\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tstatic const char test_respn[32] = \"\\0\\2\\201\\200\\0\\1\\0\\1\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tpos = memcmp(packet + 2, test_query + 2, 30);\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n\t\t\tif (pos == 0) {\n\t\t\t\tpacket_len = 32;\n\t\t\t\tmemcpy(packet + 2, test_respn + 2, 30);\n\t\t\t}\n\t\t}\n#else\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n#endif\n\n\t\tif (packet_len < HFIXEDSZ) {\n\t\t\t/* too short!\n\t\t\t * it's just a bogus packet from somewhere */\n bogus_packet:\n\t\t\tif (reply_timeout)\n\t\t\t\tgoto wait_again;\n\t\t\tgoto try_next_server;\n\t\t}\n\t\t__decode_header(packet, &h);\n\t\tDPRINTF(\"len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\tif (h.id != local_id || !h.qr) {\n\t\t\t/* unsolicited */\n\t\t\tgoto bogus_packet;\n\t\t}\n\n\t\tDPRINTF(\"Got response (i think)!\\n\");\n\t\tDPRINTF(\"qrcount=%d,ancount=%d,nscount=%d,arcount=%d\\n\",\n\t\t\t\th.qdcount, h.ancount, h.nscount, h.arcount);\n\t\tDPRINTF(\"opcode=%d,aa=%d,tc=%d,rd=%d,ra=%d,rcode=%d\\n\",\n\t\t\t\th.opcode, h.aa, h.tc, h.rd, h.ra, h.rcode);\n\n\t\t/* bug 660 says we treat negative response as an error\n\t\t * and retry, which is, eh, an error. :)\n\t\t * We were incurring long delays because of this. */\n\t\tif (h.rcode == NXDOMAIN) {\n\t\t\t/* if possible, try next search domain */\n\t\t\tif (!ends_with_dot) {\n\t\t\t\tDPRINTF(\"variant:%d sdomains:%d\\n\", variant, sdomains);\n\t\t\t\tif (variant < sdomains - 1) {\n\t\t\t\t\t/* next search domain */\n\t\t\t\t\tvariant++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* no more search domains to try */\n\t\t\t}\n\t\t\t/* dont loop, this is \"no such host\" situation */\n\t\t\th_errno = HOST_NOT_FOUND;\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* Insert other non-fatal errors here, which do not warrant\n\t\t * switching to next nameserver */\n\n\t\t/* Strange error, assuming this nameserver is feeling bad */\n\t\tif (h.rcode != 0)\n\t\t\tgoto try_next_server;\n\n\t\t/* Code below won't work correctly with h.ancount == 0, so... */\n\t\tif (h.ancount <= 0) {\n\t\t\th_errno = NO_DATA; /* [is this correct code to check for?] */\n\t\t\tgoto fail1;\n\t\t}\n\t\tpos = HFIXEDSZ;\n\t\tfor (j = 0; j < h.qdcount; j++) {\n\t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n\t\t\ti = __length_question(packet + pos, packet_len - pos);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"Packet'question section \"\n\t\t\t\t\t\"is truncated, trying next server\\n\");\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\t\t\tDPRINTF(\"Length of question %d is %d\\n\", j, i);\n\t\t}\n\t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n\n\t\tfirst_answer = 1;\n\t\tfor (j = 0; j < h.ancount; j++) {\n\t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n\t\t\t\t/* If the message was truncated but we have\n\t\t\t\t * decoded some answers, pretend it's OK */\n\t\t\t\tif (j && h.tc)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\n\t\t\tif (first_answer) {\n\t\t\t\tma.buf = a->buf;\n\t\t\t\tma.buflen = a->buflen;\n\t\t\t\tma.add_count = a->add_count;\n\t\t\t\tmemcpy(a, &ma, sizeof(ma));\n\t\t\t\tif (a->atype != T_SIG && (NULL == a->buf || (type != T_A && type != T_AAAA)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->atype != type) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ta->add_count = h.ancount - j - 1;\n\t\t\t\tif ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)\n\t\t\t\t\tbreak;\n\t\t\t\ta->add_count = 0;\n\t\t\t\tfirst_answer = 0;\n\t\t\t} else {\n\t\t\t\tfree(ma.dotted);\n\t\t\t\tif (ma.atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a->rdlength != ma.rdlength) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tDPRINTF(\"Answer address len(%u) differs from original(%u)\\n\",\n\t\t\t\t\t\t\tma.rdlength, a->rdlength);\n\t\t\t\t\tgoto try_next_server;\n\t\t\t\t}\n\t\t\t\tmemcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);\n\t\t\t\t++a->add_count;\n\t\t\t}\n\t\t}\n\n\t\t/* Success! */\n\t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);\n\t\tDPRINTF(\"Answer type = |%d|\\n\", a->atype);\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tif (outpacket)\n\t\t\t*outpacket = packet;\n\t\telse\n\t\t\tfree(packet);\n\t\tfree(lookup);\n\t\treturn packet_len;\n\n try_next_server:\n\t\t/* Try next nameserver */\n\t\tlocal_ns_num++;\n\t\tvariant = -1;\n\t} while (retries_left > 0);\n\n fail:\n\th_errno = NETDB_INTERNAL;\n fail1:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(lookup);\n\tfree(packet);\n\treturn -1;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/*\n * ns_name_unpack(msg, eom, src, dst, dstsiz)\n *      Unpack a domain name from a message, source may be compressed.\n * return:\n *      -1 if it fails, or consumed octets if it succeeds.\n */\n", "func_signal": "int ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n               u_char *dst, size_t dstsiz)", "code": "{\n\tconst u_char *srcp, *dstlim;\n\tu_char *dstp;\n\tint n, len, checked;\n\n\tlen = -1;\n\tchecked = 0;\n\tdstp = dst;\n\tsrcp = src;\n\tdstlim = dst + dstsiz;\n\tif (srcp < msg || srcp >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t/* Fetch next label in domain name. */\n\twhile ((n = *srcp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\tcase 0:\n\t\t\t\t/* Limit checks. */\n\t\t\t\tif (dstp + n + 1 >= dstlim || srcp + n >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += n + 1;\n\t\t\t\t*dstp++ = n;\n\t\t\t\tmemcpy(dstp, srcp, n);\n\t\t\t\tdstp += n;\n\t\t\t\tsrcp += n;\n\t\t\t\tbreak;\n\n\t\t\tcase NS_CMPRSFLGS:\n\t\t\t\tif (srcp >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = srcp - src + 1;\n\t\t\t\tsrcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));\n\t\t\t\tif (srcp < msg || srcp >= eom) {  /* Out of range. */\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += 2;\n\t\t\t\t/*\n\t\t\t\t * Check for loops in the compressed name;\n\t\t\t\t * if we've looked at the whole message,\n\t\t\t\t * there must be a loop.\n\t\t\t\t */\n\t\t\t\tif (checked >= eom - msg) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;                    /* flag error */\n\t\t}\n\t}\n\t*dstp = '\\0';\n\tif (len < 0)\n\t\tlen = srcp - src;\n\treturn len;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Solaris function --\n * Return nonzero if write-only or was last written to, and 0 otherwise.\n */\n", "func_signal": "int __fwriting(FILE * __restrict stream)", "code": "{\n\t__STDIO_STREAM_VALIDATE(stream);\n\n\treturn __STDIO_STREAM_IS_WRITING_OR_WRITEONLY(stream);\n}", "path": "libc\\stdio\\__fwriting.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/*\n * Expand compressed domain name 'comp_dn' to full domain name.\n * 'msg' is a pointer to the begining of the message,\n * 'eomorig' points to the first location after the message,\n * 'exp_dn' is a pointer to a buffer of size 'length' for the result.\n * Return size of compressed name or -1 if there was an error.\n */\n", "func_signal": "int dn_expand(const u_char *msg, const u_char *eom, const u_char *src,\n\t\t\t\tchar *dst, int dstsiz)", "code": "{\n\tint n = ns_name_uncompress(msg, eom, src, dst, (size_t)dstsiz);\n\n\tif (n > 0 && dst[0] == '.')\n\t\tdst[0] = '\\0';\n\treturn n;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/*\n * ns_name_uncompress(msg, eom, src, dst, dstsiz)\n *      Expand compressed domain name to presentation format.\n * return:\n *      Number of bytes read out of `src', or -1 (with errno set).\n * note:\n *      Root domain returns as \".\" not \"\".\n */\n", "func_signal": "int ns_name_uncompress(const u_char *msg, const u_char *eom,\n\t\tconst u_char *src, char *dst, size_t dstsiz)", "code": "{\n\tu_char tmp[NS_MAXCDNAME];\n\tint n;\n\n\tn = ns_name_unpack(msg, eom, src, tmp, sizeof tmp);\n\tif (n == -1)\n\t\treturn -1;\n\tif (ns_name_ntop(tmp, dst, dstsiz) == -1)\n\t\treturn -1;\n\treturn n;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* We use this instead of memcmp because some broken C libraries\n * add additional nonstandard fields to struct tm... */\n", "func_signal": "int tm_cmp(struct tm tm1, struct tm tm2)", "code": "{\n\treturn  tm1.tm_sec  != tm2.tm_sec  ||\n\t\ttm1.tm_min  != tm2.tm_min  ||\n\t\ttm1.tm_hour != tm2.tm_hour ||\n\t\ttm1.tm_mday != tm2.tm_mday ||\n\t\ttm1.tm_mon  != tm2.tm_mon  ||\n\t\ttm1.tm_year != tm2.tm_year ||\n\t\ttm1.tm_wday != tm2.tm_wday ||\n\t\ttm1.tm_yday != tm2.tm_yday ||\n\t\ttm1.tm_isdst!= tm2.tm_isdst;\n}", "path": "test\\time\\time.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Generate a unique temporary directory name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   The directory is created, mode 700, and its name is returned.\n   (This function comes from OpenBSD.) */\n", "func_signal": "char * mkdtemp (char *template)", "code": "{\n  if (__gen_tempname (template, __GT_DIR))\n    return NULL;\n  else\n    return template;\n}", "path": "libc\\stdlib\\mkdtemp.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Open a master pseudo terminal and return its file descriptor.  */\n", "func_signal": "int\nposix_openpt (int flags)", "code": "{\n#define have_no_dev_ptmx (1<<0)\n#define devpts_mounted   (1<<1)\n#if !defined __UNIX98PTY_ONLY__\n  static smallint _state;\n#endif\n  int fd;\n\n#if !defined __UNIX98PTY_ONLY__\n  if (!(_state & have_no_dev_ptmx))\n#endif\n    {\n      fd = open (_PATH_DEVPTMX, flags);\n      if (fd != -1)\n\t{\n#if defined __ASSUME_DEVPTS__\n\t  return fd;\n#else\n\t  struct statfs fsbuf;\n\n\t  /* Check that the /dev/pts filesystem is mounted\n\t     or if /dev is a devfs filesystem (this implies /dev/pts).  */\n\t  if (\n#if !defined __UNIX98PTY_ONLY__\n\t      (_state & devpts_mounted) ||\n#endif\n\t      (__libc_statfs (_PATH_DEVPTS, &fsbuf) == 0\n\t\t  && fsbuf.f_type == DEVPTS_SUPER_MAGIC)\n\t      || (__libc_statfs (_PATH_DEV, &fsbuf) == 0\n\t\t  && fsbuf.f_type == DEVFS_SUPER_MAGIC))\n\t    {\n\t      /* Everything is ok.  */\n#if !defined __UNIX98PTY_ONLY__\n\t      _state |= devpts_mounted;\n#endif\n\t      return fd;\n\t    }\n\n\t  /* If /dev/pts is not mounted then the UNIX98 pseudo terminals\n             are not usable.  */\n\t  close (fd);\n#if !defined __UNIX98PTY_ONLY__\n\t  _state |= have_no_dev_ptmx;\n#endif\n#endif\n\t}\n      else\n\t{\n#if !defined __UNIX98PTY_ONLY__\n\t  if (errno == ENOENT || errno == ENODEV)\n\t    _state |= have_no_dev_ptmx;\n\t  else\n#endif\n\t    return -1;\n\t}\n    }\n#if !defined __UNIX98PTY_ONLY__ && defined __UCLIBC_HAS_GETPT__\n  /* If we have no ptmx then ignore flags and use the fallback.  */\n  if (_state & have_no_dev_ptmx)\n    return __bsd_getpt();\n#endif\n  return -1;\n}", "path": "libc\\stdlib\\getpt.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Will be called under __resolv_lock. */\n", "func_signal": "static void res_sync_func(void)", "code": "{\n\tstruct __res_state *rp = &(_res);\n\tint n;\n\n\t/* If we didn't get malloc failure earlier... */\n\tif (__nameserver != (void*) &__local_nameserver) {\n\t\t/* TODO:\n\t\t * if (__nameservers < rp->nscount) - try to grow __nameserver[]?\n\t\t */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameservers > rp->_u._ext.nscount)\n\t\t\t__nameservers = rp->_u._ext.nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa6 = *rp->_u._ext.nsaddrs[n]; /* struct copy */\n#else /* IPv4 only */\n\t\tif (__nameservers > rp->nscount)\n\t\t\t__nameservers = rp->nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa4 = rp->nsaddr_list[n]; /* struct copy */\n#endif\n\t}\n\t/* Extend and comment what program is known\n\t * to use which _res.XXX member(s).\n\n\t   __resolv_opts = rp->options;\n\t   ...\n\t */\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Thinking in noninternationalized USASCII (per the DNS spec),\n * is this characted special (\"in need of quoting\") ?\n */\n", "func_signal": "static int special(int ch)", "code": "{\n\tswitch (ch) {\n\t\tcase 0x22: /* '\"' */\n\t\tcase 0x2E: /* '.' */\n\t\tcase 0x3B: /* ';' */\n\t\tcase 0x5C: /* '\\\\' */\n\t\t\t/* Special modifiers in zone files. */\n\t\tcase 0x40: /* '@' */\n\t\tcase 0x24: /* '$' */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Having ungotten characters implies the stream is reading.\n * The scheme used here treats the least significant 2 bits of\n * the stream's modeflags member as follows:\n *   0 0   Not currently reading.\n *   0 1   Reading, but no ungetc() or scanf() push back chars.\n *   1 0   Reading with one ungetc() char (ungot[1] is 1)\n *         or one scanf() pushed back char (ungot[1] is 0).\n *   1 1   Reading with both an ungetc() char and a scanf()\n *         pushed back char.  Note that this must be the result\n *         of a scanf() push back (in ungot[0]) _followed_ by\n *         an ungetc() call (in ungot[1]).\n *\n * Notes:\n *   scanf() can NOT use ungetc() to push back characters.\n *     (See section 7.19.6.2 of the C9X rationale -- WG14/N897.)\n */\n", "func_signal": "int ungetc(int c, register FILE *stream)", "code": "{\n\t__STDIO_AUTO_THREADLOCK_VAR;\n\n\t__STDIO_AUTO_THREADLOCK(stream);\n\t__STDIO_STREAM_VALIDATE(stream);\n\n#ifdef __UCLIBC_MJN3_ONLY__\n#warning CONSIDER: Make fast ungetc an option?\n#endif\n#ifdef __UCLIBC_HAS_STDIO_GETC_MACRO__\n\t/* If buffered narrow reading with no ungot slots filled, and if not\n\t * ungetting a different char than the one last read from the buffer,\n\t * we can simply decrement the position and not worry about disabling\n\t * the getc macros.  This will cut down on overhead in applications\n\t * that use getc/ungetc extensively (like gcc). */\n\t/* NOTE: If we can use getc, then we are buffered narrow reading with\n\t * no ungot slots filled. */\n\tif (__STDIO_STREAM_CAN_USE_BUFFER_GET(stream)\n\t\t&& (c != EOF)\n\t\t&& (stream->__bufpos > stream->__bufstart)\n\t\t&& (stream->__bufpos[-1] == ((unsigned char)c))\n\t\t) {\n\t\t--stream->__bufpos;\n\t\t__STDIO_STREAM_CLEAR_EOF(stream); /* Must clear end-of-file flag. */\n\t} else\n#endif\n\t/* Note: Even if c == EOF, we need to initialize/verify the\n\t * stream's orientation and ensure the stream is in reading\n\t * mode (if readable and properly oriented). */\n\tif ((!__STDIO_STREAM_IS_NARROW_READING(stream)\n\t\t && __STDIO_STREAM_TRANS_TO_READ(stream, __FLAG_NARROW))\n\t\t|| ((stream->__modeflags & __FLAG_UNGOT)\n\t\t\t&& ((stream->__modeflags & 1) || stream->__ungot[1]))\n\t\t) {\n\t\tc = EOF;\n\t} else if (c != EOF) {\n\t\t__STDIO_STREAM_DISABLE_GETC(stream);\n\n\t\t/* Flag this as a user ungot, as scanf does the necessary fixup. */\n\t\tstream->__ungot[1] = 1;\n\t\tstream->__ungot[(++stream->__modeflags) & 1] = c;\n\n\t\t__STDIO_STREAM_CLEAR_EOF(stream); /* Must clear end-of-file flag. */\n\t}\n\n\t__STDIO_STREAM_VALIDATE(stream);\n\t__STDIO_AUTO_THREADUNLOCK(stream);\n\n\treturn c;\n}", "path": "libc\\stdio\\ungetc.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Our res_init never fails (always returns 0) */\n", "func_signal": "int res_init(void)", "code": "{\n\tstruct __res_state *rp = &(_res);\n\tint i;\n\tint n;\n#ifdef __UCLIBC_HAS_IPV6__\n\tint m = 0;\n#endif\n\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t__close_nameservers();\n\t__open_nameservers();\n\n\t__res_sync = res_sync_func;\n\n\tmemset(rp, 0, sizeof(*rp));\n\trp->options = RES_INIT;\n#ifdef __UCLIBC_HAS_COMPAT_RES_STATE__\n\trp->retrans = RES_TIMEOUT;\n\trp->retry = 4;\n/*TODO: pulls in largish static buffers... use simpler one? */\n\trp->id = random();\n#endif\n\trp->ndots = 1;\n#ifdef __UCLIBC_HAS_EXTRA_COMPAT_RES_STATE__\n\trp->_vcsock = -1;\n#endif\n\n\tn = __searchdomains;\n\tif (n > ARRAY_SIZE(rp->dnsrch))\n\t\tn = ARRAY_SIZE(rp->dnsrch);\n\tfor (i = 0; i < n; i++)\n\t\trp->dnsrch[i] = __searchdomain[i];\n\n\t/* copy nameservers' addresses */\n\ti = 0;\n#ifdef __UCLIBC_HAS_IPV4__\n\tn = 0;\n\twhile (n < ARRAY_SIZE(rp->nsaddr_list) && i < __nameservers) {\n\t\tif (__nameserver[i].sa.sa_family == AF_INET) {\n\t\t\trp->nsaddr_list[n] = __nameserver[i].sa4; /* struct copy */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\tif (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {\n\t\t\t\trp->_u._ext.nsaddrs[m] = (void*) &rp->nsaddr_list[n];\n\t\t\t\tm++;\n\t\t\t}\n#endif\n\t\t\tn++;\n\t\t}\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameserver[i].sa.sa_family == AF_INET6\n\t\t && m < ARRAY_SIZE(rp->_u._ext.nsaddrs)\n\t\t) {\n\t\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(sa6));\n\t\t\tif (sa6) {\n\t\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n#endif\n\t\ti++;\n\t}\n\trp->nscount = n;\n#ifdef __UCLIBC_HAS_IPV6__\n\trp->_u._ext.nscount = m;\n#endif\n\n#else /* IPv6 only */\n\twhile (m < ARRAY_SIZE(rp->_u._ext.nsaddrs) && i < __nameservers) {\n\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(sa6));\n\t\tif (sa6) {\n\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\tm++;\n\t\t}\n\t\ti++;\n\t}\n\trp->_u._ext.nscount = m;\n#endif\n\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\treturn 0;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Must be called under __resolv_lock. */\n", "func_signal": "void attribute_hidden __close_nameservers(void)", "code": "{\n\tif (__nameserver != (void*) &__local_nameserver)\n\t\tfree(__nameserver);\n\t__nameserver = NULL;\n\t__nameservers = 0;\n\twhile (__searchdomains)\n\t\tfree(__searchdomain[--__searchdomains]);\n\tfree(__searchdomain);\n\t__searchdomain = NULL;\n\t/*__searchdomains = 0; - already is */\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Must be called under __resolv_lock. */\n", "func_signal": "void attribute_hidden __open_nameservers(void)", "code": "{\n\tstatic uint32_t resolv_conf_mtime;\n\n\tchar szBuffer[MAXLEN_searchdomain];\n\tFILE *fp;\n\tint i;\n\tsockaddr46_t sa;\n\n\tif (!__res_sync) {\n\t\t/* Reread /etc/resolv.conf if it was modified.  */\n\t\tstruct stat sb;\n\t\tif (stat(\"/etc/resolv.conf\", &sb) != 0)\n\t\t\tsb.st_mtime = 0;\n\t\tif (resolv_conf_mtime != (uint32_t)sb.st_mtime) {\n\t\t\tresolv_conf_mtime = sb.st_mtime;\n\t\t\t__close_nameservers(); /* force config reread */\n\t\t}\n\t}\n\n\tif (__nameservers)\n\t\tgoto sync;\n\n\tfp = fopen(\"/etc/resolv.conf\", \"r\");\n#ifdef FALLBACK_TO_CONFIG_RESOLVCONF\n\tif (!fp) {\n\t\t/* If we do not have a pre-populated /etc/resolv.conf then\n\t\t   try to use the one from /etc/config which exists on numerous\n\t\t   systems ranging from some uClinux to IRIX installations and\n\t\t   may be the only /etc dir that was mounted rw.  */\n\t\tfp = fopen(\"/etc/config/resolv.conf\", \"r\");\n\t}\n#endif\n\n\tif (fp) {\n\t\twhile (fgets(szBuffer, sizeof(szBuffer), fp) != NULL) {\n\t\t\tvoid *ptr;\n\t\t\tchar *keyword, *p;\n\n\t\t\tkeyword = p = skip_and_NUL_space(szBuffer);\n\t\t\t/* skip keyword */\n\t\t\tp = skip_nospace(p);\n\t\t\t/* find next word */\n\t\t\tp = skip_and_NUL_space(p);\n\n\t\t\tif (strcmp(keyword, \"nameserver\") == 0) {\n\t\t\t\t/* terminate IP addr */\n\t\t\t\t*skip_nospace(p) = '\\0';\n\t\t\t\tmemset(&sa, 0, sizeof(sa));\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (inet_pton(AF_INET6, p, &sa.sa6.sin6_addr) > 0) {\n\t\t\t\t\tsa.sa6.sin6_family = AF_INET6;\n\t\t\t\t\tsa.sa6.sin6_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\t\telse if (inet_pton(AF_INET, p, &sa.sa4.sin_addr) > 0) {\n\t\t\t\t\tsa.sa4.sin_family = AF_INET;\n\t\t\t\t\tsa.sa4.sin_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n\t\t\t\telse\n\t\t\t\t\tcontinue; /* garbage on this line */\n\t\t\t\tptr = realloc(__nameserver, (__nameservers + 1) * sizeof(__nameserver[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__nameserver = ptr;\n\t\t\t\t__nameserver[__nameservers++] = sa; /* struct copy */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(keyword, \"domain\") == 0 || strcmp(keyword, \"search\") == 0) {\n\t\t\t\tchar *p1;\n\n\t\t\t\t/* free old domains (\"last 'domain' or 'search' wins\" rule) */\n\t\t\t\twhile (__searchdomains)\n\t\t\t\t\tfree(__searchdomain[--__searchdomains]);\n\t\t\t\t/*free(__searchdomain);*/\n\t\t\t\t/*__searchdomain = NULL; - not necessary */\n next_word:\n\t\t\t\t/* terminate current word */\n\t\t\t\tp1 = skip_nospace(p);\n\t\t\t\t/* find next word (maybe) */\n\t\t\t\tp1 = skip_and_NUL_space(p1);\n\t\t\t\t/* add it */\n\t\t\t\tptr = realloc(__searchdomain, (__searchdomains + 1) * sizeof(__searchdomain[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__searchdomain = ptr;\n\t\t\t\t/* NB: strlen(p) <= MAXLEN_searchdomain) because szBuffer[] is smaller */\n\t\t\t\tptr = strdup(p);\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\tDPRINTF(\"adding search %s\\n\", (char*)ptr);\n\t\t\t\t__searchdomain[__searchdomains++] = (char*)ptr;\n\t\t\t\tp = p1;\n\t\t\t\tif (*p)\n\t\t\t\t\tgoto next_word;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* if (strcmp(keyword, \"sortlist\") == 0)... */\n\t\t\t/* if (strcmp(keyword, \"options\") == 0)... */\n\t\t}\n\t\tfclose(fp);\n\t}\n\tif (__nameservers == 0) {\n\t\t/* Have to handle malloc failure! What a mess...\n\t\t * And it's not only here, we need to be careful\n\t\t * to never write into __nameserver[0] if it points\n\t\t * to constant __local_nameserver, or free it. */\n\t\t__nameserver = malloc(sizeof(__nameserver[0]));\n\t\tif (__nameserver)\n\t\t\tmemcpy(__nameserver, &__local_nameserver, sizeof(__local_nameserver));\n\t\telse\n\t\t\t__nameserver = (void*) &__local_nameserver;\n\t\t__nameservers++;\n\t}\n\tif (__searchdomains == 0) {\n\t\tchar buf[256];\n\t\tchar *p;\n\t\ti = gethostname(buf, sizeof(buf) - 1);\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tif (i == 0 && (p = strchr(buf, '.')) != NULL && p[1]) {\n\t\t\tp = strdup(p + 1);\n\t\t\tif (!p)\n\t\t\t\tgoto err;\n\t\t\t__searchdomain = malloc(sizeof(__searchdomain[0]));\n\t\t\tif (!__searchdomain) {\n\t\t\t\tfree(p);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t__searchdomain[0] = p;\n\t\t\t__searchdomains++;\n err: ;\n\t\t}\n\t}\n\tDPRINTF(\"nameservers = %d\\n\", __nameservers);\n\n sync:\n\tif (__res_sync)\n\t\t__res_sync();\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Helpers. Both stop on EOL, if it's '\\n', it is converted to NUL first */\n", "func_signal": "static char *skip_nospace(char *p)", "code": "{\n\twhile (*p != '\\0' && !isspace(*p)) {\n\t\tif (*p == '\\n') {\n\t\t\t*p = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Encode a dotted string into nameserver transport-level encoding.\n   This routine is fairly dumb, and doesn't attempt to compress\n   the data */\n", "func_signal": "int attribute_hidden __encode_dotted(const char *dotted, unsigned char *dest, int maxlen)", "code": "{\n\tunsigned used = 0;\n\n\twhile (dotted && *dotted) {\n\t\tchar *c = strchr(dotted, '.');\n\t\tint l = c ? c - dotted : strlen(dotted);\n\n\t\t/* two consecutive dots are not valid */\n\t\tif (l == 0)\n\t\t\treturn -1;\n\n\t\tif (l >= (maxlen - used - 1))\n\t\t\treturn -1;\n\n\t\tdest[used++] = l;\n\t\tmemcpy(dest + used, dotted, l);\n\t\tused += l;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tdotted = c + 1;\n\t}\n\n\tif (maxlen < 1)\n\t\treturn -1;\n\n\tdest[used++] = 0;\n\n\treturn used;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Helpers */\n", "func_signal": "static int __length_question(const unsigned char *data, int maxlen)", "code": "{\n\tconst unsigned char *start;\n\tunsigned b;\n\n\tif (!data)\n\t\treturn -1;\n\n\tstart = data;\n\twhile (1) {\n\t\tif (maxlen <= 0)\n\t\t\treturn -1;\n\t\tb = *data++;\n\t\tif (b == 0)\n\t\t\tbreak;\n\t\tif ((b & 0xc0) == 0xc0) {\n\t\t\t/* It's a \"compressed\" name. */\n\t\t\tdata++; /* skip lsb of redirected offset */\n\t\t\tmaxlen -= 2;\n\t\t\tbreak;\n\t\t}\n\t\tdata += b;\n\t\tmaxlen -= (b + 1); /* account for data++ above */\n\t}\n\t/* Up to here we were skipping encoded name */\n\n\t/* Account for QTYPE and QCLASS fields */\n\tif (maxlen < 4)\n\t\treturn -1;\n\treturn data - start + 2 + 2;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/* Decode a dotted string from nameserver transport-level encoding.\n   This routine understands compressed data. */\n", "func_signal": "int attribute_hidden __decode_dotted(const unsigned char *packet,\n\t\tint offset,\n\t\tint packet_len,\n\t\tchar *dest,\n\t\tint dest_len)", "code": "{\n\tunsigned b;\n\tbool measure = 1;\n\tunsigned total = 0;\n\tunsigned used = 0;\n\n\tif (!packet)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (offset >= packet_len)\n\t\t\treturn -1;\n\t\tb = packet[offset++];\n\t\tif (b == 0)\n\t\t\tbreak;\n\n\t\tif (measure)\n\t\t\ttotal++;\n\n\t\tif ((b & 0xc0) == 0xc0) {\n\t\t\tif (offset >= packet_len)\n\t\t\t\treturn -1;\n\t\t\tif (measure)\n\t\t\t\ttotal++;\n\t\t\t/* compressed item, redirect */\n\t\t\toffset = ((b & 0x3f) << 8) | packet[offset];\n\t\t\tmeasure = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (used + b + 1 >= dest_len)\n\t\t\treturn -1;\n\t\tif (offset + b + 1 >= packet_len)\n\t\t\treturn -1;\n\t\tmemcpy(dest + used, packet + offset, b);\n\t\toffset += b;\n\t\tused += b;\n\n\t\tif (measure)\n\t\t\ttotal += b;\n\n\t\tif (packet[offset] != 0)\n\t\t\tdest[used++] = '.';\n\t\telse\n\t\t\tdest[used++] = '\\0';\n\t}\n\n\t/* The null byte must be counted too */\n\tif (measure)\n\t\ttotal++;\n\n\tDPRINTF(\"Total decode len = %d\\n\", total);\n\n\treturn total;\n}", "path": "libc\\inet\\resolv.c", "repo_name": "mat-c/uClibc", "stars": 2, "license": "lgpl-2.1", "language": "c", "size": 17096}
{"docstring": "/*\n * Connect to TCF channel server\n */\n", "func_signal": "void channel_connect(PeerServer * ps, ChannelConnectCallBack callback, void * callback_args)", "code": "{\n    char * transportname = peer_server_getprop(ps, \"TransportName\", NULL);\n\n    if (transportname == NULL || strcmp(transportname, \"TCP\") == 0 || strcmp(transportname, \"SSL\") == 0) {\n        channel_tcp_connect(ps, callback, callback_args);\n    }\n    else {\n        callback(callback_args, ERR_INV_TRANSPORT, NULL);\n    }\n}", "path": "channel.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* defined(WIN32) */\n", "func_signal": "int run_test_process(ContextAttachCallBack * done, void * data)", "code": "{\n#if defined(WIN32)\n    char fnm[FILE_PATH_SIZE];\n    char cmd[FILE_PATH_SIZE];\n    int res = 0;\n    STARTUPINFO si;\n    PROCESS_INFORMATION prs;\n    ContextAttachArgs * args;\n\n    memset(&si, 0, sizeof(si));\n    memset(&prs, 0, sizeof(prs));\n    memset(fnm, 0, sizeof(fnm));\n    if (GetModuleFileName(NULL, fnm, sizeof(fnm)) == 0) {\n        set_win32_errno(GetLastError());\n        return -1;\n    }\n    si.cb = sizeof(si);\n    strcpy(cmd, \"agent.exe -t\");\n    if (CreateProcess(fnm, cmd, NULL, NULL,\n            FALSE, CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE | CREATE_NO_WINDOW,\n            NULL, NULL, &si, &prs) == 0) {\n        set_win32_errno(GetLastError());\n        return -1;\n    }\n    args = (ContextAttachArgs *)loc_alloc(sizeof(ContextAttachArgs));\n    args->done = done;\n    args->data = data;\n    args->thread = prs.hThread;\n    args->process = prs.hProcess;\n    res = context_attach(prs.dwProcessId, done_context_attach, args, 0);\n    if (res != 0) loc_free(args);\n    return res;\n#elif defined(_WRS_KERNEL)\n    int tid = taskCreate(\"tTcf\", 100, 0, 0x4000, (FUNCPTR)test_proc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    if (tid == 0) return -1;\n    taskStop(tid);\n    taskActivate(tid);\n    assert(taskIsStopped(tid));\n    return context_attach(tid, done, data, 0);\n#else\n    /* Create child process to debug */\n    int pid = fork();\n    if (pid < 0) return -1;\n    if (pid == 0) {\n        int fd;\n        if (context_attach_self() < 0) exit(1);\n        fd = sysconf(_SC_OPEN_MAX);\n        while (fd-- > 2) close(fd);\n#if defined(__APPLE__)\n        if (kill(getpid(), SIGSTOP) < 0) exit(1);\n#else\n        if (tkill(getpid(), SIGSTOP) < 0) exit(1);\n#endif\n        test_proc();\n        exit(0);\n    }\n    return context_attach(pid, done, data, 1);\n#endif\n}", "path": "test.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Close communication channel\n */\n", "func_signal": "void channel_close(Channel *c)", "code": "{\n    trace(LOG_PROTOCOL, \"Closing channel %#lx %s\", c, c->peer_name);\n    c->close(c, 0);\n}", "path": "channel.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Start TCF channel server\n */\n", "func_signal": "ChannelServer * channel_server(PeerServer * ps)", "code": "{\n    char * transportname = peer_server_getprop(ps, \"TransportName\", NULL);\n\n    if (transportname == NULL || strcmp(transportname, \"TCP\") == 0 || strcmp(transportname, \"SSL\") == 0) {\n        return channel_tcp_server(ps);\n    }\n    else {\n        errno = ERR_INV_TRANSPORT;\n        return NULL;\n    }\n}", "path": "channel.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* SERVICE_Streams */\n", "func_signal": "static void command_create_test_streams(char * token, Channel * c)", "code": "{\n    char id_inp[256];\n    char id_out[256];\n    long buf_size0;\n    long buf_size1;\n    int err = 0;\n\n    buf_size0 = json_read_long(&c->inp);\n    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);\n    buf_size1 = json_read_long(&c->inp);\n    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);\n    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);\n\n#if SERVICE_Streams\n    if (buf_size0 <= 0 || buf_size1 <= 0) err = ERR_INV_NUMBER;\n    if (!err) {\n        StreamsTest * st = loc_alloc_zero(sizeof(StreamsTest));\n        virtual_stream_create(DIAGNOSTICS, NULL, (unsigned)buf_size0,\n            VS_ENABLE_REMOTE_WRITE, streams_test_callback, st, &st->inp);\n        virtual_stream_create(DIAGNOSTICS, NULL, (unsigned)buf_size1,\n            VS_ENABLE_REMOTE_READ, streams_test_callback, st, &st->out);\n        virtual_stream_get_id(st->inp, id_inp, sizeof(id_inp));\n        virtual_stream_get_id(st->out, id_out, sizeof(id_out));\n    }\n#else\n    err = ERR_UNSUPPORTED;\n#endif\n    write_stringz(&c->out, \"R\");\n    write_stringz(&c->out, token);\n    write_errno(&c->out, err);\n    if (err) {\n        write_stringz(&c->out, \"null\");\n        write_stringz(&c->out, \"null\");\n    }\n    else {\n        json_write_string(&c->out, id_inp);\n        write_stream(&c->out, 0);\n        json_write_string(&c->out, id_out);\n        write_stream(&c->out, 0);\n    }\n    write_stream(&c->out, MARKER_EOM);\n}", "path": "diagnostics.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n* json_read_array - generic read array function\n*\n* This function will call the call_back with inp and arg as\n*       arguments for each element of the list.\n* Return 0 if null, 1 otherwise\n*/\n", "func_signal": "int json_read_array(InputStream * inp, JsonArrayCallBack * call_back, void * arg)", "code": "{\n    int ch = read_stream(inp);\n    if (ch == 'n') {\n        if (read_stream(inp) != 'u') exception(ERR_JSON_SYNTAX);\n        if (read_stream(inp) != 'l') exception(ERR_JSON_SYNTAX);\n        if (read_stream(inp) != 'l') exception(ERR_JSON_SYNTAX);\n        return 0;\n    }\n    if (ch != '[') {\n        exception(ERR_PROTOCOL);\n        return 1;\n    }\n    if (peek_stream(inp) == ']') {\n        read_stream(inp);\n        return 1;\n    }\n    for (;;) {\n        call_back(inp, arg);\n        ch = read_stream(inp);\n        if (ch == ',') continue;\n        if (ch == ']') break;\n        exception(ERR_JSON_SYNTAX);\n    }\n    return 1;\n}", "path": "json.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* Find peer server based on ID */\n", "func_signal": "PeerServer * peer_server_find(const char * id)", "code": "{\n    PeerServer * s;\n\n    assert(is_dispatch_thread());\n    for (s = peers; s != NULL; s = s->next) {\n        if (strcmp(s->id, id) == 0) return s;\n    }\n    return NULL;\n}", "path": "peer.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* inet_ntop()/inet_pton() are not available before Windows Vista */\n", "func_signal": "const char * inet_ntop(int af, const void * src, char * dst, socklen_t size)", "code": "{\n    char * str = NULL;\n    if (af != AF_INET) {\n#ifdef EAFNOSUPPORT\n        errno = EAFNOSUPPORT;\n#else\n        errno = EINVAL;\n#endif\n        return NULL;\n    }\n    str = inet_ntoa(*(struct in_addr *)src);\n    if ((socklen_t)strlen(str) >= size) {\n        errno = ENOSPC;\n        return NULL;\n    }\n    return strcpy(dst, str);\n}", "path": "mdep.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* ENABLE_SSL */\n", "func_signal": "static void delete_channel(ChannelTCP * c)", "code": "{\n    trace(LOG_PROTOCOL, \"Deleting channel %#lx\", c);\n    assert(c->lock_cnt == 0);\n    assert(c->magic == CHANNEL_MAGIC);\n    assert(c->read_pending == 0);\n    if (c->ibuf.handling_msg == HandleMsgTriggered) {\n        /* Cancel pending message handling since channel object is gone. */\n        c->ibuf.handling_msg = HandleMsgIdle;\n        cancel_event(handle_channel_msg, c, 0);\n    }\n    channel_clear_broadcast_group(&c->chan);\n    channel_clear_suspend_group(&c->chan);\n    c->magic = 0;\n#if ENABLE_SSL\n    if (c->ssl) SSL_free(c->ssl);\n#endif /* ENABLE_SSL */\n#if ENABLE_Splice\n    close(c->pipefd[0]);\n    close(c->pipefd[1]);\n#endif /* ENABLE_Splice */\n    loc_free(c->chan.peer_name);\n    loc_free(c);\n}", "path": "channel_tcp.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Start communication of a newly created channel\n */\n", "func_signal": "void channel_start(Channel * c)", "code": "{\n    trace(LOG_PROTOCOL, \"Starting channel %#lx %s\", c, c->peer_name);\n    c->start_comm(c);\n}", "path": "channel.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* ENABLE_Trace */\n", "func_signal": "void open_log_file(char * log_name)", "code": "{\n#if ENABLE_Trace\n    if (log_name == 0) {\n        log_file = NULL;\n    }\n    else if (strcmp(log_name, \"-\") == 0) {\n        log_file = stderr;\n    }\n    else if ((log_file = fopen(log_name, \"a\")) == NULL) {\n        fprintf(stderr, \"TCF: error: cannot create log file %s\\n\", log_name);\n        exit(1);\n    }\n#endif /* ENABLE_Trace */\n}", "path": "trace.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * strdup2() with concatenation and  end-of-memory checking.\n */\n", "func_signal": "char * loc_strdup2(const char * s1, const char * s2)", "code": "{\n    char * rval = loc_alloc(strlen(s1) + strlen(s2) + 1);\n    strcpy(rval, s1);\n    strcat(rval, s2);\n    return rval;\n}", "path": "myalloc.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * When a context is stopped by breakpoint, it is necessary to disable\n * the breakpoint temporarily before the context can be resumed.\n * This function function removes break instruction, then does single step\n * over breakpoint location, then restores break intruction.\n * Return: 0 if it is OK to resume context from current state,\n * return 1 if context needs to step over a breakpoint.\n */\n", "func_signal": "int skip_breakpoint(Context * ctx, int single_step)", "code": "{\n    BreakInstruction * bi;\n\n    assert(!ctx->exited);\n    assert(ctx->stopped);\n    assert(single_step || ctx->stepping_over_bp == NULL);\n\n    if (ctx->stepping_over_bp != NULL) return 0;\n    if (ctx->exited || ctx->exiting || !ctx->stopped_by_bp) return 0;\n\n#ifdef _WRS_KERNEL\n    /* VxWork debug library can skip breakpoint when neccesary, no code is needed here */\n    return 0;\n#else\n    assert(!ctx->regs_error);\n    bi = find_instruction(ctx, get_regs_PC(ctx->regs));\n    if (bi == NULL || bi->error) return 0;\n    bi->skip_cnt++;\n    ctx->stepping_over_bp = bi;\n    assert(bi->skip_cnt > 0);\n    context_lock(ctx);\n    post_safe_event(ctx->mem, safe_skip_breakpoint, ctx);\n    return 1;\n#endif\n}", "path": "breakpoints.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Add microsecond value to timespec.\n */\n", "func_signal": "static void time_add_usec(struct timespec * tv, unsigned long usec)", "code": "{\n    tv->tv_sec += usec / 1000000;\n    tv->tv_nsec += (usec % 1000000) * 1000;\n    if (tv->tv_nsec >= 1000000000) {\n        tv->tv_sec++;\n        tv->tv_nsec -= 1000000000;\n    }\n}", "path": "events.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Get kernel process information for all processes.\n */\n", "func_signal": "static int get_allprocesses(kinfo_proc **kprocs, int *nprocs)", "code": "{\n    size_t          len;\n    kinfo_proc *    kp;\n    int             mib_name[] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL};\n    int             mib_len = 3;\n\n    if (sysctl(mib_name, mib_len, NULL, &len, NULL, 0) < 0) {\n        return -1;\n    }\n\n    kp = (struct kinfo_proc *)malloc(len);\n\n    if (sysctl(mib_name, mib_len, kp, &len, NULL, 0) < 0) {\n        free(kp);\n        return -1;\n    }\n\n    *kprocs = kp;\n    *nprocs = len / sizeof(kinfo_proc);\n    return 0;\n}", "path": "sysmon.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * strndup() with end-of-memory checking.\n */\n", "func_signal": "char * loc_strndup(const char * s, size_t len)", "code": "{\n    char * rval = loc_alloc(len + 1);\n    strncpy(rval, s, len);\n    rval[len] = '\\0';\n    return rval;\n}", "path": "myalloc.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* NDEBUG */\n", "func_signal": "void check_error_debug(char * file, int line, int error)", "code": "{\n    if (error == 0) return;\n#if ENABLE_Trace\n    trace(LOG_ALWAYS, \"Fatal error %d: %s\", error, errno_to_str(error));\n    trace(LOG_ALWAYS, \"  At %s:%d\", file, line);\n    trace(LOG_ALWAYS, \"  Exiting agent...\");\n    if (log_file == stderr) exit(1);\n#endif\n    fprintf(stderr, \"Fatal error %d: %s\", error, errno_to_str(error));\n    fprintf(stderr, \"  At %s:%d\", file, line);\n    fprintf(stderr, \"  Exiting agent...\");\n    exit(1);\n}", "path": "errors.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * strdup() with end-of-memory checking.\n */\n", "func_signal": "char * loc_strdup(const char * s)", "code": "{\n    char * rval = loc_alloc(strlen(s) + 1);\n    strcpy(rval, s);\n    return rval;\n}", "path": "myalloc.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* ENABLE_Plugins */\n", "func_signal": "void ini_cmdline_handler(int interactive, Protocol * protocol)", "code": "{\n    proto = protocol;\n\n#if ENABLE_Plugins\n    if (plugin_add_function(\"Cmdline_cmd_done\", (void *)cmd_done)) {\n        fprintf(stderr, \"Error: Cannot add cmd_done shared function\\n\");\n    }\n    if (plugin_add_function(\"Cmdline_add_cmd\", (void *)add_cmdline_cmd)) {\n        fprintf(stderr, \"Error: Cannot add add_cmd shared function\\n\");\n    }\n    if (plugin_add_function(\"Cmdline_add_connect_callback\", (void *)add_connect_callback)) {\n        fprintf(stderr, \"Error: Cannot add add_connect_callback shared function\\n\");\n    }\n    if (plugin_add_function(\"Cmdline_add_disconnect_callback\", (void *)add_disconnect_callback)) {\n        fprintf(stderr, \"Error: Cannot add add_disconnect_callback shared function\\n\");\n    }\n#endif\n\n    add_cmdline_cmd(\"exit\",      \"quit the program\",          cmd_exit);\n    add_cmdline_cmd(\"tcf\",       \"send TCF command\",          cmd_tcf);\n    add_cmdline_cmd(\"peers\",     \"show list of known peers\",  cmd_peers);\n    add_cmdline_cmd(\"peerinfo\",  \"show info about a peer\",    cmd_peerinfo);\n    add_cmdline_cmd(\"connect\",   \"connect a peer\",            cmd_connect);\n\n    interactive_flag = interactive;\n    if (infile == NULL) infile = stdin;\n    check_error(pthread_mutex_init(&cmdline_mutex, NULL));\n    check_error(pthread_cond_init(&cmdline_signal, NULL));\n    /* Create thread to read cmd line */\n    check_error(pthread_create(&interactive_thread, &pthread_create_attr, interactive_handler, 0));\n}", "path": "cmdline.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/*\n * Get kernel process information for a specified pid.\n */\n", "func_signal": "static kinfo_proc *get_process(pid_t pid)", "code": "{\n    kinfo_proc *        kp;\n    int                 mib_name[] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, 0};\n    int                 mib_len = 4;\n    size_t              len = sizeof(kinfo_proc);\n\n    mib_name[3] = pid;\n\n    kp = malloc(len);\n    if (kp == NULL) {\n        return NULL;\n    }\n\n    if (sysctl(mib_name, mib_len, kp, &len, NULL, 0) < 0) {\n        free(kp);\n        return NULL;\n    }\n\n    return kp;\n}", "path": "sysmon.c", "repo_name": "ville-k/TCF-Target-Agent-for-ARM", "stars": 3, "license": "None", "language": "c", "size": 327}
{"docstring": "/* ----- Functions to update some elements in the vector tables ------ */\n", "func_signal": "int setSparseIntElements(MYSQL * sqlConn, rdbVector * vectorInfo,\n\t\t\t unsigned int indexes[], int numIndexes, \n\t\t\t int values[], int numValues)", "code": "{\n  if( !ensureVectorMaterialization(sqlConn, vectorInfo) )\n    return 0;\n\n  int i, success = 1;\n  for( i = 0 ; i < numIndexes ; i++ )\n  {\n    success *= internalSetIntElement(sqlConn, vectorInfo, \n\t\t\t     indexes[i], values[i%numValues]);\n  }\n\n  return success;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ---------- Internal Functions for data type convertions ---------------- */\n", "func_signal": "int internalConvertVectors(MYSQL * sqlConn, rdbVector * fromVector, \n\t\t\t   rdbVector * toVector, char * sqlTemplate, int type)", "code": "{\n  /* Build the sql string */\n  int length = strlen(sqlTemplate) + strlen(fromVector->tableName) + 1;\n  char * sqlString = (char*) malloc( length * sizeof(char*) );\n  sprintf(sqlString, sqlTemplate, fromVector->tableName);\n\n  initRDBVector(&toVector, 1, 0);\n  toVector->size = fromVector->size;\n\n  /* Create the view */\n  int success = 0;\n  switch( type )\n  {\n    case SXP_TYPE_INTEGER:\n      success = createNewIntegerVectorView(sqlConn, toVector, sqlString);\n      break;\n    case SXP_TYPE_DOUBLE:\n      success = createNewDoubleVectorView(sqlConn, toVector, sqlString);\n      break;\n    case SXP_TYPE_STRING:\n      success = createNewStringVectorView(sqlConn, toVector, sqlString);\n      break;\n    case SXP_TYPE_COMPLEX:\n      success = createNewComplexVectorView(sqlConn, toVector, sqlString);\n      break;\n    case SXP_TYPE_LOGIC:\n      success = createNewLogicVectorView(sqlConn, toVector, sqlString);\n      break;\n  }\n\n  if( success )\n     createVectorViewReferences(sqlConn, toVector, fromVector, fromVector);\n  else\n     toVector->size = 0;\n\n  free(sqlString);\n  return success;\n}", "path": "RIOTDB\\src\\clib\\convert_vectors.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ------- Internal functions to perform insertions of new values ------- */\n", "func_signal": "int internalInsertIntElement(MYSQL * sqlConn, rdbVector * vectorInfo, \n\t\t\t     unsigned int index, int value)", "code": "{\n  /* Build the sql string */\n  int length = strlen(sqlTemplateInsertIntElement) + \n               strlen(vectorInfo->tableName) + \n               2*MAX_INT_LENGTH + 1;\n  char strInsertElem[length];\n  sprintf( strInsertElem, sqlTemplateInsertIntElement, vectorInfo->tableName, \n\t   index, value );\n\n  /* Execute the query */\n  int success = mysql_query(sqlConn, strInsertElem);\n  return (success != 0) ? 0 : 1;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------- Functions to access matrix tables by element -------------- */\n", "func_signal": "int getIntMatrixElement(MYSQL * sqlConn, rdbMatrix * matrixInfo, \n\t\t  \tunsigned int row, unsigned int col, \n\t\t\tint * value, char * byte)", "code": "{\n  /* Execute the query to get element */\n  if( !execGetMatrixElementSQLCall(sqlConn, matrixInfo->tableName, row, col) )\n    return 0;\n\n  /* Get the value */\n  MYSQL_RES *sqlRes;\n  MYSQL_ROW sqlRow;\n  sqlRes = mysql_use_result(sqlConn);\n  *byte = 0;\n\n  if( (sqlRow = mysql_fetch_row(sqlRes)) != NULL )\n  {\n    if(sqlRow[0] != NULL)\n    {\n      *value = atoi(sqlRow[0]);\n      *byte = 1;\n    }\n  }\n\n  /* Clear out the results set */\n  while( (sqlRow = mysql_fetch_row(sqlRes)) != NULL );\n  mysql_free_result(sqlRes);\n\n  return 1;\n}", "path": "RIOTDB\\src\\clib\\get_matrix_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ----------------------- Function to check for NA ----------------------- */\n", "func_signal": "int checkRDBVectorForNA(MYSQL * sqlConn, rdbVector * vectorInfo,\n\t\t\trdbVector * resultVector)", "code": "{\n  /* Create a new logic table and initialize every entry to true*/\n  initRDBVector(&resultVector, 0, 0);\n  if( !createNewLogicVectorTable(sqlConn, resultVector) ||\n      !insertSeqLogicVectorTable(sqlConn, resultVector, '1', vectorInfo->size) )\n    return 0;\n\n  /* Update the non NA entries to False */\n  int length = strlen(sqlTemplateCheckForNA) + strlen(vectorInfo->tableName) +\n               strlen(resultVector->tableName) + 1;\n  char strUpdateSQL[length];\n  sprintf( strUpdateSQL, sqlTemplateCheckForNA, vectorInfo->tableName,\n\t   resultVector->tableName );\n\n  int success = mysql_query(sqlConn, strUpdateSQL);\n  return ( success != 0 ) ? 0 : 1;\n}", "path": "RIOTDB\\src\\clib\\handle_vector_tables.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------------------- Test Double Insertions -------------------------- */\n", "func_signal": "int TestDoubleInsertions(MYSQL* sqlConn, int testInsert, \n\t\t\t int testInsertSeq, int testLoad)", "code": "{\n  if( testInsert )\n  {\n    rdbMatrix * matrixInfo;\n    initRDBMatrix(&matrixInfo, 0, 1);\n    if( !createNewDoubleMatrixTable(sqlConn, matrixInfo) )\n    {\n       printf(\"ERROR Create Double Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n  \n    printf(\"Insert elements into double table %s\\n\", matrixInfo->tableName);\n    int size = 7;\n    double array[7] = {10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7};\n    int nRows = 3, nCols = 4;\n    if( !insertIntoDoubleMatrixTable(sqlConn, matrixInfo, array, \n\t\t\t\t     size, nRows, nCols) )\n    {\n      printf(\"ERROR Insert Elem Double Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    double value = 0;\n    char byte = 0;\n    if( !getDoubleMatrixElement(sqlConn, matrixInfo, 2, 3, &value, &byte) )\n    {\n      printf(\"ERROR Getting Elem Double Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n    if( byte == 1)\n       printf(\"Got element (row, col)=(2, 3): %lf\\n\", value);\n    else\n       printf(\"Got element (row, col)=(2, 3): NA\\n\");\n\n    if( !printDoubleRDBMatrix(sqlConn, matrixInfo) )\n      return 0;\n  }\n  \n  if( testInsertSeq )\n  {\n    rdbMatrix * matrixInfo;\n    initRDBMatrix(&matrixInfo, 0, 1);\n    if( !createNewDoubleMatrixTable(sqlConn, matrixInfo) )\n    {\n       printf(\"ERROR Create Double Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n\n    printf(\"Insert sequence into double table %s\\n\", matrixInfo->tableName);\n    int nRows = 4, nCols = 5;\n    if( !insertSeqDoubleMatrixTable(sqlConn, matrixInfo, 1, 1.8, 0.2, \n                                    nRows, nCols))\n    {\n      printf(\"ERROR Insert Seq Double Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printDoubleRDBMatrix(sqlConn, matrixInfo) )\n      return 0;\n  }\n\n  if( testLoad )\n  {\n    rdbMatrix * matrixInfo;\n    initRDBMatrix(&matrixInfo, 0, 1);\n    if( !createNewDoubleMatrixTable(sqlConn, matrixInfo) )\n    {\n       printf(\"ERROR Create Double Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n  \n    printf(\"Load data into Double Table: %s\\n\", matrixInfo->tableName);\n\n    if( !loadIntoMatrixTable(sqlConn, matrixInfo, \"testData/matrixDouble.txt\") )\n    {\n      printf(\"ERROR Load Doubles: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printDoubleRDBMatrix(sqlConn, matrixInfo) )\n      return 0;\n  }\n\n  return 1;\n}", "path": "RIOTDB\\src\\test\\testMatrix.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------------------- TestLoadAllMatrices ------------------------- */\n", "func_signal": "int TestLoadAllMatrices(MYSQL * sqlConn, int testDelete)", "code": "{\n  rdbMatrix ** arrayMatrixInfoObjects;\n  unsigned long int numTables;\n\n  if( !loadAllRDBMatrices(sqlConn, &arrayMatrixInfoObjects, &numTables) )\n  {\n     printf(\"ERROR Load RDB Matrixs: %s\\n\", mysql_error(sqlConn));\n     return 0;\n  }\n\n  printf(\"\\nNumber of tables: %ld\\n\", numTables);\n  int i;\n  for( i = 0 ; i < numTables ; i++ )\n  {\n     printf(\"\\t%ld\\t%s\", \n\t    arrayMatrixInfoObjects[i]->metadataID,\n\t    arrayMatrixInfoObjects[i]->tableName);\n\n     if( testDelete )\n     {\n        deleteRDBMatrix(sqlConn, arrayMatrixInfoObjects[i]);\n\tprintf(\"\\t--Deleted! %s\", mysql_error(sqlConn));\n     }\n     printf(\"\\n\");\n  }\n\n  for( i = 0 ; i < numTables ; i++ )\n  {\n     clearRDBMatrix(&arrayMatrixInfoObjects[i]);\n  }\n\n  if( numTables != 0 )\n  {\n     free(arrayMatrixInfoObjects);\n  }\n  printf(\"----------------------------------------\\n\");\n\n  return 1;\n}", "path": "RIOTDB\\src\\test\\testMatrix.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* -- Functions to update some elements using a Logic Vector as indexes -- */\n", "func_signal": "int setIntElementsWithLogic(MYSQL * sqlConn, rdbVector * vectorInfo,\n\t\t\t    rdbVector * logicVector, \n\t\t\t    int values[], int numValues)", "code": "{\n  if( logicVector->sxp_type != SXP_TYPE_LOGIC || logicVector->size <= 0 )\n    return 0;\n\n  if( !ensureVectorMaterialization(sqlConn, vectorInfo) )\n    return 0;\n\n  int lIndex, lSize = logicVector->size;\n  int i, success = 1;\n  int logic = 0;\n  int next = 0;\n  char flag;\n  for( i = 1 ; i <= vectorInfo->size ; i++ )\n  {\n     flag = 0;\n     lIndex = (i % lSize == 0) ? lSize : i % lSize;\n     if( getLogicElement(sqlConn, logicVector, lIndex, &logic, &flag) )\n     {\n       if( flag != 0 && logic != 0 )\n       {\n\t success *= setIntElement(sqlConn, vectorInfo, i,\n\t\t\t\t  values[next%numValues]);\n\t next++;\n       }\n     }\n  }\n\n  return success;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/*---------------  Functions to create vector tables ---------------- */\n", "func_signal": "int createNewIntVectorTable(MYSQL * sqlConn, rdbVector * vectorInfo)", "code": "{\n  vectorInfo->sxp_type = SXP_TYPE_INTEGER;\n  return internalCreateNewVectorTable(sqlConn, vectorInfo, \n\t\t\t\t      sqlTemplateCreateIntVector);\n}", "path": "RIOTDB\\src\\clib\\handle_vector_tables.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------------- Functions to dublicate a vector table -------------- */\n", "func_signal": "int duplicateVectorTable(MYSQL * sqlConn, rdbVector *  originalVector,\n\t\t\t rdbVector *copyVector)", "code": "{\n  /* Create the new table */\n  copyRDBVector(&copyVector, originalVector, 0);\n  copyVector->isView = 0;\n\n  int success = 0;\n  if( originalVector->sxp_type == SXP_TYPE_INTEGER )\n     success = createNewIntVectorTable(sqlConn, copyVector);\n  else if( originalVector->sxp_type == SXP_TYPE_DOUBLE )\n     success = createNewDoubleVectorTable(sqlConn, copyVector);\n  else if( originalVector->sxp_type == SXP_TYPE_COMPLEX )\n     success = createNewComplexVectorTable(sqlConn, copyVector);\n  else if( originalVector->sxp_type == SXP_TYPE_STRING )\n     success = createNewStringVectorTable(sqlConn, copyVector);\n  else if( originalVector->sxp_type == SXP_TYPE_LOGIC )\n     success = createNewLogicVectorTable(sqlConn, copyVector);\n\n  if( !success )\n    return 0;\n\n  /* Copy all the data to the new table */\n  int length = strlen(sqlTemplateDublicateTable) + strlen(copyVector->tableName)+\n               strlen(originalVector->tableName) + 1;\n  char strDublicateTableSQL[length];\n  sprintf( strDublicateTableSQL, sqlTemplateDublicateTable, \n\t   copyVector->tableName, originalVector->tableName );\n\n  success = mysql_query(sqlConn, strDublicateTableSQL);\n\n  return( success != 0 )? 0 : 1;\n}", "path": "RIOTDB\\src\\clib\\handle_vector_tables.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* -- Functions to update some elements using a DBVector with indexes -- */\n", "func_signal": "int setIntElementsWDBVector(MYSQL * sqlConn, rdbVector * vectorInfo,\n\t\t\t    rdbVector * indexVector, \n\t\t\t    int values[], int numValues)", "code": "{\n  if( indexVector->sxp_type != SXP_TYPE_INTEGER &&\n      indexVector->sxp_type != SXP_TYPE_DOUBLE )\n    return 0;\n\n  if( !ensureVectorMaterialization(sqlConn, vectorInfo) )\n    return 0;\n\n  int i, success = 1;\n  int dbIndex = 0;\n  int next = 0;\n  char flag;\n  for( i = 1 ; i <= indexVector->size ; i++ )\n  {\n     flag = 0;\n     if( getIntElement(sqlConn, indexVector, i, &dbIndex, &flag) )\n     {\n       if( flag != 0 )\n       {\n\t success *= setIntElement(sqlConn, vectorInfo, dbIndex, \n\t\t\t\t  values[next%numValues]);\n\t next++;\n       }\n     }\n  }\n\n  return success;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ---------- Functions to update vector tables with ranges ----------- */\n", "func_signal": "int setRangeIntElements(MYSQL * sqlConn, rdbVector * vectorInfo, \n\t\t        unsigned int greaterThan,  unsigned int lessThan, \n\t\t\tint values[], int numValues)", "code": "{\n  if( !ensureVectorMaterialization(sqlConn, vectorInfo) )\n    return 0;\n\n  int i, success = 1, j = 0;\n  for( i = greaterThan ; i <= lessThan ; i++, j++ )\n  {\n    success *= internalSetIntElement(sqlConn, vectorInfo, i, values[j%numValues]);\n  }\n\n  return success;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------------------- TestLoadAllMatrices ------------------------- */\n", "func_signal": "int TestMatrixMultiplication(MYSQL * sqlConn)", "code": "{\n    /* Create an integer matrix */\n    rdbMatrix * input1;\n    initRDBMatrix(&input1, 0, 1);\n    if( !createNewIntMatrixTable(sqlConn, input1) )\n    {\n       printf(\"ERROR Create Int Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n\n    printf(\"Insert sequence into integer table %s\\n\", input1->tableName);\n     if( !insertSeqIntMatrixTable(sqlConn, input1, 1, 18, 2, 3, 4))\n    {\n      printf(\"ERROR Insert Seq Int Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printIntegerRDBMatrix(sqlConn, input1) )\n      return 0;\n\n    /* Create another integer matrix */\n    rdbMatrix * input2;\n    initRDBMatrix(&input2, 0, 1);\n    if( !createNewIntMatrixTable(sqlConn, input2) )\n    {\n       printf(\"ERROR Create Int Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n\n    printf(\"Insert sequence into integer table %s\\n\", input2->tableName);\n    if( !insertSeqIntMatrixTable(sqlConn, input2, 1, 18, 2, 4, 3))\n    {\n      printf(\"ERROR Insert Seq Int Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printIntegerRDBMatrix(sqlConn, input2) )\n      return 0;\n\n    /* Create a double matrix */\n    rdbMatrix * input3;\n    initRDBMatrix(&input3, 0, 1);\n    if( !createNewDoubleMatrixTable(sqlConn, input3) )\n    {\n       printf(\"ERROR Create Double Table: %s\\n\", mysql_error(sqlConn)); \n       return 0;\n    }\n\n    printf(\"Insert sequence into double table %s\\n\", input3->tableName);\n    if( !insertSeqDoubleMatrixTable(sqlConn, input3, 1, 1.8, 0.2, 4, 5))\n    {\n      printf(\"ERROR Insert Seq Double Table: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printDoubleRDBMatrix(sqlConn, input3) )\n      return 0;\n\n    /* Create the result views */\n    rdbMatrix * result1, * result2;\n    initRDBMatrix(&result1, 0, 1);\n    initRDBMatrix(&result2, 0, 1);\n\n    /* Perform multiplications */\n    printf(\"Multiply %s with %s\\n\", input1->tableName, input2->tableName);\n    if( !performMatrixMultiplication(sqlConn, result1, input1, input2) )\n    {\n      printf(\"ERROR Performing multiplication: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printIntegerRDBMatrix(sqlConn, result1) )\n      return 0;\n\n    printf(\"Multiply %s with %s\\n\", input1->tableName, input3->tableName);\n    if( !performMatrixMultiplication(sqlConn, result2, input1, input3) )\n    {\n      printf(\"ERROR Performing multiplication: %s\\n\", mysql_error(sqlConn));\n      return 0;\n    }\n\n    if( !printDoubleRDBMatrix(sqlConn, result2) )\n      return 0;\n\n    return 1;\n}", "path": "RIOTDB\\src\\test\\testMatrix.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* -------------------- Function to handle table sizes ---------------------- */\n", "func_signal": "int getLogicalVectorSize(MYSQL * sqlConn, rdbVector * vectorInfo, int * size)", "code": "{\n  return internalGetVectorSize(sqlConn, vectorInfo, size,\n\t\t\t       sqlTemplateGetVectorLogicalSize);\n}", "path": "RIOTDB\\src\\clib\\handle_vector_tables.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ------------ Internal functions to perform the updates ------------ */\n", "func_signal": "int internalUpdateIntElement(MYSQL * sqlConn, rdbVector * vectorInfo, \n\t\t\t     unsigned int index, int value)", "code": "{\n  /* Build the sql string */\n  int length = strlen(sqlTemplateUpdateIntElement) + \n               strlen(vectorInfo->tableName) + \n               2*MAX_INT_LENGTH + 1;\n  char strUpdateElem[length];\n  sprintf( strUpdateElem, sqlTemplateUpdateIntElement, vectorInfo->tableName, \n\t   value, index );\n\n  /* Execute the query */\n  int success = mysql_query(sqlConn, strUpdateElem);\n  return (success != 0) ? 0 : 1;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* --------------------------- main ---------------------------------- */\n", "func_signal": "int main()", "code": "{\n  printf(\"Starting Execution!\\n\");\n\n  /* Connect to database */\n  MYSQL *sqlConn = NULL;\n  int success = connectToLocalDB(&sqlConn);\n  if( !success || sqlConn == NULL )\n  {\n     printf(\"ERROR Connect DB: %s\\n\", mysql_error(sqlConn));\n     return -1;\n  }\n\n  printf(\"Connected to DB\\n\");\n\n  /* Choose which tests to perform */\n  int testIntInsertions     = 1;\n  int testDoubleInsertions  = 1;\n\n  int testInsert    = 1;\n  int testInsertSeq = 1;\n  int testLoad      = 1;\n\n  /* ------------------------------ */\n  int testMultiplication  = 1;\n\n  /* ------------------------------ */\n  int testLoadMatrices = 1;\n  int testDelete = 0;\n\n  /* ------------------------------ */\n\n  /* Perform the tests */\n  if( testIntInsertions && \n      !TestIntegerInsertions(sqlConn, testInsert, testInsertSeq, testLoad)){\n    return -1;\n  }\n\n  if( testDoubleInsertions && \n      !TestDoubleInsertions(sqlConn, testInsert, testInsertSeq, testLoad)){\n    return -1;\n  }\n\n  /* --------------------------------------------------------------------- */\n\n  if( testMultiplication && !TestMatrixMultiplication(sqlConn) ) {\n    return -1;\n  }\n\n  /* --------------------------------------------------------------------- */\n\n  if( testLoadMatrices && !TestLoadAllMatrices(sqlConn, testDelete) ) {\n    return -1;\n  }\n\n\n  /* Close Connection */\n  mysql_close(sqlConn);\n\n  printf(\"Completed Execution!\\n\");\n\n  return 0;\n}", "path": "RIOTDB\\src\\test\\testMatrix.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ------------ Functions to delete/drop vector tables -------------- */\n", "func_signal": "int deleteRDBVector(MYSQL * sqlConn, rdbVector * vectorInfo)", "code": "{\n  /* Decrement the reference counter. \n     If it reaches zero, then we can delete */\n  if( !decrementRefCounter(sqlConn, &(vectorInfo->refCounter), \n\t\t\t   vectorInfo->metadataID) )\n    return 0;\n\n  if( vectorInfo->refCounter <= 0 && !vectorInfo->isView )\n  {\n     /* Delete the table */\n     return dropVectorTable(sqlConn, vectorInfo);\n  }\n  else if( vectorInfo->refCounter <= 0 && vectorInfo->isView )\n  {\n     /* Delete the view */\n     return dropVectorView(sqlConn, vectorInfo);\n  }\n\n  return 1;\n}", "path": "RIOTDB\\src\\clib\\handle_vector_tables.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ---------- Functions to update vector tables by element ----------- */\n", "func_signal": "int setIntElement(MYSQL * sqlConn, rdbVector * vectorInfo, \n\t\t  unsigned int index, int value)", "code": "{\n  if( !ensureVectorMaterialization(sqlConn, vectorInfo) )\n    return 0;\n\n  return internalSetIntElement(sqlConn, vectorInfo, index, value);\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ------------- Functions for data type convertions ------------------ */\n", "func_signal": "int convertNumericToComplex(MYSQL * sqlConn, rdbVector * numericVector, \n\t\t\t    rdbVector * complexVector)", "code": "{\n  return internalConvertVectors(sqlConn, numericVector, complexVector, \n\t\t\t\tsqlTemplateNumericToComplex, SXP_TYPE_COMPLEX);\n}", "path": "RIOTDB\\src\\clib\\convert_vectors.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/* ---------------- Internal functions for the setters --------------- */\n", "func_signal": "int internalSetIntElement(MYSQL * sqlConn, rdbVector * vectorInfo, \n\t\t  unsigned int index, int value)", "code": "{\n  /* If index is greater then size, then \"extend\" the vector */\n  if( index > vectorInfo->size )\n  {\n     vectorInfo->size = index;\n     setLogicalVectorSize(sqlConn, vectorInfo, index);\n     return internalInsertIntElement(sqlConn, vectorInfo, index, value);\n  }\n\n  /* Need to check the the element is already in the vector or not */\n  int current;\n  char byte = 0;\n  getIntElement(sqlConn, vectorInfo, index, &current, &byte);\n\n  if( byte == 1 && current != value )\n     return internalUpdateIntElement(sqlConn, vectorInfo, index, value);\n  else if( byte == 0 )\n     return internalInsertIntElement(sqlConn, vectorInfo, index, value);\n\n  return 1;\n}", "path": "RIOTDB\\src\\clib\\set_vector_data.c", "repo_name": "yizhang-zz/riot", "stars": 3, "license": "None", "language": "c", "size": 160}
{"docstring": "/*\n * printresults - prints a performance summary for some malloc package\n */\n", "func_signal": "static void printresults(int n, stats_t *stats)", "code": "{\n    int i;\n    double secs = 0;\n    double ops = 0;\n    double util = 0;\n\n    /* Print the individual results for each trace */\n    printf(\"%5s%7s %5s%8s%10s%6s\\n\", \n\t   \"trace\", \" valid\", \"util\", \"ops\", \"secs\", \"Kops\");\n    for (i=0; i < n; i++) {\n\tif (stats[i].valid) {\n\t    printf(\"%2d%10s%5.0f%%%8.0f%10.6f%6.0f\\n\", \n\t\t   i,\n\t\t   \"yes\",\n\t\t   stats[i].util*100.0,\n\t\t   stats[i].ops,\n\t\t   stats[i].secs,\n\t\t   (stats[i].ops/1e3)/stats[i].secs);\n\t    secs += stats[i].secs;\n\t    ops += stats[i].ops;\n\t    util += stats[i].util;\n\t}\n\telse {\n\t    printf(\"%2d%10s%6s%8s%10s%6s\\n\", \n\t\t   i,\n\t\t   \"no\",\n\t\t   \"-\",\n\t\t   \"-\",\n\t\t   \"-\",\n\t\t   \"-\");\n\t}\n    }\n\n    /* Print the aggregate results for the set of traces */\n    if (errors == 0) {\n\tprintf(\"%12s%5.0f%%%8.0f%10.6f%6.0f\\n\", \n\t       \"Total       \",\n\t       (util/n)*100.0,\n\t       ops, \n\t       secs,\n\t       (ops/1e3)/secs);\n    }\n    else {\n\tprintf(\"%12s%6s%8s%10s%6s\\n\", \n\t       \"Total       \",\n\t       \"-\", \n\t       \"-\", \n\t       \"-\", \n\t       \"-\");\n    }\n\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * add_range - As directed by request opnum in trace tracenum,\n *     we've just called the student's mm_malloc to allocate a block of \n *     size bytes at addr lo. After checking the block for correctness,\n *     we create a range struct for this block and add it to the range list. \n */\n", "func_signal": "static int add_range(range_t **ranges, char *lo, int size, \n\t\t     int tracenum, int opnum)", "code": "{\n    char *hi = lo + size - 1;\n    range_t *p;\n    char msg[MAXLINE];\n\n    assert(size > 0);\n\n    /* Payload addresses must be ALIGNMENT-byte aligned */\n    if (!IS_ALIGNED(lo)) {\n\tsprintf(msg, \"Payload address (%p) not aligned to %d bytes\", \n\t\tlo, ALIGNMENT);\n        malloc_error(tracenum, opnum, msg);\n        return 0;\n    }\n\n    /* The payload must lie within the extent of the heap */\n    if ((lo < (char *)mem_heap_lo()) || (lo > (char *)mem_heap_hi()) || \n\t(hi < (char *)mem_heap_lo()) || (hi > (char *)mem_heap_hi())) {\n\tsprintf(msg, \"Payload (%p:%p) lies outside heap (%p:%p)\",\n\t\tlo, hi, mem_heap_lo(), mem_heap_hi());\n\tmalloc_error(tracenum, opnum, msg);\n        return 0;\n    }\n\n    /* The payload must not overlap any other payloads */\n    for (p = *ranges;  p != NULL;  p = p->next) {\n        if ((lo >= p->lo && lo <= p-> hi) ||\n            (hi >= p->lo && hi <= p->hi)) {\n\t    sprintf(msg, \"Payload (%p:%p) overlaps another payload (%p:%p)\\n\",\n\t\t    lo, hi, p->lo, p->hi);\n\t    malloc_error(tracenum, opnum, msg);\n\t    return 0;\n        }\n    }\n\n    /* \n     * Everything looks OK, so remember the extent of this block \n     * by creating a range struct and adding it the range list.\n     */\n    if ((p = (range_t *)malloc(sizeof(range_t))) == NULL)\n\tunix_error(\"malloc error in add_range\");\n    p->next = *ranges;\n    p->lo = lo;\n    p->hi = hi;\n    *ranges = p;\n    return 1;\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * app_error - Report an arbitrary application error\n */\n", "func_signal": "void app_error(char *msg)", "code": "{\n    printf(\"%s\\n\", msg);\n    exit(1);\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/****************************************************************\n * All the other platforms for which we haven't implemented cycle\n * counter routines. Newer models of sparcs (v8plus) have cycle\n * counters that can be accessed from user programs, but since there\n * are still many sparc boxes out there that don't support this, we\n * haven't provided a Sparc version here.\n ***************************************************************/\n", "func_signal": "void start_counter()", "code": "{\n    printf(\"ERROR: You are trying to use a start_counter routine in clock.c\\n\");\n    printf(\"that has not been implemented yet on this platform.\\n\");\n    printf(\"Please choose another timing package in config.h.\\n\");\n    exit(1);\n}", "path": "labs\\lab3\\clock.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * eval_mm_valid - Check the mm malloc package for correctness\n */\n", "func_signal": "static int eval_mm_valid(trace_t *trace, int tracenum, range_t **ranges)", "code": "{\n    int i, j;\n    int index;\n    int size;\n    int oldsize;\n    char *newp;\n    char *oldp;\n    char *p;\n    \n    /* Reset the heap and free any records in the range list */\n    mem_reset_brk();\n    clear_ranges(ranges);\n\n    /* Call the mm package's init function */\n    if (mm_init() < 0) {\n\tmalloc_error(tracenum, 0, \"mm_init failed.\");\n\treturn 0;\n    }\n\n    /* Interpret each operation in the trace in order */\n    for (i = 0;  i < trace->num_ops;  i++) {\n\tindex = trace->ops[i].index;\n\tsize = trace->ops[i].size;\n\n        switch (trace->ops[i].type) {\n\n        case ALLOC: /* mm_malloc */\n\n\t    /* Call the student's malloc */\n\t    if ((p = mm_malloc(size)) == NULL) {\n\t\tmalloc_error(tracenum, i, \"mm_malloc failed.\");\n\t\treturn 0;\n\t    }\n\t    \n\t    /* \n\t     * Test the range of the new block for correctness and add it \n\t     * to the range list if OK. The block must be  be aligned properly,\n\t     * and must not overlap any currently allocated block. \n\t     */ \n\t    if (add_range(ranges, p, size, tracenum, i) == 0)\n\t\treturn 0;\n\t    \n\t    /* ADDED: cgw\n\t     * fill range with low byte of index.  This will be used later\n\t     * if we realloc the block and wish to make sure that the old\n\t     * data was copied to the new block\n\t     */\n\t    memset(p, index & 0xFF, size);\n\n\t    /* Remember region */\n\t    trace->blocks[index] = p;\n\t    trace->block_sizes[index] = size;\n\t    break;\n\n        case REALLOC: /* mm_realloc */\n\t    \n\t    /* Call the student's realloc */\n\t    oldp = trace->blocks[index];\n\t    if ((newp = mm_realloc(oldp, size)) == NULL) {\n\t\tmalloc_error(tracenum, i, \"mm_realloc failed.\");\n\t\treturn 0;\n\t    }\n\t    \n\t    /* Remove the old region from the range list */\n\t    remove_range(ranges, oldp);\n\t    \n\t    /* Check new block for correctness and add it to range list */\n\t    if (add_range(ranges, newp, size, tracenum, i) == 0)\n\t\treturn 0;\n\t    \n\t    /* ADDED: cgw\n\t     * Make sure that the new block contains the data from the old \n\t     * block and then fill in the new block with the low order byte\n\t     * of the new index\n\t     */\n\t    oldsize = trace->block_sizes[index];\n\t    if (size < oldsize) oldsize = size;\n\t    for (j = 0; j < oldsize; j++) {\n\t      if (newp[j] != (index & 0xFF)) {\n\t\tmalloc_error(tracenum, i, \"mm_realloc did not preserve the \"\n\t\t\t     \"data from old block\");\n\t\treturn 0;\n\t      }\n\t    }\n\t    memset(newp, index & 0xFF, size);\n\n\t    /* Remember region */\n\t    trace->blocks[index] = newp;\n\t    trace->block_sizes[index] = size;\n\t    break;\n\n        case FREE: /* mm_free */\n\t    \n\t    /* Remove region from list and call student's free function */\n\t    p = trace->blocks[index];\n\t    remove_range(ranges, p);\n\t    mm_free(p);\n\t    break;\n\n\tdefault:\n\t    app_error(\"Nonexistent request type in eval_mm_valid\");\n        }\n\n    }\n\n    /* As far as we know, this is a valid malloc package */\n    return 1;\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * eval_libc_valid - We run this function to make sure that the\n *    libc malloc can run to completion on the set of traces.\n *    We'll be conservative and terminate if any libc malloc call fails.\n *\n */\n", "func_signal": "static int eval_libc_valid(trace_t *trace, int tracenum)", "code": "{\n    int i, newsize;\n    char *p, *newp, *oldp;\n\n    for (i = 0;  i < trace->num_ops;  i++) {\n        switch (trace->ops[i].type) {\n\n        case ALLOC: /* malloc */\n\t    if ((p = malloc(trace->ops[i].size)) == NULL) {\n\t\tmalloc_error(tracenum, i, \"libc malloc failed\");\n\t\tunix_error(\"System message\");\n\t    }\n\t    trace->blocks[trace->ops[i].index] = p;\n\t    break;\n\n\tcase REALLOC: /* realloc */\n            newsize = trace->ops[i].size;\n\t    oldp = trace->blocks[trace->ops[i].index];\n\t    if ((newp = realloc(oldp, newsize)) == NULL) {\n\t\tmalloc_error(tracenum, i, \"libc realloc failed\");\n\t\tunix_error(\"System message\");\n\t    }\n\t    trace->blocks[trace->ops[i].index] = newp;\n\t    break;\n\t    \n        case FREE: /* free */\n\t    free(trace->blocks[trace->ops[i].index]);\n\t    break;\n\n\tdefault:\n\t    app_error(\"invalid operation type  in eval_libc_valid\");\n\t}\n    }\n\n    return 1;\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* while sleeping for sleeptime seconds */\n", "func_signal": "double mhz_full(int verbose, int sleeptime)", "code": "{\n    double rate;\n\n    start_counter();\n    sleep(sleeptime);\n    rate = get_counter() / (1e6*sleeptime);\n    if (verbose) \n\tprintf(\"Processor clock rate ~= %.1f MHz\\n\", rate);\n    return rate;\n}", "path": "labs\\lab3\\clock.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * clear_ranges - free all of the range records for a trace \n */\n", "func_signal": "static void clear_ranges(range_t **ranges)", "code": "{\n    range_t *p;\n    range_t *pnext;\n\n    for (p = *ranges;  p != NULL;  p = pnext) {\n        pnext = p->next;\n        free(p);\n    }\n    *ranges = NULL;\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* init the timer */\n", "func_signal": "static void init_etime(void)", "code": "{\n    first_u.it_interval.tv_sec = 0;\n    first_u.it_interval.tv_usec = 0;\n    first_u.it_value.tv_sec = MAX_ETIME;\n    first_u.it_value.tv_usec = 0;\n    setitimer(ITIMER_VIRTUAL, &first_u, NULL);\n\n    first_r.it_interval.tv_sec = 0;\n    first_r.it_interval.tv_usec = 0;\n    first_r.it_value.tv_sec = MAX_ETIME;\n    first_r.it_value.tv_usec = 0;\n    setitimer(ITIMER_REAL, &first_r, NULL);\n   \n    first_p.it_interval.tv_sec = 0;\n    first_p.it_interval.tv_usec = 0;\n    first_p.it_value.tv_sec = MAX_ETIME;\n    first_p.it_value.tv_usec = 0;\n    setitimer(ITIMER_PROF, &first_p, NULL);\n}", "path": "labs\\lab3\\ftimer.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * ftimer_gettod - Use gettimeofday to estimate the running time of\n * f(argp). Return the average of n runs.  \n */\n", "func_signal": "double ftimer_gettod(ftimer_test_funct f, void *argp, int n)", "code": "{\n    int i;\n    struct timeval stv, etv;\n    double diff;\n\n    gettimeofday(&stv, NULL);\n    for (i = 0; i < n; i++) \n\tf(argp);\n    gettimeofday(&etv,NULL);\n    diff = 1E3*(etv.tv_sec - stv.tv_sec) + 1E-3*(etv.tv_usec-stv.tv_usec);\n    diff /= n;\n    return (1E-3*diff);\n}", "path": "labs\\lab3\\ftimer.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * usage - Explain the command line arguments\n */\n", "func_signal": "static void usage(void)", "code": "{\n    fprintf(stderr, \"Usage: mdriver [-hvVal] [-f <file>] [-t <dir>]\\n\");\n    fprintf(stderr, \"Options\\n\");\n    fprintf(stderr, \"\\t-a         Don't check the team structure.\\n\");\n    fprintf(stderr, \"\\t-f <file>  Use <file> as the trace file.\\n\");\n    fprintf(stderr, \"\\t-g         Generate summary info for autograder.\\n\");\n    fprintf(stderr, \"\\t-h         Print this message.\\n\");\n    fprintf(stderr, \"\\t-l         Run libc malloc as well.\\n\");\n    fprintf(stderr, \"\\t-t <dir>   Directory to find default traces.\\n\");\n    fprintf(stderr, \"\\t-v         Print per-trace performance breakdowns.\\n\");\n    fprintf(stderr, \"\\t-V         Print additional debug info.\\n\");\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * eval_mm_util - Evaluate the space utilization of the student's package\n *   The idea is to remember the high water mark \"hwm\" of the heap for \n *   an optimal allocator, i.e., no gaps and no internal fragmentation.\n *   Utilization is the ratio hwm/heapsize, where heapsize is the \n *   size of the heap in bytes after running the student's malloc \n *   package on the trace. Note that our implementation of mem_sbrk() \n *   doesn't allow the students to decrement the brk pointer, so brk\n *   is always the high water mark of the heap. \n *   \n */\n", "func_signal": "static double eval_mm_util(trace_t *trace, int tracenum, range_t **ranges)", "code": "{   \n    int i;\n    int index;\n    int size, newsize, oldsize;\n    int max_total_size = 0;\n    int total_size = 0;\n    char *p;\n    char *newp, *oldp;\n\n    /* initialize the heap and the mm malloc package */\n    mem_reset_brk();\n    if (mm_init() < 0)\n\tapp_error(\"mm_init failed in eval_mm_util\");\n\n    for (i = 0;  i < trace->num_ops;  i++) {\n        switch (trace->ops[i].type) {\n\n        case ALLOC: /* mm_alloc */\n\t    index = trace->ops[i].index;\n\t    size = trace->ops[i].size;\n\n\t    if ((p = mm_malloc(size)) == NULL) \n\t\tapp_error(\"mm_malloc failed in eval_mm_util\");\n\t    \n\t    /* Remember region and size */\n\t    trace->blocks[index] = p;\n\t    trace->block_sizes[index] = size;\n\t    \n\t    /* Keep track of current total size\n\t     * of all allocated blocks */\n\t    total_size += size;\n\t    \n\t    /* Update statistics */\n\t    max_total_size = (total_size > max_total_size) ?\n\t\ttotal_size : max_total_size;\n\t    break;\n\n\tcase REALLOC: /* mm_realloc */\n\t    index = trace->ops[i].index;\n\t    newsize = trace->ops[i].size;\n\t    oldsize = trace->block_sizes[index];\n\n\t    oldp = trace->blocks[index];\n\t    if ((newp = mm_realloc(oldp,newsize)) == NULL)\n\t\tapp_error(\"mm_realloc failed in eval_mm_util\");\n\n\t    /* Remember region and size */\n\t    trace->blocks[index] = newp;\n\t    trace->block_sizes[index] = newsize;\n\t    \n\t    /* Keep track of current total size\n\t     * of all allocated blocks */\n\t    total_size += (newsize - oldsize);\n\t    \n\t    /* Update statistics */\n\t    max_total_size = (total_size > max_total_size) ?\n\t\ttotal_size : max_total_size;\n\t    break;\n\n        case FREE: /* mm_free */\n\t    index = trace->ops[i].index;\n\t    size = trace->block_sizes[index];\n\t    p = trace->blocks[index];\n\t    \n\t    mm_free(p);\n\t    \n\t    /* Keep track of current total size\n\t     * of all allocated blocks */\n\t    total_size -= size;\n\t    \n\t    break;\n\n\tdefault:\n\t    app_error(\"Nonexistent request type in eval_mm_util\");\n\n        }\n    }\n\n    return ((double)max_total_size / (double)mem_heapsize());\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * free_trace - Free the trace record and the three arrays it points\n *              to, all of which were allocated in read_trace().\n */\n", "func_signal": "void free_trace(trace_t *trace)", "code": "{\n    free(trace->ops);         /* free the three arrays... */\n    free(trace->blocks);      \n    free(trace->block_sizes);\n    free(trace);              /* and the trace record itself... */\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * unix_error - Report a Unix-style error\n */\n", "func_signal": "void unix_error(char *msg)", "code": "{\n    printf(\"%s: %s\\n\", msg, strerror(errno));\n    exit(1);\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * ftimer_itimer - Use the interval timer to estimate the running time\n * of f(argp). Return the average of n runs.  \n */\n", "func_signal": "double ftimer_itimer(ftimer_test_funct f, void *argp, int n)", "code": "{\n    double start, tmeas;\n    int i;\n\n    init_etime();\n    start = get_etime();\n    for (i = 0; i < n; i++) \n\tf(argp);\n    tmeas = get_etime() - start;\n    return tmeas / n;\n}", "path": "labs\\lab3\\ftimer.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*******************************\n * Machine-independent functions\n ******************************/\n", "func_signal": "double ovhd()", "code": "{\n    /* Do it twice to eliminate cache effects */\n    int i;\n    double result;\n\n    for (i = 0; i < 2; i++) {\n\tstart_counter();\n\tresult = get_counter();\n    }\n    return result;\n}", "path": "labs\\lab3\\clock.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* Return the number of cycles since the last call to start_counter. */\n", "func_signal": "double get_counter()", "code": "{\n    unsigned ncyc_hi, ncyc_lo;\n    unsigned hi, lo, borrow;\n    double result;\n\n    /* Get cycle counter */\n    access_counter(&ncyc_hi, &ncyc_lo);\n\n    /* Do double precision subtraction */\n    lo = ncyc_lo - cyc_lo;\n    borrow = lo > ncyc_lo;\n    hi = ncyc_hi - cyc_hi - borrow;\n    result = (double) hi * (1 << 30) * 4 + lo;\n    if (result < 0) {\n\tfprintf(stderr, \"Error: counter returns neg value: %.0f\\n\", result);\n    }\n    return result;\n}", "path": "labs\\lab3\\clock.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/*\n * read_trace - read a trace file and store it in memory\n */\n", "func_signal": "static trace_t *read_trace(char *tracedir, char *filename)", "code": "{\n    FILE *tracefile;\n    trace_t *trace;\n    char type[MAXLINE];\n    char path[MAXLINE];\n    unsigned index, size;\n    unsigned max_index = 0;\n    unsigned op_index;\n\n    if (verbose > 1)\n\tprintf(\"Reading tracefile: %s\\n\", filename);\n\n    /* Allocate the trace record */\n    if ((trace = (trace_t *) malloc(sizeof(trace_t))) == NULL)\n\tunix_error(\"malloc 1 failed in read_trance\");\n\t\n    /* Read the trace file header */\n    strcpy(path, tracedir);\n    strcat(path, filename);\n    if ((tracefile = fopen(path, \"r\")) == NULL) {\n\tsprintf(msg, \"Could not open %s in read_trace\", path);\n\tunix_error(msg);\n    }\n    fscanf(tracefile, \"%d\", &(trace->sugg_heapsize)); /* not used */\n    fscanf(tracefile, \"%d\", &(trace->num_ids));     \n    fscanf(tracefile, \"%d\", &(trace->num_ops));     \n    fscanf(tracefile, \"%d\", &(trace->weight));        /* not used */\n    \n    /* We'll store each request line in the trace in this array */\n    if ((trace->ops = \n\t (traceop_t *)malloc(trace->num_ops * sizeof(traceop_t))) == NULL)\n\tunix_error(\"malloc 2 failed in read_trace\");\n\n    /* We'll keep an array of pointers to the allocated blocks here... */\n    if ((trace->blocks = \n\t (char **)malloc(trace->num_ids * sizeof(char *))) == NULL)\n\tunix_error(\"malloc 3 failed in read_trace\");\n\n    /* ... along with the corresponding byte sizes of each block */\n    if ((trace->block_sizes = \n\t (size_t *)malloc(trace->num_ids * sizeof(size_t))) == NULL)\n\tunix_error(\"malloc 4 failed in read_trace\");\n    \n    /* read every request line in the trace file */\n    index = 0;\n    op_index = 0;\n    while (fscanf(tracefile, \"%s\", type) != EOF) {\n\tswitch(type[0]) {\n\tcase 'a':\n\t    fscanf(tracefile, \"%u %u\", &index, &size);\n\t    trace->ops[op_index].type = ALLOC;\n\t    trace->ops[op_index].index = index;\n\t    trace->ops[op_index].size = size;\n\t    max_index = (index > max_index) ? index : max_index;\n\t    break;\n\tcase 'r':\n\t    fscanf(tracefile, \"%u %u\", &index, &size);\n\t    trace->ops[op_index].type = REALLOC;\n\t    trace->ops[op_index].index = index;\n\t    trace->ops[op_index].size = size;\n\t    max_index = (index > max_index) ? index : max_index;\n\t    break;\n\tcase 'f':\n\t    fscanf(tracefile, \"%ud\", &index);\n\t    trace->ops[op_index].type = FREE;\n\t    trace->ops[op_index].index = index;\n\t    break;\n\tdefault:\n\t    printf(\"Bogus type character (%c) in tracefile %s\\n\", \n\t\t   type[0], path);\n\t    exit(1);\n\t}\n\top_index++;\n\t\n    }\n    fclose(tracefile);\n    assert(max_index == trace->num_ids - 1);\n    assert(trace->num_ops == op_index);\n    \n    return trace;\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * remove_range - Free the range record of block whose payload starts at lo \n */\n", "func_signal": "static void remove_range(range_t **ranges, char *lo)", "code": "{\n    range_t *p;\n    range_t **prevpp = ranges;\n    int size;\n\n    for (p = *ranges;  p != NULL; p = p->next) {\n        if (p->lo == lo) {\n\t    *prevpp = p->next;\n            size = p->hi - p->lo + 1;\n            free(p);\n            break;\n        }\n        prevpp = &(p->next);\n    }\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \n * eval_libc_speed - This is the function that is used by fcyc() to\n *    measure the running time of the libc malloc package on the set\n *    of traces.\n */\n", "func_signal": "static void eval_libc_speed(void *ptr)", "code": "{\n    int i;\n    int index, size, newsize;\n    char *p, *newp, *oldp, *block;\n    trace_t *trace = ((speed_t *)ptr)->trace;\n\n    for (i = 0;  i < trace->num_ops;  i++) {\n        switch (trace->ops[i].type) {\n        case ALLOC: /* malloc */\n\t    index = trace->ops[i].index;\n\t    size = trace->ops[i].size;\n\t    if ((p = malloc(size)) == NULL)\n\t\tunix_error(\"malloc failed in eval_libc_speed\");\n\t    trace->blocks[index] = p;\n\t    break;\n\n\tcase REALLOC: /* realloc */\n\t    index = trace->ops[i].index;\n\t    newsize = trace->ops[i].size;\n\t    oldp = trace->blocks[index];\n\t    if ((newp = realloc(oldp, newsize)) == NULL)\n\t\tunix_error(\"realloc failed in eval_libc_speed\\n\");\n\t    \n\t    trace->blocks[index] = newp;\n\t    break;\n\t    \n        case FREE: /* free */\n\t    index = trace->ops[i].index;\n\t    block = trace->blocks[index];\n\t    free(block);\n\t    break;\n\t}\n    }\n}", "path": "labs\\lab3\\mdriver.c", "repo_name": "jbauer5/labs", "stars": 2, "license": "None", "language": "c", "size": 152}
{"docstring": "// get the word defition.\n", "func_signal": "ForthWord*\nforth_get_word_def(ForthInterp *interp, const char *token)", "code": "{\n    // TODO bsearch() sorted array.\n    for (size_t i = 0; i < interp->word_pos; i++) {\n        if (STREQ(token, interp->word_def[i].tokstr.str))\n            return interp->word_def + i;\n    }\n    return NULL;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// - convert tokstr to digit.\n// - check the top word's type.\n", "func_signal": "bool\nforth_pop_digit(ForthInterp *interp, digit_t *digit)", "code": "{\n    ForthWord *top = AC_TOP_WORD(interp);\n    if (top == NULL) {\n        interp->errid = FORTH_ERR_STACK_UNDERFLOW;\n        return false;\n    }\n\n    // die if not digit.\n    if (top->type != WORD_DIGIT) {\n        interp->errid = FORTH_ERR_UNEXPECTED_TYPE;\n        return false;\n    }\n    // convert if digit is not set.\n    if (! top->digitval.is_set) {\n        if (top->tokstr.str == NULL) {\n            forth_uneval_word(interp, top);\n        }\n        forth_eval_word(interp, top);\n    }\n\n    return forth_pop_digit_fast(interp, digit);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// evaluate each member and set result to word->tokstr.\n// NOTE: word->type and its value must be set.\n", "func_signal": "void\nforth_uneval_word(ForthInterp *interp, ForthWord *word)", "code": "{\n    char tmp[interp->max_word_len];    // c99\n\n    if (word->tokstr.str != NULL) return;\n\n\n    if (word->type == WORD_DIGIT) {\n        ASSERT(interp, word->digitval.is_set);\n\n        if (! dtoa(word->digitval.digit, tmp, interp->max_word_len, 10))\n            forth_die(interp, \"dtoa\", FORTH_ERR_CONVERT_FAILED);\n\n        word_set_tokstr_copy(word, tmp);\n    }\n    else if (word->type == WORD_STRING) {\n        // TODO\n    }\n    else if (word->type == WORD_FUNC) {\n        forth_error(interp, \"tried to convert word func to string.\", FORTH_ERR_CONVERT_FAILED);\n\n        // no strict? (in Perl)\n        // word_set_str_copy(uneval, WORD_FUNC_STR);\n    }\n    else if (word->type == WORD_UNDEF) {\n        forth_error(interp, \"tried to convert undefined word to string.\", FORTH_ERR_CONVERT_FAILED);\n\n        // no strict? (in Perl)\n        // word_set_str_copy(uneval, WORD_FUNC_STR);\n    }\n    else {\n        // never reach this block\n        ASSERT(interp, 0);\n    }\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// new digit\n", "func_signal": "void\nword_init_with_digit(ForthWord *word, digit_t digit)", "code": "{\n    word_init(word);\n    word->type = WORD_DIGIT;\n    word_set_digit(word, digit);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// new str\n", "func_signal": "void\nword_init_with_str(ForthWord *word, const char *str)", "code": "{\n    word_init(word);\n    word->type = WORD_STRING;\n    word_set_str_copy(word, str);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* utility functions for word functions */\n", "func_signal": "bool\nforth_pop_word(ForthInterp *interp, ForthWord *word)", "code": "{\n    ForthWord *top = AC_TOP_WORD(interp);\n    if (top == NULL) {\n        interp->errid = FORTH_ERR_STACK_UNDERFLOW;\n        return false;\n    }\n\n    if (word != NULL) {\n        // copy to word\n        word_init_with_word(word, top);\n    }\n\n    if (top->tokstr.str != NULL) {\n        forth_debugf(interp, \"pop![%s]\\n\", top->tokstr.str);\n    } else {\n        forth_debug(interp, \"pop!\\n\");\n    }\n\n    // pop\n    word_destruct(top);\n    return stack_pop(interp->word_stack) == STACK_SUCCESS;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// faster than forth_pop_word(). do not check the top word's type.\n// NOTE:\n// - strval must be set.\n// - do not check if stack num and type are ok.\n", "func_signal": "bool\nforth_pop_str_fast(ForthInterp *interp, char *str)", "code": "{\n    ForthWord *top = AC_TOP_WORD(interp);\n\n    // assign\n    strncpy(str, top->strval.str, strlen(top->strval.str) + 1);\n\n    if (top->tokstr.str != NULL) {\n        forth_debugf(interp, \"pop![%s]\\n\", top->tokstr.str);\n    } else {\n        forth_debug(interp, \"pop!\\n\");\n    }\n\n    // pop\n    word_destruct(top);\n    return stack_pop(interp->word_stack) == STACK_SUCCESS;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "/* type conversion */\n", "func_signal": "char*\nforth_word_as_tokstr(ForthInterp *interp, ForthWord *word)", "code": "{\n    // TODO\n    if (word->tokstr.str == NULL) {\n        forth_uneval_word(interp, word);\n    }\n    return word->tokstr.str;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// tokstr copy\n", "func_signal": "void\nword_set_tokstr_copy(ForthWord *word, const char *str)", "code": "{\n    if (str == NULL) return;\n    size_t len = strlen(str);\n\n    // TODO use realloc()\n    word->tokstr.str = malloc(len + 1);\n    if (! ALLOCATED(word->tokstr.str)) {\n        FREE(word->tokstr.str);    // for safety\n        return;\n    }\n\n    strcpy(word->tokstr.str, str);\n\n    word->tokstr.capacity = len + 1;\n    word->tokstr.len = len;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// new word\n", "func_signal": "void\nword_init_with_word(ForthWord *dest, ForthWord *src)", "code": "{\n    word_init(dest);\n\n    // digit\n    word_set_digit(dest, src->digitval.digit);\n    // str\n    word_set_str_copy(dest, src->strval.str);\n    // tokstr\n    word_set_tokstr_copy(dest, src->tokstr.str);\n\n    dest->type = src->type;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// called from forth_init().\n", "func_signal": "void\nforth_init_word(ForthInterp *interp)", "code": "{\n    const int word_num = 5;\n\n    interp->word_def = CAST(\n        ForthWord*, calloc(sizeof(ForthWord), word_num)\n    );\n    word_init(interp->word_def);\n    interp->word_pos = 0;\n\n    // regist word funcs.\n    forth_regist_word(interp, \"+\", forth_word_plus);\n    forth_regist_word(interp, \"-\", forth_word_minus);\n    forth_regist_word(interp, \"*\", forth_word_multiply);\n    forth_regist_word(interp, \"/\", forth_word_divide);\n    forth_regist_word(interp, \".\", forth_word_print);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// str\n", "func_signal": "void\nword_set_str(ForthWord *word, const char *str)", "code": "{\n    size_t len = strlen(str);\n\n    word->strval.str = CAST(char*, str);\n    word->strval.capacity = -1;    // not allocated!\n    word->strval.len = len;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// new tokstr\n", "func_signal": "void\nword_init_with_tokstr(ForthWord *word, const char *tokstr)", "code": "{\n    word_init(word);\n    word_set_tokstr_copy(word, tokstr);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// NOTE: copy the address of tokstr.\n", "func_signal": "void\nforth_regist_word(ForthInterp *interp, const char *tokstr, word_func_t func)", "code": "{\n    // NOTE: copy the address of tokstr.\n    word_set_tokstr(interp->word_def + interp->word_pos, tokstr);\n    interp->word_def[interp->word_pos].func = func;\n    interp->word_def[interp->word_pos].type = WORD_FUNC;\n\n    interp->word_pos++;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// - convert tokstr to digit.\n// - check the top word's type.\n", "func_signal": "bool\nforth_pop_str(ForthInterp *interp, char *str)", "code": "{\n    ForthWord *top = AC_TOP_WORD(interp);\n    if (top == NULL) {\n        interp->errid = FORTH_ERR_STACK_UNDERFLOW;\n        return false;\n    }\n\n    // die if not string.\n    if (top->type != WORD_STRING) {\n        interp->errid = FORTH_ERR_UNEXPECTED_TYPE;\n        return false;\n    }\n    if (top->strval.str == NULL) {\n        if (top->tokstr.str == NULL) {\n            forth_uneval_word(interp, top);\n        }\n        forth_eval_word(interp, top);\n    }\n\n    return forth_pop_str_fast(interp, str);\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// evaluate word->tokstr.\n// NOTE: word->type and word->tokstr must be set.\n", "func_signal": "void\nforth_eval_word(ForthInterp *interp, ForthWord *word)", "code": "{\n    if (word->tokstr.str == NULL) return;\n\n    if (word->type == WORD_DIGIT) {\n        if (! word->digitval.is_set) {\n            ASSERT(interp, word->tokstr.str != NULL);\n            char *err = NULL;\n\n            digit_t d = atod(word->tokstr.str, 10, &err);\n            if (err != NULL) {\n                fprintf(stderr, \"%s: \", word->tokstr.str);\n                forth_die(interp, \"atod\", FORTH_ERR_CONVERT_FAILED);\n            }\n\n            word_set_digit(word, d);\n            forth_debugf(interp, \"eval: %s -> %f\\n\", word->tokstr.str, word->digitval.digit);\n        }\n    }\n    else if (word->type == WORD_STRING) {\n        if (word->strval.str == NULL) {\n            size_t len = strlen(word->tokstr.str);\n            char str[len + 1];    // evaluated string.\n\n            // empty string.\n            if (STREQ(word->tokstr.str, \"\\\"\\\"\")) {\n                word_set_str(word, \"\");\n                return;\n            }\n\n            char *begin, *end, *cur_srch_pos;\n            // set inside double quotes\n            cur_srch_pos = begin = word->tokstr.str + 1;\n            end = word->tokstr.str + word->tokstr.len - 2;    // remember null byte.\n\n            // original code from parser.c\n            while (1) {\n                end = strchr(cur_srch_pos, '\"');\n\n                /* not found '\"' */\n                if (end == NULL) {\n                    // process can't reach this block\n                    // because parser checks this when parsing.\n                    forth_die(interp, \"forth_eval_word\", FORTH_ERR_UNCLOSED_STR);\n                }\n                /* found it */\n                else if (*(end - 1) != '\\\\') {    // if not escaped string.\n                    strncpy(str, begin, end - begin);\n                    str[end - begin] = '\\0';\n                    word_set_str_copy(word, str);\n\n                    return;\n                }\n                /* found but it was escaped. search again. */\n                else {\n                    // TODO escape sequence.\n                    cur_srch_pos = end;\n                }\n            }\n        }\n    }\n    else if (word->type == WORD_FUNC) {\n        forth_error(interp, \"tried to convert word func to string.\", FORTH_ERR_CONVERT_FAILED);\n\n        // no strict? (in Perl)\n        // word_set_str_copy(word, WORD_FUNC_STR);\n    }\n    else if (word->type == WORD_UNDEF) {\n        forth_error(interp, \"tried to convert undefined word to string.\", FORTH_ERR_CONVERT_FAILED);\n\n        // no strict? (in Perl)\n        // word_set_str_copy(word, \"\");\n    }\n    else {\n        // never reach this block\n        ASSERT(interp, 0);\n    }\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// tokstr\n", "func_signal": "void\nword_set_tokstr(ForthWord *word, const char *str)", "code": "{\n    size_t len = strlen(str);\n\n    word->tokstr.str = CAST(char*, str);\n\n    word->tokstr.capacity = -1;    // not allocated!\n    word->tokstr.len = len;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// str copy\n", "func_signal": "void\nword_set_str_copy(ForthWord *word, const char *str)", "code": "{\n    if (str == NULL) return;\n    size_t len = strlen(str);\n\n    // TODO use realloc()\n    word->strval.str = malloc(len + 1);\n    if (! ALLOCATED(word->strval.str)) {\n        FREE(word->strval.str);    // for safety\n        return;\n    }\n\n    strcpy(word->strval.str, str);\n\n    word->strval.capacity = len + 1;\n    word->strval.len = len;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// faster than forth_pop_word(). do not check the top word's type.\n// NOTE:\n// - digitval must be set.\n// - do not check if stack num and type are ok.\n", "func_signal": "bool\nforth_pop_digit_fast(ForthInterp *interp, digit_t *digit)", "code": "{\n    ForthWord *top = AC_TOP_WORD(interp);\n\n    // assign\n    *digit = top->digitval.digit;\n\n    if (top->tokstr.str != NULL) {\n        forth_debugf(interp, \"pop![%s]\\n\", top->tokstr.str);\n    } else {\n        forth_debug(interp, \"pop!\\n\");\n    }\n\n    // pop\n    word_destruct(top);\n    return stack_pop(interp->word_stack) == STACK_SUCCESS;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// digit\n", "func_signal": "void\nword_set_digit(ForthWord *word, digit_t digit)", "code": "{\n    word->digitval.digit = digit;\n    word->digitval.is_set = true;\n}", "path": "word.c", "repo_name": "tyru/forth-interp", "stars": 2, "license": "None", "language": "c", "size": 140}
{"docstring": "// send packet and place it in queue to be acknowledged\n", "func_signal": "bool network_send( int len )", "code": "{\n\tbool temp = network_send_no_ack(len);\n\t\n\tUint16 i = last_out_sync - queue_out_sync;\n\tif (i < NET_PACKET_QUEUE)\n\t{\n\t\tpacket_out[i] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\tpacket_copy(packet_out[i], packet_out_temp);\n\t} else {\n\t\t// connection is probably bad now\n\t\tprintf(\"warning: outbound packet queue overflow\\n\");\n\t\treturn false;\n\t}\n\t\n\tlast_out_sync++;\n\t\n\tif (network_is_sync())\n\t\tlast_out_tick = SDL_GetTicks();\n\t\n\treturn temp;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// captures joystick input for configuring assignments\n// returns false if non-joystick input was detected\n// TODO: input from joystick other than the one being configured should not be ignored\n", "func_signal": "bool detect_joystick_assignment( int j, struct joystick_assignment_struct *assignment )", "code": "{\n\tconst int axes = SDL_JoystickNumAxes(joystick[j].handle);\n\tSint16 *axis = malloc(axes * sizeof(*axis));\n\tfor (int i = 0; i < axes; i++)\n\t{\n\t\taxis[i] = SDL_JoystickGetAxis(joystick[j].handle, i);\n\t}\n\t\n\tconst int buttons = SDL_JoystickNumButtons(joystick[j].handle);\n\tUint8 *button = malloc(buttons * sizeof(*button));\n\tfor (int i = 0; i < buttons; i++)\n\t{\n\t\tbutton[i] = SDL_JoystickGetButton(joystick[j].handle, i);\n\t}\n\t\n\tbool detected = false;\n\t\n\tdo\n\t{\n\t\tsetjasondelay(1);\n\t\t\n\t\tSDL_JoystickUpdate();\n\t\t\n\t\tfor (int i = 0; i < axes; i++)\n\t\t{\n\t\t\tSint16 temp = SDL_JoystickGetAxis(joystick[j].handle, i);\n\t\t\tif (abs(temp - axis[i]) > joystick_analog_max * 2 / 3)\n\t\t\t{\n\t\t\t\tassignment->is_axis = true;\n\t\t\t\tassignment->axis_negative = temp < axis[i];\n\t\t\t\tassignment->num = i;\n\t\t\t\tdetected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < buttons; i++)\n\t\t{\n\t\t\tUint8 temp = SDL_JoystickGetButton(joystick[j].handle, i);\n\t\t\tif (temp == 1 && button[i] == 0)\n\t\t\t{\n\t\t\t\tassignment->is_axis = false;\n\t\t\t\tassignment->axis_negative = false;\n\t\t\t\tassignment->num = i;\n\t\t\t\tdetected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (temp == 0 && button[i] == 1)\n\t\t\t{\n\t\t\t\tbutton[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tservice_SDL_events(true);\n\t\tJE_showVGA();\n\t\t\n\t\twait_delay();\n\t}\n\twhile (!detected && !newkey && !newmouse);\n\t\n\tfree(axis);\n\tfree(button);\n\t\n\treturn detected;\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// send acknowledgement packet\n", "func_signal": "int network_acknowledge( Uint16 sync )", "code": "{\n\tSDLNet_Write16(PACKET_ACKNOWLEDGE, &packet_out_temp->data[0]);\n\tSDLNet_Write16(sync,               &packet_out_temp->data[2]);\n\tnetwork_send_no_ack(4);\n\t\n\treturn 0;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// helps us be lazy by pretending the joystick is a keyboard\n", "func_signal": "void push_joysticks_as_keyboard( void )", "code": "{\n\tconst SDLKey confirm = SDLK_RETURN, cancel = SDLK_ESCAPE;\n\tconst SDLKey direction[4] = { SDLK_UP, SDLK_RIGHT, SDLK_DOWN, SDLK_LEFT };\n\t\n\tpoll_joysticks();\n\t\n\tfor (int j = 0; j < joysticks; j++)\n\t{\n\t\tif (!joystick[j].input_pressed)\n\t\t\tcontinue;\n\t\t\n\t\tif (joystick[j].confirm)\n\t\t\tpush_key(confirm);\n\t\tif (joystick[j].cancel)\n\t\t\tpush_key(cancel);\n\t\t\n\t\tfor (int d = 0; d < COUNTOF(joystick[j].direction_pressed); d++)\n\t\t{\n\t\t\tif (joystick[j].direction_pressed[d])\n\t\t\t\tpush_key(direction[d]);\n\t\t}\n\t}\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// sends SDL KEYDOWN and KEYUP events for a key\n", "func_signal": "void push_key( SDLKey key )", "code": "{\n\tSDL_Event e;\n\t\n\tmemset(&e.key.keysym, 0, sizeof(e.key.keysym));\n\t\n\te.key.keysym.sym = key;\n\te.key.keysym.unicode = key;\n\t\n\te.key.state = SDL_RELEASED;\n\t\n\te.type = SDL_KEYDOWN;\n\tSDL_PushEvent(&e);\n\t\n\te.type = SDL_KEYUP;\n\tSDL_PushEvent(&e);\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// compares assignments for equality\n", "func_signal": "bool joystick_assignment_cmp( struct joystick_assignment_struct *a, struct joystick_assignment_struct *b )", "code": "{\n\treturn a->is_axis == b->is_axis\n\t       && (a->is_axis == false || a->axis_negative == b->axis_negative)\n\t       && a->num == b->num;\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// deinitializes SDL joystick system and saves joystick assignments\n", "func_signal": "void deinit_joysticks( void )", "code": "{\n\tif (ignore_joystick)\n\t\treturn;\n\t\n\tfor (int j = 0; j < joysticks; j++)\n\t{\n\t\tif (joystick[j].handle != NULL)\n\t\t{\n\t\t\tsave_joystick_assignments(j);\n\t\t\tSDL_JoystickClose(joystick[j].handle);\n\t\t}\n\t}\n\t\n\tSDL_QuitSubSystem(SDL_INIT_JOYSTICK);\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// poll for new packets received, check that connection is alive, resend queued packets if necessary\n", "func_signal": "int network_check( void )", "code": "{\n\tif (connected)\n\t{\n\t\t// timeout\n\t\tif (!network_is_alive())\n\t\t{\n\t\t\tif (!quit)\n\t\t\t\tnetwork_tyrian_halt(2, false);\n\t\t}\n\t\t\n\t\t// keep-alive\n\t\tstatic Uint32 keep_alive_tick = 0;\n\t\tif (SDL_GetTicks() - keep_alive_tick > NET_KEEP_ALIVE)\n\t\t{\n\t\t\tnetwork_prepare(PACKET_KEEP_ALIVE);\n\t\t\tnetwork_send_no_ack(4);\n\t\t\t\n\t\t\tkeep_alive_tick = SDL_GetTicks();\n\t\t}\n\t}\n\t\n\t// retry\n\tif (packet_out[0] && SDL_GetTicks() - last_out_tick > NET_RETRY)\n\t{\n\t\tif (!SDLNet_UDP_Send(socket, 0, packet_out[0]))\n\t\t{\n\t\t\tprintf(\"SDLNet_UDP_Send: %s\\n\", SDL_GetError());\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tlast_out_tick = SDL_GetTicks();\n\t}\n\t\n\tswitch (SDLNet_UDP_Recv(socket, packet_temp))\n\t{\n\t\tcase -1:\n\t\t\tprintf(\"SDLNet_UDP_Recv: %s\\n\", SDL_GetError());\n\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (packet_temp->channel == 0 && packet_temp->len >= 4)\n\t\t\t{\n\t\t\t\tswitch (SDLNet_Read16(&packet_temp->data[0]))\n\t\t\t\t{\n\t\t\t\t\tcase PACKET_ACKNOWLEDGE:\n\t\t\t\t\t\tif ((Uint16)(SDLNet_Read16(&packet_temp->data[2]) - last_ack_sync) < NET_PACKET_QUEUE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast_ack_sync = SDLNet_Read16(&packet_temp->data[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUint16 i = SDLNet_Read16(&packet_temp->data[2]) - queue_out_sync;\n\t\t\t\t\t\t\tif (i < NET_PACKET_QUEUE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (packet_out[i])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSDLNet_FreePacket(packet_out[i]);\n\t\t\t\t\t\t\t\t\tpacket_out[i] = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove acknowledged packets from queue\n\t\t\t\t\t\twhile (packet_out[0] == NULL && (Uint16)(last_ack_sync - queue_out_sync) < NET_PACKET_QUEUE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpackets_shift_up(packet_out, NET_PACKET_QUEUE);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tqueue_out_sync++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlast_in_tick = SDL_GetTicks();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_CONNECT:\n\t\t\t\t\t\tqueue_in_sync = SDLNet_Read16(&packet_temp->data[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int i = 0; i < NET_PACKET_QUEUE; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (packet_in[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSDLNet_FreePacket(packet_in[i]);\n\t\t\t\t\t\t\t\tpacket_in[i] = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_DETAILS:\n\t\t\t\t\tcase PACKET_WAITING:\n\t\t\t\t\tcase PACKET_BUSY:\n\t\t\t\t\tcase PACKET_GAME_QUIT:\n\t\t\t\t\tcase PACKET_GAME_PAUSE:\n\t\t\t\t\tcase PACKET_GAME_MENU:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUint16 i = SDLNet_Read16(&packet_temp->data[2]) - queue_in_sync;\n\t\t\t\t\t\t\tif (i < NET_PACKET_QUEUE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (packet_in[i] == NULL)\n\t\t\t\t\t\t\t\t\tpacket_in[i] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\t\t\t\t\t\t\tpacket_copy(packet_in[i], packet_temp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// inbound packet queue overflow/underflow\n\t\t\t\t\t\t\t\t// under normal circumstances, this is okay\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnetwork_acknowledge(SDLNet_Read16(&packet_temp->data[2]));\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_KEEP_ALIVE:\n\t\t\t\t\t\tlast_in_tick = SDL_GetTicks();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_QUIT:\n\t\t\t\t\t\tif (!quit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnetwork_prepare(PACKET_QUIT);\n\t\t\t\t\t\t\tnetwork_send(4);  // PACKET_QUIT\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnetwork_acknowledge(SDLNet_Read16(&packet_temp->data[2]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!quit)\n\t\t\t\t\t\t\tnetwork_tyrian_halt(1, true);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_STATE:\n\t\t\t\t\t\t// place packet in queue if within limits\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUint16 i = SDLNet_Read16(&packet_temp->data[2]) - last_state_in_sync + 1;\n\t\t\t\t\t\t\tif (i < NET_PACKET_QUEUE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (packet_state_in[i] == NULL)\n\t\t\t\t\t\t\t\t\tpacket_state_in[i] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\t\t\t\t\t\t\tpacket_copy(packet_state_in[i], packet_temp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_STATE_XOR:\n\t\t\t\t\t\t// place packet in queue if within limits\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUint16 i = SDLNet_Read16(&packet_temp->data[2]) - last_state_in_sync + 1;\n\t\t\t\t\t\t\tif (i < NET_PACKET_QUEUE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (packet_state_in_xor[i] == NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpacket_state_in_xor[i] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\t\t\t\t\t\t\t\tpacket_copy(packet_state_in_xor[i], packet_temp);\n\t\t\t\t\t\t\t\t} else if (SDLNet_Read16(&packet_state_in_xor[i]->data[0]) != PACKET_STATE_XOR) {\n\t\t\t\t\t\t\t\t\tfor (int j = 4; j < packet_state_in_xor[i]->len; j++)\n\t\t\t\t\t\t\t\t\t\tpacket_state_in_xor[i]->data[j] ^= packet_temp->data[j];\n\t\t\t\t\t\t\t\t\tSDLNet_Write16(PACKET_STATE_XOR, &packet_state_in_xor[i]->data[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase PACKET_STATE_RESEND:\n\t\t\t\t\t\t// resend requested state packet if still available\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUint16 i = last_state_out_sync - SDLNet_Read16(&packet_temp->data[2]);\n\t\t\t\t\t\t\tif (i > 0 && i < NET_PACKET_QUEUE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (packet_state_out[i])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (!SDLNet_UDP_Send(socket, 0, packet_state_out[i]))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprintf(\"SDLNet_UDP_Send: %s\\n\", SDL_GetError());\n\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"warning: bad packet %d received\\n\", SDLNet_Read16(&packet_temp->data[0]));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t\n\treturn 0;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// attempt to punch through firewall by firing off UDP packets at the opponent\n// exchange game information\n", "func_signal": "int network_connect( void )", "code": "{\n\tSDLNet_ResolveHost(&ip, network_opponent_host, network_opponent_port);\n\t\n\tSDLNet_UDP_Bind(socket, 0, &ip);\n\t\n\tUint16 episodes = 0, episodes_local = 0;\n\tassert(EPISODE_MAX <= 16);\n\tfor (int i = EPISODE_MAX - 1; i >= 0; i--)\n\t{\n\t\tepisodes <<= 1;\n\t\tepisodes |= (episodeAvail[i] != 0);\n\t}\n\tepisodes_local = episodes;\n\t\n\tassert(NET_PACKET_SIZE - 12 >= 20 + 1);\n\tif (strlen(network_player_name) > 20)\n\t\tnetwork_player_name[20] = '\\0';\n\t\nconnect_reset:\n\tnetwork_prepare(PACKET_CONNECT);\n\tSDLNet_Write16(NET_VERSION, &packet_out_temp->data[4]);\n\tSDLNet_Write16(network_delay,   &packet_out_temp->data[6]);\n\tSDLNet_Write16(episodes_local,  &packet_out_temp->data[8]);\n\tSDLNet_Write16(thisPlayerNum,   &packet_out_temp->data[10]);\n\tstrcpy((char *)&packet_out_temp->data[12], network_player_name);\n\tnetwork_send(12 + strlen(network_player_name) + 1); // PACKET_CONNECT\n\t\n\t// until opponent sends connect packet\n\twhile (true)\n\t{\n\t\tpush_joysticks_as_keyboard();\n\t\tservice_SDL_events(false);\n\t\t\n\t\tif (newkey && lastkey_sym == SDLK_ESCAPE)\n\t\t\tnetwork_tyrian_halt(0, false);\n\t\t\n\t\t// never timeout\n\t\tlast_in_tick = SDL_GetTicks();\n\t\t\n\t\tif (packet_in[0] && SDLNet_Read16(&packet_in[0]->data[0]) == PACKET_CONNECT)\n\t\t\tbreak;\n\t\t\n\t\tnetwork_update();\n\t\tnetwork_check();\n\t\t\n\t\tSDL_Delay(16);\n\t}\n\t\nconnect_again:\n\tif (SDLNet_Read16(&packet_in[0]->data[4]) != NET_VERSION)\n\t{\n\t\tprintf(\"error: network version did not match opponent's\\n\");\n\t\tnetwork_tyrian_halt(4, true);\n\t}\n\tif (SDLNet_Read16(&packet_in[0]->data[6]) != network_delay)\n\t{\n\t\tprintf(\"error: network delay did not match opponent's\\n\");\n\t\tnetwork_tyrian_halt(5, true);\n\t}\n\tif (SDLNet_Read16(&packet_in[0]->data[10]) == thisPlayerNum)\n\t{\n\t\tprintf(\"error: player number conflicts with opponent's\\n\");\n\t\tnetwork_tyrian_halt(6, true);\n\t}\n\t\n\tepisodes = SDLNet_Read16(&packet_in[0]->data[8]);\n\tfor (int i = 0; i < EPISODE_MAX; i++) {\n\t\tepisodeAvail[i] &= (episodes & 1);\n\t\tepisodes >>= 1;\n\t}\n\t\n\tnetwork_opponent_name = malloc(packet_in[0]->len - 12 + 1);\n\tstrcpy(network_opponent_name, (char *)&packet_in[0]->data[12]);\n\t\n\tnetwork_update();\n\t\n\t// until opponent has acknowledged\n\twhile (!network_is_sync())\n\t{\n\t\tservice_SDL_events(false);\n\t\t\n\t\t// got a duplicate packet; process it again (but why?)\n\t\tif (packet_in[0] && SDLNet_Read16(&packet_in[0]->data[0]) == PACKET_CONNECT)\n\t\t\tgoto connect_again;\n\t\t\n\t\tnetwork_check();\n\t\t\n\t\t// maybe opponent didn't get our packet\n\t\tif (SDL_GetTicks() - last_out_tick > NET_RETRY)\n\t\t\tgoto connect_reset;\n\t\t\n\t\tSDL_Delay(16);\n\t}\n\t\n\t// send another packet since sometimes the network syncs without both connect packets exchanged\n\t// there should be a better way to handle this\n\tnetwork_prepare(PACKET_CONNECT);\n\tSDLNet_Write16(NET_VERSION, &packet_out_temp->data[4]);\n\tSDLNet_Write16(network_delay,   &packet_out_temp->data[6]);\n\tSDLNet_Write16(episodes_local,  &packet_out_temp->data[8]);\n\tSDLNet_Write16(thisPlayerNum,   &packet_out_temp->data[10]);\n\tstrcpy((char *)&packet_out_temp->data[12], network_player_name);\n\tnetwork_send(12 + strlen(network_player_name) + 1); // PACKET_CONNECT\n\t\n\tconnected = true;\n\t\n\treturn 0;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// send packet but don't expect acknoledgment of delivery\n", "func_signal": "bool network_send_no_ack( int len )", "code": "{\n\tpacket_out_temp->len = len;\n\t\n\tif (!SDLNet_UDP_Send(socket, 0, packet_out_temp))\n\t{\n\t\tprintf(\"SDLNet_UDP_Send: %s\\n\", SDL_GetError());\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// something has gone wrong :(\n", "func_signal": "void network_tyrian_halt( int err, bool attempt_sync )", "code": "{\n\tconst char *err_msg[] = {\n\t\t\"Quitting...\",\n\t\t\"Other player quit the game.\",\n\t\t\"Network connection was lost.\",\n\t\t\"Network connection failed.\",\n\t\t\"Network version mismatch.\",\n\t\t\"Network delay mismatch.\",\n\t\t\"Network player number conflict.\",\n\t};\n\t\n\tquit = true;\n\t\n\tif (err >= COUNTOF(err_msg))\n\t\terr = 0;\n\t\n\tJE_fadeBlack(10);\n\t\n\ttempScreenSeg = VGAScreen = VGAScreenSeg;\n\t\n\tJE_loadPic(2, false);\n\tJE_dString(JE_fontCenter(err_msg[err], SMALL_FONT_SHAPES), 140, err_msg[err], SMALL_FONT_SHAPES);\n\t\n\tJE_showVGA();\n\tJE_fadeColor(10);\n\t\n\tif (attempt_sync)\n\t{\n\t\twhile (!network_is_sync() && network_is_alive())\n\t\t{\n\t\t\tservice_SDL_events(false);\n\t\t\t\n\t\t\tnetwork_check();\n\t\t\tSDL_Delay(16);\n\t\t}\n\t}\n\t\n\tif (err)\n\t{\n\t\twhile (!JE_anyButton())\n\t\t\tSDL_Delay(16);\n\t}\n\t\n\tJE_fadeBlack(10);\n\t\n\tSDLNet_Quit();\n\t\n\tJE_tyrianHalt(5);\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// converts joystick axis to sane Tyrian-usable value\n", "func_signal": "int joystick_axis_reduce( int j, int value )", "code": "{\n\tassert(j < joysticks);\n\t\n\tvalue = joystick_axis_threshold(j, value);\n\t\n\tif (value == 0)\n\t\treturn 0;\n\t\n\treturn value / (3000 - 200 * joystick[j].sensitivity);\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// receive state packet, wait until received\n", "func_signal": "bool network_state_update( void )", "code": "{\n\tif (network_state_is_reset())\n\t{\n\t\treturn 0;\n\t} else {\n\t\tpackets_shift_up(packet_state_in, NET_PACKET_QUEUE);\n\t\t\n\t\tpackets_shift_up(packet_state_in_xor, NET_PACKET_QUEUE);\n\t\t\n\t\tlast_state_in_sync++;\n\t\t\n\t\t// current xor packet index\n\t\tint x = network_delay - (last_state_in_sync - 1) % network_delay - 1;\n\t\t\n\t\t// loop until needed packet is available\n\t\twhile (!packet_state_in[0])\n\t\t{\n\t\t\t// xor the packet from thin air, if possible\n\t\t\tif (packet_state_in_xor[x] && SDLNet_Read16(&packet_state_in_xor[x]->data[0]) == PACKET_STATE_XOR)\n\t\t\t{\n\t\t\t\t// check for all other required packets\n\t\t\t\tbool okay = true;\n\t\t\t\tfor (int i = 1; i <= x; i++)\n\t\t\t\t{\n\t\t\t\t\tif (packet_state_in[i] == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tokay = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (okay)\n\t\t\t\t{\n\t\t\t\t\tpacket_state_in[0] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\t\t\t\tpacket_copy(packet_state_in[0], packet_state_in_xor[x]);\n\t\t\t\t\tfor (int i = 1; i <= x; i++)\n\t\t\t\t\t\tfor (int j = 4; j < packet_state_in[0]->len; j++)\n\t\t\t\t\t\t\tpacket_state_in[0]->data[j] ^= packet_state_in[i]->data[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic Uint32 resend_tick = 0;\n\t\t\tif (SDL_GetTicks() - last_state_in_tick > NET_RESEND && SDL_GetTicks() - resend_tick > NET_RESEND)\n\t\t\t{\n\t\t\t\tSDLNet_Write16(PACKET_STATE_RESEND,    &packet_out_temp->data[0]);\n\t\t\t\tSDLNet_Write16(last_state_in_sync - 1, &packet_out_temp->data[2]);\n\t\t\t\tnetwork_send_no_ack(4);  // PACKET_RESEND\n\t\t\t\t\n\t\t\t\tresend_tick = SDL_GetTicks();\n\t\t\t}\n\t\t\t\n\t\t\tif (network_check() == 0)\n\t\t\t\tSDL_Delay(1);\n\t\t}\n\t\t\n\t\tif (network_delay > 1)\n\t\t{\n\t\t\t// process the current in packet against the xor queue\n\t\t\tif (packet_state_in_xor[x] == NULL)\n\t\t\t{\n\t\t\t\tpacket_state_in_xor[x] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\t\t\tpacket_copy(packet_state_in_xor[x], packet_state_in[0]);\n\t\t\t\tpacket_state_in_xor[x]->status = 0;\n\t\t\t} else {\n\t\t\t\tfor (int j = 4; j < packet_state_in_xor[x]->len; j++)\n\t\t\t\t\tpacket_state_in_xor[x]->data[j] ^= packet_state_in[0]->data[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlast_state_in_tick = SDL_GetTicks();\n\t}\n\t\n\treturn 1;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// prepare new state for sending\n", "func_signal": "void network_state_prepare( void )", "code": "{\n\tif (packet_state_out[0])\n\t{\n\t\tprintf(\"warning: state packet overwritten (previous packet remains unsent)\\n\");\n\t} else {\n\t\tpacket_state_out[0] = SDLNet_AllocPacket(NET_PACKET_SIZE);\n\t\tpacket_state_out[0]->len = 28;\n\t}\n\t\n\tSDLNet_Write16(PACKET_STATE, &packet_state_out[0]->data[0]);\n\tSDLNet_Write16(last_state_out_sync, &packet_state_out[0]->data[2]);\n\tmemset(&packet_state_out[0]->data[4], 0, 28 - 4);\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// seeks to a particular joystick's entry in the config file\n", "func_signal": "FILE *seek_joystick_assignments( int j, bool read_only )", "code": "{\n\tassert(j < joysticks);\n\t\n\tconst int joystick_axes = SDL_JoystickNumAxes(joystick[j].handle), joystick_buttons = SDL_JoystickNumButtons(joystick[j].handle);\n\tchar joystick_xor = 0;\n\t\n\tconst char *joystick_name = SDL_JoystickName(j);\n\tfor (int i = 0; joystick_name[i] != '\\0'; i++)\n\t\tjoystick_xor ^= joystick_name[i];\n\t\n\tchar cfg_file[1000];\n\tsnprintf(cfg_file, sizeof(cfg_file), \"%s\" \"joystick.cfg\", get_user_directory());\n\t\n\tconst int entry_size = 3 + 3 + COUNTOF(joystick->assignment) * COUNTOF(*joystick->assignment) * 3;\n\t\n\tFILE *f = fopen(cfg_file, read_only ? \"rb\" : \"rb+\");\n\t\n\tif (f != NULL)\n\t{\n\t\tfseek(f, 0, SEEK_END);\n\t\tif (ftell(f) < 1 || (ftell(f) - 1) % entry_size != 0) // wrong size\n\t\t{\n\t\t\tfclose(f);\n\t\t\tf = NULL;\n\t\t}\n\t}\n\t\n\tif (f != NULL)\n\t{\n\t\tfseek(f, 0, SEEK_SET);\n\t\tif (fgetc(f) != joystick_cfg_version) // version mismatch\n\t\t{\n\t\t\tfclose(f);\n\t\t\tf = NULL;\n\t\t}\n\t}\n\t\n\tif (f != NULL)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tchar xor, axes, buttons;\n\t\t\t\n\t\t\txor = fgetc(f);\n\t\t\taxes = fgetc(f);\n\t\t\tbuttons = fgetc(f);\n\t\t\t\n\t\t\tif (feof(f))\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tif (xor == joystick_xor && axes == joystick_axes && buttons == joystick_buttons) // found a match\n\t\t\t\treturn f;\n\t\t\t\n\t\t\tfseek(f, -3 + entry_size, SEEK_CUR);\n\t\t}\n\t}\n\t\n\tif (!read_only)\n\t{\n\t\tif (f == NULL) // create new config\n\t\t{\n\t\t\tf = fopen(cfg_file, \"wb+\");\n\t\t\tif (f == NULL)\n\t\t\t\treturn f;\n\t\t\t\n\t\t\tfputc(joystick_cfg_version, f);\n\t\t}\n\t\tfputc(joystick_xor, f);\n\t\tfputc(joystick_axes, f);\n\t\tfputc(joystick_buttons, f);\n\t}\n\t\n\treturn f;\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// discard working packet, now processing next packet in queue\n", "func_signal": "bool network_update( void )", "code": "{\n\tif (packet_in[0])\n\t{\n\t\tpackets_shift_up(packet_in, NET_PACKET_QUEUE);\n\t\t\n\t\tqueue_in_sync++;\n\t\t\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// eliminates axis movement below the threshold\n", "func_signal": "int joystick_axis_threshold( int j, int value )", "code": "{\n\tassert(j < joysticks);\n\t\n\tbool negative = value < 0;\n\tif (negative)\n\t\tvalue = -value;\n\t\n\tif (value <= joystick[j].threshold * 1000)\n\t\treturn 0;\n\t\n\tvalue -= joystick[j].threshold * 1000;\n\t\n\treturn negative ? -value : value;\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// send state packet, xor packet if applicable\n", "func_signal": "int network_state_send( void )", "code": "{\n\tif (!SDLNet_UDP_Send(socket, 0, packet_state_out[0]))\n\t{\n\t\tprintf(\"SDLNet_UDP_Send: %s\\n\", SDL_GetError());\n\t\treturn -1;\n\t}\n\t\n\t// send xor of last network_delay packets\n\tif (network_delay > 1 && (last_state_out_sync + 1) % network_delay == 0 && packet_state_out[network_delay - 1] != NULL)\n\t{\n\t\tpacket_copy(packet_temp, packet_state_out[0]);\n\t\tSDLNet_Write16(PACKET_STATE_XOR, &packet_temp->data[0]);\n\t\tfor (int i = 1; i < network_delay; i++)\n\t\t\tfor (int j = 4; j < packet_temp->len; j++)\n\t\t\t\tpacket_temp->data[j] ^= packet_state_out[i]->data[j];\n\t\t\n\t\tif (!SDLNet_UDP_Send(socket, 0, packet_temp))\n\t\t{\n\t\t\tprintf(\"SDLNet_UDP_Send: %s\\n\", SDL_GetError());\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tpackets_shift_down(packet_state_out, NET_PACKET_QUEUE);\n\t\n\tlast_state_out_sync++;\n\t\n\treturn 0;\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// converts analog joystick axes to an angle\n// returns false if axes are centered (there is no angle)\n", "func_signal": "bool joystick_analog_angle( int j, float *angle )", "code": "{\n\tassert(j < joysticks);\n\t\n\tfloat x = joystick_axis_threshold(j, joystick[j].x), y = joystick_axis_threshold(j, joystick[j].y);\n\t\n\tif (x != 0)\n\t{\n\t\t*angle += atan(-y / x);\n\t\t*angle += (x < 0) ? -M_PI_2 : M_PI_2;\n\t\treturn true;\n\t}\n\telse if (y != 0)\n\t{\n\t\t*angle += y < 0 ? M_PI : 0;\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}", "path": "trunk\\classic\\src\\joystick.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// reset queues for new level\n", "func_signal": "void network_state_reset( void )", "code": "{\n\tlast_state_in_sync = last_state_out_sync = 0;\n\t\n\tfor (int i = 0; i < NET_PACKET_QUEUE; i++)\n\t{\n\t\tif (packet_state_in[i])\n\t\t{\n\t\t\tSDLNet_FreePacket(packet_state_in[i]);\n\t\t\tpacket_state_in[i] = NULL;\n\t\t}\n\t}\n\tfor (int i = 0; i < NET_PACKET_QUEUE; i++)\n\t{\n\t\tif (packet_state_in_xor[i])\n\t\t{\n\t\t\tSDLNet_FreePacket(packet_state_in_xor[i]);\n\t\t\tpacket_state_in_xor[i] = NULL;\n\t\t}\n\t}\n\tfor (int i = 0; i < NET_PACKET_QUEUE; i++)\n\t{\n\t\tif (packet_state_out[i])\n\t\t{\n\t\t\tSDLNet_FreePacket(packet_state_out[i]);\n\t\t\tpacket_state_out[i] = NULL;\n\t\t}\n\t}\n\t\n\tlast_state_in_tick = SDL_GetTicks();\n}", "path": "trunk\\classic\\src\\network.c", "repo_name": "simX/opentyrian", "stars": 3, "license": "None", "language": "c", "size": 2492}
{"docstring": "// returns a HEMF\n", "func_signal": "long PA_PictureToEMF( void* picture, long len )", "code": "{\n\tEngineBlock eb;\n\n\teb.fParam1 = 0;\n\teb.fParam2 = 'EMF ';\n\teb.fHandle = FromUserData( picture, len );\n\n\tCall4D( EX_PICTURE_CONVERSION, &eb );\n\tsErrorCode = eER_NoErr;\n\n\tif ( eb.fHandle )\n\t\tPA_DisposeHandle( eb.fHandle );\n\n\treturn eb.fParam1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// search a text into XLIFF file\n// pluginResource = 1 -> looking in plugin resources\n// pluginResource = 0 -> looking in current database resources\n", "func_signal": "PA_Unistring PA_LocaliseString( PA_Unichar* name, char pluginResource )", "code": "{\n\tEngineBlock eb;\n\n\tif ( pluginResource != 0 )\n\t\teb.fParam1 = 'PLUG';\n\telse\n\t\teb.fParam1 = 0;\n\n\teb.fParam2 = 0;\n\tPA_CopyUnichars( name, eb.fUName, sizeof(eb.fUName) );\n\n\tCall4D( EX_LOCALIZE_STRING, &eb );\n\n\treturn eb.fUniString1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// return the current page number of the current layout\n", "func_signal": "short PA_GetCurrentPage()", "code": "{\n\tEngineBlock eb;\n\n\teb.fError  = 0;\n\teb.fParam1 = 0;\n\n\tCall4D( EX_GET_CURRENT_PAGE, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n\t\n\treturn (short) eb.fParam1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// to be called at eAE_WebPublishPicture\n", "func_signal": "void PA_SendWebPicture( PA_PluginParameters params, void* webData, void* picture, long len, PA_WebPictureKind kind )", "code": "{\n\tPA_Event* ev;\n\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\n\tif ( ev->fWhat == eAE_WebPublishPicture )\n\t{\n\t\tev->fMessage = (long) picture;\n\t\tev->fWhen = len;\n\t\t*(void**)( & ev->fWhereV ) = webData;\n\t\tev->fModifiers = (short) kind;\n\t\tsErrorCode = eER_NoErr;\n\t}\n\telse\n\t\tsErrorCode = eER_BadEventCall;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// need to be called when area event == eAE_EditAdvancedProperties to give 4D the private data\n// you want to keep. Area event eAE_EditAdvancedProperties will be followed by the \n// eAE_DisposeAdvancedProperties to tell you to release the buffer given to 4D.\n", "func_signal": "void PA_SetAdvancedProperties( PA_PluginParameters params, void* data, long datasize )", "code": "{\n\tPA_PluginProperties* properties;\n\tPA_Event* ev;\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\n\tif ( ev->fWhat == eAE_EditAdvancedProperties )\n\t{\n\t\tsErrorCode = eER_NoErr;\n\t\tproperties = (PA_PluginProperties*) ( ev->fMessage );\n\t\tif ( properties )\n\t\t{\n\t\t\tproperties->fAdvancedProperties = data;\n\t\t\tproperties->fAdvancedPropertiesSize = datasize;\n\t\t\n\t\t\tev->fModifiers = 0x0600;\n\t\t}\n\t\telse\n\t\t\tev->fModifiers = 0;\n\t}\n\telse\n\t\tsErrorCode = eER_BadEventCall;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// add a query for a string value\n// the string pointer should NOT be disposed until the request is performed because the pointer is passed to the query,\n// not the content.\n", "func_signal": "void PA_QueryString( PA_QueryRef ref, short table, short field, PA_QueryOperator qo, PA_QueryComparison qc, PA_Unichar* string )", "code": "{\n\tLineBlock* lineblock = AddQuery( ref, table, field, qo, qc );\n\tif ( lineblock )\n\t{\n\t\tlineblock->uValue.fUnichars = string;\n\t\tPA_UnlockHandle( ref );\n\t}\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// the resource and the memory it uses are purged from memory\n", "func_signal": "void PA_ReleaseResource( short resfile, unsigned long kind, long id )", "code": "{\n\tEngineBlock eb;\n\n\teb.fTable = resfile;\n\teb.fParam1 = (long) kind;\n\teb.fParam2 = id;\n\teb.fHandle = 0;\n\teb.fError = 0;\n\n\tCall4D( EX_RELEASE_RESOURCE, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// to be called after a eAE_DisposeAdvancedProperties event. Gives you back the\n// pointer passed in PA_SetPluginParameters, so you can dispose the memory.\n", "func_signal": "void* PA_GetAdvancedPropertiesToDispose( PA_PluginParameters params )", "code": "{\n\tvoid* data;\n\tPA_Event* ev;\n\n\tdata = 0;\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\n\tif ( ev->fWhat == eAE_DisposeAdvancedProperties )\n\t{\n\t\tsErrorCode = eER_NoErr;\n\t\tdata = (void*)(ev->fMessage);\t\n\t}\n\telse\n\t\tsErrorCode = eER_BadEventCall;\n\n\treturn data;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// force current front window to show current values of variables\n", "func_signal": "void PA_UpdateVariables()", "code": "{\n\tEngineBlock eb;\n\tCall4D( EX_UPDATE_VARIABLES, &eb );\n\tsErrorCode = eER_NoErr;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// to be called if AreaEvent == eAE_GetMenuIcon \n// to give the id of the 'cicn' resource that will appears\n// beside the area name in plugin area popup of the the tools palette.\n", "func_signal": "void PA_SetMenuIcon( PA_PluginParameters params, short id )", "code": "{\n\tPA_Event* ev;\n\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\tif ( ev->fWhat == eAE_GetMenuIcon )\n\t{\n\t\tsErrorCode = eER_NoErr;\n\t\tev->fMessage = 604;\n\t\tev->fWhen = (long) id;\n\t}\n\telse\n\t\tsErrorCode = eER_BadEventCall;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// warning : two packages can share the same ID,\n// exept for modules with ID under 15000 like 4D Write\n", "func_signal": "short PA_FindPackage( short packageID )", "code": "{\n\tEngineBlock eb;\n\n\teb.fParam1 = packageID;\n\teb.fParam2 = 0;\n\tCall4D( EX_FIND_PACKAGE, &eb );\n\tsErrorCode = eER_NoErr;\n\n\treturn (short) eb.fParam2;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// return values:\n// 0 if the strings are the same,\n// 1 if text1 is greater than text2,\n// 2 if text1 is less than text2\n", "func_signal": "char PA_CompareUniBuffers( PA_Unichar* text1, long len1, PA_Unichar* text2, long len2, char diacritic, char useWildChar )", "code": "{\n\tEngineBlock eb;\n\tsErrorCode = eER_NoErr;\n\n\teb.fParam1 = (long) text1;\n\teb.fParam2 = (long) text2;\n\n\teb.fParam3 = len1;\n\teb.fParam4 = len2;\n\n\teb.fManyToOne = useWildChar;\n\teb.fOneToMany = diacritic;\n\n\tif ( sErrorCode == eER_NoErr )\n\t\tCall4D( EX_COMPARE_UNIBUFFERS, &eb );\n\n\treturn (char) eb.fParam1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// ---------------------------------------------------------------\n//\n// Sending/Receiving data between 4D Client and 4D Server\n//\n// ---------------------------------------------------------------\n", "func_signal": "void PA_SendDataToServer( long pluginRef, long dataRef, long dataKind, void* buffer, long len )", "code": "{\n\tEngineBlock eb;\n\n\teb.fParam1 = pluginRef;\n\teb.fParam2 = len;\n\teb.fParam3 = dataKind;\n\teb.fParam4 = dataRef;\n\teb.fHandle = (PA_Handle) buffer;\n\n\tCall4D( EX_WRITE_DATA, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// if you don't take an area event, call this routine to tell 4D to handle it.\n", "func_signal": "void PA_DontTakeEvent( PA_PluginParameters params )", "code": "{\n\tPA_Event* ev;\n\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\tev->fMessage = 112;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// -----------------------------------------\n//\n// Tables\n//\n// -----------------------------------------\n", "func_signal": "short PA_CountTables()", "code": "{\n\tEngineBlock\teb;\n\t\n\teb.fParam1 = 0;\n\teb.fParam4 = sVirtualStructureMode;\n\n\tCall4D( EX_COUNT_TABLES, &eb );\n\tsErrorCode = (PA_ErrorCode) eER_NoErr;\n\n\treturn (short) eb.fParam1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// AreaEvent can be eAE_AllowDrop, eAE_Drag, eAE_Drop or eAE_BeginDrag\n", "func_signal": "PA_DragContextRef PA_GetDragAndDropContext( PA_PluginParameters params )", "code": "{\n\tPA_DragContextRef context = NULL;\n\tPA_Event *ev;\n\n\tev = ( (PA_Event**) params->fParameters )[ 0 ];\n\tif ( ev->fWhat == eAE_AllowDrop || ev->fWhat == eAE_Drag || ev->fWhat == eAE_Drop )\n\t{\n\t\tPA_DragAndDropInfo dropinfo;\n\t\tdropinfo = *(PA_DragAndDropInfo *)ev->fMessage;\n\t\tcontext = dropinfo.fDragContext;\n\t\tsErrorCode = eER_NoErr;\n\t}\n\telse if ( ev->fWhat == eAE_BeginDrag )\n\t{\n\t\tcontext = (PA_DragContextRef) ev->fMessage;\n\t\tsErrorCode = eER_NoErr;\n\t}\n\telse\n\t{\n\t\tsErrorCode = eER_BadEventCall;\n\t}\n\treturn context;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// -----------------------------------------\n//\n// 4D Application arrays\n//\n// -----------------------------------------\n", "func_signal": "long PA_GetArrayNbElements( PA_Variable ar )", "code": "{\n\tif ( ( ar.fType >= eVK_ArrayOfArray && ar.fType <= eVK_ArrayBoolean ) || ar.fType == eVK_ArrayUnicode )\n\t\treturn ar.uValue.fArray.fNbElements;\n\telse\n\t\treturn -1;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// on 4D Server/4D Client only\n// the resource is locked for others 4D Client (they can't delete or modify it)\n", "func_signal": "char PA_LockResource( short resfile, unsigned long kind, long id )", "code": "{\n\tEngineBlock eb;\n\n\teb.fTable = resfile;\n\teb.fParam1 = (long) kind;\n\teb.fParam2 = id;\n\teb.fManyToOne = 1;\n\teb.fHandle = 0;\n\teb.fError = 0;\n\n\tCall4D( EX_GET_RESOURCE, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n\n\treturn (char)( ( eb.fManyToOne == 0 ) ? 1 : 0 );\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "/*\n\tOn Windows 4D allocates an offscreen port and ask form objects,\n\tincluding plugins, to draw inside. Then the offscreen is blittered on screen.\n\n\tThis may be a problem for plugin areas that cannot draw themselves in an offscreen.\n\tThese plugins should inform 4D so that the offscreen is not blittered over their area,\n\tby calling PA_SetPluginAreaClipMode( ref, 1);\n\t\n\tpluginRef is your plugin data handle you provided at plugin area creation.\n\tset clipChildren to 1 to ask 4D not to draw over your plugin area.\n\tset clipChildren to 0 to restore normal behavior\n\tfError is non-zero if no plugin area with specified ref could be found.\n*/\n", "func_signal": "void PA_SetPluginAreaClipMode( PA_PluginRef pluginRef, char clipChildren)", "code": "{\n\tEngineBlock eb;\n\n\teb.fHandle = (PA_Handle) pluginRef;\n\teb.fManyToOne = clipChildren;\n\teb.fError  = 0;\n\n\tCall4D( EX_SET_PLUGINAREA_CLIPMODE, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "// -----------------------------------------\n//\n// 4D Application sets\n//\n// -----------------------------------------\n", "func_signal": "void PA_CreateEmptySet( short table, PA_Unichar* name )", "code": "{\n\tEngineBlock eb;\n\n\teb.fTable = table;\n\tPA_CopyUnichars( name, eb.fUName, sizeof(eb.fUName) );\n\n\tCall4D( EX_CREATE_EMPTY_SET, &eb );\n\tsErrorCode = (PA_ErrorCode) eb.fError;\n}", "path": "4D Plugin API\\4DPluginAPI.c", "repo_name": "jellehelsen/CURL4D", "stars": 2, "license": "None", "language": "c", "size": 156}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n\n  if (init_run) return;\n  init_run = 1;\n\n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* This code checks to see if the Ruby object being raised as part\n   of an exception inherits from the Ruby class Exception.  If so,\n   the object is simply returned.  If not, then a new Ruby exception\n   object is created and that will be returned to Ruby.*/\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj)", "code": "{\n  VALUE exceptionClass = getExceptionClass();\n  if (rb_obj_is_kind_of(obj, exceptionClass)) {\n    return obj;\n  }  else {\n    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));\n  }\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start, \n                     swig_module_info *end, \n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n  \n  /* neither found a match */\n  return 0;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* This is a helper method that unlinks a Ruby object from its\n   underlying C++ object.  This is needed if the lifetime of the\n   Ruby object is longer than the C++ object */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr)", "code": "{\n  VALUE object = SWIG_RubyInstanceFor(ptr);\n\n  if (object != Qnil) {\n    DATA_PTR(object) = 0;\n  }\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Define Ruby class for C type */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_define_class(swig_type_info *type)", "code": "{\n  VALUE klass;\n  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n  sprintf(klass_name, \"TYPE%s\", type->name);\n  if (NIL_P(_cSWIG_Pointer)) {\n    _cSWIG_Pointer = rb_define_class_under(_mSWIG, \"Pointer\", rb_cObject);\n    rb_undef_method(CLASS_OF(_cSWIG_Pointer), \"new\");\n  }\n  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);\n  free((void *) klass_name);\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeCompare(const char *nb, const char *tb)", "code": "{\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*@SWIG:%ruby_aux_method@*/\n", "func_signal": "SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)", "code": "{\n  VALUE obj = args[0];\n  VALUE type = TYPE(obj);\n  long *res = (long *)(args[1]);\n  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);\n  return obj;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Remove a Tracking from a C/C++ struct to a Ruby object.  It\n   is very important to remove objects once they are destroyed\n   since the same memory address may be reused later to create\n   a new object. */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr)", "code": "{\n  /* Get a reference to the pointer as a Ruby number */\n  VALUE key = SWIG_RubyPtrToReference(ptr);\n\n  /* Delete the object from the hash table by calling Ruby's\n     do this we need to call the Hash.delete method.*/\n  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Create a new class instance (always owned) */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)", "code": "{\n  VALUE obj;\n  swig_class *sklass = (swig_class *) type->clientdata;\n  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);\n  rb_iv_set(obj, \"__swigtype__\", rb_str_new2(type->name));\n  return obj;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Get a Ruby number to reference a pointer */\n", "func_signal": "SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr)", "code": "{\n  /* We cast the pointer to an unsigned long\n     and then store a reference to it using\n     a Ruby number object. */\n\n  /* Convert the pointer to a Ruby number */\n  unsigned long value = (unsigned long) ptr;\n  return LONG2NUM(value);\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)", "code": "{\n  char *c;\n  swig_cast_info *tc;\n  void *vptr = 0;\n\n  /* Grab the pointer */\n  if (NIL_P(obj)) {\n    *ptr = 0;\n    return SWIG_OK;\n  } else {\n    if (TYPE(obj) != T_DATA) {\n      return SWIG_ERROR;\n    }\n    Data_Get_Struct(obj, void, vptr);\n  }\n  \n  if (own) *own = RDATA(obj)->dfree;\n    \n  /* Check to see if the input object is giving up ownership\n     of the underlying C struct or C++ object.  If so then we\n     need to reset the destructor since the Ruby object no \n     longer owns the underlying C++ object.*/ \n  if (flags & SWIG_POINTER_DISOWN) {\n    /* Is tracking on for this class? */\n    int track = 0;\n    if (ty && ty->clientdata) {\n      swig_class *sklass = (swig_class *) ty->clientdata;\n      track = sklass->trackObjects;\n    }\n\t\t\n    if (track) {\n      /* We are tracking objects for this class.  Thus we change the destructor\n       * to SWIG_RubyRemoveTracking.  This allows us to\n       * remove the mapping from the C++ to Ruby object\n       * when the Ruby object is garbage collected.  If we don't\n       * do this, then it is possible we will return a reference \n       * to a Ruby object that no longer exists thereby crashing Ruby. */\n      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;\n    } else {    \n      RDATA(obj)->dfree = 0;\n    }\n  }\n\n  /* Do type-checking if type info was provided */\n  if (ty) {\n    if (ty->clientdata) {\n      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {\n        if (vptr == 0) {\n          /* The object has already been deleted */\n          return SWIG_ObjectPreviouslyDeletedError;\n        }\n        *ptr = vptr;\n        return SWIG_OK;\n      }\n    }\n    if ((c = SWIG_MangleStr(obj)) == NULL) {\n      return SWIG_ERROR;\n    }\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) {\n      return SWIG_ERROR;\n    }\n    *ptr = SWIG_TypeCast(tc, vptr);\n  } else {\n    *ptr = vptr;\n  }\n  \n  return SWIG_OK;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* \n   Pack binary data into a string\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz)", "code": "{\n  static const char hex[17] = \"0123456789abcdef\";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* \n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = ((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = ((d - ('a'-10)) << 4);\n    else \n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (d - ('a'-10));\n    else \n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Add a Tracking from a C/C++ struct to a Ruby object */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object)", "code": "{\n  /* In a Ruby hash table we store the pointer and\n     the associated Ruby object.  The trick here is\n     that we cannot store the Ruby object directly - if\n     we do then it cannot be garbage collected.  So\n     instead we typecast it as a unsigned long and\n     convert it to a Ruby number object.*/\n\n  /* Get a reference to the pointer as a Ruby number */\n  VALUE key = SWIG_RubyPtrToReference(ptr);\n\n  /* Get a reference to the Ruby object as a Ruby number */\n  VALUE value = SWIG_RubyObjectToReference(object);\n\n  /* Store the mapping to the global hash table. */\n  rb_hash_aset(swig_ruby_trackings, key, value);\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*@SWIG:%ruby_aux_method@*/\n", "func_signal": "SWIGINTERN VALUE SWIG_AUX_NUM2LL(VALUE *args)", "code": "{\n  VALUE obj = args[0];\n  VALUE type = TYPE(obj);\n  long long *res = (long long *)(args[1]);\n  *res = type == T_FIXNUM ? NUM2LL(obj) : rb_big2ll(obj);\n  return obj;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start, \n                            swig_module_info *end, \n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1; \n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\t    \n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty)", "code": "{\n  swig_cast_info *tc;\n  const char  *c;\n\n  if (TYPE(obj) != T_STRING) goto type_error;\n  c = StringValuePtr(obj);\n  /* Pointer values must start with leading underscore */\n  if (*c != '_') goto type_error;\n  c++;\n  c = SWIG_UnpackData(c, ptr, sz);\n  if (ty) {\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) goto type_error;\n  }\n  return SWIG_OK;\n\n type_error:\n  return SWIG_ERROR;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/* Define custom exceptions for errors that do not map to existing Ruby\n   exceptions.  Note this only works for C++ since a global cannot be\n   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/\n", "func_signal": "SWIGINTERN VALUE \ngetNullReferenceError(void)", "code": "{\n  static int init = 0;\n  static VALUE rb_eNullReferenceError ;\n  if (!init) {\n    init = 1;\n    rb_eNullReferenceError = rb_define_class(\"NullReferenceError\", rb_eRuntimeError);\n  }\n  return rb_eNullReferenceError;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*@SWIG@*/\n", "func_signal": "SWIGINTERN int\nSWIG_AsVal_long (VALUE obj, long* val)", "code": "{\n  VALUE type = TYPE(obj);\n  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {\n    long v;\n    VALUE a[2];\n    a[0] = obj;\n    a[1] = (VALUE)(&v);\n    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {\n      if (val) *val = v;\n      return SWIG_OK;\n    }\n  }\n  return SWIG_TypeError;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/*@SWIG@*/\n", "func_signal": "SWIGINTERN int\nSWIG_AsVal_long_SS_long (VALUE obj, long long *val)", "code": "{\n  VALUE type = TYPE(obj);\n  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {\n    long long v;\n    VALUE a[2];\n    a[0] = obj;\n    a[1] = (VALUE)(&v);\n    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {\n      if (val) *val = v;\n      return SWIG_OK;\n    }\n  }\n  return SWIG_TypeError;\n}", "path": "ext\\chmlib_wrap.c", "repo_name": "cho45/rb-chm", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 128}
{"docstring": "/****************************************************\n*\tFIR Filter with Redundant Load Elimination\n\t\t\t\t\t\t\nBy doing two outer loops simultaneously, you can potentially  reuse data (depending on the DSP architecture).\nx and h  only  need to be loaded once, therefore reducing redundant loads.\nThis reduces memory bandwidth and power.\n*****************************************************/\n", "func_signal": "void\nfir_no_red_ld(const short x[], const short h[], long int y[])", "code": "{\n\tlong int        i, j;\n\tlong int        sum0, sum1;\n\tshort           x0, x1, h0, h1;\n\tfor (j = 0; j < 100; j += 2) {\n\t\tsum0 = 0;\n\t\tsum1 = 0;\n\t\tx0 = x[j];\n\t\tfor (i = 0; i < 32; i += 2) {\n\t\t\tx1 = x[j + i + 1];\n\t\t\th0 = h[i];\n\t\t\tsum0 += x0 * h0;\n\t\t\tsum1 += x1 * h0;\n\t\t\tx0 = x[j + i + 2];\n\t\t\th1 = h[i + 1];\n\t\t\tsum0 += x1 * h1;\n\t\t\tsum1 += x0 * h1;\n\t\t}\n\t\ty[j] = sum0 >> 15;\n\t\ty[j + 1] = sum1 >> 15;\n\t}\n#ifdef DEBUG\n\tprintf(\"fir_no_red_ld computation\\n\");\n\t\tfor (j = 0; j < 100; j+=2 ) {\n\t\t\tprintf(\"%d %d \",y[j], y[j+1]);\n\t\t}\n\tprintf(\"\\n\");\n#endif\n\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "// Initializes the seed used in the random number generator.\n", "func_signal": "int InitSeed (void)", "code": "{\n   Seed = 0;\n   return 0;\n}", "path": "tests\\tests\\pret\\sys\\cnt\\cnt\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*====================================================================*/\n", "func_signal": "void altitude_control_task(void)", "code": "{\n\tif (pprz_mode == PPRZ_MODE_AUTO2 || pprz_mode == PPRZ_MODE_HOME) {\n\t  if (vertical_mode == VERTICAL_MODE_AUTO_ALT) {\n\t    /* inlined below \t    altitude_pid_run();   */\n\t    float err = estimator_z - desired_altitude;\n\t    desired_climb = pre_climb + altitude_pgain * err;\n\t    if (desired_climb < -CLIMB_MAX) desired_climb = -CLIMB_MAX;\n\t    if (desired_climb > CLIMB_MAX) desired_climb = CLIMB_MAX;\n\t  }\n\t}\n}", "path": "tests\\tests\\pret\\sanjit\\altitude\\altitude_full_6.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/* # of codes output (for debugging) */\n", "func_signal": "void compress(void)", "code": "{\n   register long fcode;\n   register code_int i = 0;\n   register int c;\n   register code_int ent;\n   register int disp;\n   register code_int hsize_reg;\n   register int hshift;\n\n\n   offset = 0;\n   bytes_out = 3;\t\t/* includes 3-byte header mojo */\n   out_count = 0;\n   clear_flg = 0;\n   ratio = 0;\n   in_count = 1;\n   checkpoint = CHECK_GAP;\n   maxcode = MAXCODE(n_bits = INIT_BITS);\n   free_ent = ((block_compress) ? (FIRST) : (256) );\n\n   ent = getbyte ();\n\n   hshift = 0;\n   for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )\n   {\n      hshift++;\n   }\n\n   hshift = 8 - hshift;\t\t/* set hash code range bound */\n\n   hsize_reg = hsize;\n   cl_hash( (count_int) hsize_reg);\t\t/* clear hash table */\n\n\n   while ( InCnt > 0 )           /* apsim_loop 11 0 */\n   {\n      int apsim_bound111 = 0;\n\n      c = getbyte();   // decrements InCnt\n\n      in_count++;\n      fcode = (long) (((long) c << maxbits) + ent);\n      i = ((c << hshift) ^ ent);\t/* xor hashing */\n\n      if ( htabof (i) == fcode ) {\n         ent = codetabof (i);\n         continue;\n      } else if ( (long)htabof (i) < 0 ) { /* empty slot */\n         goto nomatch;\n      }\n\n\n      disp = hsize_reg - i;\t\t/* secondary hash (after G. Knott) */\n      if ( i == 0 ) {\n         disp = 1;\n      }\n\nprobe:\n\n      if ( (i -= disp) < 0 ) {  /* apsim_loop 111 11 */\n         i += hsize_reg;\n      }\n\n      if ( htabof (i) == fcode ) {\n         ent = codetabof (i);\n         continue;\n      }\n\n      if ( (long)htabof (i) > 0 && (++apsim_bound111 < in_count) )\n         goto probe;\nnomatch:\n\n      out_count++;\n      ent = c;\n      if ( free_ent < maxmaxcode ) {\n         codetabof (i) = free_ent++;\t        /* apsim_unknown codetab */\n         htabof (i) = fcode;\t\t\t/* apsim_unknown htab */\n      } else if ( ((count_int)in_count >= checkpoint) && (block_compress) ) {\n         cl_block ();\n      }\n\n   }\n   if(bytes_out > in_count) { /* exit(2) if no savings */\n      exit_stat = 2;\n   }\n   return;\n}", "path": "tests\\tests\\pret\\sys\\compress\\compress\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*****************************************************\n*\t\tJPEG Discrete Cosine Transform \t\t     *\n*****************************************************/\n", "func_signal": "void\njpegdct(short *d, short *r)", "code": "{\n#ifdef DEBUG\n\tint kc = 0;\n#endif\n\tlong int        t[12];\n\tshort           i, j, k, m, n, p;\n\tfor (k = 1, m = 0, n = 13, p = 8; k <= 8; k += 7, m += 3, n += 3, p -= 7, d -= 64) {\n\t\tfor (i = 0; i < 8; i++, d += p) {\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tt[j] = d[k * j] + d[k * (7 - j)];\n\t\t\t\tt[7 - j] = d[k * j] - d[k * (7 - j)];\n\t\t\t}\n\t\t\tt[8] = t[0] + t[3];\n\t\t\tt[9] = t[0] - t[3];\n\t\t\tt[10] = t[1] + t[2];\n\t\t\tt[11] = t[1] - t[2];\n\t\t\td[0] = (t[8] + t[10]) >> m;\n\t\t\td[4 * k] = (t[8] - t[10]) >> m;\n\t\t\tt[8] = (short) (t[11] + t[9]) * r[10];\n\t\t\td[2 * k] = t[8] + (short) ((t[9] * r[9]) >> n);\n\t\t\td[6 * k] = t[8] + (short) ((t[11] * r[11]) >> n);\n\t\t\tt[0] = (short) (t[4] + t[7]) * r[2];\n\t\t\tt[1] = (short) (t[5] + t[6]) * r[0];\n\t\t\tt[2] = t[4] + t[6];\n\t\t\tt[3] = t[5] + t[7];\n\t\t\tt[8] = (short) (t[2] + t[3]) * r[8];\n\t\t\tt[2] = (short) t[2] * r[1] + t[8];\n\t\t\tt[3] = (short) t[3] * r[3] + t[8];\n\t\t\td[7 * k] = (short) (t[4] * r[4] + t[0] + t[2]) >> n;\n\t\t\td[5 * k] = (short) (t[5] * r[6] + t[1] + t[3]) >> n;\n\t\t\td[3 * k] = (short) (t[6] * r[5] + t[1] + t[2]) >> n;\n\t\t\td[1 * k] = (short) (t[7] * r[7] + t[0] + t[3]) >> n;\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintf(\"jpegdct computation\\n\");\n\tfor (kc = 0; kc < 200; kc++) {\n\t\tprintf(\"%d \", d[kc]);\n\t}\n\tprintf(\"\\n\");\n#endif\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*====================================================================*/\n", "func_signal": "void altitude_control_task(void)", "code": "{\n\tif (pprz_mode == PPRZ_MODE_AUTO2 || pprz_mode == PPRZ_MODE_HOME) {\n\t  if (vertical_mode == VERTICAL_MODE_AUTO_ALT) {\n\t    /* inlined below \t    altitude_pid_run();   */\n\t    float err = estimator_z - desired_altitude;\n\t    desired_climb = pre_climb + altitude_pgain * err;\n\t    if (desired_climb < -CLIMB_MAX) desired_climb = -CLIMB_MAX;\n\t    if (desired_climb > CLIMB_MAX) desired_climb = CLIMB_MAX;\n\t  }\n\t}\n}", "path": "tests\\tests\\pret\\sanjit\\altitude\\altitude_full_5.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*****************************************************\n*\t\tFIR Filter\t\t     *\n*****************************************************/\n", "func_signal": "void\nfir(const short array1[], const short coeff[], long int output[])", "code": "{\n\tlong int        i, j, sum;\n\n\tfor (i = 0; i < N - ORDER; i++) {\n\t\tsum = 0;\n\t\tfor (j = 0; j < ORDER; j++) {\n\t\t\tsum += array1[i + j] * coeff[j];\n\t\t}\n\t\toutput[i] = sum >> 15;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"fir computation\\n\");\n\t\tfor (i = 0; i < N - ORDER; i++) {\n\t\t\tprintf(\"%d \",output[i]);\n\t\t}\n\tprintf(\"\\n\");\n#endif\n\n\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*--------------- variable defs pulled from other files [above] --------------------------------*/\n", "func_signal": "void stabilisation_task(void)", "code": "{\n/* ---- inlined below:    ir_update(); ---- */\n// #ifndef SIMUL\n  int16_t x1_mean = buf_ir1.sum/AV_NB_SAMPLE;\n  int16_t x2_mean = buf_ir2.sum/AV_NB_SAMPLE;\n  \n  /* simplesclar cannot have type decls in the middle of the func */\n  float rad_of_ir, err, tmp_sanjit;\n\n  ir_roll = IR_RollOfIrs(x1_mean, x2_mean) - ir_roll_neutral;\n  ir_pitch = IR_PitchOfIrs(x1_mean, x2_mean) - ir_pitch_neutral;\n  /*\n#else\n  extern volatile int16_t simul_ir_roll, simul_ir_pitch;\n  ir_roll = simul_ir_roll -  ir_roll_neutral; \n  ir_pitch = simul_ir_pitch - ir_pitch_neutral;  \n#endif\n  */\n\n  /* ---- inlined below    estimator_update_state_infrared();  ---- */\n  rad_of_ir = (ir_estim_mode == IR_ESTIM_MODE_ON && EstimatorIrGainIsCorrect()) ? \n    estimator_rad_of_ir : ir_rad_of_ir;\n  estimator_phi  = rad_of_ir * ir_roll;\n\n  estimator_theta = rad_of_ir * ir_pitch;\n\n  /* --- inlined below    roll_pitch_pid_run(); // Set  desired_aileron & desired_elevator ---- */\n  err =  estimator_phi - desired_roll;\n  desired_aileron = TRIM_PPRZ(roll_pgain * err);\n  if (pitch_of_roll <0.)\n    pitch_of_roll = 0.;\n\n  /* line below commented out by sanjit, to avoid use of fabs\n     err = -(estimator_theta - desired_pitch - pitch_of_roll * fabs(estimator_phi));\n     2 replacement lines are below\n  */\n  tmp_sanjit = (estimator_phi < 0) ? -estimator_phi : estimator_phi;\n  err = -(estimator_theta - desired_pitch - pitch_of_roll * tmp_sanjit);\n\n  desired_elevator = TRIM_PPRZ(pitch_pgain * err);\n\n  /* --- end inline ---- */\n\n    to_fbw.channels[RADIO_THROTTLE] = desired_gaz; // desired_gaz is set upon GPS message reception\n    to_fbw.channels[RADIO_ROLL] = desired_aileron;\n#ifndef ANTON_T7\n    to_fbw.channels[RADIO_PITCH] = desired_elevator;\n#endif\n    \n    // Code for camera stabilization, FIXME put that elsewhere\n    to_fbw.channels[RADIO_GAIN1] = TRIM_PPRZ(MAX_PPRZ/0.75*(-estimator_phi));\n}", "path": "tests\\tests\\pret\\sanjit\\stabilisation\\stabilisation_full_10.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*****************************************************\n*\t\t\tDot Product\t      *\n*****************************************************/\n", "func_signal": "long int\nmac(const short *a, const short *b, long int sqr, long int *sum)", "code": "{\n\tlong int        i;\n\tlong int        dotp = *sum;\n\n\tfor (i = 0; i < 150; i++) {\n\t\tdotp += b[i] * a[i];\n\t\tsqr += b[i] * b[i];\n\t}\n\n\t*sum = dotp;\n\n#ifdef DEBUG\n\tprintf(\"mac computation\\n\");\n\tprintf(\"%d \",sqr);\n\tprintf(\"\\n\");\n#endif\n\n\treturn sqr;\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*--------------- variable defs pulled from other files [above] --------------------------------*/\n", "func_signal": "void stabilisation_task(void)", "code": "{\n/* ---- inlined below:    ir_update(); ---- */\n// #ifndef SIMUL\n  int16_t x1_mean = buf_ir1.sum/AV_NB_SAMPLE;\n  int16_t x2_mean = buf_ir2.sum/AV_NB_SAMPLE;\n  \n  /* simplesclar cannot have type decls in the middle of the func */\n  float rad_of_ir, err, tmp_sanjit;\n\n  ir_roll = IR_RollOfIrs(x1_mean, x2_mean) - ir_roll_neutral;\n  ir_pitch = IR_PitchOfIrs(x1_mean, x2_mean) - ir_pitch_neutral;\n  /*\n#else\n  extern volatile int16_t simul_ir_roll, simul_ir_pitch;\n  ir_roll = simul_ir_roll -  ir_roll_neutral; \n  ir_pitch = simul_ir_pitch - ir_pitch_neutral;  \n#endif\n  */\n\n  /* ---- inlined below    estimator_update_state_infrared();  ---- */\n  rad_of_ir = (ir_estim_mode == IR_ESTIM_MODE_ON && EstimatorIrGainIsCorrect()) ? \n    estimator_rad_of_ir : ir_rad_of_ir;\n  estimator_phi  = rad_of_ir * ir_roll;\n\n  estimator_theta = rad_of_ir * ir_pitch;\n\n  /* --- inlined below    roll_pitch_pid_run(); // Set  desired_aileron & desired_elevator ---- */\n  err =  estimator_phi - desired_roll;\n  desired_aileron = TRIM_PPRZ(roll_pgain * err);\n  if (pitch_of_roll <0.)\n    pitch_of_roll = 0.;\n\n  /* line below commented out by sanjit, to avoid use of fabs\n     err = -(estimator_theta - desired_pitch - pitch_of_roll * fabs(estimator_phi));\n     2 replacement lines are below\n  */\n  tmp_sanjit = (estimator_phi < 0) ? -estimator_phi : estimator_phi;\n  err = -(estimator_theta - desired_pitch - pitch_of_roll * tmp_sanjit);\n\n  desired_elevator = TRIM_PPRZ(pitch_pgain * err);\n\n  /* --- end inline ---- */\n\n    to_fbw.channels[RADIO_THROTTLE] = desired_gaz; // desired_gaz is set upon GPS message reception\n    to_fbw.channels[RADIO_ROLL] = desired_aileron;\n#ifndef ANTON_T7\n    to_fbw.channels[RADIO_PITCH] = desired_elevator;\n#endif\n    \n    // Code for camera stabilization, FIXME put that elsewhere\n    to_fbw.channels[RADIO_GAIN1] = TRIM_PPRZ(MAX_PPRZ/0.75*(-estimator_phi));\n}", "path": "tests\\tests\\pret\\sanjit\\stabilisation\\stabilisation_full_7.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*--------------- variable defs pulled from other files [above] --------------------------------*/\n", "func_signal": "void stabilisation_task(void)", "code": "{\n/* ---- inlined below:    ir_update(); ---- */\n// #ifndef SIMUL\n  int16_t x1_mean = buf_ir1.sum/AV_NB_SAMPLE;\n  int16_t x2_mean = buf_ir2.sum/AV_NB_SAMPLE;\n  \n  /* simplesclar cannot have type decls in the middle of the func */\n  float rad_of_ir, err, tmp_sanjit;\n\n  ir_roll = IR_RollOfIrs(x1_mean, x2_mean) - ir_roll_neutral;\n  ir_pitch = IR_PitchOfIrs(x1_mean, x2_mean) - ir_pitch_neutral;\n  /*\n#else\n  extern volatile int16_t simul_ir_roll, simul_ir_pitch;\n  ir_roll = simul_ir_roll -  ir_roll_neutral; \n  ir_pitch = simul_ir_pitch - ir_pitch_neutral;  \n#endif\n  */\n\n  /* ---- inlined below    estimator_update_state_infrared();  ---- */\n  rad_of_ir = (ir_estim_mode == IR_ESTIM_MODE_ON && EstimatorIrGainIsCorrect()) ? \n    estimator_rad_of_ir : ir_rad_of_ir;\n  estimator_phi  = rad_of_ir * ir_roll;\n\n  estimator_theta = rad_of_ir * ir_pitch;\n\n  /* --- inlined below    roll_pitch_pid_run(); // Set  desired_aileron & desired_elevator ---- */\n  err =  estimator_phi - desired_roll;\n  desired_aileron = TRIM_PPRZ(roll_pgain * err);\n  if (pitch_of_roll <0.)\n    pitch_of_roll = 0.;\n\n  /* line below commented out by sanjit, to avoid use of fabs\n     err = -(estimator_theta - desired_pitch - pitch_of_roll * fabs(estimator_phi));\n     2 replacement lines are below\n  */\n  tmp_sanjit = (estimator_phi < 0) ? -estimator_phi : estimator_phi;\n  err = -(estimator_theta - desired_pitch - pitch_of_roll * tmp_sanjit);\n\n  desired_elevator = TRIM_PPRZ(pitch_pgain * err);\n\n  /* --- end inline ---- */\n\n    to_fbw.channels[RADIO_THROTTLE] = desired_gaz; // desired_gaz is set upon GPS message reception\n    to_fbw.channels[RADIO_ROLL] = desired_aileron;\n#ifndef ANTON_T7\n    to_fbw.channels[RADIO_PITCH] = desired_elevator;\n#endif\n    \n    // Code for camera stabilization, FIXME put that elsewhere\n    to_fbw.channels[RADIO_GAIN1] = TRIM_PPRZ(MAX_PPRZ/0.75*(-estimator_phi));\n}", "path": "tests\\tests\\pret\\sanjit\\stabilisation\\stabilisation_full_8.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/* Function with same flow, different data types,\n   nonsensical calculations */\n", "func_signal": "long int expint(int n, long int x)", "code": "{\n  int      i,ii,nm1;\n  long int a,b,c,d,del,fact,h,psi,ans;\n\n  nm1=n-1;                      /* arg=50 --> 49 */\n\n  if(x>1)                       /* take this leg? */\n    {\n      b=x+n;\n      c=2e6;\n      d=3e7;\n      h=d;\n\n      for (i=1;i<=100;i++)      /* MAXIT is 100 */\n        {\n          a = -i*(nm1+i);\n          b += 2;\n          d=10*(a*d+b);\n          c=b+a/c;\n          del=c*d;\n          h *= del;\n          if (del < 10000)\n            {\n              ans=h*-x;\n              return ans;\n            }\n        }\n    }\n  else                          /* or this leg? */\n    {\n      // For the current argument, will always take\n      // '2' path here:\n      ans = nm1 != 0 ? 2 : 1000;\n      fact=1;\n      for (i=1;i<=100;i++)      /* MAXIT */\n        {\n          fact *= -x/i;\n          if (i != nm1)         /* depends on parameter n */\n            del = -fact/(i-nm1);\n          else                  /* this fat piece only runs ONCE */\n            {                   /* runs on iter 49 */\n              psi = 0x00FF;\n              for (ii=1;ii<=nm1;ii++) /*  */\n                psi += ii + nm1;\n              del=psi+fact*foo(x);\n            }\n          ans += del;\n          /* conditional leave removed */\n        }\n\n    }\n  return ans;\n}", "path": "tests\\tests\\pret\\sys\\expint\\expint\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*****************************************************\n*\t\t\tIIR Filter\t\t     *\n*****************************************************/\n", "func_signal": "void\niir1(const short *coefs, const short *input, long int *optr, long int *state)", "code": "{\n\tlong int        x;\n\tlong int        t;\n\tlong int        n;\n\n\tx = input[0];\n\tfor (n = 0; n < 50; n++) {\n\t\tt = x + ((coefs[2] * state[0] + coefs[3] * state[1]) >> 15);\n\t\tx = t + ((coefs[0] * state[0] + coefs[1] * state[1]) >> 15);\n\t\tstate[1] = state[0];\n\t\tstate[0] = t;\n\t\tcoefs += 4;\t/* point to next filter coefs  */\n\t\tstate += 2;\t/* point to next filter states */\n\t}\n\t*optr++ = x;\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*--------------- variable defs pulled from other files [above] --------------------------------*/\n", "func_signal": "void stabilisation_task(void)", "code": "{\n/* ---- inlined below:    ir_update(); ---- */\n// #ifndef SIMUL\n  int16_t x1_mean = buf_ir1.sum/AV_NB_SAMPLE;\n  int16_t x2_mean = buf_ir2.sum/AV_NB_SAMPLE;\n  \n  /* simplesclar cannot have type decls in the middle of the func */\n  float rad_of_ir, err, tmp_sanjit;\n\n  ir_roll = IR_RollOfIrs(x1_mean, x2_mean) - ir_roll_neutral;\n  ir_pitch = IR_PitchOfIrs(x1_mean, x2_mean) - ir_pitch_neutral;\n  /*\n#else\n  extern volatile int16_t simul_ir_roll, simul_ir_pitch;\n  ir_roll = simul_ir_roll -  ir_roll_neutral; \n  ir_pitch = simul_ir_pitch - ir_pitch_neutral;  \n#endif\n  */\n\n  /* ---- inlined below    estimator_update_state_infrared();  ---- */\n  rad_of_ir = (ir_estim_mode == IR_ESTIM_MODE_ON && EstimatorIrGainIsCorrect()) ? \n    estimator_rad_of_ir : ir_rad_of_ir;\n  estimator_phi  = rad_of_ir * ir_roll;\n\n  estimator_theta = rad_of_ir * ir_pitch;\n\n  /* --- inlined below    roll_pitch_pid_run(); // Set  desired_aileron & desired_elevator ---- */\n  err =  estimator_phi - desired_roll;\n  desired_aileron = TRIM_PPRZ(roll_pgain * err);\n  if (pitch_of_roll <0.)\n    pitch_of_roll = 0.;\n\n  /* line below commented out by sanjit, to avoid use of fabs\n     err = -(estimator_theta - desired_pitch - pitch_of_roll * fabs(estimator_phi));\n     2 replacement lines are below\n  */\n  tmp_sanjit = (estimator_phi < 0) ? -estimator_phi : estimator_phi;\n  err = -(estimator_theta - desired_pitch - pitch_of_roll * tmp_sanjit);\n\n  desired_elevator = TRIM_PPRZ(pitch_pgain * err);\n\n  /* --- end inline ---- */\n\n    to_fbw.channels[RADIO_THROTTLE] = desired_gaz; // desired_gaz is set upon GPS message reception\n    to_fbw.channels[RADIO_ROLL] = desired_aileron;\n#ifndef ANTON_T7\n    to_fbw.channels[RADIO_PITCH] = desired_elevator;\n#endif\n    \n    // Code for camera stabilization, FIXME put that elsewhere\n    to_fbw.channels[RADIO_GAIN1] = TRIM_PPRZ(MAX_PPRZ/0.75*(-estimator_phi));\n}", "path": "tests\\tests\\pret\\sanjit\\stabilisation\\stabilisation_init_9.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*******************************************************\n*\tLattice Synthesis\t           *\n* This function doesn't follow the typical DSP multiply two  vector operation, but it will point out the compiler's flexibility   ********************************************************/\n", "func_signal": "long int\nlatsynth(short b[], const short k[], long int n, long int f)", "code": "{\n\tlong int        i;\n\n\tf -= b[n - 1] * k[n - 1];\n\tfor (i = n - 2; i >= 0; i--) {\n\t\tf -= b[i] * k[i];\n\t\tb[i + 1] = b[i] + ((k[i] * (f >> 16)) >> 16);\n\t}\n\tb[0] = f >> 16;\n\n#ifdef DEBUG\n\tprintf(\"latsynth computation\\n\");\n\tprintf(\"%d \",f);\n\tprintf(\"\\n\");\n#endif\n\treturn f;\n}", "path": "tests\\tests\\pret\\sys\\edn\\edn\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "// The main function\n", "func_signal": "int main (void)", "code": "{\n   InitSeed();\n#ifdef DEBUG\n   printf(\"\\n   *** MATRIX SUM AND COUNT BENCHMARK TEST ***\\n\\n\");\n   printf(\"RESULTS OF THE TEST:\\n\");\n#endif\n   Test(Array);\n   END_SIM;\n   return 1;\n}", "path": "tests\\tests\\pret\\sys\\cnt\\cnt\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*\n\n40001158:\t03 20 00 00 \tsethi  %hi(0x80000000), %g1\n4000115c:\t96 10 62 00 \tor  %g1, 0x200, %o3\t! 80000200 <LEON_REG+0x200>\n40001160:\t9a 10 20 33 \tmov  0x33, %o5\n40001164:\t82 10 00 0d \tmov  %o5, %g1\n40001168:\tc3 60 00 01 \tunknown\n4000116c:\t9a 10 20 0a \tmov  0xa, %o5\n40001170:\t98 10 20 07 \tmov  7, %o4\n40001174:\tda 22 c0 00 \tst  %o5, [ %o3 ]\n40001178:\t82 10 00 0c \tmov  %o4, %g1\n4000117c:\tc3 60 00 01 \tunknown\n40001180:\t9a 83 7f ff \taddcc  %o5, -1, %o5\n40001184:\t12 bf ff fc \tbne  40001174 <main+0x1c>\n40001188:\t01 00 00 00 \tnop \n4000118c:\t81 c3 e0 08 \tretl \n40001190:\t90 10 20 00 \tclr  %o0\t! 0 <_trap_table-0x40000000>\n\nFirst run to sync: 10 cycles, TIL: 48 cycles.\n(1 mem, 9 sing)\n\nLooped run: 6 cycles, TIL: 32 cycles. \n(1 mem, 5 sing) \n*/\n", "func_signal": "int main()", "code": "{\n  volatile unsigned int * buf = (unsigned int*)(0x80000200);\n  unsigned int i = 0;\n  /*\n    T1 takes 56 cycles to reach sync point\n    T0 takes 10 cycles to reach sync point\n    56 - 10 = 46 cycles to synchronize\n\n    T1 takes 7 cycles to do the loops and store in array to get back\n  to sync point\n  */\n\n  DEAD(46); //51\n  \n  /* Begin critical section */\n  for (i = 10; i > 0; i--) {\n    *buf = i;\n    // T1 takes 7 cycles to exit CS\n    DEAD(7);    \n  }\n  /* Exit critical section */\n  \n  return 0;\n}", "path": "soft\\sync\\sync_nodelay\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*\n\n*/\n", "func_signal": "int main()", "code": "{\n  DEAD(42);\n  volatile unsigned int * buf = (unsigned int*)(0x80000200);\n\n  unsigned int i = 0;\n  int arr[8];\n\n  for (i =0; i<8; i++)\n    arr[i] = 0;\n\n  // Loop takes 29 cycles\n  // Critical section takes 11\n  for (i = 0; ; i++) {\n    DEAD(7);\n    DEAD(22);\n  /* Enter critical section */\n    register int tmp = *buf;\n    arr[i%8] = tmp;\n  /* Exit critical section */\n  }\n\n/*\n  for (i = 0; i< 10; i++ )\n    printf(\"%d \", arr[i]);\n*/\n  return 0;\n}", "path": "soft\\sync\\sync_3thread_mutex\\thread1.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "// Intializes the given array with random integers.\n", "func_signal": "int Initialize(matrix Array)", "code": "{\n   register int OuterIndex, InnerIndex;\n\n   for (OuterIndex = 0; OuterIndex < MAXSIZE; OuterIndex++) //100 + 1\n      for (InnerIndex = 0; InnerIndex < MAXSIZE; InnerIndex++) //100 + 1\n         Array[OuterIndex][InnerIndex] = RandomInteger();\n\n   return 0;\n}", "path": "tests\\tests\\pret\\sys\\cnt\\cnt\\thread0.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/*--------------- variable defs pulled from other files [above] --------------------------------*/\n", "func_signal": "void stabilisation_task(void)", "code": "{\n/* ---- inlined below:    ir_update(); ---- */\n// #ifndef SIMUL\n  int16_t x1_mean = buf_ir1.sum/AV_NB_SAMPLE;\n  int16_t x2_mean = buf_ir2.sum/AV_NB_SAMPLE;\n  \n  /* simplesclar cannot have type decls in the middle of the func */\n  float rad_of_ir, err, tmp_sanjit;\n\n  ir_roll = IR_RollOfIrs(x1_mean, x2_mean) - ir_roll_neutral;\n  ir_pitch = IR_PitchOfIrs(x1_mean, x2_mean) - ir_pitch_neutral;\n  /*\n#else\n  extern volatile int16_t simul_ir_roll, simul_ir_pitch;\n  ir_roll = simul_ir_roll -  ir_roll_neutral; \n  ir_pitch = simul_ir_pitch - ir_pitch_neutral;  \n#endif\n  */\n\n  /* ---- inlined below    estimator_update_state_infrared();  ---- */\n  rad_of_ir = (ir_estim_mode == IR_ESTIM_MODE_ON && EstimatorIrGainIsCorrect()) ? \n    estimator_rad_of_ir : ir_rad_of_ir;\n  estimator_phi  = rad_of_ir * ir_roll;\n\n  estimator_theta = rad_of_ir * ir_pitch;\n\n  /* --- inlined below    roll_pitch_pid_run(); // Set  desired_aileron & desired_elevator ---- */\n  err =  estimator_phi - desired_roll;\n  desired_aileron = TRIM_PPRZ(roll_pgain * err);\n  if (pitch_of_roll <0.)\n    pitch_of_roll = 0.;\n\n  /* line below commented out by sanjit, to avoid use of fabs\n     err = -(estimator_theta - desired_pitch - pitch_of_roll * fabs(estimator_phi));\n     2 replacement lines are below\n  */\n  tmp_sanjit = (estimator_phi < 0) ? -estimator_phi : estimator_phi;\n  err = -(estimator_theta - desired_pitch - pitch_of_roll * tmp_sanjit);\n\n  desired_elevator = TRIM_PPRZ(pitch_pgain * err);\n\n  /* --- end inline ---- */\n\n    to_fbw.channels[RADIO_THROTTLE] = desired_gaz; // desired_gaz is set upon GPS message reception\n    to_fbw.channels[RADIO_ROLL] = desired_aileron;\n#ifndef ANTON_T7\n    to_fbw.channels[RADIO_PITCH] = desired_elevator;\n#endif\n    \n    // Code for camera stabilization, FIXME put that elsewhere\n    to_fbw.channels[RADIO_GAIN1] = TRIM_PPRZ(MAX_PPRZ/0.75*(-estimator_phi));\n}", "path": "tests\\tests\\pret\\sanjit\\stabilisation\\stabilisation_init_8.c", "repo_name": "blickly/pret_iss", "stars": 2, "license": "other", "language": "c", "size": 3516}
{"docstring": "/* Check whether state list contains a match. */\n", "func_signal": "int\nismatch(List *l)", "code": "{\n\tint i;\n\n\tfor(i=0; i<l->n; i++)\n\t\tif(l->s[i] == &matchstate)\n\t\t\treturn 1;\n\treturn 0;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/*\n * Step the NFA from the states in clist\n * past the character c,\n * to create next NFA state set nlist.\n */\n", "func_signal": "void\nstep(List *clist, int c, List *nlist)", "code": "{\n\tint i;\n\tState *s;\n\n\tlistid++;\n\tnlist->n = 0;\n\tfor(i=0; i<clist->n; i++){\n\t\ts = clist->s[i];\n\t\tif(s->c == c)\n\t\t\taddstate(nlist, s->out);\n\t}\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/*\n * Convert infix regexp re to postfix notation.\n * Insert . as explicit concatenation operator.\n * Cheesy parser, return static buffer.\n */\n", "func_signal": "char*\nre2post(char *re)", "code": "{\n\tint nalt, natom;\n\tstatic char buf[8000];\n\tchar *dst;\n\tstruct {\n\t\tint nalt;\n\t\tint natom;\n\t} paren[100], *p;\n\t\n\tp = paren;\n\tdst = buf;\n\tnalt = 0;\n\tnatom = 0;\n\tif(strlen(re) >= sizeof buf/2)\n\t\treturn NULL;\n\tfor(; *re; re++){\n\t\tswitch(*re){\n\t\tcase '(':\n\t\t\tif(natom > 1){\n\t\t\t\t--natom;\n\t\t\t\t*dst++ = '.';\n\t\t\t}\n\t\t\tif(p >= paren+100)\n\t\t\t\treturn NULL;\n\t\t\tp->nalt = nalt;\n\t\t\tp->natom = natom;\n\t\t\tp++;\n\t\t\tnalt = 0;\n\t\t\tnatom = 0;\n\t\t\tbreak;\n\t\tcase '|':\n\t\t\tif(natom == 0)\n\t\t\t\treturn NULL;\n\t\t\twhile(--natom > 0)\n\t\t\t\t*dst++ = '.';\n\t\t\tnalt++;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tif(p == paren)\n\t\t\t\treturn NULL;\n\t\t\tif(natom == 0)\n\t\t\t\treturn NULL;\n\t\t\twhile(--natom > 0)\n\t\t\t\t*dst++ = '.';\n\t\t\tfor(; nalt > 0; nalt--)\n\t\t\t\t*dst++ = '|';\n\t\t\t--p;\n\t\t\tnalt = p->nalt;\n\t\t\tnatom = p->natom;\n\t\t\tnatom++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\tcase '+':\n\t\tcase '?':\n\t\t\tif(natom == 0)\n\t\t\t\treturn NULL;\n\t\t\t*dst++ = *re;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(natom > 1){\n\t\t\t\t--natom;\n\t\t\t\t*dst++ = '.';\n\t\t\t}\n\t\t\t*dst++ = *re;\n\t\t\tnatom++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(p != paren)\n\t\treturn NULL;\n\twhile(--natom > 0)\n\t\t*dst++ = '.';\n\tfor(; nalt > 0; nalt--)\n\t\t*dst++ = '|';\n\t*dst = 0;\n\treturn buf;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * explore valid literal values for C99\n */\n", "func_signal": "int main(void)", "code": "{\n  ' ';\n  '\\'';\n  L' ';\n  \"\";\n  L\"\";\n  0;\n  1;\n  +0;\n  -0;\n  0x0;\n  0u;\n  0L;\n  0LU;\n  0LL;\n  0LLU;\n  0.;\n  0e0;\n  0.1;\n  0.f;\n  0.F;\n  0.l;\n  0.L;\n  0x.p0;\n  0i;\n  0I;\n  main;\n  return 0;\n}", "path": "lang\\c99\\types\\values.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * @return number of bytes of buf consumed; not more than buflen\n */\n", "func_signal": "size_t lex(const char *buf, size_t buflen, struct lexeme **head)", "code": "{\n  struct lexeme scratch;      /* always passed to match_one           */\n  struct lexeme *tail = NULL; /* previous match, used to connect list */\n  const char *curr = buf;\n  size_t left = buflen;\n  *head = NULL;\n  lexeme_init(&scratch);\n  /* initial match */\n  if (match_one(curr, left, &scratch)) {\n    struct lexeme *t = malloc(sizeof *t);\n    if (t) {\n      *t = scratch;\n      *head = t;\n      tail = t;\n      left -= scratch.len;\n      curr += scratch.len;\n      /* subsequent matches */\n      while (match_one(curr, left, &scratch)) {\n        t = malloc(sizeof *t);\n        if (t) {\n          *t = scratch;\n          lexeme_calc_loc(tail, t);\n          tail->next = t;\n          tail = t;\n        }\n        left -= scratch.len;\n        curr += scratch.len;\n      }\n    }\n    tail->next = NULL;\n  }\n  return buflen - left;\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Create singleton list containing just outp. */\n", "func_signal": "Ptrlist*\nlist1(State **outp)", "code": "{\n\tPtrlist *l;\n\t\n\tl = (Ptrlist*)outp;\n\tl->next = NULL;\n\treturn l;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * for each complex regular expression (T_SPACE through T_INDENT),\n * add the token to each character that may begin that token's match.\n */\n", "func_signal": "static void match_build_regexes(void)", "code": "{\n  char c;\n  match_add(' ',  T_SPACE);\n  match_add('\\t', T_SPACE);\n  match_add('\\v', T_SPACE);\n  match_add('\\f', T_SPACE);\n  match_add('\\r', T_SPACE);\n  match_add('\\n', T_NEWLINE);\n  match_add('/',  T_COMMENT);\n  /* CPP */\n  match_add('#',  T_CPP);\n  match_add('#',  T_CPP_IFDEF);\n  match_add('#',  T_CPP_IFNDEF);\n  match_add('#',  T_CPP_IF);\n  match_add('#',  T_CPP_ELIF);\n  match_add('#',  T_CPP_ELSE);\n  match_add('#',  T_CPP_ENDIF);\n  match_add('#',  T_CPP_INCLUDE);\n  match_add('#',  T_CPP_DEFINE);\n  match_add('#',  T_CPP_UNDEF);\n  match_add('#',  T_CPP_LINE);\n  match_add('#',  T_CPP_PRAGMA);\n  match_add('#',  T_CPP_IFDEF);\n  match_add('\\\\', T_CPP_LINECONT);\n  /* octal, decimal, hexadecimal integer constant */\n  for (c = '0'; c <= '9'; c++)\n    match_add(c,  T_CONST_INT);\n  /* floating constant */\n  match_add('.',  T_CONST_FLOAT);\n  for (c = '0'; c <= '9'; c++)\n    match_add(c,  T_CONST_FLOAT);\n  match_add('L',  T_CONST_STR);\n  match_add('\"',  T_CONST_STR);\n  match_add('L',  T_CONST_CHAR);\n  match_add('\\'', T_CONST_CHAR);\n  /* identifiers */\n  match_add('_',  T_IDENT);\n  for (c = 'a'; c <= 'z'; c++)\n    match_add(c,  T_IDENT);\n  for (c = 'A'; c <= 'Z'; c++)\n    match_add(c,  T_IDENT);\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * for all patterns that constitute a simple, non-branching token,\n * programatically add the first char\n */\n", "func_signal": "static void match_build_simple(void)", "code": "{\n  enum tok t;\n  for (t = T_AUTO; t < T_CNT; t++) {\n    const char *c = Lexeme[t].pattern;\n    c += ('^' == *c); /* skip regex \"start of line\" anchor, all patterns have this */\n    c += ('\\\\' == *c); /* get to the first REAL char */\n    c += ('\\\\' == *c);\n    assert('\\\\' != *c);\n    match_add(*c, t);\n  }\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * utility function\n * read contents of FILE into a buffer\n */\n", "func_signal": "static char * file2buf(FILE *f, size_t *len)", "code": "{\n  size_t buflen = 32 * 1024;\n  char *buf = malloc(buflen);\n  *len = 0;\n  if (buf) {\n    size_t off = 0;\n    ssize_t rd;\n    do {\n      ssize_t space;\n      space = buflen - off;\n      assert(space > 1);\n      rd = read(fileno(f), buf+off, space - 1);\n      if (rd > 0) {\n        off += rd;\n        if (off == buflen - 1) {\n          char *tmp = realloc(buf, buflen*2);\n          if (!tmp)\n            break;\n          buflen += buflen;\n        }\n      }\n    } while (rd > 0);\n    *len = off;\n    buf[off] = '\\0'; /* string-ize, ugh */\n  }\n  return buf;\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * match the single, first longest token (as defined in Lemexe) found in 'buf'\n * of not more than 'buflen' chars\n * @return 0=no match, 1=match recorded in 't'\n */\n", "func_signal": "static int match_one(const char *buf, size_t buflen, struct lexeme *t)", "code": "{\n  t->tok = T;\n  if (buflen > 0) {\n    unsigned i = 0;\n    unsigned longl;\n    int c = *buf;\n    regoff_t longest = 0;\n    while (i < Match[c].cnt) {\n      regmatch_t m[4];\n      int l, r;\n      l = Match[c].lexeme[i];\n      r = regexec(&Lexeme[l].rgx, buf, sizeof m / sizeof m[0], m, 0);\n      if (r != REG_NOMATCH) {\n        int len = m[0].rm_eo;\n        if (0 != m[0].rm_so || 0 == len) {\n          fprintf(stderr, \"expect offset=0 len>0. instead, offset=%d len=%d\",\n            m[0].rm_so, len);\n          exit(1);\n        }\n        assert((size_t)len <= buflen && \"match ran off the end of buf(!)\");\n        if (len > longest) {\n          longest = len;\n          longl = l;\n        }\n      }\n      i++;\n    }\n    if (longest > 0) {\n      t->tok = longl;\n      t->len = longest;\n      t->str = buf;\n    }\n  }\n  return t->tok != T;\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* infinite loop if *s != '\\0' */\n", "func_signal": "static int rgxlen(const char *s)", "code": "{\n  int c = 0;\n  while (*s)\n    c += (*s != '\\\\');\n  return c;\n}", "path": "lang\\c99\\bugdb\\infinite-loop-unchanged-iterator.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Add s to l, following unlabeled arrows. */\n", "func_signal": "void\naddstate(List *l, State *s)", "code": "{\n\tif(s == NULL || s->lastlist == listid)\n\t\treturn;\n\ts->lastlist = listid;\n\tif(s->c == Split){\n\t\t/* follow unlabeled arrows */\n\t\taddstate(l, s->out);\n\t\taddstate(l, s->out1);\n\t\treturn;\n\t}\n\tl->s[l->n++] = s;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * calculate the contents of curr->loc based on prev->loc\n */\n", "func_signal": "static void lexeme_calc_loc(const struct lexeme *prev, struct lexeme *curr)", "code": "{\n  unsigned nlcnt = lexeme_newline_cnt(prev);\n  curr->loc = prev->loc; /* copy whole thing */\n  curr->loc.line += nlcnt;\n  curr->loc.off.total += prev->len;\n  if (nlcnt) {\n    /* prev token contained at least one newline;\n     * calculate our current offset on current line */\n    curr->loc.off.line = lexeme_lastlinelen(prev);\n  } else {\n    /* we're still on the same line as previous token */\n    curr->loc.off.line += prev->len;\n  }\n  assert(curr->loc.line >= prev->loc.line);\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* one for each u8 */\n", "func_signal": "static void match_add(const char c, enum tok t)", "code": "{\n  int i = c;\n  unsigned cnt = Match[i].cnt;\n  assert(cnt < sizeof Match[0].lexeme / sizeof Match[0].lexeme[0]);\n  Match[i].lexeme[cnt] = t;\n  Match[i].cnt++;\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * token contains at least one newline.\n * we want to calculate the current line offset...\n * return the number of character at the end that are not newline.\n */\n", "func_signal": "static unsigned lexeme_lastlinelen(const struct lexeme *t)", "code": "{\n  unsigned cnt = 0;\n  switch (t->tok) {\n  /* NOTE: T_NEWLINE does not count towards line offset */\n  case T_COMMENT:\n  case T_CPP:\n    {\n      size_t i = t->len;\n      while (i--)\n        if ('\\n' == t->str[i])\n          break;\n      cnt = t->len - i;\n    }\n    break;\n  default:\n    break;\n  }\n  return cnt;\n}", "path": "lang\\c99\\parser\\lex.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Run NFA to determine whether it matches s. */\n", "func_signal": "int\nmatch(State *start, char *s)", "code": "{\n\tint i, c;\n\tList *clist, *nlist, *t;\n\n\tclist = startlist(start, &l1);\n\tnlist = &l2;\n\tfor(; *s; s++){\n\t\tc = *s & 0xFF;\n\t\tstep(clist, c, nlist);\n\t\tt = clist; clist = nlist; nlist = t;\t/* swap clist, nlist */\n\t}\n\treturn ismatch(clist);\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Initialize Frag struct. */\n", "func_signal": "Frag\nfrag(State *start, Ptrlist *out)", "code": "{\n\tFrag n = { start, out };\n\treturn n;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/*\n * Convert postfix regular expression to NFA.\n * Return start state.\n */\n", "func_signal": "State*\npost2nfa(char *postfix)", "code": "{\n\tchar *p;\n\tFrag stack[1000], *stackp, e1, e2, e;\n\tState *s;\n\t\n\t// fprintf(stderr, \"postfix: %s\\n\", postfix);\n\n\tif(postfix == NULL)\n\t\treturn NULL;\n\n\t#define push(s) *stackp++ = s\n\t#define pop() *--stackp\n\n\tstackp = stack;\n\tfor(p=postfix; *p; p++){\n\t\tswitch(*p){\n\t\tdefault:\n\t\t\ts = state(*p, NULL, NULL);\n\t\t\tpush(frag(s, list1(&s->out)));\n\t\t\tbreak;\n\t\tcase '.':\t/* catenate */\n\t\t\te2 = pop();\n\t\t\te1 = pop();\n\t\t\tpatch(e1.out, e2.start);\n\t\t\tpush(frag(e1.start, e2.out));\n\t\t\tbreak;\n\t\tcase '|':\t/* alternate */\n\t\t\te2 = pop();\n\t\t\te1 = pop();\n\t\t\ts = state(Split, e1.start, e2.start);\n\t\t\tpush(frag(s, append(e1.out, e2.out)));\n\t\t\tbreak;\n\t\tcase '?':\t/* zero or one */\n\t\t\te = pop();\n\t\t\ts = state(Split, e.start, NULL);\n\t\t\tpush(frag(s, append(e.out, list1(&s->out1))));\n\t\t\tbreak;\n\t\tcase '*':\t/* zero or more */\n\t\t\te = pop();\n\t\t\ts = state(Split, e.start, NULL);\n\t\t\tpatch(e.out, s);\n\t\t\tpush(frag(s, list1(&s->out1)));\n\t\t\tbreak;\n\t\tcase '+':\t/* one or more */\n\t\t\te = pop();\n\t\t\ts = state(Split, e.start, NULL);\n\t\t\tpatch(e.out, s);\n\t\t\tpush(frag(e.start, list1(&s->out1)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\te = pop();\n\tif(stackp != stack)\n\t\treturn NULL;\n\n\tpatch(e.out, &matchstate);\n\treturn e.start;\n#undef pop\n#undef push\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Compute initial state list */\n", "func_signal": "List*\nstartlist(State *start, List *l)", "code": "{\n\tl->n = 0;\n\tlistid++;\n\taddstate(l, start);\n\treturn l;\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/* Patch the list of states at out to point to start. */\n", "func_signal": "void\npatch(Ptrlist *l, State *s)", "code": "{\n\tPtrlist *next;\n\t\n\tfor(; l; l=next){\n\t\tnext = l->next;\n\t\tl->s = s;\n\t}\n}", "path": "lang\\c99\\types\\nfa.c", "repo_name": "rflynn/assume", "stars": 3, "license": "None", "language": "c", "size": 1266}
{"docstring": "/**\n * Handle an onresize() action of panel\n *\n * @param __panel - panel which received an onrefresh action\n * @return zero if callback hasn't handled received character\n */\n", "func_signal": "int\nfpd_onresize (file_panel_t *__panel)", "code": "{\n  if (!__panel)\n    {\n      return -1;\n    }\n\n  file_panel_update_columns_widths (__panel);\n  update_scroll_data (__panel);\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Save selection context for restore\n *\n * @param __panel - panel to operate with\n * @return zero on success, non-zero otherwise\n */\n", "func_signal": "int\nfpd_save_selection (file_panel_t *__panel)", "code": "{\n fpd_data_t *data;\n wchar_t *current_name;\n unsigned long current;\n\n  if (!__panel)\n    {\n      return -1;\n    }\n\n  if (!(data = __panel->user_data))\n    {\n      return -1;\n    }\n\n  /* Forget previous context */\n  FILE_PANEL_ACTION_CALL (__panel, free_saved_selection);\n\n  /* Save list of selected items */\n  if (__panel->items.selected_count)\n    {\n      unsigned long i, j = 0, n;\n      file_panel_item_t *item;\n\n      n = __panel->items.length;\n\n      data->selection_context.count = __panel->items.selected_count;\n      data->selection_context.names = malloc (n * sizeof (wchar_t*));\n\n      /* Save list of names of selected items */\n      for (i = 0; i < n; ++i)\n        {\n          item = &__panel->items.data[i];\n          if (item->selected)\n            {\n              data->selection_context.names[j++] = wcsdup (item->file->name);\n            }\n        }\n    }\n\n  /* Save currently selected item */\n  if (__panel->items.length)\n    {\n      current = __panel->items.current;\n      current_name = __panel->items.data[current].file->name;\n      data->selection_context.current_name = wcsdup (current_name);\n    }\n\n  data->selection_context.caret_pos = __panel->items.current;\n  data->selection_context.scroll_top = __panel->widget->scroll_top;\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Draw items of panel in brief mode\n *\n * @param __panel - panel from which draw items\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "static int\ndraw_brief_file_panel_items (const file_panel_t *__panel)", "code": "{\n  scr_window_t layout;\n  file_panel_widget_t *widget;\n  unsigned short column_count;\n  unsigned long i, start, per_page;\n\n  /* Get layout of widget */\n  if (!__panel || !(layout = WIDGET_LAYOUT ((WIDGET (__panel->widget)))))\n    {\n      return -1;\n    }\n\n  /* For scrolling */\n  start = __panel->widget->scroll_top;\n  per_page = __panel->widget->items_per_page;\n\n  /* This function is used to draw both brief and medium listings, */\n  /* so we should determine how much columns is used at this moment */\n  if (__panel->listing_mode == LISTING_MODE_BRIEF)\n    {\n      column_count = COLUMNS_PER_BRIEF;\n    }\n  else\n    {\n      column_count = COLUMNS_PER_MEDIUM;\n    }\n\n  /* Draw all items available for correct scrolling offset */\n  for (i = 0; i < per_page; i++)\n    {\n      scr_wnd_font (layout, *__panel->widget->font);\n      draw_brief_row (__panel, i + start, i + start >= __panel->items.length,\n                      column_count);\n    }\n\n  widget = __panel->widget;\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Update all data needed for scrolling\n *\n * @param __panel - file panel for which update scroll data\n */\n", "func_signal": "static void\nupdate_scroll_data (file_panel_t *__panel)", "code": "{\n  if (!__panel || !__panel->widget)\n    {\n      return;\n    }\n\n  file_panel_widget_t *widget = __panel->widget;\n\n  if (widget->position.height < 3)\n    {\n      /* Size of widget is too small, so */\n      /* we can't properly calculate scrolling data. */\n      /* The safest way - nothing to do */\n      return;\n    }\n\n  /* Scroll sizes */\n  widget->items_per_page = widget->position.height - 3;\n  if (__panel->listing_mode == LISTING_MODE_BRIEF)\n    {\n      widget->items_per_page *= COLUMNS_PER_BRIEF;\n    }\n  else\n    {\n      if (__panel->listing_mode == LISTING_MODE_MEDIUM)\n        {\n          widget->items_per_page *= COLUMNS_PER_MEDIUM;\n        }\n    }\n\n  /****\n   * Get scroll_top (aka index of first item on screen)\n   */\n\n  if (__panel->items.current >= __panel->items.length)\n    {\n      __panel->items.current = __panel->items.length - 1;\n    }\n\n  /* Come out of current displaying list of items */\n  if (__panel->items.current > widget->scroll_top + widget->items_per_page - 1)\n    {\n      widget->scroll_top = __panel->items.current - widget->items_per_page + 1;\n    }\n\n  if (__panel->items.current < widget->scroll_top)\n    {\n      widget->scroll_top = __panel->items.current;\n    }\n\n  /* If we tried to show list when the last item is not */\n  /* on the last row of widget */\n  if (__panel->items.length - widget->scroll_top < widget->items_per_page)\n    {\n      widget->scroll_top = __panel->items.length - widget->items_per_page;\n    }\n\n  /* If count of items is less than items per page,*/\n  /* then set scroll_top to zero */\n  if (__panel->items.length < widget->items_per_page)\n    widget->scroll_top = 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Set cursor to item with specified name\n *\n * @param __panel - panel for which do this operation\n * @param __name - name pf item on which cursor will be set\n */\n", "func_signal": "static void\ncursor_to_item (file_panel_t *__panel, wchar_t *__name)", "code": "{\n  unsigned long index;\n  index = file_panel_item_index_by_name (__panel, __name, 0);\n\n  if (index < 0)\n    {\n      index = 0;\n    }\n\n  __panel->items.current = index;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Initialize file panels' default actions stuff\n *\n * @return zero on success and non-zero if operation failed\n */\n", "func_signal": "int\nfpd_init (void)", "code": "{\n  /* Get data from configuration */\n  if (read_config ())\n    {\n      return -1;\n    }\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Draw row of brief-view table\n *\n * @param __panel - panel for which item is belong to\n * @param __intex - index of item in items list\n * @param __empty - is item empty?\n * This parameter is needed to draw empty rows of table\n * @param __column_count - total count of columns\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "static int\ndraw_brief_row (const file_panel_t *__panel, unsigned long __index,\n                BOOL __empty, unsigned short __column_count)", "code": "{\n  int row_number;\n  scr_font_t *item_font;\n  wchar_t pchar[MAX_SCREEN_WIDTH] = {0};\n  scr_window_t layout;\n  file_panel_item_t *item = NULL;\n  BOOL last_column;\n\n  unsigned short column_number,\n                 width,\n                 initial_width,\n                 left_offset;\n\n  unsigned long start, per_column;\n\n  /* Invalid pointers */\n  if (!__panel || !__panel->widget || !__panel->widget->layout)\n    {\n      return -1;\n    }\n\n  start = __panel->widget->scroll_top;\n  per_column = __panel->widget->items_per_page / __column_count;\n  layout = __panel->widget->layout;\n  row_number = __index - start;\n\n  if (!__empty)\n    {\n      /* Get pointer to item to be drawn */\n      item = &__panel->items.data[__index];\n\n      /* Set font of current item */\n      item_font = get_file_panel_item_font (__panel, __index);\n    }\n  else\n    {\n      item_font = __panel->widget->font;\n    }\n\n  /* Get number of current column */\n  column_number = (__index - start) / per_column;\n  if (column_number)\n    {\n      row_number -= per_column * column_number;\n    }\n\n  /* Is current column is last in panel? */\n  last_column = column_number == __column_count - 1;\n\n  /* Get width of current column */\n  initial_width = width = (__panel->widget->position.width -\n          2) / __column_count;\n\n  /* For last column use the rest space of panel */\n  /* width=<full width of panel>-<borders>-<widths of standard columns>- */\n  /*       <count of separators> */\n  if (last_column)\n    {\n      width = __panel->widget->position.width - 2 -\n              width * (__column_count - 1)-(column_number);\n    }\n\n  left_offset = column_number * (initial_width + 1) + 1;\n\n  /* Goto needed row and column */\n  scr_wnd_move_caret (layout, left_offset, row_number + 2);\n\n  /* Fit file name to width of column */\n  if (!__empty)\n    {\n      fit_filename (item->file->name, width, pchar);\n    }\n\n  /* Print name of file */\n  print_column_string (layout, pchar, width,\n                       !last_column, item_font,\n                       __panel->widget->border_font, 0);\n\n  /* If there is the first item in column, */\n  /* we should print a caption of column */\n  if (!row_number)\n    {\n      scr_wnd_move_caret (layout, left_offset, row_number + 1);\n\n      print_column_string (layout, L\"Name\", width,\n                           !last_column,\n                           __panel->widget->caption_font,\n                           __panel->widget->border_font,\n                           CF_ALIGN_CENTER);\n\n      /* Draw tee enclusers */\n      if (column_number)\n        {\n          /* Set border's font */\n          scr_wnd_font (layout, *__panel->widget->border_font);\n\n          /* Top enclosing */\n          scr_wnd_move_caret (layout, left_offset - 1, row_number);\n          scr_wnd_putch (layout, ACS_TTEE);\n\n          /* Bottom enclosing */\n          scr_wnd_move_caret (layout, left_offset - 1,\n                              row_number + per_column + 2);\n          scr_wnd_putch (layout, ACS_BTEE);\n        }\n    }\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Free list of panel's items\n *\n * @param __panel - panel from which free items' list\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "int\nfpd_free_items (file_panel_t *__panel)", "code": "{\n  unsigned long i;\n\n  if (!__panel)\n    {\n      return -1;\n    }\n\n  /* Free all items */\n  for (i = 0; i < __panel->items.length; i++)\n    {\n      if (__panel->items.data[i].file)\n        {\n          free (__panel->items.data[i].file);\n        }\n\n      /* Free user-defined data */\n      if (__panel->actions.item_user_data_deleter)\n        {\n          __panel->actions.item_user_data_deleter (__panel->items.data[i].\n                                                   user_data);\n        }\n    }\n\n  SAFE_FREE (__panel->items.data);\n\n  __panel->items.length = __panel->items.current = 0;\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Open specified item of panel\n *\n * @param __panel - panel, item from which will be opened\n * @param __item - item to be opened\n * @return zero on success, non-zero on failure\n */\n", "func_signal": "static int\nopen_file (file_panel_t *__panel, file_panel_item_t *__item)", "code": "{\n  /* Need this because name is a static array in file_t structure */\n  /* and we want to save pointer to this static buffer */\n  wchar_t *name = __item->file->name,\n          *cwd = __panel->cwd.data;\n\n  dynstruct_t *hookdata =\n    dynstruct_create (L\"ofh-struct\",\n                      L\"filename\", &name, sizeof (wchar_t*),\n                      L\"cwd\",      &cwd, sizeof (wchar_t*),\n                      NULL);\n\n  if (hook_call (L\"open-file-hook\", hookdata) != HOOK_SUCCESS)\n    {\n      MESSAGE_ERROR (L\"`open-file-hook' hook failure\");\n      return -1;\n    }\n\n  dynstruct_destroy (&hookdata);\n  return 0;\n\n  /*\n   * NOTE: Before running command, call iface_screen_disable() to\n   *       disable file manager's screen handlers.\n   *       After command is finished run iface_screen_enable() to\n   *       resume screen handling.\n   */\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Draw headers for columns\n *\n * @param __panel - panel from which draw headers for columns\n * @param __columns - descriptor of columns set\n * @param __layout - layout on which header will be drew\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "static int\ndraw_columns_headers (const file_panel_t *__panel,\n                      const file_panel_columns_t *__columns,\n                      scr_window_t __layout)", "code": "{\n  int i, n;\n  file_panel_column_t *column;\n\n  /* Get layout of widget */\n  if (!__panel || !__columns || !__layout || !__panel->widget)\n    {\n      return -1;\n    }\n\n  /* Move caret to start of row */\n  scr_wnd_move_caret (__layout, 1, 1);\n\n  /* Draw title for each column */\n  for (i = 0, n = __columns->count; i < n; i++)\n    {\n      column = &__columns->data[i];\n\n      print_column_string (__layout, column->title, column->width, i != n - 1,\n                           __panel->widget->caption_font,\n                           __panel->widget->border_font,\n                           CF_ALIGN_CENTER);\n    }\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Handler of `focused` callback (system-based)\n *\n * @param __widget - widget which catched this signal\n * @return zero if callback hasn't handled callback\n */\n", "func_signal": "static int\npanel_focused (file_panel_widget_t *__widget)", "code": "{\n  file_panel_t *panel;\n  fpd_data_t *data;\n\n  if (!__widget)\n    {\n      return FALSE;\n    }\n\n  if (!(panel = WIDGET_USER_DATA (__widget)))\n    {\n      return FALSE;\n    }\n\n  if (!(data = panel->user_data))\n    {\n      return FALSE;\n    }\n\n  return data->s_widget_callbacks.focused (__widget);\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Change CWD by concatenating specified name of subdir to current CWD\n *\n * @param __panel - panel for which CWD must be changed\n * @param __sub_dir - name of subdirectory to CHDIR to\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "static int\ncwd_sink (file_panel_t *__panel, const wchar_t *__sub_dir)", "code": "{\n  wchar_t *new_cwd;\n\n  if (!__panel || !__panel->widget)\n    {\n      return -1;\n    }\n\n  /* Get name of new CWD */\n  new_cwd = wcdircatsubdir (__panel->cwd.data, __sub_dir);\n\n  if (new_cwd)\n    {\n      wchar_t *fn = 0, /* File name to select */\n              *s_cwd = 0; /* Previous CWD */\n      unsigned long s_cur, s_scrolltop;\n\n      /* Backup parameters */\n      s_cwd = wcsdup (__panel->cwd.data);\n      s_cur = __panel->items.current;\n      s_scrolltop = __panel->widget->scroll_top;\n\n      if (wcscmp (__sub_dir, L\"..\"))\n        {\n          /* Reset current item */\n          __panel->items.current = 0;\n        }\n      else\n        {\n          fn = wcfilename (__panel->cwd.data);\n        }\n\n      /* Set new CWD */\n      if (file_panel_set_cwd (__panel, new_cwd))\n        {\n          /* Restore parameters */\n          file_panel_set_cwd (__panel, s_cwd);\n          __panel->items.current = s_cur;\n          __panel->widget->scroll_top = s_scrolltop;\n\n          /* Redraw panel */\n          file_panel_draw (__panel);\n\n          /* Some errors occurred */\n          MESSAGE_ERROR (L\"Cannot change directory\");\n\n          SAFE_FREE (s_cwd);\n          free (new_cwd);\n\n          return -1;\n        }\n\n      if (fn)\n        {\n          FILE_PANEL_ACTION_CALL (__panel, centre_to_item, fn);\n          free (fn);\n        }\n\n      SAFE_FREE (s_cwd);\n      free (new_cwd);\n    }\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Toggle selection flag for current item on file panel\n *\n * @param __panel - determines file panel in which current item selection\n * will be toggled\n * @return zero on success, non-zero otherwise\n */\n", "func_signal": "static int\ntoggle_current_selection (file_panel_t *__panel)", "code": "{\n  file_panel_item_t *item;\n\n  if (!__panel || !__panel->items.length)\n    {\n      return -1;\n    }\n\n  item = &__panel->items.data[__panel->items.current];\n  return toggle_item_selection (__panel, item);\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Get list of panel's items\n *\n * @param __panel - panel for which get items' list\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "int\nfpd_collect_items (file_panel_t *__panel)", "code": "{\n  file_t **list = NULL;\n  int i, count, ptr = 0;\n  BOOL cwd_root;\n  wchar_t *url;\n  size_t len;\n\n  if (!__panel || !__panel->cwd.data)\n    {\n      return -1;\n    }\n\n  cwd_root = !wcscmp (__panel->cwd.data, L\"/\");\n\n  /* Get full URL */\n  len = wcslen (__panel->vfs) + wcslen (__panel->cwd.data) +\n          wcslen (VFS_PLUGIN_DELIMETER);\n  url = malloc ((len + 1) * sizeof (wchar_t));\n\n  swprintf (url, len + 1, L\"%ls%ls%ls\", __panel->vfs, VFS_PLUGIN_DELIMETER,\n            __panel->cwd.data);\n\n  count = wcscandir (url,\n                     PANEL_DATA (__panel)->dir.filter,\n                     PANEL_DATA (__panel)->dir.comparator,\n                     &list);\n\n  free (url);\n\n  __panel->items.length = 0;\n\n  /* Errors while getting list of files */\n  if (count < 0)\n    return -1;\n\n  __panel->items.length = count - 1 - (cwd_root ? 1 : 0);\n  MALLOC_ZERO (__panel->items.data,\n               sizeof (file_panel_item_t) * __panel->items.length);\n\n  /* Copy file information from list from wcscandir */\n  /* to panel's list of items */\n  for (i = 0; i < count; i++)\n    {\n      /* Skip '.' from all listings and '..' from listing of root dir */\n      if (!wcscmp (list[i]->name, L\".\") ||\n          (cwd_root && !wcscmp (list[i]->name, L\"..\"))\n          )\n        {\n          free (list[i]);\n          continue;\n        }\n\n      __panel->items.data[ptr++].file = list[i];\n    }\n\n  /* Now we can free array, but not it's items! */\n  SAFE_FREE (list);\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Scroll view to make current item be displayed on center\n *\n * @param __panel - panel for which do this operation\n */\n", "func_signal": "static void\ncentralize_current_item (file_panel_t *__panel)", "code": "{\n  if (!__panel || !__panel->widget)\n    {\n      return;\n    }\n\n  file_panel_widget_t *widget = __panel->widget;\n\n  if (__panel->items.current >= widget->position.height / 2)\n    {\n      widget->scroll_top = __panel->items.current -\n               widget->position.height / 2;\n    }\n  else\n    {\n      widget->scroll_top = 0;\n    }\n\n  update_scroll_data (__panel);\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Enclose columns\n *\n * @param __columns - descriptor of columns set\n * @param __layout - layout on which item will be drawn\n * @param __ch - char which will be used to wnclose columns\n * @param __row - row of layout where do enclosing\n */\n", "func_signal": "static void\nencluse_columns (scr_window_t __layout, const file_panel_columns_t *__columns,\n                 wchar_t __ch, unsigned int __row)", "code": "{\n  int i, x = 0;\n\n  if (!__layout)\n    {\n      return;\n    }\n\n  for (i = 0; i < __columns->count - 1; i++)\n    {\n      x += __columns->data[i].width + 1;\n      scr_wnd_move_caret (__layout, x, __row);\n      scr_wnd_putch (__layout, __ch);\n    }\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Default action to draw a list of panel's items\n *\n * @param __panel - panel for which draw item list\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "int\nfpd_draw_item_list (file_panel_t *__panel)", "code": "{\n  /* But does we really need this call here? */\n\n  /*\n   * NOTE: User could changed a listing mode and we haven't handle this\n   *       in file_panel_set_listing_mode(). But may be it would better\n   *       if we handle this in those stuff?\n   */\n  update_scroll_data (__panel);\n\n  /*\n   * TODO: Add choosing of items' display mode here\n   */\n\n  if (__panel->listing_mode == LISTING_MODE_FULL)\n    {\n      draw_full_file_panel_items (__panel);\n    }\n  else\n    {\n      if (__panel->listing_mode == LISTING_MODE_BRIEF ||\n          __panel->listing_mode == LISTING_MODE_MEDIUM)\n        {\n          draw_brief_file_panel_items (__panel);\n        }\n    }\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Draw items of panel in full-row mode\n *\n * @param __panel - panel from which draw items\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "static int\ndraw_full_file_panel_items (const file_panel_t *__panel)", "code": "{\n  scr_window_t layout;\n  file_panel_widget_t *widget;\n  unsigned long i, n, start, per_page;\n\n  /* Get layout of widget */\n  if (!__panel || !(layout = WIDGET_LAYOUT ((WIDGET (__panel->widget)))))\n    {\n      return -1;\n    }\n\n  /* For scrolling */\n  start = __panel->widget->scroll_top;\n  per_page = __panel->widget->items_per_page;\n\n  widget = __panel->widget;\n\n  /* Draw header */\n  encluse_columns (layout, &__panel->columns, ACS_TTEE, 0);\n\n  if (draw_columns_headers (__panel, &__panel->columns, layout))\n    {\n      return -1;\n    }\n\n  /* Draw all items available for correct scrolling offset */\n  for (i = 0, n = MIN (per_page, __panel->items.length - start); i < n; i++)\n    {\n      draw_full_row (__panel, i + start, FALSE);\n    }\n\n  /* Fill itemless area with spaces */\n  scr_wnd_font (layout, *__panel->widget->font);\n  for (i = n; i < per_page; i++)\n    {\n      draw_full_row (__panel, i + start, TRUE);\n    }\n\n  /* Draw footer */\n  scr_wnd_font (layout, *__panel->widget->border_font);\n  encluse_columns (layout, &__panel->columns, ACS_BTEE, per_page + 2);\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Handler of `destroy` action\n *\n * @param __panel - panel for which this action is applying\n * @return zero on success, non-zero if failed\n */\n", "func_signal": "int\nfpd_destroy (file_panel_t *__panel)", "code": "{\n  fpd_data_t * data;\n\n  if (!__panel || !__panel->user_data)\n    {\n      return -1;\n    }\n\n  data = __panel->user_data;\n\n  free (data);\n\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/**\n * Handle an onrefresh() action of panel\n *\n * @param __panel - panel which received an onrefresh action\n * @return zero if callback hasn't handled received character\n */\n", "func_signal": "int\nfpd_onrefresh (file_panel_t *__panel)", "code": "{\n  if (!__panel)\n    {\n      return -1;\n    }\n\n  update_scroll_data (__panel);\n  return 0;\n}", "path": "src\\file_panel-defact.c", "repo_name": "sergeyvfx/fm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1108}
{"docstring": "/*\n *\n */\n", "func_signal": "void gen_dump(const struct genotype *g, FILE *f)", "code": "{\n  char hex[24],\n       *h;\n  u32 i, j;\n  for (i = 0; i < g->len; i++) {\n    const struct x86 *x = X86 + g->chromo[i].x86;\n    h = hex;\n    for (j = 0; j < x->oplen; j++) {\n      sprintf(h, \"%02\" PRIx8 \" \", x->op[j]);\n      h += 3;\n    }\n    if (x->modrmlen) {\n      sprintf(h, \"%02\" PRIx8 \" \", g->chromo[i].modrm);\n      h += 3;\n    }\n    for (j = 0; j < x->immlen; j++) {\n      sprintf(h, \"%02\" PRIx8 \" \", g->chromo[i].data[j]);\n      h += 3;\n    }\n    memset(h, ' ', sizeof hex - (h - hex));\n    hex[(sizeof hex) - 1] = '\\0';\n    fprintf(f, \"%3\" PRIu32 \" %s\", i, hex);\n    fprintf(f, x->descr, *(u32 *)&g->chromo[i].data);\n    if (x->modrmlen) {\n      char modbuf[16];\n      fprintf(f, \" %s\",\n        disp_modrm(g->chromo[i].modrm, x->modrm, modbuf, sizeof modbuf));\n    }\n    fputc('\\n', f);\n  }\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * given a candidate function, test it against all input and return a\n * score -- a distance from the ideal output.\n * a score of 0 indicates a perfect match against the test input\n */\n", "func_signal": "void score(genoscore *g, const genx_iface *iface, int verbose)", "code": "{\n  volatile u32 scor = 0, i;\n  u32 targetsum = 0,\n      testcnt,\n      x86len = gen_compile(&g->geno, x86, X86_BUFLEN);\n  if (Dump > 0)\n    x86_dump(x86, x86len, stdout);\n  if (Dump > 1)\n    (void)gen_dump(&g->geno, stdout);\n  //assert(score(x86, 1) == GENOSCORE_SCORE(g));\n  if (verbose || Dump >= 2) {\n    printf(\"%-35s %-23s %-23s\\n\"\n           \"----------------------------------- \"\n           \"----------------------- \"\n           \"-----------------------\\n\"\n           \"%11s %11s %11s %11s %11s %11s %11s\\n\"\n           \"----------- ----------- ----------- \"\n           \"----------- ----------- ----------- -----------\\n\",\n           \"Input\", \"Output\", \"Difference\",\n           \"a\", \"b\", \"c\", \"expected\", \"actual\", \"diff\", \"sum(diff)\");\n  }\n  testcnt = iface->test.i.data.len;\n  for (i = 0; i < testcnt; i++) {\n    volatile u32 sc   = shim_i(x86, iface->test.i.data.list[i].in[0],\n                                    iface->test.i.data.list[i].in[1],\n                                    iface->test.i.data.list[i].in[2]);\n    u32 diff;\n    targetsum += iface->test.i.data.list[i].out;\n    if (SCORE_BIT == iface->test.i.score) {\n      /*\n       * bitwise distance, useful for, well, bitwise functions\n       */\n      diff = popcnt(sc ^ iface->test.i.data.list[i].out);\n    } else {\n      /*\n       * arithmetic distance, useful for arithmetic functions\n       */\n      diff = (u32)abs((s32)iface->test.i.data.list[i].out - (s32)sc);\n    }\n    if (0xFFFFFFFFU - diff < scor) {\n      scor = 0xFFFFFFFFU;\n      break;\n    }\n    scor += diff;\n    if (verbose || Dump >= 2)\n      printf(\" 0x%08\" PRIx32 \"  0x%08\" PRIx32 \"  0x%08\" PRIx32\n            \"  0x%08\" PRIx32 \"  0x%08\" PRIx32 \" %11\" PRIu32 \" %11\" PRIu32 \"\\n\",\n        iface->test.i.data.list[i].in[0],\n        iface->test.i.data.list[i].in[1],\n        iface->test.i.data.list[i].in[2],\n        iface->test.i.data.list[i].out,\n        sc, diff, scor);\n  }\n  if (verbose || Dump >= 2) {\n    printf(\"score=%\" PRIu32 \"/%\" PRIu32 \" (%.7f%%)\\n\",\n      scor, targetsum,\n      100. - (((double)scor / (double)targetsum) * 100.));\n  }\n  g->score.i = scor;\n}", "path": "src\\run.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * given an offset, find the closest beginning of a\n * chromosome that we can jump to; we don't want to land in the middle!\n * @param off the total offset of the jump\n * @param rel the relative offset of the jump\n * @param idx the position of the jump within g->indiv, can't jump back!\n */\n", "func_signal": "static s32 gen_jmp_pos(const genotype *g, const u32 off, u32 rel, u32 idx)", "code": "{\n  u32 total = 0,\n      i;\n  s32 res;\n#if DEBUG\n  assert(idx < g->len);\n  assert(idx >= GEN_PREFIX_LEN);\n#endif\n  if (idx == g->len - 1)\n    return 0;\n  rel = idx + 1 + (rel % (g->len - idx - 2));\n#if DEBUG\n  assert(rel < Iface->opt.chromo_max + GEN_PREFIX_LEN + GEN_SUFFIX_LEN);\n#endif\n  for (i = 0; i < rel; i++)\n    total += chromo_bytes(g->chromo + i);\n  res = (s32)(total - off); /* calculate byte offset */\n  if (res < 0) /* can't go back, no matter what */\n    res = 0;\n#if DEBUG\n  assert(res >= 0);\n#endif\n  return res;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * given a candidate function and an input, pass input as a parameter\n * and execute 'f'\n */\n", "func_signal": "static float shim_f(const void *f, float a, float b, float c)", "code": "{\n  float out;\n  __asm__ volatile(\n    /* pass in parameter(s) */\n    \"fld  %2;\"\n    \"fstp    (%%esp);\"\n    \"fld  %3;\"\n    \"fstp 0x4(%%esp);\"\n    \"fld  %4;\"\n    \"fstp 0x8(%%esp);\"\n\n    /* call function pointer */\n    \"call *%1;\"\n    /* store st(0) in out */\n    \"fst   %0;\"\n    /*\n     * clear entire (8 member) x86 float stack\n     * every time, lest it eventually fill up.\n     * this took a while to figure out :-/\n     */\n    \"ffree %%st(0);\"\n    \"ffree %%st(1);\"\n    \"ffree %%st(2);\"\n    \"ffree %%st(3);\"\n    \"ffree %%st(4);\"\n    \"ffree %%st(5);\"\n    \"ffree %%st(6);\"\n    \"ffree %%st(7);\"\n    : \"=m\"(out)\n    : \"r\"(f), \"m\"(a), \"m\"(b), \"m\"(c));\n  return out;\n}", "path": "src\\run.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * \n */\n", "func_signal": "static void evolve(\n        genoscore  *best,\n        genoscore  *tmp,\n        struct pop *pop,\n  const genx_iface *iface,\n  const time_t      start)", "code": "{\n  u32 gencnt = 0;\n  GENOSCORE_SCORE(best) = GENOSCORE_WORST;\n  best->geno.len = 0;\n  pop_gen(pop, 0, iface);\n  do {\n    int progress;\n    pop_score(pop, iface, tmp);\n    progress = -1 == genoscore_lencmp(pop->indiv, best);\n    if (progress || 0 == gencnt % 1000) { /* display generation regularly or on progress */\n      char indivbuf[32];\n      u64 indivs = (u64)iface->opt.pop_size * (u64)(gencnt + 1);\n      time_t t = time(NULL);\n      double rate = (double)indivs / (t - start + 1.) / 1000.;\n      commafy(indivbuf, sizeof indivbuf, \"%llu\", indivs);\n      printf(\"GEN %7\" PRIu32 \" %15s genotypes (%.1fk/sec) @%s\",\n        gencnt, indivbuf, rate, ctime(&t));\n      if (progress) {\n        genoscore_copy(best, &pop->indiv[0]);\n        gen_dump(&best->geno, stdout);\n        printf(\"->score=%\" PRIt \"\\n\", GENOSCORE_SCORE(pop->indiv));\n        score(best, iface, 1);\n      }\n    }\n    pop_gen(pop, iface->opt.pop_keep, iface);\n    gencnt++;\n  } while (!(*iface->test.i.done)(best)\n  );\n}", "path": "src\\genx.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * populate g[off..off+len] with random chromosomes\n * from X86\n */\n", "func_signal": "static void chromo_random(genotype *g, unsigned off, unsigned len)", "code": "{\n  u32 i;\n  for (i = off; i < off + len; i++) {\n    const struct x86 *x;\n#ifdef X86_USE_FLOAT\ndo_over:\n#endif\n    g->chromo[i].x86 = randr(X86_FIRST, X86_COUNT - 1);\n    assert(g->chromo[i].x86 >= X86_FIRST);\n    assert(g->chromo[i].x86 < X86_COUNT);\n#ifdef X86_USE_FLOAT\n    if (FLD_14EBP == g->chromo[i].x86) {\n      /* FIXME: hard-coded logic to handle instruction dependency */\n      if (i == off + len - 1) /* need two spaces */\n        goto do_over;\n      /* generate prerequisite */\n      g->chromo[i].x86 = MOV_IMM32_14EBP;\n      *(float *)&g->chromo[i].data = randfr(Iface->test.f.min_const, Iface->test.f.max_const);\n      i++;\n      /* now put real one in */\n      g->chromo[i].x86 = FLD_14EBP;\n    } else {\n#endif\n      x = X86 + g->chromo[i].x86;\n      g->chromo[i].modrm = gen_modrm(x->modrm);\n      if (x->immlen) {\n#ifdef X86_USE_FLOAT\n        if (FLT == x->flt)\n          *(float *)&g->chromo[i].data = randfr(Iface->test.f.min_const, Iface->test.f.max_const);\n        else\n#endif\n          *(u32 *)&g->chromo[i].data = randr(0, Iface->test.i.max_const);\n      }\n#ifdef X86_USE_FLOAT\n    }\n#endif\n  }\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * ranged [min, max] u32\n * NOTE: this function gets called ALOT\n *       make it faster(!)\n */\n", "func_signal": "u32 randr(u32 min, u32 max)", "code": "{\n#if 0\n  /* this is the more proper way, but it's slower because it uses division! */\n  double scaled = (double)rnd32() / (double)0xFFFFFFFF;\n  u32 r = min + ((max - min + 1) * scaled);\n#else\n  /* trade quicker time for lower quality psuedo-random numbers */\n  u32 r = min + (rnd32() % (max - min + 1));\n#endif\n  return r;\n}", "path": "src\\rnd.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * format a u64 into a comma-separated string representation of that number, i.e.\n * 1 -> 1\n * 12 -> 12\n * 123 -> 123\n * 1234 -> 1,234\n * 12345 -> 12,345\n * 123456 -> 123,456\n * 1234567 -> 1,234,567\n */\n", "func_signal": "static void commafy(char *dst, size_t dstlen, const char *fmt, const u64 n)", "code": "{\n  static char srcbuf[64];\n  char       *src = srcbuf;\n  int         srclen;\n  int         prefix;   /* number of digits before first comma */\n  unsigned    off = 0;  /* track src offset */\n  srclen = snprintf(srcbuf, sizeof srcbuf, fmt, n);\n  prefix = srclen % 3;\n  if (prefix > 0) {\n    off = snprintf(dst, dstlen, \"%.*s,\", prefix, src);\n    src += prefix;\n  }\n  /* write each set of 3 digits + \",\" */\n  while (off + 4 < dstlen && *src) {\n    off += snprintf(dst+off, dstlen-off, \"%.*s,\", 3, src);\n    src += 3;\n  }\n  /* chop off last comma, if we've written anything at all */\n  dst[off - (off > 0)] = '\\0';\n}", "path": "src\\genx.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * execute f(in); ensure no collateral damage\n */\n", "func_signal": "static u32 shim_i(const void *f, u32 x, u32 y, u32 z)", "code": "{\n  volatile u32 out;\n  __asm__ volatile(\n    /*\n     * zero all registers to ensure candidate\n     * function doesn't have access to anything\n     * but zeroes\n     */\n#ifdef __x86_64__\n    \"pushq %%rdx;\"\n    \"pushq %%rdi;\"\n    \"pushq %%rsi;\"\n#else\n    \"push %%edx;\"\n    \"push %%edi;\"\n    \"push %%esi;\"\n#endif\n    /* pass in parameters */\n    /* zero regs */\n    \"xor  %%edx, %%edx;\"\n    \"xor  %%edi, %%edi;\"\n    \"xor  %%esi, %%esi;\"\n    /* call function pointer */\n    \"call *%1;\"\n#ifdef __x86_64__\n    \"popq %%rsi;\"\n    \"popq %%rdi;\"\n    \"popq %%rdx;\"\n#else\n    \"pop  %%esi;\"\n    \"pop  %%edi;\"\n    \"pop  %%edx;\"\n#endif\n    : \"=a\"(out)\n    : \"m\"(f), \"a\"(x), \"b\"(y), \"c\"(z));\n  return out;\n}", "path": "src\\run.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * given a candidate function, test it against all input and return a\n * score -- a distance from the ideal output.\n * a score of 0 indicates a perfect match against the test input\n */\n", "func_signal": "static float score_f(const void *f, int verbose)", "code": "{\n  float scor = 0.f;\n  u32 i;\n  if (verbose || Dump >= 2) {\n    printf(\"%-35s %-23s %-23s\\n\"\n           \"----------------------------------- \"\n           \"----------------------- \"\n           \"-----------------------\\n\"\n           \"%11s %11s %11s %11s %11s %11s %11s\\n\"\n           \"----------- ----------- ----------- \"\n           \"----------- ----------- ----------- -----------\\n\",\n           \"Input\", \"Output\", \"Difference\",\n           \"a\", \"b\", \"c\", \"expected\", \"actual\", \"diff\", \"sum(diff)\");\n  }\n  for (i = 0; i < TargetLen; i++) {\n    float diff,   /* difference between target and sc */\n          sc;\n    sc = shim_f(f, Target[i].in[0], Target[i].in[1], Target[i].in[2]);\n    if (!isfinite(sc)) {\n      scor = FLT_MAX;\n      if (verbose || Dump >= 2)\n        fputc('\\n', stdout);\n      break;\n    }\n    diff = Target[i].out - sc;\n    diff = fabs(diff);\n    /* detect overflow */\n    if (FLT_MAX - diff < scor) {\n      scor = FLT_MAX;\n      break;\n    }\n    scor += diff;\n    if (verbose || Dump >= 2)\n      printf(\"%11g %11g %11g %11g %11g %11g %11g\\n\",\n        Target[i].in[0], Target[i].in[1], Target[i].in[2],\n        Target[i].out, sc, diff, scor);\n  }\n  if (verbose || Dump >= 2)\n    printf(\"score=%g\\n\", scor);\n  return scor;\n}", "path": "src\\run.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * calculate the total size of the chromosome in bytes\n */\n", "func_signal": "static u32 chromo_bytes(const struct op *op)", "code": "{\n  const struct x86 *x = X86 + op->x86;\n  u32 len = 0;\n  len += x->oplen;\n  len += x->modrmlen;\n  len += x->immlen;\n  return len;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * append a command to the buffer\n */\n", "func_signal": "inline static u32 chromo_add(const struct op *op, u8 *buf, u32 len)", "code": "{\n  const struct x86 *x = X86 + op->x86;\n#if 0\n  assert(op->x86     < sizeof X86 / sizeof X86[0]);\n  assert(x->oplen  <= 4);\n  assert(x->modrmlen <= 1);\n  assert(x->immlen  <= 4);\n#endif\n  /* maximum possible value, but not always correc,t why use it?\n   * using a constant value for length lets optimizing compilers\n   * remove the memcpy call altogether, and it still works because\n   * we simply overwrite and extraneous bytes\n   */\n  memcpy(buf + len, x->op, sizeof x->op); \n  len += x->oplen;\n  if (x->modrmlen)\n    buf[len++] = op->modrm;\n  if (x->immlen) {\n    memcpy(buf + len, op->data, sizeof op->data);\n    len += x->immlen;\n  }\n  return len;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * shorter is better, given same score\n */\n", "func_signal": "static int score_id_lencmp(const void *va, const void *vb)", "code": "{\n  register const struct score_id *a = va,\n                                 *b = vb;\n  if (GENOSCORE_SCORE(a) > GENOSCORE_SCORE(b))\n    return 1;\n  else if (GENOSCORE_SCORE(a) < GENOSCORE_SCORE(b))\n    return -1;\n  else if (a->len > b->len)\n    return 1;\n  else if (a->len < b->len)\n    return -1;\n  return 0;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * shorter is better, given same score\n */\n", "func_signal": "int genoscore_lencmp(const void *va, const void *vb)", "code": "{\n  register const genoscore *a = va,\n                           *b = vb;\n  register int cmp = (GENOSCORE_SCORE(a) > GENOSCORE_SCORE(b))\n                   - (GENOSCORE_SCORE(a) < GENOSCORE_SCORE(b));\n  if (0 == cmp)\n    cmp = (a->geno.len > b->geno.len) - (a->geno.len < b->geno.len);\n  return cmp;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * load a genotype representation from gen_dump()\n */\n", "func_signal": "static int gen_load(FILE *f, genotype *g)", "code": "{\n  char line[256];\n  u8   byte[8],\n       tmp;\n  char descr[16];\n  int  tmp;\n  struct op *o;\n  /* setup prefix */\n  GEN_PREFIX(g);\n  g->len = GEN_PREFIX_LEN;\n  /* read genotype from file */\n  while (NULL != fgets(line, sizeof line[0], f)) {\n    if (\n         8 == sscanf(\"%2hhu %02\" PRIx8 \" %02\" PRIx8 \" %02\" PRIx8 \n                          \" %02\" PRIx8 \" %02\" PRIx8 \" %02\" PRIx8 \" %.*s\",\n                      &tmp, byte+0, byte+1, byte+2,\n                            byte+3, byte+4, byte+5, (int)(sizeof descr) - 1, descr)) {\n      o = g->chromo + g->len;\n      o->x86 = x86_by_descr(descr);\n      if (X86_NOTFOUND == o->x86) {\n        fprintf(stderr, \"Could not locate x86 instruction '%s'!\\n\", descr);\n        return 0;\n      } else {\n        const x86 *x = X86 + o->x86;\n        unsigned boff = x->oplen;\n        if (x->modrmlen)\n          o->modrm = byte[boff++];\n        if (x->immlen)\n          memcpy(o->data, byte+boff, x->immlen);\n      }\n      g->len++;\n    }\n  }\n  GEN_SUFFIX(g);\n  return 1;\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * allocate and initialize \n */\n", "func_signal": "static void pop_init(struct pop *p, const genx_iface *iface)", "code": "{\n  size_t bytes_indivs,\n         bytes_chromo_each,\n         bytes_chromo_all,\n         bytes_scores;\n  p->len = iface->opt.pop_size;\n  bytes_indivs = sizeof p->indiv[0] * p->len;\n  p->indiv = malloc(bytes_indivs);\n  assert(p->indiv != NULL);\n  bytes_chromo_each = CHROMO_SIZE(iface) * sizeof(struct op);\n  bytes_chromo_all = bytes_chromo_each * p->len;\n  p->indiv[0].geno.len = 0;\n  /* enough space for all chromosomes for entire pop to [0] */\n  p->indiv[0].geno.chromo = malloc(bytes_chromo_all);\n  assert(p->indiv[0].geno.chromo && \"Use smaller pop_size, fewer chromo_max or buy more RAM\");\n  /* initialize all indivs */\n  for (u32 i = 1; i < p->len; i++) {\n    p->indiv[i].geno.len = 0;\n    /* assign each individual a slice of the whole contiguous memory vector */\n    p->indiv[i].geno.chromo = p->indiv[i-1].geno.chromo + CHROMO_SIZE(iface);\n  }\n  bytes_scores = iface->opt.pop_size * sizeof *p->scores;\n  p->scores = malloc(bytes_scores);\n  assert(p->scores);\n}", "path": "src\\genx.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * modr/m byte specifies src and dst registers\n * @ref: #1 S 2-6 Table 2-1\n */\n", "func_signal": "u8 gen_modrm(u8 digit)", "code": "{\n  static const u8 x[] = {\n          /* dst <- src */\n    0xc0, /* eax <- eax */\n    0xd8, /* ebx <- eax */\n    0xc8, /* ecx <- eax */\n    0xd0, /* edx <- eax */\n\n    0xc3, /* eax <- ebx */\n    0xdb, /* ebx <- ebx */\n    0xcb, /* ecx <- ebx */\n    0xd3, /* edx <- ebx */\n\n    0xc1, /* eax <- ecx */\n    0xd9, /* ebx <- ecx */\n    0xc9, /* ecx <- ecx */\n    0xd1, /* edx <- ecx */\n\n    0xc2, /* eax <- edx */\n    0xda, /* ebx <- edx */\n    0xca, /* ecx <- edx */\n    0xd2  /* edx <- edx */\n  };\n  u8 modrm;\n  if (R == digit) {\n    /*\n     * NOTE: would be faster to calculate byte directly instead\n     * of using memory\n     */\n    modrm = x[rnd32() & 0xF];\n  } else {\n    /* \n     * NOTE: only includes e[abcd]x can't modify esp or ebp; but this\n     * solution makes it impossible to utilize e[sd]i\n     */\n    modrm = (0xc0 | (digit << 3)) + (rnd32() & 0x3);\n  }\n  return modrm;\n}", "path": "src\\x86.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * http://www.flipcode.com/archives/07-15-2002.shtml\n */\n", "func_signal": "u32 rnd32(void)", "code": "{\n  rndhi = (rndhi << 16) + (rndhi >> 16);\n  rndhi += rndlo;\n  rndlo += rndhi;\n  return rndhi;\n}", "path": "src\\rnd.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n *\n */\n", "func_signal": "static void gen_gen(genotype *dst, const genotype *src, const double mutate_rate)", "code": "{\n  if (src) {\n    /* mutate an existing genotype; by far the most common */\n    gen_copy(dst, src);\n    dst->len -= GEN_SUFFIX_LEN;\n    do\n      gen_mutate(dst);\n    while (mutate_rate <= rand01());\n  } else {\n    /* initial generation or re-generation from scratch, far less common */\n    /*\n     * always begin genotypes with a single chromosome. simpler\n     * solutions are always better, and it is easier to add\n     * instructions to a simple partial solution than to remove them\n     * from a complex full solution.\n     */\n    dst->len = GEN_PREFIX_LEN + 1;\n    GEN_PREFIX(dst);\n    chromo_random(dst, GEN_PREFIX_LEN, 1);\n  }\n\n#ifdef DEBUG\n    const genotype *g = dst;\n    assert(g->len > GEN_PREFIX_LEN);\n#endif\n\n  GEN_SUFFIX(dst);\n\n#ifdef DEBUG\n    assert(g->len > GEN_PREFIX_LEN + GEN_SUFFIX_LEN);\n    assert(g->chromo[0].x86 == ENTER);\n#if 0\n    assert(g->chromo[1].x86 == MOV_8_EBP_EAX);\n    assert(g->chromo[2].x86 == MOV_C_EBP_EBX);\n    assert(g->chromo[3].x86 == MOV_10_EBP_ECX);\n#endif\n    assert(g->chromo[g->len - 2].x86 == LEAVE);\n    assert(g->chromo[g->len - 1].x86 == RET);\n#endif\n\n}", "path": "src\\gen.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/**\n * find an x86 instruction by name\n */\n", "func_signal": "u8 x86_by_name(const char *descr)", "code": "{\n  unsigned i;\n  u8 off = X86_NOTFOUND;\n  size_t dlen = strlen(descr);\n  for (i = 0; i < sizeof X86 / sizeof X86[0]; i++) {\n    if (0 == strncmp(descr, X86[i].descr, dlen)) {\n      off = (u8)i;\n      break;\n    }\n  }\n  return off;\n}", "path": "src\\x86.c", "repo_name": "rflynn/genx", "stars": 3, "license": "mit", "language": "c", "size": 268}
{"docstring": "/* The return value is the color scheme base number for the colorpairs.\n * There are 11 color pairs for each color scheme.\n *\n * Default returns 0;\n * Second color scheme returns 11\n * Third color scheme returns 22\n *\n * The color scheme with the longest matching directory path is the one that \n * should be returned.\n */\n", "func_signal": "int\ncheck_directory_for_color_scheme(const char *dir)", "code": "{\n\tint x,y;\n\tint z = 0;\n\tint v = 0;\n\n\tfor(x = 0; x < cfg.color_scheme_num;  x++)\n\t{\n\t\ty = strlen(col_schemes[x].dir);\n\n\t\tif(!strncmp(col_schemes[x].dir, dir, y))\n\t\t{\n\t\t\tif (y > z)\n\t\t\t{\n\t\t\t\tz = y;\n\t\t\t\tv = x;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn (v * 11);\n}", "path": "src\\color_scheme.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * This checks the modified times of the directories.\n */\n", "func_signal": "static void\ncheck_if_filelists_have_changed(FileView *view)", "code": "{\n\tstruct stat s;\n\n\tstat(view->curr_dir, &s);\n\tif(s.st_mtime  != view->dir_mtime)\n\t\treload_window(view);\n\n\tif (curr_stats.number_of_windows != 1 && curr_stats.view != 1)\n\t{\n\t\tstat(other_view->curr_dir, &s);\n\t\tif(s.st_mtime != other_view->dir_mtime)\n\t\t\treload_window(other_view);\n\t}\n\n}", "path": "src\\keys.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * test if a bookmark already exists\n */\n", "func_signal": "int\nis_bookmark(const int x)", "code": "{\n\n\t/* the bookmark is valid if the file and the directory exists.\n\t * (i know, checking both is a bit paranoid, one should be enough.) */\n\tif (bookmarks[x].directory == NULL || bookmarks[x].file == NULL)\n\t\treturn 0;\n\telse if (is_dir(bookmarks[x].directory))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "path": "src\\bookmarks.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * low-level function without safety checks\n */\n", "func_signal": "void\nsilent_remove_bookmark(const int x)", "code": "{\n\tmy_free(bookmarks[x].directory);\n\tmy_free(bookmarks[x].file);\n\tbookmarks[x].directory = NULL;\n\tbookmarks[x].file = NULL;\n\t/* decrease number of active bookmarks */\n\tcfg.num_bookmarks--;\n}", "path": "src\\bookmarks.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* This is from the taken mainly from the readline program it just\n * returns the first file name in the directory that matches \n * the string passed to the function.  I couldn't get readline to handle \n * the Ctrl-c or Esc keys correctly so we are doing this the hard way.\n */\n", "func_signal": "static char *\nfilename_completion(char *string)", "code": "{\n\n\tDIR *dir;\n\tint x = 0;\n\tstruct dirent *d;\n\tchar * dirname = (char *)NULL;\n\tchar * filename = (char *)NULL;\n\tchar * temp =  (char *)NULL;\n\tint found = 0;\n\tint filename_len = 0;\n\n\tif (!string)\n\t\treturn NULL;\n\n\tif (!strncmp(string, \"~/\", 2))\n\t{\n\t\tchar * homedir = getenv(\"HOME\");\n\n\t\tdirname = (char *)malloc((strlen(homedir) + strlen(string) + 1));\n\n\t\tif (dirname == NULL)\n\t\t\treturn NULL;\n\n\t\tsnprintf(dirname, strlen(homedir) + strlen(string) + 1, \"%s/%s\",\n\t\t\t\thomedir, string + 2);\n\n\t\tfilename = strdup(dirname);\n\t}\n\telse\n\t{\n\t\tdirname = strdup(string);\n\t\tfilename = strdup(string);\n\t}\n\n\ttemp = strrchr(dirname, '/');\n\n\tif (temp)\n\t{\n\t\tstrcpy(filename, ++temp);\n\t\t*temp = '\\0';\n\t}\n\telse\n\t{\n\t\tdirname[0] = '.';\n\t\tdirname[1] = '\\0';\n\t}\n\n\n\tdir = opendir(dirname);\n\tfilename_len = strlen(filename);\n\n\tif(dir == NULL)\n\t{\n\t\tmy_free(filename);\n\t\tmy_free(dirname);\n\t\treturn NULL;\n\t}\n\n\tfor (x = 0; (d = readdir(dir)); x++)\n\t{\n\t\tif (!strncmp(d->d_name, filename, filename_len))\n\t\t{\n\t\t\tfound++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tclosedir(dir);\n\n\n\tif (found)\n\t{\n\t\tint isdir = 0;\n\t\tif (is_dir(d->d_name))\n\t\t{\n\t\t\tisdir = 1;\n\t\t}\n\t\telse if (strcmp(dirname, \".\"))\n\t\t{\n\t\t\tchar * tempfile = (char *)NULL;\n\t\t\tint len = strlen(dirname) + strlen(d->d_name) + 1;\n\t\t\ttempfile = (char *)malloc((len) * sizeof(char));\n\t\t\tif (!tempfile)\n\t\t\t\treturn NULL;\n\t\t\tsnprintf(tempfile, len, \"%s%s\", dirname, d->d_name);\n\t\t\tif (is_dir(tempfile))\n\t\t\t\tisdir = 1;\n\t\t\telse\n\t\t\t\ttemp = strdup(d->d_name);\n\n\t\t\tmy_free(tempfile);\n\t\t}\n\t\telse\n\t\t\ttemp = strdup(d->d_name);\n\n\t\tif (isdir)\n\t\t{\n\t\t\tchar * tempfile = (char *)NULL;\n\t\t\ttempfile = (char *) malloc((strlen(d->d_name) + 2) * sizeof(char));\n\t\t\tif (!tempfile)\n\t\t\t\treturn NULL;\n\t\t\tsnprintf(tempfile, strlen(d->d_name) + 2, \"%s/\", d->d_name);\n\t\t\ttemp = strdup(tempfile);\n\n\t\t\tmy_free(tempfile);\n\t\t}\n\n\t\tmy_free(filename);\n\t\tmy_free(dirname);\n\n\t\treturn temp;\n\t}\n\telse\n\t{\n\t\tmy_free(filename);\n\t\tmy_free(dirname);\n\t\treturn NULL;\n\t}\n}", "path": "src\\rline.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* The string returned needs to be freed in the calling function */\n", "func_signal": "char *\nexpand_macros(FileView *view, char *command, char *args,\n\t\tint *use_menu)", "code": "{\n\tchar * expanded = NULL;\n\tint x;\n\tint y = 0;\n\tint len = 0;\n\n\tcurr_stats.getting_input = 1;\n\n\texpanded = (char *)calloc(strlen(command) +1, sizeof(char *));\n\n\tfor(x = 0; x < strlen(command); x++)\n\t\t\tif(command[x] == '%')\n\t\t\t\tbreak;\n\n\tstrncat(expanded, command, x);\n\tx++;\n\tlen = strlen(expanded);\n\n\tdo\n\t{\n\t\tswitch(command[x])\n\t\t{\n\t\t\tcase 'a': /* user arguments */\n\t\t\t\t{\n\t\t\t\t\tif(!args)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchar arg_buf[strlen(args) +2];\n\n\t\t\t\t\t\texpanded = (char *)realloc(expanded, \n\t\t\t\t\t\t\t\tstrlen(expanded) + strlen(args) +3);\n\t\t\t\t\t\tsnprintf(arg_buf, sizeof(arg_buf), \"%s \", args);\n\t\t\t\t\t\tstrcat(expanded, arg_buf);\n\t\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'f': /* current dir selected files */\n\t\t\t\t{\n\t\t\t\t\tif(view->selected_files)\n\t\t\t\t\t{\n\t\t\t\t\t\tint y = 0;\n\t\t\t\t\t\tfor(y = 0; y < view->list_rows; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(view->dir_entry[y].selected)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, \n\t\t\t\t\t\t\t\t\t\tlen + strlen(view->dir_entry[y].name) +5);\n\n\t\t\t\t\t\t\t\t/* Directory has / appended to the name this removes it. */\n\t\t\t\t\t\t\t\tif(view->dir_entry[y].type == FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstrncat(expanded, view->dir_entry[y].name, \n\t\t\t\t\t\t\t\t\t\t\tstrlen(view->dir_entry[y].name) -1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar *temp = NULL;\n\t\t\t\t\t\t\t\t\ttemp = escape_filename(view->dir_entry[y].name, 1);\n\t\t\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, strlen(expanded) + \n\t\t\t\t\t\t\t\t\t\tstrlen(temp) +3);\n\t\t\t\t\t\t\t\t\tstrcat(expanded, temp);\n\n\t\t\t\t\t\t\t\t\tmy_free(temp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstrcat(expanded, \" \");\n\t\t\t\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\texpanded = (char *)realloc(expanded, strlen(expanded) + \n\t\t\t\t\t\t\t\tstrlen(view->dir_entry[view->list_pos].name) +3);\n\n\t\t\t\t\t\tif(view->dir_entry[view->list_pos].type == FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrncat(expanded, view->dir_entry[view->list_pos].name,\n\t\t\t\t\t\t\t\t\tstrlen(view->dir_entry[view->list_pos].name) -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *temp = \n\t\t\t\t\t\t\t\tescape_filename(view->dir_entry[view->list_pos].name, 1);\n\n\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, strlen(expanded) + \n\t\t\t\t\t\t\t\tstrlen(temp) +3);\n\t\t\t\t\t\t\tstrcat(expanded, temp);\n\t\t\t\t\t\t\tmy_free(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'F': /* other dir selected files */\n\t\t\t\t{\n\t\t\t\t\tif(other_view->selected_files)\n\t\t\t\t\t{\n\t\t\t\t\t\tint y = 0;\n\n\t\t\t\t\t\tfor(y = 0; y < other_view->list_rows; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(other_view->dir_entry[y].selected)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, len +\n\t\t\t\t\t\t\t\t\t\tstrlen(other_view->dir_entry[y].name) +\n\t\t\t\t\t\t\t\t\t\tstrlen(other_view->curr_dir) + 3);\n\n\t\t\t\t\t\t\t\tif(expanded == NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tshow_error_msg(\"Memory Error\", \"Unable to allocate memory\");\n\t\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstrcat(expanded, other_view->curr_dir);\n\t\t\t\t\t\t\t\tstrcat(expanded, \"/\");\n\n\t\t\t\t\t\t\t\tif(other_view->dir_entry[y].type == FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\t\t\t\t\tstrncat(expanded, other_view->dir_entry[y].name,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(other_view->dir_entry[y].name) -1);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar *temp = NULL;\n\t\t\t\t\t\t\t\t\ttemp = escape_filename(other_view->dir_entry[y].name, 1);\n\n\t\t\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, strlen(expanded) +\n\t\t\t\t\t\t\t\t\t\t\tstrlen(temp +3));\n\t\t\t\t\t\t\t\t\tstrcat(expanded, temp);\n\n\t\t\t\t\t\t\t\t\tmy_free(temp);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstrcat(expanded, \" \");\n\t\t\t\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\texpanded = (char *)realloc(expanded, len + \n\t\t\t\t\t\t\t\tstrlen(other_view->dir_entry[other_view->list_pos].name) +\n\t\t\t\t\t\t\t\tstrlen(other_view->curr_dir) +4);\n\t\t\t\t\t\tif(expanded == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshow_error_msg(\"Memory Error\", \"Unable to allocate memory\");\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstrcat(expanded, other_view->curr_dir);\n\t\t\t\t\t\tstrcat(expanded, \"/\");\n\n\t\t\t\t\t\tif(other_view->dir_entry[other_view->list_pos].type == FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\t\t\tstrncat(expanded, \n\t\t\t\t\t\t\t\t\tother_view->dir_entry[other_view->list_pos].name,\n\t\t\t\t\t\t\t\t\tstrlen(other_view->dir_entry[other_view->list_pos].name) -1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *temp =\n\t\t\t\t\t\t\t\tescape_filename(other_view->dir_entry[other_view->list_pos].name, 1);\n\t\t\t\t\t\t\texpanded = (char *)realloc(expanded, strlen(expanded) +\n\t\t\t\t\t\t\t\t\tstrlen(temp) + 3);\n\t\t\t\t\t\t\tstrcat(expanded, temp);\n\t\t\t\t\t\t\tmy_free(temp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd': /* current directory */\n\t\t\t\t{\n\t\t\t\t\texpanded = (char *)realloc(expanded, \n\t\t\t\t\t\t\tlen + strlen(view->curr_dir) +3);\n\t\t\t\t\tstrcat(expanded, \"\\\"\");\n\t\t\t\t\tstrcat(expanded, view->curr_dir);\n\t\t\t\t\tstrcat(expanded, \"\\\"\");\n\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D': /* other directory */\n\t\t\t\t{\n\t\t\t\t\texpanded = (char *)realloc(expanded, \n\t\t\t\t\t\t\tlen + strlen(other_view->curr_dir) +3);\n\t\t\t\t\tif(!expanded)\n\t\t\t\t\t{\n\t\t\t\t\t\tshow_error_msg(\"Memory Error\", \"Unable to allocate memory\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(expanded, \"\\\"\");\n\t\t\t\t\tstrcat(expanded, other_view->curr_dir);\n\t\t\t\t\tstrcat(expanded, \"\\\"\");\n\t\t\t\t\tlen = strlen(expanded);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm': /* use menu */\n\t\t\t\t*use_menu = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tx++;\n\t\ty = x;\n\n\t\tfor(; x < strlen(command); x++)\n\t\t{\n\t\t\t\tif(command[x] == '%')\n\t\t\t\t\tbreak;\n\t\t}\n\t\texpanded = (char *)realloc(expanded, len + strlen(command) +1); \n\t\tstrncat(expanded, command + y, x - y);\n\t\tlen = strlen(expanded);\n\t\tx++;\n\t\t}while(x < strlen(command));\n\n\tlen++;\n\texpanded[len] = '\\0';\n\tif (len > cfg.max_args/2)\n\t\tshow_error_msg(\"Argument is too long\", \" FIXME \");\n\n\tcurr_stats.getting_input = 0;\n\t\n\treturn expanded;\n}", "path": "src\\commands.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * This function is from the git program written by Tudor Hulubei and\n *  Andrei Pitis\n */\n", "func_signal": "int\nsort_dir_list(const void *one, const void *two)", "code": "{\n\tint retval;\n\tchar *pfirst, *psecond;\n\tconst dir_entry_t *first = (const dir_entry_t *) one;\n\tconst dir_entry_t *second = (const dir_entry_t *) two;\n\tint first_is_dir = first->type == DIRECTORY;\n\tint second_is_dir = second->type == DIRECTORY;\n\n\tif(first_is_dir != second_is_dir)\n\t\treturn first_is_dir ? -1 : 1;\n\tswitch(curr_view->sort_type)\n\t{\n\t\t case SORT_BY_NAME:\n\t\t\t\t break;\n\n\t\t case SORT_BY_EXTENSION:\n\t\t\t\t pfirst  = strrchr(first->name,  '.');\n\t\t\t\t psecond = strrchr(second->name, '.');\n\n\t\t\t\t if (pfirst && psecond)\n\t\t\t\t {\n\t\t\t\t\t retval = strcmp(++pfirst, ++psecond);\n\t\t\t\t\t if (retval != 0)\n\t\t\t\t\t\t\t return retval;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t if (pfirst || psecond)\n\t\t\t\t\t\t\t return (pfirst ? -1 : 1);\n\t\t\t\t break;\n\n\t\t case SORT_BY_SIZE:\n\t\t\t\t if (first->size == second->size)\n\t\t\t\t\t\tbreak;\n\t\t\t\t return first->size - second->size;\n\n\t\t case SORT_BY_TIME_MODIFIED:\n\t\t\t\t if (first->mtime == second->mtime)\n\t\t\t\t\t\tbreak;\n\t\t\t\t return first->mtime - second->mtime;\n\n\t\t case SORT_BY_TIME_ACCESSED:\n\t\t\t\t if (first->atime == second->atime)\n\t\t\t\t\t\tbreak;\n\t\t\t\t return first->atime - second->atime;\n\n\t\t case SORT_BY_TIME_CHANGED:\n\t\t\t\t if (first->ctime == second->ctime)\n\t\t\t\t\t\tbreak;\n\t\t\t\t return first->ctime - second->ctime;\n\n\t\t default:\n\t\t\t\t break;\n    }\n\n\treturn strcmp(first->name, second->name);\n}", "path": "src\\sort.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n *  Main Loop \n * \tEverything is driven from this function with the exception of \n * \tsignals which are handled in signals.c\n */\n", "func_signal": "void\nmain_key_press_cb(FileView *view)", "code": "{\n\tint done = 0;\n\tint reset_last_char = 0;\n\tint save_count = 0;\n\tint count = 0;\n\tint key = 0;\n\tchar count_buf[64] = \"\";\n\tchar status_buf[64] = \"\";\n\tint save_reg = 0;\n\n\tcurs_set(0);\n\n\twattroff(view->win, COLOR_PAIR(CURR_LINE_COLOR));\n\t\n\t/* Set keypress timeout to 1 second */\n\twtimeout(curr_view->win, 1000);\n\twtimeout(other_view->win, 1000);\n\n\tupdate_stat_window(view);\n\n\tif (view->selected_files)\n\t{\n\t\tsnprintf(status_buf, sizeof(status_buf), \"%d %s Selected\",\n\t\t\t\tview->selected_files, view->selected_files == 1 ? \"File\" :\n\t\t\t\t\"Files\");\n\t\tstatus_bar_message(status_buf);\n\t}\n\n\twhile (!done)\n\t{\n\t\tif (curr_stats.freeze)\n\t\t\tcontinue;\n\n\t\t/* Everything from here to if (key == ERR) gets called once a second */\n\n\t\tcheck_if_filelists_have_changed(view);\n\t\tcheck_background_jobs();\n\t\tcheck_messages();\n\n\t\tif (!curr_stats.save_msg)\n\t\t{\n\t\t\tclean_status_bar(view);\n\t\t\twrefresh(status_bar);\n\t\t}\n\n\t\t/* This waits for 1 second then skips if no keypress. */\n\t\tkey = wgetch(view->win);\n\n\n\t\tif (key == ERR)\n\t\t\tcontinue;\n\t\telse /* Puts the cursor at the start of the line for speakup */\n\t\t{\n\t\t\t/*\n\t\t\tint x, y;\n\t\t\tchar buf[256];\n\n\t\t\tgetyx(view->win, y, x);\n\t\t\t\n\t\t\tsnprintf(buf, sizeof(buf), \"x is %d y is %d \", x, y);\n\t\t\tshow_error_msg(\"cursor curr_win\", buf);\n\n\t\t\twmove(stdscr, y + 2, 0);\n\t\t\twrefresh(stdscr);\n\n\t\t\tgetyx(stdscr, y, x);\n\t\t\tsnprintf(buf, sizeof(buf), \"x is %d y is %d \", x, y);\n\t\t\tshow_error_msg(\"stdscr win\", buf);\n\t\t\t*/\n\t\t}\n\n\t\t/* This point down gets called only when a key is actually pressed */\n\n\t\tcurr_stats.save_msg = 0;\n\n\t\tif (curr_stats.use_register && !curr_stats.register_saved)\n\t\t{\n\t\t\tif (is_valid_register(key))\n\t\t\t{\n\t\t\t\tcurr_stats.curr_register = key;\n\t\t\t\tcurr_stats.register_saved = 1;\n\t\t\t\tsave_reg = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatus_bar_message(\"Invalid Register Key\");\n\t\t\t\tcurr_stats.save_msg = 1;\n\t\t\t\twrefresh(status_bar);\n\t\t\t\tcurr_stats.use_register = 0;\n\t\t\t\tcurr_stats.curr_register = -1;\n\t\t\t\tcurr_stats.register_saved = 0;\n\t\t\t\tsave_reg = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if((key > 47) && (key < 58)) /* ascii 0 - 9 */\n\t\t{\n\t\t\tif (count > 62)\n\t\t\t{\n\t\t\t\tshow_error_msg(\" Number is too large \", \n\t\t\t\t\t\t\"Vifm cannot handle that large of a number as a count. \");\n\t\t\t\tclear_num_window();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcount_buf[count] = key;\n\t\t\tcount++;\n\t\t\tcount_buf[count] = '\\0';\n\t\t\tupdate_num_window(count_buf);\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tclear_num_window();\n\t  \n\t\tswitch(key)\n\t\t{\n\t\t\tcase '\"': /* \"register */\n\t\t\t\tcurr_stats.use_register = 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* ascii Ctrl B */\n\t\t\tcase KEY_PPAGE:\n\t\t\t\tview->list_pos = view->list_pos - view->window_rows;\n\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\tbreak;\n\t\t\tcase 3: /* ascii Ctrl C */\n\t\t\tcase 27: /* ascii Escape */\n\t\t\t\t{\n\t\t\t\t\tint x;\n\n\t\t\t\t\tfor(x = 0; x < view->list_rows; x++)\n\t\t\t\t\t\tview->dir_entry[x].selected = 0;\n\n\t\t\t\t\tview->selected_files = 0;\n\t\t\t\t\tload_dir_list(curr_view, 1);// redraw_window();\n\t\t\t\t\tcurs_set(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6: /* ascii Ctrl F */\n\t\t\tcase KEY_NPAGE:\n\t\t\t\tview->list_pos = view->list_pos + view->window_rows;\n\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\tbreak;\n\t\t\tcase 7: /* ascii Ctrl G */\n\t\t\t\tif(!curr_stats.show_full)\n\t\t\t\t\tcurr_stats.show_full = 1;\n\t\t\t\tbreak;\n\t\t\tcase 9: /* ascii Tab */\n\t\t\tcase 32:  /* ascii Spacebar */\n\t\t\t\tchange_window(&view);\n\t\t\t\tbreak;\n\t\t\tcase 12: /* ascii Ctrl L - clear screen and redraw */\n\t\t\t\tredraw_window();\n\t\t\t\tcurs_set(0);\n\t\t\t\tbreak;\n\t\t\tcase 13: /* ascii Return */\n\t\t\t\thandle_file(view);\n\t\t\t\tbreak;\n\t\t\tcase 23: /* ascii Ctrl W - change windows */\n\t\t\t\t{\n\t\t\t\t\tint letter;\n\t\t\t\t\tcurr_stats.getting_input = 1;\n\t\t\t\t\tletter = wgetch(view->win);\n\t\t\t\t\tcurr_stats.getting_input = 0;\n\n\t\t\t\t\tif((letter == 'h') && (view->win == rwin.win))\n\t\t\t\t\t\tchange_window(&view);\n\t\t\t\t\telse if((letter == 'l') && (view->win == lwin.win))\n\t\t\t\t\t\tchange_window(&view);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '.': /* repeat last change */\n\t\t\t\trepeat_last_command(view);\n\t\t\t\tbreak;\n\t\t\tcase ':': /* command */\n\t\t\t\tcurr_stats.save_msg = get_command(view, GET_COMMAND, NULL);\n\t\t\t\tbreak;\n\t\t\tcase '/': /* search */\n\t\t\t\tcurr_stats.save_msg = get_command(view, GET_SEARCH_PATTERN, NULL);\n\t\t\t\tbreak;\n\t\t\tcase '?': /* search backwards */\n\t\t\t\tbreak;\n\t\t\tcase '\\'': /* mark */\n\t\t\t\tcurr_stats.save_msg = get_bookmark(view);\n\t\t\t\tbreak;\n\t\t\tcase '%': /* Jump to percent of file. */\n\t\t\t\tif(count)\n\t\t\t\t{\n\t\t\t\t\tint percent = atoi(count_buf);\n\t\t\t\t\tint line =  (percent * (view->list_rows)/100);\n\t\t\t\t\tmoveto_list_pos(view, line -1);\n\t\t\t\t\treset_last_char = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'G': /* Jump to bottom of list. */\n\t\t\t\t{\n\t\t\t\t\tif(count)\n\t\t\t\t\t\tmoveto_list_pos(view, atoi(count_buf) -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tmoveto_list_pos(view, view->list_rows - 1);\n\t\t\t\t\treset_last_char = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n   \t\t/* tbrown */\n\t\t\tcase 'H': /* go to first file in window */\n\t\t\t\t\tview->list_pos = view->top_line;\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t\treset_last_char =1;\n\t\t\t\t\tbreak;\n\t\t\t/* tbrown */\n\t\t\tcase 'L': /* go to last file in window */\n\t\t\t\t\tview->list_pos = view->top_line + view->window_rows;\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t\treset_last_char =1;\n\t\t\t\t\tbreak;\n\t\t\tcase 'M': /* zM Restore filename filter and hide dot files. */\n\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t{\n\t\t\t\t\trestore_filename_filter(view);\n\t\t\t\t\thide_dot_files(view);\n\t\t\t\t\treset_last_char = 1;\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{  /* tbrown go to middle of window */\n           if (view->list_rows<view->window_rows)\n\t\t\t\t\t {\n               view->list_pos = view->list_rows/2;\n           } \n\t\t\t\t\t else \n\t\t\t\t\t {\n               view->list_pos = view->top_line + (view->window_rows/2);\n           }\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t\treset_last_char = 1;\n        }\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tfind_previous_pattern(view);\n\t\t\t\tbreak;\n\t\t\tcase 'O': /* zO Remove filename filter. */\n\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\tremove_filename_filter(view);\n\t\t\t\treset_last_char = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'R': /* zR Show all hidden files */\n\t\t\t\t{\n\t\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\t{\n\t\t\t\t\t\tremove_filename_filter(view);\n\t\t\t\t\t\tshow_dot_files(view);\n\t\t\t\t\t}\n\t\t\t\t\treset_last_char = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': /* zo Show dot files */\n\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\ttoggle_dot_files(view);\n\t\t\t\treset_last_char = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'c': /* cw change word */\n\t\t\t\t{\n\t\t\t\t\tsave_count = 1;\n\t\t\t\t\tupdate_num_window(\"c\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd': /* dd  delete file */\n\t\t\t\t{\n\t\t\t\t\tsave_count = 1;\n\t\t\t\t\tupdate_num_window(\"d\");\n\t\t\t\t\tif(curr_stats.last_char == 'd')\n\t\t\t\t\t{\n\t\t\t\t\t\tclear_num_window();\n\t\t\t\t\t\tif(view->selected_files)\n\t\t\t\t\t\t\tdelete_file(view);\n\t\t\t\t\t\telse if(count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\tint y = view->list_pos;\n\t\t\t\t\t\t\tfor(x = 0; x < atoi(count_buf); x++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tview->dir_entry[y].selected = 1;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete_file(view);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdelete_file(view);\n\t\t\t\t\t\treset_last_char = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'f': /* zf filter selected files */\n\t\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\t\tfilter_selected_files(view);\n\t\t\t\t\tbreak;\n\t\t\tcase 'g': /* gg   Jump to top of the list. */\n\t\t\t\t{\n\t\t\t\t\tsave_count = 1;\n\t\t\t\t\tif(curr_stats.last_char == 'g')\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count)\n\t\t\t\t\t\t\tmoveto_list_pos(view, atoi(count_buf) -1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmoveto_list_pos(view, 0);\n\n\t\t\t\t\t\treset_last_char = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase KEY_LEFT:\n\t\t\tcase 'h': /* updir */\n\t\t\t\t{\n\t\t\t\t\tchange_directory(view, \"../\");\n\t\t\t\t\tload_dir_list(view, 0);\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:\n\t\t\tcase 'j': /* Move down one line */\n\t\t\t\t{\n\t\t\t\t\tif(count)\n\t\t\t\t\t\tview->list_pos += atoi(count_buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tview->list_pos++;\n\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t\treset_last_char =1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\tcase 'k': /* Move up one line */\n\t\t\t\t{\n\t\t\t\t\tif(count)\n\t\t\t\t\t\tview->list_pos -= atoi(count_buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tview->list_pos--;\n\n\t\t\t\t\tmoveto_list_pos(view, view->list_pos);\n\t\t\t\t\treset_last_char = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase KEY_RIGHT:\n\t\t\tcase 'l':\n\t\t\t\thandle_file(view);\n\t\t\t\tbreak;\n\t\t\tcase 'm': /*  'm' set mark  and 'zm' hide dot files */\n\t\t\t\t{\n\t\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\t{\n\t\t\t\t\t\thide_dot_files(view);\n\t\t\t\t\t\treset_last_char = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint mark;\n\t\t\t\t\t\tcurr_stats.getting_input = 1;\n\n\t\t\t\t\t\twtimeout(curr_view->win, -1);\n\t\t\t\t\t\tmark = wgetch(view->win);\n\t\t\t\t\t\twtimeout(curr_view->win, 1000);\n\t\t\t\t\t\tcurr_stats.getting_input = 0;\n\t\t\t\t\t\tif(key == ERR)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tadd_bookmark(mark, view->curr_dir, \n\t\t\t\t\t\t\tget_current_file_name(view));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tfind_next_pattern(view);\n\t\t\t\tbreak;\n\t\t\tcase 'o': /* zo Show dot files */\n\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t\tshow_dot_files(view);\n\t\t\t\treset_last_char = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'p': /* put files */\n\t\t\t\tcurr_stats.save_msg = put_files(view);\n\t\t\t\tbreak;\n\t\t\tcase 's': /* tmp shellout **** This should be done with key mapping */\n\t\t\t\tshellout(NULL, 0);\n\t\t\t\tbreak;\n\t\t\tcase 't': /* Tag file. */\n\t\t\t\ttag_file(view);\n\t\t\t\tbreak;\n\t\t\t\t/* tbrown */\n\t\t\tcase 'V':\n\t\t\tcase 'v': /* Visual selection of files. */\n\t\t\t\tcurr_stats.save_msg = start_visual_mode(view);\n\t\t\t\tbreak;\n\t\t\tcase 'w': /* cw change word */\n\t\t\t\t{\n\t\t\t\t\tif (curr_stats.last_char == 'c')\n\t\t\t\t\t\trename_file(view);\n\t\t\t\t}\n\t\t\t\tbreak;\n          /* tbrown */\n\t\t\tcase 'Y': /* Y yank file */\n\t\t\t\t\tyank_files(view, count, count_buf);\n\t\t\t\t\treset_last_char++;\n\t\t\t\t\tcurr_stats.save_msg = 1;\n\t\t\t\t\tbreak;\n\n\t\t\tcase 'y': /* yy yank file */\n\t\t\t\t{\n\t\t\t\t\tif(curr_stats.last_char == 'y')\n\t\t\t\t\t{\n\t\t\t\t\t\tyank_files(view, count, count_buf);\n\t\t\t\t\t\treset_last_char++;\n\t\t\t\t\t\tcurr_stats.save_msg = 1;\n\t\t\t\t\t\tsave_reg = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate_num_window(\"y\");\n\t\t\t\t\t\tsave_reg = 1;\n\t\t\t\t\t}\n\t\t\t\t\tsave_count = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z': /* zz redraw with file in center of list */\n\t\t\t\tif(curr_stats.last_char == 'z')\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} /* end of switch(key) */\n\n\t\tcurr_stats.last_char = key;\n\n\t\tif(!save_count)\n\t\t\tcount = 0;\n\n\t\tif(reset_last_char)\n\t\t{\n\t\t\tcurr_stats.last_char = 0;\n\t\t\treset_last_char = 0;\n\t\t\tcount = 0;\n\t\t}\n\n\t\tif(curr_stats.show_full)\n\t\t\tshow_full_file_properties(view);\n\t\telse\n\t\t\tupdate_stat_window(view);\n\n\t\tif(view->selected_files)\n\t\t{\n\t\t\tstatic int number = 0;\n\t\t\tif(number != view->selected_files)\n\t\t\t{\n\t\t\t\tsnprintf(status_buf, sizeof(status_buf), \"%d %s Selected\",\n\t\t\t\t\t\tview->selected_files, view->selected_files == 1 ? \"File\" :\n\t\t\t\t\t\t\"Files\");\n\t\t\t\tstatus_bar_message(status_buf);\n\t\t\t\tcurr_stats.save_msg = 1;\n\t\t\t}\n\t\t}\n\n\t\telse if(!curr_stats.save_msg)\n\t\t\tclean_status_bar(view);\n\n\t\tif (curr_stats.use_register && curr_stats.register_saved)\n\t\t{\n\t\t\tif (!save_reg)\n\t\t\t{\n\t\t\t\tcurr_stats.use_register = 0;\n\t\t\t\tcurr_stats.curr_register = -1;\n\t\t\t\tcurr_stats.register_saved = 0;\n\t\t\t}\n\t\t}\n\n\t\tif(curr_stats.need_redraw)\n\t\t\tload_dir_list(curr_view, 1);// redraw_window();\n\n\t\tupdate_all_windows();\n\t\n\t} /* end of while(!done)  */\n}", "path": "src\\keys.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* Only used for deleting and putting of files so that the changes show \n * up immediately in the file lists.\n */\n", "func_signal": "int\nbackground_and_wait_for_errors(char *cmd)", "code": "{\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tint retval = 1;\n\tmemset(&pi, 0, sizeof(pi));\n\tmemset(&pi, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tretval = CreateProcess(NULL, cmd, 0, 0, 0, 0, 0, 0, &si, &pi);\n\tCloseHandle(pi.hThread);\n\tWaitForSingleObject(pi.hProcess, 0);\n\tCloseHandle(pi.hProcess);\n\t\n\tif(!retval)\n\t{\n\t\tDWORD dw = GetLastError();\n\t\tchar buf[256];\n\t\t\n\t\tsnprintf(buf, 256, \"error is %d  -\",(int) dw);\n\t\tshow_error_msg(\"error in delete\", buf);\n\n\t}\n\n\n\treturn 0;\n\n}", "path": "src\\background.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*tbrown  \n  move down one position in the window, adding \n  to the selection list */\n", "func_signal": "void \nselect_down_one(FileView *view, int start_pos)", "code": "{\n\n    view->list_pos++;\n\n    if(view->list_pos >= view->list_rows)\n            ;\n\t\telse if(view->list_pos == 0)\n\t\t{\n\t\t\tif (start_pos == 0)\n\t\t\t\tview->selected_files = 0;\n\t\t}\n\t\telse if (view->list_pos == 1 && start_pos != 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n    else if(view->list_pos > start_pos)\n    {\n        view->dir_entry[view->list_pos].selected = 1;\n        view->selected_files++;\n    }\n    else if(view->list_pos == start_pos)\n    {\n        view->dir_entry[view->list_pos].selected = 1;\n        view->dir_entry[view->list_pos -1].selected = 0;\n        view->selected_files = 1;\n    }\n    else\n    {\n        view->dir_entry[view->list_pos -1].selected = 0;\n        view->selected_files--;\n    }\n}", "path": "src\\visual.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * transform a mark to an index\n * (0=48->0, 9=57->9, A=65->10,...,Z=90->35, a=97 -> 36,..., z=122 -> 61\n */\n", "func_signal": "int\nmark2index(const char mark)", "code": "{\n\tif ((int) mark > 96)\n\t\treturn (int) mark - 61;\n\telse if ((int) mark < 65)\n\t\treturn (int) mark - 48;\n\telse\n\t\treturn (int) mark - 55;\n}", "path": "src\\bookmarks.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* If you use this function using the free_selected_file_array() \n * will clean up the allocated memory\n */\n", "func_signal": "void\nget_all_selected_files(FileView *view)", "code": "{\n\tsize_t namelen;\n\tint x;\n\tint y = 0;\n\n\t/* No selected files so just use the current file */\n\tif(!view->selected_files)\n\t\tview->dir_entry[view->list_pos].selected = 1;\n\n\tview->selected_filelist = \n\t\t(char **)calloc(view->selected_files, sizeof(char *));\n\tif(view->selected_filelist == NULL)\n\t{\n\t\tshow_error_msg(\" Memory Error \", \"Unable to allocate enough memory\");\n\t\treturn;\n\t}\n\n\tfor(x = 0; x < view->list_rows; x++)\n\t{\n\t\tif(view->dir_entry[x].selected)\n\t\t{\n\t\t\tnamelen = strlen(view->dir_entry[x].name);\n\t\t\tview->selected_filelist[y] = malloc(namelen +1);\n\t\t\tif(view->selected_filelist[y] == NULL)\n\t\t\t{\n\t\t\t\tshow_error_msg(\" Memory Error \", \"Unable to allocate enough memory\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstrcpy(view->selected_filelist[y], \n\t\t\t\t\tview->dir_entry[x].name);\n\t\t\ty++;\n\t\t}\n\t}\n\tview->selected_files = y;\n}", "path": "src\\filelist.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* update_term_title() */\n", "func_signal": "static void\nadd_sort_type_info(FileView *view, int y, int x, int current_line)", "code": "{\n\tchar buf[24];\n\n\tswitch(view->sort_type)\n\t{\n/*\n\t\t case SORT_BY_OWNER_NAME:\n\t\t\t if((pwd_buf = getpwuid(view->dir_entry[x].uid)) != NULL)\n\t\t\t {\n\t\t\t\t snprintf(buf, sizeof(buf), \" %s\", pwd_buf->pw_name);\n\t\t\t\t break;\n\t\t\t }\n\t\t case SORT_BY_OWNER_ID:\n\t\t\t snprintf(buf, sizeof(buf), \" %d\", (int) view->dir_entry[x].uid);\n\t\t\t break;\n\t\t case SORT_BY_GROUP_NAME:\n\t\t\t if((grp_buf = getgrgid(view->dir_entry[x].gid)) != NULL)\n\t\t\t {\n\t\t\t\t snprintf(buf, sizeof(buf), \" %s\", grp_buf->gr_name);\n\t\t\t\t break;\n\t\t\t }\n\t\t case SORT_BY_GROUP_ID:\n\t\t\t snprintf(buf, sizeof(buf), \" %d\", (int) view->dir_entry[x].gid);\n\t\t\t break;\n\t\tcase SORT_BY_MODE:\n\t\t\t {\n\t\t\t\t  if (S_ISREG (view->dir_entry[x].mode))\n\t\t\t\t\t{\n\t\t\t\t\t\tif((S_IXUSR &view->dir_entry[x].mode)\n\t\t\t\t\t\t\t\t|| (S_IXGRP &view->dir_entry[x].mode)\n\t\t\t\t\t\t\t\t|| (S_IXOTH &view->dir_entry[x].mode))\n\n\t\t\t\t\t\t\tsnprintf(buf, sizeof(buf), \" exe\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsnprintf(buf, sizeof(buf), \" reg\");\n\t\t\t\t\t}\n\t\t\t\t\telse if(S_ISLNK(view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" link\");\n\t\t\t\t\telse if (S_ISDIR (view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" dir\");\n\t\t\t\t\telse if (S_ISCHR (view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" char\");\n\t\t\t\t\telse if (S_ISBLK (view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" block\");\n\t\t\t\t\telse if (S_ISFIFO (view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" fifo\");\n\t\t\t\t\telse if (S_ISSOCK (view->dir_entry[x].mode))\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \" sock\");\n\t\t\t\t\telse\n\t\t\t\t\t\t snprintf(buf, sizeof(buf), \"  ?  \");\n\t\t\t\tbreak;\n\t\t\t }\n\t\tcase SORT_BY_TIME_MODIFIED:\n\t\t\t tm_ptr = localtime(&view->dir_entry[x].mtime);\n\t\t\t strftime(buf, sizeof(buf), \" %m/%d-%H:%M\", tm_ptr);\n\t\t\t break;\n\t\tcase SORT_BY_TIME_ACCESSED:\n\t\t\t tm_ptr = localtime(&view->dir_entry[x].atime);\n\t\t\t strftime(buf, sizeof(buf), \" %m/%d-%H:%M\", tm_ptr);\n\t\t\t break;\n\t\tcase SORT_BY_TIME_CHANGED:\n\t\t\t tm_ptr = localtime(&view->dir_entry[x].ctime);\n\t\t\t strftime(buf, sizeof(buf), \" %m/%d-%H:%M\", tm_ptr);\n\t\t\t break;\n*/\n\t\tcase SORT_BY_NAME:\n\t\tcase SORT_BY_EXTENSION:\n\t\tcase SORT_BY_SIZE:\n\t\t\t\tsnprintf(buf, sizeof(buf), \" %d\", view->dir_entry[x].size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tsnprintf(buf, sizeof(buf), \" %d\", view->dir_entry[x].size);\n\t\t\tbreak;\n    }\n\n\tif (current_line)\n\t\twattron(view->win, COLOR_PAIR(CURR_LINE_COLOR + view->color_scheme)\n\t\t\t   \t| A_BOLD);\n\n\tmvwaddstr(view->win, y, \n\t\t\t\tview->window_width - strlen(buf), buf); \n\n\tif (current_line)\n\t\twattroff(view->win, COLOR_PAIR(CURR_LINE_COLOR + view->color_scheme)\n\t\t\t   \t| A_BOLD);\n}", "path": "src\\filelist.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * transform an index to a mark\n */\n", "func_signal": "char\nindex2mark(const int x)", "code": "{\n\tif (x > 35)\n\t\treturn (char) (x + 61);\n\telse if (x < 10)\n\t\treturn (char) (x + 48);\n\telse\n\t\treturn (char) (x + 55);\n}", "path": "src\\bookmarks.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * convert possible <color_name> to <int>\n */\n", "func_signal": "static int\ncolname2int(char col[])", "code": "{\n /* test if col[] is a number... */\n\t if (isdigit(col[0]))\n\t   return atoi(col);\n\n /* otherwise convert */\n if(!strcmp(col, \"black\"))\n   return COLOR_BLACK;\n if(!strcmp(col, \"blue\"))\n   return COLOR_BLUE;\n if(!strcmp(col, \"green\"))\n   return COLOR_GREEN;\n if(!strcmp(col, \"cyan\"))\n   return COLOR_CYAN;\n if(!strcmp(col, \"red\"))\n   return COLOR_RED;\n if(!strcmp(col, \"magenta\"))\n   return COLOR_MAGENTA;\n if(!strcmp(col, \"yellow\"))\n   return COLOR_YELLOW;\n if(!strcmp(col, \"white\"))\n   return COLOR_WHITE;\n /* return default color */\n return -1;\n}", "path": "src\\color_scheme.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "//shellout(char *command, int pause, int background)\n", "func_signal": "void\nshellout(char *command, int pause)", "code": "{\n\tchar buf[1024];\n\n\tif(!strcmp(cfg.shell_cmd, \"sh\"))\n\t{\n\t\tif(command != NULL)\n\t\t{\n\t\t\tif(pause)\n\t\t\t\tsnprintf(buf, sizeof(buf), \"sh %s\", command);\n\t\t\telse\n\t\t\t\tsnprintf(buf, sizeof(buf), \"sh %s\", command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(buf, sizeof(buf), \"sh\");\n\t\t}\n\t}\n\telse if(!strcmp(cfg.shell_cmd, \"powershell\"))\n\t{\n\t\tif(command != NULL)\n\t\t{\n\t\t\tif(pause)\n\t\t\t\tsnprintf(buf, sizeof(buf), \"powershell -NoExit -NoLogo -Command %s\", command);\n\t\t\telse\n\t\t\t\tsnprintf(buf, sizeof(buf), \"powershell -NoLogo -Command %s\", command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(buf, sizeof(buf), \"powershell -nologo -noexit\");\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tif(command != NULL)\n\t\t{\n\t\t\tif(pause)\n\t\t\t\tsnprintf(buf, sizeof(buf), \"cmd chdir %s & %s\", \n\t\t\t\t\t\tcurr_view->curr_dir, command);\n\t\t\telse\n\t\t\t\tsnprintf(buf, sizeof(buf), \"cmd /C chdir %s & %s\", \n\t\t\t\t\t\tcurr_view->curr_dir, command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(buf, sizeof(buf), \"cmd /K chdir %s \",\n\t\t\t\t\tcurr_view->curr_dir);\n\t\t}\n\t}\n\n\n\tdef_prog_mode();\n\tendwin();\n\n\tsystem(\"cls\");\n\tsystem(buf);\n\n//\tmy_system(\"cls\");\n//\tmy_system(buf);\n\n\n\t/* There is a problem with using the screen program and \n\t * catching all the SIGWICH signals.  So just redraw the window.\n\t */\n\tif (!isendwin())\n\t\tredraw_window();\n\n\tcurs_set(0);\n}", "path": "src\\commands.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * add color\n */\n", "func_signal": "void\nadd_color(char s1[], char s2[], char s3[])", "code": "{\n \tint fg, bg;\n\tint scheme = 0;\n\tint x = cfg.color_scheme_num -1;\n\tint y = cfg.color_pairs_num;\n\n\tfg = colname2int(s2);\n\tbg = colname2int(s3);\n\n\tif(y > 10)\n\t\ty =  (y % 11);\n\n\tscheme = ((cfg.color_scheme_num - 1) * 11);\n\n\n\tif(!strcmp(s1, \"MENU\"))\n\t\tcol_schemes[x].color[y].name = 0 + scheme;\n\n\tif(!strcmp(s1, \"BORDER\"))\n\t\tcol_schemes[x].color[y].name = 1 + scheme;\n\n\tif(!strcmp(s1, \"WIN\"))\n\t\tcol_schemes[x].color[y].name = 2 + scheme;\n\n\tif(!strcmp(s1, \"STATUS_BAR\"))\n\t\tcol_schemes[x].color[y].name = 3 + scheme;\n\n\tif(!strcmp(s1, \"CURR_LINE\"))\n\t\tcol_schemes[x].color[y].name = 4 + scheme;\n\n\tif(!strcmp(s1, \"DIRECTORY\"))\n\t\tcol_schemes[x].color[y].name = 5 + scheme;\n\n\tif(!strcmp(s1, \"FIFO\"))\n\t\tcol_schemes[x].color[y].name = 6 + scheme;\n\n\tif(!strcmp(s1, \"DEVICE\"))\n\t\tcol_schemes[x].color[y].name = 7 + scheme;\n\n\tif(!strcmp(s1, \"EXECUTABLE\"))\n\t\tcol_schemes[x].color[y].name = 8 + scheme;\n\n\tif(!strcmp(s1, \"SELECTED\"))\n\t\tcol_schemes[x].color[y].name = 9 + scheme;\n\n\tif(!strcmp(s1, \"CURRENT\"))\n\t\tcol_schemes[x].color[y].name = 10 + scheme;\n\n\tcol_schemes[x].color[y].fg = fg;\n\tcol_schemes[x].color[y].bg = bg;\n\n\tcfg.color_pairs_num++;\n}", "path": "src\\color_scheme.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* tbrown  \n\tmove up one position in the window, adding \n  to the selection list */\n", "func_signal": "void\nselect_up_one(FileView *view, int start_pos)", "code": "{\n\n    view->list_pos--;\n    if(view->list_pos < 0)\n\t\t{\n\t\t\tif (start_pos == 0)\n\t\t\t\tview->selected_files = 0;\n\t\t\tview->list_pos = 0;\n\t\t}\n\t\telse if(view->list_pos == 0)\n\t\t{\n\t\t\tif(start_pos == 0)\n\t\t\t{\n        view->dir_entry[view->list_pos +1].selected = 0;\n        view->selected_files = 0;\n\t\t\t}\n\t\t}\n    else if(view->list_pos < start_pos)\n    {\n        view->dir_entry[view->list_pos].selected = 1;\n        view->selected_files++;\n    }\n    else if(view->list_pos == start_pos)\n    {\n        view->dir_entry[view->list_pos].selected = 1;\n        view->dir_entry[view->list_pos +1].selected = 0;\n        view->selected_files = 1;\n    }\n    else\n    {\n        view->dir_entry[view->list_pos +1].selected = 0;\n        view->selected_files--;\n    }\n}", "path": "src\\visual.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\nstatic void \nadd_background_job(int pid, char *cmd, int fd) \n{\n\tJobs_List *new;\n\n\tnew = (Jobs_List *)malloc(sizeof(Jobs_List)); \n\tnew->pid = pid;\n\tnew->cmd = strdup(cmd);\n\tnew->next = jobs;\n\tnew->fd = fd; \n\tnew->error_buf = (char *)calloc(1, sizeof(char));\n\tnew->running = 1;\n\tjobs = new;\n}\n*/\n", "func_signal": "void \nadd_finished_job(int pid, int status)", "code": "{\n\tFinished_Jobs *new;\n\n\tnew = (Finished_Jobs *)malloc(sizeof(Finished_Jobs)); \n\tnew->pid = pid;\n\tnew->remove = 0;\n\tnew->next = fjobs;\n\tfjobs = new;\n}", "path": "src\\background.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/* execute command. */\n", "func_signal": "int\nfile_exec(char *command)", "code": "{\n\tchar *args[4];\n\tpid_t pid;\n\n\targs[0] = \"sh\";\n\targs[1] = \"-c\";\n\targs[2] = command;\n\targs[3] = NULL;\n\n\tpid = execute(args);\n\treturn pid;\n}", "path": "src\\fileops.c", "repo_name": "ksteen/vifm-w32", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 164}
{"docstring": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\n", "func_signal": "void MD5Init(struct MD5Context *ctx)", "code": "{\n    ctx->buf[0] = 0x67452301;\n    ctx->buf[1] = 0xefcdab89;\n    ctx->buf[2] = 0x98badcfe;\n    ctx->buf[3] = 0x10325476;\n\n    ctx->bits[0] = 0;\n    ctx->bits[1] = 0;\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\libiax2\\src\\md5.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/*\n * Final wrapup - pad to 64-byte boundary with the bit pattern \n * 1 0* (64-bit count of bits processed, MSB-first)\n */\n", "func_signal": "void MD5Final(uint8_t digest[16], struct MD5Context *ctx)", "code": "{\n    unsigned int count;\n    uint8_t *p;\n\n    /* Compute number of bytes mod 64 */\n    count = (ctx->bits[0] >> 3) & 0x3F;\n\n    /* Set the first char of padding to 0x80.  This is safe since there is\n       always at least one byte free */\n    p = ctx->in + count;\n    *p++ = 0x80;\n\n    /* Bytes of padding needed to make 64 bytes */\n    count = 64 - 1 - count;\n\n    /* Pad out to 56 mod 64 */\n    if (count < 8) {\n\t/* Two lots of padding:  Pad the first block to 64 bytes */\n\tmemset(p, 0, count);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (uint32_t *) ctx->in);\n\n\t/* Now fill the next block with 56 bytes */\n\tmemset(ctx->in, 0, 56);\n    } else {\n\t/* Pad block to 56 bytes */\n\tmemset(p, 0, count - 8);\n    }\n    byteReverse(ctx->in, 14);\n\n    /* Append length in bits and transform */\n    ((uint32_t *) ctx->in)[14] = ctx->bits[0];\n    ((uint32_t *) ctx->in)[15] = ctx->bits[1];\n\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    byteReverse((uint8_t *) ctx->buf, 4);\n    memcpy(digest, ctx->buf, 16);\n    memset(ctx, 0, sizeof(ctx));\t/* In case it's sensitive */\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\libiax2\\src\\md5.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "// Pads a w by h frame to bring it up to pw by ph size using value\n", "func_signal": "static void pad_channel(const char *src, int w, int h, unsigned char *dst,\n\t\tint pw, int ph, unsigned char value)", "code": "{\n\tint i;\n\n\tif ( w == pw )\n\t{\n\t\t// We don't need to pad each line, just copy the data\n\t\tmemcpy(dst, src, w * h);\n\t} else\n\t{\n\t\t// We DO need to pad each line\n\t\tfor ( i=0 ; i<h ; i++ )\n\t\t{\n\t\t\tmemcpy(&dst[i*pw], &src[i*w], w);\n\t\t\tmemset(&dst[i*pw+w], value, pw-w);\n\t\t}\n\t}\n\t// Pad the bottom of the frame if necessary\n\tif ( h < ph )\n\t\tmemset(dst + pw * h, value, (ph - h) * pw);\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\codec_theora.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* initialize audio driver */\n", "func_signal": "int alsa_initialize (struct iaxc_audio_driver *d ,int sample_rate)", "code": "{\n    int i;\n    int err;\n    short buf[128];\n    snd_pcm_hw_params_t *hw_params;\n    snd_pcm_sw_params_t *sw_params;\n\n    if ((err = snd_pcm_open (&stream_out, \"default\", SND_PCM_STREAM_PLAYBACK, 0)) < 0) {\n        fprintf (stderr, \"cannot open audio device default (%s)\\n\",\n        snd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {\n        fprintf (stderr, \"cannot allocate hardware parameter structure (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_any (stream_out, hw_params)) < 0) {\n\tfprintf (stderr, \"cannot initialize hardware parameter structure (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_access (stream_out, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {\n\tfprintf (stderr, \"cannot set access type (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_format (stream_out, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {\n\tfprintf (stderr, \"cannot set sample format (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_rate (stream_out, hw_params, sample_rate, 0)) < 0) {\n        fprintf (stderr, \"cannot set sample rate (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_channels (stream_out, hw_params, 1)) < 0) {\n\tfprintf (stderr, \"cannot set channel count (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params (stream_out, hw_params)) < 0) {\n\tfprintf (stderr, \"cannot set parameters (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n\n    snd_pcm_sw_params_malloc(&sw_params);\n\n    err = snd_pcm_sw_params_current(stream_out, sw_params);\n    if (err < 0) {\n\tprintf(\"Unable to determine current swparams for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n    err = snd_pcm_sw_params_set_start_threshold(stream_out, sw_params, 80);\n    if (err < 0) {\n        fprintf(stderr, \"Unable to set start threshold mode for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n    err = snd_pcm_sw_params(stream_out, sw_params);\n    if (err < 0) {\n        fprintf(stderr, \"Unable to set sw params for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n\n    if ((err = snd_pcm_open (&stream_in, \"default\", SND_PCM_STREAM_CAPTURE, 0)) < 0) {\n        fprintf (stderr, \"cannot open audio device default (%s)\\n\",\n        snd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_any (stream_in, hw_params)) < 0) {\n\tfprintf (stderr, \"cannot initialize hardware parameter structure (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_access (stream_in, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {\n\tfprintf (stderr, \"cannot set access type (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_format (stream_in, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {\n\tfprintf (stderr, \"cannot set sample format (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_rate (stream_in, hw_params, sample_rate, 0)) < 0) {\n        fprintf (stderr, \"cannot set sample rate (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params_set_channels (stream_in, hw_params, 1)) < 0) {\n\tfprintf (stderr, \"cannot set channel count (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n    if ((err = snd_pcm_hw_params (stream_in, hw_params)) < 0) {\n\tfprintf (stderr, \"cannot set parameters (%s)\\n\",\n\tsnd_strerror (err));\n\texit (1);\n    }\n\n    err = snd_pcm_sw_params_current(stream_in, sw_params);\n    if (err < 0) {\n\tprintf(\"Unable to determine current swparams for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n    err = snd_pcm_sw_params_set_start_threshold(stream_in, sw_params, 80);\n    if (err < 0) {\n        fprintf(stderr, \"Unable to set start threshold mode for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n    err = snd_pcm_sw_params(stream_in, sw_params);\n    if (err < 0) {\n        fprintf(stderr, \"Unable to set sw params for playback: %s\\n\", snd_strerror(err));\n        return err;\n    }\n\n\n    if ((err = snd_pcm_prepare (stream_in)) < 0) {\n        fprintf (stderr, \"cannot prepare audio interface for use (%s)\\n\",\n\tsnd_strerror (err));\n\t exit (1);\n    }\n\n    if ((err = snd_pcm_prepare (stream_out)) < 0) {\n        fprintf (stderr, \"cannot prepare audio interface for use (%s)\\n\",\n\tsnd_strerror (err));\n\t exit (1);\n    }\n\n    d->initialize = alsa_initialize;\n    d->destroy = alsa_destroy;\n    d->select_devices = alsa_select_devices;\n    d->selected_devices = alsa_selected_devices;\n    d->start = alsa_start;\n    d->stop = alsa_stop;\n    d->output = alsa_output;\n    d->input = alsa_input;\n    d->input_level_get = alsa_input_level_get;\n    d->input_level_set = alsa_input_level_set;\n    d->output_level_get = alsa_output_level_get;\n    d->output_level_set = alsa_output_level_set;\n    d->play_sound = alsa_play_sound;\n    d->stop_sound = alsa_stop_sound;\n\n    return 0;\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\audio_alsa.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/*\n * The core of the MD5 algorithm, this alters an existing MD5 hash to\n * reflect the addition of 16 longwords of new data.  MD5Update blocks\n * the data and converts bytes into longwords for this routine.\n */\n", "func_signal": "void MD5Transform(uint32_t buf[4], uint32_t const in[16])", "code": "{\n    uint32_t a, b, c, d;\n\n    a = buf[0];\n    b = buf[1];\n    c = buf[2];\n    d = buf[3];\n\n    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n    buf[0] += a;\n    buf[1] += b;\n    buf[2] += c;\n    buf[3] += d;\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\libiax2\\src\\md5.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* routine called at exit to shutdown audio I/O and close nicely.\nNOTE: If all this isnt done, the system doesnt not handle this\ncleanly and has to be rebooted. What a pile of doo doo!! */\n", "func_signal": "void killem(void)", "code": "{\n\tshutdown_client();\n\n\t// VC++ Memory Leak Detection\n\t//_CrtDumpMemoryLeaks();\n\n\treturn;\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\simpleclient\\win32\\simpleiax.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* routine used to shutdown and close nicely.*/\n", "func_signal": "void hangup_and_exit(int code)", "code": "{\n\tmylog(\"Dump call\\n\");\n\tiaxc_dump_call();\n\tmylog(\"Sleep for 500 msec\\n\");\n\tiaxc_millisleep(500);\n\tmylog(\"Stop processing thread\\n\");\n\tiaxc_stop_processing_thread();\n\tmylog(\"Calling iaxc_shutdown...\\n\");\n\tiaxc_shutdown();\n\tmylog(\"Exiting with code %d\\n\", code);\n\texit(code);\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\simpleclient\\stresstest\\stresstest.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Based on available data, this computes the optimal delay for the jitter buffer. \n   The optimised function is in timestamp units and is:\n   cost = delay + late_factor*[number of frames that would be late if we used that delay]\n   @param tb Array of buffers\n   @param late_factor Equivalent cost of a late frame (in timestamp units) \n */\n", "func_signal": "static spx_int16_t compute_opt_delay(JitterBuffer *jitter)", "code": "{\n   int i;\n   spx_int16_t opt=0;\n   spx_int32_t best_cost=0x7fffffff;\n   int late = 0;\n   int pos[MAX_BUFFERS];\n   int tot_count;\n   float late_factor;\n   int penalty_taken = 0;\n   int best = 0;\n   int worst = 0;\n   spx_int32_t deltaT;\n   struct TimingBuffer *tb;\n   \n   tb = jitter->_tb;\n   \n   /* Number of packet timings we have received (including those we didn't keep) */\n   tot_count = 0;\n   for (i=0;i<MAX_BUFFERS;i++)\n      tot_count += tb[i].curr_count;\n   if (tot_count==0)\n      return 0;\n   \n   /* Compute cost for one lost packet */\n   if (jitter->latency_tradeoff != 0)\n      late_factor = jitter->latency_tradeoff * 100.0f / tot_count;\n   else\n      late_factor = jitter->auto_tradeoff * jitter->window_size/tot_count;\n   \n   /*fprintf(stderr, \"late_factor = %f\\n\", late_factor);*/\n   for (i=0;i<MAX_BUFFERS;i++)\n      pos[i] = 0;\n   \n   /* Pick the TOP_DELAY \"latest\" packets (doesn't need to actually be late \n      for the current settings) */\n   for (i=0;i<TOP_DELAY;i++)\n   {\n      int j;\n      int next=-1;\n      int latest = 32767;\n      /* Pick latest amoung all sub-windows */\n      for (j=0;j<MAX_BUFFERS;j++)\n      {\n         if (pos[j] < tb[j].filled && tb[j].timing[pos[j]] < latest)\n         {\n            next = j;\n            latest = tb[j].timing[pos[j]];\n         }\n      }\n      if (next != -1)\n      {\n         spx_int32_t cost;\n         \n         if (i==0)\n            worst = latest;\n         best = latest;\n         latest = ROUND_DOWN(latest, jitter->delay_step);\n         pos[next]++;\n         \n         /* Actual cost function that tells us how bad using this delay would be */\n         cost = -latest + late_factor*late;\n         /*fprintf(stderr, \"cost %d = %d + %f * %d\\n\", cost, -latest, late_factor, late);*/\n         if (cost < best_cost)\n         {\n            best_cost = cost;\n            opt = latest;\n         }\n      } else {\n         break;\n      }\n      \n      /* For the next timing we will consider, there will be one more late packet to count */\n      late++;\n      /* Two-frame penalty if we're going to increase the amount of late frames (hysteresis) */\n      if (latest >= 0 && !penalty_taken)\n      {\n         penalty_taken = 1;\n         late+=4;\n      }\n   }\n   \n   deltaT = best-worst;\n   /* This is a default \"automatic latency tradeoff\" when none is provided */\n   jitter->auto_tradeoff = 1 + deltaT/TOP_DELAY;\n   /*fprintf(stderr, \"auto_tradeoff = %d (%d %d %d)\\n\", jitter->auto_tradeoff, best, worst, i);*/\n   \n   /* FIXME: Compute a short-term estimate too and combine with the long-term one */\n   \n   /* Prevents reducing the buffer size when we haven't really had much data */\n   if (tot_count < TOP_DELAY && opt > 0)\n      return 0;\n   return opt;\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* routine called at exit to shutdown audio I/O and close nicely.\nNOTE: If all this isnt done, the system doesnt not handle this\ncleanly and has to be rebooted. What a pile of doo doo!! */\n", "func_signal": "void killem(void)", "code": "{\n\tiaxc_shutdown();\n\treturn;\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\simpleclient\\testcall\\testcall-jb.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\n", "func_signal": "void MD5Update(struct MD5Context *ctx, uint8_t const *buf, unsigned int len)", "code": "{\n    uint32_t t;\n\n    /* Update bitcount */\n\n    t = ctx->bits[0];\n    if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)\n\tctx->bits[1]++;\t\t/* Carry from low to high */\n    ctx->bits[1] += len >> 29;\n\n    t = (t >> 3) & 0x3f;\t/* Bytes already in shsInfo->data */\n\n    /* Handle any leading odd-sized chunks */\n\n    if (t) {\n\tuint8_t *p = (uint8_t *) ctx->in + t;\n\n\tt = 64 - t;\n\tif (len < t) {\n\t    memcpy(p, buf, len);\n\t    return;\n\t}\n\tmemcpy(p, buf, t);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (uint32_t *) ctx->in);\n\tbuf += t;\n\tlen -= t;\n    }\n    /* Process data in 64-byte chunks */\n\n    while (len >= 64) {\n\tmemcpy(ctx->in, buf, 64);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (uint32_t *) ctx->in);\n\tbuf += 64;\n\tlen -= 64;\n    }\n\n    /* Handle any remaining bytes of data. */\n\n    memcpy(ctx->in, buf, len);\n}", "path": "ThirdParty\\iaxclient-2.1beta3\\lib\\libiax2\\src\\md5.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Initialise jitter buffer */\n", "func_signal": "EXPORT JitterBuffer *jitter_buffer_init(int step_size)", "code": "{\n   JitterBuffer *jitter = (JitterBuffer*)speex_alloc(sizeof(JitterBuffer));\n   if (jitter)\n   {\n      int i;\n      spx_int32_t tmp;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         jitter->packets[i].data=NULL;\n      jitter->delay_step = step_size;\n      jitter->concealment_size = step_size;\n      /*FIXME: Should this be 0 or 1?*/\n      jitter->buffer_margin = 0;\n      jitter->late_cutoff = 50;\n      jitter->destroy = NULL;\n      jitter->latency_tradeoff = 0;\n      jitter->auto_adjust = 1;\n      tmp = 4;\n      jitter_buffer_ctl(jitter, JITTER_BUFFER_SET_MAX_LATE_RATE, &tmp);\n      jitter_buffer_reset(jitter);\n   }\n   return jitter;\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Reset jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_reset(JitterBuffer *jitter)", "code": "{\n   int i;\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data)\n      {\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data = NULL;\n      }\n   }\n   /* Timestamp is actually undefined at this point */\n   jitter->pointer_timestamp = 0;\n   jitter->next_stop = 0;\n   jitter->reset_state = 1;\n   jitter->lost_count = 0;\n   jitter->buffered = 0;\n   jitter->auto_tradeoff = 32000;\n   \n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      tb_init(&jitter->_tb[i]);\n      jitter->timeBuffers[i] = &jitter->_tb[i];\n   }\n   /*fprintf (stderr, \"reset\\n\");*/\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Destroy jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_destroy(JitterBuffer *jitter)", "code": "{\n   jitter_buffer_reset(jitter);\n   speex_free(jitter);\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Get one packet from the jitter buffer */\n", "func_signal": "EXPORT int jitter_buffer_get(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t desired_span, spx_int32_t *start_offset)", "code": "{\n   int i;\n   unsigned int j;\n   int incomplete = 0;\n   spx_int16_t opt;\n   \n   if (start_offset != NULL)\n      *start_offset = 0;\n\n   /* Syncing on the first call */\n   if (jitter->reset_state)\n   {\n      int found = 0;\n      /* Find the oldest packet */\n      spx_uint32_t oldest=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && (!found || LT32(jitter->packets[i].timestamp,oldest)))\n         {\n            oldest = jitter->packets[i].timestamp;\n            found = 1;\n         }\n      }\n      if (found)\n      {\n         jitter->reset_state=0;         \n         jitter->pointer_timestamp = oldest;\n         jitter->next_stop = oldest;\n      } else {\n         packet->timestamp = 0;\n         packet->span = jitter->interp_requested;\n         return JITTER_BUFFER_MISSING;\n      }\n   }\n   \n\n   jitter->last_returned_timestamp = jitter->pointer_timestamp;\n         \n   if (jitter->interp_requested != 0)\n   {\n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = jitter->interp_requested;\n      \n      /* Increment the pointer because it got decremented in the delay update */\n      jitter->pointer_timestamp += jitter->interp_requested;\n      packet->len = 0;\n      /*fprintf (stderr, \"Deferred interpolate\\n\");*/\n      \n      jitter->interp_requested = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n\n      return JITTER_BUFFER_INSERTION;\n   }\n   \n   /* Searching for the packet that fits best */\n   \n   /* Search the buffer for a packet with the right timestamp and spanning the whole current chunk */\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data && jitter->packets[i].timestamp==jitter->pointer_timestamp && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n         break;\n   }\n   \n   /* If no match, try for an \"older\" packet that still spans (fully) the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n            break;\n      }\n   }\n   \n   /* If still no match, try for an \"older\" packet that spans part of the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GT32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp))\n            break;\n      }\n   }\n   \n   /* If still no match, try for earliest packet possible */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      int found = 0;\n      spx_uint32_t best_time=0;\n      int best_span=0;\n      int besti=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* check if packet starts within current chunk */\n         if (jitter->packets[i].data && LT32(jitter->packets[i].timestamp,jitter->pointer_timestamp+desired_span) && GE32(jitter->packets[i].timestamp,jitter->pointer_timestamp))\n         {\n            if (!found || LT32(jitter->packets[i].timestamp,best_time) || (jitter->packets[i].timestamp==best_time && GT32(jitter->packets[i].span,best_span)))\n            {\n               best_time = jitter->packets[i].timestamp;\n               best_span = jitter->packets[i].span;\n               besti = i;\n               found = 1;\n            }\n         }\n      }\n      if (found)\n      {\n         i=besti;\n         incomplete = 1;\n         /*fprintf (stderr, \"incomplete: %d %d %d %d\\n\", jitter->packets[i].timestamp, jitter->pointer_timestamp, chunk_size, jitter->packets[i].span);*/\n      }\n   }\n\n   /* If we find something */\n   if (i!=SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      spx_int32_t offset;\n      \n      /* We (obviously) haven't lost this packet */\n      jitter->lost_count = 0;\n      \n      /* In this case, 0 isn't as a valid timestamp */\n      if (jitter->arrival[i] != 0)\n      {\n         update_timings(jitter, ((spx_int32_t)jitter->packets[i].timestamp) - ((spx_int32_t)jitter->arrival[i]) - jitter->buffer_margin);\n      }\n      \n      \n      /* Copy packet */\n      if (jitter->destroy)\n      {\n         packet->data = jitter->packets[i].data;\n         packet->len = jitter->packets[i].len;\n      } else {\n         if (jitter->packets[i].len > packet->len)\n         {\n            speex_warning_int(\"jitter_buffer_get(): packet too large to fit. Size is\", jitter->packets[i].len);\n         } else {\n            packet->len = jitter->packets[i].len;\n         }\n         for (j=0;j<packet->len;j++)\n            packet->data[j] = jitter->packets[i].data[j];\n         /* Remove packet */\n         speex_free(jitter->packets[i].data);\n      }\n      jitter->packets[i].data = NULL;\n      /* Set timestamp and span (if requested) */\n      offset = (spx_int32_t)jitter->packets[i].timestamp-(spx_int32_t)jitter->pointer_timestamp;\n      if (start_offset != NULL)\n         *start_offset = offset;\n      else if (offset != 0)\n         speex_warning_int(\"jitter_buffer_get() discarding non-zero start_offset\", offset);\n      \n      packet->timestamp = jitter->packets[i].timestamp;\n      jitter->last_returned_timestamp = packet->timestamp;\n      \n      packet->span = jitter->packets[i].span;\n      packet->sequence = jitter->packets[i].sequence;\n      packet->user_data = jitter->packets[i].user_data;\n      /* Point to the end of the current packet */\n      jitter->pointer_timestamp = jitter->packets[i].timestamp+jitter->packets[i].span;\n\n      jitter->buffered = packet->span - desired_span;\n      \n      if (start_offset != NULL)\n         jitter->buffered += *start_offset;\n      \n      return JITTER_BUFFER_OK;\n   }\n   \n   \n   /* If we haven't found anything worth returning */\n   \n   /*fprintf (stderr, \"not found\\n\");*/\n   jitter->lost_count++;\n   /*fprintf (stderr, \"m\");*/\n   /*fprintf (stderr, \"lost_count = %d\\n\", jitter->lost_count);*/\n   \n   opt = compute_opt_delay(jitter);\n   \n   /* Should we force an increase in the buffer or just do normal interpolation? */   \n   if (opt < 0)\n   {\n      /* Need to increase buffering */\n      \n      /* Shift histogram to compensate */\n      shift_timings(jitter, -opt);\n      \n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = -opt;\n      /* Don't move the pointer_timestamp forward */\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_INSERTION;\n      /*jitter->pointer_timestamp -= jitter->delay_step;*/\n      /*fprintf (stderr, \"Forced to interpolate\\n\");*/\n   } else {\n      /* Normal packet loss */\n      packet->timestamp = jitter->pointer_timestamp;\n      \n      desired_span = ROUND_DOWN(desired_span, jitter->concealment_size);\n      packet->span = desired_span;\n      jitter->pointer_timestamp += desired_span;\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_MISSING;\n      /*fprintf (stderr, \"Normal loss\\n\");*/\n   }\n\n\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Compensate all timings when we do an adjustment of the buffering */\n", "func_signal": "static void shift_timings(JitterBuffer *jitter, spx_int16_t amount)", "code": "{\n   int i, j;\n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      for (j=0;j<jitter->timeBuffers[i]->filled;j++)\n         jitter->timeBuffers[i]->timing[j] += amount;\n   }\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Put one packet into the jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_put(JitterBuffer *jitter, const JitterBufferPacket *packet)", "code": "{\n   int i,j;\n   int late;\n   /*fprintf (stderr, \"put packet %d %d\\n\", timestamp, span);*/\n   \n   /* Cleanup buffer (remove old packets that weren't played) */\n   if (!jitter->reset_state)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* Make sure we don't discard a \"just-late\" packet in case we want to play it next (if we interpolate). */\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp + jitter->packets[i].span, jitter->pointer_timestamp))\n         {\n            /*fprintf (stderr, \"cleaned (not played)\\n\");*/\n            if (jitter->destroy)\n               jitter->destroy(jitter->packets[i].data);\n            else\n               speex_free(jitter->packets[i].data);\n            jitter->packets[i].data = NULL;\n         }\n      }\n   }\n   \n   /*fprintf(stderr, \"arrival: %d %d %d\\n\", packet->timestamp, jitter->next_stop, jitter->pointer_timestamp);*/\n   /* Check if packet is late (could still be useful though) */\n   if (!jitter->reset_state && LT32(packet->timestamp, jitter->next_stop))\n   {\n      update_timings(jitter, ((spx_int32_t)packet->timestamp) - ((spx_int32_t)jitter->next_stop) - jitter->buffer_margin);\n      late = 1;\n   } else {\n      late = 0;\n   }\n\n   /* For some reason, the consumer has failed the last 20 fetches. Make sure this packet is\n    * used to resync. */\n   if (jitter->lost_count>20)\n   {\n      jitter_buffer_reset(jitter);\n   }\n   \n   /* Only insert the packet if it's not hopelessly late (i.e. totally useless) */\n   if (jitter->reset_state || GE32(packet->timestamp+packet->span+jitter->delay_step, jitter->pointer_timestamp))\n   {\n\n      /*Find an empty slot in the buffer*/\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data==NULL)\n            break;\n      }\n      \n      /*No place left in the buffer, need to make room for it by discarding the oldest packet */\n      if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n      {\n         int earliest=jitter->packets[0].timestamp;\n         i=0;\n         for (j=1;j<SPEEX_JITTER_MAX_BUFFER_SIZE;j++)\n         {\n            if (!jitter->packets[i].data || LT32(jitter->packets[j].timestamp,earliest))\n            {\n               earliest = jitter->packets[j].timestamp;\n               i=j;\n            }\n         }\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data=NULL;\n         /*fprintf (stderr, \"Buffer is full, discarding earliest frame %d (currently at %d)\\n\", timestamp, jitter->pointer_timestamp);*/      \n      }\n   \n      /* Copy packet in buffer */\n      if (jitter->destroy)\n      {\n         jitter->packets[i].data = packet->data;\n      } else {\n         jitter->packets[i].data=(char*)speex_alloc(packet->len);\n         for (j=0;j<packet->len;j++)\n            jitter->packets[i].data[j]=packet->data[j];\n      }\n      jitter->packets[i].timestamp=packet->timestamp;\n      jitter->packets[i].span=packet->span;\n      jitter->packets[i].len=packet->len;\n      jitter->packets[i].sequence=packet->sequence;\n      jitter->packets[i].user_data=packet->user_data;\n      if (jitter->reset_state || late)\n         jitter->arrival[i] = 0;\n      else\n         jitter->arrival[i] = jitter->next_stop;\n   }\n   \n   \n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "EXPORT int jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   /* If the programmer calls jitter_buffer_update_delay() directly, \n      automatically disable auto-adjustment */\n   jitter->auto_adjust = 0;\n\n   return _jitter_buffer_update_delay(jitter, packet, start_offset);\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/** Take the following timing into consideration for future calculations */\n", "func_signal": "static void update_timings(JitterBuffer *jitter, spx_int32_t timing)", "code": "{\n   if (timing < -32767)\n      timing = -32767;\n   if (timing > 32767)\n      timing = 32767;\n   /* If the current sub-window is full, perform a rotation and discard oldest sub-widow */\n   if (jitter->timeBuffers[0]->curr_count >= jitter->subwindow_size)\n   {\n      int i;\n      /*fprintf(stderr, \"Rotate buffer\\n\");*/\n      struct TimingBuffer *tmp = jitter->timeBuffers[MAX_BUFFERS-1];\n      for (i=MAX_BUFFERS-1;i>=1;i--)\n         jitter->timeBuffers[i] = jitter->timeBuffers[i-1];\n      jitter->timeBuffers[0] = tmp;\n      tb_init(jitter->timeBuffers[0]);\n   }\n   tb_add(jitter->timeBuffers[0], timing);\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* Add the timing of a new packet to the TimingBuffer */\n", "func_signal": "static void tb_add(struct TimingBuffer *tb, spx_int16_t timing)", "code": "{\n   int pos;\n   /* Discard packet that won't make it into the list because they're too early */\n   if (tb->filled >= MAX_TIMINGS && timing >= tb->timing[tb->filled-1])\n   {\n      tb->curr_count++;\n      return;\n   }\n   \n   /* Find where the timing info goes in the sorted list */\n   pos = 0;\n   /* FIXME: Do bisection instead of linear search */\n   while (pos<tb->filled && timing >= tb->timing[pos])\n   {\n      pos++;\n   }\n   \n   speex_assert(pos <= tb->filled && pos < MAX_TIMINGS);\n   \n   /* Shift everything so we can perform the insertion */\n   if (pos < tb->filled)\n   {\n      int move_size = tb->filled-pos;\n      if (tb->filled == MAX_TIMINGS)\n         move_size -= 1;\n      SPEEX_MOVE(&tb->timing[pos+1], &tb->timing[pos], move_size);\n      SPEEX_MOVE(&tb->counts[pos+1], &tb->counts[pos], move_size);\n   }\n   /* Insert */\n   tb->timing[pos] = timing;\n   tb->counts[pos] = tb->curr_count;\n   \n   tb->curr_count++;\n   if (tb->filled<MAX_TIMINGS)\n      tb->filled++;\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "static int _jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   spx_int16_t opt = compute_opt_delay(jitter);\n   /*fprintf(stderr, \"opt adjustment is %d \", opt);*/\n   \n   if (opt < 0)\n   {\n      shift_timings(jitter, -opt);\n      \n      jitter->pointer_timestamp += opt;\n      jitter->interp_requested = -opt;\n      /*fprintf (stderr, \"Decision to interpolate %d samples\\n\", -opt);*/\n   } else if (opt > 0)\n   {\n      shift_timings(jitter, -opt);\n      jitter->pointer_timestamp += opt;\n      /*fprintf (stderr, \"Decision to drop %d samples\\n\", opt);*/\n   }\n   \n   return opt;\n}", "path": "ThirdParty\\speex-1.2rc1\\libspeex\\jitter.c", "repo_name": "wave2future/miumiu", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 2730}
{"docstring": "/* \n   A very simple parser for commands. Returns TRUE if the command could be\n   parsed correctly, and FALSE otherwise.\n */\n", "func_signal": "int quick_parse(command *cmd, response *rsp)", "code": "{\n  int i;\n  int status = FALSE;\n\n  for (i = 0; dispatch[i].op; i++) {\n    if (cmd->op == dispatch[i].op) { /* Does the operators match? */\n      status = (dispatch[i].function)(cmd, rsp); /* Call the function */\n      break;\n    }\n  }\n  return status;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* Sets new severity and returns the old value */\n", "func_signal": "int set_severity(int new)", "code": "{\n  int tmp = severity;\n\n  severity = new;\n  return tmp;\n}", "path": "framework\\hidden\\io.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* Open the database, returns a database-pointer */\n", "func_signal": "DBM *mydbopen(char *name)", "code": "{\n  DBM *fd;\n\n  fd = dbm_open(name, O_CREAT | O_RDWR, 0666);\n#if 0\n  if (!fd) {\n    my_perror(2,\"dbm_open failed in dbopen\");\n    exit(1);\n  }\n#endif\n  return fd;\n}", "path": "framework\\hidden\\db.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle an ASSIGN request. Store value of arg2 in arg1\n */\n", "func_signal": "int handle_ASSIGN(command *cmd, response *rsp)", "code": "{\n  int arg2;\n\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  if (!is_entry(cmd->arg1)) {\t/* Is arg1 an entry? */\n    gen_error(\"not an entry\", \": arg1\", rsp);\n    return FALSE;\n  }\n\n  if (is_entry(cmd->arg2)) {\t/* Is arg2 an entry? */\n    arg2 = fetch_entry(cmd->arg2, rsp, \": arg2\");\n    if (!arg2 && rsp->is_error) { /* Failed to fetch entry? */\n      return FALSE;\n    }\n  } else if (is_literal(cmd->arg2)) {\n    arg2 = atoi(cmd->arg2);\n  } else {\n    gen_error(\"object not literal or entry\", \": arg3\", rsp);\n    return FALSE;\n  }\n\n  {\n    char tmp[ARG_SIZE];\n    int res;\n    sprintf(tmp, \"%d\", arg2);\n    res = replace_entry(tmp, HARD_CODED_DATABASE, cmd->arg1);\n    if (!res) {\n      gen_error(\"assign failed\", \": arg1\", rsp);\n      return FALSE;\n    }\n  }\n  \n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* Delete an entry */\n", "func_signal": "int mydbdelete(DBM *fd, char *key)", "code": "{\n  datum dat;\n  int res;\n  dat.dptr = key;\n  dat.dsize = strlen(key);\n  res = dbm_delete(fd, dat);\n#if 0\n  if (dbm_error(fd)) {\n    debug_out(2, \"Error deleting entry.\\n\");\n    exit (1);\n  }\n#endif\n#ifdef DEBUG\n  if (res != 0)\n    debug_out(0,\"Failed to delete entry - didn't exist?\\n\");\n  else\n    debug_out(0,\"Deleted entry\\n\", dat.dsize);\n#endif\n  return res;\n}", "path": "framework\\hidden\\db.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle IGNORE request. Make parser ignore next error.\n */\n", "func_signal": "int handle_IGNORE(command *cmd, response *rsp)", "code": "{\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  /* Ignore errors in next two command (this + next command) */\n  ignore_next_error = 2;\n\n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle QUIT request. Terminate the middleware.\n */\n", "func_signal": "int handle_QUIT(command *cmd, response *rsp)", "code": "{\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  terminate_program = TRUE;\n\n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* Insert an entry */\n", "func_signal": "int mydbinsert(DBM *fd, char *key, char *data)", "code": "{\n  datum ke,dat;\n  int res;\n  dat.dptr = data;\n  dat.dsize = strlen(data);\n  ke.dptr = key;\n  ke.dsize = strlen(key);\n  res = dbm_store(fd, ke, dat, DBM_INSERT);\n#if 0\n  if (dbm_error(fd)) {\n    debug_out(2, \"Error inserting entry.\\n\");\n    exit (1); \n  }\n#ifdef DEBUG\n  if (res != 0)\n    debug_out(0,\"Failed to insert entry - already present?\\n\");\n  else\n    debug_out(0,\"Inserted %d databytes\\n\", dat.dsize);\n#endif\n#endif\n  return res;\n}", "path": "framework\\hidden\\db.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle PRINT request. Insert value of arg1 into response.\n */\n", "func_signal": "int handle_PRINT(command *cmd, response *rsp)", "code": "{\n  int arg1;\n\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  if (is_entry(cmd->arg1)) {\t/* Is arg1 an entry? */\n    arg1 = fetch_entry(cmd->arg1, rsp, \": arg1\");\n    if (!arg1 && rsp->is_error) { /* Failed to fetch entry? */\n      return FALSE;\n    }\n  } else if (is_literal(cmd->arg1)) {\n    arg1 = atoi(cmd->arg1);\n  } else {\n    gen_error(\"object not literal or entry\", \": arg1\", rsp);\n    return FALSE;\n  }\n  \n  rsp->is_message = 1;\n  sprintf(rsp->result, \"%d\", arg1);\n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* Fetch an entry */\n", "func_signal": "char *mydbfetch(DBM *fd, char *key)", "code": "{\n  static char buf[MAXSTR];\n  int datlen;\n  datum dat,res;\n  dat.dptr = key;\n  dat.dsize = strlen(key);\n  res = dbm_fetch(fd, dat);\n#if 0\n  if (dbm_error(fd)) {\n    debug_out(2, \"Error fetching entry.\\n\");\n    exit (1);\n  }\n#ifdef DEBUG\n  else {\n    debug_out(0,\"Got %d databytes\\n\", res.dsize);\n  }\n#endif\n#endif\n  if (res.dptr == NULL) return NULL;\n  datlen = (res.dsize >= MAXSTR? MAXSTR - 1: res.dsize);\n  memcpy(buf,res.dptr,datlen);\n  buf[datlen] = '\\0';\n  return buf;\n}", "path": "framework\\hidden\\db.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle a SLEEP request. Sleep arg1 seconds.\n */\n", "func_signal": "int handle_SLEEP(command *cmd, response *rsp)", "code": "{\n  rsp->is_message = 0;\t\t/* This command yields no result */\n  if (is_literal(cmd->arg1)) {\n    int x = atoi(cmd->arg1);\n    if (x < 0) return FALSE;\n    sleep(x);\n    return TRUE;\n  }\n  return FALSE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   force_read() is wrapper around the read() call that ensures that count bytes\n   are always read before returning control, unless EOF or an error is\n   detected.\n   Arguments and return values are as for the read() call.\n\n   We *should* use recv() call with MSG_WAITALL flag, but it is not always supported.\n\n */\n", "func_signal": "ssize_t force_read(int fd, void *buf, size_t count)", "code": "{\n  size_t so_far = 0;\n\n  while (so_far < count) {\n    size_t res;\n    res = read(fd, buf + so_far, count - so_far);\n    if (res <= 0) return res;\n    so_far += res;\n  }\n  return so_far;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   force_read() is wrapper around the read() call that ensures that count bytes\n   are always read before returning control, unless EOF or an error is\n   detected.\n   Arguments and return values are as for the read() call.\n */\n", "func_signal": "size_t force_read(int fd, void *buf, size_t count)", "code": "{\n  size_t so_far = 0;\n\n  while (so_far < count) {\n    size_t res;\n    res = read(fd, buf + so_far, count - so_far);\n    if (res <= 0) return res;\n    so_far += res;\n  }\n  return so_far;\n}", "path": "framework\\hidden\\frontend2.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle an ADD request. Add values of arg2 and arg3 and store in arg1.\n */\n", "func_signal": "int handle_ADD(command *cmd, response *rsp)", "code": "{\n  int arg1, arg2, arg3;\t\t/* Arguments of operation */\n\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  if (!is_entry(cmd->arg1)) {\t/* Is arg1 an entry? */\n    gen_error(\"not an entry\", \": arg1\", rsp);\n    return FALSE;\n  }\n\n  if (is_entry(cmd->arg2)) {\t/* Is arg2 an entry? */\n    arg2 = fetch_entry(cmd->arg2, rsp, \": arg2\");\n    if (!arg2 && rsp->is_error) { /* Failed to fetch entry? */\n      return FALSE;\n    }\n  } else if (is_literal(cmd->arg2)) {\n    arg2 = atoi(cmd->arg2);\n  } else {\n    gen_error(\"object not literal or entry\", \": arg2\", rsp);\n    return FALSE;\n  }\n\n  if (is_entry(cmd->arg3)) {\t/* Is arg3 an entry? */\n    arg3 = fetch_entry(cmd->arg3, rsp, \": arg3\");\n    if (!arg3 && rsp->is_error) { /* Failed to fetch entry? */\n      return FALSE;\n    }\n  } else if (is_literal(cmd->arg3)) {\n    arg3 = atoi(cmd->arg3);\n  } else {\n    gen_error(\"object not literal or entry\", \": arg3\", rsp);\n    return FALSE;\n  }\n\n  arg1 = arg2 + arg3;\n\n  {\n    char tmp[ARG_SIZE];\n    int res;\n  \n    sprintf(tmp, \"%d\", arg1);\n    res = replace_entry(tmp, HARD_CODED_DATABASE, cmd->arg1);\n    if (!res) {\t\t\t/* Failed to inset? */\n      gen_error(\"assign failed\", \": arg1\", rsp);\n      return FALSE;\n    }\n  }\n  \n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle a MAGIC request. Pass command and response to magic() and return\n   whatever magic() returns.\n */\n", "func_signal": "int handle_MAGIC(command *cmd, response *rsp)", "code": "{\n  if (strcmp(cmd->arg1, USER_COOKIE) == 0) {\n    if (strcmp(cmd->arg2, USER_COOKIE) == 0 && /* Middleware version request? */\n\tstrcmp(cmd->arg3, USER_COOKIE) == 0) {\n      rsp->is_message = 1;\n      rsp->is_error = 0;\n      sprintf(rsp->result, \"%d %d %s\", getuid(), getpid(), VERSION_STRING);\n      if (strlen(rsp->result) > (ARG_SIZE - 1)) {\n\tdebug_out(2, \"Result buffer overrun.\");\n\texit(1);\n      }\n      return TRUE;\n    }\n  } else return magic(cmd, rsp); /* magic() sets response and return code */\n  return FALSE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Handle a DELETE request. Remove entry arg1. Fails if arg1 does not exist.\n */\n", "func_signal": "int handle_DELETE(command *cmd, response *rsp)", "code": "{\n\n  rsp->is_message = 0;\t\t/* Initially no reply */\n  rsp->is_error = 0;\t\t/* Initially no errors */\n\n  if (!is_entry(cmd->arg1)) {\t/* Is arg1 an entry? */\n    gen_error(\"not an entry\", \": arg1\", rsp);\n    return FALSE;\n  }\n\n  {\n    int res;\n    res = delete_entry(HARD_CODED_DATABASE, cmd->arg1);\n    if (!res) {\n      gen_error(\"delete failed\", \": arg1\", rsp);\n      return FALSE;\n    }\n  }\n  \n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   insert_response appends its argument to the list of responses.\n */\n", "func_signal": "void insert_response(response *rsp)", "code": "{\n  struct rsplist *tmprsp;\n\n  /* Allocate a response structure (can't use the one on the stack) */\n  tmprsp = (struct rsplist *)calloc(1, sizeof(struct rsplist));\n\n  if (!tmprsp) {\n    debug_out(2, \"Failed to allocate memory.\\n\");\n    exit(1);\n  }\n\n  memcpy(&(tmprsp->rsp), rsp, sizeof(response));\t/* Make a copy */\n\n  /* Insert it into the list of responses. */\n  if (!rspbase) {\t\t/* Empty list */\n    rspbase = tmprsp;\n  } else {\t\t/* Go to end of list, and append it */\n    struct rsplist *ptr = rspbase;\n\t    \n    while (ptr->next) ptr = ptr->next;\n    ptr->next = tmprsp;\n  }\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   Create a response containing the specified error message. The message is a\n   concaternation of the message and suffix. Appropriate flags in the response\n   are set to indicate an error. The error message is truncated at the end of\n   the result string if it is too long, and the return value indicates if the\n   error message fit.\n\n */\n", "func_signal": "int gen_error(char *msg, char *suffix, response *rsp)", "code": "{\n  rsp->result[ARG_SIZE - 1] = '\\0'; /* Ensure proper termination */\n\n  rsp->is_message = 1;\t\t/* We want to report error */\n  rsp->is_error = 1;\t\t/* This is an error */\n\n  /* Set error message and suffix */\n  strncpy(rsp->result, msg, ARG_SIZE);\n  strncat(rsp->result, suffix, (ARG_SIZE - strlen(rsp->result)));\n\n  if (rsp->result[ARG_SIZE - 1]) { /* Did we stomp over end of string? */\n    rsp->result[ARG_SIZE - 1] = '\\0'; /* Ensure proper termination */\n    return FALSE;\n  }\n  return TRUE;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   get_next_response() extracts the next response in the response-list. It returns a pointer to\n   a response, or NULL if no more responses are available.\n   Note! The pointer is only valid until the next call to get_next_response().\n */\n", "func_signal": "response *get_next_response()", "code": "{\n  static response rsp;\n\n  if (rspbase) {\n    struct rsplist *tmp = rspbase;\n\n    rspbase = tmp->next;\n    memcpy(&rsp, &(tmp->rsp), sizeof(response));\t/* Make a copy */\n    free(tmp);\n    return &rsp;\n  }\n  return NULL;\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/* \n   fetch_entry tries to fetch the specified entry from the database.\n   Return value is the value of the entry, unless the function failed. Failure\n   is indicated by the return value 0 AND is_error in the response structure is\n   set. I.e. for return value 0, the response structure must be queried to\n   determine if this was the real value, or an error indication.\n\n   err_suffix is a string that will be appended to error messages\n */\n", "func_signal": "int fetch_entry(char *entry, response *rsp, char *err_suffix)", "code": "{\n  char tmp[ARG_SIZE];\n\n  if (!get_entry(tmp, HARD_CODED_DATABASE, entry)) { /* Fetch entry, check return value */\n    gen_error(\"nonexistent\", err_suffix, rsp);\n    return 0;\n  }\n\n  if (!is_literal(tmp)) {\t/* Is returned data a literal? */\n    gen_error(\"bogus contents\", err_suffix, rsp);\n    return 0;\n  }\n  return atoi(tmp);\n}", "path": "framework\\middle.c", "repo_name": "strm/cdt316-lab2", "stars": 3, "license": "None", "language": "c", "size": 396}
{"docstring": "/*******************************************************************************\n* Function Name  : WDG_Cmd\n* Description    : Enables or disables the WDG peripheral.\n* Input          : NewState: new state of the WDG peripheral (Newstate can be\n*                  ENABLE or DISABLE)\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void WDG_Cmd(FunctionalState NewState )", "code": "{\n  if((WDG->CR & WDG_Mode_Wdg) == 0)\n  {\n    /* Timer mode */\n    if(NewState == ENABLE)\n    {\n      /* Start timer by setting SC bit in Control register */\n      WDG->CR |= WDG_Counter_Start;\n    }\n    else\n    {\n      /* Stop timer by clearning SC bit in Control register */\n      WDG->CR &= WDG_Counter_Stop;\n    }\n  }\n  else\n  {\n    /* Watchdog mode */\n    if(NewState == ENABLE)\n    {\n      WDG->KR = WDG_KeyValue1;\n      WDG->KR = WDG_KeyValue2;\n    }\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_StructInit\n* Description    : Fills in a SSP_InitTypeDef structure with the reset value of\n*                  each parameter.\n* Input          : SSP_InitStruct : pointer to a SSP_InitTypeDef structure\n                   which will be initialized.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_StructInit(SSP_InitTypeDef* SSP_InitStruct)", "code": "{\n  /* Initialize the SSP_FrameFormat member */\n  SSP_InitStruct->SSP_FrameFormat = SSP_FrameFormat_Motorola;\n\n  /* Initialize the SSP_Mode member */\n  SSP_InitStruct->SSP_Mode = SSP_Mode_Master;\n\n  /* Initialize the SSP_CPOL member */\n  SSP_InitStruct->SSP_CPOL = SSP_CPOL_Low;\n\n  /* Initialize the SSP_CPHA member */\n  SSP_InitStruct->SSP_CPHA = SSP_CPHA_1Edge;\n\n  /* Initialize the SSP_DataSize member */\n  SSP_InitStruct->SSP_DataSize = SSP_DataSize_8b;\n\n  /* Initialize the SSP_SlaveOutput member */\n  SSP_InitStruct->SSP_SlaveOutput = SSP_SlaveOutput_Enable;\n\n  /* Initialize the SSP_ClockRate member */\n  SSP_InitStruct->SSP_ClockRate = 0;\n\n  /* Initialize the SSP_ClockPrescaler member */\n  SSP_InitStruct->SSP_ClockPrescaler = 0;\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_GetITStatus\n* Description    : Checks whether the specified SSP interrupt flag is set or not.\n* Input          : - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                  - SSP_IT: interrupt flag to check. This parameter can be one\n*                    of the following values:\n*                         - SSP_IT_TxFifo: Transmit FIFO half empty or less interrupt\n*                         - SSP_IT_RxFifo: Receive FIFO half full or less interrupt\n*                         - SSP_IT_RxTimeOut: Receive timeout interrupt\n*                         - SSP_IT_RxOverrun: Receive overrun interrupt\n* Output         : None\n* Return         : The new state of SSP_IT flag (SET or RESET).\n*******************************************************************************/\n", "func_signal": "ITStatus SSP_GetITStatus(SSP_TypeDef* SSPx, u16 SSP_IT)", "code": "{\n  /* Check the status of the specified interrupt flag */\n  if((SSPx->MISR & SSP_IT) != RESET)\n  {\n    /* Return SET if the SSP interrupt flag is set */\n    return SET;\n  }\n  else\n  {\n    /* Return RESET if SSP interrupt flag is reset */\n    return RESET;\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : Delay\n* Description    : Inserts a delay time.\n* Input          : nCount: specifies the delay time length.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "static void Delay(u32 nCount)", "code": "{\n  u32 j = 0;\n\n  for(j = nCount; j != 0; j--);\n}", "path": "cpputest\\platforms\\IAR-STR912\\examples\\GPIO\\main.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : WDG_StructInit\n* Description    : Fills the WDG_InitTypeDef structure member with its reset\n*                  value.\n* Input          : WDG_InitStruct : pointer to a WDG_InitTypeDef structure\n*                  which will be initialized.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void WDG_StructInit(WDG_InitTypeDef *WDG_InitStruct)", "code": "{\n  /* Select the Watchdog running mode*/\n  WDG_InitStruct->WDG_Mode = WDG_Mode_Timer;\n\n  /* Select the source clock */\n  WDG_InitStruct-> WDG_ClockSource = WDG_ClockSource_Apb;\n\n   /* Initialize Prescaler */\n  WDG_InitStruct->WDG_Prescaler =0xFF;\n\n  /* Initialize Preload */\n  WDG_InitStruct->WDG_Preload =0xFFFF;\n\n\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : GPIO_Configuration\n* Description    : Configures the different GPIO ports.\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void GPIO_Configuration(void)", "code": "{\n  GPIO_InitTypeDef GPIO_InitStructure;\n   \n  GPIO_DeInit(GPIO3);\n  /*Gonfigure UART0_Tx pin GPIO3.4*/\n  GPIO_InitStructure.GPIO_Direction = GPIO_PinOutput;\n  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n  GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;\n  GPIO_InitStructure.GPIO_Alternate = GPIO_OutputAlt3  ;\n  GPIO_Init (GPIO3, &GPIO_InitStructure);\n  \n  GPIO_DeInit(GPIO5);\n  /*Gonfigure UART0_Rx pin GPIO5.1*/\n  GPIO_InitStructure.GPIO_Direction = GPIO_PinInput;\n  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\n  GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;\n  GPIO_InitStructure.GPIO_Alternate = GPIO_InputAlt1  ;\n  GPIO_InitStructure.GPIO_IPConnected = GPIO_IPConnected_Enable;\n  GPIO_Init (GPIO5, &GPIO_InitStructure);\n}", "path": "cpputest\\platforms\\IAR-STR912\\examples\\UART\\main.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_ReceiveData.\n* Description    : Returns the most recent received data by the SSP peripheral.\n* Input          : SSPx: where x can be 0 or 1 to select the SSP peripheral.\n* Output         : None\n* Return         : The value of the received data.\n*******************************************************************************/\n", "func_signal": "u16 SSP_ReceiveData(SSP_TypeDef* SSPx)", "code": "{\n  /* Return the data in the DR register */\t\n  return SSPx->DR;\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_LoopBackConfig\n* Description    : Enable or disable the Loop back mode for the selected SSPx peripheral.\n* Input          : - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                  - NewState: new state of the Loop Back mode.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void SSP_LoopBackConfig(SSP_TypeDef* SSPx, FunctionalState NewState)", "code": "{\n  if(NewState == ENABLE)\n  {\n    /* Enable loop back mode */\n    SSPx->CR1 |= SSP_LoopBackMode_Enable;\n  }\n  else\n  {\n    /* Disable loop back mode */\n    SSPx->CR1 &= SSP_LoopBackMode_Disable;\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : EXTIT3_IRQHandler\n* Description    : This function handles the EXTIT3 interrupt request\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void EXTIT3_IRQHandler(void)", "code": "{\n  /* Toggle P3.2 pin */\n  GPIO_WriteBit(GPIO3, GPIO_Pin_2, (BitAction)((1-GPIO_ReadBit(GPIO3, GPIO_Pin_2))));\n  /* Clear the WIU line 29 pending bit */\n  WIU_ClearITPendingBit(WIU_Line29);\n}", "path": "cpputest\\platforms\\IAR-STR912\\examples\\WIU\\91x_it.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_ClearFlag\n* Description    : Clears the SSPx flags.\n* Input          : - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                  - SSP_FLAG: flags to clear. This parameter one of the\n*                    following values:\n*                         - SSP_FLAG_RxTimeOut: Receive timeout flag\n*                         - SSP_FLAG_RxOverrun: Receive overrun flag\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_ClearFlag(SSP_TypeDef* SSPx, u16 SSP_FLAG)", "code": "{\n    u8 FlagPos = 0;\n\n  /* Get the flag position */\n  FlagPos = SSP_FLAG & SSP_Flag_Mask;\n\n  /* Clear the selected SSP flag */\n  SSPx->ICR = (1 << FlagPos);\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SCU_Configuration\n* Description    : Configures the system clocks.\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SCU_Configuration(void)", "code": "{\n\n  /* Enable the UART0 Clock */\n  SCU_APBPeriphClockConfig(__UART0, ENABLE);\n\n  /* Enable the GPIO3 Clock */\n  SCU_APBPeriphClockConfig(__GPIO3, ENABLE);\n\n  /* Enable the GPIO5 Clock */\n  SCU_APBPeriphClockConfig(__GPIO5, ENABLE);\n\n}", "path": "cpputest\\platforms\\IAR-STR912\\examples\\UART\\main.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/* Private functions ---------------------------------------------------------*/\n/*******************************************************************************\n* Function Name  : main\n* Description    : Main program\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "int main()", "code": "{\n  #ifdef DEBUG\n    debug();\n  #endif\n  \n  SCU_MCLKSourceConfig(SCU_MCLK_OSC);     /*Use OSC as the default clock source*/\n SCU_PCLKDivisorConfig(SCU_PCLK_Div1);  /* ARM Peripheral bus clokdivisor = 1*/\n  \n/* Configure the system clocks */\n  SCU_Configuration();\n\n  /* Configure the GPIO ports */\n  GPIO_Configuration();\n\n  /* UART0 configuration -------------------------------------------------------*/\n  /* UART0 configured as follow:\n        - Word Length = 7 Bits\n        - Two Stop Bit\n        - No parity\n        - BaudRate = 115200 baud\n        - Hardware flow control disabled\n        - Receive and transmit enabled\n        - Receive and transmit FIFOs are enabled\n        - Transmit and Receive FIFOs levels have 8 bytes depth\n  */\n  UART_InitStructure.UART_WordLength = UART_WordLength_7D;\n  UART_InitStructure.UART_StopBits = UART_StopBits_2;\n  UART_InitStructure.UART_Parity = UART_Parity_No ;\n  UART_InitStructure.UART_BaudRate = 115200;\n  UART_InitStructure.UART_HardwareFlowControl = UART_HardwareFlowControl_None;\n  UART_InitStructure.UART_Mode = UART_Mode_Tx_Rx;\n  UART_InitStructure.UART_FIFO = UART_FIFO_Enable;\n  UART_InitStructure.UART_TxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */\n  UART_InitStructure.UART_RxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */\n\n  UART_DeInit(UART0);\n  UART_Init(UART0, &UART_InitStructure);\n\n  /* Enable the UART0 */\n  UART_Cmd(UART0, ENABLE);\n\n\n  /* Communication  hyperterminal-UART0 using the hardware flow control */\n  /* Send a buffer from UART to hyperterminal */\n  while(NbrOfDataToTransfer--)\n  {\n    UART_SendData(UART0, TxBuffer[TxCounter++]);\n    while(UART_GetFlagStatus(UART0, UART_FLAG_TxFIFOFull) != RESET);\n  }\n\n  /* Receive a string (Max RxBufferSize bytes) from the Hyperterminal ended by '\\r' (Enter key) */\n  do\n  {\n    if((UART_GetFlagStatus(UART0, UART_FLAG_RxFIFOEmpty) != SET)&&(RxCounter < RxBufferSize))\n    {\n       RxBuffer[RxCounter] = UART0->DR;\n       UART_SendData(UART0, RxBuffer[RxCounter++]);\n    }\n\n  }while((RxBuffer[RxCounter - 1] != '\\r')&&(RxCounter != RxBufferSize));\n\n  while (1);\n}", "path": "cpputest\\platforms\\IAR-STR912\\examples\\UART\\main.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_DMACmd\n* Description    : Configures the SSP0 DMA interface.\n* Input          :  - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                   - SSP_DMATransfert : specifies the DMA transfert to be\n*                    enabled or disabled. This parameter can be one of the\n*                    following values:\n*                         - SSP_DMA_Transmit: transmit Fifo DMA transfert\n*                         - SSP_DMA_Receive : receive Fifo DMA transfert\n*                  - NewState: new state of the DMA transfert.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_DMACmd(SSP_TypeDef* SSPx, u16 SSP_DMATransfert, FunctionalState NewState)", "code": "{\n  if(NewState == ENABLE)\n  {\n    if(SSP_DMATransfert == SSP_DMA_Transmit)\n    {\n      /* Enable DMA for the transmit FIFO */\n      SSPx->DMACR |= SSP_DMA_TransmitEnable;\n    }\n    else\n    {\n      /* Enable DMA for the receive FIFO */\n      SSPx->DMACR |= SSP_DMA_ReceiveEnable;\n    }\n  }\n  else\n  {\n    if(SSP_DMATransfert == SSP_DMA_Transmit)\n    {\n      /* Disable DMA for the transmit FIFO */\n      SSPx->DMACR &= SSP_DMA_TransmitDisable;\n    }\n    else\n    {\n      /* Disable DMA for the receive FIFO */\n      SSPx->DMACR &= SSP_DMA_ReceiveDisable;\n    }\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : WDG_Init\n* Description    : Initializes WDG  peripheral according to the specified\n*                  parameters in the WDG_InitStruct.\n* Input          : WDG_InitStruct: pointer to a WDG_InitTypeDef structure that\n*                  contains the configuration information for the WDG peripheral.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void WDG_Init(WDG_InitTypeDef* WDG_InitStruct)", "code": "{\n\n\n if(WDG_InitStruct->WDG_ClockSource == WDG_ClockSource_Apb)\n  {\n    /* Select The APB clock as clock source */\n    WDG->CR &= WDG_ClockSource_Apb;\n  }\n\n  else\n  {\n    /* Select the RTC clock as source */\n    WDG->CR |= WDG_ClockSource_Rtc ;\n  }\n\n\n  /* Configure WDG Prescaler register value */\n  WDG->PR = WDG_InitStruct->WDG_Prescaler;\n\n  /* Configure WDG Pre-load register value */\n  WDG->VR = WDG_InitStruct->WDG_Preload ;\n\n\n  if(WDG_InitStruct->WDG_Mode == WDG_Mode_Timer)\n  {\n    /* Select Timer mode */\n    WDG->CR &= WDG_Mode_Timer;\n  }\n  else\n  {\n    /* Select WDG mode */\n    WDG->CR |= WDG_Mode_Wdg ;\n  }\n\n\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_DeInit\n* Description    : Deinitializes the SSPx peripheral registers to their default\n*                  reset values.\n* Input          : SSPx: where x can be 0 or 1 to select the SSP peripheral.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_DeInit(SSP_TypeDef* SSPx)", "code": "{\n  if(SSPx == SSP0)\n  {\n    /* Reset the SSP0 registers values*/\n    SCU_APBPeriphReset(__SSP0,ENABLE);\n    SCU_APBPeriphReset(__SSP0,DISABLE);\n  }\n  else if (SSPx == SSP1)\n  {\n    /* Reset the SSP1 registers values*/\n    SCU_APBPeriphReset(__SSP1,ENABLE);\n    SCU_APBPeriphReset(__SSP1,DISABLE);\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : WDG_GetFlagStatus\n* Description    : Checks whether the WDG End of Count(EC) flag is set or not.\n* Input          : None\n* Output         : None\n* Return         : The new state of the WDG_FLAG (SET or RESET).\n*******************************************************************************/\n", "func_signal": "FlagStatus WDG_GetFlagStatus(void)", "code": "{\n  if((WDG->SR & WDG_FLAG_EC) != RESET )\n  {\n    return SET;\n  }\n  else\n  {\n    return RESET;\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_Init\n* Description    : Initializes the SSPx  peripheral according to the specified\n*                  parameters in the SSP_InitTypeDef structure.\n* Input          : - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                  - SSP_InitStruct: pointer to a SSP_InitTypeDef structure that\n*                    contains the configuration information for the specified SSP\n*                    peripheral.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_Init(SSP_TypeDef* SSPx, SSP_InitTypeDef* SSP_InitStruct)", "code": "{\n  if(SSP_InitStruct->SSP_FrameFormat == SSP_FrameFormat_Motorola)\n  {\n    /* Set the Motorola frame format */\n    SSPx->CR0 &= SSP_FrameFormat_Motorola;\n    /* Configure the Clock polarity */\n    if(SSP_InitStruct->SSP_CPOL == SSP_CPOL_High)\n    {\n      /* SCK is held high when no data is being transfered */\n      SSPx->CR0 |= SSP_CPOL_High;\n    }\n    else\n    {\n      /* SCK is held low when no data is being transfered */\n      SSPx->CR0 &= SSP_CPOL_Low;\n    }\n    /* Configure the Clock Phase */\n    if(SSP_InitStruct->SSP_CPHA == SSP_CPHA_2Edge)\n    {\n      /* Data captured on second clock edge */\n      SSPx->CR0 |= SSP_CPHA_2Edge;\n    }\n    else\n    {\n      /* Data captured on first clock edge */\n      SSPx->CR0 &= SSP_CPHA_1Edge;\n    }\n  }\n   /* Configure the Frame format */\n  else\n  {\n    /* Clear the FRF[1:0] bits */\n    SSPx->CR0 &= SSP_FrameFormat_Mask;\n    /* Set the TI frame format */\n    SSPx->CR0 |= SSP_InitStruct->SSP_FrameFormat;\n  }\n  /* Configure the Mode */\n  if(SSP_InitStruct->SSP_Mode == SSP_Mode_Slave)\n  {\n    /* Set the slave mode */\n    SSPx->CR1 |= SSP_Mode_Slave;\n    /* Configure the Slave output */\n    if(SSP_InitStruct->SSP_SlaveOutput == SSP_SlaveOutput_Disable)\n    {\n      /* Slave output disabled */\n      SSPx->CR1 |= SSP_SlaveOutput_Disable;\n    }\n    else\n    {\n      /* Slave output enabled */\n      SSPx->CR1 &= SSP_SlaveOutput_Enable;\n    }\n  }\n  else\n  {\n    /* Set the master mode */\n    SSPx->CR1 &= SSP_Mode_Master;\n    /* Clear clock rate SCR[7:0] bits */\n    SSPx->CR0 &= SSP_ClockRate_Mask;\n    /* Set the serial clock rate */\n    SSPx->CR0 |= (SSP_InitStruct->SSP_ClockRate<<8);\n    /* Clear clock prescaler CPSDVSR[7:0] bits */\n    SSPx->PR &= SSP_ClockPrescaler_Mask;\n    /* Set the serial clock prescaler */\n    SSPx->PR |= SSP_InitStruct->SSP_ClockPrescaler;\n  }\n\n  /* Clear data size DSS[3:0] bits */\n  SSPx->CR0 &= SSP_DataSize_Mask;\n  /* Set the data size */\n  SSPx->CR0 |= SSP_InitStruct->SSP_DataSize;\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : SSP_Cmd\n* Description    : Enables or disables the specified SSP peripheral.\n* Input          : - SSPx: where x can be 0 or 1 to select the SSP peripheral.\n*                  - NewState: new state of the  SSPx peripheral. This parameter\n*                    can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SSP_Cmd(SSP_TypeDef* SSPx, FunctionalState NewState)", "code": "{\n  if(NewState == ENABLE)\n  {\n    /* Enable the SSP peripheral */\n    SSPx->CR1 |= SSP_Enable;\n  }\n  else\n  {\n    /* Disable the SSP peripheral */\n    SSPx->CR1 &= SSP_Disable;\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_ssp.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*******************************************************************************\n* Function Name  : WDG_GetITStatus\n* Description    : Checks whether the WDG End of Count(EC) interrupt is occured or not.\n* Input          : None\n* Output         : None\n* Return         : The new state of WDG_IT (SET or RESET).\n*******************************************************************************/\n", "func_signal": "ITStatus WDG_GetITStatus(void)", "code": "{\n  if(((WDG->SR & WDG_IT_EC) != RESET )&&((WDG->MR & WDG_IT_EC) != RESET ))\n  {\n    return SET;\n  }\n  else\n  {\n    return RESET;\n  }\n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/******************************************************************************\n* Function Name  : WDG_DeInit\n* Description    : Deinitializes the WDG peripheral registers to their default\n*                  reset values.\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void WDG_DeInit(void)", "code": "{\n\n  SCU_APBPeriphReset(__WDG, ENABLE);  /*WDG peripheral under Reset */\n  SCU_APBPeriphReset(__WDG, DISABLE);  /*WDG peripheral Reset off*/\n  \n}", "path": "cpputest\\platforms\\IAR-STR912\\source\\91x_wdg.c", "repo_name": "dougbradbury/TddCpp", "stars": 2, "license": "None", "language": "c", "size": 528}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void griewank (void)", "code": "{\n\t  /* This is the generalized Griewank function */\n\n\t  int idx_i;\n\t  double result_s,result_p;\n\n\t  result_s=0.0;\n\t  result_p=1.0;\n\n\t  for (idx_i = 0; idx_i < ( psos[cur_pso].dimension ); idx_i++)\n\t  {\n\t\t  result_s +=psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i] * psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i];\n\t\t  result_p *=cos(psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i]/sqrt(idx_i+1));\n\t  }\n\t  psos[cur_pso].eva_fun_value = result_s/4000.0 - result_p +1;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void michalewicz_min (void)", "code": "{\n    int idx_i;\n    float x1,x2, y1,y2,fit_value;\n    int env_pso;\n    double temp_max,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        x1 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][0];\n        x2 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][1];\n    }\n    else\n    {\n        x1 = psos[cur_pso].position_values[psos[cur_pso].popu_index][0];\n        x2 = psos[cur_pso].position_values[psos[cur_pso].popu_index][1];\n    }\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            y1 = psos[env_pso].pbest_position_values[idx_i][0];\n            y2 = psos[env_pso].pbest_position_values[idx_i][1];\n        }\n        else\n        {\n            y1 = psos[env_pso].position_values[idx_i][0];\n            y2 = psos[env_pso].position_values[idx_i][1];\n        }\n        temp_value = 100 * pow((x2- x1*x1),2) + pow((1.0-x1),2)  - y1*(x1+x2*x2) - y2*(x1*x1+x2);\n        if (idx_i == 0)\n        {\n            temp_max = temp_value;\n            fit_value = (float)temp_max;\n        }\n        else\n        {\n            fit_value = max(temp_value,temp_max);\n            temp_max = fit_value;\n        }\n\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g7_best_solution (void)", "code": "{\n    double x1, x2, x3, x4, x5, x6, x7, x8, x9, x10;\n\n    x1  = psos[0].pbest_position_values[psos[0].global_best_index][0];\n    x2  = psos[0].pbest_position_values[psos[0].global_best_index][1];\n    x3  = psos[0].pbest_position_values[psos[0].global_best_index][2];\n    x4  = psos[0].pbest_position_values[psos[0].global_best_index][3];\n    x5  = psos[0].pbest_position_values[psos[0].global_best_index][4];\n    x6  = psos[0].pbest_position_values[psos[0].global_best_index][5];\n    x7  = psos[0].pbest_position_values[psos[0].global_best_index][6];\n    x8  = psos[0].pbest_position_values[psos[0].global_best_index][7];\n    x9  = psos[0].pbest_position_values[psos[0].global_best_index][8];\n    x10 = psos[0].pbest_position_values[psos[0].global_best_index][9];\n\n    // restrictions\n    paper_results[0] = -(105- 4*x1- 5*x2+ 3*x7- 9*x8);\n    paper_results[1] = -(-3*pow(x1-2, 2)- 4*pow(x2-3, 2)- 2*x3*x3+ 7*x4+ 120);\n    paper_results[2] = -(-10*x1+ 8*x2+ 17*x7- 2*x8);\n    paper_results[3] = -(-x1*x1- 2*pow(x2-2, 2)+ 2*x1*x2- 14*x5+ 6*x6);\n    paper_results[4] = -(8*x1- 2*x2- 5*x9+ 2*x10+12);\n    paper_results[5] = -(-5*x1*x1- 8*x2- pow(x3-6, 2)+ 2*x4+ 40);\n    paper_results[6] = -(3*x1 -6*x2- 12*pow(x9-8, 2)+ 7*x10);\n    paper_results[7] = -(-0.5*pow(x1-8, 2)- 2*(x2-4)- 3*x5*x5+ x6+ 30);\n\n    paper_results[8] =  x1*x1+ x2*x2+ x1*x2- 14*x1 -16*x2+ pow(x3-10, 2)\n\t           +4*pow(x4-5,2)+ pow(x5-3, 2)+ 2*pow(x6-1, 2)+ 5*x7*x7\n\t           +7*pow(x8-11, 2)+ 2*pow(x9-10, 2)+ pow(x10-7, 2)+ 45;\n\n    counter = 9;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void rosenbrock (void)", "code": "{\n\n\t/* this is the Rosenbrock function  */\n\n\tint idx_i;\n\tdouble result;\n\n\tresult=0.0;\n\n\tfor (idx_i = 1; idx_i < ( psos[cur_pso].dimension ); idx_i++)\n\t{\n\t\tresult += 100.0*(psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i] - psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1] * psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1]) * (psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i] - psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1] * psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1]) + (psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1]-1) * (psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i - 1]-1);\n\t}\n\n\tpsos[cur_pso].eva_fun_value = fabs(result);\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void michalewicz_2_max (void)", "code": "{\n    int idx_i;\n    float x1,x2, y1,y2,fit_value;\n    int env_pso;\n    double temp_min,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        y1 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][0];\n        y2 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][1];\n    }\n    else\n    {\n        y1 = psos[cur_pso].position_values[psos[cur_pso].popu_index][0];\n        y2 = psos[cur_pso].position_values[psos[cur_pso].popu_index][1];\n    }\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            x1 = psos[env_pso].pbest_position_values[idx_i][0];\n            x2 = psos[env_pso].pbest_position_values[idx_i][1];\n        }\n        else\n        {\n            x1 = psos[env_pso].position_values[idx_i][0];\n            x2 = psos[env_pso].position_values[idx_i][1];\n        }\n\n        temp_value = pow((x1-2),2) + pow((x2-1),2) +y1*(x1*x1-x2)+y2*(x1+x2-2);\n\n        if (idx_i == 0)\n        {\n            temp_min = temp_value;\n            fit_value = temp_min;\n        }\n        else\n        {\n            fit_value = min(temp_value,temp_min);\n            temp_min = fit_value;\n        }\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void linear_iw (void)", "code": "{\n    int total_gen,cur_index;\n\n    total_gen =  total_cycle_of_PSOs * psos[cur_pso].env_data.max_generation;\n    cur_index =  pso_cycle_index     * psos[cur_pso].env_data.max_generation + psos[cur_pso].gene_index;\n\n    psos[cur_pso].inertia_weight = ((psos[cur_pso].init_inertia_weight ) - 0.4 ) * ( total_gen - cur_index) / total_gen + 0.4 + ((rand()%600)/1000.0) - 0.3;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:  Asymmetry initialization\n*\n**************************************************/\n", "func_signal": "static void PSO_random_asymmetry_initialize (void)", "code": "{\n    int b;\n\t  for (b=0;b<(psos[cur_pso].dimension);b++)\n\t  {\n        if (psos[cur_pso].env_data.boundary_flag)\n        {\n           (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b] = (float)((psos[cur_pso].env_data.up_boundaries[b]) - (psos[cur_pso].env_data.low_boundaries[b] ) ) * ((rand()%1000)/1000.0) + (psos[cur_pso].env_data.low_boundaries[b] );\n\t\t     psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][b] =  (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b];\n           psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = 0.5* ((psos[cur_pso].env_data.up_boundaries[b]) - (psos[cur_pso].env_data.low_boundaries[b] ) ) * ((rand()%1000)/1000.0);\n        }\n        else\n        {\n\t  \t     ((psos[cur_pso].position_values)[psos[cur_pso].popu_index][b] ) = (float) (((psos[cur_pso].env_data.init_range.right) - (psos[cur_pso].env_data.init_range.left ))*((rand()%1000)/1000.0) + (psos[cur_pso].env_data.init_range.left ));\n\t\t     psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][b] =  (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b];\n\t\t     psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = (psos[cur_pso].env_data.max_velocity)*((rand()%1000)/1000.0);\n        }\n\t\t  if (((rand()%1000)/1000.0) > 0.5)\n\t      {\n\t  \t      psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = -(psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b]  );\n\t      }\n\t  }\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g9_min (void)", "code": "{\n    int idx_i,idx_j;\n    double x[7];\n    double y[4];\n    double r[4];\n    double p[4];\n\n    double fit_value;\n    int env_pso;\n    double temp_max,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        for (idx_i = 0; idx_i <7 ; idx_i++ )\n        {\n            x[idx_i]  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n    else\n    {\n        for (idx_i = 0; idx_i <7 ; idx_i++ )\n        {\n            x[idx_i]  = psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n\n    // constrains\n    r[0] = 2 * x[0] * x[0] + 3 * pow(x[1],4) + x[2] + 4 * x[3] * x[3] + 5 * x[4]  - 127;\n    r[1] = 7 * x[0] + 3 * x[1] + 10 * x[2] * x[2] + x[3] - x[4] - 282;\n    r[2] = 23 * x[0] + x[1] * x[1] + 6 * x[5] * x[5] - 8 * x[6] - 196;\n    r[3] = 4 * x[0] * x[0] + x[1] * x[1] - 3 * x[0] * x[1] + 2 * x[2] * x[2] + 5 * x[5] - 11 * x[6];\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            for (idx_j = 0; idx_j <4 ; idx_j++ )\n            {\n                y[idx_j] = psos[env_pso].pbest_position_values[idx_i][idx_j];\n            }\n        }\n        else\n        {\n            for (idx_j = 0; idx_j <4 ; idx_j++ )\n            {\n                y[idx_j] = psos[env_pso].position_values[idx_i][idx_j];\n            }\n        }\n\n        temp_value = pow((x[0] - 10),2) + 5 * pow((x[1] - 12),2) + pow(x[2],4) + 3 * pow((x[3] - 11),2)\n                     + 10 * pow((x[4]),6) + 7 * pow(x[5],2) + pow(x[6],4) - 4 * x[5] * x[6] - 10 * x[5] - 8 * x[6];\n\n        for (idx_j = 0; idx_j <4 ; idx_j++ )\n        {\n            if ((r[idx_j]) >= (-y[idx_j]/200.0))\n            {\n                p[idx_j] = y[idx_j] * r[idx_j] + 100 * r[idx_j] * r[idx_j];\n            }\n            else\n            {\n                p[idx_j] = - y[idx_j] * y[idx_j]/400.0;\n            }\n            temp_value += p[idx_j];\n        }\n        if (idx_i == 0)\n        {\n            temp_max = temp_value;\n            fit_value = temp_max;\n        }\n        else\n        {\n            fit_value = max(temp_value,temp_max);\n            temp_max = fit_value;\n        }\n    }\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g9_max (void)", "code": "{\n    int idx_i,idx_j;\n    double x[7];\n    double y[4];\n    double r[4];\n    double p[4];\n\n    double fit_value;\n    int env_pso;\n    double temp_min,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        for (idx_i = 0; idx_i <4 ; idx_i++ )\n        {\n            y[idx_i]  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n    else\n    {\n        for (idx_i = 0; idx_i <4 ; idx_i++ )\n        {\n            y[idx_i]  = psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            for (idx_j = 0; idx_j <7 ; idx_j++ )\n            {\n                x[idx_j] = psos[env_pso].pbest_position_values[idx_i][idx_j];\n            }\n        }\n        else\n        {\n            for (idx_j = 0; idx_j <7 ; idx_j++ )\n            {\n                x[idx_j] = psos[env_pso].position_values[idx_i][idx_j];\n            }\n        }\n\n        // constrains\n        r[0] = 2 * x[0] * x[0] + 3 * pow(x[1],4) + x[2] + 4 * x[3] * x[3] + 5 * x[4]  - 127;\n        r[1] = 7 * x[0] + 3 * x[1] + 10 * x[2] * x[2] + x[3] - x[4] - 282;\n        r[2] = 23 * x[0] + x[1] * x[1] + 6 * x[5] * x[5] - 8 * x[6] - 196;\n        r[3] = 4 * x[0] * x[0] + x[1] * x[1] - 3 * x[0] * x[1] + 2 * x[2] * x[2] + 5 * x[5] - 11 * x[6];\n\n        temp_value = pow((x[0] - 10),2) + 5 * pow((x[1] - 12),2) + pow(x[2],4) + 3 * pow((x[3] - 11),2)\n                     + 10 * pow((x[4]),6) + 7 * pow(x[5],2) + pow(x[6],4) - 4 * x[5] * x[6] - 10 * x[5] - 8 * x[6];\n\n        for (idx_j = 0; idx_j <4 ; idx_j++ )\n        {\n            if ((r[idx_j]) >= (-y[idx_j]/200.0))\n            {\n                p[idx_j] = y[idx_j] * r[idx_j] + 100 * r[idx_j] * r[idx_j];\n            }\n            else\n            {\n                p[idx_j] = - y[idx_j] * y[idx_j]/400.0;\n            }\n            temp_value += p[idx_j];\n        }\n        if (idx_i == 0)\n        {\n            temp_min = temp_value;\n            fit_value = temp_min;\n        }\n        else\n        {\n            fit_value = min(temp_value,temp_min);\n            temp_min = fit_value;\n        }\n\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g1_max (void)", "code": "{\n    int idx_i,idx_j;\n    double x[13];\n    double y[9];\n    double r[9];\n    double p[9];\n\n    double fit_value;\n    int env_pso;\n    double temp_min,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        for (idx_i = 0; idx_i <9 ; idx_i++ )\n        {\n            y[idx_i]  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n    else\n    {\n        for (idx_i = 0; idx_i <9 ; idx_i++ )\n        {\n            y[idx_i]  = psos[cur_pso].position_values[psos[cur_pso].popu_index][idx_i];\n        }\n    }\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            for (idx_j = 0; idx_j <13 ; idx_j++ )\n            {\n                x[idx_j] = psos[env_pso].pbest_position_values[idx_i][idx_j];\n            }\n        }\n        else\n        {\n            for (idx_j = 0; idx_j <13 ; idx_j++ )\n            {\n                x[idx_j] = psos[env_pso].position_values[idx_i][idx_j];\n            }\n        }\n\n        // constrains\n        r[0] =  2 * x[0] + 2     * x[1]  + x[9]  + x[10] - 10;\n        r[1] =  2 * x[0] + 2     * x[2]  + x[9]  + x[11] - 10;\n        r[2] =  2 * x[1] + 2     * x[2]  + x[10] + x[11] - 10;\n        r[3] = -8 * x[0] + x[9];\n        r[4] = -8 * x[1] + x[10];\n        r[5] = -8 * x[2] + x[11];\n        r[6] = -2 * x[3] - x[4]  + x[9];\n        r[7] = -2 * x[5] - x[6]  + x[10];\n        r[8] = -2 * x[7] - x[8]  + x[11];\n\n        temp_value = 0.0;\n        for (idx_j = 0; idx_j <4 ; idx_j++ )\n        {\n            temp_value += 5 * (x[idx_j] - x[idx_j] * x[idx_j]);\n        }\n\n        for (idx_j = 4; idx_j <13 ; idx_j++ )\n        {\n            temp_value -= x[idx_j];\n        }\n\n        for (idx_j = 0; idx_j <9 ; idx_j++ )\n        {\n            if ((r[idx_j]) >= (-y[idx_j]/200.0))\n            {\n                p[idx_j] = y[idx_j] * r[idx_j] + 100 * r[idx_j] * r[idx_j];\n            }\n            else\n            {\n                p[idx_j] = - y[idx_j] * y[idx_j]/400.0;\n            }\n        }\n\n\n        for (idx_j = 0; idx_j <9 ; idx_j++ )\n        {\n            temp_value += p[idx_j];\n        }\n\n        if (idx_i == 0)\n        {\n            temp_min = temp_value;\n            fit_value = temp_min;\n        }\n        else\n        {\n            fit_value = min(temp_value,temp_min);\n            temp_min = fit_value;\n        }\n\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g7_max (void)", "code": "{\n    int idx_i;\n    double x1, x2, x3, x4, x5, x6, x7, x8, x9, x10;\n\t  double y1, y2, y3, y4, y5, y6, y7, y8;\n\t  double r1, r2, r3, r4, r5, r6, r7, r8;\n    double p1, p2, p3, p4, p5, p6, p7, p8;\n    double fit_value;\n    int env_pso;\n    double temp_min,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        y1 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][0];\n        y2 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][1];\n        y3 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][2];\n        y4 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][3];\n        y5 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][4];\n        y6 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][5];\n        y7 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][6];\n        y8 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][7];\n    }\n    else\n    {\n        y1 = psos[cur_pso].position_values[psos[cur_pso].popu_index][0];\n        y2 = psos[cur_pso].position_values[psos[cur_pso].popu_index][1];\n        y3 = psos[cur_pso].position_values[psos[cur_pso].popu_index][2];\n        y4 = psos[cur_pso].position_values[psos[cur_pso].popu_index][3];\n        y5 = psos[cur_pso].position_values[psos[cur_pso].popu_index][4];\n        y6 = psos[cur_pso].position_values[psos[cur_pso].popu_index][5];\n        y7 = psos[cur_pso].position_values[psos[cur_pso].popu_index][6];\n        y8 = psos[cur_pso].position_values[psos[cur_pso].popu_index][7];\n    }\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            x1  = psos[env_pso].pbest_position_values[idx_i][0];\n            x2  = psos[env_pso].pbest_position_values[idx_i][1];\n            x3  = psos[env_pso].pbest_position_values[idx_i][2];\n            x4  = psos[env_pso].pbest_position_values[idx_i][3];\n            x5  = psos[env_pso].pbest_position_values[idx_i][4];\n            x6  = psos[env_pso].pbest_position_values[idx_i][5];\n            x7  = psos[env_pso].pbest_position_values[idx_i][6];\n            x8  = psos[env_pso].pbest_position_values[idx_i][7];\n            x9  = psos[env_pso].pbest_position_values[idx_i][8];\n            x10 = psos[env_pso].pbest_position_values[idx_i][9];\n        }\n        else\n        {\n            x1  = psos[env_pso].position_values[idx_i][0];\n            x2  = psos[env_pso].position_values[idx_i][1];\n            x3  = psos[env_pso].position_values[idx_i][2];\n            x4  = psos[env_pso].position_values[idx_i][3];\n            x5  = psos[env_pso].position_values[idx_i][4];\n            x6  = psos[env_pso].position_values[idx_i][5];\n            x7  = psos[env_pso].position_values[idx_i][6];\n            x8  = psos[env_pso].position_values[idx_i][7];\n            x9  = psos[env_pso].position_values[idx_i][8];\n            x10 = psos[env_pso].position_values[idx_i][9];\n        }\n\n        r1= -(105- 4*x1- 5*x2+ 3*x7- 9*x8);\n        r2= -(-3*pow(x1-2, 2)- 4*pow(x2-3, 2)- 2*x3*x3+ 7*x4+ 120);\n        r3= -(-10*x1+ 8*x2+ 17*x7- 2*x8);\n        r4= -(-x1*x1- 2*pow(x2-2, 2)+2*x1*x2- 14*x5+ 6*x6);\n        r5= -(8*x1- 2*x2- 5*x9+ 2*x10+12);\n        r6= -(-5*x1*x1- 8*x2- 1*pow(x3-6, 2)+ 2*x4+ 40);\n        r7= -(3*x1 -6*x2- 12*pow(x9-8, 2)+ 7*x10);\n        r8= -(-0.5*pow(x1-8, 2)- 2*(x2-4)- 3*x5*x5+ x6+ 30);\n\n        temp_value =  x1*x1+ x2*x2+ x1*x2- 14*x1 -16*x2+ pow(x3-10, 2)\n\t               +4*pow(x4-5,2)+ pow(x5-3, 2)+ 2*pow(x6-1, 2)+ 5*x7*x7\n\t               +7*pow(x8-11, 2)+ 2*pow(x9-10, 2)+ pow(x10-7, 2)+ 45;\n\n        if ((r1) >= (-y1/200.0))\n        {\n            p1 = y1 * r1 + 100 * r1 * r1;\n        }\n        else\n        {\n            p1 = - y1*y1/400.0;\n        }\n\n        if ((r2) >= (-y2/200.0))\n        {\n            p2 = y2 * r2 + 100 * r2 * r2;\n        }\n        else\n        {\n            p2 = - y2*y2/400.0;\n        }\n\n        if ((r3) >= (-y3/200.0))\n        {\n            p3 = y3 * r3 + 100 * r3 * r3;\n        }\n        else\n        {\n            p3 = - y3*y3/400.0;\n        }\n\n        if ((r4) >= (-y4/200.0))\n        {\n            p4 = y4 * r4 + 100 * r4 * r4;\n        }\n        else\n        {\n            p4 = - y4*y4/400.0;\n        }\n\n        if ((r5) >= (-y5/200.0))\n        {\n            p5 = y5 * r5 + 100 * r5 * r5;\n        }\n        else\n        {\n            p5 = - y5*y5/400.0;\n        }\n\n        if ((r6) >= (-y6/200.0))\n        {\n            p6 = y6 * r6 + 100 * r6 * r6;\n        }\n        else\n        {\n            p6 = - y6*y6/400.0;\n        }\n\n        if ((r7) >= (-y7/200.0))\n        {\n            p7 = y7 * r7 + 100 * r7 * r7;\n        }\n        else\n        {\n            p7 = - y7*y7/400.0;\n        }\n\n        if ((r8) >= (-y8/200.0))\n        {\n            p8 = y8 * r8 + 100 * r8 * r8;\n        }\n        else\n        {\n            p8 = - y8*y8/400.0;\n        }\n\n        temp_value += p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;\n        //temp_value += (y1*r1 +y2*r2 +y3*r3 +y4*r4 +y5*r5 +y6*r6 +y7*r7+y8*r8);\n\n        if (idx_i == 0)\n        {\n            temp_min = temp_value;\n            fit_value = temp_min;\n        }\n        else\n        {\n            fit_value = min(temp_value,temp_min);\n            temp_min = fit_value;\n        }\n\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/************************************************************/\n/*      PSO functons                                        */\n/************************************************************/\n/************************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n*************************************************************/\n", "func_signal": "void PSO_Main_Loop (void)", "code": "{\n    BOOLEAN running;\n\n    pso_initialize();\n    // start running PSOs\n    while ((pso_cycle_index++) < total_cycle_of_PSOs)\n    {\n        running = TRUE;\n        while (running)\n        {\n            if (PSO_current_state == PSOS_DONE)\n            {\n                running = FALSE;                          // end running this cycle of PSO\n            }\n            pso_state_handler(PSO_current_state);         // run state handler\n        }\n    }\n    pso_store_results();                                  // output results\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void PSO_update_position (void)", "code": "{\n   int idx_i;\n   for (idx_i = 0; idx_i < (psos[cur_pso].dimension) ;idx_i++ )\n\t {\n\t\t  psos[cur_pso].position_values[psos[cur_pso].popu_index ][idx_i ] +=  psos[cur_pso].velocity_values[psos[cur_pso].popu_index ][idx_i ];\n        if (psos[cur_pso].env_data.boundary_flag)\n        {\n            if ((psos[cur_pso].position_values[psos[cur_pso].popu_index ][idx_i ]) < (psos[cur_pso].env_data.low_boundaries[idx_i] ))\n            {\n                psos[cur_pso].position_values[psos[cur_pso].popu_index ][idx_i ] =  psos[cur_pso].env_data.low_boundaries[idx_i] + ((psos[cur_pso].env_data.up_boundaries[idx_i] - psos[cur_pso].env_data.low_boundaries[idx_i] ) * ((rand()%1000)/100000.0));  // low boundary + noise\n            }\n            else  if ((psos[cur_pso].position_values[psos[cur_pso].popu_index ][idx_i ]) > (psos[cur_pso].env_data.up_boundaries[idx_i]))\n            {\n                psos[cur_pso].position_values[psos[cur_pso].popu_index ][idx_i ] =  psos[cur_pso].env_data.up_boundaries[idx_i] -  ((psos[cur_pso].env_data.up_boundaries[idx_i] - psos[cur_pso].env_data.low_boundaries[idx_i] ) * ((rand()%1000)/100000.0));   // up boundary - noise\n            }\n        }\n\t }\n\n\tPSO_current_state =  PSO_EVALUATE;       // go back to the PSO_EVALUATE state\n\t(psos[cur_pso].popu_index)++;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g7_min (void)", "code": "{\n    int idx_i;\n    double x1, x2, x3, x4, x5, x6, x7, x8, x9, x10;\n\t  double y1, y2, y3, y4, y5, y6, y7, y8;\n\t  double r1, r2, r3, r4, r5, r6, r7, r8;\n    double p1, p2, p3, p4, p5, p6, p7, p8;\n\n    double fit_value;\n    int env_pso;\n    double temp_max,temp_value;\n\n    env_pso = (cur_pso)?0:1;\n\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        x1  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][0];\n        x2  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][1];\n        x3  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][2];\n        x4  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][3];\n        x5  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][4];\n        x6  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][5];\n        x7  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][6];\n        x8  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][7];\n        x9  = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][8];\n        x10 = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][9];\n    }\n    else\n    {\n        x1  = psos[cur_pso].position_values[psos[cur_pso].popu_index][0];\n        x2  = psos[cur_pso].position_values[psos[cur_pso].popu_index][1];\n        x3  = psos[cur_pso].position_values[psos[cur_pso].popu_index][2];\n        x4  = psos[cur_pso].position_values[psos[cur_pso].popu_index][3];\n        x5  = psos[cur_pso].position_values[psos[cur_pso].popu_index][4];\n        x6  = psos[cur_pso].position_values[psos[cur_pso].popu_index][5];\n        x7  = psos[cur_pso].position_values[psos[cur_pso].popu_index][6];\n        x8  = psos[cur_pso].position_values[psos[cur_pso].popu_index][7];\n        x9  = psos[cur_pso].position_values[psos[cur_pso].popu_index][8];\n        x10 = psos[cur_pso].position_values[psos[cur_pso].popu_index][9];\n    }\n\n    // restrictions\n    r1= -(105- 4*x1- 5*x2+ 3*x7- 9*x8);\n    r2= -(-3*pow(x1-2, 2)- 4*pow(x2-3, 2)- 2*x3*x3+ 7*x4+ 120);\n    r3= -(-10*x1+ 8*x2+ 17*x7- 2*x8);\n    r4= -(-x1*x1- 2*pow(x2-2, 2)+ 2*x1*x2- 14*x5+ 6*x6);\n    r5= -(8*x1- 2*x2- 5*x9+ 2*x10+12);\n    r6= -(-5*x1*x1- 8*x2- pow(x3-6, 2)+ 2*x4+ 40);\n    r7= -(3*x1 -6*x2- 12*pow(x9-8, 2)+ 7*x10);\n    r8= -(-0.5*pow(x1-8, 2)- 2*(x2-4)- 3*x5*x5+ x6+ 30);\n\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            y1 = psos[env_pso].pbest_position_values[idx_i][0];\n            y2 = psos[env_pso].pbest_position_values[idx_i][1];\n            y3 = psos[env_pso].pbest_position_values[idx_i][2];\n            y4 = psos[env_pso].pbest_position_values[idx_i][3];\n            y5 = psos[env_pso].pbest_position_values[idx_i][4];\n            y6 = psos[env_pso].pbest_position_values[idx_i][5];\n            y7 = psos[env_pso].pbest_position_values[idx_i][6];\n            y8 = psos[env_pso].pbest_position_values[idx_i][7];\n        }\n        else\n        {\n            y1 = psos[env_pso].position_values[idx_i][0];\n            y2 = psos[env_pso].position_values[idx_i][1];\n            y3 = psos[env_pso].position_values[idx_i][2];\n            y4 = psos[env_pso].position_values[idx_i][3];\n            y5 = psos[env_pso].position_values[idx_i][4];\n            y6 = psos[env_pso].position_values[idx_i][5];\n            y7 = psos[env_pso].position_values[idx_i][6];\n            y8 = psos[env_pso].position_values[idx_i][7];\n        }\n\n        temp_value =  x1*x1+ x2*x2+ x1*x2- 14*x1 -16*x2+ pow(x3-10, 2)\n\t               +4*pow(x4-5,2)+ pow(x5-3, 2)+ 2*pow(x6-1, 2)+ 5*x7*x7\n\t               +7*pow(x8-11, 2)+ 2*pow(x9-10, 2)+ pow(x10-7, 2)+ 45;\n\n        if ((r1) >= (-y1/200.0))\n        {\n            p1 = y1 * r1 + 100 * r1 * r1;\n        }\n        else\n        {\n            p1 = - y1*y1/400.0;\n        }\n\n        if ((r2) >= (-y2/200.0))\n        {\n            p2 = y2 * r2 + 100 * r2 * r2;\n        }\n        else\n        {\n            p2 = - y2*y2/400.0;\n        }\n\n        if ((r3) >= (-y3/200.0))\n        {\n            p3 = y3 * r3 + 100 * r3 * r3;\n        }\n        else\n        {\n            p3 = - y3*y3/400.0;\n        }\n\n        if ((r4) >= (-y4/200.0))\n        {\n            p4 = y4 * r4 + 100 * r4 * r4;\n        }\n        else\n        {\n            p4 = - y4*y4/400.0;\n        }\n\n        if ((r5) >= (-y5/200.0))\n        {\n            p5 = y5 * r5 + 100 * r5 * r5;\n        }\n        else\n        {\n            p5 = - y5*y5/400.0;\n        }\n\n        if ((r6) >= (-y6/200.0))\n        {\n            p6 = y6 * r6 + 100 * r6 * r6;\n        }\n        else\n        {\n            p6 = - y6*y6/400.0;\n        }\n\n        if ((r7) >= (-y7/200.0))\n        {\n            p7 = y7 * r7 + 100 * r7 * r7;\n        }\n        else\n        {\n            p7 = - y7*y7/400.0;\n        }\n\n        if ((r8) >= (-y8/200.0))\n        {\n            p8 = y8 * r8 + 100 * r8 * r8;\n        }\n        else\n        {\n            p8 = - y8*y8/400.0;\n        }\n\n        temp_value += p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;\n        //temp_value += (y1*r1 +y2*r2 +y3*r3 +y4*r4 +y5*r5 +y6*r6 +y7*r7+y8*r8);\n\n        if (idx_i == 0)\n        {\n            temp_max = temp_value;\n            fit_value = temp_max;\n        }\n        else\n        {\n            fit_value = max(temp_value,temp_max);\n            temp_max = fit_value;\n        }\n\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/************************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n*************************************************************/\n", "func_signal": "static void allocate_pso_memory (void)", "code": "{\n    int idx_i;\n\n    for (idx_i =0 ; idx_i<NUM_PSO ;idx_i++ )\n    {\n        FVectorAllocate(&(psos[idx_i].pbest_values),          psos[idx_i].popu_size);\n        FMatrixAllocate(&(psos[idx_i].velocity_values),       psos[idx_i].popu_size,  psos[idx_i].dimension);\n        FMatrixAllocate(&(psos[idx_i].position_values),       psos[idx_i].popu_size,  psos[idx_i].dimension);\n        FMatrixAllocate(&(psos[idx_i].pbest_position_values), psos[idx_i].popu_size,  psos[idx_i].dimension);\n    }\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g9_best_solution (void)", "code": "{\n    int idx_i;\n    double x[7];\n\n    for (idx_i = 0; idx_i <7 ; idx_i++ )\n    {\n        x[idx_i]  = psos[0].pbest_position_values[psos[0].global_best_index][idx_i];\n    }\n\n    // constrains\n    paper_results[0] = 2 * x[0] * x[0] + 3 * pow(x[1],4) + x[2] + 4 * x[3] * x[3] + 5 * x[4]  - 127;\n    paper_results[1] = 7 * x[0] + 3 * x[1] + 10 * x[2] * x[2] + x[3] - x[4] - 282;\n    paper_results[2] = 23 * x[0] + x[1] * x[1] + 6 * x[5] * x[5] - 8 * x[6] - 196;\n    paper_results[3] = 4 * x[0] * x[0] + x[1] * x[1] - 3 * x[0] * x[1] + 2 * x[2] * x[2] + 5 * x[5] - 11 * x[6];\n\n    paper_results[4] = pow((x[0] - 10),2) + 5 * pow((x[1] - 12),2) + pow(x[2],4) + 3 * pow((x[3] - 11),2)\n                 + 10 * pow((x[4]),6) + 7 * pow(x[5],2) + pow(x[6],4) - 4 * x[5] * x[6] - 10 * x[5] - 8 * x[6];\n    counter = 5;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:  Symmetry Initialization\n*\n**************************************************/\n", "func_signal": "static void PSO_random_symmetry_initialize (void)", "code": "{\n    int b;\n\t  for (b=0;b<(psos[cur_pso].dimension);b++)\n\t  {\n        if (psos[cur_pso].env_data.boundary_flag)\n        {\n           (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b] = (float)((psos[cur_pso].env_data.up_boundaries[b]) - (psos[cur_pso].env_data.low_boundaries[b] ) ) * ((rand()%1000)/1000.0) + (psos[cur_pso].env_data.low_boundaries[b] );\n\t\t     psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][b] =  (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b];\n           psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = 0.5* ((psos[cur_pso].env_data.up_boundaries[b]) - (psos[cur_pso].env_data.low_boundaries[b] ) ) * ((rand()%1000)/1000.0);\n        }\n        else\n        {\n\t  \t     ((psos[cur_pso].position_values)[psos[cur_pso].popu_index][b] ) = (float) (((psos[cur_pso].env_data.init_range.right) - (psos[cur_pso].env_data.init_range.left ))*((rand()%1000)/1000.0) + (psos[cur_pso].env_data.init_range.left ));\n\t\t     psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][b] =  (psos[cur_pso].position_values)[psos[cur_pso].popu_index][b];\n\t\t     psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = (psos[cur_pso].env_data.max_velocity)*((rand()%1000)/1000.0);\n        }\n\t\t  if (((rand()%1000)/1000.0) > 0.5)\n\t      {\n\t  \t      psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b] = -(psos[cur_pso].velocity_values[psos[cur_pso].popu_index][b]  );\n\t      }\n\t  }\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void simple_min (void)", "code": "{\n    int idx_i;\n    float x, y,fit_value;\n    int env_pso;\n    double temp_max;\n\n    env_pso = (cur_pso)?0:1;\n    if (pso_update_pbest_each_cycle_pending)\n    {\n        x = psos[cur_pso].pbest_position_values[psos[cur_pso].popu_index][0];\n    }\n    else\n    {\n        x = psos[cur_pso].position_values[psos[cur_pso].popu_index][0];\n    }\n    for (idx_i = 0; idx_i < (psos[env_pso].popu_size) ; idx_i++ )\n    {\n        if (pso_update_pbest_each_cycle_pending)\n        {\n            y = psos[env_pso].pbest_position_values[idx_i][0];\n        }\n        else\n        {\n            y = psos[env_pso].position_values[idx_i][0];\n        }\n        if (idx_i == 0)\n        {\n            temp_max = x * y;\n            fit_value = temp_max;\n        }\n        else\n        {\n            fit_value = max((x * y),temp_max);\n            temp_max = fit_value;\n        }\n    }\n\n    psos[cur_pso].eva_fun_value = fit_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void PSO_next_generation (void)", "code": "{\n//printf(\"best fitness = %f\\tbest index = %d\\n\",psos[cur_pso].pbest_values[psos[cur_pso].global_best_index ], psos[cur_pso].global_best_index);\n    if ((++(psos[cur_pso].gene_index)) < (psos[cur_pso].env_data.max_generation  ) )\n    { // next generation of the same population of PSO\n        PSO_current_state = PSO_UPDATE_INERTIA_WEIGHT;\n    }\n    else\n    {\n        if ( (++cur_pso ) >= NUM_PSO)\n        { // end of the cycle\n            cur_pso = 0;                                   // move to the first pso\n        }\n        PSO_current_state = PSO_UPDATE_PBEST_EACH_CYCLE;   // move to the next state\n        psos[cur_pso].popu_index = 0;\n    }\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/*************************************************\n*     Function:\n*\n*   Parameters:\n*\n*      Returns:\n*\n*  Description:\n*\n**************************************************/\n", "func_signal": "static void g1_best_solution (void)", "code": "{\n    int idx_i,idx_j;\n    double x[13];\n\n    double temp_value;\n\n    for (idx_i = 0; idx_i <13 ; idx_i++ )\n    {\n        x[idx_i]  = psos[0].pbest_position_values[psos[0].global_best_index][idx_i];\n    }\n    counter = 10;\n    // constrains\n    paper_results[0] =  2 * x[0] + 2     * x[1]  + x[9]  + x[10] - 10;\n    paper_results[1] =  2 * x[0] + 2     * x[2]  + x[9]  + x[11] - 10;\n    paper_results[2] =  2 * x[1] + 2     * x[2]  + x[10] + x[11] - 10;\n    paper_results[3] = -8 * x[0] + x[9];\n    paper_results[4] = -8 * x[1] + x[10];\n    paper_results[5] = -8 * x[2] + x[11];\n    paper_results[6] = -2 * x[3] - x[4]  + x[9];\n    paper_results[7] = -2 * x[5] - x[6]  + x[10];\n    paper_results[8] = -2 * x[7] - x[8]  + x[11];\n\n    temp_value = 0.0;\n    for (idx_j = 0; idx_j <4 ; idx_j++ )\n    {\n        temp_value += 5 * (x[idx_j] - x[idx_j] * x[idx_j]);\n    }\n\n    for (idx_j = 4; idx_j <13 ; idx_j++ )\n    {\n        temp_value -= x[idx_j];\n    }\n    paper_results[9] = temp_value;\n}", "path": "pso_nn\\psostate.c", "repo_name": "btbytes/ci", "stars": 3, "license": "None", "language": "c", "size": 168}
{"docstring": "/* extract regular file */\n", "func_signal": "int\ntar_extract_regfile(TAR *t, char *realname)", "code": "{\n\tmode_t mode;\n\tsize_t size;\n\tuid_t uid;\n\tgid_t gid;\n\tint fdout;\n\tint i, k;\n\tchar buf[T_BLOCKSIZE];\n\tchar *filename;\n\n#ifdef DEBUG\n\tprintf(\"==> tar_extract_regfile(t=0x%lx, realname=\\\"%s\\\")\\n\", t,\n\t       realname);\n#endif\n\n\tif (!TH_ISREG(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\tmode = th_get_mode(t);\n\tsize = th_get_size(t);\n\tuid = th_get_uid(t);\n\tgid = th_get_gid(t);\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1)\n\t\treturn -1;\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (mode %04o, uid %d, gid %d, %d bytes)\\n\",\n\t       filename, mode, uid, gid, size);\n#endif\n\tfdout = open(filename, O_WRONLY | O_CREAT | O_TRUNC\n#ifdef O_BINARY\n\t\t     | O_BINARY\n#endif\n\t\t    , 0666);\n\tif (fdout == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"open()\");\n#endif\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#if 0\n\t/* change the owner.  (will only work if run as root) */\n\tif (fchown(fdout, uid, gid) == -1 && errno != EPERM)\n\t{\n#ifdef DEBUG\n\t\tperror(\"fchown()\");\n#endif\n\t\treturn -1;\n\t}\n\n\t/* make sure the mode isn't inheritted from a file we're overwriting */\n\tif (fchmod(fdout, mode & 07777) == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"fchmod()\");\n#endif\n\t\treturn -1;\n\t}\n#endif\n\n\t/* extract the file */\n\tfor (i = size; i > 0; i -= T_BLOCKSIZE)\n\t{\n\t\tk = tar_block_read(t, buf);\n\t\tif (k != T_BLOCKSIZE)\n\t\t{\n\t\t\tif (k != -1)\n\t\t\t\terrno = EINVAL;\n\t\t\tif (!realname) free(filename);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* write block to output file */\n\t\tif (write(fdout, buf,\n\t\t\t  ((i > T_BLOCKSIZE) ? T_BLOCKSIZE : i)) == -1){\n\t\t\tif (!realname) free(filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* close output file */\n\tif (close(fdout) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"### done extracting %s\\n\", filename);\n#endif\n\n\tif (!realname) free(filename);\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* switchboard */\n", "func_signal": "int\ntar_extract_file(TAR *t, char *realname)", "code": "{\n\tint i;\n\tlinkname_t *lnp;\n\tchar *filename;\n\n\tif (t->options & TAR_NOOVERWRITE)\n\t{\n\t\tstruct stat s;\n\n\t\tif (lstat(realname, &s) == 0 || errno != ENOENT)\n\t\t{\n\t\t\terrno = EEXIST;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (TH_ISDIR(t))\n\t{\n\t\ti = tar_extract_dir(t, realname);\n\t\tif (i == 1)\n\t\t\ti = 0;\n\t}\n#ifndef _WIN32\n\telse if (TH_ISLNK(t))\n\t\ti = tar_extract_hardlink(t, realname);\n#endif\n#ifndef _WIN32\n\telse if (TH_ISSYM(t))\n\t\ti = tar_extract_symlink(t, realname);\n#endif\n\telse if (TH_ISCHR(t))\n\t\ti = tar_extract_chardev(t, realname);\n#ifndef _WIN32\n\telse if (TH_ISBLK(t))\n\t\ti = tar_extract_blockdev(t, realname);\n#endif\n\telse if (TH_ISFIFO(t))\n\t\ti = tar_extract_fifo(t, realname);\n\telse /* if (TH_ISREG(t)) */\n\t\ti = tar_extract_regfile(t, realname);\n\n\tif (i != 0)\n\t\treturn i;\n\n\ti = tar_set_file_perms(t, realname);\n\tif (i != 0)\n\t\treturn i;\n\n\tlnp = (linkname_t *)calloc(1, sizeof(linkname_t));\n\tif (lnp == NULL)\n\t\treturn -1;\n\tfilename = th_get_pathname(t);\n\tstrlcpy(lnp->ln_save, filename, sizeof(lnp->ln_save));\n\tfree(filename);\n\tstrlcpy(lnp->ln_real, realname, sizeof(lnp->ln_real));\n#ifdef DEBUG\n\tfilename = th_get_pathname(t);\n\tprintf(\"tar_extract_file(): calling libtar_hash_add(): key=\\\"%s\\\", \"\n\t       \"value=\\\"%s\\\"\\n\", filename, realname);\n\tfree(filename);\n#endif\n\tif (libtar_hash_add(t->h, lnp) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* skip regfile */\n", "func_signal": "int\ntar_skip_regfile(TAR *t)", "code": "{\n\tint i, k;\n\tsize_t size;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISREG(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tsize = th_get_size(t);\n\tfor (i = size; i > 0; i -= T_BLOCKSIZE)\n\t{\n\t\tk = tar_block_read(t, buf);\n\t\tif (k != T_BLOCKSIZE)\n\t\t{\n\t\t\tif (k != -1)\n\t\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_getkey() - hash-based search for an element in a hash\n** returns:\n**\t1\t\t\tmatch found\n**\t0\t\t\tno match\n*/\n", "func_signal": "int\nlibtar_hash_getkey(libtar_hash_t *h,\n\t\t\t      libtar_hashptr_t *hp, void *key,\n\t\t\t      libtar_matchfunc_t matchfunc)", "code": "{\n#ifdef DS_DEBUG\n\tprintf(\"==> libtar_hash_getkey(h=0x%lx, hp={%d,0x%lx}, \"\n\t       \"key=0x%lx, matchfunc=0x%lx)\\n\",\n\t       h, hp->bucket, hp->node, key, matchfunc);\n#endif\n\n\tif (hp->bucket == -1)\n\t{\n\t\thp->bucket = (*(h->hashfunc))(key, h->numbuckets);\n#ifdef DS_DEBUG\n\t\tprintf(\"    libtar_hash_getkey(): hp->bucket \"\n\t\t       \"set to %d\\n\", hp->bucket);\n#endif\n\t}\n\n\tif (h->table[hp->bucket] == NULL)\n\t{\n#ifdef DS_DEBUG\n\t\tprintf(\"    libtar_hash_getkey(): no list \"\n\t\t       \"for bucket %d, returning 0\\n\", hp->bucket);\n#endif\n\t\thp->bucket = -1;\n\t\treturn 0;\n\t}\n\n#ifdef DS_DEBUG\n\tprintf(\"<== libtar_hash_getkey(): \"\n\t       \"returning libtar_list_search()\\n\");\n#endif\n\treturn libtar_list_search(h->table[hp->bucket], &(hp->node),\n\t\t\t\t\t     key, matchfunc);\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* block device */\n", "func_signal": "int\ntar_extract_blockdev(TAR *t, char *realname)", "code": "{\n#ifndef _WIN32\n\tmode_t mode;\n\tunsigned long devmaj, devmin;\n\tchar *filename;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISBLK(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\tmode = th_get_mode(t);\n\tdevmaj = th_get_devmajor(t);\n\tdevmin = th_get_devminor(t);\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (block device %ld,%ld)\\n\",\n\t       filename, devmaj, devmin);\n#endif\n\tif (mknod(filename, mode | S_IFBLK,\n\t\t  compat_makedev(devmaj, devmin)) == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"mknod()\");\n#endif\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n\tif (!realname) free(filename);\n#endif\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* FIFO */\n", "func_signal": "int\ntar_extract_fifo(TAR *t, char *realname)", "code": "{\n\tmode_t mode;\n\tchar *filename;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISFIFO(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\tmode = th_get_mode(t);\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (fifo)\\n\", filename);\n#endif\n\tif (mkfifo(filename, mode) == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"mkfifo()\");\n#endif\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n\tif (!realname) free(filename);\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_empty() - empty the hash\n*/\n", "func_signal": "void\nlibtar_hash_empty(libtar_hash_t *h, libtar_freefunc_t freefunc)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < h->numbuckets; i++)\n\t\tif (h->table[i] != NULL)\n\t\t\tlibtar_list_empty(h->table[i], freefunc);\n\n\th->nents = 0;\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_add() - add an element to the hash\n** returns:\n**\t0\t\t\tsuccess\n**\t-1 (and sets errno)\tfailure\n*/\n", "func_signal": "int\nlibtar_hash_add(libtar_hash_t *h, void *data)", "code": "{\n\tint bucket, i;\n\n#ifdef DS_DEBUG\n\tprintf(\"==> libtar_hash_add(h=0x%lx, data=0x%lx)\\n\",\n\t       h, data);\n#endif\n\n\tbucket = (*(h->hashfunc))(data, h->numbuckets);\n#ifdef DS_DEBUG\n\tprintf(\"    libtar_hash_add(): inserting in bucket %d\\n\",\n\t       bucket);\n#endif\n\tif (h->table[bucket] == NULL)\n\t{\n#ifdef DS_DEBUG\n\t\tprintf(\"    libtar_hash_add(): creating new list\\n\");\n#endif\n\t\th->table[bucket] = libtar_list_new(LIST_QUEUE, NULL);\n\t}\n\n#ifdef DS_DEBUG\n\tprintf(\"<== libtar_hash_add(): \"\n\t       \"returning libtar_list_add()\\n\");\n#endif\n\ti = libtar_list_add(h->table[bucket], data);\n\tif (i == 0)\n\t\th->nents++;\n\treturn i;\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* wrapper function for th_read_internal() to handle GNU extensions */\n", "func_signal": "int\nth_read(TAR *t)", "code": "{\n\tint i, j;\n\tsize_t sz;\n\tchar *ptr;\n\n#ifdef DEBUG\n\tprintf(\"==> th_read(t=0x%lx)\\n\", t);\n#endif\n\n\tif (t->th_buf.gnu_longname != NULL)\n\t\tfree(t->th_buf.gnu_longname);\n\tif (t->th_buf.gnu_longlink != NULL)\n\t\tfree(t->th_buf.gnu_longlink);\n\tmemset(&(t->th_buf), 0, sizeof(struct tar_header));\n\n\ti = th_read_internal(t);\n\tif (i == 0)\n\t\treturn 1;\n\telse if (i != T_BLOCKSIZE)\n\t{\n\t\tif (i != -1)\n\t\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* check for GNU long link extention */\n\tif (TH_ISLONGLINK(t))\n\t{\n\t\tsz = th_get_size(t);\n\t\tj = (sz / T_BLOCKSIZE) + (sz % T_BLOCKSIZE ? 1 : 0);\n#ifdef DEBUG\n\t\tprintf(\"    th_read(): GNU long linkname detected \"\n\t\t       \"(%ld bytes, %d blocks)\\n\", sz, j);\n#endif\n\t\tt->th_buf.gnu_longlink = (char *)malloc(j * T_BLOCKSIZE);\n\t\tif (t->th_buf.gnu_longlink == NULL)\n\t\t\treturn -1;\n\n\t\tfor (ptr = t->th_buf.gnu_longlink; j > 0;\n\t\t     j--, ptr += T_BLOCKSIZE)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"    th_read(): reading long linkname \"\n\t\t\t       \"(%d blocks left, ptr == %ld)\\n\", j, ptr);\n#endif\n\t\t\ti = tar_block_read(t, ptr);\n\t\t\tif (i != T_BLOCKSIZE)\n\t\t\t{\n\t\t\t\tif (i != -1)\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n#ifdef DEBUG\n\t\t\tprintf(\"    th_read(): read block == \\\"%s\\\"\\n\", ptr);\n#endif\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"    th_read(): t->th_buf.gnu_longlink == \\\"%s\\\"\\n\",\n\t\t       t->th_buf.gnu_longlink);\n#endif\n\n\t\ti = th_read_internal(t);\n\t\tif (i != T_BLOCKSIZE)\n\t\t{\n\t\t\tif (i != -1)\n\t\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* check for GNU long name extention */\n\tif (TH_ISLONGNAME(t))\n\t{\n\t\tsz = th_get_size(t);\n\t\tj = (sz / T_BLOCKSIZE) + (sz % T_BLOCKSIZE ? 1 : 0);\n#ifdef DEBUG\n\t\tprintf(\"    th_read(): GNU long filename detected \"\n\t\t       \"(%ld bytes, %d blocks)\\n\", sz, j);\n#endif\n\t\tt->th_buf.gnu_longname = (char *)malloc(j * T_BLOCKSIZE);\n\t\tif (t->th_buf.gnu_longname == NULL)\n\t\t\treturn -1;\n\n\t\tfor (ptr = t->th_buf.gnu_longname; j > 0;\n\t\t     j--, ptr += T_BLOCKSIZE)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"    th_read(): reading long filename \"\n\t\t\t       \"(%d blocks left, ptr == %ld)\\n\", j, ptr);\n#endif\n\t\t\ti = tar_block_read(t, ptr);\n\t\t\tif (i != T_BLOCKSIZE)\n\t\t\t{\n\t\t\t\tif (i != -1)\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n#ifdef DEBUG\n\t\t\tprintf(\"    th_read(): read block == \\\"%s\\\"\\n\", ptr);\n#endif\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"    th_read(): t->th_buf.gnu_longname == \\\"%s\\\"\\n\",\n\t\t       t->th_buf.gnu_longname);\n#endif\n\n\t\ti = th_read_internal(t);\n\t\tif (i != T_BLOCKSIZE)\n\t\t{\n\t\t\tif (i != -1)\n\t\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n#if 0\n\t/*\n\t** work-around for old archive files with broken typeflag fields\n\t** NOTE: I fixed this in the TH_IS*() macros instead\n\t*/\n\n\t/*\n\t** (directories are signified with a trailing '/')\n\t*/\n\tif (t->th_buf.typeflag == AREGTYPE\n\t    && t->th_buf.name[strlen(t->th_buf.name) - 1] == '/')\n\t\tt->th_buf.typeflag = DIRTYPE;\n\n\t/*\n\t** fallback to using mode bits\n\t*/\n\tif (t->th_buf.typeflag == AREGTYPE)\n\t{\n\t\tmode = (mode_t)oct_to_int(t->th_buf.mode);\n\n\t\tif (S_ISREG(mode))\n\t\t\tt->th_buf.typeflag = REGTYPE;\n\t\telse if (S_ISDIR(mode))\n\t\t\tt->th_buf.typeflag = DIRTYPE;\n\t\telse if (S_ISFIFO(mode))\n\t\t\tt->th_buf.typeflag = FIFOTYPE;\n\t\telse if (S_ISCHR(mode))\n\t\t\tt->th_buf.typeflag = CHRTYPE;\n\t\telse if (S_ISBLK(mode))\n\t\t\tt->th_buf.typeflag = BLKTYPE;\n\t\telse if (S_ISLNK(mode))\n\t\t\tt->th_buf.typeflag = SYMTYPE;\n\t}\n#endif\n\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\block.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */\n", "func_signal": "static void fmtint (char *buffer, size_t *currlen, size_t maxlen,\n\t\t    long value, int base, int min, int max, int flags)", "code": "{\n  int signvalue = 0;\n  unsigned long uvalue;\n  char convert[20];\n  int place = 0;\n  int spadlen = 0; /* amount to space pad */\n  int zpadlen = 0; /* amount to zero pad */\n  int caps = 0;\n  \n  if (max < 0)\n    max = 0;\n\n  uvalue = value;\n\n  if(!(flags & DP_F_UNSIGNED))\n  {\n    if( value < 0 ) {\n      signvalue = '-';\n      uvalue = -value;\n    }\n    else\n      if (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\tsignvalue = '+';\n    else\n      if (flags & DP_F_SPACE)\n\tsignvalue = ' ';\n  }\n  \n  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n  do {\n    convert[place++] =\n      (caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n      [uvalue % (unsigned)base  ];\n    uvalue = (uvalue / (unsigned)base );\n  } while(uvalue && (place < 20));\n  if (place == 20) place--;\n  convert[place] = 0;\n\n  zpadlen = max - place;\n  spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n  if (zpadlen < 0) zpadlen = 0;\n  if (spadlen < 0) spadlen = 0;\n  if (flags & DP_F_ZERO)\n  {\n    zpadlen = MAX(zpadlen, spadlen);\n    spadlen = 0;\n  }\n  if (flags & DP_F_MINUS) \n    spadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n  dprint (1, (debugfile, \"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n      zpadlen, spadlen, min, max, place));\n#endif\n\n  /* Spaces */\n  while (spadlen > 0) \n  {\n    dopr_outch (buffer, currlen, maxlen, ' ');\n    --spadlen;\n  }\n\n  /* Sign */\n  if (signvalue) \n    dopr_outch (buffer, currlen, maxlen, signvalue);\n\n  /* Zeros */\n  if (zpadlen > 0) \n  {\n    while (zpadlen > 0)\n    {\n      dopr_outch (buffer, currlen, maxlen, '0');\n      --zpadlen;\n    }\n  }\n\n  /* Digits */\n  while (place > 0) \n    dopr_outch (buffer, currlen, maxlen, convert[--place]);\n  \n  /* Left Justified spaces */\n  while (spadlen < 0) {\n    dopr_outch (buffer, currlen, maxlen, ' ');\n    ++spadlen;\n  }\n}", "path": "ext\\libtar\\compat\\snprintf.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* character device */\n", "func_signal": "int\ntar_extract_chardev(TAR *t, char *realname)", "code": "{\n\tmode_t mode;\n\tunsigned long devmaj, devmin;\n\tchar *filename;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISCHR(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\tmode = th_get_mode(t);\n\tdevmaj = th_get_devmajor(t);\n\tdevmin = th_get_devminor(t);\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (character device %ld,%ld)\\n\",\n\t       filename, devmaj, devmin);\n#endif\n\tif (mknod(filename, mode | S_IFCHR,\n\t\t  compat_makedev(devmaj, devmin)) == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"mknod()\");\n#endif\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n\tif (!realname) free(filename);\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_del() - delete an entry from the hash\n** returns:\n**\t0\t\t\tsuccess\n**\t-1 (and sets errno)\tfailure\n*/\n", "func_signal": "int\nlibtar_hash_del(libtar_hash_t *h,\n\t\t\t   libtar_hashptr_t *hp)", "code": "{\n\tif (hp->bucket < 0\n\t    || hp->bucket >= h->numbuckets\n\t    || h->table[hp->bucket] == NULL\n\t    || hp->node == NULL)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tlibtar_list_del(h->table[hp->bucket], &(hp->node));\n\th->nents--;\n\treturn 0;\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_str_hashfunc() - default hash function, optimized for\n**\t\t\t\t      7-bit strings\n*/\n", "func_signal": "unsigned int\nlibtar_str_hashfunc(char *key, unsigned int num_buckets)", "code": "{\n#if 0\n\tregister unsigned result = 0;\n\tregister int i;\n\n\tif (key == NULL)\n\t\treturn 0;\n\n\tfor (i = 0; *key != '\\0' && i < 32; i++)\n\t\tresult = result * 33U + *key++;\n\n\treturn (result % num_buckets);\n#else\n\tif (key == NULL)\n\t\treturn 0;\n\n\treturn (key[0] % num_buckets);\n#endif\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_search() - iterative search for an element in a hash\n** returns:\n**\t1\t\t\tmatch found\n**\t0\t\t\tno match\n*/\n", "func_signal": "int\nlibtar_hash_search(libtar_hash_t *h,\n\t\t\t      libtar_hashptr_t *hp, void *data,\n\t\t\t      libtar_matchfunc_t matchfunc)", "code": "{\n\twhile (libtar_hash_next(h, hp) != 0)\n\t\tif ((*matchfunc)(data, libtar_listptr_data(&(hp->node))) != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* read a header block */\n", "func_signal": "int\nth_read_internal(TAR *t)", "code": "{\n\tint i;\n\tint num_zero_blocks = 0;\n\n#ifdef DEBUG\n\tprintf(\"==> th_read_internal(TAR=\\\"%s\\\")\\n\", t->pathname);\n#endif\n\n\twhile ((i = tar_block_read(t, &(t->th_buf))) == T_BLOCKSIZE)\n\t{\n\t\t/* two all-zero blocks mark EOF */\n\t\tif (t->th_buf.name[0] == '\\0')\n\t\t{\n\t\t\tnum_zero_blocks++;\n\t\t\tif (!BIT_ISSET(t->options, TAR_IGNORE_EOT)\n\t\t\t    && num_zero_blocks >= 2)\n\t\t\t\treturn 0;\t/* EOF */\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* verify magic and version */\n\t\tif (BIT_ISSET(t->options, TAR_CHECK_MAGIC)\n\t\t    && strncmp(t->th_buf.magic, TMAGIC, TMAGLEN - 1) != 0)\n\t\t{\n#ifdef DEBUG\n\t\t\tputs(\"!!! unknown magic value in tar header\");\n#endif\n\t\t\treturn -2;\n\t\t}\n\n\t\tif (BIT_ISSET(t->options, TAR_CHECK_VERSION)\n\t\t    && strncmp(t->th_buf.version, TVERSION, TVERSLEN) != 0)\n\t\t{\n#ifdef DEBUG\n\t\t\tputs(\"!!! unknown version value in tar header\");\n#endif\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* check chksum */\n\t\tif (!BIT_ISSET(t->options, TAR_IGNORE_CRC)\n\t\t    && !th_crc_ok(t))\n\t\t{\n#ifdef DEBUG\n\t\t\tputs(\"!!! tar header checksum error\");\n#endif\n\t\t\treturn -2;\n\t\t}\n\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"<== th_read_internal(): returning %d\\n\", i);\n#endif\n\treturn i;\n}", "path": "ext\\libtar\\lib\\block.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* hardlink */\n", "func_signal": "int\ntar_extract_hardlink(TAR * t, char *realname)", "code": "{\n#ifndef _WIN32\n\tchar *filename;\n\tchar *linktgt = NULL;\n\tlinkname_t *lnp;\n\tlibtar_hashptr_t hp;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISLNK(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\tlibtar_hashptr_reset(&hp);\n\tif (libtar_hash_getkey(t->h, &hp, th_get_linkname(t),\n\t\t\t       (libtar_matchfunc_t)libtar_str_match) != 0)\n\t{\n\t\tlnp = (linkname_t *)libtar_hashptr_data(&hp);\n\t\tlinktgt = lnp->ln_real;\n\t}\n\telse\n\t\tlinktgt = th_get_linkname(t);\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (link to %s)\\n\", filename, linktgt);\n#endif\n\tif (link(linktgt, filename) == -1)\n\t{\n#ifdef DEBUG\n\t\tperror(\"link()\");\n#endif\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n\tif (!realname) free(filename);\n#endif\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hashptr_reset() - reset a hash pointer\n*/\n", "func_signal": "void\nlibtar_hashptr_reset(libtar_hashptr_t *hp)", "code": "{\n\tlibtar_listptr_reset(&(hp->node));\n\thp->bucket = -1;\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/* directory */\n", "func_signal": "int\ntar_extract_dir(TAR *t, char *realname)", "code": "{\n\tmode_t mode;\n\tchar *filename;\n\tchar buf[T_BLOCKSIZE];\n\n\tif (!TH_ISDIR(t))\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfilename = (realname ? realname : th_get_pathname(t));\n\tmode = th_get_mode(t);\n\n\t/* Make a copy of the string because dirname and mkdirhier may modify the\n\t * string */\n\tstrncpy(buf, filename, sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif (mkdirhier(dirname(filename)) == -1){\n\t\tif (!realname) free(filename);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"  ==> extracting: %s (mode %04o, directory)\\n\", filename,\n\t       mode);\n#endif\n\tif (mkdir(filename, mode) == -1)\n\t{\n\t\tif (errno == EEXIST)\n\t\t{\n\t\t\tif (chmod(filename, mode) == -1)\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tperror(\"chmod()\");\n#endif\n\t\t\t\tif (!realname) free(filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tputs(\"  *** using existing directory\");\n#endif\n\t\t\t\tif (!realname) free(filename);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef DEBUG\n\t\t\tperror(\"mkdir()\");\n#endif\n\t\t\tif (!realname) free(filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!realname) free(filename);\n\treturn 0;\n}", "path": "ext\\libtar\\lib\\extract.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** find the last occurrance of find in string\n*/\n", "func_signal": "char *\nstrrstr(char *string, char *find)", "code": "{\n\tsize_t stringlen, findlen;\n\tchar *cp;\n\n\tfindlen = strlen(find);\n\tstringlen = strlen(string);\n\tif (findlen > stringlen)\n\t\treturn NULL;\n\n\tfor (cp = string + stringlen - findlen; cp >= string; cp--)\n\t\tif (strncmp(cp, find, findlen) == 0)\n\t\t\treturn cp;\n\n\treturn NULL;\n}", "path": "ext\\libtar\\compat\\strrstr.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n** libtar_hash_free() - delete all of the nodes in the hash\n*/\n", "func_signal": "void\nlibtar_hash_free(libtar_hash_t *h, libtar_freefunc_t freefunc)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < h->numbuckets; i++)\n\t\tif (h->table[i] != NULL)\n\t\t\tlibtar_list_free(h->table[i], freefunc);\n\n\tfree(h->table);\n\tfree(h);\n}", "path": "ext\\libtar\\win32\\listhash\\libtar_hash.c", "repo_name": "jasherai/tarruby", "stars": 2, "license": "None", "language": "c", "size": 504}
{"docstring": "/*\n * call-seq:\n *    XML::Dtd.new(\"DTD string\") -> dtd\n *    XML::Dtd.new(\"public\", \"system\") -> dtd\n *    XML::Dtd.new(\"name\", \"public\", \"system\", document) -> external subset dtd\n *    XML::Dtd.new(\"name\", \"public\", \"system\", document, false) -> internal subset dtd\n *    XML::Dtd.new(\"name\", \"public\", \"system\", document, true) -> internal subset dtd\n *\n * Create a new Dtd from the specified public and system\n * identifiers.\n */\n", "func_signal": "static VALUE rxml_dtd_initialize(int argc, VALUE *argv, VALUE self)", "code": "{\n  VALUE external, system, dtd_string;\n  xmlParserInputBufferPtr buffer;\n  xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n  xmlChar *new_string;\n  xmlDtdPtr xdtd;\n\n  // 1 argument -- string                            --> parsujeme jako dtd\n  // 2 arguments -- public, system                   --> bude se hledat\n  // 3 arguments -- public, system, name             --> creates an external subset (any parameter may be nil)\n  // 4 arguments -- public, system, name, doc        --> creates an external subset (any parameter may be nil)\n  // 5 arguments -- public, system, name, doc, true  --> creates an internal subset (all but last parameter may be nil)\n  switch (argc)\n  {\n  case 3:\n  case 4:\n  case 5: {\n      VALUE name, doc, internal;\n      const xmlChar *xname = NULL, *xpublic = NULL, *xsystem = NULL;\n      xmlDocPtr xdoc = NULL;\n\n      rb_scan_args(argc, argv, \"32\", &external, &system, &name, &doc, &internal);\n\n      if (external != Qnil) {\n        Check_Type(external, T_STRING);\n        xpublic = (const xmlChar*) StringValuePtr(external);\n      }\n      if (system != Qnil) {\n        Check_Type(system, T_STRING);\n        xsystem = (const xmlChar*) StringValuePtr(system);\n      }\n      if (name != Qnil) {\n        Check_Type(name, T_STRING);\n        xname = (const xmlChar*) StringValuePtr(name);\n      }\n      if (doc != Qnil) {\n        if (rb_obj_is_kind_of(doc, cXMLDocument) == Qfalse)\n          rb_raise(rb_eTypeError, \"Must pass an XML::Document object\");\n        Data_Get_Struct(doc, xmlDoc, xdoc);\n      }\n\n      if (internal == Qnil || internal == Qfalse)\n        xdtd = xmlNewDtd(xdoc, xname, xpublic, xsystem);\n      else\n        xdtd = xmlCreateIntSubset(xdoc, xname, xpublic, xsystem);\n\n      if (xdtd == NULL)\n        rxml_raise(&xmlLastError);\n\n      /* Document will free this dtd now. */\n      RDATA(self)->dfree = NULL;\n      DATA_PTR(self) = xdtd;\n\n      xmlSetTreeDoc((xmlNodePtr) xdtd, xdoc);\n    }\n    break;\n\n  case 2:\n    rb_scan_args(argc, argv, \"20\", &external, &system);\n\n    Check_Type(external, T_STRING);\n    Check_Type(system, T_STRING);\n\n    xdtd = xmlParseDTD((xmlChar*) StringValuePtr(external),\n        (xmlChar*) StringValuePtr(system));\n\n    if (xdtd == NULL)\n      rxml_raise(&xmlLastError);\n\n    DATA_PTR(self) = xdtd;\n\n    xmlSetTreeDoc((xmlNodePtr) xdtd, NULL);\n    break;\n\n  case 1:\n    rb_scan_args(argc, argv, \"10\", &dtd_string);\n    Check_Type(dtd_string, T_STRING);\n\n    /* Note that buffer is freed by xmlParserInputBufferPush*/\n    buffer = xmlAllocParserInputBuffer(enc);\n    new_string = xmlStrdup((xmlChar*) StringValuePtr(dtd_string));\n    xmlParserInputBufferPush(buffer, xmlStrlen(new_string),\n        (const char*) new_string);\n\n    xdtd = xmlIOParseDTD(NULL, buffer, enc);\n\n    if (xdtd == NULL)\n      rxml_raise(&xmlLastError);\n\n    xmlFree(new_string);\n\n    DATA_PTR(self) = xdtd;\n    break;\n\n  default:\n    rb_raise(rb_eArgError, \"wrong number of arguments\");\n  }\n\n  return self;\n}", "path": "ext\\libxml\\ruby_xml_dtd.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::Schema.string(\"schema_data\") -> \"value\"\n *\n * Create a new schema using the specified string.\n */\n", "func_signal": "static VALUE rxml_schema_init_from_string(VALUE self, VALUE schema_str)", "code": "{\n  xmlSchemaParserCtxtPtr xparser;\n  xmlSchemaPtr xschema;\n\n  Check_Type(schema_str, T_STRING);\n\n  xparser = xmlSchemaNewMemParserCtxt(StringValuePtr(schema_str), strlen(\n      StringValuePtr(schema_str)));\n  xschema = xmlSchemaParse(xparser);\n  xmlSchemaFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);\n}", "path": "ext\\libxml\\ruby_xml_schema.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.empty? -> (true|false)\n *\n * Determine whether this nodeset is empty (contains no nodes).\n */\n", "func_signal": "static VALUE rxml_xpath_object_empty_q(VALUE self)", "code": "{\n  rxml_xpath_object *rxpop;\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n\n  if (rxpop->xpop->type != XPATH_NODESET)\n    return Qnil;\n\n  return (rxpop->xpop->nodesetval == NULL || rxpop->xpop->nodesetval->nodeNr <= 0) ? Qtrue\n      : Qfalse;\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::RelaxNG.document(document) -> relaxng\n *\n * Create a new relaxng from the specified document.\n */\n", "func_signal": "static VALUE rxml_relaxng_init_from_document(VALUE class, VALUE document)", "code": "{\n  xmlDocPtr xdoc;\n  xmlRelaxNGPtr xrelaxng;\n  xmlRelaxNGParserCtxtPtr xparser;\n\n  Data_Get_Struct(document, xmlDoc, xdoc);\n\n  xparser = xmlRelaxNGNewDocParserCtxt(xdoc);\n  xrelaxng = xmlRelaxNGParse(xparser);\n  xmlRelaxNGFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);\n}", "path": "ext\\libxml\\ruby_xml_relaxng.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/* Custom free function for copied namespace nodes */\n", "func_signal": "static void rxml_namespace_xpath_free(xmlNsPtr xns)", "code": "{\n  xns->_private = NULL;\n  xmlFreeNs(xns);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    dtd.uri -> \"string\"\n *\n * Obtain this dtd's URI (for a SYSTEM or PUBLIC DTD).\n */\n", "func_signal": "static VALUE rxml_dtd_uri_get(VALUE self)", "code": "{\n  xmlDtdPtr xdtd;\n  Data_Get_Struct(self, xmlDtd, xdtd);\n\n\n  if (xdtd->SystemID == NULL)\n    return (Qnil);\n  else\n    return (rb_str_new2((const char*) xdtd->SystemID));\n}", "path": "ext\\libxml\\ruby_xml_dtd.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::Relaxng.new(relaxng_uri) -> relaxng\n *\n * Create a new relaxng from the specified URI.\n */\n", "func_signal": "static VALUE rxml_relaxng_init_from_uri(VALUE class, VALUE uri)", "code": "{\n  xmlRelaxNGParserCtxtPtr xparser;\n  xmlRelaxNGPtr xrelaxng;\n\n  Check_Type(uri, T_STRING);\n\n  xparser = xmlRelaxNGNewParserCtxt(StringValuePtr(uri));\n  xrelaxng = xmlRelaxNGParse(xparser);\n  xmlRelaxNGFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);\n}", "path": "ext\\libxml\\ruby_xml_relaxng.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::Schema.document(document) -> schema\n *\n * Create a new schema from the specified document.\n */\n", "func_signal": "static VALUE rxml_schema_init_from_document(VALUE class, VALUE document)", "code": "{\n  xmlDocPtr xdoc;\n  xmlSchemaPtr xschema;\n  xmlSchemaParserCtxtPtr xparser;\n\n  Data_Get_Struct(document, xmlDoc, xdoc);\n\n  xparser = xmlSchemaNewDocParserCtxt(xdoc);\n  xschema = xmlSchemaParse(xparser);\n  xmlSchemaFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);\n}", "path": "ext\\libxml\\ruby_xml_schema.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    nodes.debug -> (true|false)\n *\n * Dump libxml debugging information to stdout.\n * Requires Libxml be compiled with debugging enabled.\n */\n", "func_signal": "static VALUE rxml_xpath_object_debug(VALUE self)", "code": "{\n#ifdef LIBXML_DEBUG_ENABLED\n  rxml_xpath_object *rxpop;\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  xmlXPathDebugDumpObject(stdout, rxpop->xpop, 0);\n  return Qtrue;\n#else\n  rb_warn(\"libxml was compiled without debugging support.\")\n  return Qfalse;\n#endif\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.to_a -> [node, ..., node]\n *\n * Obtain an array of the nodes in this set.\n */\n", "func_signal": "static VALUE rxml_xpath_object_to_a(VALUE self)", "code": "{\n  VALUE set_ary, nodeobj;\n  rxml_xpath_object *rxpop;\n  xmlXPathObjectPtr xpop;\n  int i;\n\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  xpop = rxpop->xpop;\n\n  set_ary = rb_ary_new();\n\n  if (!((xpop->nodesetval == NULL) || (xpop->nodesetval->nodeNr == 0)))\n  {\n    for (i = 0; i < xpop->nodesetval->nodeNr; i++)\n    {\n      nodeobj = rxml_xpath_object_tabref(xpop, i);\n      rb_ary_push(set_ary, nodeobj);\n    }\n  }\n\n  return (set_ary);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    dtd.name -> \"string\"\n *\n * Obtain this dtd's name.\n */\n", "func_signal": "static VALUE rxml_dtd_name_get(VALUE self)", "code": "{\n  xmlDtdPtr xdtd;\n  Data_Get_Struct(self, xmlDtd, xdtd);\n\n\n  if (xdtd->name == NULL)\n    return (Qnil);\n  else\n    return (rb_str_new2((const char*) xdtd->name));\n}", "path": "ext\\libxml\\ruby_xml_dtd.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::Schema.initialize(schema_uri) -> schema\n *\n * Create a new schema from the specified URI.\n */\n", "func_signal": "static VALUE rxml_schema_init_from_uri(VALUE class, VALUE uri)", "code": "{\n  xmlSchemaParserCtxtPtr xparser;\n  xmlSchemaPtr xschema;\n\n  Check_Type(uri, T_STRING);\n\n  xparser = xmlSchemaNewParserCtxt(StringValuePtr(uri));\n  xschema = xmlSchemaParse(xparser);\n  xmlSchemaFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);\n}", "path": "ext\\libxml\\ruby_xml_schema.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    dtd.external_id -> \"string\"\n *\n * Obtain this dtd's external identifer (for a PUBLIC DTD).\n */\n", "func_signal": "static VALUE rxml_dtd_external_id_get(VALUE self)", "code": "{\n  xmlDtdPtr xdtd;\n  Data_Get_Struct(self, xmlDtd, xdtd);\n\n\n  if (xdtd->ExternalID == NULL)\n    return (Qnil);\n  else\n    return (rb_str_new2((const char*) xdtd->ExternalID));\n}", "path": "ext\\libxml\\ruby_xml_dtd.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.first -> node\n *\n * Returns the first node in this node set, or nil if none exist.\n */\n", "func_signal": "static VALUE rxml_xpath_object_first(VALUE self)", "code": "{\n  rxml_xpath_object *rxpop;\n\n  if (rxml_xpath_object_empty_q(self) == Qtrue)\n    return Qnil;\n\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  return rxml_xpath_object_tabref(rxpop->xpop, 0);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n * xpath_object[i] -> node\n *\n * array index into set of nodes\n */\n", "func_signal": "static VALUE rxml_xpath_object_aref(VALUE self, VALUE aref)", "code": "{\n  rxml_xpath_object *rxpop;\n\n  if (rxml_xpath_object_empty_q(self) == Qtrue)\n    return Qnil;\n\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  return rxml_xpath_object_tabref(rxpop->xpop, NUM2INT(aref));\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/* Memory management of xpath results is tricky.  If a nodeset is\n   returned, it generally consists of pointers to nodes in the \n   original document.  However, namespace nodes are handled differently - \n   libxml creates copies of them instead.  Thus, when an xmlXPathObjectPtr\n   is freed, libxml iterates over the results to find the copied namespace \n   nodes to free them.\n\n   This causes problems for the bindings because the underlying document\n   may be freed before the xmlXPathObjectPtr instance.  This might seem\n   counterintuitive since the xmlXPathObjectPtr marks the document.\n   However, once both objects go out of scope, the order of their \n   destruction is random.\n\n   To deal with this, the wrapper code searches for the namespace nodes\n   and wraps them in Ruby objects.  When the Ruby objects go out of scope\n   then the namespace nodes are freed. */\n", "func_signal": "static void rxml_xpath_object_free(rxml_xpath_object *rxpop)", "code": "{\n  /* We positively, absolutely cannot let libxml iterate over\n     the nodeTab since if the underlying document has been\n     freed the majority of entries are invalid, resulting in\n     segmentation faults.*/\n  if (rxpop->xpop->nodesetval && rxpop->xpop->nodesetval->nodeTab)\n  {\n    xmlFree(rxpop->xpop->nodesetval->nodeTab);\n    rxpop->xpop->nodesetval->nodeTab = NULL;\n  }\n  xmlXPathFreeObject(rxpop->xpop);\n  xfree(rxpop);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.xpath_type -> int\n *\n * Returns the XPath type of the result object.\n * Possible values are defined as constants\n * on the XML::XPath class and include:\n *\n * * XML::XPath::UNDEFINED\n * * XML::XPath::NODESET\n * * XML::XPath::BOOLEAN\n * * XML::XPath::NUMBER\n * * XML::XPath::STRING\n * * XML::XPath::POINT\n * * XML::XPath::RANGE\n * * XML::XPath::LOCATIONSET\n * * XML::XPath::USERS\n * * XML::XPath::XSLT_TREE\n */\n", "func_signal": "static VALUE rxml_xpath_object_get_type(VALUE self)", "code": "{\n  rxml_xpath_object *rxpop;\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  return INT2FIX(rxpop->xpop->type);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.length -> num\n *\n * Obtain the length of the nodesetval node list.\n */\n", "func_signal": "static VALUE rxml_xpath_object_length(VALUE self)", "code": "{\n  rxml_xpath_object *rxpop;\n\n  if (rxml_xpath_object_empty_q(self) == Qtrue)\n    return INT2FIX(0);\n\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n  return INT2NUM(rxpop->xpop->nodesetval->nodeNr);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    XML::RelaxNG.string(\"relaxng_data\") -> \"value\"\n *\n * Create a new relaxng using the specified string.\n */\n", "func_signal": "static VALUE rxml_relaxng_init_from_string(VALUE self, VALUE relaxng_str)", "code": "{\n  xmlRelaxNGParserCtxtPtr xparser;\n  xmlRelaxNGPtr xrelaxng;\n\n  Check_Type(relaxng_str, T_STRING);\n\n  xparser = xmlRelaxNGNewMemParserCtxt(StringValuePtr(relaxng_str), strlen(\n      StringValuePtr(relaxng_str)));\n  xrelaxng = xmlRelaxNGParse(xparser);\n  xmlRelaxNGFreeParserCtxt(xparser);\n\n  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);\n}", "path": "ext\\libxml\\ruby_xml_relaxng.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*\n * call-seq:\n *    xpath_object.string -> String\n *\n * Returns the original XPath expression as a string.\n */\n", "func_signal": "static VALUE rxml_xpath_object_string(VALUE self)", "code": "{\n  rxml_xpath_object *rxpop;\n\n  Data_Get_Struct(self, rxml_xpath_object, rxpop);\n\n  if (rxpop->xpop->stringval == NULL)\n    return Qnil;\n\n  return rb_str_new2((const char*) rxpop->xpop->stringval);\n}", "path": "ext\\libxml\\ruby_xml_xpath_object.c", "repo_name": "tadman/libxml-ruby", "stars": 2, "license": "mit", "language": "c", "size": 1556}
{"docstring": "/*NUMPY_API\n  Get pointer to one of correct type for array\n*/\n", "func_signal": "NPY_NO_EXPORT char *\nPyArray_One(PyArrayObject *arr)", "code": "{\n    char *oneval;\n    int ret, storeflags;\n    PyObject *obj;\n\n    if (_check_object_rec(arr->descr) < 0) {\n        return NULL;\n    }\n    oneval = PyDataMem_NEW(arr->descr->elsize);\n    if (oneval == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    obj = PyInt_FromLong((long) 1);\n    if (PyArray_ISOBJECT(arr)) {\n        memcpy(oneval, &obj, sizeof(PyObject *));\n        Py_DECREF(obj);\n        return oneval;\n    }\n\n    storeflags = arr->flags;\n    arr->flags |= BEHAVED;\n    ret = arr->descr->f->setitem(obj, oneval, arr);\n    arr->flags = storeflags;\n    Py_DECREF(obj);\n    if (ret < 0) {\n        PyDataMem_FREE(oneval);\n        return NULL;\n    }\n    return oneval;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/* Backward compatibility only */\n/* In both Zero and One\n\n***You must free the memory once you are done with it\nusing PyDataMem_FREE(ptr) or you create a memory leak***\n\nIf arr is an Object array you are getting a\nBORROWED reference to Zero or One.\nDo not DECREF.\nPlease INCREF if you will be hanging on to it.\n\nThe memory for the ptr still must be freed in any case;\n*/\n", "func_signal": "static int\n_check_object_rec(PyArray_Descr *descr)", "code": "{\n    if (PyDataType_HASFIELDS(descr) && PyDataType_REFCHK(descr)) {\n        PyErr_SetString(PyExc_TypeError, \"Not supported for this data-type.\");\n        return -1;\n    }\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n *\n * Get New ArrayFlagsObject\n */\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_NewFlagsObject(PyObject *obj)", "code": "{\n    PyObject *flagobj;\n    int flags;\n    if (obj == NULL) {\n        flags = CONTIGUOUS | OWNDATA | FORTRAN | ALIGNED;\n    }\n    else {\n        flags = PyArray_FLAGS(obj);\n    }\n    flagobj = PyArrayFlags_Type.tp_alloc(&PyArrayFlags_Type, 0);\n    if (flagobj == NULL) {\n        return NULL;\n    }\n    Py_XINCREF(obj);\n    ((PyArrayFlagsObject *)flagobj)->arr = obj;\n    ((PyArrayFlagsObject *)flagobj)->flags = flags;\n    return flagobj;\n}", "path": "numpy\\core\\src\\multiarray\\flagsobject.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * Ensure that any exponent, if present, is at least MIN_EXPONENT_DIGITS\n * in length.\n */\n", "func_signal": "static void\n_ensure_minimum_exponent_length(char* buffer, size_t buf_size)", "code": "{\n    char *p = strpbrk(buffer, \"eE\");\n    if (p && (*(p + 1) == '-' || *(p + 1) == '+')) {\n        char *start = p + 2;\n        int exponent_digit_cnt = 0;\n        int leading_zero_cnt = 0;\n        int in_leading_zeros = 1;\n        int significant_digit_cnt;\n\n        /* Skip over the exponent and the sign. */\n        p += 2;\n\n        /* Find the end of the exponent, keeping track of leading zeros. */\n        while (*p && isdigit(Py_CHARMASK(*p))) {\n            if (in_leading_zeros && *p == '0') {\n                ++leading_zero_cnt;\n            }\n            if (*p != '0') {\n                in_leading_zeros = 0;\n            }\n            ++p;\n            ++exponent_digit_cnt;\n        }\n\n        significant_digit_cnt = exponent_digit_cnt - leading_zero_cnt;\n        if (exponent_digit_cnt == MIN_EXPONENT_DIGITS) {\n            /*\n             * If there are 2 exactly digits, we're done,\n             * regardless of what they contain\n             */\n        }\n        else if (exponent_digit_cnt > MIN_EXPONENT_DIGITS) {\n            int extra_zeros_cnt;\n\n            /*\n             * There are more than 2 digits in the exponent.  See\n             * if we can delete some of the leading zeros\n             */\n            if (significant_digit_cnt < MIN_EXPONENT_DIGITS) {\n                significant_digit_cnt = MIN_EXPONENT_DIGITS;\n            }\n            extra_zeros_cnt = exponent_digit_cnt - significant_digit_cnt;\n\n            /*\n             * Delete extra_zeros_cnt worth of characters from the\n             * front of the exponent\n             */\n            assert(extra_zeros_cnt >= 0);\n\n            /*\n             * Add one to significant_digit_cnt to copy the\n             * trailing 0 byte, thus setting the length\n             */\n            memmove(start, start + extra_zeros_cnt, significant_digit_cnt + 1);\n        }\n        else {\n            /*\n             * If there are fewer than 2 digits, add zeros\n             * until there are 2, if there's enough room\n             */\n            int zeros = MIN_EXPONENT_DIGITS - exponent_digit_cnt;\n            if (start + zeros + exponent_digit_cnt + 1 < buffer + buf_size) {\n                memmove(start + zeros, start, exponent_digit_cnt + 1);\n                memset(start, '0', zeros);\n            }\n        }\n    }\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/* 0-strided arrays are not contiguous (even if dimension == 1) */\n", "func_signal": "static int\n_IsFortranContiguous(PyArrayObject *ap)", "code": "{\n    intp sd;\n    intp dim;\n    int i;\n\n    if (ap->nd == 0) {\n        return 1;\n    }\n    sd = ap->descr->elsize;\n    if (ap->nd == 1) {\n        return ap->dimensions[0] == 1 || sd == ap->strides[0];\n    }\n    for (i = 0; i < ap->nd; ++i) {\n        dim = ap->dimensions[i];\n        /* fortran contiguous by definition */\n        if (dim == 0) {\n            return 1;\n        }\n        if (ap->strides[i] != sd) {\n            return 0;\n        }\n        sd *= dim;\n    }\n    return 1;\n}", "path": "numpy\\core\\src\\multiarray\\flagsobject.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n * Cast to an already created array.  Arrays don't have to be \"broadcastable\"\n * Only requirement is they have the same number of elements.\n */\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_CastAnyTo(PyArrayObject *out, PyArrayObject *mp)", "code": "{\n    int simple;\n    PyArray_VectorUnaryFunc *castfunc = NULL;\n    int mpsize = PyArray_SIZE(mp);\n\n    if (mpsize == 0) {\n        return 0;\n    }\n    if (!PyArray_ISWRITEABLE(out)) {\n        PyErr_SetString(PyExc_ValueError, \"output array is not writeable\");\n        return -1;\n    }\n\n    if (!(mpsize == PyArray_SIZE(out))) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"arrays must have the same number of\"\n                        \" elements for the cast.\");\n        return -1;\n    }\n\n    castfunc = PyArray_GetCastFunc(mp->descr, out->descr->type_num);\n    if (castfunc == NULL) {\n        return -1;\n    }\n    simple = ((PyArray_ISCARRAY_RO(mp) && PyArray_ISCARRAY(out)) ||\n              (PyArray_ISFARRAY_RO(mp) && PyArray_ISFARRAY(out)));\n    if (simple) {\n        castfunc(mp->data, out->data, mpsize, mp, out);\n        return 0;\n    }\n    if (PyArray_SAMESHAPE(out, mp)) {\n        int iswap, oswap;\n        iswap = PyArray_ISBYTESWAPPED(mp) && !PyArray_ISFLEXIBLE(mp);\n        oswap = PyArray_ISBYTESWAPPED(out) && !PyArray_ISFLEXIBLE(out);\n        return _broadcast_cast(out, mp, castfunc, iswap, oswap);\n    }\n    return _bufferedcast(out, mp, castfunc);\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n *Check the type coercion rules.\n */\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_CanCastSafely(int fromtype, int totype)", "code": "{\n    PyArray_Descr *from, *to;\n    int felsize, telsize;\n\n    if (fromtype == totype) {\n        return 1;\n    }\n    if (fromtype == PyArray_BOOL) {\n        return 1;\n    }\n    if (totype == PyArray_BOOL) {\n        return 0;\n    }\n    if (totype == PyArray_OBJECT || totype == PyArray_VOID) {\n        return 1;\n    }\n    if (fromtype == PyArray_OBJECT || fromtype == PyArray_VOID) {\n        return 0;\n    }\n    from = PyArray_DescrFromType(fromtype);\n    /*\n     * cancastto is a PyArray_NOTYPE terminated C-int-array of types that\n     * the data-type can be cast to safely.\n     */\n    if (from->f->cancastto) {\n        int *curtype;\n        curtype = from->f->cancastto;\n        while (*curtype != PyArray_NOTYPE) {\n            if (*curtype++ == totype) {\n                return 1;\n            }\n        }\n    }\n    if (PyTypeNum_ISUSERDEF(totype)) {\n        return 0;\n    }\n    to = PyArray_DescrFromType(totype);\n    telsize = to->elsize;\n    felsize = from->elsize;\n    Py_DECREF(from);\n    Py_DECREF(to);\n\n    switch(fromtype) {\n    case PyArray_BYTE:\n    case PyArray_SHORT:\n    case PyArray_INT:\n    case PyArray_LONG:\n    case PyArray_LONGLONG:\n        if (PyTypeNum_ISINTEGER(totype)) {\n            if (PyTypeNum_ISUNSIGNED(totype)) {\n                return 0;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISFLOAT(totype)) {\n            if (felsize < 8) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISCOMPLEX(totype)) {\n            if (felsize < 8) {\n                return (telsize >> 1) > felsize;\n            }\n            else {\n                return (telsize >> 1) >= felsize;\n            }\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_UBYTE:\n    case PyArray_USHORT:\n    case PyArray_UINT:\n    case PyArray_ULONG:\n    case PyArray_ULONGLONG:\n        if (PyTypeNum_ISINTEGER(totype)) {\n            if (PyTypeNum_ISSIGNED(totype)) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISFLOAT(totype)) {\n            if (felsize < 8) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISCOMPLEX(totype)) {\n            if (felsize < 8) {\n                return (telsize >> 1) > felsize;\n            }\n            else {\n                return (telsize >> 1) >= felsize;\n            }\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_FLOAT:\n    case PyArray_DOUBLE:\n    case PyArray_LONGDOUBLE:\n        if (PyTypeNum_ISCOMPLEX(totype)) {\n            return (telsize >> 1) >= felsize;\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_CFLOAT:\n    case PyArray_CDOUBLE:\n    case PyArray_CLONGDOUBLE:\n        return totype > fromtype;\n    case PyArray_STRING:\n    case PyArray_UNICODE:\n        return totype > fromtype;\n    default:\n        return 0;\n    }\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n  Get pointer to zero of correct type for array.\n*/\n", "func_signal": "NPY_NO_EXPORT char *\nPyArray_Zero(PyArrayObject *arr)", "code": "{\n    char *zeroval;\n    int ret, storeflags;\n    PyObject *obj;\n\n    if (_check_object_rec(arr->descr) < 0) {\n        return NULL;\n    }\n    zeroval = PyDataMem_NEW(arr->descr->elsize);\n    if (zeroval == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    obj=PyInt_FromLong((long) 0);\n    if (PyArray_ISOBJECT(arr)) {\n        memcpy(zeroval, &obj, sizeof(PyObject *));\n        Py_DECREF(obj);\n        return zeroval;\n    }\n    storeflags = arr->flags;\n    arr->flags |= BEHAVED;\n    ret = arr->descr->f->setitem(obj, zeroval, arr);\n    arr->flags = storeflags;\n    Py_DECREF(obj);\n    if (ret < 0) {\n        PyDataMem_FREE(zeroval);\n        return NULL;\n    }\n    return zeroval;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * Ensure that buffer has a decimal point in it.  The decimal point\n * will not be in the current locale, it will always be '.'\n */\n", "func_signal": "static void\n_ensure_decimal_point(char* buffer, size_t buf_size)", "code": "{\n    int insert_count = 0;\n    char* chars_to_insert;\n\n    /* search for the first non-digit character */\n    char *p = buffer;\n    if (*p == '-' || *p == '+')\n        /*\n         * Skip leading sign, if present.  I think this could only\n         * ever be '-', but it can't hurt to check for both.\n         */\n        ++p;\n    while (*p && isdigit(Py_CHARMASK(*p))) {\n        ++p;\n    }\n    if (*p == '.') {\n        if (isdigit(Py_CHARMASK(*(p+1)))) {\n            /*\n             * Nothing to do, we already have a decimal\n             * point and a digit after it.\n             */\n        }\n        else {\n            /*\n             * We have a decimal point, but no following\n             * digit.  Insert a zero after the decimal.\n             */\n            ++p;\n            chars_to_insert = \"0\";\n            insert_count = 1;\n        }\n    }\n    else {\n        chars_to_insert = \".0\";\n        insert_count = 2;\n    }\n    if (insert_count) {\n        size_t buf_len = strlen(buffer);\n        if (buf_len + insert_count + 1 >= buf_size) {\n            /*\n             * If there is not enough room in the buffer\n             * for the additional text, just skip it.  It's\n             * not worth generating an error over.\n             */\n        }\n        else {\n            memmove(p + insert_count, p, buffer + strlen(buffer) - p + 1);\n            memcpy(p, chars_to_insert, insert_count);\n        }\n    }\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * Given a string that may have a decimal point in the current\n * locale, change it back to a dot.  Since the string cannot get\n * longer, no need for a maximum buffer size parameter.\n */\n", "func_signal": "static void\n_change_decimal_from_locale_to_dot(char* buffer)", "code": "{\n    struct lconv *locale_data = localeconv();\n    const char *decimal_point = locale_data->decimal_point;\n\n    if (decimal_point[0] != '.' || decimal_point[1] != 0) {\n        size_t decimal_point_len = strlen(decimal_point);\n\n        if (*buffer == '+' || *buffer == '-') {\n            buffer++;\n        }\n        while (isdigit(Py_CHARMASK(*buffer))) {\n            buffer++;\n        }\n        if (strncmp(buffer, decimal_point, decimal_point_len) == 0) {\n            *buffer = '.';\n            buffer++;\n            if (decimal_point_len > 1) {\n                /* buffer needs to get smaller */\n                size_t rest_len = strlen(buffer + (decimal_point_len - 1));\n                memmove(buffer, buffer + (decimal_point_len - 1), rest_len);\n                buffer[rest_len] = 0;\n            }\n        }\n    }\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/* Compute factorial of n */\n", "func_signal": "int  fact(int n)", "code": "{\n    if (n <= 1) return 1;\n    else return n*fact(n-1);\n}", "path": "numpy\\distutils\\tests\\swig_ext\\src\\example.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n * See if array scalars can be cast.\n */\n", "func_signal": "NPY_NO_EXPORT Bool\nPyArray_CanCastScalar(PyTypeObject *from, PyTypeObject *to)", "code": "{\n    int fromtype;\n    int totype;\n\n    fromtype = _typenum_fromtypeobj((PyObject *)from, 0);\n    totype = _typenum_fromtypeobj((PyObject *)to, 0);\n    if (fromtype == PyArray_NOTYPE || totype == PyArray_NOTYPE) {\n        return FALSE;\n    }\n    return (Bool) PyArray_CanCastSafely(fromtype, totype);\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * NumPyOS_ascii_ftolf:\n *\t* fp: FILE pointer\n *\t* value: Place to store the value read\n *\n * Similar to PyOS_ascii_strtod, except that it reads input from a file.\n *\n * Similarly to fscanf, this function always consumes leading whitespace,\n * and any text that could be the leading part in valid input.\n *\n * Return value: similar to fscanf.\n *      * 0 if no number read,\n *      * 1 if a number read,\n *      * EOF if end-of-file met before reading anything.\n */\n", "func_signal": "NPY_NO_EXPORT int\nNumPyOS_ascii_ftolf(FILE *fp, double *value)", "code": "{\n    char buffer[FLOAT_FORMATBUFLEN + 1];\n    char *endp;\n    char *p;\n    int c;\n    int ok;\n\n    /*\n     * Pass on to PyOS_ascii_strtod the leftmost matching part in regexp\n     *\n     *     \\s*[+-]? ( [0-9]*\\.[0-9]+([eE][+-]?[0-9]+)\n     *              | nan  (  \\([:alphanum:_]*\\) )?\n     *              | inf(inity)?\n     *              )\n     *\n     * case-insensitively.\n     *\n     * The \"do { ... } while (0)\" wrapping in macros ensures that they behave\n     * properly eg. in \"if ... else\" structures.\n     */\n\n#define END_MATCH()                                                         \\\n        goto buffer_filled\n\n#define NEXT_CHAR()                                                         \\\n        do {                                                                \\\n            if (c == EOF || endp >= buffer + FLOAT_FORMATBUFLEN)            \\\n                END_MATCH();                                                \\\n            *endp++ = (char)c;                                              \\\n            c = getc(fp);                                                   \\\n        } while (0)\n\n#define MATCH_ALPHA_STRING_NOCASE(string)                                   \\\n        do {                                                                \\\n            for (p=(string); *p!='\\0' && (c==*p || c+('a'-'A')==*p); ++p)   \\\n                NEXT_CHAR();                                                \\\n            if (*p != '\\0') END_MATCH();                                    \\\n        } while (0)\n\n#define MATCH_ONE_OR_NONE(condition)                                        \\\n        do { if (condition) NEXT_CHAR(); } while (0)\n\n#define MATCH_ONE_OR_MORE(condition)                                        \\\n        do {                                                                \\\n            ok = 0;                                                         \\\n            while (condition) { NEXT_CHAR(); ok = 1; }                      \\\n            if (!ok) END_MATCH();                                           \\\n        } while (0)\n\n#define MATCH_ZERO_OR_MORE(condition)                                       \\\n        while (condition) { NEXT_CHAR(); }\n\n    /* 1. emulate fscanf EOF handling */\n    c = getc(fp);\n    if (c == EOF) {\n        return EOF;\n    }\n    /* 2. consume leading whitespace unconditionally */\n    while (NumPyOS_ascii_isspace(c)) {\n        c = getc(fp);\n    }\n\n    /* 3. start reading matching input to buffer */\n    endp = buffer;\n\n    /* 4.1 sign (optional) */\n    MATCH_ONE_OR_NONE(c == '+' || c == '-');\n\n    /* 4.2 nan, inf, infinity; [case-insensitive] */\n    if (c == 'n' || c == 'N') {\n        NEXT_CHAR();\n        MATCH_ALPHA_STRING_NOCASE(\"an\");\n\n        /* accept nan([:alphanum:_]*), similarly to strtod */\n        if (c == '(') {\n            NEXT_CHAR();\n            MATCH_ZERO_OR_MORE(NumPyOS_ascii_isalnum(c) || c == '_');\n            if (c == ')') {\n                NEXT_CHAR();\n            }\n        }\n        END_MATCH();\n    }\n    else if (c == 'i' || c == 'I') {\n        NEXT_CHAR();\n        MATCH_ALPHA_STRING_NOCASE(\"nfinity\");\n        END_MATCH();\n    }\n\n    /* 4.3 mantissa */\n    MATCH_ZERO_OR_MORE(NumPyOS_ascii_isdigit(c));\n\n    if (c == '.') {\n        NEXT_CHAR();\n        MATCH_ONE_OR_MORE(NumPyOS_ascii_isdigit(c));\n    }\n\n    /* 4.4 exponent */\n    if (c == 'e' || c == 'E') {\n        NEXT_CHAR();\n        MATCH_ONE_OR_NONE(c == '+' || c == '-');\n        MATCH_ONE_OR_MORE(NumPyOS_ascii_isdigit(c));\n    }\n\n    END_MATCH();\n\nbuffer_filled:\n\n    ungetc(c, fp);\n    *endp = '\\0';\n\n    /* 5. try to convert buffer. */\n    *value = NumPyOS_ascii_strtod(buffer, &p);\n\n    /* return 1 if something read, else 0 */\n    return (buffer == p) ? 0 : 1;\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * NumPyOS_ascii_strncasecmp:\n *\n * Same as strncasecmp under C locale\n */\n", "func_signal": "static int\nNumPyOS_ascii_strncasecmp(const char* s1, const char* s2, size_t len)", "code": "{\n    int diff;\n    while (len > 0 && *s1 != '\\0' && *s2 != '\\0') {\n        diff = ((int)NumPyOS_ascii_tolower(*s1)) -\n            ((int)NumPyOS_ascii_tolower(*s2));\n        if (diff != 0) {\n            return diff;\n        }\n        ++s1;\n        ++s2;\n        --len;\n    }\n    if (len > 0) {\n        return ((int)*s1) - ((int)*s2);\n    }\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * Check that the format string is a valid one for NumPyOS_ascii_format*\n */\n", "func_signal": "static int\n_check_ascii_format(const char *format)", "code": "{\n    char format_char;\n    size_t format_len = strlen(format);\n\n    /* The last character in the format string must be the format char */\n    format_char = format[format_len - 1];\n\n    if (format[0] != '%') {\n        return -1;\n    }\n\n    /*\n     * I'm not sure why this test is here.  It's ensuring that the format\n     * string after the first character doesn't have a single quote, a\n     * lowercase l, or a percent. This is the reverse of the commented-out\n     * test about 10 lines ago.\n     */\n    if (strpbrk(format + 1, \"'l%\")) {\n        return -1;\n    }\n\n    /*\n     * Also curious about this function is that it accepts format strings\n     * like \"%xg\", which are invalid for floats.  In general, the\n     * interface to this function is not very good, but changing it is\n     * difficult because it's a public API.\n     */\n    if (!(format_char == 'e' || format_char == 'E'\n          || format_char == 'f' || format_char == 'F'\n          || format_char == 'g' || format_char == 'G')) {\n        return -1;\n    }\n\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/* relies on setflags order being write, align, uic */\n", "func_signal": "static int\narrayflags_updateifcopy_set(PyArrayFlagsObject *self, PyObject *obj)", "code": "{\n    PyObject *res;\n    if (self->arr == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"Cannot set flags on array scalars.\");\n        return -1;\n    }\n    res = PyObject_CallMethod(self->arr, \"setflags\", \"OOO\", Py_None, Py_None,\n                              (PyObject_IsTrue(obj) ? Py_True : Py_False));\n    if (res == NULL) {\n        return -1;\n    }\n    Py_DECREF(res);\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\flagsobject.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n * Get a cast function to cast from the input descriptor to the\n * output type_number (must be a registered data-type).\n * Returns NULL if un-successful.\n */\n", "func_signal": "NPY_NO_EXPORT PyArray_VectorUnaryFunc *\nPyArray_GetCastFunc(PyArray_Descr *descr, int type_num)", "code": "{\n    PyArray_VectorUnaryFunc *castfunc = NULL;\n\n    if (type_num < PyArray_NTYPES) {\n        castfunc = descr->f->cast[type_num];\n    }\n    if (castfunc == NULL) {\n        PyObject *obj = descr->f->castdict;\n        if (obj && PyDict_Check(obj)) {\n            PyObject *key;\n            PyObject *cobj;\n\n            key = PyInt_FromLong(type_num);\n            cobj = PyDict_GetItem(obj, key);\n            Py_DECREF(key);\n            if (PyCObject_Check(cobj)) {\n                castfunc = PyCObject_AsVoidPtr(cobj);\n            }\n        }\n        if (castfunc) {\n            return castfunc;\n        }\n    }\n    else {\n        return castfunc;\n    }\n\n    PyErr_SetString(PyExc_ValueError, \"No cast function available.\");\n    return NULL;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*NUMPY_API\n * For backward compatibility\n *\n * Cast an array using typecode structure.\n * steals reference to at --- cannot be NULL\n */\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_CastToType(PyArrayObject *mp, PyArray_Descr *at, int fortran)", "code": "{\n    PyObject *out;\n    int ret;\n    PyArray_Descr *mpd;\n\n    mpd = mp->descr;\n\n    if (((mpd == at) ||\n                ((mpd->type_num == at->type_num) &&\n                 PyArray_EquivByteorders(mpd->byteorder, at->byteorder) &&\n                 ((mpd->elsize == at->elsize) || (at->elsize==0)))) &&\n                 PyArray_ISBEHAVED_RO(mp)) {\n        Py_DECREF(at);\n        Py_INCREF(mp);\n        return (PyObject *)mp;\n    }\n\n    if (at->elsize == 0) {\n        PyArray_DESCR_REPLACE(at);\n        if (at == NULL) {\n            return NULL;\n        }\n        if (mpd->type_num == PyArray_STRING &&\n            at->type_num == PyArray_UNICODE) {\n            at->elsize = mpd->elsize << 2;\n        }\n        if (mpd->type_num == PyArray_UNICODE &&\n            at->type_num == PyArray_STRING) {\n            at->elsize = mpd->elsize >> 2;\n        }\n        if (at->type_num == PyArray_VOID) {\n            at->elsize = mpd->elsize;\n        }\n    }\n\n    out = PyArray_NewFromDescr(mp->ob_type, at,\n                               mp->nd,\n                               mp->dimensions,\n                               NULL, NULL,\n                               fortran,\n                               (PyObject *)mp);\n\n    if (out == NULL) {\n        return NULL;\n    }\n    ret = PyArray_CastTo((PyArrayObject *)out, mp);\n    if (ret != -1) {\n        return out;\n    }\n\n    Py_DECREF(out);\n    return NULL;\n\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * NumPyOS_ascii_strtod:\n *\n * Work around bugs in PyOS_ascii_strtod\n */\n", "func_signal": "NPY_NO_EXPORT double\nNumPyOS_ascii_strtod(const char *s, char** endptr)", "code": "{\n    struct lconv *locale_data = localeconv();\n    const char *decimal_point = locale_data->decimal_point;\n    size_t decimal_point_len = strlen(decimal_point);\n\n    char buffer[FLOAT_FORMATBUFLEN+1];\n    const char *p;\n    char *q;\n    size_t n;\n    double result;\n\n    while (NumPyOS_ascii_isspace(*s)) {\n        ++s;\n    }\n\n    /*\n     * ##1\n     *\n     * Recognize POSIX inf/nan representations on all platforms.\n     */\n    p = s;\n    result = 1.0;\n    if (*p == '-') {\n        result = -1.0;\n        ++p;\n    }\n    else if (*p == '+') {\n        ++p;\n    }\n    if (NumPyOS_ascii_strncasecmp(p, \"nan\", 3) == 0) {\n        p += 3;\n        if (*p == '(') {\n            ++p;\n            while (NumPyOS_ascii_isalnum(*p) || *p == '_') {\n                ++p;\n            }\n            if (*p == ')') {\n                ++p;\n            }\n        }\n        if (endptr != NULL) {\n            *endptr = (char*)p;\n        }\n        return NPY_NAN;\n    }\n    else if (NumPyOS_ascii_strncasecmp(p, \"inf\", 3) == 0) {\n        p += 3;\n        if (NumPyOS_ascii_strncasecmp(p, \"inity\", 5) == 0) {\n            p += 5;\n        }\n        if (endptr != NULL) {\n            *endptr = (char*)p;\n        }\n        return result*NPY_INFINITY;\n    }\n    /* End of ##1 */\n\n    /*\n     * ## 2\n     *\n     * At least Python versions <= 2.5.2 and <= 2.6.1\n     *\n     * Fails to do best-efforts parsing of strings of the form \"1<DP>234\"\n     * where <DP> is the decimal point under the foreign locale.\n     */\n    if (decimal_point[0] != '.' || decimal_point[1] != 0) {\n        p = s;\n        if (*p == '+' || *p == '-') {\n            ++p;\n        }\n        while (*p >= '0' && *p <= '9') {\n            ++p;\n        }\n        if (strncmp(p, decimal_point, decimal_point_len) == 0) {\n            n = (size_t)(p - s);\n            if (n > FLOAT_FORMATBUFLEN) {\n                n = FLOAT_FORMATBUFLEN;\n            }\n            memcpy(buffer, s, n);\n            buffer[n] = '\\0';\n            result = PyOS_ascii_strtod(buffer, &q);\n            if (endptr != NULL) {\n                *endptr = (char*)(s + (q - buffer));\n            }\n            return result;\n        }\n    }\n    /* End of ##2 */\n\n    return PyOS_ascii_strtod(s, endptr);\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/*\n * Fix the generated string: make sure the decimal is ., that exponent has a\n * minimal number of digits, and that it has a decimal + one digit after that\n * decimal if decimal argument != 0 (Same effect that 'Z' format in\n * PyOS_ascii_formatd\n */\n", "func_signal": "static char*\n_fix_ascii_format(char* buf, size_t buflen, int decimal)", "code": "{\n    /*\n     * Get the current locale, and find the decimal point string.\n     * Convert that string back to a dot.\n     */\n    _change_decimal_from_locale_to_dot(buf);\n\n    /*\n     * If an exponent exists, ensure that the exponent is at least\n     * MIN_EXPONENT_DIGITS digits, providing the buffer is large enough\n     * for the extra zeros.  Also, if there are more than\n     * MIN_EXPONENT_DIGITS, remove as many zeros as possible until we get\n     * back to MIN_EXPONENT_DIGITS\n     */\n    _ensure_minimum_exponent_length(buf, buflen);\n\n    if (decimal != 0) {\n        _ensure_decimal_point(buf, buflen);\n    }\n\n    return buf;\n}", "path": "numpy\\core\\src\\multiarray\\numpyos.c", "repo_name": "efiring/numpy-work", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 17076}
{"docstring": "/* gnl_composition_ghost_pad_set_target:\n * target: The target #GstPad. The refcount will be decremented (given to the ghostpad).\n */\n", "func_signal": "static void\ngnl_composition_ghost_pad_set_target (GnlComposition * comp, GstPad * target)", "code": "{\n  gboolean hadghost = (comp->private->ghostpad) ? TRUE : FALSE;\n\n  if (target)\n    GST_DEBUG_OBJECT (comp, \"%s:%s , hadghost:%d\",\n        GST_DEBUG_PAD_NAME (target), hadghost);\n  else\n    GST_DEBUG_OBJECT (comp, \"Removing target, hadghost:%d\", hadghost);\n\n  if (!(hadghost)) {\n    /* Create new ghostpad */\n    comp->private->ghostpad =\n        gnl_object_ghost_pad_no_target ((GnlObject *) comp, \"src\", GST_PAD_SRC);\n    GST_DEBUG_OBJECT (comp->private->ghostpad,\n        \"About to replace event_pad_func\");\n    comp->private->gnl_event_pad_func =\n        GST_PAD_EVENTFUNC (comp->private->ghostpad);\n    gst_pad_set_event_function (comp->private->ghostpad,\n        GST_DEBUG_FUNCPTR (gnl_composition_event_handler));\n    GST_DEBUG_OBJECT (comp->private->ghostpad, \"eventfunc is now %s\",\n        GST_DEBUG_FUNCPTR_NAME (GST_PAD_EVENTFUNC (comp->private->ghostpad)));\n  } else {\n    GstPad *ptarget =\n        gst_ghost_pad_get_target (GST_GHOST_PAD (comp->private->ghostpad));\n\n    if (ptarget && ptarget == target) {\n      GST_DEBUG_OBJECT (comp,\n          \"Target of ghostpad is the same as existing one, not changing\");\n      gst_object_unref (ptarget);\n      return;\n    }\n\n    /* Unset previous target */\n    if (ptarget) {\n      GST_DEBUG_OBJECT (comp, \"Previous target was %s:%s, blocking that pad\",\n          GST_DEBUG_PAD_NAME (ptarget));\n      gst_pad_set_blocked_async (ptarget, TRUE,\n          (GstPadBlockCallback) pad_blocked, comp);\n      /* remove event probe */\n      if (comp->private->ghosteventprobe) {\n        gst_pad_remove_event_probe (ptarget, comp->private->ghosteventprobe);\n        comp->private->ghosteventprobe = 0;\n      }\n      gst_object_unref (ptarget);\n    }\n  }\n\n  gnl_object_ghost_pad_set_target ((GnlObject *) comp,\n      comp->private->ghostpad, target);\n\n  if (target && (comp->private->ghosteventprobe == 0)) {\n    comp->private->ghosteventprobe =\n        gst_pad_add_event_probe (target, G_CALLBACK (ghost_event_probe_handler),\n        comp);\n    GST_DEBUG_OBJECT (comp, \"added event probe %d\",\n        comp->private->ghosteventprobe);\n  }\n\n  if (!(hadghost)) {\n    gst_pad_set_active (comp->private->ghostpad, TRUE);\n    if (!(gst_element_add_pad (GST_ELEMENT (comp), comp->private->ghostpad)))\n      GST_WARNING (\"Couldn't add the ghostpad\");\n    else {\n      COMP_OBJECTS_UNLOCK (comp);\n      gst_element_no_more_pads (GST_ELEMENT (comp));\n      COMP_OBJECTS_LOCK (comp);\n    }\n  }\n  GST_DEBUG_OBJECT (comp, \"END\");\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/**\n * gnl_object_to_media_time:\n * @object: a #GnlObject\n * @objecttime: The #GstClockTime we want to convert\n * @mediatime: A pointer on a #GstClockTime to fill\n *\n * Converts a #GstClockTime from the object (container) context to the media context\n *\n * Returns: TRUE if @objecttime was within the limits of the @object start/stop time,\n * FALSE otherwise\n */\n", "func_signal": "gboolean\ngnl_object_to_media_time (GnlObject * object, GstClockTime otime,\n    GstClockTime * mtime)", "code": "{\n  g_return_val_if_fail (mtime, FALSE);\n\n  GST_DEBUG_OBJECT (object, \"ObjectTime : %\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (otime));\n\n  GST_DEBUG_OBJECT (object,\n      \"Start/Stop:[%\" GST_TIME_FORMAT \" -- %\" GST_TIME_FORMAT \"] \"\n      \"Media [%\" GST_TIME_FORMAT \" -- %\" GST_TIME_FORMAT \"]\",\n      GST_TIME_ARGS (object->start),\n      GST_TIME_ARGS (object->stop),\n      GST_TIME_ARGS (object->media_start), GST_TIME_ARGS (object->media_stop));\n\n  /* limit check */\n  if ((otime < object->start) || (otime >= object->stop)) {\n    GST_DEBUG_OBJECT (object, \"ObjectTime is outside object start/stop times\");\n    if (otime < object->start) {\n      *mtime =\n          (object->media_start ==\n          GST_CLOCK_TIME_NONE) ? object->start : object->media_start;\n    } else {\n      if (GST_CLOCK_TIME_IS_VALID (object->media_stop))\n        *mtime = object->media_stop;\n      else if (GST_CLOCK_TIME_IS_VALID (object->media_start))\n        *mtime = object->media_start + object->duration;\n      else\n        *mtime = object->stop;\n    }\n    return FALSE;\n  }\n\n  if (object->media_start == GST_CLOCK_TIME_NONE) {\n    /* no time shifting, for live sources ? */\n    *mtime = otime;\n  } else {\n    *mtime = (otime - object->start) * object->rate + object->media_start;\n  }\n\n  GST_DEBUG_OBJECT (object, \"Returning MediaTime : %\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (*mtime));\n\n  return TRUE;\n}", "path": "gnl\\gnlobject.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * get_new_seek_event:\n *\n * Returns a seek event for the currently configured segment\n * and start/stop values\n *\n * The GstSegment and segment_start|stop must have been configured\n * before calling this function.\n */\n", "func_signal": "static GstEvent *\nget_new_seek_event (GnlComposition * comp, gboolean initial,\n    gboolean updatestoponly)", "code": "{\n  GstSeekFlags flags;\n  gint64 start, stop;\n  GstSeekType starttype = GST_SEEK_TYPE_SET;\n\n  GST_DEBUG_OBJECT (comp, \"initial:%d\", initial);\n  /* remove the seek flag */\n  if (!(initial))\n    flags = comp->private->segment->flags;\n  else\n    flags = GST_SEEK_FLAG_ACCURATE | GST_SEEK_FLAG_FLUSH;\n\n  GST_DEBUG_OBJECT (comp,\n      \"private->segment->start:%\" GST_TIME_FORMAT \" segment_start%\"\n      GST_TIME_FORMAT, GST_TIME_ARGS (comp->private->segment->start),\n      GST_TIME_ARGS (comp->private->segment_start));\n  GST_DEBUG_OBJECT (comp,\n      \"private->segment->stop:%\" GST_TIME_FORMAT \" segment_stop%\"\n      GST_TIME_FORMAT, GST_TIME_ARGS (comp->private->segment->stop),\n      GST_TIME_ARGS (comp->private->segment_stop));\n\n  start = MAX (comp->private->segment->start, comp->private->segment_start);\n  stop = GST_CLOCK_TIME_IS_VALID (comp->private->segment->stop)\n      ? MIN (comp->private->segment->stop, comp->private->segment_stop)\n      : comp->private->segment_stop;\n  if (updatestoponly) {\n    starttype = GST_SEEK_TYPE_NONE;\n    start = GST_CLOCK_TIME_NONE;\n  }\n\n  GST_DEBUG_OBJECT (comp,\n      \"Created new seek event. Flags:%d, start:%\" GST_TIME_FORMAT \", stop:%\"\n      GST_TIME_FORMAT, flags, GST_TIME_ARGS (start), GST_TIME_ARGS (stop));\n  return gst_event_new_seek (comp->private->segment->rate,\n      comp->private->segment->format, flags, starttype, start,\n      GST_SEEK_TYPE_SET, stop);\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * recursive depth-first compare stack function on old stack\n *\n * _ Add no-longer used objects to the deactivate list\n * _ unlink child-parent relations that have changed (not same parent, or not same order)\n * _ blocks available source pads\n *\n * WITH OBJECTS LOCK TAKEN\n */\n", "func_signal": "static GList *\ncompare_deactivate_single_node (GnlComposition * comp, GNode * node,\n    GNode * newstack, gboolean modify)", "code": "{\n  GNode *child;\n  GNode *newnode = NULL;        /* Same node in newstack */\n  GnlObject *oldparent;\n  GList *deactivate = NULL;\n  GnlObject *oldobj = NULL;\n  GstPad *srcpad = NULL;\n\n  if (!node)\n    return NULL;\n\n  oldparent = G_NODE_IS_ROOT (node) ? NULL : (GnlObject *) node->parent->data;\n  oldobj = (GnlObject *) node->data;\n  if (newstack)\n    newnode = g_node_find (newstack, G_IN_ORDER, G_TRAVERSE_ALL, oldobj);\n\n  GST_DEBUG_OBJECT (comp, \"oldobj:%s\",\n      GST_ELEMENT_NAME ((GstElement *) oldobj));\n\n  srcpad = get_src_pad ((GstElement *) oldobj);\n\n  /* PRE PROCESSING */\n  if (srcpad) {\n    gst_pad_set_blocked_async (srcpad, TRUE, (GstPadBlockCallback) pad_blocked,\n        comp);\n\n    if (!oldparent) {\n      /* previous root of the tree */\n\n      /* if modify, send flush events downstream */\n      if (modify) {\n        GstPad *peerpad = NULL;\n\n        if ((peerpad = gst_pad_get_peer (srcpad))) {\n          GST_DEBUG_OBJECT (comp, \"Sending flush events downstream\");\n\n          gst_pad_send_event (peerpad, gst_event_new_flush_start ());\n          gst_pad_send_event (peerpad, gst_event_new_flush_stop ());\n          gst_object_unref (peerpad);\n          GST_DEBUG_OBJECT (comp, \"DONE Sending flush events downstream\");\n        } else\n          GST_WARNING_OBJECT (comp,\n              \"Top level object wasn't connected to a peerpad. Can't send downstream flushes\");\n      }\n\n    }\n  }\n\n  /* remove the target of the ghostpad */\n  if (!oldparent && comp->private->ghostpad) {\n    GST_DEBUG_OBJECT (comp,\n        \"Setting ghostpad target to NULL so oldobj srcpad is no longer linked\");\n    gnl_composition_ghost_pad_set_target (comp, NULL);\n  }\n\n  /* Optionnal OPERATION PROCESSING */\n  if (GNL_IS_OPERATION (oldobj)) {\n    for (child = node->children; child; child = child->next) {\n      GList *newdeac =\n          compare_deactivate_single_node (comp, child, newstack, modify);\n\n      if (newdeac)\n        deactivate = g_list_concat (deactivate, newdeac);\n    }\n  } else {\n    /* FIXME : do we need to do something specific for sources ? */\n  }\n\n  /* POST PROCESSING */\n  if (newnode) {\n    GnlObject *newparent =\n        G_NODE_IS_ROOT (newnode) ? NULL : (GnlObject *) newnode->parent->data;\n\n    GST_LOG_OBJECT (oldobj, \"exists in new stack\");\n\n    if ((oldparent != newparent) ||\n        (oldparent && newparent &&\n            (g_node_child_index (node, oldobj) != g_node_child_index (newnode,\n                    oldobj)))) {\n      GST_LOG_OBJECT (comp,\n          \"not same parent, or same parent but in different order\");\n\n      /* unlink */\n      if (oldparent) {\n        GstPad *peerpad = NULL;\n\n        if (srcpad)\n          peerpad = gst_pad_get_peer (srcpad);\n        gst_element_unlink ((GstElement *) oldobj, (GstElement *) oldparent);\n        /* send flush start / flush stop */\n        if (peerpad) {\n          GST_LOG_OBJECT (peerpad, \"Sending flush start/stop\");\n          gst_pad_send_event (peerpad, gst_event_new_flush_start ());\n          gst_pad_send_event (peerpad, gst_event_new_flush_stop ());\n          gst_object_unref (peerpad);\n        }\n      }\n\n    } else {\n      GST_LOG_OBJECT (comp, \"same parent, same order\");\n    }\n\n  } else {\n    /* no longer used in new stack */\n    GST_LOG_OBJECT (comp, \"%s not used anymore\", GST_ELEMENT_NAME (oldobj));\n\n    if (oldparent) {\n      GstPad *peerpad = NULL;\n\n      /* unlink from oldparent */\n      GST_LOG_OBJECT (comp, \"unlinking from previous parent\");\n      gst_element_unlink ((GstElement *) oldobj, (GstElement *) oldparent);\n      if (srcpad && (peerpad = gst_pad_get_peer (srcpad))) {\n        GST_LOG_OBJECT (peerpad, \"Sending flush start/stop\");\n        gst_pad_send_event (peerpad, gst_event_new_flush_start ());\n        gst_pad_send_event (peerpad, gst_event_new_flush_stop ());\n        gst_object_unref (peerpad);\n      }\n    }\n\n    GST_LOG_OBJECT (comp, \"adding %s to deactivate list\",\n        GST_ELEMENT_NAME (oldobj));\n    deactivate = g_list_append (deactivate, oldobj);\n  }\n  /* only unblock if it's not the ROOT */\n\n  if (srcpad)\n    gst_object_unref (srcpad);\n\n  return deactivate;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n  get_valid_src_pad\n\n  Returns True if there's a src pad compatible with the GnlObject caps in the\n  given element. Fills in pad if so. The returned pad has an incremented refcount\n*/\n", "func_signal": "static gboolean\nget_valid_src_pad (GnlSource * source, GstElement * element, GstPad ** pad)", "code": "{\n  GstIterator *srcpads;\n\n  g_return_val_if_fail (pad, FALSE);\n\n  srcpads = gst_element_iterate_src_pads (element);\n  *pad = (GstPad *) gst_iterator_find_custom (srcpads,\n      (GCompareFunc) compare_src_pad, GNL_OBJECT (source)->caps);\n  gst_iterator_free (srcpads);\n\n  if (*pad)\n    return TRUE;\n  return FALSE;\n}", "path": "gnl\\gnlsource.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/* signal_duration_change\n * Creates a new GST_MESSAGE_DURATION with the currently configured\n * composition duration and sends that on the bus.\n */\n", "func_signal": "static inline void\nsignal_duration_change (GnlComposition * comp)", "code": "{\n  gst_element_post_message (GST_ELEMENT_CAST (comp),\n      gst_message_new_duration (GST_OBJECT_CAST (comp),\n          GST_FORMAT_TIME, ((GnlObject *) comp)->duration));\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * get_stack_list:\n * @comp: The #GnlComposition\n * @timestamp: The #GstClockTime to look at\n * @priority: The priority level to start looking from\n * @activeonly: Only look for active elements if TRUE\n * @start: The biggest start time of the objects in the stack\n * @stop: The smallest stop time of the objects in the stack\n * @highprio: The highest priority in the stack\n *\n * Not MT-safe, you should take the objects lock before calling it.\n * Returns: A tree of #GNode sorted in priority order, corresponding\n * to the given search arguments. The returned value can be #NULL.\n */\n", "func_signal": "static GNode *\nget_stack_list (GnlComposition * comp, GstClockTime timestamp,\n    guint32 priority, gboolean activeonly, GstClockTime * start,\n    GstClockTime * stop, guint * highprio)", "code": "{\n  GList *tmp = comp->private->objects_start;\n  GList *stack = NULL;\n  GNode *ret = NULL;\n  GstClockTime nstart = GST_CLOCK_TIME_NONE;\n  GstClockTime nstop = GST_CLOCK_TIME_NONE;\n  guint32 highest = 0;\n\n  GST_DEBUG_OBJECT (comp,\n      \"timestamp:%\" GST_TIME_FORMAT \", priority:%u, activeonly:%d\",\n      GST_TIME_ARGS (timestamp), priority, activeonly);\n\n  GST_LOG (\"objects_start:%p\", comp->private->objects_start);\n\n  for (; tmp; tmp = g_list_next (tmp)) {\n    GnlObject *object = (GnlObject *) tmp->data;\n\n    GST_LOG_OBJECT (object,\n        \"start: %\" GST_TIME_FORMAT \" , stop:%\" GST_TIME_FORMAT \" , duration:%\"\n        GST_TIME_FORMAT \", priority:%u\", GST_TIME_ARGS (object->start),\n        GST_TIME_ARGS (object->stop), GST_TIME_ARGS (object->duration),\n        object->priority);\n\n    if (object->start <= timestamp) {\n      if ((object->stop > timestamp) &&\n          (object->priority >= priority) &&\n          ((!activeonly) || (object->active))) {\n        GST_LOG_OBJECT (comp, \"adding %s: sorted to the stack\",\n            GST_OBJECT_NAME (object));\n        stack = g_list_insert_sorted (stack, object,\n            (GCompareFunc) priority_comp);\n      }\n    } else {\n      GST_LOG_OBJECT (comp, \"too far, stopping iteration\");\n      break;\n    }\n  }\n\n  /* append the default source if we have one */\n  if ((timestamp < ((GnlObject *) comp)->stop) && comp->private->defaultobject)\n    stack = g_list_append (stack, comp->private->defaultobject);\n\n  /* convert that list to a stack */\n  tmp = stack;\n  ret = convert_list_to_tree (&tmp, &nstart, &nstop, &highest);\n\n  GST_DEBUG (\"nstart:%\" GST_TIME_FORMAT \", nstop:%\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (nstart), GST_TIME_ARGS (nstop));\n\n  if (*stop)\n    *stop = nstop;\n  if (*start)\n    *start = nstart;\n  if (highprio)\n    *highprio = highest;\n\n  g_list_free (stack);\n\n  return ret;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * has_dynamic_pads\n * Returns TRUE if the element has only dynamic pads.\n */\n", "func_signal": "static gboolean\nhas_dynamic_srcpads (GstElement * element)", "code": "{\n  gboolean ret = TRUE;\n  GList *templates;\n  GstPadTemplate *template;\n\n  templates =\n      gst_element_class_get_pad_template_list (GST_ELEMENT_GET_CLASS (element));\n\n  while (templates) {\n    template = (GstPadTemplate *) templates->data;\n\n    if ((GST_PAD_TEMPLATE_DIRECTION (template) == GST_PAD_SRC)\n        && (GST_PAD_TEMPLATE_PRESENCE (template) == GST_PAD_ALWAYS)) {\n      ret = FALSE;\n      break;\n    }\n\n    templates = g_list_next (templates);\n  }\n\n  return ret;\n}", "path": "gnl\\gnlsource.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * gnl_object_ghost_pad_no_target:\n * /!\\ Doesn't add the pad to the GnlObject....\n */\n", "func_signal": "GstPad *\ngnl_object_ghost_pad_no_target (GnlObject * object, const gchar * name,\n    GstPadDirection dir)", "code": "{\n  GstPad *ghost;\n  GnlPadPrivate *priv;\n\n  /* create a no_target ghostpad */\n  ghost = gst_ghost_pad_new_no_target (name, dir);\n  if (!ghost)\n    return NULL;\n\n  GST_DEBUG (\"grabbing existing pad functions\");\n\n  /* remember the existing ghostpad event/query/link/unlink functions */\n  priv = g_new0 (GnlPadPrivate, 1);\n  priv->dir = dir;\n  priv->object = object;\n\n  /* grab/replace event/query functions */\n  GST_DEBUG_OBJECT (ghost, \"Setting priv->eventfunc to %p\",\n      GST_PAD_EVENTFUNC (ghost));\n  priv->eventfunc = GST_PAD_EVENTFUNC (ghost);\n  priv->queryfunc = GST_PAD_QUERYFUNC (ghost);\n\n  gst_pad_set_event_function (ghost,\n      GST_DEBUG_FUNCPTR (ghostpad_event_function));\n  gst_pad_set_query_function (ghost,\n      GST_DEBUG_FUNCPTR (ghostpad_query_function));\n\n  gst_pad_set_element_private (ghost, priv);\n\n  return ghost;\n}", "path": "gnl\\gnlobject.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/* OBJECTS LOCK must be taken when calling this ! */\n", "func_signal": "static GstClockTime\nget_current_position (GnlComposition * comp)", "code": "{\n  GstFormat format = GST_FORMAT_TIME;\n  gint64 value = GST_CLOCK_TIME_NONE;\n  GstPad *pad;\n  GnlObject *obj;\n  gboolean res;\n\n  /* 1. Try querying position downstream */\n  if (comp->private->ghostpad) {\n    GstPad *peer = gst_pad_get_peer (comp->private->ghostpad);\n    if (peer) {\n      res = gst_pad_query_position (peer, &format, &value);\n      gst_object_unref (peer);\n      if (res && (format == GST_FORMAT_TIME)) {\n        GST_LOG_OBJECT (comp,\n            \"Successfully got downstream position %\" GST_TIME_FORMAT,\n            GST_TIME_ARGS ((guint64) value));\n        goto beach;\n      }\n    }\n    GST_DEBUG_OBJECT (comp, \"Downstream position query failed\");\n    /* resetting format/value */\n    format = GST_FORMAT_TIME;\n    value = GST_CLOCK_TIME_NONE;\n  }\n\n  /* 2. If downstream fails , try within the current stack */\n  if (!comp->private->current) {\n    GST_DEBUG_OBJECT (comp, \"No current stack, can't send query\");\n    goto beach;\n  }\n\n  obj = (GnlObject *) comp->private->current->data;\n\n  if (!(pad = get_src_pad ((GstElement *) obj)))\n    goto beach;\n\n  res = gst_pad_query_position (pad, &format, &value);\n\n  if (format != GST_FORMAT_TIME) {\n    GST_WARNING_OBJECT (comp, \"query returned a format different from TIME\");\n    value = GST_CLOCK_TIME_NONE;\n  } else {\n    GST_LOG_OBJECT (comp, \"Query returned %\" GST_TIME_FORMAT,\n        GST_TIME_ARGS ((guint64) value));\n  }\n\nbeach:\n  return (guint64) value;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/* \n * Child modification updates\n */\n", "func_signal": "static void\nobject_start_changed (GnlObject * object, GParamSpec * arg G_GNUC_UNUSED,\n    GnlComposition * comp)", "code": "{\n  GST_DEBUG_OBJECT (object, \"start position changed (%\" GST_TIME_FORMAT\n      \"), evaluating pipeline update\", GST_TIME_ARGS (object->start));\n\n  comp->private->objects_start = g_list_sort\n      (comp->private->objects_start, (GCompareFunc) objects_start_compare);\n\n  comp->private->objects_stop = g_list_sort\n      (comp->private->objects_stop, (GCompareFunc) objects_stop_compare);\n\n  if (comp->private->current && (OBJECT_IN_ACTIVE_SEGMENT (comp, object) ||\n          g_node_find (comp->private->current,\n              G_IN_ORDER, G_TRAVERSE_ALL, object))) {\n    GstClockTime curpos = get_current_position (comp);\n    if (curpos == GST_CLOCK_TIME_NONE)\n      curpos = comp->private->segment->start = comp->private->segment_start;\n    update_pipeline (comp, curpos, TRUE, TRUE, TRUE);\n  } else\n    update_start_stop_duration (comp);\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n *\n * END OF UTILITY FUNCTIONS\n *\n */\n", "func_signal": "static GstStateChangeReturn\ngnl_composition_change_state (GstElement * element, GstStateChange transition)", "code": "{\n  GnlComposition *comp = (GnlComposition *) element;\n  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;\n\n  switch (transition) {\n    case GST_STATE_CHANGE_READY_TO_PAUSED:{\n      GstIterator *childs;\n      GstIteratorResult res;\n      GValue val = { 0 };\n\n      /* state-lock all elements */\n      GST_DEBUG_OBJECT (comp,\n          \"Setting all childs to READY and locking their state\");\n      g_value_init (&val, G_TYPE_BOOLEAN);\n      g_value_set_boolean (&val, FALSE);\n      childs = gst_bin_iterate_elements (GST_BIN (comp));\n      res = gst_iterator_fold (childs,\n          (GstIteratorFoldFunction) lock_child_state, &val, NULL);\n      gst_iterator_free (childs);\n    }\n\n      /* set ghostpad target */\n      if (!(update_pipeline (comp, COMP_REAL_START (comp), TRUE, FALSE, TRUE))) {\n        ret = GST_STATE_CHANGE_FAILURE;\n        goto beach;\n      }\n      break;\n    case GST_STATE_CHANGE_PAUSED_TO_READY:\n    case GST_STATE_CHANGE_READY_TO_NULL:\n      gnl_composition_reset (comp);\n      break;\n    default:\n      break;\n  }\n\n  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);\n\n  if (ret == GST_STATE_CHANGE_FAILURE)\n    return ret;\n\n  switch (transition) {\n    case GST_STATE_CHANGE_PAUSED_TO_READY:\n    case GST_STATE_CHANGE_READY_TO_NULL:\n      unblock_childs (comp);\n      break;\n    default:\n      break;\n  }\n\nbeach:\n  return ret;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * Converts a sorted list to a tree\n * Recursive\n *\n * stack will be set to the next item to use in the parent.\n * If operations number of sinks is limited, it will only use that number.\n */\n", "func_signal": "static GNode *\nconvert_list_to_tree (GList ** stack, GstClockTime * start,\n    GstClockTime * stop, guint32 * highprio)", "code": "{\n  GNode *ret;\n  guint nbsinks;\n  gboolean limit;\n  GList *tmp;\n  GnlObject *object;\n\n  if (!stack || !*stack)\n    return NULL;\n\n  object = (GnlObject *) (*stack)->data;\n\n  GST_DEBUG (\"object:%s , *start:%\" GST_TIME_FORMAT \", *stop:%\"\n      GST_TIME_FORMAT \" highprio:%d\",\n      GST_ELEMENT_NAME (object), GST_TIME_ARGS (*start),\n      GST_TIME_ARGS (*stop), *highprio);\n\n  /* update earliest stop */\n  if (GST_CLOCK_TIME_IS_VALID (*stop)) {\n    if (GST_CLOCK_TIME_IS_VALID (object->stop) && (*stop > object->stop))\n      *stop = object->stop;\n  } else {\n    *stop = object->stop;\n  }\n\n  if (GST_CLOCK_TIME_IS_VALID (*start)) {\n    if (GST_CLOCK_TIME_IS_VALID (object->start) && (*start < object->start))\n      *start = object->start;\n  } else {\n    *start = object->start;\n  }\n\n  if (GNL_IS_SOURCE (object)) {\n    *stack = g_list_next (*stack);\n    /* update highest priority.\n     * We do this here, since it's only used with sources (leafs of the tree) */\n    if (object->priority > *highprio)\n      *highprio = object->priority;\n    ret = g_node_new (object);\n    goto beach;\n  } else {                      /* GnlOperation */\n    GnlOperation *oper = (GnlOperation *) object;\n\n    GST_LOG_OBJECT (oper, \"operation, num_sinks:%d\", oper->num_sinks);\n    ret = g_node_new (object);\n    limit = (oper->dynamicsinks == FALSE);\n    nbsinks = oper->num_sinks;\n\n    /* FIXME : if num_sinks == -1 : request the proper number of pads */\n    for (tmp = g_list_next (*stack); tmp && (!limit || nbsinks);) {\n      g_node_append (ret, convert_list_to_tree (&tmp, start, stop, highprio));\n\n      if (limit)\n        nbsinks--;\n    }\n  }\n\nbeach:\n  GST_DEBUG_OBJECT (object,\n      \"*start:%\" GST_TIME_FORMAT \" *stop:%\" GST_TIME_FORMAT \" priority:%u\",\n      GST_TIME_ARGS (*start), GST_TIME_ARGS (*stop), *highprio);\n\n  return ret;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * compare_relink_stack:\n * @comp: The #GnlComposition\n * @stack: The new stack\n * @modify: TRUE if the timeline has changed and needs downstream flushes.\n *\n * Compares the given stack to the current one and relinks it if needed.\n *\n * WITH OBJECTS LOCK TAKEN\n *\n * Returns: The #GList of #GnlObject no longer used\n */\n", "func_signal": "static GList *\ncompare_relink_stack (GnlComposition * comp, GNode * stack, gboolean modify)", "code": "{\n  GList *deactivate = NULL;\n\n  /* 1. reset waiting pads for new stack */\n  comp->private->waitingpads = 0;\n\n  /* 2. Traverse old stack to deactivate no longer used objects */\n\n  deactivate =\n      compare_deactivate_single_node (comp, comp->private->current, stack,\n      modify);\n\n  /* 3. Traverse new stack to do needed (re)links */\n\n  compare_relink_single_node (comp, stack, comp->private->current);\n\n  return deactivate;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n  translate_outgoing_position_query\n\n  Should only be called:\n  _ if the query is a GST_QUERY_POSITION\n  _ after the query was sent upstream\n  _ if the upstream query returned TRUE\n*/\n", "func_signal": "static gboolean\ntranslate_incoming_position_query (GnlObject * object, GstQuery * query)", "code": "{\n  GstFormat format;\n  gint64 cur, cur2;\n\n  gst_query_parse_position (query, &format, &cur);\n  if (format != GST_FORMAT_TIME) {\n    GST_WARNING_OBJECT (object,\n        \"position query is in a format different from time, returning without modifying values\");\n    goto beach;\n  }\n\n  if (!(gnl_media_to_object_time (object, (guint64) cur, (guint64 *) & cur2))) {\n    GST_WARNING_OBJECT (object,\n        \"Couldn't get object time for %\" GST_TIME_FORMAT, GST_TIME_ARGS (cur));\n    goto beach;\n  }\n\n  gst_query_set_position (query, GST_FORMAT_TIME, cur2);\n\nbeach:\n  return TRUE;\n}", "path": "gnl\\gnlobject.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * get_src_pad:\n * element: a #GstElement\n *\n * Returns: The src pad for the given element. A reference was added to the\n * returned pad, remove it when you don't need that pad anymore.\n * Returns NULL if there's no source pad.\n */\n", "func_signal": "static GstPad *\nget_src_pad (GstElement * element)", "code": "{\n  GstIterator *it;\n  GstIteratorResult itres;\n  GstPad *srcpad;\n\n  it = gst_element_iterate_src_pads (element);\n  itres = gst_iterator_next (it, (gpointer) & srcpad);\n  if (itres != GST_ITERATOR_OK) {\n    GST_DEBUG (\"%s doesn't have a src pad !\", GST_ELEMENT_NAME (element));\n    srcpad = NULL;\n  }\n  gst_iterator_free (it);\n  return srcpad;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/**\n * gnl_object_ghost_pad:\n * @object: #GnlObject to add the ghostpad to\n * @name: Name for the new pad\n * @target: Target #GstPad to ghost\n *\n * Adds a #GstGhostPad overridding the correct pad [query|event]_function so \n * that time shifting is done correctly\n * The #GstGhostPad is added to the #GnlObject\n *\n * /!\\ This function doesn't check if the existing [src|sink] pad was removed\n * first, so you might end up with more pads than wanted\n *\n * Returns: The #GstPad if everything went correctly, else NULL.\n */\n", "func_signal": "GstPad *\ngnl_object_ghost_pad_full (GnlObject * object, const gchar * name,\n    GstPad * target, gboolean flush_hack)", "code": "{\n  GstPadDirection dir = GST_PAD_DIRECTION (target);\n  GstPad *ghost;\n\n  GST_DEBUG_OBJECT (object, \"name:%s, target:%p, flush_hack:%d\",\n      name, target, flush_hack);\n\n  g_return_val_if_fail (target, FALSE);\n  g_return_val_if_fail ((dir != GST_PAD_UNKNOWN), FALSE);\n\n  ghost = gnl_object_ghost_pad_no_target (object, name, dir);\n  if (ghost && (!(gnl_object_ghost_pad_set_target (object, ghost, target)))) {\n    GST_WARNING_OBJECT (object,\n        \"Couldn't set the target pad... removing ghostpad\");\n    gst_object_unref (ghost);\n    return NULL;\n  }\n\n\n  /* activate pad */\n  gst_pad_set_active (ghost, TRUE);\n  /* add it to element */\n  if (!(gst_element_add_pad (GST_ELEMENT (object), ghost))) {\n    GST_WARNING (\"couldn't add newly created ghostpad\");\n    return NULL;\n  }\n  control_internal_pad (ghost, object);\n\n  return ghost;\n}", "path": "gnl\\gnlobject.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * update_pipeline:\n * @comp: The #GnlComposition\n * @currenttime: The #GstClockTime to update at, can be GST_CLOCK_TIME_NONE.\n * @initial: TRUE if this is the first setup\n * @change_state: Change the state of the (de)activated objects if TRUE.\n * @modify: Flush downstream if TRUE. Needed for modified timelines.\n *\n * Updates the internal pipeline and properties. If @currenttime is \n * GST_CLOCK_TIME_NONE, it will not modify the current pipeline\n *\n * Returns: FALSE if there was an error updating the pipeline.\n */\n", "func_signal": "static gboolean\nupdate_pipeline (GnlComposition * comp, GstClockTime currenttime,\n    gboolean initial, gboolean change_state, gboolean modify)", "code": "{\n  gboolean ret = TRUE;\n\n  GST_DEBUG_OBJECT (comp,\n      \"currenttime:%\" GST_TIME_FORMAT\n      \" initial:%d , change_state:%d , modify:%d\", GST_TIME_ARGS (currenttime),\n      initial, change_state, modify);\n\n  COMP_OBJECTS_LOCK (comp);\n\n  update_start_stop_duration (comp);\n\n  if ((GST_CLOCK_TIME_IS_VALID (currenttime))) {\n    GstState state = GST_STATE (comp);\n    GstState nextstate =\n        (GST_STATE_NEXT (comp) ==\n        GST_STATE_VOID_PENDING) ? GST_STATE (comp) : GST_STATE_NEXT (comp);\n    GNode *stack = NULL;\n    GList *deactivate = NULL;\n    GstClockTime new_start = GST_CLOCK_TIME_NONE;\n    GstClockTime new_stop = GST_CLOCK_TIME_NONE;\n    gboolean samestack = FALSE;\n    gboolean startchanged, stopchanged;\n\n    GST_DEBUG_OBJECT (comp,\n        \"now really updating the pipeline, current-state:%s\",\n        gst_element_state_get_name (state));\n\n\n    /* (re)build the stack and relink new elements */\n    stack =\n        get_clean_toplevel_stack (comp, &currenttime, &new_start, &new_stop);\n    samestack = are_same_stacks (comp->private->current, stack);\n\n    if (!samestack)\n      deactivate = compare_relink_stack (comp, stack, modify);\n\n    startchanged = comp->private->segment_start != currenttime;\n    stopchanged = comp->private->segment_stop != new_stop;\n\n    /* set new segment_start/stop */\n    comp->private->segment_start = currenttime;\n    comp->private->segment_stop = new_stop;\n\n    /* Clear pending child seek */\n    if (comp->private->childseek) {\n      GST_DEBUG (\"unreffing event %p\", comp->private->childseek);\n      gst_event_unref (comp->private->childseek);\n      comp->private->childseek = NULL;\n    }\n\n    /* activate new stack */\n    if (comp->private->current)\n      g_node_destroy (comp->private->current);\n    comp->private->current = NULL;\n\n    COMP_OBJECTS_UNLOCK (comp);\n\n    if (deactivate) {\n      GList *tmp;\n\n      GST_DEBUG_OBJECT (comp, \"De-activating objects no longer used\");\n\n      /* state-lock elements no more used */\n      for (tmp = deactivate; tmp; tmp = g_list_next (tmp)) {\n        GST_LOG (\"%p\", tmp->data);\n\n        if (change_state)\n          gst_element_set_state (GST_ELEMENT (tmp->data), state);\n        gst_element_set_locked_state (GST_ELEMENT (tmp->data), TRUE);\n      }\n      g_list_free (deactivate);\n\n      GST_DEBUG_OBJECT (comp, \"Finished de-activating objects no longer used\");\n    }\n\n    comp->private->current = stack;\n\n    GST_DEBUG_OBJECT (comp, \"activating objects in new stack to %s\",\n        gst_element_state_get_name (nextstate));\n\n    if (!samestack && stack)\n      unlock_activate_stack (comp, stack, change_state, nextstate);\n    GST_DEBUG_OBJECT (comp, \"Finished activating objects in new stack\");\n\n    if (comp->private->current) {\n      GstEvent *event;\n\n      /* There is a valid timeline stack */\n\n      COMP_OBJECTS_LOCK (comp);\n\n      /* 1. Create new seek event for newly configured timeline stack */\n      if (samestack && (startchanged || stopchanged))\n        event =\n            get_new_seek_event (comp,\n            (state == GST_STATE_PLAYING) ? FALSE : TRUE, !startchanged);\n      else\n        event = get_new_seek_event (comp, initial, FALSE);\n\n      /* 2. Is the stack entirely ready ? */\n      if (comp->private->waitingpads == 0) {\n        GstPad *pad = NULL;\n\n        /* 2.a. Stack is entirely ready */\n\n        /* 3. Get toplevel object source pad */\n        if ((pad = get_src_pad (GST_ELEMENT (comp->private->current->data)))) {\n\n          GST_DEBUG_OBJECT (comp, \"We have a valid toplevel element pad %s:%s\",\n              GST_DEBUG_PAD_NAME (pad));\n\n          /* 4. Unconditionnaly set the ghostpad target to pad */\n          GST_LOG_OBJECT (comp,\n              \"Setting the composition's ghostpad target to %s:%s\",\n              GST_DEBUG_PAD_NAME (pad));\n          gnl_composition_ghost_pad_set_target (comp, pad);\n\n          /* 5. send seek event */\n          GST_LOG_OBJECT (comp, \"sending seek event\");\n          if (!(gst_pad_send_event (pad, event))) {\n            ret = FALSE;\n          } else {\n            /* 6. unblock top-level pad */\n            GST_LOG_OBJECT (comp, \"About to unblock top-level srcpad\");\n            gst_pad_set_blocked_async (pad, FALSE,\n                (GstPadBlockCallback) pad_blocked, comp);\n          }\n          gst_object_unref (pad);\n        } else {\n          GST_WARNING_OBJECT (comp,\n              \"Timeline is entirely linked, but couldn't get top-level element's source pad\");\n          ret = FALSE;\n        }\n      } else {\n        /* 2.b. Stack isn't entirely ready, save seek event for later on */\n        GST_LOG_OBJECT (comp,\n            \"The timeline stack isn't entirely linked, delaying sending seek event (waitingpads:%d)\",\n            comp->private->waitingpads);\n        comp->private->childseek = event;\n        ret = TRUE;\n      }\n      COMP_OBJECTS_UNLOCK (comp);\n\n    } else {\n      if ((!comp->private->objects_start) && comp->private->ghostpad) {\n        GST_DEBUG_OBJECT (comp, \"composition is now empty, removing ghostpad\");\n        gnl_object_remove_ghost_pad ((GnlObject *) comp,\n            comp->private->ghostpad);\n        comp->private->ghostpad = NULL;\n        comp->private->ghosteventprobe = 0;\n        comp->private->segment_start = 0;\n        comp->private->segment_stop = GST_CLOCK_TIME_NONE;\n      }\n    }\n  } else {\n    COMP_OBJECTS_UNLOCK (comp);\n  }\n\n  GST_DEBUG_OBJECT (comp, \"Returning %d\", ret);\n  return ret;\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/**\n * gnl_media_to_object_time:\n * @object:\n * @mediatime: The #GstClockTime we want to convert\n * @objecttime: A pointer on a #GstClockTime to fill\n *\n * Converts a #GstClockTime from the media context to the object (container) context\n *\n * Returns: TRUE if @objecttime was within the limits of the @object media start/stop time,\n * FALSE otherwise\n */\n", "func_signal": "gboolean\ngnl_media_to_object_time (GnlObject * object, GstClockTime mtime,\n    GstClockTime * otime)", "code": "{\n  g_return_val_if_fail (otime, FALSE);\n\n  GST_DEBUG_OBJECT (object, \"MediaTime : %\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (mtime));\n\n  GST_DEBUG_OBJECT (object,\n      \"Start/Stop:[%\" GST_TIME_FORMAT \" -- %\" GST_TIME_FORMAT \"] \"\n      \"Media [%\" GST_TIME_FORMAT \" -- %\" GST_TIME_FORMAT \"]\",\n      GST_TIME_ARGS (object->start),\n      GST_TIME_ARGS (object->stop),\n      GST_TIME_ARGS (object->media_start), GST_TIME_ARGS (object->media_stop));\n\n\n  /* limit check */\n  if (object->media_start == GST_CLOCK_TIME_NONE)\n    return gnl_object_to_media_time (object, mtime, otime);\n\n  if (mtime < object->media_start) {\n    GST_DEBUG_OBJECT (object,\n        \"media time is before media_start, forcing to start\");\n    *otime = object->start;\n    return FALSE;\n  } else if ((object->media_stop != GST_CLOCK_TIME_NONE)\n      && (mtime >= object->media_stop)) {\n    GST_DEBUG_OBJECT (object,\n        \"media time is at or after media_stop, forcing to stop\");\n    *otime = object->stop;\n  } else\n    *otime = (mtime - object->media_start) / object->rate + object->start;\n\n  GST_DEBUG_OBJECT (object, \"Returning ObjectTime : %\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (*otime));\n  return TRUE;\n}", "path": "gnl\\gnlobject.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/*\n * recursive depth-first relink stack function on new stack\n *\n * _ relink nodes with changed parent/order\n * _ links new nodes with parents\n * _ unblocks available source pads (except for toplevel)\n *\n * WITH OBJECTS LOCK TAKEN\n */\n", "func_signal": "static void\ncompare_relink_single_node (GnlComposition * comp, GNode * node,\n    GNode * oldstack)", "code": "{\n  GNode *child;\n  GNode *oldnode = NULL;\n  GnlObject *newobj;\n  GnlObject *newparent;\n  GnlObject *oldparent = NULL;\n  GstPad *srcpad = NULL;\n\n  if (!node)\n    return;\n\n  newparent = G_NODE_IS_ROOT (node) ? NULL : (GnlObject *) node->parent->data;\n  newobj = (GnlObject *) node->data;\n  if (oldstack) {\n    oldnode = g_node_find (oldstack, G_IN_ORDER, G_TRAVERSE_ALL, newobj);\n    if (oldnode)\n      oldparent =\n          G_NODE_IS_ROOT (oldnode) ? NULL : (GnlObject *) oldnode->parent->data;\n  }\n  GST_DEBUG_OBJECT (comp, \"newobj:%s\",\n      GST_ELEMENT_NAME ((GstElement *) newobj));\n\n  srcpad = get_src_pad ((GstElement *) newobj);\n\n  if (srcpad) {\n    gst_pad_set_blocked_async (srcpad, TRUE, (GstPadBlockCallback) pad_blocked,\n        comp);\n  }\n\n  if (GNL_IS_OPERATION (newobj)) {\n    guint nbchilds = g_node_n_children (node);\n    GnlOperation *oper = (GnlOperation *) newobj;\n\n    GST_LOG_OBJECT (newobj, \"is operation, analyzing the %d childs\", nbchilds);\n    if (oper->dynamicsinks)\n      g_object_set (G_OBJECT (newobj), \"sinks\", nbchilds, NULL);\n    for (child = node->children; child; child = child->next)\n      compare_relink_single_node (comp, child, oldstack);\n    if (nbchilds < oper->num_sinks)\n      GST_ERROR (\"ACHTUNG ! NOT ENOUGH SINKPADS ! %d / %d\",\n          oper->num_sinks, nbchilds);\n    if (nbchilds == 0)\n      GST_ERROR (\"ACHTUNG ! OPERATION HAS NO CHILDS !!!\");\n    /* Make sure we have enough sinkpads */\n  } else {\n    /* FIXME : do we need to do something specific for sources ? */\n  }\n\n  if (srcpad) {\n    GST_LOG_OBJECT (newobj, \"has a valid source pad\");\n    /* POST PROCESSING */\n    if ((oldparent != newparent) ||\n        (oldparent && newparent &&\n            (g_node_child_index (node, newobj) != g_node_child_index (oldnode,\n                    newobj)))) {\n      GST_LOG_OBJECT (newobj,\n          \"not same parent, or same parent but in different order\");\n\n      /* relink to new parent in required order */\n      if (newparent) {\n        /* FIXME : do it in required order */\n        if (!(gst_element_link ((GstElement *) newobj,\n                    (GstElement *) newparent)))\n          GST_ERROR_OBJECT (comp, \"Couldn't link %s to %s\",\n              GST_ELEMENT_NAME (newobj), GST_ELEMENT_NAME (newparent));\n      }\n    } else\n      GST_LOG_OBJECT (newobj, \"Same parent and same position in the new stack\");\n\n    /* the new root handling is taken care of in the global compare_relink_stack() */\n    if (!G_NODE_IS_ROOT (node))\n      gst_pad_set_blocked_async (srcpad, FALSE,\n          (GstPadBlockCallback) pad_blocked, comp);\n  } else {\n    GnlCompositionEntry *entry = COMP_ENTRY (comp, newobj);\n\n    GST_LOG_OBJECT (newobj, \"no existing pad, connecting to 'no-more-pads'\");\n    comp->private->waitingpads++;\n    if (!(entry->nomorepadshandler))\n      entry->nomorepadshandler = g_signal_connect\n          (G_OBJECT (newobj), \"no-more-pads\",\n          G_CALLBACK (no_more_pads_object_cb), comp);\n  }\n\n  if (srcpad)\n    gst_object_unref (srcpad);\n\n  GST_LOG_OBJECT (newobj, \"DONE\");\n}", "path": "gnl\\gnlcomposition.c", "repo_name": "prajnashi/gnonlin", "stars": 2, "license": "other", "language": "c", "size": 680}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptGetRecord\n *\n *  DESCRIPTION: Get a record from a Appointment Database\n *\n *  PARAMETERS: database pointer\n *                  database index\n *                  database record\n *\n *  RETURNS: ##0 if successful, errorcode if not\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "Err ApptGetRecord (DmOpenRef dbP, UInt16 index, ApptDBRecordPtr r,\n                   MemHandle * handleP)", "code": "{\n    MemHandle handle;\n    ApptPackedDBRecordPtr src;\n\n    handle = DmQueryRecord(dbP, index);\n    ErrFatalDisplayIf(DmGetLastErr(), \"Error Querying record\");\n\n    src = (ApptPackedDBRecordPtr) MemHandleLock (handle);\n\n    if (DmGetLastErr()) {\n        *handleP = 0;\n        return DmGetLastErr();\n    }\n\n    ApptUnpack(src, r);\n\n    *handleP = handle;\n    return 0;\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/***********************************************************************\n *\n * FUNCTION:    ApptGetAppointments\n *\n * DESCRIPTION: This routine returns a list of appointments that are on \n *              the date specified\n *\n * PARAMETERS:  dbP    - pointer to the database\n *              date   - date to search for\n *              countP - number of appointments on the specified \n *                       day (returned value)\n *\n * RETURNED:    handle of the appointment list (ApptInfoType)\n *\n * REVISION HISTORY:\n *          Name    Date        Description\n *          ----    ----        -----------\n *          art     6/15/95     Initial Revision\n *\n ***********************************************************************/\n", "func_signal": "MemHandle ApptGetAppointments (DmOpenRef dbP, DateType date, UInt16 * countP)", "code": "{\n    Err error;\n    Int16 result;\n    Int16 count = 0;\n    UInt16    recordNum;\n    Boolean repeats;\n    MemHandle recordH;\n    MemHandle apptListH;\n    ApptInfoPtr apptList;\n    ApptDBRecordType apptRec;\n    ApptPackedDBRecordPtr r;\n\n    // Allocated a block to hold the appointment list.\n    apptListH = MemHandleNew (sizeof (ApptInfoType) * apptMaxPerDay);\n    ErrFatalDisplayIf(!apptListH, \"Out of memory\");\n    if (! apptListH) return (0);\n\n    apptList = MemHandleLock (apptListH);\n\n    // Find the first non-repeating appointment of the day.\n    if (ApptFindFirst (dbP, date, &recordNum)) {\n        while (count < apptMaxPerDay) {\n            // Check if the appointment is on the date passed, if it is\n            // add it to the appointment list.\n            recordH = DmQueryRecord (dbP, recordNum);\n            r = MemHandleLock (recordH);\n            result = DateCompare (r->when.date, date);\n\n            if (result == 0) {\n                // Add the record to the appoitment list.\n                apptList[count].startTime = r->when.startTime;\n                apptList[count].endTime = r->when.endTime;\n                apptList[count].recordNum = recordNum;\n                count++;\n            }\n            MemHandleUnlock (recordH);\n            if (result != 0) break;\n\n            // Get the next record.\n            error = DmSeekRecordInCategory (dbP, &recordNum, 1,\n                                            dmSeekForward,\n                                            dmAllCategories);\n            if (error == dmErrSeekFailed) break;\n        }\n    }\n\n    // Add the repeating appointments to the list.  Repeating appointments\n    // are stored at the beginning of the database.\n    recordNum = 0;\n    while (count < apptMaxPerDay) {\n        recordH = DmQueryNextInCategory (dbP, &recordNum, dmAllCategories);\n        if (! recordH) break;\n        \n        r = (ApptPackedDBRecordPtr) MemHandleLock (recordH);\n        \n        repeats = (r->flags.repeat != 0);\n        if (repeats) {\n            ApptUnpack (r, &apptRec);\n            if (ApptRepeatsOnDate (&apptRec, date)) {\n                // Add the record to the appoitment list.\n                apptList[count].startTime = r->when.startTime;              \n                apptList[count].endTime = r->when.endTime;              \n                apptList[count].recordNum = recordNum;  \n                count++;\n            }\n        }\n        MemHandleUnlock (recordH);\n\n        // If the record has no repeating info we've reached the end of the \n        // repeating appointments.\n        if (! repeats) break;\n        \n        recordNum++;\n    }\n\n    // Sort the list by start time.\n    // SysInsertionSort (apptList, count, sizeof (ApptInfoType),\n    //          ApptListCompare, 0L);\n\n    // If there are no appointments on the specified day, free the appointment\n    // list.\n    if (count == 0) {\n        MemPtrFree (apptList);\n        apptListH = 0;\n    }\n    // Resize the appointment list block to release any unused space.\n    else {\n        MemHandleUnlock (apptListH);\n        MemHandleResize (apptListH, count * sizeof (ApptInfoType));\n    }\n\n    *countP = count;\n    return (apptListH);\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/* Get preferences, open (or create) app database */\n", "func_signal": "static UInt16 StartApplication(void)", "code": "{\n\tUInt32  version;\n\tErr     err;\n    UInt32  val;\n\tSonySysFtrSysInfoP sonySysFtrSysInfoP;\n\tUInt16  refNum;\n\n    gTableRowHandle = 0;\n\n    if (OpenDatabases() < 0) {\n/*         if (!DatebookDB) { */\n/*             /\\* */\n/*              * BTW make sure there is \" \" (single space) in unused ^1 ^2 ^3 */\n/*              * entries or PalmOS <= 2 will blow up. */\n/*              *\\/ */\n\n/*             SysCopyStringResource(gAppErrStr, DateBookFirstAlertString); */\n/*             FrmCustomAlert(ErrorAlert, gAppErrStr, \" \", \" \"); */\n/*         } */\n\n        return 1;\n    }\n    \n    err = lunar_OpenLibrary(&lunarRefNum, &lunarClientText);\n    if (err != errNone) {\n        FrmCustomAlert(ErrorAlert, \"Please install lunarlib.prc\", \" \", \" \");\n        return 1;\n    }\n\n\tif (_TRGVGAFeaturePresent(&version)) gbVgaExists = true;\n\telse gbVgaExists = false;\n\t\n\terr = FtrGet(sysFtrCreator, sysFtrNumROMVersion, &version);\n\tis35 = (version >= 0x03503000);\n\n    if (!FtrGet(sysFtrCreator, sysFtrNumOEMCompanyID, &val)) {\n        Err         error;\n        UInt32      width, height;\n\n        if (val == sonyHwrOEMCompanyID_Sony) {\n       \t\tif ((error = FtrGet(sonySysFtrCreator,\n                                sonySysFtrNumSysInfoP, (UInt32*)&sonySysFtrSysInfoP))) {\n                // NOT CLIE\n            }\n            else {\n                if ((sonySysFtrSysInfoP->extn & sonySysFtrSysInfoExtnSilk) &&\n                    (sonySysFtrSysInfoP->libr & sonySysFtrSysInfoLibrSilk)) {\n                    if ((error = SysLibFind(sonySysLibNameSilk, &refNum))) {\n                        if (error == sysErrLibNotFound) {\n                            // coulnd't find lib\n                            error = SysLibLoad('libr', sonySysFileCSilkLib, &refNum);\n                        }\n                    }\n                    if (!error ) {\n                        // the silkscreen library is available and usable\n                        if (VskGetAPIVersion(refNum) < 2) {\n                            error = SilkLibOpen(refNum);\n                        }\n                        else error = VskOpen(refNum); \n                        \n                        if (error == errNone) {\n                            EnableSilkResize(refNum, vskResizeVertically | vskResizeHorizontally);\n                        \n                            hrSRefNum = refNum;\n                            gSilkLibLoaded = true;\n                        }\n                    }\n                }\n            }\n\n            error = SysLibLoad('libr', sonySysFileCHRLib, &hrRefNum);\n            \n            if (!error) {\n                gSonyClie = true;\n\n                HROpen(hrRefNum);\n                width = hrWidth; height = hrHeight;\n                HRWinScreenMode(hrRefNum, winScreenModeSet, &width, &height, NULL, NULL);\n            }\n        }\n    }\n\n    if(gbVgaExists)\n    \tVgaSetScreenMode(screenMode1To1, rotateModeNone);\n\n    // set current date to  the starting date\n\tDateSecondsToDate(TimGetSeconds(), &gStartDate);\n    \n    GetEventNoteInfo();\n\n    if (gSilkLibLoaded) {\n    \t// for NR70, Notification manager\n\t\tLocalID             ProgramdbID;\n\t\tUInt16              ProgramcardNo;\n\t\n    \tSysCurAppDatabase (&ProgramcardNo, &ProgramdbID); \n        err = SysNotifyRegister(ProgramcardNo, ProgramdbID,\n                                sysNotifyDisplayChangeEvent, NR70GraffitiHandleEvent, \n                                sysNotifyNormalPriority, NULL);\n        ErrFatalDisplayIf( ( err != errNone ), \"can't register\" );\n    }\n    \n\n    return 0;\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/* Save preferences, close forms, close app database */\n", "func_signal": "static void StopApplication(void)", "code": "{\n    if (gSilkLibLoaded) {\n    \t// for NR70, Notification manager\n\t\tLocalID             ProgramdbID;\n\t\tUInt16              ProgramcardNo;\n        Int16 \t            error;\n\n    \tSysCurAppDatabase (&ProgramcardNo, &ProgramdbID);\n\n        error = SysNotifyUnregister(ProgramcardNo, ProgramdbID,\n                                    sysNotifyDisplayChangeEvent, sysNotifyNormalPriority);\n        ErrFatalDisplayIf( ( error != errNone ), \"can't unregister\" );\n        \n        if (VskGetAPIVersion(hrSRefNum) < 2) {\n            // old devices didn't restore the silkscreen automatically\n            // for applications that don't support silkscreen resizing;\n            // therefore, we need to restore the silkscreen explicitly\n            (void) ResizeSilk(hrSRefNum, vskResizeMax);\n        }\n\n        // disable silkscreen resizing before we quit\n        (void) EnableSilkResize(hrSRefNum, vskResizeDisable);\n\n        if (VskGetAPIVersion(hrSRefNum) < 2) {\n            SilkLibClose(hrSRefNum);\n        }\n        else VskClose(hrSRefNum); // same as SilkLibClose\n    }\n\n    if (gSonyClie) {\n        HRWinScreenMode(hrRefNum, winScreenModeSetToDefaults,\n                        NULL, NULL, NULL, NULL);\n        HRClose(hrRefNum);\n    }\n    \n    FrmSaveAllForms();\n    FrmCloseAllForms();\n    CloseDatabases();\n    freememories();\n\n    lunar_CloseLibrary(lunarRefNum, lunarClientText);\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptUnpack\n *\n *  DESCRIPTION: Fills in the ApptDBRecord structure\n *\n *  PARAMETERS: database record\n *\n *  RETURNS: the record unpacked\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "void ApptUnpack(ApptPackedDBRecordPtr src, ApptDBRecordPtr dest)", "code": "{\n    ApptDBRecordFlags   flags;\n    char *p;\n\n\n    flags = src->flags;\n    p = &src->firstField;\n    dest->when = (ApptDateTimeType *) src;\n\n    if (flags.alarm) {\n        dest->alarm = (AlarmInfoType *) p;\n        p += sizeof (AlarmInfoType);\n    } else\n        dest->alarm = NULL;\n\n\n    if (flags.repeat) {\n        dest->repeat = (RepeatInfoType *) p;\n        p += sizeof (RepeatInfoType);\n    } else\n        dest->repeat = NULL;\n\n\n    if (flags.exceptions) {\n        dest->exceptions = (ExceptionsListType *) p;\n        p += sizeof (UInt16) +\n            (((ExceptionsListType *) p)->numExceptions * sizeof (DateType));\n    } else\n        dest->exceptions = NULL;\n\n\n    if (flags.description) {\n        dest->description = p;\n        p += StrLen(p) + 1;\n    } else\n        dest->description = NULL;\n\n\n    if (flags.note) {\n        dest->note = p;\n    } else\n        dest->note = NULL;\n\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "// check if description has the information about name1 and name2\n//\n", "func_signal": "Boolean IsSameRecord(Char* notefield, HappyDays birth)", "code": "{\n    Char *p;\n    \n    if (notefield && (p = StrStr(notefield,gPrefsR.notifywith))) {\n        p += StrLen(gPrefsR.notifywith);\n\n        StrPrintF(gAppErrStr, \"%ld\", Hash(birth.name1,birth.name2));\n        \n        if (StrCompare(gAppErrStr, p) ==0) return true;\n    }\n    return false;\n}", "path": "notify.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptPack\n *\n *  DESCRIPTION: Pack an ApptDBRecordType\n *\n *  PARAMETERS: database record\n *\n *  RETURNS: the ApptPackedDBRecord is packed\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "static void ApptPack(ApptDBRecordPtr s, ApptPackedDBRecordPtr d)", "code": "{\n    ApptDBRecordFlags   flags;\n    UInt16    size;\n    UInt32    offset = 0;\n\n\n    *(unsigned char *)&flags = 0;           // clear the flags\n\n\n    // copy the ApptDateTimeType\n    //c = (char *) d;\n    offset = 0;\n    DmWrite(d, offset, s->when, sizeof(ApptDateTimeType));\n    offset += sizeof (ApptDateTimeType) + sizeof (ApptDBRecordFlags);\n\n\n    if (s->alarm != NULL) {\n        DmWrite(d, offset, s->alarm, sizeof(AlarmInfoType));\n        offset += sizeof (AlarmInfoType);\n        flags.alarm = 1;\n    }\n\n\n    if (s->repeat != NULL) {\n        DmWrite(d, offset, s->repeat, sizeof(RepeatInfoType));\n        offset += sizeof (RepeatInfoType);\n        flags.repeat = 1;\n    }\n\n\n    if (s->exceptions != NULL) {\n        size = sizeof (UInt16) +\n            (s->exceptions->numExceptions * sizeof (DateType));\n        DmWrite(d, offset, s->exceptions, size);\n        offset += size;\n        flags.exceptions = 1;\n    }\n\n\n    if (s->description != NULL) {\n        size = StrLen(s->description) + 1;\n        DmWrite(d, offset, s->description, size);\n        offset += size;\n        flags.description = 1;\n    }\n\n\n\n    if (s->note != NULL) {\n        size = StrLen(s->note) + 1;\n        DmWrite(d, offset, s->note, size);\n        offset += size;\n        flags.note = 1;\n    }\n\n    DmWrite(d, sizeof(ApptDateTimeType), &flags, sizeof(flags));\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/***********************************************************************\n *\n * FUNCTION:    TimeCompare\n *\n * DESCRIPTION: This routine compares two times.  \"No time\" is represented\n *              by minus one, and is considered less than all times.\n *\n * PARAMETERS:  nothing\n *\n * RETURNED:    if t1 > t2  returns a positive int\n *              if t1 < t2  returns a negative int\n *              if t1 = t2  returns zero\n *\n * REVISION HISTORY:\n *          Name    Date        Description\n *          ----    ----        -----------\n *          art 6/12/95     Initial Revision\n *\n ***********************************************************************/\n", "func_signal": "static Int16 TimeCompare (TimeType t1, TimeType t2)", "code": "{\n    Int16 int1, int2;\n\n    int1 = TimeToInt(t1);\n    int2 = TimeToInt(t2);\n\n    if (int1 > int2)\n        return (1);\n    else if (int1 < int2)\n        return (-1);\n    return 0;\n\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "// check global notify preference, and make datebookDB entry private\n//\n", "func_signal": "void ChkNMakePrivateRecord(DmOpenRef db, Int16 index)", "code": "{\n    UInt16 attributes;\n    // if private is set, make the record private\n    //\n    if (gPrefsR.private == 1) {\n        DmRecordInfo(db, index, &attributes, NULL,NULL);\n        attributes |= dmRecAttrSecret;\n        DmSetRecordInfo(db, index, &attributes, NULL);\n    }\n}", "path": "notify.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "// temporary return value;\n", "func_signal": "Char* EventTypeString(HappyDays r)", "code": "{\n\tstatic char tmpString[4];\n    \n    if (!r.custom[0]) {\n        tmpString[0] = gPrefsR.custom[0];\n    }\n    else tmpString[0] = r.custom[0];\n    tmpString[1] = 0;\n\n    StrToLower(&tmpString[2], tmpString);     // use temporary\n    tmpString[2] = tmpString[2] - 'a' + 'A';  // make upper\n    tmpString[3] = 0;\n\n    return &tmpString[2];\n}", "path": "notify.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptNewRecord\n *\n *  DESCRIPTION: Create a new packed record in sorted position\n *\n *  PARAMETERS: database pointer\n *              database record\n *\n *  RETURNS: ##0 if successful, error code if not\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "Err ApptNewRecord(DmOpenRef dbP, ApptDBRecordPtr r, UInt16 *index)", "code": "{\n    MemHandle recordH;\n    ApptPackedDBRecordPtr recordP;\n    UInt16                    newIndex;\n    Err err;\n\n\n    // Make a new chunk with the correct size.\n    recordH = DmNewHandle (dbP, (UInt32) ApptPackedSize(r));\n    if (recordH == NULL)\n        return dmErrMemError;\n\n    recordP = MemHandleLock (recordH);\n\n    // Copy the data from the unpacked record to the packed one.\n    ApptPack (r, recordP);\n\n    newIndex = ApptFindSortPosition(dbP, recordP);\n\n    MemPtrUnlock (recordP);\n\n    // 4) attach in place\n    err = DmAttachRecord(dbP, &newIndex, recordH, 0);\n    if (err)\n        MemHandleFree(recordH);\n    else\n        *index = newIndex;\n\n    return err;\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: AddrUnpack\n *\n *  DESCRIPTION: Fills in the AddrDBRecord structure\n *\n *  PARAMETERS: address record to unpack\n *                the address record to unpack into\n *\n *  RETURNS: the record unpacked\n *\n *  CREATED: 1/14/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "void AddrUnpack(AddrPackedDBRecord *src, AddrDBRecordPtr dest)", "code": "{\n    Int16 index;\n    UInt32 flags;\n    char *p;\n\n    dest->options = src->options;\n    flags = src->flags.allBits;\n    p = &src->firstField;\n         \n    for (index=firstAddressField; index < addressFieldsCount; index++) {\n        /* If the flag is set point to the string else NULL */\n        if (GetBitMacro(flags, index) != 0) {\n            dest->fields[index] = p;\n            p += StrLen(p) + 1;\n        } else dest->fields[index] = NULL;\n    }\n}", "path": "address.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/* Main entry point; it is unlikely you will need to change this except to\n   handle other launch command codes */\n", "func_signal": "UInt32 PilotMain(UInt16 cmd, MemPtr cmdPBP, UInt16 launchFlags)", "code": "{\n    UInt16 err;\n\n    if (cmd == sysAppLaunchCmdNormalLaunch) {\n        err = StartApplication();\n        if (err) return err;\n\n\t\tFrmGotoForm(StartForm);     // read the address db and so\n        EventLoop();\n        StopApplication();\n\t}\n\t// Launch code sent to running app before sysAppLaunchCmdFind\n\t// or other action codes that will cause data searches or manipulation.              \n\telse if (cmd == sysAppLaunchCmdSaveData) {\n   \t\tFrmSaveAllForms();\n   \t}\n   \telse if (cmd == sysAppLaunchCmdFind) {\n      \tSearch((FindParamsPtr)cmdPBP);\n    } \n\t// This launch code might be sent to the app when it's already running\n   \telse if (cmd == sysAppLaunchCmdGoTo) {\n      \tBoolean  launched;\n      \tlaunched = launchFlags & sysAppLaunchFlagNewGlobals;\n      \n      \tif (launched) {\n         \terr = StartApplication();\n         \tif (!err) {\n            \tGoToItem((GoToParamsPtr) cmdPBP, launched);\n            \tEventLoop();\n            \tStopApplication();   \n         \t}\n      \t} else {\n         \tGoToItem((GoToParamsPtr) cmdPBP, launched);\n      \t}\n   \t}\n\telse {\n        return sysErrParamErr;\n    }\n\n    return 0;\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptGetRepeatInfo\n *\n *  DESCRIPTION: Fills in the ApptDBRecord structure\n *\n *  PARAMETERS: database record\n *\n *  RETURNS: the record unpacked\n *\n *  CREATED: 4/28/03\n *\n *  BY: Peter Epstein\n *\n *************************************************************/\n", "func_signal": "RepeatInfoPtr ApptGetRepeatInfo(ApptPackedDBRecordPtr src)", "code": "{\n\tApptDBRecordFlags\tflags;\n\tchar *p;\n\n\t\n\tflags = src->flags;\n\tp = &src->firstField;\n\n\tif (flags.alarm) \n\t\tp += sizeof (AlarmInfoType);\n\n\tif (flags.repeat)\n\t\treturn (RepeatInfoType *) p;\n\telse\n\t\treturn NULL;\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptFindSortPosition\n *\n *  DESCRIPTION: Return where a record is or should be\n *      Useful to find or find where to insert a record.\n *\n *  PARAMETERS: database record\n *\n *  RETURNS: position where a record should be\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "static UInt16 ApptFindSortPosition(DmOpenRef dbP, ApptPackedDBRecordPtr\n                                 newRecord)", "code": "{\n    return (DmFindSortPosition (dbP, newRecord, NULL,\n                                (DmComparF *)ApptComparePackedRecords, 0));\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/***********************************************************************\n *\n * FUNCTION:    ApptFindFirst\n *\n * DESCRIPTION: This routine finds the first appointment on the specified\n *              day.\n *\n * PARAMETERS:  dbP    - pointer to the database\n *              date   - date to search for\n *              indexP - pointer to the index of the first record on the \n *                       specified day (returned value)\n *\n * RETURNED:    true if a record has found\n *\n * REVISION HISTORY:\n *          Name    Date        Description\n *          ----    ----        -----------\n *          art 6/15/95     Initial Revision\n *\n ***********************************************************************/\n", "func_signal": "Boolean ApptFindFirst (DmOpenRef dbP, DateType date, UInt16 * indexP)", "code": "{\n    Err err;\n    Int16 numOfRecords;\n    Int16 kmin, probe, i;     // all positions in the database.\n    Int16 result = 0;         // result of comparing two records\n    UInt16 index;\n    MemHandle recordH;\n    Boolean found = false;\n    ApptPackedDBRecordPtr r;\n\n    kmin = probe = 0;\n    numOfRecords = DmNumRecords(dbP);\n\n\n    while (numOfRecords > 0) {\n        i = numOfRecords >> 1;\n        probe = kmin + i;\n\n        index = probe;\n        recordH = DmQueryNextInCategory (dbP, &index, dmAllCategories);\n        if (recordH) {\n            r = (ApptPackedDBRecordPtr) MemHandleLock (recordH);\n            if (r->flags.repeat)\n                result = 1;\n            else\n                result = DateCompare (date, r->when.date);\n            MemHandleUnlock (recordH);\n        }\n\n        // If no handle, assume the record is deleted, deleted records\n        // are greater.\n        else\n            result = -1;\n\n\n        // If the date passed is less than the probe's date, keep searching.\n        if (result < 0)\n            numOfRecords = i;\n\n        // If the date passed is greater than the probe's date, keep searching.\n        else if (result > 0) {\n            kmin = probe + 1;\n            numOfRecords = numOfRecords - i - 1;\n        }\n\n        // If the records are equal find the first record on the day.\n        else {\n            found = true;\n            *indexP = index;\n            while (true) {\n                err = DmSeekRecordInCategory (dbP, &index, 1, dmSeekBackward,\n                                              dmAllCategories);\n                if (err == dmErrSeekFailed) break;\n\n                recordH = DmQueryRecord(dbP, index);\n                r = (ApptPackedDBRecordPtr) MemHandleLock (recordH);\n                if (r->flags.repeat)\n                    result = 1;\n                else\n                    result = DateCompare (date, r->when.date);\n                MemHandleUnlock (recordH);\n                if (result != 0) break;\n                *indexP = index;\n            }\n\n            break;\n        }\n    }\n\n\n    // If that were no appointments on the specified day, return the\n    // index of the next appointment (on a future day).\n    if (! found) {\n        if (result < 0)\n            *indexP = probe;\n        else\n            *indexP = probe + 1;\n    }\n\n    return (found);\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/* The main event loop */\n", "func_signal": "static void EventLoop(void)", "code": "{\n    UInt16 err;\n    EventType e;\n\n    do {\n        EvtGetEvent(&e, evtWaitForever);\n\n        if (SpecialKeyDown(&e)) continue;\n        \n        if (SysHandleEvent(&e)) continue;\n        if (MenuHandleEvent (NULL, &e, &err)) continue;\n        \n        if (! ApplicationHandleEvent (&e))\n            FrmDispatchEvent (&e);\n    } while (e.eType != appStopEvent && !gProgramExit);\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/*\n * These are called in StartApplication and StopApplication because they\n * are required memory allocations that exist from start to finish of the\n * application run.\n */\n", "func_signal": "static void freememories(void)", "code": "{\n    if (gTableRowHandle) {\n        MemHandleFree(gTableRowHandle);\n        gTableRowHandle = 0;\n    }\n    \n    if (gEventNoteInfo) MemPtrFree(gEventNoteInfo);\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/***********************************************************************\n *\n * FUNCTION:    GoToItem\n *\n * DESCRIPTION: This routine is a entry point of this application.\n *              It is generally call as the result of hiting of \n *              \"Go to\" button in the text search dialog.\n *\n * PARAMETERS:    recordNum - \n ***********************************************************************/\n", "func_signal": "static void GoToItem (GoToParamsPtr goToParams, Boolean launchingApp)", "code": "{\n   \tUInt16 recordNum;\n   \tEventType event;\n\tLineItemPtr ptr;\n\tInt16 selected = -1;\n\tInt16 i;\n\n   \trecordNum = goToParams->recordNum;\n\n  \t// If the application is already running, close all the open forms.  If\n   \t// the current record is blank, then it will be deleted, so we'll \n   \t// the record's unique id to find the record index again, after all \n   \t// the forms are closed.\n   \tif (! launchingApp) {\n\t\tUInt32 uniqueID;\n\t\tDmRecordInfo (MainDB, recordNum, NULL, &uniqueID, NULL);\n      \tFrmCloseAllForms ();\n      \tDmFindRecordByID (MainDB, uniqueID, &recordNum);\n   \t}\n\n\t// initialize category\n\t//\n\tStrCopy(gPrefsR.addrCategory, \"All\");\n\n\tMainFormReadDB();\n\n\n\t// find the inital gMainTableStart \n\t// \n\tif (gMainTableTotals <= 0) return;\n\tif ((ptr = MemHandleLock(gTableRowHandle))) {\n\t\tfor (i = 0; i < gMainTableTotals; i++) {\n\t\t\tif (ptr[i].birthRecordNum == recordNum) {\n\t\t\t\tselected = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tMemPtrUnlock(ptr);\n\t}\n\n\t// gMainTableStart = MAX(0, selected-4);\n\tFrmGotoForm(MainForm);\n   \tMemSet (&event, sizeof(EventType), 0);\n\n   \t// Send an event to goto a form and select the matching text.\n   \tevent.eType = frmGotoEvent;\n   \tevent.data.frmGoto.formID = MainForm;\n\t// trick selected number is returned by recordNum\n   \tevent.data.frmGoto.recordNum = selected;\n   \tevent.data.frmGoto.matchPos = goToParams->matchPos;\n   \tevent.data.frmGoto.matchLen = goToParams->searchStrLen;\n   \tevent.data.frmGoto.matchFieldNum = goToParams->matchFieldNum;\n   \tEvtAddEventToQueue (&event);\n}", "path": "happydays.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/************************************************************\n *\n *  FUNCTION: ApptPackedSize\n *\n *  DESCRIPTION: Return the packed size of an ApptDBRecordType \n *\n *  PARAMETERS: database record\n *\n *  RETURNS: the size in bytes\n *\n *  CREATED: 1/25/95 \n *\n *  BY: Roger Flores\n *\n *************************************************************/\n", "func_signal": "static UInt16 ApptPackedSize (ApptDBRecordPtr r)", "code": "{\n    UInt16 size;\n\n\n    size = sizeof (ApptDateTimeType) + sizeof (ApptDBRecordFlags);\n\n    if (r->alarm != NULL)\n        size += sizeof (AlarmInfoType);\n\n    if (r->repeat != NULL)\n        size += sizeof (RepeatInfoType);\n\n    if (r->exceptions != NULL)\n        size += sizeof (UInt16) +\n            (r->exceptions->numExceptions * sizeof (DateType));\n\n    if (r->description != NULL)\n        size += StrLen(r->description) + 1;\n\n    if (r->note != NULL)\n        size += StrLen(r->note) + 1;\n\n\n    return size;\n}", "path": "datebook.c", "repo_name": "jmjeong/happydays.palm", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 920}
{"docstring": "/* default credit distribution callback, NOTE, this callback holds the TX lock */\n", "func_signal": "void HTCDefaultCreditDist(void                     *Context,\n                          HTC_ENDPOINT_CREDIT_DIST *pEPDistList,\n                          HTC_CREDIT_DIST_REASON   Reason)", "code": "{\n    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;\n\n    if (Reason == HTC_CREDIT_DIST_SEND_COMPLETE) {\n        pCurEpDist = pEPDistList;\n            /* simple distribution */\n        while (pCurEpDist != NULL) {\n            if (pCurEpDist->TxCreditsToDist > 0) {\n                    /* just give the endpoint back the credits */\n                pCurEpDist->TxCredits += pCurEpDist->TxCreditsToDist;\n                pCurEpDist->TxCreditsToDist = 0;\n            }\n            pCurEpDist = pCurEpDist->pNext;\n        }\n    }\n\n    /* note we do not need to handle the other reason codes as this is a very\n     * simple distribution scheme, no need to seek for more credits or handle inactivity */\n}", "path": "target\\linux\\s3c24xx\\files-2.6.31\\drivers\\ar6000\\htc\\htc_services.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * routines to write data to the output file\n */\n", "func_signal": "int\nwrite_out_data(FILE *outfile, uint8_t *data, size_t len,\n\t\tstruct csum_state *css)", "code": "{\n\terrno = 0;\n\n\tfwrite(data, len, 1, outfile);\n\tif (errno) {\n\t\tERRS(\"unable to write output file\");\n\t\treturn ERR_FATAL;\n\t}\n\n\tif (css) {\n\t\tcsum_update(data, len, css);\n\t}\n\n\treturn 0;\n}", "path": "tools\\firmware-utils\\src\\mkcasfw.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static inline void adm5120_rx_dma_update(struct dma_desc *desc,\n\tstruct sk_buff *skb, int end)", "code": "{\n\tdesc->misc = 0;\n\tdesc->buf2 = 0;\n\tdesc->buflen = RX_MAX_PKTLEN;\n\tdesc->buf1 = DESC_ADDR(skb->data) |\n\t\tDESC_OWN | (end ? DESC_EOR : 0);\n}", "path": "target\\linux\\adm5120\\files\\drivers\\net\\adm5120sw.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * our driver startup and shutdown routines\n */\n", "func_signal": "static int\nnull_init(void)", "code": "{\n\tdprintk(\"%s(%p)\\n\", __FUNCTION__, null_init);\n\n\tmemset(&nulldev, 0, sizeof(nulldev));\n\tsoftc_device_init(&nulldev, \"ocfnull\", 0, null_methods);\n\n\tnull_id = crypto_get_driverid(softc_get_device(&nulldev),\n\t\t\t\tCRYPTOCAP_F_HARDWARE);\n\tif (null_id < 0)\n\t\tpanic(\"ocfnull: crypto device cannot initialize!\");\n\n#define\tREGISTER(alg) \\\n\tcrypto_register(null_id,alg,0,0)\n\tREGISTER(CRYPTO_DES_CBC);\n\tREGISTER(CRYPTO_3DES_CBC);\n\tREGISTER(CRYPTO_RIJNDAEL128_CBC);\n\tREGISTER(CRYPTO_MD5);\n\tREGISTER(CRYPTO_SHA1);\n\tREGISTER(CRYPTO_MD5_HMAC);\n\tREGISTER(CRYPTO_SHA1_HMAC);\n#undef REGISTER\n\n\treturn 0;\n}", "path": "target\\linux\\generic-2.6\\files\\crypto\\ocf\\ocfnull\\ocfnull.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static void sw_dump_desc(char *label, struct dma_desc *desc, int tx)", "code": "{\n\tu32 t;\n\n\tSW_DBG(\"%s %s desc/%p\\n\", label, tx ? \"tx\" : \"rx\", desc);\n\n\tt = desc->buf1;\n\tSW_DBG(\"    buf1 %08X addr=%08X; len=%08X %s%s\\n\", t,\n\t\tt & DESC_ADDR_MASK,\n\t\tdesc->buflen,\n\t\t(t & DESC_OWN) ? \"SWITCH\" : \"CPU\",\n\t\t(t & DESC_EOR) ? \" RE\" : \"\");\n\n\tt = desc->buf2;\n\tSW_DBG(\"    buf2 %08X addr=%08X%s\\n\", desc->buf2,\n\t\tt & DESC_ADDR_MASK,\n\t\t(t & DESC_BUF2_EN) ? \" EN\" : \"\" );\n\n\tt = desc->misc;\n\tif (tx)\n\t\tSW_DBG(\"    misc %08X%s pktlen=%04X ports=%02X vlan=%02X\\n\", t,\n\t\t\t(t & DESC_CSUM) ? \" CSUM\" : \"\",\n\t\t\t(t >> DESC_PKTLEN_SHIFT) & DESC_PKTLEN_MASK,\n\t\t\t(t >> DESC_DSTPORT_SHIFT) & DESC_DSTPORT_MASK,\n\t\t\tt & DESC_VLAN_MASK);\n\telse\n\t\tSW_DBG(\"    misc %08X pktlen=%04X port=%d DA=%d%s%s type=%d\\n\",\n\t\t\tt,\n\t\t\t(t >> DESC_PKTLEN_SHIFT) & DESC_PKTLEN_MASK,\n\t\t\t(t >> DESC_SRCPORT_SHIFT) & DESC_SRCPORT_MASK,\n\t\t\t(t >> DESC_DA_SHIFT) & DESC_DA_MASK,\n\t\t\t(t & DESC_IPCSUM_FAIL) ? \" IPCF\" : \"\",\n\t\t\t(t & DESC_VLAN_TAG) ? \" VLAN\" : \"\",\n\t\t\t(t & DESC_TYPE_MASK));\n}", "path": "target\\linux\\adm5120\\files\\drivers\\net\\adm5120sw.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* -------------------------------------------------------------------------- */\n", "func_signal": "static int __init adm5120_switch_mod_init(void)", "code": "{\n\tint err;\n\n\tpr_info(DRV_DESC \" version \" DRV_VERSION \"\\n\");\n\terr = platform_driver_register(&adm5120_switch_driver);\n\n\treturn err;\n}", "path": "target\\linux\\adm5120\\files\\drivers\\net\\adm5120sw.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Process a request.\n */\n", "func_signal": "static int\nnull_process(device_t arg, struct cryptop *crp, int hint)", "code": "{\n\tunsigned int lid;\n\n\tdprintk(\"%s()\\n\", __FUNCTION__);\n\n\t/* Sanity check */\n\tif (crp == NULL) {\n\t\tdprintk(\"%s,%d: EINVAL\\n\", __FILE__, __LINE__);\n\t\treturn EINVAL;\n\t}\n\n\tcrp->crp_etype = 0;\n\n\tif (crp->crp_desc == NULL || crp->crp_buf == NULL) {\n\t\tdprintk(\"%s,%d: EINVAL\\n\", __FILE__, __LINE__);\n\t\tcrp->crp_etype = EINVAL;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * find the session we are using\n\t */\n\n\tlid = crp->crp_sid & 0xffffffff;\n\tif (lid >= null_sesnum || lid == 0) {\n\t\tcrp->crp_etype = ENOENT;\n\t\tdprintk(\"%s,%d: ENOENT\\n\", __FILE__, __LINE__);\n\t\tgoto done;\n\t}\n\ndone:\n\tcrypto_done(crp);\n\treturn 0;\n}", "path": "target\\linux\\generic-2.6\\files\\crypto\\ocf\\ocfnull\\ocfnull.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Output SHA-1(file contents), returns 0 if successful.\n */\n", "func_signal": "int sha1_file( char *filename, uchar digest[20] )", "code": "{\n    FILE *f;\n    size_t n;\n    sha1_context ctx;\n    uchar buf[1024];\n\n    if( ( f = fopen( filename, \"rb\" ) ) == NULL )\n        return( 1 );\n\n    sha1_starts( &ctx );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha1_update( &ctx, buf, (uint) n );\n\n    sha1_finish( &ctx, digest );\n\n    fclose( f );\n    return( 0 );\n}", "path": "tools\\firmware-utils\\src\\sha1.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* default credit init callback */\n", "func_signal": "static void HTCDefaultCreditInit(void                     *Context,\n                                 HTC_ENDPOINT_CREDIT_DIST *pEPList,\n                                 int                      TotalCredits)", "code": "{\n    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;\n    int                      totalEps = 0;\n    int                      creditsPerEndpoint;\n\n    pCurEpDist = pEPList;\n        /* first run through the list and figure out how many endpoints we are dealing with */\n    while (pCurEpDist != NULL) {\n        pCurEpDist = pCurEpDist->pNext;\n        totalEps++;\n    }\n\n        /* even distribution */\n    creditsPerEndpoint = TotalCredits/totalEps;\n\n    pCurEpDist = pEPList;\n        /* run through the list and set minimum and normal credits and\n         * provide the endpoint with some credits to start */\n    while (pCurEpDist != NULL) {\n\n        if (creditsPerEndpoint < pCurEpDist->TxCreditsPerMaxMsg) {\n                /* too many endpoints and not enough credits */\n            AR_DEBUG_ASSERT(FALSE);\n            break;\n        }\n            /* our minimum is set for at least 1 max message */\n        pCurEpDist->TxCreditsMin = pCurEpDist->TxCreditsPerMaxMsg;\n            /* this value is ignored by our credit alg, since we do\n             * not dynamically adjust credits, this is the policy of\n             * the \"default\" credit distribution, something simple and easy */\n        pCurEpDist->TxCreditsNorm = 0xFFFF;\n            /* give the endpoint minimum credits */\n        pCurEpDist->TxCredits = creditsPerEndpoint;\n        pCurEpDist->TxCreditsAssigned = creditsPerEndpoint;\n        pCurEpDist = pCurEpDist->pNext;\n    }\n\n}", "path": "target\\linux\\s3c24xx\\files-2.6.31\\drivers\\ar6000\\htc\\htc_services.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* convert the sector number into a CHS value for the partition table */\n", "func_signal": "static void to_chs(long sect, unsigned char chs[3])", "code": "{\n\tint c,h,s;\n\t\n\ts = (sect % sectors) + 1;\n\tsect = sect / sectors;\n\th = sect % heads;\n\tsect = sect / heads;\n\tc = sect;\n\n\tchs[0] = h;\n\tchs[1] = s | ((c >> 2) & 0xC0);\n\tchs[2] = c & 0xFF;\n\n\treturn;\n}", "path": "tools\\firmware-utils\\src\\ptgen.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* check the partition sizes and write the partition table */\n", "func_signal": "static int gen_ptable(int nr)", "code": "{\n\tstruct pte pte[4];\n\tunsigned long sect = 0; \n\tint i, fd, ret = -1, start, len;\n\n\tmemset(pte, 0, sizeof(struct pte) * 4);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (!parts[i].size) {\n\t\t\tfprintf(stderr, \"Invalid size in partition %d!\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\t\tpte[i].active = ((i + 1) == active) ? 0x80 : 0;\n\t\tpte[i].type = parts[i].type;\n\t\tpte[i].start = cpu_to_le16(start = sect + sectors);\n\t\tsect = round_to_cyl(start + parts[i].size * 2);\n\t\tpte[i].length = cpu_to_le16(len = sect - start);\n\t\tto_chs(start, pte[i].chs_start);\n\t\tto_chs(start + len - 1, pte[i].chs_end);\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"Partition %d: start=%ld, end=%ld, size=%ld\\n\", i, (long) start * 512, ((long) start + (long) len) * 512, (long) len * 512);\n\t\tprintf(\"%ld\\n\", ((long) start * 512));\n\t\tprintf(\"%ld\\n\", ((long) len * 512));\n\t}\n\n\tif ((fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0) {\n\t\tfprintf(stderr, \"Can't open output file '%s'\\n\",filename);\n\t\treturn -1;\n\t}\n\n\tlseek(fd, 446, SEEK_SET);\n\tif (write(fd, pte, sizeof(struct pte) * 4) != sizeof(struct pte) * 4) {\n\t\tfprintf(stderr, \"write failed.\\n\");\n\t\tgoto fail;\n\t}\n\tlseek(fd, 510, SEEK_SET);\n\tif (write(fd, \"\\x55\\xaa\", 2) != 2) {\n\t\tfprintf(stderr, \"write failed.\\n\");\n\t\tgoto fail;\n\t}\n\t\n\tret = 0;\nfail:\n\tclose(fd);\n\treturn ret;\n}", "path": "tools\\firmware-utils\\src\\ptgen.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Core SHA-1 functions\n */\n", "func_signal": "void sha1_starts( sha1_context *ctx )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}", "path": "tools\\firmware-utils\\src\\sha1.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Generate a new software session.\n */\n", "func_signal": "static int\nnull_newsession(device_t arg, u_int32_t *sid, struct cryptoini *cri)", "code": "{\n\tdprintk(\"%s()\\n\", __FUNCTION__);\n\tif (sid == NULL || cri == NULL) {\n\t\tdprintk(\"%s,%d - EINVAL\\n\", __FILE__, __LINE__);\n\t\treturn EINVAL;\n\t}\n\n\tif (null_sesnum == 0)\n\t\tnull_sesnum++;\n\t*sid = null_sesnum++;\n\treturn 0;\n}", "path": "target\\linux\\generic-2.6\\files\\crypto\\ocf\\ocfnull\\ocfnull.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static void adm5120_switch_cleanup(void)", "code": "{\n\tint i;\n\n\t/* disable interrupts */\n\tsw_int_mask(SWITCH_INTS_ALL);\n\n\tfor (i = 0; i < SWITCH_NUM_PORTS; i++) {\n\t\tstruct net_device *dev = adm5120_devs[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tadm5120_switch_tx_ring_free();\n\tadm5120_switch_rx_ring_free();\n}", "path": "target\\linux\\adm5120\\files\\drivers\\net\\adm5120sw.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Output SHA-1(buf)\n */\n", "func_signal": "void sha1_csum( uchar *buf, uint buflen, uchar digest[20] )", "code": "{\n    sha1_context ctx;\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, buf, buflen );\n    sha1_finish( &ctx, digest );\n}", "path": "tools\\firmware-utils\\src\\sha1.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Output HMAC-SHA-1(key,buf)\n */\n", "func_signal": "void sha1_hmac( uchar *key, uint keylen, uchar *buf, uint buflen,\n                uchar digest[20] )", "code": "{\n    uint i;\n    sha1_context ctx;\n    uchar k_ipad[64];\n    uchar k_opad[64];\n    uchar tmpbuf[20];\n\n    memset( k_ipad, 0x36, 64 );\n    memset( k_opad, 0x5C, 64 );\n\n    for( i = 0; i < keylen; i++ )\n    {\n        if( i >= 64 ) break;\n\n        k_ipad[i] ^= key[i];\n        k_opad[i] ^= key[i];\n    }\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, k_ipad, 64 );\n    sha1_update( &ctx, buf, buflen );\n    sha1_finish( &ctx, tmpbuf );\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, k_opad, 64 );\n    sha1_update( &ctx, tmpbuf, 20 );\n    sha1_finish( &ctx, digest );\n\n    memset( k_ipad, 0, 64 );\n    memset( k_opad, 0, 64 );\n    memset( tmpbuf, 0, 20 );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}", "path": "tools\\firmware-utils\\src\\sha1.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int sha1_self_test( void )", "code": "{\n    int i, j;\n    uchar buf[1000];\n    uchar sha1sum[20];\n    sha1_context ctx;\n\n    for( i = 0; i < 3; i++ )\n    {\n        printf( \"  SHA-1 test #%d: \", i + 1 );\n\n        sha1_starts( &ctx );\n\n        if( i < 2 )\n            sha1_update( &ctx, (uchar *) sha1_test_str[i],\n                         strlen( sha1_test_str[i] ) );\n        else\n        {\n            memset( buf, 'a', 1000 );\n            for( j = 0; j < 1000; j++ )\n                sha1_update( &ctx, (uchar *) buf, 1000 );\n        }\n\n        sha1_finish( &ctx, sha1sum );\n\n        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )\n        {\n            printf( \"failed\\n\" );\n            return( 1 );\n        }\n\n        printf( \"passed\\n\" );\n    }\n\n    printf( \"\\n\" );\n    return( 0 );\n}", "path": "tools\\firmware-utils\\src\\sha1.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* callback when a control message arrives on this endpoint */\n", "func_signal": "void HTCControlRecv(void *Context, HTC_PACKET *pPacket)", "code": "{\n    AR_DEBUG_ASSERT(pPacket->Endpoint == ENDPOINT_0);\n\n        /* the only control messages we are expecting are NULL messages (credit resports), which should\n         * never get here */\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n                    (\"HTCControlRecv, got message with length:%d \\n\",\n                    pPacket->ActualLength + HTC_HDR_LENGTH));\n\n        /* dump header and message */\n    DebugDumpBytes(pPacket->pBuffer - HTC_HDR_LENGTH,\n                   pPacket->ActualLength + HTC_HDR_LENGTH,\n                   \"Unexpected ENDPOINT 0 Message\");\n\n    HTC_RECYCLE_RX_PKT((HTC_TARGET*)Context,pPacket);\n}", "path": "target\\linux\\s3c24xx\\files-2.6.31\\drivers\\ar6000\\htc\\htc_services.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* round the sector number up to the next cylinder */\n", "func_signal": "static inline unsigned long round_to_cyl(long sect)", "code": "{\n\tint cyl_size = heads * sectors;\n\n\treturn sect + cyl_size - (sect % cyl_size); \n}", "path": "tools\\firmware-utils\\src\\ptgen.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/* \n * parse the size argument, which is either\n * a simple number (K assumed) or\n * K, M or G\n *\n * returns the size in KByte\n */\n", "func_signal": "static long to_kbytes(const char *string)", "code": "{\n\tint exp = 0;\n\tlong result;\n\tchar *end;\n\n\tresult = strtoul(string, &end, 0);\n\tswitch (tolower(*end)) {\n\t\t\tcase 'k' :\n\t\t\tcase '\\0' : exp = 0; break;\n\t\t\tcase 'm' : exp = 1; break;\n\t\t\tcase 'g' : exp = 2; break;\n\t\t\tdefault: return 0;\n\t}\n\n\tif (*end)\n\t\tend++;\n\n\tif (*end) {\n\t\tfprintf(stderr, \"garbage after end of number\\n\");\n\t\treturn 0;\n\t}\n\n\t/* result: number + 1024^(exp) */\n\treturn result * ((2 << ((10 * exp) - 1)) ?: 1);\n}", "path": "tools\\firmware-utils\\src\\ptgen.c", "repo_name": "hentel/openwrt", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 67165}
{"docstring": "/*\n** This is the test layer's wrapper around sqlite3OsFree(). The argument is a\n** pointer to the space allocated for the application to use.\n*/\n", "func_signal": "static void OSFREE(void *pFree)", "code": "{\n  u32 *p;         /* Pointer to the OS-layer allocation */\n  sqlite3OsEnterMutex();\n  p = (u32 *)getOsPointer(pFree);\n  checkGuards(p);\n  unlinkAlloc(p);\n  memset(pFree, 0x55, OSSIZEOF(pFree));\n  sqlite3OsFree(p);\n  sqlite3_nFree++;\n  sqlite3OsLeaveMutex();\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/* AFP-style locking following the behavior of unixLock, see the unixLock \n** function comments for details of lock management. */\n", "func_signal": "static int afpUnixLock(OsFile *id, int locktype)", "code": "{\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;\n  int gotPendingLock = 0;\n  \n  assert( pFile );\n  OSTRACE5(\"LOCK    %d %s was %s pid=%d\\n\", pFile->h,\n         locktypeName(locktype), locktypeName(pFile->locktype), getpid());  \n  /* If there is already a lock of this type or more restrictive on the\n    ** OsFile, do nothing. Don't use the afp_end_lock: exit path, as\n    ** sqlite3OsEnterMutex() hasn't been called yet.\n    */\n  if( pFile->locktype>=locktype ){\n    OSTRACE3(\"LOCK    %d %s ok (already held)\\n\", pFile->h,\n           locktypeName(locktype));\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct\n    */\n  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );\n  assert( locktype!=PENDING_LOCK );\n  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );\n  \n  /* This mutex is needed because pFile->pLock is shared across threads\n    */\n  sqlite3OsEnterMutex();\n\n  /* Make sure the current thread owns the pFile.\n    */\n  rc = transferOwnership(pFile);\n  if( rc!=SQLITE_OK ){\n    sqlite3OsLeaveMutex();\n    return rc;\n  }\n    \n  /* A PENDING lock is needed before acquiring a SHARED lock and before\n    ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will\n    ** be released.\n    */\n  if( locktype==SHARED_LOCK \n      || (locktype==EXCLUSIVE_LOCK && pFile->locktype<PENDING_LOCK)\n      ){\n    int failed = _AFPFSSetLock(context->filePath, pFile->h, \n      PENDING_BYTE, 1, 1);\n    if (failed) {\n      rc = SQLITE_BUSY;\n      goto afp_end_lock;\n    }\n  }\n  \n  /* If control gets to this point, then actually go ahead and make\n    ** operating system calls for the specified lock.\n    */\n  if( locktype==SHARED_LOCK ){\n    int lk, failed;\n    int tries = 0;\n    \n    /* Now get the read-lock */\n    /* note that the quality of the randomness doesn't matter that much */\n    lk = random(); \n    context->sharedLockByte = (lk & 0x7fffffff)%(SHARED_SIZE - 1);\n    failed = _AFPFSSetLock(context->filePath, pFile->h, \n      SHARED_FIRST+context->sharedLockByte, 1, 1);\n    \n    /* Drop the temporary PENDING lock */\n    if (_AFPFSSetLock(context->filePath, pFile->h, PENDING_BYTE, 1, 0)) {\n      rc = SQLITE_IOERR_UNLOCK;  /* This should never happen */\n      goto afp_end_lock;\n    }\n    \n    if( failed ){\n      rc = SQLITE_BUSY;\n    } else {\n      pFile->locktype = SHARED_LOCK;\n    }\n  }else{\n    /* The request was for a RESERVED or EXCLUSIVE lock.  It is\n    ** assumed that there is a SHARED or greater lock on the file\n    ** already.\n    */\n    int failed = 0;\n    assert( 0!=pFile->locktype );\n    if (locktype >= RESERVED_LOCK && pFile->locktype < RESERVED_LOCK) {\n        /* Acquire a RESERVED lock */\n        failed = _AFPFSSetLock(context->filePath, pFile->h, RESERVED_BYTE, 1,1);\n    }\n    if (!failed && locktype == EXCLUSIVE_LOCK) {\n      /* Acquire an EXCLUSIVE lock */\n        \n      /* Remove the shared lock before trying the range.  we'll need to \n      ** reestablish the shared lock if we can't get the  afpUnixUnlock\n      */\n      if (!_AFPFSSetLock(context->filePath, pFile->h, SHARED_FIRST +\n                         context->sharedLockByte, 1, 0)) {\n        /* now attemmpt to get the exclusive lock range */\n        failed = _AFPFSSetLock(context->filePath, pFile->h, SHARED_FIRST, \n                               SHARED_SIZE, 1);\n        if (failed && _AFPFSSetLock(context->filePath, pFile->h, SHARED_FIRST +\n                                    context->sharedLockByte, 1, 1)) {\n          rc = SQLITE_IOERR_RDLOCK; /* this should never happen */\n        }\n      } else {\n        /* */\n        rc = SQLITE_IOERR_UNLOCK; /* this should never happen */\n      }\n    }\n    if( failed && rc == SQLITE_OK){\n      rc = SQLITE_BUSY;\n    }\n  }\n  \n  if( rc==SQLITE_OK ){\n    pFile->locktype = locktype;\n  }else if( locktype==EXCLUSIVE_LOCK ){\n    pFile->locktype = PENDING_LOCK;\n  }\n  \nafp_end_lock:\n    sqlite3OsLeaveMutex();\n  OSTRACE4(\"LOCK    %d %s %s\\n\", pFile->h, locktypeName(locktype), \n         rc==SQLITE_OK ? \"ok\" : \"failed\");\n  return rc;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Close a file.\n*/\n", "func_signal": "int os2Close( OsFile **pld )", "code": "{\n  os2File *pFile;\n  APIRET rc = NO_ERROR;\n  if( pld && (pFile = (os2File*)*pld) != 0 ){\n    OSTRACE2( \"CLOSE %d\\n\", pFile->h );\n    rc = DosClose( pFile->h );\n    pFile->locktype = NO_LOCK;\n    if( pFile->delOnClose != 0 ){\n        rc = DosForceDelete( pFile->pathToDel );\n    }\n    *pld = 0;\n    OpenCounter( -1 );\n  }\n\n  return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** This routine checks for a byte-order mark at the beginning of the \n** UTF-16 string stored in *pMem. If one is present, it is removed and\n** the encoding of the Mem adjusted. This routine does not do any\n** byte-swapping, it just sets Mem.enc appropriately.\n**\n** The allocation (static, dynamic etc.) and encoding of the Mem may be\n** changed by this function.\n*/\n", "func_signal": "static int sqlite3VdbeMemHandleBom(Mem *pMem)", "code": "{\n  int rc = SQLITE_OK;\n  u8 bom = 0;\n\n  if( pMem->n<0 || pMem->n>1 ){\n    u8 b1 = *(u8 *)pMem->z;\n    u8 b2 = *(((u8 *)pMem->z) + 1);\n    if( b1==0xFE && b2==0xFF ){\n      bom = SQLITE_UTF16BE;\n    }\n    if( b1==0xFF && b2==0xFE ){\n      bom = SQLITE_UTF16LE;\n    }\n  }\n  \n  if( bom ){\n    /* This function is called as soon as a string is stored in a Mem*,\n    ** from within sqlite3VdbeMemSetStr(). At that point it is not possible\n    ** for the string to be stored in Mem.zShort, or for it to be stored\n    ** in dynamic memory with no destructor.\n    */\n    assert( !(pMem->flags&MEM_Short) );\n    assert( !(pMem->flags&MEM_Dyn) || pMem->xDel );\n    if( pMem->flags & MEM_Dyn ){\n      void (*xDel)(void*) = pMem->xDel;\n      char *z = pMem->z;\n      pMem->z = 0;\n      pMem->xDel = 0;\n      rc = sqlite3VdbeMemSetStr(pMem, &z[2], pMem->n-2, bom, SQLITE_TRANSIENT);\n      xDel(z);\n    }else{\n      rc = sqlite3VdbeMemSetStr(pMem, &pMem->z[2], pMem->n-2, bom, \n          SQLITE_TRANSIENT);\n    }\n  }\n  return rc;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Return a pointer to the Pager.nExtra bytes of \"extra\" space \n** allocated along with the specified page.\n*/\n", "func_signal": "static void *sqlite3PagerGetExtra(DbPage *pPg)", "code": "{\n  Pager *pPager = pPg->pPager;\n  return (pPager?PGHDR_TO_EXTRA(pPg, pPager):0);\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Return TRUE if zNum is a 64-bit signed integer and write\n** the value of the integer into *pNum.  If zNum is not an integer\n** or is an integer that is too large to be expressed with 64 bits,\n** then return false.  If n>0 and the integer is string is not\n** exactly n bytes long, return false.\n**\n** When this routine was originally written it dealt with only\n** 32-bit numbers.  At that time, it was much faster than the\n** atoi() library routine in RedHat 7.2.\n*/\n", "func_signal": "static int sqlite3Atoi64(const char *zNum, i64 *pNum)", "code": "{\n  i64 v = 0;\n  int neg;\n  int i, c;\n  while( isspace(*(u8*)zNum) ) zNum++;\n  if( *zNum=='-' ){\n    neg = 1;\n    zNum++;\n  }else if( *zNum=='+' ){\n    neg = 0;\n    zNum++;\n  }else{\n    neg = 0;\n  }\n  for(i=0; (c=zNum[i])>='0' && c<='9'; i++){\n    v = v*10 + c - '0';\n  }\n  *pNum = neg ? -v : v;\n  return c==0 && i>0 && \n      (i<19 || (i==19 && memcmp(zNum,\"9223372036854775807\",19)<=0));\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Return the pathname of the journal file for this database. The return\n** value of this routine is the same regardless of whether the journal file\n** has been created or not.\n*/\n", "func_signal": "static const char *sqlite3BtreeGetJournalname(Btree *p)", "code": "{\n  assert( p->pBt->pPager!=0 );\n  return sqlite3PagerJournalname(p->pBt->pPager);\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Load the content of the sqlite_stat1 table into the index hash tables.\n*/\n", "func_signal": "static int sqlite3AnalysisLoad(sqlite3 *db, int iDb)", "code": "{\n  analysisInfo sInfo;\n  HashElem *i;\n  char *zSql;\n  int rc;\n\n  /* Clear any prior statistics */\n  for(i=sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash);i;i=sqliteHashNext(i)){\n    Index *pIdx = sqliteHashData(i);\n    sqlite3DefaultRowEst(pIdx);\n  }\n\n  /* Check to make sure the sqlite_stat1 table existss */\n  sInfo.db = db;\n  sInfo.zDatabase = db->aDb[iDb].zName;\n  if( sqlite3FindTable(db, \"sqlite_stat1\", sInfo.zDatabase)==0 ){\n     return SQLITE_ERROR;\n  }\n\n\n  /* Load new statistics out of the sqlite_stat1 table */\n  zSql = sqlite3MPrintf(\"SELECT idx, stat FROM %Q.sqlite_stat1\",\n                        sInfo.zDatabase);\n  sqlite3SafetyOff(db);\n  rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);\n  sqlite3SafetyOn(db);\n  sqliteFree(zSql);\n  return rc;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Attempt to open a file for both reading and writing.  If that\n** fails, try opening it read-only.  If the file does not exist,\n** try to create it.\n**\n** On success, a handle for the open file is written to *id\n** and *pReadonly is set to 0 if the file was opened for reading and\n** writing or 1 if the file was opened read-only.  The function returns\n** SQLITE_OK.\n**\n** On failure, the function returns SQLITE_CANTOPEN and leaves\n** *id and *pReadonly unchanged.\n*/\n", "func_signal": "static int sqlite3Os2OpenReadWrite(\n  const char *zFilename,\n  OsFile **pld,\n  int *pReadonly\n)", "code": "{\n  os2File  f;\n  HFILE    hf;\n  ULONG    ulAction;\n  APIRET   rc = NO_ERROR;\n\n  assert( *pld == 0 );\n  rc = DosOpen( (PSZ)zFilename, &hf, &ulAction, 0L,\n            FILE_ARCHIVED | FILE_NORMAL,\n                OPEN_ACTION_CREATE_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,\n                OPEN_FLAGS_FAIL_ON_ERROR | OPEN_FLAGS_RANDOM |\n                    OPEN_SHARE_DENYNONE | OPEN_ACCESS_READWRITE, (PEAOP2)NULL );\n  if( rc != NO_ERROR ){\n    rc = DosOpen( (PSZ)zFilename, &hf, &ulAction, 0L,\n            FILE_ARCHIVED | FILE_NORMAL,\n                OPEN_ACTION_CREATE_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,\n                OPEN_FLAGS_FAIL_ON_ERROR | OPEN_FLAGS_RANDOM |\n                        OPEN_SHARE_DENYWRITE | OPEN_ACCESS_READONLY, (PEAOP2)NULL );\n    if( rc != NO_ERROR ){\n        return SQLITE_CANTOPEN;\n    }\n    *pReadonly = 1;\n  }\n  else{\n    *pReadonly = 0;\n  }\n  f.h = hf;\n  f.locktype = NO_LOCK;\n  f.delOnClose = 0;\n  f.pathToDel = NULL;\n  OpenCounter(+1);\n  OSTRACE3( \"OPEN R/W %d \\\"%s\\\"\\n\", hf, zFilename );\n  return allocateOs2File( &f, pld );\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** This routine identifies subexpressions in the WHERE clause where\n** each subexpression is separated by the AND operator or some other\n** operator specified in the op parameter.  The WhereClause structure\n** is filled with pointers to subexpressions.  For example:\n**\n**    WHERE  a=='hello' AND coalesce(b,11)<10 AND (c+12!=d OR c==22)\n**           \\________/     \\_______________/     \\________________/\n**            slot[0]            slot[1]               slot[2]\n**\n** The original WHERE clause in pExpr is unaltered.  All this routine\n** does is make slot[] entries point to substructure within pExpr.\n**\n** In the previous sentence and in the diagram, \"slot[]\" refers to\n** the WhereClause.a[] array.  This array grows as needed to contain\n** all terms of the WHERE clause.\n*/\n", "func_signal": "static void whereSplit(WhereClause *pWC, Expr *pExpr, int op)", "code": "{\n  if( pExpr==0 ) return;\n  if( pExpr->op!=op ){\n    whereClauseInsert(pWC, pExpr, 0);\n  }else{\n    whereSplit(pWC, pExpr->pLeft, op);\n    whereSplit(pWC, pExpr->pRight, op);\n  }\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\n", "func_signal": "static void *sqlite3Os2Dlopen(const char *zFilename)", "code": "{\n  UCHAR loadErr[256];\n  HMODULE hmod;\n  APIRET rc;\n  rc = DosLoadModule(loadErr, sizeof(loadErr), zFilename, &hmod);\n  if (rc != NO_ERROR) return 0;\n  return (void*)hmod;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Delete any previous value and set the value stored in *pMem to val,\n** manifest type REAL.\n*/\n", "func_signal": "static void sqlite3VdbeMemSetDouble(Mem *pMem, double val)", "code": "{\n  if( isnan(val) ){\n    sqlite3VdbeMemSetNull(pMem);\n  }else{\n    sqlite3VdbeMemRelease(pMem);\n    pMem->r = val;\n    pMem->flags = MEM_Real;\n    pMem->type = SQLITE_FLOAT;\n  }\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Delete a temporary cursor such as was made by the CreateTemporaryCursor()\n** function above.\n*/\n", "func_signal": "static void sqlite3BtreeReleaseTempCursor(BtCursor *pCur)", "code": "{\n  if( pCur->pPage ){\n    sqlite3PagerUnref(pCur->pPage->pDbPage);\n  }\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Close a cursor.  The read lock on the database file is released\n** when the last cursor is closed.\n*/\n", "func_signal": "static int sqlite3BtreeCloseCursor(BtCursor *pCur)", "code": "{\n  BtShared *pBt = pCur->pBtree->pBt;\n  clearCursorPosition(pCur);\n  if( pCur->pPrev ){\n    pCur->pPrev->pNext = pCur->pNext;\n  }else{\n    pBt->pCursor = pCur->pNext;\n  }\n  if( pCur->pNext ){\n    pCur->pNext->pPrev = pCur->pPrev;\n  }\n  releasePage(pCur->pPage);\n  unlockBtreeIfUnused(pBt);\n  invalidateOverflowCache(pCur);\n  sqliteFree(pCur);\n  return SQLITE_OK;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Free any overflow pages associated with the given Cell.\n*/\n", "func_signal": "static int clearCell(MemPage *pPage, unsigned char *pCell)", "code": "{\n  BtShared *pBt = pPage->pBt;\n  CellInfo info;\n  Pgno ovflPgno;\n  int rc;\n  int nOvfl;\n  int ovflPageSize;\n\n  sqlite3BtreeParseCellPtr(pPage, pCell, &info);\n  if( info.iOverflow==0 ){\n    return SQLITE_OK;  /* No overflow pages. Return without doing anything */\n  }\n  ovflPgno = get4byte(&pCell[info.iOverflow]);\n  ovflPageSize = pBt->usableSize - 4;\n  nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize;\n  assert( ovflPgno==0 || nOvfl>0 );\n  while( nOvfl-- ){\n    MemPage *pOvfl;\n    if( ovflPgno==0 || ovflPgno>sqlite3PagerPagecount(pBt->pPager) ){\n      return SQLITE_CORRUPT_BKPT;\n    }\n\n    rc = getOverflowPage(pBt, ovflPgno, &pOvfl, (nOvfl==0)?0:&ovflPgno);\n    if( rc ) return rc;\n    rc = freePage(pOvfl);\n    sqlite3PagerUnref(pOvfl->pDbPage);\n    if( rc ) return rc;\n  }\n  return SQLITE_OK;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Get a single 8-bit random value from the RC4 PRNG.  The Mutex\n** must be held while executing this routine.\n**\n** Why not just use a library random generator like lrand48() for this?\n** Because the OP_NewRowid opcode in the VDBE depends on having a very\n** good source of random numbers.  The lrand48() library function may\n** well be good enough.  But maybe not.  Or maybe lrand48() has some\n** subtle problems on some systems that could cause problems.  It is hard\n** to know.  To minimize the risk of problems due to bad lrand48()\n** implementations, SQLite uses this random number generator based\n** on RC4, which we know works very well.\n**\n** (Later):  Actually, OP_NewRowid does not depend on a good source of\n** randomness any more.  But we will leave this code in all the same.\n*/\n", "func_signal": "static int randomByte(void)", "code": "{\n  unsigned char t;\n\n  /* All threads share a single random number generator.\n  ** This structure is the current state of the generator.\n  */\n  static struct {\n    unsigned char isInit;          /* True if initialized */\n    unsigned char i, j;            /* State variables */\n    unsigned char s[256];          /* State variables */\n  } prng;\n\n  /* Initialize the state of the random number generator once,\n  ** the first time this routine is called.  The seed value does\n  ** not need to contain a lot of randomness since we are not\n  ** trying to do secure encryption or anything like that...\n  **\n  ** Nothing in this file or anywhere else in SQLite does any kind of\n  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random\n  ** number generator) not as an encryption device.\n  */\n  if( !prng.isInit ){\n    int i;\n    char k[256];\n    prng.j = 0;\n    prng.i = 0;\n    sqlite3OsRandomSeed(k);\n    for(i=0; i<256; i++){\n      prng.s[i] = i;\n    }\n    for(i=0; i<256; i++){\n      prng.j += prng.s[i] + k[i];\n      t = prng.s[prng.j];\n      prng.s[prng.j] = prng.s[i];\n      prng.s[i] = t;\n    }\n    prng.isInit = 1;\n  }\n\n  /* Generate and return single random byte\n  */\n  prng.i++;\n  t = prng.s[prng.i];\n  prng.j += t;\n  prng.s[prng.i] = prng.s[prng.j];\n  prng.s[prng.j] = t;\n  t += prng.s[prng.i];\n  return prng.s[t];\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Generate code that will do an analysis of an entire database\n*/\n", "func_signal": "static void analyzeDatabase(Parse *pParse, int iDb)", "code": "{\n  sqlite3 *db = pParse->db;\n  Schema *pSchema = db->aDb[iDb].pSchema;    /* Schema of database iDb */\n  HashElem *k;\n  int iStatCur;\n  int iMem;\n\n  sqlite3BeginWriteOperation(pParse, 0, iDb);\n  iStatCur = pParse->nTab++;\n  openStatTable(pParse, iDb, iStatCur, 0);\n  iMem = pParse->nMem;\n  for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n    Table *pTab = (Table*)sqliteHashData(k);\n    analyzeOneTable(pParse, pTab, iStatCur, iMem);\n  }\n  loadAnalysis(pParse, iDb);\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Extract the user data from a sqlite3_context structure and return a\n** pointer to it.\n*/\n", "func_signal": "void *sqlite3_user_data(sqlite3_context *p)", "code": "{\n  assert( p && p->pFunc );\n  return p->pFunc->pUserData;\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Check to see if column iCol of the given statement is valid.  If\n** it is, return a pointer to the Mem for the value of that column.\n** If iCol is not valid, return a pointer to a Mem which has a value\n** of NULL.\n*/\n", "func_signal": "static Mem *columnMem(sqlite3_stmt *pStmt, int i)", "code": "{\n  Vdbe *pVm = (Vdbe *)pStmt;\n  int vals = sqlite3_data_count(pStmt);\n  if( i>=vals || i<0 ){\n    static const Mem nullMem = {{0}, 0.0, \"\", 0, MEM_Null, SQLITE_NULL };\n    sqlite3Error(pVm->db, SQLITE_RANGE, 0);\n    return (Mem*)&nullMem;\n  }\n  return &pVm->pTos[(1-vals)+i];\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\n", "func_signal": "static char *sqlite3VMPrintf(const char *zFormat, va_list ap)", "code": "{\n  char zBase[SQLITE_PRINT_BUF_SIZE];\n  return base_vprintf(printf_realloc, 1, zBase, sizeof(zBase), zFormat, ap);\n}", "path": "UnsignedByte\\Sqlite3\\sqlite3.c", "repo_name": "SRabbelier/unsignedbyte", "stars": 3, "license": "None", "language": "c", "size": 10500}
{"docstring": "/*\n** Implementation of the last_insert_rowid() SQL function.  The return\n** value is the same as the sqlite3_last_insert_rowid() API function.\n*/\n", "func_signal": "static void last_insert_rowid(\n  sqlite3_context *context, \n  int NotUsed, \n  sqlite3_value **NotUsed2\n)", "code": "{\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.\n** If the indicated statement has never been prepared, it is prepared\n** and cached, otherwise the cached version is reset.\n*/\n", "func_signal": "static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,\n                             sqlite3_stmt **ppStmt)", "code": "{\n  assert( iStmt<MAX_STMT );\n  if( v->pFulltextStatements[iStmt]==NULL ){\n    const char *zStmt;\n    int rc;\n    switch( iStmt ){\n      case CONTENT_INSERT_STMT:\n        zStmt = contentInsertStatement(v); break;\n      case CONTENT_SELECT_STMT:\n        zStmt = contentSelectStatement(v); break;\n      case CONTENT_UPDATE_STMT:\n        zStmt = contentUpdateStatement(v); break;\n      default:\n        zStmt = fulltext_zStatement[iStmt];\n    }\n    rc = sql_prepare(v->db, v->zDb, v->zName, &v->pFulltextStatements[iStmt],\n                         zStmt);\n    if( zStmt != fulltext_zStatement[iStmt]) sqlite3_free((void *) zStmt);\n    if( rc!=SQLITE_OK ) return rc;\n  } else {\n    int rc = sqlite3_reset(v->pFulltextStatements[iStmt]);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  *ppStmt = v->pFulltextStatements[iStmt];\n  return SQLITE_OK;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Close a file.\n*/\n", "func_signal": "static int unixClose(sqlite3_file *id)", "code": "{\n  int rc = SQLITE_OK;\n  if( id ){\n    unixFile *pFile = (unixFile *)id;\n    unixUnlock(id, NO_LOCK);\n    unixEnterMutex();\n    if( pFile->pOpen && pFile->pOpen->nLock ){\n      /* If there are outstanding locks, do not actually close the file just\n      ** yet because that would clear those locks.  Instead, add the file\n      ** descriptor to pOpen->aPending.  It will be automatically closed when\n      ** the last lock is cleared.\n      */\n      int *aNew;\n      struct unixOpenCnt *pOpen = pFile->pOpen;\n      aNew = sqlite3_realloc(pOpen->aPending, (pOpen->nPending+1)*sizeof(int) );\n      if( aNew==0 ){\n        /* If a malloc fails, just leak the file descriptor */\n      }else{\n        pOpen->aPending = aNew;\n        pOpen->aPending[pOpen->nPending] = pFile->h;\n        pOpen->nPending++;\n        pFile->h = -1;\n      }\n    }\n    releaseLockInfo(pFile->pLock);\n    releaseOpenCnt(pFile->pOpen);\n    rc = closeUnixFile(id);\n    unixLeaveMutex();\n  }\n  return rc;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Record the fact that an affinity change has occurred on iCount\n** registers starting with iStart.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount)", "code": "{\n  int iEnd = iStart + iCount - 1;\n  int i;\n  struct yColCache *p;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int r = p->iReg;\n    if( r>=iStart && r<=iEnd ){\n      p->affChange = 1;\n    }\n  }\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Set the pointer-map entries for all children of page pPage. Also, if\n** pPage contains cells that point to overflow pages, set the pointer\n** map entries for the overflow pages as well.\n*/\n", "func_signal": "static int setChildPtrmaps(MemPage *pPage)", "code": "{\n  int i;                             /* Counter variable */\n  int nCell;                         /* Number of cells in page pPage */\n  int rc;                            /* Return code */\n  BtShared *pBt = pPage->pBt;\n  u8 isInitOrig = pPage->isInit;\n  Pgno pgno = pPage->pgno;\n\n  assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n  rc = sqlite3BtreeInitPage(pPage);\n  if( rc!=SQLITE_OK ){\n    goto set_child_ptrmaps_out;\n  }\n  nCell = pPage->nCell;\n\n  for(i=0; i<nCell; i++){\n    u8 *pCell = findCell(pPage, i);\n\n    rc = ptrmapPutOvflPtr(pPage, pCell);\n    if( rc!=SQLITE_OK ){\n      goto set_child_ptrmaps_out;\n    }\n\n    if( !pPage->leaf ){\n      Pgno childPgno = get4byte(pCell);\n      rc = ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno);\n      if( rc!=SQLITE_OK ) goto set_child_ptrmaps_out;\n    }\n  }\n\n  if( !pPage->leaf ){\n    Pgno childPgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n    rc = ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno);\n  }\n\nset_child_ptrmaps_out:\n  pPage->isInit = isInitOrig;\n  return rc;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/* Helper function to build the result string for dump_terms(). */\n", "func_signal": "static int generateTermsResult(sqlite3_context *pContext, fts3Hash *pTerms)", "code": "{\n  int iTerm, nTerms, nResultBytes, iByte;\n  char *result;\n  TermData *pData;\n  fts3HashElem *e;\n\n  /* Iterate pTerms to generate an array of terms in pData for\n  ** sorting.\n  */\n  nTerms = fts3HashCount(pTerms);\n  assert( nTerms>0 );\n  pData = sqlite3_malloc(nTerms*sizeof(TermData));\n  if( pData==NULL ) return SQLITE_NOMEM;\n\n  nResultBytes = 0;\n  for(iTerm = 0, e = fts3HashFirst(pTerms); e; iTerm++, e = fts3HashNext(e)){\n    nResultBytes += fts3HashKeysize(e)+1;   /* Term plus trailing space */\n    assert( iTerm<nTerms );\n    pData[iTerm].pTerm = fts3HashKey(e);\n    pData[iTerm].nTerm = fts3HashKeysize(e);\n    pData[iTerm].pCollector = fts3HashData(e);  /* unused */\n  }\n  assert( iTerm==nTerms );\n\n  assert( nResultBytes>0 );   /* nTerms>0, nResultsBytes must be, too. */\n  result = sqlite3_malloc(nResultBytes);\n  if( result==NULL ){\n    sqlite3_free(pData);\n    return SQLITE_NOMEM;\n  }\n\n  if( nTerms>1 ) qsort(pData, nTerms, sizeof(*pData), termDataCmp);\n\n  /* Read the terms in order to build the result. */\n  iByte = 0;\n  for(iTerm=0; iTerm<nTerms; ++iTerm){\n    memcpy(result+iByte, pData[iTerm].pTerm, pData[iTerm].nTerm);\n    iByte += pData[iTerm].nTerm;\n    result[iByte++] = ' ';\n  }\n  assert( iByte==nResultBytes );\n  assert( result[nResultBytes-1]==' ' );\n  result[nResultBytes-1] = '\\0';\n\n  /* Passes away ownership of result. */\n  sqlite3_result_text(pContext, result, nResultBytes-1, sqlite3_free);\n  sqlite3_free(pData);\n  return SQLITE_OK;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** This routine is called after a single SQL statement has been\n** parsed and a VDBE program to execute that statement has been\n** prepared.  This routine puts the finishing touches on the\n** VDBE program and resets the pParse structure for the next\n** parse.\n**\n** Note that if an error occurred, it might be the case that\n** no VDBE code was generated.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse)", "code": "{\n  sqlite3 *db;\n  Vdbe *v;\n\n  db = pParse->db;\n  if( db->mallocFailed ) return;\n  if( pParse->nested ) return;\n  if( pParse->nErr ) return;\n\n  /* Begin by generating some termination code at the end of the\n  ** vdbe program\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp0(v, OP_Halt);\n\n    /* The cookie mask contains one bit for each database file open.\n    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are\n    ** set for each database that is used.  Generate code to start a\n    ** transaction on each used database and to verify the schema cookie\n    ** on each used database.\n    */\n    if( pParse->cookieGoto>0 ){\n      u32 mask;\n      int iDb;\n      sqlite3VdbeJumpHere(v, pParse->cookieGoto-1);\n      for(iDb=0, mask=1; iDb<db->nDb; mask<<=1, iDb++){\n        if( (mask & pParse->cookieMask)==0 ) continue;\n        sqlite3VdbeUsesBtree(v, iDb);\n        sqlite3VdbeAddOp2(v,OP_Transaction, iDb, (mask & pParse->writeMask)!=0);\n        if( db->init.busy==0 ){\n          sqlite3VdbeAddOp2(v,OP_VerifyCookie, iDb, pParse->cookieValue[iDb]);\n        }\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      {\n        int i;\n        for(i=0; i<pParse->nVtabLock; i++){\n          char *vtab = (char *)pParse->apVtabLock[i]->pVtab;\n          sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n        }\n        pParse->nVtabLock = 0;\n      }\n#endif\n\n      /* Once all the cookies have been verified and transactions opened, \n      ** obtain the required table-locks. This is a no-op unless the \n      ** shared-cache feature is enabled.\n      */\n      codeTableLocks(pParse);\n\n      /* Initialize any AUTOINCREMENT data structures required.\n      */\n      sqlite3AutoincrementBegin(pParse);\n\n      /* Finally, jump back to the beginning of the executable code. */\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, pParse->cookieGoto);\n    }\n  }\n\n\n  /* Get the VDBE program ready for execution\n  */\n  if( v && ALWAYS(pParse->nErr==0) && !db->mallocFailed ){\n#ifdef SQLITE_DEBUG\n    FILE *trace = (db->flags & SQLITE_VdbeTrace)!=0 ? stdout : 0;\n    sqlite3VdbeTrace(v, trace);\n#endif\n    assert( pParse->iCacheLevel==0 );  /* Disables and re-enables match */\n    sqlite3VdbeMakeReady(v, pParse->nVar, pParse->nMem,\n                         pParse->nTab, pParse->explain);\n    pParse->rc = SQLITE_DONE;\n    pParse->colNamesSet = 0;\n  }else if( pParse->rc==SQLITE_OK ){\n    pParse->rc = SQLITE_ERROR;\n  }\n  pParse->nTab = 0;\n  pParse->nMem = 0;\n  pParse->nSet = 0;\n  pParse->nVar = 0;\n  pParse->cookieMask = 0;\n  pParse->cookieGoto = 0;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/* TODO(shess) Should plwDestroy() also terminate the doclist?  But\n** then plwDestroy() would no longer be just a destructor, it would\n** also be doing work, which isn't consistent with the overall idiom.\n** Another option would be for plwAdd() to always append any necessary\n** terminator, so that the output is always correct.  But that would\n** add incremental work to the common case with the only benefit being\n** API elegance.  Punt for now.\n*/\n", "func_signal": "static void plwTerminate(PLWriter *pWriter)", "code": "{\n  if( pWriter->dlw->iType>DL_DOCIDS ){\n    char c[VARINT_MAX];\n    int n = fts3PutVarint(c, POS_END);\n    dataBufferAppend(pWriter->dlw->b, c, n);\n  }\n#ifndef NDEBUG\n  /* Mark as terminated for assert in plwAdd(). */\n  pWriter->iPos = -1;\n#endif\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** The sqlite3_mutex_leave() routine exits a mutex that was previously\n** entered by the same thread.  The behavior is undefined if the mutex \n** is not currently entered. If a NULL pointer is passed as an argument\n** this function is a no-op.\n*/\n", "func_signal": "SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p)", "code": "{\n  if( p ){\n    sqlite3GlobalConfig.mutex.xMutexLeave(p);\n  }\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Compute the soundex encoding of a word.\n*/\n", "func_signal": "static void soundexFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  char zResult[8];\n  const u8 *zIn;\n  int i, j;\n  static const unsigned char iCode[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,\n    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,\n    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,\n    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,\n  };\n  assert( argc==1 );\n  zIn = (u8*)sqlite3_value_text(argv[0]);\n  if( zIn==0 ) zIn = (u8*)\"\";\n  for(i=0; zIn[i] && !sqlite3Isalpha(zIn[i]); i++){}\n  if( zIn[i] ){\n    u8 prevcode = iCode[zIn[i]&0x7f];\n    zResult[0] = sqlite3Toupper(zIn[i]);\n    for(j=1; j<4 && zIn[i]; i++){\n      int code = iCode[zIn[i]&0x7f];\n      if( code>0 ){\n        if( code!=prevcode ){\n          prevcode = code;\n          zResult[j++] = code + '0';\n        }\n      }else{\n        prevcode = 0;\n      }\n    }\n    while( j<4 ){\n      zResult[j++] = '0';\n    }\n    zResult[j] = 0;\n    sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);\n  }else{\n    sqlite3_result_text(context, \"?000\", 4, SQLITE_STATIC);\n  }\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Delete an entire expression list.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList)", "code": "{\n  int i;\n  struct ExprList_item *pItem;\n  if( pList==0 ) return;\n  assert( pList->a!=0 || (pList->nExpr==0 && pList->nAlloc==0) );\n  assert( pList->nExpr<=pList->nAlloc );\n  for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){\n    sqlite3ExprDelete(db, pItem->pExpr);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zSpan);\n  }\n  sqlite3DbFree(db, pList->a);\n  sqlite3DbFree(db, pList);\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Generate code that will cause the most recent index analysis to\n** be laoded into internal hash tables where is can be used.\n*/\n", "func_signal": "static void loadAnalysis(Parse *pParse, int iDb)", "code": "{\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb);\n  }\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Return the sector size in bytes of the underlying block device for\n** the specified file. This is almost always 512 bytes, but may be\n** larger for some devices.\n**\n** SQLite code assumes this function cannot fail. It also assumes that\n** if two files are created in the same file-system directory (i.e.\n** a database and its journal file) that the sector size will be the\n** same for both.\n*/\n", "func_signal": "static int unixSectorSize(sqlite3_file *NotUsed)", "code": "{\n  UNUSED_PARAMETER(NotUsed);\n  return SQLITE_DEFAULT_SECTOR_SIZE;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** This function does not contribute anything to the operation of SQLite.\n** it is sometimes activated temporarily while debugging code responsible \n** for setting pointer-map entries.\n*/\n", "func_signal": "static int ptrmapCheckPages(MemPage **apPage, int nPage)", "code": "{\n  int i, j;\n  for(i=0; i<nPage; i++){\n    Pgno n;\n    u8 e;\n    MemPage *pPage = apPage[i];\n    BtShared *pBt = pPage->pBt;\n    assert( pPage->isInit );\n\n    for(j=0; j<pPage->nCell; j++){\n      CellInfo info;\n      u8 *z;\n     \n      z = findCell(pPage, j);\n      sqlite3BtreeParseCellPtr(pPage, z, &info);\n      if( info.iOverflow ){\n        Pgno ovfl = get4byte(&z[info.iOverflow]);\n        ptrmapGet(pBt, ovfl, &e, &n);\n        assert( n==pPage->pgno && e==PTRMAP_OVERFLOW1 );\n      }\n      if( !pPage->leaf ){\n        Pgno child = get4byte(z);\n        ptrmapGet(pBt, child, &e, &n);\n        assert( n==pPage->pgno && e==PTRMAP_BTREE );\n      }\n    }\n    if( !pPage->leaf ){\n      Pgno child = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n      ptrmapGet(pBt, child, &e, &n);\n      assert( n==pPage->pgno && e==PTRMAP_BTREE );\n    }\n  }\n  return 1;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/* This function is used by SQL generated to implement the\n** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER \n** statement. The second is a table name. The table name in the CREATE \n** TRIGGER statement is replaced with the third argument and the result \n** returned. This is analagous to renameTableFunc() above, except for CREATE\n** TRIGGER, not CREATE INDEX and CREATE TABLE.\n*/\n", "func_signal": "static void renameTriggerFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n)", "code": "{\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  int dist = 3;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TRIGGER \n  ** statement is that the table name is the first token that is immediatedly\n  ** preceded by either TK_ON or TK_DOT and immediatedly followed by one\n  ** of TK_WHEN, TK_BEGIN or TK_FOR.\n  */\n  if( zSql ){\n    do {\n\n      if( !*zCsr ){\n        /* Ran out of input before finding the table name. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      }while( token==TK_SPACE );\n      assert( len>0 );\n\n      /* Variable 'dist' stores the number of tokens read since the most\n      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN \n      ** token is read and 'dist' equals 2, the condition stated above\n      ** to be met.\n      **\n      ** Note that ON cannot be a database, table or column name, so\n      ** there is no need to worry about syntax like \n      ** \"CREATE TRIGGER ... ON ON.ON BEGIN ...\" etc.\n      */\n      dist++;\n      if( token==TK_DOT || token==TK_ON ){\n        dist = 0;\n      }\n    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );\n\n    /* Variable tname now contains the token that is the old table-name\n    ** in the CREATE TRIGGER statement.\n    */\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", ((u8*)tname.z) - zSql, zSql, \n       zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Add MEM_Str to the set of representations for the given Mem.  Numbers\n** are converted using sqlite3_snprintf().  Converting a BLOB to a string\n** is a no-op.\n**\n** Existing representations MEM_Int and MEM_Real are *not* invalidated.\n**\n** A MEM_Null value will never be passed to this function. This function is\n** used for converting values to text for returning to the user (i.e. via\n** sqlite3_value_text()), or for ensuring that values to be used as btree\n** keys are strings. In the former case a NULL pointer is returned the\n** user and the later is an internal programming error.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, int enc)", "code": "{\n  int rc = SQLITE_OK;\n  int fg = pMem->flags;\n  const int nByte = 32;\n\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( !(fg&MEM_Zero) );\n  assert( !(fg&(MEM_Str|MEM_Blob)) );\n  assert( fg&(MEM_Int|MEM_Real) );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n\n  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){\n    return SQLITE_NOMEM;\n  }\n\n  /* For a Real or Integer, use sqlite3_mprintf() to produce the UTF-8\n  ** string representation of the value. Then, if the required encoding\n  ** is UTF-16le or UTF-16be do a translation.\n  ** \n  ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.\n  */\n  if( fg & MEM_Int ){\n    sqlite3_snprintf(nByte, pMem->z, \"%lld\", pMem->u.i);\n  }else{\n    assert( fg & MEM_Real );\n    sqlite3_snprintf(nByte, pMem->z, \"%!.15g\", pMem->r);\n  }\n  pMem->n = sqlite3Strlen30(pMem->z);\n  pMem->enc = SQLITE_UTF8;\n  pMem->flags |= MEM_Str|MEM_Term;\n  sqlite3VdbeChangeEncoding(pMem, enc);\n  return rc;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Convert a sorted list of elements into a binary tree. Make the tree\n** as deep as it needs to be in order to contain the entire list.\n*/\n", "func_signal": "static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList)", "code": "{\n  int iDepth;           /* Depth of the tree so far */\n  struct RowSetEntry *p;       /* Current tree root */\n  struct RowSetEntry *pLeft;   /* Left subtree */\n\n  assert( pList!=0 );\n  p = pList;\n  pList = p->pRight;\n  p->pLeft = p->pRight = 0;\n  for(iDepth=1; pList; iDepth++){\n    pLeft = p;\n    p = pList;\n    pList = p->pRight;\n    p->pLeft = pLeft;\n    p->pRight = rowSetNDeepTree(&pList, iDepth);\n  }\n  return p;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** This routine is called once for each row in the result table.  Its job\n** is to fill in the TabResult structure appropriately, allocating new\n** memory as necessary.\n*/\n", "func_signal": "static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv)", "code": "{\n  TabResult *p = (TabResult*)pArg;  /* Result accumulator */\n  int need;                         /* Slots needed in p->azResult[] */\n  int i;                            /* Loop counter */\n  char *z;                          /* A single column of result */\n\n  /* Make sure there is enough space in p->azResult to hold everything\n  ** we need to remember from this invocation of the callback.\n  */\n  if( p->nRow==0 && argv!=0 ){\n    need = nCol*2;\n  }else{\n    need = nCol;\n  }\n  if( p->nData + need > p->nAlloc ){\n    char **azNew;\n    p->nAlloc = p->nAlloc*2 + need;\n    azNew = sqlite3_realloc( p->azResult, sizeof(char*)*p->nAlloc );\n    if( azNew==0 ) goto malloc_failed;\n    p->azResult = azNew;\n  }\n\n  /* If this is the first row, then generate an extra row containing\n  ** the names of all columns.\n  */\n  if( p->nRow==0 ){\n    p->nColumn = nCol;\n    for(i=0; i<nCol; i++){\n      z = sqlite3_mprintf(\"%s\", colv[i]);\n      if( z==0 ) goto malloc_failed;\n      p->azResult[p->nData++] = z;\n    }\n  }else if( p->nColumn!=nCol ){\n    sqlite3_free(p->zErrMsg);\n    p->zErrMsg = sqlite3_mprintf(\n       \"sqlite3_get_table() called with two or more incompatible queries\"\n    );\n    p->rc = SQLITE_ERROR;\n    return 1;\n  }\n\n  /* Copy over the row data\n  */\n  if( argv!=0 ){\n    for(i=0; i<nCol; i++){\n      if( argv[i]==0 ){\n        z = 0;\n      }else{\n        int n = sqlite3Strlen30(argv[i])+1;\n        z = sqlite3_malloc( n );\n        if( z==0 ) goto malloc_failed;\n        memcpy(z, argv[i], n);\n      }\n      p->azResult[p->nData++] = z;\n    }\n    p->nRow++;\n  }\n  return 0;\n\nmalloc_failed:\n  p->rc = SQLITE_NOMEM;\n  return 1;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Set the collating sequence for expression pExpr to be the collating\n** sequence named by pToken.   Return a pointer to the revised expression.\n** The collating sequence is marked as \"explicit\" using the EP_ExpCollate\n** flag.  An explicit collating sequence will override implicit\n** collating sequences.\n*/\n", "func_signal": "SQLITE_PRIVATE Expr *sqlite3ExprSetColl(Parse *pParse, Expr *pExpr, Token *pCollName)", "code": "{\n  char *zColl = 0;            /* Dequoted name of collation sequence */\n  CollSeq *pColl;\n  sqlite3 *db = pParse->db;\n  zColl = sqlite3NameFromToken(db, pCollName);\n  if( pExpr && zColl ){\n    pColl = sqlite3LocateCollSeq(pParse, zColl);\n    if( pColl ){\n      pExpr->pColl = pColl;\n      pExpr->flags |= EP_ExpCollate;\n    }\n  }\n  sqlite3DbFree(db, zColl);\n  return pExpr;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/*\n** Implementation of the sqlite3_pcache.xInit method.\n*/\n", "func_signal": "static int pcache1Init(void *NotUsed)", "code": "{\n  UNUSED_PARAMETER(NotUsed);\n  assert( pcache1.isInit==0 );\n  memset(&pcache1, 0, sizeof(pcache1));\n  if( sqlite3GlobalConfig.bCoreMutex ){\n    pcache1.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_LRU);\n  }\n  pcache1.isInit = 1;\n  return SQLITE_OK;\n}", "path": "tests\\sources\\sqlite3.c", "repo_name": "gcross/Privateer", "stars": 2, "license": "other", "language": "c", "size": 1132}
{"docstring": "/* Check properties of any chunk, whether free, inuse, mmapped etc  */\n", "func_signal": "static void do_check_any_chunk(mstate m, mchunkptr p)", "code": "{\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* --------------------------- realloc support --------------------------- */\n", "func_signal": "static void* internal_realloc(mstate m, void* oldmem, size_t bytes)", "code": "{\n  if (bytes >= MAX_REQUEST) {\n    MALLOC_FAILURE_ACTION;\n    return 0;\n  }\n  if (!PREACTION(m)) {\n    mchunkptr oldp = mem2chunk(oldmem);\n    size_t oldsize = chunksize(oldp);\n    mchunkptr next = chunk_plus_offset(oldp, oldsize);\n    mchunkptr newp = 0;\n    void* extra = 0;\n\n    /* Try to either shrink or extend into top. Else malloc-copy-free */\n\n    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&\n                ok_next(oldp, next) && ok_pinuse(next))) {\n      size_t nb = request2size(bytes);\n      if (is_mmapped(oldp))\n        newp = mmap_resize(m, oldp, nb);\n      else if (oldsize >= nb) { /* already big enough */\n        size_t rsize = oldsize - nb;\n        newp = oldp;\n        if (rsize >= MIN_CHUNK_SIZE) {\n          mchunkptr remainder = chunk_plus_offset(newp, nb);\n          set_inuse(m, newp, nb);\n          set_inuse(m, remainder, rsize);\n          extra = chunk2mem(remainder);\n        }\n      }\n      else if (next == m->top && oldsize + m->topsize > nb) {\n        /* Expand into top */\n        size_t newsize = oldsize + m->topsize;\n        size_t newtopsize = newsize - nb;\n        mchunkptr newtop = chunk_plus_offset(oldp, nb);\n        set_inuse(m, oldp, nb);\n        newtop->head = newtopsize |PINUSE_BIT;\n        m->top = newtop;\n        m->topsize = newtopsize;\n        newp = oldp;\n      }\n    }\n    else {\n      USAGE_ERROR_ACTION(m, oldmem);\n      POSTACTION(m);\n      return 0;\n    }\n\n    POSTACTION(m);\n\n    if (newp != 0) {\n      if (extra != 0) {\n        internal_free(m, extra);\n      }\n      check_inuse_chunk(m, newp);\n      return chunk2mem(newp);\n    }\n    else {\n      void* newmem = internal_malloc(m, bytes);\n      if (newmem != 0) {\n        size_t oc = oldsize - overhead_for(oldp);\n        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);\n        internal_free(m, oldmem);\n      }\n      return newmem;\n    }\n  }\n  return 0;\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Check properties of top chunk */\n", "func_signal": "static void do_check_top_chunk(mstate m, mchunkptr p)", "code": "{\n  msegmentptr sp = segment_holding(m, (char*)p);\n  size_t  sz = chunksize(p);\n  assert(sp != 0);\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n  assert(sz == m->topsize);\n  assert(sz > 0);\n  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);\n  assert(pinuse(p));\n  assert(!next_pinuse(p));\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Check properties of inuse chunks */\n", "func_signal": "static void do_check_inuse_chunk(mstate m, mchunkptr p)", "code": "{\n  do_check_any_chunk(m, p);\n  assert(cinuse(p));\n  assert(next_pinuse(p));\n  /* If not pinuse and not mmapped, previous chunk has OK offset */\n  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);\n  if (is_mmapped(p))\n    do_check_mmapped_chunk(m, p);\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Add a segment to hold a new noncontiguous region */\n", "func_signal": "static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped)", "code": "{\n  /* Determine locations and sizes of segment, fenceposts, old top */\n  char* old_top = (char*)m->top;\n  msegmentptr oldsp = segment_holding(m, old_top);\n  char* old_end = oldsp->base + oldsp->size;\n  size_t ssize = pad_request(sizeof(struct malloc_segment));\n  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n  size_t offset = align_offset(chunk2mem(rawsp));\n  char* asp = rawsp + offset;\n  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;\n  mchunkptr sp = (mchunkptr)csp;\n  msegmentptr ss = (msegmentptr)(chunk2mem(sp));\n  mchunkptr tnext = chunk_plus_offset(sp, ssize);\n  mchunkptr p = tnext;\n  int nfences = 0;\n\n  /* reset top to new space */\n  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);\n\n  /* Set up segment record */\n  assert(is_aligned(ss));\n  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);\n  *ss = m->seg; /* Push current record */\n  m->seg.base = tbase;\n  m->seg.size = tsize;\n  m->seg.sflags = mmapped;\n  m->seg.next = ss;\n\n  /* Insert trailing fenceposts */\n  for (;;) {\n    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);\n    p->head = FENCEPOST_HEAD;\n    ++nfences;\n    if ((char*)(&(nextp->head)) < old_end)\n      p = nextp;\n    else\n      break;\n  }\n  assert(nfences >= 2);\n\n  /* Insert the rest of old top into a bin as an ordinary free chunk */\n  if (csp != old_top) {\n    mchunkptr q = (mchunkptr)old_top;\n    size_t psize = csp - old_top;\n    mchunkptr tn = chunk_plus_offset(q, psize);\n    set_free_with_pinuse(q, psize, tn);\n    insert_chunk(m, q, psize);\n  }\n\n  check_top_chunk(m, m->top);\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/*\n * Find the first occurrence of find in s.\n */\n", "func_signal": "char *\nstrstr(const char *s, const char *find)", "code": "{\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != 0) {\n\t\tlen = strlen(find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif ((sc = *s++) == 0)\n\t\t\t\t\treturn (NULL);\n\t\t\t} while (sc != c);\n\t\t} while (strncmp(s, find, len) != 0);\n\t\ts--;\n    }\n\treturn ((char *)s);\n}", "path": "libc\\string\\strstr.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* called from setjmp assembly fragment */\n", "func_signal": "int\nsigsetmask(int mask)", "code": "{\n    int  n;\n\n    union {\n        int       the_mask;\n        sigset_t  the_sigset;\n    } in, out;\n\n    n = sigprocmask(SIG_SETMASK, &in.the_sigset, &out.the_sigset);\n    if (n)\n        return n;\n\n    return out.the_mask;\n}", "path": "libc\\unistd\\sigsetmask.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Check a tree and its subtrees.  */\n", "func_signal": "static void do_check_tree(mstate m, tchunkptr t)", "code": "{\n  tchunkptr head = 0;\n  tchunkptr u = t;\n  bindex_t tindex = t->index;\n  size_t tsize = chunksize(t);\n  bindex_t idx;\n  compute_tree_index(tsize, idx);\n  assert(tindex == idx);\n  assert(tsize >= MIN_LARGE_SIZE);\n  assert(tsize >= minsize_for_tree_index(idx));\n  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));\n\n  do { /* traverse through chain of same-sized nodes */\n    do_check_any_chunk(m, ((mchunkptr)u));\n    assert(u->index == tindex);\n    assert(chunksize(u) == tsize);\n    assert(!cinuse(u));\n    assert(!next_pinuse(u));\n    assert(u->fd->bk == u);\n    assert(u->bk->fd == u);\n    if (u->parent == 0) {\n      assert(u->child[0] == 0);\n      assert(u->child[1] == 0);\n    }\n    else {\n      assert(head == 0); /* only one node on chain has parent */\n      head = u;\n      assert(u->parent != u);\n      assert (u->parent->child[0] == u ||\n              u->parent->child[1] == u ||\n              *((tbinptr*)(u->parent)) == u);\n      if (u->child[0] != 0) {\n        assert(u->child[0]->parent == u);\n        assert(u->child[0] != u);\n        do_check_tree(m, u->child[0]);\n      }\n      if (u->child[1] != 0) {\n        assert(u->child[1]->parent == u);\n        assert(u->child[1] != u);\n        do_check_tree(m, u->child[1]);\n      }\n      if (u->child[0] != 0 && u->child[1] != 0) {\n        assert(chunksize(u->child[0]) < chunksize(u->child[1]));\n      }\n    }\n    u = u->fd;\n  } while (u != t);\n  assert(head != 0);\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Check all properties of malloc_state. */\n", "func_signal": "static void do_check_malloc_state(mstate m)", "code": "{\n  bindex_t i;\n  size_t total;\n  /* check bins */\n  for (i = 0; i < NSMALLBINS; ++i)\n    do_check_smallbin(m, i);\n  for (i = 0; i < NTREEBINS; ++i)\n    do_check_treebin(m, i);\n\n  if (m->dvsize != 0) { /* check dv chunk */\n    do_check_any_chunk(m, m->dv);\n    assert(m->dvsize == chunksize(m->dv));\n    assert(m->dvsize >= MIN_CHUNK_SIZE);\n    assert(bin_find(m, m->dv) == 0);\n  }\n\n  if (m->top != 0) {   /* check top chunk */\n    do_check_top_chunk(m, m->top);\n    assert(m->topsize == chunksize(m->top));\n    assert(m->topsize > 0);\n    assert(bin_find(m, m->top) == 0);\n  }\n\n  total = traverse_and_check(m);\n  assert(total <= m->footprint);\n  assert(m->footprint <= m->max_footprint);\n#if USE_MAX_ALLOWED_FOOTPRINT\n  //TODO: change these assertions if we allow for shrinking.\n  assert(m->footprint <= m->max_allowed_footprint);\n  assert(m->max_footprint <= m->max_allowed_footprint);\n#endif\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* allocate a large request from the best fitting chunk in a treebin */\n", "func_signal": "static void* tmalloc_large(mstate m, size_t nb)", "code": "{\n  tchunkptr v = 0;\n  size_t rsize = -nb; /* Unsigned negation */\n  tchunkptr t;\n  bindex_t idx;\n  compute_tree_index(nb, idx);\n\n  if ((t = *treebin_at(m, idx)) != 0) {\n    /* Traverse tree for this bin looking for node with size == nb */\n    size_t sizebits = nb << leftshift_for_tree_index(idx);\n    tchunkptr rst = 0;  /* The deepest untaken right subtree */\n    for (;;) {\n      tchunkptr rt;\n      size_t trem = chunksize(t) - nb;\n      if (trem < rsize) {\n        v = t;\n        if ((rsize = trem) == 0)\n          break;\n      }\n      rt = t->child[1];\n      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n      if (rt != 0 && rt != t)\n        rst = rt;\n      if (t == 0) {\n        t = rst; /* set t to least subtree holding sizes > nb */\n        break;\n      }\n      sizebits <<= 1;\n    }\n  }\n\n  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */\n    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n    if (leftbits != 0) {\n      bindex_t i;\n      binmap_t leastbit = least_bit(leftbits);\n      compute_bit2idx(leastbit, i);\n      t = *treebin_at(m, i);\n    }\n  }\n\n  while (t != 0) { /* find smallest of tree or subtree */\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n    t = leftmost_child(t);\n  }\n\n  /*  If dv is a better fit, return 0 so malloc will use it */\n  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {\n    if (RTCHECK(ok_address(m, v))) { /* split */\n      mchunkptr r = chunk_plus_offset(v, nb);\n      assert(chunksize(v) == rsize + nb);\n      if (RTCHECK(ok_next(v, r))) {\n        unlink_large_chunk(m, v);\n        if (rsize < MIN_CHUNK_SIZE)\n          set_inuse_and_pinuse(m, v, (rsize + nb));\n        else {\n          set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n          set_size_and_pinuse_of_free_chunk(r, rsize);\n          insert_chunk(m, r, rsize);\n        }\n        return chunk2mem(v);\n      }\n    }\n    CORRUPTION_ERROR_ACTION(m);\n  }\n  return 0;\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* default corruption action */\n", "func_signal": "static void reset_on_error(mstate m)", "code": "{\n  int i;\n  ++malloc_corruption_error_count;\n  /* Reinitialize fields to forget about all memory */\n  m->smallbins = m->treebins = 0;\n  m->dvsize = m->topsize = 0;\n  m->seg.base = 0;\n  m->seg.size = 0;\n  m->seg.next = 0;\n  m->top = m->dv = 0;\n  for (i = 0; i < NTREEBINS; ++i)\n    *treebin_at(m, i) = 0;\n  init_bins(m);\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Allocate chunk and prepend remainder with chunk in successor base. */\n", "func_signal": "static void* prepend_alloc(mstate m, char* newbase, char* oldbase,\n                           size_t nb)", "code": "{\n  mchunkptr p = align_as_chunk(newbase);\n  mchunkptr oldfirst = align_as_chunk(oldbase);\n  size_t psize = (char*)oldfirst - (char*)p;\n  mchunkptr q = chunk_plus_offset(p, nb);\n  size_t qsize = psize - nb;\n  set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n\n  assert((char*)oldfirst > (char*)q);\n  assert(pinuse(oldfirst));\n  assert(qsize >= MIN_CHUNK_SIZE);\n\n  /* consolidate remainder with first chunk of old base */\n  if (oldfirst == m->top) {\n    size_t tsize = m->topsize += qsize;\n    m->top = q;\n    q->head = tsize | PINUSE_BIT;\n    check_top_chunk(m, q);\n  }\n  else if (oldfirst == m->dv) {\n    size_t dsize = m->dvsize += qsize;\n    m->dv = q;\n    set_size_and_pinuse_of_free_chunk(q, dsize);\n  }\n  else {\n    if (!cinuse(oldfirst)) {\n      size_t nsize = chunksize(oldfirst);\n      unlink_chunk(m, oldfirst, nsize);\n      oldfirst = chunk_plus_offset(oldfirst, nsize);\n      qsize += nsize;\n    }\n    set_free_with_pinuse(q, qsize, oldfirst);\n    insert_chunk(m, q, qsize);\n    check_free_chunk(m, q);\n  }\n\n  check_malloced_chunk(m, chunk2mem(p), nb);\n  return chunk2mem(p);\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Unmap and unlink any mmapped segments that don't contain used chunks */\n", "func_signal": "static size_t release_unused_segments(mstate m)", "code": "{\n  size_t released = 0;\n  msegmentptr pred = &m->seg;\n  msegmentptr sp = pred->next;\n  while (sp != 0) {\n    char* base = sp->base;\n    size_t size = sp->size;\n    msegmentptr next = sp->next;\n    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {\n      mchunkptr p = align_as_chunk(base);\n      size_t psize = chunksize(p);\n      /* Can unmap if first chunk holds entire segment and not pinned */\n      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {\n        tchunkptr tp = (tchunkptr)p;\n        assert(segment_holds(sp, (char*)sp));\n        if (p == m->dv) {\n          m->dv = 0;\n          m->dvsize = 0;\n        }\n        else {\n          unlink_large_chunk(m, tp);\n        }\n        if (CALL_MUNMAP(base, size) == 0) {\n          released += size;\n          m->footprint -= size;\n          /* unlink obsoleted record */\n          sp = pred;\n          sp->next = next;\n        }\n        else { /* back out if cannot unmap */\n          insert_large_chunk(m, tp, psize);\n        }\n      }\n    }\n    pred = sp;\n    sp = next;\n  }\n  return released;\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Return true if segment contains a segment link */\n", "func_signal": "static int has_segment_link(mstate m, msegmentptr ss)", "code": "{\n  msegmentptr sp = &m->seg;\n  for (;;) {\n    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)\n      return 1;\n    if ((sp = sp->next) == 0)\n      return 0;\n  }\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Check properties of free chunks */\n", "func_signal": "static void do_check_free_chunk(mstate m, mchunkptr p)", "code": "{\n  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);\n  mchunkptr next = chunk_plus_offset(p, sz);\n  do_check_any_chunk(m, p);\n  assert(!cinuse(p));\n  assert(!next_pinuse(p));\n  assert (!is_mmapped(p));\n  if (p != m->dv && p != m->top) {\n    if (sz >= MIN_CHUNK_SIZE) {\n      assert((sz & CHUNK_ALIGN_MASK) == 0);\n      assert(is_aligned(chunk2mem(p)));\n      assert(next->prev_foot == sz);\n      assert(pinuse(p));\n      assert (next == m->top || cinuse(next));\n      assert(p->fd->bk == p);\n      assert(p->bk->fd == p);\n    }\n    else  /* markers are always of size SIZE_T_SIZE */\n      assert(sz == SIZE_T_SIZE);\n  }\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void* win32direct_mmap(size_t size)", "code": "{\n  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n                           PAGE_READWRITE);\n  return (ptr != 0)? ptr: MFAIL;\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/*  Check all the chunks in a smallbin.  */\n", "func_signal": "static void do_check_smallbin(mstate m, bindex_t i)", "code": "{\n  sbinptr b = smallbin_at(m, i);\n  mchunkptr p = b->bk;\n  unsigned int empty = (m->smallmap & (1U << i)) == 0;\n  if (p == b)\n    assert(empty);\n  if (!empty) {\n    for (; p != b; p = p->bk) {\n      size_t size = chunksize(p);\n      mchunkptr q;\n      /* each chunk claims to be free */\n      do_check_free_chunk(m, p);\n      /* chunk belongs in bin */\n      assert(small_index(size) == i);\n      assert(p->bk == b || chunksize(p->bk) == chunksize(p));\n      /* chunk is followed by an inuse chunk */\n      q = next_chunk(p);\n      if (q->head != FENCEPOST_HEAD)\n        do_check_inuse_chunk(m, q);\n    }\n  }\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* !NO_MALLINFO */\n", "func_signal": "static void internal_malloc_stats(mstate m)", "code": "{\n  if (!PREACTION(m)) {\n    size_t maxfp = 0;\n    size_t fp = 0;\n    size_t used = 0;\n    check_malloc_state(m);\n    if (is_initialized(m)) {\n      msegmentptr s = &m->seg;\n      maxfp = m->max_footprint;\n      fp = m->footprint;\n      used = fp - (m->topsize + TOP_FOOT_SIZE);\n\n      while (s != 0) {\n        mchunkptr q = align_as_chunk(s->base);\n        while (segment_holds(s, q) &&\n               q != m->top && q->head != FENCEPOST_HEAD) {\n          if (!cinuse(q))\n            used -= chunksize(q);\n          q = next_chunk(q);\n        }\n        s = s->next;\n      }\n    }\n\n    fprintf(stderr, \"max system bytes = %10lu\\n\", (unsigned long)(maxfp));\n    fprintf(stderr, \"system bytes     = %10lu\\n\", (unsigned long)(fp));\n    fprintf(stderr, \"in use bytes     = %10lu\\n\", (unsigned long)(used));\n\n    POSTACTION(m);\n  }\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* This function supports releasing coalesed segments */\n", "func_signal": "static int win32munmap(void* ptr, size_t size)", "code": "{\n  MEMORY_BASIC_INFORMATION minfo;\n  char* cptr = ptr;\n  while (size) {\n    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n      return -1;\n    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n        minfo.State != MEM_COMMIT || minfo.RegionSize > size)\n      return -1;\n    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n      return -1;\n    cptr += minfo.RegionSize;\n    size -= minfo.RegionSize;\n  }\n  return 0;\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* Initialize bins for a new mstate that is otherwise zeroed out */\n", "func_signal": "static void init_bins(mstate m)", "code": "{\n  /* Establish circular links for smallbins */\n  bindex_t i;\n  for (i = 0; i < NSMALLBINS; ++i) {\n    sbinptr bin = smallbin_at(m,i);\n    bin->fd = bin->bk = bin;\n  }\n}", "path": "libc\\bionic\\dlmalloc.c", "repo_name": "prajnashi/bionic", "stars": 2, "license": "None", "language": "c", "size": 1884}
{"docstring": "/* G_PLATFORM_WIN32 */\n", "func_signal": "gboolean\ng_get_filename_charsets (G_CONST_RETURN gchar ***filename_charsets)", "code": "{\n  static const gchar *charsets[] = {\n    \"UTF-8\",\n    NULL\n  };\n\n#ifdef G_OS_WIN32\n  /* On Windows GLib pretends that the filename charset is UTF-8 */\n  if (filename_charsets)\n    *filename_charsets = charsets;\n\n  return TRUE;\n#else\n  gboolean result;\n\n  /* Cygwin works like before */\n  result = g_get_charset (&(charsets[0]));\n\n  if (filename_charsets)\n    *filename_charsets = charsets;\n\n  return result;\n#endif\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* Binary compatibility version. Not for newly compiled code. */\n", "func_signal": "gchar*\ng_filename_from_utf8 (const gchar *utf8string,\n\t\t      gssize       len,            \n\t\t      gsize       *bytes_read,    \n\t\t      gsize       *bytes_written,\n\t\t      GError     **error)", "code": "{\n  const gchar *charset;\n\n  if (g_get_charset (&charset))\n    return strdup_len (utf8string, len, bytes_read, bytes_written, error);\n  else\n    return g_convert (utf8string, len,\n\t\t      charset, \"UTF-8\", bytes_read, bytes_written, error);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* allows an empty string */\n", "func_signal": "static gboolean\nhostname_validate (const char *hostname)", "code": "{\n  const char *p;\n  gunichar c, first_char, last_char;\n\n  p = hostname;\n  if (*p == '\\0')\n    return TRUE;\n  do\n    {\n      /* read in a label */\n      c = g_utf8_get_char (p);\n      p = g_utf8_next_char (p);\n      if (!is_asciialphanum (c))\n\treturn FALSE;\n      first_char = c;\n      do\n\t{\n\t  last_char = c;\n\t  c = g_utf8_get_char (p);\n\t  p = g_utf8_next_char (p);\n\t}\n      while (is_asciialphanum (c) || c == '-');\n      if (last_char == '-')\n\treturn FALSE;\n      \n      /* if that was the last label, check that it was a toplabel */\n      if (c == '\\0' || (c == '.' && *p == '\\0'))\n\treturn is_asciialpha (first_char);\n    }\n  while (c == '.');\n  return FALSE;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* !NEED_ICONV_CACHE */\n", "func_signal": "static GIConv\nopen_converter (const gchar *to_codeset,\n\t\tconst gchar *from_codeset,\n\t\tGError     **error)", "code": "{\n  GIConv cd;\n\n  cd = g_iconv_open (to_codeset, from_codeset);\n\n  if (cd == (GIConv) -1)\n    {\n      /* Something went wrong.  */\n      if (error)\n\t{\n\t  if (errno == EINVAL)\n\t    g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,\n\t\t\t _(\"Conversion from character set '%s' to '%s' is not supported\"),\n\t\t\t from_codeset, to_codeset);\n\t  else\n\t    g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,\n\t\t\t _(\"Could not open converter from '%s' to '%s'\"),\n\t\t\t from_codeset, to_codeset);\n\t}\n    }\n  \n  return cd;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/*\n * iconv_cache_bucket_new:\n * @key: cache key\n * @cd: iconv descriptor\n *\n * Creates a new cache bucket, inserts it into the cache and\n * increments the cache size.\n *\n * This assumes ownership of @key.\n *\n * Returns a pointer to the newly allocated cache bucket.\n **/\n", "func_signal": "static struct _iconv_cache_bucket *\niconv_cache_bucket_new (gchar *key, GIConv cd)", "code": "{\n  struct _iconv_cache_bucket *bucket;\n  \n  bucket = g_new (struct _iconv_cache_bucket, 1);\n  bucket->key = key;\n  bucket->refcount = 1;\n  bucket->used = TRUE;\n  bucket->cd = cd;\n  \n  g_hash_table_insert (iconv_cache, bucket->key, bucket);\n  \n  /* FIXME: if we sorted the list so items with few refcounts were\n     first, then we could expire them faster in iconv_cache_expire_unused () */\n  iconv_cache_list = g_list_prepend (iconv_cache_list, bucket);\n  \n  iconv_cache_size++;\n  \n  return bucket;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* This is called from g_thread_init(). It's used to\n * initialize some static data in a threadsafe way.\n */\n", "func_signal": "void \n_g_convert_thread_init (void)", "code": "{\n  const gchar **dummy;\n  (void) g_get_filename_charsets (&dummy);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_uri_list_extract_uris:\n * @uri_list: an URI list \n *\n * Splits an URI list conforming to the text/uri-list\n * mime type defined in RFC 2483 into individual URIs,\n * discarding any comments. The URIs are not validated.\n *\n * Returns: a newly allocated %NULL-terminated list of\n *   strings holding the individual URIs. The array should\n *   be freed with g_strfreev().\n *\n * Since: 2.6\n */\n", "func_signal": "gchar **\ng_uri_list_extract_uris (const gchar *uri_list)", "code": "{\n  GSList *uris, *u;\n  const gchar *p, *q;\n  gchar **result;\n  gint n_uris = 0;\n\n  uris = NULL;\n\n  p = uri_list;\n\n  /* We don't actually try to validate the URI according to RFC\n   * 2396, or even check for allowed characters - we just ignore\n   * comments and trim whitespace off the ends.  We also\n   * allow LF delimination as well as the specified CRLF.\n   *\n   * We do allow comments like specified in RFC 2483.\n   */\n  while (p)\n    {\n      if (*p != '#')\n\t{\n\t  while (g_ascii_isspace (*p))\n\t    p++;\n\n\t  q = p;\n\t  while (*q && (*q != '\\n') && (*q != '\\r'))\n\t    q++;\n\n\t  if (q > p)\n\t    {\n\t      q--;\n\t      while (q > p && g_ascii_isspace (*q))\n\t\tq--;\n\n\t      if (q > p)\n\t\t{\n\t\t  uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));\n\t\t  n_uris++;\n\t\t}\n\t    }\n\t}\n      p = strchr (p, '\\n');\n      if (p)\n\tp++;\n    }\n\n  result = g_new (gchar *, n_uris + 1);\n\n  result[n_uris--] = NULL;\n  for (u = uris; u; u = u->next)\n    result[n_uris--] = u->data;\n\n  g_slist_free (uris);\n\n  return result;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* caller *must* hold the iconv_cache_lock */\n", "func_signal": "static void\niconv_cache_init (void)", "code": "{\n  static gboolean initialized = FALSE;\n  \n  if (initialized)\n    return;\n  \n  iconv_cache_list = NULL;\n  iconv_cache = g_hash_table_new (g_str_hash, g_str_equal);\n  iconv_open_hash = g_hash_table_new (g_direct_hash, g_direct_equal);\n  \n  initialized = TRUE;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* G_PLATFORM_WIN32 */\n", "func_signal": "static gboolean\nget_filename_charset (const gchar **filename_charset)", "code": "{\n  const gchar **charsets;\n  gboolean is_utf8;\n  \n  is_utf8 = g_get_filename_charsets (&charsets);\n\n  if (filename_charset)\n    *filename_charset = charsets[0];\n  \n  return is_utf8;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_filename_from_uri:\n * @uri: a uri describing a filename (escaped, encoded in ASCII).\n * @hostname: Location to store hostname for the URI, or %NULL.\n *            If there is no hostname in the URI, %NULL will be\n *            stored in this location.\n * @error: location to store the error occuring, or %NULL to ignore\n *         errors. Any of the errors in #GConvertError may occur.\n * \n * Converts an escaped ASCII-encoded URI to a local filename in the\n * encoding used for filenames. \n * \n * Return value: a newly-allocated string holding the resulting\n *               filename, or %NULL on an error.\n **/\n", "func_signal": "gchar *\ng_filename_from_uri (const gchar *uri,\n\t\t     gchar      **hostname,\n\t\t     GError     **error)", "code": "{\n  const char *path_part;\n  const char *host_part;\n  char *unescaped_hostname;\n  char *result;\n  char *filename;\n  int offs;\n#ifdef G_OS_WIN32\n  char *p, *slash;\n#endif\n\n  if (hostname)\n    *hostname = NULL;\n\n  if (!has_case_prefix (uri, \"file:/\"))\n    {\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,\n\t\t   _(\"The URI '%s' is not an absolute URI using the \\\"file\\\" scheme\"),\n\t\t   uri);\n      return NULL;\n    }\n  \n  path_part = uri + strlen (\"file:\");\n  \n  if (strchr (path_part, '#') != NULL)\n    {\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,\n\t\t   _(\"The local file URI '%s' may not include a '#'\"),\n\t\t   uri);\n      return NULL;\n    }\n\t\n  if (has_case_prefix (path_part, \"///\")) \n    path_part += 2;\n  else if (has_case_prefix (path_part, \"//\"))\n    {\n      path_part += 2;\n      host_part = path_part;\n\n      path_part = strchr (path_part, '/');\n\n      if (path_part == NULL)\n\t{\n\t  g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,\n\t\t       _(\"The URI '%s' is invalid\"),\n\t\t       uri);\n\t  return NULL;\n\t}\n\n      unescaped_hostname = g_unescape_uri_string (host_part, path_part - host_part, \"\", TRUE);\n\n      if (unescaped_hostname == NULL ||\n\t  !hostname_validate (unescaped_hostname))\n\t{\n\t  g_free (unescaped_hostname);\n\t  g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,\n\t\t       _(\"The hostname of the URI '%s' is invalid\"),\n\t\t       uri);\n\t  return NULL;\n\t}\n      \n      if (hostname)\n\t*hostname = unescaped_hostname;\n      else\n\tg_free (unescaped_hostname);\n    }\n\n  filename = g_unescape_uri_string (path_part, -1, \"/\", FALSE);\n\n  if (filename == NULL)\n    {\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,\n\t\t   _(\"The URI '%s' contains invalidly escaped characters\"),\n\t\t   uri);\n      return NULL;\n    }\n\n  offs = 0;\n#ifdef G_OS_WIN32\n  /* Drop localhost */\n  if (hostname && *hostname != NULL &&\n      g_ascii_strcasecmp (*hostname, \"localhost\") == 0)\n    {\n      g_free (*hostname);\n      *hostname = NULL;\n    }\n\n  /* Turn slashes into backslashes, because that's the canonical spelling */\n  p = filename;\n  while ((slash = strchr (p, '/')) != NULL)\n    {\n      *slash = '\\\\';\n      p = slash + 1;\n    }\n\n  /* Windows URIs with a drive letter can be like \"file://host/c:/foo\"\n   * or \"file://host/c|/foo\" (some Netscape versions). In those cases, start\n   * the filename from the drive letter.\n   */\n  if (g_ascii_isalpha (filename[1]))\n    {\n      if (filename[2] == ':')\n\toffs = 1;\n      else if (filename[2] == '|')\n\t{\n\t  filename[2] = ':';\n\t  offs = 1;\n\t}\n    }\n#endif\n\n  result = g_strdup (filename + offs);\n  g_free (filename);\n\n  return result;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_iconv_close:\n * @converter: a conversion descriptor from g_iconv_open()\n *\n * Same as the standard UNIX routine iconv_close(), but\n * may be implemented via libiconv on UNIX flavors that lack\n * a native implementation. Should be called to clean up\n * the conversion descriptor from g_iconv_open() when\n * you are done converting things.\n *\n * GLib provides g_convert() and g_locale_to_utf8() which are likely\n * more convenient than the raw iconv wrappers.\n * \n * Return value: -1 on error, 0 on success\n **/\n", "func_signal": "gint\ng_iconv_close (GIConv converter)", "code": "{\n  iconv_t cd = (iconv_t)converter;\n\n  return iconv_close (cd);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* Note: This escape function works on file: URIs, but if you want to\n * escape something else, please read RFC-2396 */\n", "func_signal": "static gchar *\ng_escape_uri_string (const gchar *string, \n\t\t     UnsafeCharacterSet mask)", "code": "{\n#define ACCEPTABLE(a) ((a)>=32 && (a)<128 && (acceptable[(a)-32] & use_mask))\n\n  const gchar *p;\n  gchar *q;\n  gchar *result;\n  int c;\n  gint unacceptable;\n  UnsafeCharacterSet use_mask;\n  \n  g_return_val_if_fail (mask == UNSAFE_ALL\n\t\t\t|| mask == UNSAFE_ALLOW_PLUS\n\t\t\t|| mask == UNSAFE_PATH\n\t\t\t|| mask == UNSAFE_HOST\n\t\t\t|| mask == UNSAFE_SLASHES, NULL);\n  \n  unacceptable = 0;\n  use_mask = mask;\n  for (p = string; *p != '\\0'; p++)\n    {\n      c = (guchar) *p;\n      if (!ACCEPTABLE (c)) \n\tunacceptable++;\n    }\n  \n  result = g_malloc (p - string + unacceptable * 2 + 1);\n  \n  use_mask = mask;\n  for (q = result, p = string; *p != '\\0'; p++)\n    {\n      c = (guchar) *p;\n      \n      if (!ACCEPTABLE (c))\n\t{\n\t  *q++ = '%'; /* means hex coming */\n\t  *q++ = hex[c >> 4];\n\t  *q++ = hex[c & 15];\n\t}\n      else\n\t*q++ = *p;\n    }\n  \n  *q = '\\0';\n  \n  return result;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_filename_to_uri:\n * @filename: an absolute filename specified in the GLib file name encoding,\n *            which is the on-disk file name bytes on Unix, and UTF-8 on \n *            Windows\n * @hostname: A UTF-8 encoded hostname, or %NULL for none.\n * @error: location to store the error occuring, or %NULL to ignore\n *         errors. Any of the errors in #GConvertError may occur.\n * \n * Converts an absolute filename to an escaped ASCII-encoded URI, with the path\n * component following Section 3.3. of RFC 2396.\n * \n * Return value: a newly-allocated string holding the resulting\n *               URI, or %NULL on an error.\n **/\n", "func_signal": "gchar *\ng_filename_to_uri (const gchar *filename,\n\t\t   const gchar *hostname,\n\t\t   GError     **error)", "code": "{\n  char *escaped_uri;\n\n  g_return_val_if_fail (filename != NULL, NULL);\n\n  if (!g_path_is_absolute (filename))\n    {\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,\n\t\t   _(\"The pathname '%s' is not an absolute path\"),\n\t\t   filename);\n      return NULL;\n    }\n\n  if (hostname &&\n      !(g_utf8_validate (hostname, -1, NULL)\n\t&& hostname_validate (hostname)))\n    {\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,\n\t\t   _(\"Invalid hostname\"));\n      return NULL;\n    }\n  \n#ifdef G_OS_WIN32\n  /* Don't use localhost unnecessarily */\n  if (hostname && g_ascii_strcasecmp (hostname, \"localhost\") == 0)\n    hostname = NULL;\n#endif\n\n  escaped_uri = g_escape_file_uri (hostname, filename);\n\n  return escaped_uri;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_iconv_open:\n * @to_codeset: destination codeset\n * @from_codeset: source codeset\n * \n * Same as the standard UNIX routine iconv_open(), but\n * may be implemented via libiconv on UNIX flavors that lack\n * a native implementation.\n * \n * GLib provides g_convert() and g_locale_to_utf8() which are likely\n * more convenient than the raw iconv wrappers.\n * \n * Return value: a \"conversion descriptor\", or (GIConv)-1 if\n *  opening the converter failed.\n **/\n", "func_signal": "GIConv\ng_iconv_open (const gchar  *to_codeset,\n\t      const gchar  *from_codeset)", "code": "{\n  iconv_t cd;\n  \n  if (!try_conversion (to_codeset, from_codeset, &cd))\n    {\n      const char **to_aliases = _g_charset_get_aliases (to_codeset);\n      const char **from_aliases = _g_charset_get_aliases (from_codeset);\n\n      if (from_aliases)\n\t{\n\t  const char **p = from_aliases;\n\t  while (*p)\n\t    {\n\t      if (try_conversion (to_codeset, *p, &cd))\n\t\tgoto out;\n\n\t      if (try_to_aliases (to_aliases, *p, &cd))\n\t\tgoto out;\n\n\t      p++;\n\t    }\n\t}\n\n      if (try_to_aliases (to_aliases, from_codeset, &cd))\n\tgoto out;\n    }\n\n out:\n  return (cd == (iconv_t)-1) ? (GIConv)-1 : (GIConv)cd;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/**\n * g_iconv:\n * @converter: conversion descriptor from g_iconv_open()\n * @inbuf: bytes to convert\n * @inbytes_left: inout parameter, bytes remaining to convert in @inbuf\n * @outbuf: converted output bytes\n * @outbytes_left: inout parameter, bytes available to fill in @outbuf\n * \n * Same as the standard UNIX routine iconv(), but\n * may be implemented via libiconv on UNIX flavors that lack\n * a native implementation.\n *\n * GLib provides g_convert() and g_locale_to_utf8() which are likely\n * more convenient than the raw iconv wrappers.\n * \n * Return value: count of non-reversible conversions, or -1 on error\n **/\n", "func_signal": "gsize \ng_iconv (GIConv   converter,\n\t gchar  **inbuf,\n\t gsize   *inbytes_left,\n\t gchar  **outbuf,\n\t gsize   *outbytes_left)", "code": "{\n  iconv_t cd = (iconv_t)converter;\n\n  return iconv (cd, inbuf, inbytes_left, outbuf, outbytes_left);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* Binary compatibility version. Not for newly compiled code. */\n", "func_signal": "gchar*\ng_filename_to_utf8 (const gchar *opsysstring, \n\t\t    gssize       len,           \n\t\t    gsize       *bytes_read,   \n\t\t    gsize       *bytes_written,\n\t\t    GError     **error)", "code": "{\n  const gchar *charset;\n\n  if (g_get_charset (&charset))\n    return strdup_len (opsysstring, len, bytes_read, bytes_written, error);\n  else\n    return g_convert (opsysstring, len, \n\t\t      \"UTF-8\", charset, bytes_read, bytes_written, error);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/*\n * g_locale_to_utf8\n *\n * \n */\n", "func_signal": "static gchar *\nstrdup_len (const gchar *string,\n\t    gssize       len,\n\t    gsize       *bytes_written,\n\t    gsize       *bytes_read,\n\t    GError      **error)", "code": "{\n  gsize real_len;\n\n  if (!g_utf8_validate (string, len, NULL))\n    {\n      if (bytes_read)\n\t*bytes_read = 0;\n      if (bytes_written)\n\t*bytes_written = 0;\n\n      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,\n\t\t   _(\"Invalid byte sequence in conversion input\"));\n      return NULL;\n    }\n  \n  if (len < 0)\n    real_len = strlen (string);\n  else\n    {\n      real_len = 0;\n      \n      while (real_len < len && string[real_len])\n\treal_len++;\n    }\n  \n  if (bytes_read)\n    *bytes_read = real_len;\n  if (bytes_written)\n    *bytes_written = real_len;\n\n  return g_strndup (string, real_len);\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/*\n * iconv_cache_bucket_expire:\n * @node: cache bucket's node\n * @bucket: cache bucket\n *\n * Expires a single cache bucket @bucket. This should only ever be\n * called on a bucket that currently has no used iconv descriptors\n * open.\n *\n * @node is not a required argument. If @node is not supplied, we\n * search for it ourselves.\n **/\n", "func_signal": "static void\niconv_cache_bucket_expire (GList *node, struct _iconv_cache_bucket *bucket)", "code": "{\n  g_hash_table_remove (iconv_cache, bucket->key);\n  \n  if (node == NULL)\n    node = g_list_find (iconv_cache_list, bucket);\n  \n  g_assert (node != NULL);\n  \n  if (node->prev)\n    {\n      node->prev->next = node->next;\n      if (node->next)\n        node->next->prev = node->prev;\n    }\n  else\n    {\n      iconv_cache_list = node->next;\n      if (node->next)\n        node->next->prev = NULL;\n    }\n  \n  g_list_free_1 (node);\n  \n  g_free (bucket->key);\n  g_iconv_close (bucket->cd);\n  g_free (bucket);\n  \n  iconv_cache_size--;\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/* Test of haystack has the needle prefix, comparing case\n * insensitive. haystack may be UTF-8, but needle must\n * contain only ascii. */\n", "func_signal": "static gboolean\nhas_case_prefix (const gchar *haystack, const gchar *needle)", "code": "{\n  const gchar *h, *n;\n  \n  /* Eat one character at a time. */\n  h = haystack;\n  n = needle;\n\n  while (*n && *h &&\n\t g_ascii_tolower (*n) == g_ascii_tolower (*h))\n    {\n      n++;\n      h++;\n    }\n  \n  return *n == '\\0';\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "/*\n * iconv_cache_expire_unused:\n *\n * Expires as many unused cache buckets as it needs to in order to get\n * the total number of buckets < ICONV_CACHE_SIZE.\n **/\n", "func_signal": "static void\niconv_cache_expire_unused (void)", "code": "{\n  struct _iconv_cache_bucket *bucket;\n  GList *node, *next;\n  \n  node = iconv_cache_list;\n  while (node && iconv_cache_size >= ICONV_CACHE_SIZE)\n    {\n      next = node->next;\n      \n      bucket = node->data;\n      if (bucket->refcount == 0)\n        iconv_cache_bucket_expire (node, bucket);\n      \n      node = next;\n    }\n}", "path": "aqua\\glib\\gconvert.c", "repo_name": "hananh/xchat-aqua", "stars": 3, "license": "gpl-2.0", "language": "c", "size": 11537}
{"docstring": "// check whether a group of frames is resizable in the direction of 'axis'\n", "func_signal": "ubyte frame_siblings_growable(frame **siblings, ubyte axis, ucell size)", "code": "{\n\tint i, x, y, w, h;\n\tframe *f = siblings[0];\n\tif (axis == LEFT || axis == RIGHT)\n\t{\n\t\tif (axis == LEFT) { x = f->x - size; y = f->y; }\n\t\telse { x = f->x + f->w; y = f->y; }\n\t\tw = size; h = 0;\n\t\tfor (i = 0; siblings[i]; i++)\n\t\t\ty = MIN(y, siblings[i]->y), h += siblings[i]->h;\n\t} else\n\tif (axis == TOP || axis == BOTTOM)\n\t{\n\t\tif (axis == TOP) { x = f->x; y = f->y - size; }\n\t\telse { x = f->x; y = f->y + f->h; }\n\t\tw = 0; h = size;\n\t\tfor (i = 0; siblings[i]; i++)\n\t\t\tx = MIN(x, siblings[i]->x), w += siblings[i]->w;\n\t}\n\tFOR_RING (f, f->group->frames, i)\n\t{\n\t\tif (frame_covers(f, x+1, y+1, w-2, h-2))\n\t\t{\n\t\t\tif ((axis == LEFT || axis == RIGHT ) && f->w <= settings[ms_frame_min_wh].u) return 0;\n\t\t\tif ((axis == TOP  || axis == BOTTOM) && f->h <= settings[ms_frame_min_wh].u) return 0;\n\t\t}\n\t}\n\treturn 1;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// return false/0 if the frame does not cover the block dfine dby x, y, w, h.\n// if the frame and block do overlap anywhere, return the side of the frame\n// closest to a block side.\n", "func_signal": "ubyte frame_covers(frame *s, int x, int y, int width, int height)", "code": "{\n\tubyte side = 0;\n\tint a = x, b = y, c = x + width, d = y + height;\n\tint e = s->x, f = s->y, g = s->x + s->w, h = s->y + s->h;\n\t     if (e > a && f > b && e < c && f < d) // ef\n\t\tside = nearest_side(e, f, a, b, c, d);\n\telse if (g > a && f > b && g < c && f < d) // gf\n\t\tside = nearest_side(g, f, a, b, c, d);\n\telse if (e > a && h > b && e < c && h < d) // eh\n\t\tside = nearest_side(e, h, a, b, c, d);\n\telse if (g > a && h > b && g < c && h < d) // gh\n\t\tside = nearest_side(g, h, a, b, c, d);\n\telse if (a > e && b > f && a < g && b < h) // ab\n\t\tside = nearest_side(a, b, e, f, g, h);\n\telse if (c > e && b > f && c < g && b < h) // cb\n\t\tside = nearest_side(c, b, e, f, g, h);\n\telse if (a > e && d > f && a < g && d < h) // ad\n\t\tside = nearest_side(a, d, e, f, g, h);\n\telse if (c > e && d > f && c < g && d < h) // cd\n\t\tside = nearest_side(c, d, e, f, g, h);\n\treturn side;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// CLIENTS\n", "func_signal": "void client_configure(client *c, XConfigureRequestEvent *cr)", "code": "{\n\tXWindowAttributes attr;\n\tWindow trans = None;\n\tXSizeHints hints;\n\tlong userhints;\n\tint x, y, w, h, pw, ph, b;\n\tframe *f = c->frame;\n\tgroup *g = c->group;\n\tWindow win = c->win;\n\tchar debug[BLOCK]; int dlen = 0;\n\n\tif (g->flags & GF_STACKING)\n\t{\n\t\tx = g->l; y = g->t;\n\t\tpw = g->head->screen->width - g->l - g->r;\n\t\tph = g->head->screen->height - g->t - g->b;\n\t} else\n\t{\n\t\tx = f->x+1; y = f->y+1;\n\t\tpw = f->w-2; ph = f->h-2;\n\t}\n\tw = pw; h = ph;\n\twindow_name(c->win, c->name);\n\twindow_class(c->win, c->class);\n\tdlen += sprintf(debug+dlen, \"%s \", c->name);\n\n\tif (!XGetTransientForHint(display, win, &trans) && trans == None && g->flags & GF_TILING)\n\t{\n\t\t// normal windows go full frame\n\t\tdlen += sprintf(debug+dlen, \"normal \");\n\t\tw = pw; h = ph; b = 0;\n\t} else\n\t{\n\t\tb = 1;\n\t\t// stacking and transient windows stay their preferred size\n\t\tif (XGetWindowAttributes(display, win, &attr))\n\t\t{\n\t\t\tx = attr.x; y = attr.y; w = attr.width; h = attr.height;\n\t\t}\n\t\tif (cr)\n\t\t{\n\t\t\tif (cr->value_mask & CWX) x = cr->x;\n\t\t\tif (cr->value_mask & CWY) y = cr->y;\n\t\t\tif (cr->value_mask & CWWidth)  w = cr->width;\n\t\t\tif (cr->value_mask & CWHeight) h = cr->height;\n\t\t}\n\t\tdlen += sprintf(debug+dlen, \"floating %d %d %d %d \", x, y, w, h);\n\t}\n\tif (XGetWMNormalHints(display, win, &hints, &userhints))\n\t{\n\t\tdlen += sprintf(debug+dlen, \"hints \");\n\t\tif (hints.flags & PMinSize)\n\t\t{\n\t\t\tdlen += sprintf(debug+dlen, \"PMinSize %d %d \", hints.min_width, hints.min_height);\n\t\t\tw = MAX(w, hints.min_width); h = MAX(h, hints.min_height);\n\t\t}\n\t\tif (hints.flags & PMaxSize)\n\t\t{\n\t\t\tdlen += sprintf(debug+dlen, \"PMaxSize %d %d \", hints.max_width, hints.max_height);\n\t\t\tw = MIN(w, hints.max_width); h = MIN(h, hints.max_height);\n\t\t}\n\t\tif (hints.flags & PResizeInc && hints.flags & PBaseSize)\n\t\t{\n\t\t\tw -= hints.base_width; h -= hints.base_height;\n\t\t\tw -= w % hints.width_inc; h -= h % hints.height_inc;\n\t\t\tw += hints.base_width; h += hints.base_height;\n\t\t\tdlen += sprintf(debug+dlen, \"PResizeInc %d %d %d %d \", hints.width_inc, hints.height_inc, w, h);\n\t\t}\n\t\tif (hints.flags & PAspect)\n\t\t{\n\t\t\tdcell ratio = (dcell)w / h;\n\t\t\tdcell minr = (dcell)hints.min_aspect.x / hints.min_aspect.y;\n\t\t\tdcell maxr = (dcell)hints.max_aspect.x / hints.max_aspect.y;\n\t\t\tdlen += sprintf(debug+dlen, \"PAspect %2.2f %2.2f %2.2f \", ratio, minr, maxr);\n\t\t\t\tif (ratio < minr) h = (int)(w / minr);\n\t\t\telse if (ratio > maxr) w = (int)(h * maxr);\n\t\t}\n\t\tw = MIN(w, pw); h = MIN(h, ph);\n\t\tif (trans == None)\n\t\t{\n\t\t\tw = MAX(settings[ms_frame_min_wh].u-2, w);\n\t\t\th = MAX(settings[ms_frame_min_wh].u-2, h);\n\t\t}\n\t}\n\t// center fixed size window whe tiling\n\tif (g->flags & GF_TILING && (w < pw || h < ph))\n\t{\n\t\tx = f->x+1 + ((pw - w) / 2);\n\t\ty = f->y+1 + ((ph - h) / 2);\n\t}\n\tdlen += sprintf(debug+dlen, \"Co-ords %d %d %d %d \", x, y, w, h);\n\tif (c->x != x || c->y != y || c->w != w || c->h != h)\n\t\tXMoveResizeWindow(display, win, x, y, w, h);\n\tXSetWindowBorderWidth(display, win, b);\n\tXSetWindowBorder(display, win, get_color(c->group->head, settings[ms_border_unfocus].s));\n\tc->x = x; c->y = y; c->w = w; c->h = h;\n\tif (DEBUG) note(\"%s\", debug);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/*\nint\nresize_list()\n{\n\twresize(list, LIST_LINES, COLS);\n}\n*/\n", "func_signal": "int\nuilist_free()", "code": "{\n\tdelwin(list);\n\tlist = NULL;\n}", "path": "pwman\\src\\uilist.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/**\n * Get multiple GnuPG Recipient IDs\n */\n", "func_signal": "void\ngnupg_get_ids(char **ids, int max_id_num)", "code": "{\n\tInputField fields[max_id_num];\n\tchar names[max_id_num][STRING_LONG];\n\tint i;\n\n\tfor(i=0; i<max_id_num; i++) {\n\t\tfields[i].name = names[i]; // Needs a local string to write into\n\t\tsnprintf(fields[i].name, STRING_LONG, \"Recipient %d: \", (i+1));\n\t\tfields[i].value = ids[i]; // String to write into comes from caller\n\t\tfields[i].max_length = STRING_LONG;\n\t\tfields[i].type = STRING;\n\t}\n\n\t// Prompt to edit the recipients\n\t// This will verify the IDs for us\n\taction_input_gpgid_dialog(fields, max_id_num, \"Edit Recipients\");\n}", "path": "pwman\\src\\gnupg.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// resize frames to match changes in the screen border padding\n", "func_signal": "void group_resize(group *ta, int l, int r, int t, int b)", "code": "{\n\tframe *f = ta->frames; int i;\n\tint sw = ta->head->screen->width;\n\tint sh = ta->head->screen->height;\n\t     if (l < ta->l) { frames_fill_gap(ta, l, ta->t, ta->l - l, sh - ta->b, FRAMES_ALL); ta->l = l; }\n\telse if (l > ta->l) { frames_make_gap(ta, ta->l, ta->t, l - ta->l, sh - ta->b); ta->l = l; }\n\t     if (r < ta->r) { frames_fill_gap(ta, sw - ta->r, ta->t, ta->r - r, sh - ta->b, FRAMES_ALL); ta->r = r; }\n\telse if (r > ta->r) { frames_make_gap(ta, sw - r, ta->t, r - ta->r, sh - ta->b); ta->r = r; }\n\t     if (t < ta->t) { frames_fill_gap(ta, ta->l, t, sw - ta->l - ta->r, ta->t - t, FRAMES_ALL); ta->t = t; }\n\telse if (t > ta->t) { frames_make_gap(ta, ta->l, ta->t, sw - ta->l - ta->r, t - ta->t); ta->t = t; }\n\t     if (b < ta->b) { frames_fill_gap(ta, ta->l, sh - ta->b, sw - ta->l - ta->r, ta->b - b, FRAMES_ALL); ta->b = b; }\n\telse if (b > ta->b) { frames_make_gap(ta, ta->l, sh - b, sw - ta->l - ta->r, b - ta->b); ta->b = b; }\n\tFOR_RING (f, ta->frames, i)\n\t\tframe_update(f);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// locate all frames bordering the block defined by x, y, w, h.  'bordering'\n// follows the frame_borders() rules.\n", "func_signal": "struct frame_match* frames_bordering(group *t, int x, int y, int w, int h)", "code": "{\n\t// null terminator\n\tframe *f; int i = 0, fc;\n\tFOR_RING (f, t->frames, fc); fc++;\n\tstruct frame_match *matches = allocate(sizeof(struct frame_match)*fc);\n\tmemset(matches, 0, sizeof(struct frame_match)*fc);\n\tFOR_RING (f, t->frames, fc)\n\t{\n\t\tubyte side = frame_borders(f, x, y, w, h);\n\t\tif (side)\n\t\t{\n\t\t\tmatches[i].frame = f;\n\t\t\tmatches[i].side = side;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn matches;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/**\n * Get a single GnuPG Recipient ID\n */\n", "func_signal": "void\ngnupg_get_id(char *id)", "code": "{\n\twhile(1){\n\t\tid = ui_statusline_ask_str(\"GnuPG Recipient ID:\", id, STRING_LONG);\n\t\tif(id[0] == 0){\n\t\t\treturn;\n\t\t}\n\t\tif(gnupg_check_id(id) == 0){\n\t\t\treturn;\n\t\t}\n\t\tdebug(\"get_gnupg_id: if here is reached id is bad\");\n\t\tui_statusline_msg(\"Bad Recipient, Try again\"); getch();\n\t}\n}", "path": "pwman\\src\\gnupg.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// will override this as some sort of gui notice\n", "func_signal": "void say(const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap,fmt);\n\tchar pad[BLOCK], cmd[BLOCK];\n\tvsnprintf(pad, BLOCK, fmt, ap);\n\tva_end(ap);\n\tsnprintf(cmd, BLOCK, settings[ms_notify].s, pad);\n\texec_cmd(cmd);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// find a frame's siblings on the same axis.  these will form a single block bordering the axis\n", "func_signal": "frame** frame_siblings(frame *f, ubyte axis)", "code": "{\n\tframe *s, **matches = allocate(sizeof(frame*)*NOTE);\n\tmemset(matches, 0, sizeof(frame*)*NOTE);\n\t// first check for an opposite frame that exactly matches. we don't\n\t// want to move a group unless we have to\n\tint i = 0; matches[i++] = f;\n\tubyte side1 = 0, side2 = 0;\n\tif (axis == LEFT || axis == RIGHT)\n\t\t{ side1 = TOP; side2 = BOTTOM; }\n\telse { side1 = LEFT; side2 = RIGHT; }\n\ts = f->group->frames;\n\tdo {\ts = frame_sibling(s, axis, side1);\n\t\tif (s) matches[i++] = s;\n\t} while (s);\n\ts = f;\n\tdo {\ts = frame_sibling(s, axis, side2);\n\t\tif (s) matches[i++] = s;\n\t} while (s);\n\treturn matches;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// EVENTS\n", "func_signal": "void menu(char *cmd, char *after)", "code": "{\n\tchar *tmp = allocate(strlen(cmd)+strlen(after)+BLOCK);\n\tsprintf(tmp, \"%s | %s | %s\", cmd, settings[ms_dmenu].s, after);\n\texec_cmd(tmp); free(tmp);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// resize as many frames as necessary to fill the block defined by x, y, w, h, ignoring\n// any frames in **exceptions.\n", "func_signal": "void frames_fill_gap_except(group *t, frame **exceptions, int x, int y, int w, int h, ubyte mode)", "code": "{\n\tstruct frame_match *matches = frames_bordering(t, x, y, w, h);\n\tint sides[5], i; memset(&sides, 0, sizeof(int)*5);\n\tfor (i = 0; matches[i].frame; i++)\n\t\tif (!frame_in_set(exceptions, matches[i].frame))\n\t\t\tsides[matches[i].side]++;\n\tif (sides[LEFT] && sides[RIGHT])\n\t\tsides[sides[LEFT] < sides[RIGHT] ? RIGHT: LEFT] = 0;\n\tif (sides[TOP] && sides[BOTTOM])\n\t\tsides[sides[TOP] < sides[BOTTOM] ? BOTTOM: TOP] = 0;\n\tif (mode == FRAMES_FEWEST)\n\t{\n\t\tif (sides[TOP] + sides[BOTTOM] < sides[LEFT] + sides[RIGHT])\n\t\t\t{ sides[TOP] = 0; sides[BOTTOM] = 0; }\n\t\telse { sides[LEFT] = 0; sides[RIGHT] = 0; }\n\t}\n\tfor (i = 0; matches[i].frame; i++)\n\t{\n\t\tframe *f = matches[i].frame;\n\t\tubyte side = matches[i].side;\n\t\tif (frame_in_set(exceptions, f)) continue;\n\t\tif (!sides[side]) continue;\n\t\t     if (side == LEFT) { f->x -= w; f->w += w; }\n\t\telse if (side == RIGHT)  f->w += w;\n\t\telse if (side == TOP)  { f->y -= h; f->h += h; }\n\t\telse if (side == BOTTOM) f->h += h;\n\t\tframe_update(f);\n\t}\n\tfree(matches);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// x11 color\n", "func_signal": "ucell get_color(head *h, const char *name)", "code": "{\n\tXColor color;\n\tColormap map = DefaultColormap(display, h->id);\n\treturn XAllocNamedColor(display, map, name, &color, &color) ? color.pixel: None;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// return 0/false if the frame is not adjacent to the block defined by x, y, w, h.\n// if a frame side does touch a block side, and the length of the frame's side is\n// contained *entirely within* the block side, return the side number.\n// also see frame_relative()\n", "func_signal": "ubyte frame_borders(frame *s, int x, int y, int w, int h)", "code": "{\n\tubyte in_y = (s->y >= y && s->y + s->h <= y + h) ? 1: 0;\n\tubyte in_x = (s->x >= x && s->x + s->w <= x + w) ? 1: 0;\n\tif (s->x == x && in_y) return LEFT;\n\tif (s->x == x + w && in_y) return LEFT;\n\tif (s->x + s->w == x && in_y) return RIGHT;\n\tif (s->x + s->w == x + w && in_y) return RIGHT;\n\tif (s->y == y && in_x) return TOP;\n\tif (s->y == y + h && in_x) return TOP;\n\tif (s->y + s->h == y && in_x) return BOTTOM;\n\tif (s->y + s->h == y + h && in_x) return BOTTOM;\n\treturn 0;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// HEADS\n", "func_signal": "void head_focus(head *h)", "code": "{\n\tgroup_unfocus(heads->groups);\n\theads = h;\n\tif (heads->display_string)\n\t\tputenv(heads->display_string);\n\tgroup_focus(heads->groups);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// exchange the content of the current frame for another\n", "func_signal": "void frame_swap(ubyte direction)", "code": "{\n\tgroup_track(heads->groups);\n\tgroup *t = heads->groups;\n\tframe *f = t->frames;\n\tframe *s = frame_relative(f, direction);\n\tif (s)\n\t{\n\t\tclient *a = f->cli, *b = s->cli;\n\t\tf->cli = NULL; s->cli = NULL;\n\t\tif (a) client_display(a, s);\n\t\tif (b) client_display(b, f);\n\t}\n\tframe_focus(f);\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/* Borrowed/adapted from e2fsprogs's UUID generation code */\n", "func_signal": "static int pwgen_get_random_fd(void)", "code": "{\n\tstruct timeval\ttv;\n\tstatic int\tfd = -2;\n\tint\t\ti;\n\n\tif (fd == -2) {\n\t\tgettimeofday(&tv, 0);\n\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\t\tif (fd == -1)\n\t\t\tfd = open(\"/dev/random\", O_RDONLY | O_NONBLOCK);\n#ifdef HAVE_DRAND48\n\t\tsrand48((tv.tv_sec<<9) ^ (getpgrp()<<15) ^\n\t\t\t(getpid()) ^ (tv.tv_usec>>11));\n#else\n\t\tsrandom((getpid() << 16) ^ (getpgrp() << 8) ^ getuid() \n\t\t      ^ tv.tv_sec ^ tv.tv_usec);\n#endif\n\t}\n\t/* Crank the random number generator a few times */\n\tgettimeofday(&tv, 0);\n\tfor (i = (tv.tv_sec ^ tv.tv_usec) & 0x1F; i > 0; i--)\n#ifdef HAVE_DRAND48\n\t\tdrand48();\n#else\n\t\trand();\n#endif\n\treturn fd;\n}", "path": "pwman\\src\\pwgen.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// find a frame that has some adjacent border to the supplied frame, in the direction of side\n// this bails out with the first find.  could be expanded to return the frame with the longest\n// stretch of adjacent border, which might be more intuitive in the UI navigation.\n", "func_signal": "frame* frame_relative(frame *f, ubyte side)", "code": "{\n\tframe *s; int i;\n\tFOR_RING (s, f, i)\n\t{\n\t\t// skip self\n\t\tif (!i) continue;\n\t\tif (\t(side == LEFT   && f->x == (s->x + s->w) && frames_overlap_y(f, s)) ||\n\t\t\t(side == RIGHT  && s->x == (f->x + f->w) && frames_overlap_y(f, s)) ||\n\t\t\t(side == TOP    && f->y == (s->y + s->h) && frames_overlap_x(f, s)) ||\n\t\t\t(side == BOTTOM && s->y == (f->y + f->h) && frames_overlap_x(f, s))\n\t\t\t) return s;\n\t}\n\treturn NULL;\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "// error handler courtesy of dwm\n", "func_signal": "int error_callback(Display *dpy, XErrorEvent *ee)", "code": "{\n\tif (  ee->error_code == BadWindow ||\n\t\t(ee->request_code == X_SetInputFocus     && ee->error_code == BadMatch   ) ||\n\t\t(ee->request_code == X_PolyText8         && ee->error_code == BadDrawable) ||\n\t\t(ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable) ||\n\t\t(ee->request_code == X_PolySegment       && ee->error_code == BadDrawable) ||\n\t\t(ee->request_code == X_ConfigureWindow   && ee->error_code == BadMatch   ) ||\n\t\t(ee->request_code == X_GrabButton        && ee->error_code == BadAccess  ) ||\n\t\t(ee->request_code == X_GrabKey           && ee->error_code == BadAccess  ) ||\n\t\t(ee->request_code == X_CopyArea          && ee->error_code == BadDrawable))\n\t\treturn 0;\n\tnote(\"fatal error: request code=%d, error code=%d\\n\",\n\t\tee->request_code, ee->error_code);\n\treturn xerrorxlib(dpy, ee); /* may call exit */\n}", "path": "musca\\musca.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/*\n * Generate a random number n, where 0 <= n < max_num, using\n * /dev/urandom if possible.\n */\n", "func_signal": "int pwgen_random_number(int max_num)", "code": "{\n\tint i, fd = pwgen_get_random_fd();\n\tint lose_counter = 0, nbytes=4;\n\tunsigned int rand;\n\tchar *cp = (char *) &rand;\n\n\tif (fd >= 0) {\n\t\twhile (nbytes > 0) {\n\t\t\ti = read(fd, cp, nbytes);\n\t\t\tif ((i < 0) &&\n\t\t\t    ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\t\tcontinue;\n\t\t\tif (i <= 0) {\n\t\t\t\tif (lose_counter++ == 8)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnbytes -= i;\n\t\t\tcp += i;\n\t\t\tlose_counter = 0;\n\t\t}\n\t}\n\tif (nbytes == 0)\n\t\treturn (rand % max_num);\n\n\t/* OK, we weren't able to use /dev/random, fall back to rand/rand48 */\n\n#ifdef RAND48\n\treturn ((int) ((drand48() * max_num)));\n#else\n\treturn ((int) (random() / ((float) RAND_MAX) * max_num));\n#endif\n}", "path": "pwman\\src\\pwgen.c", "repo_name": "nogweii/src", "stars": 3, "license": "None", "language": "c", "size": 19176}
{"docstring": "/** looks for a CRLF0CRLF sequence in haystack up to limit\n * I'm wasn't too sure about strstr_n above, so I wrote this one instead */\n", "func_signal": "static char * strstr_CRLF0CRLF(char * haystack, size_t limit)", "code": "{\n\tchar *c0 = haystack, *end = haystack + limit - 6;\n\twhile (c0 < end) {\n\t\tif (c0[0] == '\\r' && c0[1] == '\\n' && c0[2] == '0' &&\n\t\t    c0[3] == '\\r' && c0[4] == '\\n') /* && c0[5] == '\\0') */ {\n\t\t\thttp_debug(\"found CRLF0CRLF!!\\n\");\n\t\t\treturn c0;\n\t\t}\n\t\t++c0;\n\t}\n\treturn NULL;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** copy head and body over, handles binary data */\n", "func_signal": "static void headbody_dup(http_request *dest, http_request *src)", "code": "{\n\tif (src->body) {\n\t\tfree_body(dest);\n\t\tdest->body_len = src->body_len;\n\t\tsafe_calloc(dest->body,dest->body_len + 1);\n\t\tmemcpy(dest->body,src->body,dest->body_len);\n\t}\n\tif (src->head) {\n\t\tfree_head(dest);\n\t\tdest->head_len = src->head_len;\n\t\tsafe_calloc(dest->head,HTTP_HEAD_SIZE);\n\t\tmemcpy(dest->head,src->head,dest->head_len);\n\t}\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/**\n\threq_transform\n\tTransforms an http_request based on specified data.  Returns 0 on \n\tsuccess, -1 for partial success or error.  \n\tAll parameters are optional.  If a parameter is NULL, then it remains\n\tunchanged.  \n\tIt's large and ugly.\n*/\n", "func_signal": "int hreq_transform(http_request *req, struct in_addr * host, int * port,\n\tconst char * hostname, const char * url, const char * password, \n\tconst char * username)", "code": "{\n\tchar *tmp;\n\tif(host != NULL)\n\t\treq->addr.sin_addr = *host;\n\tif(port != NULL)\n\t\treq->addr.sin_port = *port;\n\tif(hostname != NULL) {\n\t\ttmp = strdup(hostname);\n\t\tif(tmp == NULL)\n\t\t\treturn -1;\n\t\tsafe_free(req->hostname);\n\t\treq->hostname = tmp;\n\t}\n\tif(url != NULL) {\n\t\ttmp = strdup(url);\n\t\tif(tmp == NULL)\n\t\t\treturn -1;\n\t\tsafe_free(req->url);\n\t\treq->url = tmp;\n\t}\n\tif(password != NULL) {\n\t\ttmp = strdup(password);\n\t\tif(tmp == NULL)\n\t\t\treturn -1;\n\t\tsafe_free(req->password);\n\t\treq->password = tmp;\n\t}\n\tif(username != NULL) {\n\t\ttmp = strdup(username);\n\t\tif(tmp == NULL)\n\t\t\treturn -1;\n\t\tsafe_free(req->username);\n\t\treq->username = tmp;\n\t}\n\n\treturn 0;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** post an HTTP request from a string */\n/** Return value is either the HTTP code, or -1 for error. */\n", "func_signal": "int http_post_str (http_request * req, char *str)", "code": "{\n        int fd, ret;\n\tstruct timeval t0 = current_time();\n\t\n\tfd = http_connect(req);\n\tif(fd == -1)\n\t\treturn -1;\n\n\tif (req->ssl_ctx) {\n\t\tif ((ret = http_ssl_connect(fd,req))!=0)\n\t\t\treturn ret;\n\t}\n\t\n\tsend_http_post_request_str(fd, req, str);\n\treq->connect_tv = time_difference(current_time(),t0);\n\t\n\tret = http_handle_response(fd, req);\n\t\n\tclose(fd);\n\treq->page_tv = time_difference(current_time(),t0);\t\n\treturn ret;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** creates a new HTTP 1.0 request structure */\n", "func_signal": "http_request * new_http_req (\n\t\tstruct in_addr host, const int port, const char * hostname,\n\t\tconst char * url, const int ssl, const char * password, \n\t\tconst char * username)", "code": "{\n\tstruct timeval t0 = { 0, 0 };\n\thttp_request * req = NULL;\n\tsafe_calloc(req,sizeof(http_request));\n        \n\treq->addr.sin_family = AF_INET;\n\treq->addr.sin_addr = host;\n\treq->version = 1;\n\treq->body_len = 0;\n\n\treq->body = NULL;\n\treq->redirects = 0;\n\treq->status = 0;\n\n\treq->redirect_tv = t0;\n\treq->connect_tv = t0;\n\treq->first_byte_tv = t0;\n\treq->page_tv = t0;\n\n\tif (!port)\n\t\treq->addr.sin_port = htons((ssl ? 443 : 80));\n\telse\n\t\treq->addr.sin_port = htons(port);\n\n\tif (username) {\n\t\treq->username = strdup(username);\n\t\tif (password)\n\t\t\treq->password = strdup(password);\n\t}\n\n\treq->ssl_flag = 0;\n\treq->ssl_ctx = NULL;\n\treq->ssl = NULL;\n\tif (ssl) {\n\t\tint ret = http_ssl_init(req);\n\t\tif (ret) {\n\t\t\thttp_req_destroy(req);\n\t\t\treturn NULL;\n\t\t}\n\t}\t\n\tsafe_calloc(req->head, HTTP_HEAD_SIZE);\n\n\treq->url = strdup(url);\n\treq->hostname = strdup(hostname);\n\n\tinit_cookie_list(req->cookies, MAX_COOKIES_PER_REQUEST);\n\t\n\treturn req;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** perform an HTTP GET */\n", "func_signal": "static ssize_t send_http_get_request(unsigned fd, http_request * req)", "code": "{\n\tunsigned char * request = NULL;\n\tssize_t ret;\n\tchar * cookies = cookies_strdup(req->cookies, MAX_COOKIES_PER_REQUEST);\n\tsafe_calloc(request,HTTP_HEAD_SIZE);\n\t\n\t/* generate a simple http 1.0 request */\n\tsnprintf(request,(HTTP_HEAD_SIZE-1), \"GET %s HTTP/1.%d\\r\\n\"\n\t\t\t\"Host: %s\\r\\n\"\n\t\t\t\"User-Agent: %s\\r\\n\"\n\t\t\t\"%s\" /* keep-alive */\n\t\t\t\"Accept-Encoding: gzip,deflate\\r\\n\"\n\t\t\t\"%s\"\t/* Cookies. */\n\t\t\t\"\\r\\n\",\n\t\t\treq->url, req->version, req->hostname,\n\t\t\tread_str_opt(\"user-agent\"),\n\t\t\t(req->version>0 ? \"Connection: keep-alive\\r\\n\" : \"\"),\n\t\t\t(cookies != NULL?  cookies : \"\"));\n\t\n\thttp_debug(\"host: %s header<\\n%s>\\n\",req->hostname,request);\n\tret = write_from_buffer(fd,request, req->ssl);\n\tsafe_free(request);\n\tsafe_free(cookies);\n\treturn ret;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** decide how to read a chunked or close request from the server */\n", "func_signal": "static void http_read_length_unknown(unsigned fd, http_request * req,\n\t\tint keep)", "code": "{\n\tchar * tmp = get_header_dup(\"Transfer-Encoding\",req->head);\n\tif (tmp != NULL) {\n\t\tif (!strncasecmp(\"chunked\",tmp,strlen(\"chunked\")))\n\t\t\thttp_read_chunked_body(fd, req, keep);\n\t} else {\n\t\t/* server closed the connection, so just read whatever's\n\t\t * left */\n\t\ttmp = get_header_dup(\"Connection\",req->head);\n\t\tif ((tmp != NULL) &&\n\t\t\t\t!strncasecmp(\"close\",tmp,\n\t\t\t\tstrlen(\"close\"))) {\n\t\t\tio_debug(\"Got \\\"Connection: close\\\" header\\n\");\n\t\t} else {\n\t\t\tio_debug(\"Didn't get \\\"Connection: close\\\" header\\n\");\n/* \t\t\tio_err(\"[%s]\\n\",req->head); */\n\t\t}\n\t\tbehead_http_req(req,req->head_len);\n\t\treq->body = realloc(req->body,HTTP_BODY_LIMIT + 1);\n\t\tmemset(req->body + req->body_len, 0,\n\t\t\t\tHTTP_BODY_LIMIT - req->body_len + 1);\n\t\thttp_debug(\"\\n\");\n\t\treq->body_len += read_to_buffer(fd,\n\t\t\t\treq->body + req->body_len,\n\t\t\t\tHTTP_BODY_LIMIT - req->body_len,\n\t\t\t\treq->ssl);\n\t}\n\tsafe_free(tmp);\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** this reads chunked encoding, stops if it sees \\r\\n0\\r\\n */\n", "func_signal": "static ssize_t read_to_buffer_0(unsigned fd, unsigned char * buf,\n\t\tunsigned len, SSL * ssl)", "code": "{\n\tssize_t seen = 0, last = 0, s = 0;\n\tsize_t limit = len;\n\thttp_debug(\"len: %u\\n\",len);\n\tif (ssl) BIO_get_fd(ssl->rbio,&fd);\n\twhile (len > 0) {\n\t\tsize_t num = len < HTTP_READ_SIZE ? len : HTTP_READ_SIZE;\n\t\tint ret;\n\t\thttp_debug(\"start select...\");\n\t\tret = r_select(fd, (last == s || s == 0));\n\t\tlast = (s == 0) ? num : s;\n\t\tcommon_read_block();\n\t\tif (NULL!=strstr_CRLF0CRLF(buf,limit))\n\t\t\tbreak;\n\t}\n\treturn seen;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/* just grab the headers off any connection */\n", "func_signal": "static ssize_t read_header(unsigned fd, unsigned char * buf,\n\t\tunsigned len, SSL * ssl)", "code": "{\n\tssize_t seen = 0, last = 0, s = 0;\n\tsize_t limit = len;\n\tif (ssl) BIO_get_fd(ssl->rbio,&fd);\n\twhile (len > 0) {\n\t\tsize_t num = len < HTTP_READ_SIZE ? len : HTTP_READ_SIZE;\n\t\tint ret;\n\t\thttp_debug(\"start select...\");\n\t\tret = r_select(fd, (last == s || s == 0));\n\t\tlast = (s == 0) ? num : s;\n\t\tcommon_read_block();\n\t\tif (NULL!=strstr(buf,\"\\r\\n\\r\\n\"))\n\t\t\tbreak;\n\t\tif (NULL!=strstr(buf,\"\\n\\n\"))\n\t\t\tbreak;\n\t}\n\treturn seen;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** http_connect - initialize a new HTTP connection */\n", "func_signal": "static int http_connect (http_request * req)", "code": "{\n        int fd, ret, optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\tstruct timeval to;\n\tfd_set wfds, efds;\n\n\tif (req->addr.sin_addr.s_addr == INADDR_NONE)\n\t\treturn -1;\n\tif ((fd = socket(req->addr.sin_family, SOCK_STREAM, 0)) < 0) {\n\t\tio_err(\"%s:%d: socket creation failed %s\\n\",\n\t\t\t\t__FILE__,__LINE__,strerror(errno));\n\t\tgoto error;\n\t}\n\n#ifndef BLOCKING_HTTP\n\t{\n\t\tint flags = fcntl(fd, F_GETFL, 0);                                            \n\t\tfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n\t}\n#endif /* BLOCKING_HTTP */\n\t\n\tret = connect(fd,(struct sockaddr *)(&(req->addr)),sizeof(req->addr));\n\tif (ret<0 && errno != EINPROGRESS) {\n\t\tio_err(\"connection to %s failed: %s\\n\",\n\t\t\t\tinet_ntoa(req->addr.sin_addr), strerror(errno));\n\t\tgoto error;\n\t}\n\n\tFD_ZERO(&wfds);\n\tFD_ZERO(&efds);\n\tFD_SET(fd, &wfds);\n\tFD_SET(fd, &efds);\n\tget_timeout(&to, 1);\n\n\t/*\tThis loop is just to make sure that we retry if we get \n\t\tEINPROGRESS, and handle the other conditions predictably.\n\t\tTreating EINPROGRESS as an error was fuckin up our Christmas\n\t\tfor some https sites.  This is kind of sloppy; I'd like to\n\t\tre-structure the function entirely to break it up and make\n\t\tit shorter and cleaner.\n\t*/\n\tdo {\n\t\tret = select(fd + 1, NULL, &wfds, &efds, &to);\n\t\t\n\t\tif (ret < 0 && errno != EINPROGRESS) { //Bad errors\n\t\t\tprint_loc();\n\t\t\tio_debug(\"problem select()-ing: %s\\n\", strerror(errno));\n\t\t\tgoto error;\n\t\t} else if (ret == 0) {\t//Timeout\n\t\t\tprint_loc();\n\t\t\tio_debug(\"Select timeout on %d.\\n\", fd);\n\t\t\tgoto error;\n\t\t} else if (ret > 0) {\t//No errors\n\t\t\tbreak;\n\t\t}\n\t\t//Otherwise, it was EINPROGRESS\n\t\tprint_loc(); io_debug(\"We did, in fact, get an EINPROGRESS.\\n\");\n\t\tusleep(1000);\n\t} while(errno == EINPROGRESS);\n\n\tgetsockopt(fd, SOL_SOCKET, SO_ERROR, &optval, &optlen);\n\tif (optval) {\n\t\tprint_loc();\n\t\tio_err(\"%s:%d: connection closed\\n\",__FILE__,__LINE__);\n\t\tgoto error;\n\t}\n\n\treturn fd;\nerror:\n\tclose(fd);\n\treturn -1;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** construct a application/x-www-form-urlencoded POST request here: */\n", "func_signal": "static void send_http_post_request(unsigned fd, http_request * req,\n\t\tnv_list * nvl)", "code": "{\n\tif (req->head == NULL)\n\t\tsafe_calloc(req->head,HTTP_HEAD_SIZE);\n\n\treq->body = nv_list_to_string(nvl);\n\tif (req->body == NULL) {\n\t\tnv_list_dump(nvl);\n\t\tabort();\n\t}\n\t\n\tsnprintf(req->head,HTTP_HEAD_SIZE-1,\"POST %s HTTP/1.%d\\r\\n\"\n\t\t\t\"Host: %s\\r\\n\"\n\t\t\t\"User-Agent: %s\\r\\n\"\n\t\t\t\"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n\t\t\t\"Content-Length: %lu\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\treq->url,\n\t\t\treq->version,\n\t\t\treq->hostname, read_str_opt(\"user-agent\"),\n\t\t\t(unsigned long)strlen(req->body));\n\n \thttp_debug(\"host: %s header<\\n%s>\\n\",req->hostname,req->head);\n\twrite_from_buffer(fd,req->head,req->ssl);\n\twrite_from_buffer(fd,req->body,req->ssl);\n\tfree_body(req);\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** read a body and discard it as it's being read */\n", "func_signal": "static void http_read_body_discard (unsigned fd, http_request * req)", "code": "{\n\tchar * tmp = NULL;\n\ttmp = get_header_dup(\"Content-Length\",req->head);\n\tif (tmp != NULL) {\n\t\tunsigned len = atoi(tmp);\n\t\tchar * buf = NULL;\n\t\tsafe_calloc(buf,HTTP_READ_SIZE);\n\t\tbehead_http_req(req,len);\n\t\twhile (len > 0) {\n\t\t\tssize_t s;\n\t\t\tunsigned want = len - req->body_len;\n \t\t\thttp_debug(\"\\n\");\n\t\t\ts = read_to_buffer(fd, buf, (want > HTTP_READ_SIZE\n\t\t\t\t\t? HTTP_READ_SIZE - req->body_len\n\t\t\t\t\t: want), req->ssl);\n\t\t\tif (s<=0)\n\t\t\t\tbreak;\n\t\t\tlen -= s;\n\t\t}\n\t\tsafe_free(buf);\n\t} else\n\t\thttp_read_length_unknown(fd, req, 0);\n\tfree_body(req); /* just in case behead gave it anything */\n\tsafe_free(tmp);\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** read a body and keep up to HTTP_BODY_LIMIT */\n", "func_signal": "static void http_read_body_keep (unsigned fd, http_request * req)", "code": "{\n\tchar * tmp = NULL;\n\ttmp = get_header_dup(\"Content-Length\",req->head);\n\n\tif (tmp != NULL) {\n\t\tunsigned len, total;\n\t\tssize_t seen;\n\t\t\n\t\tlen = total = atoi(tmp);\n\t\tsafe_free(tmp);\n\t\tif (len > HTTP_BODY_LIMIT)\n\t\t\tlen = HTTP_BODY_LIMIT;\n\t\tbehead_http_req(req,len);\n\n\t\t/* read the part we want to keep */\n \t\thttp_debug(\"\\n\");\n\t\tseen = read_to_buffer(fd,\n\t\t\t\treq->body + req->body_len,\n\t\t\t\tlen - req->body_len, req->ssl);\n\t\treq->body_len += seen;\n\n\t\t/* deal with the rest of the junk data */\n\t\tif (total > len)\n\t\t\thttp_read_discard(fd, req, total-len);\n\t\t\n\t\ttmp = get_header_dup(\"Content-Encoding\",req->head);\n\t\tif (tmp != NULL) {\n\t\t\tif (is_inflatable(tmp))\n\t\t\t\thttp_inflate(req,tmp);\n\t\t\tsafe_free(tmp);\n\t\t}\n\t} else \n\t\thttp_read_length_unknown(fd, req, 1);\n\tsafe_free(tmp);\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** creates a new HTTP 1.0 request object based on an old one */\n", "func_signal": "http_request * http_req_dup(http_request *req)", "code": "{\n\thttp_request * newreq = NULL;\n\tint tmp;\n\n\tsafe_calloc(newreq,sizeof(http_request));\n       \t \n\tnewreq->addr = req->addr;\n\tnewreq->version = req->version;\n\tnewreq->redirects = req->redirects;\n\tnewreq->status = req->status;\n\t\n\tnewreq->redirect_tv = req->redirect_tv;\n\tnewreq->connect_tv = req->connect_tv;\n\tnewreq->first_byte_tv = req->first_byte_tv;\n\tnewreq->page_tv = req->page_tv;\n\t\n\tnewreq->body = NULL;\n\tnewreq->head = NULL;\n\tnewreq->url = NULL;\n\tnewreq->hostname = NULL;\n\tnewreq->username = NULL;\n\tnewreq->password = NULL;\n\t\n\tif (req->username) {\n\t\tnewreq->username = strdup(req->username);\n\t\tif (req->password)\n\t\t\tnewreq->password = strdup(req->password);\n\t}\n\n\tnewreq->ssl_flag = req->ssl_flag;\n\tnewreq->ssl_ctx = NULL;\n\tnewreq->ssl = NULL;\n\tif (req->ssl_ctx) {\n\t\ttmp = http_ssl_init(newreq);\n\t\tif (tmp) {\n\t\t\tprint_loc(); io_err(\"Couldn't initialize SSL!\\n\");\n\t\t\thttp_req_destroy(newreq);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\theadbody_dup(newreq,req);\n\n\tif (req->url)\n\t\tnewreq->url = strdup(req->url);\n\tif (req->hostname)\n\t\tnewreq->hostname = strdup(req->hostname);\n\t\n\treturn newreq;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** inflates an http req->body into its uncompressed form */\n", "func_signal": "static void http_inflate(http_request *req, const char * tmp)", "code": "{\n\tz_stream z;\n\tBytef buf[_ZBUF];\n\tchar *dest = NULL;\n\tsize_t dlen = 0;\n\tint err;\n\tint window_bits;\n\t\n\tz.zalloc = (alloc_func)Z_NULL;\n\tz.zfree = (free_func)Z_NULL;\n\tz.opaque = 0;\n\tz.next_in = req->body;\n\tz.avail_in = req->body_len;\n\n\twindow_bits = (!strcasecmp(tmp,\"deflate\")) ? -MAX_WBITS : MAX_WBITS+32;\n\n\tif ((err = inflateInit2(&z,window_bits)) != Z_OK) {\n\t\tio_err(\"zlib error (%d) on %s%s\\n\",\n\t\t\t\terr,req->hostname,req->url);\n\t\tfree_body(req);\n\t\treturn;\n\t}\n\t\n\twhile (1) {\n\t\tint ret;\n\t\tz.next_out = &buf[0];\n\t\tz.avail_out = _ZBUF;\n\t\tret = inflate(&z, Z_SYNC_FLUSH);\n\t\tif (ret == Z_OK || ret == Z_STREAM_END) {\n\t\t\tunsigned seen = _ZBUF - z.avail_out;\n\t\t\tif (((seen+dlen) == 0)\n\t\t\t\t\t|| ((seen+dlen) >= HTTP_BODY_LIMIT)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdest = realloc(dest, dlen + seen + 1);\n\t\t\tmemset(dest + dlen, 0, seen + 1);\n\t\t\tmemcpy(dest + dlen, &buf[0], seen);\n\t\t\tdlen += seen;\n\t\t\tif (ret == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* -5 == Z_BUF_ERROR  -- don't wait around to handle\n\t\t\t * this, just error out */\n\t\t\tif (!dest) {\n\t\t\t\tdlen = 1;\n\t\t\t\tsafe_calloc(dest,dlen);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tinflateEnd(&z);\n\tfree_body(req);\n\treq->body_len = dlen;\n\treq->body = dest;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** reads a chunked http response and automatically inflates it if needed */\n", "func_signal": "static void http_read_chunked_body(unsigned fd,\thttp_request *req, int keep)", "code": "{\n\tchar *tmp = get_header_dup(\"Content-Encoding\",req->head);\n\tread_chunked_body_bin(fd,req,keep);\n\tif (keep) {\n\t\tunchunk_chunked_body(req);\n\t\tif (tmp != NULL) {\n\t\t\tif (is_inflatable(tmp))\n\t\t\t\thttp_inflate(req,tmp);\n\t\t\tsafe_free(tmp);\n\t\t}\n\t}\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** turn a chunked HTTP body into a regular one */\n/* status: working without any known bugs */\n/* read the respective RFCs on chunked HTTP transfers to understand this */\n", "func_signal": "static void unchunk_chunked_body(http_request *req)", "code": "{\n\tchar *dest = NULL;\n\tsize_t dlen = 0, len;\n\tchar *c0, *c1, *start;\n\n\tc0 = start = req->body;\n\twhile (1) {\n\t\twhile(((c0-start) < (req->body_len-1)) && !isxdigit(*c0))\n\t\t\t++c0;\n\t\tc1 = c0;\n\t\twhile(((c1-start) < (req->body_len-1)) && isxdigit(*c1))\n\t\t\t++c1;\n\t\tif (((c1+1)<(req->body+req->body_len)) &&\n\t\t\t\t\t(c1[0]=='\\r' && c1[1]=='\\n')) {\n\t\t\tlen = strtoul(c0,NULL,16);\n\t\t\tif (len == 0) {\n\t\t\t\tfree_body(req);\n\t\t\t\treq->body_len = dlen;\n\t\t\t\treq->body = realloc(dest,req->body_len + 1);\n\t\t\t\t*(req->body+req->body_len) = '\\0';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tc0 = c1+2;\n\t\t\tif ((dlen+len) > req->body_len)\n\t\t\t\tlen = req->body_len - (c0 - start);\n\t\t\tdest = realloc(dest,dlen+len+1); \n\t\t\tmemset(dest+dlen,0,len+1);\n\t\t\tmemcpy(dest+dlen,c0,len);\n\t\t\tc0 += len;\n\t\t\tdlen += len;\n\t\t} else {\n\t\t\t/* c0 = c1; */ /* I don't think we need this */\n\t\t\tfree_body(req);\n\t\t\treq->body_len = c0 - start;\n\t\t\treq->body = realloc(dest,req->body_len + 1);\n\t\t\t*(req->body+req->body_len) = '\\0';\n/* \t\t\tio_err(\"premature end of chunk: %d\\n\",req->body_len); */\n\t\t\treturn;\n\t\t}\n\t}\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** write everything in a buffer to a file descriptor */\n", "func_signal": "static ssize_t write_from_buffer(unsigned fd, const char * buf, SSL * ssl)", "code": "{\n\tssize_t seen = 0, w;\n\tsize_t len;\n\n\tassert(buf != NULL);\n\tlen = strlen(buf);\n\n\tif (ssl) {\n\t\tint bfd;\n\t\tBIO_get_fd(ssl->rbio,&bfd);\n\t}\n\twhile (len > 0) {\n\t\tsize_t num = len < HTTP_READ_SIZE ? len : HTTP_READ_SIZE;\n\t\tif (ssl)\n\t\t\tw = SSL_write(ssl, buf + seen, (int)num);\n\t\telse\n\t\t\tw = write(fd,buf + seen, num);\n\t\tif (w <= 0)\n\t\t\tbreak;\n\t\tlen -= w;\n\t\tseen += w;\n\t}\n\treturn seen;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** this splits and chomps off the part of the header that may have been \n * intended for the body\n * returns 1 if CRLFCRLF was used to break, 0 if LFLF only */\n", "func_signal": "static void behead_http_req (http_request *req, unsigned len)", "code": "{\n\tchar *split, c;\n\tsize_t offset = 4;\n\tsplit = strstr(req->head,\"\\r\\n\\r\\n\");\n\tif (split == NULL) {\n\t\tif ((split = strstr(req->head,\"\\n\\n\")) == NULL) {\n\t\t\tprint_loc();\n\t\t\tio_warning(\"Unable to split HEAD from BODY!  \"\n\t\t\t\t   \"(Really hard neck?)\\n\");\n\t\t\tsafe_calloc(req->body,req->head_len + 1);\n\t\t\tmemcpy(req->body,req->head,req->head_len);\n\t\t\treq->body_len = req->head_len;\n\t\t\treturn;\n\t\t}\n\t\toffset = 2;\n\t}\n\tsplit += offset;\n\tsafe_calloc(req->body,len+1);\n\t\n\tc = *split;\n\t*split = '\\0';\n\n\treq->body_len = req->head_len - strlen(req->head);\n\treq->head_len = strlen(req->head);\n\t*split = c;\n\tmemcpy(req->body, split, req->body_len);\n\t*split = '\\0'; /* truncate the header to where it should be */\n\treq->head = realloc(req->head,strlen(req->head) + 1);\n \thttp_debug(\"header: <%s>\\n\",req->head);\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "/** read the return message from the server and do something with it \n *  Return value is -1 or the HTTP code.\n*/\n", "func_signal": "static int http_handle_response (unsigned fd, http_request * req)", "code": "{\n\tint ret = 0;\n\tstruct timeval t0 = current_time();\n\tif (req->head == NULL)\n\t\tsafe_calloc(req->head,HTTP_HEAD_SIZE);\n\telse\n\t\tmemset(req->head,0,HTTP_HEAD_SIZE);\n\t/* read the first byte and time it: */\n \thttp_debug(\"\\n\");\n\treq->head_len = read_to_buffer(fd, req->head, 1, req->ssl);\n\treq->first_byte_tv = time_difference(current_time(),t0);\n\t\n\treq->head_len += read_header(fd,req->head+req->head_len,\n\t\t\tHTTP_HEAD_SIZE - req->head_len,\n\t\t\treq->ssl);\n\n\tif (req->head_len < 16)\n\t\treturn invalid_header(req);\n\t\n\tif(!strncmp(req->head,\"HTTP/1.1 \", 9)) {\n\t\tret = atoi(req->head + 9);\n\t} else if (!strncmp(req->head,\"HTTP/1.0 \", 9)) {\n\t\tret = atoi(req->head + 9);\n\t\tif (req->version == 1)\n\t\t\treq->version = 0;\n\t} else if (!strncmp(req->head,\"HTTP \", 5))\n\t\t/* a broken server just returned \"HTTP \" */\n\t\tret = atoi(req->head + 5);\n\telse\n\t\treturn invalid_header(req);\n\n\tparse_cstring(req->cookies, MAX_COOKIES_PER_REQUEST, req->head);\n\t\n\treq->status = ret;\n\t\t\n\tprint_loc(); io_debug(\"HTTP code: %d\\n\",ret);\n\tswitch (ret) {\n\t\tcase 200:\n\t\t\thttp_read_body(fd, req);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase 301:\n\t\tcase 302:\n\t\t\tret = http_handle_redirect(fd, req);\n\t\t\tbreak;\n\t\tcase 300:\n\t\tcase 404:\n\t\tdefault:\n\t\t\tio_debug(\"\\nUnsupported HTTP code: %d [%s]\\n\",\n\t\t\t\t\tret,req->head);\n\t\t\tbreak;\n\t}\n\treturn ret;\n}", "path": "src\\net-modules\\http.c", "repo_name": "pete/freenote-probe", "stars": 2, "license": "other", "language": "c", "size": 392}
{"docstring": "// called by device interrupt routines to feed input characters\n// into the circular console input buffer.\n", "func_signal": "void\ncons_intr(int (*proc)(void))", "code": "{\n\tint c;\n\n\twhile ((c = (*proc)()) != -1) {\n\t\tif (c == 0)\n\t\t\tcontinue;\n\t\tcons.buf[cons.wpos++] = c;\n\t\tif (cons.wpos == CONSBUFSIZE)\n\t\t\tcons.wpos = 0;\n\t}\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Decodes integer into s32_t.\n *\n * @param p points to a pbuf holding an ASN1 coded integer\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded integer\n * @param len length of the coded integer field\n * @param value return host order integer\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n *\n * @note ASN coded integers are _always_ signed!\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_s32t(struct pbuf *p, u16_t ofs, u16_t len, s32_t *value)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  u8_t *lsb_ptr = (u8_t*)value;\n#endif\n#if BYTE_ORDER == BIG_ENDIAN\n  u8_t *lsb_ptr = (u8_t*)value + sizeof(s32_t) - 1;\n#endif\n  u8_t sign;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n      if ((len > 0) && (len < 5))\n      {\n        if (*msg_ptr & 0x80)\n        {\n          /* negative, start from -1 */\n          *value = -1;\n          sign = 1;\n        }\n        else\n        {\n          /* positive, start from 0 */\n          *value = 0;\n          sign = 0;\n        }\n        /* OR/AND octets with value */\n        while (len > 1)\n        {\n          len--;\n          if (sign)\n          {\n            *lsb_ptr &= *msg_ptr;\n            *value <<= 8;\n            *lsb_ptr |= 255;\n          }\n          else\n          {\n            *lsb_ptr |= *msg_ptr;\n            *value <<= 8;\n          }\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n        }\n        if (sign)\n        {\n          *lsb_ptr &= *msg_ptr;\n        }\n        else\n        {\n          *lsb_ptr |= *msg_ptr;\n        }\n        return ERR_OK;\n      }\n      else\n      {\n        return ERR_ARG;\n      }\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// output a character to the console\n", "func_signal": "void\ncons_putc(int c)", "code": "{\n\tlpt_putc(c);\n\tcga_putc(c);\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/* USE_CRYPT */\n", "func_signal": "static u_char\nGet7Bits( u_char *input, int startBit)", "code": "{\n  register unsigned int  word;\n\n  word  = (unsigned)input[startBit / 8] << 8;\n  word |= (unsigned)input[startBit / 8 + 1];\n\n  word >>= 15 - (startBit % 8 + 7);\n\n  return word & 0xFE;\n}", "path": "net\\lwip\\netif\\ppp\\chpms.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// return the next input character from the console, or 0 if none waiting\n", "func_signal": "int\ncons_getc(void)", "code": "{\n\tint c;\n\n\t// poll for any pending input characters,\n\t// so that this function works even when interrupts are disabled\n\t// (e.g., when called from the kernel monitor).\n\tserial_intr();\n\tkbd_intr();\n\n\t// grab the next character from the input buffer.\n\tif (cons.rpos != cons.wpos) {\n\t\tc = cons.buf[cons.rpos++];\n\t\tif (cons.rpos == CONSBUFSIZE)\n\t\t\tcons.rpos = 0;\n\t\treturn c;\n\t}\n\treturn 0;\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// initialize the console devices\n", "func_signal": "void\ncons_init(void)", "code": "{\n\tcga_init();\n\tkbd_init();\n\tserial_init();\n\n\tif (!serial_exists)\n\t\tcprintf(\"Serial port does not exist!\\n\");\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/*\n * Get data from the keyboard.  If we finish a character, return it.  Else 0.\n * Return -1 if no data.\n */\n", "func_signal": "static int\nkbd_proc_data(void)", "code": "{\n\tint c;\n\tuint8_t data;\n\tstatic uint32_t shift;\n\n\tif ((inb(KBSTATP) & KBS_DIB) == 0)\n\t\treturn -1;\n\n\tdata = inb(KBDATAP);\n\n\tif (data == 0xE0) {\n\t\t// E0 escape character\n\t\tshift |= E0ESC;\n\t\treturn 0;\n\t} else if (data & 0x80) {\n\t\t// Key released\n\t\tdata = (shift & E0ESC ? data : data & 0x7F);\n\t\tshift &= ~(shiftcode[data] | E0ESC);\n\t\treturn 0;\n\t} else if (shift & E0ESC) {\n\t\t// Last character was an E0 escape; or with 0x80\n\t\tdata |= 0x80;\n\t\tshift &= ~E0ESC;\n\t}\n\n\tshift |= shiftcode[data];\n\tshift ^= togglecode[data];\n\n\tc = charcode[shift & (CTL | SHIFT)][data];\n\tif (shift & CAPSLOCK) {\n\t\tif ('a' <= c && c <= 'z')\n\t\t\tc += 'A' - 'a';\n\t\telse if ('A' <= c && c <= 'Z')\n\t\t\tc += 'a' - 'A';\n\t}\n\n\t// Process special keys\n\t// Ctrl-Alt-Del: reboot\n\tif (!(~shift & (CTL | ALT)) && c == KEY_DEL) {\n\t\tcprintf(\"Rebooting!\\n\");\n\t\toutb(0x92, 0x3); // courtesy of Chris Frost\n\t}\n\n\treturn c;\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Decodes positive integer (counter, gauge, timeticks) into u32_t.\n *\n * @param p points to a pbuf holding an ASN1 coded integer\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded integer\n * @param len length of the coded integer field\n * @param value return host order integer\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n *\n * @note ASN coded integers are _always_ signed. E.g. +0xFFFF is coded\n * as 0x00,0xFF,0xFF. Note the leading sign octet. A positive value\n * of 0xFFFFFFFF is preceded with 0x00 and the length is 5 octets!!\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_u32t(struct pbuf *p, u16_t ofs, u16_t len, u32_t *value)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n      if ((len > 0) && (len < 6))\n      {\n        /* start from zero */\n        *value = 0;\n        if (*msg_ptr & 0x80)\n        {\n          /* negative, expecting zero sign bit! */\n          return ERR_ARG;\n        }\n        else\n        {\n          /* positive */\n          if ((len > 1) && (*msg_ptr == 0))\n          {\n            /* skip leading \"sign byte\" octet 0x00 */\n            len--;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n        }\n        /* OR octets with value */\n        while (len > 1)\n        {\n          len--;\n          *value |= *msg_ptr;\n          *value <<= 8;\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n        }\n        *value |= *msg_ptr;\n        return ERR_OK;\n      }\n      else\n      {\n        return ERR_ARG;\n      }\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/* in == 8-byte string (expanded version of the 56-bit key)\n * out == 64-byte string where each byte is either 1 or 0\n * Note that the low-order \"bit\" is always ignored by by setkey()\n */\n", "func_signal": "static void\nExpand(u_char *in, u_char *out)", "code": "{\n  int j, c;\n  int i;\n\n  for(i = 0; i < 64; in++){\n    c = *in;\n    for(j = 7; j >= 0; j--) {\n      *out++ = (c >> j) & 01;\n    }\n    i += 8;\n  }\n}", "path": "net\\lwip\\netif\\ppp\\chpms.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/*\n * Print a number (base <= 16) in reverse order,\n * using specified putch function and associated pointer putdat.\n */\n", "func_signal": "static void\nprintnum(void (*putch)(int, void*), void *putdat,\n\t unsigned long long num, unsigned base, int width, int padc)", "code": "{\n\t// first recursively print all preceding (more significant) digits\n\tif (num >= base) {\n\t\tprintnum(putch, putdat, num / base, base, width - 1, padc);\n\t} else {\n\t\t// print any needed pad characters before first digit\n\t\twhile (--width > 0)\n\t\t\tputch(padc, putdat);\n\t}\n\n\t// then print this (the least significant) digit\n\tputch(\"0123456789abcdef\"[num % base], putdat);\n}", "path": "lib\\printfmt.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Decodes length field from incoming pbuf chain into host length.\n *\n * @param p points to a pbuf holding an ASN1 coded length\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded length\n * @param octets_used returns number of octets used by the length code\n * @param length return host order length, upto 64k\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_length(struct pbuf *p, u16_t ofs, u8_t *octets_used, u16_t *length)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n\n      if (*msg_ptr < 0x80)\n      {\n        /* primitive definite length format */\n        *octets_used = 1;\n        *length = *msg_ptr;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x80)\n      {\n        /* constructed indefinite length format, termination with two zero octets */\n        u8_t zeros;\n        u8_t i;\n\n        *length = 0;\n        zeros = 0;\n        while (zeros != 2)\n        {\n          i = 2;\n          while (i > 0)\n          {\n            i--;\n            (*length) += 1;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n            if (*msg_ptr == 0)\n            {\n              zeros++;\n              if (zeros == 2)\n              {\n                /* stop while (i > 0) */\n                i = 0;\n              }\n            }\n            else\n            {\n              zeros = 0;\n            }\n          }\n        }\n        *octets_used = 1;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x81)\n      {\n        /* constructed definite length format, one octet */\n        ofs += 1;\n        if (ofs >= plen)\n        {\n          /* next octet in next pbuf */\n          p = p->next;\n          if (p == NULL) { return ERR_ARG; }\n          msg_ptr = p->payload;\n        }\n        else\n        {\n          /* next octet in same pbuf */\n          msg_ptr++;\n        }\n        *length = *msg_ptr;\n        *octets_used = 2;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x82)\n      {\n        u8_t i;\n\n        /* constructed definite length format, two octets */\n        i = 2;\n        while (i > 0)\n        {\n          i--;\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n          if (i == 0)\n          {\n            /* least significant length octet */\n            *length |= *msg_ptr;\n          }\n          else\n          {\n            /* most significant length octet */\n            *length = (*msg_ptr) << 8;\n          }\n        }\n        *octets_used = 3;\n        return ERR_OK;\n      }\n      else\n      {\n        /* constructed definite length format 3..127 octets, this is too big (>64k) */\n        /**  @todo: do we need to accept inefficient codings with many leading zero's? */\n        *octets_used = 1 + ((*msg_ptr) & 0x7f);\n        return ERR_ARG;\n      }\n    }\n    p = p->next;\n  }\n\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// Same as getuint but signed - can't use getuint\n// because of sign extension\n", "func_signal": "static long long\ngetint(va_list *ap, int lflag)", "code": "{\n\tif (lflag >= 2)\n\t\treturn va_arg(*ap, long long);\n\telse if (lflag)\n\t\treturn va_arg(*ap, long);\n\telse\n\t\treturn va_arg(*ap, int);\n}", "path": "lib\\printfmt.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/* key from rasapi32.dll */\n", "func_signal": "static void\nChapMS_LANMan( char *rchallenge,\n               int rchallenge_len,\n               char *secret,\n               int secret_len,\n               MS_ChapResponse  *response)", "code": "{\n  int      i;\n  u_char    UcasePassword[MAX_NT_PASSWORD]; /* max is actually 14 */\n  u_char    PasswordHash[16];\n  \n  /* LANMan password is case insensitive */\n  BZERO(UcasePassword, sizeof(UcasePassword));\n  for (i = 0; i < secret_len; i++) {\n    UcasePassword[i] = (u_char)toupper(secret[i]);\n  }\n  DesEncrypt( StdText, UcasePassword + 0, PasswordHash + 0 );\n  DesEncrypt( StdText, UcasePassword + 7, PasswordHash + 8 );\n  ChallengeResponse(rchallenge, PasswordHash, response->LANManResp);\n}", "path": "net\\lwip\\netif\\ppp\\chpms.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// Get an unsigned int of various possible sizes from a varargs list,\n// depending on the lflag parameter.\n", "func_signal": "static unsigned long long\ngetuint(va_list *ap, int lflag)", "code": "{\n\tif (lflag >= 2)\n\t\treturn va_arg(*ap, unsigned long long);\n\telse if (lflag)\n\t\treturn va_arg(*ap, unsigned long);\n\telse\n\t\treturn va_arg(*ap, unsigned int);\n}", "path": "lib\\printfmt.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Retrieves type field from incoming pbuf chain.\n *\n * @param p points to a pbuf holding an ASN1 coded type field\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded type field\n * @param type return ASN1 type\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_type(struct pbuf *p, u16_t ofs, u8_t *type)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n      *type = *msg_ptr;\n      return ERR_OK;\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Decodes object identifier from incoming message into array of s32_t.\n *\n * @param p points to a pbuf holding an ASN1 coded object identifier\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded object identifier\n * @param len length of the coded object identifier\n * @param oid return object identifier struct\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_oid(struct pbuf *p, u16_t ofs, u16_t len, struct snmp_obj_id *oid)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n  s32_t *oid_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n\n      oid->len = 0;\n      oid_ptr = &oid->id[0];\n      if (len > 0)\n      {\n        /* first compressed octet */\n        if (*msg_ptr == 0x2B)\n        {\n          /* (most) common case 1.3 (iso.org) */\n          *oid_ptr = 1;\n          oid_ptr++;\n          *oid_ptr = 3;\n          oid_ptr++;\n        }\n        else if (*msg_ptr < 40)\n        {\n          *oid_ptr = 0;\n          oid_ptr++;\n          *oid_ptr = *msg_ptr;\n          oid_ptr++;\n        }\n        else if (*msg_ptr < 80)\n        {\n          *oid_ptr = 1;\n          oid_ptr++;\n          *oid_ptr = (*msg_ptr) - 40;\n          oid_ptr++;\n        }\n        else\n        {\n          *oid_ptr = 2;\n          oid_ptr++;\n          *oid_ptr = (*msg_ptr) - 80;\n          oid_ptr++;\n        }\n        oid->len = 2;\n      }\n      else\n      {\n        /* accepting zero length identifiers e.g. for\n           getnext operation. uncommon but valid */\n        return ERR_OK;\n      }\n      len--;\n      if (len > 0)\n      {\n        ofs += 1;\n        if (ofs >= plen)\n        {\n          /* next octet in next pbuf */\n          p = p->next;\n          if (p == NULL) { return ERR_ARG; }\n          msg_ptr = p->payload;\n          plen += p->len;\n        }\n        else\n        {\n          /* next octet in same pbuf */\n          msg_ptr++;\n        }\n      }\n      while ((len > 0) && (oid->len < LWIP_SNMP_OBJ_ID_LEN))\n      {\n        /* sub-identifier uses multiple octets */\n        if (*msg_ptr & 0x80)\n        {\n          s32_t sub_id = 0;\n\n          while ((*msg_ptr & 0x80) && (len > 1))\n          {\n            len--;\n            sub_id = (sub_id << 7) + (*msg_ptr & ~0x80);\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n          if (!(*msg_ptr & 0x80) && (len > 0))\n          {\n            /* last octet sub-identifier */\n            len--;\n            sub_id = (sub_id << 7) + *msg_ptr;\n            *oid_ptr = sub_id;\n          }\n        }\n        else\n        {\n          /* !(*msg_ptr & 0x80) sub-identifier uses single octet */\n          len--;\n          *oid_ptr = *msg_ptr;\n        }\n        if (len > 0)\n        {\n          /* remaining oid bytes available ... */\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n        }\n        oid_ptr++;\n        oid->len++;\n      }\n      if (len == 0)\n      {\n        /* len == 0, end of oid */\n        return ERR_OK;\n      }\n      else\n      {\n        /* len > 0, oid->len == LWIP_SNMP_OBJ_ID_LEN or malformed encoding */\n        return ERR_ARG;\n      }\n\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/* The inverse of Expand\n */\n", "func_signal": "static void\nCollapse(u_char *in, u_char *out)", "code": "{\n  int j;\n  int i;\n  unsigned int c;\n\n  for (i = 0; i < 64; i += 8, out++) {\n    c = 0;\n    for (j = 7; j >= 0; j--, in++) {\n      c |= *in << j;\n    }\n    *out = c & 0xff;\n  }\n}", "path": "net\\lwip\\netif\\ppp\\chpms.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/***********************************/\n/*** PUBLIC FUNCTION DEFINITIONS ***/\n/***********************************/\n", "func_signal": "void\nChapMS( chap_state *cstate, char *rchallenge, int rchallenge_len, char *secret, int secret_len)", "code": "{\n  MS_ChapResponse response;\n#ifdef MSLANMAN\n  extern int ms_lanman;\n#endif\n\n#if 0\n  CHAPDEBUG((LOG_INFO, \"ChapMS: secret is '%.*s'\\n\", secret_len, secret));\n#endif\n  BZERO(&response, sizeof(response));\n\n  /* Calculate both always */\n  ChapMS_NT(rchallenge, rchallenge_len, secret, secret_len, &response);\n\n#ifdef MSLANMAN\n  ChapMS_LANMan(rchallenge, rchallenge_len, secret, secret_len, &response);\n\n  /* prefered method is set by option  */\n  response.UseNT = !ms_lanman;\n#else\n  response.UseNT = 1;\n#endif\n\n  BCOPY(&response, cstate->response, MS_CHAP_RESPONSE_LEN);\n  cstate->resp_length = MS_CHAP_RESPONSE_LEN;\n}", "path": "net\\lwip\\netif\\ppp\\chpms.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n * Decodes (copies) raw data (ip-addresses, octet strings, opaque encoding)\n * from incoming message into array.\n *\n * @param p points to a pbuf holding an ASN1 coded raw data\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded raw data\n * @param len length of the coded raw data (zero is valid, e.g. empty string!)\n * @param raw_len length of the raw return value\n * @param raw return raw bytes\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_raw(struct pbuf *p, u16_t ofs, u16_t len, u16_t raw_len, u8_t *raw)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  if (len > 0)\n  {\n    plen = 0;\n    while (p != NULL)\n    {\n      base = plen;\n      plen += p->len;\n      if (ofs < plen)\n      {\n        msg_ptr = p->payload;\n        msg_ptr += ofs - base;\n        if (raw_len >= len)\n        {\n          while (len > 1)\n          {\n            /* copy len - 1 octets */\n            len--;\n            *raw = *msg_ptr;\n            raw++;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n          /* copy last octet */\n          *raw = *msg_ptr;\n          return ERR_OK;\n        }\n        else\n        {\n          /* raw_len < len, not enough dst space */\n          return ERR_ARG;\n        }\n      }\n      p = p->next;\n    }\n    /* p == NULL, ofs >= plen */\n    return ERR_ARG;\n  }\n  else\n  {\n    /* len == 0, empty string */\n    return ERR_OK;\n  }\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "// Stupid I/O delay routine necessitated by historical PC design flaws\n", "func_signal": "static void\ndelay(void)", "code": "{\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n}", "path": "kern\\console.c", "repo_name": "qun/jos", "stars": 2, "license": "None", "language": "c", "size": 733}
{"docstring": "/* \n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = ((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = ((d - ('a'-10)) << 4);\n    else \n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (d - ('a'-10));\n    else \n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* \n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n  \n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }    \n    cast = cast->next;\n  }\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* \n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (int)((l1 - f1) - (l2 - f2));\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Define Ruby class for C type */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_define_class(swig_type_info *type)", "code": "{\n  VALUE klass;\n  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n  sprintf(klass_name, \"TYPE%s\", type->name);\n  if (NIL_P(_cSWIG_Pointer)) {\n    _cSWIG_Pointer = rb_define_class_under(_mSWIG, \"Pointer\", rb_cObject);\n    rb_undef_method(CLASS_OF(_cSWIG_Pointer), \"new\");\n  }\n  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);\n  free((void *) klass_name);\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n\n  if (init_run) return;\n  init_run = 1;\n\n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* This function is called when a user inputs a wrong argument to\n   a method.\n */\n", "func_signal": "SWIGINTERN \nconst char* Ruby_Format_TypeError( const char* msg,\n\t\t\t\t   const char* type, \n\t\t\t\t   const char* name, \n\t\t\t\t   const int argn,\n\t\t\t\t   VALUE input )", "code": "{\n  char buf[128];\n  VALUE str;\n  VALUE asStr;\n  if ( msg && *msg )\n    {\n      str = rb_str_new2(msg);\n    }\n  else\n    {\n      str = rb_str_new(NULL, 0);\n    }\n\n  str = rb_str_cat2( str, \"Expected argument \" );\n  sprintf( buf, \"%d of type \", argn-1 );\n  str = rb_str_cat2( str, buf );\n  str = rb_str_cat2( str, type );\n  str = rb_str_cat2( str, \", but got \" );\n  str = rb_str_cat2( str, rb_obj_classname(input) );\n  str = rb_str_cat2( str, \" \" );\n  asStr = rb_inspect(input);\n  if ( RSTRING_LEN(asStr) > 30 )\n    {\n      str = rb_str_cat( str, StringValuePtr(asStr), 30 );\n      str = rb_str_cat2( str, \"...\" );\n    }\n  else\n    {\n      str = rb_str_append( str, asStr );\n    }\n\n  if ( name )\n    {\n      str = rb_str_cat2( str, \"\\n\\tin SWIG method '\" );\n      str = rb_str_cat2( str, name );\n      str = rb_str_cat2( str, \"'\" );\n    }\n\n  return StringValuePtr( str );\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* \n   Pack binary data into a string\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz)", "code": "{\n  static const char hex[17] = \"0123456789abcdef\";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Initialize Ruby runtime support */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_InitRuntime(void)", "code": "{\n  if (_mSWIG == Qnil) {\n    _mSWIG = rb_define_module(\"SWIG\");\n    swig_call_id  = rb_intern(\"call\");\n    swig_arity_id = rb_intern(\"arity\");\n  }\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Add a Tracking from a C/C++ struct to a Ruby object */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object)", "code": "{\n  /* In a Ruby hash table we store the pointer and\n     the associated Ruby object.  The trick here is\n     that we cannot store the Ruby object directly - if\n     we do then it cannot be garbage collected.  So\n     instead we typecast it as a unsigned long and\n     convert it to a Ruby number object.*/\n\n  /* Get a reference to the pointer as a Ruby number */\n  VALUE key = SWIG_RubyPtrToReference(ptr);\n\n  /* Get a reference to the Ruby object as a Ruby number */\n  VALUE value = SWIG_RubyObjectToReference(object);\n\n  /* Store the mapping to the global hash table. */\n  rb_hash_aset(swig_ruby_trackings, key, value);\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Get type mangle from class name */\n", "func_signal": "SWIGRUNTIMEINLINE char *\nSWIG_Ruby_MangleStr(VALUE obj)", "code": "{\n  VALUE stype = rb_iv_get(obj, \"@__swigtype__\");\n  return StringValuePtr(stype);\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if not equal, 1 if equal\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeEquiv(const char *nb, const char *tb)", "code": "{\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* \n   Pack 'void *' into a string buffer.\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz)", "code": "{\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = '_';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Create a new class instance (always owned) */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)", "code": "{\n  VALUE obj;\n  swig_class *sklass = (swig_class *) type->clientdata;\n  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);\n  rb_iv_set(obj, \"@__swigtype__\", rb_str_new2(type->name));\n  return obj;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)", "code": "{\n  char *c;\n  swig_cast_info *tc;\n  void *vptr = 0;\n\n  /* Grab the pointer */\n  if (NIL_P(obj)) {\n    *ptr = 0;\n    return SWIG_OK;\n  } else {\n    if (TYPE(obj) != T_DATA) {\n      return SWIG_ERROR;\n    }\n    Data_Get_Struct(obj, void, vptr);\n  }\n  \n  if (own) *own = RDATA(obj)->dfree;\n    \n  /* Check to see if the input object is giving up ownership\n     of the underlying C struct or C++ object.  If so then we\n     need to reset the destructor since the Ruby object no \n     longer owns the underlying C++ object.*/ \n  if (flags & SWIG_POINTER_DISOWN) {\n    /* Is tracking on for this class? */\n    int track = 0;\n    if (ty && ty->clientdata) {\n      swig_class *sklass = (swig_class *) ty->clientdata;\n      track = sklass->trackObjects;\n    }\n\t\t\n    if (track) {\n      /* We are tracking objects for this class.  Thus we change the destructor\n       * to SWIG_RubyRemoveTracking.  This allows us to\n       * remove the mapping from the C++ to Ruby object\n       * when the Ruby object is garbage collected.  If we don't\n       * do this, then it is possible we will return a reference \n       * to a Ruby object that no longer exists thereby crashing Ruby. */\n      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;\n    } else {    \n      RDATA(obj)->dfree = 0;\n    }\n  }\n\n  /* Do type-checking if type info was provided */\n  if (ty) {\n    if (ty->clientdata) {\n      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {\n        if (vptr == 0) {\n          /* The object has already been deleted */\n          return SWIG_ObjectPreviouslyDeletedError;\n        }\n        *ptr = vptr;\n        return SWIG_OK;\n      }\n    }\n    if ((c = SWIG_MangleStr(obj)) == NULL) {\n      return SWIG_ERROR;\n    }\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) {\n      return SWIG_ERROR;\n    } else {\n      int newmemory = 0;\n      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);\n      assert(!newmemory); /* newmemory handling not yet implemented */\n    }\n  } else {\n    *ptr = vptr;\n  }\n  \n  return SWIG_OK;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* \n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr)", "code": "{\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Check convert */\n", "func_signal": "SWIGRUNTIMEINLINE int\nSWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)", "code": "{\n  char *c = SWIG_MangleStr(obj);\n  if (!c) return 0;\n  return SWIG_TypeCheck(c,ty) != 0;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* This code checks to see if the Ruby object being raised as part\n   of an exception inherits from the Ruby class Exception.  If so,\n   the object is simply returned.  If not, then a new Ruby exception\n   object is created and that will be returned to Ruby.*/\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj)", "code": "{\n  VALUE exceptionClass = getExceptionClass();\n  if (rb_obj_is_kind_of(obj, exceptionClass)) {\n    return obj;\n  }  else {\n    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));\n  }\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)", "code": "{\n  int own =  flags & SWIG_POINTER_OWN; \n  int track;\n  char *klass_name;\n  swig_class *sklass;\n  VALUE klass;\n  VALUE obj;\n  \n  if (!ptr)\n    return Qnil;\n  \n  if (type->clientdata) {\n    sklass = (swig_class *) type->clientdata;\n\t\t\n    /* Are we tracking this class and have we already returned this Ruby object? */\n    track = sklass->trackObjects;\n    if (track) {\n      obj = SWIG_RubyInstanceFor(ptr);\n      \n      /* Check the object's type and make sure it has the correct type.\n        It might not in cases where methods do things like \n        downcast methods. */\n      if (obj != Qnil) {\n        VALUE value = rb_iv_get(obj, \"@__swigtype__\");\n        char* type_name = RSTRING_PTR(value);\n\t\t\t\t\n        if (strcmp(type->name, type_name) == 0) {\n          return obj;\n        }\n      }\n    }\n\n    /* Create a new Ruby object */\n    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), \n\t\t\t   ( own ? VOIDFUNC(sklass->destroy) : \n\t\t\t     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )\n\t\t\t     ), ptr);\n\n    /* If tracking is on for this class then track this object. */\n    if (track) {\n      SWIG_RubyAddTracking(ptr, obj);\n    }\n  } else {\n    klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n    sprintf(klass_name, \"TYPE%s\", type->name);\n    klass = rb_const_get(_mSWIG, rb_intern(klass_name));\n    free((void *) klass_name);\n    obj = Data_Wrap_Struct(klass, 0, 0, ptr);\n  }\n  rb_iv_set(obj, \"@__swigtype__\", rb_str_new2(type->name));\n  \n  return obj;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type)", "code": "{\n  /* The \"str\" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == '|') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* Remove a Tracking from a C/C++ struct to a Ruby object.  It\n   is very important to remove objects once they are destroyed\n   since the same memory address may be reused later to create\n   a new object. */\n", "func_signal": "SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr)", "code": "{\n  /* Get a reference to the pointer as a Ruby number */\n  VALUE key = SWIG_RubyPtrToReference(ptr);\n\n  /* Delete the object from the hash table by calling Ruby's\n     do this we need to call the Hash.delete method.*/\n  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);\n}", "path": "lib\\itexToMML\\itex-src\\itex2MML_ruby.c", "repo_name": "rhyhann/sb", "stars": 2, "license": "None", "language": "c", "size": 716}
{"docstring": "/* ********************************************************************** */\n", "func_signal": "static void\nemfv_selection_get(GtkWidget *widget, GtkSelectionData *data, guint info, guint time_stamp, EMFolderView *emfv)", "code": "{\n\tstruct _EMFolderViewPrivate *p = emfv->priv;\n\n\tif (p->selection_uri == NULL)\n\t\treturn;\n\n\tgtk_selection_data_set(data, data->target, 8, (unsigned char *)p->selection_uri, strlen(p->selection_uri));\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* adds a rule with a gui */\n", "func_signal": "void\nvfolder_gui_add_rule(EMVFolderRule *rule)", "code": "{\n\tGtkWidget *w;\n\tGtkDialog *gd;\n\n\t/* this should be done before we call this function */\n\tvfolder_load_storage ();\n\n\tw = filter_rule_get_widget((FilterRule *)rule, (RuleContext *)context);\n\n\tgd = (GtkDialog *)gtk_dialog_new_with_buttons(_(\"New Search Folder\"),\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      GTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL,\n\t\t\t\t\t\t      GTK_RESPONSE_CANCEL,\n\t\t\t\t\t\t      GTK_STOCK_OK,\n\t\t\t\t\t\t      GTK_RESPONSE_OK,\n\t\t\t\t\t\t      NULL);\n\tgtk_dialog_set_default_response(gd, GTK_RESPONSE_OK);\n\tgtk_container_set_border_width (GTK_CONTAINER (gd), 6);\n\tgtk_box_set_spacing ((GtkBox *) gd->vbox, 6);\n\tg_object_set(gd, \"allow_shrink\", FALSE, \"allow_grow\", TRUE, NULL);\n\tgtk_window_set_default_size (GTK_WINDOW (gd), 500, 500);\n\tgtk_box_pack_start((GtkBox *)gd->vbox, w, TRUE, TRUE, 0);\n\tgtk_widget_show((GtkWidget *)gd);\n\tg_object_set_data_full(G_OBJECT(gd), \"rule\", rule, (GDestroyNotify)g_object_unref);\n\tg_signal_connect(gd, \"response\", G_CALLBACK(new_rule_clicked), NULL);\n\tgtk_widget_show((GtkWidget *)gd);\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* should this be elsewhere/take a uid list? */\n", "func_signal": "int\nem_folder_view_open_selected(EMFolderView *emfv)", "code": "{\n\tGPtrArray *uids, *views;\n\tint i = 0;\n\n\tuids = message_list_get_selected(emfv->list);\n\n\tif (uids->len >= 10) {\n\t\tchar *num = g_strdup_printf(\"%d\", uids->len);\n\t\tint doit;\n\n\t\tdoit = em_utils_prompt_user((GtkWindow *)gtk_widget_get_toplevel((GtkWidget *)emfv),\n\t\t\t\t\t    \"/apps/evolution/mail/prompts/open_many\",\n\t\t\t\t\t    \"mail:ask-open-many\", num, NULL);\n\t\tg_free(num);\n\t\tif (!doit) {\n\t\t\tmessage_list_free_uids(emfv->list, uids);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n        if (em_utils_folder_is_drafts(emfv->folder, emfv->folder_uri)\n\t    || em_utils_folder_is_outbox(emfv->folder, emfv->folder_uri)) {\n\t\tem_utils_edit_messages(emfv->folder, uids, TRUE);\n\t\treturn uids->len;\n\t}\n\n\t/* for vfolders we need to edit the *original*, not the vfolder copy */\n\tviews = g_ptr_array_new();\n\tfor (i=0;i<uids->len;i++) {\n\t\tif (camel_object_is((CamelObject *)emfv->folder, camel_vee_folder_get_type())) {\n\t\t\tCamelVeeMessageInfo *vinfo = (CamelVeeMessageInfo *)camel_folder_get_message_info(emfv->folder, uids->pdata[i]);\n\n\t\t\tif (vinfo) {\n\t\t\t\tchar *uid;\n\t\t\t\t/* TODO: get_location shouldn't strdup the uid */\n\t\t\t\tCamelFolder *f = camel_vee_folder_get_location((CamelVeeFolder *)emfv->folder, vinfo, &uid);\n\t\t\t\tchar *uri = mail_tools_folder_to_url(f);\n\n\t\t\t\tif (em_utils_folder_is_drafts(f, uri) || em_utils_folder_is_outbox(f, uri)) {\n\t\t\t\t\tGPtrArray *edits = g_ptr_array_new();\n\n\t\t\t\t\tg_ptr_array_add(edits, uid);\n\t\t\t\t\tem_utils_edit_messages(f, edits, TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tg_free(uid);\n\t\t\t\t\tg_ptr_array_add(views, g_strdup(uids->pdata[i]));\n\t\t\t\t}\n\t\t\t\tg_free(uri);\n\t\t\t}\n\t\t} else {\n\t\t\tg_ptr_array_add(views, g_strdup(uids->pdata[i]));\n\t\t}\n\t}\n\n\t/* TODO: have an em_utils_open_messages call? */\n\tfor (i=0; i<views->len; i++) {\n\t\tEMMessageBrowser *emmb;\n\n\t\temmb = (EMMessageBrowser *)em_message_browser_window_new();\n\t\tmessage_list_set_threaded(((EMFolderView *)emmb)->list, emfv->list->threaded);\n\t\t/* do not inherit search filter, because it can hide actual message for some filters */\n\t\t/*message_list_set_search(((EMFolderView *)emmb)->list, emfv->list->search);*/\n\t\tem_folder_view_set_hide_deleted((EMFolderView *)emmb, emfv->hide_deleted);\n\t\t/* FIXME: session needs to be passed easier than this */\n\t\tem_format_set_session((EMFormat *)((EMFolderView *)emmb)->preview, ((EMFormat *)emfv->preview)->session);\n\t\tem_folder_view_set_folder((EMFolderView *)emmb, emfv->folder, emfv->folder_uri);\n\t\tem_folder_view_set_message((EMFolderView *)emmb, views->pdata[i], FALSE);\n\t\tgtk_widget_show(emmb->window);\n\t\t/* TODO: this loads the message twice (!) */\n\t\tem_utils_handle_receipt (emfv->folder, uids->pdata[i], NULL);\n\t\tg_free(views->pdata[i]);\n\t}\n\tg_ptr_array_free(views, TRUE);\n\n\tmessage_list_free_uids(emfv->list, uids);\n\n\treturn i;\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* Popup menu\n   In many cases these are the functions called by the bonobo callbacks too */\n", "func_signal": "static void\nemfv_popup_open(EPopup *ep, EPopupItem *pitem, void *data)", "code": "{\n\tEMFolderView *emfv = data;\n\tem_folder_view_open_selected(emfv);\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* called when a uri is deleted from a store */\n", "func_signal": "void\nmail_vfolder_delete_uri(CamelStore *store, const char *curi)", "code": "{\n\tFilterRule *rule;\n\tconst char *source;\n\tCamelVeeFolder *vf;\n\tGString *changed;\n\tchar *uri;\n\tGList *link;\n\n\tif (context == NULL || uri_is_spethal(store, curi))\n\t\treturn;\n\n\turi = em_uri_from_camel(curi);\n\n\td(printf (\"Deleting uri to check: %s\\n\", uri));\n\n\tg_return_if_fail (mail_in_main_thread());\n\n\tchanged = g_string_new (\"\");\n\n\tLOCK();\n\n\t/* see if any rules directly reference this removed uri */\n \trule = NULL;\n\twhile ((rule = rule_context_next_rule ((RuleContext *) context, rule, NULL))) {\n\n\t\tif (!rule->name) {\n\t\t\td(printf(\"invalid rule (%p): rule->name is set to NULL\\n\", rule));\n\t\t\tcontinue;\n\t\t}\n\n\t\tsource = NULL;\n\t\twhile ((source = em_vfolder_rule_next_source ((EMVFolderRule *) rule, source))) {\n\t\t\tchar *csource = em_uri_to_camel(source);\n\n\t\t\t/* Remove all sources that match, ignore changed events though\n\t\t\t   because the adduri call above does the work async */\n\t\t\tif (camel_store_folder_uri_equal(store, curi, csource)) {\n\t\t\t\tvf = g_hash_table_lookup (vfolder_hash, rule->name);\n\t\t\t\tif (!vf) {\n\t\t\t\t\tg_warning (\"vf is NULL for %s\\n\", rule->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg_signal_handlers_disconnect_matched (rule, G_SIGNAL_MATCH_FUNC|G_SIGNAL_MATCH_DATA, 0,\n\t\t\t\t\t\t\t\t      0, NULL, rule_changed, vf);\n\t\t\t\tem_vfolder_rule_remove_source ((EMVFolderRule *)rule, source);\n\t\t\t\tg_signal_connect (rule, \"changed\", G_CALLBACK(rule_changed), vf);\n\t\t\t\tg_string_append_printf (changed, \"    %s\\n\", rule->name);\n\t\t\t\tsource = NULL;\n\t\t\t}\n\t\t\tg_free(csource);\n\t\t}\n\t}\n\n\tif ((link = mv_find_folder(source_folders_remote, store, curi)) != NULL) {\n\t\tg_free(link->data);\n\t\tsource_folders_remote = g_list_remove_link(source_folders_remote, link);\n\t}\n\n\tif ((link = mv_find_folder(source_folders_local, store, curi)) != NULL) {\n\t\tg_free(link->data);\n\t\tsource_folders_local = g_list_remove_link(source_folders_local, link);\n\t}\n\n\tUNLOCK();\n\n\tif (changed->str[0]) {\n\t\tGtkWidget *dialog;\n\t\tchar *user;\n\n\t\tdialog = e_error_new(NULL, \"mail:vfolder-updated\", changed->str, uri, NULL);\n\t\tem_utils_show_info_silent (dialog);\n\n\t\tuser = g_strdup_printf (\"%s/vfolders.xml\",\n\t\t\t\t\tmail_component_peek_base_directory (mail_component_peek ()));\n\t\trule_context_save ((RuleContext *) context, user);\n\t\tg_free (user);\n\t}\n\n\tg_string_free (changed, TRUE);\n\n\tg_free(uri);\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* ********************************************************************** */\n", "func_signal": "static GList *\nmv_find_folder(GList *l, CamelStore *store, const char *uri)", "code": "{\n\twhile (l) {\n\t\tif (camel_store_folder_uri_equal(store, l->data, uri))\n\t\t\tbreak;\n\t\tl = l->next;\n\t}\n\treturn l;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* searching for certificates */\n", "func_signal": "ECert*\ne_cert_db_find_cert_by_nickname (ECertDB *certdb,\n\t\t\t\t const char *nickname,\n\t\t\t\t GError **error)", "code": "{\n\t/*  nsNSSShutDownPreventionLock locker;*/\n\tCERTCertificate *cert = NULL;\n\n\t/*PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, (\"Getting \\\"%s\\\"\\n\", asciiname));*/\n\tcert = PK11_FindCertFromNickname((char*)nickname, NULL);\n\tif (!cert) {\n\t\tcert = CERT_FindCertByNickname(CERT_GetDefaultCertDB(), (char*)nickname);\n\t}\n\n\n\tif (cert) {\n\t\t/*    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, (\"got it\\n\"));*/\n\t\tECert *ecert = e_cert_new (cert);\n\t\treturn ecert;\n\t}\n\telse {\n\t\t/* XXX gerror */\n\t\treturn NULL;\n\t}\n}", "path": "smime\\lib\\e-cert-db.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* so special we never use it */\n", "func_signal": "static int\nuri_is_spethal(CamelStore *store, const char *uri)", "code": "{\n\tCamelURL *url;\n\tint res;\n\n\t/* This is a bit of a hack, but really the only way it can be done at the moment. */\n\n\tif ((store->flags & (CAMEL_STORE_VTRASH|CAMEL_STORE_VJUNK)) == 0)\n\t\treturn FALSE;\n\n\turl = camel_url_new(uri, NULL);\n\tif (url == NULL)\n\t\treturn TRUE;\n\n\t/* don't use strcasecmp here */\n\tif (url->fragment) {\n\t\tres = (((store->flags & CAMEL_STORE_VTRASH)\n\t\t\t&& strcmp(url->fragment, CAMEL_VTRASH_NAME) == 0)\n\t\t       || ((store->flags & CAMEL_STORE_VJUNK)\n\t\t\t   && strcmp(url->fragment, CAMEL_VJUNK_NAME) == 0));\n\t} else {\n\t\tres = url->path\n\t\t\t&& (((store->flags & CAMEL_STORE_VTRASH)\n\t\t\t     && strcmp(url->path, \"/\" CAMEL_VTRASH_NAME) == 0)\n\t\t\t    || ((store->flags & CAMEL_STORE_VJUNK)\n\t\t\t\t&& strcmp(url->path, \"/\" CAMEL_VJUNK_NAME) == 0));\n\t}\n\n\tcamel_url_free(url);\n\n\treturn res;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* deleting certificates */\n", "func_signal": "gboolean\ne_cert_db_delete_cert (ECertDB *certdb,\n\t\t       ECert   *ecert)", "code": "{\n\t/*  nsNSSShutDownPreventionLock locker;\n\t    nsNSSCertificate *nssCert = NS_STATIC_CAST(nsNSSCertificate*, aCert); */\n\n\tCERTCertificate *cert;\n\tSECStatus srv = SECSuccess;\n\tif (!e_cert_mark_for_deletion (ecert)) {\n\t\treturn FALSE;\n\t}\n\n\tcert = e_cert_get_internal_cert (ecert);\n\tif (cert->slot && e_cert_get_cert_type (ecert) != E_CERT_USER) {\n\t\t/* To delete a cert of a slot (builtin, most likely), mark it as\n\t\t   completely untrusted.  This way we keep a copy cached in the\n\t\t   local database, and next time we try to load it off of the\n\t\t   external token/slot, we'll know not to trust it.  We don't\n\t\t   want to do that with user certs, because a user may  re-store\n\t\t   the cert onto the card again at which point we *will* want to\n\t\t   trust that cert if it chains up properly. */\n\t\tCERTCertTrust trust;\n\n\t\te_cert_trust_init_with_values (&trust, 0, 0, 0);\n\t\tsrv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(),\n\t\t\t\t\t   cert, &trust);\n\t}\n\n\t/*PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, (\"cert deleted: %d\", srv));*/\n\treturn (srv) ? FALSE : TRUE;\n}", "path": "smime\\lib\\e-cert-db.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* uri should be a camel uri */\n", "func_signal": "static int\nvfolder_adduri(const char *uri, GList *folders, int remove)", "code": "{\n\tstruct _adduri_msg *m;\n\tint id;\n\n\tm = mail_msg_new(&vfolder_adduri_info);\n\tm->folders = folders;\n\tm->uri = g_strdup(uri);\n\tm->remove = remove;\n\n\tid = m->base.seq;\n\tmail_msg_slow_ordered_push (m);\n\n\treturn id;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* uri is a camel uri */\n", "func_signal": "static int\nuri_is_ignore(CamelStore *store, const char *uri)", "code": "{\n\tEAccountList *accounts;\n\tEAccount *account;\n\tEIterator *iter;\n\tint found = FALSE;\n\n\td(printf(\"checking '%s' against:\\n  %s\\n  %s\\n  %s\\n\", uri,\n\t\t mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_OUTBOX),\n\t\t mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_SENT),\n\t\t mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_DRAFTS)));\n\n\tfound = camel_store_folder_uri_equal(store, mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_OUTBOX), uri)\n\t\t|| camel_store_folder_uri_equal(store, mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_SENT), uri)\n\t\t|| camel_store_folder_uri_equal(store, mail_component_get_folder_uri(NULL, MAIL_COMPONENT_FOLDER_DRAFTS), uri);\n\n\tif (found)\n\t\treturn found;\n\n\taccounts = mail_config_get_accounts ();\n\titer = e_list_get_iterator ((EList *) accounts);\n\twhile (e_iterator_is_valid (iter)) {\n\t\tchar *curi;\n\n\t\taccount = (EAccount *) e_iterator_get (iter);\n\n\t\td(printf(\"checking sent_folder_uri '%s' == '%s'\\n\",\n\t\t\t account->sent_folder_uri ? account->sent_folder_uri : \"empty\", uri));\n\n\t\tif (account->sent_folder_uri) {\n\t\t\tcuri = em_uri_to_camel(account->sent_folder_uri);\n\t\t\tfound = camel_store_folder_uri_equal(store, uri, curi);\n\t\t\tg_free(curi);\n\t\t}\n\t\tif (!found && account->drafts_folder_uri) {\n\t\t\tcuri = em_uri_to_camel(account->drafts_folder_uri);\n\t\t\tfound = camel_store_folder_uri_equal(store, uri, curi);\n\t\t\tg_free(curi);\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\n\t\te_iterator_next (iter);\n\t}\n\n\tg_object_unref (iter);\n\n\treturn found;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* ********************************************************************** */\n", "func_signal": "static void\nemfv_set_folder(EMFolderView *emfv, CamelFolder *folder, const char *uri)", "code": "{\n\tint isout = (folder && uri\n\t\t     && (em_utils_folder_is_drafts(folder, uri)\n\t\t\t || em_utils_folder_is_sent(folder, uri)\n\t\t\t || em_utils_folder_is_outbox(folder, uri)));\n\n\tif (folder == emfv->folder)\n\t\treturn;\n\n\tif (emfv->priv->selected_id)\n\t\tg_source_remove(emfv->priv->selected_id);\n\n\tif (emfv->preview)\n\t\tem_format_format ((EMFormat *) emfv->preview, NULL, NULL, NULL);\n\n\tmessage_list_set_folder(emfv->list, folder, uri, isout);\n\tg_free(emfv->folder_uri);\n\temfv->folder_uri = uri ? g_strdup(uri):NULL;\n\n\tif (emfv->folder) {\n\t\temfv->hide_deleted = emfv->list->hidedeleted; /* <- a bit nasty but makes it track the display better */\n\t\tmail_sync_folder (emfv->folder, NULL, NULL);\n\t\tcamel_object_unref(emfv->folder);\n\t}\n\n\temfv->folder = folder;\n\tif (folder) {\n\t\t/* We need to set this up to get the right view options for the message-list,\n\t\t * even if we're not showing it */\n\t\temfv_setup_view_instance(emfv);\n\t\tcamel_object_ref(folder);\n\t}\n\n\temfv_enable_menus(emfv);\n\n\t/* TODO: should probably be called after all processing, not just this class's impl */\n\tg_signal_emit(emfv, signals[EMFV_LOADED], 0);\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* Returns output stream for the uri, or NULL on any error.\n   When done with the stream, just g_output_stream_close and g_object_unref it.\n   It will ask for overwrite if file already exists.\n*/\n", "func_signal": "GOutputStream *\nopen_for_writing (GtkWindow *parent, const char *uri, GError **error)", "code": "{\n\tGFile *file;\n\tGFileOutputStream *fostream;\n\tGError *err = NULL;\n\n\tg_return_val_if_fail (uri != NULL, NULL);\n\n\tfile = g_file_new_for_uri (uri);\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tfostream = g_file_create (file, G_FILE_CREATE_NONE, NULL, &err);\n\n\tif (err && err->code == G_IO_ERROR_EXISTS) {\n\t\tg_clear_error (&err);\n\n\t\tif (e_error_run (parent, E_ERROR_ASK_FILE_EXISTS_OVERWRITE, uri, NULL) == GTK_RESPONSE_OK) {\n\t\t\tfostream = g_file_replace (file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &err);\n\n\t\t\tif (err && fostream) {\n\t\t\t\tg_object_unref (fostream);\n\t\t\t\tfostream = NULL;\n\t\t\t}\n\t\t} else if (fostream) {\n\t\t\tg_object_unref (fostream);\n\t\t\tfostream = NULL;\n\t\t}\n\t}\n\n\tg_object_unref (file);\n\n\tif (error && err)\n\t\t*error = err;\n\telse if (err)\n\t\tg_error_free (err);\n\n\tif (fostream)\n\t\treturn G_OUTPUT_STREAM (fostream);\n\n\treturn NULL;\n}", "path": "plugins\\ipod-sync\\ipod-sync.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* clones a filter/search rule into a matching vfolder rule (assuming the same system definitions) */\n", "func_signal": "FilterRule *\nvfolder_clone_rule(FilterRule *in)", "code": "{\n\tFilterRule *rule = (FilterRule *)em_vfolder_rule_new();\n\txmlNodePtr xml;\n\n\txml = filter_rule_xml_encode(in);\n\tfilter_rule_xml_decode(rule, xml, (RuleContext *)context);\n\txmlFreeNodeList(xml);\n\n\treturn rule;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* called when a new uri becomes (un)available */\n", "func_signal": "void\nmail_vfolder_add_uri(CamelStore *store, const char *curi, int remove)", "code": "{\n\tFilterRule *rule;\n\tconst char *source;\n\tCamelVeeFolder *vf;\n\tGList *folders = NULL, *link;\n\tint remote = (((CamelService *)store)->provider->flags & CAMEL_PROVIDER_IS_REMOTE) != 0;\n\tint is_ignore;\n\tchar *uri;\n\n\turi = em_uri_from_camel(curi);\n\tif (context == NULL || uri_is_spethal(store, curi)) {\n\t\tg_free(uri);\n\t\treturn;\n\t}\n\n\tg_return_if_fail (mail_in_main_thread());\n\n\tis_ignore = uri_is_ignore(store, curi);\n\n\tLOCK();\n\n/* \td(printf(\"%s uri to check: %s\\n\", remove?\"Removing\":\"Adding\", uri)); */\n\n\t/* maintain the source folders lists for changed rules later on */\n\tif (CAMEL_IS_VEE_STORE(store)) {\n\t\tis_ignore = TRUE;\n\t} else if (remove) {\n\t\tif (remote) {\n\t\t\tif ((link = mv_find_folder(source_folders_remote, store, curi)) != NULL) {\n\t\t\t\tg_free(link->data);\n\t\t\t\tsource_folders_remote = g_list_remove_link(source_folders_remote, link);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((link = mv_find_folder(source_folders_local, store, curi)) != NULL) {\n\t\t\t\tg_free(link->data);\n\t\t\t\tsource_folders_local = g_list_remove_link(source_folders_local, link);\n\t\t\t}\n\t\t}\n\t} else if (!is_ignore) {\n\t\t/* we ignore drafts/sent/outbox here */\n\t\tif (remote) {\n\t\t\tif (mv_find_folder(source_folders_remote, store, curi) == NULL)\n\t\t\t\tsource_folders_remote = g_list_prepend(source_folders_remote, g_strdup(curi));\n\t\t} else {\n\t\t\tif (mv_find_folder(source_folders_local, store, curi) == NULL)\n\t\t\t\tsource_folders_local = g_list_prepend(source_folders_local, g_strdup(curi));\n\t\t}\n\t}\n\n \trule = NULL;\n\twhile ((rule = rule_context_next_rule((RuleContext *)context, rule, NULL))) {\n\t\tint found = FALSE;\n\n\t\tif (!rule->name) {\n\t\t\td(printf(\"invalid rule (%p): rule->name is set to NULL\\n\", rule));\n\t\t\tcontinue;\n\t\t}\n\t\t/* dont auto-add any sent/drafts folders etc, they must be explictly listed as a source */\n\t\tif (rule->source\n\t\t    && !is_ignore\n\t\t    && ((((EMVFolderRule *)rule)->with == EM_VFOLDER_RULE_WITH_LOCAL && !remote)\n\t\t\t|| (((EMVFolderRule *)rule)->with == EM_VFOLDER_RULE_WITH_REMOTE_ACTIVE && remote)\n\t\t\t|| (((EMVFolderRule *)rule)->with == EM_VFOLDER_RULE_WITH_LOCAL_REMOTE_ACTIVE)))\n\t\t\tfound = TRUE;\n\n\t\tsource = NULL;\n\t\twhile (!found && (source = em_vfolder_rule_next_source((EMVFolderRule *)rule, source))) {\n\t\t\tchar *csource;\n\t\t\tcsource = em_uri_to_camel(source);\n\t\t\tfound = camel_store_folder_uri_equal(store, curi, csource);\n\t\t\td(printf(found?\" '%s' == '%s'?\\n\":\" '%s' != '%s'\\n\", curi, csource));\n\t\t\tg_free(csource);\n\t\t}\n\n\t\tif (found) {\n\t\t\tvf = g_hash_table_lookup(vfolder_hash, rule->name);\n\t\t\tif (!vf) {\n\t\t\t\tg_warning (\"vf is NULL for %s\\n\", rule->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcamel_object_ref(vf);\n\t\t\tfolders = g_list_prepend(folders, vf);\n\t\t}\n\t}\n\n\tUNLOCK();\n\n\tif (folders != NULL)\n\t\tvfolder_adduri(curi, folders, remove);\n\n\tg_free(uri);\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* importing certificates */\n", "func_signal": "gboolean\ne_cert_db_import_certs (ECertDB *certdb,\n\t\t\tchar *data, guint32 length,\n\t\t\tECertType cert_type,\n\t\t\tGError **error)", "code": "{\n\t/*nsNSSShutDownPreventionLock locker;*/\n\tPRArenaPool *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n\tGList *certs = NULL;\n\tCERTDERCerts *certCollection = e_cert_db_get_certs_from_package (arena, data, length);\n\tint i;\n\tgboolean rv;\n\n\tif (!certCollection) {\n\t\t/* XXX gerror */\n\t\tPORT_FreeArena(arena, PR_FALSE);\n\t\treturn FALSE;\n\t}\n\n\t/* Now let's create some certs to work with */\n\tfor (i=0; i<certCollection->numcerts; i++) {\n\t\tSECItem *currItem = &certCollection->rawCerts[i];\n\t\tECert *cert;\n\n\t\tcert = e_cert_new_from_der ((char*)currItem->data, currItem->len);\n\t\tif (!cert) {\n\t\t\t/* XXX gerror */\n\t\t\tg_list_foreach (certs, (GFunc)g_object_unref, NULL);\n\t\t\tg_list_free (certs);\n\t\t\tPORT_FreeArena(arena, PR_FALSE);\n\t\t\treturn FALSE;\n\t\t}\n\t\tcerts = g_list_append (certs, cert);\n\t}\n\tswitch (cert_type) {\n\tcase E_CERT_CA:\n\t\trv = handle_ca_cert_download(certdb, certs, error);\n\t\tbreak;\n\tdefault:\n\t\t/* We only deal with import CA certs in this method currently.*/\n\t\t/* XXX gerror */\n\t\tPORT_FreeArena(arena, PR_FALSE);\n\t\trv = FALSE;\n\t}\n\n\tg_list_foreach (certs, (GFunc)g_object_unref, NULL);\n\tg_list_free (certs);\n\tPORT_FreeArena(arena, PR_FALSE);\n\treturn rv;\n}", "path": "smime\\lib\\e-cert-db.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* sources_uri should be camel uri's */\n", "func_signal": "static int\nvfolder_setup(CamelFolder *folder, const char *query, GList *sources_uri, GList *sources_folder)", "code": "{\n\tstruct _setup_msg *m;\n\tint id;\n\n\tm = mail_msg_new(&vfolder_setup_info);\n\tm->folder = folder;\n\tcamel_object_ref(folder);\n\tm->query = g_strdup(query);\n\tm->sources_uri = sources_uri;\n\tm->sources_folder = sources_folder;\n\n\tid = m->base.seq;\n\tmail_msg_slow_ordered_push (m);\n\n\treturn id;\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* flag all selected messages. Return number flagged */\n/* FIXME: Should this be part of message-list instead? */\n", "func_signal": "int\nem_folder_view_mark_selected(EMFolderView *emfv, guint32 mask, guint32 set)", "code": "{\n\tGPtrArray *uids;\n\tint i;\n\n\tif (emfv->folder == NULL)\n\t\treturn 0;\n\n\tuids = message_list_get_selected(emfv->list);\n\tcamel_folder_freeze(emfv->folder);\n\n\tfor (i=0; i<uids->len; i++)\n\t\tcamel_folder_set_message_flags(emfv->folder, uids->pdata[i], mask, set);\n\n\tmessage_list_free_uids(emfv->list, uids);\n\tcamel_folder_thaw(emfv->folder);\n\n\treturn i;\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* ******************************************************************************** */\n", "func_signal": "static void\nemfv_list_display_view(GalViewInstance *instance, GalView *view, EMFolderView *emfv)", "code": "{\n\tif (GAL_IS_VIEW_ETABLE(view))\n\t\tgal_view_etable_attach_tree(GAL_VIEW_ETABLE(view), emfv->list->tree);\n}", "path": "mail\\em-folder-view.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/* called when a uri is renamed in a store */\n", "func_signal": "void\nmail_vfolder_rename_uri(CamelStore *store, const char *cfrom, const char *cto)", "code": "{\n\tFilterRule *rule;\n\tconst char *source;\n\tCamelVeeFolder *vf;\n\tint changed = 0;\n\tchar *from, *to;\n\n\td(printf(\"vfolder rename uri: %s to %s\\n\", cfrom, cto));\n\n\tif (context == NULL || uri_is_spethal(store, cfrom) || uri_is_spethal(store, cto))\n\t\treturn;\n\n\tg_return_if_fail (mail_in_main_thread());\n\n\tfrom = em_uri_from_camel(cfrom);\n\tto = em_uri_from_camel(cto);\n\n\tLOCK();\n\n\t/* see if any rules directly reference this removed uri */\n \trule = NULL;\n\twhile ( (rule = rule_context_next_rule((RuleContext *)context, rule, NULL)) ) {\n\t\tsource = NULL;\n\t\twhile ( (source = em_vfolder_rule_next_source((EMVFolderRule *)rule, source)) ) {\n\t\t\tchar *csource = em_uri_to_camel(source);\n\n\t\t\t/* Remove all sources that match, ignore changed events though\n\t\t\t   because the adduri call above does the work async */\n\t\t\tif (camel_store_folder_uri_equal(store, cfrom, csource)) {\n\t\t\t\td(printf(\"Vfolder '%s' used '%s' ('%s') now uses '%s'\\n\", rule->name, source, from, to));\n\t\t\t\tvf = g_hash_table_lookup(vfolder_hash, rule->name);\n\t\t\t\tif (!vf) {\n\t\t\t\t\tg_warning (\"vf is NULL for %s\\n\", rule->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg_signal_handlers_disconnect_matched(rule, G_SIGNAL_MATCH_FUNC|G_SIGNAL_MATCH_DATA, 0,\n\t\t\t\t\t\t\t\t     0, NULL, rule_changed, vf);\n\t\t\t\tem_vfolder_rule_remove_source((EMVFolderRule *)rule, source);\n\t\t\t\tem_vfolder_rule_add_source((EMVFolderRule *)rule, to);\n\t\t\t\tg_signal_connect(rule, \"changed\", G_CALLBACK(rule_changed), vf);\n\t\t\t\tchanged++;\n\t\t\t\tsource = NULL;\n\t\t\t}\n\t\t\tg_free(csource);\n\t\t}\n\t}\n\n\tUNLOCK();\n\n\tif (changed) {\n\t\tchar *user;\n\n\t\td(printf(\"Vfolders updated from renamed folder\\n\"));\n\t\tuser = g_strdup_printf(\"%s/vfolders.xml\", mail_component_peek_base_directory (mail_component_peek ()));\n\t\trule_context_save((RuleContext *)context, user);\n\t\tg_free(user);\n\t}\n\n\tg_free(from);\n\tg_free(to);\n}", "path": "mail\\mail-vfolder.c", "repo_name": "johnnyjacob/evolution", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 31698}
{"docstring": "/**\n * lm_connection_new_with_context:\n * @server: The hostname to the server for the connection.\n * @context: The context this connection should be running in.\n * \n * Creates a new closed connection running in a certain context. To open the \n * connection call #lm_connection_open. @server can be #NULL but must be set \n * before calling #lm_connection_open.\n * \n * Return value: A newly created LmConnection, should be unreffed with lm_connection_unref().\n **/\n", "func_signal": "LmConnection *\nlm_connection_new_with_context (const gchar *server, GMainContext *context)", "code": "{\n\tLmConnection *connection;\n\n\tconnection = lm_connection_new (server);\n\tconnection->context = context;\n\n\tif (context) {\n        \tg_main_context_ref (connection->context);\n\t}\n\n\treturn connection;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_send_with_reply_and_block:\n * @connection: an #LmConnection\n * @message: an #LmMessage\n * @error: Set if error was detected during sending.\n * \n * Send @message and wait for return.\n * \n * Return value: The reply\n **/\n", "func_signal": "LmMessage *\nlm_connection_send_with_reply_and_block (LmConnection  *connection,\n\t\t\t\t\t LmMessage     *message,\n\t\t\t\t\t GError       **error)", "code": "{\n\tgchar     *id;\n\tLmMessage *reply = NULL;\n\n\tg_return_val_if_fail (connection != NULL, NULL);\n\tg_return_val_if_fail (message != NULL, NULL);\n\n\tif (connection->state < LM_CONNECTION_STATE_OPENING) {\n\t\tg_set_error (error,\n\t\t\t     LM_ERROR,\n\t\t\t     LM_ERROR_CONNECTION_NOT_OPEN,\n\t\t\t     \"Connection is not open, call lm_connection_open() first\");\n\t\treturn FALSE;\n\t}\n\n\n\tif (lm_message_node_get_attribute (message->node, \"id\")) {\n\t\tid = g_strdup (lm_message_node_get_attribute (message->node, \n\t\t\t\t\t\t\t      \"id\"));\n\t} else {\n\t\tid = _lm_utils_generate_id ();\n\t\tlm_message_node_set_attributes (message->node, \"id\", id, NULL);\n\t}\n\n\tlm_message_queue_detach (connection->queue);\n\n\tlm_connection_send (connection, message, error);\n\n\twhile (!reply) {\n\t\tconst gchar *m_id;\n\t\tguint        n;\n\n\t\tg_main_context_iteration (connection->context, TRUE);\n\t\n\t\tif (lm_message_queue_is_empty (connection->queue)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (n = 0; n < lm_message_queue_get_length (connection->queue); n++) {\n\t\t\tLmMessage *m;\n\n\t\t\tm = (LmMessage *) lm_message_queue_peek_nth (connection->queue, n);\n\n\t\t\tm_id = lm_message_node_get_attribute (m->node, \"id\");\n\t\t\t\n\t\t\tif (m_id && strcmp (m_id, id) == 0) {\n\t\t\t\treply = m;\n\t\t\t\tlm_message_queue_pop_nth (connection->queue, n);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tg_free (id);\n\tlm_message_queue_attach (connection->queue, connection->context);\n\n\treturn reply;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_ssl:\n * @connection: An #LmConnection\n * @ssl: An #LmSSL\n *\n * Sets SSL struct or unset if @ssl is %NULL. If set @connection will use SSL to for the connection.\n */\n", "func_signal": "void\nlm_connection_set_ssl (LmConnection *connection, LmSSL *ssl)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\t//! rxt\n\tg_return_if_fail (lm_ssl_is_supported () == TRUE);\n\n\tif (connection->ssl) {\n\t\tlm_ssl_unref (connection->ssl);\n\t}\n\n\tif (ssl) {\n\t\tconnection->ssl = lm_ssl_ref (ssl);\n\t} else {\n\t\tconnection->ssl = NULL;\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_unref:\n * @connection: Connection to remove reference from.\n * \n * Removes a reference on @connection. If there are no references to\n * @connection it will be freed and shouldn't be used again.\n **/\n", "func_signal": "void\nlm_connection_unref (LmConnection *connection)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\t\n\tconnection->ref_count--;\n\t\n\tif (connection->ref_count == 0) {\n\t\tconnection_free (connection);\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_open:\n * @connection: #LmConnection to open\n * @function: Callback function that will be called when the connection is open.\n * @user_data: User data that will be passed to @function.\n * @notify: Function for freeing that user_data, can be NULL.\n * @error: location to store error, or %NULL\n * \n * An async call to open @connection. When the connection is open @function will be called.\n * \n * Return value: #TRUE if everything went fine, otherwise #FALSE.\n **/\n", "func_signal": "gboolean\nlm_connection_open (LmConnection      *connection, \n\t\t    LmResultFunction   function,\n\t\t    gpointer           user_data,\n\t\t    GDestroyNotify     notify,\n\t\t    GError           **error)", "code": "{\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\t\n\tconnection->open_cb = _lm_utils_new_callback (function, \n\t\t\t\t\t\t      user_data, notify);\n\tconnection->blocking = FALSE;\n\n\treturn connection_do_open (connection, error);\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_send: \n * @connection: #LmConnection to send message over.\n * @message: #LmMessage to send.\n * @error: location to store error, or %NULL\n * \n * Asynchronous call to send a message.\n * \n * Return value: Returns #TRUE if no errors where detected while sending, #FALSE otherwise.\n **/\n", "func_signal": "gboolean\nlm_connection_send (LmConnection  *connection, \n\t\t    LmMessage     *message, \n\t\t    GError       **error)", "code": "{\n\tgchar    *xml_str;\n\tgchar    *ch;\n\tgboolean  result;\n\t\n\tlm_verbose (\"lm_connection_send\\n\");\n\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\tg_return_val_if_fail (message != NULL, FALSE);\n\n\txml_str = lm_message_node_to_string (message->node);\n\tif ((ch = strstr (xml_str, \"</stream:stream>\"))) {\n\t\t*ch = '\\0';\n\t}\n\t\n\t//! rxt\n\t//write_debug_file(xml_str);\n\n\tresult = connection_send (connection, xml_str, -1, error);\n\tg_free (xml_str);\n\n\treturn result;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_get_state:\n * @connection: Connection to get state on\n *\n * Returns the state of the connection.\n *\n * Return value: The state of the connection.\n **/\n", "func_signal": "LmConnectionState \nlm_connection_get_state (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, \n\t\t\t      LM_CONNECTION_STATE_CLOSED);\n\n\treturn connection->state;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_is_authenticated:\n * @connection: #LmConnection to check if it is authenticated\n * \n * Check if @connection is authenticated.\n * \n * Return value: #TRUE if connection is authenticated, #FALSE otherwise.\n **/\n", "func_signal": "gboolean \nlm_connection_is_authenticated (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\n\treturn connection->state >= LM_CONNECTION_STATE_AUTHENTICATED;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_get_jid:\n * @connection: an #LmConnection\n * \n * Fetches the jid set for @connection is using. \n * \n * Return value: the jid\n **/\n", "func_signal": "const gchar *\nlm_connection_get_jid (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, NULL);\n\n\treturn connection->jid;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_get_server:\n * @connection: an #LmConnection\n * \n * Fetches the server address that @connection is using. \n * \n * Return value: the server address\n **/\n", "func_signal": "const gchar *\nlm_connection_get_server (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, NULL);\n\n\treturn connection->server;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/* From lm-ssl-protected.h */\n", "func_signal": "LmSSL *\n_lm_ssl_new (const gchar    *expected_fingerprint,\n\t    LmSSLFunction   ssl_function,\n\t    gpointer        user_data,\n\t    GDestroyNotify  notify)", "code": "{\n\tLmSSL *ssl;\n\n\tssl = g_new0 (LmSSL, 1);\n\n\t_lm_ssl_base_init ((LmSSLBase *) ssl,\n\t\t\t   expected_fingerprint,\n\t\t\t   ssl_function, user_data, notify);\n\tgnutls_global_set_log_level(9);\n\n\treturn ssl;\n}", "path": "loudmouth\\lm-ssl-gnutls.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_get_port:\n * @connection: an #LmConnection\n * \n * Fetches the port that @connection is using.\n * \n * Return value: The port used.\n **/\n", "func_signal": "guint\nlm_connection_get_port (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, 0);\n\n\treturn connection->port;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_proxy: \n * @connection: an #LmConnection\n * @proxy: an #LmProxy\n *\n * Sets the proxy to use for this connection. To unset pass #NULL.\n * \n **/\n", "func_signal": "void\nlm_connection_set_proxy (LmConnection *connection, LmProxy *proxy)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\n\tif (lm_connection_is_open (connection)) {\n\t\tg_warning (\"Can't change server proxy while connected\");\n\t\treturn;\n\t}\n\n\tif (connection->proxy) {\n\t\tlm_proxy_unref (connection->proxy);\n\t\tconnection->proxy = NULL;\n\t}\n\n\tif (proxy && lm_proxy_get_type (proxy) != LM_PROXY_TYPE_NONE) {\n\t\tconnection->proxy = lm_proxy_ref (proxy);\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_unregister_message_handler:\n * @connection: Connection to unregister a handler for.\n * @handler: The handler to unregister.\n * @type: What type of messages to unregister this handler for.\n * \n * Unregisters a handler for @connection. @handler will no longer be called \n * when incoming messages of @type arrive.\n **/\n", "func_signal": "void\nlm_connection_unregister_message_handler (LmConnection      *connection,\n\t\t\t\t\t  LmMessageHandler  *handler,\n\t\t\t\t\t  LmMessageType      type)", "code": "{\n\tGSList *l;\n\t\n\tg_return_if_fail (connection != NULL);\n\tg_return_if_fail (handler != NULL);\n\tg_return_if_fail (type != LM_MESSAGE_TYPE_UNKNOWN);\n\n\tfor (l = connection->handlers[type]; l; l = l->next) {\n\t\tHandlerData *hd = (HandlerData *) l->data;\n\t\t\n\t\tif (handler == hd->handler) {\n\t\t\tconnection->handlers[type] = g_slist_remove_link (connection->handlers[type], l);\n\t\t\tg_slist_free (l);\n\t\t\tlm_message_handler_unref (hd->handler);\n\t\t\tg_free (hd);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_disconnect_function:\n * @connection: Connection to register disconnect callback for.\n * @function: Function to be called when @connection is closed.\n * @user_data: User data passed to @function.\n * @notify: Function that will be called with @user_data when @user_data needs to be freed. Pass #NULL if it shouldn't be freed.\n * \n * Set the callback that will be called when a connection is closed. \n **/\n", "func_signal": "void\nlm_connection_set_disconnect_function (LmConnection         *connection,\n\t\t\t\t       LmDisconnectFunction  function,\n\t\t\t\t       gpointer              user_data,\n\t\t\t\t       GDestroyNotify        notify)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\n\tif (connection->disconnect_cb) {\n\t\t_lm_utils_free_callback (connection->disconnect_cb);\n\t}\n\t\t\n\tif (function) {\n\t\tconnection->disconnect_cb = _lm_utils_new_callback (function, \n\t    \t\t\t\t\t                    user_data,\n\t\t\t\t\t\t\t            notify);\n\t} else {\n\t\tconnection->disconnect_cb = NULL;\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_close:\n * @connection: #LmConnection to close \n * @error: location to store error, or %NULL\n * \n * A synchronous call to close the connection. When returning the connection is considered to be closed and can be opened again with lm_connection_open().\n * \n * Return value: Returns #TRUE if no errors where detected, otherwise #FALSE.\n **/\n", "func_signal": "gboolean\nlm_connection_close (LmConnection      *connection, \n\t\t     GError           **error)", "code": "{\n\tgboolean no_errors = TRUE;\n\t\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\n#ifdef HAVE_ASYNCNS\n\t_asyncns_cancel (connection->socket);\n#endif\n\n\tif (connection->state == LM_CONNECTION_STATE_CLOSED) {\n\t\tg_set_error (error,\n\t\t\t     LM_ERROR,\n\t\t\t     LM_ERROR_CONNECTION_NOT_OPEN,\n\t\t\t     \"Connection is not open, call lm_connection_open() first\");\n\t\treturn FALSE;\n\t}\n\n\tlm_verbose (\"Disconnecting from: %s:%d\\n\", \n\t\t    connection->server, connection->port);\n\t\n\tif (lm_connection_is_open (connection)) {\n\t\tif (!connection_send (connection, \"</stream:stream>\", -1, error)) {\n\t\t\tno_errors = FALSE;\n\t\t}\n\n\t\tlm_socket_flush (connection->socket);\n\t}\n\t\n\tconnection_do_close (connection);\n\tconnection_signal_disconnect (connection, LM_DISCONNECT_REASON_OK);\n\t\n\treturn no_errors;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_keep_alive_rate:\n * @connection: an #LmConnection\n * @rate: Number of seconds between keep alive packages are sent.\n * \n * Set the keep alive rate, in seconds. Set to 0 to prevent keep alive messages to be sent.\n * A keep alive message is a single space character.\n **/\n", "func_signal": "void\nlm_connection_set_keep_alive_rate (LmConnection *connection, guint rate)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\n\tconnection_stop_keep_alive (connection);\n\n\tif (rate == 0) {\n\t\tconnection->keep_alive_source = NULL;\n\t\treturn;\n\t}\n\n\tconnection->keep_alive_rate = rate;\n\t\n\tif (lm_connection_is_open (connection)) {\n\t\tconnection_start_keep_alive (connection);\n\t}\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_jid:\n * @connection: an #LmConnection\n * @jid: JID to be used for @connection\n * \n * Sets the JID to be used for @connection.\n **/\n", "func_signal": "void \nlm_connection_set_jid (LmConnection *connection, const gchar *jid)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\n\tif (lm_connection_is_open (connection)) {\n\t\tg_warning (\"Can't change JID while connected\");\n\t\treturn;\n\t}\n\n\tg_free (connection->jid);\n\tconnection->jid = g_strdup (jid);\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_set_port:\n * @connection: an #LmConnection\n * @port: server port\n * \n * Sets the server port that @connection will be using.\n **/\n", "func_signal": "void\nlm_connection_set_port (LmConnection *connection, guint port)", "code": "{\n\tg_return_if_fail (connection != NULL);\n\t\n\tif (lm_connection_is_open (connection)) {\n\t\tg_warning (\"Can't change server port while connected\");\n\t\treturn;\n\t}\n\t\n\tconnection->port = port;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/**\n * lm_connection_is_open:\n * @connection: #LmConnection to check if it is open.\n * \n * Check if the @connection is currently open.\n * \n * Return value: #TRUE if connection is open and #FALSE if it is closed.\n **/\n", "func_signal": "gboolean\nlm_connection_is_open (LmConnection *connection)", "code": "{\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\t\n\treturn connection->state >= LM_CONNECTION_STATE_OPEN;\n}", "path": "loudmouth\\lm-connection.c", "repo_name": "siraj/loudmouthcmake", "stars": 3, "license": "None", "language": "c", "size": 356}
{"docstring": "/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int yylex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* helper functions --------------------- */\n", "func_signal": "Bool defineProc(cFuncPointer cfunction, char *name, sEnvironment *env)", "code": "{\n  sExpression *pexp = newProc(cfunction);\n  eval(cons(newSymbol(\"define\"),\n            cons(newSymbol(name),\n                 pexp)), env);\n  return TRUE;\n}", "path": "src\\proc.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param bytes the byte buffer to scan\n * @param len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n", "func_signal": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )", "code": "{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* Copy into YYRESULT an error message about the unexpected token\n   YYCHAR while in state YYSTATE.  Return the number of bytes copied,\n   including the terminating null byte.  If YYRESULT is null, do not\n   copy anything; just return the number of bytes that would be\n   copied.  As a special case, return 0 if an ordinary \"syntax error\"\n   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during\n   size calculation.  */\n", "func_signal": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)", "code": "{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}", "path": "src\\y.tab.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */\n", "func_signal": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * \n */\n", "func_signal": "void yy_delete_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void yyrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void yyensure_buffer_stack (void)", "code": "{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* list functions */\n", "func_signal": "static sExpression *callProcListCons(sExpression *argument)", "code": "{\n  if(isList(argument)){\n    sList *arguments = toList(argument);\n    return cons(car(arguments), cadr(arguments));\n  }\n\n  return &sError;\n}", "path": "src\\proc.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )", "code": "{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 16 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 15);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void yypop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* misc */\n", "func_signal": "Bool callProcSymbolEqualSub(sExpression *temp1, sExpression *temp2)", "code": "{\n  int result = (temp1->value == temp2->value);\n  if(isSymbol(temp1) && isSymbol(temp2)){\n    result = strcmp(toSymb(temp1)->name, toSymb(temp1)->name) == 0;\n  }else if(isNumber(temp1) && isNumber(temp2)){\n    result = (toNum(temp1)->value) == (toNum(temp2)->value);\n  }else if(isString(temp1) && isString(temp2)){\n    result = strcmp(toString(temp1)->value, toString(temp2)->value) == 0;\n  }\n  return result == TRUE ? TRUE : FALSE;\n}", "path": "src\\proc.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* define functions to symbols */\n", "func_signal": "void initPrimitiveProcs()", "code": "{\n  defineProc(callProcPrintf, \"print\", sGlobalEnvironment);\n  defineProc(callProcIntAdd, \"+\", sGlobalEnvironment);\n  defineProc(callProcIntSub, \"-\", sGlobalEnvironment);\n  defineProc(callProcIntDiv, \"/\", sGlobalEnvironment);\n  defineProc(callProcIntMul, \"*\", sGlobalEnvironment);\n  defineProc(callProcIntEqual, \"=\", sGlobalEnvironment);\n  defineProc(callProcIntLT, \"<\", sGlobalEnvironment);\n  defineProc(callProcIntGT, \">\", sGlobalEnvironment);\n  defineProc(callProcSymbolEqual, \"equal?\", sGlobalEnvironment);\n  defineProc(callProcSymbolEqualType, \"equalType?\", sGlobalEnvironment);\n  defineProc(callProcIsAtom, \"atom?\", sGlobalEnvironment);\n  defineProc(callProcIsNull, \"null?\", sGlobalEnvironment);\n  defineProc(callProcListCar, \"car\", sGlobalEnvironment);\n  defineProc(callProcListCdr, \"cdr\", sGlobalEnvironment);\n  defineProc(callProcListCons, \"cons\", sGlobalEnvironment);\n}", "path": "src\\proc.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void yy_flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}", "path": "src\\lex.yy.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* mapping from C function to Scheme ---- */\n", "func_signal": "static sExpression *callProcPrintf(sExpression *arguments)", "code": "{\n  if(isList(arguments)){\n    printExp(car(toList(arguments)));\n  }else{\n    printExp(arguments);\n  }\n  return &sNull;\n}", "path": "src\\proc.c", "repo_name": "tkmr/tonburi-scm", "stars": 2, "license": "None", "language": "c", "size": 744}
{"docstring": "/* int MouseButton.getState(void) */\n", "func_signal": "METHOD MouseButton_getState(Ctx *ctx, knh_sfp_t *sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_MouseButtonEvent *button = (SDL_MouseButtonEvent *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, button->state);\n}", "path": "sdl\\sdl_mouse.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void SDL.init(int flags) */\n", "func_signal": "METHOD SDL_init(Ctx* ctx,knh_sfp_t* sfp)", "code": "{\n  int flags = p_int(sfp[1]);\n  if(SDL_Init((Uint32)flags) == -1){\n    fprintf(stderr,\"initialize error %s\\n\",SDL_GetError());\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int KeyBoard.getType(void) */\n", "func_signal": "METHOD KeyBoard_getType(Ctx *ctx, knh_sfp_t* sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_KeyboardEvent *key = (SDL_KeyboardEvent *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, key->type);\n}", "path": "sdl\\sdl_keyboard.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void SDL.getError */\n", "func_signal": "METHOD SDL_getError(Ctx* ctx,knh_sfp_t* sfp)", "code": "{\n  printf(\"%s\\n\",SDL_GetError());\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void SDL.wasInit(int flags) */\n", "func_signal": "METHOD SDL_wasInit(Ctx* ctx,knh_sfp_t* sfp)", "code": "{\n  int flags = p_int(sfp[1]);\n  if(SDL_WasInit(flags)!=0){\n    printf(\"It is initialized\\n\");\n  } else {\n    printf(\"It is not initialized\\n\");\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void String.wmGetCaption(String title) */\n", "func_signal": "METHOD String_wmGetCaption(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  char* title = p_char(sfp[0]);\n  SDL_WM_GetCaption(&title,&title);\n  if(title){\n    printf(\"Title was set to: %s\\n\",title);\n  } else {\n    printf(\"No window title was set !\\n\");\n  }\n\n  KNH_RETURN_void(ctx, sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int MouseMotion.getState(void) */\n", "func_signal": "METHOD MouseMotion_getState(Ctx *ctx, knh_sfp_t *sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_MouseMotionEvent *motion = (SDL_MouseMotionEvent *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, motion->state);\n}", "path": "sdl\\sdl_mouse.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int Surface.mapRGB(int red, int green, int blue) */\n", "func_signal": "METHOD Surface_mapRGB(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  SDL_Surface *screen = ((sfp[0].glue)->ptr);\n  Uint8 red = p_int(sfp[1]);\n  Uint8 green = p_int(sfp[2]);\n  Uint8 blue = p_int(sfp[3]);\n  Uint32 ret ;\n  ret = SDL_MapRGB(screen->format, red, green, blue);\n\n  KNH_RETURN_Int(ctx, sfp, ret);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int MouseButton.getY(void) */\n", "func_signal": "METHOD MouseButton_getY(Ctx *ctx, knh_sfp_t *sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_MouseButtonEvent *button = (SDL_MouseButtonEvent *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, button->y);\n}", "path": "sdl\\sdl_mouse.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void SDL.wmSetIcon(Surface icon, int mask) */\n", "func_signal": "METHOD SDL_wmSetIcon(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  SDL_Surface* icon = ((sfp[1].glue)->ptr);\n  Uint8 mask = p_int(sfp[2]);\n  SDL_WM_SetIcon(icon, &mask);\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void Surface.getClipRect(self, Rect rect) */\n", "func_signal": "METHOD Surface_getClipRect(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  SDL_Surface *screen = ((sfp[0].glue)->ptr);\n  SDL_Rect *rect = ((sfp[1].glue)->ptr);\n  SDL_GetClipRect(screen, rect);\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* Surface SDL.getVideoSurface() */\n", "func_signal": "METHOD SDL_getVideoSurface(Ctx* ctx,knh_sfp_t *sfp)", "code": "{\n  SDL_Surface* ret;\n  ret = SDL_GetVideoSurface();\n\n  KNH_RETURN(ctx,sfp,new_Glue(ctx,\"sdl.Surface\",ret,NULL));\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int KeySym.getUniCode(void) */\n", "func_signal": "METHOD KeySym_getUniCode(Ctx *ctx, knh_sfp_t* sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_keysym *sym = (SDL_keysym *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, sym->unicode);\n}", "path": "sdl\\sdl_keyboard.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void Suface.saveBMP(self, String file) */\n", "func_signal": "METHOD Surface_saveBMP(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  SDL_Surface* self = ((sfp[0].glue)->ptr);\n  char* file = p_char(sfp[1]);\n  if(SDL_SaveBMP(self, file) == -1){\n    fprintf(stderr,\"%s\\n\",SDL_GetError());\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* int MouseMotion.getYrel(void) */\n", "func_signal": "METHOD MouseMotion_getYrel(Ctx *ctx, knh_sfp_t *sfp)", "code": "{\n  knh_Glue_t *glue = sfp[0].glue;\n  SDL_MouseMotionEvent *motion = (SDL_MouseMotionEvent *)(glue->ptr);\n  KNH_RETURN_Int(ctx, sfp, motion->yrel);\n}", "path": "sdl\\sdl_mouse.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* VideoInfo SDL.getVideoInfo() */\n", "func_signal": "METHOD SDL_getVideoInfo(Ctx* ctx,knh_sfp_t *sfp)", "code": "{\n  SDL_VideoInfo* ret;\n  ret = SDL_GetVideoInfo();\n\n  KNH_RETURN(ctx,sfp,new_Glue(ctx,\"sdl.VideoInfo\",ret,NULL));\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* Grubmode SDL.wmGrabInput(Grubmod grabmode) */\n", "func_signal": "METHOD SDL_wmGrabInput(Ctx* ctx, knh_sfp_t *sfp)", "code": "{\n  int grabmode = p_int(sfp[1]);\n  int ret = SDL_WM_GrabInput(grabmode);\n\n  KNH_RETURN_Int(ctx, sfp, ret);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void Surface.setAlpha(self, int flag, int alpha) */\n", "func_signal": "METHOD Surface_setAlpha(Ctx* ctx,knh_sfp_t *sfp)", "code": "{\n  SDL_Surface* self = ((sfp[0].glue)->ptr);\n  Uint32 flag = p_int(sfp[1]);\n  Uint8 alpha = p_int(sfp[2]);\n  if(SDL_SetAlpha(self, flag, alpha) == -1){\n    fprintf(stderr,\"%s\\n\",SDL_GetError());\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void SDL.videoModeOK(int width, int height, int bpp, int flags) */\n", "func_signal": "METHOD SDL_videoModeOK(Ctx* ctx,knh_sfp_t *sfp)", "code": "{\n  int width = p_int(sfp[1]);\n  int height = p_int(sfp[2]);\n  int bpp = p_int(sfp[3]);\n  int flags = p_int(sfp[4]);\n  int chk = SDL_VideoModeOK(width, height, bpp, flags);\n  if(chk == 0){\n    printf(\"Unusable mode\\n\");\n  } else {\n    printf(\"Reccommend %dbpp\\n\",chk);\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* void Surface.blitSurface(self, Surface screen) */\n", "func_signal": "METHOD Surface_blitSurface(Ctx* ctx,knh_sfp_t *sfp)", "code": "{\n\n  SDL_Surface *self = (SDL_Surface*)((sfp[0].glue)->ptr);\n  knh_sdl_rect_t* rect1 = (knh_sdl_rect_t*)((sfp[1].glue)->ptr);\n  SDL_Surface *screen = (SDL_Surface*)((sfp[2].glue)->ptr);\n  knh_sdl_rect_t* rect2 = (knh_sdl_rect_t*)((sfp[3].glue)->ptr);\n  SDL_Rect srcrect;\n  SDL_Rect dstrect;\n  srcrect.x = (Sint16)rect1->x;\n  srcrect.y = (Sint16)rect1->y;\n  srcrect.w = (Uint16)rect1->w;\n  srcrect.h = (Uint16)rect1->h;\n  dstrect.x = (Sint16)rect2->x;\n  dstrect.y = (Sint16)rect2->y;\n  dstrect.w = (Uint16)rect2->w;\n  dstrect.h = (Uint16)rect2->h;\n  if(SDL_BlitSurface(self, &srcrect, screen, &dstrect) != 0){\n    fprintf(stderr,\"%s\\n\",SDL_GetError());\n  }\n\n  KNH_RETURN_void(ctx,sfp);\n}", "path": "sdl\\sdl.c", "repo_name": "kenigarashi/myprivate", "stars": 2, "license": "None", "language": "c", "size": 380}
{"docstring": "/* return angle difference */\n", "func_signal": "static double\ndiffa(double a1, double a2)", "code": "{\n    double da = fmod(a2 - a1, 2 * M_PI);\n    if (da < 0)\n\tda += 2 * M_PI;\n    if (da > M_PI)\n\tda -= 2 * M_PI;\n    return da;\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * send the ALPS init sequence, ie 4 consecutive \"disable\"s before the \"enable\"\n * This \"magic knock\" is performed both for the trackpad and for the pointing\n * stick. Not all models have a pointing stick, but trying to initialize it\n * anyway doesn't seem to hurt.\n */\n", "func_signal": "static void\nALPS_initialize(int fd)", "code": "{\n    xf86FlushInput(fd);\n    ps2_putbyte(fd, PS2_CMD_SET_DEFAULT);\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_2_1);\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_2_1);\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_2_1);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_ENABLE);\n\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_1_1);\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_1_1);\n    ps2_putbyte(fd, PS2_CMD_SET_SCALING_1_1);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_DISABLE);\n    ps2_putbyte(fd, PS2_CMD_ENABLE);\n\n    ALPS_sync(fd);\n}", "path": "src\\alpscomm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Set the synaptics touchpad mode byte by special commands\n */\n", "func_signal": "static Bool\nps2_synaptics_set_mode(int fd, byte mode)", "code": "{\n    PS2DBG(ErrorF(\"set mode byte to: 0x%02X\\n\", mode));\n    return (ps2_special_cmd(fd, mode) &&\n\t    ps2_putbyte(fd, PS2_CMD_SET_SAMPLE_RATE) &&\n\t    ps2_putbyte(fd, 0x14));\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Free SynapticsSHM data previously allocated by alloc_param_data().\n */\n", "func_signal": "static void\nfree_param_data(SynapticsPrivate *priv)", "code": "{\n    int shmid;\n\n    if (!priv->synpara)\n\treturn;\n\n    if (priv->shm_config) {\n\tif ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)\n\t    shmctl(shmid, IPC_RMID, NULL);\n    } else {\n\txfree(priv->synpara);\n    }\n\n    priv->synpara = NULL;\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Read the capability-bits from the touchpad\n * see also the SYN_CAP_* macros\n */\n", "func_signal": "static Bool\nps2_synaptics_capability(int fd, struct SynapticsHwInfo *synhw)", "code": "{\n    byte cap[3];\n\n    PS2DBG(ErrorF(\"Read capabilites...\\n\"));\n\n    synhw->capabilities = 0;\n    synhw->ext_cap = 0;\n    if (ps2_send_cmd(fd, SYN_QUE_CAPABILITIES) &&\n\tps2_getbyte(fd, &cap[0]) &&\n\tps2_getbyte(fd, &cap[1]) &&\n\tps2_getbyte(fd, &cap[2])) {\n\tsynhw->capabilities = (cap[0] << 16) | (cap[1] << 8) | cap[2];\n\tPS2DBG(ErrorF(\"capabilities %06X\\n\", synhw->capabilities));\n\tif (SYN_CAP_VALID(*synhw)) {\n\t    if (SYN_EXT_CAP_REQUESTS(*synhw)) {\n\t\tif (ps2_send_cmd(fd, SYN_QUE_EXT_CAPAB) &&\n\t\t    ps2_getbyte(fd, &cap[0]) &&\n\t\t    ps2_getbyte(fd, &cap[1]) &&\n\t\t    ps2_getbyte(fd, &cap[2])) {\n\t\t    synhw->ext_cap = (cap[0] << 16) | (cap[1] << 8) | cap[2];\n\t\t    PS2DBG(ErrorF(\"ext-capability %06X\\n\", synhw->ext_cap));\n\t\t} else {\n\t\t    PS2DBG(ErrorF(\"synaptics says, that it has extended-capabilities, \"\n\t\t\t\t  \"but I cannot read them.\"));\n\t\t}\n\t    }\n\t    PS2DBG(ErrorF(\"...done.\\n\"));\n\t    return TRUE;\n\t}\n    }\n    PS2DBG(ErrorF(\"...failed.\\n\"));\n    return FALSE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n *  Uninitialize the device.\n */\n", "func_signal": "static void SynapticsUnInit(InputDriverPtr drv,\n                            InputInfoPtr   local,\n                            int            flags)", "code": "{\n    xfree(local->private);\n    local->private = NULL;\n    xf86DeleteInput(local, 0);\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/* return angle of point relative to center */\n", "func_signal": "static double\nangle(SynapticsPrivate *priv, int x, int y)", "code": "{\n    double xCenter = (priv->synpara->left_edge + priv->synpara->right_edge) / 2.0;\n    double yCenter = (priv->synpara->top_edge + priv->synpara->bottom_edge) / 2.0;\n\n    return atan2(-(y - yCenter), x - xCenter);\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Send a command to the synpatics touchpad by special commands\n */\n", "func_signal": "static Bool\nps2_send_cmd(int fd, byte c)", "code": "{\n    PS2DBG(ErrorF(\"send command: 0x%02X\\n\", c));\n    return (ps2_special_cmd(fd, c) &&\n\t    ps2_putbyte(fd, PS2_CMD_STATUS_REQUEST));\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Read a byte from the ps/2 port\n */\n", "func_signal": "static Bool\nps2_getbyte(int fd, byte *b)", "code": "{\n    if (xf86WaitForInput(fd, 50000) > 0) {\n\tif (xf86ReadSerial(fd, b, 1) != 1) {\n\t    PS2DBG(ErrorF(\"ps2_getbyte: No byte read\\n\"));\n\t    return FALSE;\n\t}\n\tPS2DBG(ErrorF(\"ps2_getbyte: byte %02X read\\n\", *b));\n\treturn TRUE;\n    }\n    PS2DBG(ErrorF(\"ps2_getbyte: timeout xf86WaitForInput\\n\"));\n    return FALSE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Decide if the current packet stored in priv->protoBuf is valid.\n */\n", "func_signal": "static Bool\nps2_packet_ok(struct SynapticsHwInfo *synhw, struct CommData *comm)", "code": "{\n    unsigned char *buf = comm->protoBuf;\n    int newabs = SYN_MODEL_NEWABS(*synhw);\n\n    if (newabs ? ((buf[0] & 0xC0) != 0x80) : ((buf[0] & 0xC0) != 0xC0)) {\n\tDBG(4, ErrorF(\"Synaptics driver lost sync at 1st byte\\n\"));\n\treturn FALSE;\n    }\n\n    if (!newabs && ((buf[1] & 0x60) != 0x00)) {\n\tDBG(4, ErrorF(\"Synaptics driver lost sync at 2nd byte\\n\"));\n\treturn FALSE;\n    }\n\n    if ((newabs ? ((buf[3] & 0xC0) != 0xC0) : ((buf[3] & 0xC0) != 0x80))) {\n\tDBG(4, ErrorF(\"Synaptics driver lost sync at 4th byte\\n\"));\n\treturn FALSE;\n    }\n\n    if (!newabs && ((buf[4] & 0x60) != 0x00)) {\n\tDBG(4, ErrorF(\"Synaptics driver lost sync at 5th byte\\n\"));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Identify Touchpad\n * See also the SYN_ID_* macros\n */\n", "func_signal": "static Bool\npsm_synaptics_identify(int fd, synapticshw_t *ident)", "code": "{\n    int ret;\n\n    SYSCALL(ret = ioctl(fd, MOUSE_SYN_GETHWINFO, ident));\n    if (ret == 0)\n\treturn TRUE;\n    else\n\treturn FALSE;\n}", "path": "src\\psmcomm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Identify Touchpad\n * See also the SYN_ID_* macros\n */\n", "func_signal": "static Bool\nps2_synaptics_identify(int fd, struct SynapticsHwInfo *synhw)", "code": "{\n    byte id[3];\n\n    PS2DBG(ErrorF(\"Identify Touchpad...\\n\"));\n\n    synhw->identity = 0;\n    if (ps2_send_cmd(fd, SYN_QUE_IDENTIFY) &&\n\tps2_getbyte(fd, &id[0]) &&\n\tps2_getbyte(fd, &id[1]) &&\n\tps2_getbyte(fd, &id[2])) {\n\tsynhw->identity = (id[0] << 16) | (id[1] << 8) | id[2];\n\tPS2DBG(ErrorF(\"ident %06X\\n\", synhw->identity));\n\tif (SYN_ID_IS_SYNAPTICS(*synhw)) {\n\t    PS2DBG(ErrorF(\"...done.\\n\"));\n\t    return TRUE;\n\t}\n    }\n    PS2DBG(ErrorF(\"...failed.\\n\"));\n    return FALSE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n *  called for each full received packet from the touchpad\n */\n", "func_signal": "static void\nReadInput(LocalDevicePtr local)", "code": "{\n    SynapticsPrivate *priv = (SynapticsPrivate *) (local->private);\n    struct SynapticsHwState hw;\n    int delay = 0;\n    Bool newDelay = FALSE;\n\n    while (SynapticsGetHwState(local, priv, &hw)) {\n\thw.millis = GetTimeInMillis();\n\tpriv->hwState = hw;\n\tdelay = HandleState(local, &hw);\n\tnewDelay = TRUE;\n    }\n\n    if (newDelay)\n\tpriv->timer = TimerSet(priv->timer, 0, delay, timerFunc, local);\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Convert from absolute X/Y coordinates to a coordinate system where\n * -1 corresponds to the left/upper edge and +1 corresponds to the\n * right/lower edge.\n */\n", "func_signal": "static void\nrelative_coords(SynapticsPrivate *priv, int x, int y,\n\t\tdouble *relX, double *relY)", "code": "{\n    int minX = priv->synpara->left_edge;\n    int maxX = priv->synpara->right_edge;\n    int minY = priv->synpara->top_edge;\n    int maxY = priv->synpara->bottom_edge;\n    double xCenter = (minX + maxX) / 2.0;\n    double yCenter = (minY + maxY) / 2.0;\n\n    if ((maxX - xCenter > 0) && (maxY - yCenter > 0)) {\n\t*relX = (x - xCenter) / (maxX - xCenter);\n\t*relY = (y - yCenter) / (maxY - yCenter);\n    } else {\n\t*relX = 0;\n\t*relY = 0;\n    }\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n *  called by the module loader for initialization\n */\n", "func_signal": "static InputInfoPtr\nSynapticsPreInit(InputDriverPtr drv, IDevPtr dev, int flags)", "code": "{\n    LocalDevicePtr local;\n    SynapticsPrivate *priv;\n\n    /* allocate memory for SynapticsPrivateRec */\n    priv = xcalloc(1, sizeof(SynapticsPrivate));\n    if (!priv)\n\treturn NULL;\n\n    /* Allocate a new InputInfoRec and add it to the head xf86InputDevs. */\n    local = xf86AllocateInput(drv, 0);\n    if (!local) {\n\txfree(priv);\n\treturn NULL;\n    }\n\n    /* initialize the InputInfoRec */\n    local->name                    = dev->identifier;\n    local->type_name               = XI_TOUCHPAD;\n    local->device_control          = DeviceControl;\n    local->read_input              = ReadInput;\n    local->control_proc            = ControlProc;\n    local->close_proc              = CloseProc;\n    local->switch_mode             = SwitchMode;\n    local->conversion_proc         = ConvertProc;\n    local->reverse_conversion_proc = NULL;\n    local->dev                     = NULL;\n    local->private                 = priv;\n    local->private_flags           = 0;\n    local->flags                   = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;\n    local->conf_idev               = dev;\n#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0\n    local->motion_history_proc     = xf86GetMotionEvents;\n    local->history_size            = 0;\n#endif\n    local->always_core_feedback    = 0;\n\n    xf86Msg(X_INFO, \"Synaptics touchpad driver version %s\\n\", PACKAGE_VERSION);\n\n    xf86CollectInputOptions(local, NULL, NULL);\n\n    xf86OptionListReport(local->options);\n\n    /* may change local->options */\n    SetDeviceAndProtocol(local);\n\n    /* open the touchpad device */\n    local->fd = xf86OpenSerial(local->options);\n    if (local->fd == -1) {\n\txf86Msg(X_ERROR, \"Synaptics driver unable to open device\\n\");\n\tgoto SetupProc_fail;\n    }\n    xf86ErrorFVerb(6, \"port opened successfully\\n\");\n\n    /* initialize variables */\n    priv->timer = NULL;\n    priv->repeatButtons = 0;\n    priv->nextRepeat = 0;\n    priv->count_packet_finger = 0;\n    priv->tap_state = TS_START;\n    priv->tap_button = 0;\n    priv->tap_button_state = TBS_BUTTON_UP;\n    priv->touch_on.millis = 0;\n\n    /* read hardware dimensions */\n    ReadDevDimensions(local);\n\n    /* install shared memory or normal memory for parameters */\n    priv->shm_config = xf86SetBoolOption(local->options, \"SHMConfig\", FALSE);\n\n    set_default_parameters(local);\n\n    priv->largest_valid_x = MIN(priv->synpara_default.right_edge, XMAX_NOMINAL);\n\n    if (!alloc_param_data(local))\n\tgoto SetupProc_fail;\n\n    priv->comm.buffer = XisbNew(local->fd, 200);\n    DBG(9, XisbTrace(priv->comm.buffer, 1));\n\n    if (!QueryHardware(local)) {\n\txf86Msg(X_ERROR, \"%s Unable to query/initialize Synaptics hardware.\\n\", local->name);\n\tgoto SetupProc_fail;\n    }\n\n#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0\n    local->history_size = xf86SetIntOption(opts, \"HistorySize\", 0);\n#endif\n\n    xf86ProcessCommonOptions(local, local->options);\n    local->flags |= XI86_CONFIGURED;\n\n    if (local->fd != -1) {\n\tif (priv->comm.buffer) {\n\t    XisbFree(priv->comm.buffer);\n\t    priv->comm.buffer = NULL;\n\t}\n\txf86CloseSerial(local->fd);\n    }\n    local->fd = -1;\n\n    return local;\n\n SetupProc_fail:\n    if (local->fd >= 0) {\n\txf86CloseSerial(local->fd);\n\tlocal->fd = -1;\n    }\n\n    if (priv->comm.buffer)\n\tXisbFree(priv->comm.buffer);\n    free_param_data(priv);\n    xfree(priv);\n    local->private = NULL;\n    return local;\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Use the Synaptics extended ps/2 syntax to write a special command byte. Needed by\n * ps2_send_cmd and ps2_set_mode.\n * special command: 0xE8 rr 0xE8 ss 0xE8 tt 0xE8 uu where (rr*64)+(ss*16)+(tt*4)+uu\n *                  is the command. A 0xF3 or 0xE9 must follow (see ps2_send_cmd, ps2_set_mode)\n */\n", "func_signal": "static Bool\nps2_special_cmd(int fd, byte cmd)", "code": "{\n    int i;\n\n    /* initialize with 'inert' command */\n    if (!ps2_putbyte(fd, PS2_CMD_SET_SCALING_1_1))\n\treturn FALSE;\n\n    /* send 4x 2-bits with set resolution command */\n    for (i = 0; i < 4; i++) {\n\tif (!ps2_putbyte(fd, PS2_CMD_SET_RESOLUTION) ||\n\t    !ps2_putbyte(fd, (cmd >> 6) & 0x3))\n\t    return FALSE;\n\tcmd <<= 2;\n    }\n    return TRUE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Allocate and initialize memory for the SynapticsSHM data to hold driver\n * parameter settings.\n * The function will allocate shared memory if priv->shm_config is TRUE.\n * The allocated data is initialized from priv->synpara_default.\n */\n", "func_signal": "static Bool\nalloc_param_data(LocalDevicePtr local)", "code": "{\n    int shmid;\n    SynapticsPrivate *priv = local->private;\n\n    if (priv->synpara)\n\treturn TRUE;\t\t\t    /* Already allocated */\n\n    if (priv->shm_config) {\n\tif ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)\n\t    shmctl(shmid, IPC_RMID, NULL);\n\tif ((shmid = shmget(SHM_SYNAPTICS, sizeof(SynapticsSHM),\n\t\t\t\t0777 | IPC_CREAT)) == -1) {\n\t    xf86Msg(X_ERROR, \"%s error shmget\\n\", local->name);\n\t    return FALSE;\n\t}\n\tif ((priv->synpara = (SynapticsSHM*)shmat(shmid, NULL, 0)) == NULL) {\n\t    xf86Msg(X_ERROR, \"%s error shmat\\n\", local->name);\n\t    return FALSE;\n\t}\n    } else {\n\tpriv->synpara = xcalloc(1, sizeof(SynapticsSHM));\n\tif (!priv->synpara)\n\t    return FALSE;\n    }\n\n    *(priv->synpara) = priv->synpara_default;\n    return TRUE;\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * Read the model-id bytes from the touchpad\n * see also SYN_MODEL_* macros\n */\n", "func_signal": "static Bool\nps2_synaptics_model_id(int fd, struct SynapticsHwInfo *synhw)", "code": "{\n    byte mi[3];\n\n    PS2DBG(ErrorF(\"Read mode id...\\n\"));\n\n    synhw->model_id = 0;\n    if (ps2_send_cmd(fd, SYN_QUE_MODEL) &&\n\tps2_getbyte(fd, &mi[0]) &&\n\tps2_getbyte(fd, &mi[1]) &&\n\tps2_getbyte(fd, &mi[2])) {\n\tsynhw->model_id = (mi[0] << 16) | (mi[1] << 8) | mi[2];\n\tPS2DBG(ErrorF(\"mode-id %06X\\n\", synhw->model_id));\n\tPS2DBG(ErrorF(\"...done.\\n\"));\n\treturn TRUE;\n    }\n    PS2DBG(ErrorF(\"...failed.\\n\"));\n    return FALSE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * React on changes in the hardware state. This function is called every time\n * the hardware state changes. The return value is used to specify how many\n * milliseconds to wait before calling the function again if no state change\n * occurs.\n */\n", "func_signal": "static int\nHandleState(LocalDevicePtr local, struct SynapticsHwState *hw)", "code": "{\n    SynapticsPrivate *priv = (SynapticsPrivate *) (local->private);\n    SynapticsSHM *para = priv->synpara;\n    int finger;\n    int dx, dy, buttons, rep_buttons, id;\n    edge_type edge;\n    int change;\n    struct ScrollData scroll;\n    int double_click, repeat_delay;\n    int delay = 1000000000;\n    int timeleft;\n    int i;\n\n    /* update hardware state in shared memory */\n    para->x = hw->x;\n    para->y = hw->y;\n    para->z = hw->z;\n    para->numFingers = hw->numFingers;\n    para->fingerWidth = hw->fingerWidth;\n    para->left = hw->left;\n    para->right = hw->right;\n    para->up = hw->up;\n    para->down = hw->down;\n    for (i = 0; i < 8; i++)\n\tpara->multi[i] = hw->multi[i];\n    para->middle = hw->middle;\n    para->guest_left = hw->guest_left;\n    para->guest_mid = hw->guest_mid;\n    para->guest_right = hw->guest_right;\n    para->guest_dx = hw->guest_dx;\n    para->guest_dy = hw->guest_dy;\n\n    /* If touchpad is switched off, we skip the whole thing and return delay */\n    if (para->touchpad_off == 1)\n\treturn delay;\n\n    /* Treat the first two multi buttons as up/down for now. */\n    hw->up |= hw->multi[0];\n    hw->down |= hw->multi[1];\n\n    if (!para->guestmouse_off) {\n\thw->left |= hw->guest_left;\n\thw->middle |= hw->guest_mid;\n\thw->right |= hw->guest_right;\n    }\n\n    /* 3rd button emulation */\n    hw->middle |= HandleMidButtonEmulation(priv, hw, &delay);\n\n    /* Fingers emulate other buttons */\n    if(hw->left && hw->numFingers >= 1){\n        HandleClickWithFingers(para, hw);\n    }\n\n    /* Two finger emulation */\n    if (hw->z >= para->emulate_twofinger_z && hw->numFingers == 1) {\n\thw->numFingers = 2;\n    }\n\n    /* Fingers emulate other buttons */\n    if(hw->left && hw->numFingers >= 1){\n        HandleClickWithFingers(para, hw);\n    }\n\n    /* Up/Down button scrolling or middle/double click */\n    double_click = FALSE;\n    if (!para->updown_button_scrolling) {\n\tif (hw->down) {\t\t/* map down button to middle button */\n\t    hw->middle = TRUE;\n\t}\n\n\tif (hw->up) {\t\t/* up button generates double click */\n\t    if (!priv->prev_up)\n\t\tdouble_click = TRUE;\n\t}\n\tpriv->prev_up = hw->up;\n\n\t/* reset up/down button events */\n\thw->up = hw->down = FALSE;\n    }\n\n    /* Left/right button scrolling, or middle clicks */\n    if (!para->leftright_button_scrolling) {\n\tif (hw->multi[2] || hw->multi[3])\n\t    hw->middle = TRUE;\n\n\t/* reset left/right button events */\n\thw->multi[2] = hw->multi[3] = FALSE;\n    }\n\n    /*\n     * Some touchpads have a scroll wheel region where a very large X\n     * coordinate is reported. \n     *\n     *    We suggest two  solution this problem:\n     */\n    if (hw->x <= XMAX_VALID) {\n\tif (priv->largest_valid_x < hw->x)\n\t    priv->largest_valid_x = hw->x;\n    } else {\n      if (!(para->special_scroll_area_right))\n      /*               First:\n      * Adjust the X coordinate to eliminate the discontinuity \n      * and use it region as 1 coordinate size line.\n      */\n\thw->x = priv->largest_valid_x + 1;\n      else {\n      /*               Second (default):\n       * Adjust the X coordinate to eliminate the discontinuity\n       * and use it region as scroll area automaticly.\n       */\t\n\t\n\tif (priv->synpara->right_edge > priv->largest_valid_x + 1)\n\t  priv->synpara->right_edge=priv->largest_valid_x + 1;\n\tpara->special_scroll_area_right = FALSE;\n       \n\thw->x = priv->largest_valid_x + 1;\n      }\n    }\n\n    edge = edge_detection(priv, hw->x, hw->y);\n    edge = HandleEdgeOrientation(para->orientation, edge);\n\n    finger = SynapticsDetectFinger(priv, hw);\n\n    /* tap and drag detection */\n    timeleft = HandleTapProcessing(priv, hw, edge, finger);\n    if (timeleft > 0)\n\tdelay = MIN(delay, timeleft);\n\n    timeleft = HandleScrolling(priv, hw, edge, finger, &scroll);\n    if (timeleft > 0)\n\tdelay = MIN(delay, timeleft);\n\n    timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy);\n    delay = MIN(delay, timeleft);\n\n    rep_buttons = ((para->updown_button_repeat ? 0x18 : 0) |\n\t\t   (para->leftright_button_repeat ? 0x60 : 0));\n\n    buttons = ((hw->left     ? 0x01 : 0) |\n\t       (hw->middle   ? 0x02 : 0) |\n\t       (hw->right    ? 0x04 : 0) |\n\t       (hw->up       ? 0x08 : 0) |\n\t       (hw->down     ? 0x10 : 0) |\n\t       (hw->multi[2] ? 0x20 : 0) |\n\t       (hw->multi[3] ? 0x40 : 0));\n\n    if (priv->tap_button > 0) {\n\tint tap_mask = 1 << (priv->tap_button - 1);\n\tif (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {\n\t    if (tap_mask != (priv->lastButtons & tap_mask)) {\n\t\txf86PostButtonEvent(local->dev, FALSE, priv->tap_button, TRUE, 0, 0);\n\t\tpriv->lastButtons |= tap_mask;\n\t    }\n\t    priv->tap_button_state = TBS_BUTTON_UP;\n\t}\n\tif (priv->tap_button_state == TBS_BUTTON_DOWN)\n\t    buttons |= tap_mask;\n    }\n\n    /* Post events */\n    if (dx || dy)\n\txf86PostMotionEvent(local->dev, 0, 0, 2, dx, dy);\n\n    if (priv->mid_emu_state == MBE_LEFT_CLICK)\n    {\n\txf86PostButtonEvent(local->dev, FALSE, 1, 1, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 1, 0, 0, 0);\n\tpriv->mid_emu_state = MBE_OFF;\n    } else if (priv->mid_emu_state == MBE_RIGHT_CLICK)\n    {\n\txf86PostButtonEvent(local->dev, FALSE, 3, 1, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 3, 0, 0, 0);\n\tpriv->mid_emu_state = MBE_OFF;\n    }\n\n    change = buttons ^ priv->lastButtons;\n    while (change) {\n\tid = ffs(change); /* number of first set bit 1..32 is returned */\n\tchange &= ~(1 << (id - 1));\n\txf86PostButtonEvent(local->dev, FALSE, id, (buttons & (1 << (id - 1))), 0, 0);\n    }\n\n    while (scroll.up-- > 0) {\n\txf86PostButtonEvent(local->dev, FALSE, 4, !hw->up, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 4, hw->up, 0, 0);\n    }\n    while (scroll.down-- > 0) {\n\txf86PostButtonEvent(local->dev, FALSE, 5, !hw->down, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 5, hw->down, 0, 0);\n    }\n    while (scroll.left-- > 0) {\n\txf86PostButtonEvent(local->dev, FALSE, 6, TRUE, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 6, FALSE, 0, 0);\n    }\n    while (scroll.right-- > 0) {\n\txf86PostButtonEvent(local->dev, FALSE, 7, TRUE, 0, 0);\n\txf86PostButtonEvent(local->dev, FALSE, 7, FALSE, 0, 0);\n    }\n    if (double_click) {\n\tint i;\n\tfor (i = 0; i < 2; i++) {\n\t    xf86PostButtonEvent(local->dev, FALSE, 1, !hw->left, 0, 0);\n\t    xf86PostButtonEvent(local->dev, FALSE, 1, hw->left, 0, 0);\n\t}\n    }\n\n    /* Handle auto repeat buttons */\n    repeat_delay = clamp(para->scroll_button_repeat, SBR_MIN, SBR_MAX);\n    if (((hw->up || hw->down) && para->updown_button_repeat &&\n\t para->updown_button_scrolling) ||\n\t((hw->multi[2] || hw->multi[3]) && para->leftright_button_repeat &&\n\t para->leftright_button_scrolling)) {\n\tpriv->repeatButtons = buttons & rep_buttons;\n\tif (!priv->nextRepeat) {\n\t    priv->nextRepeat = hw->millis + repeat_delay * 2;\n\t}\n    } else {\n\tpriv->repeatButtons = 0;\n\tpriv->nextRepeat = 0;\n    }\n\n    if (priv->repeatButtons) {\n\ttimeleft = TIME_DIFF(priv->nextRepeat, hw->millis);\n\tif (timeleft > 0)\n\t    delay = MIN(delay, timeleft);\n\tif (timeleft <= 0) {\n\t    int change, id;\n\t    change = priv->repeatButtons;\n\t    while (change) {\n\t\tid = ffs(change);\n\t\tchange &= ~(1 << (id - 1));\n\t\txf86PostButtonEvent(local->dev, FALSE, id, FALSE, 0, 0);\n\t\txf86PostButtonEvent(local->dev, FALSE, id, TRUE, 0, 0);\n\t    }\n\n\t    priv->nextRepeat = hw->millis + repeat_delay;\n\t    delay = MIN(delay, repeat_delay);\n\t}\n    }\n\n    /* Save old values of some state variables */\n    priv->finger_state = finger;\n    priv->lastButtons = buttons;\n\n    return delay;\n}", "path": "src\\synaptics.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/*\n * reset the touchpad\n */\n", "func_signal": "static Bool\nps2_synaptics_reset(int fd)", "code": "{\n    byte r[2];\n\n    xf86FlushInput(fd);\n    PS2DBG(ErrorF(\"Reset the Touchpad...\\n\"));\n    if (!ps2_putbyte(fd, PS2_CMD_RESET)) {\n\tPS2DBG(ErrorF(\"...failed\\n\"));\n\treturn FALSE;\n    }\n    xf86WaitForInput(fd, 4000000);\n    if (ps2_getbyte(fd, &r[0]) && ps2_getbyte(fd, &r[1])) {\n\tif (r[0] == 0xAA && r[1] == 0x00) {\n\t    PS2DBG(ErrorF(\"...done\\n\"));\n\t    return TRUE;\n\t} else {\n\t    PS2DBG(ErrorF(\"...failed. Wrong reset ack 0x%02x, 0x%02x\\n\", r[0], r[1]));\n\t    return FALSE;\n\t}\n    }\n    PS2DBG(ErrorF(\"...failed\\n\"));\n    return FALSE;\n}", "path": "src\\ps2comm.c", "repo_name": "mildred/xorg-synaptics-orientation-patch", "stars": 2, "license": "mit", "language": "c", "size": 1180}
{"docstring": "/* Unpack the argument tuple */\n", "func_signal": "SWIGINTERN int\nSWIG_Python_UnpackTuple(PyObject *args, const char *name, int min, int max, PyObject **objs)", "code": "{\n  if (!args) {\n    if (!min && !max) {\n      return 1;\n    } else {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got none\", \n\t\t   name, (min == max ? \"\" : \"at least \"), min);\n      return 0;\n    }\n  }  \n  if (!PyTuple_Check(args)) {\n    PyErr_SetString(PyExc_SystemError, \"UnpackTuple() argument list is not a tuple\");\n    return 0;\n  } else {\n    register int l = PyTuple_GET_SIZE(args);\n    if (l < min) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at least \"), min, l);\n      return 0;\n    } else if (l > max) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at most \"), max, l);\n      return 0;\n    } else {\n      register int i;\n      for (i = 0; i < l; ++i) {\n\tobjs[i] = PyTuple_GET_ITEM(args, i);\n      }\n      for (; l < max; ++l) {\n\tobjs[l] = 0;\n      }\n      return i + 1;\n    }    \n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own)", "code": "{\n  if (!obj) return SWIG_ERROR;\n  if (obj == Py_None) {\n    if (ptr) *ptr = 0;\n    return SWIG_OK;\n  } else {\n    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);\n    while (sobj) {\n      void *vptr = sobj->ptr;\n      if (ty) {\n\tswig_type_info *to = sobj->ty;\n\tif (to == ty) {\n\t  /* no type cast needed */\n\t  if (ptr) *ptr = vptr;\n\t  break;\n\t} else {\n\t  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n\t  if (!tc) {\n\t    sobj = (PySwigObject *)sobj->next;\n\t  } else {\n\t    if (ptr) *ptr = SWIG_TypeCast(tc,vptr);\n\t    break;\n\t  }\n\t}\n      } else {\n\tif (ptr) *ptr = vptr;\n\tbreak;\n      }\n    }\n    if (sobj) {\n      if (own) *own = sobj->own;\n      if (flags & SWIG_POINTER_DISOWN) {\n\tsobj->own = 0;\n      }\n      return SWIG_OK;\n    } else {\n      int res = SWIG_ERROR;\n      if (flags & SWIG_POINTER_IMPLICIT_CONV) {\n\tPySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;\n\tif (data && !data->implicitconv) {\n\t  PyObject *klass = data->klass;\n\t  if (klass) {\n\t    PyObject *impconv;\n\t    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/\n\t    impconv = SWIG_Python_CallFunctor(klass, obj);\n\t    data->implicitconv = 0;\n\t    if (PyErr_Occurred()) {\n\t      PyErr_Clear();\n\t      impconv = 0;\n\t    }\n\t    if (impconv) {\n\t      PySwigObject *iobj = SWIG_Python_GetSwigThis(impconv);\n\t      if (iobj) {\n\t\tvoid *vptr;\n\t\tres = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);\n\t\tif (SWIG_IsOK(res)) {\n\t\t  if (ptr) {\n\t\t    *ptr = vptr;\n\t\t    /* transfer the ownership to 'ptr' */\n\t\t    iobj->own = 0;\n\t\t    res = SWIG_AddCast(res);\n\t\t    res = SWIG_AddNewMask(res);\n\t\t  } else {\n\t\t    res = SWIG_AddCast(res);\t\t    \n\t\t  }\n\t\t}\n\t      }\n\t      Py_DECREF(impconv);\n\t    }\n\t  }\n\t}\n      }\n      return res;\n    }\n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags)", "code": "{\n  if (!ptr) {\n    return SWIG_Py_Void();\n  } else {\n    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;\n    PyObject *robj = PySwigObject_New(ptr, type, own);\n    PySwigClientData *clientdata = type ? (PySwigClientData *)(type->clientdata) : 0;\n    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {\n      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);\n      if (inst) {\n\tPy_DECREF(robj);\n\trobj = inst;\n      }\n    }\n    return robj;\n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n  \n  if (init_run) return;\n  init_run = 1;\n  \n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* #define SWIG_PYTHON_SLOW_GETSET_THIS */\n", "func_signal": "SWIGRUNTIME PySwigObject *\nSWIG_Python_GetSwigThis(PyObject *pyobj)", "code": "{\n  if (PySwigObject_Check(pyobj)) {\n    return (PySwigObject *) pyobj;\n  } else {\n    PyObject *obj = 0;\n#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))\n    if (PyInstance_Check(pyobj)) {\n      obj = _PyInstance_Lookup(pyobj, SWIG_This());      \n    } else {\n      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);\n      if (dictptr != NULL) {\n\tPyObject *dict = *dictptr;\n\tobj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;\n      } else {\n#ifdef PyWeakref_CheckProxy\n\tif (PyWeakref_CheckProxy(pyobj)) {\n\t  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);\n\t  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;\n\t}\n#endif\n\tobj = PyObject_GetAttr(pyobj,SWIG_This());\n\tif (obj) {\n\t  Py_DECREF(obj);\n\t} else {\n\t  if (PyErr_Occurred()) PyErr_Clear();\n\t  return 0;\n\t}\n      }\n    }\n#else\n    obj = PyObject_GetAttr(pyobj,SWIG_This());\n    if (obj) {\n      Py_DECREF(obj);\n    } else {\n      if (PyErr_Occurred()) PyErr_Clear();\n      return 0;\n    }\n#endif\n    if (obj && !PySwigObject_Check(obj)) {\n      /* a PyObject is called 'this', try to get the 'real this'\n\t PySwigObject from it */ \n      return SWIG_Python_GetSwigThis(obj);\n    }\n    return (PySwigObject *)obj;\n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Append a value to the result obj */\n", "func_signal": "SWIGINTERN PyObject*\nSWIG_Python_AppendOutput(PyObject* result, PyObject* obj)", "code": "{\n#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyList_Check(result)) {\n      PyObject *o2 = result;\n      result = PyList_New(1);\n      PyList_SetItem(result, 0, o2);\n    }\n    PyList_Append(result,obj);\n    Py_DECREF(obj);\n  }\n  return result;\n#else\n  PyObject*   o2;\n  PyObject*   o3;\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyTuple_Check(result)) {\n      o2 = result;\n      result = PyTuple_New(1);\n      PyTuple_SET_ITEM(result, 0, o2);\n    }\n    o3 = PyTuple_New(1);\n    PyTuple_SET_ITEM(o3, 0, obj);\n    o2 = result;\n    result = PySequence_Concat(o2, o3);\n    Py_DECREF(o2);\n    Py_DECREF(o3);\n  }\n  return result;\n#endif\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* \n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (l1 - f1) - (l2 - f2);\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* \n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr)", "code": "{\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start, \n                     swig_module_info *end, \n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n  \n  /* neither found a match */\n  return 0;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* PyModule_AddObject function was introduced in Python 2.0.  The following function\n   is copied out of Python/modsupport.c in python version 2.3.4 */\n", "func_signal": "SWIGINTERN int\nPyModule_AddObject(PyObject *m, char *name, PyObject *o)", "code": "{\n  PyObject *dict;\n  if (!PyModule_Check(m)) {\n    PyErr_SetString(PyExc_TypeError,\n\t\t    \"PyModule_AddObject() needs module as first arg\");\n    return SWIG_ERROR;\n  }\n  if (!o) {\n    PyErr_SetString(PyExc_TypeError,\n\t\t    \"PyModule_AddObject() needs non-NULL value\");\n    return SWIG_ERROR;\n  }\n  \n  dict = PyModule_GetDict(m);\n  if (dict == NULL) {\n    /* Internal error -- modules must have a dict! */\n    PyErr_Format(PyExc_SystemError, \"module '%s' has no __dict__\",\n\t\t PyModule_GetName(m));\n    return SWIG_ERROR;\n  }\n  if (PyDict_SetItemString(dict, name, o))\n    return SWIG_ERROR;\n  Py_DECREF(o);\n  return SWIG_OK;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Convert a pointer value, signal an exception on a type mismatch */\n", "func_signal": "SWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags)", "code": "{\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n    if (flags & SWIG_POINTER_EXCEPTION) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n  }\n  return result;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Error manipulation */\n", "func_signal": "SWIGINTERN void \nSWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj)", "code": "{\n  SWIG_PYTHON_THREAD_BEGIN_BLOCK; \n  PyErr_SetObject(errtype, obj);\n  Py_DECREF(obj);\n  SWIG_PYTHON_THREAD_END_BLOCK;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty)", "code": "{\n  swig_type_info *to = PySwigPacked_UnpackData(obj, ptr, sz);\n  if (!to) return SWIG_ERROR;\n  if (ty) {\n    if (to != ty) {\n      /* check type cast? */\n      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n      if (!tc) return SWIG_ERROR;\n    }\n  }\n  return SWIG_OK;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type)", "code": "{\n  /* The \"str\" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == '|') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* The python void return value */\n", "func_signal": "SWIGRUNTIMEINLINE PyObject * \nSWIG_Py_Void(void)", "code": "{\n  PyObject *none = Py_None;\n  Py_INCREF(none);\n  return none;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* \n   Pack binary data into a string\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz)", "code": "{\n  static const char hex[17] = \"0123456789abcdef\";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* \n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n  \n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }    \n    cast = cast->next;\n  }\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start, \n                            swig_module_info *end, \n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1; \n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\t    \n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Set a constant value */\n", "func_signal": "SWIGINTERN void\nSWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj)", "code": "{   \n  PyDict_SetItemString(d, (char*) name, obj);\n  Py_DECREF(obj);                            \n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "/* Acquire a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_AcquirePtr(PyObject *obj, int own)", "code": "{\n  if (own) {\n    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);\n    if (sobj) {\n      int oldown = sobj->own;\n      sobj->own = own;\n      return oldown;\n    }\n  }\n  return 0;\n}", "path": "ruby_wrap.c", "repo_name": "valo/rubypython", "stars": 3, "license": "mit", "language": "c", "size": 263}
{"docstring": "// decrypt NOTICE messages (and forward DH1080 key-exchange)\n", "func_signal": "void decrypt_notice(SERVER_REC *server, char *msg, char *nick, char *address, char *target)", "code": "{\n\tchar *DH1024warn;\n\n\tif(strncmp(msg, \"DH1024_\", 7)==0)\n\t{\n\t\tDH1024warn = \"\\002FiSH:\\002 Received \\002old DH1024\\002 public key from you! Please update to latest version: http://fish.sekure.us\";\n\t\tsignal_stop();\n\t\tirc_send_cmdv((IRC_SERVER_REC *)server, \"NOTICE %s :%s\\n\", nick, DH1024warn);\n\t\tsignal_emit(\"message irc own_notice\", 3, server, DH1024warn, nick);\n\t\treturn;\n\t}\n\n\tif(strncmp(msg, \"DH1080_\", 7)==0)\n\t{\n\t\tDH1080_received(server, msg, nick, address, target);\n\t\treturn;\n\t}\n\n#ifdef FiSH_DECRYPT_ZNC_LOGS\n\tif(IsZNCtimestamp(msg)) msg += 11;\n#endif\n\n\tFiSH_decrypt(server, msg, msg, ischannel(*target) ? target : nick);\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// replace '[' and ']' from nick/channel with '~' (otherwise problems with .ini files)\n", "func_signal": "void FixIniSection(const char *section, char *fixedSection)", "code": "{\n\tif(section!=NULL)\n\t{\n\t\tstrncpy(fixedSection, section, CONTACT_SIZE);\n\t\tfixedSection[CONTACT_SIZE-1] = '\\0';\n\t}\n\n\twhile(*fixedSection != '\\0')\n\t{\n\t\tif((*fixedSection == '[') || (*fixedSection == ']')) *fixedSection='~';\n\t\tfixedSection++;\n\t}\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "/* init the SHA state */\n", "func_signal": "void sha_init(sha_state * md)", "code": "{\n    md->curlen = md->length = 0;\n    md->state[0] = 0x6A09E667U;\n    md->state[1] = 0xBB67AE85U;\n    md->state[2] = 0x3C6EF372U;\n    md->state[3] = 0xA54FF53AU;\n    md->state[4] = 0x510E527FU;\n    md->state[5] = 0x9B05688CU;\n    md->state[6] = 0x1F83D9ABU;\n    md->state[7] = 0x5BE0CD19U;\n}", "path": "SHA-256.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// perform auto-keyXchange only for known people\n", "func_signal": "void do_auto_keyx(QUERY_REC *query, int automatic)", "code": "{\n\tif(keyx_query_created)\n\t\treturn;\t// query was created by FiSH\n\n\tif(GetBlowIniSwitch(\"FiSH\", \"auto_keyxchange\", \"1\") == 0)\n\t\treturn;\n\n\tif(LoadKeyForContact(query->name, NULL))\n\t\tcmd_keyx(query->name, query->server, NULL);\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// format outgoing (encrypted) messages (add crypt-mark or remove plain-prefix)\n", "func_signal": "void format_msg(SERVER_REC *server, char *msg, char *target, char *orig_target)", "code": "{\n\tchar contactName[CONTACT_SIZE]=\"\", myMark[20]=\"\", markPos[20]=\"\", formattedMsg[800]=\"\";\n\tint i;\n\tchar *plainMsg;\n\n\n\tif(IsNULLorEmpty(msg) || IsNULLorEmpty(target)) return;\n\tif(GetBlowIniSwitch(\"FiSH\", \"process_outgoing\", \"1\") == 0) return;\n\tif(LoadKeyForContact(target, NULL)==FALSE) return;\n\n\n\tplainMsg = IsPlainPrefix(msg);\n\tif(plainMsg)\n\t{\n\t\tsignal_continue(4, server, plainMsg, target, orig_target);\n\t\treturn;\n\t}\n\n\n\t// generally cut a message to a size of 512 byte, as everything above will never arrive complete anyway\n\tif(strlen(msg) > 512) msg[512]='\\0';\n\n\n\t// append crypt-mark?\n\tFixIniSection(target, contactName);\t// replace '[' and ']' with '~' in contact name\n\tif(GetBlowIniSwitch(contactName, \"mark_encrypted\", \"1\") != 0)\n\t{\n\t\tGetPrivateProfileString(\"FiSH\", \"mark_encrypted\", \"\", myMark, sizeof(myMark), iniPath);\t// global setting\n\t\tif(*myMark != '\\0')\n\t\t{\n\t\t\tstrcpy(formattedMsg, msg);\n\n\t\t\tGetPrivateProfileString(\"FiSH\", \"mark_position\", \"0\", markPos, sizeof(markPos), iniPath);\n\t\t\tif(*markPos=='0') strcat(formattedMsg, myMark);\t\t//append mark at the end\n\t\t\telse\n\t\t\t{\t// prefix mark\n\t\t\t\ti=strlen(myMark);\n\t\t\t\tmemmove(formattedMsg+i, formattedMsg, strlen(formattedMsg)+1);\n\t\t\t\tstrncpy(formattedMsg, myMark, i);\n\t\t\t}\n\n\t\t\tsignal_continue(4, server, formattedMsg, target, orig_target);\n\n\t\t\tZeroMemory(formattedMsg, sizeof(formattedMsg));\n\t\t}\n\t}\n\n\treturn;\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// Input:  priv_key = buffer of 200 bytes\n//         pub_key  = buffer of 200 bytes\n// Output: priv_key = Your private key\n//         pub_key  = Your public key\n", "func_signal": "int DH1080_gen(char *priv_key, char *pub_key)", "code": "{\n\tunsigned char raw_buf[160];\n\tunsigned long seed;\n\tint len, iRet;\n\n\tmpz_t mpz_privkey, mpz_pubkey, mpz_base;\n\tgmp_randstate_t randstate;\n\n\tpriv_key[0]='0';\n\tpriv_key[1]='\\0';\n\tpub_key[0]='0';\n\tpub_key[1]='\\0';\n\n\tmpz_init(mpz_privkey);\n\tmpz_init(mpz_pubkey);\n\tmpz_init_set_ui(mpz_base, 2);\n\n\t// #*#*#*#*#* RNG START #*#*#*#*#*\n\ttime((time_t *)&seed);\n\n\tgmp_randinit_default(randstate);\n\tgmp_randseed_ui(randstate, seed);\n\tmpz_urandomb(mpz_privkey, randstate, 1080);\n\tgmp_randclear(randstate);\n\tseed=0;\n\t// #*#*#*#*#* RNG END #*#*#*#*#*\n\n\tmpz_powm(mpz_pubkey, mpz_base, mpz_privkey, mpz_prime);\n\n\tif(DH_verifyPubKey(mpz_pubkey))\n\t{\n\t\tmpz_export((void*)raw_buf, &len, 1, 1, 1, 0, mpz_privkey);\n\t\tmpz_clear(mpz_privkey);\n\n\t\tmpz_export((void*)raw_buf, &len, 1, 1, 1, 0, mpz_pubkey);\n\t\thtob64(raw_buf, pub_key, len);\n\n\t\tiRet=1;\n\t}\n\telse iRet=0;\n\n\tZeroMemory(raw_buf, sizeof(raw_buf));\n\n\tmpz_clear(mpz_pubkey);\n\tmpz_clear(mpz_prime);\n\n\treturn iRet;\n}", "path": "DH1080.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// Input:  MyPrivKey = Your private key\n//         HisPubKey = Someones public key\n// Output: MyPrivKey has been destroyed for security reasons\n//         HisPubKey = the secret key\n", "func_signal": "int DH1080_comp(char *MyPrivKey, char *HisPubKey)", "code": "{\n\tint i=0, len, iRet;\n\tunsigned char SHA256digest[35], base64_tmp[160];\n\tmpz_t mpz_myPrivkey, mpz_hisPubkey, mpz_prime, mpz_theKey;\n\n\t// Verify base64 strings\n\tif((strspn(MyPrivKey, B64ABC) != strlen(MyPrivKey)) || (strspn(HisPubKey, B64ABC) != strlen(HisPubKey)))\n\t{\n\t\tmemset(MyPrivKey, 0x20, strlen(MyPrivKey));\n\t\tmemset(HisPubKey, 0x20, strlen(HisPubKey));\n\t\treturn 0;\n\t}\n\n\tmpz_init(mpz_hisPubkey);\n\n\tlen=b64toh(HisPubKey, base64_tmp);\n\tmpz_import(mpz_hisPubkey, len, 1, 1, 1, 0, base64_tmp);\n\n\tif(DH_verifyPubKey(mpz_hisPubkey))\n\t{\n\t\tmpz_init(mpz_theKey);\n\t\tmpz_init(mpz_myPrivkey);\n\n\t\tlen=b64toh(MyPrivKey, base64_tmp);\n\t\tmpz_import(mpz_myPrivkey, len, 1, 1, 1, 0, base64_tmp);\n\t\tmemset(MyPrivKey, 0x20, strlen(MyPrivKey));\n\n\t\tmpz_powm(mpz_theKey, mpz_hisPubkey, mpz_myPrivkey, mpz_prime);\n\t\tmpz_clear(mpz_myPrivkey);\n\n\t\tmpz_export((void*)base64_tmp, &len, 1, 1, 1, 0, mpz_theKey);\n\t\tmpz_clear(mpz_theKey);\n\t\tSHA256_memory(base64_tmp, len, SHA256digest);\n\t\thtob64(SHA256digest, HisPubKey, 32);\n\n\t\tiRet=1;\n\t}\n\telse iRet=0;\n\n\n\tZeroMemory(base64_tmp, sizeof(base64_tmp));\n\tZeroMemory(SHA256digest, sizeof(SHA256digest));\n\n\tmpz_clear(mpz_hisPubkey);\n\n\treturn iRet;\n}", "path": "DH1080.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// decrypt a base64 cipher text (using key for target)\n", "func_signal": "int FiSH_decrypt(const SERVER_REC *server, char *msg_ptr, char *msg_bak, const char *target)", "code": "{\n\tchar contactName[CONTACT_SIZE]=\"\", theKey[KEYBUF_SIZE]=\"\", bf_dest[1000]=\"\";\n\tchar myMark[20]=\"\", markPos[20]=\"\", *recoded;\n\tint msg_len, i, mark_broken_block=0, action_found=0;\n\n\n\tif(IsNULLorEmpty(msg_ptr) || msg_bak==NULL || IsNULLorEmpty(target)) return 0;\n\n\tif(GetBlowIniSwitch(\"FiSH\", \"process_incoming\", \"1\") == 0) return 0;\n\n\tif(strncmp(msg_ptr, \"+OK \", 4)==0) msg_ptr += 4;\n\telse if(strncmp(msg_ptr, \"mcps \", 5)==0) msg_ptr += 5;\n\telse return 0;\t\t// don't process, blowcrypt-prefix not found\n\n\t// Verify base64 string\n\tmsg_len=strlen(msg_ptr);\n\tif((strspn(msg_ptr, B64) != msg_len) || (msg_len < 12)) return 0;\n\n\tif(LoadKeyForContact(target, theKey)==FALSE) return 0;\n\n\t// usually a received message does not exceed 512 chars, but we want to prevent evil buffer overflow\n\tif(msg_len >= (int)(sizeof(bf_dest)*1.5)) msg_ptr[(int)(sizeof(bf_dest)*1.5)-20]='\\0';\n\n\t// block-align blowcrypt strings if truncated by IRC server (each block is 12 chars long)\n\t// such a truncated block is destroyed and not needed anymore\n\tif(msg_len != (msg_len/12)*12)\n\t{\n\t\tmsg_len=(msg_len/12)*12;\n\t\tmsg_ptr[msg_len]='\\0';\n\t\tGetPrivateProfileString(\"FiSH\", \"mark_broken_block\", \" \\002&\\002\", myMark, sizeof(myMark), iniPath);\n\t\tif(*myMark=='\\0' || isNoChar(*myMark)) mark_broken_block=0;\n\t\telse mark_broken_block=1;\n\t}\n\n\tdecrypt_string(theKey, msg_ptr, bf_dest, msg_len);\n\tZeroMemory(theKey, KEYBUF_SIZE);\n\n\tif(*bf_dest=='\\0') return 0;\t// don't process, decrypted msg is bad\n\n#ifdef FiSH_USE_IRSSI_RECODE\n\t// recode message again, last time it was the encrypted message...\n\tif(settings_get_bool(\"recode\") && server!=NULL)\n\t{\n\t\trecoded = recode_in(server, bf_dest, target);\n\t\tif(recoded)\n\t\t{\n\t\t\tstrncpy(bf_dest, recoded, sizeof(bf_dest));\n\t\t\tZeroMemory(recoded, strlen(recoded));\n\t\t\tg_free(recoded);\n\t\t}\n\t}\n#endif\n\n\ti=0;\n\twhile(bf_dest[i] != 0x0A && bf_dest[i] != 0x0D && bf_dest[i] != '\\0') i++;\n\tbf_dest[i]='\\0';\t// in case of wrong key, decrypted message might have control characters -> cut message\n\n\tif(strncmp(bf_dest, \"\\001ACTION \", 8)==0)\n\t{\n\t\t// ACTION message found\n\t\tif(bf_dest[i-1] == '\\001') bf_dest[i-1] = '\\0';\t// remove 0x01 control character\n\t\taction_found = 1;\n\t}\n\n\t// append broken-block-mark?\n\tif(mark_broken_block) strcat(bf_dest, myMark);\n\n\t// append crypt-mark?\n\tFixIniSection(target, contactName);\t// replace '[' and ']' with '~' in contact name\n\tif(GetBlowIniSwitch(contactName, \"mark_encrypted\", \"1\") != 0)\n\t{\n\t\tGetPrivateProfileString(\"FiSH\", \"mark_encrypted\", \"\", myMark, sizeof(myMark), iniPath);\t// global setting\n\t\tif(*myMark != '\\0')\n\t\t{\n\t\t\tGetPrivateProfileString(\"FiSH\", \"mark_position\", \"0\", markPos, sizeof(markPos), iniPath);\n\t\t\tif(*markPos=='0' || action_found) strcat(bf_dest, myMark);\t\t// append mark at the end (default for ACTION messages)\n\t\t\telse\n\t\t\t{\t// prefix mark\n\t\t\t\ti=strlen(myMark);\n\t\t\t\tmemmove(bf_dest+i, bf_dest, strlen(bf_dest)+1);\n\t\t\t\tstrncpy(bf_dest, myMark, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcpy(msg_bak, bf_dest);\t// copy decrypted message back (overwriting the base64 cipher text)\n\tZeroMemory(bf_dest, sizeof(bf_dest));\n\n\treturn 1;\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "/* compress 512-bits */\n", "func_signal": "static void sha_compress(sha_state * md)", "code": "{\n    unsigned int S[8], W[64], t0, t1;\n    int i;\n\n    /* copy state into S */\n    for (i = 0; i < 8; i++)\n        S[i] = md->state[i];\n\n    /* copy the state into 512-bits into W[0..15] */\n    for (i = 0; i < 16; i++)\n        W[i] = (((unsigned int) md->buf[(4 * i) + 0]) << 24) |\n            (((unsigned int) md->buf[(4 * i) + 1]) << 16) |\n            (((unsigned int) md->buf[(4 * i) + 2]) << 8) |\n            (((unsigned int) md->buf[(4 * i) + 3]));\n\n    /* fill W[16..63] */\n    for (i = 16; i < 64; i++)\n        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];\n\n    /* Compress */\n    for (i = 0; i < 64; i++) {\n        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];\n        t1 = Sigma0(S[0]) + Maj(S[0], S[1], S[2]);\n        S[7] = S[6];\n        S[6] = S[5];\n        S[5] = S[4];\n        S[4] = S[3] + t0;\n        S[3] = S[2];\n        S[2] = S[1];\n        S[1] = S[0];\n        S[0] = t0 + t1;\n    }\n\n    /* feedback */\n    for (i = 0; i < 8; i++)\n        md->state[i] += S[i];\n}", "path": "SHA-256.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// load base64 blowfish key for contact\n// if theKey is NULL, only a test is made (= IsKeySetForContact)\n", "func_signal": "unsigned short LoadKeyForContact(const char *contactPtr, char *theKey)", "code": "{\n\tchar contactName[CONTACT_SIZE]=\"\", tmpKey[KEYBUF_SIZE]=\"\";\n\tunsigned short bRet=FALSE;\n\n\n\tFixIniSection(contactPtr, contactName);\t// replace '[' and ']' with '~' in contact name\n\n\tGetPrivateProfileString(contactName, \"key\", \"\", tmpKey, KEYBUF_SIZE, iniPath);\n\tif(strlen(tmpKey) < 16) return FALSE;\t\t// don't process, encrypted key not found in ini\n\n\tif(strncmp(tmpKey, \"+OK \", 4)==0)\n\t{\n\t\t// encrypted key found\n\t\tif(theKey)\n\t\t{\n\t\t\t// if it's not just a test, lets decrypt the key\n\t\t\tdecrypt_string((char *)iniKey, tmpKey+4, theKey, strlen(tmpKey+4));\n\t\t}\n\n\t\tbRet=TRUE;\n\t}\n\n\tZeroMemory(tmpKey, KEYBUF_SIZE);\n\treturn bRet;\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// New command: /notice+ <nick/#channel> <notice message>\n", "func_signal": "void cmd_crypt_notice(const char *data, SERVER_REC *server, WI_ITEM_REC *item)", "code": "{\n\tchar bf_dest[1000]=\"\", *msg;\n\tconst char *target;\n\tvoid *free_arg=NULL;\n\n\n\tif(data==NULL || (strlen(data) < 3)) goto notice_error;\n\tif(!cmd_get_params(data, &free_arg, 1, &target)) goto notice_error;\n\n\tmsg = strchr(data, ' ');\n\tif (IsNULLorEmpty(target) || IsNULLorEmpty(msg)) goto notice_error;\n\n\tmsg++; // point to the notice message\n\n\n\t// generally refuse a notice size of more than 512 byte, as everything above will never arrive complete anyway\n\tif(strlen(msg) >= 512)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /notice+ \\002error\\002: message argument exceeds buffer size!\");\n\t\tgoto notice_error;\n\t}\n\n\tif(FiSH_encrypt(server, msg, target, bf_dest)==0)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /notice+ \\002error\\002: Encryption disabled or no key found for %s.\", target);\n\t\tgoto notice_error;\n\t}\n\n\tbf_dest[512]='\\0';\n\tirc_send_cmdv((IRC_SERVER_REC *)server, \"NOTICE %s :%s\\n\", target, bf_dest);\n\n\tsignal_emit(\"message irc own_notice\", 3, server, msg, target);\n\tcmd_params_free(free_arg);\n\treturn;\n\nnotice_error:\n\tif(free_arg) cmd_params_free(free_arg);\n\tprinttext(server, item!=NULL ? window_item_get_target(item) : NULL, MSGLEVEL_CRAP,\n\t\t\t\"\\002FiSH:\\002 Usage: /notice+ <nick/#channel> <notice message>\");\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// removes leading and trailing blanks from string\n", "func_signal": "char *strfcpy(char *dest, char *buffer, int destSize)", "code": "{\n\tint i=0, k=strlen(buffer);\n\n\tif(k < 2) return NULL;\n\n\twhile(buffer[i]==' ') i++;\n\twhile(buffer[k-1]==' ') k--;\n\n\tbuffer[k]=0;\n\n\tstrncpy(dest, buffer+i, destSize);\n\tdest[destSize-1] = '\\0';\n\treturn dest;\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// verify the Diffie-Hellman public key as described in RFC 2631\n", "func_signal": "unsigned short DH_verifyPubKey(mpz_t mpz_pubkey)", "code": "{\n\tunsigned short bRet = FALSE;\n\n\t// Verify that pubkey lies within the interval [2,p-1].\n\t// If it does not, the key is invalid.\n\tif(\t(mpz_cmp(mpz_pubkey, mpz_prime) == -1) &&\n\t\t(mpz_cmp(mpz_pubkey, mpz_b_1) == 1)) bRet = TRUE;\n\n\treturn bRet;\n}", "path": "DH1080.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// encrypt a message and store in bf_dest (using key for target)\n", "func_signal": "int FiSH_encrypt(const SERVER_REC *server, const char *msg_ptr, const char *target, char *bf_dest)", "code": "{\n\tchar theKey[KEYBUF_SIZE]=\"\";\n\n\n\tif(IsNULLorEmpty(msg_ptr) || bf_dest==NULL || IsNULLorEmpty(target)) return 0;\n\n\tif(GetBlowIniSwitch(\"FiSH\", \"process_outgoing\", \"1\") == 0) return 0;\n\n\tif(LoadKeyForContact(target, theKey)==FALSE) return 0;\n\n\tstrcpy(bf_dest, \"+OK \");\n\n\tencrypt_string(theKey, msg_ptr, bf_dest+4, strlen(msg_ptr));\n\n\tZeroMemory(theKey, KEYBUF_SIZE);\n\treturn 1;\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// Change back to default blow.ini password, irssi syntax: /unsetinipw\n", "func_signal": "static void cmd_unsetinipw(const char *arg, SERVER_REC *server, WI_ITEM_REC *item)", "code": "{\n\tunsetiniFlag=1;\n\tcmd_setinipw(\"Some_boogie_dummy_key\", server, item);\n\tunsetiniFlag=0;\n\n\tif(WritePrivateProfileString(\"FiSH\", \"ini_password_Hash\", \"\\0\", iniPath) == -1)\n\t{\n\t\tprinttext(server, item!=NULL ? window_item_get_target(item) : NULL,\tMSGLEVEL_CRAP,\n\t\t\t\"\\002FiSH ERROR:\\002 Unable to write to blow.ini, probably out of space or permission denied.\");\n\t\treturn;\n\t}\n\n\tprinttext(server, item!=NULL ? window_item_get_target(item) : NULL, MSGLEVEL_CRAP,\n\t\t\"\\002FiSH:\\002 Changed back to default blow.ini password, you won't have to enter it on start-up anymore!\");\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// sha-256 a block of memory\n", "func_signal": "void SHA256_memory(unsigned char *buf, int len, unsigned char *hash)", "code": "{\n    sha_state md;\n\n    sha_init(&md);\n    sha_process(&md, buf, len);\n    sha_done(&md, hash);\n    memset(&md, 0, sizeof(md));\n}", "path": "SHA-256.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// sha-256 a file, return 1 if ok\n", "func_signal": "int sha_file(unsigned char *filename, unsigned char *hash)", "code": "{\n    unsigned char buf[512];\n    int i;\n    FILE *in;\n    sha_state md;\n\n    sha_init(&md);\n    in = fopen(filename, \"rb\");\n    if (!in)\n        return 0;\n    do {\n        i = fread(buf, 1, 512, in);\n        sha_process(&md, buf, i);\n    }\n    while (i == 512);\n    sha_done(&md, hash);\n    fclose(in);\n    return 1;\n}", "path": "SHA-256.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// copy key for old nick to use with the new one\n", "func_signal": "void query_nick_changed(QUERY_REC *query, char *orignick)", "code": "{\n\tchar theKey[KEYBUF_SIZE]=\"\", contactName[CONTACT_SIZE]=\"\";\n\n\n\tif(GetBlowIniSwitch(\"FiSH\", \"nicktracker\", \"1\") == 0) return;\n\n\tif(orignick==NULL || strcasecmp(orignick, query->name)==0) return;\t// same nick, different case?\n\n\tif(LoadKeyForContact(orignick, theKey)==FALSE)\n\t\treturn;\t// see if there is a key for the old nick\n\n\tFixIniSection(query->name, contactName);\n\n\tif(WritePrivateProfileString(contactName, \"key\", theKey, iniPath) == -1)\n\t\tprinttext(NULL, NULL, MSGLEVEL_CRAP, \"\\002FiSH ERROR:\\002 Unable to write to blow.ini, probably out of space or permission denied.\");\n\n\tZeroMemory(theKey, KEYBUF_SIZE);\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// New command: /me+ <action message>\n", "func_signal": "void cmd_crypt_action(const char *data, SERVER_REC *server, WI_ITEM_REC *item)", "code": "{\t// New command: /me+ <action message>\n\tchar bf_dest[1000]=\"\";\n\tconst char *target;\n\n\n\tif(data==NULL || (strlen(data) < 2)) goto action_error;\n\n\tif(item!=NULL) target=window_item_get_target(item);\n\telse goto action_error;\n\n\n\t// generally refuse an action size of more than 512 byte, as everything above will never arrive complete anyway\n\tif(strlen(data) >= 512)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /me+ \\002error\\002: message argument exceeds buffer size!\");\n\t\treturn;\n\t}\n\n\tif(FiSH_encrypt(server, (char *)data, target, bf_dest)==0)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /me+ \\002error\\002: Encryption disabled or no key found for %s.\", target);\n\t\treturn;\n\t}\n\n\tbf_dest[512]='\\0';\n\tirc_send_cmdv((IRC_SERVER_REC *)server, \"PRIVMSG %s :\\001ACTION %s\\001\\n\", target, bf_dest);\n\n\tsignal_emit(\"message irc own_action\", 3, server, data, target);\n\treturn;\n\naction_error:\n\tprinttext(server, item!=NULL ? window_item_get_target(item) : NULL, MSGLEVEL_CRAP,\n\t\t\t\"\\002FiSH:\\002 Usage: /me+ <action message>\");\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "// set encrypted topic for current channel, irssi syntax: /topic+ <your topic>\n", "func_signal": "void cmd_crypt_TOPIC(const char *data, SERVER_REC *server, WI_ITEM_REC *item)", "code": "{\n\tchar bf_dest[1000]=\"\";\n\tconst char *target;\n\n\n\tif(data==0 || *data=='\\0') goto topic_error;\n\tif(item!=NULL) target=window_item_get_target(item);\n\telse goto topic_error;\n\n\n\tif(!ischannel(*target))\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 Please change to the channel window where you want to set the topic!\");\n\t\tgoto topic_error;\n\t}\n\n\t// generally refuse a topic size of more than 512 byte, as everything above will never arrive complete anyway\n\tif(strlen(data) >= 512)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /topic+ error: topic length exceeds buffer size!\");\n\t\tgoto topic_error;\n\t}\n\n\t// encrypt a message (using key for target)\n\tif(FiSH_encrypt(server, (char *)data, target, bf_dest)==0)\n\t{\n\t\tprinttext(server, target, MSGLEVEL_CRAP, \"\\002FiSH:\\002 /topic+ error: Encryption disabled or no key found for %s.\", target);\n\t\tgoto topic_error;\n\t}\n\n\tbf_dest[512]='\\0';\n\tirc_send_cmdv((IRC_SERVER_REC *)server, \"TOPIC %s :%s\\n\", target, bf_dest);\n\treturn;\n\ntopic_error:\n\tprinttext(server, item!=NULL ? window_item_get_target(item) : NULL, MSGLEVEL_CRAP,\n\t\t\t\"\\002FiSH:\\002 Usage: /topic+ <your new topic>\");\n}", "path": "FiSH.c", "repo_name": "fishman/fish-irssi-gmp", "stars": 2, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Update()\n *\n * input   : state\n *           data\n *           databitlen\n * output  : state (updated)\n * returns : SUCCESS\n */\n", "func_signal": "HashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen)", "code": "{\n  state->HashUpdate(&state->ctx, data, databitlen);\n\n  return SUCCESS;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Final()\n *\n * input   : state\n * output  : hashval\n * returns : SUCCESS\n */\n", "func_signal": "HashReturn Final(hashState *state, BitSequence *hashval)", "code": "{\n  state->HashFinal(hashval, &state->ctx);\n\n  return SUCCESS;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora512Update()\n *\n * updating function for AURORA-512 and AURORA-384\n *\n * input  : msg (msg_bitlen [bits])\n *          msg_bitlen\n *          hctx\n * output : hctx (updated context)\n */\n", "func_signal": "static void Aurora512Update(AURORA_CTX *hctx, const BitSequence *msg, DataLength msg_bitlen)", "code": "{\n  int byte_cnt = hctx->cnt / 8;\n  DataLength msg_bytelen = msg_bitlen >> 3;\n  DataLength msg_blklen;\n  int bit_ofs = hctx->cnt & 0x07;\n  int msg_ofs = ((int) (msg_bitlen & 0x07U) + bit_ofs) & 0x07;\n  BitSequence tmp;\n  int i;\n\n  if((hctx->cnt < 0) || (hctx->cnt >= 512)){\n    return ;\n  }\n\n  if(bit_ofs){\n    /* previous data is not byte aligned */\n    tmp = hctx->buff[byte_cnt];\n    hctx->cnt -= bit_ofs;\n    while(msg_bytelen--){\n      hctx->buff[byte_cnt++] = tmp | (*msg >> bit_ofs);\n      tmp = *msg++ << (8 - bit_ofs);\n      hctx->cnt += 8;\n      if(hctx->cnt >= 64){\n\thctx->cnt = 0;\n\tbyte_cnt = 0;\n\thctx->blk_num++;\n\tif(hctx->blk_idx >= 0x08080808U){\n\t  /* mixing function */\n\t  Aurora512MF(hctx, hctx->blk_idx);\n\t  hctx->blk_idx = 0U;\n\t}\n\tAurora512CF(hctx, hctx->buff, hctx->blk_idx);\n\thctx->blk_idx += 0x01010101U;\n      }\n    }\n    hctx->buff[byte_cnt] = tmp & (0xffU << (8 - msg_ofs));\n    hctx->cnt += msg_ofs;\n  }else{\n    /* previous data is byte aligned */\n    /* computation for extra block */\n    if((byte_cnt) && (msg_bytelen >= (DataLength) (AURORA_BLK_SIZE - byte_cnt))){\n      msg_bytelen -= (DataLength) (AURORA_BLK_SIZE - byte_cnt);\n      for(i = byte_cnt; i < AURORA_BLK_SIZE; i++){\n\thctx->buff[i] = *msg++;\n      }\n      hctx->cnt = 0;\n      byte_cnt = 0;\n      hctx->blk_num++;\n      if(hctx->blk_idx >= 0x08080808U){\n\t/* mixing function */\n\tAurora512MF(hctx, hctx->blk_idx);\n\thctx->blk_idx = 0U;\n      }\n      Aurora512CF(hctx, hctx->buff, hctx->blk_idx);\n      hctx->blk_idx += 0x01010101U;\n    }\n    \n    /* main computation */\n    msg_blklen = msg_bytelen / (DataLength) AURORA_BLK_SIZE;\n    hctx->blk_num += msg_blklen;\n    while(msg_blklen--){\n      if(hctx->blk_idx >= 0x08080808U){\n\t/* mixing function */\n\tAurora512MF(hctx, hctx->blk_idx);\n\thctx->blk_idx = 0U;\n      }\n      Aurora512CF(hctx, msg, hctx->blk_idx);\n      hctx->blk_idx += 0x01010101U;\n      msg += AURORA_BLK_SIZE;\n    }\n    \n    msg_bytelen %= (DataLength) AURORA_BLK_SIZE; /* remaining bytes */\n    \n    /* copy remaining data to local buffer */\n    hctx->cnt += (int) (msg_bytelen * 8);\n    while(msg_bytelen--){\n      hctx->buff[byte_cnt++] = *msg++;\n    }\n\n    if(msg_bitlen & 0x07U){\n      /* input data is not byte aligned */\n      hctx->buff[byte_cnt] = (*msg & (0xffU << (8 - (int) (msg_bitlen & 0x07U))));\n      hctx->cnt += (int) (msg_bitlen & 0x07U);\n    }\n  }\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Hash()\n *\n * input   : hashbitlen\n *           data\n *           databitlen\n * output  : hashval\n * returns : BAD_HASHBITLEN, FAIL or SUCCESS\n */\n", "func_signal": "HashReturn Hash(int hashbitlen, const BitSequence *data, DataLength databitlen, BitSequence *hashval)", "code": "{\n  hashState state;\n\n  if(BAD_HASHBITLEN == Init(&state, hashbitlen)){\n    return BAD_HASHBITLEN;\n  }\n  Update(&state, data, databitlen);\n  Final(&state, hashval);\n\n  return SUCCESS;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* FreeBSD, NetBSD, OpenBSD, DragonFly, MacOS X, Cygwin */\n", "func_signal": "static inline int\ndisable_seek_optimization (FILE *fp)", "code": "{\n  int saved_flags = fp_->_flags & (__SOPT | __SNPT);\n  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;\n  return saved_flags;\n}", "path": "coreutils-6.12\\lib\\fflush.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Translate USER to a UID, with cache.\n   Return NULL if there is no such user.\n   (We also cache which user names have no passwd entry,\n   so we don't keep looking them up.)  */\n", "func_signal": "uid_t *\ngetuidbyname (const char *user)", "code": "{\n  struct userid *tail;\n  struct passwd *pwent;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return &tail->id.u;\n\n  for (tail = nouser_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return NULL;\n\n  pwent = getpwnam (user);\n#ifdef __DJGPP__\n  /* We need to pretend to be the user USER, to make\n     pwd functions know about an arbitrary user name.  */\n  if (!pwent && strspn (user, digits) < strlen (user))\n    {\n      setenv (\"USER\", user, 1);\n      pwent = getpwnam (user);\t/* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);\n  strcpy (tail->name, user);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (pwent)\n    {\n      tail->id.u = pwent->pw_uid;\n      tail->next = user_alist;\n      user_alist = tail;\n      return &tail->id.u;\n    }\n\n  tail->next = nouser_alist;\n  nouser_alist = tail;\n  return NULL;\n}", "path": "coreutils-6.12\\lib\\idcache.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Flush all pending data on STREAM according to POSIX rules.  Both\n   output and seekable input streams are supported.  */\n", "func_signal": "int\nrpl_fflush (FILE *stream)", "code": "{\n  int result;\n  off_t pos;\n\n  /* When stream is NULL, POSIX and C99 only require flushing of \"output\n     streams and update streams in which the most recent operation was not\n     input\", and all implementations do this.\n\n     When stream is \"an output stream or an update stream in which the most\n     recent operation was not input\", POSIX and C99 requires that fflush\n     writes out any buffered data, and all implementations do this.\n\n     When stream is, however, an input stream or an update stream in\n     which the most recent operation was input, C99 specifies nothing,\n     and POSIX only specifies behavior if the stream is seekable.\n     mingw, in particular, drops the input buffer, leaving the file\n     descriptor positioned at the end of the input buffer. I.e. ftell\n     (stream) is lost.  We don't want to call the implementation's\n     fflush in this case.\n\n     We test ! freading (stream) here, rather than fwriting (stream), because\n     what we need to know is whether the stream holds a \"read buffer\", and on\n     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n  if (stream == NULL || ! freading (stream))\n    return fflush (stream);\n\n  /* Clear the ungetc buffer.\n\n     This is needed before fetching the file-position indicator, because\n     1) The file position indicator is incremented by fgetc() and decremented\n        by ungetc():\n        <http://www.opengroup.org/susv3/functions/fgetc.html>\n          \"... the fgetc() function shall ... advance the associated file\n           position indicator for the stream ...\"\n        <http://www.opengroup.org/susv3/functions/ungetc.html>\n          \"The file-position indicator is decremented by each successful\n           call to ungetc()...\"\n     2) <http://www.opengroup.org/susv3/functions/ungetc.html> says:\n          \"The value of the file-position indicator for the stream after\n           reading or discarding all pushed-back bytes shall be the same\n           as it was before the bytes were pushed back.\"\n     3) Here we are discarding all pushed-back bytes.\n\n     Unfortunately it is impossible to implement this on platforms with\n     _IOERR, because an ungetc() on this platform prepends the pushed-back\n     bytes to the buffer without an indication of the limit between the\n     pushed-back bytes and the read-ahead bytes.  */\n  clear_ungetc_buffer (stream);\n\n  /* POSIX does not specify fflush behavior for non-seekable input\n     streams.  Some implementations purge unread data, some return\n     EBADF, some do nothing.  */\n  pos = ftello (stream);\n  if (pos == -1)\n    {\n      errno = EBADF;\n      return EOF;\n    }\n\n  /* To get here, we must be flushing a seekable input stream, so the\n     semantics of fpurge are now appropriate to clear the buffer.  To\n     avoid losing data, the lseek is also necessary.  */\n  result = fpurge (stream);\n  if (result != 0)\n    return result;\n\n#if (defined __sferror || defined __DragonFly__) && defined __SNPT /* FreeBSD, NetBSD, OpenBSD, DragonFly, MacOS X, Cygwin */\n\n  {\n    /* Disable seek optimization for the next fseeko call.  This tells the\n       following fseeko call to seek to the desired position directly, rather\n       than to seek to a block-aligned boundary.  */\n    int saved_flags = disable_seek_optimization (stream);\n\n    result = fseeko (stream, pos, SEEK_SET);\n\n    restore_seek_optimization (stream, saved_flags);\n  }\n  return result;\n\n#else\n\n  pos = lseek (fileno (stream), pos, SEEK_SET);\n  if (pos == -1)\n    return EOF;\n  /* After a successful lseek, update the file descriptor's position cache\n     in the stream.  */\n  update_fpos_cache (stream, pos);\n\n  return 0;\n\n#endif\n}", "path": "coreutils-6.12\\lib\\fflush.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora256Final()\n *\n * finalization function for AURORA-256\n *\n * input  : hctx\n * output : digest\n */\n", "func_signal": "static void Aurora256Final(BitSequence *digest, AURORA_CTX *hctx)", "code": "{\n  int byte_cnt = hctx->cnt / 8;\n  int i;\n\n  if((hctx->cnt < 0) || (hctx->cnt >= 512)){\n    return ;\n  }\n\n  if(0 != hctx->cnt){\n    hctx->blk_num++;\n  }\n\n  if(hctx->cnt & 0x07){\n    hctx->buff[byte_cnt++] |= 0x80U >> (hctx->cnt & 0x07);\n  }else{\n    hctx->buff[byte_cnt++] = 0x80U;\n  }\n\n  if(hctx->cnt > 447){\n    /* computation for extra block */\n    for(i = byte_cnt; i < AURORA_BLK_SIZE; i++){\n      hctx->buff[i] = 0U;\n    }\n    Aurora256CF(hctx, hctx->buff, 0x00000000U);\n    byte_cnt = 0;\n  }\n\n  /* computation for final block */\n  for(i = byte_cnt; i < (AURORA_BLK_SIZE - 8); i++){\n    hctx->buff[i] = 0U;\n  }\n\n  \n  WRITE64BIT(hctx->buff + AURORA_BLK_SIZE - 8, hctx->blk_num);\n\n  Aurora256CF(hctx, hctx->buff, 0x01010101U);\n\n  WRITE256BIT(digest, hctx->h[0], hctx->h[1], hctx->h[2], hctx->h[3], hctx->h[4], hctx->h[5], hctx->h[6], hctx->h[7]);\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora512Final()\n *\n * finalization function for AURORA-512\n *\n * input  : hctx\n * output : digest\n */\n", "func_signal": "static void Aurora512Final(BitSequence *digest, AURORA_CTX *hctx)", "code": "{\n  int byte_cnt = hctx->cnt / 8;\n  int i;\n\n  if((hctx->cnt < 0) || (hctx->cnt >= 512)){\n    return ;\n  }\n\n  if(0 != hctx->cnt){\n    hctx->blk_num++;\n  }\n\n  if(hctx->cnt & 0x07){\n    hctx->buff[byte_cnt++] |= 0x80U >> (hctx->cnt & 0x07);\n  }else{\n    hctx->buff[byte_cnt++] = 0x80U;\n  }\n\n  if(hctx->cnt > 447){\n    /* computation for extra block */\n    for(i = byte_cnt; i < AURORA_BLK_SIZE; i++){\n      hctx->buff[i] = 0U;\n    }\n    if(hctx->blk_idx >= 0x08080808U){\n      /* mixing function */\n      Aurora512MF(hctx, hctx->blk_idx);\n      hctx->blk_idx = 0U;\n    }\n    Aurora512CF(hctx, hctx->buff, hctx->blk_idx);\n    hctx->blk_idx += 0x01010101U;\n    byte_cnt = 0;\n  }\n\n  /* computation for final block */\n  for(i = byte_cnt; i < (AURORA_BLK_SIZE - 8); i++){\n    hctx->buff[i] = 0U;\n  }\n\n  WRITE64BIT(hctx->buff + AURORA_BLK_SIZE - 8, hctx->blk_num);\n\n  /* final compression */\n  if(hctx->blk_idx >= 0x08080808U){\n    /* mixing function */\n    Aurora512MF(hctx, hctx->blk_idx);\n    hctx->blk_idx = 0U;\n  }\n  Aurora512CF(hctx, hctx->buff, hctx->blk_idx);\n  hctx->blk_idx += 0x01010101U;\n\n  /* final mixing */\n  Aurora512MF(hctx, 0x09090909U);\n\n  WRITE256BIT(digest, hctx->h[0], hctx->h[1], hctx->h[2], hctx->h[3], hctx->h[4], hctx->h[5], hctx->h[6], hctx->h[7]);\n  WRITE256BIT(digest + 32, hctx->h[8], hctx->h[9], hctx->h[10], hctx->h[11], hctx->h[12], hctx->h[13], hctx->h[14], hctx->h[15]);\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Translate GID to a group name, with cache, or NULL if unresolved.  */\n", "func_signal": "char *\ngetgroup (gid_t gid)", "code": "{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    {\n      if (tail->id.g == gid)\n\t{\n\t  match = tail;\n\t  break;\n\t}\n    }\n\n  if (match == NULL)\n    {\n      struct group *grent = getgrgid (gid);\n      char const *name = grent ? grent->gr_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.g = gid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = group_alist;\n      group_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}", "path": "coreutils-6.12\\lib\\idcache.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora384Final()\n *\n * finalization function for AURORA-384\n *\n * input  : hctx\n * output : digest\n */\n", "func_signal": "static void Aurora384Final(BitSequence *digest, AURORA_CTX *hctx)", "code": "{\n  BitSequence digest512[AURORA512_DIGEST_SIZE];\n  int cnt = 0;\n  int i, j;\n\n  Aurora512Final(digest512, hctx);\n  for(i = 0; i < 8; i++){\n    for(j = 0; j < 6; j++){\n      *digest++ = digest512[cnt++];\n    }\n    cnt += 2;\n  }\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Translate UID to a login name, with cache, or NULL if unresolved.  */\n", "func_signal": "char *\ngetuser (uid_t uid)", "code": "{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    {\n      if (tail->id.u == uid)\n\t{\n\t  match = tail;\n\t  break;\n\t}\n    }\n\n  if (match == NULL)\n    {\n      struct passwd *pwent = getpwuid (uid);\n      char const *name = pwent ? pwent->pw_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.u = uid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = user_alist;\n      user_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}", "path": "coreutils-6.12\\lib\\idcache.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora256Update()\n *\n * updating function for AURORA-256 and AURORA-224\n *\n * input  : msg (msg_bitlen [bits])\n *          msg_bitlen\n *          hctx\n * output : hctx (updated context)\n */\n", "func_signal": "static void Aurora256Update(AURORA_CTX *hctx, const BitSequence *msg, DataLength msg_bitlen)", "code": "{\n  int byte_cnt = hctx->cnt / 8;\n  DataLength msg_bytelen = msg_bitlen >> 3;\n  DataLength msg_blklen;\n  int bit_ofs = hctx->cnt & 0x07;\n  int msg_ofs = ((int) (msg_bitlen & 0x07U) + bit_ofs) & 0x07;\n  BitSequence tmp;\n  int i;\n\n  if((hctx->cnt < 0) || (hctx->cnt >= 512)){\n    return ;\n  }\n\n  if(bit_ofs){\n    /* previous data is not byte aligned */\n    tmp = hctx->buff[byte_cnt];\n    hctx->cnt -= bit_ofs;\n    while(msg_bytelen--){\n      hctx->buff[byte_cnt++] = tmp | (*msg >> bit_ofs);\n      tmp = *msg++ << (8 - bit_ofs);\n      hctx->cnt += 8;\n      if(hctx->cnt >= 64){\n\thctx->cnt = 0;\n\tbyte_cnt = 0;\n\thctx->blk_num++;\n\tAurora256CF(hctx, hctx->buff, 0x00000000U);\n      }\n    }\n    hctx->buff[byte_cnt] = tmp & (0xffU << (8 - msg_ofs));\n    hctx->cnt += msg_ofs;\n  }else{\n    /* previous data is byte aligned */\n    /* computation for extra block */\n    if((byte_cnt) && (msg_bytelen >= (DataLength) (AURORA_BLK_SIZE - byte_cnt))){\n      msg_bytelen -= (DataLength) (AURORA_BLK_SIZE - byte_cnt);\n      for(i = byte_cnt; i < AURORA_BLK_SIZE; i++){\n\thctx->buff[i] = *msg++;\n      }\n      hctx->cnt = 0;\n      byte_cnt = 0;\n      hctx->blk_num++;\n      Aurora256CF(hctx, hctx->buff, 0x00000000U);\n    }\n    \n    /* main computation */\n    msg_blklen = msg_bytelen / (DataLength) AURORA_BLK_SIZE;\n    hctx->blk_num += msg_blklen;\n    while(msg_blklen--){\n      Aurora256CF(hctx, msg, 0x00000000U);\n      msg += AURORA_BLK_SIZE;\n    }\n    \n    msg_bytelen %= (DataLength) AURORA_BLK_SIZE; /* remaining bytes */\n    \n    /* copy remaining data to local buffer */\n    hctx->cnt += (int) (msg_bytelen * 8);\n    while(msg_bytelen--){\n      hctx->buff[byte_cnt++] = *msg++;\n    }\n\n    if(msg_bitlen & 0x07U){\n      /* input data is not aligned */\n      hctx->buff[byte_cnt] = (*msg & (0xffU << (8 - (int) (msg_bitlen & 0x07U))));\n      hctx->cnt += (int) (msg_bitlen & 0x07U);\n    }\n  }\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora512MF\n *\n * mixing function for AURORA-384/512\n */\n", "func_signal": "static void Aurora512MF(AURORA_CTX *hctx, const AURORA_UINT32 mask)", "code": "{\n  BitSequence m[64];\n  int i;\n\n  for(i = 0; i < 16; i++){\n    WRITE32BIT(m + i * 4, hctx->h[i]);\n  }\n  Aurora512CF(hctx, m, mask);\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Init()\n *\n * input   : state\n *           hashbitlen\n * output  : state (updated)\n * returns : BAD_HASHBITLEN (hashbitlen is invalid) or SUCCESS\n */\n", "func_signal": "HashReturn Init(hashState *state, int hashbitlen)", "code": "{\n  if(AURORA256_DIGEST_SIZE_BIT == hashbitlen){\n    /* AURORA-256 */\n    AuroraInit0(&state->ctx);\n    state->HashUpdate = Aurora256Update;\n    state->HashFinal = Aurora256Final;\n  }else if(AURORA224_DIGEST_SIZE_BIT == hashbitlen){\n    /* AURORA-224 */\n    AuroraInit1(&state->ctx);\n    state->HashUpdate = Aurora256Update;\n    state->HashFinal = Aurora224Final;\n  }else if(AURORA512_DIGEST_SIZE_BIT == hashbitlen){\n    /* AURORA-512 */\n    AuroraInit0(&state->ctx);\n    state->HashUpdate = Aurora512Update;\n    state->HashFinal = Aurora512Final;\n  }else if(AURORA384_DIGEST_SIZE_BIT == hashbitlen){\n    /* AURORA-384 */\n    AuroraInit1(&state->ctx);\n    state->HashUpdate = Aurora512Update;\n    state->HashFinal = Aurora384Final;\n  }else{\n    /* invalid hashbitlen */\n    return BAD_HASHBITLEN;\n  }\n\n  state->hashbitlen = hashbitlen;\n\n  return SUCCESS;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Set the access and modification time stamps of FD (a.k.a. FILE) to be\n   TIMESPEC[0] and TIMESPEC[1], respectively.\n   FD must be either negative -- in which case it is ignored --\n   or a file descriptor that is open on FILE.\n   If FD is nonnegative, then FILE can be NULL, which means\n   use just futimes (or equivalent) instead of utimes (or equivalent),\n   and fail if on an old system without futimes (or equivalent).\n   If TIMESPEC is null, set the time stamps to the current time.\n   Return 0 on success, -1 (setting errno) on failure.  */\n", "func_signal": "int\ngl_futimens (int fd ATTRIBUTE_UNUSED,\n\t     char const *file, struct timespec const timespec[2])", "code": "{\n  /* Some Linux-based NFS clients are buggy, and mishandle time stamps\n     of files in NFS file systems in some cases.  We have no\n     configure-time test for this, but please see\n     <http://bugs.gentoo.org/show_bug.cgi?id=132673> for references to\n     some of the problems with Linux 2.6.16.  If this affects you,\n     compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to\n     help in some cases, albeit at a cost in performance.  But you\n     really should upgrade your kernel to a fixed version, since the\n     problem affects many applications.  */\n\n#if HAVE_BUGGY_NFS_TIME_STAMPS\n  if (fd < 0)\n    sync ();\n  else\n    fsync (fd);\n#endif\n\n  /* POSIX 200x added two interfaces to set file timestamps with\n     nanosecond resolution.  */\n#if HAVE_UTIMENSAT\n  if (fd < 0)\n    return utimensat (AT_FDCWD, file, timespec, 0);\n#endif\n#if HAVE_FUTIMENS\n  return futimens (fd, timespec);\n#else\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n  {\n# if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n    struct timeval timeval[2];\n    struct timeval const *t;\n    if (timespec)\n      {\n\ttimeval[0].tv_sec = timespec[0].tv_sec;\n\ttimeval[0].tv_usec = timespec[0].tv_nsec / 1000;\n\ttimeval[1].tv_sec = timespec[1].tv_sec;\n\ttimeval[1].tv_usec = timespec[1].tv_nsec / 1000;\n\tt = timeval;\n      }\n    else\n      t = NULL;\n\n    if (fd < 0)\n      {\n#  if HAVE_FUTIMESAT\n\treturn futimesat (AT_FDCWD, file, t);\n#  endif\n      }\n    else\n      {\n\t/* If futimesat or futimes fails here, don't try to speed things\n\t   up by returning right away.  glibc can incorrectly fail with\n\t   errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0\n\t   in high security mode doesn't allow ordinary users to read\n\t   /proc/self, so glibc incorrectly fails with errno == EACCES.\n\t   If errno == EIO, EPERM, or EROFS, it's probably safe to fail\n\t   right away, but these cases are rare enough that they're not\n\t   worth optimizing, and who knows what other messed-up systems\n\t   are out there?  So play it safe and fall back on the code\n\t   below.  */\n#  if HAVE_FUTIMESAT\n\tif (futimesat (fd, NULL, t) == 0)\n\t  return 0;\n#  elif HAVE_FUTIMES\n\tif (futimes (fd, t) == 0)\n\t  return 0;\n#  endif\n      }\n# endif /* HAVE_FUTIMESAT || HAVE_WORKING_UTIMES */\n\n    if (!file)\n      {\n# if ! (HAVE_FUTIMESAT || (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n\terrno = ENOSYS;\n# endif\n\n\t/* Prefer EBADF to ENOSYS if both error numbers apply.  */\n\tif (errno == ENOSYS)\n\t  {\n\t    int fd2 = dup (fd);\n\t    int dup_errno = errno;\n\t    if (0 <= fd2)\n\t      close (fd2);\n\t    errno = (fd2 < 0 && dup_errno == EBADF ? EBADF : ENOSYS);\n\t  }\n\n\treturn -1;\n      }\n\n# if HAVE_WORKING_UTIMES\n    return utimes (file, t);\n# else\n    {\n      struct utimbuf utimbuf;\n      struct utimbuf const *ut;\n      if (timespec)\n\t{\n\t  utimbuf.actime = timespec[0].tv_sec;\n\t  utimbuf.modtime = timespec[1].tv_sec;\n\t  ut = &utimbuf;\n\t}\n      else\n\tut = NULL;\n\n      return utime (file, ut);\n    }\n# endif /* !HAVE_WORKING_UTIMES */\n  }\n#endif /* !HAVE_FUTIMENS */\n}", "path": "coreutils-6.12\\lib\\utimens.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * Aurora224Final()\n *\n * finalization function for AURORA-224\n *\n * input  : hctx\n * output : digest\n */\n", "func_signal": "static void Aurora224Final(BitSequence *digest, AURORA_CTX *hctx)", "code": "{\n  BitSequence digest256[AURORA256_DIGEST_SIZE];\n  int cnt = 0;\n  int i, j;\n\n  Aurora256Final(digest256, hctx);\n  for(i = 0; i < 4; i++){\n    for(j = 0; j < 7; j++){\n      *digest++ = digest256[cnt++];\n    }\n    cnt++;\n  }\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * AuroraInit1()\n *\n * initialization function for AURORA-224 and AURORA-384\n * input and output: hctx\n */\n", "func_signal": "static void AuroraInit1(AURORA_CTX *hctx)", "code": "{\n  int i;\n\n  for(i = 0; i < 16; i++){\n    hctx->h[i] = 0xffffffffU;\n  }\n  hctx->blk_num = 0U;\n  hctx->cnt = 0;\n  hctx->blk_idx = 0;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/*\n * AuroraInit0()\n *\n * initialization function for AURORA-256 and AURORA-512\n * input and output: hctx\n */\n", "func_signal": "static void AuroraInit0(AURORA_CTX *hctx)", "code": "{\n  int i;\n\n  for(i = 0; i < 16; i++){\n    hctx->h[i] = 0U;\n  }\n  hctx->blk_num = 0U;\n  hctx->cnt = 0;\n  hctx->blk_idx = 0U;\n}", "path": "entries\\AURORA\\32\\aurora_opt32.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "/* Translate GROUP to a GID, with cache.\n   Return NULL if there is no such group.\n   (We also cache which group names have no group entry,\n   so we don't keep looking them up.)  */\n", "func_signal": "gid_t *\ngetgidbyname (const char *group)", "code": "{\n  struct userid *tail;\n  struct group *grent;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return &tail->id.g;\n\n  for (tail = nogroup_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return NULL;\n\n  grent = getgrnam (group);\n#ifdef __DJGPP__\n  /* We need to pretend to belong to group GROUP, to make\n     grp functions know about an arbitrary group name.  */\n  if (!grent && strspn (group, digits) < strlen (group))\n    {\n      setenv (\"GROUP\", group, 1);\n      grent = getgrnam (group);\t/* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);\n  strcpy (tail->name, group);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (grent)\n    {\n      tail->id.g = grent->gr_gid;\n      tail->next = group_alist;\n      group_alist = tail;\n      return &tail->id.g;\n    }\n\n  tail->next = nogroup_alist;\n  nogroup_alist = tail;\n  return NULL;\n}", "path": "coreutils-6.12\\lib\\idcache.c", "repo_name": "kinghajj/sha3sums", "stars": 3, "license": "None", "language": "c", "size": 7852}
{"docstring": "// here, rect is the relative rectagle location against to the widget\n", "func_signal": "int STK_FontDraw(STK_Font *font, char *str, STK_Widget *widget, SDL_Rect *rect, SDL_Color *fg, SDL_Color *bg)", "code": "{\n\tSDL_Surface *text;\n\tSDL_Rect src, dst;\n\tUint32 colorkey_bg;\n\n\tSTK_Window *win = STK_WindowGetTop();\n\tif (!win)\n\t\treturn -1;\n\tif (!str || !strcmp(str, \"\"))\n\t\treturn -1;\n\t\n\ttext = TTF_RenderUTF8_Shaded(font->font, str, *fg, *bg);\n//\ttext = TTF_RenderUTF8_Solid(font->font, str, *fg);\n\t\n\tdst.x = rect->x;\n\tdst.y = rect->y;\n\t// here, setting dst.w = rect->w means use widget's border as limits\n\tdst.w = (text->w <= rect->w ? text->w: rect->w); \n\tdst.h = (text->h <= rect->h ? text->h: rect->h); \n\t\n\t// set the background of label being transparent, magic num is for test only\n\tcolorkey_bg = SDL_MapRGB(text->format, bg->r, bg->g, bg->b);\n\tSDL_SetColorKey(text, SDL_SRCCOLORKEY, colorkey_bg);\n\t\n\tsrc.x = 0;\n\tsrc.y = 0;\n\tsrc.w = dst.w;\n\tsrc.h = dst.h;\n\t\t\t\n\tSDL_BlitSurface(text, &src, widget->surface, &dst);\n\tSDL_FreeSurface(text);\n\n\treturn 0;\n}", "path": "stk_font.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* Note: Based on algorithm from sge library with multiple-hline draw removal */\n/* and other speedup changes. */\n", "func_signal": "int ellipseColor(SDL_Surface * dst, Sint16 x, Sint16 y, Sint16 rx, Sint16 ry, Uint32 color)", "code": "{\n    Sint16 left, right, top, bottom;\n    int result;\n    Sint16 x1, y1, x2, y2;\n    int ix, iy;\n    int h, i, j, k;\n    int oh, oi, oj, ok;\n    int xmh, xph, ypk, ymk;\n    int xmi, xpi, ymj, ypj;\n    int xmj, xpj, ymi, ypi;\n    int xmk, xpk, ymh, yph;\n    Uint8 *colorptr;\n\n    /*\n     * Sanity check radii \n     */\n    if ((rx < 0) || (ry < 0)) {\n\treturn (-1);\n    }\n\n    /*\n     * Special case for rx=0 - draw a vline \n     */\n    if (rx == 0) {\n\treturn (vlineColor(dst, x, y - ry, y + ry, color));\n    }\n    /*\n     * Special case for ry=0 - draw a hline \n     */\n    if (ry == 0) {\n\treturn (hlineColor(dst, x - rx, x + rx, y, color));\n    }\n\n    /*\n     * Get clipping boundary \n     */\n    left = dst->clip_rect.x;\n    right = dst->clip_rect.x + dst->clip_rect.w - 1;\n    top = dst->clip_rect.y;\n    bottom = dst->clip_rect.y + dst->clip_rect.h - 1;\n\n    /*\n     * Test if bounding box of ellipse is visible \n     */\n    x1 = x - rx;\n    x2 = x + rx;\n    y1 = y - ry;\n    y2 = y + ry;\n    if ((x1<left) && (x2<left)) {\n        return(0);\n    } \n    if ((x1>right) && (x2>right)) {\n        return(0);\n    } \n    if ((y1<top) && (y2<top)) {\n        return(0);\n    } \n    if ((y1>bottom) && (y2>bottom)) {\n        return(0);\n    } \n\n    /*\n     * Init vars \n     */\n    oh = oi = oj = ok = 0xFFFF;\n\n    /*\n     * Draw \n     */\n    result = 0;\n\n    /* Lock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tif (SDL_LockSurface(dst) < 0) {\n\t    return (-1);\n\t}\n    }\n\n    /*\n     * Check alpha \n     */\n    if ((color & 255) == 255) {\n\n\t/*\n\t * No Alpha - direct memory writes \n\t */\n\n\t/*\n\t * Setup color \n\t */\n\tcolorptr = (Uint8 *) & color;\n\tif (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n\t    color = SDL_MapRGBA(dst->format, colorptr[0], colorptr[1], colorptr[2], colorptr[3]);\n\t} else {\n\t    color = SDL_MapRGBA(dst->format, colorptr[3], colorptr[2], colorptr[1], colorptr[0]);\n\t}\n\n\n\tif (rx > ry) {\n\t    ix = 0;\n\t    iy = rx * 64;\n\n\t    do {\n\t\th = (ix + 32) >> 6;\n\t\ti = (iy + 32) >> 6;\n\t\tj = (h * ry) / rx;\n\t\tk = (i * ry) / rx;\n\n\t\tif (((ok != k) && (oj != k)) || ((oj != j) && (ok != j)) || (k != j)) {\n\t\t    xph = x + h;\n\t\t    xmh = x - h;\n\t\t    if (k > 0) {\n\t\t\typk = y + k;\n\t\t\tymk = y - k;\n\t\t\tresult |= fastPixelColorNolock(dst, xmh, ypk, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xph, ypk, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xmh, ymk, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xph, ymk, color);\n\t\t    } else {\n\t\t\tresult |= fastPixelColorNolock(dst, xmh, y, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xph, y, color);\n\t\t    }\n\t\t    ok = k;\n\t\t    xpi = x + i;\n\t\t    xmi = x - i;\n\t\t    if (j > 0) {\n\t\t\typj = y + j;\n\t\t\tymj = y - j;\n\t\t\tresult |= fastPixelColorNolock(dst, xmi, ypj, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpi, ypj, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xmi, ymj, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpi, ymj, color);\n\t\t    } else {\n\t\t\tresult |= fastPixelColorNolock(dst, xmi, y, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpi, y, color);\n\t\t    }\n\t\t    oj = j;\n\t\t}\n\n\t\tix = ix + iy / rx;\n\t\tiy = iy - ix / rx;\n\n\t    } while (i > h);\n\t} else {\n\t    ix = 0;\n\t    iy = ry * 64;\n\n\t    do {\n\t\th = (ix + 32) >> 6;\n\t\ti = (iy + 32) >> 6;\n\t\tj = (h * rx) / ry;\n\t\tk = (i * rx) / ry;\n\n\t\tif (((oi != i) && (oh != i)) || ((oh != h) && (oi != h) && (i != h))) {\n\t\t    xmj = x - j;\n\t\t    xpj = x + j;\n\t\t    if (i > 0) {\n\t\t\typi = y + i;\n\t\t\tymi = y - i;\n\t\t\tresult |= fastPixelColorNolock(dst, xmj, ypi, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpj, ypi, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xmj, ymi, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpj, ymi, color);\n\t\t    } else {\n\t\t\tresult |= fastPixelColorNolock(dst, xmj, y, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpj, y, color);\n\t\t    }\n\t\t    oi = i;\n\t\t    xmk = x - k;\n\t\t    xpk = x + k;\n\t\t    if (h > 0) {\n\t\t\typh = y + h;\n\t\t\tymh = y - h;\n\t\t\tresult |= fastPixelColorNolock(dst, xmk, yph, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpk, yph, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xmk, ymh, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpk, ymh, color);\n\t\t    } else {\n\t\t\tresult |= fastPixelColorNolock(dst, xmk, y, color);\n\t\t\tresult |= fastPixelColorNolock(dst, xpk, y, color);\n\t\t    }\n\t\t    oh = h;\n\t\t}\n\n\t\tix = ix + iy / ry;\n\t\tiy = iy - ix / ry;\n\n\t    } while (i > h);\n\t}\n\n    } else {\n\n\tif (rx > ry) {\n\t    ix = 0;\n\t    iy = rx * 64;\n\n\t    do {\n\t\th = (ix + 32) >> 6;\n\t\ti = (iy + 32) >> 6;\n\t\tj = (h * ry) / rx;\n\t\tk = (i * ry) / rx;\n\n\t\tif (((ok != k) && (oj != k)) || ((oj != j) && (ok != j)) || (k != j)) {\n\t\t    xph = x + h;\n\t\t    xmh = x - h;\n\t\t    if (k > 0) {\n\t\t\typk = y + k;\n\t\t\tymk = y - k;\n\t\t\tresult |= pixelColorNolock (dst, xmh, ypk, color);\n\t\t\tresult |= pixelColorNolock (dst, xph, ypk, color);\n\t\t\tresult |= pixelColorNolock (dst, xmh, ymk, color);\n\t\t\tresult |= pixelColorNolock (dst, xph, ymk, color);\n\t\t    } else {\n\t\t\tresult |= pixelColorNolock (dst, xmh, y, color);\n\t\t\tresult |= pixelColorNolock (dst, xph, y, color);\n\t\t    }\n\t\t    ok = k;\n\t\t    xpi = x + i;\n\t\t    xmi = x - i;\n\t\t    if (j > 0) {\n\t\t\typj = y + j;\n\t\t\tymj = y - j;\n\t\t\tresult |= pixelColorNolock (dst, xmi, ypj, color);\n\t\t\tresult |= pixelColorNolock (dst, xpi, ypj, color);\n\t\t\tresult |= pixelColorNolock (dst, xmi, ymj, color);\n\t\t\tresult |= pixelColor(dst, xpi, ymj, color);\n\t\t    } else {\n\t\t\tresult |= pixelColorNolock (dst, xmi, y, color);\n\t\t\tresult |= pixelColorNolock (dst, xpi, y, color);\n\t\t    }\n\t\t    oj = j;\n\t\t}\n\n\t\tix = ix + iy / rx;\n\t\tiy = iy - ix / rx;\n\n\t    } while (i > h);\n\t} else {\n\t    ix = 0;\n\t    iy = ry * 64;\n\n\t    do {\n\t\th = (ix + 32) >> 6;\n\t\ti = (iy + 32) >> 6;\n\t\tj = (h * rx) / ry;\n\t\tk = (i * rx) / ry;\n\n\t\tif (((oi != i) && (oh != i)) || ((oh != h) && (oi != h) && (i != h))) {\n\t\t    xmj = x - j;\n\t\t    xpj = x + j;\n\t\t    if (i > 0) {\n\t\t\typi = y + i;\n\t\t\tymi = y - i;\n\t\t\tresult |= pixelColorNolock (dst, xmj, ypi, color);\n\t\t\tresult |= pixelColorNolock (dst, xpj, ypi, color);\n\t\t\tresult |= pixelColorNolock (dst, xmj, ymi, color);\n\t\t\tresult |= pixelColorNolock (dst, xpj, ymi, color);\n\t\t    } else {\n\t\t\tresult |= pixelColorNolock (dst, xmj, y, color);\n\t\t\tresult |= pixelColorNolock (dst, xpj, y, color);\n\t\t    }\n\t\t    oi = i;\n\t\t    xmk = x - k;\n\t\t    xpk = x + k;\n\t\t    if (h > 0) {\n\t\t\typh = y + h;\n\t\t\tymh = y - h;\n\t\t\tresult |= pixelColorNolock (dst, xmk, yph, color);\n\t\t\tresult |= pixelColorNolock (dst, xpk, yph, color);\n\t\t\tresult |= pixelColorNolock (dst, xmk, ymh, color);\n\t\t\tresult |= pixelColorNolock (dst, xpk, ymh, color);\n\t\t    } else {\n\t\t\tresult |= pixelColorNolock (dst, xmk, y, color);\n\t\t\tresult |= pixelColorNolock (dst, xpk, y, color);\n\t\t    }\n\t\t    oh = h;\n\t\t}\n\n\t\tix = ix + iy / ry;\n\t\tiy = iy - ix / ry;\n\n\t    } while (i > h);\n\t}\n\n    }\t\t\t\t/* Alpha check */\n\n    /* Unlock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tSDL_UnlockSurface(dst);\n    }\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "// \n", "func_signal": "void STK_SlidebarDraw(STK_Widget *widget)", "code": "{\n\tSTK_Slidebar *slider = (STK_Slidebar *)widget;\n\tSDL_Rect r;\n\tSDL_Surface *s = widget->surface;\n\tUint32 tmpcolor;\n\tint bx, by;\n\n\tif (slider->orientation == STK_SLIDEBAR_VERTICAL) {\n\t\tbx = widget->border;\n\t\tby = slider->curpixel;\n\t}\n\telse {\n\t\tbx = slider->curpixel;\n\t\tby = widget->border;\t\t\n\t}\n\n\t// fill background\n\ttmpcolor = SDL_MapRGB(widget->surface->format, widget->bgcolor.r, widget->bgcolor.g, widget->bgcolor.b);\n\tSDL_FillRect(s, NULL, tmpcolor);\n\t\n\tSTK_BaseRectAssign(\t&r, \n\t\t\t\tbx,\n\t\t\t\tby,\n\t\t\t\tslider->b_width,\n\t\t\t\tslider->b_height );\n\ttmpcolor = SDL_MapRGB(widget->surface->format, widget->fgcolor.r, widget->fgcolor.g, widget->fgcolor.b);\n\tSDL_FillRect(s, &r, tmpcolor);\n\t// draw outer border\n\tSTK_ImageDrawFrame(s, STK_IMAGE_FRAME_CONCAVE);\n\t// draw inner border\n\tSTK_ImageDrawFrameWithRect(s, &r, STK_IMAGE_FRAME_CONVEX);\n\t\n\treturn;\n}", "path": "stk_slidebar.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ----- Pixel - fast, no blending, no locking, clipping */\n", "func_signal": "int fastPixelColorNolock(SDL_Surface * dst, Sint16 x, Sint16 y, Uint32 color)", "code": "{\n    int bpp;\n    Uint8 *p;\n\n    /*\n     * Honor clipping setup at pixel level \n     */\n    if ((x >= clip_xmin(dst)) && (x <= clip_xmax(dst)) && (y >= clip_ymin(dst)) && (y <= clip_ymax(dst))) {\n\n\t/*\n\t * Get destination format \n\t */\n\tbpp = dst->format->BytesPerPixel;\n\tp = (Uint8 *) dst->pixels + y * dst->pitch + x * bpp;\n\tswitch (bpp) {\n\tcase 1:\n\t    *p = color;\n\t    break;\n\tcase 2:\n\t    *(Uint16 *) p = color;\n\t    break;\n\tcase 3:\n\t    if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n\t\tp[0] = (color >> 16) & 0xff;\n\t\tp[1] = (color >> 8) & 0xff;\n\t\tp[2] = color & 0xff;\n\t    } else {\n\t\tp[0] = color & 0xff;\n\t\tp[1] = (color >> 8) & 0xff;\n\t\tp[2] = (color >> 16) & 0xff;\n\t    }\n\t    break;\n\tcase 4:\n\t    *(Uint32 *) p = color;\n\t    break;\n\t}\t\t\t/* switch */\n\n\n    }\n\n    return (0);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ---- Polygon */\n", "func_signal": "int polygonColor(SDL_Surface * dst, Sint16 * vx, Sint16 * vy, int n, Uint32 color)", "code": "{\n    int result;\n    int i;\n    Sint16 *x1, *y1, *x2, *y2;\n\n    /*\n     * Sanity check \n     */\n    if (n < 3) {\n\treturn (-1);\n    }\n\n    /*\n     * Pointer setup \n     */\n    x1 = x2 = vx;\n    y1 = y2 = vy;\n    x2++;\n    y2++;\n\n    /*\n     * Draw \n     */\n    result = 0;\n    for (i = 1; i < n; i++) {\n\tresult |= STK_PrimDrawLine(dst, *x1, *y1, *x2, *y2, color);\n\tx1 = x2;\n\ty1 = y2;\n\tx2++;\n\ty2++;\n    }\n    result |= STK_PrimDrawLine(dst, *x1, *y1, *vx, *vy, color);\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* AA-Trigon */\n", "func_signal": "int aatrigonColor(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint32 color)", "code": "{\n    Sint16 vx[3]; \n    Sint16 vy[3];\n \n    vx[0]=x1;\n    vx[1]=x2;\n    vx[2]=x3;\n    vy[0]=y1;\n    vy[1]=y2;\n    vy[2]=y3;\n \n    return(aapolygonColor(dst,vx,vy,3,color));\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ----- Rectangle */\n", "func_signal": "int STK_PrimRectColor(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint32 color)", "code": "{\n    int result;\n    Sint16 w, h, xtmp, ytmp;\n\n    /*\n     * Swap x1, x2 if required \n     */\n    if (x1 > x2) {\n\txtmp = x1;\n\tx1 = x2;\n\tx2 = xtmp;\n    }\n\n    /*\n     * Swap y1, y2 if required \n     */\n    if (y1 > y2) {\n\tytmp = y1;\n\ty1 = y2;\n\ty2 = ytmp;\n    }\n\n    /*\n     * Calculate width&height \n     */\n    w = x2 - x1;\n    h = y2 - y1;\n\n    /*\n     * Sanity check \n     */\n    if ((w < 0) || (h < 0)) {\n\treturn (0);\n    }\n\n    /*\n     * Test for special cases of straight lines or single point \n     */\n    if (x1 == x2) {\n\tif (y1 == y2) {\n\t    return (pixelColor(dst, x1, y1, color));\n\t} else {\n\t    return (vlineColor(dst, x1, y1, y2, color));\n\t}\n    } else {\n\tif (y1 == y2) {\n\t    return (hlineColor(dst, x1, x2, y1, color));\n\t}\n    }\n\n    /*\n     * Draw rectangle \n     */\n    result = 0;\n    result |= hlineColor(dst, x1, x2, y1, color);\n    result |= hlineColor(dst, x1, x2, y2, color);\n    y1 += 1;\n    y2 -= 1;\n    if (y1<=y2) {\n        result |= vlineColor(dst, x1, y1, y2, color);\n        result |= vlineColor(dst, x2, y1, y2, color);\n    }\n    return (result);\n\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* (faster but dangerous, make sure we stay in surface bounds) */\n", "func_signal": "int fastPixelColorNolockNoclip(SDL_Surface * dst, Sint16 x, Sint16 y, Uint32 color)", "code": "{\n    int bpp;\n    Uint8 *p;\n\n    /*\n     * Get destination format \n     */\n    bpp = dst->format->BytesPerPixel;\n    p = (Uint8 *) dst->pixels + y * dst->pitch + x * bpp;\n    switch (bpp) {\n    case 1:\n\t*p = color;\n\tbreak;\n    case 2:\n\t*(Uint16 *) p = color;\n\tbreak;\n    case 3:\n\tif (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n\t    p[0] = (color >> 16) & 0xff;\n\t    p[1] = (color >> 8) & 0xff;\n\t    p[2] = color & 0xff;\n\t} else {\n\t    p[0] = color & 0xff;\n\t    p[1] = (color >> 8) & 0xff;\n\t    p[2] = (color >> 16) & 0xff;\n\t}\n\tbreak;\n    case 4:\n \t*(Uint32 *) p = color;\n\tbreak;\n    }\t\t\t\t/* switch */\n\n    return (0);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* Just store color including alpha, no blending */\n", "func_signal": "int hlineColorStore(SDL_Surface * dst, Sint16 x1, Sint16 x2, Sint16 y, Uint32 color)", "code": "{\n    Sint16 left, right, top, bottom;\n    Uint8 *pixel, *pixellast;\n    int dx;\n    int pixx, pixy;\n    Sint16 w;\n    Sint16 xtmp;\n    int result = -1;\n\n    /*\n     * Get clipping boundary \n     */\n    left = dst->clip_rect.x;\n    right = dst->clip_rect.x + dst->clip_rect.w - 1;\n    top = dst->clip_rect.y;\n    bottom = dst->clip_rect.y + dst->clip_rect.h - 1;\n\n    /*\n     * Check visibility of hline \n     */\n    if ((x1<left) && (x2<left)) {\n        return(0);\n    }\n    if ((x1>right) && (x2>right)) {\n        return(0);\n    }\n    if ((y<top) || (y>bottom)) {\n        return (0);\n    }\n\n    /*\n     * Clip x \n     */\n    if (x1 < left) {\n\tx1 = left;\n    }\n    if (x2 > right) {\n\tx2 = right;\n    }\n\n    /*\n     * Swap x1, x2 if required \n     */\n    if (x1 > x2) {\n\txtmp = x1;\n\tx1 = x2;\n\tx2 = xtmp;\n    }\n\n    /*\n     * Calculate width \n     */\n    w = x2 - x1;\n\n    /*\n     * Sanity check on width \n     */\n    if (w < 0) {\n\treturn (0);\n    }\n\n    /*\n     * Lock surface \n     */\n    SDL_LockSurface(dst);\n\n    /*\n     * More variable setup \n     */\n    dx = w;\n    pixx = dst->format->BytesPerPixel;\n    pixy = dst->pitch;\n    pixel = ((Uint8 *) dst->pixels) + pixx * (int) x1 + pixy * (int) y;\n\n    /*\n     * Draw \n     */\n    switch (dst->format->BytesPerPixel) {\n    case 1:\n        memset(pixel, color, dx);\n        break;\n    case 2:\n        pixellast = pixel + dx + dx;\n        for (; pixel <= pixellast; pixel += pixx) {\n            *(Uint16 *) pixel = color;\n        }\n        break;\n    case 3:\n        pixellast = pixel + dx + dx + dx;\n        for (; pixel <= pixellast; pixel += pixx) {\n            if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n                pixel[0] = (color >> 16) & 0xff;\n                pixel[1] = (color >> 8) & 0xff;\n                pixel[2] = color & 0xff;\n            } else {\n                pixel[0] = color & 0xff;\n                pixel[1] = (color >> 8) & 0xff;\n                pixel[2] = (color >> 16) & 0xff;\n            }\n        }\n        break;\n    default:\t\t/* case 4 */\n        dx = dx + dx;\n        pixellast = pixel + dx + dx;\n        for (; pixel <= pixellast; pixel += pixx) {\n            *(Uint32 *) pixel = color;\n        }\n        break;\n    }\n\n    /*\n     * Unlock surface \n     */\n    SDL_UnlockSurface(dst);\n\n    /*\n     * Set result code \n     */\n    result = 0;\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ----- Filled rectangle (Box) */\n", "func_signal": "int STK_PrimBoxColor(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint32 color)", "code": "{\n    Sint16 left, right, top, bottom;\n    Uint8 *pixel, *pixellast;\n    int x, dx;\n    int dy;\n    int pixx, pixy;\n    Sint16 w, h, tmp;\n    int result;\n    Uint8 *colorptr;\n\n    /*\n     * Get clipping boundary \n     */\n    left = dst->clip_rect.x;\n    right = dst->clip_rect.x + dst->clip_rect.w - 1;\n    top = dst->clip_rect.y;\n    bottom = dst->clip_rect.y + dst->clip_rect.h - 1;\n    \n    /* Check visibility */\n    if ((x1<left) && (x2<left)) {\n        return(0);\n    }\n    if ((x1>right) && (x2>right)) {\n        return(0);\n    }\n    if ((y1<top) && (y2<top)) {\n        return(0);\n    }\n    if ((y1>bottom) && (y2>bottom)) {\n        return(0);\n    }\n     \n    /* Clip all points */\n    if (x1<left) { \n        x1=left; \n    } else if (x1>right) {\n        x1=right;\n    }\n    if (x2<left) { \n        x2=left; \n    } else if (x2>right) {\n        x2=right;\n    }\n    if (y1<top) { \n        y1=top; \n    } else if (y1>bottom) {\n        y1=bottom;\n    }\n    if (y2<top) { \n        y2=top; \n    } else if (y2>bottom) {\n        y2=bottom;\n    }\n\n    /*\n     * Order coordinates \n     */\n    if (x1 > x2) {\n\ttmp = x1;\n\tx1 = x2;\n\tx2 = tmp;\n    }\n    if (y1 > y2) {\n\ttmp = y1;\n\ty1 = y2;\n\ty2 = tmp;\n    }\n\n    /*\n     * Test for special cases of straight line or single point \n     */\n    if (x1 == x2) {\n\tif (y1 == y2) {\n\t    return (pixelColor(dst, x1, y1, color));\n\t} else { \n\t    return (vlineColor(dst, x1, y1, y2, color));\n\t}\n    }\n    if (y1 == y2) {\n\treturn (hlineColor(dst, x1, x2, y1, color));\n    }\n\n\n    /*\n     * Calculate width&height \n     */\n    w = x2 - x1;\n    h = y2 - y1;\n\n    /*\n     * Alpha check \n     */\n    if ((color & 255) == 255) {\n\n\t/*\n\t * No alpha-blending required \n\t */\n\n\t/*\n\t * Setup color \n\t */\n\tcolorptr = (Uint8 *) & color;\n\tif (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n\t    color = SDL_MapRGBA(dst->format, colorptr[0], colorptr[1], colorptr[2], colorptr[3]);\n\t} else {\n\t    color = SDL_MapRGBA(dst->format, colorptr[3], colorptr[2], colorptr[1], colorptr[0]);\n\t}\n\n\t/*\n\t * Lock surface \n\t */\n\tSDL_LockSurface(dst);\n\n\t/*\n\t * More variable setup \n\t */\n\tdx = w;\n\tdy = h;\n\tpixx = dst->format->BytesPerPixel;\n\tpixy = dst->pitch;\n\tpixel = ((Uint8 *) dst->pixels) + pixx * (int) x1 + pixy * (int) y1;\n\tpixellast = pixel + pixx * dx + pixy * dy;\n\tdx++;\n\t\n\t/*\n\t * Draw \n\t */\n\tswitch (dst->format->BytesPerPixel) {\n\tcase 1:\n\t    for (; pixel <= pixellast; pixel += pixy) {\n\t\tmemset(pixel, (Uint8) color, dx);\n\t    }\n\t    break;\n\tcase 2:\n\t    pixy -= (pixx * dx);\n\t    for (; pixel <= pixellast; pixel += pixy) {\n\t\tfor (x = 0; x < dx; x++) {\n\t\t    *(Uint16 *) pixel = color;\n\t\t    pixel += pixx;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\t    pixy -= (pixx * dx);\n\t    for (; pixel <= pixellast; pixel += pixy) {\n\t\tfor (x = 0; x < dx; x++) {\n\t\t    if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n\t\t\tpixel[0] = (color >> 16) & 0xff;\n\t\t\tpixel[1] = (color >> 8) & 0xff;\n\t\t\tpixel[2] = color & 0xff;\n\t\t    } else {\n\t\t\tpixel[0] = color & 0xff;\n\t\t\tpixel[1] = (color >> 8) & 0xff;\n\t\t\tpixel[2] = (color >> 16) & 0xff;\n\t\t    }\n\t\t    pixel += pixx;\n\t\t}\n\t    }\n\t    break;\n\tdefault:\t\t/* case 4 */\n\t    pixy -= (pixx * dx);\n\t    for (; pixel <= pixellast; pixel += pixy) {\n\t\tfor (x = 0; x < dx; x++) {\n\t\t    *(Uint32 *) pixel = color;\n\t\t    pixel += pixx;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\t/*\n\t * Unlock surface \n\t */\n\tSDL_UnlockSurface(dst);\n\n\tresult = 0;\n\n    } else {\n\n\tresult = filledRectAlpha(dst, x1, y1, x1 + w, y1 + h, color);\n\n    }\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* Based on code from Anders Lindstroem, based on code from SGE, based on code from TwinLib */\n", "func_signal": "int aaellipseColor(SDL_Surface * dst, Sint16 xc, Sint16 yc, Sint16 rx, Sint16 ry, Uint32 color)", "code": "{\n    Sint16 left, right, top, bottom;\n    Sint16 x1,y1,x2,y2;\n    int i;\n    int a2, b2, ds, dt, dxt, t, s, d;\n    Sint16 x, y, xs, ys, dyt, xx, yy, xc2, yc2;\n    float cp;\n    Uint8 weight, iweight;\n    int result;\n\n    /*\n     * Sanity check radii \n     */\n    if ((rx < 0) || (ry < 0)) {\n\treturn (-1);\n    }\n\n    /*\n     * Special case for rx=0 - draw a vline \n     */\n    if (rx == 0) {\n\treturn (vlineColor(dst, xc, yc - ry, yc + ry, color));\n    }\n    /*\n     * Special case for ry=0 - draw a hline \n     */\n    if (ry == 0) {\n\treturn (hlineColor(dst, xc - rx, xc + rx, yc, color));\n    }\n\n    /*\n     * Get clipping boundary \n     */\n    left = dst->clip_rect.x;\n    right = dst->clip_rect.x + dst->clip_rect.w - 1;\n    top = dst->clip_rect.y;\n    bottom = dst->clip_rect.y + dst->clip_rect.h - 1;\n\n    /*\n     * Test if bounding box of ellipse is visible \n     */\n    x1 = xc - rx;\n    x2 = xc + rx;\n    y1 = yc - ry;\n    y2 = yc + ry;\n    if ((x1<left) && (x2<left)) {\n        return(0);\n    } \n    if ((x1>right) && (x2>right)) {\n        return(0);\n    } \n    if ((y1<top) && (y2<top)) {\n        return(0);\n    } \n    if ((y1>bottom) && (y2>bottom)) {\n        return(0);\n    } \n    \n    /* Variable setup */\n    a2 = rx * rx;\n    b2 = ry * ry;\n\n    ds = 2 * a2;\n    dt = 2 * b2;\n\n    xc2 = 2 * xc;\n    yc2 = 2 * yc;\n\n    dxt = (int) (a2 / sqrt(a2 + b2));\n\n    t = 0;\n    s = -2 * a2 * ry;\n    d = 0;\n\n    x = xc;\n    y = yc - ry;\n\n    /* Draw */\n    result = 0;\n\n    /* Lock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tif (SDL_LockSurface(dst) < 0) {\n\t    return (-1);\n\t}\n    }\n\n    /* \"End points\" */\n    result |= pixelColorNolock(dst, x, y, color);\n    result |= pixelColorNolock(dst, xc2 - x, y, color);\n    result |= pixelColorNolock(dst, x, yc2 - y, color);\n    result |= pixelColorNolock(dst, xc2 - x, yc2 - y, color);\n\n    for (i = 1; i <= dxt; i++) {\n\tx--;\n\td += t - b2;\n\n\tif (d >= 0)\n\t    ys = y - 1;\n\telse if ((d - s - a2) > 0) {\n\t    if ((2 * d - s - a2) >= 0)\n\t\tys = y + 1;\n\t    else {\n\t\tys = y;\n\t\ty++;\n\t\td -= s + a2;\n\t\ts += ds;\n\t    }\n\t} else {\n\t    y++;\n\t    ys = y + 1;\n\t    d -= s + a2;\n\t    s += ds;\n\t}\n\n\tt -= dt;\n\n\t/* Calculate alpha */\n\tif (s != 0.0) {\n\t    cp = (float) abs(d) / (float) abs(s);\n\t    if (cp > 1.0) {\n\t\tcp = 1.0;\n\t    }\n\t} else {\n\t    cp = 1.0;\n\t}\n\n\t/* Calculate weights */\n\tweight = (Uint8) (cp * 255);\n\tiweight = 255 - weight;\n\n\t/* Upper half */\n\txx = xc2 - x;\n\tresult |= pixelColorWeightNolock(dst, x, y, color, iweight);\n\tresult |= pixelColorWeightNolock(dst, xx, y, color, iweight);\n\n\tresult |= pixelColorWeightNolock(dst, x, ys, color, weight);\n\tresult |= pixelColorWeightNolock(dst, xx, ys, color, weight);\n\n\t/* Lower half */\n\tyy = yc2 - y;\n\tresult |= pixelColorWeightNolock(dst, x, yy, color, iweight);\n\tresult |= pixelColorWeightNolock(dst, xx, yy, color, iweight);\n\n\tyy = yc2 - ys;\n\tresult |= pixelColorWeightNolock(dst, x, yy, color, weight);\n\tresult |= pixelColorWeightNolock(dst, xx, yy, color, weight);\n    }\n\n    dyt = abs(y - yc);\n\n    for (i = 1; i <= dyt; i++) {\n\ty++;\n\td -= s + a2;\n\n\tif (d <= 0)\n\t    xs = x + 1;\n\telse if ((d + t - b2) < 0) {\n\t    if ((2 * d + t - b2) <= 0)\n\t\txs = x - 1;\n\t    else {\n\t\txs = x;\n\t\tx--;\n\t\td += t - b2;\n\t\tt -= dt;\n\t    }\n\t} else {\n\t    x--;\n\t    xs = x - 1;\n\t    d += t - b2;\n\t    t -= dt;\n\t}\n\n\ts += ds;\n\n\t/* Calculate alpha */\n\tif (t != 0.0) {\n\t    cp = (float) abs(d) / (float) abs(t);\n\t    if (cp > 1.0) {\n\t\tcp = 1.0;\n\t    }\n\t} else {\n\t    cp = 1.0;\n\t}\n\n\t/* Calculate weight */\n\tweight = (Uint8) (cp * 255);\n\tiweight = 255 - weight;\n\n\t/* Left half */\n\txx = xc2 - x;\n\tyy = yc2 - y;\n\tresult |= pixelColorWeightNolock(dst, x, y, color, iweight);\n\tresult |= pixelColorWeightNolock(dst, xx, y, color, iweight);\n\n\tresult |= pixelColorWeightNolock(dst, x, yy, color, iweight);\n\tresult |= pixelColorWeightNolock(dst, xx, yy, color, iweight);\n\n\t/* Right half */\n\txx = 2 * xc - xs;\n\tresult |= pixelColorWeightNolock(dst, xs, y, color, weight);\n\tresult |= pixelColorWeightNolock(dst, xx, y, color, weight);\n\n\tresult |= pixelColorWeightNolock(dst, xs, yy, color, weight);\n\tresult |= pixelColorWeightNolock(dst, xx, yy, color, weight);\n\n\n    }\n\n    /* Unlock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tSDL_UnlockSurface(dst);\n    }\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* Trigon */\n", "func_signal": "int trigonColor(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint32 color)", "code": "{\n    Sint16 vx[3]; \n    Sint16 vy[3];\n \n    vx[0]=x1;\n    vx[1]=x2;\n    vx[2]=x3;\n    vy[0]=y1;\n    vy[1]=y2;\n    vy[2]=y3;\n \n    return(polygonColor(dst,vx,vy,3,color));\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* Filled rectangle with alpha blending, color in destination format */\n", "func_signal": "int _filledRectAlpha(SDL_Surface * surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint32 color, Uint8 alpha)", "code": "{\n    Uint32 Rmask = surface->format->Rmask, Gmask =\n\tsurface->format->Gmask, Bmask = surface->format->Bmask, Amask = surface->format->Amask;\n    Uint32 R, G, B, A = 0;\n    Sint16 x, y;\n\n    switch (surface->format->BytesPerPixel) {\n    case 1:{\t\t\t/* Assuming 8-bpp */\n        Uint8 *row, *pixel;\n        Uint8 dR, dG, dB;\n\n        Uint8 sR = surface->format->palette->colors[color].r;\n        Uint8 sG = surface->format->palette->colors[color].g;\n        Uint8 sB = surface->format->palette->colors[color].b;\n\n        for (y = y1; y <= y2; y++) {\n            row = (Uint8 *) surface->pixels + y * surface->pitch;\n            for (x = x1; x <= x2; x++) {\n                pixel = row + x;\n\n                dR = surface->format->palette->colors[*pixel].r;\n                dG = surface->format->palette->colors[*pixel].g;\n                dB = surface->format->palette->colors[*pixel].b;\n\n                dR = dR + ((sR - dR) * alpha >> 8);\n                dG = dG + ((sG - dG) * alpha >> 8);\n                dB = dB + ((sB - dB) * alpha >> 8);\n\n                *pixel = SDL_MapRGB(surface->format, dR, dG, dB);\n            }\n        }\n    }\n\tbreak;\n\n    case 2:{\t\t\t/* Probably 15-bpp or 16-bpp */\n        Uint16 *row, *pixel;\n        Uint32 dR = (color & Rmask), dG = (color & Gmask), dB = (color & Bmask), dA = (color & Amask);\n\n        for (y = y1; y <= y2; y++) {\n            row = (Uint16 *) surface->pixels + y * surface->pitch / 2;\n            for (x = x1; x <= x2; x++) {\n                pixel = row + x;\n\n                R = ((*pixel & Rmask) + ((dR - (*pixel & Rmask)) * alpha >> 8)) & Rmask;\n                G = ((*pixel & Gmask) + ((dG - (*pixel & Gmask)) * alpha >> 8)) & Gmask;\n                B = ((*pixel & Bmask) + ((dB - (*pixel & Bmask)) * alpha >> 8)) & Bmask;\n                if (Amask)\n                    A = ((*pixel & Amask) + ((dA - (*pixel & Amask)) * alpha >> 8)) & Amask;\n\n                *pixel = R | G | B | A;\n            }\n        }\n    }\n\tbreak;\n\n    case 3:{\t\t\t/* Slow 24-bpp mode, usually not used */\n        Uint8 *row, *pix;\n        Uint8 dR, dG, dB, dA;\n        Uint8 rshift8 = surface->format->Rshift / 8;\n        Uint8 gshift8 = surface->format->Gshift / 8;\n        Uint8 bshift8 = surface->format->Bshift / 8;\n        Uint8 ashift8 = surface->format->Ashift / 8;\n\n        Uint8 sR = (color >> surface->format->Rshift) & 0xff;\n        Uint8 sG = (color >> surface->format->Gshift) & 0xff;\n        Uint8 sB = (color >> surface->format->Bshift) & 0xff;\n        Uint8 sA = (color >> surface->format->Ashift) & 0xff;\n\n        for (y = y1; y <= y2; y++) {\n            row = (Uint8 *) surface->pixels + y * surface->pitch;\n            for (x = x1; x <= x2; x++) {\n                pix = row + x * 3;\n\n                dR = *((pix) + rshift8);\n                dG = *((pix) + gshift8);\n                dB = *((pix) + bshift8);\n                dA = *((pix) + ashift8);\n\n                dR = dR + ((sR - dR) * alpha >> 8);\n                dG = dG + ((sG - dG) * alpha >> 8);\n                dB = dB + ((sB - dB) * alpha >> 8);\n                dA = dA + ((sA - dA) * alpha >> 8);\n\n                *((pix) + rshift8) = dR;\n                *((pix) + gshift8) = dG;\n                *((pix) + bshift8) = dB;\n                *((pix) + ashift8) = dA;\n            }\n        }\n\n    }\n\tbreak;\n\n    case 4:{\t\t\t/* Probably 32-bpp */\n        Uint32 *row, *pixel;\n        Uint32 dR = (color & Rmask), dG = (color & Gmask), dB = (color & Bmask), dA = (color & Amask);\n\n        for (y = y1; y <= y2; y++) {\n            row = (Uint32 *) surface->pixels + y * surface->pitch / 4;\n            for (x = x1; x <= x2; x++) {\n                pixel = row + x;\n\n                R = ((*pixel & Rmask) + ((dR - (*pixel & Rmask)) * alpha >> 8)) & Rmask;\n                G = ((*pixel & Gmask) + ((dG - (*pixel & Gmask)) * alpha >> 8)) & Gmask;\n                B = ((*pixel & Bmask) + ((dB - (*pixel & Bmask)) * alpha >> 8)) & Bmask;\n                if (Amask)\n                    A = ((*pixel & Amask) + ((dA - (*pixel & Amask)) * alpha >> 8)) & Amask;\n\n                *pixel = R | G | B | A;\n            }\n        }\n    }\n\tbreak;\n    }\n\n    return (0);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ----- Pixel - pixel draw with blending enabled if a<255 */\n", "func_signal": "int pixelColor(SDL_Surface * dst, Sint16 x, Sint16 y, Uint32 color)", "code": "{\n    Uint8 alpha;\n    Uint32 mcolor;\n    int result = 0;\n\n    /*\n     * Lock the surface \n     */\n    if (SDL_MUSTLOCK(dst)) {\n\tif (SDL_LockSurface(dst) < 0) {\n\t    return (-1);\n\t}\n    }\n\n    /*\n     * Setup color \n     */\n    alpha = color & 0x000000ff;\n    mcolor =\n\tSDL_MapRGBA(dst->format, (color & 0xff000000) >> 24,\n\t\t    (color & 0x00ff0000) >> 16, (color & 0x0000ff00) >> 8, alpha);\n\n    /*\n     * Draw \n     */\n    result = _putPixelAlpha(dst, x, y, mcolor, alpha);\n\n    /*\n     * Unlock the surface \n     */\n    if (SDL_MUSTLOCK(dst)) {\n\tSDL_UnlockSurface(dst);\n    }\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ----- Pixel - fast, no blending, no locking RGB input */\n", "func_signal": "int fastPixelRGBANolock(SDL_Surface * dst, Sint16 x, Sint16 y, Uint8 r, Uint8 g, Uint8 b, Uint8 a)", "code": "{\n    Uint32 color;\n\n    /*\n     * Setup color \n     */\n    color = SDL_MapRGBA(dst->format, r, g, b, a);\n\n    /*\n     * Draw \n     */\n    return (fastPixelColorNolock(dst, x, y, color));\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* ---- AA-Polygon */\n", "func_signal": "int aapolygonColor(SDL_Surface * dst, Sint16 * vx, Sint16 * vy, int n, Uint32 color)", "code": "{\n    int result;\n    int i;\n    Sint16 *x1, *y1, *x2, *y2;\n\n    /*\n     * Sanity check \n     */\n    if (n < 3) {\n\treturn (-1);\n    }\n\n    /*\n     * Pointer setup \n     */\n    x1 = x2 = vx;\n    y1 = y2 = vy;\n    x2++;\n    y2++;\n\n    /*\n     * Draw \n     */\n    result = 0;\n    for (i = 1; i < n; i++) {\n\tresult |= aalineColorInt(dst, *x1, *y1, *x2, *y2, color, 0);\n\tx1 = x2;\n\ty1 = y2;\n\tx2++;\n\ty2++;\n    }\n    result |= aalineColorInt(dst, *x1, *y1, *vx, *vy, color, 0);\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/*\n  Calculate bezier interpolator of data array with ndata values at position 't'\n*/\n", "func_signal": "double evaluateBezier (double *data, int ndata, double t)", "code": "{\n    double mu, result;\n    int n,k,kn,nn,nkn;\n    double blend,muk,munk;\n     \n    /* Sanity check bounds */\n    if (t<0.0) {\n        return(data[0]);\n    }\n    if (t>=(double)ndata) {\n        return(data[ndata-1]);\n    }\n  \n    /* Adjust t to the range 0.0 to 1.0 */ \n    mu=t/(double)ndata;\n \n    /* Calculate interpolate */\n    n=ndata-1;\n    result=0.0;\n    muk = 1;\n    munk = pow(1-mu,(double)n);\n    for (k=0;k<=n;k++) \n    {\n        nn = n;\n        kn = k;\n        nkn = n - k;\n        blend = muk * munk;\n        muk *= mu;\n        munk /= (1-mu);\n        while (nn >= 1) \n        {\n            blend *= nn;\n            nn--;\n            if (kn > 1) \n            {\n                blend /= (double)kn;\n                kn--;\n            }\n            if (nkn > 1)\n            {\n                blend /= (double)nkn;\n                nkn--;\n            }\n        }\n        result += data[k] * blend;\n    }\n                                                          \n    return(result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "// now, we only use linear array to store output message, not circle array\n", "func_signal": "int STK_MsgBoxCalcDisplayLineWindow(STK_MsgBox *msgbox, int font_height)", "code": "{\n\tint sum;\n\tint d = (msgbox->end_line + STK_MSGBOX_LINEBUF_NUM - msgbox->start_line) % STK_MSGBOX_LINEBUF_NUM;\n\t\n\tsum = font_height*d + msgbox->interval*(d - 1);\n\t\n\twhile (sum >= msgbox->textarea.h) {\n\t\tsum -= (font_height + msgbox->interval);\n\t\t// move the top line up\n\t\tmsgbox->start_line++;\n\t\tmsgbox->start_line %= STK_MSGBOX_LINEBUF_NUM; \n\t}\n\n\treturn 0;\n}", "path": "stk_msgbox.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* New, faster routine - default blending pixel */\n", "func_signal": "int _putPixelAlpha(SDL_Surface * surface, Sint16 x, Sint16 y, Uint32 color, Uint8 alpha)", "code": "{\n    Uint32 Rmask = surface->format->Rmask, Gmask =\n\tsurface->format->Gmask, Bmask = surface->format->Bmask, Amask = surface->format->Amask;\n    Uint32 R, G, B, A = 0;\n\n    if (x >= clip_xmin(surface) && x <= clip_xmax(surface)\n\t&& y >= clip_ymin(surface) && y <= clip_ymax(surface)) {\n\n\tswitch (surface->format->BytesPerPixel) {\n\tcase 1:{\t\t/* Assuming 8-bpp */\n            if (alpha == 255) {\n                *((Uint8 *) surface->pixels + y * surface->pitch + x) = color;\n            } else {\n                Uint8 *pixel = (Uint8 *) surface->pixels + y * surface->pitch + x;\n\n                Uint8 dR = surface->format->palette->colors[*pixel].r;\n                Uint8 dG = surface->format->palette->colors[*pixel].g;\n                Uint8 dB = surface->format->palette->colors[*pixel].b;\n                Uint8 sR = surface->format->palette->colors[color].r;\n                Uint8 sG = surface->format->palette->colors[color].g;\n                Uint8 sB = surface->format->palette->colors[color].b;\n\n                dR = dR + ((sR - dR) * alpha >> 8);\n                dG = dG + ((sG - dG) * alpha >> 8);\n                dB = dB + ((sB - dB) * alpha >> 8);\n\n                *pixel = SDL_MapRGB(surface->format, dR, dG, dB);\n            }\n        }\n\t    break;\n\n\tcase 2:{\t\t/* Probably 15-bpp or 16-bpp */\n            if (alpha == 255) {\n                *((Uint16 *) surface->pixels + y * surface->pitch / 2 + x) = color;\n            } else {\n                Uint16 *pixel = (Uint16 *) surface->pixels + y * surface->pitch / 2 + x;\n                Uint32 dc = *pixel;\n\n                R = ((dc & Rmask) + (((color & Rmask) - (dc & Rmask)) * alpha >> 8)) & Rmask;\n                G = ((dc & Gmask) + (((color & Gmask) - (dc & Gmask)) * alpha >> 8)) & Gmask;\n                B = ((dc & Bmask) + (((color & Bmask) - (dc & Bmask)) * alpha >> 8)) & Bmask;\n                if (Amask)\n                    A = ((dc & Amask) + (((color & Amask) - (dc & Amask)) * alpha >> 8)) & Amask;\n\n                *pixel = R | G | B | A;\n            }\n        }\n\t    break;\n\n\tcase 3:{\t\t/* Slow 24-bpp mode, usually not used */\n            Uint8 *pix = (Uint8 *) surface->pixels + y * surface->pitch + x * 3;\n            Uint8 rshift8 = surface->format->Rshift / 8;\n            Uint8 gshift8 = surface->format->Gshift / 8;\n            Uint8 bshift8 = surface->format->Bshift / 8;\n            Uint8 ashift8 = surface->format->Ashift / 8;\n\n\n            if (alpha == 255) {\n                *(pix + rshift8) = color >> surface->format->Rshift;\n                *(pix + gshift8) = color >> surface->format->Gshift;\n                *(pix + bshift8) = color >> surface->format->Bshift;\n                *(pix + ashift8) = color >> surface->format->Ashift;\n            } else {\n                Uint8 dR, dG, dB, dA = 0;\n                Uint8 sR, sG, sB, sA = 0;\n\n                pix = (Uint8 *) surface->pixels + y * surface->pitch + x * 3;\n\n                dR = *((pix) + rshift8);\n                dG = *((pix) + gshift8);\n                dB = *((pix) + bshift8);\n                dA = *((pix) + ashift8);\n\n                sR = (color >> surface->format->Rshift) & 0xff;\n                sG = (color >> surface->format->Gshift) & 0xff;\n                sB = (color >> surface->format->Bshift) & 0xff;\n                sA = (color >> surface->format->Ashift) & 0xff;\n\n                dR = dR + ((sR - dR) * alpha >> 8);\n                dG = dG + ((sG - dG) * alpha >> 8);\n                dB = dB + ((sB - dB) * alpha >> 8);\n                dA = dA + ((sA - dA) * alpha >> 8);\n\n                *((pix) + rshift8) = dR;\n                *((pix) + gshift8) = dG;\n                *((pix) + bshift8) = dB;\n                *((pix) + ashift8) = dA;\n            }\n        }\n\t    break;\n\n\tcase 4:{\t\t/* Probably 32-bpp */\n            if (alpha == 255) {\n                *((Uint32 *) surface->pixels + y * surface->pitch / 4 + x) = color;\n            } else {\n                Uint32 *pixel = (Uint32 *) surface->pixels + y * surface->pitch / 4 + x;\n                Uint32 dc = *pixel;\n\n                R = ((dc & Rmask) + (((color & Rmask) - (dc & Rmask)) * alpha >> 8)) & Rmask;\n                G = ((dc & Gmask) + (((color & Gmask) - (dc & Gmask)) * alpha >> 8)) & Gmask;\n                B = ((dc & Bmask) + (((color & Bmask) - (dc & Bmask)) * alpha >> 8)) & Bmask;\n                if (Amask)\n                    A = ((dc & Amask) + (((color & Amask) - (dc & Amask)) * alpha >> 8)) & Amask;\n\n                *pixel = R | G | B | A;\n            }\n        }\n\t    break;\n\t}\n    }\n\n    return (0);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/* \n\nThis implementation of the Wu antialiasing code is based on Mike Abrash's\nDDJ article which was reprinted as Chapter 42 of his Graphics Programming\nBlack Book, but has been optimized to work with SDL and utilizes 32-bit\nfixed-point arithmetic. (A. Schiffler).\n\n*/\n", "func_signal": "int aalineColorInt(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint32 color, int draw_endpoint)", "code": "{\n    Sint32 xx0, yy0, xx1, yy1;\n    int result;\n    Uint32 intshift, erracc, erradj;\n    Uint32 erracctmp, wgt, wgtcompmask;\n    int dx, dy, tmp, xdir, y0p1, x0pxdir;\n\n    /*\n     * Clip line and test if we have to draw \n     */\n    if (!(clipLine(dst, &x1, &y1, &x2, &y2))) {\n\treturn (0);\n    }\n\n    /*\n     * Keep on working with 32bit numbers \n     */\n    xx0 = x1;\n    yy0 = y1;\n    xx1 = x2;\n    yy1 = y2;\n\n    /*\n     * Reorder points if required \n     */\n    if (yy0 > yy1) {\n\ttmp = yy0;\n\tyy0 = yy1;\n\tyy1 = tmp;\n\ttmp = xx0;\n\txx0 = xx1;\n\txx1 = tmp;\n    }\n\n    /*\n     * Calculate distance \n     */\n    dx = xx1 - xx0;\n    dy = yy1 - yy0;\n\n    /*\n     * Adjust for negative dx and set xdir \n     */\n    if (dx >= 0) {\n\txdir = 1;\n    } else {\n\txdir = -1;\n\tdx = (-dx);\n    }\n\n    /*\n     * Check for special cases \n     */\n    if (dx == 0) {\n\t/*\n\t * Vertical line \n\t */\n\treturn (vlineColor(dst, x1, y1, y2, color));\n    } else if (dy == 0) {\n\t/*\n\t * Horizontal line \n\t */\n\treturn (hlineColor(dst, x1, x2, y1, color));\n    } else if (dx == dy) {\n\t/*\n\t * Diagonal line \n\t */\n\treturn (STK_PrimDrawLine(dst, x1, y1, x2, y2, color));\n    }\n\n    /*\n     * Line is not horizontal, vertical or diagonal \n     */\n    result = 0;\n\n    /*\n     * Zero accumulator \n     */\n    erracc = 0;\n\n    /*\n     * # of bits by which to shift erracc to get intensity level \n     */\n    intshift = 32 - AAbits;\n    /*\n     * Mask used to flip all bits in an intensity weighting \n     */\n    wgtcompmask = AAlevels - 1;\n\n    /* Lock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tif (SDL_LockSurface(dst) < 0) {\n\t    return (-1);\n\t}\n    }\n\n    /*\n     * Draw the initial pixel in the foreground color \n     */\n    result |= pixelColorNolock(dst, x1, y1, color);\n\n    /*\n     * x-major or y-major? \n     */\n    if (dy > dx) {\n\n\t/*\n\t * y-major.  Calculate 16-bit fixed point fractional part of a pixel that\n\t * X advances every time Y advances 1 pixel, truncating the result so that\n\t * we won't overrun the endpoint along the X axis \n\t */\n\t/*\n\t * Not-so-portable version: erradj = ((Uint64)dx << 32) / (Uint64)dy; \n\t */\n\terradj = ((dx << 16) / dy) << 16;\n\n\t/*\n\t * draw all pixels other than the first and last \n\t */\n\tx0pxdir = xx0 + xdir;\n\twhile (--dy) \n        {\n\t    erracctmp = erracc;\n\t    erracc += erradj;\n\t    if (erracc <= erracctmp) \n            {\n\t\t/*\n\t\t * rollover in error accumulator, x coord advances \n\t\t */\n\t\txx0 = x0pxdir;\n\t\tx0pxdir += xdir;\n\t    }\n\t    yy0++;\t\t/* y-major so always advance Y */\n\n\t    /*\n\t     * the AAbits most significant bits of erracc give us the intensity\n\t     * weighting for this pixel, and the complement of the weighting for\n\t     * the paired pixel. \n\t     */\n\t    wgt = (erracc >> intshift) & 255;\n\t    result |= pixelColorWeightNolock (dst, xx0, yy0, color, 255 - wgt);\n\t    result |= pixelColorWeightNolock (dst, x0pxdir, yy0, color, wgt);\n\t}\n\n    } else {\n\n\t/*\n\t * x-major line.  Calculate 16-bit fixed-point fractional part of a pixel\n\t * that Y advances each time X advances 1 pixel, truncating the result so\n\t * that we won't overrun the endpoint along the X axis. \n\t */\n\t/*\n\t * Not-so-portable version: erradj = ((Uint64)dy << 32) / (Uint64)dx; \n\t */\n\terradj = ((dy << 16) / dx) << 16;\n\n\t/*\n\t * draw all pixels other than the first and last \n\t */\n\ty0p1 = yy0 + 1;\n\twhile (--dx) {\n\n\t    erracctmp = erracc;\n\t    erracc += erradj;\n\t    if (erracc <= erracctmp) {\n\t\t/*\n\t\t * Accumulator turned over, advance y \n\t\t */\n\t\tyy0 = y0p1;\n\t\ty0p1++;\n\t    }\n\t    xx0 += xdir;\t/* x-major so always advance X */\n\t    /*\n\t     * the AAbits most significant bits of erracc give us the intensity\n\t     * weighting for this pixel, and the complement of the weighting for\n\t     * the paired pixel. \n\t     */\n\t    wgt = (erracc >> intshift) & 255;\n\t    result |= pixelColorWeightNolock (dst, xx0, yy0, color, 255 - wgt);\n\t    result |= pixelColorWeightNolock (dst, xx0, y0p1, color, wgt);\n\t}\n    }\n\n    /*\n     * Do we have to draw the endpoint \n     */\n    if (draw_endpoint) {\n\t/*\n\t * Draw final pixel, always exactly intersected by the line and doesn't\n\t * need to be weighted. \n\t */\n\tresult |= pixelColorNolock (dst, x2, y2, color);\n    }\n\n    /* Unlock surface */\n    if (SDL_MUSTLOCK(dst)) {\n\tSDL_UnlockSurface(dst);\n    }\n\n    return (result);\n}", "path": "stk_prim.c", "repo_name": "xenyinzen/stk", "stars": 3, "license": "None", "language": "c", "size": 12966}
{"docstring": "/*\n * Set composer error.\n */\n", "func_signal": "static int\nyaml_parser_set_composer_error(yaml_parser_t *parser,\n        const char *problem, yaml_mark_t problem_mark)", "code": "{\n    parser->error = YAML_COMPOSER_ERROR;\n    parser->problem = problem;\n    parser->problem_mark = problem_mark;\n\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Check the references of a node and assign the anchor id if needed.\n */\n", "func_signal": "static void\nyaml_emitter_anchor_node(yaml_emitter_t *emitter, int index)", "code": "{\n    yaml_node_t *node = emitter->document->nodes.start + index - 1;\n    yaml_node_item_t *item;\n    yaml_node_pair_t *pair;\n\n    emitter->anchors[index-1].references ++;\n\n    if (emitter->anchors[index-1].references == 1) {\n        switch (node->type) {\n            case YAML_SEQUENCE_NODE:\n                for (item = node->data.sequence.items.start;\n                        item < node->data.sequence.items.top; item ++) {\n                    yaml_emitter_anchor_node(emitter, *item);\n                }\n                break;\n            case YAML_MAPPING_NODE:\n                for (pair = node->data.mapping.pairs.start;\n                        pair < node->data.mapping.pairs.top; pair ++) {\n                    yaml_emitter_anchor_node(emitter, pair->key);\n                    yaml_emitter_anchor_node(emitter, pair->value);\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    else if (emitter->anchors[index-1].references == 2) {\n        emitter->anchors[index-1].anchor = (++ emitter->last_anchor_id);\n    }\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Compose a sequence node.\n */\n", "func_signal": "static int\nyaml_parser_load_sequence(yaml_parser_t *parser, yaml_event_t *first_event)", "code": "{\n    yaml_event_t event;\n    yaml_node_t node;\n    struct {\n        yaml_node_item_t *start;\n        yaml_node_item_t *end;\n        yaml_node_item_t *top;\n    } items = { NULL, NULL, NULL };\n    int index, item_index;\n    yaml_char_t *tag = first_event->data.sequence_start.tag;\n\n    if (!tag || strcmp((char *)tag, \"!\") == 0) {\n        yaml_free(tag);\n        tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG);\n        if (!tag) goto error;\n    }\n\n    if (!STACK_INIT(parser, items, INITIAL_STACK_SIZE)) goto error;\n\n    SEQUENCE_NODE_INIT(node, tag, items.start, items.end,\n            first_event->data.sequence_start.style,\n            first_event->start_mark, first_event->end_mark);\n\n    if (!PUSH(parser, parser->document->nodes, node)) goto error;\n\n    index = parser->document->nodes.top - parser->document->nodes.start;\n\n    if (!yaml_parser_register_anchor(parser, index,\n                first_event->data.sequence_start.anchor)) return 0;\n\n    if (!yaml_parser_parse(parser, &event)) return 0;\n\n    while (event.type != YAML_SEQUENCE_END_EVENT) {\n        item_index = yaml_parser_load_node(parser, &event);\n        if (!item_index) return 0;\n        if (!PUSH(parser,\n                    parser->document->nodes.start[index-1].data.sequence.items,\n                    item_index)) return 0;\n        if (!yaml_parser_parse(parser, &event)) return 0;\n    }\n\n    parser->document->nodes.start[index-1].end_mark = event.end_mark;\n\n    return index;\n\nerror:\n    yaml_free(tag);\n    yaml_free(first_event->data.sequence_start.anchor);\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Compose a mapping node.\n */\n", "func_signal": "static int\nyaml_parser_load_mapping(yaml_parser_t *parser, yaml_event_t *first_event)", "code": "{\n    yaml_event_t event;\n    yaml_node_t node;\n    struct {\n        yaml_node_pair_t *start;\n        yaml_node_pair_t *end;\n        yaml_node_pair_t *top;\n    } pairs = { NULL, NULL, NULL };\n    int index;\n    yaml_node_pair_t pair;\n    yaml_char_t *tag = first_event->data.mapping_start.tag;\n\n    if (!tag || strcmp((char *)tag, \"!\") == 0) {\n        yaml_free(tag);\n        tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_MAPPING_TAG);\n        if (!tag) goto error;\n    }\n\n    if (!STACK_INIT(parser, pairs, INITIAL_STACK_SIZE)) goto error;\n\n    MAPPING_NODE_INIT(node, tag, pairs.start, pairs.end,\n            first_event->data.mapping_start.style,\n            first_event->start_mark, first_event->end_mark);\n\n    if (!PUSH(parser, parser->document->nodes, node)) goto error;\n\n    index = parser->document->nodes.top - parser->document->nodes.start;\n\n    if (!yaml_parser_register_anchor(parser, index,\n                first_event->data.mapping_start.anchor)) return 0;\n\n    if (!yaml_parser_parse(parser, &event)) return 0;\n\n    while (event.type != YAML_MAPPING_END_EVENT) {\n        pair.key = yaml_parser_load_node(parser, &event);\n        if (!pair.key) return 0;\n        if (!yaml_parser_parse(parser, &event)) return 0;\n        pair.value = yaml_parser_load_node(parser, &event);\n        if (!pair.value) return 0;\n        if (!PUSH(parser,\n                    parser->document->nodes.start[index-1].data.mapping.pairs,\n                    pair)) return 0;\n        if (!yaml_parser_parse(parser, &event)) return 0;\n    }\n\n    parser->document->nodes.start[index-1].end_mark = event.end_mark;\n\n    return index;\n\nerror:\n    yaml_free(tag);\n    yaml_free(first_event->data.mapping_start.anchor);\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Set composer error with context.\n */\n", "func_signal": "static int\nyaml_parser_set_composer_error_context(yaml_parser_t *parser,\n        const char *context, yaml_mark_t context_mark,\n        const char *problem, yaml_mark_t problem_mark)", "code": "{\n    parser->error = YAML_COMPOSER_ERROR;\n    parser->context = context;\n    parser->context_mark = context_mark;\n    parser->problem = problem;\n    parser->problem_mark = problem_mark;\n\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Issue a STREAM-START event.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_emitter_open(yaml_emitter_t *emitter)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark = { 0, 0, 0 };\n\n    assert(emitter);            /* Non-NULL emitter object is required. */\n    assert(!emitter->opened);   /* Emitter should not be opened yet. */\n\n    STREAM_START_EVENT_INIT(event, YAML_ANY_ENCODING, mark, mark);\n\n    if (!yaml_emitter_emit(emitter, &event)) {\n        return 0;\n    }\n\n    emitter->opened = 1;\n\n    return 1;\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Add an anchor.\n */\n", "func_signal": "static int\nyaml_parser_register_anchor(yaml_parser_t *parser,\n        int index, yaml_char_t *anchor)", "code": "{\n    yaml_alias_data_t data = { anchor, index, { 0, 0, 0 } };\n    yaml_alias_data_t *alias_data;\n\n    if (!anchor) return 1;\n\n    data.mark = parser->document->nodes.start[index-1].start_mark;\n\n    for (alias_data = parser->aliases.start;\n            alias_data != parser->aliases.top; alias_data ++) {\n        if (strcmp((char *)alias_data->anchor, (char *)anchor) == 0) {\n            yaml_free(anchor);\n            return yaml_parser_set_composer_error_context(parser,\n                    \"found duplicate anchor; first occurence\",\n                    alias_data->mark, \"second occurence\", data.mark);\n        }\n    }\n\n    if (!PUSH(parser, parser->aliases, data)) {\n        yaml_free(anchor);\n        return 0;\n    }\n\n    return 1;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Dump a YAML document.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_emitter_dump(yaml_emitter_t *emitter, yaml_document_t *document)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark = { 0, 0, 0 };\n\n    assert(emitter);            /* Non-NULL emitter object is required. */\n    assert(document);           /* Non-NULL emitter object is expected. */\n\n    emitter->document = document;\n\n    if (!emitter->opened) {\n        if (!yaml_emitter_open(emitter)) goto error;\n    }\n\n    if (STACK_EMPTY(emitter, document->nodes)) {\n        if (!yaml_emitter_close(emitter)) goto error;\n        yaml_emitter_delete_document_and_anchors(emitter);\n        return 1;\n    }\n\n    assert(emitter->opened);    /* Emitter should be opened. */\n\n    emitter->anchors = yaml_malloc(sizeof(*(emitter->anchors))\n            * (document->nodes.top - document->nodes.start));\n    if (!emitter->anchors) goto error;\n    memset(emitter->anchors, 0, sizeof(*(emitter->anchors))\n            * (document->nodes.top - document->nodes.start));\n\n    DOCUMENT_START_EVENT_INIT(event, document->version_directive,\n            document->tag_directives.start, document->tag_directives.end,\n            document->start_implicit, mark, mark);\n    if (!yaml_emitter_emit(emitter, &event)) goto error;\n\n    yaml_emitter_anchor_node(emitter, 1);\n    if (!yaml_emitter_dump_node(emitter, 1)) goto error;\n\n    DOCUMENT_END_EVENT_INIT(event, document->end_implicit, mark, mark);\n    if (!yaml_emitter_emit(emitter, &event)) goto error;\n\n    yaml_emitter_delete_document_and_anchors(emitter);\n\n    return 1;\n\nerror:\n\n    yaml_emitter_delete_document_and_anchors(emitter);\n\n    return 0;\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Flush the output buffer.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_emitter_flush(yaml_emitter_t *emitter)", "code": "{\n    int low, high;\n\n    assert(emitter);    /* Non-NULL emitter object is expected. */\n    assert(emitter->write_handler); /* Write handler must be set. */\n    assert(emitter->encoding);  /* Output encoding must be set. */\n\n    emitter->buffer.last = emitter->buffer.pointer;\n    emitter->buffer.pointer = emitter->buffer.start;\n\n    /* Check if the buffer is empty. */\n\n    if (emitter->buffer.start == emitter->buffer.last) {\n        return 1;\n    }\n\n    /* If the output encoding is UTF-8, we don't need to recode the buffer. */\n\n    if (emitter->encoding == YAML_UTF8_ENCODING)\n    {\n        if (emitter->write_handler(emitter->write_handler_data,\n                    emitter->buffer.start,\n                    emitter->buffer.last - emitter->buffer.start)) {\n            emitter->buffer.last = emitter->buffer.start;\n            emitter->buffer.pointer = emitter->buffer.start;\n            return 1;\n        }\n        else {\n            return yaml_emitter_set_writer_error(emitter, \"Write error\");\n        }\n    }\n\n    /* Recode the buffer into the raw buffer. */\n\n    low = (emitter->encoding == YAML_UTF16LE_ENCODING ? 0 : 1);\n    high = (emitter->encoding == YAML_UTF16LE_ENCODING ? 1 : 0);\n\n    while (emitter->buffer.pointer != emitter->buffer.last)\n    {\n        unsigned char octet;\n        unsigned int width;\n        unsigned int value;\n        size_t k;\n\n        /* \n         * See the \"reader.c\" code for more details on UTF-8 encoding.  Note\n         * that we assume that the buffer contains a valid UTF-8 sequence.\n         */\n\n        /* Read the next UTF-8 character. */\n\n        octet = emitter->buffer.pointer[0];\n\n        width = (octet & 0x80) == 0x00 ? 1 :\n                (octet & 0xE0) == 0xC0 ? 2 :\n                (octet & 0xF0) == 0xE0 ? 3 :\n                (octet & 0xF8) == 0xF0 ? 4 : 0;\n\n        value = (octet & 0x80) == 0x00 ? octet & 0x7F :\n                (octet & 0xE0) == 0xC0 ? octet & 0x1F :\n                (octet & 0xF0) == 0xE0 ? octet & 0x0F :\n                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;\n\n        for (k = 1; k < width; k ++) {\n            octet = emitter->buffer.pointer[k];\n            value = (value << 6) + (octet & 0x3F);\n        }\n\n        emitter->buffer.pointer += width;\n\n        /* Write the character. */\n\n        if (value < 0x10000)\n        {\n            emitter->raw_buffer.last[high] = value >> 8;\n            emitter->raw_buffer.last[low] = value & 0xFF;\n\n            emitter->raw_buffer.last += 2;\n        }\n        else\n        {\n            /* Write the character using a surrogate pair (check \"reader.c\"). */\n\n            value -= 0x10000;\n            emitter->raw_buffer.last[high] = 0xD8 + (value >> 18);\n            emitter->raw_buffer.last[low] = (value >> 10) & 0xFF;\n            emitter->raw_buffer.last[high+2] = 0xDC + ((value >> 8) & 0xFF);\n            emitter->raw_buffer.last[low+2] = value & 0xFF;\n\n            emitter->raw_buffer.last += 4;\n        }\n    }\n\n    /* Write the raw buffer. */\n\n    if (emitter->write_handler(emitter->write_handler_data,\n                emitter->raw_buffer.start,\n                emitter->raw_buffer.last - emitter->raw_buffer.start)) {\n        emitter->buffer.last = emitter->buffer.start;\n        emitter->buffer.pointer = emitter->buffer.start;\n        emitter->raw_buffer.last = emitter->raw_buffer.start;\n        emitter->raw_buffer.pointer = emitter->raw_buffer.start;\n        return 1;\n    }\n    else {\n        return yaml_emitter_set_writer_error(emitter, \"Write error\");\n    }\n}", "path": "libyaml\\writer.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Compose a node corresponding to an alias.\n */\n", "func_signal": "static int\nyaml_parser_load_alias(yaml_parser_t *parser, yaml_event_t *first_event)", "code": "{\n    yaml_char_t *anchor = first_event->data.alias.anchor;\n    yaml_alias_data_t *alias_data;\n\n    for (alias_data = parser->aliases.start;\n            alias_data != parser->aliases.top; alias_data ++) {\n        if (strcmp((char *)alias_data->anchor, (char *)anchor) == 0) {\n            yaml_free(anchor);\n            return alias_data->index;\n        }\n    }\n\n    yaml_free(anchor);\n    return yaml_parser_set_composer_error(parser, \"found undefined alias\",\n            first_event->start_mark);\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Serialize a mapping.\n */\n", "func_signal": "static int\nyaml_emitter_dump_mapping(yaml_emitter_t *emitter, yaml_node_t *node,\n        yaml_char_t *anchor)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark  = { 0, 0, 0 };\n\n    int implicit = (strcmp((char *)node->tag, YAML_DEFAULT_MAPPING_TAG) == 0);\n\n    yaml_node_pair_t *pair;\n\n    MAPPING_START_EVENT_INIT(event, anchor, node->tag, implicit,\n            node->data.mapping.style, mark, mark);\n    if (!yaml_emitter_emit(emitter, &event)) return 0;\n\n    for (pair = node->data.mapping.pairs.start;\n            pair < node->data.mapping.pairs.top; pair ++) {\n        if (!yaml_emitter_dump_node(emitter, pair->key)) return 0;\n        if (!yaml_emitter_dump_node(emitter, pair->value)) return 0;\n    }\n\n    MAPPING_END_EVENT_INIT(event, mark, mark);\n    if (!yaml_emitter_emit(emitter, &event)) return 0;\n\n    return 1;\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Issue a STREAM-END event.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_emitter_close(yaml_emitter_t *emitter)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark = { 0, 0, 0 };\n\n    assert(emitter);            /* Non-NULL emitter object is required. */\n    assert(emitter->opened);    /* Emitter should be opened. */\n\n    if (emitter->closed) return 1;\n\n    STREAM_END_EVENT_INIT(event, mark, mark);\n\n    if (!yaml_emitter_emit(emitter, &event)) {\n        return 0;\n    }\n\n    emitter->closed = 1;\n\n    return 1;\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Compose a node.\n */\n", "func_signal": "static int\nyaml_parser_load_node(yaml_parser_t *parser, yaml_event_t *first_event)", "code": "{\n    switch (first_event->type) {\n        case YAML_ALIAS_EVENT:\n            return yaml_parser_load_alias(parser, first_event);\n        case YAML_SCALAR_EVENT:\n            return yaml_parser_load_scalar(parser, first_event);\n        case YAML_SEQUENCE_START_EVENT:\n            return yaml_parser_load_sequence(parser, first_event);\n        case YAML_MAPPING_START_EVENT:\n            return yaml_parser_load_mapping(parser, first_event);\n        default:\n            assert(0);  /* Could not happen. */\n            return 0;\n    }\n\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Set the writer error and return 0.\n */\n", "func_signal": "static int\nyaml_emitter_set_writer_error(yaml_emitter_t *emitter, const char *problem)", "code": "{\n    emitter->error = YAML_WRITER_ERROR;\n    emitter->problem = problem;\n\n    return 0;\n}", "path": "libyaml\\writer.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Load the next document of the stream.\n */\n", "func_signal": "YAML_DECLARE(int)\nyaml_parser_load(yaml_parser_t *parser, yaml_document_t *document)", "code": "{\n    yaml_event_t event;\n\n    assert(parser);     /* Non-NULL parser object is expected. */\n    assert(document);   /* Non-NULL document object is expected. */\n\n    memset(document, 0, sizeof(yaml_document_t));\n    if (!STACK_INIT(parser, document->nodes, INITIAL_STACK_SIZE))\n        goto error;\n\n    if (!parser->stream_start_produced) {\n        if (!yaml_parser_parse(parser, &event)) goto error;\n        assert(event.type == YAML_STREAM_START_EVENT);\n                        /* STREAM-START is expected. */\n    }\n\n    if (parser->stream_end_produced) {\n        return 1;\n    }\n\n    if (!yaml_parser_parse(parser, &event)) goto error;\n    if (event.type == YAML_STREAM_END_EVENT) {\n        return 1;\n    }\n\n    if (!STACK_INIT(parser, parser->aliases, INITIAL_STACK_SIZE))\n        goto error;\n\n    parser->document = document;\n\n    if (!yaml_parser_load_document(parser, &event)) goto error;\n\n    yaml_parser_delete_aliases(parser);\n    parser->document = NULL;\n\n    return 1;\n\nerror:\n\n    yaml_parser_delete_aliases(parser);\n    yaml_document_delete(document);\n    parser->document = NULL;\n\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Serialize a scalar.\n */\n", "func_signal": "static int\nyaml_emitter_dump_scalar(yaml_emitter_t *emitter, yaml_node_t *node,\n        yaml_char_t *anchor)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark  = { 0, 0, 0 };\n\n    int plain_implicit = (strcmp((char *)node->tag,\n                YAML_DEFAULT_SCALAR_TAG) == 0);\n    int quoted_implicit = (strcmp((char *)node->tag,\n                YAML_DEFAULT_SCALAR_TAG) == 0);\n\n    SCALAR_EVENT_INIT(event, anchor, node->tag, node->data.scalar.value,\n            node->data.scalar.length, plain_implicit, quoted_implicit,\n            node->data.scalar.style, mark, mark);\n\n    return yaml_emitter_emit(emitter, &event);\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Compose a scalar node.\n */\n", "func_signal": "static int\nyaml_parser_load_scalar(yaml_parser_t *parser, yaml_event_t *first_event)", "code": "{\n    yaml_node_t node;\n    int index;\n    yaml_char_t *tag = first_event->data.scalar.tag;\n\n    if (!tag || strcmp((char *)tag, \"!\") == 0) {\n        yaml_free(tag);\n        tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_SCALAR_TAG);\n        if (!tag) goto error;\n    }\n\n    SCALAR_NODE_INIT(node, tag, first_event->data.scalar.value,\n            first_event->data.scalar.length, first_event->data.scalar.style,\n            first_event->start_mark, first_event->end_mark);\n\n    if (!PUSH(parser, parser->document->nodes, node)) goto error;\n\n    index = parser->document->nodes.top - parser->document->nodes.start;\n\n    if (!yaml_parser_register_anchor(parser, index,\n                first_event->data.scalar.anchor)) return 0;\n\n    return index;\n\nerror:\n    yaml_free(tag);\n    yaml_free(first_event->data.scalar.anchor);\n    yaml_free(first_event->data.scalar.value);\n    return 0;\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Delete the stack of aliases.\n */\n", "func_signal": "static void\nyaml_parser_delete_aliases(yaml_parser_t *parser)", "code": "{\n    while (!STACK_EMPTY(parser, parser->aliases)) {\n        yaml_free(POP(parser, parser->aliases).anchor);\n    }\n    STACK_DEL(parser, parser->aliases);\n}", "path": "libyaml\\loader.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Clean up the emitter object after a document is dumped.\n */\n", "func_signal": "static void\nyaml_emitter_delete_document_and_anchors(yaml_emitter_t *emitter)", "code": "{\n    int index;\n\n    if (!emitter->anchors) {\n        yaml_document_delete(emitter->document);\n        emitter->document = NULL;\n        return;\n    }\n\n    for (index = 0; emitter->document->nodes.start + index\n            < emitter->document->nodes.top; index ++) {\n        yaml_node_t node = emitter->document->nodes.start[index];\n        if (!emitter->anchors[index].serialized) {\n            yaml_free(node.tag);\n            if (node.type == YAML_SCALAR_NODE) {\n                yaml_free(node.data.scalar.value);\n            }\n        }\n        if (node.type == YAML_SEQUENCE_NODE) {\n            STACK_DEL(emitter, node.data.sequence.items);\n        }\n        if (node.type == YAML_MAPPING_NODE) {\n            STACK_DEL(emitter, node.data.mapping.pairs);\n        }\n    }\n\n    STACK_DEL(emitter, emitter->document->nodes);\n    yaml_free(emitter->anchors);\n\n    emitter->anchors = NULL;\n    emitter->last_anchor_id = 0;\n    emitter->document = NULL;\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/*\n * Serialize an alias.\n */\n", "func_signal": "static int\nyaml_emitter_dump_alias(yaml_emitter_t *emitter, yaml_char_t *anchor)", "code": "{\n    yaml_event_t event;\n    yaml_mark_t mark  = { 0, 0, 0 };\n\n    ALIAS_EVENT_INIT(event, anchor, mark, mark);\n\n    return yaml_emitter_emit(emitter, &event);\n}", "path": "libyaml\\dumper.c", "repo_name": "drodriguez/PocketCheat", "stars": 3, "license": "mit", "language": "c", "size": 193}
{"docstring": "/**\n * gst_app_sink_get_max_buffers:\n * @appsink: a #GstAppSink\n *\n * Get the maximum amount of buffers that can be queued in @appsink.\n *\n * Returns: The maximum amount of buffers that can be queued.\n */\n", "func_signal": "guint\ngst_app_sink_get_max_buffers (GstAppSink * appsink)", "code": "{\n  guint result;\n\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), 0);\n\n  g_mutex_lock (appsink->mutex);\n  result = appsink->max_buffers;\n  g_mutex_unlock (appsink->mutex);\n\n  return result;\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* sink currently only operates in push mode */\n", "func_signal": "static gboolean\ngst_audio_ringbuffer_sink_activate_push (GstPad * pad, gboolean active)", "code": "{\n  gboolean result = TRUE;\n  GstAudioRingbuffer *ringbuffer;\n\n  ringbuffer = GST_AUDIO_RINGBUFFER (gst_pad_get_parent (pad));\n\n  if (active) {\n    GST_DEBUG_OBJECT (ringbuffer, \"activating push mode\");\n    ringbuffer->is_eos = FALSE;\n    ringbuffer->pulling = FALSE;\n  } else {\n    /* unblock chain function */\n    GST_DEBUG_OBJECT (ringbuffer, \"deactivating push mode\");\n    ringbuffer->pulling = FALSE;\n  }\n\n  gst_object_unref (ringbuffer);\n\n  return result;\n}", "path": "gst\\audiobuffer\\gstaudioringbuffer.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_set_drop:\n * @appsink: a #GstAppSink\n * @emit: the new state\n *\n * Instruct @appsink to drop old buffers when the maximum amount of queued\n * buffers is reached.\n */\n", "func_signal": "void\ngst_app_sink_set_drop (GstAppSink * appsink, gboolean drop)", "code": "{\n  g_return_if_fail (GST_IS_APP_SINK (appsink));\n\n  g_mutex_lock (appsink->mutex);\n  if (appsink->drop != drop) {\n    appsink->drop = drop;\n    /* signal the change */\n    g_cond_signal (appsink->cond);\n  }\n  g_mutex_unlock (appsink->mutex);\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_set_caps:\n * @appsink: a #GstAppSink\n * @caps: caps to set\n *\n * Set the capabilities on the appsink element.  This function takes\n * a copy of the caps structure. After calling this method, the sink will only\n * accept caps that match @caps. If @caps is non-fixed, you must check the caps\n * on the buffers to get the actual used caps. \n */\n", "func_signal": "void\ngst_app_sink_set_caps (GstAppSink * appsink, const GstCaps * caps)", "code": "{\n  GstCaps *old;\n\n  g_return_if_fail (appsink != NULL);\n  g_return_if_fail (GST_IS_APP_SINK (appsink));\n\n  GST_OBJECT_LOCK (appsink);\n  GST_DEBUG_OBJECT (appsink, \"setting caps to %\" GST_PTR_FORMAT, caps);\n  if ((old = appsink->caps) != caps) {\n    if (caps)\n      appsink->caps = gst_caps_copy (caps);\n    else\n      appsink->caps = NULL;\n    if (old)\n      gst_caps_unref (old);\n  }\n  GST_OBJECT_UNLOCK (appsink);\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_pull_buffer:\n * @appsink: a #GstAppSink\n *\n * This function blocks until a buffer or EOS becomes available or the appsink\n * element is set to the READY/NULL state. \n *\n * This function will only return buffers when the appsink is in the PLAYING\n * state. All rendered buffers will be put in a queue so that the application\n * can pull buffers at its own rate. Note that when the application does not\n * pull buffers fast enough, the queued buffers could consume a lot of memory,\n * especially when dealing with raw video frames.\n *\n * If an EOS event was received before any buffers, this function returns\n * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition. \n *\n * Returns: a #GstBuffer or NULL when the appsink is stopped or EOS.\n */\n", "func_signal": "GstBuffer *\ngst_app_sink_pull_buffer (GstAppSink * appsink)", "code": "{\n  GstBuffer *buf = NULL;\n\n  g_return_val_if_fail (appsink != NULL, NULL);\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);\n\n  g_mutex_lock (appsink->mutex);\n\n  while (TRUE) {\n    GST_DEBUG_OBJECT (appsink, \"trying to grab a buffer\");\n    if (!appsink->started)\n      goto not_started;\n\n    if (!g_queue_is_empty (appsink->queue))\n      break;\n\n    if (appsink->is_eos)\n      goto eos;\n\n    /* nothing to return, wait */\n    GST_DEBUG_OBJECT (appsink, \"waiting for a buffer\");\n    g_cond_wait (appsink->cond, appsink->mutex);\n  }\n  buf = g_queue_pop_head (appsink->queue);\n  GST_DEBUG_OBJECT (appsink, \"we have a buffer %p\", buf);\n  g_cond_signal (appsink->cond);\n  g_mutex_unlock (appsink->mutex);\n\n  return buf;\n\n  /* special conditions */\neos:\n  {\n    GST_DEBUG_OBJECT (appsink, \"we are EOS, return NULL\");\n    g_mutex_unlock (appsink->mutex);\n    return NULL;\n  }\nnot_started:\n  {\n    GST_DEBUG_OBJECT (appsink, \"we are stopped, return NULL\");\n    g_mutex_unlock (appsink->mutex);\n    return NULL;\n  }\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_set_emit_signals:\n * @appsink: a #GstAppSink\n * @emit: the new state\n *\n * Make appsink emit the \"new-preroll\" and \"new-buffer\" signals. This option is\n * by default disabled because signal emission is expensive and unneeded when\n * the application prefers to operate in pull mode.\n */\n", "func_signal": "void\ngst_app_sink_set_emit_signals (GstAppSink * appsink, gboolean emit)", "code": "{\n  g_return_if_fail (GST_IS_APP_SINK (appsink));\n\n  g_mutex_lock (appsink->mutex);\n  appsink->emit_signals = emit;\n  g_mutex_unlock (appsink->mutex);\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/*\n * metadata_dispose:\n * @meta_data: [in] metadata handler to be freed\n *\n * Call this function to free any resource allocated by #metadata_init\n * @see_also: #metadata_init\n *\n * Returns: nothing\n */\n", "func_signal": "void\nmetadata_dispose (MetaData ** meta_data)", "code": "{\n\n  if (meta_data == NULL || (*meta_data) == NULL)\n    return;\n\n  switch ((*meta_data)->img_type) {\n    case IMG_JPEG:\n      if (G_LIKELY ((*meta_data)->options & META_OPT_DEMUX))\n        metadataparse_jpeg_dispose (&(*meta_data)->format_data.jpeg_parse);\n      else\n        metadatamux_jpeg_dispose (&(*meta_data)->format_data.jpeg_mux);\n      break;\n    case IMG_PNG:\n      if (G_LIKELY ((*meta_data)->options & META_OPT_DEMUX))\n        metadataparse_png_dispose (&(*meta_data)->format_data.png_parse);\n      else\n        metadatamux_png_dispose (&(*meta_data)->format_data.png_mux);\n      break;\n    case IMG_NONE:\n    default:\n      break;\n  }\n\n  metadata_chunk_array_free (&(*meta_data)->strip_chunks);\n  metadata_chunk_array_free (&(*meta_data)->inject_chunks);\n\n  if ((*meta_data)->xmp_adapter) {\n    gst_object_unref ((*meta_data)->xmp_adapter);\n    (*meta_data)->xmp_adapter = NULL;\n  }\n\n  if ((*meta_data)->iptc_adapter) {\n    gst_object_unref ((*meta_data)->iptc_adapter);\n    (*meta_data)->iptc_adapter = NULL;\n  }\n\n  if ((*meta_data)->exif_adapter) {\n    gst_object_unref ((*meta_data)->exif_adapter);\n    (*meta_data)->exif_adapter = NULL;\n  }\n\n  g_free (*meta_data);\n  *meta_data = NULL;\n\n}", "path": "ext\\metadata\\metadata.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* pretty static, but may turn out needed a few times */\n", "func_signal": "AtomsTreeFlavor\ngst_qt_mux_map_format_to_flavor (GstQTMuxFormat format)", "code": "{\n  if (format == GST_QT_MUX_FORMAT_QT)\n    return ATOMS_TREE_FLAVOR_MOV;\n  else\n    return ATOMS_TREE_FLAVOR_ISOM;\n}", "path": "gst\\qtmux\\gstqtmuxmap.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_get_caps:\n * @appsink: a #GstAppSink\n *\n * Get the configured caps on @appsink.\n *\n * Returns: the #GstCaps accepted by the sink. gst_caps_unref() after usage.\n */\n", "func_signal": "GstCaps *\ngst_app_sink_get_caps (GstAppSink * appsink)", "code": "{\n  GstCaps *caps;\n\n  g_return_val_if_fail (appsink != NULL, NULL);\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);\n\n  GST_OBJECT_LOCK (appsink);\n  if ((caps = appsink->caps))\n    gst_caps_ref (caps);\n  GST_DEBUG_OBJECT (appsink, \"getting caps of %\" GST_PTR_FORMAT, caps);\n  GST_OBJECT_UNLOCK (appsink);\n\n  return caps;\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_get_drop:\n * @appsink: a #GstAppSink\n *\n * Check if @appsink will drop old buffers when the maximum amount of queued\n * buffers is reached.\n *\n * Returns: %TRUE if @appsink is dropping old buffers when the queue is\n * filled.\n */\n", "func_signal": "gboolean\ngst_app_sink_get_drop (GstAppSink * appsink)", "code": "{\n  gboolean result;\n\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);\n\n  g_mutex_lock (appsink->mutex);\n  result = appsink->drop;\n  g_mutex_unlock (appsink->mutex);\n\n  return result;\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* src operating in push mode, we will proxy the push from upstream, basically\n * acting as a passthrough element. */\n", "func_signal": "static gboolean\ngst_audio_ringbuffer_src_activate_push (GstPad * pad, gboolean active)", "code": "{\n  gboolean result = FALSE;\n  GstAudioRingbuffer *ringbuffer;\n\n  ringbuffer = GST_AUDIO_RINGBUFFER (gst_pad_get_parent (pad));\n\n  if (active) {\n    GST_DEBUG_OBJECT (ringbuffer, \"activating push mode\");\n    ringbuffer->is_eos = FALSE;\n    ringbuffer->pushing = TRUE;\n    ringbuffer->pulling = FALSE;\n    result = TRUE;\n  } else {\n    GST_DEBUG_OBJECT (ringbuffer, \"deactivating push mode\");\n    ringbuffer->pushing = FALSE;\n    ringbuffer->pulling = FALSE;\n    result = TRUE;\n  }\n\n  gst_object_unref (ringbuffer);\n\n  return result;\n}", "path": "gst\\audiobuffer\\gstaudioringbuffer.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_set_max_buffers:\n * @appsink: a #GstAppSink\n * @max: the maximum number of buffers to queue\n *\n * Set the maximum amount of buffers that can be queued in @appsink. After this\n * amount of buffers are queued in appsink, any more buffers will block upstream\n * elements until a buffer is pulled from @appsink.\n */\n", "func_signal": "void\ngst_app_sink_set_max_buffers (GstAppSink * appsink, guint max)", "code": "{\n  g_return_if_fail (GST_IS_APP_SINK (appsink));\n\n  g_mutex_lock (appsink->mutex);\n  if (max != appsink->max_buffers) {\n    appsink->max_buffers = max;\n    /* signal the change */\n    g_cond_signal (appsink->cond);\n  }\n  g_mutex_unlock (appsink->mutex);\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_is_eos:\n * @appsink: a #GstAppSink\n *\n * Check if @appsink is EOS, which is when no more buffers can be pulled because\n * an EOS event was received.\n *\n * This function also returns %TRUE when the appsink is not in the PAUSED or\n * PLAYING state.\n *\n * Returns: %TRUE if no more buffers can be pulled and the appsink is EOS.\n */\n", "func_signal": "gboolean\ngst_app_sink_is_eos (GstAppSink * appsink)", "code": "{\n  gboolean ret;\n\n  g_return_val_if_fail (appsink != NULL, FALSE);\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);\n\n  g_mutex_lock (appsink->mutex);\n  if (!appsink->started)\n    goto not_started;\n\n  if (appsink->is_eos && g_queue_is_empty (appsink->queue)) {\n    GST_DEBUG_OBJECT (appsink, \"we are EOS and the queue is empty\");\n    ret = TRUE;\n  } else {\n    GST_DEBUG_OBJECT (appsink, \"we are not yet EOS\");\n    ret = FALSE;\n  }\n  g_mutex_unlock (appsink->mutex);\n\n  return ret;\n\nnot_started:\n  {\n    GST_DEBUG_OBJECT (appsink, \"we are stopped, return TRUE\");\n    g_mutex_unlock (appsink->mutex);\n    return TRUE;\n  }\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/*\n * metadata_lazy_update:\n * @meta_data: [in] metata handle\n *\n * This function must be called after #metadata_parse and after the element\n * has modified the segments (chunks)\n * Data written to #META_DATA_INJECT_CHUNKS will be properly wrapped\n * This function is really importante in case o muxing 'cause:\n * 1- 'cause gives the oportunity to muxers to wrapper new segments with\n * apropriate bytes\n *   ex: in case of JPEG it can wrap the EXIF chunk (created using tags) with\n * chunk id and chunk size\n * 2- 'cause gives the oportunity to muxer to decide if some chunks should\n * still be striped/injected\n *   ex: if there is no EXIF chunk to be inserted, the muxer decides to not\n * strip JFIF anymore\n * @see_also: #metadata_parse #META_DATA_INJECT_CHUNKS\n *\n * Returns: nothing\n */\n", "func_signal": "void\nmetadata_lazy_update (MetaData * meta_data)", "code": "{\n  switch (meta_data->img_type) {\n    case IMG_JPEG:\n      if (G_LIKELY (meta_data->options & META_OPT_DEMUX))\n        metadataparse_jpeg_lazy_update (&meta_data->format_data.jpeg_parse);\n      else\n        metadatamux_jpeg_lazy_update (&meta_data->format_data.jpeg_mux);\n      break;\n    case IMG_PNG:\n      if (G_LIKELY (meta_data->options & META_OPT_DEMUX))\n        metadataparse_png_lazy_update (&meta_data->format_data.png_parse);\n      else\n        metadatamux_png_lazy_update (&meta_data->format_data.png_mux);\n      break;\n    default:\n      /* unexpected */\n      break;\n  }\n\n}", "path": "ext\\metadata\\metadata.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/*\n * metadata_init:\n * @meta_data: [in] metadata handler to be inited\n * @options: [in] which types of metadata will be processed (EXIF, IPTC and/or\n * XMP) and how it will be handled (DEMUXING or MUXING). Look at #MetaOptions\n * to see the available options.\n *\n * Init metadata handle.\n * This function must be called before any other function from this module.\n * This function must not be called twice without call to #metadata_dispose\n * beteween them.\n * @see_also: #metadata_dispose #metadata_parse\n *\n * Returns: nothing\n */\n", "func_signal": "void\nmetadata_init (MetaData ** meta_data, const MetaOptions options)", "code": "{\n\n  if (meta_data == NULL)\n    return;\n  if ((*meta_data))\n    metadata_dispose (meta_data);\n\n  (*meta_data) = g_new (MetaData, 1);\n\n  (*meta_data)->state = STATE_NULL;\n  (*meta_data)->img_type = IMG_NONE;\n  (*meta_data)->options = options;\n  (*meta_data)->offset_orig = 0;\n  (*meta_data)->exif_adapter = NULL;\n  (*meta_data)->iptc_adapter = NULL;\n  (*meta_data)->xmp_adapter = NULL;\n\n  if ((*meta_data)->options & META_OPT_DEMUX) {\n    /* when parsing we will probably strip only 3 chunk (exif, iptc and xmp)\n       so we use 4 just in case there is more than one chunk of them.\n       But this is just for convinience, 'cause the chunk_array increases\n       dinamically */\n    metadata_chunk_array_init (&(*meta_data)->strip_chunks, 4);\n    /* at most 1 chunk will be injected (JPEG JFIF) */\n    metadata_chunk_array_init (&(*meta_data)->inject_chunks, 1);\n  } else {\n    /* at most 1 chunk will be striped (JPEG JFIF) */\n    metadata_chunk_array_init (&(*meta_data)->strip_chunks, 1);\n    /* at most 3 chunk will be injected (EXIF, IPTC, XMP) */\n    metadata_chunk_array_init (&(*meta_data)->inject_chunks, 3);\n  }\n\n}", "path": "ext\\metadata\\metadata.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* this cddb info is from \n   http://www.freedb.org/modules.php?name=Sections&sop=viewarticle&artid=6\n\n   this will probably be of interest to anyone wishing to actually use the discid\n   http://www.freedb.org/modules.php?name=Sections&sop=viewarticle&artid=28\n*/\n", "func_signal": "static gint\ncddb_sum (gint n)", "code": "{\n  gint ret = 0;\n\n  while (n > 0) {\n    ret += n % 10;\n    n /= 10;\n  }\n\n  return ret;\n}", "path": "sys\\cdrom\\gstcdplayer_ioctl.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* pull mode, downstream will call our getrange function */\n", "func_signal": "static gboolean\ngst_audio_ringbuffer_src_activate_pull (GstPad * pad, gboolean active)", "code": "{\n  gboolean result;\n  GstAudioRingbuffer *ringbuffer;\n\n  ringbuffer = GST_AUDIO_RINGBUFFER (gst_pad_get_parent (pad));\n\n  if (active) {\n    GST_DEBUG_OBJECT (ringbuffer, \"activating pull mode\");\n\n    /* try to activate upstream in pull mode as well. If it fails, no problems,\n     * we'll be activated in push mode. Remember that we are pulling-through */\n    ringbuffer->pulling = gst_pad_activate_pull (ringbuffer->sinkpad, active);\n\n    ringbuffer->is_eos = FALSE;\n    ringbuffer->waiting = TRUE;\n    ringbuffer->flushing = FALSE;\n    gst_segment_init (&ringbuffer->src_segment, GST_FORMAT_BYTES);\n    result = TRUE;\n  } else {\n    GST_DEBUG_OBJECT (ringbuffer, \"deactivating pull mode\");\n\n    if (ringbuffer->pulling)\n      gst_pad_activate_pull (ringbuffer->sinkpad, active);\n\n    ringbuffer->pulling = FALSE;\n    ringbuffer->waiting = FALSE;\n    ringbuffer->flushing = TRUE;\n    result = TRUE;\n  }\n  gst_object_unref (ringbuffer);\n\n  return result;\n}", "path": "gst\\audiobuffer\\gstaudioringbuffer.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/**\n * gst_app_sink_get_emit_signals:\n * @appsink: a #GstAppSink\n *\n * Check if appsink will emit the \"new-preroll\" and \"new-buffer\" signals.\n *\n * Returns: %TRUE if @appsink is emiting the \"new-preroll\" and \"new-buffer\"\n * signals.\n */\n", "func_signal": "gboolean\ngst_app_sink_get_emit_signals (GstAppSink * appsink)", "code": "{\n  gboolean result;\n\n  g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);\n\n  g_mutex_lock (appsink->mutex);\n  result = appsink->emit_signals;\n  g_mutex_unlock (appsink->mutex);\n\n  return result;\n}", "path": "gst-libs\\gst\\app\\gstappsink.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* notes:\n * - avc1 brand is not used, since the specific extensions indicated by it\n *   are not used (e.g. sample groupings, etc)\n * - 3GPP2 specific formats not (yet) used, only 3GPP, so no need yet either\n *   for 3g2a (but later on, moov might be used to conditionally switch to\n *   3g2a if needed) */\n", "func_signal": "void\ngst_qt_mux_map_format_to_header (GstQTMuxFormat format, GstBuffer ** _prefix,\n    guint32 * _major, guint32 * _version, GList ** _compatible, AtomMOOV * moov)", "code": "{\n  static guint32 qt_brands[] = { 0 };\n  static guint32 mp4_brands[] = { FOURCC_mp41, FOURCC_isom, FOURCC_iso2, 0 };\n  static guint32 gpp_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };\n  static guint32 mjp2_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };\n  static guint8 mjp2_prefix[] =\n      { 0, 0, 0, 12, 'j', 'P', ' ', ' ', 0x0D, 0x0A, 0x87, 0x0A };\n  guint32 *comp = NULL;\n  guint32 major = 0, version = 0;\n  GstBuffer *prefix = NULL;\n  GList *result = NULL;\n\n  g_return_if_fail (_prefix != NULL);\n  g_return_if_fail (_major != NULL);\n  g_return_if_fail (_version != NULL);\n  g_return_if_fail (_compatible != NULL);\n\n  switch (format) {\n    case GST_QT_MUX_FORMAT_QT:\n      major = FOURCC_qt__;\n      comp = qt_brands;\n      version = 0x20050300;\n      break;\n    case GST_QT_MUX_FORMAT_MP4:\n      major = FOURCC_mp42;\n      comp = mp4_brands;\n      break;\n    case GST_QT_MUX_FORMAT_3GP:\n      major = FOURCC_3gg7;\n      comp = gpp_brands;\n      break;\n    case GST_QT_MUX_FORMAT_MJ2:\n      major = FOURCC_mjp2;\n      comp = mjp2_brands;\n      version = 0;\n      prefix = gst_buffer_new_and_alloc (sizeof (mjp2_prefix));\n      memcpy (GST_BUFFER_DATA (prefix), mjp2_prefix, GST_BUFFER_SIZE (prefix));\n      break;\n    default:\n      g_assert_not_reached ();\n      break;\n  }\n\n  /* convert list to list, hm */\n  while (comp && *comp != 0) {\n    /* order matters over efficiency */\n    result = g_list_append (result, GUINT_TO_POINTER (*comp));\n    comp++;\n  }\n\n  *_major = major;\n  *_version = version;\n  *_prefix = prefix;\n  *_compatible = result;\n\n  /* TODO 3GPP may include mp42 as compatible if applicable */\n  /* TODO 3GPP major brand 3gp7 if at most 1 video and audio track */\n}", "path": "gst\\qtmux\\gstqtmuxmap.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/* called only once, as opposed to dispose */\n", "func_signal": "static void\ngst_audio_ringbuffer_finalize (GObject * object)", "code": "{\n  GstAudioRingbuffer *ringbuffer = GST_AUDIO_RINGBUFFER (object);\n\n  GST_DEBUG_OBJECT (ringbuffer, \"finalizing ringbuffer\");\n\n  g_cond_free (ringbuffer->cond);\n\n  G_OBJECT_CLASS (elem_parent_class)->finalize (object);\n}", "path": "gst\\audiobuffer\\gstaudioringbuffer.c", "repo_name": "prajnashi/gst-plugins-bad", "stars": 3, "license": "other", "language": "c", "size": 13854}
{"docstring": "/*\n * aim_tx_enqueue__immediate()\n *\n * Parallel to aim_tx_enqueue__queuebased, however, this bypasses\n * the whole queue mess when you want immediate writes to happen.\n *\n * Basically the same as its __queuebased couterpart, however\n * instead of doing a list append, it just calls aim_tx_sendframe()\n * right here. \n * \n */\n", "func_signal": "static int aim_tx_enqueue__immediate(aim_session_t *sess, aim_frame_t *fr)", "code": "{\n\n\tif (!fr->conn) {\n\t\timcb_error(sess->aux_data, \"packet has no connection\");\n\t\taim_frame_destroy(fr);\n\t\treturn 0;\n\t}\n\n\tif (fr->hdrtype == AIM_FRAMETYPE_FLAP)\n\t\tfr->hdr.flap.seqnum = aim_get_next_txseqnum(fr->conn);\n\n\tfr->handled = 0; /* not sent yet */\n\n\taim_tx_sendframe(sess, fr);\n\n\taim_frame_destroy(fr);\n\n\treturn 0;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * Since aim_get_command will aim_conn_kill dead connections, we need\n * to clean up the rxqueue of unprocessed connections on that socket.\n *\n * XXX: this is something that was handled better in the old connection\n * handling method, but eh.\n */\n", "func_signal": "void aim_rxqueue_cleanbyconn(aim_session_t *sess, aim_conn_t *conn)", "code": "{\n\taim_frame_t *currx;\n\n\tfor (currx = sess->queue_incoming; currx; currx = currx->next) {\n\t\tif ((!currx->handled) && (currx->conn == conn))\n\t\t\tcurrx->handled = 1;\n\t}\t\n\treturn;\n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * Purge recieve queue of all handled commands (->handled==1).  Also\n * allows for selective freeing using ->nofree so that the client can\n * keep the data for various purposes.  \n *\n * If ->nofree is nonzero, the frame will be delinked from the global list, \n * but will not be free'ed.  The client _must_ keep a pointer to the\n * data -- libfaim will not!  If the client marks ->nofree but\n * does not keep a pointer, it's lost forever.\n *\n */\n", "func_signal": "void aim_purge_rxqueue(aim_session_t *sess)", "code": "{\n\taim_frame_t *cur, **prev;\n\n\tfor (prev = &sess->queue_incoming; (cur = *prev); ) {\n\t\tif (cur->handled) {\n\n\t\t\t*prev = cur->next;\n\t\t\t\n\t\t\tif (!cur->nofree)\n\t\t\t\taim_frame_destroy(cur);\n\n\t\t} else\n\t\t\tprev = &cur->next;\n\t}\n\n\treturn;\n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* Converts such an array back into a command string. Mainly used for the IPC code right now. */\n", "func_signal": "char *irc_build_line( char **cmd )", "code": "{\n\tint i, len;\n\tchar *s;\n\t\n\tif( cmd[0] == NULL )\n\t\treturn NULL;\n\t\n\tlen = 1;\n\tfor( i = 0; cmd[i]; i ++ )\n\t\tlen += strlen( cmd[i] ) + 1;\n\t\n\tif( strchr( cmd[i-1], ' ' ) != NULL )\n\t\tlen ++;\n\t\n\ts = g_new0( char, len + 1 );\n\tfor( i = 0; cmd[i]; i ++ )\n\t{\n\t\tif( cmd[i+1] == NULL && strchr( cmd[i], ' ' ) != NULL )\n\t\t\tstrcat( s, \":\" );\n\t\t\n\t\tstrcat( s, cmd[i] );\n\t\t\n\t\tif( cmd[i+1] )\n\t\t\tstrcat( s, \" \" );\n\t}\n\tstrcat( s, \"\\r\\n\" );\n\t\n\treturn s;\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * Read into a byte stream.  Will not read more than count, but may read\n * less if there is not enough room in the stream buffer.\n */\n", "func_signal": "static int aim_bstream_recv(aim_bstream_t *bs, int fd, size_t count)", "code": "{\n\tint red = 0;\n\n\tif (!bs || (fd < 0) || (count < 0))\n\t\treturn -1;\n\t\n\tif (count > (bs->len - bs->offset))\n\t\tcount = bs->len - bs->offset; /* truncate to remaining space */\n\n\tif (count) {\n\n\t\tred = aim_recv(fd, bs->data + bs->offset, count);\n\n\t\tif (red <= 0)\n\t\t\treturn -1;\n\t}\n\n\tbs->offset += red;\n\n\treturn red;\n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* Split an IRC-style line into little parts/arguments. */\n", "func_signal": "char **irc_parse_line( char *line )", "code": "{\n\tint i, j;\n\tchar **cmd;\n\t\n\t/* Move the line pointer to the start of the command, skipping spaces and the optional prefix. */\n\tif( line[0] == ':' )\n\t{\n\t\tfor( i = 0; line[i] != ' '; i ++ );\n\t\tline = line + i;\n\t}\n\tfor( i = 0; line[i] == ' '; i ++ );\n\tline = line + i;\n\t\n\t/* If we're already at the end of the line, return. If not, we're going to need at least one element. */\n\tif( line[0] == '\\0')\n\t\treturn NULL;\n\t\n\t/* Count the number of char **cmd elements we're going to need. */\n\tj = 1;\n\tfor( i = 0; line[i] != '\\0'; i ++ )\n\t{\n\t\tif( line[i] == ' ' )\n\t\t{\n\t\t\tj ++;\n\t\t\t\n\t\t\tif( line[i+1] == ':' )\n\t\t\t\tbreak;\n\t\t}\n\t}\t\n\n\t/* Allocate the space we need. */\n\tcmd = g_new( char *, j + 1 );\n\tcmd[j] = NULL;\n\t\n\t/* Do the actual line splitting, format is:\n\t * Input: \"PRIVMSG #bitlbee :foo bar\"\n\t * Output: cmd[0]==\"PRIVMSG\", cmd[1]==\"#bitlbee\", cmd[2]==\"foo bar\", cmd[3]==NULL\n\t */\n\n\tcmd[0] = line;\n\tfor( i = 0, j = 0; line[i] != '\\0'; i ++ )\n\t{\n\t\tif( line[i] == ' ' )\n\t\t{\n\t\t\tline[i] = '\\0';\n\t\t\tcmd[++j] = line + i + 1;\n\t\t\t\n\t\t\tif( line[i+1] == ':' )\n\t\t\t{\n\t\t\t\tcmd[j] ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cmd;\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n *  aim_tx_purgequeue()\n *  \n *  This is responsable for removing sent commands from the transmit \n *  queue. This is not a required operation, but it of course helps\n *  reduce memory footprint at run time!  \n *\n */\n", "func_signal": "void aim_tx_purgequeue(aim_session_t *sess)", "code": "{\n\taim_frame_t *cur, **prev;\n\n\tfor (prev = &sess->queue_outgoing; (cur = *prev); ) {\n\n\t\tif (cur->handled) {\n\t\t\t*prev = cur->next;\n\n\t\t\taim_frame_destroy(cur);\n\n\t\t} else\n\t\t\tprev = &cur->next;\n\t}\n\n\treturn;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* Splits a long string into separate lines. The array is NULL-terminated and, unless the string\n   contains an incomplete line at the end, ends with an empty string. */\n", "func_signal": "char **irc_tokenize( char *buffer )", "code": "{\n\tint i, j, n = 3;\n\tchar **lines;\n\n\t/* Allocate n+1 elements. */\n\tlines = g_new( char *, n + 1 );\n\t\n\tlines[0] = buffer;\n\t\n\t/* Split the buffer in several strings, and accept any kind of line endings,\n\t * knowing that ERC on Windows may send something interesting like \\r\\r\\n,\n\t * and surely there must be clients that think just \\n is enough... */\n\tfor( i = 0, j = 0; buffer[i] != '\\0'; i ++ )\n\t{\n\t\tif( buffer[i] == '\\r' || buffer[i] == '\\n' )\n\t\t{\n\t\t\twhile( buffer[i] == '\\r' || buffer[i] == '\\n' )\n\t\t\t\tbuffer[i++] = '\\0';\n\t\t\t\n\t\t\tlines[++j] = buffer + i;\n\t\t\t\n\t\t\tif( j >= n )\n\t\t\t{\n\t\t\t\tn *= 2;\n\t\t\t\tlines = g_renew( char *, lines, n + 1 );\n\t\t\t}\n\n\t\t\tif( buffer[i] == '\\0' )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/* NULL terminate our list. */ \n\tlines[++j] = NULL;\n\t\n\treturn lines;\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * Allocate a new tx frame.\n *\n * This is more for looks than anything else.\n *\n * Right now, that is.  If/when we implement a pool of transmit\n * frames, this will become the request-an-unused-frame part.\n *\n * framing = AIM_FRAMETYPE_OFT/FLAP\n * chan = channel for FLAP, hdrtype for OFT\n *\n */\n", "func_signal": "aim_frame_t *aim_tx_new(aim_session_t *sess, aim_conn_t *conn, guint8 framing, guint8 chan, int datalen)", "code": "{\n\taim_frame_t *fr;\n\n\tif (!conn) {\n\t\timcb_error(sess->aux_data, \"no connection specified\");\n\t\treturn NULL;\n\t}\n\n\tif (!(fr = (aim_frame_t *)g_new0(aim_frame_t,1)))\n\t\treturn NULL;\n\n\tfr->conn = conn; \n\n\tfr->hdrtype = framing;\n\n\tif (fr->hdrtype == AIM_FRAMETYPE_FLAP) {\n\n\t\tfr->hdr.flap.type = chan;\n\n\t} else \n\t\timcb_error(sess->aux_data, \"unknown framing\");\n\n\tif (datalen > 0) {\n\t\tguint8 *data;\n\n\t\tif (!(data = (unsigned char *)g_malloc(datalen))) {\n\t\t\taim_frame_destroy(fr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\taim_bstream_init(&fr->data, data, datalen);\n\t}\n\n\treturn fr;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* called for both reply and change-reply */\n", "func_signal": "static int infochange(aim_session_t *sess, aim_module_t *mod, aim_frame_t *rx, aim_modsnac_t *snac, aim_bstream_t *bs)", "code": "{\n\n\t/*\n\t * struct {\n\t *    guint16 perms;\n\t *    guint16 tlvcount;\n\t *    aim_tlv_t tlvs[tlvcount];\n\t *  } admin_info[n];\n\t */\n\twhile (aim_bstream_empty(bs)) {\n\t\tguint16 perms, tlvcount;\n\n\t\tperms = aimbs_get16(bs);\n\t\ttlvcount = aimbs_get16(bs);\n\n\t\twhile (tlvcount && aim_bstream_empty(bs)) {\n\t\t\taim_rxcallback_t userfunc;\n\t\t\tguint16 type, len;\n\t\t\tguint8 *val;\n\t\t\tint str = 0;\n\n\t\t\ttype = aimbs_get16(bs);\n\t\t\tlen = aimbs_get16(bs);\n\n\t\t\tif ((type == 0x0011) || (type == 0x0004))\n\t\t\t\tstr = 1;\n\n\t\t\tif (str)\n\t\t\t\tval = (guint8 *)aimbs_getstr(bs, len);\n\t\t\telse\n\t\t\t\tval = aimbs_getraw(bs, len);\n\n\t\t\t/* XXX fix so its only called once for the entire packet */\n\t\t\tif ((userfunc = aim_callhandler(sess, rx->conn, snac->family, snac->subtype)))\n\t\t\t\tuserfunc(sess, rx, (snac->subtype == 0x0005) ? 1 : 0, perms, type, len, val, str);\n\n\t\t\tg_free(val);\n\n\t\t\ttlvcount--;\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "protocols\\oscar\\admin.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/**\n * aim_frame_destroy - free aim_frame_t \n * @frame: the frame to free  \n *\n * returns -1 on error; 0 on success.  \n *\n */\n", "func_signal": "void aim_frame_destroy(aim_frame_t *frame)", "code": "{\n\n\tg_free(frame->data.data); /* XXX aim_bstream_free */\n\n\tg_free(frame);\n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* Returns 0 if everything seems to be okay, a number >0 when there was a\n   timeout. The number returned is the number of seconds we received no\n   pongs from the user. When not connected yet, we don't ping but drop the\n   connection when the user fails to connect in IRC_LOGIN_TIMEOUT secs. */\n", "func_signal": "static gboolean irc_userping( gpointer _irc, gint fd, b_input_condition cond )", "code": "{\n\tirc_t *irc = _irc;\n\tint rv = 0;\n\t\n\tif( !( irc->status & USTATUS_LOGGED_IN ) )\n\t{\n\t\tif( gettime() > ( irc->last_pong + IRC_LOGIN_TIMEOUT ) )\n\t\t\trv = gettime() - irc->last_pong;\n\t}\n\telse\n\t{\n\t\tif( ( gettime() > ( irc->last_pong + global.conf->ping_interval ) ) && !irc->pinging )\n\t\t{\n\t\t\tirc_write( irc, \"PING :%s\", IRC_PING_STRING );\n\t\t\tirc->pinging = 1;\n\t\t}\n\t\telse if( gettime() > ( irc->last_pong + global.conf->ping_timeout ) )\n\t\t{\n\t\t\trv = gettime() - irc->last_pong;\n\t\t}\n\t}\n\t\n\tif( rv > 0 )\n\t{\n\t\tirc_abort( irc, 0, \"Ping Timeout: %d seconds\", rv );\n\t\treturn FALSE;\n\t}\n\t\n\treturn TRUE;\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * aim_tx_enqeue__queuebased()\n *\n * The overall purpose here is to enqueue the passed in command struct\n * into the outgoing (tx) queue.  Basically...\n *   1) Make a scope-irrelevent copy of the struct\n *   3) Mark as not-sent-yet\n *   4) Enqueue the struct into the list\n *   6) Return\n *\n * Note that this is only used when doing queue-based transmitting;\n * that is, when sess->tx_enqueue is set to &aim_tx_enqueue__queuebased.\n *\n */\n", "func_signal": "static int aim_tx_enqueue__queuebased(aim_session_t *sess, aim_frame_t *fr)", "code": "{\n\n\tif (!fr->conn) {\n\t\timcb_error(sess->aux_data, \"Warning: enqueueing packet with no connection\");\n\t\tfr->conn = aim_getconn_type(sess, AIM_CONN_TYPE_BOS);\n\t}\n\n\tif (fr->hdrtype == AIM_FRAMETYPE_FLAP) {\n\t\t/* assign seqnum -- XXX should really not assign until hardxmit */\n\t\tfr->hdr.flap.seqnum = aim_get_next_txseqnum(fr->conn);\n\t}\n\n\tfr->handled = 0; /* not sent yet */\n\n\t/* see overhead note in aim_rxqueue counterpart */\n\tif (!sess->queue_outgoing)\n\t\tsess->queue_outgoing = fr;\n\telse {\n\t\taim_frame_t *cur;\n\n\t\tfor (cur = sess->queue_outgoing; cur->next; cur = cur->next)\n\t\t\t;\n\t\tcur->next = fr;\n\t}\n\n\treturn 0;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* USE WITH CAUTION!\n   Sets pass without checking */\n", "func_signal": "void irc_setpass (irc_t *irc, const char *pass)", "code": "{\n\tg_free (irc->password);\n\t\n\tif (pass) {\n\t\tirc->password = g_strdup (pass);\n\t} else {\n\t\tirc->password = NULL;\n\t}\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n *\n */\n", "func_signal": "int aim_recv(int fd, void *buf, size_t count)", "code": "{\n\tint left, cur; \n\n\tfor (cur = 0, left = count; left; ) {\n\t\tint ret;\n\t\t\n\t\tret = recv(fd, ((unsigned char *)buf)+cur, left, 0);\n\n\t\t/* Of course EOF is an error, only morons disagree with that. */\n\t\tif (ret <= 0)\n\t\t\treturn -1;\n\n\t\tcur += ret;\n\t\tleft -= ret;\n\t}\n\n\treturn cur;\n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*\n * Grab a single command sequence off the socket, and enqueue\n * it in the incoming event queue in a seperate struct.\n */\n", "func_signal": "int aim_get_command(aim_session_t *sess, aim_conn_t *conn)", "code": "{\n\tguint8 flaphdr_raw[6];\n\taim_bstream_t flaphdr;\n\taim_frame_t *newrx;\n\tguint16 payloadlen;\n\t\n\tif (!sess || !conn)\n\t\treturn 0;\n\n\tif (conn->fd == -1)\n\t\treturn -1; /* its a aim_conn_close()'d connection */\n\n\t/* KIDS, THIS IS WHAT HAPPENS IF YOU USE CODE WRITTEN FOR GUIS IN A DAEMON!\n\t   \n\t   And wouldn't it make sense to return something that prevents this function\n\t   from being called again IMMEDIATELY (and making the program suck up all\n\t   CPU time)?...\n\t   \n\tif (conn->fd < 3)\n\t\treturn 0;\n\t*/\n\n\tif (conn->status & AIM_CONN_STATUS_INPROGRESS)\n\t\treturn aim_conn_completeconnect(sess, conn);\n\n\taim_bstream_init(&flaphdr, flaphdr_raw, sizeof(flaphdr_raw));\n\n\t/*\n\t * Read FLAP header.  Six bytes:\n\t *    \n\t *   0 char  -- Always 0x2a\n\t *   1 char  -- Channel ID.  Usually 2 -- 1 and 4 are used during login.\n\t *   2 short -- Sequence number \n\t *   4 short -- Number of data bytes that follow.\n\t */\n\tif (aim_bstream_recv(&flaphdr, conn->fd, 6) < 6) {\n\t\taim_conn_close(conn);\n\t\treturn -1;\n\t}\n\n\taim_bstream_rewind(&flaphdr);\n\n\t/*\n\t * This shouldn't happen unless the socket breaks, the server breaks,\n\t * or we break.  We must handle it just in case.\n\t */\n\tif (aimbs_get8(&flaphdr) != 0x2a) {\n\t\tguint8 start;\n\n\t\taim_bstream_rewind(&flaphdr);\n\t\tstart = aimbs_get8(&flaphdr);\n\t\timcb_error(sess->aux_data, \"FLAP framing disrupted\");\n\t\taim_conn_close(conn);\n\t\treturn -1;\n\t}\t\n\n\t/* allocate a new struct */\n\tif (!(newrx = (aim_frame_t *)g_new0(aim_frame_t,1)))\n\t\treturn -1;\n\n\t/* we're doing FLAP if we're here */\n\tnewrx->hdrtype = AIM_FRAMETYPE_FLAP;\n\t\n\tnewrx->hdr.flap.type = aimbs_get8(&flaphdr);\n\tnewrx->hdr.flap.seqnum = aimbs_get16(&flaphdr);\n\tpayloadlen = aimbs_get16(&flaphdr);\n\n\tnewrx->nofree = 0; /* free by default */\n\n\tif (payloadlen) {\n\t\tguint8 *payload = NULL;\n\n\t\tif (!(payload = (guint8 *) g_malloc(payloadlen))) {\n\t\t\taim_frame_destroy(newrx);\n\t\t\treturn -1;\n\t\t}\n\n\t\taim_bstream_init(&newrx->data, payload, payloadlen);\n\n\t\t/* read the payload */\n\t\tif (aim_bstream_recv(&newrx->data, conn->fd, payloadlen) < payloadlen) {\n\t\t\taim_frame_destroy(newrx); /* free's payload */\n\t\t\taim_conn_close(conn);\n\t\t\treturn -1;\n\t\t}\n\t} else\n\t\taim_bstream_init(&newrx->data, NULL, 0);\n\n\n\taim_bstream_rewind(&newrx->data);\n\n\tnewrx->conn = conn;\n\n\tnewrx->next = NULL;  /* this will always be at the bottom */\n\n\tif (!sess->queue_incoming)\n\t\tsess->queue_incoming = newrx;\n\telse {\n\t\taim_frame_t *cur;\n\n\t\tfor (cur = sess->queue_incoming; cur->next; cur = cur->next)\n\t\t\t;\n\t\tcur->next = newrx;\n\t}\n\n\tnewrx->conn->lastactivity = time(NULL);\n\n\treturn 0;  \n}", "path": "protocols\\oscar\\rxqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/**\n * aim_tx_cleanqueue - get rid of packets waiting for tx on a dying conn\n * @sess: session\n * @conn: connection that's dying\n *\n * for now this simply marks all packets as sent and lets them\n * disappear without warning.\n *\n */\n", "func_signal": "void aim_tx_cleanqueue(aim_session_t *sess, aim_conn_t *conn)", "code": "{\n\taim_frame_t *cur;\n\n\tfor (cur = sess->queue_outgoing; cur; cur = cur->next) {\n\t\tif (cur->conn == conn)\n\t\t\tcur->handled = 1;\n\t}\n\n\treturn;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* Because we have no garbage collection, this is quite annoying */\n", "func_signal": "void irc_free( irc_t * irc )", "code": "{\n\tuser_t *user, *usertmp;\n\t\n\tlog_message( LOGLVL_INFO, \"Destroying connection with fd %d\", irc->fd );\n\t\n\tif( irc->status & USTATUS_IDENTIFIED && set_getbool( &irc->set, \"save_on_quit\" ) ) \n\t\tif( storage_save( irc, NULL, TRUE ) != STORAGE_OK )\n\t\t\tirc_usermsg( irc, \"Error while saving settings!\" );\n\t\n\tirc_connection_list = g_slist_remove( irc_connection_list, irc );\n\t\n\twhile( irc->accounts )\n\t{\n\t\tif( irc->accounts->ic )\n\t\t\timc_logout( irc->accounts->ic, FALSE );\n\t\telse if( irc->accounts->reconnect )\n\t\t\tcancel_auto_reconnect( irc->accounts );\n\t\t\n\t\tif( irc->accounts->ic == NULL )\n\t\t\taccount_del( irc, irc->accounts );\n\t\telse\n\t\t\t/* Nasty hack, but account_del() doesn't work in this\n\t\t\t   case and we don't want infinite loops, do we? ;-) */\n\t\t\tirc->accounts = irc->accounts->next;\n\t}\n\t\n\twhile( irc->queries != NULL )\n\t\tquery_del( irc, irc->queries );\n\t\n\twhile( irc->set )\n\t\tset_del( &irc->set, irc->set->key );\n\t\n\tif (irc->users != NULL)\n\t{\n\t\tuser = irc->users;\n\t\twhile( user != NULL )\n\t\t{\n\t\t\tg_free( user->nick );\n\t\t\tg_free( user->away );\n\t\t\tg_free( user->handle );\n\t\t\tif( user->user != user->nick ) g_free( user->user );\n\t\t\tif( user->host != user->nick ) g_free( user->host );\n\t\t\tif( user->realname != user->nick ) g_free( user->realname );\n\t\t\tb_event_remove( user->sendbuf_timer );\n\t\t\t\t\t\n\t\t\tusertmp = user;\n\t\t\tuser = user->next;\n\t\t\tg_free( usertmp );\n\t\t}\n\t}\n\t\n\tif( irc->ping_source_id > 0 )\n\t\tb_event_remove( irc->ping_source_id );\n\tif( irc->r_watch_source_id > 0 )\n\t\tb_event_remove( irc->r_watch_source_id );\n\tif( irc->w_watch_source_id > 0 )\n\t\tb_event_remove( irc->w_watch_source_id );\n\t\n\tclosesocket( irc->fd );\n\tirc->fd = -1;\n\t\n\tg_hash_table_foreach_remove( irc->userhash, irc_free_hashkey, NULL );\n\tg_hash_table_destroy( irc->userhash );\n\t\n\tg_hash_table_foreach_remove( irc->watches, irc_free_hashkey, NULL );\n\tg_hash_table_destroy( irc->watches );\n\t\n\tif( irc->iconv != (GIConv) -1 )\n\t\tg_iconv_close( irc->iconv );\n\tif( irc->oconv != (GIConv) -1 )\n\t\tg_iconv_close( irc->oconv );\n\t\n\tg_free( irc->sendbuffer );\n\tg_free( irc->readbuffer );\n\t\n\tg_free( irc->nick );\n\tg_free( irc->user );\n\tg_free( irc->host );\n\tg_free( irc->realname );\n\tg_free( irc->password );\n\t\n\tg_free( irc->myhost );\n\tg_free( irc->mynick );\n\t\n\tg_free( irc->channel );\n\t\n\tg_free( irc->last_target );\n\t\n\tg_free( irc );\n\t\n\tif( global.conf->runmode == RUNMODE_INETD ||\n\t    global.conf->runmode == RUNMODE_FORKDAEMON ||\n\t    ( global.conf->runmode == RUNMODE_DAEMON &&\n\t      global.listen_socket == -1 &&\n\t      irc_connection_list == NULL ) )\n\t\tb_main_quit();\n}", "path": "irc.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/**\n * Subtype 0x0003 - Response to 0x0015/0x002, contains an ICQesque packet.\n */\n", "func_signal": "static int icqresponse(aim_session_t *sess, aim_module_t *mod, aim_frame_t *rx, aim_modsnac_t *snac, aim_bstream_t *bs)", "code": "{\n\tint ret = 0;\n\taim_tlvlist_t *tl;\n\taim_tlv_t *datatlv;\n\taim_bstream_t qbs;\n\tguint32 ouruin;\n\tguint16 cmdlen, cmd, reqid;\n\n\tif (!(tl = aim_readtlvchain(bs)) || !(datatlv = aim_gettlv(tl, 0x0001, 1))) {\n\t\taim_freetlvchain(&tl);\n\t\timcb_error(sess->aux_data, \"corrupt ICQ response\\n\");\n\t\treturn 0;\n\t}\n\n\taim_bstream_init(&qbs, datatlv->value, datatlv->length);\n\n\tcmdlen = aimbs_getle16(&qbs);\n\touruin = aimbs_getle32(&qbs);\n\tcmd = aimbs_getle16(&qbs);\n\treqid = aimbs_getle16(&qbs);\n\n\tif (cmd == 0x0041) { /* offline message */\n\t\tguint16 msglen;\n\t\tstruct aim_icq_offlinemsg msg;\n\t\taim_rxcallback_t userfunc;\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\n\t\tmsg.sender = aimbs_getle32(&qbs);\n\t\tmsg.year = aimbs_getle16(&qbs);\n\t\tmsg.month = aimbs_getle8(&qbs);\n\t\tmsg.day = aimbs_getle8(&qbs);\n\t\tmsg.hour = aimbs_getle8(&qbs);\n\t\tmsg.minute = aimbs_getle8(&qbs);\n\t\tmsg.type = aimbs_getle16(&qbs);\n\t\tmsglen = aimbs_getle16(&qbs);\n\t\tmsg.msg = aimbs_getstr(&qbs, msglen);\n\n\t\tif ((userfunc = aim_callhandler(sess, rx->conn, AIM_CB_FAM_ICQ, AIM_CB_ICQ_OFFLINEMSG)))\n\t\t\tret = userfunc(sess, rx, &msg);\n\n\t\tg_free(msg.msg);\n\n\t} else if (cmd == 0x0042) {\n\t\taim_rxcallback_t userfunc;\n\n\t\tif ((userfunc = aim_callhandler(sess, rx->conn, AIM_CB_FAM_ICQ, AIM_CB_ICQ_OFFLINEMSGCOMPLETE)))\n\t\t\tret = userfunc(sess, rx);\n\t} else if (cmd == 0x07da) { /* information */\n\t\tguint16 subtype;\n\t\tstruct aim_icq_info *info;\n\t\taim_rxcallback_t userfunc;\n\n\t\tsubtype = aimbs_getle16(&qbs);\n\t\taim_bstream_advance(&qbs, 1); /* 0x0a */\n\n\t\t/* find another data from the same request */\n\t\tfor (info = sess->icq_info; info && (info->reqid != reqid); info = info->next);\n\n\t\tif (!info) {\n\t\t\tinfo = g_new0(struct aim_icq_info, 1);\n\t\t\tinfo->reqid = reqid;\n\t\t\tinfo->next = sess->icq_info;\n\t\t\tsess->icq_info = info;\n\t\t}\n\n\t\tswitch (subtype) {\n\t\t\tcase 0x00a0: { /* hide ip status */\n\t\t\t\t\t\t\t /* nothing */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00aa: { /* password change status */\n\t\t\t\t\t\t\t /* nothing */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00c8: { /* general and \"home\" information */\n\t\t\t\t\t\t\t info->nick = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->first = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->last = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->email = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homecity = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homestate = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homephone = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homefax = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homeaddr = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->mobile = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homezip = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->homecountry = aimbs_getle16(&qbs);\n\t\t\t\t\t\t\t /* 0x0a 00 02 00 */\n\t\t\t\t\t\t\t /* 1 byte timezone? */\n\t\t\t\t\t\t\t /* 1 byte hide email flag? */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00dc: { /* personal information */\n\t\t\t\t\t\t\t info->age = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->unknown = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->gender = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->personalwebpage = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->birthyear = aimbs_getle16(&qbs);\n\t\t\t\t\t\t\t info->birthmonth = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->birthday = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->language1 = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->language2 = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t info->language3 = aimbs_getle8(&qbs);\n\t\t\t\t\t\t\t /* 0x00 00 01 00 00 01 00 00 00 00 00 */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00d2: { /* work information */\n\t\t\t\t\t\t\t info->workcity = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workstate = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workphone = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workfax = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workaddr = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workzip = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workcountry = aimbs_getle16(&qbs);\n\t\t\t\t\t\t\t info->workcompany = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workdivision = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->workposition = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t aim_bstream_advance(&qbs, 2); /* 0x01 00 */\n\t\t\t\t\t\t\t info->workwebpage = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00e6: { /* additional personal information */\n\t\t\t\t\t\t\t info->info = aimbs_getstr(&qbs, aimbs_getle16(&qbs)-1);\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00eb: { /* email address(es) */\n\t\t\t\t\t\t\t int i;\n\t\t\t\t\t\t\t info->numaddresses = aimbs_getle16(&qbs);\n\t\t\t\t\t\t\t info->email2 = g_new0(char *, info->numaddresses);\n\t\t\t\t\t\t\t for (i = 0; i < info->numaddresses; i++) {\n\t\t\t\t\t\t\t\t info->email2[i] = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t\t if (i+1 != info->numaddresses)\n\t\t\t\t\t\t\t\t\t aim_bstream_advance(&qbs, 1); /* 0x00 */\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00f0: { /* personal interests */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x00fa: { /* past background and current organizations */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x0104: { /* alias info */\n\t\t\t\t\t\t\t info->nick = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->first = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->last = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t aim_bstream_advance(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t /* email address? */\n\t\t\t\t\t\t\t /* Then 0x00 02 00 */\n\t\t\t\t\t\t } break;\n\t\t\tcase 0x010e: { /* unknown */\n\t\t\t\t\t\t\t /* 0x00 00 */\n\t\t\t\t\t\t } break;\n\n\t\t\tcase 0x019a: { /* simple info */\n\t\t\t\t\t\t\t aim_bstream_advance(&qbs, 2);\n\t\t\t\t\t\t\t info->uin = aimbs_getle32(&qbs);\n\t\t\t\t\t\t\t info->nick = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->first = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->last = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t info->email = aimbs_getstr(&qbs, aimbs_getle16(&qbs));\n\t\t\t\t\t\t\t /* Then 0x00 02 00 00 00 00 00 */\n\t\t\t\t\t\t } break;\n\t\t} /* End switch statement */\n\n\n\t\tif (!(snac->flags & 0x0001)) {\n\t\t\tif (subtype != 0x0104)\n\t\t\t\tif ((userfunc = aim_callhandler(sess, rx->conn, AIM_CB_FAM_ICQ, AIM_CB_ICQ_INFO)))\n\t\t\t\t\tret = userfunc(sess, rx, info);\n\n\t\t\t/* Bitlbee - not supported, yet \n\t\t\tif (info->uin && info->nick)\n\t\t\t\tif ((userfunc = aim_callhandler(sess, rx->conn, AIM_CB_FAM_ICQ, AIM_CB_ICQ_ALIAS)))\n\t\t\t\t\tret = userfunc(sess, rx, info);\n\t\t\t*/\n\n\t\t\tif (sess->icq_info == info) {\n\t\t\t\tsess->icq_info = info->next;\n\t\t\t} else {\n\t\t\t\tstruct aim_icq_info *cur;\n\t\t\t\tfor (cur=sess->icq_info; (cur->next && (cur->next!=info)); cur=cur->next);\n\t\t\t\tif (cur->next)\n\t\t\t\t\tcur->next = cur->next->next;\n\t\t\t}\n\t\t\taim_icq_freeinfo(info);\n\t\t}\n\t}\n\n\taim_freetlvchain(&tl);\n\n\treturn ret;\n}", "path": "protocols\\oscar\\icq.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/* \n *  aim_get_next_txseqnum()\n *\n *   This increments the tx command count, and returns the seqnum\n *   that should be stamped on the next FLAP packet sent.  This is\n *   normally called during the final step of packet preparation\n *   before enqueuement (in aim_tx_enqueue()).\n *\n */\n", "func_signal": "flap_seqnum_t aim_get_next_txseqnum(aim_conn_t *conn)", "code": "{\n\tflap_seqnum_t ret;\n\t\n\tret = ++conn->seqnum;\n\n\treturn ret;\n}", "path": "protocols\\oscar\\txqueue.c", "repo_name": "jianingy/bitlbee-clone", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 612}
{"docstring": "/*****************************************************************************\n* Function: GadgetSetNumDays\n*\n* Description: Sets number of days\n*****************************************************************************/\n", "func_signal": "void\nGadgetSetNumDays(UInt8 numDays)", "code": "{\n  gGadgetDaysNum=numDays;\n  gGadgetDaysWidth=GADGET_TOTAL_DRAWWIDTH / numDays;\n  gGadgetCompleteRedraw=true;\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetHandler\n*\n* Description: We use extended Gadgeting => We need an event handler for it\n*****************************************************************************/\n", "func_signal": "Boolean\nGadgetHandler(FormGadgetTypeInCallback *gadgetP, UInt16 cmd, void *paramP)", "code": "{\n  Boolean handled = false; \n  EventType *event = (EventType *)paramP;\n  \n  switch (cmd) { \n    case formGadgetDrawCmd: \n      //Sent to active gadgets any time form is  \n      //drawn or redrawn. \n      GadgetRedraw();\n      gadgetP->attr.visible = true; \n      handled = true; \n      break; \n       \n    case formGadgetHandleEventCmd: \n      //Sent when form receives a gadget event.  \n      //paramP points to EventType structure.\n\n      if (event->eType == frmGadgetEnterEvent) { \n        // penDown in gadget's bounds.\n        GadgetTap((FormGadgetType *)gadgetP, event);\n        handled = true;\n      }\n      if (event->eType == frmGadgetMiscEvent) {\n        //This event is sent by your application\n        //when it needs to send info to the gadget\n      }\n      break;\n\n    case formGadgetDeleteCmd:\n      //Perform any cleanup prior to deletion.\n      TNlistFree(gGadgetTimeList);\n      gGadgetTimeList = NULL;\n      break;\n\n    case formGadgetEraseCmd:\n      //FrmHideObject takes care of this if you \n      //return false.\n       handled = false;\n       break;\n\n    default:\n      break;\n\n  }\n  return handled;\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * Receive Functions\n ***********************************************************************/\n", "func_signal": "static Err\nBeamReadRecordIntoDB(DmOpenRef cats, DmOpenRef dogs, ExgSocketPtr socketPtr, UInt32 numBytes,\n\t\t     UInt16 category, UInt16 *courseID, UInt8 *courseType, UInt16 *noteID)", "code": "{\n  char *buffer=NULL;\n  Err  err=0;\n  UInt32 bytesReceived=0, numBytesToRead=numBytes;\n  void *curpos=NULL;\n  Boolean allocatedRec = false, doAlloc=true, doAllocInDogs=false;\n  MemHandle recHandle=NULL;\n  Char *recPtr=NULL;\n  Char *t=MemPtrNew(numBytes);\n  UInt16 index = dmMaxRecordIndex, searchIndex=0;\n  MemHandle m;\n                              \n  buffer=(char *)MemPtrNew(numBytesToRead);\n  curpos=t;\n\n  // Receive the record\n  do {\n    bytesReceived = ExgReceive(socketPtr, buffer, numBytesToRead, &err);\n    numBytes -= bytesReceived;\n\n    MemMove(curpos, buffer, bytesReceived);\n    curpos += bytesReceived;\n  } while (!err && (bytesReceived > 0) && (numBytes > 0));\n\n  MemPtrFree((MemPtr) buffer);\n\n  // Pre handling for record to prevent duplicates from happen\n  if (t[0] == TYPE_CTYP) {\n    // It's a course type. check if that already exists\n    CourseTypeDBRecord *ct=(CourseTypeDBRecord *)t;\n    UInt8 newID=0;\n    while ( doAlloc && ((m = DmQueryNextInCategory(dogs, &searchIndex, 0)) != NULL)) {\n      Char *b=MemHandleLock(m);\n      if (b[0] == TYPE_CTYP) {\n        CourseTypeDBRecord *tct = (CourseTypeDBRecord *)b;\n        if (tct->id > newID)  newID=tct->id;\n        if (StrCompare(ct->name, tct->name) == 0) {\n          // Strings match, we already have such a course type\n          *courseType=tct->id;\n          doAlloc=false;\n        }\n      }\n      searchIndex += 1;\n      MemHandleUnlock(m);\n    }\n    newID += 1;\n    if (doAlloc)  *courseType = newID;\n    doAllocInDogs=true;\n  } else if (t[0] == TYPE_COURSE) {\n    // It's a course, give it a new course ID\n    PackedCourseDBRecord *pc=(PackedCourseDBRecord *)t;\n\n    pc->id = CourseNewID(cats, category);\n    pc->ctype = *courseType;\n    *courseID=pc->id;\n    *noteID = 0; //Reset note ID\n\n    // Test, if we have already a course named like the wanted course\n    // name is first field so we can just access it and do not need to unpack the course\n    while(doAlloc && ((m = DmQueryNextInCategory(cats, &searchIndex, category)) != NULL)) {\n      Char *b=MemHandleLock(m);\n      if (b[0] == TYPE_COURSE) {\n        PackedCourseDBRecord *tpc = (PackedCourseDBRecord *)b;\n        if ((StrCompare(tpc->name, pc->name) == 0) && (tpc->ctype == pc->ctype)) {\n          // Strings match, we already have such a course\n          *courseID=tpc->id;\n          doAlloc=false;\n        }\n      }\n      searchIndex += 1;\n      MemHandleUnlock(m);\n    }\n  } else if (t[0] == TYPE_TIME) {\n    TimeDBRecord *tr = (TimeDBRecord *)t;\n    tr->course = *courseID;\n    tr->note = *noteID;\n    // Check if this course already exists\n    while(doAlloc && ((m = DmQueryNextInCategory(cats, &searchIndex, category)) != NULL)) {\n      Char *b=MemHandleLock(m);\n      if (b[0] == TYPE_TIME) {\n        TimeDBRecord *tt = (TimeDBRecord *)b;\n        if ( (tt->course == *courseID) && (tr->day == tt->day) &&\n             (TimeToInt(tr->begin) == TimeToInt(tt->begin)) && (TimeToInt(tr->end) == TimeToInt(tt->end)) ) {\n          // Times match\n          doAlloc=false;\n        }\n      }\n      searchIndex += 1;\n      MemHandleUnlock(m);\n    }\n  } else if (t[0] == TYPE_EXAM) {\n    ExamDBRecord *ex = (ExamDBRecord *)t;\n    ex->course = *courseID;\n    ex->note = *noteID;\n    // Check if this exam already exists\n    while(doAlloc && ((m = DmQueryNextInCategory(cats, &searchIndex, category)) != NULL)) {\n      Char *b=MemHandleLock(m);\n      if (b[0] == TYPE_EXAM) {\n        ExamDBRecord *te = (ExamDBRecord *)b;\n        if ( (te->course == *courseID) && (DateToDays(te->date) == DateToDays(ex->date)) ) {\n          // Exams match\n          doAlloc=false;\n        }\n      }\n      searchIndex += 1;\n      MemHandleUnlock(m);\n    }\n  } else if (t[0] == TYPE_NOTE) {\n    NoteDBRecord *note = (NoteDBRecord *)t;\n    *noteID = NoteGetNewID(cats, category);\n    note->id = *noteID;\n  }\n\n  // Store record\n  if (doAlloc) {\n    if (! doAllocInDogs) {\n      // Store record in CATS database\n      recHandle = DmNewRecord(cats, &index, numBytesToRead);\n      if (!recHandle) {\n        err =DmGetLastErr();\n        return err;\n      }\n  \n      allocatedRec = true;\n      recPtr=MemHandleLock(recHandle);\n      err = DmWrite(recPtr, 0, t, numBytesToRead);\n      MemHandleUnlock(recHandle);\n      MemPtrFree((MemPtr) t);\n  \n      if (recHandle) {\n        UInt16 attr;\n        DmReleaseRecord(cats, index, false);\n        DmRecordInfo(cats, index, &attr, NULL, NULL);\n        attr |= category;\n        DmSetRecordInfo(cats, index, &attr, NULL);\n      }\n      if (err && allocatedRec) DmRemoveRecord(cats, index);\n  \n      DatabaseSortByDBRef(cats);\n    } else {\n      // Store in DOGS database\n      recHandle = DmNewRecord(dogs, &index, numBytesToRead);\n      if (!recHandle) {\n        err =DmGetLastErr();\n        return err;\n      }\n  \n      allocatedRec = true;\n      recPtr=MemHandleLock(recHandle);\n      err = DmWrite(recPtr, 0, t, numBytesToRead);\n      MemHandleUnlock(recHandle);\n      MemPtrFree((MemPtr) t);\n  \n      if (err && allocatedRec) DmRemoveRecord(dogs, index);\n  \n      DatabaseSortByDBRef(dogs);\n    }\n  }\n\n  return err;\n}", "path": "beam.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetDrawHintErase\n*\n* Description: Erase the area where the hintbox goes\n*****************************************************************************/\n", "func_signal": "void\nGadgetDrawHintErase(void)", "code": "{\n  RectangleType bounds;\n  UInt16 gadgetIndex;\n  ControlType *ctl;\n\n  if (! gForm) return;\n\n  gadgetIndex = FrmGetObjectIndex(gForm, gHintGadgetID);\n  FrmGetObjectBounds(gForm, gadgetIndex, &bounds);\n\n  WinEraseRectangle(&bounds, 0);\n\n  ctl=GetObjectPtr(BUTTON_edit);\n  CtlHideControl(ctl);\n  ctl=GetObjectPtr(BUTTON_beam);\n  CtlHideControl(ctl);\n\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * Send Functions\n ***********************************************************************/\n", "func_signal": "static Err\nBeamBytes(ExgSocketPtr s, void *buffer, UInt32 bytesToSend)", "code": "{\n  Err err=0;\n\n  while (!err && (bytesToSend >0)) {\n    UInt32 bytesSent = ExgSend(s, buffer, bytesToSend, &err);\n    bytesToSend -= bytesSent;\n    buffer = ((Char *)buffer) + bytesSent;\n  }\n\n  return err;\n}", "path": "beam.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * handling for the main drop down menu actions\n ***********************************************************************/\n", "func_signal": "Boolean\nHandleMenuEvent (UInt16 command)", "code": "{\n  Boolean handled = false;\n  MenuEraseStatus(0);\n  gMenuCurrentForm=FrmGetFormId(FrmGetActiveForm());\n\n  switch (command) {\n  case MENUITEM_about:\n    FrmDoDialog(FrmInitForm(FORM_about));\n    handled=true;\n    break;\n\n  case MENUITEM_course:\n    AddCourse();\n    handled=true;\n    break;\n\n  case MENUITEM_time:\n    if (CountCourses() != 0) {\n      AddTime();\n    } else {\n      FrmAlert(ALERT_nocourses);\n    }\n    handled=true;\n    break;\n\n  case MENUITEM_courselist:\n    FrmGotoForm(FORM_courselist);\n    handled=true;\n    break;\n\n  case MENUITEM_settings:\n    FrmPopupForm(FORM_settings);\n    handled=true;\n    break;\n\n  case MENUITEM_alarm:\n    FrmPopupForm(FORM_alarm_sets);\n    handled=true;\n    break;\n\n  case MENUITEM_exams:\n    FrmGotoForm(FORM_exams);\n    handled=true;\n    break;\n\n  case MENUITEM_beam:\n    BeamSemester(DatabaseGetCat());\n    handled=true;\n    break;\n\n  case MENUITEM_chat:\n    AppLaunchWithCommand(UNICHAT_APP_CREATOR, sysAppLaunchCmdNormalLaunch, NULL);\n    handled=true;\n    break;\n\n  case MENUITEM_mensa:\n    AppLaunchWithCommand(UNIMENSA_APP_CREATOR, sysAppLaunchCmdNormalLaunch, NULL);\n    handled=true;\n    break;\n\n  default:\n    break;\n  }\n\n  return handled;\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * application is finished, so we have to clean the desktop behind us\n ***********************************************************************/\n", "func_signal": "static void\nStopApplication (void)", "code": "{\n  gPrefs.curCat = DatabaseGetCat();\n  PrefSavePrefs(&gPrefs);\n  FrmCloseAllForms ();\n  CacheFree();\n  CloseDatabase();\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n * Function:  DeleteEntry\n *\n * Description:  Deletes an entry\n *****************************************************************************/\n", "func_signal": "void\nDeleteEntry(void)", "code": "{\n  MemHandle mc, mt, mh, type;\n  TimeDBRecord *t;\n  CourseDBRecord c;\n  Char *day, *bot, begin[timeStringLength], end[timeStringLength];\n  UInt16 pressedButton=0;\n  TimeFormatType timeFormat=tfColon24h;\n\n  mc = DmQueryRecord(DatabaseGetRef(), GadgetGetHintCourseIndex());\n  UnpackCourse(&c, MemHandleLock(mc));\n\n  mt = DmQueryRecord(DatabaseGetRef(), GadgetGetHintTimeIndex());\n  t = (TimeDBRecord *)MemHandleLock(mt);\n\n  // Mi 08:00 - 09:30         <-- Example\n  // 2    5   3   5   3       <-- Num Chars for MemPtrNew\n  bot=(Char *)MemPtrNew(19);\n  MemSet(bot, MemPtrSize(bot), 0);\n\n  TimeToAscii(t->begin.hours, t->begin.minutes, timeFormat, begin);\n  TimeToAscii(t->end.hours, t->end.minutes, timeFormat, end);\n\n  mh = DmGetResource(strRsc, GADGET_STRINGS_WDAYSTART+t->day);\n  day = (Char *)MemHandleLock(mh);\n\n  type = MemHandleNew(1);\n  CourseTypeGetShort(&type, c.ctype);\n\n  StrPrintF(bot, \"%s %s - %s\", day, begin, end);\n\n  pressedButton=FrmCustomAlert(ALERT_dodel, c.name, (Char *)MemHandleLock(type), bot);\n\n  MemHandleUnlock(type);\n  MemHandleFree(type);\n  MemPtrFree((MemPtr)bot);\n  MemHandleUnlock(mc);\n  MemHandleUnlock(mt);\n  MemHandleUnlock(mh);\n\n  if (pressedButton == 0) {\n    // First Button => Yes, delete\n    Err err=errNone;\n    UInt16 deleteIndex = GadgetGetHintTimeIndex();\n    NoteDelete(&deleteIndex);\n    err=DmRemoveRecord(DatabaseGetRef(), deleteIndex);\n    if (err) FrmCustomAlert(ALERT_debug, \"Delete failed #132-a\", \"\", \"\");\n    // We cannot just redraw, unfortunately :-(\n    GadgetSetNeedsCompleteRedraw(true);\n    FrmDrawForm(FrmGetActiveForm());\n  }\n}", "path": "delete.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetDrawHintNext\n* Complexity: O(N), N = DmNumRecords\n*\n* Description: Draw info for closest upcoming event.\n*****************************************************************************/\n", "func_signal": "void\nGadgetDrawHintNext(void)", "code": "{\n  MemHandle m;\n  UInt16 index=0;\n  DateTimeType dt;\n  Boolean found=false, foundFirst=false;\n  UInt16 curTime, curMinTind=0, wantCourse=0, curMinTime=0xFFFF;\n  Int16 diffTime;\n  TimeDBRecord *t;\n\n  TimSecondsToDateTime(TimGetSeconds(), &dt);\n\n  if ((dt.weekDay > 0) && (dt.weekDay <= gGadgetDaysNum)) {\n    dt.weekDay = dt.weekDay-1;\n  } else {\n    dt.weekDay = 0;\n    dt.hour = 0;\n    dt.minute = 0;\n  }\n\n  curTime = dt.weekDay * GADGET_DAYVALUE + dt.hour * 60 + dt.minute;\n\n  // Search for record nearest in _past_ to current time\n  // NOTE: We assume that the types are sorted \"times -> courses\"! We use that to reduce everything to ONE while loop\n  while( !found && ((m = DmQueryNextInCategory(DatabaseGetRef(), &index, DatabaseGetCat())) != NULL)) {\n    Char *s=MemHandleLock(m);\n    if (s[0] == TYPE_TIME) {\n      t = (TimeDBRecord *)s;\n      if ( GadgetEventIsVisible(t) ) {\n        if (! foundFirst) {\n          foundFirst = true;\n          curMinTind = index;\n          wantCourse = t->course;\n        }\n\n        diffTime = (t->day * GADGET_DAYVALUE + t->begin.hours * 60 + t->begin.minutes) - curTime;\n        if ( (diffTime > 0) && (diffTime < curMinTime) ) {\n          curMinTind = index;\n          curMinTime = diffTime;\n          wantCourse = t->course;\n        }\n      }\n    } else if (s[0] == TYPE_COURSE) {\n      CourseDBRecord c;\n      UnpackCourse(&c, s);\n      if (c.id == wantCourse) {\n        gCourseIndex = index;\n        gTimeIndex = curMinTind;\n        found=true;\n      }\n    }\n    MemHandleUnlock(m);\n    index += 1;\n  }\n\n  if (! found || ! foundFirst)  GadgetDrawHintErase();\n  else                          GadgetDrawHintCurrent();\n\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * main function\n ***********************************************************************/\n", "func_signal": "UInt32\nPilotMain(UInt16 cmd, MemPtr cmdPBP, UInt16 launchFlags)", "code": "{\n  UInt16 error = RomVersionCompatible (MINVERSION, launchFlags);\n  if (error) return (error);\n\n  /***\n  * NORMAL STARTUP\n  ****/\n  if ( cmd == sysAppLaunchCmdNormalLaunch ) {\n    error = StartApplication ();\n    if (error) {\n      // PalmOS before 3.5 will continuously relaunch this app unless we switch to\n      // another safe one.\n      if (error != dmErrCorruptDatabase) {\n        FrmCustomAlert(ALERT_debug, \"Please reports this bug! Give your Palm device and PalmOS version, this BadBug(TM) should not happen.\", \"\", \"\");\n      }\n      StopApplication();\n      AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);\n      return error;\n    }\n\n    FrmGotoForm(FORM_main);\n\n    AppEventLoop ();\n    StopApplication ();\n\n    /***\n     * FIND\n     ****/\n    /*\n      } else if (cmd == sysAppLaunchCmdSaveData) {\n      FrmSaveAllForms();\n      } else if (cmd == sysAppLaunchCmdFind) {\n      PalmGlobalFind((FindParamsPtr)cmdPBP);\n    */\n\n    /***\n     * GoTo\n     ****/\n    /*\n      } else if (cmd == sysAppLaunchCmdGoTo) {\n      Boolean launched = launchFlags & sysAppLaunchFlagNewGlobals;\n\t\n      if (launched) {\n      error = StartApplication();\n      if (! error) {\n      GoToItem((GoToParamsPtr)cmdPBP, launched);\n      AppEventLoop();\n      StopApplication();\n      }\n      } else {\n      GoToItem((GoToParamsPtr)cmdPBP, launched);\n      }\n    */\n\n    /***\n     * BEAMING\n     ****/\n  } else if (cmd == sysAppLaunchCmdSyncNotify) {\n    // Register with the Exchange Manager\n    ExgRegisterData(APP_CREATOR, exgRegExtensionID, \"umx\");\n  } else if (cmd == sysAppLaunchCmdExgAskUser) {\n    // Always assume \"Yes\" as answer to the accept dialog since we display our\n    // own on which the user can cancel the data\n    ExgAskParamType *exgAskParam = (ExgAskParamType *)cmdPBP;\n    exgAskParam->result=exgAskOk;\n  } else if (cmd == sysAppLaunchCmdExgReceiveData) {\n    DmOpenRef cats=NULL, dogs=NULL;\n    // Is app active?\n    if (launchFlags & sysAppLaunchFlagSubCall) {\n      // Quit Forms\n      FrmSaveAllForms();\n\n      cats = DatabaseGetRefN(DB_MAIN);\n      dogs = DatabaseGetRefN(DB_DATA);\n      error = BeamReceive(cats, dogs, (ExgSocketPtr) cmdPBP);\n      CacheReset();\n      FrmGotoForm(FORM_main);\n\n    } else {\n      // Another app was running when we were called\n      cats = DmOpenDatabaseByTypeCreator(DATABASE_TYPE, APP_CREATOR, dmModeReadWrite);\n      dogs = DmOpenDatabaseByTypeCreator(DATABASE_DATA_TYPE, APP_CREATOR, dmModeReadWrite);\n      if (! (cats && dogs)) {\n        FrmAlert(ALERT_beamdbfail);\n      } else {\n        error=BeamReceive(cats, dogs, (ExgSocketPtr)cmdPBP);\n      }\n      if (cats)  DmCloseDatabase(cats);\n      if (dogs)  DmCloseDatabase(dogs);\n    }\n\n    /***\n     * ALARM\n     ****/\n  } else if (cmd == sysAppLaunchCmdAlarmTriggered) {\n    // Is app active?\n    if (launchFlags & sysAppLaunchFlagSubCall) {\n      AlarmTriggered(DatabaseGetRefN(DB_MAIN), (SysAlarmTriggeredParamType *)cmdPBP);\n    } else {\n      DmOpenRef cats = DmOpenDatabaseByTypeCreator(DATABASE_TYPE, APP_CREATOR, dmModeReadWrite);\n      AlarmTriggered(cats, (SysAlarmTriggeredParamType *)cmdPBP);\n      DmCloseDatabase(cats);\n    }\n\n    /***\n     * ATTENTION\n     ****/\n  } else if (cmd == sysAppLaunchCmdAttention) {\n    // Is app active?\n    if (launchFlags & sysAppLaunchFlagSubCall) {\n      AttentionBottleNeckProc(DatabaseGetRefN(DB_MAIN), (AttnLaunchCodeArgsType *)cmdPBP);\n    } else {\n      // Another app was running when we were called\n      DmOpenRef cats = DmOpenDatabaseByTypeCreator(DATABASE_TYPE, APP_CREATOR, dmModeReadWrite);\n      AttentionBottleNeckProc(cats, (AttnLaunchCodeArgsType *)cmdPBP);\n      DmCloseDatabase(cats);\n    }\n\n    /***\n     * ATTENTION GOTO\n     ****/\n  } else if (cmd == appLaunchCmdAlarmEventGoto) {\n    error = StartApplication ();\n    if (error) {\n      // PalmOS before 3.5 will continuously relaunch this app unless we switch to\n      // another safe one.\n      if (error != dmErrCorruptDatabase) {\n        FrmCustomAlert(ALERT_debug, \"Please reports this bug! Give your Palm device and PalmOS version, this BadBug(TM) should not happen.\", \"\", \"\");\n      }\n      StopApplication();\n      AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);\n      return error;\n    }\n\n    ExamSetGoto(*(UInt32 *)cmdPBP);\n    FrmGotoForm(FORM_exams);\n\n    AppEventLoop ();\n    StopApplication ();\n\n\n  /***\n  * TIME CHANGE\n  ****/\n  // Launch code sent when the system time is changed.\n  } else if (cmd == sysAppLaunchCmdTimeChange) {\n    // reset the trigger for the next alarm to fire\n    if (launchFlags & sysAppLaunchFlagSubCall) {\n      AlarmReset(DatabaseGetRefN(DB_MAIN));\n      // Remove any \"future\" alarms from the attention manager queue\n      // (ie alarms that will trigger after the new time setting)\n      //AlarmUpdatePosted(DeviceTimeChanged);\n    } else {\n      // Another app was running when we were called\n      DmOpenRef cats = DmOpenDatabaseByTypeCreator(DATABASE_TYPE, APP_CREATOR, dmModeReadWrite);\n      if (cats != 0) {\n        AlarmReset(cats);\n        //AlarmUpdatePosted(DeviceTimeChanged);\n        DmCloseDatabase(cats);\n      }\n    }\n    \n  \n  /***\n  * RESET\n  ****/\n  // This action code is sent after the system is reset.\n  } else if (cmd == sysAppLaunchCmdSystemReset) {\n    if (! ((SysAppLaunchCmdSystemResetType*)cmdPBP)->hardReset) {\n      if (launchFlags & sysAppLaunchFlagSubCall) {\n        AlarmReset(DatabaseGetRefN(DB_MAIN));\n      } else {\n        // Another app was running when we were called\n        DmOpenRef cats = DmOpenDatabaseByTypeCreator(DATABASE_TYPE, APP_CREATOR, dmModeReadWrite);\n        if (cats != 0) {\n          AlarmReset(cats);\n          DmCloseDatabase(cats);\n        }\n      }\n    }\n\n  }\n\n  return 0;\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * FUNCTION:    GetObjectPtr\n * DESCRIPTION: This routine returns a pointer to an object in the current\n *              form.\n * PARAMETERS:  formId - id of the form to display\n ***********************************************************************/\n", "func_signal": "void *\nGetObjectPtr(UInt16 objectID)", "code": "{\n  FormPtr frmP = FrmGetActiveForm();\n  return (FrmGetObjectPtr(frmP, FrmGetObjectIndex(frmP, objectID)));\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Functions for editing SETTINGS\n*****************************************************************************/\n", "func_signal": "static void\nSettingsFormInit(FormType *frm)", "code": "{\n  ControlType *ctl;\n  \n  ctl = GetObjectPtr(CHECKBOX_sets_saturday);\n  CtlSetValue(ctl, (gPrefs.numDays != GADGET_DEFAULT_NUMDAYS));\n\n  ctl = GetObjectPtr(CHECKBOX_sets_showtype);\n  CtlSetValue(ctl, gPrefs.showTypes);\n\n  ctl = GetObjectPtr(CHECKBOX_sets_showshort);\n  CtlSetValue(ctl, gPrefs.showShortNames);\n\n  ctl = GetObjectPtr(CHECKBOX_sets_showtime);\n  CtlSetValue(ctl, gPrefs.showTimeline);\n\n}", "path": "prefs.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetDrawTimeline\n*\n* Description: Draws a line for the current time\n*****************************************************************************/\n", "func_signal": "void\nGadgetDrawTimeline(GadgetTimelineDrawType drawType)", "code": "{\n  DateTimeType dt;\n  TimeType now;\n\n  TimSecondsToDateTime(TimGetSeconds(), &dt);\n\n  if (drawType == gtDraw) {\n    now.hours=dt.hour;\n    now.minutes=dt.minute;\n    gGadgetLastTimeline.hours=now.hours;\n    gGadgetLastTimeline.minutes=now.minutes;\n    GadgetDrawWeekdays();\n  } else {\n    now.hours=gGadgetLastTimeline.hours;\n    now.minutes=gGadgetLastTimeline.minutes;\n  }\n\n  if ( ((gGadgetCurScreen == GADGET_SCREEN_DAY) && (now.hours >= 8) && (now.hours < 20)) ||\n       ((gGadgetCurScreen == GADGET_SCREEN_NIGHT) && ((now.hours < 8) || (now.hours >= 20))) ) {\n\n    UInt8 y, gadgetWidth;\n    UInt16 gadgetIndex;\n    FormType *frm;\n    RectangleType bounds;\n    RGBColorType red={0x00, 0xFF, 0x00, 0x00}, old;\n\n    y = GadgetCalcTimeTop(now);\n\n    frm = FrmGetActiveForm();\n    gadgetIndex = FrmGetObjectIndex(frm, gGadgetID);\n    FrmGetObjectBounds(frm, gadgetIndex, &bounds);\n    gadgetWidth=gGadgetDaysNum * gGadgetDaysWidth + gGadgetDaysNum - 1;\n\n    WinInvertLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT, bounds.topLeft.y+GADGET_TOP+y,\n                  bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gadgetWidth-1, bounds.topLeft.y+GADGET_TOP+y);\n\n    if (drawType == gtDraw) {\n      TNSetForeColorRGB(&red, &old);\n      WinDrawPixel(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+1, bounds.topLeft.y+GADGET_TOP+y);\n      WinDrawLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+2, bounds.topLeft.y+GADGET_TOP+y-1,\n                  bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+2, bounds.topLeft.y+GADGET_TOP+y+1);\n      WinDrawLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+3, bounds.topLeft.y+GADGET_TOP+y-2,\n                  bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+3, bounds.topLeft.y+GADGET_TOP+y+2);\n      TNSetForeColorRGB(&old, NULL);\n    } else if (drawType == gtErase) {\n      RectangleType rect;\n      RctSetRectangle(&rect,\n                      bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+1, bounds.topLeft.y+GADGET_TOP+y-2,\n                      bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gGadgetDaysNum*gGadgetDaysWidth+gGadgetDaysNum+3, bounds.topLeft.y+GADGET_TOP+y+2);\n      WinEraseRectangle(&rect, 0);\n    }\n  }\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * main event loop; loops until appStopEvent is caught or\n * QuitApp is set\n ***********************************************************************/\n", "func_signal": "static void\nAppEventLoop(void)", "code": "{\n  UInt16 error;\n  EventType event;\n\n\n  do {\n    EvtGetEvent(&event, evtWaitForever);\n\n\n    if (! SysHandleEvent(&event))\n      if (! MenuHandleEvent(0, &event, &error))\n\tif (! AppHandleEvent(&event))\n\t  FrmDispatchEvent(&event);\n\n    // Check the heaps after each event\n#if EMULATION_LEVEL != EMULATION_NONE\n    MemHeapCheck(0);\n    MemHeapCheck(1);\n#endif\n  } while (event.eType != appStopEvent);\n\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetHintTap\n*\n* Description: Handles penDown events (taps) on the hint gadget\n*****************************************************************************/\n", "func_signal": "void\nGadgetHintTap(FormGadgetType *pGadget, EventType *event)", "code": "{\n  //you may find it useful to track if they\n  //lift the pen still within the boundaries of the gadget\n  Boolean isPenDown = true;\n  Int16 newPointX, newPointY, startPointX, startPointY;\n  UInt16 index;\n  RectangleType bounds, rect;\n  Char noteSymb[2] = { GADGET_NOTESYMBOL, 0 };\n  FontID oldFont;\n  Boolean drawn=false;\n  IndexedColorType curForeColor, curBackColor, curTextColor;\n\n  // This is just needed since we do not want to access internal structure\n  // data directly in FormGadgetType (need rect field below)\n  index = TNGetObjectIndexFromPtr(FrmGetActiveForm(), pGadget);\n  FrmGetObjectBounds(FrmGetActiveForm(), index, &bounds);\n\n  oldFont = FntSetFont(symbolFont);\n  RctSetRectangle(&rect,\n                  bounds.topLeft.x+1,  // +1 for border\n                  bounds.topLeft.y+1, // Put VALUE BELOW here.... +top+1 removed because of own Gadget\n                  bounds.extent.x-3, bounds.extent.y - 3); // -4 for bottom border\n  RctSetRectangle(&rect, rect.topLeft.x+rect.extent.x-8,\n                         rect.topLeft.y+rect.extent.y-12,\n                         FntLineWidth(noteSymb, 1), FntLineHeight());\n\n\n  //track the pen down event\n  EvtGetPen(&newPointX, &newPointY, &isPenDown);\n  startPointX = newPointX;\n  startPointY = newPointY;\n  while (isPenDown){\n    EvtGetPen(&newPointX, &newPointY, &isPenDown);\n\n    if (gHintNote) {\n      if (! drawn && RctPtInRectangle(newPointX, newPointY, &rect)) {\n        curForeColor = WinSetForeColor(UIColorGetTableEntryIndex(UIObjectSelectedForeground));\n        curBackColor = WinSetBackColor(UIColorGetTableEntryIndex(UIObjectSelectedFill));\n        curTextColor = WinSetTextColor(UIColorGetTableEntryIndex(UIObjectSelectedForeground));\n        TNDrawCharsToFitWidth(noteSymb, &rect);\n        WinSetForeColor(curForeColor);\n        WinSetForeColor(curBackColor);\n        WinSetForeColor(curTextColor);\n        drawn = true;\n      } else if (drawn && ! RctPtInRectangle(newPointX, newPointY, &rect)) {\n        curForeColor = WinSetForeColor(UIColorGetTableEntryIndex(UIObjectForeground));\n        curBackColor = WinSetBackColor(UIColorGetTableEntryIndex(UIObjectFill));\n        curTextColor = WinSetTextColor(UIColorGetTableEntryIndex(UIObjectForeground));\n        TNDrawCharsToFitWidth(noteSymb, &rect);\n        WinSetForeColor(curForeColor);\n        WinSetForeColor(curBackColor);\n        WinSetForeColor(curTextColor);\n        drawn = false;\n      }\n    }\n\n  }\n\n  FntSetFont(oldFont);\n\n  if (gHintNote && RctPtInRectangle(newPointX, newPointY, &rect)) {\n    NoteSet(GadgetGetHintTimeIndex(), FORM_main);\n    FrmPopupForm(NewNoteView);\n  } // else outside gadget bounds -> do nothing\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * handling for form and control actions\n * menu actions are forwarded to MainFormDoCommand\n ***********************************************************************/\n", "func_signal": "static Boolean\nMainFormHandleEvent (EventPtr event)", "code": "{\n  FormType *frm;\n  Boolean handled = false;\n  Boolean categoryEdited, reDraw=false;\n  UInt16 category, numRecords;\n  ControlType *ctl;\n  UInt32 *recordList;\n\n  \n  if (event->eType == ctlSelectEvent) {\n    // button handling\n    handled = true;\n    switch (event->data.ctlSelect.controlID) {\n      // the ok button - this leaves the application\n\n      case LIST_cat_trigger:\n        frm = FrmGetActiveForm();\n        category=DatabaseGetCat();\n        numRecords=DmNumRecordsInCategory(DatabaseGetRef(), DELETE_CATEGORY);\n        recordList=(UInt32 *)MemPtrNew(numRecords * sizeof(UInt32));\n        CatPreEdit(numRecords, recordList);\n        categoryEdited = CategorySelect(DatabaseGetRef(), frm,\n                                        LIST_cat_trigger, LIST_cat, false,\n                                        &category, gCategoryName, 0,\n                                        STRING_cat_edit); // categoryDefaultEditCategoryString\n        if (categoryEdited || (category != DatabaseGetCat())) {\n          reDraw=true;\n          DatabaseSetCat(category);\n          ctl = GetObjectPtr(LIST_cat_trigger);\n          CategoryGetName(DatabaseGetRef(), DatabaseGetCat(), gCategoryName); \n          CategorySetTriggerLabel(ctl, gCategoryName); \n        }\n        CatPostEdit(numRecords, recordList);\n        if (reDraw)  {\n          GadgetSetNeedsCompleteRedraw(true);\n          FrmDrawForm(frm);\n        }\n        if (recordList != NULL)    MemPtrFree((MemPtr)recordList);\n        break;\n\n      case BUTTON_beam:\n        BeamCourse(GadgetGetHintCourseIndex());\n        break;\n\n      case BUTTON_edit:\n        gMenuCurrentForm=FORM_main;\n        EditTime();\n        break;\n\n      case BUTTON_next:\n        GadgetDrawHintNext();\n        break;\n\n      default:\n        break;\n      }\n    } else if (event->eType == keyDownEvent) {\n      // We have a hard button assigned and it was pressed\n      if (TxtCharIsHardKey(event->data.keyDown.modifiers, event->data.keyDown.chr)) {\n        if (! (event->data.keyDown.modifiers & poweredOnKeyMask)) {\n          GadgetDrawHintNext();\n          handled = true;\n        }\n      } else if (EvtKeydownIsVirtual(event)) {\n        // Up or down keys pressed\n        switch (event->data.keyDown.chr) {\n          case vchrPageUp:\n            if (event->data.keyDown.modifiers & autoRepeatKeyMask) {\n              if (! gMainRepeat) {\n                GadgetSwitchScreen();\n                gMainRepeat = true;\n              }\n            } else {\n              GadgetDrawStep(winUp);\n              gMainRepeat = false;\n            }\n            handled=true;\n            break;\n\n          case vchrPageDown:\n            if (event->data.keyDown.modifiers & autoRepeatKeyMask) {\n              if (! gMainRepeat) {\n                GadgetSwitchScreen();\n                gMainRepeat = true;\n              }\n            } else {\n              GadgetDrawStep(winDown);\n              gMainRepeat = false;\n            }\n            handled=true;\n            break;\n\n          case vchrSendData:\n            BeamCourse(GadgetGetHintCourseIndex());\n            handled=true;\n            break;\n\n          default:\n            break;\n        }\n      }\n    } else if (event->eType == menuEvent) {\n      // forwarding of menu events\n      return HandleMenuEvent(event->data.menu.itemID);\n    } else if (event->eType == menuOpenEvent) {\n      return HandleMenuOpenEvent(event);\n    } else if (event->eType == frmUpdateEvent) {\n      // redraws the form if needed\n      frm = FrmGetActiveForm();\n      FrmDrawForm(frm);\n      // GadgetDrawHintNext();\n      handled = true;\n    } else if (event->eType == frmOpenEvent) {\n      ControlType *ctl;\n      LocalID dbID;\n      UInt16 cardNo;\n      Boolean newKeyP4=false;\n      UInt16 newKeyP2=0xFFFF;\n\n      // initializes and draws the form at program launch\n      frm = FrmGetActiveForm();\n\n      GadgetSet(frm, GADGET_main, GADGET_hint);\n      FrmSetGadgetHandler(frm, FrmGetObjectIndex(frm, GADGET_main), GadgetHandler);\n      FrmSetGadgetHandler(frm, FrmGetObjectIndex(frm, GADGET_hint), GadgetHintHandler);\n\n      FrmDrawForm(frm);\n      GadgetDrawHintNext();\n\n      ctl = GetObjectPtr(LIST_cat_trigger);\n      CategoryGetName (DatabaseGetRef(), DatabaseGetCat(), gCategoryName); \n      CategorySetTriggerLabel (ctl, gCategoryName); \n\n      DmOpenDatabaseInfo(DatabaseGetRefN(DB_MAIN), &dbID, NULL, NULL, &cardNo, NULL);\n      SysNotifyRegister(cardNo, dbID, sysNotifyLateWakeupEvent, HandleNotification, sysNotifyNormalPriority, NULL);\n\n    \tKeyRates(false,&gKeyP1, &gKeyP2, &gKeyP3, &gKeyP4);\n\t    KeyRates(true, &gKeyP1, &newKeyP2, &gKeyP3, &newKeyP4);\n\n      handled = true;\n    } else if (event->eType == frmCloseEvent) {\n      // this is done if program is closed\n      LocalID dbID;\n      UInt16 cardNo;\n      DmOpenDatabaseInfo(DatabaseGetRefN(DB_MAIN), &dbID, NULL, NULL, &cardNo, NULL);\n      SysNotifyUnregister(cardNo, dbID, sysNotifyLateWakeupEvent, sysNotifyNormalPriority);\n      // Restore original key rates\n\t    KeyRates(true, &gKeyP1, &gKeyP2, &gKeyP3, &gKeyP4);\n    }\n\n  return (handled);\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetSet\n*\n* Description: Must be called before draw to set the form the gadget is in\n*              and the IDs of the Gadget and the hint gadget\n*****************************************************************************/\n", "func_signal": "void\nGadgetSet(FormPtr frm, UInt16 gadgetID, UInt16 hintGadgetID)", "code": "{\n  gForm=frm;\n  gGadgetID=gadgetID;\n  gHintGadgetID=hintGadgetID;\n  gGadgetDaysNum=gPrefs.numDays;\n  gGadgetDaysWidth=GADGET_TOTAL_DRAWWIDTH / gGadgetDaysNum;\n  gCourseIndex=0;\n  gTimeIndex=0;\n  gTimeDrawnIndex=0;\n  gHintDrawn=false;\n  gGadgetCompleteRedraw=true;\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: GadgetDraw\n*\n* Description: Draws the basic gadget (grid, days, times)\n*****************************************************************************/\n", "func_signal": "void\nGadgetDraw(Boolean eraseFirst)", "code": "{\n  RectangleType bounds;\n  UInt8 i, gadgetWidth;\n  RGBColorType color, prevColor;\n  UInt16 gadgetIndex;\n  RectangleType rect;\n  FormType *frm=gForm;\n\n  // Check if GadgetSet has already been called. If not => die\n  if (! frm) return;\n\n  gadgetIndex = FrmGetObjectIndex(frm, gGadgetID);\n  FrmGetObjectBounds(frm, gadgetIndex, &bounds);\n\n  // Erase background\n  if (eraseFirst)  WinEraseRectangle(&bounds, 0);\n\n  // Write Times\n  if (gGadgetCurScreen == GADGET_SCREEN_DAY) {\n    for (i=0; i < 7; i++) { // 7 because we have to write 7 times 08:00, 10:00,..., 20:00\n      Char time[timeStringLength];\n      if (i < 1)  StrPrintF(time, \"0%u:00\", 8+i*2);\n      else  StrPrintF(time, \"%u:00\", 8+i*2);\n      WinDrawChars(time, StrLen(time), bounds.topLeft.x+GADGET_BASELEFT,\n                   (i != 7 - 1) ? bounds.topLeft.y+GADGET_STRINGS_TOP+i*GADGET_STRINGS_OFFSET\n                   /* ^last^ */ : bounds.topLeft.y+GADGET_STRINGS_TOP+i*GADGET_STRINGS_OFFSET-2);\n    }\n  } else {\n    for (i=0; i < 2; i++) {\n      Char time[timeStringLength];\n      StrPrintF(time, \"%u:00\", 20+i*2);\n      WinDrawChars(time, StrLen(time), bounds.topLeft.x+GADGET_BASELEFT,\n                   bounds.topLeft.y+GADGET_STRINGS_TOP+i*GADGET_STRINGS_OFFSET);\n    }\n    for (i=2; i < 7; i++) {\n      Char time[timeStringLength];\n      StrPrintF(time, \"0%u:00\", (i-2)*2);\n      WinDrawChars(time, StrLen(time), bounds.topLeft.x+GADGET_BASELEFT,\n                   (i != 7 - 1) ? bounds.topLeft.y+GADGET_STRINGS_TOP+i*GADGET_STRINGS_OFFSET\n                   /* ^last^ */ : bounds.topLeft.y+GADGET_STRINGS_TOP+i*GADGET_STRINGS_OFFSET-2);\n    }\n  }\n\n  // Write Weekdays\n  GadgetDrawWeekdays();\n\n  // Draw Grid: Color is light gray on colored palms, dark gray on gray palms\n  if (TNisColored()) {\n    color.r = 0x77;  color.g = 0x77;  color.b = 0x77;\n  } else {\n    color.r = 0x44;  color.g = 0x44;  color.b = 0x44;\n  }\n\n  TNSetForeColorRGB(&color, &prevColor);\n\n  gadgetWidth=gGadgetDaysNum * gGadgetDaysWidth + gGadgetDaysNum - 1;\n  RctSetRectangle(&rect, bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT, bounds.topLeft.y+GADGET_TOP, gadgetWidth, GADGET_HEIGHT);\n  WinDrawRectangleFrame(simpleFrame, &rect);\n  for(i=1; i <= 5; ++i) { // Draw the 5 gray dashed lines\n    if ( (gGadgetCurScreen == GADGET_SCREEN_NIGHT) && (i == 2)) {\n      WinDrawLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT, bounds.topLeft.y+GADGET_TOP+i*GADGET_STRINGS_OFFSET,\n                  bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gadgetWidth-1, bounds.topLeft.y+GADGET_TOP+i*GADGET_STRINGS_OFFSET);\n    } else {\n      WinDrawGrayLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT, bounds.topLeft.y+GADGET_TOP+i*GADGET_STRINGS_OFFSET,\n                      bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+gadgetWidth-1, bounds.topLeft.y+GADGET_TOP+i*GADGET_STRINGS_OFFSET);\n    }\n  }\n  for(i=1; i <= gGadgetDaysNum -1; ++i) {\n    WinDrawLine(bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+i*gGadgetDaysWidth+(i-1), bounds.topLeft.y+GADGET_TOP,\n                bounds.topLeft.x+GADGET_BASELEFT+GADGET_LEFT+i*gGadgetDaysWidth+(i-1), bounds.topLeft.y+GADGET_TOP+GADGET_HEIGHT-1);\n  }\n\n  TNSetForeColorRGB(&prevColor, NULL);\n}", "path": "gadget.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*****************************************************************************\n* Function: DrawCourses\n*\n* Description: local function to fill the course list\n*****************************************************************************/\n", "func_signal": "static void\nDrawCourses(ListType *lst)", "code": "{\n  MemHandle mWebsite, mEmail, old;\n  Char *buffer;\n  FieldType *fldWebsite, *fldEmail;\n  \n  gNumCourses=CountCourses();\n  gCourseList = (Char **) MemPtrNew(gNumCourses * sizeof(Char *));\n  gCourseInd = (UInt16 *) MemPtrNew(gNumCourses * sizeof(UInt16));\n\n  CourseListGen(gCourseList, NULL, gCourseInd, gNumCourses, 0, CLIST_SEARCH_INDEX);\n  LstSetListChoices(lst, gCourseList, gNumCourses);\n  LstSetSelection(lst, -1);\n\n  \n  fldWebsite = GetObjectPtr(FIELD_cl_website);\n  fldEmail = GetObjectPtr(FIELD_cl_email);\n  \n  mWebsite = MemHandleNew(4);\n  buffer = MemHandleLock(mWebsite);\n  MemSet(buffer, 4, 0);\n  StrCopy(buffer, \"-?-\");\n  MemHandleUnlock(mWebsite);\n\n  old = FldGetTextHandle(fldWebsite);\n  FldSetTextHandle(fldWebsite, mWebsite);\n  if (old != NULL)  MemHandleFree(old); \n\n  mEmail = MemHandleNew(4);\n  buffer = MemHandleLock(mEmail);\n  MemSet(buffer, 4, 0);\n  StrCopy(buffer, \"-?-\");\n  MemHandleUnlock(mEmail);\n\n  old = FldGetTextHandle(fldEmail);\n  FldSetTextHandle(fldEmail, mEmail);\n  if (old != NULL)  MemHandleFree(old); \n\n  \n}", "path": "clist.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/***********************************************************************\n * function is called at program start\n * you can put your own initialization jobs there\n ***********************************************************************/\n", "func_signal": "static UInt16\nStartApplication(void)", "code": "{\n  Err err = 0;\n\n  // Initialize the random number seed;\n  SysRandom( TimGetSeconds() );\n\n  // Load prefs\n  PrefLoadPrefs(&gPrefs);\n\n  // Initialize TNglue\n  err = TNGlueColorInit();\n\n  // Initialize Cache\n  CacheInit();\n\n  // Open Database\n  if (err == errNone)  err = OpenDatabase();\n  if (err == errNone)  DatabaseSetCat(gPrefs.curCat);\n\n  // Set Alarms\n  if (err == errNone)  AlarmReset(DatabaseGetRefN(DB_MAIN));\n\n\n  return (err);\n}", "path": "UniMatrix.c", "repo_name": "timn/palm-unimatrix", "stars": 2, "license": "None", "language": "c", "size": 432}
{"docstring": "/*\n * Initialize server\n */\n", "func_signal": "int32_t\nserver_init(bthid_server_p srv)", "code": "{\n\tstruct sockaddr_l2cap\tl2addr;\n\n\tassert(srv != NULL);\n\n\tsrv->ctrl = srv->intr = -1;\n\tFD_ZERO(&srv->rfdset);\n\tFD_ZERO(&srv->wfdset);\n\tLIST_INIT(&srv->sessions);\n\n\t/* Open /dev/consolectl */\n\tsrv->cons = open(\"/dev/consolectl\", O_RDWR);\n\tif (srv->cons < 0) {\n\t\tsyslog(LOG_ERR, \"Could not open /dev/consolectl. %s (%d)\",\n\t\t\tstrerror(errno), errno);\n\t\treturn (-1);\n\t}\n\n\t/* Create control socket */\n\tsrv->ctrl = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BLUETOOTH_PROTO_L2CAP);\n\tif (srv->ctrl < 0) {\n\t\tsyslog(LOG_ERR, \"Could not create control L2CAP socket. \" \\\n\t\t\t\"%s (%d)\", strerror(errno), errno);\n\t\tclose(srv->cons);\n\t\treturn (-1);\n\t}\n\n\tl2addr.l2cap_len = sizeof(l2addr);\n\tl2addr.l2cap_family = AF_BLUETOOTH;\n\tmemcpy(&l2addr.l2cap_bdaddr, &srv->bdaddr, sizeof(l2addr.l2cap_bdaddr));\n\tl2addr.l2cap_psm = htole16(0x11);\n\n\tif (bind(srv->ctrl, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n            syslog(LOG_ERR, \"Could not bind control L2CAP socket. \"     \\\n                   \"%s (%d)\", strerror(errno), errno);\n            close(srv->ctrl);\n            close(srv->cons);\n            return (-1);\n\t}\n\n\tif (listen(srv->ctrl, 10) < 0) {\n\t\tsyslog(LOG_ERR, \"Could not listen on control L2CAP socket. \" \\\n\t\t\t\"%s (%d)\", strerror(errno), errno);\n\t\tclose(srv->ctrl);\n\t\tclose(srv->cons);\n\t\treturn (-1);\n\t}\n\n\t/* Create intrrupt socket */\n\tsrv->intr = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BLUETOOTH_PROTO_L2CAP);\n\tif (srv->intr < 0) {\n\t\tsyslog(LOG_ERR, \"Could not create interrupt L2CAP socket. \" \\\n\t\t\t\"%s (%d)\", strerror(errno), errno);\n\t\tclose(srv->ctrl);\n\t\tclose(srv->cons);\n\t\treturn (-1);\n\t}\n\n\tl2addr.l2cap_psm = htole16(0x13);\n\n\tif (bind(srv->intr, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n\t\tsyslog(LOG_ERR, \"Could not bind interrupt L2CAP socket. \" \\\n\t\t\t\"%s (%d)\", strerror(errno), errno);\n\t\tclose(srv->intr);\n\t\tclose(srv->ctrl);\n\t\tclose(srv->cons);\n\t\treturn (-1);\n\t}\n\n\tif (listen(srv->intr, 10) < 0) {\n\t\tsyslog(LOG_ERR, \"Could not listen on interrupt L2CAP socket. \"\\\n\t\t\t\"%s (%d)\", strerror(errno), errno);\n\t\tclose(srv->intr);\n\t\tclose(srv->ctrl);\n\t\tclose(srv->cons);\n\t\treturn (-1);\n\t}\n\n\tFD_SET(srv->ctrl, &srv->rfdset);\n\tFD_SET(srv->intr, &srv->rfdset);\n\tsrv->maxfd = max(srv->ctrl, srv->intr);\n\n\treturn (0);\n}", "path": "server.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Write hids file */\n", "func_signal": "int32_t\nwrite_hids_file(void)", "code": "{\n\tchar\t\t path[PATH_MAX];\n\tFILE\t\t*f;\n\thid_device_t\t*d;\n\n\tif (hids_file == NULL) {\n\t\tSYSLOG(LOGERR, \"Unknown HIDs file name!\" EOL);\n\t\treturn (-1);\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s.new\", hids_file);\n\n\tif ((f = fopen(path, \"w\")) == NULL) {\n\t\tSYSLOG(LOGERR, \"Could not open HIDs file '%s'. %s (%d)\" EOL,\n\t\t\tpath, strerror(errno), errno);\n\t\treturn (-1);\n\t}\n\n\tLIST_FOREACH(d, &hid_devices, next)\n\t\tif (!d->new_device)\n\t\t\tfprintf(f, \"%s\\n\", bt_ntoa(&d->bdaddr, NULL));\n\n\tfclose(f);\n\n\tif (rename(path, hids_file) < 0) {\n\t\tSYSLOG(LOGERR, \"Could not rename new HIDs file '%s' to '%s'. \" \\\n\t\t\t\"%s (%d)\" EOL, path, hids_file, strerror(errno), errno);\n\t\tunlink(path);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Lookup session by bdaddr\n */\n", "func_signal": "bthid_session_p\nsession_by_bdaddr(bthid_server_p srv, bdaddr_p bdaddr)", "code": "{\n\tbthid_session_p\ts;\n\n\tassert(srv != NULL);\n\tassert(bdaddr != NULL);\n\n\tLIST_FOREACH(s, &srv->sessions, next)\n\t\tif (memcmp(&s->bdaddr, bdaddr, sizeof(s->bdaddr)) == 0)\n\t\t\tbreak;\n\n\treturn (s);\n}", "path": "session.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Check config entry */\n", "func_signal": "static int32_t\ncheck_hid_device(hid_device_p d)", "code": "{\n\thid_data_t\thd;\n\thid_item_t\thi;\n\tint32_t\t\tpage;\n\n\tif (get_hid_device(&d->bdaddr) != NULL) {\n\t\tSYSLOG(LOGERR, \"Ignoring duplicated entry for bdaddr %s\" EOL,\n\t\t\t\tbt_ntoa(&d->bdaddr, NULL));\n\t\treturn (0);\n\t}\n\n\tif (d->control_psm == 0) {\n\t\tSYSLOG(LOGERR, \"Ignoring entry with invalid control PSM\" EOL);\n\t\treturn (0);\n\t}\n\n\tif (d->interrupt_psm == 0) {\n\t\tSYSLOG(LOGERR, \"Ignoring entry with invalid interrupt PSM\" EOL);\n\t\treturn (0);\n\t}\n\n\tif (d->desc == NULL) {\n\t\tSYSLOG(LOGERR, \"Ignoring entry without HID descriptor\" EOL);\n\t\treturn (0);\n\t}\n\n\t/* XXX somehow need to make sure descriptor is valid */\n\tfor (hd = hid_start_parse(d->desc, ~0, -1); hid_get_item(hd, &hi) > 0; ) {\n\t\tswitch (hi.kind) {\n\t\tcase hid_collection:\n\t\tcase hid_endcollection:\n\t\tcase hid_output:\n\t\tcase hid_feature:\n\t\t\tbreak;\n\n\t\tcase hid_input:\n\t\t\t/* Check if the device may send keystrokes */\n\t\t\tpage = HID_PAGE(hi.usage);\n\t\t\tif (page == HUP_KEYBOARD)\n\t\t\t\td->keyboard = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\thid_end_parse(hd);\n\n\treturn (1);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Re-read hids file */\n", "func_signal": "int32_t\nread_hids_file(void)", "code": "{\n\tFILE\t\t*f;\n\thid_device_t\t*d;\n\tchar\t\t*line;\n\tbdaddr_t\t bdaddr;\n\tint32_t\t\t lineno;\n\n\tif (hids_file == NULL) {\n\t\tSYSLOG(LOGERR, \"Unknown HIDs file name!\" EOL);\n\t\treturn (-1);\n\t}\n\n\tif ((f = fopen(hids_file, \"r\")) == NULL) {\n\t\tif (errno == ENOENT)\n\t\t\treturn (0);\n\n\t\tSYSLOG(LOGERR, \"Could not open HIDs file '%s'. %s (%d)\" EOL,\n\t\t\thids_file, strerror(errno), errno);\n\t\treturn (-1);\n\t}\n\n\tfor (lineno = 1; fgets(buffer, sizeof(buffer), f) != NULL; lineno ++) {\n\t\tif ((line = strtok(buffer, \"\\r\\n\\t \")) == NULL)\n\t\t\tcontinue; /* ignore empty lines */\n\n\t\tif (!bt_aton(line, &bdaddr)) {\n\t\t\tSYSLOG(LOGWARNING, \"Ignoring unparseable BD_ADDR in \" \\\n\t\t\t\t\"%s:%d\" EOL, hids_file, lineno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((d = get_hid_device(&bdaddr)) != NULL)\n\t\t\td->new_device = 0;\n\t}\n\n\tfclose(f);\n\n\treturn (0);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Free config entry */\n", "func_signal": "static void\nfree_hid_device(hid_device_p d)", "code": "{\n\tif (d->desc != NULL)\n\t\thid_dispose_report_desc(d->desc);\n\n\tmemset(d, 0, sizeof(*d));\n\tfree(d);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Process keys\n */\n", "func_signal": "int32_t\nkbd_process_keys(bthid_session_p s)", "code": "{\n\tbitstr_t\tdiff[bitstr_size(xsize)];\n\tint32_t\t\tf1, f2, i;\n\n\tassert(s != NULL);\n\tassert(s->srv != NULL);\n\n\t/* Check if the new keys have been pressed */\n\tbit_ffs(s->keys1, xsize, &f1);\n\n\t/* Check if old keys still pressed */\n\tbit_ffs(s->keys2, xsize, &f2);\n\n\tif (f1 == -1) {\n\t\t/* no new key pressed */\n\t\tif (f2 != -1) {\n\t\t\t/* release old keys */\n\t\t\tkbd_write(s->keys2, f2, 0, s->vkbd);\n\t\t\tmemset(s->keys2, 0, bitstr_size(xsize));\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\tif (f2 == -1) {\n\t\t/* no old keys, but new keys pressed */\n\t\tassert(f1 != -1);\n\t\t\n\t\tmemcpy(s->keys2, s->keys1, bitstr_size(xsize));\n\t\tkbd_write(s->keys1, f1, 1, s->vkbd);\n\t\tmemset(s->keys1, 0, bitstr_size(xsize));\n\n\t\treturn (0);\n\t}\n\n\t/* new keys got pressed, old keys got released */\n\tmemset(diff, 0, bitstr_size(xsize));\n\n\tfor (i = f2; i < xsize; i ++) {\n\t\tif (bit_test(s->keys2, i)) {\n\t\t\tif (!bit_test(s->keys1, i)) {\n\t\t\t\tbit_clear(s->keys2, i);\n\t\t\t\tbit_set(diff, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = f1; i < xsize; i++) {\n\t\tif (bit_test(s->keys1, i)) {\n\t\t\tif (!bit_test(s->keys2, i))\n\t\t\t\tbit_set(s->keys2, i);\n\t\t\telse\n\t\t\t\tbit_clear(s->keys1, i);\n\t\t}\n\t}\n\n\tbit_ffs(diff, xsize, &f2);\n\tif (f2 > 0)\n\t\tkbd_write(diff, f2, 0, s->vkbd);\n\n\tbit_ffs(s->keys1, xsize, &f1);\n\tif (f1 > 0) {\n\t\tkbd_write(s->keys1, f1, 1, s->vkbd);\n\t\tmemset(s->keys1, 0, bitstr_size(xsize));\n\t}\n\n\treturn (0);\n}", "path": "kbd.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* ! YYPARSE_PARAM */\n", "func_signal": "int\nyyparse (YYPARSE_PARAM_ARG)\n    YYPARSE_PARAM_DECL", "code": "{\n    int yym, yyn, yystate;\n#if YYDEBUG\n    const char *yys;\n\n    if ((yys = getenv(\"YYDEBUG\")))\n    {\n        yyn = *yys;\n        if (yyn >= '0' && yyn <= '9')\n            yydebug = yyn - '0';\n    }\n#endif\n\n    yynerrs = 0;\n    yyerrflag = 0;\n    yychar = (-1);\n\n    if (yyss == NULL && yygrowstack()) goto yyoverflow;\n    yyssp = yyss;\n    yyvsp = yyvs;\n    *yyssp = yystate = 0;\n\nyyloop:\n    if ((yyn = yydefred[yystate])) goto yyreduce;\n    if (yychar < 0)\n    {\n        if ((yychar = yylex()) < 0) yychar = 0;\n#if YYDEBUG\n        if (yydebug)\n        {\n            yys = 0;\n            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];\n            if (!yys) yys = \"illegal-symbol\";\n            printf(\"%sdebug: state %d, reading %d (%s)\\n\",\n                    YYPREFIX, yystate, yychar, yys);\n        }\n#endif\n    }\n    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&\n            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)\n    {\n#if YYDEBUG\n        if (yydebug)\n            printf(\"%sdebug: state %d, shifting to state %d\\n\",\n                    YYPREFIX, yystate, yytable[yyn]);\n#endif\n        if (yyssp >= yysslim && yygrowstack())\n        {\n            goto yyoverflow;\n        }\n        *++yyssp = yystate = yytable[yyn];\n        *++yyvsp = yylval;\n        yychar = (-1);\n        if (yyerrflag > 0)  --yyerrflag;\n        goto yyloop;\n    }\n    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&\n            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)\n    {\n        yyn = yytable[yyn];\n        goto yyreduce;\n    }\n    if (yyerrflag) goto yyinrecovery;\n#if defined(lint) || defined(__GNUC__)\n    goto yynewerror;\n#endif\nyynewerror:\n    yyerror(\"syntax error\");\n#if defined(lint) || defined(__GNUC__)\n    goto yyerrlab;\n#endif\nyyerrlab:\n    ++yynerrs;\nyyinrecovery:\n    if (yyerrflag < 3)\n    {\n        yyerrflag = 3;\n        for (;;)\n        {\n            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&\n                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)\n            {\n#if YYDEBUG\n                if (yydebug)\n                    printf(\"%sdebug: state %d, error recovery shifting\\\n to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);\n#endif\n                if (yyssp >= yysslim && yygrowstack())\n                {\n                    goto yyoverflow;\n                }\n                *++yyssp = yystate = yytable[yyn];\n                *++yyvsp = yylval;\n                goto yyloop;\n            }\n            else\n            {\n#if YYDEBUG\n                if (yydebug)\n                    printf(\"%sdebug: error recovery discarding state %d\\n\",\n                            YYPREFIX, *yyssp);\n#endif\n                if (yyssp <= yyss) goto yyabort;\n                --yyssp;\n                --yyvsp;\n            }\n        }\n    }\n    else\n    {\n        if (yychar == 0) goto yyabort;\n#if YYDEBUG\n        if (yydebug)\n        {\n            yys = 0;\n            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];\n            if (!yys) yys = \"illegal-symbol\";\n            printf(\"%sdebug: state %d, error recovery discards token %d (%s)\\n\",\n                    YYPREFIX, yystate, yychar, yys);\n        }\n#endif\n        yychar = (-1);\n        goto yyloop;\n    }\nyyreduce:\n#if YYDEBUG\n    if (yydebug)\n        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",\n                YYPREFIX, yystate, yyn, yyrule[yyn]);\n#endif\n    yym = yylen[yyn];\n    if (yym)\n        yyval = yyvsp[1-yym];\n    else\n        memset(&yyval, 0, sizeof yyval);\n    switch (yyn)\n    {\ncase 3:\n#line 101 \"parser.y\"\n{\n\t\t\thid_device = (hid_device_t *) calloc(1, sizeof(*hid_device));\n\t\t\tif (hid_device == NULL) {\n\t\t\t\tSYSLOG(LOGCRIT, \"Could not allocate new \" \\\n\t\t\t\t\t\t\"config entry\" EOL);\n\t\t\t\tYYABORT;\n\t\t\t}\n\n\t\t\thid_device->new_device = 1;\n\t\t\t}\nbreak;\ncase 4:\n#line 112 \"parser.y\"\n{\n\t\t\tif (check_hid_device(hid_device))\n\t\t\t\tLIST_INSERT_HEAD(&hid_devices,hid_device,next);\n\t\t\telse\n\t\t\t\tfree_hid_device(hid_device);\n\n\t\t\thid_device = NULL;\n\t\t\t}\nbreak;\ncase 15:\n#line 137 \"parser.y\"\n{\n\t\t\tmemcpy(&hid_device->bdaddr, &yyvsp[0].bdaddr, sizeof(hid_device->bdaddr));\n\t\t\t}\nbreak;\ncase 16:\n#line 143 \"parser.y\"\n{\n\t\t\thid_device->control_psm = yyvsp[0].num;\n\t\t\t}\nbreak;\ncase 17:\n#line 149 \"parser.y\"\n{\n\t\t\thid_device->interrupt_psm = yyvsp[0].num;\n\t\t\t}\nbreak;\ncase 18:\n#line 155 \"parser.y\"\n{\n\t\t\thid_device->reconnect_initiate = 1;\n\t\t\t}\nbreak;\ncase 19:\n#line 159 \"parser.y\"\n{\n\t\t\thid_device->reconnect_initiate = 0;\n\t\t\t}\nbreak;\ncase 20:\n#line 165 \"parser.y\"\n{\n\t\t\thid_device->battery_power = 1;\n\t\t\t}\nbreak;\ncase 21:\n#line 169 \"parser.y\"\n{\n\t\t\thid_device->battery_power = 0;\n\t\t\t}\nbreak;\ncase 22:\n#line 175 \"parser.y\"\n{\n\t\t\thid_device->normally_connectable = 1;\n\t\t\t}\nbreak;\ncase 23:\n#line 179 \"parser.y\"\n{\n\t\t\thid_device->normally_connectable = 0;\n\t\t\t}\nbreak;\ncase 24:\n#line 185 \"parser.y\"\n{\n\t\t\thid_descriptor_size = 0;\n\t\t\t}\nbreak;\ncase 25:\n#line 189 \"parser.y\"\n{\n\t\t\tif (hid_device->desc != NULL)\n\t\t\t\thid_dispose_report_desc(hid_device->desc);\n\n\t\t\thid_device->desc = hid_use_report_desc((unsigned char *) buffer, hid_descriptor_size);\n\t\t\tif (hid_device->desc == NULL) {\n\t\t\t\tSYSLOG(LOGCRIT, \"Could not use HID descriptor\" EOL);\n\t\t\t\tYYABORT;\n\t\t\t}\n\t\t\t}\nbreak;\ncase 28:\n#line 206 \"parser.y\"\n{\n\t\t\tif (hid_descriptor_size >= (int32_t) sizeof(buffer)) {\n\t\t\t\tSYSLOG(LOGCRIT, \"HID descriptor is too big\" EOL);\n\t\t\t\tYYABORT;\n\t\t\t}\n\n\t\t\tbuffer[hid_descriptor_size ++] = yyvsp[0].num;\n\t\t\t}\nbreak;\ncase 29:\n#line 217 \"parser.y\"\n{\n\t\t\t\tYYABORT;\n\t\t\t}\nbreak;\n#line 847 \"parser.c\"\n    }\n    yyssp -= yym;\n    yystate = *yyssp;\n    yyvsp -= yym;\n    yym = yylhs[yyn];\n    if (yystate == 0 && yym == 0)\n    {\n#if YYDEBUG\n        if (yydebug)\n            printf(\"%sdebug: after reduction, shifting from state 0 to\\\n state %d\\n\", YYPREFIX, YYFINAL);\n#endif\n        yystate = YYFINAL;\n        *++yyssp = YYFINAL;\n        *++yyvsp = yyval;\n        if (yychar < 0)\n        {\n            if ((yychar = yylex()) < 0) yychar = 0;\n#if YYDEBUG\n            if (yydebug)\n            {\n                yys = 0;\n                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];\n                if (!yys) yys = \"illegal-symbol\";\n                printf(\"%sdebug: state %d, reading %d (%s)\\n\",\n                        YYPREFIX, YYFINAL, yychar, yys);\n            }\n#endif\n        }\n        if (yychar == 0) goto yyaccept;\n        goto yyloop;\n    }\n    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&\n            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)\n        yystate = yytable[yyn];\n    else\n        yystate = yydgoto[yym];\n#if YYDEBUG\n    if (yydebug)\n        printf(\"%sdebug: after reduction, shifting from state %d \\\nto state %d\\n\", YYPREFIX, *yyssp, yystate);\n#endif\n    if (yyssp >= yysslim && yygrowstack())\n    {\n        goto yyoverflow;\n    }\n    *++yyssp = yystate;\n    *++yyvsp = yyval;\n    goto yyloop;\nyyoverflow:\n    yyerror(\"yacc stack overflow\");\nyyabort:\n    return (1);\nyyaccept:\n    return (0);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Create new session\n */\n", "func_signal": "bthid_session_p\nsession_open(bthid_server_p srv, hid_device_p const d)", "code": "{\n\tbthid_session_p\ts;\n\n\tassert(srv != NULL);\n\tassert(d != NULL);\n\n\tif ((s = (bthid_session_p) malloc(sizeof(*s))) == NULL)\n\t\treturn (NULL);\n\n\ts->srv = srv;  \n\tmemcpy(&s->bdaddr, &d->bdaddr, sizeof(s->bdaddr));\n\ts->ctrl = -1;\n\ts->intr = -1;\n\n\tif (d->keyboard) {\n\t\t/* Open /dev/vkbdctl */\n\t\ts->vkbd = open(\"/dev/vkbdctl\", O_RDWR);\n\t\tif (s->vkbd < 0) {\n\t\t\tsyslog(LOG_ERR, \"Could not open /dev/vkbdctl \" \\\n\t\t\t\t\"for %s. %s (%d)\", bt_ntoa(&s->bdaddr, NULL),\n\t\t\t\tstrerror(errno), errno);\n\t\t\tfree(s);\n\t\t\treturn (NULL);\n\t\t}\n\t} else\n\t\ts->vkbd = -1;\n\n\ts->state = CLOSED;\n\n\ts->keys1 = bit_alloc(kbd_maxkey());\n\tif (s->keys1 == NULL) {\n\t\tfree(s);\n\t\treturn (NULL);\n\t}\n\n\ts->keys2 = bit_alloc(kbd_maxkey());\n\tif (s->keys2 == NULL) {\n\t\tfree(s->keys1);\n\t\tfree(s);\n\t\treturn (NULL);\n\t}\n\n\tLIST_INSERT_HEAD(&srv->sessions, s, next);\n\n\treturn (s);\n}", "path": "session.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Accept new connection \n */\n", "func_signal": "static int32_t\nserver_accept(bthid_server_p srv, int32_t fd)", "code": "{\n\tbthid_session_p\t\ts;\n\thid_device_p\t\td;\n\tstruct sockaddr_l2cap\tl2addr;\n\tint32_t\t\t\tnew_fd;\n\tsocklen_t\t\tlen;\n\n        syslog(LOG_CRIT, \"server::server_accept: start\");\n\n\tlen = sizeof(l2addr);\n\tif ((new_fd = accept(fd, (struct sockaddr *) &l2addr, &len)) < 0) {\n            syslog(LOG_ERR, \"Could not accept %s connection. %s (%d)\",\n                   (fd == srv->ctrl)? \"control\" : \"interrupt\",\n                   strerror(errno), errno);\n            return (-1);\n\t}\n\n\t/* Is device configured? */\n\tif ((d = get_hid_device(&l2addr.l2cap_bdaddr)) == NULL) {\n            syslog(LOG_ERR, \"Rejecting %s connection from %s. \" \\\n                   \"Device not configured\",\n                   (fd == srv->ctrl)? \"control\" : \"interrupt\",\n                   bt_ntoa(&l2addr.l2cap_bdaddr, NULL));\n            close(new_fd);\n            return (-1);\n\t}\n\n\t/* Check if we have session for the device */\n\tif ((s = session_by_bdaddr(srv, &l2addr.l2cap_bdaddr)) == NULL) {\n            d->new_device = 0; /* reset new device flag */\n            write_hids_file();\n            \n            /* Create new inbound session */\n            if ((s = session_open(srv, d)) == NULL) {\n                syslog(LOG_CRIT, \"Could not open inbound session \"\n                       \"for %s\", bt_ntoa(&l2addr.l2cap_bdaddr, NULL));\n                close(new_fd);\n                return (-1);\n            }\n\t}\n        \n\t/* Update descriptors */\n\tif (fd == srv->ctrl) {\n\t\tassert(s->ctrl == -1);\n\t\ts->ctrl = new_fd;\n\t\ts->state = (s->intr == -1)? W4INTR : OPEN;\n\t} else {\n\t\tassert(s->intr == -1);\n\t\ts->intr = new_fd;\n\t\ts->state = (s->ctrl == -1)? W4CTRL : OPEN;\n\t}\n\n\tFD_SET(new_fd, &srv->rfdset);\n\tif (new_fd > srv->maxfd)\n\t\tsrv->maxfd = new_fd;\n\n\tsyslog(LOG_NOTICE, \"Accepted %s connection from %s\",\n\t\t(fd == srv->ctrl)? \"control\" : \"interrupt\",\n\t\tbt_ntoa(&l2addr.l2cap_bdaddr, NULL));\n\n\t/* Register session's vkbd descriptor (if needed) for read */\n\tif (s->state == OPEN && d->keyboard) {\n\t\tassert(s->vkbd != -1);\n\n\t\tFD_SET(s->vkbd, &srv->rfdset);\n\t\tif (s->vkbd > srv->maxfd)\n\t\t\tsrv->maxfd = s->vkbd;\n\t}\n\n\treturn (0);\n}", "path": "server.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Process data from the interrupt channel\n */\n", "func_signal": "int32_t\nhid_interrupt(bthid_session_p s, uint8_t *data, int32_t len)", "code": "{\n    hid_device_p\thid_device;\n    hid_data_t\td;\n    hid_item_t\th;\n    int32_t\t\treport_id, usage, page, val,\n        mouse_x, mouse_y, mouse_z, mouse_butt,\n        mevents, kevents;\n\n    uint8_t *p_data;\n\n    int i;\n\n    int button_val;\n    int temp_max_strength;\n\n    char if_movement_tilting = 0;\n    char if_movement_pointing = 0;\n\n    //char temp_char[10000];\n    //char *p_temp_char;\n    \n\n    report_id = 0;\n\n    assert(s != NULL);\n    assert(s->srv != NULL);\n    assert(data != NULL);\n\n    /*\n    p_temp_char = temp_char;\n    p_data = data;\n\n    for(i = 0; i < len; i++) {\n        sprintf(p_temp_char, \"%04X \", p_data[0]);\n        p_temp_char += 5;\n        p_data++;\n    }\n    p_temp_char[0] = 0;\n    syslog(LOG_CRIT, \"hid::hid_interrupt: start: len: %d %s\", len, temp_char);\n    */\n\n    if (len < 3) {\n        syslog(LOG_ERR, \"Got short message (%d bytes) on Interrupt \" \\\n               \"channel from %s\", len, bt_ntoa(&s->bdaddr, NULL));\n        return (-1);\n    }\n\n    if (data[0] != 0xa1) {\n        syslog(LOG_ERR, \"Got unexpected message 0x%x on \" \\\n               \"Interrupt channel from %s\",\n               data[0], bt_ntoa(&s->bdaddr, NULL));\n        return (-1);\n    }\n\n    hid_device = get_hid_device(&s->bdaddr);\n    assert(hid_device != NULL);\n\n    mouse_x = mouse_y = mouse_z = mouse_butt = mevents = kevents = 0;\n\n    //button\n    button_val = data[2] * 256 + data[3];\n    //syslog(LOG_CRIT, \"hid::hid_interrupt: button_val: %04x\", button_val);\n    if(button_val & WIIMOTE_BUTTON_A && !(pre_button_val & WIIMOTE_BUTTON_A)) {\n        mouse_butt |= 1;\n        mevents++;\n    }\n\n    if(button_val & WIIMOTE_BUTTON_B && !(pre_button_val & WIIMOTE_BUTTON_B)) {\n        mouse_butt |= 4;\n        mevents++;\n    }\n\n    if_movement_pointing = button_val & WIIMOTE_BUTTON_1;\n    if_movement_tilting = button_val & WIIMOTE_BUTTON_2;\n    if(if_movement_tilting && !if_movement_pointing)\n        movement_val = WIIMOTE_MOVEMENT_TILTING;\n    else if(if_movement_pointing && !if_movement_tilting)\n        movement_val = WIIMOTE_MOVEMENT_POINTING;\n\n    //resolution\n    if(button_val & WIIMOTE_BUTTON_PLUS && !(pre_button_val & WIIMOTE_BUTTON_PLUS)) {\n        switch(movement_val) {\n        case WIIMOTE_MOVEMENT_TILTING:\n            resolution_motion--;\n            resolution_motion = max(resolution_motion, RESOLUTION_MIN);\n            //syslog(LOG_CRIT, \"hid::hid_interrupt: resolution_motion: %d\", resolution_motion);\n            break;\n        case WIIMOTE_MOVEMENT_POINTING:\n            resolution_ir--;\n            resolution_ir = max(resolution_ir, RESOLUTION_MIN);\n            //syslog(LOG_CRIT, \"hid::hid_interrupt: resolution_ir: %d\", resolution_ir);\n            break;\n        default:\n            break;\n        }\n    }\n        \n    if(button_val & WIIMOTE_BUTTON_MINUS && !(pre_button_val & WIIMOTE_BUTTON_MINUS)) {\n        switch(movement_val) {\n        case WIIMOTE_MOVEMENT_TILTING:\n            resolution_motion++;\n            resolution_motion = min(resolution_motion, RESOLUTION_MAX);\n            //syslog(LOG_CRIT, \"hid::hid_interrupt: resolution_motion: %d\", resolution_motion);\n            break;\n        case WIIMOTE_MOVEMENT_POINTING:\n            resolution_ir++;\n            resolution_ir = min(resolution_ir, RESOLUTION_MAX);\n            //syslog(LOG_CRIT, \"hid::hid_interrupt: resolution_ir: %d\", resolution_ir);\n            break;\n        default:\n            break;\n        }\n    }\n\n\n    //tilting\n    current_motion_x = data[4];\n    current_motion_y = data[5];\n    current_motion_z = data[6];\n\n    //pointing\n    p_data = &data[7];\n\n    for(i = 0; i < WIIMOTE_N_IR; i++, p_data += 3) {\n        if(!(p_data[0] == 0xff && p_data[1] == 0xff)) {\n            ir[i].x = p_data[0] + ((p_data[2] >> 4) & 0x03) * 256;\n            ir[i].y = p_data[1] + ((p_data[2] >> 6) & 0x03) * 256;\n            ir[i].strength = p_data[2] & 0x0f;\n        }\n        else {\n            ir[i].x = 0;\n            ir[i].y = 0;\n            ir[i].strength = 0;\n        }\n    }\n\n    temp_max_strength = 0;\n    for(i = 0; i < WIIMOTE_N_IR; i++) {\n        if(ir[i].strength > temp_max_strength) {\n            temp_max_strength = ir[i].strength;\n            if(ir[i].pre_strength != 0) {\n                current_ir_x = ir[i].x;\n                current_ir_y = ir[i].y;\n                pre_ir_x = ir[i].pre_x;\n                pre_ir_y = ir[i].pre_y;\n            }\n            else {\n                current_ir_x = 0;\n                current_ir_y = 0;\n                pre_ir_x = 0;\n                pre_ir_y = 0;\n            }\n        }\n    }\n\n    /*\n    syslog(LOG_CRIT, \"hid::hid_interrupt: ir: (%3d,%3d) pre: (%3d,%3d) mouse: (%3d,%3d) data: (%3x,%3x,%3x) (%3x,%3x,%3x) (%3x,%3x,%3x) (%3x,%3x,%3x)\", \n           current_ir_x, current_ir_y, \n           pre_ir_x, pre_ir_y,\n           -current_ir_x + pre_ir_x, current_ir_y - pre_ir_y, \n           data[7], data[8], data[9], \n           data[10], data[11], data[12], \n           data[13], data[14], data[15],\n           data[16], data[17], data[18]);\n    */\n\n    mouse_x = 0;\n    mouse_y = 0;\n    mouse_z = 0;\n    switch(movement_val) {\n    case WIIMOTE_MOVEMENT_TILTING:\n        if(if_motion_first) {\n            if_motion_first = 0;\n            center_motion_x = current_motion_x;\n            center_motion_y = current_motion_y;\n        }\n        mouse_x = current_motion_x - center_motion_x;\n        mouse_y = current_motion_y - center_motion_y;\n\n        mouse_x /= resolution_motion;\n        mouse_y /= resolution_motion;\n        mevents++;\n        //mouse_z = current_motion_z - 0x9c;\n        break;\n    case WIIMOTE_MOVEMENT_POINTING:\n        mouse_x = -current_ir_x + pre_ir_x;\n//     \t mouse_x = -current_ir_x;\n        mouse_y = current_ir_y - pre_ir_y;\n//        mouse_y = current_ir_y;\n        \n        mouse_x /= resolution_ir;\n        mouse_y /= resolution_ir;\n\n        if(temp_max_strength > 0 && (mouse_x || mouse_y))\n            mevents++;\n        break;\n    default:\n        break;\n    }\n\n    //set pre.\n    for(i = 0; i < WIIMOTE_N_IR; i++) {\n        ir[i].pre_x = ir[i].x;\n        ir[i].pre_y = ir[i].y;\n        ir[i].pre_strength = ir[i].strength;\n    }\n\n    pre_button_val = button_val;\n\n\n    for (d = hid_start_parse(hid_device->desc, 1 << hid_input, -1);\n         hid_get_item(d, &h) > 0; ) {\n\n        page = HID_PAGE(h.usage);\n        usage = HID_USAGE(h.usage);\n        val = hid_get_data(data, &h);\n\n        //syslog(LOG_CRIT, \"hid::hid_interrupt: page: %d HUP_GENERIC_DESKTOP: %d HUP_KEYBOARD: %d HUP_BUTTON: %d HUP_CONSUMER: %d HUP_MICROSOFT: %d\", page, HUP_GENERIC_DESKTOP, HUP_KEYBOARD, HUP_BUTTON, HUP_CONSUMER, HUP_MICROSOFT);\n    }\n    hid_end_parse(d);\n\n    /* \n     * XXX FIXME Feed mouse events into kernel.\n     * The code block below works, but it is not good enough.\n     * Need to track double-clicks etc.\n     *\n     * Double click currently works in X, but not in console.\n     */\n\n    if (mevents > 0) {\n        struct mouse_info\tmi;\n\n\n          syslog(LOG_CRIT, \"hid::hid_interrupt: mouse: (%d,%d,%d) button: %d\", \n          mouse_x, mouse_y, mouse_z, mouse_butt);\n        \n        \n        mi.operation = MOUSE_ACTION;\n        mi.u.data.x = mouse_x;\n        mi.u.data.y = mouse_y;\n        mi.u.data.z = mouse_z;\n        mi.u.data.buttons = mouse_butt;\n\n        if (ioctl(s->srv->cons, CONS_MOUSECTL, &mi) < 0)\n            syslog(LOG_ERR, \"Could not process mouse events from \"      \\\n                   \"%s. %s (%d)\", bt_ntoa(&s->bdaddr, NULL),\n                   strerror(errno), errno);\n    }\n\n    return (0);\n}", "path": "hid.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Re-read config file */\n", "func_signal": "int32_t\nread_config_file(void)", "code": "{\n\tint32_t\te;\n\n\tif (config_file_1 == NULL && config_file_2 == NULL) {\n\t\tSYSLOG(LOGERR, \"Unknown config file name!\" EOL);\n\t\treturn (-1);\n\t}\n\n\tif ((yyin = fopen(config_file_1, \"r\")) == NULL)\n            if((yyin = fopen(config_file_2, \"r\")) == NULL) {\n                SYSLOG(LOGERR, \"Could not open config file '%s'. %s (%d)\" EOL,\n                       config_file_1, strerror(errno), errno);\n\t\treturn (-1);\n            }\n        \n\n\tclean_config();\n\tif (yyparse() < 0) {\n\t\tSYSLOG(LOGERR, \"Could not parse config file '%s'\" EOL,\n                       config_file_1);\n\t\te = -1;\n\t} else\n\t\te = 0;\n\n\tfclose(yyin);\n\tyyin = NULL;\n\n\treturn (e);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Print config entry */\n", "func_signal": "void\nprint_hid_device(hid_device_p d, FILE *f)", "code": "{\n\t/* XXX FIXME hack! */\n\tstruct report_desc {\n\t\tunsigned int\tsize;\n\t\tunsigned char\tdata[1];\n\t};\n\t/* XXX FIXME hack! */\n\n\tstruct report_desc\t*desc = (struct report_desc *) d->desc;\n\tuint32_t\t\t i;\n\n\tfprintf(f,\n\"device {\\n\"\t\t\t\t\t\\\n\"\tbdaddr\t\t\t%s;\\n\"\t\t\\\n\"\tcontrol_psm\t\t0x%x;\\n\"\t\\\n\"\tinterrupt_psm\t\t0x%x;\\n\"\t\\\n\"\treconnect_initiate\t%s;\\n\"\t\t\\\n\"\tbattery_power\t\t%s;\\n\"\t\t\\\n\"\tnormally_connectable\t%s;\\n\"\t\t\\\n\"\thid_descriptor\t\t{\",\n\t\tbt_ntoa(&d->bdaddr, NULL),\n\t\td->control_psm, d->interrupt_psm,\n                d->reconnect_initiate? \"true\" : \"false\",\n                d->battery_power? \"true\" : \"false\",\n                d->normally_connectable? \"true\" : \"false\");\n \n\tfor (i = 0; i < desc->size; i ++) {\n\t\t\tif ((i % 8) == 0)\n\t\t\t\tfprintf(f, \"\\n\t\t\");\n \n\t\t\tfprintf(f, \"0x%2.2x \", desc->data[i]);\n\t}\n                \n\tfprintf(f,\n\"\\n\"\t\t\\\n\"\t};\\n\"\t\\\n\"}\\n\");\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Process data on the connection\n */\n", "func_signal": "static int32_t\nserver_process(bthid_server_p srv, int32_t fd)", "code": "{\n\tbthid_session_p\t\ts = session_by_fd(srv, fd);\n\tint32_t\t\t\tlen, to_read;\n\tint32_t\t\t\t(*cb)(bthid_session_p, uint8_t *, int32_t);\n\tunion {\n\t\tuint8_t\t\tb[1024];\n\t\tvkbd_status_t\ts;\n\t}\t\t\tdata;\n\n        //syslog(LOG_CRIT, \"server::server_process: start\");\n\n\tif (s == NULL)\n\t\treturn (0); /* can happen on device disconnect */\n\n\n\tif (fd == s->ctrl) {\n\t\tcb = hid_control;\n\t\tto_read = sizeof(data.b);\n\t} else if (fd == s->intr) {\n\t\tcb = hid_interrupt;\n\t\tto_read = sizeof(data.b);\n\t} else {\n\t\tassert(fd == s->vkbd);\n\n\t\tcb = kbd_status_changed;\n\t\tto_read = sizeof(data.s);\n\t}\n\n\tdo {\n\t\tlen = read(fd, &data, to_read);\n\t} while (len < 0 && errno == EINTR);\n\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"Could not read data from %s (%s). %s (%d)\",\n\t\t\tbt_ntoa(&s->bdaddr, NULL),\n\t\t\t(fd == s->ctrl)? \"control\" : \"interrupt\",\n\t\t\tstrerror(errno), errno);\n\t\tsession_close(s);\n\t\treturn (0);\n\t}\n\n\tif (len == 0) {\n\t\tsyslog(LOG_NOTICE, \"Remote device %s has closed %s connection\",\n\t\t\tbt_ntoa(&s->bdaddr, NULL),\n\t\t\t(fd == s->ctrl)? \"control\" : \"interrupt\");\n\t\tsession_close(s);\n\t\treturn (0);\n\t}\n\n\t(*cb)(s, (uint8_t *) &data, len);\n\n\treturn (0);\n}", "path": "server.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Close session\n */\n", "func_signal": "void\nsession_close(bthid_session_p s)", "code": "{\n\tassert(s != NULL);\n\tassert(s->srv != NULL);\n\n\tLIST_REMOVE(s, next);\n\n\tif (s->intr != -1) {\n\t\tFD_CLR(s->intr, &s->srv->rfdset);\n\t\tFD_CLR(s->intr, &s->srv->wfdset);\n\t\tclose(s->intr);\n\n\t\tif (s->srv->maxfd == s->intr)\n\t\t\ts->srv->maxfd --;\n\t}\n\n\tif (s->ctrl != -1) {\n\t\tFD_CLR(s->ctrl, &s->srv->rfdset);\n\t\tFD_CLR(s->ctrl, &s->srv->wfdset);\n\t\tclose(s->ctrl);\n\n\t\tif (s->srv->maxfd == s->ctrl)\n\t\t\ts->srv->maxfd --;\n\t}\n\n\tif (s->vkbd != -1) {\n\t\tFD_CLR(s->vkbd, &s->srv->rfdset);\n\t\tclose(s->vkbd);\n\n\t\tif (s->srv->maxfd == s->vkbd)\n\t\t\ts->srv->maxfd --;\n\t}\n\n\tfree(s->keys1);\n\tfree(s->keys2);\n\n\tmemset(s, 0, sizeof(*s));\n\tfree(s);\n}", "path": "session.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Lookup session by fd\n */\n", "func_signal": "bthid_session_p\nsession_by_fd(bthid_server_p srv, int32_t fd)", "code": "{\n\tbthid_session_p\ts;\n\n\tassert(srv != NULL);\n\tassert(fd >= 0);\n\n\tLIST_FOREACH(s, &srv->sessions, next)\n\t\tif (s->ctrl == fd || s->intr == fd || s->vkbd == fd)\n\t\t\tbreak;\n\n\treturn (s);\n}", "path": "session.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/*\n * Shutdown server\n */\n", "func_signal": "void\nserver_shutdown(bthid_server_p srv)", "code": "{\n\tassert(srv != NULL);\n\n\tclose(srv->cons);\n\tclose(srv->ctrl);\n\tclose(srv->intr);\n\n\twhile (!LIST_EMPTY(&srv->sessions))\n\t\tsession_close(LIST_FIRST(&srv->sessions));\n\n\tmemset(srv, 0, sizeof(*srv));\n}", "path": "server.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Clean config */\n", "func_signal": "void\nclean_config(void)", "code": "{\n\twhile (!LIST_EMPTY(&hid_devices)) {\n\t\thid_device_p\td = LIST_FIRST(&hid_devices);\n\n\t\tLIST_REMOVE(d, next);\n\t\tfree_hid_device(d);\n\t}\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* allocate initial stack or double stack size, up to YYMAXDEPTH */\n", "func_signal": "static int yygrowstack()", "code": "{\n    int newsize, i;\n    short *newss;\n    YYSTYPE *newvs;\n\n    if ((newsize = yystacksize) == 0)\n        newsize = YYINITSTACKSIZE;\n    else if (newsize >= YYMAXDEPTH)\n        return -1;\n    else if ((newsize *= 2) > YYMAXDEPTH)\n        newsize = YYMAXDEPTH;\n    i = yyssp - yyss;\n    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :\n      (short *)malloc(newsize * sizeof *newss);\n    if (newss == NULL)\n        return -1;\n    yyss = newss;\n    yyssp = newss + i;\n    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :\n      (YYSTYPE *)malloc(newsize * sizeof *newvs);\n    if (newvs == NULL)\n        return -1;\n    yyvs = newvs;\n    yyvsp = newvs + i;\n    yystacksize = newsize;\n    yysslim = yyss + newsize - 1;\n    return 0;\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/* Lookup config entry */\n", "func_signal": "hid_device_p\nget_hid_device(bdaddr_p bdaddr)", "code": "{\n\thid_device_p\td;\n\n\tLIST_FOREACH(d, &hid_devices, next)\n\t\tif (memcmp(&d->bdaddr, bdaddr, sizeof(bdaddr_t)) == 0)\n\t\t\tbreak;\n\n\treturn (d);\n}", "path": "parser.c", "repo_name": "lordofhyphens/bsdmoted", "stars": 2, "license": "bsd-3-clause", "language": "c", "size": 224}
{"docstring": "/**\n * shell_global_create_root_pixmap_actor:\n * @global: a #ShellGlobal\n *\n * Creates an actor showing the root window pixmap.\n *\n * Return value: (transfer none): a #ClutterActor with the root window pixmap.\n *               The actor is floating, hence (transfer none).\n */\n", "func_signal": "ClutterActor *\nshell_global_create_root_pixmap_actor (ShellGlobal *global)", "code": "{\n  GdkWindow *window;\n  GdkEventMask events;\n  gboolean created_new_pixmap = FALSE;\n  ClutterActor *clone;\n\n  /* The actor created is actually a ClutterClone of global->root_pixmap. */\n\n  if (global->root_pixmap == NULL)\n    {\n      global->root_pixmap = CLUTTER_GLX_TEXTURE_PIXMAP (clutter_glx_texture_pixmap_new ());\n\n      /* The low and medium quality filters give nearest-neighbor resizing. */\n      clutter_texture_set_filter_quality (CLUTTER_TEXTURE (global->root_pixmap),\n                                          CLUTTER_TEXTURE_QUALITY_HIGH);\n\n      /* The pixmap actor is only referenced by its clones. */\n      g_object_ref_sink (global->root_pixmap);\n\n      g_signal_connect (G_OBJECT (global->root_pixmap), \"destroy\",\n                        G_CALLBACK (root_pixmap_destroy), global);\n\n      /* Watch the root window for changes. */\n      window = gdk_get_default_root_window ();\n      events = gdk_window_get_events (window);\n      events |= GDK_PROPERTY_CHANGE_MASK;\n      gdk_window_set_events (window, events);\n      /* Metacity handles some root window property updates in its global\n       * event filter, though not this one. For all root window property\n       * updates, the global filter returns GDK_FILTER_CONTINUE, so our\n       * window specific filter will be called.\n       */\n      gdk_window_add_filter (window, root_window_filter, global);\n\n      update_root_window_pixmap (global);\n\n      created_new_pixmap = TRUE;\n    }\n\n  clone = clutter_clone_new (CLUTTER_ACTOR (global->root_pixmap));\n\n  if (created_new_pixmap)\n    g_object_unref(global->root_pixmap);\n\n  return clone;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/*\n * Called when the root window pixmap actor is destroyed.\n */\n", "func_signal": "static void\nroot_pixmap_destroy (GObject *sender, gpointer data)", "code": "{\n  ShellGlobal *global = SHELL_GLOBAL (data);\n\n  gdk_window_remove_filter (gdk_get_default_root_window (),\n                            root_window_filter, global);\n  global->root_pixmap = NULL;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/*\n * Updates the global->root_pixmap actor with the root window's pixmap or fails\n * with a warning.\n */\n", "func_signal": "static void\nupdate_root_window_pixmap (ShellGlobal *global)", "code": "{\n  Atom type;\n  int format;\n  gulong nitems;\n  gulong bytes_after;\n  guchar *data;\n\n  if (!XGetWindowProperty (gdk_x11_get_default_xdisplay (),\n                           gdk_x11_get_default_root_xwindow (),\n                           gdk_x11_get_xatom_by_name (\"_XROOTPMAP_ID\"),\n                           0, LONG_MAX,\n                           False,\n                           AnyPropertyType,\n                           &type, &format, &nitems, &bytes_after, &data) &&\n      type != None)\n  {\n     /* Got a property. */\n     if (type == XA_PIXMAP && format == 32 && nitems == 1)\n       {\n         /* Was what we expected. */\n         clutter_x11_texture_pixmap_set_pixmap (CLUTTER_X11_TEXTURE_PIXMAP (global->root_pixmap),\n                                                *(Pixmap *)data);\n       }\n     else\n       {\n         g_warning (\"Could not get the root window pixmap\");\n       }\n\n     XFree(data);\n  }\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_clutter_texture_set_from_pixbuf: \n * texture: #ClutterTexture to be modified\n * pixbuf: #GdkPixbuf to set as an image for #ClutterTexture\n *\n * Convenience function for setting an image for #ClutterTexture based on #GdkPixbuf.\n * Copied from an example posted by hp in this thread http://mail.gnome.org/archives/gtk-devel-list/2008-September/msg00218.html\n *\n * Return value: %TRUE on success, %FALSE on failure\n */\n", "func_signal": "gboolean\nshell_clutter_texture_set_from_pixbuf (ClutterTexture *texture,\n                                       GdkPixbuf      *pixbuf)", "code": "{\n    return clutter_texture_set_from_rgb_data (texture,\n                                              gdk_pixbuf_get_pixels (pixbuf),\n                                              gdk_pixbuf_get_has_alpha (pixbuf),\n                                              gdk_pixbuf_get_width (pixbuf),\n                                              gdk_pixbuf_get_height (pixbuf),\n                                              gdk_pixbuf_get_rowstride (pixbuf),\n                                              gdk_pixbuf_get_has_alpha (pixbuf)\n                                              ? 4 : 3,\n                                              0, NULL);\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_global_get_windows:\n *\n * Gets the list of MutterWindows for the plugin's screen\n *\n * Return value: (element-type MutterWindow) (transfer none): the list of windows\n */\n", "func_signal": "GList *\nshell_global_get_windows (ShellGlobal *global)", "code": "{\n  g_return_val_if_fail (SHELL_IS_GLOBAL (global), NULL);\n\n  return mutter_plugin_get_windows (global->plugin);\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_global_create_vertical_gradient:\n * @top: the color at the top\n * @bottom: the color at the bottom\n *\n * Creates a vertical gradient actor.\n *\n * Return value: (transfer none): a #ClutterCairoTexture actor with the\n *               gradient. The texture actor is floating, hence (transfer none).\n */\n", "func_signal": "ClutterCairoTexture *\nshell_global_create_vertical_gradient (ClutterColor *top,\n                                       ClutterColor *bottom)", "code": "{\n  ClutterCairoTexture *texture;\n  cairo_t *cr;\n  cairo_pattern_t *pattern;\n\n  /* Draw the gradient on an 8x8 pixel texture. Because the gradient is drawn\n   * from the uppermost to the lowermost row, after stretching 1/16 of the\n   * texture height has the top color and 1/16 has the bottom color. The 8\n   * pixel width is chosen for reasons related to graphics hardware internals.\n   */\n  texture = CLUTTER_CAIRO_TEXTURE (clutter_cairo_texture_new (8, 8));\n  cr = clutter_cairo_texture_create (texture);\n\n  pattern = cairo_pattern_create_linear (0, 0, 0, 8);\n  cairo_pattern_add_color_stop_rgba (pattern, 0,\n                                     top->red / 255.,\n                                     top->green / 255.,\n                                     top->blue / 255.,\n                                     top->alpha / 255.);\n  cairo_pattern_add_color_stop_rgba (pattern, 1,\n                                     bottom->red / 255.,\n                                     bottom->green / 255.,\n                                     bottom->blue / 255.,\n                                     bottom->alpha / 255.);\n\n  cairo_set_source (cr, pattern);\n  cairo_paint (cr);\n\n  cairo_pattern_destroy (pattern);\n  cairo_destroy (cr);\n\n  return texture;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * gdm_user_get_home_directory:\n * @user: the user object to examine.\n *\n * Retrieves the home directory of @user.\n *\n * Returns: a pointer to an array of characters which must not be modified or\n *  freed, or %NULL.\n *\n * Since: 1.0\n **/\n", "func_signal": "G_CONST_RETURN gchar *\ngdm_user_get_home_directory (GdmUser *user)", "code": "{\n        g_return_val_if_fail (GDM_IS_USER (user), NULL);\n\n        return user->home_dir;\n}", "path": "src\\gdmuser\\gdm-user.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "//FIXME investigate why this doesn't work\n", "func_signal": "static gboolean\nna_tray_manager_selection_clear_event (GtkWidget         *widget,\n                                       GdkEventSelection *event,\n                                       NaTrayManager     *manager)", "code": "{\n  g_signal_emit (manager, manager_signals[LOST_SELECTION], 0);\n  na_tray_manager_unmanage (manager);\n\n  return FALSE;\n}", "path": "src\\tray\\na-tray-manager.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/* needs to stay in sync with gdm-slave */\n", "func_signal": "static char *\n_get_primary_user_session_id (GdmUserManager *manager,\n                              GdmUser        *user)", "code": "{\n        gboolean    res;\n        gboolean    can_activate_sessions;\n        GError     *error;\n        GList      *sessions;\n        GList      *l;\n        char       *primary_ssid;\n\n        if (manager->priv->seat_id == NULL || manager->priv->seat_id[0] == '\\0') {\n                g_debug (\"GdmUserManager: display seat id is not set; can't switch sessions\");\n                return NULL;\n        }\n\n        primary_ssid = NULL;\n        sessions = NULL;\n\n        g_debug (\"GdmUserManager: checking if seat can activate sessions\");\n\n        error = NULL;\n        res = dbus_g_proxy_call (manager->priv->seat_proxy,\n                                 \"CanActivateSessions\",\n                                 &error,\n                                 G_TYPE_INVALID,\n                                 G_TYPE_BOOLEAN, &can_activate_sessions,\n                                 G_TYPE_INVALID);\n        if (! res) {\n                g_warning (\"unable to determine if seat can activate sessions: %s\",\n                           error->message);\n                g_error_free (error);\n                goto out;\n        }\n\n        if (! can_activate_sessions) {\n                g_debug (\"GdmUserManager: seat is unable to activate sessions\");\n                goto out;\n        }\n\n        sessions = gdm_user_get_sessions (user);\n        if (sessions == NULL) {\n                g_warning (\"unable to determine sessions for user: %s\",\n                           gdm_user_get_user_name (user));\n                goto out;\n        }\n\n        for (l = sessions; l != NULL; l = l->next) {\n                const char *ssid;\n\n                ssid = l->data;\n\n                /* FIXME: better way to choose? */\n                if (ssid != NULL) {\n                        primary_ssid = g_strdup (ssid);\n                        break;\n                }\n        }\n\n out:\n\n        return primary_ssid;\n}", "path": "src\\gdmuser\\gdm-user-manager.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_global_get:\n *\n * Gets the singleton global object that represents the desktop.\n *\n * Return value: (transfer none): the singleton global object\n */\n", "func_signal": "ShellGlobal *\nshell_global_get (void)", "code": "{\n  static ShellGlobal *the_object = NULL;\n\n  if (!the_object)\n    the_object = g_object_new (SHELL_TYPE_GLOBAL, 0);\n\n  return the_object;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_get_button_event_click_count:\n *\n * Return value: click count for button press and release events\n */\n", "func_signal": "guint16\nshell_get_button_event_click_count(ClutterEvent *event)", "code": "{\n  g_return_val_if_fail(event->type == CLUTTER_BUTTON_PRESS ||\n                       event->type == CLUTTER_BUTTON_RELEASE, 0);\n  return event->button.click_count;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/* Code to close all file descriptors before we exec; copied from gspawn.c in GLib.\n *\n * Authors: Padraig O'Briain, Matthias Clasen, Lennart Poettering\n *\n * http://bugzilla.gnome.org/show_bug.cgi?id=469231\n * http://bugzilla.gnome.org/show_bug.cgi?id=357585\n */\n", "func_signal": "static int\nset_cloexec (void *data, gint fd)", "code": "{\n  if (fd >= GPOINTER_TO_INT (data))\n    fcntl (fd, F_SETFD, FD_CLOEXEC);\n\n  return 0;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * gdm_user_get_uid:\n * @user: the user object to examine.\n *\n * Retrieves the ID of @user.\n *\n * Returns: a pointer to an array of characters which must not be modified or\n *  freed, or %NULL.\n *\n * Since: 1.0\n **/\n", "func_signal": "uid_t\ngdm_user_get_uid (GdmUser *user)", "code": "{\n        g_return_val_if_fail (GDM_IS_USER (user), -1);\n\n        return user->uid;\n}", "path": "src\\gdmuser\\gdm-user.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * gdm_manager_get_user:\n * @manager: the manager to query.\n * @username: the login name of the user to get.\n *\n * Retrieves a pointer to the #GdmUser object for the login named @username\n * from @manager. This pointer is not a reference, and should not be released.\n *\n * Returns: a pointer to a #GdmUser object.\n **/\n", "func_signal": "GdmUser *\ngdm_user_manager_get_user (GdmUserManager *manager,\n                           const char     *username)", "code": "{\n        GdmUser *user;\n\n        g_return_val_if_fail (GDM_IS_USER_MANAGER (manager), NULL);\n        g_return_val_if_fail (username != NULL && username[0] != '\\0', NULL);\n\n        user = g_hash_table_lookup (manager->priv->users, username);\n\n        if (user == NULL) {\n                struct passwd *pwent;\n\n                pwent = getpwnam (username);\n\n                if (pwent != NULL) {\n                        user = add_new_user_for_pwent (manager, pwent);\n                }\n        }\n\n        return user;\n}", "path": "src\\gdmuser\\gdm-user-manager.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * _gdm_user_update:\n * @user: the user object to update.\n * @pwent: the user data to use.\n *\n * Updates the properties of @user using the data in @pwent.\n *\n * Since: 1.0\n **/\n", "func_signal": "void\n_gdm_user_update (GdmUser             *user,\n                  const struct passwd *pwent)", "code": "{\n        gchar *real_name;\n\n        g_return_if_fail (GDM_IS_USER (user));\n        g_return_if_fail (pwent != NULL);\n\n        g_object_freeze_notify (G_OBJECT (user));\n\n        /* Display Name */\n        if (pwent->pw_gecos && pwent->pw_gecos[0] != '\\0') {\n                gchar *first_comma;\n\n                first_comma = strchr (pwent->pw_gecos, ',');\n                if (first_comma) {\n                        real_name = g_strndup (pwent->pw_gecos,\n                                                  (first_comma - pwent->pw_gecos));\n                } else {\n                        real_name = g_strdup (pwent->pw_gecos);\n                }\n\n                if (real_name[0] == '\\0') {\n                        g_free (real_name);\n                        real_name = NULL;\n                }\n        } else {\n                real_name = NULL;\n        }\n\n        if ((real_name && !user->real_name) ||\n            (!real_name && user->real_name) ||\n            (real_name &&\n             user->real_name &&\n             strcmp (real_name, user->real_name) != 0)) {\n                g_free (user->real_name);\n                user->real_name = real_name;\n                g_object_notify (G_OBJECT (user), \"real-name\");\n        } else {\n                g_free (real_name);\n        }\n\n        /* UID */\n        if (pwent->pw_uid != user->uid) {\n                user->uid = pwent->pw_uid;\n                g_object_notify (G_OBJECT (user), \"uid\");\n        }\n\n        /* Username */\n        if ((pwent->pw_name && !user->user_name) ||\n            (!pwent->pw_name && user->user_name) ||\n            (pwent->pw_name &&\n             user->user_name &&\n             strcmp (user->user_name, pwent->pw_name) != 0)) {\n                g_free (user->user_name);\n                user->user_name = g_strdup (pwent->pw_name);\n                g_object_notify (G_OBJECT (user), \"user-name\");\n        }\n\n        /* Home Directory */\n        if ((pwent->pw_dir && !user->home_dir) ||\n            (!pwent->pw_dir && user->home_dir) ||\n            strcmp (user->home_dir, pwent->pw_dir) != 0) {\n                g_free (user->home_dir);\n                user->home_dir = g_strdup (pwent->pw_dir);\n                g_object_notify (G_OBJECT (user), \"home-directory\");\n                g_signal_emit (user, signals[ICON_CHANGED], 0);\n        }\n\n        /* Shell */\n        if ((pwent->pw_shell && !user->shell) ||\n            (!pwent->pw_shell && user->shell) ||\n            (pwent->pw_shell &&\n             user->shell &&\n             strcmp (user->shell, pwent->pw_shell) != 0)) {\n                g_free (user->shell);\n                user->shell = g_strdup (pwent->pw_shell);\n                g_object_notify (G_OBJECT (user), \"shell\");\n        }\n\n        update_icon_monitor (user);\n\n        g_object_thaw_notify (G_OBJECT (user));\n}", "path": "src\\gdmuser\\gdm-user.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_get_categories_for_desktop_file:\n *\n * @desktop_file_name: name of the desktop file for which to retrieve categories\n *\n * Return value: (element-type char*) (transfer full): List of categories\n *\n */\n", "func_signal": "GSList *\nshell_get_categories_for_desktop_file(const char *desktop_file_name)", "code": "{\n    GKeyFile *key_file;\n    const char * const *search_dirs;\n    char **categories = NULL;\n    GSList *categories_list = NULL; \n    char *full_path = NULL;   \n    GError *error = NULL;\n    gsize len;  \n    int i; \n\n    key_file = g_key_file_new (); \n    search_dirs = get_applications_search_path();\n   \n    g_key_file_load_from_dirs (key_file, desktop_file_name, (const char **)search_dirs, &full_path, 0, &error);\n\n    if (error != NULL) \n      {\n        g_warning (\"Error when loading a key file for %s: %s\", desktop_file_name, error->message);\n        g_clear_error (&error);\n      }\n    else \n      {\n        categories = g_key_file_get_string_list (key_file,\n                                                 \"Desktop Entry\",\n                                                 \"Categories\",\n                                                 &len,\n                                                 &error);\n        if (error != NULL)\n          {\n            // \"Categories\" is not a required key in the desktop files, so it's ok if we didn't find it\n            g_clear_error (&error);\n          } \n      }\n\n    g_key_file_free (key_file);\n \n    if (categories == NULL)\n      return NULL;\n\n    // gjs currently does not support returning arrays (other than a NULL value for an array), so we need \n    // to convert the array we are returning to GSList, returning which gjs supports. \n    // See http://bugzilla.gnome.org/show_bug.cgi?id=560567 for more info on gjs array support.\n    for (i = 0; categories[i]; i++)\n      {\n        categories_list = g_slist_prepend (categories_list, g_strdup (categories[i])); \n      }\n\n    g_strfreev (categories);\n\n    return categories_list;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_get_event_key_symbol:\n *\n * Return value: Clutter key value for the key press and release events, \n *               as specified in clutter-keysyms.h  \n */\n", "func_signal": "guint16\nshell_get_event_key_symbol(ClutterEvent *event)", "code": "{\n  g_return_val_if_fail(event->type == CLUTTER_KEY_PRESS ||\n                       event->type == CLUTTER_KEY_RELEASE, 0);\n\n  return event->key.keyval;\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * go_cairo_convert_data_to_pixbuf:\n * @src: a pointer to pixel data in cairo format\n * @dst: a pointer to pixel data in pixbuf format\n * @width: image width\n * @height: image height\n * @rowstride: data rowstride\n *\n * Converts the pixel data stored in @src in CAIRO_FORMAT_ARGB32 cairo format\n * to GDK_COLORSPACE_RGB pixbuf format and move them\n * to @dst. If @src == @dst, pixel are converted in place.\n **/\n", "func_signal": "static void\ngo_cairo_convert_data_to_pixbuf (unsigned char *dst,\n                                 unsigned char const *src,\n                                 int width,\n                                 int height,\n                                 int rowstride)", "code": "{\n        int i,j;\n        unsigned int t;\n        unsigned char a, b, c;\n\n        g_return_if_fail (dst != NULL);\n\n#define MULT(d,c,a,t) G_STMT_START { t = (a)? c * 255 / a: 0; d = t;} G_STMT_END\n\n        if (src == dst || src == NULL) {\n                for (i = 0; i < height; i++) {\n                        for (j = 0; j < width; j++) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n                                MULT(a, dst[2], dst[3], t);\n                                MULT(b, dst[1], dst[3], t);\n                                MULT(c, dst[0], dst[3], t);\n                                dst[0] = a;\n                                dst[1] = b;\n                                dst[2] = c;\n#else\n                                MULT(a, dst[1], dst[0], t);\n                                MULT(b, dst[2], dst[0], t);\n                                MULT(c, dst[3], dst[0], t);\n                                dst[3] = dst[0];\n                                dst[0] = a;\n                                dst[1] = b;\n                                dst[2] = c;\n#endif\n                                dst += 4;\n                        }\n                        dst += rowstride - width * 4;\n                }\n        } else {\n                for (i = 0; i < height; i++) {\n                        for (j = 0; j < width; j++) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n                                MULT(dst[0], src[2], src[3], t);\n                                MULT(dst[1], src[1], src[3], t);\n                                MULT(dst[2], src[0], src[3], t);\n                                dst[3] = src[3];\n#else\n                                MULT(dst[0], src[1], src[0], t);\n                                MULT(dst[1], src[2], src[0], t);\n                                MULT(dst[2], src[3], src[0], t);\n                                dst[3] = src[0];\n#endif\n                                src += 4;\n                                dst += 4;\n                        }\n                        src += rowstride - width * 4;\n                        dst += rowstride - width * 4;\n                }\n        }\n#undef MULT\n}", "path": "src\\gdmuser\\gdm-user.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * gdm_user_get_real_name:\n * @user: the user object to examine.\n *\n * Retrieves the display name of @user.\n *\n * Returns: a pointer to an array of characters which must not be modified or\n *  freed, or %NULL.\n *\n * Since: 1.0\n **/\n", "func_signal": "G_CONST_RETURN gchar *\ngdm_user_get_real_name (GdmUser *user)", "code": "{\n        g_return_val_if_fail (GDM_IS_USER (user), NULL);\n\n        return (user->real_name ? user->real_name : user->user_name);\n}", "path": "src\\gdmuser\\gdm-user.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/**\n * shell_global_set_stage_input_area:\n * x: X coordinate of rectangle\n * y: Y coordinate of rectangle\n * width: width of rectangle\n * height: height of rectangle\n *\n * Sets the area of the stage that is responsive to mouse clicks as\n * a rectangle.\n */\n", "func_signal": "void\nshell_global_set_stage_input_area (ShellGlobal *global,\n                                   int          x,\n                                   int          y,\n                                   int          width,\n                                   int          height)", "code": "{\n  g_return_if_fail (SHELL_IS_GLOBAL (global));\n\n  /* Cache these so we can save/restore across grabs */ \n  global->input_x = x;\n  global->input_y = y;\n  global->input_width = width;\n  global->input_height = height;\n  /* If we have a grab active, we'll set the input area when we ungrab. */\n  if (!global->grab_active)\n    mutter_plugin_set_stage_input_area (global->plugin, x, y, width, height);\n}", "path": "src\\shell-global.c", "repo_name": "knewter/gnome-shell", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 521}
{"docstring": "/** Entry point to tor-resolve */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n  uint32_t sockshost;\n  uint16_t socksport = 0, port_option = 0;\n  int isSocks4 = 0, isVerbose = 0, isReverse = 0, force = 0;\n  char **arg;\n  int n_args;\n  struct in_addr a;\n  uint32_t result = 0;\n  char *result_hostname = NULL;\n  char buf[INET_NTOA_BUF_LEN];\n  log_severity_list_t *s = tor_malloc_zero(sizeof(log_severity_list_t));\n\n  init_logging();\n\n  arg = &argv[1];\n  n_args = argc-1;\n\n  if (!n_args)\n    usage();\n\n  if (!strcmp(arg[0],\"--version\")) {\n    printf(\"Tor version %s.\\n\",VERSION);\n    return 0;\n  }\n  while (n_args && *arg[0] == '-') {\n    if (!strcmp(\"-v\", arg[0]))\n      isVerbose = 1;\n    else if (!strcmp(\"-4\", arg[0]))\n      isSocks4 = 1;\n    else if (!strcmp(\"-5\", arg[0]))\n      isSocks4 = 0;\n    else if (!strcmp(\"-x\", arg[0]))\n      isReverse = 1;\n    else if (!strcmp(\"-F\", arg[0]))\n      force = 1;\n    else if (!strcmp(\"-p\", arg[0])) {\n      int p;\n      if (n_args < 2) {\n        fprintf(stderr, \"No arguments given to -p\\n\");\n        usage();\n      }\n      p = atoi(arg[1]);\n      if (p<1 || p > 65535) {\n        fprintf(stderr, \"-p requires a number between 1 and 65535\\n\");\n        usage();\n      }\n      port_option = (uint16_t) p;\n      ++arg; /* skip the port */\n      --n_args;\n    } else {\n      fprintf(stderr, \"Unrecognized flag '%s'\\n\", arg[0]);\n      usage();\n    }\n    ++arg;\n    --n_args;\n  }\n\n  if (isSocks4 && isReverse) {\n    fprintf(stderr, \"Reverse lookups not supported with SOCKS4a\\n\");\n    usage();\n  }\n\n  if (isVerbose)\n    set_log_severity_config(LOG_DEBUG, LOG_ERR, s);\n  else\n    set_log_severity_config(LOG_WARN, LOG_ERR, s);\n  add_stream_log(s, \"<stderr>\", fileno(stderr));\n\n  if (n_args == 1) {\n    log_debug(LD_CONFIG, \"defaulting to localhost\");\n    sockshost = 0x7f000001u; /* localhost */\n    if (port_option) {\n      log_debug(LD_CONFIG, \"Using port %d\", (int)port_option);\n      socksport = port_option;\n    } else {\n      log_debug(LD_CONFIG, \"defaulting to port 9050\");\n      socksport = 9050; /* 9050 */\n    }\n  } else if (n_args == 2) {\n    if (parse_addr_port(LOG_WARN, arg[1], NULL, &sockshost, &socksport)<0) {\n      fprintf(stderr, \"Couldn't parse/resolve address %s\", arg[1]);\n      return 1;\n    }\n    if (socksport && port_option && socksport != port_option) {\n      log_warn(LD_CONFIG, \"Conflicting ports; using %d, not %d\",\n               (int)socksport, (int)port_option);\n    } else if (port_option) {\n      socksport = port_option;\n    } else if (!socksport) {\n      log_debug(LD_CONFIG, \"defaulting to port 9050\");\n      socksport = 9050;\n    }\n  } else {\n    usage();\n  }\n\n  if (network_init()<0) {\n    log_err(LD_BUG,\"Error initializing network; exiting.\");\n    return 1;\n  }\n\n  if (do_resolve(arg[0], sockshost, socksport, isReverse,\n                 isSocks4 ? 4 : 5, &result,\n                 &result_hostname))\n    return 1;\n\n  if (result_hostname) {\n    printf(\"%s\\n\", result_hostname);\n  } else {\n    a.s_addr = htonl(result);\n    tor_inet_ntoa(&a, buf, sizeof(buf));\n    printf(\"%s\\n\", buf);\n  }\n  return 0;\n}", "path": "src\\tools\\tor-resolve.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Determine the responsible hidden service directories for the\n * rend_encoded_v2_service_descriptor_t's in <b>descs</b> and upload them;\n * <b>service_id</b> and <b>seconds_valid</b> are only passed for logging\n * purposes. */\n", "func_signal": "static void\ndirectory_post_to_hs_dir(rend_service_descriptor_t *renddesc,\n                         smartlist_t *descs, const char *service_id,\n                         int seconds_valid)", "code": "{\n  int i, j, failed_upload = 0;\n  smartlist_t *responsible_dirs = smartlist_create();\n  smartlist_t *successful_uploads = smartlist_create();\n  routerstatus_t *hs_dir;\n  for (i = 0; i < smartlist_len(descs); i++) {\n    rend_encoded_v2_service_descriptor_t *desc = smartlist_get(descs, i);\n    /* Determine responsible dirs. */\n    if (hid_serv_get_responsible_directories(responsible_dirs,\n                                             desc->desc_id) < 0) {\n      log_warn(LD_REND, \"Could not determine the responsible hidden service \"\n                        \"directories to post descriptors to.\");\n      smartlist_free(responsible_dirs);\n      smartlist_free(successful_uploads);\n      return;\n    }\n    for (j = 0; j < smartlist_len(responsible_dirs); j++) {\n      char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];\n      hs_dir = smartlist_get(responsible_dirs, j);\n      if (smartlist_digest_isin(renddesc->successful_uploads,\n                                hs_dir->identity_digest))\n        /* Don't upload descriptor if we succeeded in doing so last time. */\n        continue;\n      if (!router_get_by_digest(hs_dir->identity_digest)) {\n        log_info(LD_REND, \"Not sending publish request for v2 descriptor to \"\n                          \"hidden service directory '%s'; we don't have its \"\n                          \"router descriptor. Queuing for later upload.\",\n                 hs_dir->nickname);\n        failed_upload = -1;\n        continue;\n      }\n      /* Send publish request. */\n      directory_initiate_command_routerstatus(hs_dir,\n                                              DIR_PURPOSE_UPLOAD_RENDDESC_V2,\n                                              ROUTER_PURPOSE_GENERAL,\n                                              1, NULL, desc->desc_str,\n                                              strlen(desc->desc_str), 0);\n      base32_encode(desc_id_base32, sizeof(desc_id_base32),\n                    desc->desc_id, DIGEST_LEN);\n      log_info(LD_REND, \"Sending publish request for v2 descriptor for \"\n                        \"service '%s' with descriptor ID '%s' with validity \"\n                        \"of %d seconds to hidden service directory '%s' on \"\n                        \"port %d.\",\n               safe_str(service_id),\n               safe_str(desc_id_base32),\n               seconds_valid,\n               hs_dir->nickname,\n               hs_dir->dir_port);\n      /* Remember successful upload to this router for next time. */\n      if (!smartlist_digest_isin(successful_uploads, hs_dir->identity_digest))\n        smartlist_add(successful_uploads, hs_dir->identity_digest);\n    }\n    smartlist_clear(responsible_dirs);\n  }\n  if (!failed_upload) {\n    if (renddesc->successful_uploads) {\n      SMARTLIST_FOREACH(renddesc->successful_uploads, char *, c, tor_free(c););\n      smartlist_free(renddesc->successful_uploads);\n      renddesc->successful_uploads = NULL;\n    }\n    renddesc->all_uploads_performed = 1;\n  } else {\n    /* Remember which routers worked this time, so that we don't upload the\n     * descriptor to them again. */\n    if (!renddesc->successful_uploads)\n      renddesc->successful_uploads = smartlist_create();\n    SMARTLIST_FOREACH(successful_uploads, const char *, c, {\n      if (!smartlist_digest_isin(renddesc->successful_uploads, c)) {\n        char *hsdir_id = tor_memdup(c, DIGEST_LEN);\n        smartlist_add(renddesc->successful_uploads, hsdir_id);\n      }\n    });\n  }\n  smartlist_free(responsible_dirs);\n  smartlist_free(successful_uploads);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Set *<b>out</b> to a newly allocated SOCKS4a resolve request with\n * <b>username</b> and <b>hostname</b> as provided.  Return the number\n * of bytes in the request. */\n", "func_signal": "static ssize_t\nbuild_socks_resolve_request(char **out,\n                            const char *username,\n                            const char *hostname,\n                            int reverse,\n                            int version)", "code": "{\n  size_t len = 0;\n  tor_assert(out);\n  tor_assert(username);\n  tor_assert(hostname);\n\n  if (version == 4) {\n    len = 8 + strlen(username) + 1 + strlen(hostname) + 1;\n    *out = tor_malloc(len);\n    (*out)[0] = 4;      /* SOCKS version 4 */\n    (*out)[1] = '\\xF0'; /* Command: resolve. */\n    set_uint16((*out)+2, htons(0)); /* port: 0. */\n    set_uint32((*out)+4, htonl(0x00000001u)); /* addr: 0.0.0.1 */\n    memcpy((*out)+8, username, strlen(username)+1);\n    memcpy((*out)+8+strlen(username)+1, hostname, strlen(hostname)+1);\n  } else if (version == 5) {\n    int is_ip_address;\n    struct in_addr in;\n    size_t addrlen;\n    is_ip_address = tor_inet_aton(hostname, &in);\n    if (!is_ip_address && reverse) {\n      log_err(LD_GENERAL, \"Tried to do a reverse lookup on a non-IP!\");\n      return -1;\n    }\n    addrlen = reverse ? 4 : 1 + strlen(hostname);\n    len = 6 + addrlen;\n    *out = tor_malloc(len);\n    (*out)[0] = 5; /* SOCKS version 5 */\n    (*out)[1] = reverse ? '\\xF1' : '\\xF0'; /* RESOLVE_PTR or RESOLVE */\n    (*out)[2] = 0; /* reserved. */\n    (*out)[3] = reverse ? 1 : 3;\n    if (reverse) {\n      set_uint32((*out)+4, in.s_addr);\n    } else {\n      (*out)[4] = (char)(uint8_t)(addrlen - 1);\n      memcpy((*out)+5, hostname, addrlen - 1);\n    }\n    set_uint16((*out)+4+addrlen, 0); /* port */\n  } else {\n    tor_assert(0);\n  }\n\n  return len;\n}", "path": "src\\tools\\tor-resolve.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Set up rend_service_list, based on the values of HiddenServiceDir and\n * HiddenServicePort in <b>options</b>.  Return 0 on success and -1 on\n * failure.  (If <b>validate_only</b> is set, parse, warn and return as\n * normal, but don't actually change the configured services.)\n */\n", "func_signal": "int\nrend_config_services(or_options_t *options, int validate_only)", "code": "{\n  config_line_t *line;\n  rend_service_t *service = NULL;\n  rend_service_port_config_t *portcfg;\n  smartlist_t *old_service_list = NULL;\n\n  if (!validate_only) {\n    old_service_list = rend_service_list;\n    rend_service_list = smartlist_create();\n  }\n\n  for (line = options->RendConfigLines; line; line = line->next) {\n    if (!strcasecmp(line->key, \"HiddenServiceDir\")) {\n      if (service) { /* register the one we just finished parsing */\n        if (validate_only)\n          rend_service_free(service);\n        else\n          rend_add_service(service);\n      }\n      service = tor_malloc_zero(sizeof(rend_service_t));\n      service->directory = tor_strdup(line->value);\n      service->ports = smartlist_create();\n      service->intro_period_started = time(NULL);\n      continue;\n    }\n    if (!service) {\n      log_warn(LD_CONFIG, \"%s with no preceding HiddenServiceDir directive\",\n               line->key);\n      rend_service_free(service);\n      return -1;\n    }\n    if (!strcasecmp(line->key, \"HiddenServicePort\")) {\n      portcfg = parse_port_config(line->value);\n      if (!portcfg) {\n        rend_service_free(service);\n        return -1;\n      }\n      smartlist_add(service->ports, portcfg);\n    } else if (!strcasecmp(line->key, \"HiddenServiceAuthorizeClient\")) {\n      /* Parse auth type and comma-separated list of client names and add a\n       * rend_authorized_client_t for each client to the service's list\n       * of authorized clients. */\n      smartlist_t *type_names_split, *clients;\n      const char *authname;\n      int num_clients;\n      if (service->auth_type != REND_NO_AUTH) {\n        log_warn(LD_CONFIG, \"Got multiple HiddenServiceAuthorizeClient \"\n                 \"lines for a single service.\");\n        rend_service_free(service);\n        return -1;\n      }\n      type_names_split = smartlist_create();\n      smartlist_split_string(type_names_split, line->value, \" \", 0, 2);\n      if (smartlist_len(type_names_split) < 1) {\n        log_warn(LD_BUG, \"HiddenServiceAuthorizeClient has no value. This \"\n                         \"should have been prevented when parsing the \"\n                         \"configuration.\");\n        smartlist_free(type_names_split);\n        rend_service_free(service);\n        return -1;\n      }\n      authname = smartlist_get(type_names_split, 0);\n      if (!strcasecmp(authname, \"basic\")) {\n        service->auth_type = REND_BASIC_AUTH;\n      } else if (!strcasecmp(authname, \"stealth\")) {\n        service->auth_type = REND_STEALTH_AUTH;\n      } else {\n        log_warn(LD_CONFIG, \"HiddenServiceAuthorizeClient contains \"\n                 \"unrecognized auth-type '%s'. Only 'basic' or 'stealth' \"\n                 \"are recognized.\",\n                 (char *) smartlist_get(type_names_split, 0));\n        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));\n        smartlist_free(type_names_split);\n        rend_service_free(service);\n        return -1;\n      }\n      service->clients = smartlist_create();\n      if (smartlist_len(type_names_split) < 2) {\n        log_warn(LD_CONFIG, \"HiddenServiceAuthorizeClient contains \"\n                            \"auth-type '%s', but no client names.\",\n                 service->auth_type == REND_BASIC_AUTH ? \"basic\" : \"stealth\");\n        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));\n        smartlist_free(type_names_split);\n        continue;\n      }\n      clients = smartlist_create();\n      smartlist_split_string(clients, smartlist_get(type_names_split, 1),\n                             \",\", SPLIT_SKIP_SPACE, 0);\n      SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));\n      smartlist_free(type_names_split);\n      /* Remove duplicate client names. */\n      num_clients = smartlist_len(clients);\n      smartlist_sort_strings(clients);\n      smartlist_uniq_strings(clients);\n      if (smartlist_len(clients) < num_clients) {\n        log_info(LD_CONFIG, \"HiddenServiceAuthorizeClient contains %d \"\n                            \"duplicate client name(s); removing.\",\n                 num_clients - smartlist_len(clients));\n        num_clients = smartlist_len(clients);\n      }\n      SMARTLIST_FOREACH_BEGIN(clients, const char *, client_name)\n      {\n        rend_authorized_client_t *client;\n        size_t len = strlen(client_name);\n        if (len < 1 || len > REND_CLIENTNAME_MAX_LEN) {\n          log_warn(LD_CONFIG, \"HiddenServiceAuthorizeClient contains an \"\n                              \"illegal client name: '%s'. Length must be \"\n                              \"between 1 and %d characters.\",\n                   client_name, REND_CLIENTNAME_MAX_LEN);\n          SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));\n          smartlist_free(clients);\n          rend_service_free(service);\n          return -1;\n        }\n        if (strspn(client_name, REND_LEGAL_CLIENTNAME_CHARACTERS) != len) {\n          log_warn(LD_CONFIG, \"HiddenServiceAuthorizeClient contains an \"\n                              \"illegal client name: '%s'. Valid \"\n                              \"characters are [A-Za-z0-9+-_].\",\n                   client_name);\n          SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));\n          smartlist_free(clients);\n          rend_service_free(service);\n          return -1;\n        }\n        client = tor_malloc_zero(sizeof(rend_authorized_client_t));\n        client->client_name = tor_strdup(client_name);\n        smartlist_add(service->clients, client);\n        log_debug(LD_REND, \"Adding client name '%s'\", client_name);\n      }\n      SMARTLIST_FOREACH_END(client_name);\n      SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));\n      smartlist_free(clients);\n      /* Ensure maximum number of clients. */\n      if ((service->auth_type == REND_BASIC_AUTH &&\n            smartlist_len(service->clients) > 512) ||\n          (service->auth_type == REND_STEALTH_AUTH &&\n            smartlist_len(service->clients) > 16)) {\n        log_warn(LD_CONFIG, \"HiddenServiceAuthorizeClient contains %d \"\n                            \"client authorization entries, but only a \"\n                            \"maximum of %d entries is allowed for \"\n                            \"authorization type '%s'.\",\n                 smartlist_len(service->clients),\n                 service->auth_type == REND_BASIC_AUTH ? 512 : 16,\n                 service->auth_type == REND_BASIC_AUTH ? \"basic\" : \"stealth\");\n        rend_service_free(service);\n        return -1;\n      }\n    } else {\n      tor_assert(!strcasecmp(line->key, \"HiddenServiceVersion\"));\n      if (strcmp(line->value, \"2\")) {\n        log_warn(LD_CONFIG,\n                 \"The only supported HiddenServiceVersion is 2.\");\n        rend_service_free(service);\n        return -1;\n      }\n    }\n  }\n  if (service) {\n    if (validate_only)\n      rend_service_free(service);\n    else\n      rend_add_service(service);\n  }\n\n  /* If this is a reload and there were hidden services configured before,\n   * keep the introduction points that are still needed and close the\n   * other ones. */\n  if (old_service_list && !validate_only) {\n    smartlist_t *surviving_services = smartlist_create();\n    circuit_t *circ;\n\n    /* Copy introduction points to new services. */\n    /* XXXX This is O(n^2), but it's only called on reconfigure, so it's\n     * probably ok? */\n    SMARTLIST_FOREACH(rend_service_list, rend_service_t *, new, {\n      SMARTLIST_FOREACH(old_service_list, rend_service_t *, old, {\n        if (!strcmp(old->directory, new->directory)) {\n          smartlist_add_all(new->intro_nodes, old->intro_nodes);\n          smartlist_clear(old->intro_nodes);\n          smartlist_add(surviving_services, old);\n          break;\n        }\n      });\n    });\n\n    /* Close introduction circuits of services we don't serve anymore. */\n    /* XXXX it would be nicer if we had a nicer abstraction to use here,\n     * so we could just iterate over the list of services to close, but\n     * once again, this isn't critical-path code. */\n    for (circ = _circuit_get_global_list(); circ; circ = circ->next) {\n      if (!circ->marked_for_close &&\n          circ->state == CIRCUIT_STATE_OPEN &&\n          (circ->purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO ||\n           circ->purpose == CIRCUIT_PURPOSE_S_INTRO)) {\n        origin_circuit_t *oc = TO_ORIGIN_CIRCUIT(circ);\n        int keep_it = 0;\n        tor_assert(oc->rend_data);\n        SMARTLIST_FOREACH(surviving_services, rend_service_t *, ptr, {\n          if (!memcmp(ptr->pk_digest, oc->rend_data->rend_pk_digest,\n                      DIGEST_LEN)) {\n            keep_it = 1;\n            break;\n          }\n        });\n        if (keep_it)\n          continue;\n        log_info(LD_REND, \"Closing intro point %s for service %s.\",\n                 safe_str(oc->build_state->chosen_exit->nickname),\n                 oc->rend_data->onion_address);\n        circuit_mark_for_close(circ, END_CIRC_REASON_FINISHED);\n        /* XXXX Is there another reason we should use here? */\n      }\n    }\n    smartlist_free(surviving_services);\n    SMARTLIST_FOREACH(old_service_list, rend_service_t *, ptr,\n                      rend_service_free(ptr));\n    smartlist_free(old_service_list);\n  }\n\n  return 0;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Helper: free storage held by a single service authorized client entry. */\n", "func_signal": "static void\nrend_authorized_client_free(rend_authorized_client_t *client)", "code": "{\n  if (!client) return;\n  if (client->client_key)\n    crypto_free_pk_env(client->client_key);\n  tor_free(client->client_name);\n  tor_free(client);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Called when we're done building a circuit to an introduction point:\n *  sends a RELAY_ESTABLISH_INTRO cell.\n */\n", "func_signal": "void\nrend_service_intro_has_opened(origin_circuit_t *circuit)", "code": "{\n  rend_service_t *service;\n  size_t len;\n  int r;\n  char buf[RELAY_PAYLOAD_SIZE];\n  char auth[DIGEST_LEN + 9];\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  int reason = END_CIRC_REASON_TORPROTOCOL;\n  crypto_pk_env_t *intro_key;\n\n  tor_assert(circuit->_base.purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO);\n  tor_assert(circuit->cpath);\n  tor_assert(circuit->rend_data);\n\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,\n                circuit->rend_data->rend_pk_digest, REND_SERVICE_ID_LEN);\n\n  service = rend_service_get_by_pk_digest(\n                circuit->rend_data->rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unrecognized service ID %s on introduction circuit %d.\",\n             serviceid, circuit->_base.n_circ_id);\n    reason = END_CIRC_REASON_NOSUCHSERVICE;\n    goto err;\n  }\n\n  /* If we already have enough introduction circuits for this service,\n   * redefine this one as a general circuit. */\n  if (count_established_intro_points(serviceid) > NUM_INTRO_POINTS) {\n    log_info(LD_CIRC|LD_REND, \"We have just finished an introduction \"\n             \"circuit, but we already have enough. Redefining purpose to \"\n             \"general.\");\n    TO_CIRCUIT(circuit)->purpose = CIRCUIT_PURPOSE_C_GENERAL;\n    circuit_has_opened(circuit);\n    return;\n  }\n\n  log_info(LD_REND,\n           \"Established circuit %d as introduction point for service %s\",\n           circuit->_base.n_circ_id, serviceid);\n\n  /* Use the intro key instead of the service key in ESTABLISH_INTRO. */\n  intro_key = circuit->intro_key;\n  /* Build the payload for a RELAY_ESTABLISH_INTRO cell. */\n  r = crypto_pk_asn1_encode(intro_key, buf+2,\n                            RELAY_PAYLOAD_SIZE-2);\n  if (r < 0) {\n    log_warn(LD_BUG, \"Internal error; failed to establish intro point.\");\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n  len = r;\n  set_uint16(buf, htons((uint16_t)len));\n  len += 2;\n  memcpy(auth, circuit->cpath->prev->handshake_digest, DIGEST_LEN);\n  memcpy(auth+DIGEST_LEN, \"INTRODUCE\", 9);\n  if (crypto_digest(buf+len, auth, DIGEST_LEN+9))\n    goto err;\n  len += 20;\n  note_crypto_pk_op(REND_SERVER);\n  r = crypto_pk_private_sign_digest(intro_key, buf+len, buf, len);\n  if (r<0) {\n    log_warn(LD_BUG, \"Internal error: couldn't sign introduction request.\");\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n  len += r;\n\n  if (relay_send_command_from_edge(0, TO_CIRCUIT(circuit),\n                                   RELAY_COMMAND_ESTABLISH_INTRO,\n                                   buf, len, circuit->cpath->prev)<0) {\n    log_info(LD_GENERAL,\n             \"Couldn't send introduction request for service %s on circuit %d\",\n             serviceid, circuit->_base.n_circ_id);\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n\n  return;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), reason);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Return the service whose public key has a digest of <b>digest</b>, or\n * NULL if no such service exists.\n */\n", "func_signal": "static rend_service_t *\nrend_service_get_by_pk_digest(const char* digest)", "code": "{\n  SMARTLIST_FOREACH(rend_service_list, rend_service_t*, s,\n                    if (!memcmp(s->pk_digest,digest,DIGEST_LEN))\n                        return s);\n  return NULL;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Parses a real-port to virtual-port mapping and returns a new\n * rend_service_port_config_t.\n *\n * The format is: VirtualPort (IP|RealPort|IP:RealPort)?\n *\n * IP defaults to 127.0.0.1; RealPort defaults to VirtualPort.\n */\n", "func_signal": "static rend_service_port_config_t *\nparse_port_config(const char *string)", "code": "{\n  smartlist_t *sl;\n  int virtport;\n  int realport;\n  uint16_t p;\n  tor_addr_t addr;\n  const char *addrport;\n  rend_service_port_config_t *result = NULL;\n\n  sl = smartlist_create();\n  smartlist_split_string(sl, string, \" \",\n                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  if (smartlist_len(sl) < 1 || smartlist_len(sl) > 2) {\n    log_warn(LD_CONFIG, \"Bad syntax in hidden service port configuration.\");\n    goto err;\n  }\n\n  virtport = (int)tor_parse_long(smartlist_get(sl,0), 10, 1, 65535, NULL,NULL);\n  if (!virtport) {\n    log_warn(LD_CONFIG, \"Missing or invalid port %s in hidden service port \"\n             \"configuration\", escaped(smartlist_get(sl,0)));\n    goto err;\n  }\n\n  if (smartlist_len(sl) == 1) {\n    /* No addr:port part; use default. */\n    realport = virtport;\n    tor_addr_from_ipv4h(&addr, 0x7F000001u); /* 127.0.0.1 */\n  } else {\n    addrport = smartlist_get(sl,1);\n    if (strchr(addrport, ':') || strchr(addrport, '.')) {\n      if (tor_addr_port_parse(addrport, &addr, &p)<0) {\n        log_warn(LD_CONFIG,\"Unparseable address in hidden service port \"\n                 \"configuration.\");\n        goto err;\n      }\n      realport = p?p:virtport;\n    } else {\n      /* No addr:port, no addr -- must be port. */\n      realport = (int)tor_parse_long(addrport, 10, 1, 65535, NULL, NULL);\n      if (!realport) {\n        log_warn(LD_CONFIG,\"Unparseable or out-of-range port %s in hidden \"\n                 \"service port configuration.\", escaped(addrport));\n        goto err;\n      }\n      tor_addr_from_ipv4h(&addr, 0x7F000001u); /* Default to 127.0.0.1 */\n    }\n  }\n\n  result = tor_malloc(sizeof(rend_service_port_config_t));\n  result->virtual_port = virtport;\n  result->real_port = realport;\n  tor_addr_copy(&result->real_addr, &addr);\n err:\n  SMARTLIST_FOREACH(sl, char *, c, tor_free(c));\n  smartlist_free(sl);\n  return result;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Check client authorization of a given <b>descriptor_cookie</b> for\n * <b>service</b>. Return 1 for success and 0 for failure. */\n", "func_signal": "static int\nrend_check_authorization(rend_service_t *service,\n                         const char *descriptor_cookie)", "code": "{\n  rend_authorized_client_t *auth_client = NULL;\n  tor_assert(service);\n  tor_assert(descriptor_cookie);\n  if (!service->clients) {\n    log_warn(LD_BUG, \"Can't check authorization for a service that has no \"\n                     \"authorized clients configured.\");\n    return 0;\n  }\n\n  /* Look up client authorization by descriptor cookie. */\n  SMARTLIST_FOREACH(service->clients, rend_authorized_client_t *, client, {\n    if (!memcmp(client->descriptor_cookie, descriptor_cookie,\n                REND_DESC_COOKIE_LEN)) {\n      auth_client = client;\n      break;\n    }\n  });\n  if (!auth_client) {\n    char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];\n    base64_encode(descriptor_cookie_base64, sizeof(descriptor_cookie_base64),\n                  descriptor_cookie, REND_DESC_COOKIE_LEN);\n    log_info(LD_REND, \"No authorization found for descriptor cookie '%s'! \"\n                      \"Dropping cell!\",\n             descriptor_cookie_base64);\n    return 0;\n  }\n\n  /* Allow the request. */\n  log_debug(LD_REND, \"Client %s authorized for service %s.\",\n            auth_client->client_name, service->service_id);\n  return 1;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Launch a circuit to serve as an introduction point for the service\n * <b>service</b> at the introduction point <b>nickname</b>\n */\n", "func_signal": "static int\nrend_service_launch_establish_intro(rend_service_t *service,\n                                    rend_intro_point_t *intro)", "code": "{\n  origin_circuit_t *launched;\n\n  log_info(LD_REND,\n           \"Launching circuit to introduction point %s for service %s\",\n           escaped_safe_str(intro->extend_info->nickname),\n           service->service_id);\n\n  rep_hist_note_used_internal(time(NULL), 1, 0);\n\n  ++service->n_intro_circuits_launched;\n  launched = circuit_launch_by_extend_info(CIRCUIT_PURPOSE_S_ESTABLISH_INTRO,\n                             intro->extend_info,\n                             CIRCLAUNCH_NEED_UPTIME|CIRCLAUNCH_IS_INTERNAL);\n\n  if (!launched) {\n    log_info(LD_REND,\n             \"Can't launch circuit to establish introduction at %s.\",\n             escaped_safe_str(intro->extend_info->nickname));\n    return -1;\n  }\n\n  if (memcmp(intro->extend_info->identity_digest,\n      launched->build_state->chosen_exit->identity_digest, DIGEST_LEN)) {\n    char cann[HEX_DIGEST_LEN+1], orig[HEX_DIGEST_LEN+1];\n    base16_encode(cann, sizeof(cann),\n                  launched->build_state->chosen_exit->identity_digest,\n                  DIGEST_LEN);\n    base16_encode(orig, sizeof(orig),\n                  intro->extend_info->identity_digest, DIGEST_LEN);\n    log_info(LD_REND, \"The intro circuit we just cannibalized ends at $%s, \"\n                      \"but we requested an intro circuit to $%s. Updating \"\n                      \"our service.\", cann, orig);\n    extend_info_free(intro->extend_info);\n    intro->extend_info = extend_info_dup(launched->build_state->chosen_exit);\n  }\n\n  launched->rend_data = tor_malloc_zero(sizeof(rend_data_t));\n  strlcpy(launched->rend_data->onion_address, service->service_id,\n          sizeof(launched->rend_data->onion_address));\n  memcpy(launched->rend_data->rend_pk_digest, service->pk_digest, DIGEST_LEN);\n  launched->intro_key = crypto_pk_dup_key(intro->intro_key);\n  if (launched->_base.state == CIRCUIT_STATE_OPEN)\n    rend_service_intro_has_opened(launched);\n  return 0;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Validate <b>service</b> and add it to rend_service_list if possible.\n */\n", "func_signal": "static void\nrend_add_service(rend_service_t *service)", "code": "{\n  int i;\n  rend_service_port_config_t *p;\n\n  service->intro_nodes = smartlist_create();\n\n  if (service->auth_type != REND_NO_AUTH &&\n      smartlist_len(service->clients) == 0) {\n    log_warn(LD_CONFIG, \"Hidden service with client authorization but no \"\n                        \"clients; ignoring.\");\n    rend_service_free(service);\n    return;\n  }\n\n  if (!smartlist_len(service->ports)) {\n    log_warn(LD_CONFIG, \"Hidden service with no ports configured; ignoring.\");\n    rend_service_free(service);\n  } else {\n    smartlist_add(rend_service_list, service);\n    log_debug(LD_REND,\"Configuring service with directory \\\"%s\\\"\",\n              service->directory);\n    for (i = 0; i < smartlist_len(service->ports); ++i) {\n      p = smartlist_get(service->ports, i);\n      log_debug(LD_REND,\"Service maps port %d to %s:%d\",\n                p->virtual_port, fmt_addr(&p->real_addr), p->real_port);\n    }\n  }\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Called when we fail building a rendezvous circuit at some point other\n * than the last hop: launches a new circuit to the same rendezvous point.\n */\n", "func_signal": "void\nrend_service_relaunch_rendezvous(origin_circuit_t *oldcirc)", "code": "{\n  origin_circuit_t *newcirc;\n  cpath_build_state_t *newstate, *oldstate;\n\n  tor_assert(oldcirc->_base.purpose == CIRCUIT_PURPOSE_S_CONNECT_REND);\n\n  if (!oldcirc->build_state ||\n      oldcirc->build_state->failure_count > MAX_REND_FAILURES ||\n      oldcirc->build_state->expiry_time < time(NULL)) {\n    log_info(LD_REND,\n             \"Attempt to build circuit to %s for rendezvous has failed \"\n             \"too many times or expired; giving up.\",\n             oldcirc->build_state ?\n               oldcirc->build_state->chosen_exit->nickname : \"*unknown*\");\n    return;\n  }\n\n  oldstate = oldcirc->build_state;\n  tor_assert(oldstate);\n\n  if (oldstate->pending_final_cpath == NULL) {\n    log_info(LD_REND,\"Skipping relaunch of circ that failed on its first hop. \"\n             \"Initiator will retry.\");\n    return;\n  }\n\n  log_info(LD_REND,\"Reattempting rendezvous circuit to '%s'\",\n           oldstate->chosen_exit->nickname);\n\n  newcirc = circuit_launch_by_extend_info(CIRCUIT_PURPOSE_S_CONNECT_REND,\n                            oldstate->chosen_exit,\n                            CIRCLAUNCH_NEED_CAPACITY|CIRCLAUNCH_IS_INTERNAL);\n\n  if (!newcirc) {\n    log_warn(LD_REND,\"Couldn't relaunch rendezvous circuit to '%s'.\",\n             oldstate->chosen_exit->nickname);\n    return;\n  }\n  newstate = newcirc->build_state;\n  tor_assert(newstate);\n  newstate->failure_count = oldstate->failure_count+1;\n  newstate->expiry_time = oldstate->expiry_time;\n  newstate->pending_final_cpath = oldstate->pending_final_cpath;\n  oldstate->pending_final_cpath = NULL;\n\n  newcirc->rend_data = rend_data_dup(oldcirc->rend_data);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Consider republication of v2 rendezvous service descriptors that failed\n * previously, but without regenerating descriptor contents.\n */\n", "func_signal": "void\nrend_consider_descriptor_republication(void)", "code": "{\n  int i;\n  rend_service_t *service;\n\n  if (!consider_republishing_rend_descriptors)\n    return;\n  consider_republishing_rend_descriptors = 0;\n\n  if (!get_options()->PublishHidServDescriptors)\n    return;\n\n  for (i=0; i < smartlist_len(rend_service_list); ++i) {\n    service = smartlist_get(rend_service_list, i);\n    if (service->desc && !service->desc->all_uploads_performed) {\n      /* If we failed in uploading a descriptor last time, try again *without*\n       * updating the descriptor's contents. */\n      upload_service_descriptor(service);\n    }\n  }\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Log the status of introduction points for all rendezvous services\n * at log severity <b>severity</b>.\n */\n", "func_signal": "void\nrend_service_dump_stats(int severity)", "code": "{\n  int i,j;\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  const char *safe_name;\n  origin_circuit_t *circ;\n\n  for (i=0; i < smartlist_len(rend_service_list); ++i) {\n    service = smartlist_get(rend_service_list, i);\n    log(severity, LD_GENERAL, \"Service configured in \\\"%s\\\":\",\n        service->directory);\n    for (j=0; j < smartlist_len(service->intro_nodes); ++j) {\n      intro = smartlist_get(service->intro_nodes, j);\n      safe_name = safe_str(intro->extend_info->nickname);\n\n      circ = find_intro_circuit(intro, service->pk_digest);\n      if (!circ) {\n        log(severity, LD_GENERAL, \"  Intro point %d at %s: no circuit\",\n            j, safe_name);\n        continue;\n      }\n      log(severity, LD_GENERAL, \"  Intro point %d at %s: circuit is %s\",\n          j, safe_name, circuit_state_to_string(circ->_base.state));\n    }\n  }\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** For every service, check how many intro points it currently has, and:\n *  - Pick new intro points as necessary.\n *  - Launch circuits to any new intro points.\n */\n", "func_signal": "void\nrend_services_introduce(void)", "code": "{\n  int i,j,r;\n  routerinfo_t *router;\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  int changed, prev_intro_nodes;\n  smartlist_t *intro_routers;\n  time_t now;\n  or_options_t *options = get_options();\n\n  intro_routers = smartlist_create();\n  now = time(NULL);\n\n  for (i=0; i < smartlist_len(rend_service_list); ++i) {\n    smartlist_clear(intro_routers);\n    service = smartlist_get(rend_service_list, i);\n\n    tor_assert(service);\n    changed = 0;\n    if (now > service->intro_period_started+INTRO_CIRC_RETRY_PERIOD) {\n      /* One period has elapsed; we can try building circuits again. */\n      service->intro_period_started = now;\n      service->n_intro_circuits_launched = 0;\n    } else if (service->n_intro_circuits_launched >=\n               MAX_INTRO_CIRCS_PER_PERIOD) {\n      /* We have failed too many times in this period; wait for the next\n       * one before we try again. */\n      continue;\n    }\n\n    /* Find out which introduction points we have in progress for this\n       service. */\n    for (j=0; j < smartlist_len(service->intro_nodes); ++j) {\n      intro = smartlist_get(service->intro_nodes, j);\n      router = router_get_by_digest(intro->extend_info->identity_digest);\n      if (!router || !find_intro_circuit(intro, service->pk_digest)) {\n        log_info(LD_REND,\"Giving up on %s as intro point for %s.\",\n                 intro->extend_info->nickname, service->service_id);\n        if (service->desc) {\n          SMARTLIST_FOREACH(service->desc->intro_nodes, rend_intro_point_t *,\n                            dintro, {\n            if (!memcmp(dintro->extend_info->identity_digest,\n                intro->extend_info->identity_digest, DIGEST_LEN)) {\n              log_info(LD_REND, \"The intro point we are giving up on was \"\n                                \"included in the last published descriptor. \"\n                                \"Marking current descriptor as dirty.\");\n              service->desc_is_dirty = now;\n            }\n          });\n        }\n        rend_intro_point_free(intro);\n        smartlist_del(service->intro_nodes,j--);\n        changed = 1;\n      }\n      if (router)\n        smartlist_add(intro_routers, router);\n    }\n\n    /* We have enough intro points, and the intro points we thought we had were\n     * all connected.\n     */\n    if (!changed && smartlist_len(service->intro_nodes) >= NUM_INTRO_POINTS) {\n      /* We have all our intro points! Start a fresh period and reset the\n       * circuit count. */\n      service->intro_period_started = now;\n      service->n_intro_circuits_launched = 0;\n      continue;\n    }\n\n    /* Remember how many introduction circuits we started with. */\n    prev_intro_nodes = smartlist_len(service->intro_nodes);\n    /* We have enough directory information to start establishing our\n     * intro points. We want to end up with three intro points, but if\n     * we're just starting, we launch five and pick the first three that\n     * complete.\n     *\n     * The ones after the first three will be converted to 'general'\n     * internal circuits in rend_service_intro_has_opened(), and then\n     * we'll drop them from the list of intro points next time we\n     * go through the above \"find out which introduction points we have\n     * in progress\" loop. */\n#define NUM_INTRO_POINTS_INIT (NUM_INTRO_POINTS + 2)\n    for (j=prev_intro_nodes; j < (prev_intro_nodes == 0 ?\n             NUM_INTRO_POINTS_INIT : NUM_INTRO_POINTS); ++j) {\n      router_crn_flags_t flags = CRN_NEED_UPTIME;\n      if (get_options()->_AllowInvalid & ALLOW_INVALID_INTRODUCTION)\n        flags |= CRN_ALLOW_INVALID;\n      router = router_choose_random_node(NULL, intro_routers,\n                                         options->ExcludeNodes, flags);\n      if (!router) {\n        log_warn(LD_REND,\n                 \"Could only establish %d introduction points for %s.\",\n                 smartlist_len(service->intro_nodes), service->service_id);\n        break;\n      }\n      changed = 1;\n      smartlist_add(intro_routers, router);\n      intro = tor_malloc_zero(sizeof(rend_intro_point_t));\n      intro->extend_info = extend_info_from_router(router);\n      intro->intro_key = crypto_new_pk_env();\n      tor_assert(!crypto_pk_generate_key(intro->intro_key));\n      smartlist_add(service->intro_nodes, intro);\n      log_info(LD_REND, \"Picked router %s as an intro point for %s.\",\n               router->nickname, service->service_id);\n    }\n\n    /* If there's no need to launch new circuits, stop here. */\n    if (!changed)\n      continue;\n\n    /* Establish new introduction points. */\n    for (j=prev_intro_nodes; j < smartlist_len(service->intro_nodes); ++j) {\n      intro = smartlist_get(service->intro_nodes, j);\n      r = rend_service_launch_establish_intro(service, intro);\n      if (r<0) {\n        log_warn(LD_REND, \"Error launching circuit to node %s for service %s.\",\n                 intro->extend_info->nickname, service->service_id);\n      }\n    }\n  }\n  smartlist_free(intro_routers);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Called once a circuit to a rendezvous point is established: sends a\n *  RELAY_COMMAND_RENDEZVOUS1 cell.\n */\n", "func_signal": "void\nrend_service_rendezvous_has_opened(origin_circuit_t *circuit)", "code": "{\n  rend_service_t *service;\n  char buf[RELAY_PAYLOAD_SIZE];\n  crypt_path_t *hop;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  char hexcookie[9];\n  int reason;\n\n  tor_assert(circuit->_base.purpose == CIRCUIT_PURPOSE_S_CONNECT_REND);\n  tor_assert(circuit->cpath);\n  tor_assert(circuit->build_state);\n  tor_assert(circuit->rend_data);\n  hop = circuit->build_state->pending_final_cpath;\n  tor_assert(hop);\n\n  base16_encode(hexcookie,9,circuit->rend_data->rend_cookie,4);\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,\n                circuit->rend_data->rend_pk_digest, REND_SERVICE_ID_LEN);\n\n  log_info(LD_REND,\n           \"Done building circuit %d to rendezvous with \"\n           \"cookie %s for service %s\",\n           circuit->_base.n_circ_id, hexcookie, serviceid);\n\n  service = rend_service_get_by_pk_digest(\n                circuit->rend_data->rend_pk_digest);\n  if (!service) {\n    log_warn(LD_GENERAL, \"Internal error: unrecognized service ID on \"\n             \"introduction circuit.\");\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n\n  /* All we need to do is send a RELAY_RENDEZVOUS1 cell... */\n  memcpy(buf, circuit->rend_data->rend_cookie, REND_COOKIE_LEN);\n  if (crypto_dh_get_public(hop->dh_handshake_state,\n                           buf+REND_COOKIE_LEN, DH_KEY_LEN)<0) {\n    log_warn(LD_GENERAL,\"Couldn't get DH public key.\");\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n  memcpy(buf+REND_COOKIE_LEN+DH_KEY_LEN, hop->handshake_digest,\n         DIGEST_LEN);\n\n  /* Send the cell */\n  if (relay_send_command_from_edge(0, TO_CIRCUIT(circuit),\n                                   RELAY_COMMAND_RENDEZVOUS1,\n                                   buf, REND_COOKIE_LEN+DH_KEY_LEN+DIGEST_LEN,\n                                   circuit->cpath->prev)<0) {\n    log_warn(LD_GENERAL, \"Couldn't send RENDEZVOUS1 cell.\");\n    reason = END_CIRC_REASON_INTERNAL;\n    goto err;\n  }\n\n  crypto_dh_free(hop->dh_handshake_state);\n  hop->dh_handshake_state = NULL;\n\n  /* Append the cpath entry. */\n  hop->state = CPATH_STATE_OPEN;\n  /* set the windows to default. these are the windows\n   * that bob thinks alice has.\n   */\n  hop->package_window = circuit_initial_package_window();\n  hop->deliver_window = CIRCWINDOW_START;\n\n  onion_append_to_cpath(&circuit->cpath, hop);\n  circuit->build_state->pending_final_cpath = NULL; /* prevent double-free */\n\n  /* Change the circuit purpose. */\n  circuit->_base.purpose = CIRCUIT_PURPOSE_S_REND_JOINED;\n\n  return;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), reason);\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Encode and sign an up-to-date service descriptor for <b>service</b>,\n * and upload it/them to the responsible hidden service directories.\n */\n", "func_signal": "static void\nupload_service_descriptor(rend_service_t *service)", "code": "{\n  time_t now = time(NULL);\n  int rendpostperiod;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  int uploaded = 0;\n\n  rendpostperiod = get_options()->RendPostPeriod;\n\n  /* Upload descriptor? */\n  if (get_options()->PublishHidServDescriptors) {\n    networkstatus_t *c = networkstatus_get_latest_consensus();\n    if (c && smartlist_len(c->routerstatus_list) > 0) {\n      int seconds_valid, i, j, num_descs;\n      smartlist_t *descs = smartlist_create();\n      smartlist_t *client_cookies = smartlist_create();\n      /* Either upload a single descriptor (including replicas) or one\n       * descriptor for each authorized client in case of authorization\n       * type 'stealth'. */\n      num_descs = service->auth_type == REND_STEALTH_AUTH ?\n                      smartlist_len(service->clients) : 1;\n      for (j = 0; j < num_descs; j++) {\n        crypto_pk_env_t *client_key = NULL;\n        rend_authorized_client_t *client = NULL;\n        smartlist_clear(client_cookies);\n        switch (service->auth_type) {\n          case REND_NO_AUTH:\n            /* Do nothing here. */\n            break;\n          case REND_BASIC_AUTH:\n            SMARTLIST_FOREACH(service->clients, rend_authorized_client_t *,\n                cl, smartlist_add(client_cookies, cl->descriptor_cookie));\n            break;\n          case REND_STEALTH_AUTH:\n            client = smartlist_get(service->clients, j);\n            client_key = client->client_key;\n            smartlist_add(client_cookies, client->descriptor_cookie);\n            break;\n        }\n        /* Encode the current descriptor. */\n        seconds_valid = rend_encode_v2_descriptors(descs, service->desc,\n                                                   now, 0,\n                                                   service->auth_type,\n                                                   client_key,\n                                                   client_cookies);\n        if (seconds_valid < 0) {\n          log_warn(LD_BUG, \"Internal error: couldn't encode service \"\n                   \"descriptor; not uploading.\");\n          smartlist_free(descs);\n          smartlist_free(client_cookies);\n          return;\n        }\n        /* Post the current descriptors to the hidden service directories. */\n        rend_get_service_id(service->desc->pk, serviceid);\n        log_info(LD_REND, \"Sending publish request for hidden service %s\",\n                     serviceid);\n        directory_post_to_hs_dir(service->desc, descs, serviceid,\n                                 seconds_valid);\n        /* Free memory for descriptors. */\n        for (i = 0; i < smartlist_len(descs); i++)\n          rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));\n        smartlist_clear(descs);\n        /* Update next upload time. */\n        if (seconds_valid - REND_TIME_PERIOD_OVERLAPPING_V2_DESCS\n            > rendpostperiod)\n          service->next_upload_time = now + rendpostperiod;\n        else if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS)\n          service->next_upload_time = now + seconds_valid + 1;\n        else\n          service->next_upload_time = now + seconds_valid -\n              REND_TIME_PERIOD_OVERLAPPING_V2_DESCS + 1;\n        /* Post also the next descriptors, if necessary. */\n        if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS) {\n          seconds_valid = rend_encode_v2_descriptors(descs, service->desc,\n                                                     now, 1,\n                                                     service->auth_type,\n                                                     client_key,\n                                                     client_cookies);\n          if (seconds_valid < 0) {\n            log_warn(LD_BUG, \"Internal error: couldn't encode service \"\n                     \"descriptor; not uploading.\");\n            smartlist_free(descs);\n            smartlist_free(client_cookies);\n            return;\n          }\n          directory_post_to_hs_dir(service->desc, descs, serviceid,\n                                   seconds_valid);\n          /* Free memory for descriptors. */\n          for (i = 0; i < smartlist_len(descs); i++)\n            rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));\n          smartlist_clear(descs);\n        }\n      }\n      smartlist_free(descs);\n      smartlist_free(client_cookies);\n      uploaded = 1;\n      log_info(LD_REND, \"Successfully uploaded v2 rend descriptors!\");\n    }\n  }\n\n  /* If not uploaded, try again in one minute. */\n  if (!uploaded)\n    service->next_upload_time = now + 60;\n\n  /* Unmark dirty flag of this service. */\n  service->desc_is_dirty = 0;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Replace the old value of <b>service</b>-\\>desc with one that reflects\n * the other fields in service.\n */\n", "func_signal": "static void\nrend_service_update_descriptor(rend_service_t *service)", "code": "{\n  rend_service_descriptor_t *d;\n  origin_circuit_t *circ;\n  int i;\n  if (service->desc) {\n    rend_service_descriptor_free(service->desc);\n    service->desc = NULL;\n  }\n  d = service->desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));\n  d->pk = crypto_pk_dup_key(service->private_key);\n  d->timestamp = time(NULL);\n  d->intro_nodes = smartlist_create();\n  /* Support intro protocols 2 and 3. */\n  d->protocols = (1 << 2) + (1 << 3);\n\n  for (i = 0; i < smartlist_len(service->intro_nodes); ++i) {\n    rend_intro_point_t *intro_svc = smartlist_get(service->intro_nodes, i);\n    rend_intro_point_t *intro_desc;\n    circ = find_intro_circuit(intro_svc, service->pk_digest);\n    if (!circ || circ->_base.purpose != CIRCUIT_PURPOSE_S_INTRO)\n      continue;\n\n    /* We have an entirely established intro circuit. */\n    intro_desc = tor_malloc_zero(sizeof(rend_intro_point_t));\n    intro_desc->extend_info = extend_info_dup(intro_svc->extend_info);\n    if (intro_svc->intro_key)\n      intro_desc->intro_key = crypto_pk_dup_key(intro_svc->intro_key);\n    smartlist_add(d->intro_nodes, intro_desc);\n  }\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Return the number of introduction points that are or have been\n * established for the given service address in <b>query</b>. */\n", "func_signal": "static int\ncount_established_intro_points(const char *query)", "code": "{\n  int num_ipos = 0;\n  circuit_t *circ;\n  for (circ = _circuit_get_global_list(); circ; circ = circ->next) {\n    if (!circ->marked_for_close &&\n        circ->state == CIRCUIT_STATE_OPEN &&\n        (circ->purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO ||\n         circ->purpose == CIRCUIT_PURPOSE_S_INTRO)) {\n      origin_circuit_t *oc = TO_ORIGIN_CIRCUIT(circ);\n      if (oc->rend_data &&\n          !rend_cmp_service_ids(query, oc->rend_data->onion_address))\n        num_ipos++;\n    }\n  }\n  return num_ipos;\n}", "path": "src\\or\\rendservice.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/** Given a <b>len</b>-byte SOCKS4a response in <b>response</b>, set\n * *<b>addr_out</b> to the address it contains (in host order).\n * Return 0 on success, -1 on error.\n */\n", "func_signal": "static int\nparse_socks4a_resolve_response(const char *hostname,\n                               const char *response, size_t len,\n                               uint32_t *addr_out)", "code": "{\n  uint8_t status;\n  tor_assert(response);\n  tor_assert(addr_out);\n\n  if (len < RESPONSE_LEN_4) {\n    log_warn(LD_PROTOCOL,\"Truncated socks response.\");\n    return -1;\n  }\n  if (((uint8_t)response[0])!=0) { /* version: 0 */\n    log_warn(LD_PROTOCOL,\"Nonzero version in socks response: bad format.\");\n    return -1;\n  }\n  status = (uint8_t)response[1];\n  if (get_uint16(response+2)!=0) { /* port: 0 */\n    log_warn(LD_PROTOCOL,\"Nonzero port in socks response: bad format.\");\n    return -1;\n  }\n  if (status != 90) {\n    log_warn(LD_NET,\"Got status response '%d': socks request failed.\", status);\n    if (!strcasecmpend(hostname, \".onion\")) {\n      log_warn(LD_NET,\n        \"%s is a hidden service; those don't have IP addresses. \"\n        \"To connect to a hidden service, you need to send the hostname \"\n        \"to Tor; we suggest an application that uses SOCKS 4a.\",hostname);\n      return -1;\n    }\n    return -1;\n  }\n\n  *addr_out = ntohl(get_uint32(response+4));\n  return 0;\n}", "path": "src\\tools\\tor-resolve.c", "repo_name": "pruby/Tor-Mirror", "stars": 2, "license": "other", "language": "c", "size": 23192}
{"docstring": "/**********\n\n   Take a line of the form \"TAG=value string\", parse it, convert the\n   value to UTF-8, and add it to the\n   Error checking is performed (return 0 if OK, negative on error).\n\n   Note that this assumes a null-terminated string, which may cause\n   problems with > 8-bit character sets!\n\n***********/\n", "func_signal": "int  add_comment(char *line, vorbis_comment *vc, int raw, int escapes)", "code": "{\n\tchar *mark, *value, *utf8_value, *unescaped_value;\n\tint unescaped_len;\n\n\t/* strip any terminal newline */\n\t{\n\t\tint len = strlen(line);\n\t\tif (line[len-1] == '\\n') line[len-1] = '\\0';\n\t}\n\n\t/* validation: basically, we assume it's a tag\n\t * if it has an '=' after one or more valid characters,\n\t * as the comment spec requires. For the moment, we\n\t * also restrict ourselves to 0-terminated values */\n\n\tmark = strchr(line, '=');\n\tif (mark == NULL) return -1;\n\n\tvalue = line;\n\twhile (value < mark) {\n\t\tif(*value < 0x20 || *value > 0x7d || *value == 0x3d) return -1;\n\t\tvalue++;\n\t}\n\n\t/* split the line by turning the '=' in to a null */\n\t*mark = '\\0';\t\n\tvalue++;\n\n\tif (raw) {\n\t\tif (!utf8_validate(value)) {\n\t\t\tfprintf(stderr, _(\"'%s' is not valid UTF-8, cannot add\\n\"), line);\n\t\t\treturn -1;\n\t\t}\n\t\tutf8_value = value;\n\t} else {\n\t\t/* convert the value from the native charset to UTF-8 */\n\t\tif (utf8_encode(value, &utf8_value) < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"Couldn't convert comment to UTF-8, cannot add\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (escapes) {\n\t\tunescaped_value = unescape(utf8_value, &unescaped_len);\n\t\t/*\n\t\t  NOTE: unescaped_len remains unused; to write comments with embeded\n\t\t  \\0's one would need to access the vc struct directly -- see\n\t\t  vorbis_comment_add() in vorbis/lib/info.c for details, but use mem*\n\t\t  instead of str*...\n\t\t*/\n\t\tif(unescaped_value == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"Couldn't un-escape comment, cannot add\\n\"));\n\t\t\tif (!raw)\n\t\t\t\tfree(utf8_value);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tunescaped_value = utf8_value;\n\t}\n\n\t/* append the comment and return */\n\tvorbis_comment_add_tag(vc, line, unescaped_value);\n\tif (escapes)\n\t\tfree(unescaped_value);\n\tif (!raw)\n\t\tfree(utf8_value);\n\treturn 0;\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n\n   Convert raw comment content to a safely escaped single-line 0-terminated\n   string.  The raw comment can contain null bytes and thus requires an\n   explicit size argument.  The size argument doesn't include a trailing '\\0'\n   (the vorbis bitstream doesn't use one).\n\n   Returns the address of a newly allocated string - caller is responsible to\n   free it.\n\n***********/\n", "func_signal": "char *escape(const char *from, int fromsize)", "code": "{\n\t/* worst-case allocation, will be trimmed when done */\n\tchar *to = malloc(fromsize * 2 + 1);\n\n\tchar *s;\n\tfor (s = to; fromsize > 0; fromsize--, from++) {\n\t\tswitch (*from) {\n\t\tcase '\\n':\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = 'n';\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = 'r';\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0';\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '\\\\';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* normal character */\n\t\t\t*s++ = *from;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t*s++ = '\\0';\n\tto = realloc(to, s - to);\t/* free unused space */\n\treturn to;\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n   parse_options()\n\n   This function takes care of parsing the command line options\n   with getopt() and fills out the param struct with the mode,\n   flags, and filenames.\n\n***********/\n", "func_signal": "void parse_options(int argc, char *argv[], param_t *param)", "code": "{\n\tint ret;\n\tint option_index = 1;\n\n\tsetlocale(LC_ALL, \"\");\n\n\twhile ((ret = getopt_long(argc, argv, \"alwhqVc:t:Re\",\n\t\t\tlong_options, &option_index)) != -1) {\n\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(stderr, _(\"Internal error parsing command options\\n\"));\n\t\t\t\texit(1);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tparam->mode = MODE_LIST;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tparam->raw = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tparam->escapes = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tparam->mode = MODE_WRITE;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tparam->mode = MODE_APPEND;\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\tfprintf(stderr, _(\"vorbiscomment from vorbis-tools \" VERSION \"\\n\"));\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tusage();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t/* set quiet flag: unused */\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tparam->commentfilename = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tparam->comments = realloc(param->comments, \n\t\t\t\t\t\t(param->commentcount+1)*sizeof(char *));\n\t\t\t\tparam->comments[param->commentcount++] = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tusage();\n\t\t\t\texit(1);\n\t\t}\n\t}\n\n\t/* remaining bits must be the filenames */\n\tif((param->mode == MODE_LIST && (argc-optind) != 1) ||\n\t   ((param->mode == MODE_WRITE || param->mode == MODE_APPEND) &&\n\t   ((argc-optind) < 1 || (argc-optind) > 2))) {\n\t\t\tusage();\n\t\t\texit(1);\n\t}\n\n\tparam->infilename = strdup(argv[optind]);\n\tif (param->mode == MODE_WRITE || param->mode == MODE_APPEND)\n\t{\n\t\tif(argc-optind == 1)\n\t\t{\n\t\t\tparam->tempoutfile = 1;\n\t\t\tparam->outfilename = malloc(strlen(param->infilename)+8);\n\t\t\tstrcpy(param->outfilename, param->infilename);\n\t\t\tstrcat(param->outfilename, \".vctemp\");\n\t\t}\n\t\telse\n\t\t\tparam->outfilename = strdup(argv[optind+1]);\n\t}\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n\n   allocate and initialize a the parameter struct\n\n***********/\n", "func_signal": "param_t *new_param(void)", "code": "{\n\tparam_t *param = (param_t *)malloc(sizeof(param_t));\n\n\t/* mode and flags */\n\tparam->mode = MODE_LIST;\n\tparam->raw = 0;\n\tparam->escapes = 0;\n\n\t/* filenames */\n\tparam->infilename  = NULL;\n\tparam->outfilename = NULL;\n\tparam->commentfilename = \"-\";\t/* default */\n\n\t/* file pointers */\n\tparam->in = param->out = NULL;\n\tparam->com = NULL;\n\tparam->tempoutfile=0;\n\n\t/* comments */\n\tparam->commentcount=0;\n\tparam->comments=NULL;\n\n\treturn param;\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Defines the so called `hashpjw' function by P.J. Weinberger\n   [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,\n   1986, 1987 Bell Telephone Laboratories, Inc.]  */\n", "func_signal": "unsigned long int\n__hash_string (const char *str_param)", "code": "{\n  unsigned long int hval, g;\n  const char *str = str_param;\n\n  /* Compute the hash value for the given string.  */\n  hval = 0;\n  while (*str != '\\0')\n    {\n      hval <<= 4;\n      hval += (unsigned char) *str++;\n      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));\n      if (g != 0)\n\t{\n\t  hval ^= g >> (HASHWORDBITS - 8);\n\t  hval ^= g;\n\t}\n    }\n  return hval;\n}", "path": "intl\\hash-string.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Add this filename to the playlist.  Filename will be strdup()'ed.  Note\n   that this function will never fail. */\n", "func_signal": "int playlist_append_file(playlist_t *list, char *filename)", "code": "{\n  list->last->next = playlist_element_create(filename);\n  list->last = list->last->next;\n\n  return 1; /* No way to fail */\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Opens a file containing filenames, one per line, and adds them to the\n   playlist */\n", "func_signal": "int playlist_append_from_file(playlist_t *list, char *playlist_filename)", "code": "{\n  FILE *fp;\n  char filename[NAME_MAX+1];\n  struct stat stat_buf;\n  int length;\n  int i;\n\n  if (strcmp(playlist_filename, \"-\") == 0)\n    fp = stdin;\n  else\n    fp = fopen(playlist_filename, \"r\");\n\n  if (fp == NULL)\n    return 0;\n\n  while (!feof(fp)) {\n\n    if ( fgets(filename, NAME_MAX+1 /* no, really! */, fp) == NULL )\n      continue;\n\n    filename[NAME_MAX] = '\\0'; /* Just to make sure */\n    length = strlen(filename);\n\n    /* Skip blank lines */\n    for (i = 0; i < length && isspace(filename[i]); i++);\n    if (i == length)\n      continue;\n\n    /* Crop off trailing newlines if present. Handle DOS (\\r\\n), Unix (\\n)\n     * and MacOS<9 (\\r) line endings. */\n    if (filename[length - 2] == '\\r' && filename[length - 1] == '\\n')\n      filename[length - 2] = '\\0';\n    else if (filename[length - 1] == '\\n' || filename[length - 1] == '\\r')\n      filename[length - 1] = '\\0';\n\n    if (stat(filename, &stat_buf) == 0) {\n\n      if (S_ISDIR(stat_buf.st_mode)) {\n\tif (playlist_append_directory(list, filename) == 0)\n\t  fprintf(stderr, \n\t\t  _(\"Warning from playlist %s: \"\n\t\t    \"Could not read directory %s.\\n\"), playlist_filename,\n\t\t  filename);\n      } else {\n\tplaylist_append_file(list, filename);\n      }\n    } else /* If we can't stat it, it might be a non-disk source */\n      playlist_append_file(list, filename);\n\n  }\n\n  return 1;\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/*\n * Adds the fishead packets in the skeleton output stream\n */\n", "func_signal": "static void add_vorbis_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt)", "code": "{\n\n   fisbone_packet fp;\n\n   memset(&fp, 0, sizeof(fp));\n   fp.serial_no = opt->serialno;\n   fp.nr_header_packet = 3;\n   fp.granule_rate_n = opt->rate;\n   fp.granule_rate_d = 1;\n   fp.start_granule = 0;\n   fp.preroll = 2;\n   fp.granule_shift = 0;\n\n   add_message_header_field(&fp, \"Content-Type\", \"audio/vorbis\");\n\n   add_fisbone_to_stream(os, &fp);\n}", "path": "oggenc\\encode.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n   main.c\n\n   This is the main function where options are read and written\n   you should be able to just read this function and see how\n   to call the vcedit routines. Details of how to pack/unpack the\n   vorbis_comment structure itself are in the following two routines.\n   The rest of the file is ui dressing so make the program minimally\n   useful as a command line utility and can generally be ignored.\n\n***********/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tvcedit_state *state;\n\tvorbis_comment *vc;\n\tparam_t\t*param;\n\tint i;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\n\t/* initialize the cmdline interface */\n\tparam = new_param();\n\tparse_options(argc, argv, param);\n\n\t/* take care of opening the requested files */\n\t/* relevent file pointers are returned in the param struct */\n\topen_files(param);\n\n\t/* which mode are we in? */\n\n\tif (param->mode == MODE_LIST) {\n\t\t\n\t\tstate = vcedit_new_state();\n\n\t\tif(vcedit_open(state, param->in) < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"Failed to open file as Vorbis: %s\\n\"), \n\t\t\t\t\tvcedit_error(state));\n            close_files(param, 0);\n            free_param(param);\n            vcedit_clear(state);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* extract and display the comments */\n\t\tvc = vcedit_comments(state);\n\t\tprint_comments(param->com, vc, param->raw, param->escapes);\n\n\t\t/* done */\n\t\tvcedit_clear(state);\n\n\t\tclose_files(param, 0);\n        free_param(param);\n\t\treturn 0;\t\t\n\t}\n\n\tif (param->mode == MODE_WRITE || param->mode == MODE_APPEND) {\n\n\t\tstate = vcedit_new_state();\n\n\t\tif(vcedit_open(state, param->in) < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"Failed to open file as Vorbis: %s\\n\"), \n\t\t\t\t\tvcedit_error(state));\n\t\t\tclose_files(param, 0);\n\t\t\tfree_param(param);\n\t\t\tvcedit_clear(state);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* grab and clear the exisiting comments */\n\t\tvc = vcedit_comments(state);\n\t\tif(param->mode != MODE_APPEND) \n\t\t{\n\t\t\tvorbis_comment_clear(vc);\n\t\t\tvorbis_comment_init(vc);\n\t\t}\n\n\t\tfor(i=0; i < param->commentcount; i++)\n\t\t{\n\t\t\tif (add_comment(param->comments[i], vc,\n\t\t\t\t\tparam->raw, param->escapes) < 0)\n\t\t\t\tfprintf(stderr, _(\"Bad comment: \\\"%s\\\"\\n\"), param->comments[i]);\n\t\t}\n\n\t\t/* build the replacement structure */\n\t\tif(param->commentcount==0)\n\t\t{\n\t\t\tchar *comment;\n\n\t\t\twhile ((comment = read_line (param->com)))\n                        {\n                                if (add_comment(comment, vc, param->raw, param->escapes) < 0)\n                                {\n                                        fprintf (stderr, _(\"bad comment: \\\"%s\\\"\\n\"),\n                                                 comment);\n                                }\n                                free (comment);\n                        }\n\t\t}\n\n\t\t/* write out the modified stream */\n\t\tif(vcedit_write(state, param->out) < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"Failed to write comments to output file: %s\\n\"), \n\t\t\t\t\tvcedit_error(state));\n\t\t\tclose_files(param, 0);\n\t\t\tfree_param(param);\n\t\t\tvcedit_clear(state);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* done */\n\t\tvcedit_clear(state);\n\t\t\n\t\tclose_files(param, 1);\n\t\tfree_param(param);\n\t\treturn 0;\n\t}\n\n\t/* should never reach this point */\n\tfprintf(stderr, _(\"no action specified\\n\"));\n    free_param(param);\n\treturn 1;\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Return the number of items in the playlist */\n", "func_signal": "int playlist_length(playlist_t *list)", "code": "{\n  int length;\n  playlist_element_t *element;\n\n  element = list->head;\n  length = 0; /* don't count head node */\n  while (element->next != NULL) {\n    length++;\n    element = element->next;\n  }\n\n  return length;\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n   close_files()\n\n   Do some quick clean-up.\n\n***********/\n", "func_signal": "void close_files(param_t *p, int output_written)", "code": "{\n  if (p->in != NULL && p->in != stdin) fclose(p->in);\n  if (p->out != NULL && p->out != stdout) fclose(p->out);\n  if (p->com != NULL && p->com != stdout && p->com != stdin) fclose(p->com);\n\n  if(p->tempoutfile) {\n#if HAVE_STAT && HAVE_CHMOD\n    struct stat st;\n    stat (p->infilename, &st);\n#endif\n\n    if(output_written) {\n      /* Some platforms fail to rename a file if the new name already \n       * exists, so we need to remove, then rename. How stupid.\n       */\n      if(rename(p->outfilename, p->infilename)) {\n        if(remove(p->infilename))\n          fprintf(stderr, _(\"Error removing old file %s\\n\"), p->infilename);\n        else if(rename(p->outfilename, p->infilename)) \n          fprintf(stderr, _(\"Error renaming %s to %s\\n\"), p->outfilename, \n                  p->infilename);\n      } else {\n#if HAVE_STAT && HAVE_CHMOD\n        chmod (p->infilename, st.st_mode);\n#endif\n      }\n    }\n    else {\n      if(remove(p->outfilename)) {\n        fprintf(stderr, _(\"Error removing erroneous temporary file %s\\n\"), \n                    p->outfilename);\n      }\n    }\n  }\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Recursively adds files from the directory and subdirectories */\n", "func_signal": "int playlist_append_directory(playlist_t *list, char *dirname)", "code": "{\n  DIR *dir;\n  int dir_len = strlen(dirname);\n  struct dirent *entry;\n  struct stat stat_buf;\n  char nextfile[NAME_MAX + 1];\n\n  dir = opendir(dirname);\n\n  if (dir == NULL) {\n    return 0;\n  }\n\n  entry = readdir(dir);\n  while (entry != NULL) {\n    int sub_len = strlen(entry->d_name);\n\n    /* Make sure full pathname is within limits and we don't parse the\n       relative directory entries. */\n    if (dir_len + sub_len + 1 < NAME_MAX \n\t&& strcmp(entry->d_name, \".\") != 0  \n\t&& strcmp(entry->d_name, \"..\") != 0  ) {\n\n      /* Build the new full pathname */\n      strcpy(nextfile, dirname);\n      strcat(nextfile, \"/\");\n      strcat(nextfile, entry->d_name);\n\n      if (stat(nextfile, &stat_buf) == 0) {\n\t\n\t/* Decide what type of entry this is */\n\tif (S_ISDIR(stat_buf.st_mode)) {\n\t  \n\t/* Recursively follow directories */\n\t  if ( playlist_append_directory(list, nextfile) == 0 ) {\n\t    fprintf(stderr,\n\t\t  _(\"Warning: Could not read directory %s.\\n\"), \n\t\t    nextfile);\n\t  }\n\t} else {\n\t/* Assume everything else is a file of some sort */\n\t  playlist_append_file(list, nextfile);\n\t}\n      }\n    }\n\n    entry = readdir(dir);\n  }\n\n  closedir(dir);\n\n  return 1;\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Return number of bits set in X.  */\n", "func_signal": "static inline int\npop (int x)", "code": "{\n  /* We assume that no more than 16 bits are used.  */\n  x = ((x & ~0x5555) >> 1) + (x & 0x5555);\n  x = ((x & ~0x3333) >> 2) + (x & 0x3333);\n  x = ((x >> 4) + x) & 0x0f0f;\n  x = ((x >> 8) + x) & 0xff;\n\n  return x;\n}", "path": "intl\\l10nflist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Deallocate array and all contained strings created by playlist_to_array. */\n", "func_signal": "void playlist_array_destroy(char **array, int size)", "code": "{\n  int i;\n\n  for (i = 0; i < size; i++)\n    free(array[i]);\n\n  free(array);\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n\n   Print out the comments from the vorbis structure\n\n   this version just dumps the raw strings\n   a more elegant version would use vorbis_comment_query()\n\n***********/\n", "func_signal": "void print_comments(FILE *out, vorbis_comment *vc, int raw, int escapes)", "code": "{\n\tint i;\n\tchar *escaped_value, *decoded_value;\n\n\tfor (i = 0; i < vc->comments; i++) {\n\t\tif (escapes) {\n\t\t\tescaped_value = escape(vc->user_comments[i], vc->comment_lengths[i]);\n\t\t} else {\n\t\t\tescaped_value = vc->user_comments[i];\n\t\t}\n\n\t\tif (!raw && utf8_decode(escaped_value, &decoded_value) >= 0) {\n\t\t\tfprintf(out, \"%s\\n\", decoded_value);\n\t\t\tfree(decoded_value);\n\t\t} else {\n\t\t\tfprintf(out, \"%s\\n\", escaped_value);\n\t\t}\n\n\t\tif (escapes) {\n\t\t\tfree(escaped_value);\n\t\t}\n\t}\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n   open_files()\n\n   This function takes care of opening the appropriate files\n   based on the mode and filenames in the param structure.\n   A filename of '-' is interpreted as stdin/out.\n\n   The idea is just to hide the tedious checking so main()\n   is easier to follow as an example.\n\n***********/\n", "func_signal": "void open_files(param_t *p)", "code": "{\n\t/* for all modes, open the input file */\n\n\tif (strncmp(p->infilename,\"-\",2) == 0) {\n\t\tp->in = stdin;\n\t} else {\n\t\tp->in = fopen(p->infilename, \"rb\");\n\t}\n\tif (p->in == NULL) {\n\t\tfprintf(stderr,\n\t\t\t_(\"Error opening input file '%s'.\\n\"),\n\t\t\tp->infilename);\n\t\texit(1);\n\t}\n\n\tif (p->mode == MODE_WRITE || p->mode == MODE_APPEND) { \n\n\t\t/* open output for write mode */\n        if(!strcmp(p->infilename, p->outfilename)) {\n            fprintf(stderr, _(\"Input filename may not be the same as output filename\\n\"));\n            exit(1);\n        }\n\n\t\tif (strncmp(p->outfilename,\"-\",2) == 0) {\n\t\t\tp->out = stdout;\n\t\t} else {\n\t\t\tp->out = fopen(p->outfilename, \"wb\");\n\t\t}\n\t\tif(p->out == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Error opening output file '%s'.\\n\"),\n\t\t\t\tp->outfilename);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* commentfile is input */\n\t\t\n\t\tif ((p->commentfilename == NULL) ||\n\t\t\t\t(strncmp(p->commentfilename,\"-\",2) == 0)) {\n\t\t\tp->com = stdin;\n\t\t} else {\n\t\t\tp->com = fopen(p->commentfilename, \"r\");\n\t\t}\n\t\tif (p->com == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Error opening comment file '%s'.\\n\"),\n\t\t\t\tp->commentfilename);\n\t\t\texit(1);\n\t\t}\n\n\t} else {\n\n\t\t/* in list mode, commentfile is output */\n\n\t\tif ((p->commentfilename == NULL) ||\n\t\t\t\t(strncmp(p->commentfilename,\"-\",2) == 0)) {\n\t\t\tp->com = stdout;\n\t\t} else {\n\t\t\tp->com = fopen(p->commentfilename, \"w\");\n\t\t}\n\t\tif (p->com == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Error opening comment file '%s'\\n\"),\n\t\t\t\tp->commentfilename);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/* all done */\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Convert the playlist to an array of strings.  Strings are deep copied. \n   Size will be set to the number of elements in the array. */\n", "func_signal": "char **playlist_to_array(playlist_t *list, int *size)", "code": "{\n  char **array;\n  int i;\n  playlist_element_t *element;\n\n  *size = playlist_length(list);\n  array = calloc(*size, sizeof(char *));\n\n  if (array == NULL) {\n    fprintf(stderr,\n\t    _(\"ERROR: Out of memory in playlist_to_array().\\n\"));\n    exit(1);\n  }\n\n  for (i = 0, element = list->head->next; \n       i < *size; \n       i++, element = element->next) {\n\n    array[i] = strdup(element->filename);\n\n    if (array[i] == NULL) {\n      fprintf(stderr,\n\t      _(\"ERROR: Out of memory in playlist_to_array().\\n\"));\n      exit(1);\n    }\n  }\n\n\n  return array;\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/**********\n\n   Convert a safely escaped 0-terminated string to raw comment content.  The\n   result can contain null bytes, so the the result's length is written into\n   *tosize.  This size doesn't include a trailing '\\0' (the vorbis bitstream\n   doesn't use one) but we do append it for convenience since\n   vorbis_comment_add[_tag]() has a null-terminated interface.\n\n   Returns the address of a newly allocated string - caller is responsible to\n   free it.  Returns NULL in case of error (if the input is mal-formed).\n\n***********/\n", "func_signal": "char *unescape(const char *from, int *tosize)", "code": "{\n\t/* worst-case allocation, will be trimmed when done */\n\tchar *to = malloc(strlen(from) + 1);\n\n\tchar *s;\n\tfor (s = to; *from != '\\0'; ) {\n\t\tif (*from == '\\\\') {\n\t\t\tfrom++;\n\t\t\tswitch (*from++) {\n\t\t\tcase 'n':\n\t\t\t\t*s++ = '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\t*s++ = '\\r';\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\t*s++ = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*s++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\0':\n\t\t\t\t/* A backslash as the last character of the string is an error. */\n\t\t\t\t/* FALL-THROUGH */\n\t\t\tdefault:\n\t\t\t\t/* We consider any unrecognized escape as an error.  This is\n\t\t\t\t   good in general and reserves them for future expansion. */\n\t\t\t\tfree(to);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* normal character */\n\t\t\t*s++ = *from++;\n\t\t}\n\t}\n\n\t*tosize = s - to;\t\t\t/* excluding '\\0' */\n\n\t*s++ = '\\0';\n\tto = realloc(to, s - to);\t/* free unused space */\n\treturn to;\n}", "path": "vorbiscomment\\vcomment.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Only destroys the current node.  Does not affect linked nodes. */\n", "func_signal": "void playlist_element_destroy(playlist_element_t *element)", "code": "{\n  free(element->filename);\n  free(element);\n}", "path": "ogg123\\playlist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Normalize codeset name.  There is no standard for the codeset\n   names.  Normalization allows the user to use any of the common\n   names.  The return value is dynamically allocated and has to be\n   freed by the caller.  */\n", "func_signal": "const char *\n_nl_normalize_codeset (const char *codeset, size_t name_len)", "code": "{\n  int len = 0;\n  int only_digit = 1;\n  char *retval;\n  char *wp;\n  size_t cnt;\n\n  for (cnt = 0; cnt < name_len; ++cnt)\n    if (isalnum ((unsigned char) codeset[cnt]))\n      {\n\t++len;\n\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  only_digit = 0;\n      }\n\n  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);\n\n  if (retval != NULL)\n    {\n      if (only_digit)\n\twp = stpcpy (retval, \"iso\");\n      else\n\twp = retval;\n\n      for (cnt = 0; cnt < name_len; ++cnt)\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  *wp++ = tolower ((unsigned char) codeset[cnt]);\n\telse if (isdigit ((unsigned char) codeset[cnt]))\n\t  *wp++ = codeset[cnt];\n\n      *wp = '\\0';\n    }\n\n  return (const char *) retval;\n}", "path": "intl\\l10nflist.c", "repo_name": "imalone/imalone_vorbis-tools", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 1964}
{"docstring": "/* Returns the element in LIST with the smallest value according\n   to LESS given auxiliary data AUX.  If there is more than one\n   minimum, returns the one that appears earlier in the list.  If\n   the list is empty, returns its tail. */\n", "func_signal": "struct list_elem *\nlist_min (struct list *list, list_less_func *less, void *aux)", "code": "{\n  struct list_elem *min = list_begin (list);\n  if (min != list_end (list)) \n    {\n      struct list_elem *e;\n      \n      for (e = list_next (min); e != list_end (list); e = list_next (e))\n        if (less (e, min, aux))\n          min = e; \n    }\n  return min;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the element in LIST with the largest value according\n   to LESS given auxiliary data AUX.  If there is more than one\n   maximum, returns the one that appears earlier in the list.  If\n   the list is empty, returns its tail. */\n", "func_signal": "struct list_elem *\nlist_max (struct list *list, list_less_func *less, void *aux)", "code": "{\n  struct list_elem *max = list_begin (list);\n  if (max != list_end (list)) \n    {\n      struct list_elem *e;\n      \n      for (e = list_next (max); e != list_end (list); e = list_next (e))\n        if (less (max, e, aux))\n          max = e; \n    }\n  return max;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Sorts LIST according to LESS given auxiliary data AUX, using a\n   natural iterative merge sort that runs in O(n lg n) time and\n   O(1) space in the number of elements in LIST. */\n", "func_signal": "void\nlist_sort (struct list *list, list_less_func *less, void *aux)", "code": "{\n  size_t output_run_cnt;        /* Number of runs output in current pass. */\n\n  assert (list != NULL);\n  assert (less != NULL);\n\n  /* Pass over the list repeatedly, merging adjacent runs of\n     nondecreasing elements, until only one run is left. */\n  do\n    {\n      struct list_elem *a0;     /* Start of first run. */\n      struct list_elem *a1b0;   /* End of first run, start of second. */\n      struct list_elem *b1;     /* End of second run. */\n\n      output_run_cnt = 0;\n      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)\n        {\n          /* Each iteration produces one output run. */\n          output_run_cnt++;\n\n          /* Locate two adjacent runs of nondecreasing elements\n             A0...A1B0 and A1B0...B1. */\n          a1b0 = find_end_of_run (a0, list_end (list), less, aux);\n          if (a1b0 == list_end (list))\n            break;\n          b1 = find_end_of_run (a1b0, list_end (list), less, aux);\n\n          /* Merge the runs. */\n          inplace_merge (a0, a1b0, b1, less, aux);\n        }\n    }\n  while (output_run_cnt > 1);\n\n  assert (is_sorted (list_begin (list), list_end (list), less, aux));\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the element after ELEM in its list.  If ELEM is the\n   last element in its list, returns the list tail.  Results are\n   undefined if ELEM is itself a list tail. */\n", "func_signal": "struct list_elem *\nlist_next (struct list_elem *elem)", "code": "{\n  assert (is_head (elem) || is_interior (elem));\n  return elem->next;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the LIST's reverse beginning, for iterating through\n   LIST in reverse order, from back to front. */\n", "func_signal": "struct list_elem *\nlist_rbegin (struct list *list)", "code": "{\n  assert (list != NULL);\n  return list->tail.prev;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Iterates through LIST and removes all but the first in each\n   set of adjacent elements that are equal according to LESS\n   given auxiliary data AUX.  If DUPLICATES is non-null, then the\n   elements from LIST are appended to DUPLICATES. */\n", "func_signal": "void\nlist_unique (struct list *list, struct list *duplicates,\n             list_less_func *less, void *aux)", "code": "{\n  struct list_elem *elem, *next;\n\n  assert (list != NULL);\n  assert (less != NULL);\n  if (list_empty (list))\n    return;\n\n  elem = list_begin (list);\n  while ((next = list_next (elem)) != list_end (list))\n    if (!less (elem, next, aux) && !less (next, elem, aux)) \n      {\n        list_remove (next);\n        if (duplicates != NULL)\n          list_push_back (duplicates, next);\n      }\n    else\n      elem = next;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Inserts ELEM in the proper position in LIST, which must be\n   sorted according to LESS given auxiliary data AUX.\n   Runs in O(n) average case in the number of elements in LIST. */\n", "func_signal": "void\nlist_insert_ordered (struct list *list, struct list_elem *elem,\n                     list_less_func *less, void *aux)", "code": "{\n  struct list_elem *e;\n\n  assert (list != NULL);\n  assert (elem != NULL);\n  assert (less != NULL);\n\n  for (e = list_begin (list); e != list_end (list); e = list_next (e))\n    if (less (elem, e, aux))\n      break;\n  return list_insert (e, elem);\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Inserts ELEM just before BEFORE, which may be either an\n   interior element or a tail.  The latter case is equivalent to\n   list_push_back(). */\n", "func_signal": "void\nlist_insert (struct list_elem *before, struct list_elem *elem)", "code": "{\n  assert (is_interior (before) || is_tail (before));\n  assert (elem != NULL);\n\n  elem->prev = before->prev;\n  elem->next = before;\n  before->prev->next = elem;\n  before->prev = elem;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the back element in LIST.\n   Undefined behavior if LIST is empty. */\n", "func_signal": "struct list_elem *\nlist_back (struct list *list)", "code": "{\n  assert (!list_empty (list));\n  return list->tail.prev;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the front element in LIST.\n   Undefined behavior if LIST is empty. */\n", "func_signal": "struct list_elem *\nlist_front (struct list *list)", "code": "{\n  assert (!list_empty (list));\n  return list->head.next;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Swaps the `struct list_elem *'s that A and B point to. */\n", "func_signal": "static void\nswap (struct list_elem **a, struct list_elem **b)", "code": "{\n  struct list_elem *t = *a;\n  *a = *b;\n  *b = t;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns LIST's tail.\n\n   list_end() is often used in iterating through a list from\n   front to back.  See the big comment at the top of list.h for\n   an example. */\n", "func_signal": "struct list_elem *\nlist_end (struct list *list)", "code": "{\n  assert (list != NULL);\n  return &list->tail;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Initializes LIST as an empty list. */\n", "func_signal": "void\nlist_init (struct list *list)", "code": "{\n  assert (list != NULL);\n  list->head.prev = NULL;\n  list->head.next = &list->tail;\n  list->tail.prev = &list->head;\n  list->tail.next = NULL;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Removes the front element from LIST and returns it.\n   Undefined behavior if LIST is empty before removal. */\n", "func_signal": "struct list_elem *\nlist_pop_front (struct list *list)", "code": "{\n  struct list_elem *front = list_front (list);\n  list_remove (front);\n  return front;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Return's LIST's tail. */\n", "func_signal": "struct list_elem *\nlist_tail (struct list *list)", "code": "{\n  assert (list != NULL);\n  return &list->tail;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Removes the back element from LIST and returns it.\n   Undefined behavior if LIST is empty before removal. */\n", "func_signal": "struct list_elem *\nlist_pop_back (struct list *list)", "code": "{\n  struct list_elem *back = list_back (list);\n  list_remove (back);\n  return back;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns true only if the list elements A through B (exclusive)\n   are in order according to LESS given auxiliary data AUX. */\n", "func_signal": "static bool\nis_sorted (struct list_elem *a, struct list_elem *b,\n           list_less_func *less, void *aux)", "code": "{\n  if (a != b)\n    while ((a = list_next (a)) != b) \n      if (less (a, list_prev (a), aux))\n        return false;\n  return true;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Finds a run, starting at A and ending not after B, of list\n   elements that are in nondecreasing order according to LESS\n   given auxiliary data AUX.  Returns the (exclusive) end of the\n   run.\n   A through B (exclusive) must form a non-empty range. */\n", "func_signal": "static struct list_elem *\nfind_end_of_run (struct list_elem *a, struct list_elem *b,\n                 list_less_func *less, void *aux)", "code": "{\n  assert (a != NULL);\n  assert (b != NULL);\n  assert (less != NULL);\n  assert (a != b);\n  \n  do \n    {\n      a = list_next (a);\n    }\n  while (a != b && !less (a, list_prev (a), aux));\n  return a;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Merges A0 through A1B0 (exclusive) with A1B0 through B1\n   (exclusive) to form a combined range also ending at B1\n   (exclusive).  Both input ranges must be nonempty and sorted in\n   nondecreasing order according to LESS given auxiliary data\n   AUX.  The output range will be sorted the same way. */\n", "func_signal": "static void\ninplace_merge (struct list_elem *a0, struct list_elem *a1b0,\n               struct list_elem *b1,\n               list_less_func *less, void *aux)", "code": "{\n  assert (a0 != NULL);\n  assert (a1b0 != NULL);\n  assert (b1 != NULL);\n  assert (less != NULL);\n  assert (is_sorted (a0, a1b0, less, aux));\n  assert (is_sorted (a1b0, b1, less, aux));\n\n  while (a0 != a1b0 && a1b0 != b1)\n    if (!less (a1b0, a0, aux)) \n      a0 = list_next (a0);\n    else \n      {\n        a1b0 = list_next (a1b0);\n        list_splice (a0, list_prev (a1b0), a1b0);\n      }\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* Returns the beginning of LIST.  */\n", "func_signal": "struct list_elem *\nlist_begin (struct list *list)", "code": "{\n  assert (list != NULL);\n  return list->head.next;\n}", "path": "src\\list.c", "repo_name": "spolu/ur", "stars": 2, "license": "gpl-3.0", "language": "c", "size": 156}
{"docstring": "/* \n * open/closes the device \n */\n", "func_signal": "int \nmpio_device_open(mpio_t *m)", "code": "{\n  struct usb_device *dev;\n  struct usb_interface_descriptor *interface;\n  struct usb_endpoint_descriptor *ep;\n  int ret, i;\n\n  if (m->fd)\n    return MPIO_OK;\n\n  debugn(2, \"trying libusb\\n\");\n  usb_init();\n  usb_find_busses();\n  usb_find_devices();\n  \n  m->usb_busses = usb_get_busses();\n  \n  for (m->usb_bus = m->usb_busses; \n       m->usb_bus; \n       m->usb_bus = m->usb_bus->next) {\n\n    for (dev = m->usb_bus->devices; dev; dev = dev->next) {\n      if (dev->descriptor.idVendor == 0x2735) {\n\tif ((dev->descriptor.idProduct != 0x01)  &&\n\t    (dev->descriptor.idProduct != 0x71))\n\t  debugn(2, \"Found Product ID %02x, which is unknown. Proceeding anyway.\\n\",\n\t\tdev->descriptor.idProduct);\n\tm->usb_handle = usb_open(dev);\n\tif (m->usb_handle) {\n\t  /* found and opened the device,\n\t     now find the communication endpoints */\n\t  m->usb_in_ep = m->usb_out_ep = 0;\n\t  \n\t  ret = usb_claim_interface (m->usb_handle, 0);\n\t  \n\t  if (ret < 0)\n\t    {\n\t      debugn(2, \"Error claiming device: %d  \\\"%s\\\"\\n\", ret, usb_strerror());\n\t      usb_close(m->usb_handle);\n\t      return MPIO_ERR_PERMISSION_DENIED;\n\t    } else {\n\t      debugn(2, \"claimed interface 0\\n\");\n\t    }\n\t  \n\t  interface = dev->config->interface->altsetting;\n\n\t  for (i = 0 ; i < interface->bNumEndpoints; i++) {\n\t    ep = &interface->endpoint[i];\n\t    debugn(2, \"USB endpoint #%d (Addr=0x%02x, Attr=0x%02x)\\n\", i, \n\t\t ep->bEndpointAddress, ep->bmAttributes);\n\t    if (ep->bmAttributes == 2) {\n\t      if (ep->bEndpointAddress & USB_ENDPOINT_IN) {\n\t\tdebugn(2, \"FOUND incoming USB endpoint (0x%02x)\\n\", ep->bEndpointAddress);\n\t\tm->usb_in_ep = ep->bEndpointAddress & ~(USB_ENDPOINT_IN);\n\t      } else {\n\t\tdebugn(2, \"FOUND outgoing USB endpoint (0x%02x)\\n\", ep->bEndpointAddress);\n\t\tm->usb_out_ep = ep->bEndpointAddress;\n\t      }\n\t    }\n\t  }\n\t  \n\t  m->fd=1;\n\t  if (!(m->usb_in_ep && m->usb_out_ep)) {\n\t    debugn(2, \"Did not find USB bulk endpoints.\\n\");\n\t    mpio_device_close(m);\n\t    return MPIO_ERR_PERMISSION_DENIED;\t    \n\t  }\t  \n\t  \n\t  debugn(2, \"using libusb\\n\");\n\t  return MPIO_OK;\n\t}      \n      }\n    }\n  }\n  \n  if (m->usb_handle)\n    usb_close(m->usb_handle);\n  return MPIO_ERR_PERMISSION_DENIED;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* encoding and decoding of blockaddresses */\n", "func_signal": "DWORD \nblockaddress_encode(DWORD ba)", "code": "{\n  WORD addr;\n  BYTE p = 0, c = 0;\n  BYTE high, low;\n\n  high = 0x10 | ((ba / 0x80) & 0x07);\n  low  = (ba * 2) & 0xff;\n    \n  c = high;\n  while (c) \n    {\n      if (c & 0x01)\n\tp ^= 1;\n      c /= 2;\n    }\n\n  c = low;\n  while (c) \n    {\n      if (c & 0x01)\n\tp ^= 0x01;\n      c /= 2;\n    }  \n  \n  addr = (high * 0x100) + low + p;\n\n  return addr;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* \n * Set command packet  \n *\n * parameter:\n *\n * cmd:       commando code\n * mem:       internal/external\n * index:     sector/block\n * size:      size of used memory chip\n * wsize:     write size, only for PUT_BLOCK\n * buffer:    output buffer of command packet\n *\n */\n", "func_signal": "int\nmpio_io_set_cmdpacket(mpio_t *m, mpio_cmd_t cmd, mpio_mem_t mem, DWORD index,\n\t\t      WORD size, BYTE wsize, CHAR *buffer)", "code": "{\n  BYTE memory;\n\n  /* clear cmdpacket*/\n  memset(buffer, 0, 0x40);  \n\n  *buffer = cmd;\n  memory = mem;\n  if (mem == MPIO_EXTERNAL_MEM)\n    memory = model2externalmem(m->model);\n  \n  *(buffer + 0x01) =   memory;\n  *(buffer + 0x03) =   (BYTE) (index & 0x00ff);\n  *(buffer + 0x04) =   (BYTE)((index & 0xff00) >> 8);\n  /*  SM cards with less or equal 32 MB only need 2 Bytes\n   *  to address sectors or blocks.\n   *  The highest byte has to be 0xff in that case!\n   */\n  if (size <= 32) \n    {\n      *(buffer + 0x05) = 0xff;\n    } else {  \n      *(buffer + 0x05) = (BYTE) (index >> 16);\n    }  \n  /* is this always 0x48 in case of a block write ?? */\n  *(buffer + 0x06) = wsize;  \n\n  memcpy((buffer + 0x3b), \"jykim\", 5);\n\n  return (0);\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * read/write of megablocks\n */\n", "func_signal": "int\nmpio_io_megablock_read(mpio_t *m, mpio_mem_t mem, mpio_fatentry_t *f, BYTE *output)", "code": "{\n  int i=0;\n  int j=0;\n  int nwrite, nread;\n  mpio_smartmedia_t *sm;\n  BYTE  chip;\n  DWORD address;\n  CHAR cmdpacket[CMD_SIZE], recvbuff[BLOCK_TRANS];\n\n  if (mem == MPIO_INTERNAL_MEM) sm = &m->internal;\n  if (mem == MPIO_EXTERNAL_MEM) sm = &m->external;\n\n  fatentry2hw(f, &chip, &address);\n\n  mpio_io_set_cmdpacket(m, GET_BLOCK, chip, address, sm->size, 0, cmdpacket);\n\n  debugn(5, \"\\n>>> MPIO\\n\");\n  hexdump(cmdpacket, sizeof(cmdpacket));\n    \n  nwrite = mpio_io_write(m, cmdpacket, CMD_SIZE);\n\n/*   hexdumpn(0, cmdpacket, 16); */\n\n  if(nwrite != CMD_SIZE) \n    {\n      debug (\"\\nFailed to send command.\\n\");\n      close (m->fd);\n      return 1;\n    }\n\n  /*  Receive packets from MPIO   */\n  for (i = 0; i < 8; i++) \n    {      \n      nread = mpio_io_read(m, recvbuff, BLOCK_TRANS);\n      \n      if(nread != BLOCK_TRANS) \n\t{\n\t  debug (\"\\nFailed to read (sub-)block.(nread=0x%04x)\\n\",nread);\n\t  close (m->fd);\n\t  return 1;\n\t}\n      \n      debugn(5, \"\\n<<< MPIO (%d)\\n\", i);\n      hexdump(recvbuff, BLOCK_TRANS);\n\n      for (j = 0; j < BLOCK_SECTORS; j++) {\n\tmemcpy(output + (j * SECTOR_SIZE) + (i * BLOCK_SIZE), \n\t       recvbuff + (j * SECTOR_TRANS), \n\t       SECTOR_SIZE);\n      }\n    }\n\n  return 0;  \n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* \n * read version block from MPIO\n *\n * parameter:\n *\n * m:         mpio context\n * buffer:    return buffer (has to be CMD_SIZE)\n *\n */\n", "func_signal": "int\nmpio_io_version_read(mpio_t *m, CHAR *buffer)", "code": "{\n  int nwrite, nread;\n  CHAR cmdpacket[CMD_SIZE], status[CMD_SIZE];\n\n  /*  Send command packet to MPIO  */\n  mpio_io_set_cmdpacket (m, GET_VERSION, 0, 0, 0xff, 0, cmdpacket);\n\n  debugn  (5, \">>> MPIO\\n\");\n  hexdump (cmdpacket, sizeof(cmdpacket));\n\n  nwrite = mpio_io_write(m, cmdpacket, 0x40);\n\n  if (nwrite != CMD_SIZE) \n    {\n      debug (\"Failed to send command.\\n\");\n      close (m->fd);\n      return 0;    \n    }\n\n  /*  Receive packet from MPIO  */\n  nread = mpio_io_read(m, status, 0x40);\n\n  if (nread == -1 || nread != 0x40) \n    {\n      debug (\"Failed to read Sector.(nread=0x%04x)\\n\",nread);\n      close (m->fd);\n      return 0;    \n    }\n\n  debugn (5, \"<<< MPIO\\n\");\n  hexdump (status, 0x40);\n\n  memcpy(buffer, status, 0x40);\n  \n  return CMD_SIZE;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* copied from netpbm */\n", "func_signal": "void\npbm_readpbminit( FILE *file, int *colsP, int *rowsP )", "code": "{\n    /* Check magic number. */\n    if ( pm_readmagicnumber(file) != ('P'*256 + '4') ) {\n\t    fprintf(stderr,\"This is not a raw pbm file.\\n\");\n\t    exit(-1);\n    }\n    *colsP = pbm_getint(file);\n    *rowsP = pbm_getint(file);\n}", "path": "tools\\mpiologo.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * read/write of blocks\n */\n", "func_signal": "int\nmpio_io_block_read(mpio_t *m, mpio_mem_t mem, mpio_fatentry_t *f, BYTE *output)", "code": "{\n  int i=0;\n  int nwrite, nread;\n  mpio_smartmedia_t *sm;\n  BYTE  chip;\n  DWORD address;\n  CHAR cmdpacket[CMD_SIZE], recvbuff[BLOCK_TRANS];\n\n  if (mem == MPIO_INTERNAL_MEM) sm = &m->internal;\n  if (mem == MPIO_EXTERNAL_MEM) sm = &m->external;\n\n  if (sm->version)\n    return mpio_io_megablock_read(m, mem, f, output);\n\n  fatentry2hw(f, &chip, &address);\n\n  mpio_io_set_cmdpacket(m, GET_BLOCK, chip, address, sm->size, 0, cmdpacket);\n\n  debugn(5, \"\\n>>> MPIO\\n\");\n  hexdump(cmdpacket, sizeof(cmdpacket));\n    \n  nwrite = mpio_io_write(m, cmdpacket, CMD_SIZE);\n\n  if(nwrite != CMD_SIZE) \n    {\n      debug (\"\\nFailed to send command.\\n\");\n      close (m->fd);\n      return 1;\n    }\n\n  /*  Receive packet from MPIO   */\n  nread = mpio_io_read(m, recvbuff, BLOCK_TRANS);\n\n  if(nread != BLOCK_TRANS) \n    {\n      debug (\"\\nFailed to read Block.(nread=0x%04x)\\n\",nread);\n      close (m->fd);\n      return 1;\n    }\n\n  debugn(5, \"\\n<<< MPIO\\n\");\n  hexdump(recvbuff, BLOCK_TRANS);\n\n  for (i = 0; i < BLOCK_SECTORS; i++) \n    {\n      /* check ECC Area information */\n      if (mem==MPIO_EXTERNAL_MEM) {      \n\tif (mpio_ecc_256_check ((recvbuff + (i * SECTOR_TRANS)),\n\t\t\t\t((recvbuff +(i * SECTOR_TRANS) \n\t\t\t\t  + SECTOR_SIZE +13))) ||\t\n\t    mpio_ecc_256_check ((recvbuff + (i * SECTOR_TRANS) \n\t\t\t\t + (SECTOR_SIZE / 2)),\n\t\t\t\t((recvbuff +(i * SECTOR_TRANS) \n\t\t\t\t  + SECTOR_SIZE + 8))))\n\t  debug (\"ECC error @ (chip=0x%02x address=0x%06x)\\n\", chip, address);\n      }\n      \n      memcpy(output + (i * SECTOR_SIZE), \n\t     recvbuff + (i * SECTOR_TRANS), \n\t     SECTOR_SIZE);\n    }\n\n  return 0;  \n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * zone management\n */\n", "func_signal": "int   \nmpio_zone_init(mpio_t *m, mpio_cmd_t mem)", "code": "{\n  mpio_smartmedia_t *sm;\n  int i;\n  int zone, block, e;\n  \n  if (mem != MPIO_EXTERNAL_MEM) \n    {\n      debug(\"called function with wrong memory selection!\\n\");\n      return -1;\n    }\n  sm = &m->external;\n\n  for(i=0; i<sm->max_blocks; i++)\n    {\n      zone = i / MPIO_ZONE_PBLOCKS;\n      block= i % MPIO_ZONE_PBLOCKS;\n\n      e = i * 0x10;\n\n      sm->zonetable[zone][block]=blockaddress_decode(sm->spare+e);\n      \n      hexdumpn(4, (CHAR *)sm->spare+e, 0x10);\n      debugn(2, \"decoded: %04x\\n\", sm->zonetable[zone][block]);\n    }\n  return MPIO_OK;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* read \"size\" sectors of fat into the provided buffer */\n", "func_signal": "int\nmpio_rootdir_read (mpio_t *m, mpio_mem_t mem)", "code": "{\n  mpio_smartmedia_t *sm;  \n  mpio_fatentry_t   *f;\n  CHAR recvbuff[SECTOR_SIZE];\n  int i;\n\n  if (mem == MPIO_INTERNAL_MEM) sm = &m->internal;\n  if (mem == MPIO_EXTERNAL_MEM) sm = &m->external;\n  \n  if (sm->version) {\n    /* new chip */\n    f = mpio_fatentry_new(m, mem, 0x00, FTYPE_MUSIC);  \n    if (!f)\n      return 1;\n    mpio_io_block_read(m, mem, f, sm->root->dir);\n    free (f);\t\n  } else {\n    /* old chip */\n    for (i = 0; i < DIR_NUM; i++) {\n      if (mpio_io_sector_read(m, mem, (sm->dir_offset + i), recvbuff))\n\treturn 1;\n      memcpy(sm->root->dir + (i * SECTOR_SIZE), recvbuff, SECTOR_SIZE);\n    }\n  }\n\n  return (0);\n}", "path": "libmpio\\src\\directory.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* foobar  */\n", "func_signal": "void \nfatentry2hw(mpio_fatentry_t *f, BYTE *chip, DWORD *address)", "code": "{\n  mpio_smartmedia_t *sm;\n  \n  if (f->mem == MPIO_INTERNAL_MEM) \n    {\n      sm       = &f->m->internal;\n      /*       hexdump((CHAR *)&f->entry, 4); */\n      /*       hexdump((CHAR *)&f->hw_address, 4); */\n      *chip    = f->hw_address / 0x1000000;    \n      *address = f->hw_address & 0x0ffffff;\n    }\n  if (f->mem == MPIO_EXTERNAL_MEM) \n    {\n      sm        = &f->m->external;\n      *chip     = MPIO_EXTERNAL_MEM;\n      *address  = mpio_zone_block_find_log(f->m, f->mem, f->entry);\n      debugn(3, \"%06x (logical: %04x)\\n\", *address, f->entry);\n    }\n  return;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* mpiosh core functions */\n", "func_signal": "void\nmpiosh_init(void)", "code": "{\n  /* set state */\n  mpiosh.dev = NULL;\n  mpiosh.config = NULL;\n  mpiosh.prompt = NULL;\n\n  /* read configuration */\n  mpiosh.config = mpiosh_config_new();\n  if (mpiosh.config)\n    mpiosh_config_read(mpiosh.config);\n\n  mpiosh.card = mpiosh.config->default_mem;\n  if (mpiosh.config->default_mem == MPIO_EXTERNAL_MEM)\n    mpiosh.prompt = mpiosh.config->prompt_ext;\n  else\n    mpiosh.prompt = mpiosh.config->prompt_int;\n\n  /* inital mpio library */\n  mpiosh.dev = mpio_init(mpiosh_callback_init);\n\n  printf(\"\\n\");\n  \n  if ((mpiosh.dev) && (mpiosh.config->charset))\n    mpio_charset_set(mpiosh.dev, mpiosh.config->charset);\n}", "path": "src\\mpiosh.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* TODO: please clean me up !!! */\n", "func_signal": "int\nmpio_dentry_get_real(mpio_t *m, mpio_mem_t mem, BYTE *buffer,                   \n\t\t     CHAR *filename, int filename_size,\n\t\t     CHAR *filename_8_3,\n\t\t     WORD *year, BYTE *month, BYTE *day,\n\t\t     BYTE *hour, BYTE *minute, DWORD *fsize,\n\t\t     BYTE *type)", "code": "{\n  int date, time;  \n  int vfat = 0;  \n  int num_slots = 0;  \n  int slots = 0;\n  size_t in = 0, out = 0, iconv_return;\n  mpio_dir_entry_t *dentry;\n  mpio_fatentry_t  *f;\n  mpio_dir_slot_t  *slot;\n  CHAR *unicode = 0;\n  CHAR *uc;\n  CHAR *fname = 0;\n  iconv_t ic;\n  int dsize, i;\n  \n  if (buffer == NULL)\n    return -1;  \n\n  dentry = (mpio_dir_entry_t *)buffer;\n\n  if ((dentry->name[0] & 0x40)    && \n      (dentry->attr == 0x0f)      &&\n      (dentry->start[0] == 0x00)  &&\n      (dentry->start[1] == 0x00)) \n    {\n      dsize = mpio_dentry_get_size(m, mem, buffer);\n      debugn(3, \"dentry size is: 0x%02x\\n\", dsize);\n      hexdump((CHAR *)buffer, dsize);\n      num_slots = (dsize / 0x20) - 1;\n      slots = num_slots - 1;\n      dentry++;\n      vfat++;    \n      in = num_slots * 26;\n      out = num_slots * 13;\n      unicode = malloc(in + 2);\n      memset(unicode, 0x00, (in+2));\n      uc = unicode;\n      fname = filename;\n      slot = (mpio_dir_slot_t *)buffer;\n      mpio_dentry_copy_from_slot(unicode + (26 * slots), slot);\n      slots--;\n      \n      while ((dentry->attr == 0x0f)      &&\n\t     (dentry->start[0] == 0x00)  &&\n\t     (dentry->start[1] == 0x00)) \n\t{\n\t  /* this/these are vfat slots */\n\t  slot = (mpio_dir_slot_t *)dentry;\n\t  mpio_dentry_copy_from_slot((unicode + (26 * slots)), slot);\n\t  dentry++;\n\t  slots--;\n\t}\n    }  \n  \n  if (vfat) \n    {\n      ic = iconv_open(m->charset, UNICODE);\n      memset(fname, 0, filename_size);\n      hexdumpn(4, unicode, in+2);\n      debugn(4, \"before iconv: in: %2d - out: %2d\\n\", in, out);\n      iconv_return = iconv(ic, (char **)&uc, &in, (char **)&fname, &out);\n      debugn(4, \"after  iconv: in: %2d - out: %2d (return: %d)\\n\", in, out,\n\t     iconv_return);\n      hexdumpn(4, filename, (num_slots*13)-out);\n      iconv_close(ic);\n    } \n  free(unicode);\n\n  memcpy(filename_8_3, dentry->name, 8);\n  i=8;\n  while(filename_8_3[i-1]==' ')\n    i--;\n  filename_8_3[i++] = '.';\t\n  memcpy(filename_8_3 + i, dentry->ext, 3);\n  i+=3;\n  while(filename_8_3[i-1]==' ')\n    i--;  \n  filename_8_3[i] = 0;\n  hexdumpn(4, filename_8_3, 13);\n\n  if (!vfat) \n    {    \n      if (filename_size >= 12) \n\t{\n\t  snprintf(filename, 13, \"%s\", filename_8_3);\t    \n\t  /* UGLY !! */      \n\t  if (((strncmp(dentry->name, \".       \", 8)==0) &&\n\t       (strncmp(dentry->ext, \"   \", 3) == 0)))\n\t    filename[1]=0;\n\t  if (((strncmp(dentry->name, \"..      \", 8)==0) &&\n\t       (strncmp(dentry->ext, \"   \", 3) == 0)))\n\t    filename[2]=0;\n\t} else {\n\t  snprintf(filename, filename_size, \"%s\", \"ERROR\");\n\t}\n    }\n\n  date  = (dentry->date[1] * 0x100) + dentry->date[0];\n  *year  = date / 512 + 1980;\n  *month = (date / 32) & 0xf;\n  *day   = date & 0x1f;\n  \n  time  = (dentry->time[1] * 0x100) + dentry->time[0];\n  *hour  = time / 2048;\n  *minute= (time / 32) & 0x3f;\n\n  *fsize = dentry->size[3];\n  *fsize *= 0x100;\n  *fsize += dentry->size[2];\n  *fsize *= 0x100;\n  *fsize += dentry->size[1];\n  *fsize *= 0x100;\n  *fsize += dentry->size[0];\n\n  if (dentry->attr & 0x10) {\n    /* is this a directory? */\n    *type = FTYPE_DIR;\n    if ((dentry->attr & 0x08) &&\n\t(dentry->attr & 0x02)) \n      *type = FTYPE_DIR_RECURSION;\n  } else {\n    *type = FTYPE_PLAIN;\n    if (mem == MPIO_INTERNAL_MEM) {\n      f = mpio_dentry_get_startcluster(m, mem, buffer);\n      if (f) {\t\n\t*type = m->internal.fat[f->entry * 0x10 + 0x06];\n      } else {\n\t/* we did not find the startcluster, thus the internal \n\t   FAT is broken for this file */\n\t*type = FTYPE_BROKEN;\n      }\n    }    \n  }\n\n  return(((BYTE *)dentry) - buffer);\n}", "path": "libmpio\\src\\directory.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* END copied from netpbm */\n", "func_signal": "int\nlogo_read( BYTE **lpp, char *filename, int model )", "code": "{\n    int totalbytes, framesize, maxsize, cols, rows, framerows;\n\n    totalbytes = pbm_read( lpp, filename, &cols, &rows );\n\n    framesize = (model ? LOGO_FRAMESIZE_DMK: LOGO_FRAMESIZE);\n      maxsize = (model ? LOGO_MAXSIZE_DMK: LOGO_MAXSIZE);\n    framerows = (model ? 16 : 48);\n\n    if (totalbytes / framesize > LOGO_FRAMEMAX) {\n\tfprintf(stderr,\"Warning: Too much frames. Forced to be set 255.\\n\");\n\ttotalbytes = maxsize;\n\trows = maxsize / cols * 8;\n    }\n\n    if ( cols != 128 ) fprintf(stderr,\"Warning: Width is not 128 pixels.\\n\");\n    if ( (rows % framerows) != 0 )\n\tfprintf(stderr,\"Warning: Hight is not %d*N pixels.\\n\", framerows);\n\n    return (totalbytes);\n}", "path": "tools\\mpiologo.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * write chunk of data to MPIO filedescriptor\n *\n * parameter:\n *\n * fd:        filedescriptor\n * block:     data buffer (has to be num_bytes)\n * num_bytes: size of data buffer\n *\n */\n", "func_signal": "int\nmpio_io_bulk_write(int fd, CHAR *block, int num_bytes)", "code": "{\n  CHAR *p;\n  int count, bytes_left, bytes_written;\n\n  bytes_left = num_bytes;\n  bytes_written = 0;\n  p = block;\n\n  do\n  {\n    count = write (fd, p, bytes_left);\n    if (count > 0)\n    {\n      p += count;\n      bytes_written += count;\n      bytes_left -= count;\n    }\n  } while (bytes_left > 0 && count > 0);\n\n  return bytes_written;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* commands */\n", "func_signal": "void\nmpiosh_cmd_debug(char *args[])", "code": "{\n  if (args[0] != NULL) {\n    if (!strcmp(args[0], \"level\")) {\n      debug_level(strtol(args[1], NULL, 0));\n    } else if (!strcmp(args[0], \"file\")) {\n      debug_file(args[1]);\n    } else if (!strcmp(args[0], \"on\")) {\n      if (debug_level_get() == -1)\n\tdebug_level(1);\n      else\n\tfprintf(stderr, \"debug already activated for level %d\\n\",\n\t\tdebug_level_get());\n    } else if (!strcmp(args[0], \"off\")) {\n      if (debug_level_get() == -1)\n\tfprintf(stderr,\t\"debug already deactivated\\n\");\n      else\n\tdebug_level(-1);\n    } else {\n      fprintf(stderr, \"unknown debug command\\n\");\n      printf(\"debug [level|file|on|off] <value>\\n\");\n    }\n  } else {\n    fprintf(stderr, \"error: no arguments given\\n\");\n    printf(\"debug [level|file|on|off] <value>\\n\");\n  }  \n}", "path": "src\\callback.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * report sizes of selected memory\n */\n", "func_signal": "int\nmpio_block_get_sectors(mpio_t *m, mpio_mem_t mem)", "code": "{\n  mpio_smartmedia_t *sm=0;\n  int sectors;\n  \n  if (mem == MPIO_INTERNAL_MEM) sm = &m->internal;\n  if (mem == MPIO_EXTERNAL_MEM) sm = &m->external;\n  if (!sm)\n    {\n      debug(\"error in memory selection, aborting\\n\");      \n      exit (-1);\n    }\n\n  sectors = BLOCK_SECTORS;\n  if (sm->version)\n    sectors = MEGABLOCK_SECTORS;\n\n  return sectors;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* small hack to handle external addressing on different MPIO models */\n", "func_signal": "BYTE \nmodel2externalmem(mpio_model_t model)", "code": "{\n  BYTE m;\n\n  switch(model) \n    {\n    case MPIO_MODEL_DMG:\n    case MPIO_MODEL_DMG_PLUS:\n    case MPIO_MODEL_FD100:\n    case MPIO_MODEL_FY100:\n    case MPIO_MODEL_FY200:\n    case MPIO_MODEL_VP_01:\n      m = 0x80;\n      break;\n    default:\n      m = 0x10;\n    }\n\n  return m;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* directory operations */\n", "func_signal": "BYTE *\nmpio_directory_open(mpio_t *m, mpio_mem_t mem)", "code": "{  \n  BYTE *out;  \n  if (mem == MPIO_EXTERNAL_MEM) {\n    if (m->external.id)  { \n      out = m->external.cdir->dir;\n    } else {\n      return NULL;\n    }\n  } else {    \n    if (!m->internal.size)\n      return NULL;\n    out = m->internal.cdir->dir;\n  }\n\n  if (out[0] == 0x00) \n    {\n      debugn(3, \"directory is empty\\n\");\n      return NULL;\n    }\n  \n  debugn(3, \"first dentry: %08x\\n\", out);\n  \n  return out;  \n}", "path": "libmpio\\src\\directory.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/*\n * read chunk of data from MPIO filedescriptor\n *\n * parameter:\n *\n * fd:        filedescriptor\n * block:     return buffer (has to be num_bytes)\n * num_bytes: size of return buffer\n *\n */\n", "func_signal": "int\nmpio_io_bulk_read (int fd, CHAR *block, int num_bytes)", "code": "{\n  int total_read, count, bytes_left;\n  CHAR *p;\n\n  total_read = 0;\n  bytes_left = num_bytes;\n  p = block;\n\n  do\n  {\n    count = read (fd, p, bytes_left);\n\n    if (count > 0)\n      {\n        total_read += count;\n\tbytes_left -= count;\n\tp += count;\n      }\n  } while (total_read < num_bytes && count > 0);\n\n  return total_read;\n}", "path": "libmpio\\src\\io.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* helper */\n", "func_signal": "BYTE\nmpiosh_ftype2ascii(BYTE ftype)", "code": "{\n  switch(ftype) \n    {\n    case FTYPE_CONF:\n    case FTYPE_FONT:\n    case FTYPE_OTHER:\n    case FTYPE_MEMO:\n    case FTYPE_WAV:\n    case FTYPE_ENTRY:\n    case FTYPE_DIR:\n    case FTYPE_PLAIN:\n      return ftype;\n    case FTYPE_DIR_RECURSION:\n      return 'r';\n    case FTYPE_CHAN:\n      return 'c';\n    case FTYPE_MUSIC:\n      return '-';\n    default:\n      return '?';\n    }\n  return '?';\n}", "path": "src\\callback.c", "repo_name": "PromyLOPh/mpiosh", "stars": 2, "license": "gpl-2.0", "language": "c", "size": 732}
{"docstring": "/* imprime o tempo em segundos dividido em dias, horas, minutos, seg.*/\n", "func_signal": "void printtime(long t)", "code": "{\n  long dias,horas,minutos,segundos;\n  if (t<1) {printf(\"<1 segundo\");return;}\n  minutos = (long) t/60;\n  segundos = t - minutos*60;\n  horas = (long) minutos/60;\n  minutos = minutos-horas*60;\n  dias = (long) horas/24;\n  horas = horas - dias*24;\n  if (dias==1) printf(\"%ld dia\",dias);\n  if (dias>1) printf(\"%ld dias\",dias);\n  if (dias && (horas||minutos||segundos)) printf(\", \");\n  if (horas==1) printf(\"%ld hora\",horas);\n  if (horas>1) printf(\"%ld horas\",horas);\n  if (horas && (minutos||segundos)) printf(\", \");\n  if (minutos==1) printf(\"%ld minuto\",minutos);\n  if (minutos>1) printf(\"%ld minutos\",minutos);\n  if (minutos && segundos) printf(\", \");\n  if (segundos==1) printf(\"%ld segundo\",segundos);\n  if (segundos>1) printf(\"%ld segundos\",segundos);\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\tempo.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/*\n      Inicializacao de uma variavel do tipo Union find.\n      Aloca espaco para armazenar os elementso a pesquisar.\n      Aloca espaco para armazenar os nomes dos conjuntos de cada elemento.\n*/\n", "func_signal": "boolean init_uf(unionfindtype *uf, int n)", "code": "{\n  int i;\n  /* alocacao de memoria necessaria */\n  uf->size = n;\n  uf->father = (int *) malloc(sizeof(int) * n);\n  if (!uf->father) return (false);\n  \n  uf->cardinality = (int *) malloc(sizeof(int) * n);\n  if (!uf->cardinality) {\n    free(uf->father);\n    return(false);\n  }\n\n  /* atribuicao inicial para que o nome dos conjuntos onde esta' cada */\n  /* elemento seja unico para cada elemento */\n  \n  for (i=0;i<n;i++) {\n    uf->father[i] = i;\n    uf->cardinality[i]= 1;\n  }\n  return(true);\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\unionfin.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/**********************************************************************************\\\n*  Rotina que resolve uma mochila binaria por Programao Dinmica.\n*  Autor: Cid Carvalho de Souza\n*  Data: 10/2002\n*\n*  Objetivo: resolver uma mochila binaria maximizando o custo cx\n*  e com uma restricao do tipo wx <= b.\n*\n*  Entrada: vetores $c$ (custos), $w$ (pesos), $b$ (capacidade)\n*  e $n$ numero de itens.\n*\n*  Saidas: vetor $x$ (solucoes) e $z$ (valor otimo).\n*\n*  Observacao: todos os vetores sao inteiros, exceto os custos\n*  que sao \"double\", assim como o valor otimo $z$.\n*\n*  IMPORTANTE: todos os  vetores comecam na posicao zero  mas os itens\n*  so supostamente numerados de 1 a n. Assim, c[1]  o custo do item 1.\n*\n\\**********************************************************************************/\n", "func_signal": "void Mochila(double *c,int *w,int b,int n,int *x,double *val)", "code": "{\n  int k, d;\n\n  double aux, limite=0.0;   /* variaveis auxiliares para calculos de custo */\n  double **z;   /* matriz de resultados intermediarios da Prog. Din */\n\n  /* aloca espaco para $z$ */\n  z=(double **)malloc((n+1)*sizeof(double *));\n  for(k=0;k<=n;k++) z[k]=(double *)malloc((b+1)*sizeof(double));\n\n\n  /* inicializa o $z$ */\n  for(k=0;k<=n;k++)\n    for(d=0;d<=b;d++) z[k][d]=0.0;\n\n  /* calculo do \"limite\" (numero negativo cujo valor absoluto eh \n     maior que o valor otimo com certeza): foi inicializado com ZERO. */\n  for(k=1;k<=n;k++) limite=limite-c[k];\n\n  /* prog. din.: completando a matriz z */\n  for(k=1;k<=n;k++)\n    for(d=1;d<=b;d++){\n      /* aux sera igual ao valor de z[k-1][d-w[k]] quando esta celula \n         existir ou sera igual ao \"limite\" caso contrario. */\n      aux = (d-w[k]) < 0 ? limite : z[k-1][d-w[k]] ;\n      z[k][d] = (z[k-1][d] > aux+c[k]) ? z[k-1][d] : aux+c[k];\n    }\n\n  /* carrega o vetor solucao */\n  for(k=0;k<=n;k++) x[k]=0;\n\n  d=b;   k=n;\n  while ((d!=0) && (k!=0)) {\n    if (z[k-1][d] != z[k][d]) {\n      d=d-w[k];   x[k]=1;\n    }\n    k--;\n  }\n\n  *val=z[n][b];\n\n  /* desaloca espaco de $z$ */\n  for(k=0;k<=n;k++) free(z[k]);\n  free(z);\n\n  return;\n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* imprime o tempo no formato hh:mm:ss \n   e se tiver dias, imprime no formato dd_hh:mm:ss */\n", "func_signal": "void shortprinttime(char *s,long t)", "code": "{\n  long dias,horas,minutos,segundos;\n  int i;\n  minutos = (long) t/60;\n  segundos = t - minutos*60;\n  horas = (long) minutos/60;\n  minutos = minutos-horas*60;\n  dias = (long) horas/24;\n  horas = horas - dias*24;\n  s[0]='\\0';\n  if (dias==0)\n    sprintf(s,\"%2ldh:%2ldm:%2lds\",horas,minutos,segundos);\n  else\n    sprintf(s,\"%2ldd,%2ldh:%2ldm:%2lds\",dias,horas,minutos,segundos);\n  for (i=0;i<strlen(s);i++)\n    if (s[i]==' ') s[i]='0';\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\tempo.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* Funcao para imprimir uma variavel de unionfind */\n", "func_signal": "void print_uf(unionfindtype *uf)", "code": "{\n  int i;\n  printf(\"Elem. \");\n  for (i=0;i<uf->size;i++) printf(\" %2d\",i);\n  printf(\"\\nConj. \");\n  for (i=0;i<uf->size;i++) printf(\" %2d\",find_uf(uf,i));\n  printf(\"\\n\\n\");\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\unionfin.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* rotina auxiliar  de comparacao para o \"qsort\".  CUIDADO: Feito para\n * ordenar em ordem *DECRESCENTE* ! */\n", "func_signal": "int ComparaRegAux(const void *a, const void *b)", "code": "{\n    int ret;\n    if (((RegAux *)a)->valor > ((RegAux *)b)->valor) ret=-1;\n    else {\n\tif (((RegAux *)a)->valor < ((RegAux *)b)->valor) ret=1;\n\telse ret=0;\n    }\n    return ret; \n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/*********************************************************************************/\n", "func_signal": "void ImprimeSol(double *a)", "code": "{\n  int i;\n  for(i=0;i<n;i++) if (a[i] > EPSILON)\n    printf(\"x[%3d]=%12.6f (w[%3d]=%6d, c[%3d]=%12.6f)\\n\",i,a[i],i,w[i],i,c[i]);\n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* init_maxflow */\n", "func_signal": "void oddfini_maxflow ()", "code": "{\n  free (active);\n  free (number);\n}", "path": "CODIGO\\ugraph\\grafo\\ugraph\\source\\maxflow.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/**********************************************************************************\\\n * Rotina copiada de programas exemplo do XPRES ... :(\n * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n *\n * Name:         errormsg \n * Purpose:      Display error information about failed subroutines.\n * Arguments:    const char *sSubName   Subroutine name             \n *               int nLineNo            Line number                 \n *               int nErrCode           Error code                  \n * Return Value: None                                               \n\\**********************************************************************************/\n", "func_signal": "void errormsg(const char *sSubName,int nLineNo,int nErrCode)", "code": "{\n   int nErrNo;             /* Optimizer error number */\n\n   /* Print error message */\n   printf(\"The subroutine %s has failed on line %d\\n\",sSubName,nLineNo);\n\n   /* Append the error code, if it exists */\n   if (nErrCode!=-1) printf(\"with error code %d\\n\",nErrCode);\n\n   /* Append Optimizer error number, if available */\n   if (nErrCode==32) {\n      XPRSgetintattrib(prob,XPRS_ERRORCODE,&nErrNo);\n      printf(\"The Optimizer error number is: %d\\n\",nErrNo);\n   }\n\n   /* Free memory, close files and exit */\n   XPRSdestroyprob(prob);\n   XPRSfree();\n   exit(nErrCode);\n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* faz uma busca de um elemento na variavel union find */\n/* aproveita o caminho percorrido para aproximar os elementos que estao no */\n/* mesmo caminho com o nome do conjunto */\n", "func_signal": "int find_uf(unionfindtype *uf,int element)", "code": "{\n  int block,fatherelement;\n\n  if ((element>=0) &&(element < uf->size)) {\n    block = element;\n    \n    /* primeiro encontre o nome do elemento. */\n    while (uf->father[block] != block) block = uf->father[block];\n    \n\n    /* percorra o caminho ate' o nome do conjunto e va atualizando */\n    /* o nome do conjunto de todos os elementos do caminho percorrido. */\n    while (uf->father[element] != element) {\n      fatherelement = uf->father[element];\n      uf->father[element] = block;\n      element = fatherelement;\n    }\n    return(block);\n  }else {\n    printf(\"Uso indevido da funcao \\\"find_uf\\\"\\n\");\n    return(0);\n  }\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\unionfin.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* mensagem de uso do programa */\n", "func_signal": "void showUsage()", "code": "{\n\tprintf (\"Uso: knap <estrategia> <prof_max_para_corte> < <instancia> \\n\");\n        printf (\"- estrategia: string de \\\"0\\\"\\'s e \\\"1\\\"\\'s de tamanho 2.\\n\");\n\tprintf (\"  - 1a. posio  \\\"1\\\" se a heurstica primal  usada. \\n\");\n\tprintf (\"  - 2a. posio  \\\"1\\\" se as minhas \\\"cover inequalities\\\" forem separadas.\\n\");\n\tprintf (\"    Nota: estrategia=\\\"00\\\" equivale a um Branch-and-Bound puro\\n\");\n\tprintf (\"- prof_max_para_corte: maior altura de um n para aplicar cortes\\n\");\n\tprintf (\"  (default=1000000) \\n\");\n\tprintf (\"- instancia: nome do arquivo contendo a instncia \\n\");\n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* imprime o tempo em segundos dividido em dias, horas, minutos, seg.*/\n", "func_signal": "void sprinttime(char *s,long t)", "code": "{\n  long dias,horas,minutos,segundos;\n  char aux[100];\n  if (t<1) {sprintf(s,\"%s\",\"<1 segundo\");return;}\n  minutos = (long) t/60;\n  segundos = t - minutos*60;\n  horas = (long) minutos/60;\n  minutos = minutos-horas*60;\n  dias = (long) horas/24;\n  horas = horas - dias*24;\n  s[0]='\\0';\n  if (dias==1) {sprintf(aux,\"%ld dia\",dias);strcat(s,aux);}\n  if (dias>1) {sprintf(aux,\"%ld dias\",dias);strcat(s,aux);}\n  if (dias && (horas||minutos||segundos)) strcat(s,\", \");\n  if (horas==1) {sprintf(aux,\"%ld hora\",horas);strcat(s,aux);}\n  if (horas>1) {sprintf(aux,\"%ld horas\",horas);strcat(s,aux);}\n  if (horas && (minutos||segundos)) strcat(s,\", \");\n  if (minutos==1) {sprintf(aux,\"%ld minuto\",minutos);strcat(s,aux);}\n  if (minutos>1) {sprintf(aux,\"%ld minutos\",minutos);strcat(s,aux);}\n  if (minutos && segundos) strcat(s,\", \");\n  if (segundos==1) {sprintf(aux,\"%ld segundo\",segundos);strcat(s,aux);}\n  if (segundos>1) {sprintf(aux,\"%ld segundos\",segundos);strcat(s,aux);}\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\tempo.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* =====================================================================\n * Rotina (callback) para salvar a  melhor solucao.  Roda para todo n\n * onde acha solucao inteira.\n * =====================================================================\n*/\n", "func_signal": "void XPRS_CC SalvaMelhorSol(XPRSprob prob, void *my_object)", "code": "{\n   int i, cols, peso_aux=0, node;\n   double objval;\n   Boolean viavel;\n\n   /* pega o numero do n corrente */\n   xpress_ret=XPRSgetintattrib(prob,XPRS_NODES,&node);\n   if (xpress_ret) \n     errormsg(\"SalvaMelhorSol: rotina XPRSgetintattrib.\\n\",__LINE__,xpress_ret);\n\n   xpress_ret=XPRSgetintattrib(prob,XPRS_COLS,&cols);\n   if (xpress_ret) \n       errormsg(\"SalvaMelhorSol: rotina XPRSgetintattrib\\n\",__LINE__,xpress_ret);\n\n   xpress_ret=XPRSgetdblattrib(prob,XPRS_LPOBJVAL,&objval);\n   if (xpress_ret) \n       errormsg(\"SalvaMelhorSol: rotina XPRSgetdblattrib\\n\",__LINE__,xpress_ret);\n\n   xpress_ret=XPRSgetsol(prob,x,NULL,NULL,NULL);\n   if (xpress_ret) \n     errormsg(\"SalvaMelhorSol: Erro na chamada da rotina XPRSgetsol\\n\",__LINE__,xpress_ret);\n\n   /* testa se a soluo  vivel */\n   for(i=0;i<cols;i++) peso_aux += x[i]*w[i];\n   viavel=(peso_aux <= W + EPSILON);\n\n   /*\n   printf(\"\\n..Encontrada uma soluo inteira (n=%d): valor=%f, peso=%d,\",\n\t  node,objval,peso_aux);\n   if (viavel) printf(\" viavel\\n\"); else printf(\" inviavel\\n\");\n   for(i=0;i<cols;i++) \n     if (x[i]>EPSILON) printf(\" x[%3d] = %12.6f (w=%6d, c=%12.6f)\\n\",i,x[i],w[i],c[i]);\n   */\n\n   /* se a solucao tiver custo melhor que a melhor solucao disponivel entao salva */\n   if ((objval > zstar-EPSILON) && viavel) {\n\n     printf(\".. atualizando melhor soluo ...\\n\");\n     for(i=0;i<cols;i++) xstar[i]=x[i];\n     zstar=objval;\n     \n     /* informa xpress sobre novo incumbent */\n     xpress_ret=XPRSsetdblcontrol(prob,XPRS_MIPABSCUTOFF,zstar+1.0-EPSILON);\n     if (xpress_ret) \n       errormsg(\"SalvaMelhorSol: XPRSsetdblcontrol.\\n\",__LINE__,xpress_ret);\n     \n     NODE_BEST_INTEGER_SOL=node; \n     /* Impresso para sada */\n     printf(\"..Melhor soluo inteira encontrada no n %d, peso %d e custo %12.6f\\n\",\n\t    NODE_BEST_INTEGER_SOL,peso_aux,zstar);\n     printf(\"..Soluo encontrada: \\n\");\n     ImprimeSol(x);\n   }\n   \n   return;\n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* This maxflow version is for undirected graphs and\n     computes maximum flow only, i.e. the resulting flow\n     is not computed for all edges, the graph structure\n     is expected to be initialized already, the function\n     \"init_maxflow\" must be called first, then \"maxflow\"\n     may be called any number of times, the function \n     \"fini_maxflow\" should be called after the final \n     maxflow call.                                      */\n", "func_signal": "BOOL oddinit_maxflow (long n)", "code": "{\n  active = (oddnode **) malloc ((n+1L) * sizeof (oddnode *));\n    /* holds stacks of active nodes arranged by distances */ \n  if (active == (oddnode **) 0)\n   { printf (\"Unable to allocate memory\\n\");\n     return (FALSE);\n   }\n  number = (long *) malloc ((n+1L) * sizeof (long));\n    /* counts occurences of node distances in set \n       of alive nodes, i.e. nodes not contained in\n       the set of nodes disconnected from the sink */ \n  if (number == (long *) 0)\n   { printf (\"Unable to allocate memory\\n\");\n     return (FALSE);\n   }\n  co_check = TRUE;\n  return (TRUE);\n\n}", "path": "CODIGO\\ugraph\\grafo\\ugraph\\source\\maxflow.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* global_relabel */\n", "func_signal": "double oddmaxflow (oddgraph *gr, oddnode *s_ptr, oddnode *t_ptr)", "code": "{\n  /* Determines maximum flow and minimum cut between nodes\n     s (= *s_ptr) and t (= *t_ptr) in an undirected graph  \n\n     References:\n     ----------\n     A. Goldberg/ E. Tarjan: \"A New Approach to the\n     Maximum Flow Problem\", in Proc. 18th ACM Symp. \n     on Theory of Computing, 1986.\n  */\n  oddnode *aptr, *nptr, *q_front, *q_rear;\n  /*oddnode **ptr;*/\n  oddedge *eptr/*, *my_scan_ptr*/;\n  long n, m, level, i, n_discharge;\n  double incre;\n  long /*count, dist,*/ dmin/*, *upper, *lower*/;\n  double cap;\n  /*char any;*/\n   \n  /* node ids range from 1 to n, node array indices  \n     range from 0 to n-1                             */\n\n  n = gr->n_nodes;\n  for (nptr = &(gr->nodes[n-1L]); nptr >= gr->nodes; nptr--)\n    {  nptr->scan_ptr = nptr->first_edge;\n       if (nptr->scan_ptr == ODDNILE)\n\t{ fprintf (stderr, \"isolated node in input graph (maxflow.c)\\n\");\n\t  return (FALSE);\n        }\n       nptr->excess = 0.0L;\n       nptr->stack_link = ODDNILN;\n       nptr->alive = TRUE;\n       nptr->unmarked = TRUE;\n    }\n  m = gr->n_edges;\n  for (eptr = &(gr->edges[2L*m-1L]); eptr >= gr->edges; eptr--)\n     eptr->rcap = eptr->cap;\n      \n  for (i = n; i >= 0L; i--)\n    { number[i] = 0L;\n      active[i] = ODDNILN;\n    }\n  t_ptr->dist = 0L;\n\n    /* breadth first search to get exact distances \n       from sink and for test of graph connectivity */\n\n  t_ptr->unmarked = FALSE; \n  q_front = t_ptr;\n  q_rear = q_front;\n bfs_next:\n  level = q_rear->dist + 1L;\n  eptr = q_rear->first_edge;\n  while (eptr != ODDNILE)\n     { if (eptr->adjac->unmarked && eptr->back->rcap > EPS)\n        { nptr = eptr->adjac;\n\t  nptr->unmarked = FALSE;\n\t  nptr->dist = level;\n\t  ++number[level];\n          q_front->bfs_link = nptr;\n\t  q_front = nptr;\n        }\n       eptr = eptr->next;\n     }\n  if (q_rear == q_front)\n    goto bfs_ready;\n\n  q_rear = q_rear->bfs_link;\n  goto bfs_next;\n\n bfs_ready:\n  if (co_check)\n   { co_check = FALSE;\n     for (nptr = &(gr->nodes[n-1]); nptr >= gr->nodes; --nptr)\n       if (nptr->unmarked)\n        { fprintf (stderr,\"Input graph not connected\\n\");\n          return (-1.0L);\n        }\n   }\n\n\n  s_ptr->dist = n; /* number[0] and number[n] not required */\n  t_ptr->dist = 0L;\n  t_ptr->excess = 1.0L;  /* to be subtracted again */\n\n\n  /* initial preflow push from source node */\n\n  max_dist = 0L;  /* = max_dist of active nodes */\n  eptr = s_ptr->first_edge;\n  while (eptr != ODDNILE)\n     { nptr = eptr->adjac;\n       cap = eptr->rcap;\n       nptr->excess += cap;\n       s_ptr->excess -= cap;\n       eptr->back->rcap += cap;\n       eptr->rcap = 0.0L;\n\n       if (nptr != t_ptr && nptr->excess <= cap + EPS) \n        { /* push node nptr onto stack for nptr->dist,\n\t     but only once in case of double edges     */\n\t  nptr->stack_link = active[nptr->dist];\n\t  active[nptr->dist] = nptr;\n          if (nptr->dist > max_dist)\n\t    max_dist = nptr->dist;\n        }\n       eptr = eptr->next;\n     }\n\n  s_ptr->alive = FALSE;\n  bound = n - 1L; \n  n_discharge = 0L;\n\n  /* main loop */\n\n  do { /* get maximum distance active node */\n       aptr = active[max_dist];\n       while (aptr != ODDNILN)\n\t { active[max_dist] = aptr->stack_link;\n\t   eptr = aptr->scan_ptr;\n\n           edge_scan:  /* for current active node  */\n\t     nptr = eptr->adjac;\n             if (nptr->dist == aptr->dist - 1L &&\n\t\t eptr->rcap > EPS) \n              { incre = aptr->excess;\n\t        if (incre <= eptr->rcap)\n\t         { /* perform a non saturating push */\n\t           eptr->rcap -= incre;\n\t           eptr->back->rcap += incre;\n\t\t   aptr->excess = 0.0L;\n                   nptr->excess += incre;\n\t\t   if (nptr->excess <= incre + EPS)\n\t\t    { /* push nptr onto active stack */\n\t\t      nptr->stack_link = active[nptr->dist];\n\t\t      active[nptr->dist] = nptr;\n                    }\n                   aptr->scan_ptr = eptr;\n\t\t   goto node_ready;\n                 }\n                else\n\t         { /* perform a saturating push */\n\t\t   incre = eptr->rcap;\n\t\t   eptr->back->rcap += incre; \n\t\t   aptr->excess -= incre;\n\t\t   nptr->excess += incre;\n\t\t   eptr->rcap = 0.0L;\n\t\t   if (nptr->excess <= incre + EPS)\n\t\t    { /* push nptr onto active stack */\n                      nptr->stack_link = active[nptr->dist];\n\t\t      active[nptr->dist] = nptr;\n                    }\n\t\t   if (aptr->excess <= EPS)\n\t\t    { aptr->scan_ptr = eptr;\n\t\t      goto node_ready;\n                    }\n                 }\n              }\n             if (eptr->next == ODDNILE) \n              { /* all incident arcs scanned, but node still\n\t\t   has positive excess, check if for all nptr       \n\t\t   nptr->dist != aptr->dist                  */\n\n                if (number[aptr->dist] == 1L)\n\t\t { /* put all nodes v with dist[v] >= dist[a] \n\t\t      into the set of \"dead\" nodes since they\n\t\t      are disconnected from the sink          */\n                     \n\t\t   for (nptr = &(gr->nodes[n-1L]);\n\t\t\tnptr >= gr->nodes; nptr--)\n                     if (nptr->alive &&\n\t\t\t nptr->dist > aptr->dist)\n\t\t      { --number[nptr->dist];\n\t\t\tactive[nptr->dist] = ODDNILN; \n\t\t        nptr->alive = FALSE; \n\t\t\tnptr->dist = n;\n\t\t\t--bound;\n\t\t      }\n                   --number[aptr->dist];\n\t\t   active[aptr->dist] = ODDNILN;\n\t\t   aptr->alive = FALSE;\n\t\t   aptr->dist = n;\n\t\t   --bound;\n\t\t   goto node_ready;\n                 }\n\t        else\n\t\t { /* determine new label value */\n                   dmin = n;\n\t\t   aptr->scan_ptr = ODDNILE;\n\t\t   eptr = aptr->first_edge;\n\t\t   while (eptr != ODDNILE)\n\t\t      { if (eptr->adjac->dist < dmin\n\t\t\t    && eptr->rcap > EPS)\n                         { dmin = eptr->adjac->dist;\n\t\t\t   if (aptr->scan_ptr == ODDNILE)\n\t\t\t     aptr->scan_ptr = eptr;\n                         }\n                        eptr = eptr->next;\n                      }\n\t\t   if (++dmin < bound)\n\t\t    { /* ordinary relabel operation */\n\t\t      --number[aptr->dist];\n\t\t      aptr->dist = dmin;\n\t\t      ++number[dmin];\n\t\t      max_dist = dmin;\n                      eptr = aptr->scan_ptr;\n\t\t      goto edge_scan;\n                    }\n                   else\n\t\t    { aptr->alive = FALSE;\n\t\t      --number[aptr->dist];\n\t\t      aptr->dist = n;\n\t\t      --bound;\n\t\t      goto node_ready;\n                    }\n                 }\n              }\n             else\n\t      { eptr = eptr->next;\n                goto edge_scan;\n              }\n\n          node_ready: \n\t   ++n_discharge;\n\t   if (n_discharge == n)\n\t    { n_discharge = 0L;\n\t      oddglobal_relabel (gr, t_ptr);\n            }\n\t   aptr = active[max_dist];\n         } /* aptr != ODDNILN */ \n       --max_dist;\n     } \n  while (max_dist > 0L);  \n\n  return (t_ptr->excess - 1.0L);\n}", "path": "CODIGO\\ugraph\\grafo\\ugraph\\source\\maxflow.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* fini_maxflow */\n", "func_signal": "void oddglobal_relabel (oddgraph *gr, oddnode *tptr)", "code": "{ \n  /* breadth first search to get exact distance labels\n     from sink with reordering of stack of active nodes */\n\n  oddnode *front, *rear, *nptr, **ptr;\n  oddedge *eptr;\n  long n, level, count, i;\n\n  n = gr->n_nodes;\n  for (nptr = &(gr->nodes[n-1L]); nptr >= gr->nodes; nptr--)\n    { nptr->unmarked = TRUE;\n      nptr->stack_link = ODDNILN;\n      nptr->scan_ptr = nptr->first_edge;\n    }\n  tptr->unmarked = FALSE;\n     /* initialize stack of active nodes */\n  for (ptr = &(active[n]); ptr >= active; ptr--)\n    *ptr = ODDNILN;\n  for (i = 0L; i <= n; i++)\n    number[i] = 0L;\n  max_dist = 0L;\n  count = 1L;     /* number of alive nodes */\n  front = tptr;\n  rear = front;\n\n bfs_next:\n  level = rear->dist + 1L;\n  eptr = rear->first_edge;\n  while (eptr != ODDNILE)\n     { nptr = eptr->adjac;\n       if (nptr->alive && nptr->unmarked\n\t               && eptr->back->rcap > EPS) \n\t{ nptr->unmarked = FALSE;\n\t  nptr->dist = level;\n\t  ++count;\n\t  ++number[level];\n\t  if (nptr->excess > EPS)\n           { nptr->stack_link = active[level];\n\t     active[level] = nptr;\n\t     max_dist = level;\n           }\n\t  front->bfs_link = nptr;\n\t  front = nptr;\n        }\n       eptr = eptr->next;\n     }\n  if (front == rear)\n    goto bfs_ready;\n       \n  rear = rear->bfs_link;\n  goto bfs_next;\n\n bfs_ready: \n\n  if (count < bound)\n   { /* identify nodes that are marked alive but have\n\tnot been reached by BFS and mark them as dead  */\n     for (nptr = &(gr->nodes[n-1L]); nptr >= gr->nodes; nptr--)\n       if (nptr->unmarked && nptr->alive)\n        { nptr->dist = n;\n          nptr->alive = FALSE;\n        }\n     bound = count;\n   }\n\n}", "path": "CODIGO\\ugraph\\grafo\\ugraph\\source\\maxflow.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* Fecha uma variavel do tipo unionfind e coloca a disposicao do sistema a \n   memoria usada para armazenar o nome dos conjuntos e a cardinalidade de\n   cada conjunto. */\n", "func_signal": "void close_uf(unionfindtype *uf)", "code": "{\n  if ((uf->father) && (uf->cardinality)) {\n    free(uf->father);\n    free(uf->cardinality);\n  }else{\n    printf(\"A funcao \\\"close_uf\\\" detetou erro de inicializacao \"\n\t   \"de seu parametro.\\n\");\n  }\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\unionfin.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* reinicializa o campo onde esta os valores dos nomes dos conjuntos onde */\n/* esta' cada elemento de forma que o nome de seu conjunto seja unico. */\n", "func_signal": "boolean reinit_uf(unionfindtype *uf)", "code": "{\n  int i;\n  if ((!uf->father) || (!uf->cardinality)) return (false);\n  for (i=0;i<uf->size;i++) {\n    uf->father[i] = i;\n    uf->cardinality[i] = 1;\n  }\n  return(true);\n}", "path": "CODIGO\\ugraph\\grafo\\myutil\\source\\unionfin.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/**********************************************************************************\\\n* Rotina para separacao de Cover inequalities. Roda em todo n.\n* Autor: Cid Carvalho de Souza \n* Data: segundo semestre de 2003\n\\**********************************************************************************/\n", "func_signal": "int XPRS_CC Cortes(XPRSprob prob, void* data)", "code": "{\n    int encontrou, i, irhs, k, node, node_depth, solfile, ret;\n    int nLPStatus, nIntInf;\n\n    /*  variaveis para a separacao das cover inequalities */\n    int *peso, capacidade, nitem, *sol;\n    double *custo, val, lpobjval, ajuste_val;\n\n\n    /* se for B&B puro e no usar Heurstica Primal, no faz nada */\n    if ( (!BRANCH_AND_CUT) && (!HEURISTICA_PRIMAL)) return 0;\n\n    /* Recupera a  status do LP e o  nmero de inviabilidades inteiras\n     * Procura  cortes e executa heurstica primal  (quando tiver sido\n     *  solicitado) apenas  se o  LP  for timo  e a  soluo no  for\n     * inteira. */\n    XPRSgetintattrib(prob,XPRS_LPSTATUS,&nLPStatus);\n    XPRSgetintattrib(prob,XPRS_MIPINFEAS,&nIntInf);\n    if (!(nLPStatus == 1 && nIntInf>0)) return 0;\n    \n    /* Muda  o parmetro  SOLUTIONFILE para pegar  a soluo do  LP da\n        memria. LEIA O MANUAL PARA ENTENDER este trecho */\n    XPRSgetintcontrol(prob,XPRS_SOLUTIONFILE,&solfile);\n    XPRSsetintcontrol(prob,XPRS_SOLUTIONFILE,0);\n    /* Pega a soluo do LP. */\n    XPRSgetsol(prob,x,NULL,NULL,NULL);\n    /* Restaura de volta o valor do SOLUTIONFILE */\n    XPRSsetintcontrol(prob,XPRS_SOLUTIONFILE,solfile);\n\n    /* verifica o nmero do n em que se encontra */\n    XPRSgetintattrib(prob,XPRS_NODES,&node);\n\n    /* Imprime cabealho do n */\n    printf(\"\\n=========\\n\");\n    printf(\"N %d\\n\",node);\n    printf(\"\\n=========\\n\");\n    printf(\"Lao de separao: %d\\n\",itersep);\n \n    /* executa a heurstica primal se for o caso */\n    if (HEURISTICA_PRIMAL) HeuristicaPrimal(node);\n\n    /* pega o valor otimo do LP ... */\n    XPRSgetdblattrib(prob, XPRS_LPOBJVAL,&lpobjval);\n\n    /* Imprime dados sobre o n */\n    printf(\".Valor timo do LP: %12.6f\\n\",lpobjval);\n    printf(\".Soluo tima do LP:\\n\");\n    ImprimeSol(x);\n    printf(\".Rotina de separao\\n\");\n\n    /* guarda o valor da funo objetivo no primeiro n */\n    if (node==1) objval_node1=lpobjval;\n\n        /* guarda o valor da funo objetivo da primeira relaxao */\n    if ((node==1) && (!itersep)) objval_relax=lpobjval;\n\n    /* sai fora se for branch and bound puro */\n    if (!BRANCH_AND_CUT) return 0;\n\n    /*  sai  fora se  a  profundidade do  n  corrente  for maior  que\n     * MAX_NODE_DEPTH_FOR_SEP. */\n    xpress_ret=XPRSgetintattrib(prob,XPRS_NODEDEPTH,&node_depth);\n    if (xpress_ret) \n       errormsg(\"Cortes: erro na chamada da rotina XPRSgetintattrib.\\n\",__LINE__,xpress_ret);\n    if (node_depth > MAX_NODE_DEPTH_FOR_SEP) return 0;\n\n    /* varivel indicando se achou desigualdade violada ou no */\n    encontrou=0; \n    \n    /* carga dos parametros para a rotina de separacao da Cover Ineq */\n    \n    /* ATENCAO:  A rotina Mochila nao  usa a posicao  zero dos vetores\n       custo, peso  e sol,  portanto para carregar  o problema  e para\n       pegar a solucao eh preciso acertar os indices */\n\n    peso=(int *)malloc(sizeof(int)*(n+1)); /* +1 !! */\n    assert(peso);\n    capacidade=0;\n\n    for(i=0;i<n;i++){\n      peso[i+1]=w[i]; /* +1 !!! */\n      capacidade=capacidade+peso[i+1]; /* +1 !! */\n    }\n    capacidade=capacidade-1-W;\n    \n    /* calcula custos para o problema de separao (mochila) */\n    ajuste_val=0.0; /* ajuste para o custo do pbm da separao */\n    custo=(double *)malloc(sizeof(double)*(n+1));  /* +1 !!! */\n    assert(custo);\n    for(i=0;i<n;i++) {\n      custo[i+1]=1.0-x[i]; \n      ajuste_val += custo[i+1];\n    }\n    \n    /* aloca espaco para o vetor solucao da rotina Mochila */\n    sol=(int *)malloc(sizeof(int)*(n+1)); /* +1 !!! */\n    assert(sol);\n\n    /* resolve a mochila usando Programao Dinmica */\n    Mochila(custo,peso,capacidade,n,sol,&val);\n\n    /* calculo do RHS da desigualdade de cobertura */\n    irhs=0;\n    for(i=1;i<=n;i++)\n      if (sol[i]==0) irhs++;\n    \n    /* verifica se a desigualdade estah violada */\n    if (ajuste_val - val < 1.0-EPSILON) {\n      encontrou=1;\n      \n      /* prepara a insercao do corte */\n      mtype[0]=1;\n      qrtype[0]='L';\n      drhs[0]=(double)irhs - 1.0;\n      mstart[0]=0; mstart[1]=irhs;\n      k=0;\n      for(i=1;i<=n;i++)\n\tif (!sol[i]) {\n\t  mcols[k]=i-1;   dmatval[k]=1.0;   k++;\n\t}\n      assert(k==irhs);\n\n      /* Impresso do corte */\n      printf(\"..corte encontrado: (viol=%12.6f)\\n\\n   \",1.0-ajuste_val+val);\n      for(i=0;i<irhs;i++){\n\tprintf(\"x[%d] \",mcols[i]);\n\tif (i==irhs-1) printf(\"<= %d\\n\\n\",irhs-1);\n\telse printf(\"+ \");\n      }\n\n      /* adiciona o corte usando rotina XPRSaddcuts */\n      xpress_ret=XPRSaddcuts(prob, 1, mtype, qrtype, drhs, mstart, mcols, dmatval);\n      totcuts++;\n      if (xpress_ret) \n\terrormsg(\"Cortes: erro na chamada da rotina XPRSgetintattrib.\\n\",__LINE__,xpress_ret);\n      \n    }\n    else printf(\"..corte no encontrado\\n\");\n    \n    assert(peso && sol && custo);\n    free(peso);      free(sol);         free(custo); \n\n    printf(\"..Fim da rotina de cortes\\n\");\n\n    /* salva um arquivo MPS com o LP original */\n    xpress_ret=XPRSwriteprob(prob,\"LPcuts\",\"l\");\n    if (xpress_ret) \n      errormsg(\"Cortes: rotina XPRSwriteprob.\\n\",__LINE__,xpress_ret);\n\n\n    if ((encontrou) && (itersep < MAX_ITER_SEP)) \n      { itersep++; ret=1; /* continua buscando cortes neste n */ }\n    else\n      { itersep=0; ret=0; /* vai parar de buscar cortes neste n */}\n\n    return ret;\n    \n}", "path": "CODIGO\\Exemplo-BnC-mochila\\princ.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/* so' chamo esta rotina para um vertice v que seja branco */\n", "func_signal": "boolean gr_dfs_circuit(graphtype *g,int *nseq,int *seq,int *cor,\n\t\t       int *pilha,int npilha,int v,int pai_v,\n\t\t       boolean *edgesetmask)", "code": "{\n  int e,u,i,j,k;\n  cor[v] = GR_DFS_CIRCUIT_CINZA;\n  pilha[npilha] = v;\n  npilha++;\n  for (e=gr_getvertexfirstadj(g,v);e!=-1;e=gr_getvertexnextadj(g,v,e)){\n    /* se for uma aresta proibida, vai para a proxima */\n    if (!edgesetmask[e]) continue;\n    if (g->edge[e].v==v) u = g->edge[e].u;\n    else u = g->edge[e].v;\n    if (u==pai_v) continue;\n    if (cor[u]==GR_DFS_CIRCUIT_CINZA) { /* encontrou um circuito */\n      i=npilha-1;\n      while (pilha[i]!=u) i--;\n      /* localizei o inicio do circuito */\n      for (j=i,k=0;j<npilha;j++,k++)\n\tseq[k] = pilha[j];\n      *nseq = k;\n      return(true);\n    } else if (cor[u]==GR_DFS_CIRCUIT_BRANCO) {\n      if (gr_dfs_circuit(g,nseq,seq,cor,pilha,npilha,u,v,edgesetmask))\n\treturn(true);\n      cor[u] = GR_DFS_CIRCUIT_PRETO;\n    }\n  }\n  return(false);\n}", "path": "CODIGO\\ugraph\\grafo\\ugraph\\source\\circuit.c", "repo_name": "luisguilherme/mo420e-tp3", "stars": 2, "license": "None", "language": "c", "size": 3732}
{"docstring": "/*\n * mport_bundle_read_init(bundle, filename)\n *\n * connect the bundle struct to the file at filename.\n */\n", "func_signal": "int mport_bundle_read_init(mportBundleRead *bundle, const char *filename)", "code": "{\n  if ((bundle->filename = strdup(filename)) == NULL) \n    RETURN_ERROR(MPORT_ERR_FATAL, \"Couldn't dup filename\");\n    \n  if ((bundle->archive = archive_read_new()) == NULL)\n    RETURN_ERROR(MPORT_ERR_FATAL, \"Couldn't dup filename\");\n    \n  \n  archive_read_support_format_tar(bundle->archive);\n  archive_read_support_compression_bzip2(bundle->archive);\n  \n  if (archive_read_open_filename(bundle->archive, bundle->filename, 10240) != ARCHIVE_OK) {\n    RETURN_ERROR(MPORT_ERR_FATAL, archive_error_string(bundle->archive));\n  }\n  \n  return MPORT_OK;    \n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*  \n * mport_bundle_read_finish(bundle)\n *\n * close the file connected to the bundle, and free any memory allocated.\n */\n", "func_signal": "int mport_bundle_read_finish(mportInstance *mport, mportBundleRead *bundle)", "code": "{\n  int ret = MPORT_OK;\n    \n  if (archive_read_finish(bundle->archive) != ARCHIVE_OK)\n    ret = SET_ERROR(MPORT_ERR_FATAL, archive_error_string(bundle->archive));\n\n  if (bundle->stub_attached && (mport != NULL)) {\n    if (mport_detach_stub_db(mport->db) != MPORT_OK)\n      ret = mport_err_code();\n  }\n\n  if (bundle->tmpdir != NULL) {\n    if (mport_rmtree(bundle->tmpdir) != MPORT_OK)\n      ret = mport_err_code();\n  }      \n\n  free(bundle->tmpdir);\n  free(bundle->filename);\n  free(bundle);\n                  \n  return ret;\n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * Looks up a pkgname from the index and fills a vector of index entries\n * with the result.\n *\n * Globbing is supported, and the alias list is consulted.  The calling code\n * is responsible for freeing the memory allocated.  See\n * mport_index_entry_free_vec()\n */\n", "func_signal": "MPORT_PUBLIC_API int mport_index_lookup_pkgname(mportInstance *mport, const char *pkgname, mportIndexEntry ***entry_vec)", "code": "{\n  char *lookup;\n  int count, i, step;\n  sqlite3_stmt *stmt;\n  int ret = MPORT_OK;\n  mportIndexEntry **e;\n  \n  MPORT_CHECK_FOR_INDEX(mport, \"mport_index_lookup_pkgname()\")\n  \n  if (lookup_alias(mport, pkgname, &lookup) != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n\n  if (mport_db_prepare(mport->db, &stmt, \"SELECT COUNT(*) FROM index.packages WHERE pkg GLOB %Q\", lookup) != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n    \n  switch (sqlite3_step(stmt)) {\n    case SQLITE_ROW:\n      count = sqlite3_column_int(stmt, 0);\n      break;\n    case SQLITE_DONE:\n      ret = SET_ERROR(MPORT_ERR_FATAL, \"No rows returned from a 'SELECT COUNT(*)' query.\");\n      goto DONE;\n      break;\n    default:\n      ret = SET_ERROR(MPORT_ERR_FATAL, sqlite3_errmsg(mport->db));\n      goto DONE;\n      break;\n  }\n  \n  sqlite3_finalize(stmt);\n  \n  e = (mportIndexEntry **)calloc(count + 1, sizeof(mportIndexEntry *));\n  *entry_vec = e;\n  \n  if (count == 0) \n    return MPORT_OK;\n  \n  if (mport_db_prepare(mport->db, &stmt, \"SELECT pkg, version, comment, www, bundlefile FROM index.packages WHERE pkg GLOB %Q\", lookup) != MPORT_OK) {\n    ret = mport_err_code();\n    goto DONE;\n  }\n  \n  while (1) {\n    step = sqlite3_step(stmt);\n    \n    if (step == SQLITE_ROW) {\n      if ((e[i] = (mportIndexEntry *)malloc(sizeof(mportIndexEntry))) == NULL) {\n        ret = MPORT_ERR_FATAL;\n        goto DONE;\n      }\n      \n      e[i]->pkgname    = strdup(sqlite3_column_text(stmt, 0));\n      e[i]->version    = strdup(sqlite3_column_text(stmt, 1));\n      e[i]->comment    = strdup(sqlite3_column_text(stmt, 2));\n      e[i]->www        = strdup(sqlite3_column_text(stmt, 3));\n      e[i]->bundlefile = strdup(sqlite3_column_text(stmt, 4));\n      \n      if (e[i]->pkgname == NULL || e[i]->version == NULL || e[i]->comment == NULL || e[i]->www == NULL || e[i]->bundlefile == NULL) {\n        ret = MPORT_ERR_FATAL;\n        goto DONE;\n      }\n      \n      i++;\n    } else if (step == SQLITE_DONE) {\n      e[i] = NULL;\n      goto DONE;\n    } else {\n      ret = SET_ERROR(MPORT_ERR_FATAL, sqlite3_errmsg(mport->db));\n      goto DONE;\n    }\n  }\n      \n  DONE:\n    free(lookup);\n    sqlite3_finalize(stmt);\n    return ret; \n}", "path": "index.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* \n * mport_bundle_read_prep_for_install(mport, bundle)\n * \n * Extract the metafile into a tmpdir that the bundle maintains, attach the stub db for the \n * instance master database.\n */\n", "func_signal": "int mport_bundle_read_prep_for_install(mportInstance *mport, mportBundleRead *bundle)", "code": "{\n  sqlite3_stmt *stmt;\n  int bundle_version;\n  int ret;\n  \n  if (mport_bundle_read_extract_metafiles(bundle, &(bundle->tmpdir)) != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n  \n  if (mport_attach_stub_db(mport->db, bundle->tmpdir) != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n\n  bundle->stub_attached = 1;\n    \n  if (mport_db_prepare(mport->db, &stmt, \"SELECT value FROM stub.meta WHERE field='bundle_format_version'\") != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n\n  ret = sqlite3_step(stmt);\n  sqlite3_finalize(stmt);\n    \n  switch (ret) {\n    case SQLITE_ROW:\n      bundle_version = sqlite3_column_int(stmt, 0);\n      \n      if (bundle_version > MPORT_BUNDLE_VERSION) {\n        RETURN_ERRORX(MPORT_ERR_FATAL, \"%s: bundle is version %i; this version of mport only supports up to version %i\", bundle->filename, bundle_version, MPORT_BUNDLE_VERSION);\n      }\n      break;\n    case SQLITE_DONE:\n      RETURN_ERRORX(MPORT_ERR_FATAL, \"%s: no stub.meta table, or no bundle_format_version field\", bundle->filename);    \n      break;\n    default:\n      RETURN_ERROR(MPORT_ERR_FATAL, sqlite3_errmsg(mport->db));\n      break;\n  }\n  \n  return MPORT_OK;\n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * Loads the index database.  The index contains a list of bundles that are\n * available for download, a list of aliases (apache is aliased to apache22 for \n * example), and a list of mirrors.\n *\n * This function will use the current local index if it is present and younger\n * than the max index age.  Otherwise, it will download the index.  If any \n * index is present, the mirror list will be used; otherwise the bootstrap\n * url will be used.\n */\n", "func_signal": "MPORT_PUBLIC_API int mport_index_load(mportInstance *mport)", "code": "{\n  if (mport_file_exists(MPORT_INDEX_FILE)) {\n    if (mport_db_do(mport->db, \"ATTACH %Q AS index\", MPORT_INDEX_FILE) != MPORT_OK)\n        RETURN_CURRENT_ERROR;\n        \n    mport->flags |= MPORT_INST_HAVE_INDEX;\n  \n    if (!index_is_recentish(mport)) {\n      if (mport_fetch_index(mport) != MPORT_OK)\n        RETURN_CURRENT_ERROR;\n        \n      if (mport_db_do(mport->db, \"DETACH index\") != MPORT_OK)\n        RETURN_CURRENT_ERROR;\n        \n      mport->flags &= ~MPORT_INST_HAVE_INDEX;\n        \n      if (mport_db_do(mport->db, \"ATTACH %Q AS index\", MPORT_INDEX_FILE) != MPORT_OK)\n        RETURN_CURRENT_ERROR;\n        \n      mport->flags |= MPORT_INST_HAVE_INDEX;\n    }\n  } else {\n    if (mport_fetch_bootstrap_index(mport) != MPORT_OK)\n      RETURN_CURRENT_ERROR;\n    \n    if (mport_db_do(mport->db, \"ATTACH %Q AS index\", MPORT_INDEX_FILE) != MPORT_OK)\n      RETURN_CURRENT_ERROR;\n      \n    mport->flags |= MPORT_INST_HAVE_INDEX;\n  }\n  \n\n  return MPORT_OK;\n}", "path": "index.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* free a mportIndexEntry struct */\n", "func_signal": "MPORT_PUBLIC_API void mport_index_entry_free(mportIndexEntry *e)", "code": "{\n  free(e->pkgname);\n  free(e->comment);\n  free(e->version);\n  free(e->www);\n  free(e->bundlefile);\n  free(e);\n}", "path": "index.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* \n * create a directory with mode 755.  Do not fail if the\n * directory exists already.\n */\n", "func_signal": "int mport_mkdir(const char *dir)", "code": "{\n  if (mkdir(dir, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0) {\n    if (errno != EEXIST) \n      RETURN_ERRORX(MPORT_ERR_FATAL, \"Couldn't mkdir %s: %s\", dir, strerror(errno));\n  }\n  \n  return MPORT_OK;\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * mport_run_asset_exec(fmt, cwd, last_file)\n * \n * handles a @exec or a @unexec directive in a plist.  This function\n * does the substitions and then runs the command.  last_file is \n * absolute path.\n *\n * Substitutions:\n * %F\tThe last filename extracted (last_file argument)\n * %D\tThe current working directory (cwd)\n * %B\tReturn the directory part (\"dirname\") of %D/%F\n * %f\tReturn the filename part of (\"basename\") %D/%F\n */\n", "func_signal": "int mport_run_asset_exec(mportInstance *mport, const char *fmt, const char *cwd, const char *last_file)", "code": "{\n  size_t l;\n  size_t max = FILENAME_MAX * 2;\n  char cmnd[max];\n  char *pos = cmnd;\n  char *name;\n\n  while (*fmt && max > 0) {\n    if (*fmt == '%') {\n      fmt++;\n      switch (*fmt) {\n        case 'F':\n          /* last_file is absolute, so we skip the cwd at the begining */\n          (void)strlcpy(pos, last_file + strlen(cwd) + 1, max);\n          l = strlen(last_file + strlen(cwd) + 1);\n          pos += l;\n          max -= l;\n          break;\n        case 'D':\n          (void)strlcpy(pos, cwd, max);\n          l = strlen(cwd);\n          pos += l;\n          max -= l;\n          break;\n        case 'B':\n          name = dirname(last_file);\n          (void)strlcpy(pos, name, max);\n          l = strlen(name);\n          pos += l;\n          max -= l;\n          break;\n        case 'f':\n          name = basename(last_file);\n          (void)strlcpy(pos, name, max);\n          l = strlen(name);\n          pos += l;\n          max -= l;\n          break;\n        default:\n          *pos = *fmt;\n          max--;\n          pos++;\n      }\n      fmt++;\n    } else {\n      *pos = *fmt;\n      pos++;\n      fmt++;\n      max--;\n    }\n  }\n  \n  *pos = '\\0';\n\n  /* cmnd now hold the expaded command, now execute it*/\n  return mport_xsystem(mport, cmnd);\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* free a vector of mportIndexEntry structs */\n", "func_signal": "MPORT_PUBLIC_API void mport_index_entry_free_vec(mportIndexEntry **e)", "code": "{\n  int i;\n  \n  for (i=0; e[i] != NULL; i++) \n    mport_index_entry_free(e[i]);\n  \n  free(e);\n}", "path": "index.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * Fills the string vector with the list of the mirrors for the current\n * country.  \n * \n * XXX - The country is currently hardcoded to the US.\n */\n", "func_signal": "int mport_index_get_mirror_list(mportInstance *mport, char ***list_p)", "code": "{\n  char **list;\n  int len, ret, i;\n  sqlite3_stmt *stmt;\n  \n  /* XXX the country is hard coded until a configuration system is created */    \n  if (mport_db_prepare(mport->db, &stmt, \"SELECT COUNT(*) FROM index.mirrors WHERE country='us'\") != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n\n  switch (sqlite3_step(stmt)) {\n    case SQLITE_ROW:\n      len = sqlite3_column_int(stmt, 0);\n      sqlite3_finalize(stmt);\n      break;\n    case SQLITE_DONE:\n      SET_ERROR(MPORT_ERR_FATAL, \"A 'SELECT COUNT(*)...' statement returned no rows.\");\n      sqlite3_finalize(stmt);\n      RETURN_CURRENT_ERROR;\n      break;\n    default:\n      SET_ERROR(MPORT_ERR_FATAL, sqlite3_errmsg(mport->db));\n      sqlite3_finalize(stmt);\n      RETURN_CURRENT_ERROR;\n  }\n  \n  list = calloc(len + 1, sizeof(char *));\n  *list_p = list;  \n  i = 0;\n    \n  if (mport_db_prepare(mport->db, &stmt, \"SELECT mirror FROM index.mirrors WHERE country='us'\") != MPORT_OK)\n    RETURN_CURRENT_ERROR;\n    \n  while (1) {\n    ret = sqlite3_step(stmt);\n    \n    if (ret == SQLITE_ROW) {\n      list[i] = strdup(sqlite3_column_text(stmt, 0));\n      \n      if (list[i] == NULL) {\n        sqlite3_finalize(stmt);\n        RETURN_ERROR(MPORT_ERR_FATAL, \"Out of memory.\");\n      }\n      \n      i++;\n    } else if (ret == SQLITE_DONE) {\n      list[i] = NULL;\n      break;\n    } else {\n      sqlite3_finalize(stmt);\n      RETURN_ERROR(MPORT_ERR_FATAL, sqlite3_errmsg(mport->db));\n    }\n  }\n  \n  sqlite3_finalize(stmt);\n  return MPORT_OK;\n}", "path": "index.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* XXX - should this be implemented as a macro? inline? */\n", "func_signal": "int mport_bundle_read_extract_next_file(mportBundleRead *bundle, struct archive_entry *entry)", "code": "{\n  if (archive_read_extract(bundle->archive, entry, ARCHIVE_EXTRACT_OWNER|ARCHIVE_EXTRACT_PERM|ARCHIVE_EXTRACT_TIME|ARCHIVE_EXTRACT_ACL|ARCHIVE_EXTRACT_FFLAGS) != ARCHIVE_OK) \n    RETURN_ERROR(MPORT_ERR_FATAL, archive_error_string(bundle->archive));\n  \n  return MPORT_OK;\n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* mport_xsystem(mportInstance *mport, char *fmt, ...)\n * \n * Our own version on system that takes a format string and a list \n * of values.  The fmt works exactly like the stdio output formats.\n * \n * If mport is non-NULL and has a root set, your command will run \n * chroot'ed into mport->root.\n */\n", "func_signal": "int mport_xsystem(mportInstance *mport, const char *fmt, ...)", "code": "{\n  va_list args;\n  char *cmnd;\n  int ret;\n  \n  va_start(args, fmt);\n  \n  if (vasprintf(&cmnd, fmt, args) == -1) {\n    /* XXX How will the caller know this is no mem, and not a failed exec? */\n    va_end(args);\n    RETURN_ERROR(MPORT_ERR_FATAL, \"Couldn't allocate xsystem cmnd string.\");\n  }\n  va_end(args);\n  \n  if (mport != NULL && *(mport->root) != '\\0') {\n    char *chroot_cmd;\n    if (asprintf(&chroot_cmd, \"%s %s %s\", MPORT_CHROOT_BIN, mport->root, cmnd) == -1)\n      RETURN_ERROR(MPORT_ERR_FATAL, \"Couldn't allocate xsystem chroot string.\");\n  \n    free(cmnd);\n    cmnd = chroot_cmd;\n  }\n    \n  ret = system(cmnd);\n  \n  free(cmnd);\n  \n  return ret;\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* mport_free_vec(void **)\n *\n * free a null padded list of pointers, freeing each pointer as well.\n */\n", "func_signal": "void mport_free_vec(void *vec)", "code": "{\n  char *p = (char *)*(char **)vec;\n  \n  while (p != NULL) {\n    free(p);\n    p++;\n  }\n  \n  free(vec);\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * mport_rmdir(dir, ignore_nonempty)\n *\n * delete the given directory.  If ignore_nonempty is non-zero, then\n * we return OK even if we couldn't delete the dir because it wasn't empty or\n * didn't exist.\n */\n", "func_signal": "int mport_rmdir(const char *dir, int ignore_nonempty)", "code": "{\n  if (rmdir(dir) != 0) {\n    if (ignore_nonempty && (errno == ENOTEMPTY || errno == ENOENT)) {\n      return MPORT_OK;\n    } else {\n      RETURN_ERRORX(MPORT_ERR_FATAL, \"Couldn't rmdir %s: %s\", dir, strerror(errno));\n    }\n  } \n  \n  return MPORT_OK;\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* \n * mport_bundle_read_extract_metafiles(bundle, &dirnamep)\n *\n * creates a temporary directory containing all the meta files.  It is\n * expected that this will be called before next_entry() or next_file(),\n * terrible things might happen if you don't do this!\n *\n * The calling code should free the memory that dirnamep points to.\n */\n", "func_signal": "int mport_bundle_read_extract_metafiles(mportBundleRead *bundle, char **dirnamep)", "code": "{\n  /* extract the meta-files into the a temp dir */\n  char filepath[FILENAME_MAX];\n  const char *file;\n  char dirtmpl[] = \"/tmp/mport.XXXXXXXX\";\n  char *tmpdir = mkdtemp(dirtmpl);\n  struct archive_entry *entry;\n     \n  if (tmpdir == NULL)\n    RETURN_ERROR(MPORT_ERR_FATAL, strerror(errno));\n  \n  if ((*dirnamep = strdup(tmpdir)) == NULL) \n    RETURN_ERROR(MPORT_ERR_FATAL, \"Out of memory.\");\n  \n  while (1) {\n    if (mport_bundle_read_next_entry(bundle, &entry) != MPORT_OK)\n      RETURN_CURRENT_ERROR;     \n \n    if (entry == NULL)\n      break;\n \n    file = archive_entry_pathname(entry);\n       \n    if (*file == '+') {\n      (void)snprintf(filepath, FILENAME_MAX, \"%s/%s\", tmpdir, file);\n      archive_entry_set_pathname(entry, filepath);\n      \n      if (mport_bundle_read_extract_next_file(bundle, entry) != MPORT_OK)\n        RETURN_CURRENT_ERROR;        \n    } else {\n      /* entry points to the first real file in the bundle, so we \n       * want to hold on to that until next_entry() is called\n       */\n      bundle->firstreal = entry;\n      break;\n    }\n  }\n \n  return MPORT_OK;                 \n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* a wrapper around chdir, to work with our error system */\n", "func_signal": "int mport_chdir(mportInstance *mport, const char *dir)", "code": "{\n  if (mport != NULL) {\n    char *finaldir;\n  \n    asprintf(&finaldir, \"%s%s\", mport->root, dir);\n  \n    if (finaldir == NULL)\n      RETURN_ERROR(MPORT_ERR_FATAL, \"Couldn't building root'ed dir\");\n    \n    if (chdir(finaldir) != 0) {\n      free(finaldir);\n      RETURN_ERRORX(MPORT_ERR_FATAL, \"Couldn't chdir to %s: %s\", finaldir, strerror(errno));\n    }\n  \n    free(finaldir);\n  } else {\n    if (chdir(dir) != 0) \n      RETURN_ERRORX(MPORT_ERR_FATAL, \"Couldn't chdir to %s: %s\", dir, strerror(errno));\n  }\n  \n  return MPORT_OK;\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * mport_bundle_read_skip_metafiles(bundle)\n *\n * Skip all the metafiles, leaving the bundle ready for reading datafiles.\n */\n", "func_signal": "int mport_bundle_read_skip_metafiles(mportBundleRead *bundle)", "code": "{\n  struct archive_entry *entry;\n  \n  while (1) {\n    if (mport_bundle_read_next_entry(bundle, &entry) != MPORT_OK)\n      RETURN_CURRENT_ERROR;\n    \n    if (*(archive_entry_pathname(entry)) != '+') {\n      bundle->firstreal = entry;\n      break;\n    }\n  }\n  \n  return MPORT_OK;\n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* callers for the callbacks (only for msg at the moment) */\n", "func_signal": "void mport_call_msg_cb(mportInstance *mport, const char *fmt, ...)", "code": "{\n  va_list args;\n  char *msg;\n  \n  va_start(args, fmt);\n  (void)vasprintf(&msg, fmt, args);\n  va_end(args);\n  \n  if (msg == NULL) \n    return; /* No message for you! */\n\n  (mport->msg_cb)(msg);\n  \n  free(msg);\n}", "path": "instance.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * mport_bundle_read_next_entry(bundle, &entry)\n *\n * sets entry to the next file entry in the bundle.\n *\n * If the end the archive is reached, then this function will return MPORT_OK\n * and entry will be set to NULL.\n */\n", "func_signal": "int mport_bundle_read_next_entry(mportBundleRead *bundle, struct archive_entry **entryp)", "code": "{\n  int ret;\n \n  if (bundle->firstreal != NULL) {\n    /* handle the lookahead issue with extracting metafiles */\n    *entryp = bundle->firstreal;\n    bundle->firstreal = NULL;\n    return MPORT_OK;\n  }\n  \n  while (1) {\n    ret = archive_read_next_header(bundle->archive, entryp);\n    \n    if (ret == ARCHIVE_RETRY) continue;\n\n    if (ret == ARCHIVE_FATAL) \n      RETURN_ERROR(MPORT_ERR_FATAL, archive_error_string(bundle->archive));\n\n    /* ret was warn or OK, we're done */\n    if (ret == ARCHIVE_EOF) \n      *entryp = NULL;  \n\n    break;\n  }\n    \n  return MPORT_OK;\n}", "path": "bundle_read.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * Quick test to see if a file exists.\n */\n", "func_signal": "int mport_file_exists(const char *file)", "code": "{\n  struct stat st;\n  \n  return (lstat(file, &st) == 0);\n}", "path": "util.c", "repo_name": "ctriv/libmport", "stars": 2, "license": "None", "language": "c", "size": 312}
{"docstring": "/* ***************************************************** */\n", "func_signal": "static void startTunReadThread(n2n_edge_t *eee)", "code": "{\n  HANDLE hThread;\n  DWORD dwThreadId;\n\n  hThread = CreateThread(NULL, /* no security attributes */\n\t\t\t 0,            /* use default stack size */\n\t\t\t (LPTHREAD_START_ROUTINE)tunReadThread, /* thread function */\n\t\t\t (void*)eee,     /* argument to thread function */\n\t\t\t 0,            /* use default creation flags */\n\t\t\t &dwThreadId); /* returns the thread identifier */\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* ************************************** */\n", "func_signal": "static void edge_deinit(n2n_edge_t * eee)", "code": "{\n  TwoFishDestroy(eee->enc_tf);\n  TwoFishDestroy(eee->dec_tf);\n  if ( eee->sinfo.sock >=0 )\n    {\n      close( eee->sinfo.sock );\n    }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* Move the peer from the pending_peers list to the known_peers lists.\n *\n * peer must be a pointer to an element of the pending_peers list.\n *\n * Called by main loop when Rx a REGISTER_ACK.\n */\n", "func_signal": "void set_peer_operational( n2n_edge_t * eee, const struct n2n_packet_header * hdr )", "code": "{\n  struct peer_info * prev = NULL;\n  struct peer_info * scan;\n  macstr_t mac_buf;\n  ipstr_t ip_buf;\n\n  scan=eee->pending_peers;\n\n  while ( NULL != scan )\n    {\n      if ( 0 != memcmp( scan->mac_addr, hdr->dst_mac, 6 ) )\n        {\n\t  break; /* found. */\n        }\n\n      prev = scan;\n      scan = scan->next;\n    }\n\n  if ( scan )\n    {\n\n      /* Remove scan from pending_peers. */\n      if ( prev )\n        {\n\t  prev->next = scan->next;\n        }\n      else\n        {\n\t  eee->pending_peers = scan->next;\n        }\n\n      /* Add scan to known_peers. */\n      scan->next = eee->known_peers;\n      eee->known_peers = scan;\n\n      scan->public_ip = hdr->public_ip;\n\n      traceEvent(TRACE_INFO, \"=== new peer [mac=%s][socket=%s:%hu]\",\n\t\t macaddr_str(scan->mac_addr, mac_buf, sizeof(mac_buf)),\n\t\t intoa(ntohl(scan->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t ntohs(scan->public_ip.port));\n\n      traceEvent( TRACE_NORMAL, \"Pending peers list size=%ld\",\n\t\t  peer_list_size( eee->pending_peers ) );\n\n      traceEvent( TRACE_NORMAL, \"Operational peers list size=%ld\",\n\t\t  peer_list_size( eee->known_peers ) );\n\n\n      scan->last_seen = time(NULL);\n    }\n  else\n    {\n      traceEvent( TRACE_WARNING, \"Failed to find sender in pending_peers.\" );\n    }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** Read a single packet from the TAP interface, process it and write out the\n *  corresponding packet to the cooked socket.\n *\n *  REVISIT: fails if more than one packet is waiting to be read.\n */\n", "func_signal": "static void readFromTAPSocket( n2n_edge_t * eee )", "code": "{\n  /* tun -> remote */\n  u_char decrypted_msg[2048];\n  size_t len;\n\n  len = tuntap_read(&(eee->device), decrypted_msg, sizeof(decrypted_msg));\n\n  if((len <= 0) || (len > sizeof(decrypted_msg)))\n    traceEvent(TRACE_WARNING, \"read()=%d [%d/%s]\\n\",\n\t       len, errno, strerror(errno));\n  else {\n    traceEvent(TRACE_INFO, \"### Rx L2 Msg (%d) tun -> network\", len);\n\n    if ( eee->drop_ipv6_ndp && is_ip6_discovery( decrypted_msg, len ) ) {\n      traceEvent(TRACE_WARNING, \"Dropping unsupported IPv6 neighbour discovery packet\");\n    } else {\n      send_packet2net(eee, (char*)decrypted_msg, len);\n    }\n  }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* *********************************************** */\n", "func_signal": "static void send_register( n2n_edge_t * eee,\n\t\t\t   const struct peer_addr *remote_peer,\n\t\t\t   u_char is_ack)", "code": "{\n  struct n2n_packet_header hdr;\n  char pkt[N2N_PKT_HDR_SIZE];\n  size_t len = sizeof(hdr);\n  ipstr_t ip_buf;\n\n  fill_standard_header_fields( &(eee->sinfo), &hdr, (char*)(eee->device.mac_addr));\n  hdr.sent_by_supernode = 0;\n  hdr.msg_type = (is_ack == 0) ? MSG_TYPE_REGISTER : MSG_TYPE_REGISTER_ACK;\n  memcpy(hdr.community_name, eee->community_name, COMMUNITY_LEN);\n\n  marshall_n2n_packet_header( (u_int8_t *)pkt, &hdr );\n  send_packet( &(eee->sinfo), pkt, &len, remote_peer, N2N_COMPRESSION_ENABLED );\n\n  traceEvent(TRACE_INFO, \"Sent %s message to %s:%hu\",\n             ((hdr.msg_type==MSG_TYPE_REGISTER)?\"MSG_TYPE_REGISTER\":\"MSG_TYPE_REGISTER_ACK\"),\n\t     intoa(ntohl(remote_peer->addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t     ntohs(remote_peer->port));\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/*\n * Return: 0 = ok, -1 = invalid packet\n *\n */\n", "func_signal": "static int check_received_packet(n2n_edge_t * eee, char *pkt,\n\t\t\t\t u_int pkt_len)", "code": "{\n\n  if(pkt_len == 42) {\n    /* ARP */\n    if((pkt[12] != 0x08) || (pkt[13] != 0x06)) return(0); /* No ARP */\n    if((pkt[20] != 0x00) || (pkt[21] != 0x02)) return(0); /* No ARP Reply */\n    if(memcmp(&pkt[28], &(eee->device.ip_addr), 4))   return(0); /* This is not me */\n\n    if(memcmp(eee->device.mac_addr, &pkt[22], 6) == 0) {\n      traceEvent(TRACE_WARNING, \"Bounced packet received: supernode bug?\");\n      return(0);\n    }\n\n    traceEvent(TRACE_ERROR, \"Duplicate address found. Your IP is used by MAC %02X:%02X:%02X:%02X:%02X:%02X\",\n\t       pkt[22+0] & 0xFF, pkt[22+1] & 0xFF, pkt[22+2] & 0xFF,\n\t       pkt[22+3] & 0xFF, pkt[22+4] & 0xFF, pkt[22+5] & 0xFF);\n    exit(0);\n  } else if(pkt_len > 32 /* IP + Ethernet */) {\n    /* Check if this packet is for us or if it's routed */\n    struct ether_header *eh = (struct ether_header*)pkt;\n      \n    const struct in_addr bcast = { 0xffffffff };\n\n    if(ntohs(eh->ether_type) == 0x0800) {\n\n      /* Note: all elements of the_ip are in network order */\n      struct ip *the_ip = (struct ip*)(pkt+sizeof(struct ether_header));\n\n      if((the_ip->ip_dst.s_addr != eee->device.ip_addr)\n\t && ((the_ip->ip_dst.s_addr & eee->device.device_mask) != (eee->device.ip_addr & eee->device.device_mask)) /* Not a broadcast */\n\t && ((the_ip->ip_dst.s_addr & 0xE0000000) != (0xE0000000 /* 224.0.0.0-239.255.255.255 */)) /* Not a multicast */\n\t && ((the_ip->ip_dst.s_addr) != (bcast.s_addr)) /* always broadcast (RFC919) */\n\t && (!(eee->allow_routing)) /* routing is enabled so let it in */\n\t )\n      {\n          /* Dropping the packet */\n\n          ipstr_t ip_buf;\n          ipstr_t ip_buf2;\n\n\t  /* This is a packet that needs to be routed */\n\t  traceEvent(TRACE_INFO, \"Discarding routed packet [rcvd=%s][expected=%s]\",\n\t\t     intoa(ntohl(the_ip->ip_dst.s_addr), ip_buf, sizeof(ip_buf)),\n\t\t     intoa(ntohl(eee->device.ip_addr), ip_buf2, sizeof(ip_buf2)));\n      } else {\n\t/* This packet is for us */\n\n\t/* traceEvent(TRACE_INFO, \"Received non-routed packet\"); */\n\treturn(0);\n      }\n    } else\n      return(0);\n  } else {\n    traceEvent(TRACE_INFO, \"Packet too short (%d bytes): discarded\", pkt_len);\n  }\n\n  return(-1);\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** Start the registration process.\n *\n *  If the peer is already in pending_peers, ignore the request.\n *  If not in pending_peers, add it and send a REGISTER.\n *\n *  If hdr is for a direct peer-to-peer packet, try to register back to sender\n *  even if the MAC is in pending_peers. This is because an incident direct\n *  packet indicates that peer-to-peer exchange should work so more aggressive\n *  registration can be permitted (once per incoming packet) as this should only\n *  last for a small number of packets..\n *\n *  Called from the main loop when Rx a packet for our device mac.\n */\n", "func_signal": "void try_send_register( n2n_edge_t * eee,\n                        const struct n2n_packet_header * hdr )", "code": "{\n  ipstr_t ip_buf;\n\n  /* REVISIT: purge of pending_peers not yet done. */\n  struct peer_info * scan = find_peer_by_mac( eee->pending_peers, hdr->src_mac );\n\n  if ( NULL == scan )\n    {\n      scan = calloc( 1, sizeof( struct peer_info ) );\n\n      memcpy(scan->mac_addr, hdr->src_mac, 6);\n      scan->public_ip = hdr->public_ip;\n      scan->last_seen = time(NULL); /* Don't change this it marks the pending peer for removal. */\n\n      peer_list_add( &(eee->pending_peers), scan );\n\n      traceEvent( TRACE_NORMAL, \"Pending peers list size=%ld\",\n\t\t  peer_list_size( eee->pending_peers ) );\n\n      traceEvent( TRACE_NORMAL, \"Sending REGISTER request to %s:%hu\",\n\t\t  intoa(ntohl(scan->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t  ntohs(scan->public_ip.port));\n\n      send_register(eee,\n\t\t    &(scan->public_ip),\n\t\t    0 /* is not ACK */ );\n\n      /* pending_peers now owns scan. */\n    }\n  else\n    {\n      /* scan already in pending_peers. */\n\n      if ( 0 == hdr->sent_by_supernode )\n        {\n\t  /* over-write supernode-based socket with direct socket. */\n\t  scan->public_ip = hdr->public_ip;\n\n\t  traceEvent( TRACE_NORMAL, \"Sending additional REGISTER request to %s:%hu\",\n\t\t      intoa(ntohl(scan->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t      ntohs(scan->public_ip.port));\n\n\n\t  send_register(eee,\n\t\t\t&(scan->public_ip),\n\t\t\t0 /* is not ACK */ );\n        }\n    }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** Destination MAC 33:33:0:00:00:00 - 33:33:FF:FF:FF:FF is reserved for IPv6\n * neighbour discovery.\n */\n", "func_signal": "int is_ip6_discovery( const void * buf, size_t bufsize )", "code": "{\n  int retval = 0;\n\n  if ( bufsize >= sizeof(struct ether_header) )\n    {\n      struct ether_header *eh = (struct ether_header*)buf;\n      if ( (0x33 == eh->ether_dhost[0]) &&\n\t   (0x33 == eh->ether_dhost[1]) )\n        {\n\t  retval = 1; /* This is an IPv6 neighbour discovery packet. */\n        }\n    }\n  return retval;\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** Called from update_registrations to periodically send gratuitous ARP\n * broadcasts. */\n", "func_signal": "static void send_grat_arps(n2n_edge_t * eee,)", "code": "{\n  char buffer[48];\n  size_t len;\n\n  traceEvent(TRACE_NORMAL, \"Sending gratuitous ARP...\");\n  len = build_gratuitous_arp(buffer, sizeof(buffer));\n  send_packet2net(eee, buffer, len);\n  send_packet2net(eee, buffer, len); /* Two is better than one :-) */\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* dotted decimal 12 numbers + 3 dots */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n  int opt=0;\n  u_int16_t local_port = 0 /* any port */;\n  char *tuntap_dev_name = NULL;\n  char *ip_addr = NULL;\n  char  netmask[N2N_NETMASK_STR_SIZE]=\"255.255.255.0\";\n  int   mtu = DEFAULT_MTU;\n  int   got_s = 0;\n\n#ifndef WIN32\n  uid_t userid=0; /* root is the only guaranteed ID */\n  gid_t groupid=0; /* root is the only guaranteed ID */\n  int   fork_as_daemon=0;\n  char  *pidfile = NULL;\n#endif\n\n  size_t numPurged;\n  time_t lastStatus=0;\n\n  char * device_mac=NULL;\n  char * encrypt_key=NULL;\n\n  int     i, effectiveargc=0;\n  char ** effectiveargv=NULL;\n  char  * linebuffer = NULL;\n\n  n2n_edge_t eee; /* single instance for this program */\n\n  if (-1 == edge_init(&eee) ){\n    traceEvent( TRACE_ERROR, \"Failed in edge_init\" );\n    exit(1);\n  }\n\n  if( getenv( \"N2N_KEY\" )) {\n    encrypt_key = strdup( getenv( \"N2N_KEY\" ));\n  }\n\n#ifdef WIN32\n  tuntap_dev_name = \"\";\n#endif\n#ifdef __linux__\n  tuntap_dev_name = \"edge0\";\n#endif\n\n  memset(&(eee.supernode), 0, sizeof(eee.supernode));\n  eee.supernode.family = AF_INET;\n\n  linebuffer = (char *)malloc(MAX_CMDLINE_BUFFER_LENGTH);\n  if (!linebuffer) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    exit(1);\n  }\n  snprintf(linebuffer, MAX_CMDLINE_BUFFER_LENGTH, \"%s\",argv[0]);\n\n#ifdef WIN32\n\tfor(i=0; i<strlen(linebuffer); i++)\n\t\tif(linebuffer[i] == '\\\\') linebuffer[i] = '/';\n#endif\n\n  for(i=1;i<argc;++i) {\n    if(argv[i][0] == '@') {\n      if (readConfFile(&argv[i][1], linebuffer)<0) exit(1); /* <<<<----- check */\n    } else\n      if ((strlen(linebuffer)+strlen(argv[i])+2) < MAX_CMDLINE_BUFFER_LENGTH) {\n\tstrncat(linebuffer, \" \", 1);\n\tstrncat(linebuffer, argv[i], strlen(argv[i]));\n      } else {\n\ttraceEvent( TRACE_ERROR, \"too many argument\");\n\texit(1);\n      }\n  }\n  /*  strip trailing spaces */\n  while(strlen(linebuffer) && linebuffer[strlen(linebuffer)-1]==' ')\n    linebuffer[strlen(linebuffer)-1]= '\\0';\n\n  /* build the new argv from the linebuffer */\n  effectiveargv = buildargv(linebuffer);\n\n  effectiveargc =0;\n  while (effectiveargv[effectiveargc]) ++effectiveargc;\neffectiveargv[effectiveargc] = 0;\n  if (linebuffer) {\n    free(linebuffer);\n    linebuffer = NULL;\n  }\n\n  /* {int k;for(k=0;k<effectiveargc;++k)  printf(\"%s\\n\",effectiveargv[k]);} */\n\n  optarg = NULL;\n  while((opt = getopt_long(effectiveargc, effectiveargv, \"k:a:bc:u:g:m:M:s:d:l:p:fP:vhrt\", long_options, NULL)) != EOF) {\n    switch (opt) {\n    case 'a':\n\t\t  printf(\"%s\\n\", optarg);\n      ip_addr = strdup(optarg);\n      break;\n    case 'c': /* community */\n      eee.community_name = strdup(optarg);\n      if(strlen(eee.community_name) > COMMUNITY_LEN)\n\teee.community_name[COMMUNITY_LEN] = '\\0';\n      break;\n#ifndef WIN32\n\n    case 'u': /* uid */\n      {\n        userid = atoi(optarg);\n        break;\n      }\n    case 'g': /* uid */\n      {\n        groupid = atoi(optarg);\n        break;\n      }\n    case 'f' : /* fork as daemon */\n      {\n        fork_as_daemon = 1;\n        break;\n      }\n      case 'P' : /* pidfile */\n        {\n          pidfile = strdup(optarg);\n          break;\n        }\n#endif\n    case 'm' : /* device_mac */\n      {\n        device_mac = strdup(optarg);\n        break;\n      }\n    case 'M' : /* device_mac */\n      {\n        mtu = atoi(optarg);\n        break;\n      }\n    case 'k': /* encrypt key */\n      encrypt_key = strdup(optarg);\n      break;\n    case 'r': /* enable packet routing across n2n endpoints */\n      eee.allow_routing = 1;\n      break;\n    case 'l': /* supernode-list */\n      snprintf(eee.supernode_ip, sizeof(eee.supernode_ip), \"%s\", optarg);\n      supernode2addr(&eee, eee.supernode_ip);\n      break;\n    case 'd': /* tun-device */\n      tuntap_dev_name = strdup(optarg);\n      break;\n    case 't': /* Use HTTP tunneling */\n      eee.sinfo.is_udp_socket = 0;\n      break;\n    case 'b':\n      eee.re_resolve_supernode_ip = 1;\n      break;\n    case 'p':\n      local_port = atoi(optarg) & 0xffff;\n      break;\n    case 's': /* Subnet Mask */\n      if (0 != got_s) {\n          traceEvent(TRACE_WARNING, \"Multiple subnet masks supplied.\");\n      }\n      strncpy(netmask, optarg, N2N_NETMASK_STR_SIZE);\n      got_s = 1;\n      break;\n    case 'h': /* help */\n      help();\n      break;\n    case 'v': /* verbose */\n      traceLevel = 3;\n      break;\n    }\n  }\n\n  if(!(\n#ifdef __linux__\n       tuntap_dev_name &&\n#endif\n       eee.community_name &&\n       ip_addr &&\n       eee.supernode.addr_type.v4_addr &&\n       encrypt_key))\n    help();\n\n#ifndef WIN32\n  /* If running suid root then we need to setuid before using the force. */\n  setuid( 0 );\n  /* setgid( 0 ); */\n#endif\n\n  if(tuntap_open(&(eee.device), tuntap_dev_name, ip_addr, netmask, device_mac, mtu) < 0)\n    return(-1);\n\n#ifndef WIN32\n  if ( (userid != 0) || (groupid != 0 ) ) {\n    traceEvent(TRACE_NORMAL, \"Interface up. Dropping privileges to uid=%d, gid=%d\", userid, groupid);\n\n    /* Finished with the need for root privileges. Drop to unprivileged user. */\n    setreuid( userid, userid );\n    setregid( groupid, groupid );\n  }\n#endif\n\n  if(local_port > 0)\n    traceEvent(TRACE_NORMAL, \"Binding to local port %hu\", local_port);\n\n  if(edge_init_twofish( &eee, (u_int8_t *)(encrypt_key), strlen(encrypt_key) ) < 0) return(-1);\n  eee.sinfo.sock = open_socket(local_port, eee.sinfo.is_udp_socket, 0);\n  if(eee.sinfo.sock < 0) return(-1);\n\n  if( !(eee.sinfo.is_udp_socket) ) {\n    int rc = connect_socket(eee.sinfo.sock, &(eee.supernode));\n\n    if(rc == -1) {\n      traceEvent(TRACE_WARNING, \"Error while connecting to supernode\\n\");\n      return(-1);\n    }\n  }\n\n#ifndef WIN32\n  if ( fork_as_daemon )\n    {\n      useSyslog=1; /* traceEvent output now goes to syslog. */\n      daemon( 0, 0 );\n    }\n    \n    if ( pidfile )\n    {\n       writePid(pidfile);\n    }\n    \n#endif\n\n  update_registrations(&eee);\n\n  traceEvent(TRACE_NORMAL, \"\");\n  traceEvent(TRACE_NORMAL, \"Ready\");\n\n#ifdef WIN32\n  startTunReadThread(&eee);\n#endif\n\n  /* Main loop\n   *\n   * select() is used to wait for input on either the TAP fd or the UDP/TCP\n   * socket. When input is present the data is read and processed by either\n   * readFromIPSocket() or readFromTAPSocket()\n   */\n\n  while(1) {\n    int rc, max_sock = 0;\n    fd_set socket_mask;\n    struct timeval wait_time;\n    time_t nowTime;\n\n    FD_ZERO(&socket_mask);\n    FD_SET(eee.sinfo.sock, &socket_mask);\n#ifndef WIN32\n    FD_SET(eee.device.fd, &socket_mask);\n    max_sock = max( eee.sinfo.sock, eee.device.fd );\n#endif\n\n    wait_time.tv_sec = SOCKET_TIMEOUT_INTERVAL_SECS; wait_time.tv_usec = 0;\n\n    rc = select(max_sock+1, &socket_mask, NULL, NULL, &wait_time);\n    nowTime=time(NULL);\n\n    if(rc > 0)\n      {\n        /* Any or all of the FDs could have input; check them all. */\n\n        if(FD_ISSET(eee.sinfo.sock, &socket_mask))\n\t  {\n            /* Read a cooked socket from the internet socket. Writes on the TAP\n             * socket. */\n            readFromIPSocket(&eee);\n\t  }\n\n#ifndef WIN32\n        if(FD_ISSET(eee.device.fd, &socket_mask))\n\t  {\n            /* Read an ethernet frame from the TAP socket. Write on the IP\n             * socket. */\n            readFromTAPSocket(&eee);\n\t  }\n#endif\n      }\n\n    update_registrations(&eee);\n\n    numPurged =  purge_expired_registrations( &(eee.known_peers) );\n    numPurged += purge_expired_registrations( &(eee.pending_peers) );\n    if ( numPurged > 0 )\n      {\n        traceEvent( TRACE_NORMAL, \"Peer removed: pending=%ld, operational=%ld\",\n                    peer_list_size( eee.pending_peers ), peer_list_size( eee.known_peers ) );\n      }\n\n    if ( ( nowTime - lastStatus ) > STATUS_UPDATE_INTERVAL )\n      {\n        lastStatus = nowTime;\n\n        traceEvent( TRACE_NORMAL, \"STATUS: pending=%ld, operational=%ld\",\n                    peer_list_size( eee.pending_peers ), peer_list_size( eee.known_peers ) );\n      }\n  } /* while */\n\n  send_deregister( &eee, &(eee.supernode));\n\n  closesocket(eee.sinfo.sock);\n  tuntap_close(&(eee.device));\n\n  edge_deinit( &eee );\n\n  return(0);\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* ***************************************************** */\n", "func_signal": "static int find_peer_destination(n2n_edge_t * eee,\n                                 const u_char *mac_address,\n                                 struct peer_addr *destination)", "code": "{\n  const struct peer_info *scan = eee->known_peers;\n  macstr_t mac_buf;\n  ipstr_t ip_buf;\n  int retval=0;\n\n  traceEvent(TRACE_INFO, \"Searching destination peer for MAC %02X:%02X:%02X:%02X:%02X:%02X\",\n\t     mac_address[0] & 0xFF, mac_address[1] & 0xFF, mac_address[2] & 0xFF,\n\t     mac_address[3] & 0xFF, mac_address[4] & 0xFF, mac_address[5] & 0xFF);\n\n  while(scan != NULL) {\n    traceEvent(TRACE_INFO, \"Evaluating peer [MAC=%02X:%02X:%02X:%02X:%02X:%02X][ip=%s:%hu]\",\n\t       scan->mac_addr[0] & 0xFF, scan->mac_addr[1] & 0xFF, scan->mac_addr[2] & 0xFF,\n\t       scan->mac_addr[3] & 0xFF, scan->mac_addr[4] & 0xFF, scan->mac_addr[5] & 0xFF,\n\t       intoa(ntohl(scan->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t       ntohs(scan->public_ip.port));\n\n    if((scan->last_seen > 0) &&\n       (memcmp(mac_address, scan->mac_addr, 6) == 0))\n      {\n        memcpy(destination, &scan->public_ip, sizeof(struct sockaddr_in));\n        retval=1;\n        break;\n      }\n    scan = scan->next;\n  }\n\n  if ( 0 == retval )\n    {\n      memcpy(destination, &(eee->supernode), sizeof(struct sockaddr_in));\n    }\n\n  traceEvent(TRACE_INFO, \"find_peer_address(%s) -> [socket=%s:%hu]\",\n             macaddr_str( (char *)mac_address, mac_buf, sizeof(mac_buf)),\n             intoa(ntohl(destination->addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n             ntohs(destination->port));\n\n  return retval;\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* ************************************** */\n", "func_signal": "static int edge_init(n2n_edge_t * eee)", "code": "{\n#ifdef WIN32\n  initWin32();\n#endif\n  memset(eee, 0, sizeof(n2n_edge_t));\n\n  eee->re_resolve_supernode_ip = 0;\n  eee->community_name = NULL;\n  eee->sinfo.sock     = -1;\n  eee->sinfo.is_udp_socket = 1;\n  eee->pkt_sent      = 0;\n  eee->allow_routing = 0;\n  eee->drop_ipv6_ndp = 0;\n  eee->encrypt_key   = NULL;\n  eee->enc_tf        = NULL;\n  eee->dec_tf        = NULL;\n  eee->known_peers   = NULL;\n  eee->pending_peers = NULL;\n  eee->last_register = 0;\n\n  if(lzo_init() != LZO_E_OK) {\n    traceEvent(TRACE_ERROR, \"LZO compression error\");\n    return(-1);\n  }\n\n  return(0);\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* parse the configuration file */\n", "func_signal": "static int readConfFile(const char * filename, char * const linebuffer)", "code": "{\n  struct stat stats;\n  FILE    *   fd;\n  char    *   buffer = NULL;\n\n  buffer = (char *)malloc(MAX_CONFFILE_LINE_LENGTH);\n  if (!buffer) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return -1;\n  }\n\n  if (stat(filename, &stats)) {\n    if (errno == ENOENT)\n      traceEvent(TRACE_ERROR, \"parameter file %s not found/unable to access\\n\", filename);\n    else\n      traceEvent(TRACE_ERROR, \"cannot stat file %s, errno=%d\\n\",filename, errno);\n    free(buffer);\n    return -1;\n  }\n\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    traceEvent(TRACE_ERROR, \"Unable to open parameter file '%s' (%d)...\\n\",filename,errno);\n    free(buffer);\n    return -1;\n  }\n  while(fgets(buffer, MAX_CONFFILE_LINE_LENGTH,fd)) {\n    char    *   p = NULL;\n\n    /* strip out comments */\n    p = strchr(buffer, '#');\n    if (p) *p ='\\0';\n\n    /* remove \\n */\n    p = strchr(buffer, '\\n');\n    if (p) *p ='\\0';\n\n    /* strip out heading spaces */\n    p = buffer;\n    while(*p == ' ' && *p != '\\0') ++p;\n    if (p != buffer) strncpy(buffer,p,strlen(p)+1);\n\n    /* strip out trailing spaces */\n    while(strlen(buffer) && buffer[strlen(buffer)-1]==' ')\n      buffer[strlen(buffer)-1]= '\\0';\n\n    /* check for nested @file option */\n    if (strchr(buffer, '@')) {\n      traceEvent(TRACE_ERROR, \"@file in file nesting is not supported\\n\");\n      free(buffer);\n      return -1;\n    }\n    if ((strlen(linebuffer)+strlen(buffer)+2)< MAX_CMDLINE_BUFFER_LENGTH) {\n      strncat(linebuffer, \" \", 1);\n      strncat(linebuffer, buffer, strlen(buffer));\n    } else {\n      traceEvent(TRACE_ERROR, \"too many argument\");\n      free(buffer);\n      return -1;\n    }\n  }\n\n  free(buffer);\n  fclose(fd);\n\n  return 0;\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* Create the argv vector */\n", "func_signal": "static char ** buildargv(char * const linebuffer)", "code": "{\n  const int  INITIAL_MAXARGC = 16;\t/* Number of args + NULL in initial argv */\n  int     maxargc;\n  int     argc=0;\n  char ** argv;\n  char *  buffer, * buff;\n\n  buffer = (char *)calloc(1, strlen(linebuffer)+2);\n  if (!buffer) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return NULL;\n  }\n  strncpy(buffer, linebuffer,strlen(linebuffer));\n\n  maxargc = INITIAL_MAXARGC;\n  argv = (char **)malloc(maxargc * sizeof(char*));\n  if (argv == NULL) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return NULL;\n  }\n  buff = buffer;\n  while(buff) {\n    char * p = strchr(buff,' ');\n    if (p) {\n      *p='\\0';\n      argv[argc++] = strdup(buff);\n      while(*++p == ' ' && *p != '\\0');\n      buff=p;\n      if (argc >= maxargc) {\n\tmaxargc *= 2;\n\targv = (char **)realloc(argv, maxargc * sizeof(char*));\n\tif (argv == NULL) {\n\t  traceEvent(TRACE_ERROR, \"Unable to re-allocate memory\");\n\t  free(buffer);\n\t  return NULL;\n\t}\n      }\n    } else {\n      argv[argc++] = strdup(buff);\n      break;\n    }\n  }\n  argv[argc] = NULL;\n  free(buffer);\n  return argv;\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** Update the last_seen time for this peer, or get registered. */\n", "func_signal": "void check_peer( n2n_edge_t * eee,\n                 const struct n2n_packet_header * hdr )", "code": "{\n  struct peer_info * scan = find_peer_by_mac( eee->known_peers, hdr->src_mac );\n\n  if ( NULL == scan )\n    {\n      /* Not in known_peers - start the REGISTER process. */\n      try_send_register( eee, hdr );\n    }\n  else\n    {\n      /* Already in known_peers. */\n      update_peer_address( eee, hdr, time(NULL) );\n    }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* ***************************************************** */\n", "func_signal": "void readFromIPSocket( n2n_edge_t * eee )", "code": "{\n  ipstr_t ip_buf;\n  macstr_t mac_buf;\n  char packet[2048], decrypted_msg[2048];\n  size_t len;\n  int data_sent_len;\n  struct peer_addr sender;\n\n  /* remote -> tun */\n  u_int8_t discarded_pkt;\n  struct n2n_packet_header hdr_storage;\n\n  len = receive_data( &(eee->sinfo), packet, sizeof(packet), &sender,\n                      &discarded_pkt, (char*)(eee->device.mac_addr), \n                      N2N_COMPRESSION_ENABLED, &hdr_storage);\n\n  if(len <= 0) return;\n\n  traceEvent(TRACE_INFO, \"### Rx N2N Msg network -> tun\");\n\n  if(discarded_pkt) {\n    traceEvent(TRACE_INFO, \"Discarded incoming pkt\");\n  } else {\n    if(len <= 0)\n      traceEvent(TRACE_WARNING, \"receive_data()=%d [%s]\\n\", len, strerror(errno));\n    else {\n      if(len < N2N_PKT_HDR_SIZE)\n\ttraceEvent(TRACE_WARNING, \"received packet too short [len=%d]\\n\", len);\n      else {\n\tstruct n2n_packet_header *hdr = &hdr_storage;\n\n\ttraceEvent(TRACE_INFO, \"Received packet from %s:%hu\",\n\t\t   intoa(ntohl(sender.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t   ntohs(sender.port));\n\n\ttraceEvent(TRACE_INFO, \"Received message [msg_type=%s] from %s [dst mac=%s]\",\n\t\t   msg_type2str(hdr->msg_type),\n\t\t   hdr->sent_by_supernode ? \"supernode\" : \"peer\",\n\t\t   macaddr_str(hdr->dst_mac, mac_buf, sizeof(mac_buf)));\n\n\tif(hdr->version != N2N_PKT_VERSION) {\n\t  traceEvent(TRACE_WARNING,\n\t\t     \"Received packet with unknown protocol version (%d): discarded\\n\",\n\t\t     hdr->version);\n\t  return;\n\t}\n\n\t/* FIX - Add IPv6 support */\n\tif(hdr->public_ip.addr_type.v4_addr == 0) {\n\t  hdr->public_ip.addr_type.v4_addr = sender.addr_type.v4_addr;\n\t  hdr->public_ip.port = sender.port;\n\t  hdr->public_ip.family = AF_INET;\n\t}\n\n\tif(strncmp(hdr->community_name, eee->community_name, COMMUNITY_LEN) != 0) {\n\t  traceEvent(TRACE_WARNING, \"Received packet with invalid community [expected=%s][received=%s]\\n\",\n\t\t     eee->community_name, hdr->community_name);\n\t} else {\n\t  if(hdr->msg_type == MSG_TYPE_PACKET) {\n\t    /* assert: the packet received is destined for device.mac_addr or broadcast MAC. */\n\n\t    len -= N2N_PKT_HDR_SIZE;\n\n\t    /* Decrypt message first */\n\t    len = TwoFishDecryptRaw((u_int8_t *)&packet[N2N_PKT_HDR_SIZE],\n\t\t\t\t    (u_int8_t *)decrypted_msg, len, eee->dec_tf);\n\n\t    if(len > 0) {\n\t      if(check_received_packet(eee, decrypted_msg, len) == 0) {\n\n\t\tif ( 0 == memcmp(hdr->dst_mac, eee->device.mac_addr, 6) )\n\t\t  {\n\t\t    check_peer( eee, hdr );\n\t\t  }\n\n\t\tdata_sent_len = tuntap_write(&(eee->device), (u_char*)decrypted_msg, len);\n\n\t\tif(data_sent_len != len)\n\t\t  traceEvent(TRACE_WARNING, \"tuntap_write() [sent=%d][attempted_to_send=%d] [%s]\\n\",\n\t\t\t     data_sent_len, len, strerror(errno));\n\t\telse {\n\t\t  /* Normal situation. */\n\t\t  traceEvent(TRACE_INFO, \"### Tx L2 Msg -> tun\");\n\t\t}\n\t      } else {\n\t\t\ttraceEvent(TRACE_WARNING, \"Bad destination: message discarded\");\n\t      }\n\t    }\n\t    /* else silently ignore empty packet. */\n\n\t  } else if(hdr->msg_type == MSG_TYPE_REGISTER) {\n\t    traceEvent(TRACE_INFO, \"Received registration request from remote peer [ip=%s:%hu]\",\n\t\t       intoa(ntohl(hdr->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t       ntohs(hdr->public_ip.port));\n\t    if ( 0 == memcmp(hdr->dst_mac, (eee->device.mac_addr), 6) )\n\t      {\n\t\tcheck_peer( eee, hdr );\n\t      }\n\n\n\t    send_register(eee, &hdr->public_ip, 1); /* Send ACK back */\n\t  } else if(hdr->msg_type == MSG_TYPE_REGISTER_ACK) {\n\t    traceEvent(TRACE_NORMAL, \"Received REGISTER_ACK from remote peer [ip=%s:%hu]\",\n\t\t       intoa(ntohl(hdr->public_ip.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t       ntohs(hdr->public_ip.port));\n\n\t    /* if ( 0 == memcmp(hdr->dst_mac, eee->device.mac_addr, 6) ) */\n\t    {\n\t      if ( hdr->sent_by_supernode )\n                {\n\t\t  /* Response to supernode registration. Supernode is not in the pending_peers list. */\n                }\n\t      else\n                {\n\t\t  /* Move from pending_peers to known_peers; ignore if not in pending. */\n\t\t  set_peer_operational( eee, hdr );\n                }\n\t    }\n\n\t  } else {\n\t    traceEvent(TRACE_WARNING, \"Unable to handle packet type %d: ignored\\n\", hdr->msg_type);\n\t    return;\n\t  }\n\t}\n      }\n    }\n  }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** @brief Check to see if we should re-register with our peers and the\n *         supernode.\n *\n *  This is periodically called by the main loop. The list of registrations is\n *  not modified. Registration packets may be sent.\n */\n", "func_signal": "static void update_registrations( n2n_edge_t * eee )", "code": "{\n  /* REVISIT: BbMaj7: have shorter timeout to REGISTER to supernode if this has\n   * not yet succeeded. */\n\n  if(time(NULL) < (eee->last_register+REGISTER_FREQUENCY)) return; /* Too early */\n\n  traceEvent(TRACE_NORMAL, \"Registering with supernode\");\n  if(eee->re_resolve_supernode_ip)\n    supernode2addr(eee, eee->supernode_ip);\n\n  send_register(eee, &(eee->supernode), 0); /* Register with supernode */\n\n  /* REVISIT: turn-on gratuitous ARP with config option. */\n  /* send_grat_arps(sock_fd, is_udp_sock); */\n\n  eee->last_register = time(NULL);\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/** A layer-2 packet was received at the tunnel and needs to be sent via UDP. */\n", "func_signal": "static void send_packet2net(n2n_edge_t * eee,\n\t\t\t    char *decrypted_msg, size_t len)", "code": "{\n  ipstr_t ip_buf;\n  char packet[2048];\n  int data_sent_len;\n  struct n2n_packet_header hdr;\n  struct peer_addr destination;\n  macstr_t mac_buf;\n  macstr_t mac2_buf;\n  struct ether_header *eh = (struct ether_header*)decrypted_msg;\n\n  /* Discard IP packets that are not originated by this hosts */\n  if(!(eee->allow_routing)) {\n    if(ntohs(eh->ether_type) == 0x0800) {\n      /* This is an IP packet from the local source address - not forwarded. */\n#define ETH_FRAMESIZE 14\n#define IP4_SRCOFFSET 12\n      u_int32_t *dst = (u_int32_t*)&decrypted_msg[ETH_FRAMESIZE + IP4_SRCOFFSET];\n\n      /* Note: all elements of the_ip are in network order */\n      if( *dst != eee->device.ip_addr) {\n\t\t/* This is a packet that needs to be routed */\n\t\ttraceEvent(TRACE_INFO, \"Discarding routed packet [%s]\", \n\t\t\t\t               intoa(ntohl(*dst), ip_buf, sizeof(ip_buf)));\n\t\treturn;\n      } else {\n\t/* This packet is originated by us */\n\t/* traceEvent(TRACE_INFO, \"Sending non-routed packet\"); */\n      }\n    }\n  }\n\n  /* Encrypt \"decrypted_msg\" into the second half of the n2n packet. */\n  len = TwoFishEncryptRaw((u_int8_t *)decrypted_msg,\n\t\t\t  (u_int8_t *)&packet[N2N_PKT_HDR_SIZE], len, eee->enc_tf);\n\n  /* Add the n2n header to the start of the n2n packet. */\n  fill_standard_header_fields( &(eee->sinfo), &hdr, (char*)(eee->device.mac_addr) );\n  hdr.msg_type = MSG_TYPE_PACKET;\n  hdr.sent_by_supernode = 0;\n  memcpy(hdr.community_name, eee->community_name, COMMUNITY_LEN);\n  memcpy(hdr.dst_mac, decrypted_msg, 6);\n\n  marshall_n2n_packet_header( (u_int8_t *)packet, &hdr );\n\n  len += N2N_PKT_HDR_SIZE;\n\n  if(find_peer_destination(eee, eh->ether_dhost, &destination))\n    traceEvent(TRACE_INFO, \"** Going direct [dst_mac=%s][dest=%s:%hu]\",\n\t       macaddr_str((char*)eh->ether_dhost, mac_buf, sizeof(mac_buf)),\n\t       intoa(ntohl(destination.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t       ntohs(destination.port));\n  else\n    traceEvent(TRACE_INFO, \"   Going via supernode [src_mac=%s][dst_mac=%s]\",\n\t       macaddr_str((char*)eh->ether_shost, mac_buf, sizeof(mac_buf)),\n\t       macaddr_str((char*)eh->ether_dhost, mac2_buf, sizeof(mac2_buf)));\n\n  data_sent_len = reliable_sendto( &(eee->sinfo), packet, &len, &destination, \n                                   N2N_COMPRESSION_ENABLED);\n\n  if(data_sent_len != len)\n    traceEvent(TRACE_WARNING, \"sendto() [sent=%d][attempted_to_send=%d] [%s]\\n\",\n\t       data_sent_len, len, strerror(errno));\n  else {\n    ++(eee->pkt_sent);\n    traceEvent(TRACE_INFO, \"Sent %d byte MSG_TYPE_PACKET ok\", data_sent_len);\n  }\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* ***************************************************** */\n", "func_signal": "static void supernode2addr(n2n_edge_t * eee, char* addr)", "code": "{\n  char *supernode_host = strtok(addr, \":\");\n\n  if(supernode_host) {\n    char *supernode_port = strtok(NULL, \":\");\n    const struct addrinfo aihints = {0, PF_INET, 0, 0, 0, NULL, NULL, NULL};\n    struct addrinfo * ainfo = NULL;\n    int nameerr;\n    ipstr_t ip_buf;\n\n    if ( supernode_port )\n      eee->supernode.port = htons(atoi(supernode_port));\n    else\n      traceEvent(TRACE_WARNING, \"Bad supernode parameter (-l <host:port>)\");\n\n    nameerr = getaddrinfo( supernode_host, NULL, &aihints, &ainfo );\n\n    if( 0 == nameerr )\n      {\n\tstruct sockaddr_in * saddr;\n\n\t/* ainfo s the head of a linked list if non-NULL. */\n\tif ( ainfo && (PF_INET == ainfo->ai_family) )\n\t  {\n\t    /* It is definitely and IPv4 address -> sockaddr_in */\n\t    saddr = (struct sockaddr_in *)ainfo->ai_addr;\n\n\t    eee->supernode.addr_type.v4_addr = saddr->sin_addr.s_addr;\n\t  }\n\telse\n\t  {\n\t    /* Should only return IPv4 addresses due to aihints. */\n\t    traceEvent(TRACE_WARNING, \"Failed to resolve supernode IPv4 address for %s\", supernode_host);\n\t  }\n\n\tfreeaddrinfo(ainfo); /* free everything allocated by getaddrinfo(). */\n\tainfo = NULL;\n      } else {\n      traceEvent(TRACE_WARNING, \"Failed to resolve supernode host %s, assuming numeric\", supernode_host);\n      eee->supernode.addr_type.v4_addr = inet_addr(supernode_host);\n    }\n\n    traceEvent(TRACE_NORMAL, \"Using supernode %s:%hu\",\n\t       intoa(ntohl(eee->supernode.addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t       ntohs(eee->supernode.port));\n  } else\n    traceEvent(TRACE_WARNING, \"Wrong supernode parameter (-l <host:port>)\");\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/* *********************************************** */\n", "func_signal": "static void send_deregister(n2n_edge_t * eee,\n\t\t\t    struct peer_addr *remote_peer)", "code": "{\n  struct n2n_packet_header hdr;\n  char pkt[N2N_PKT_HDR_SIZE];\n  size_t len = sizeof(hdr);\n\n  fill_standard_header_fields( &(eee->sinfo), &hdr, (char*)(eee->device.mac_addr) );\n  hdr.sent_by_supernode = 0;\n  hdr.msg_type = MSG_TYPE_DEREGISTER;\n  memcpy(hdr.community_name, eee->community_name, COMMUNITY_LEN);\n\n  marshall_n2n_packet_header( (u_int8_t *)pkt, &hdr );\n  send_packet( &(eee->sinfo), pkt, &len, remote_peer, N2N_COMPRESSION_ENABLED);\n}", "path": "src\\edge.c", "repo_name": "alaricsp/kitten-n2n", "stars": 2, "license": "None", "language": "c", "size": 321}
{"docstring": "/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n", "func_signal": "static int check_next (LexState *ls, const char *set)", "code": "{\n  if (!strchr(set, ls->current))\n    return 0;\n  save_and_next(ls);\n  return 1;\n}", "path": "3rdparty\\lua-5.1.3\\src\\llex.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_user_data:\n * @scaled_font: a #cairo_scaled_font_t\n * @key: the address of the #cairo_user_data_key_t the user data was\n * attached to\n *\n * Return user data previously attached to @scaled_font using the\n * specified key.  If no user data has been attached with the given\n * key this function returns %NULL.\n *\n * Return value: the user data previously attached or %NULL.\n *\n * Since: 1.4\n **/\n", "func_signal": "void *\ncairo_scaled_font_get_user_data (cairo_scaled_font_t\t     *scaled_font,\n\t\t\t\t const cairo_user_data_key_t *key)", "code": "{\n    return _cairo_user_data_array_get_data (&scaled_font->user_data,\n\t\t\t\t\t    key);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_reference_count:\n * @scaled_font: a #cairo_scaled_font_t\n *\n * Returns the current reference count of @scaled_font.\n *\n * Return value: the current reference count of @scaled_font.  If the\n * object is a nil object, 0 will be returned.\n *\n * Since: 1.4\n **/\n", "func_signal": "unsigned int\ncairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font)", "code": "{\n    if (scaled_font == NULL ||\n\t    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))\n\treturn 0;\n\n    return CAIRO_REFERENCE_COUNT_GET_VALUE (&scaled_font->ref_count);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/* DFB_COMPOSITE_TRAPEZOIDS */\n", "func_signal": "static cairo_int_status_t\n_cairo_directfb_surface_set_clip_region (void           *abstract_surface,\n                                         cairo_region_t *region)", "code": "{\n    cairo_directfb_surface_t *surface = abstract_surface;\n    \n    D_DEBUG_AT (Cairo_DirectFB, \n                \"%s( surface=%p, region=%p ).\\n\",\n                __FUNCTION__, surface, region);\n    \n    if (region) {\n        cairo_box_int_t *boxes;\n        int              n_boxes;\n        cairo_status_t   status;\n        int              i;\n\n        status = _cairo_region_get_boxes (region, &n_boxes, &boxes);\n        if (status)\n            return status;\n        \n        if (surface->n_clips != n_boxes) {\n            if (surface->clips)\n                free (surface->clips);\n            \n            surface->clips = _cairo_malloc_ab (n_boxes, sizeof(DFBRegion));\n            if (!surface->clips) {\n                surface->n_clips = 0;\n                _cairo_region_boxes_fini (region, boxes);\n                return _cairo_error (CAIRO_STATUS_NO_MEMORY);\n            }\n        \n            surface->n_clips = n_boxes;\n        }\n        \n        for (i = 0; i < n_boxes; i++) {\n            surface->clips[i].x1 = boxes[i].p1.x;\n            surface->clips[i].y1 = boxes[i].p1.y;\n            surface->clips[i].x2 = boxes[i].p2.x;\n            surface->clips[i].y2 = boxes[i].p2.y;\n        }\n\n        _cairo_region_boxes_fini (region, boxes);\n    }\n    else {\n        if (surface->clips) {\n            free (surface->clips);\n            surface->clips = NULL;\n            surface->n_clips = 0;\n        }\n    }\n\n    return CAIRO_STATUS_SUCCESS;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-directfb-surface.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_glyph_set_metrics:\n * @scaled_glyph: a #cairo_scaled_glyph_t\n * @scaled_font: a #cairo_scaled_font_t\n * @fs_metrics: a #cairo_text_extents_t in font space\n *\n * _cairo_scaled_glyph_set_metrics() stores user space metrics\n * for the specified glyph given font space metrics. It is\n * called by the font backend when initializing a glyph with\n * CAIRO_SCALED_GLYPH_INFO_METRICS.\n **/\n", "func_signal": "void\n_cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,\n\t\t\t\t cairo_scaled_font_t *scaled_font,\n\t\t\t\t cairo_text_extents_t *fs_metrics)", "code": "{\n    cairo_bool_t first = TRUE;\n    double hm, wm;\n    double min_user_x = 0.0, max_user_x = 0.0, min_user_y = 0.0, max_user_y = 0.0;\n    double min_device_x = 0.0, max_device_x = 0.0, min_device_y = 0.0, max_device_y = 0.0;\n    double device_x_advance, device_y_advance;\n\n    for (hm = 0.0; hm <= 1.0; hm += 1.0)\n\tfor (wm = 0.0; wm <= 1.0; wm += 1.0) {\n\t    double x, y;\n\n\t    /* Transform this corner to user space */\n\t    x = fs_metrics->x_bearing + fs_metrics->width * wm;\n\t    y = fs_metrics->y_bearing + fs_metrics->height * hm;\n\t    cairo_matrix_transform_point (&scaled_font->font_matrix,\n\t\t\t\t\t  &x, &y);\n\t    if (first) {\n\t\tmin_user_x = max_user_x = x;\n\t\tmin_user_y = max_user_y = y;\n\t    } else {\n\t\tif (x < min_user_x) min_user_x = x;\n\t\tif (x > max_user_x) max_user_x = x;\n\t\tif (y < min_user_y) min_user_y = y;\n\t\tif (y > max_user_y) max_user_y = y;\n\t    }\n\n\t    /* Transform this corner to device space from glyph origin */\n\t    x = fs_metrics->x_bearing + fs_metrics->width * wm;\n\t    y = fs_metrics->y_bearing + fs_metrics->height * hm;\n\t    cairo_matrix_transform_distance (&scaled_font->scale,\n\t\t\t\t\t     &x, &y);\n\n\t    if (first) {\n\t\tmin_device_x = max_device_x = x;\n\t\tmin_device_y = max_device_y = y;\n\t    } else {\n\t\tif (x < min_device_x) min_device_x = x;\n\t\tif (x > max_device_x) max_device_x = x;\n\t\tif (y < min_device_y) min_device_y = y;\n\t\tif (y > max_device_y) max_device_y = y;\n\t    }\n\t    first = FALSE;\n\t}\n    scaled_glyph->metrics.x_bearing = min_user_x;\n    scaled_glyph->metrics.y_bearing = min_user_y;\n    scaled_glyph->metrics.width = max_user_x - min_user_x;\n    scaled_glyph->metrics.height = max_user_y - min_user_y;\n\n    scaled_glyph->metrics.x_advance = fs_metrics->x_advance;\n    scaled_glyph->metrics.y_advance = fs_metrics->y_advance;\n    cairo_matrix_transform_distance (&scaled_font->font_matrix,\n\t\t\t\t     &scaled_glyph->metrics.x_advance,\n\t\t\t\t     &scaled_glyph->metrics.y_advance);\n\n    device_x_advance = fs_metrics->x_advance;\n    device_y_advance = fs_metrics->y_advance;\n    cairo_matrix_transform_distance (&scaled_font->scale,\n\t\t\t\t     &device_x_advance,\n\t\t\t\t     &device_y_advance);\n\n    scaled_glyph->bbox.p1.x = _cairo_fixed_from_double (min_device_x);\n    scaled_glyph->bbox.p1.y = _cairo_fixed_from_double (min_device_y);\n    scaled_glyph->bbox.p2.x = _cairo_fixed_from_double (max_device_x);\n    scaled_glyph->bbox.p2.y = _cairo_fixed_from_double (max_device_y);\n\n    scaled_glyph->x_advance = _cairo_lround (device_x_advance);\n    scaled_glyph->y_advance = _cairo_lround (device_y_advance);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/* DFB_SHOW_GLYPHS */\n", "func_signal": "static cairo_bool_t\n_cairo_directfb_surface_is_similar (void *surface_a, void *surface_b, cairo_content_t content)", "code": "{\n    cairo_directfb_surface_t *a = (cairo_directfb_surface_t *) surface_a;\n    cairo_directfb_surface_t *b = (cairo_directfb_surface_t *) surface_b;\n\n    return a->dfb == b->dfb;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-directfb-surface.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_font_matrix:\n * @scaled_font: a #cairo_scaled_font_t\n * @font_matrix: return value for the matrix\n *\n * Stores the font matrix with which @scaled_font was created into\n * @matrix.\n *\n * Since: 1.2\n **/\n", "func_signal": "void\ncairo_scaled_font_get_font_matrix (cairo_scaled_font_t\t*scaled_font,\n\t\t\t\t   cairo_matrix_t\t*font_matrix)", "code": "{\n    if (scaled_font->status) {\n\tcairo_matrix_init_identity (font_matrix);\n\treturn;\n    }\n\n    *font_matrix = scaled_font->font_matrix;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/* LUA_NUMBER */\n", "func_signal": "static void read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  lua_assert(isdigit(ls->current));\n  do {\n    save_and_next(ls);\n  } while (isdigit(ls->current) || ls->current == '.');\n  if (check_next(ls, \"Ee\"))  /* `E'? */\n    check_next(ls, \"+-\");  /* optional exponent sign */\n  while (isalnum(ls->current) || ls->current == '_')\n    save_and_next(ls);\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}", "path": "3rdparty\\lua-5.1.3\\src\\llex.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_destroy:\n * @scaled_font: a #cairo_scaled_font_t\n *\n * Decreases the reference count on @font by one. If the result\n * is zero, then @font and all associated resources are freed.\n * See cairo_scaled_font_reference().\n **/\n", "func_signal": "void\ncairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font)", "code": "{\n    cairo_scaled_font_map_t *font_map;\n    cairo_scaled_font_t *lru = NULL;\n\n    if (scaled_font == NULL ||\n\t    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))\n\treturn;\n\n    font_map = _cairo_scaled_font_map_lock ();\n    assert (font_map != NULL);\n\n    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));\n\n    if (_cairo_reference_count_dec_and_test (&scaled_font->ref_count)) {\n\tif (scaled_font->hash_entry.hash != ZOMBIE) {\n\t    /* Rather than immediately destroying this object, we put it into\n\t     * the font_map->holdovers array in case it will get used again\n\t     * soon (and is why we must hold the lock over the atomic op on\n\t     * the reference count). To make room for it, we do actually\n\t     * destroy the least-recently-used holdover.\n\t     */\n\t    if (font_map->num_holdovers == CAIRO_SCALED_FONT_MAX_HOLDOVERS)\n\t    {\n\t\tlru = font_map->holdovers[0];\n\t\tassert (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&lru->ref_count));\n\n\t\t_cairo_hash_table_remove (font_map->hash_table, &lru->hash_entry);\n\n\t\tfont_map->num_holdovers--;\n\t\tmemmove (&font_map->holdovers[0],\n\t\t\t &font_map->holdovers[1],\n\t\t\t font_map->num_holdovers * sizeof (cairo_scaled_font_t*));\n\t    }\n\n\t    font_map->holdovers[font_map->num_holdovers] = scaled_font;\n\t    font_map->num_holdovers++;\n\t} else\n\t    lru = scaled_font;\n    }\n    _cairo_scaled_font_map_unlock ();\n\n    /* If we pulled an item from the holdovers array, (while the font\n     * map lock was held, of course), then there is no way that anyone\n     * else could have acquired a reference to it. So we can now\n     * safely call fini on it without any lock held. This is desirable\n     * as we never want to call into any backend function with a lock\n     * held. */\n    if (lru) {\n\t_cairo_scaled_font_fini (lru);\n\tfree (lru);\n    }\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_set_user_data:\n * @scaled_font: a #cairo_scaled_font_t\n * @key: the address of a #cairo_user_data_key_t to attach the user data to\n * @user_data: the user data to attach to the #cairo_scaled_font_t\n * @destroy: a #cairo_destroy_func_t which will be called when the\n * #cairo_t is destroyed or when new user data is attached using the\n * same key.\n *\n * Attach user data to @scaled_font.  To remove user data from a surface,\n * call this function with the key that was used to set it and %NULL\n * for @data.\n *\n * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a\n * slot could not be allocated for the user data.\n *\n * Since: 1.4\n **/\n", "func_signal": "cairo_status_t\ncairo_scaled_font_set_user_data (cairo_scaled_font_t\t     *scaled_font,\n\t\t\t\t const cairo_user_data_key_t *key,\n\t\t\t\t void\t\t\t     *user_data,\n\t\t\t\t cairo_destroy_func_t\t      destroy)", "code": "{\n    if (CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))\n\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n\n    return _cairo_user_data_array_set_data (&scaled_font->user_data,\n\t\t\t\t\t    key, user_data, destroy);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * _trace_mask_to_path:\n * @bitmap: An alpha mask (either %CAIRO_FORMAT_A1 or %CAIRO_FORMAT_A8)\n * @path: An initialized path to hold the result\n *\n * Given a mask surface, (an alpha image), fill out the provided path\n * so that when filled it would result in something that approximates\n * the mask.\n *\n * Note: The current tracing code here is extremely primitive. It\n * operates only on an A1 surface, (converting an A8 surface to A1 if\n * necessary), and performs the tracing by drawing a little square\n * around each pixel that is on in the mask. We do not pretend that\n * this is a high-quality result. But we are leaving it up to someone\n * who cares enough about getting a better result to implement\n * something more sophisticated.\n **/\n", "func_signal": "static cairo_status_t\n_trace_mask_to_path (cairo_image_surface_t *mask,\n\t\t     cairo_path_fixed_t *path)", "code": "{\n    cairo_status_t status;\n    cairo_image_surface_t *a1_mask;\n    unsigned char *row, *byte_ptr, byte;\n    int rows, cols, bytes_per_row;\n    int x, y, bit;\n    double xoff, yoff;\n\n    if (mask->format == CAIRO_FORMAT_A1)\n\ta1_mask = (cairo_image_surface_t *) cairo_surface_reference (&mask->base);\n    else\n\ta1_mask = _cairo_image_surface_clone (mask, CAIRO_FORMAT_A1);\n\n    status = cairo_surface_status (&a1_mask->base);\n    if (status) {\n\tcairo_surface_destroy (&a1_mask->base);\n\treturn status;\n    }\n\n    cairo_surface_get_device_offset (&mask->base, &xoff, &yoff);\n\n    bytes_per_row = (a1_mask->width + 7) / 8;\n    for (y = 0, row = a1_mask->data, rows = a1_mask->height; rows; row += a1_mask->stride, rows--, y++) {\n\tfor (x = 0, byte_ptr = row, cols = (a1_mask->width + 7) / 8; cols; byte_ptr++, cols--) {\n\t    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);\n\t    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {\n\t\tif (byte & (1 << bit)) {\n\t\t    status = _add_unit_rectangle_to_path (path,\n\t\t\t\t\t\t\t  x - xoff, y - yoff);\n\t\t    if (status)\n\t\t\tgoto BAIL;\n\t\t}\n\t    }\n\t}\n    }\n\nBAIL:\n    cairo_surface_destroy (&a1_mask->base);\n\n    return status;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * _cairo_scaled_font_set_error:\n * @scaled_font: a scaled_font\n * @status: a status value indicating an error, (eg. not\n * CAIRO_STATUS_SUCCESS)\n *\n * Atomically sets scaled_font->status to @status and calls _cairo_error;\n *\n * All assignments of an error status to scaled_font->status should happen\n * through _cairo_scaled_font_set_error(). Note that due to the nature of\n * the atomic operation, it is not safe to call this function on the nil\n * objects.\n *\n * The purpose of this function is to allow the user to set a\n * breakpoint in _cairo_error() to generate a stack trace for when the\n * user causes cairo to detect an error.\n *\n * Return value: the error status.\n **/\n", "func_signal": "cairo_status_t\n_cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,\n\t\t\t      cairo_status_t status)", "code": "{\n    if (status == CAIRO_STATUS_SUCCESS)\n\treturn status;\n\n    /* Don't overwrite an existing error. This preserves the first\n     * error, which is the most significant. */\n    _cairo_status_set_error (&scaled_font->status, status);\n\n    return _cairo_error (status);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_font_face:\n * @scaled_font: a #cairo_scaled_font_t\n *\n * Gets the font face that this scaled font was created for.\n *\n * Return value: The #cairo_font_face_t with which @scaled_font was\n * created.\n *\n * Since: 1.2\n **/\n", "func_signal": "cairo_font_face_t *\ncairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font)", "code": "{\n    if (scaled_font->status)\n\treturn (cairo_font_face_t*) &_cairo_font_face_nil;\n\n    return scaled_font->font_face;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/* XXX This should disappear in favour of a common pool of error objects. */\n", "func_signal": "cairo_scaled_font_t *\n_cairo_scaled_font_create_in_error (cairo_status_t status)", "code": "{\n    cairo_scaled_font_t *scaled_font;\n\n    assert (status != CAIRO_STATUS_SUCCESS);\n\n    if (status == CAIRO_STATUS_NO_MEMORY)\n\treturn (cairo_scaled_font_t *) &_cairo_scaled_font_nil;\n\n    CAIRO_MUTEX_LOCK (_cairo_scaled_font_error_mutex);\n    scaled_font = _cairo_scaled_font_nil_objects[status];\n    if (scaled_font == NULL) {\n\tscaled_font = malloc (sizeof (cairo_scaled_font_t));\n\tif (scaled_font == NULL) {\n\t    CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_error_mutex);\n\t    _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);\n\t    return (cairo_scaled_font_t *) &_cairo_scaled_font_nil;\n\t}\n\n\t*scaled_font = _cairo_scaled_font_nil;\n\tscaled_font->status = status;\n\t_cairo_scaled_font_nil_objects[status] = scaled_font;\n    }\n    CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_error_mutex);\n\n    return scaled_font;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_ctm:\n * @scaled_font: a #cairo_scaled_font_t\n * @ctm: return value for the CTM\n *\n * Stores the CTM with which @scaled_font was created into @ctm.\n *\n * Since: 1.2\n **/\n", "func_signal": "void\ncairo_scaled_font_get_ctm (cairo_scaled_font_t\t*scaled_font,\n\t\t\t   cairo_matrix_t\t*ctm)", "code": "{\n    if (scaled_font->status) {\n\tcairo_matrix_init_identity (ctm);\n\treturn;\n    }\n\n    *ctm = scaled_font->ctm;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_type:\n * @scaled_font: a #cairo_scaled_font_t\n *\n * This function returns the type of the backend used to create\n * a scaled font. See #cairo_font_type_t for available types.\n *\n * Return value: The type of @scaled_font.\n *\n * Since: 1.2\n **/\n", "func_signal": "cairo_font_type_t\ncairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font)", "code": "{\n    if (CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))\n\treturn CAIRO_FONT_TYPE_TOY;\n\n    return scaled_font->backend->type;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/*\n * Basic #cairo_scaled_font_t object management\n */\n", "func_signal": "cairo_status_t\n_cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,\n\t\t\t cairo_font_face_t\t\t   *font_face,\n\t\t\t const cairo_matrix_t              *font_matrix,\n\t\t\t const cairo_matrix_t              *ctm,\n\t\t\t const cairo_font_options_t\t   *options,\n\t\t\t const cairo_scaled_font_backend_t *backend)", "code": "{\n    cairo_status_t status;\n\n    status = cairo_font_options_status ((cairo_font_options_t *) options);\n    if (status)\n\treturn status;\n\n    _cairo_scaled_font_init_key (scaled_font, font_face,\n\t\t\t\t font_matrix, ctm, options);\n\n    cairo_matrix_multiply (&scaled_font->scale,\n\t\t\t   &scaled_font->font_matrix,\n\t\t\t   &scaled_font->ctm);\n\n    scaled_font->scale_inverse = scaled_font->scale;\n    status = cairo_matrix_invert (&scaled_font->scale_inverse);\n    if (status) {\n\t/* If the font scale matrix is rank 0, just using an all-zero inverse matrix\n\t * makes everything work correctly.  This make font size 0 work without\n\t * producing an error.\n\t *\n\t * FIXME:  If the scale is rank 1, we still go into error mode.  But then\n\t * again, that's what we doo everywhere in cairo.\n\t *\n\t * Also, the check for == 0. below may bee too harsh...\n\t */\n        if (scaled_font->scale.xx == 0. && scaled_font->scale.xy == 0. &&\n\t    scaled_font->scale.yx == 0. && scaled_font->scale.yy == 0.)\n\t    cairo_matrix_init (&scaled_font->scale_inverse,\n\t\t\t       0, 0, 0, 0,\n\t\t\t       -scaled_font->scale.x0,\n\t\t\t       -scaled_font->scale.y0);\n\telse\n\t    return status;\n    }\n\n    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,\n\t\t\t\t\t       _cairo_scaled_glyph_destroy,\n\t\t\t\t\t       MAX_GLYPHS_CACHED_PER_FONT);\n    if (scaled_font->glyphs == NULL)\n\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n\n    CAIRO_REFERENCE_COUNT_INIT (&scaled_font->ref_count, 1);\n\n    _cairo_user_data_array_init (&scaled_font->user_data);\n\n    cairo_font_face_reference (font_face);\n\n    CAIRO_MUTEX_INIT (scaled_font->mutex);\n\n    scaled_font->surface_backend = NULL;\n    scaled_font->surface_private = NULL;\n\n    scaled_font->backend = backend;\n\n    return CAIRO_STATUS_SUCCESS;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/*\n * Compute a device-space bounding box for the glyphs.\n */\n", "func_signal": "cairo_status_t\n_cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t\t *scaled_font,\n\t\t\t\t\t const cairo_glyph_t\t *glyphs,\n\t\t\t\t\t int                      num_glyphs,\n\t\t\t\t\t cairo_rectangle_int_t   *extents)", "code": "{\n    cairo_status_t status = CAIRO_STATUS_SUCCESS;\n    int i;\n    cairo_point_int_t min = { CAIRO_RECT_INT_MAX, CAIRO_RECT_INT_MAX };\n    cairo_point_int_t max = { CAIRO_RECT_INT_MIN, CAIRO_RECT_INT_MIN };\n\n    if (scaled_font->status)\n\treturn scaled_font->status;\n\n    for (i = 0; i < num_glyphs; i++) {\n\tcairo_scaled_glyph_t\t*scaled_glyph;\n\tint\t\t\tleft, top;\n\tint\t\t\tright, bottom;\n\tint\t\t\tx, y;\n\n\tstatus = _cairo_scaled_glyph_lookup (scaled_font,\n\t\t\t\t\t     glyphs[i].index,\n\t\t\t\t\t     CAIRO_SCALED_GLYPH_INFO_METRICS,\n\t\t\t\t\t     &scaled_glyph);\n\tif (status)\n\t    return _cairo_scaled_font_set_error (scaled_font, status);\n\n\t/* glyph images are snapped to pixel locations */\n\tx = _cairo_lround (glyphs[i].x);\n\ty = _cairo_lround (glyphs[i].y);\n\n\tleft   = x + _cairo_fixed_integer_floor(scaled_glyph->bbox.p1.x);\n\ttop    = y + _cairo_fixed_integer_floor (scaled_glyph->bbox.p1.y);\n\tright  = x + _cairo_fixed_integer_ceil(scaled_glyph->bbox.p2.x);\n\tbottom = y + _cairo_fixed_integer_ceil (scaled_glyph->bbox.p2.y);\n\n\tif (left < min.x) min.x = left;\n\tif (right > max.x) max.x = right;\n\tif (top < min.y) min.y = top;\n\tif (bottom > max.y) max.y = bottom;\n    }\n    if (min.x < max.x && min.y < max.y) {\n\textents->x = min.x;\n\textents->width = max.x - min.x;\n\textents->y = min.y;\n\textents->height = max.y - min.y;\n    } else {\n\textents->x = extents->y = 0;\n\textents->width = extents->height = 0;\n    }\n    return CAIRO_STATUS_SUCCESS;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_reference:\n * @scaled_font: a #cairo_scaled_font_t, (may be %NULL in which case\n * this function does nothing)\n *\n * Increases the reference count on @scaled_font by one. This prevents\n * @scaled_font from being destroyed until a matching call to\n * cairo_scaled_font_destroy() is made.\n *\n * The number of references to a #cairo_scaled_font_t can be get using\n * cairo_scaled_font_get_reference_count().\n *\n * Returns: the referenced #cairo_scaled_font_t\n **/\n", "func_signal": "cairo_scaled_font_t *\ncairo_scaled_font_reference (cairo_scaled_font_t *scaled_font)", "code": "{\n    if (scaled_font == NULL ||\n\t    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))\n\treturn scaled_font;\n\n    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));\n\n    _cairo_reference_count_inc (&scaled_font->ref_count);\n\n    return scaled_font;\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/**\n * cairo_scaled_font_get_font_options:\n * @scaled_font: a #cairo_scaled_font_t\n * @options: return value for the font options\n *\n * Stores the font options with which @scaled_font was created into\n * @options.\n *\n * Since: 1.2\n **/\n", "func_signal": "void\ncairo_scaled_font_get_font_options (cairo_scaled_font_t\t\t*scaled_font,\n\t\t\t\t    cairo_font_options_t\t*options)", "code": "{\n    if (cairo_font_options_status (options))\n\treturn;\n\n    if (scaled_font->status) {\n\t_cairo_font_options_init_default (options);\n\treturn;\n    }\n\n    _cairo_font_options_init_copy (options, &scaled_font->options);\n}", "path": "3rdparty\\cairo-1.6.4\\src\\cairo-scaled-font.c", "repo_name": "elq/torch5", "stars": 2, "license": "other", "language": "c", "size": 2276}
{"docstring": "/* Server methods */\n", "func_signal": "static void avahi_llmnr_server_prepare_response(AvahiServer *s, AvahiInterface *i, AvahiEntry *e)", "code": "{\n    assert(s);\n    assert(i);\n    assert(e);\n    assert(e->type == AVAHI_ENTRY_LLMNR);\n\n    avahi_record_list_push (s->llmnr.record_list, \n\t\t\t   (e->record), \n\t\t\t   (e->flags) & AVAHI_PUBLISH_UNIQUE, \n\t\t\t   avahi_llmnr_entry_is_verifying(s, e, i), \n\t\t\t   0);\n\n    assert(!avahi_record_list_is_empty(s->llmnr.record_list));\n}", "path": "avahi-core\\llmnr-server.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Decrease the n_verifying counter and free the 'lq' object */\n", "func_signal": "static void decrease_n_verify(AvahiLLMNREntryVerify *ev)", "code": "{\n\tassert(ev);\n\tassert(ev->e->group->type == AVAHI_GROUP_LLMNR);\n\n\t/* \n\t1. Group is new and presently the state is verifying and decreasing the counter\n\tmay enter the group in established state.\n\t2. Group is already established and we are registering a new entry, we should have \n\tn_verifying greater than zero \n\t*/\n\tassert((ev->e->group->state == AVAHI_ENTRY_GROUP_LLMNR_VERIFYING) ||\n\t\t   (ev->e->group->proto.llmnr.n_verifying > 0));\n\n\t--ev->e->group->proto.llmnr.n_verifying;\n\tcheck_established(ev->e->group);\n}", "path": "avahi-core\\verify.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* This function is called when 'AvahiLLMNRQuery' has been processed completely.\nBased on the data we get in 'userdata', state of the 'AvahiLLMNREntryVerifier' is decided*/\n", "func_signal": "static void query_callback(\n\tAvahiIfIndex idx,\n    AvahiProtocol protocol,\n    AvahiRecord *r,\n    void *userdata)", "code": "{\n\t/* Get AvahiLLMNREntryVerify object, responder address and 'T' bit info, if any*/\n\n\tAvahiVerifierData *vdata = userdata;\n\tint win, t_bit ;\n\n\tAvahiLLMNREntryVerify *ev;\n\tconst AvahiAddress *address;\n\n\twin = 0;\n\tev = (vdata->ev);\n\taddress = (vdata->address);\n\tt_bit = (vdata->t_bit);\n\n\t/* May be by the time we come back in this function due to conflict in some other entry\n\tof the group this entry belongs to, this entry has already been put up in the dead state.*/\n<<<<<<< HEAD:avahi-core/verify.c\n\tif(ev->e->dead)\n=======\n\tif (ev->e->dead) \n>>>>>>> cc62833... squash 1:avahi-core/verify.c\n\t\treturn;\n\n\tassert(AVAHI_IF_VALID(idx));\n\tassert(AVAHI_PROTO_VALID(protocol));\n\tassert(userdata);\n\tassert(ev->e->type == AVAHI_ENTRY_LLMNR);\n<<<<<<< HEAD:avahi-core/verify.c\n=======\n\tassert(!ev->e->dead);\n>>>>>>> cc62833... squash 1:avahi-core/verify.c\n\n\t/* Start comparing values.*/\n\tif(ev->state == AVAHI_CONFLICT) {\n\n\t\t/* Set by handle_response function*/\n\t\t/* There is already a conflict about this key or name is not UNIQUE */\n\t\t/* Withdraw this Entry*/\n\t\twithdraw_llmnr_entry(ev->s, ev->e);\n\n\t} else {\n\n\t\tif(!r && !address) {\n\t\t\t/* No record found for this key. Our name is unique. */\n<<<<<<< HEAD:avahi-core/verify.c\n\t\t\tchar *t = avahi_record_to_string(ev->e->record);\t\t\n/*\t\t\tavahi_log_info(\"**LLMNR Entry Verified\\n %s on interface index (%d) and protocol : %s\", \n\t\t\t\t\t\t\tt, \n\t\t\t\t\t\t\tev->interface->hardware->index, \n\t\t\t\t\t\t\tev->interface->protocol == AVAHI_PROTO_INET ? \"IPv4\" : \"IPv6\");*/\n\n\t\t\tev->state = AVAHI_VERIFIED;\n\n\t\t\tif(ev->e->group)\n=======\n/*\t\t\tchar *t;\n\t\t\tt = avahi_record_to_string(ev->e->record);\t\t\n\t\t\tavahi_log_info(\"LLMNR Entry Verified\\n %s on interface index (%d) and protocol : %s\",\n\t\t\t\t\t\t\tt, \n\t\t\t\t\t\t\tev->interface->hardware->index, \n\t\t\t\t\t\t\tavahi_proto_to_string(ev->interface->protocol));*/\n\n\t\t\tev->state = AVAHI_VERIFIED;\n\n\t\t\tif(ev->e->group) \n>>>>>>> cc62833... squash 1:avahi-core/verify.c\n\t\t\t\tdecrease_n_verify(ev);\n\n\t\t} else {\n\t\t\t/* We may have two cases now !r && address || r && !address\n\t\t\tr && !address when T bit is clear\n\t\t\t!r && address when T bit is set */\n\n\t\t\t/*  So check 'T' bit first*/\n\t\t\tif(!(t_bit)) {\n\n \t\t\t\t/* Assert that we had a response for this key */\n\t\t\t\tassert(r);\n\n\t\t\t\t/*Another host has already claimed for this name and is using it.*/\n\t\t\t\tev->state = AVAHI_CONFLICT;\n\n\t\t\t\t/* withdraw this entry */\t\n\t\t\t\twithdraw_llmnr_entry(ev->s, ev->e);\n\n\t\t\t} else {\n\t\t\t\t/* 'T' bit is set. Now we compare two IP addresses lexicographically*/\n\t\t\t\tassert(protocol == address->proto);\n\n\t\t\t\t/* Source IP address = which is being used by interface to join LLMNR group\n\t\t\t\tWe compare that address and responder address */\n\t\t\t\tassert(ev->interface->llmnr.llmnr_joined);\n\t\t\t\t\n\t\t\t\t\tif( (protocol == AVAHI_PROTO_INET) && \n\t\t\t\t\t\t(memcmp (&(ev->interface->llmnr.local_llmnr_address.data.ipv4.address), &(address->data.ipv4.address), sizeof(AvahiIPv4Address))) )\n\t\t\t\t\t\t\twin = 1;\n\t\t\t\t\telse /*( protocol == AVAHI_PROTO_INET6) */\n\t\t\t\t\t\tif(memcmp( &(ev->interface->llmnr.local_llmnr_address.data.ipv6.address), &(address->data.ipv6.address), sizeof(AvahiIPv6Address)))\n\t\t\t\t\t\t\twin = 1;\n\n\t\t\t\t\tif(win) {\n\t\t\t\t\t\t/* We can claim this name */\n\t\t\t\t\t\tev->state = AVAHI_ESTABLISHED;\n\t\t\t\t\t\tdecrease_n_verify(ev);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev->state = AVAHI_CONFLICT;\n\t\t\t\t\t\twithdraw_llmnr_entry(ev->s, ev->e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n<<<<<<< HEAD:avahi-core/verify.c\n\t/*ev->lq = NULL;*/\n=======\n\tev->lq = NULL;\n>>>>>>> cc62833... squash 1:avahi-core/verify.c\n\treturn;\n}", "path": "avahi-core\\verify.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* AvahiServiceResolver implementation */\n", "func_signal": "DBusHandlerResult avahi_service_resolver_event (AvahiClient *client, AvahiResolverEvent event, DBusMessage *message)", "code": "{\n    AvahiServiceResolver *r = NULL;\n    DBusError error;\n    const char *path;\n    AvahiStringList *strlst = NULL;\n\n    assert(client);\n    assert(message);\n    \n    dbus_error_init (&error);\n\n    if (!(path = dbus_message_get_path(message)))\n        goto fail;\n\n    for (r = client->service_resolvers; r; r = r->service_resolvers_next)\n        if (strcmp (r->path, path) == 0)\n            break;\n\n    if (!r)\n        goto fail;\n\n    switch (event) {\n        case AVAHI_RESOLVER_FOUND: {\n            int j;\n            int32_t interface, protocol, aprotocol;\n            uint32_t flags;\n            char *name, *type, *domain, *host, *address;\n            uint16_t port;\n            DBusMessageIter iter, sub;\n            AvahiAddress a;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_INT32, &interface,\n                    DBUS_TYPE_INT32, &protocol,\n                    DBUS_TYPE_STRING, &name,\n                    DBUS_TYPE_STRING, &type,\n                    DBUS_TYPE_STRING, &domain,\n                    DBUS_TYPE_STRING, &host,\n                    DBUS_TYPE_INT32, &aprotocol,\n                    DBUS_TYPE_STRING, &address,\n                    DBUS_TYPE_UINT16, &port,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n            \n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n        \n            dbus_message_iter_init(message, &iter);\n        \n            for (j = 0; j < 9; j++)\n                dbus_message_iter_next(&iter);\n        \n            if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||\n                dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_ARRAY) {\n                fprintf(stderr, \"Error parsing service resolving message\\n\");\n                goto fail;\n            }\n        \n            strlst = NULL;\n            dbus_message_iter_recurse(&iter, &sub);\n        \n            for (;;) {\n                DBusMessageIter sub2;\n                int at;\n                const uint8_t *k;\n                int n;\n            \n                if ((at = dbus_message_iter_get_arg_type(&sub)) == DBUS_TYPE_INVALID)\n                    break;\n            \n                assert(at == DBUS_TYPE_ARRAY);\n            \n                if (dbus_message_iter_get_element_type(&sub) != DBUS_TYPE_BYTE) {\n                    fprintf(stderr, \"Error parsing service resolving message\\n\");\n                    goto fail;\n                }\n            \n                dbus_message_iter_recurse(&sub, &sub2);\n\n                k = NULL; n = 0;\n                dbus_message_iter_get_fixed_array(&sub2, &k, &n);\n                if (k && n > 0)\n                    strlst = avahi_string_list_add_arbitrary(strlst, k, n);\n            \n                dbus_message_iter_next(&sub);\n            }\n\n            dbus_message_iter_next(&iter);\n\n            if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_UINT32) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n\n            dbus_message_iter_get_basic(&iter, &flags);\n                                    \n            assert(address);\n\n            if (address[0] == 0)\n                address = NULL;\n\t    else\n            \tavahi_address_parse(address, (AvahiProtocol) aprotocol, &a);\n    \n            r->callback(r, (AvahiIfIndex) interface, (AvahiProtocol) protocol, AVAHI_RESOLVER_FOUND, name, type, domain, host, address ? &a : NULL, port, strlst, (AvahiLookupResultFlags) flags, r->userdata);\n        \n            avahi_string_list_free(strlst);\n            break;\n        }\n            \n        case AVAHI_RESOLVER_FAILURE: {\n            char *etxt;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_STRING, &etxt,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n            \n            avahi_client_set_errno(r->client, avahi_error_dbus_to_number(etxt));\n            r->callback(r, r->interface, r->protocol, event, r->name, r->type, r->domain, NULL, NULL, 0, NULL, 0, r->userdata);\n            break;\n        }\n    }\n\n    return DBUS_HANDLER_RESULT_HANDLED;\n\n    \nfail:\n    dbus_error_free (&error);\n    avahi_string_list_free(strlst);\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}", "path": "avahi-client\\resolver.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* AvahiHostNameResolver implementation */\n", "func_signal": "DBusHandlerResult avahi_host_name_resolver_event (AvahiClient *client, AvahiResolverEvent event, DBusMessage *message)", "code": "{\n    AvahiHostNameResolver *r = NULL;\n    DBusError error;\n    const char *path;\n\n    assert(client);\n    assert(message);\n    \n    dbus_error_init (&error);\n\n    if (!(path = dbus_message_get_path(message)))\n        goto fail;\n\n    for (r = client->host_name_resolvers; r; r = r->host_name_resolvers_next)\n        if (strcmp (r->path, path) == 0)\n            break;\n\n    if (!r)\n        goto fail;\n\n    switch (event) {\n        case AVAHI_RESOLVER_FOUND: {\n            int32_t interface, protocol, aprotocol;\n            uint32_t flags;\n            char *name, *address;\n            AvahiAddress a;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_INT32, &interface,\n                    DBUS_TYPE_INT32, &protocol,\n                    DBUS_TYPE_STRING, &name,\n                    DBUS_TYPE_INT32, &aprotocol,\n                    DBUS_TYPE_STRING, &address,\n                    DBUS_TYPE_UINT32, &flags,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n            \n            assert(address);\n            if (!avahi_address_parse(address, (AvahiProtocol) aprotocol, &a)) {\n                fprintf(stderr, \"Failed to parse address\\n\");\n                goto fail;\n            }\n            \n            r->callback(r, (AvahiIfIndex) interface, (AvahiProtocol) protocol, AVAHI_RESOLVER_FOUND, name, &a, (AvahiLookupResultFlags) flags, r->userdata);\n            break;\n        }\n            \n        case AVAHI_RESOLVER_FAILURE: {\n            char *etxt;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_STRING, &etxt,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n            \n            avahi_client_set_errno(r->client, avahi_error_dbus_to_number(etxt));\n            r->callback(r, r->interface, r->protocol, event, r->host_name, NULL, 0, r->userdata);\n            break;\n        }\n    }\n\n    return DBUS_HANDLER_RESULT_HANDLED;\n    \nfail:\n    dbus_error_free (&error);\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}", "path": "avahi-client\\resolver.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* handle address coming or going away */\n", "func_signal": "static int\nrtm_dispatch_newdeladdr(struct rtm_dispinfo *di)", "code": "{\n        Address                 *ap;\n        struct ifa_msghdr       *ifam;\n        struct sockaddr         *sa;\n        struct sockaddr_in      *sin;\n        int                     link_local;\n\n/* macro to skip to next RTA; has side-effects */\n#define SKIPRTA(ifamsgp, rta, sa)                                       \\\n        do {                                                            \\\n                if ((ifamsgp)->ifam_addrs & (rta))                      \\\n                        (sa) = next_sa((sa));                           \\\n        } while (0)\n\n        ifam = &((rtmunion_t *)di->di_buf)->ifam;\n\n        assert(ifam->ifam_type == RTM_NEWADDR ||\n               ifam->ifam_type == RTM_DELADDR);\n\n        daemon_log(LOG_DEBUG, \"%s: %s for iface %d (%s)\", __func__,\n            ifam->ifam_type == RTM_NEWADDR ? \"NEWADDR\" : \"DELADDR\",\n            ifam->ifam_index, (ifam->ifam_index == ifindex) ? \"ours\" : \"not ours\");\n\n        if (ifam->ifam_index != ifindex)\n                return (0);\n\n        if (!(ifam->ifam_addrs & RTA_IFA)) {\n                daemon_log(LOG_ERR, \"ifa msg has no RTA_IFA.\");\n                return (0);\n        }\n\n        /* skip over rtmsg padding correctly */\n        sa = (struct sockaddr *)(ifam + 1);\n        SKIPRTA(ifam, RTA_DST, sa);\n        SKIPRTA(ifam, RTA_GATEWAY, sa);\n        SKIPRTA(ifam, RTA_NETMASK, sa);\n        SKIPRTA(ifam, RTA_GENMASK, sa);\n        SKIPRTA(ifam, RTA_IFP, sa);\n\n        /*\n         * sa now points to RTA_IFA sockaddr; we are only interested\n         * in updates for routable addresses.\n         */\n        if (sa->sa_family != AF_INET) {\n                daemon_log(LOG_DEBUG, \"%s: RTA_IFA family not AF_INET (=%d)\", __func__, sa->sa_family);\n                return (0);\n        }\n\n        sin = (struct sockaddr_in *)sa;\n        link_local = IN_LINKLOCAL(ntohl(sin->sin_addr.s_addr));\n\n        daemon_log(LOG_DEBUG, \"%s: %s for %s (%s)\", __func__,\n            ifam->ifam_type == RTM_NEWADDR ? \"NEWADDR\" : \"DELADDR\",\n            inet_ntoa(sin->sin_addr), link_local ? \"link local\" : \"routable\");\n\n        if (link_local)\n                return (0);\n\n        for (ap = addresses; ap; ap = ap->addresses_next) {\n                if (ap->address == sin->sin_addr.s_addr)\n                        break;\n        }\n        if (ifam->ifam_type == RTM_DELADDR && ap != NULL) {\n                AVAHI_LLIST_REMOVE(Address, addresses, addresses, ap);\n                avahi_free(ap);\n        }\n        if (ifam->ifam_type == RTM_NEWADDR && ap == NULL) {\n                ap = avahi_new(Address, 1);\n                ap->address = sin->sin_addr.s_addr;\n                AVAHI_LLIST_PREPEND(Address, addresses, addresses, ap);\n        }\n\n        return (0);\n#undef SKIPRTA\n}", "path": "avahi-autoipd\\iface-bsd.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/** Add an arbitrary record */\n", "func_signal": "int avahi_entry_group_add_record(\n    AvahiEntryGroup *group,\n    AvahiIfIndex interface,\n    AvahiProtocol protocol,\n    AvahiPublishFlags flags,\n    const char *name,\n    uint16_t clazz,\n    uint16_t type,\n    uint32_t ttl,\n    const void *rdata,\n    size_t size)", "code": "{\n\n    DBusMessage *message = NULL, *reply = NULL;\n    int r = AVAHI_OK;\n    DBusError error;\n    AvahiClient *client;\n    int32_t i_interface, i_protocol;\n    uint32_t u_flags;\n\n    assert(name);\n\n    client = group->client;\n\n    if (!group->path || !avahi_client_is_connected(group->client))\n        return avahi_client_set_errno(group->client, AVAHI_ERR_BAD_STATE);\n\n    dbus_error_init(&error);\n    \n    if (!(message = dbus_message_new_method_call (AVAHI_DBUS_NAME, group->path, AVAHI_DBUS_INTERFACE_ENTRY_GROUP, \"AddRecord\"))) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_NO_MEMORY);\n        goto fail;\n    }\n\n    i_interface = (int32_t) interface;\n    i_protocol = (int32_t) protocol;\n    u_flags = (uint32_t) flags;\n        \n    if (!dbus_message_append_args(\n            message,\n            DBUS_TYPE_INT32, &i_interface,\n            DBUS_TYPE_INT32, &i_protocol,\n            DBUS_TYPE_UINT32, &u_flags,\n            DBUS_TYPE_STRING, &name,\n            DBUS_TYPE_UINT16, &clazz,\n            DBUS_TYPE_UINT16, &type,\n            DBUS_TYPE_UINT32, &ttl,\n            DBUS_TYPE_INVALID) || append_rdata(message, rdata, size) < 0) {\n        r = avahi_client_set_errno(group->client, AVAHI_ERR_NO_MEMORY);\n        goto fail;\n    }\n    \n    if (!(reply = dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error)) ||\n        dbus_error_is_set (&error)) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_DBUS_ERROR);\n        goto fail;\n    }\n    \n    if (!dbus_message_get_args(reply, &error, DBUS_TYPE_INVALID) ||\n        dbus_error_is_set (&error)) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_DBUS_ERROR);\n        goto fail;\n    }\n\n    dbus_message_unref(message);\n    dbus_message_unref(reply);\n\n    return AVAHI_OK;\n\nfail:\n    \n    if (dbus_error_is_set(&error)) {\n        r = avahi_client_set_dbus_error(client, &error);\n        dbus_error_free(&error);\n    }\n\n    if (message)\n        dbus_message_unref(message);\n\n    if (reply)\n        dbus_message_unref(reply);\n\n    return r;\n}", "path": "avahi-client\\entrygroup.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Solaris 8 and later; Sol 7? */\n/*\n * I got this function from GNU zsbra\n */\n", "func_signal": "static int ip6_masklen (struct in6_addr netmask)", "code": "{\n    int len = 0;\n    unsigned char val;\n    unsigned char *pnt;\n\n    pnt = (unsigned char *) & netmask;\n\n    while ((*pnt == 0xff) && len < 128) {\n        len += 8;\n        pnt++;\n    }\n\n    if (len < 128) {\n        val = *pnt;\n        while (val) {\n            len++;\n            val <<= 1;\n        }\n    }\n    return len;\n}", "path": "avahi-core\\iface-pfroute.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/** Set the wide area DNS servers */\n", "func_signal": "int avahi_server_set_wide_area_servers(AvahiServer *s, const AvahiAddress *a, unsigned n)", "code": "{\n    assert(s);\n\n    if (!s->wide_area.wide_area_lookup_engine)\n        return avahi_server_set_errno(s, AVAHI_ERR_INVALID_CONFIG);\n\n    avahi_wide_area_set_servers(s->wide_area.wide_area_lookup_engine, a, n);\n    return AVAHI_OK;\n}", "path": "avahi-core\\server.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* handle link coming or going away */\n", "func_signal": "static int\nrtm_dispatch_ifannounce(struct rtm_dispinfo *di)", "code": "{\n        rtmunion_t *rtm = (void *)di->di_buf;\n\n        assert(rtm->rtm.rtm_type == RTM_IFANNOUNCE);\n\n        daemon_log(LOG_DEBUG, \"%s: IFANNOUNCE for ifindex %d\",\n            __func__, rtm->ifan.ifan_index);\n\n        switch (rtm->ifan.ifan_what) {\n        case IFAN_ARRIVAL:\n                if (rtm->ifan.ifan_index == ifindex) {\n                        daemon_log(LOG_ERR,\n\"RTM_IFANNOUNCE IFAN_ARRIVAL, for ifindex %d, which we already manage.\",\n                            ifindex);\n                        return (-1);\n                }\n                break;\n        case IFAN_DEPARTURE:\n                if (rtm->ifan.ifan_index == ifindex) {\n                        daemon_log(LOG_ERR, \"Interface vanished.\");\n                        return (-1);\n                }\n                break;\n        default:\n                /* ignore */\n                break;\n        }\n\n        return (0);\n}", "path": "avahi-autoipd\\iface-bsd.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/** Set the browsing domains */\n", "func_signal": "int avahi_server_set_browse_domains(AvahiServer *s, AvahiStringList *domains)", "code": "{\n    AvahiStringList *l;\n    \n    assert(s);\n\n    for (l = s->config.browse_domains; l; l = l->next)\n        if (!avahi_is_valid_domain_name((char*) l->text))\n            return avahi_server_set_errno(s, AVAHI_ERR_INVALID_DOMAIN_NAME);\n    \n    avahi_string_list_free(s->config.browse_domains);\n    s->config.browse_domains = avahi_string_list_copy(domains);\n\n    return AVAHI_OK;\n}", "path": "avahi-core\\server.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* /LLMNR */\n", "func_signal": "int avahi_dump_caches(AvahiInterfaceMonitor *m, AvahiDumpCallback callback, void* userdata)", "code": "{\n    AvahiInterface *i;\n    assert(m);\n\n    for (i = m->interfaces; i; i = i->interface_next) {\n        if (avahi_interface_is_relevant(i)) {\n            char ln[256];\n            snprintf(ln, sizeof(ln), \";;; INTERFACE %s.%s ;;;\", i->hardware->name, avahi_proto_to_string(i->protocol));\n            callback(ln, userdata);\n            if (avahi_cache_dump(i->mdns.cache, callback, userdata) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}", "path": "avahi-core\\iface.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Escape \"\\\" and \".\", append \\0 */\n", "func_signal": "char *avahi_escape_label(const char* src, size_t src_length, char **ret_name, size_t *ret_size)", "code": "{\n    char *r;\n\n    assert(src);\n    assert(ret_name);\n    assert(*ret_name);\n    assert(ret_size);\n    assert(*ret_size > 0);\n\n    r = *ret_name;\n\n    while (src_length > 0) {\n        if (*src == '.' || *src == '\\\\') {\n\n            /* Dot or backslash */\n            \n            if (*ret_size < 3)\n                return NULL;\n            \n            *((*ret_name) ++) = '\\\\';\n            *((*ret_name) ++) = *src;\n            (*ret_size) -= 2;\n            \n        } else if (\n            *src == '_' ||\n            *src == '-' ||\n            (*src >= '0' && *src <= '9') ||\n            (*src >= 'a' && *src <= 'z') ||\n            (*src >= 'A' && *src <= 'Z')) {\n\n            /* Proper character */\n            \n            if (*ret_size < 2)\n                return NULL;\n        \n            *((*ret_name)++) = *src;\n            (*ret_size) --;\n            \n        } else {\n\n            /* Everything else */\n\n            if (*ret_size < 5)\n                return NULL;\n\n            *((*ret_name) ++) = '\\\\';\n            *((*ret_name) ++) = '0' + (char)  ((uint8_t) *src / 100);\n            *((*ret_name) ++) = '0' + (char) (((uint8_t) *src / 10) % 10);\n            *((*ret_name) ++) = '0' + (char)  ((uint8_t) *src % 10);\n            \n            (*ret_size) -= 4;\n        }\n\n        src_length --;\n        src++;\n    }\n\n    **ret_name = 0;\n\n    return r;\n}", "path": "avahi-common\\domain.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Move a node to the correct position */\n", "func_signal": "void avahi_prio_queue_shuffle(AvahiPrioQueue *q, AvahiPrioQueueNode *n)", "code": "{\n    assert(q);\n    assert(n);\n    assert(n->queue == q);\n\n    /* Move up until the position is OK */\n    while (n->parent && q->compare(n->parent->data, n->data) > 0)\n        exchange_nodes(q, n, n->parent);\n\n    /* Move down until the position is OK */\n    for (;;) {\n        AvahiPrioQueueNode *min;\n\n        if (!(min = n->left)) {\n            /* No children */\n            assert(!n->right);\n            break;\n        }\n\n        if (n->right && q->compare(n->right->data, min->data) < 0)\n            min = n->right;\n\n        /* min now contains the smaller one of our two children */\n\n        if (q->compare(n->data, min->data) <= 0)\n            /* Order OK */\n            break;\n\n        exchange_nodes(q, n, min);\n    }\n}", "path": "avahi-core\\prioq.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Just for internal use */\n", "func_signal": "int avahi_server_set_errno(AvahiServer *s, int error)", "code": "{\n    assert(s);\n\n    return s->error = error;\n}", "path": "avahi-core\\server.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/*\n * Dispatch kernel routing socket messages.\n */\n", "func_signal": "static int\nrtm_dispatch(void)", "code": "{\n        struct msghdr mh;\n        struct iovec iov[1];\n        struct rt_msghdr *rtm;\n        struct rtm_dispinfo *di;\n        ssize_t len;\n        int retval;\n\n        di = malloc(sizeof(*di));\n        if (di == NULL) {\n                daemon_log(LOG_ERR, \"malloc(%d): %s\", sizeof(*di),\n                    strerror(errno));\n                return (-1);\n        }\n        di->di_buflen = MAX_RTMSG_SIZE;\n        di->di_buf = calloc(MAX_RTMSG_SIZE, 1);\n        if (di->di_buf == NULL) {\n                free(di);\n                daemon_log(LOG_ERR, \"calloc(%d): %s\", MAX_RTMSG_SIZE,\n                    strerror(errno));\n                return (-1);\n        }\n\n        memset(&mh, 0, sizeof(mh));\n        iov[0].iov_base = di->di_buf;\n        iov[0].iov_len = di->di_buflen;\n        mh.msg_iov = iov;\n        mh.msg_iovlen = 1;\n\n        retval = 0;\n        for (;;) {\n                len = recvmsg(fd, &mh, MSG_DONTWAIT);\n                if (len == -1) {\n                        if (errno == EWOULDBLOCK)\n                                break;\n                        else {\n                                daemon_log(LOG_ERR, \"recvmsg(): %s\",\n                                    strerror(errno));\n                                retval = -1;\n                                break;\n                        }\n                }\n\n                rtm = (void *)di->di_buf;\n                if (rtm->rtm_version != RTM_VERSION) {\n                        daemon_log(LOG_ERR,\n                            \"unknown routing socket message (version %d)\\n\",\n                            rtm->rtm_version);\n                        /* this is non-fatal; just ignore it for now. */\n                        continue;\n                }\n\n                switch (rtm->rtm_type) {\n                case RTM_NEWADDR:\n                case RTM_DELADDR:\n                        retval = rtm_dispatch_newdeladdr(di);\n                        break;\n                case RTM_IFANNOUNCE:\n                        retval = rtm_dispatch_ifannounce(di);\n                        break;\n                default:\n                        daemon_log(LOG_DEBUG, \"%s: rtm_type %d ignored\", __func__, rtm->rtm_type);\n                        break;\n                }\n\n                /*\n                 * If we got an error; assume our position on the call\n                 * stack is enclosed by a level-triggered event loop,\n                 * and signal the error condition.\n                 */\n                if (retval != 0)\n                        break;\n        }\n        free(di->di_buf);\n        free(di);\n\n        return (retval);\n}", "path": "avahi-autoipd\\iface-bsd.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* LLMNR */\n", "func_signal": "int avahi_interface_post_llmnr_query(AvahiInterface *i, AvahiLLMNRQuery *lq, int im)", "code": "{\n    assert(i);\n    assert(lq);\n\n    if (!i->llmnr.verifying)\n        return 0;\n\n    /*lq object  post id will be filled by qj there only */\n    if(avahi_llmnr_query_scheduler_post(i->llmnr.query_scheduler, lq, im)) \n\t\treturn 1;\n\t\n\treturn 0;\n}", "path": "avahi-core\\iface.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* AvahiAddressResolver implementation */\n", "func_signal": "DBusHandlerResult avahi_address_resolver_event (AvahiClient *client, AvahiResolverEvent event, DBusMessage *message)", "code": "{\n    AvahiAddressResolver *r = NULL;\n    DBusError error;\n    const char *path;\n\n    assert(client);\n    assert(message);\n    \n    dbus_error_init (&error);\n\n    if (!(path = dbus_message_get_path(message)))\n        goto fail;\n\n    for (r = client->address_resolvers; r; r = r->address_resolvers_next)\n        if (strcmp (r->path, path) == 0)\n            break;\n\n    if (!r)\n        goto fail;\n\n    switch (event) {\n        case AVAHI_RESOLVER_FOUND: {\n            int32_t interface, protocol, aprotocol;\n            uint32_t flags;\n            char *name, *address;\n            AvahiAddress a;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_INT32, &interface,\n                    DBUS_TYPE_INT32, &protocol,\n                    DBUS_TYPE_INT32, &aprotocol,\n                    DBUS_TYPE_STRING, &address,\n                    DBUS_TYPE_STRING, &name,\n                    DBUS_TYPE_UINT32, &flags,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n            \n            assert(address);\n            if (!avahi_address_parse(address, (AvahiProtocol) aprotocol, &a)) {\n                fprintf(stderr, \"Failed to parse address\\n\");\n                goto fail;\n            }\n            \n            r->callback(r, (AvahiIfIndex) interface, (AvahiProtocol) protocol, AVAHI_RESOLVER_FOUND, &a, name, (AvahiLookupResultFlags) flags, r->userdata);\n            break;\n        }\n\n        case AVAHI_RESOLVER_FAILURE: {\n            char *etxt;\n            \n            if (!dbus_message_get_args(\n                    message, &error,\n                    DBUS_TYPE_STRING, &etxt,\n                    DBUS_TYPE_INVALID) ||\n                dbus_error_is_set (&error)) {\n                fprintf(stderr, \"Failed to parse resolver event.\\n\");\n                goto fail;\n            }\n            \n            avahi_client_set_errno(r->client, avahi_error_dbus_to_number(etxt));\n            r->callback(r, r->interface, r->protocol, event, &r->address, NULL, 0, r->userdata);\n            break;\n        }\n    }\n\n    return DBUS_HANDLER_RESULT_HANDLED;\n    \nfail:\n    dbus_error_free (&error);\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}", "path": "avahi-client\\resolver.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* Read the first label from string *name, unescape \"\\\" and write it to dest */\n", "func_signal": "char *avahi_unescape_label(const char **name, char *dest, size_t size)", "code": "{\n    unsigned i = 0;\n    char *d;\n    \n    assert(dest);\n    assert(size > 0);\n    assert(name);\n\n    d = dest;\n    \n    for (;;) {\n        if (i >= size)\n            return NULL;\n\n        if (**name == '.') {\n            (*name)++;\n            break;\n        }\n        \n        if (**name == 0)\n            break;\n        \n        if (**name == '\\\\') {\n            /* Escaped character */\n\n            (*name) ++;\n\n            if (**name == 0)\n                /* Ending NUL */\n                return NULL;\n            \n            else if (**name == '\\\\' || **name == '.') {\n                /* Escaped backslash or dot */\n                *(d++) = *((*name) ++);\n                i++;\n            } else if (isdigit(**name)) {\n                int n;\n\n                /* Escaped literal ASCII character */\n                \n                if (!isdigit(*(*name+1)) || !isdigit(*(*name+2)))\n                    return NULL;\n\n                n = ((uint8_t) (**name - '0') * 100) + ((uint8_t) (*(*name+1) - '0') * 10) + ((uint8_t) (*(*name +2) - '0'));\n\n                if (n > 255 || n == 0)\n                    return NULL;\n                \n                *(d++) = (char) n;\n                i++;\n\n                (*name) += 3;\n            } else\n                return NULL;\n            \n        } else {\n\n            /* Normal character */\n            \n            *(d++) = *((*name) ++);\n            i++;\n        }\n    }\n\n    assert(i < size);\n\n    *d = 0;\n\n    if (!avahi_utf8_valid(dest))\n        return NULL;\n\n    return dest;\n}", "path": "avahi-common\\domain.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/** Add a host/address pair */\n", "func_signal": "int avahi_entry_group_add_address(\n    AvahiEntryGroup *group,\n    AvahiIfIndex interface,\n    AvahiProtocol protocol,\n    AvahiPublishFlags flags,\n    const char *name,\n    const AvahiAddress *a)", "code": "{\n\n    DBusMessage *message = NULL, *reply = NULL;\n    int r = AVAHI_OK;\n    DBusError error;\n    AvahiClient *client;\n    int32_t i_interface, i_protocol;\n    uint32_t u_flags;\n    char s_address[AVAHI_ADDRESS_STR_MAX];\n    char *p_address = s_address;\n\n    assert(name);\n\n    client = group->client;\n\n    if (!group->path || !avahi_client_is_connected(group->client))\n        return avahi_client_set_errno(group->client, AVAHI_ERR_BAD_STATE);\n\n    dbus_error_init(&error);\n    \n    if (!(message = dbus_message_new_method_call (AVAHI_DBUS_NAME, group->path, AVAHI_DBUS_INTERFACE_ENTRY_GROUP, \"AddAddress\"))) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_NO_MEMORY);\n        goto fail;\n    }\n\n    i_interface = (int32_t) interface;\n    i_protocol = (int32_t) protocol;\n    u_flags = (uint32_t) flags;\n        \n    if (!avahi_address_snprint (s_address, sizeof (s_address), a))\n    {\n        r = avahi_client_set_errno(client, AVAHI_ERR_INVALID_ADDRESS);\n        goto fail;\n    }\n\n    if (!dbus_message_append_args(\n            message,\n            DBUS_TYPE_INT32, &i_interface,\n            DBUS_TYPE_INT32, &i_protocol,\n            DBUS_TYPE_UINT32, &u_flags,\n            DBUS_TYPE_STRING, &name,\n            DBUS_TYPE_STRING, &p_address,\n            DBUS_TYPE_INVALID)) {\n        r = avahi_client_set_errno(group->client, AVAHI_ERR_NO_MEMORY);\n        goto fail;\n    }\n    \n    if (!(reply = dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error)) ||\n        dbus_error_is_set (&error)) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_DBUS_ERROR);\n        goto fail;\n    }\n    \n    if (!dbus_message_get_args(reply, &error, DBUS_TYPE_INVALID) ||\n        dbus_error_is_set (&error)) {\n        r = avahi_client_set_errno(client, AVAHI_ERR_DBUS_ERROR);\n        goto fail;\n    }\n\n    dbus_message_unref(message);\n    dbus_message_unref(reply);\n\n    return AVAHI_OK;\n\nfail:\n    \n    if (dbus_error_is_set(&error)) {\n        r = avahi_client_set_dbus_error(client, &error);\n        dbus_error_free(&error);\n    }\n\n    if (message)\n        dbus_message_unref(message);\n\n    if (reply)\n        dbus_message_unref(reply);\n\n    return r;\n}", "path": "avahi-client\\entrygroup.c", "repo_name": "sunilghai/avahi-llmnr", "stars": 3, "license": "lgpl-2.1", "language": "c", "size": 1288}
{"docstring": "/* shove5551() */\n", "func_signal": "static void scaleInternalPackedPixel(int components,\n                                     void (*extractPackedPixel)\n                                     (int, const void*,GLfloat []),\n                                     void (*shovePackedPixel)\n                                     (const GLfloat [], int, void*),\n                                     GLint widthIn,GLint heightIn,\n                                     const void* dataIn,\n                                     GLint widthOut,GLint heightOut,\n                                     void* dataOut,\n                                     GLint pixelSizeInBytes,\n                                     GLint rowSizeInBytes, GLint isSwap)", "code": "{\n   float convx;\n   float convy;\n   float percent;\n\n   /* Max components in a format is 4, so... */\n   float totals[4];\n   float extractTotals[4], extractMoreTotals[4], shoveTotals[4];\n\n   float area;\n   int i,j,k,xindex;\n\n   const char *temp, *temp0;\n   int outindex;\n\n   int lowx_int, highx_int, lowy_int, highy_int;\n   float x_percent, y_percent;\n   float lowx_float, highx_float, lowy_float, highy_float;\n   float convy_float, convx_float;\n   int convy_int, convx_int;\n   int l, m;\n   const char* left;\n   const char* right;\n\n   if (widthIn==widthOut*2 && heightIn==heightOut*2)\n   {\n      halveImagePackedPixel(components,extractPackedPixel,shovePackedPixel,\n                            widthIn, heightIn, dataIn, dataOut,\n                            pixelSizeInBytes,rowSizeInBytes,isSwap);\n      return;\n   }\n   convy=(float)heightIn/heightOut;\n   convx=(float)widthIn/widthOut;\n   convy_int=floor(convy);\n   convy_float=convy-convy_int;\n   convx_int=floor(convx);\n   convx_float=convx-convx_int;\n\n   area=convx*convy;\n\n   lowy_int=0;\n   lowy_float=0;\n   highy_int=convy_int;\n   highy_float=convy_float;\n\n   for (i=0; i<heightOut; i++)\n   {\n      lowx_int=0;\n      lowx_float=0;\n      highx_int=convx_int;\n      highx_float=convx_float;\n\n      for (j=0; j<widthOut; j++)\n      {\n         /*\n         ** Ok, now apply box filter to box that goes from (lowx, lowy)\n         ** to (highx, highy) on input data into this pixel on output\n         ** data.\n         */\n         totals[0]=totals[1]=totals[2]=totals[3]=0.0;\n\n         /* calculate the value for pixels in the 1st row */\n         xindex=lowx_int*pixelSizeInBytes;\n         if ((highy_int>lowy_int) && (highx_int>lowx_int))\n         {\n            y_percent=1-lowy_float;\n            temp=(const char*)dataIn+xindex+lowy_int*rowSizeInBytes;\n            percent=y_percent*(1-lowx_float);\n            (*extractPackedPixel)(isSwap, temp, extractTotals);\n            for (k=0; k<components; k++)\n            {\n               totals[k]+=extractTotals[k]*percent;\n            }\n            left=temp;\n            for (l=lowx_int+1; l<highx_int; l++)\n            {\n               temp+=pixelSizeInBytes;\n               (*extractPackedPixel)(isSwap, temp, extractTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=extractTotals[k]*y_percent;\n               }\n            }\n            temp+=pixelSizeInBytes;\n            right=temp;\n            percent=y_percent*highx_float;\n            (*extractPackedPixel)(isSwap, temp, extractTotals);\n            for (k=0; k<components; k++)\n            {\n               totals[k]+=extractTotals[k]*percent;\n            }\n\n            /* calculate the value for pixels in the last row */\n            y_percent=highy_float;\n            percent=y_percent*(1-lowx_float);\n            temp=(const char*)dataIn+xindex+highy_int*rowSizeInBytes;\n            (*extractPackedPixel)(isSwap, temp, extractTotals);\n            for (k=0; k<components; k++)\n            {\n               totals[k]+=extractTotals[k]*percent;\n            }\n            for (l=lowx_int+1; l<highx_int; l++)\n            {\n               temp+=pixelSizeInBytes;\n               (*extractPackedPixel)(isSwap, temp, extractTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=extractTotals[k]*y_percent;\n               }\n            }\n            temp+=pixelSizeInBytes;\n            percent=y_percent*highx_float;\n            (*extractPackedPixel)(isSwap, temp, extractTotals);\n            for (k=0; k<components; k++)\n            {\n               totals[k]+=extractTotals[k]*percent;\n            }\n\n            /* calculate the value for pixels in the 1st and last column */\n            for (m=lowy_int+1; m<highy_int; m++)\n            {\n               left+=rowSizeInBytes;\n               right+=rowSizeInBytes;\n               (*extractPackedPixel)(isSwap, left, extractTotals);\n               (*extractPackedPixel)(isSwap, right, extractMoreTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=(extractTotals[k]*(1-lowx_float)+extractMoreTotals[k]*highx_float);\n               }\n            }\n         }\n         else\n         {\n            if (highy_int>lowy_int)\n            {\n               x_percent=highx_float-lowx_float;\n               percent=(1-lowy_float)*x_percent;\n               temp=(const char*)dataIn+xindex+lowy_int*rowSizeInBytes;\n               (*extractPackedPixel)(isSwap, temp, extractTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=extractTotals[k]*percent;\n               }\n               for (m=lowy_int+1; m<highy_int; m++)\n               {\n                  temp+=rowSizeInBytes;\n                  (*extractPackedPixel)(isSwap, temp, extractTotals);\n                  for (k=0; k<components; k++)\n                  {\n                     totals[k]+=extractTotals[k]*x_percent;\n                  }\n               }\n               percent=x_percent*highy_float;\n               temp+=rowSizeInBytes;\n               (*extractPackedPixel)(isSwap, temp, extractTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=extractTotals[k]*percent;\n               }\n            }\n            else\n            {\n               if (highx_int > lowx_int)\n               {\n                  y_percent=highy_float-lowy_float;\n                  percent=(1-lowx_float)*y_percent;\n                  temp=(const char*)dataIn+xindex+lowy_int*rowSizeInBytes;\n                  (*extractPackedPixel)(isSwap, temp, extractTotals);\n                  for (k=0; k<components; k++)\n                  {\n                     totals[k]+= extractTotals[k] * percent;\n                  }\n                  for (l=lowx_int+1; l<highx_int; l++)\n                  {\n                     temp+=pixelSizeInBytes;\n                     (*extractPackedPixel)(isSwap, temp, extractTotals);\n                     for (k=0; k<components; k++)\n                     {\n                        totals[k]+=extractTotals[k]*y_percent;\n                     }\n                  }\n                  temp+=pixelSizeInBytes;\n                  percent=y_percent*highx_float;\n                  (*extractPackedPixel)(isSwap, temp, extractTotals);\n                  for (k=0; k<components; k++)\n                  {\n                     totals[k]+=extractTotals[k]*percent;\n                  }\n               }\n               else\n               {\n                  percent=(highy_float-lowy_float)*(highx_float-lowx_float);\n                  temp=(const char*)dataIn+xindex+lowy_int*rowSizeInBytes;\n                  (*extractPackedPixel)(isSwap, temp, extractTotals);\n                  for (k=0; k<components; k++)\n                  {\n                     totals[k]+=extractTotals[k]*percent;\n                  }\n               }\n            }\n         }\n\n         /* this is for the pixels in the body */\n         temp0=(const char*)dataIn+xindex+pixelSizeInBytes+(lowy_int+1)*rowSizeInBytes;\n         for (m=lowy_int+1; m<highy_int; m++)\n         {\n            temp=temp0;\n            for (l=lowx_int+1; l<highx_int; l++)\n            {\n               (*extractPackedPixel)(isSwap, temp, extractTotals);\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=extractTotals[k];\n               }\n               temp+=pixelSizeInBytes;\n            }\n            temp0 += rowSizeInBytes;\n         }\n\n         outindex=(j+(i*widthOut));\n         for (k=0; k<components; k++)\n         {\n            shoveTotals[k]=totals[k]/area;\n         }\n         (*shovePackedPixel)(shoveTotals, outindex, (void*)dataOut);\n         lowx_int=highx_int;\n         lowx_float=highx_float;\n         highx_int+=convx_int;\n         highx_float+=convx_float;\n         if (highx_float>1)\n         {\n            highx_float-=1.0;\n            highx_int++;\n         }\n      }\n      lowy_int=highy_int;\n      lowy_float=highy_float;\n      highy_int+=convy_int;\n      highy_float+=convy_float;\n\n      if (highy_float>1)\n      {\n         highy_float-=1.0;\n         highy_int++;\n      }\n   }\n\n   assert(outindex==(widthOut*heightOut-1));\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* Determines if the packed pixel type is compatible with the format */\n", "func_signal": "static GLboolean isLegalFormatForPackedPixelType(GLenum format, GLenum type)", "code": "{\n   /* if not a packed pixel type then return true */\n   if (!isTypePackedPixel(type))\n   {\n      return GL_TRUE;\n   }\n\n   /* 5_6_5 is only compatible with RGB */\n   if ((type==GL_UNSIGNED_SHORT_5_6_5) && format!=GL_RGB)\n   {\n      return GL_FALSE;\n   }\n\n   /* 4_4_4_4 & 5_5_5_1\n    * are only compatible with RGBA\n    */\n   if ((type==GL_UNSIGNED_SHORT_4_4_4_4 || type==GL_UNSIGNED_SHORT_5_5_5_1) &&\n       (format != GL_RGBA))\n   {\n      return GL_FALSE;\n   }\n\n   return GL_TRUE;\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* closestFit() */\n", "func_signal": "GLAPI GLint APIENTRY \ngluScaleImage(GLenum format, GLsizei widthin, GLsizei heightin,\n              GLenum typein, const void* datain, GLsizei widthout,\n              GLsizei heightout, GLenum typeout, void* dataout)", "code": "{\n   int components;\n   GLushort* beforeImage=NULL;\n   GLushort* afterImage=NULL;\n   PixelStorageModes psm;\n\n   if (widthin==0 || heightin==0 || widthout==0 || heightout==0)\n   {\n      return 0;\n   }\n\n   if (widthin<0 || heightin<0 || widthout<0 || heightout<0)\n   {\n      return GLU_INVALID_VALUE;\n   }\n\n   if (!legalFormat(format) || !legalType(typein) || !legalType(typeout))\n   {\n      return GLU_INVALID_ENUM;\n   }\n   if (!isLegalFormatForPackedPixelType(format, typein))\n   {\n      return GLU_INVALID_OPERATION;\n   }\n   if (!isLegalFormatForPackedPixelType(format, typeout))\n   {\n      return GLU_INVALID_OPERATION;\n   }\n   beforeImage=malloc(image_size(widthin, heightin, format, GL_UNSIGNED_SHORT));\n   afterImage=malloc(image_size(widthout, heightout, format, GL_UNSIGNED_SHORT));\n   if (beforeImage==NULL || afterImage==NULL)\n   {\n      if (beforeImage!=NULL)\n      {\n         free(beforeImage);\n      }\n      if (afterImage!=NULL)\n      {\n         free(afterImage);\n      }\n      return GLU_OUT_OF_MEMORY;\n   }\n\n   retrieveStoreModes(&psm);\n   fill_image(&psm,widthin, heightin, format, typein, 0, datain, beforeImage);\n   components=elements_per_group(format, 0);\n   scale_internal(components, widthin, heightin, beforeImage, widthout, heightout, afterImage);\n   empty_image(&psm, widthout, heightout, format, typeout, 0, afterImage, dataout);\n   free((GLbyte*)beforeImage);\n   free((GLbyte*)afterImage);\n\n   return 0;\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*\n** Compute memory required for internal packed array of data of given type\n** and format.\n*/\n", "func_signal": "static GLint image_size(GLint width, GLint height, GLenum format, GLenum type)", "code": "{\n   int bytes_per_row;\n   int components;\n\n   assert(width>0);\n   assert(height>0);\n   components=elements_per_group(format, type);\n\n   bytes_per_row=bytes_per_element(type)*width;\n\n   return bytes_per_row*height*components;\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* shove4444() */\n", "func_signal": "static void extract5551(int isSwap,const void* packedPixel, GLfloat extractComponents[])", "code": "{\n   GLushort ushort;\n\n   if (isSwap)\n   {\n      ushort=__GLU_SWAP_2_BYTES(packedPixel);\n   }\n   else\n   {\n      ushort=*(const GLushort*)packedPixel;\n   }\n\n   /* 11111000,00000000 == 0xf800 */\n   /* 00000111,11000000 == 0x07c0 */\n   /* 00000000,00111110 == 0x003e */\n   /* 00000000,00000001 == 0x0001 */\n\n   extractComponents[0]=(float)((ushort&0xf800)>>11)/31.0;/* 31 = 2^5-1*/\n   extractComponents[1]=(float)((ushort&0x07c0)>>6)/31.0;\n   extractComponents[2]=(float)((ushort&0x003e)>>1)/31.0;\n   extractComponents[3]=(float)((ushort&0x0001));\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*--------------------------------------------------------------------------\n * Decimation of packed pixel types\n *--------------------------------------------------------------------------\n */\n", "func_signal": "static void extract565(int isSwap, const void* packedPixel, GLfloat extractComponents[])", "code": "{\n   GLushort ushort=*(const GLushort*)packedPixel;\n\n   if (isSwap)\n   {\n      ushort=__GLU_SWAP_2_BYTES(packedPixel);\n   }\n   else\n   {\n      ushort=*(const GLushort*)packedPixel;\n   }\n\n   /* 11111000,00000000 == 0xf800 */\n   /* 00000111,11100000 == 0x07e0 */\n   /* 00000000,00011111 == 0x001f */\n\n   extractComponents[0]=(float)((ushort&0xf800)>>11)/31.0; /* 31 = 2^5-1*/\n   extractComponents[1]=(float)((ushort&0x07e0)>>5)/63.0;  /* 63 = 2^6-1*/\n   extractComponents[2]=(float)((ushort&0x001f))/31.0;\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*\n** Insert array into user's data applying all pixel store modes.\n** The internal format is an array of unsigned shorts.\n** empty_image() because it is the opposite of fill_image().\n*/\n", "func_signal": "static void empty_image(const PixelStorageModes* psm, GLint width,\n                        GLint height, GLenum format, GLenum type,\n                        GLboolean index_format, const GLushort* oldimage,\n                        void* userdata)", "code": "{\n   GLint components;\n   GLint element_size;\n   GLint rowsize;\n   GLint padding;\n   GLint groups_per_line;\n   GLint group_size;\n   GLint elements_per_line;\n   GLubyte* start;\n   GLubyte* iter;\n   const GLushort* iter2;\n   GLint i, j, k;\n   GLint myswap_bytes;\n\n   myswap_bytes=psm->pack_swap_bytes;\n   components=elements_per_group(format, type);\n   if (psm->pack_row_length>0)\n   {\n      groups_per_line = psm->pack_row_length;\n   }\n   else\n   {\n      groups_per_line = width;\n   }\n\n   {\n      float shoveComponents[4];\n\n      element_size=bytes_per_element(type);\n      group_size=element_size*components;\n      if (element_size==1)\n      {\n         myswap_bytes = 0;\n      }\n\n      rowsize=groups_per_line*group_size;\n      padding=(rowsize%psm->pack_alignment);\n      if (padding)\n      {\n         rowsize+=psm->pack_alignment-padding;\n      }\n      start=(GLubyte*) userdata+psm->pack_skip_rows*rowsize+psm->pack_skip_pixels*group_size;\n      elements_per_line=width*components;\n\n      iter2=oldimage;\n      for (i=0; i<height; i++)\n      {\n         iter=start;\n         for (j=0; j<elements_per_line; j++)\n         {\n            Type_Widget widget;\n\n            switch(type)\n            {\n               case GL_UNSIGNED_BYTE:\n                    *iter=*iter2++>>8;\n                    break;\n               case GL_UNSIGNED_SHORT_5_6_5:\n                    for (k=0; k<3; k++)\n                    {\n                       shoveComponents[k]=*iter2++/65535.0;\n                    }\n                    shove565(shoveComponents, 0, (void*)&widget.us[0]);\n                    if (myswap_bytes)\n                    {\n                       iter[0]=widget.ub[1];\n                       iter[1]=widget.ub[0];\n                    }\n                    else\n                    {\n                       *(GLushort*)iter=widget.us[0];\n                    }\n                    break;\n               case GL_UNSIGNED_SHORT_4_4_4_4:\n                    for (k=0; k<4; k++)\n                    {\n                       shoveComponents[k]=*iter2++/65535.0;\n                    }\n                    shove4444(shoveComponents,0,(void *)&widget.us[0]);\n                    if (myswap_bytes)\n                    {\n                       iter[0]=widget.ub[1];\n                       iter[1]=widget.ub[0];\n                    }\n                    else\n                    {\n                       *(GLushort *)iter = widget.us[0];\n                    }\n                    break;\n               case GL_UNSIGNED_SHORT_5_5_5_1:\n                    for (k=0; k<4; k++)\n                    {\n                       shoveComponents[k]=*iter2++/65535.0;\n                    }\n                    shove5551(shoveComponents,0,(void *)&widget.us[0]);\n                    if (myswap_bytes)\n                    {\n                       iter[0]=widget.ub[1];\n                       iter[1]=widget.ub[0];\n                    }\n                    else\n                    {\n                       *(GLushort*)iter=widget.us[0];\n                    }\n                    break;\n            }\n            iter+=element_size;\n         } /* for j */\n         start+=rowsize;\n#if 1\n         /* want 'iter' pointing at start, not within, row for assertion\n          * purposes\n          */\n         iter=start;\n#endif\n      } /* for i */\n\n      /* iterators should be one byte past end */\n      if (!isTypePackedPixel(type))\n      {\n         assert(iter2==&oldimage[width*height*components]);\n      }\n      else\n      {\n         assert(iter2==&oldimage[width*height*elements_per_group(format, 0)]);\n      }\n      assert(iter==&((GLubyte *)userdata)[rowsize*height+psm->pack_skip_rows*rowsize+\n                   psm->pack_skip_pixels*group_size]);\n\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* */\n", "func_signal": "static GLboolean isTypePackedPixel(GLenum type)", "code": "{\n   assert(legalType(type));\n\n   if (type==GL_UNSIGNED_SHORT_5_6_5 ||\n       type==GL_UNSIGNED_SHORT_4_4_4_4 ||\n       type==GL_UNSIGNED_SHORT_5_5_5_1)\n   {\n      return 1;\n   }\n   else\n   {\n      return 0;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* halve1Dimage_ubyte() */\n", "func_signal": "static void scale_internal(GLint components, GLint widthin, GLint heightin,\n                           const GLushort* datain,\n                           GLint widthout, GLint heightout,\n                           GLushort* dataout)", "code": "{\n   float x, lowx, highx, convx, halfconvx;\n   float y, lowy, highy, convy, halfconvy;\n   float xpercent,ypercent;\n   float percent;\n\n   /* Max components in a format is 4, so... */\n   float totals[4];\n   float area;\n   int i,j,k,yint,xint,xindex,yindex;\n   int temp;\n\n   if (widthin==widthout*2 && heightin==heightout*2)\n   {\n      halveImage(components, widthin, heightin, datain, dataout);\n      return;\n   }\n\n   convy=(float)heightin/heightout;\n   convx=(float)widthin/widthout;\n   halfconvx=convx/2;\n   halfconvy=convy/2;\n   for (i=0; i<heightout; i++)\n   {\n      y=convy*(i+0.5);\n      if (heightin>heightout)\n      {\n         highy=y+halfconvy;\n         lowy=y-halfconvy;\n      }\n      else\n      {\n         highy=y+0.5;\n         lowy=y-0.5;\n      }\n      for (j=0; j<widthout; j++)\n      {\n         x=convx*(j+0.5);\n         if (widthin>widthout)\n         {\n            highx=x+halfconvx;\n            lowx=x-halfconvx;\n         }\n         else\n         {\n            highx=x+0.5;\n            lowx=x-0.5;\n         }\n         /*\n         ** Ok, now apply box filter to box that goes from (lowx, lowy)\n         ** to (highx, highy) on input data into this pixel on output\n         ** data.\n         */\n         totals[0] = totals[1] = totals[2] = totals[3] = 0.0;\n         area = 0.0;\n\n         y=lowy;\n         yint=floor(y);\n         while (y<highy)\n         {\n            yindex=(yint+heightin) % heightin;\n            if (highy<yint+1)\n            {\n               ypercent=highy-y;\n            }\n            else\n            {\n               ypercent=yint+1-y;\n            }\n\n            x=lowx;\n            xint=floor(x);\n\n            while (x<highx)\n            {\n               xindex=(xint+widthin) % widthin;\n               if (highx<xint+1)\n               {\n                  xpercent=highx-x;\n               }\n               else\n               {\n                  xpercent=xint+1-x;\n               }\n\n               percent=xpercent*ypercent;\n               area+=percent;\n               temp=(xindex+(yindex*widthin))*components;\n               for (k=0; k<components; k++)\n               {\n                  totals[k]+=datain[temp+k]*percent;\n               }\n\n               xint++;\n               x=xint;\n            }\n            yint++;\n            y=yint;\n         }\n\n         temp=(j+(i*widthout))*components;\n         for (k=0; k<components; k++)\n         {\n            /* totals[] should be rounded in the case of enlarging an RGB\n             * ramp when the type is 4444\n             */\n            dataout[temp+k]=(totals[k]+0.5)/area;\n         }\n      }\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* isLegalFormatForPackedPixelType() */\n", "func_signal": "static GLboolean isLegalLevels(GLint userLevel,GLint baseLevel,GLint maxLevel,\n                               GLint totalLevels)", "code": "{\n   if (baseLevel < 0 || baseLevel < userLevel || maxLevel < baseLevel ||\n       totalLevels < maxLevel)\n   {\n      return GL_FALSE;\n   }\n   else\n   {\n      return GL_TRUE;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* extract4444() */\n", "func_signal": "static void shove4444(const GLfloat shoveComponents[], int index,void* packedPixel)", "code": "{\n   assert(0.0<=shoveComponents[0] && shoveComponents[0]<=1.0);\n   assert(0.0<=shoveComponents[1] && shoveComponents[1]<=1.0);\n   assert(0.0<=shoveComponents[2] && shoveComponents[2]<=1.0);\n   assert(0.0<=shoveComponents[3] && shoveComponents[3]<=1.0);\n\n   /* due to limited precision, need to round before shoving */\n   ((GLushort*)packedPixel)[index]=((GLushort)((shoveComponents[0]*15)+0.5)<<12)&0xf000;\n   ((GLushort*)packedPixel)[index]|=((GLushort)((shoveComponents[1]*15)+0.5)<<8)&0x0f00;\n   ((GLushort*)packedPixel)[index]|=((GLushort)((shoveComponents[2]*15)+0.5)<<4)&0x00f0;\n   ((GLushort*)packedPixel)[index]|=((GLushort)((shoveComponents[3]*15)+0.5))&0x000f;\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* gluBuild2DMipmapLevels() */\n", "func_signal": "GLAPI GLint APIENTRY\ngluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width,\n                  GLsizei height, GLenum format, GLenum type, const void* data)", "code": "{\n   GLint widthPowerOf2, heightPowerOf2;\n   int level, levels;\n\n   int rc=checkMipmapArgs(internalFormat,format,type);\n   if (rc!=0)\n   {\n      return rc;\n   }\n\n   if (width<1 || height<1)\n   {\n      return GLU_INVALID_VALUE;\n   }\n\n   closestFit(target, width, height, internalFormat, format, type,\n              &widthPowerOf2,&heightPowerOf2);\n\n   levels=computeLog(widthPowerOf2);\n   level=computeLog(heightPowerOf2);\n   if (level>levels)\n   {\n      levels=level;\n   }\n\n   return gluBuild2DMipmapLevelsCore(target,internalFormat, width, height,\n                                     widthPowerOf2, heightPowerOf2, format,\n                                     type, 0, 0, levels, data);\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*\n** Compute the nearest power of 2 number.  This algorithm is a little\n** strange, but it works quite well.\n*/\n", "func_signal": "static int nearestPower(GLuint value)", "code": "{\n   int i=1;\n\n   /* Error! */\n   if (value==0)\n   {\n      return -1;\n   }\n\n   for (;;)\n   {\n      if (value==1)\n      {\n         return i;\n      }\n      else\n      {\n         if (value==3)\n         {\n            return i*4;\n         }\n      }\n      value=value>>1;\n      i*=2;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* Given user requested texture size, determine if it fits. If it\n * doesn't then halve both sides and make the determination again\n * until it does fit (for IR only).\n */\n", "func_signal": "static void closestFit(GLenum target, GLint width, GLint height,\n                       GLint internalFormat, GLenum format, GLenum type,\n                       GLint *newWidth, GLint *newHeight)", "code": "{\n   GLint maxsize;\n\n   glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);\n\n   /* clamp user's texture sizes to maximum sizes, if necessary */\n   *newWidth=nearestPower(width);\n   if (*newWidth>maxsize)\n   {\n      *newWidth=maxsize;\n   }\n   *newHeight=nearestPower(height);\n   if (*newHeight>maxsize)\n   {\n      *newHeight = maxsize;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* gluBuild2DMipmapLevelsCore() */\n", "func_signal": "GLAPI GLint APIENTRY\ngluBuild2DMipmapLevels(GLenum target, GLint internalFormat,\n                       GLsizei width, GLsizei height, GLenum format,\n                       GLenum type, GLint userLevel, GLint baseLevel,\n                       GLint maxLevel, const void* data)", "code": "{\n   int level, levels;\n\n   int rc=checkMipmapArgs(internalFormat,format,type);\n\n   if (rc!=0)\n   {\n      return rc;\n   }\n\n   if (width<1 || height<1)\n   {\n      return GLU_INVALID_VALUE;\n   }\n\n   levels=computeLog(width);\n   level=computeLog(height);\n   if (level>levels)\n   {\n      levels=level;\n   }\n\n   levels+=userLevel;\n   if (!isLegalLevels(userLevel, baseLevel, maxLevel, levels))\n   {\n      return GLU_INVALID_VALUE;\n   }\n\n   return gluBuild2DMipmapLevelsCore(target, internalFormat, width, height,\n                                     width, height, format, type,\n                                     userLevel, baseLevel, maxLevel, data);\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*\n** Extract array from user's data applying all pixel store modes.\n** The internal format used is an array of unsigned shorts.\n*/\n", "func_signal": "static void fill_image(const PixelStorageModes* psm,\n                       GLint width, GLint height, GLenum format,\n                       GLenum type, GLboolean index_format,\n                       const void* userdata, GLushort* newimage)", "code": "{\n   GLint components;\n   GLint element_size;\n   GLint rowsize;\n   GLint padding;\n   GLint groups_per_line;\n   GLint group_size;\n   GLint elements_per_line;\n   const GLubyte* start;\n   const GLubyte* iter;\n   GLushort* iter2;\n   GLint i, j, k;\n   GLint myswap_bytes;\n\n   myswap_bytes=psm->unpack_swap_bytes;\n   components=elements_per_group(format,type);\n   if (psm->unpack_row_length>0)\n   {\n      groups_per_line = psm->unpack_row_length;\n   }\n   else\n   {\n      groups_per_line = width;\n   }\n\n   {\n      element_size=bytes_per_element(type);\n      group_size=element_size*components;\n      if (element_size==1)\n      {\n         myswap_bytes=0;\n      }\n\n      rowsize=groups_per_line*group_size;\n      padding=(rowsize%psm->unpack_alignment);\n      if (padding)\n      {\n         rowsize+=psm->unpack_alignment-padding;\n      }\n      start=(const GLubyte*)userdata+psm->unpack_skip_rows*rowsize+\n                            psm->unpack_skip_pixels*group_size;\n      elements_per_line=width*components;\n\n      iter2=newimage;\n      for (i=0; i<height; i++)\n      {\n         iter=start;\n         for (j=0; j<elements_per_line; j++)\n         {\n            float extractComponents[4];\n\n            switch (type)\n            {\n               case GL_UNSIGNED_BYTE:\n                    *iter2++=(*iter)*257;\n                    break;\n               case GL_UNSIGNED_SHORT_5_6_5:\n                    extract565(myswap_bytes, iter, extractComponents);\n                    for (k=0; k<3; k++)\n                    {\n                       *iter2++=(GLushort)(extractComponents[k]*65535);\n                    }\n                    break;\n               case GL_UNSIGNED_SHORT_4_4_4_4:\n                    extract4444(myswap_bytes, iter, extractComponents);\n                    for (k=0; k<4; k++)\n                    {\n                       *iter2++=(GLushort)(extractComponents[k]*65535);\n                    }\n                    break;\n               case GL_UNSIGNED_SHORT_5_5_5_1:\n                    extract5551(myswap_bytes, iter, extractComponents);\n                    for (k = 0; k < 4; k++)\n                    {\n                       *iter2++=(GLushort)(extractComponents[k]*65535);\n                    }\n                    break;\n            }\n            iter+=element_size;\n         } /* for j */\n         start+=rowsize;\n#if 1\n         /* want 'iter' pointing at start, not within, row for assertion\n          * purposes\n          */\n         iter= start;\n#endif\n      } /* for i */\n\n      /* iterators should be one byte past end */\n      if (!isTypePackedPixel(type))\n      {\n         assert(iter2==&newimage[width*height*components]);\n      }\n      else\n      {\n         assert(iter2==&newimage[width*height*elements_per_group(format, 0)]);\n      }\n      assert(iter==&((const GLubyte*)userdata)[rowsize*height+\n             psm->unpack_skip_rows*rowsize+psm->unpack_skip_pixels*group_size]);\n\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* rowSizeInBytes is at least the width (in bytes) due to padding on\n *  inputs; not always equal. Output NEVER has row padding.\n */\n", "func_signal": "static void halveImagePackedPixel(int components,\n                                  void (*extractPackedPixel)\n                                  (int, const void*,GLfloat []),\n                                  void (*shovePackedPixel)\n                                  (const GLfloat [],int, void*),\n                                  GLint width, GLint height,\n                                  const void* dataIn, void* dataOut,\n                                  GLint pixelSizeInBytes,\n                                  GLint rowSizeInBytes, GLint isSwap)", "code": "{\n   /* handle case where there is only 1 column/row */\n   if (width==1 || height==1)\n   {\n      assert(!(width==1 && height==1)); /* can't be 1x1 */\n      halve1DimagePackedPixel(components,extractPackedPixel,shovePackedPixel,\n                              width,height,dataIn,dataOut,pixelSizeInBytes,\n                              rowSizeInBytes,isSwap);\n      return;\n   }\n\n   {\n      int ii, jj;\n\n      int halfWidth=width/2;\n      int halfHeight=height/2;\n      const char* src=(const char*)dataIn;\n      int padBytes=rowSizeInBytes-(width*pixelSizeInBytes);\n      int outIndex=0;\n\n      for (ii=0; ii<halfHeight; ii++)\n      {\n         for (jj=0; jj<halfWidth; jj++)\n         {\n#define BOX4 4\n            float totals[4];              /* 4 is maximum components */\n            float extractTotals[BOX4][4]; /* 4 is maximum components */\n            int cc;\n\n            (*extractPackedPixel)(isSwap, src, &extractTotals[0][0]);\n            (*extractPackedPixel)(isSwap, (src+pixelSizeInBytes), &extractTotals[1][0]);\n            (*extractPackedPixel)(isSwap, (src+rowSizeInBytes), &extractTotals[2][0]);\n            (*extractPackedPixel)(isSwap, (src+rowSizeInBytes+pixelSizeInBytes), &extractTotals[3][0]);\n            for (cc=0; cc<components; cc++)\n            {\n               int kk;\n\n               /* grab 4 pixels to average */\n               totals[cc]=0.0;\n               for (kk=0; kk<BOX4; kk++)\n               {\n                  totals[cc]+=extractTotals[kk][cc];\n               }\n               totals[cc]/=(float)BOX4;\n            }\n            (*shovePackedPixel)(totals, outIndex, dataOut);\n\n            outIndex++;\n            /* skip over to next square of 4 */\n            src+=pixelSizeInBytes+pixelSizeInBytes;\n         }\n         /* skip past pad bytes, if any, to get to next row */\n         src+=padBytes;\n\n         /* src is at beginning of a row here, but it's the second row of\n          * the square block of 4 pixels that we just worked on so we\n          * need to go one more row.\n          * i.e.,\n          *                   OO...\n          *           here -->OO...\n          *       but want -->OO...\n          *                   OO...\n          *                   ...\n          */\n         src+=rowSizeInBytes;\n      }\n\n      /* both pointers must reach one byte after the end */\n      assert(src==&((const char*)dataIn)[rowSizeInBytes*height]);\n      assert(outIndex==halfWidth*halfHeight);\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/*\n * Utility Routines\n */\n", "func_signal": "static GLint elements_per_group(GLenum format, GLenum type)", "code": "{\n   /*\n    * Return the number of elements per group of a specified format\n    */\n\n   /* If the type is packedpixels then answer is 1 (ignore format) */\n   if (type==GL_UNSIGNED_SHORT_5_6_5 ||\n       type==GL_UNSIGNED_SHORT_4_4_4_4 ||\n       type==GL_UNSIGNED_SHORT_5_5_5_1)\n   {\n      return 1;\n   }\n\n   /* Types are not packed pixels, so get elements per group */\n   switch(format)\n   {\n      case GL_RGB:\n           return 3;\n      case GL_LUMINANCE_ALPHA:\n           return 2;\n      case GL_RGBA:\n           return 4;\n      default:\n           return 1;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* checkMipmapArgs() */\n", "func_signal": "static GLboolean legalFormat(GLenum format)", "code": "{\n   switch(format)\n   {\n      case GL_ALPHA:\n      case GL_RGB:\n      case GL_RGBA:\n      case GL_LUMINANCE:\n      case GL_LUMINANCE_ALPHA:\n           return GL_TRUE;\n      default:\n           return GL_FALSE;\n   }\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
{"docstring": "/* */\n", "func_signal": "static void halve1Dimage_ubyte(GLint components, GLuint width, GLuint height,\n                               const GLubyte* dataIn, GLubyte* dataOut,\n                               GLint element_size, GLint ysize,\n                               GLint group_size)", "code": "{\n   GLint halfWidth=width/2;\n   GLint halfHeight=height/2;\n   const char* src=(const char*)dataIn;\n   GLubyte* dest=dataOut;\n   int jj;\n\n   assert(width==1 || height==1); /* must be 1D */\n   assert(width!=height);         /* can't be square */\n\n   if (height==1)\n   {                              /* 1 row */\n      assert(width!=1);           /* widthxheight can't be 1x1 */\n      halfHeight=1;\n\n      for (jj=0; jj<halfWidth; jj++)\n      {\n         int kk;\n         for (kk=0; kk<components; kk++)\n         {\n            *dest=(*(const GLubyte*)src+\n                   *(const GLubyte*)(src+group_size))/2;\n\n            src+=element_size;\n            dest++;\n         }\n         src+=group_size;         /* skip to next 2 */\n      }\n      {\n         int padBytes=ysize-(width*group_size);\n         src+=padBytes;           /* for assertion only */\n      }\n   }\n   else\n   {\n      if (width==1)\n      {                           /* 1 column */\n         int padBytes=ysize-(width*group_size);\n         assert(height!=1);       /* widthxheight can't be 1x1 */\n         halfWidth=1;\n\n         /* one vertical column with possible pad bytes per row */\n         /* average two at a time */\n         for (jj=0; jj<halfHeight; jj++)\n         {\n            int kk;\n\n            for (kk=0; kk<components; kk++)\n            {\n               *dest=(*(const GLubyte*)src+*(const GLubyte*)(src+ysize))/2;\n\n               src+=element_size;\n               dest++;\n            }\n            src+=padBytes; /* add pad bytes, if any, to get to end to row */\n            src+=ysize;\n         }\n      }\n   }\n\n   assert(src==&((const char*)dataIn)[ysize*height]);\n   assert((char*)dest==&((char*)dataOut)[components*element_size*halfWidth*halfHeight]);\n}", "path": "source\\glues_mipmap.c", "repo_name": "Cpasjuste/GLU", "stars": 3, "license": "other", "language": "c", "size": 186}
