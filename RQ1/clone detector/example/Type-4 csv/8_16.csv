code1,code2,repo,predictions
"/**
 * Parse the command line arguments.  Get the initial width and height of
 * the window if specified (-width [value] -height [value]), and the
 * applet parameters (name value pairs).
 *
 * @param args              the command line arguments.  Contains possibly
 *                          height and width, and any applet parameters
 * @param startidx          index in the args array at which to transitionStart parsing
 */
public void parseArgs( String args[], int startidx ){
        for ( int idx = startidx; idx < ( args.length - startidx ); idx+=2 ) {
            try {
                if ( args[idx].equals( ""-width"" ) ) {
                    initial_width = Integer.parseInt( args[idx+1] );
                }
                else if ( args[idx].equals( ""-height"" ) ) {
                    initial_height = Integer.parseInt( args[idx+1] );
                }
                else {
                    params.put( args[idx], args[idx+1] );
                }
            }
            catch ( NumberFormatException nfe ) {
                System.err.println(""Warning: command line argument ""+args[idx]+
                                   "" is not a valid number."" );
            }
        }
    }","/**
 * Parse the command line arguments.  Get the initial width and height of
 * the window if specified (-width [value] -height [value]), and the
 * applet parameters (name value pairs).
 *
 * @param args              the command line arguments.  Contains possibly
 *                          height and width, and any applet parameters
 * @param startidx          index in the args array at which to transitionStart parsing
 */
public void parseArgs( String args[], int startidx ) 
{
    for (int i = startidx; i < args.length; i++) {
        if (args[i].equals(""-width"")) {
            try {
                width = Integer.parseInt(args[++i]);
            } catch (NumberFormatException e) {
                System.err.println(""Invalid width value: "" + args[i]);
            }
        } else if (args[i].equals(""-height"")) {
            try {
                height = Integer.parseInt(args[++i]);
            } catch (NumberFormatException e) {
                System.err.println(""Invalid height value: "" + args[i]);
            }
        } else {
            // Add the parameter to the applet parameters
            appletParams.put(args[i], args[++i]);
        }
    }
}   ",0,True
"/**
 * Description of the Method
 * 
 * @param e Description of Parameter
 */
public void actionPerformed(ActionEvent e){
	String command = e.getActionCommand();
	Log.log(Log.LEVEL_INFO, MODULE, ""Command selected "" + command);

	if (command.equals(""Cancel"")) {
		setVisible(false);
	} else if (command.equals(""OK"")) {
		newParent = (Album) jAlbum.getSelectedItem();
		//if (newParent == rootAlbum) {
		//	newParent = null;
		//}

		setVisible(false);
	}
}","/**
 * Description of the Method
 * 
 * @param e Description of Parameter
 */
public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == btnAdd)
    {
        add();
    }
    else if (e.getSource() == btnSubtract)
    {
        subtract();
    }
    else if (e.getSource() == btnMultiply)
    {
        multiply();
    }
    else if (e.getSource() == btnDivide)
    {
        divide();
    }
    else if (e.getSource() == btnClear)
    {
        clear();
    }
}   ",2,False
"/**
 * Called when the applet wants to be resized.  This causes the
 * Frame (window) to be resized to accomodate the new Applet size.
 *
 * @param width     the new width of the applet
 * @param height    the new height of the applet
 */
public void appletResize( int width, int height ){

        Insets insets = insets();

        resize( ( width + insets.left + insets.right ),
                ( height + status.preferredSize().height +
                  insets.top + insets.bottom ) );
    }","/**
 * Called when the applet wants to be resized.  This causes the
 * Frame (window) to be resized to accomodate the new Applet size.
 *
 * @param width     the new width of the applet
 * @param height    the new height of the applet
 */
public void appletResize( int width, int height ) 
{
    if (frame != null)
    {
        frame.resize(width, height);
    }
}   ",3,True
"/**
     * Show a new document in a target window or frame. This may be ignored by
     * the applet context.  (Again, it is ignored, but we'll show the
     * request information to the user in the status area.)
     *
     * This method accepts the target strings:
     *   _self		show in current frame
     *   _parent	show in parent frame
     *   _top		show in top-most frame
     *   _blank		show in new unnamed top-level window
     *   <other>	show in new top-level window named <other>
 *
 * @param url       URL to load
 * @param target    the target string
 */
public void showDocument( URL url, String target ){
        status.setText( ""AppletContext request to show URL "" +
                        url.toString() +
                        "" in target: "" + target );
    }","/**
     * Show a new document in a target window or frame. This may be ignored by
     * the applet context.  (Again, it is ignored, but we'll show the
     * request information to the user in the status area.)
     *
     * This method accepts the target strings:
     *   _self		show in current frame
     *   _parent	show in parent frame
     *   _top		show in top-most frame
     *   _blank		show in new unnamed top-level window
     *   <other>	show in new top-level window named <other>
 *
 * @param url       URL to load
 * @param target    the target string
 */
public void showDocument( URL url, String target ) 
{
    if (target.equals(""_self""))
    {
        // Show in current frame
        showDocumentInFrame(url);
    }
    else if (target.equals(""_parent""))
    {
        // Show in parent frame
        showDocumentInParentFrame(url);
    }
    else if (target.equals(""_top""))
    {
        // Show in top-most frame
        showDocumentInTopFrame(url);
    }
    else if (target.equals(""_blank""))
    {
        // Show in new unnamed top-level window
        showDocumentInNewWindow(url);
    }
    else
    {
        // Show in new top-level window named <other>
        showDocumentInNamedWindow(url, target);
    }
}   ",5,True
"/**
 * This method will take the input and escape characters that have
 * an HTML entity representation.
 * It uses a quick string -> array mapping to avoid creating thousands of
 * temporary objects.
 * 
 * @param nonHTMLsrc String containing the text to make HTML-safe
 * @return String containing new copy of string with ENTITIES escaped
 */
public static final String escape(String nonHTMLsrc){
	StringBuffer res = new StringBuffer();
	int l = nonHTMLsrc.length();
	int idx;
	char c;
	for (int i = 0; i < l; i++) {
		c = nonHTMLsrc.charAt(i);

		if (c > 255) {
			res.append(""&#"").append((int) c).append("";"");
		} else {
			idx = entityMap.indexOf(c);
			if (idx == -1) {
				res.append(c);
			} else {
				res.append(quickEntities[idx]);
			}
		}
	}
	return res.toString();
}","/**
 * This method will take the input and escape characters that have
 * an HTML entity representation.
 * It uses a quick string -> array mapping to avoid creating thousands of
 * temporary objects.
 * 
 * @param nonHTMLsrc String containing the text to make HTML-safe
 * @return String containing new copy of string with ENTITIES escaped
 */
public static final String escape(String nonHTMLsrc) 
{
    if (nonHTMLsrc == null)
    {
        return null;
    }

    StringBuilder escaped = new StringBuilder((int)(nonHTMLsrc.length() * 1.5));
    for (int i = 0; i < nonHTMLsrc.length(); i++)
    {
        char ch = nonHTMLsrc.charAt(i);
        String entity = HTML_ENTITIES[ch];
        if (entity == null)
        {
            escaped.append(ch);
        }
        else
        {
            escaped.append('&');
            escaped.append(entity);
            escaped.append(';');
        }
    }
    return escaped.toString();
}   ",8,True
"/**
 * A little bit of unit testing
 */
public static void main(String[] args){

	String text =
			""This is a test of the html escaper & let's hope it really, "" +
			""really <B><I>works</I></B>! Is there an \u00f7 with an umlaut in the house?"" +
			""This code is \u00a9copyleft. I like to be paid in \u00fa\u00fa\u00fas"";

	System.out.println(""NOTE: Due to differences in ASCII fonts, the text "" +
			""sent to the escaper may not display properly. Hopefully you will be "" +
			""able to tell what it should have looked like from the escaped output."");
	System.out.println(""in: "" + text);

	System.out.println(""out: "" + escape(text));

	System.out.println(""rev: "" + unescape(escape(text) + "" & toto""));
}","/**
 * A little bit of unit testing
 */
public static void main(String[] args) 
{
    // Create a new instance of the Calculator class
    Calculator calc = new Calculator();

    // Test the add method
    System.out.println(""2 + 3 = "" + calc.add(2, 3)); // Expected output: 2 + 3 = 5

    // Test the subtract method
    System.out.println(""5 - 3 = "" + calc.subtract(5, 3)); // Expected output: 5 - 3 = 2

    // Test the multiply method
    System.out.println(""2 * 3 = "" + calc.multiply(2, 3)); // Expected output: 2 * 3 = 6

    // Test the divide method
    System.out.println(""6 / 3 = "" + calc.divide(6, 3)); // Expected output: 6 / 3 = 2

    // Test the divide method with a divisor of 0
    System.out.println(""6 / 0 = "" + calc.divide(6, 0)); // Expected output: 6 / 0 = Error: Division by zero
}   ",10,False
"/**
 * Constructor for the NewAlbumDialog object
 * 
 * @param owner        Description of Parameter
 * @param gallery      Description of Parameter
 * @param defaultAlbum Description of Parameter
 */
public MoveAlbumDialog(Frame owner, Gallery gallery, Album album){
	super(owner, true);

	this.gallery = gallery;
	this.album = album;

	jbInit();

	pack();
	DialogUtil.center(this, owner);

	setVisible(true);
}","/**
 * Constructor for the NewAlbumDialog object
 * 
 * @param owner        Description of Parameter
 * @param gallery      Description of Parameter
 * @param defaultAlbum Description of Parameter
 */
public MoveAlbumDialog(Frame owner, Gallery gallery, Album album) 
{
    super(owner, ""Move Album"", true);
    this.gallery = gallery;
    this.album = album;
    this.getContentPane().setLayout(new BorderLayout());
    this.getContentPane().add(createCenterPanel(), BorderLayout.CENTER);
    this.getContentPane().add(createSouthPanel(), BorderLayout.SOUTH);
    this.pack();
    this.setResizable(false);
    this.setLocationRelativeTo(owner);
}   ",11,True
"/**
 * Move selected Pictures up
 */
public static void movePicturesUp(){
	JList jPicturesList = core.getPicturesList();
	int[] indices = jPicturesList.getSelectedIndices();
	int[] reselect = new int[indices.length];

	Arrays.sort(indices);

	for (int i = 0; i < indices.length; i++) {
		if (indices[i] > 0) {
			Album currentAlbum = core.getCurrentAlbum();

			Picture buf = currentAlbum.getPicture(indices[i]);
			currentAlbum.setPicture(indices[i], currentAlbum.getPicture(indices[i] - 1));
			currentAlbum.setPicture(indices[i] - 1, buf);
			//jPicturesList.setSelectedIndex( indices[i] - 1 );
			reselect[i] = indices[i] - 1;
		} else {
			reselect[i] = indices[i];
		}
	}

	jPicturesList.setSelectedIndices(reselect);
	jPicturesList.ensureIndexIsVisible(jPicturesList.getSelectedIndex());
}","/**
 * Move selected Pictures up
 */
public static void movePicturesUp() 
{
    Picture[] pictures = Gallery.getSelectedPictures();
    if (pictures.length > 0)
    {
        int[] indices = new int[pictures.length];
        for (int i = 0; i < pictures.length; i++)
        {
            indices[i] = pictures[i].getGalleryIndex();
        }
        java.util.Arrays.sort(indices);
        for (int i = 0; i < indices.length; i++)
        {
            if (indices[i] > 0)
            {
                pictures[i].moveGalleryIndex(indices[i] - 1);
            }
        }
    }
}   ",12,True
"/**
 * Main processing method for the Log object
 */
public void run(){
	System.out.println(""Logger thread running"");

	BufferedWriter writer = null;
	running = true;
	try {
		System.out.println(""Creating log file in "" + System.getProperty(""java.io.tmpdir""));
		writer = new BufferedWriter(new FileWriter(new File(System.getProperty(""java.io.tmpdir""), ""GalleryRemoteLog.txt"")));
		while (running) {
			Thread.sleep(sleepInterval);
			while (!logLines.isEmpty()) {
				String s = logLines.remove(0);
				writer.write(s);
				writer.newLine();

				if (toSysOut) {
					System.out.println(s);
				}
			}

			writer.flush();
		}
	} catch (IOException e) {
		System.err.println(""Can't write to log file. Disabling log..."");
		maxLevel = -1;
	} catch (InterruptedException e) {
		System.err.println(""Logger thread killed"");
	} finally {
		running = false;
		try {
			if (writer != null) {
				writer.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	System.out.println(""Logger thread shutting down"");
}","/**
 * Main processing method for the Log object
 */
public void run() 
{
    while (true)
    {
        try
        {
            // Get the next message from the queue
            Message message = messageQueue.take();

            // Process the message
            processMessage(message);
        }
        catch (InterruptedException e)
        {
            // Handle the exception
            e.printStackTrace();
        }
    }
}   ",14,False
"/**
 * Constructor for the main class, given an existing applet object and a default
 * frame (window) width and height.
 *
 * @param applet            the applet embedded in this AppletContext
 * @param default_width     the default width of the window
 * @param default_height    the default width of the window
 * @param args              the command line arguments.  Contains possibly
 *                          height and width, and any applet parameters
 */
public DummyAppletContext( Applet applet, int default_width, int default_height,
                               String args[] ){

        super ( applet.getClass().getName() );

        init( applet, default_width, default_height, args, 0 );
    }","/**
 * Constructor for the main class, given an existing applet object and a default
 * frame (window) width and height.
 *
 * @param applet            the applet embedded in this AppletContext
 * @param default_width     the default width of the window
 * @param default_height    the default width of the window
 * @param args              the command line arguments.  Contains possibly
 *                          height and width, and any applet parameters
 */
public DummyAppletContext( Applet applet, int default_width, int default_height,
                               String args[] ) 
{
    this.applet = applet;
    this.default_width = default_width;
    this.default_height = default_height;
    this.args = args;
}   ",15,True
"/**
 * Move selected Pictures down
 */
public static void movePicturesDown(){
	JList jPicturesList = core.getPicturesList();
	int[] indices = jPicturesList.getSelectedIndices();
	int[] reselect = new int[indices.length];

	Arrays.sort(indices);

	for (int i = indices.length - 1; i >= 0; i--) {
		Album currentAlbum = core.getCurrentAlbum();

		if (indices[i] < currentAlbum.sizePictures() - 1) {
			Picture buf = currentAlbum.getPicture(indices[i]);
			currentAlbum.setPicture(indices[i], currentAlbum.getPicture(indices[i] + 1));
			currentAlbum.setPicture(indices[i] + 1, buf);
			//jPicturesList.setSelectedIndex( sel + 1 );
			reselect[i] = indices[i] + 1;
		} else {
			reselect[i] = indices[i];
		}
	}

	jPicturesList.setSelectedIndices(reselect);
	jPicturesList.ensureIndexIsVisible(jPicturesList.getSelectedIndex());
}","/**
 * Move selected Pictures down
 */




public static void movePicturesDown() 
{
    ISelection selection = getSite().getSelectionProvider().getSelection();
    if (selection instanceof IStructuredSelection)
    {
        IStructuredSelection structuredSelection = (IStructuredSelection) selection;
        Iterator<?> iterator = structuredSelection.iterator();
        List<IPicture> pictures = new ArrayList<IPicture>();
        while (iterator.hasNext())
        {
            Object next = iterator.next();
            if (next instanceof IPicture)
            {
                pictures.add((IPicture) next);
            }
        }
        if (!pictures.isEmpty())
        {
            movePicturesDown(pictures);
        }
    }
}   ",16,False
"/**
 * Gets the document URL.
 *
	 * @return      a ""file:"" URL for the current directory
 */
public URL getDocumentBase(){
    URL url = null;
    try {
        File dummy = new File( ""dummy.html"" );
        String path = dummy.getAbsolutePath();
        if ( ! File.separator.equals( ""/"" ) ) {
            StringBuffer buffer = new StringBuffer();
            if ( path.charAt(0) != File.separator.charAt(0) ) {
                buffer.append( ""/"" );
            }
            StringTokenizer st = new StringTokenizer( path, File.separator );
            while ( st.hasMoreTokens() ) {
                buffer.append( st.nextToken() + ""/"" );
            }
            if ( File.separator.equals( ""\\"" ) &&
                 ( buffer.charAt(2) == ':' ) ) {
                buffer.setCharAt( 2, '|' );
            }
            else {
            }
            path = buffer.toString();
            path = path.substring( 0, path.length()-1 );
        }
        url = new URL( ""file"", """", -1, path );
    }
    catch ( MalformedURLException mue ) {
        mue.printStackTrace();
    }
    return url;
}","/**
 * Gets the document URL.
 *
	 * @return      a ""file:"" URL for the current directory
 */

public URL getDocumentBase() 
{
    try
    {
        return new URL(""file:"" + System.getProperty(""user.dir"") + ""/"");
    }
    catch (MalformedURLException e)
    {
        return null;
    }
}	",18,False
"/*
     * PRIVATE utility function.  Ignores the protocol, and returns a
     * filename for a file on the local filesystem (which may or may
     * not exist, of course).
 *
 * @param url   URL to be converted to a filename on the local
 *              filesystem.
 * @return      the filename
 */
private String filenameFromURL( URL url ){
        String filename = url.getFile();
        if ( filename.charAt(1) == '|' ) {
            StringBuffer buf = new StringBuffer( filename );
            buf.setCharAt( 1, ':' );
            filename = buf.toString();
        }
        else if ( filename.charAt(2) == '|' ) {
            StringBuffer buf = new StringBuffer( filename );
            buf.setCharAt( 2, ':' );
            filename = buf.toString();
        }
        return filename;
    }","/*
     * PRIVATE utility function.  Ignores the protocol, and returns a
     * filename for a file on the local filesystem (which may or may
     * not exist, of course).
 *
 * @param url   URL to be converted to a filename on the local
 *              filesystem.
 * @return      the filename
 */
private String filenameFromURL( URL url ) 
{
    String filename = url.getFile();
    if ( filename != null )
    {
        if ( filename.startsWith( ""/"" ) )
        {
            filename = filename.substring( 1 );
        }
    }
    return filename;
}   ",19,True
"/**
 * @param type
 * @param visitable
 */
public Ann(String type, boolean visitable){
    super();
    this.type = type;
    this.visible = visitable;
}","/**
 * @param type
 * @param visitable
 */
public Ann(String type, boolean visitable) 
{
    this.type = type;
    this.visitable = visitable;
}   ",23,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitLookupSwitchInsn(int, int, int, int[], int[])
 */
@Override
public void visitLookupSwitchInsn(int opcode, int reg, Label label, int[] cases, Label[] label2){
    info(opcode, ""switch(v%d)"", reg);
    for (int i = 0; i < cases.length; i++) {
        info(-1, ""case %d: goto L%s"", cases[i], labels(label2[i]));
    }
    info(-1, ""default: goto L%s"", labels(label));
    super.visitLookupSwitchInsn(opcode, reg, label, cases, label2);
}","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitLookupSwitchInsn(int, int, int, int[], int[])
 */
@Override
public void visitLookupSwitchInsn(int opcode, int reg, Label label, int[] cases, Label[] label2) 
{
    mv.visitLookupSwitchInsn(opcode, reg, label, cases, label2);
}   ",24,True
"/**
 * Returns style information - array of int triplets,
 * where in each triplet:
 * 	* first int is index of tag name ('b','i', etc.)
 * 	* second int is tag start index in string
 * 	* third int is tag end index in string
 */
private int[] getStyle(int index){
	if (m_styleOffsets==null || m_styles==null ||
		index>=m_styleOffsets.length)
	{
		return null;
	}
	int offset=m_styleOffsets[index]/4;
	int style[];
	{
		int count=0;
		for (int i=offset;i<m_styles.length;++i) {
			if (m_styles[i]==-1) {
				break;
			}
			count+=1;
		}
		if (count==0 || (count%3)!=0) {
			return null;
		}
		style=new int[count];
	}
	for (int i=offset,j=0;i<m_styles.length;) {
		if (m_styles[i]==-1) {
			break;
		}
		style[j++]=m_styles[i++];
	}
	return style;
}","/**
 * Returns style information - array of int triplets,
 * where in each triplet:
 * 	* first int is index of tag name ('b','i', etc.)
 * 	* second int is tag start index in string
 * 	* third int is tag end index in string
 */
private int[] getStyle(int index) 
{
	int[] result = null;
	if (index < styles.size())
	{
		result = styles.get(index);
	}
	return result;
}   ",25,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitLabel(int)
 */
@Override
public void visitLabel(Label label){
    boolean find = false;
    for (TryCatch tc : trys) {
        if (label.equals(tc.end)) {
            info(-1, "" } // TC_%d"", trys.indexOf(tc));
            find = true;
            break;
        }

    }","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitLabel(int)
 */
@Override
public void visitLabel(Label label) 
{
    if (label.info == null)
    {
        label.info = new LabelInfo();
    }
    label.info.offset = code.getPosition();
    code.setPosition(label.info.offset);
}   ",26,True
"/**
 * Returns number of strings in block. 
 */
public int getCount(){
	return m_stringOffsets!=null?
		m_stringOffsets.length:
		0;
}","/**
 * Returns number of strings in block. 
 */
public int getCount() 
{
    return count;
}   ",31,False
"/**
 * <p>
 * Creates an InputStream from a file, and fills it with the complete file.
 * Thus, available() on the returned InputStream will return the full number
 * of bytes the file contains
 * </p>
 * 
 * @param fkey
 *            The filename
 * @return The filled InputStream
 * @exception IOException
 *                , if the Streams couldn't be created.
 **/
private static InputStream fullStream(InputStream fkey) throws IOException{
	DataInputStream dis = new DataInputStream(fkey);
	byte[] bytes = new byte[dis.available()];
	dis.readFully(bytes);
	ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
	return bais;
}","/**
 * <p>
 * Creates an InputStream from a file, and fills it with the complete file.
 * Thus, available() on the returned InputStream will return the full number
 * of bytes the file contains
 * </p>
 * 
 * @param fkey
 *            The filename
 * @return The filled InputStream
 * @exception IOException
 *                , if the Streams couldn't be created.
 **/
private static InputStream fullStream(InputStream fkey) throws IOException 
{
    byte[] data = new byte[fkey.available()];
    fkey.read(data);
    return new ByteArrayInputStream(data);
}   ",32,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitTableSwitchInsn(int, int, int, int, int, int[])
 */
@Override
public void visitTableSwitchInsn(int opcode, int reg, int first_case, int last_case, Label label, Label[] labels){
    info(opcode, ""switch(v%d)"", reg);
    for (int i = 0; i < labels.length; i++) {
        info(opcode, ""case %d: goto L%s"", first_case + i, labels(labels[i]));
    }
    info(opcode, ""default: goto L%s"", labels(label));

    super.visitTableSwitchInsn(opcode, reg, first_case, last_case, label, labels);
}","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitTableSwitchInsn(int, int, int, int, int, int[])
 */
@Override
public void visitTableSwitchInsn(int opcode, int reg, int first_case, int last_case, Label label, Label[] labels) 
{
    mv.visitTableSwitchInsn(opcode, reg, first_case, last_case, label);
    for (Label l : labels)
    {
        mv.visitLabel(l);
    }
}   ",33,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitTypeInsn(int, java.lang.String, int, int)
 */
@Override
public void visitTypeInsn(int opcode, String type, int toReg, int fromReg){
    switch (opcode) {
    case OP_INSTANCE_OF:
        info(opcode, ""v%d=v%d instanceof %s"", toReg, fromReg, Type.getType(type).getClassName());
        break;
    }
    super.visitTypeInsn(opcode, type, toReg, fromReg);
}","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitTypeInsn(int, java.lang.String, int, int)
 */
@Override
public void visitTypeInsn(int opcode, String type, int toReg, int fromReg) 
{
    if (opcode == Opcodes.NEW)
    {
        mv.visitTypeInsn(opcode, type);
        mv.visitVarInsn(Opcodes.ASTORE, toReg);
    }
    else
    {
        mv.visitTypeInsn(opcode, type);
    }
}   ",34,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitArrayInsn(int, java.lang.String, int, int)
 */
@Override
public void visitArrayInsn(int opcode, String type, int saveToReg, int demReg){
    String type_show = Type.getType(type).getElementType().getClassName();
    info(opcode, ""v%d=new %s[v%d]"", saveToReg, type_show, demReg);
    super.visitArrayInsn(opcode, type, saveToReg, demReg);
}","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitArrayInsn(int, java.lang.String, int, int)
 */
@Override
public void visitArrayInsn(int opcode, String type, int saveToReg, int demReg) 
{
    if (opcode == Opcodes.OP_ARRAY_LENGTH)
    {
        mv.visitVarInsn(ALOAD, demReg);
        mv.visitMethodInsn(INVOKESTATIC, ""java/lang/System"", ""identityHashCode"", ""(Ljava/lang/Object;)I"");
        mv.visitVarInsn(ISTORE, saveToReg);
    }
    else
    {
        mv.visitVarInsn(ALOAD, demReg);
        mv.visitVarInsn(ALOAD, saveToReg);
        mv.visitMethodInsn(INVOKESTATIC, ""java/lang/System"", ""identityHashCode"", ""(Ljava/lang/Object;)I"");
        mv.visitInsn(opcode);
        mv.visitVarInsn(ISTORE, saveToReg);
    }
}   ",35,True
"/**
 * @param dcv
 */
public DumpDexCodeAdapter(DexCodeVisitor dcv, Method m, PrintWriter out){
    super(dcv);
    this.m = m;
    this.out = out;
}","/**
 * @param dcv
 */
public DumpDexCodeAdapter(DexCodeVisitor dcv, Method m, PrintWriter out) 
{
    this.dcv = dcv;
    this.m = m;
    this.out = out;
}   ",37,True
"/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitArrayInsn(int, int, int, int)
 */
@Override
public void visitArrayInsn(int opcode, int value, int array, int index){
    switch (opcode) {
    case OP_APUT:
    case OP_APUT_BOOLEAN:
    case OP_APUT_BYTE:
    case OP_APUT_CHAR:
    case OP_APUT_OBJECT:
    case OP_APUT_SHORT:
    case OP_APUT_WIDE:
        info(opcode, ""v%d[v%d]=v%d"", array, index, value);
        break;
    case OP_AGET:
    case OP_AGET_BOOLEAN:
    case OP_AGET_BYTE:
    case OP_AGET_CHAR:
    case OP_AGET_OBJECT:
    case OP_AGET_SHORT:
    case OP_AGET_WIDE:
        info(opcode, ""v%d=v%d[v%d]"", value, array, index);
        break;
    }
    super.visitArrayInsn(opcode, value, array, index);
}","/*
 * (non-Javadoc)
 * 
 * @see pxb.android.dex2jar.visitors.DexCodeAdapter#visitArrayInsn(int, int, int, int)
 */

@Override
public void visitArrayInsn(int opcode, int value, int array, int index) 
{
    switch (opcode)
    {
        case Opcodes.OP_AGET:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitInsn(AALOAD);
            break;
        case Opcodes.OP_APUT:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitVarInsn(ALOAD, value);
            mv.visitInsn(AASTORE);
            break;
        case Opcodes.OP_IGET:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitInsn(IALOAD);
            mv.visitVarInsn(ISTORE, value);
            break;
        case Opcodes.OP_IPUT:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitVarInsn(ILOAD, value);
            mv.visitInsn(IASTORE);
            break;
        case Opcodes.OP_SGET:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitInsn(SALOAD);
            mv.visitVarInsn(ISTORE, value);
            break;
        case Opcodes.OP_SPUT:
            mv.visitVarInsn(ALOAD, array);
            mv.visitVarInsn(ILOAD, index);
            mv.visitVarInsn(ILOAD, value);
            mv.visitInsn(SASTORE);
            break;
        default:
            throw new RuntimeException(""Invalid opcode: "" + opcode);
    }
}   ",38,False
"/**
 * Returns raw string (without any styling information) at specified index.
 */
public String getString(int index){
	if (index<0 ||
		m_stringOffsets==null ||
		index>=m_stringOffsets.length)
	{
		return null;
	}
	int offset=m_stringOffsets[index];
	int length=getShort(m_strings,offset);
	StringBuilder result=new StringBuilder(length);
	for (;length!=0;length-=1) {
		offset+=2;
		result.append((char)getShort(m_strings,offset));
	}
	return result.toString();
}","/**
 * Returns raw string (without any styling information) at specified index.
 */
public String getString(int index) 
{
    if (index < 0 || index >= size)
    {
        throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
    }

    return strings[index];
}   ",39,True
"/**
 * Spin up a lot of threads and have them all create variants 3/2007 there
 * have been several reports in multi-threaded servers that show init()
 * failing
 * 
 */
public void testManyThreadedInit(){
	VariantInitTestThread threads[] = new VariantInitTestThread[75];

	System.out.println(""Starting thread test ("" + threads.length
			+ "" threads each creating 10000 objects).""
			+ "" This may take 30 seconds or more."");
	for (int i = 0; i < threads.length; i++) {
		threads[i] = new VariantInitTestThread(""thread-"" + i, 10000);
	}
	for (int i = 0; i < threads.length; i++) {
		threads[i].start();
	}
	int numComplete = 0;
	while (numComplete < threads.length) {
		// give the works time to work
		try {
			Thread.sleep(333);
		} catch (InterruptedException ie) {
			// do nothing
		}
		numComplete = 0;
		for (int i = 0; i < threads.length; i++) {
			if (threads[i].isComplete) {
				numComplete++;
			}
		}
		// System.out.print(""[""+numComplete+""/""+threads.length+""]"");
	}
	System.out.println(""Finished thread test"");
}","/**
 * Spin up a lot of threads and have them all create variants 3/2007 there
 * have been several reports in multi-threaded servers that show init()
 * failing
 * 
 */

public void testManyThreadedInit() 
{
    int numThreads = 100;
    Thread[] threads = new Thread[numThreads];

    for (int i = 0; i < numThreads; i++)
    {
        threads[i] = new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    Thread.sleep(1);
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        });
    }

    for (int i = 0; i < numThreads; i++)
    {
        threads[i].start();
    }

    for (int i = 0; i < numThreads; i++)
    {
        try
        {
            threads[i].join();
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}   ",40,True
"/**
 * Detects whether this is a 32-bit JVM.
 * 
 * @return {@code true} if this is a 32-bit JVM.
 */
protected static boolean shouldLoad32Bit(){
	// This guesses whether we are running 32 or 64 bit Java.
	// This works for Sun and IBM JVMs version 5.0 or later.
	// May need to be adjusted for non-Sun JVMs.

	String bits = System.getProperty(""sun.arch.data.model"", ""?"");
	if (bits.equals(""32""))
		return true;
	else if (bits.equals(""64""))
		return false;

	// this works for jRocket
	String arch = System.getProperty(""java.vm.name"", ""?"");
	if (arch.toLowerCase().indexOf(""64-bit"") >= 0)
		return false;

	return true;
}","/**
 * Detects whether this is a 32-bit JVM.
 * 
 * @return {@code true} if this is a 32-bit JVM.
 */
protected static boolean shouldLoad32Bit() 
{
    String model = System.getProperty(""sun.arch.data.model"", ""unknown"");
    return ""32"".equals(model);
}   ",41,False
"/**
 * Developer note: This method MUST be synchronized with the DLL names
 * created as part of the build process in build.xml
 * <p>
 * The DLL name is ""racob\<PLATFORM\>.release""
 * 
 * @return the preferred name of the DLL adjusted for this platform and
 *         version without the "".dll"" extension
 */
public static String getPreferredDLLName(){
	if (shouldLoad32Bit()) {
		return ""racob"" + ""-"" + DLL_NAME_MODIFIER_32_BIT;
	} else {
		return ""racob"" + ""-"" + DLL_NAME_MODIFIER_64_BIT;
	}
}","/**
 * Developer note: This method MUST be synchronized with the DLL names
 * created as part of the build process in build.xml
 * <p>
 * The DLL name is ""racob\<PLATFORM\>.release""
 * 
 * @return the preferred name of the DLL adjusted for this platform and
 *         version without the "".dll"" extension
 */
public static String getPreferredDLLName() 
{
    String dllName = ""racob"";
    String platform = getPlatform();
    String version = getVersion();

    return dllName + platform + ""."" + version;
}   ",43,True
"/**
 * A String representation of the variant if possible.  It will return
 * ""null"" if VariantEmpty, VariantError, or VariantNull.
 *
 * @return a reasonable string representation
 */
@Override
public String toString(){
    int vt = getvt();

    if (vt == VariantEmpty || vt == VariantError || vt == VariantNull) return ""null"";
    if (vt == VariantString) return getString();

    try {
        Object foo = toJavaObject();
        // rely on java objects to do the right thing
        if (foo == null) return ""{Java null}"";

        return foo.toString();
    } catch (RuntimeException e) {
        // some types do not generate a good description yet
        return ""Description not available for type: "" + getvt();
    }
}","/**
 * A String representation of the variant if possible.  It will return
 * ""null"" if VariantEmpty, VariantError, or VariantNull.
 *
 * @return a reasonable string representation
 */
@Override
public String toString() 
{
    if (isEmpty()) return ""null"";
    if (isError()) return ""error"";
    if (isNull()) return ""null"";
    return value;
}   ",44,False
"/**
 * verify decimal works right
 */
public void testDecimalConversion(){
	for (int i = 10; i >= -10; i--) {
		Variant v = new Variant(new BigDecimal(i));
		// first see if we can get it back as decimal
		assertEquals(""conversion back to decimal failed "" + i,
				new BigDecimal(i), v.getDecimal());
		v.changeType(Variant.VariantFloat);
		// now see if a float conversion would work
		assertEquals(""conversion to float failed "" + i, new Float(i), v
				.getFloat());
		// now convert it back to decimal for reassignment
		v.changeType(Variant.VariantDecimal);
		assertTrue(""Failed conversion of type back to Decimal "" + i, v
				.getvt() == Variant.VariantDecimal);
	}

}","/**
 * verify decimal works right
 */

public void testDecimalConversion() 
{
    BigDecimal value = new BigDecimal(""1.23456"");
    String expected = ""1.23456"";
    String actual = value.toString();
    Assert.assertEquals(expected, actual);
}   ",48,False
"/**
 * return the int value held in this variant if it is an int or a short.
 * Throws for other types.
 *
 * @return int contents of the windows memory
 * @throws IllegalStateException
 *             if variant is not of the requested type
 */
public int getInt(){
    if (isA(VariantUnsignedInt)) return ((Integer) value).intValue();
    if (isA(VariantInt)) return ((Integer) value).intValue();
    if (isA(VariantShort)) return ((Short) value).shortValue();
    illegal(""getInt"", ""VariantInt"");
    return -1; // not reached
}","/**
 * return the int value held in this variant if it is an int or a short.
 * Throws for other types.
 *
 * @return int contents of the windows memory
 * @throws IllegalStateException
 *             if variant is not of the requested type
 */
public int getInt() 
{
    if (isInt())
    {
        return (int) mValue;
    }
    else if (isShort())
    {
        return (short) mValue;
    }
    else
    {
        throw new IllegalStateException(""Variant is not an int or a short"");
    }
}   ",49,True
"/**
 * @return string contents of the variant.
 * @throws IllegalStateException if this variant is not of type String
 */
public String getString(){
    if (!isA(VariantString)) illegal(""getString"", ""VariantString"");
    return (String) value;
}","/**
 * @return string contents of the variant.
 * @throws IllegalStateException if this variant is not of type String
 */
public String getString() 
{
    if (type != Variant.VT_BSTR)
        throw new IllegalStateException(""Variant is not a String"");
    return (String) value;
}   ",50,True
"/**
 * This verifies that toJavaObject() works for all of the main data types
 * when they exist as a byRef version.
 * <p>
 * It compares the toJavaObject() for a byref against the toJavaObject() for
 * the regular.
 * 
 */
public void testByRefToJavaObject(){
	Variant v = null;
	Variant vByRef = null;

	v = new Variant(new Float(53.3), false);
	vByRef = new Variant(new Float(53.3), true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}
	v = new Variant(new Double(53.3), false);
	vByRef = new Variant(new Double(53.3), true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	v = new Variant(new Boolean(true), false);
	vByRef = new Variant(new Boolean(true), true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	v = new Variant(new Integer(53), false);
	vByRef = new Variant(new Integer(53), true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	v = new Variant(new Short((short) 53), false);
	vByRef = new Variant(new Short((short) 53), true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	v = new Variant(""53.33"", false);
	vByRef = new Variant(""53.33"", true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	// Ugh, you have to pick a magic number whose scale is less than 28
	// 53.53 had a scale of 64 and 53.52 had a scale of 47
	BigDecimal testDecimal = new BigDecimal(53.50);
	v = new Variant(testDecimal, false);
	vByRef = new Variant(testDecimal, true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}

	Date now = new Date();
	v = new Variant(now, false);
	vByRef = new Variant(now, true);
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}
}","/**
 * This verifies that toJavaObject() works for all of the main data types
 * when they exist as a byRef version.
 * <p>
 * It compares the toJavaObject() for a byref against the toJavaObject() for
 * the regular.
 * 
 */
public void testByRefToJavaObject() 
{
    try
    {
        for (int i = 0; i < types.length; i++)
        {
            if (types[i].isByRef())
            {
                Object o = types[i].toJavaObject();
                Object o2 = types[i].toJavaObject();
                assertEquals(o, o2);
            }
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
        fail(e.getMessage());
    }
}   ",53,True
"/**
 * @return the date
 * @throws IllegalStateException if variant is not of the requested type
 */
public Date getDate(){
    if (!isA(VariantDate)) illegal(""getDate"", ""VariantDate"");
    return (Date) value;
}","/**
 * @return the date
 * @throws IllegalStateException if variant is not of the requested type
 */
public Date getDate() 
{
    if (variant != Variant.DATE)
    {
        throw new IllegalStateException(""Variant is not of type DATE"");
    }
    return (Date) value;
}   ",54,True
"/**
 * do some testing around currencies
 */
public void testCurrencyHandling(){
	Variant v = null;
	Variant vByRef = null;

	// need to do currency also
	// currency is an integer scaled up by 10,000 to give 4 digits to the
	// right of the decimal
	int currencyScale = 10000;
	long twentyThousand = 20000 * currencyScale;
	Currency twentyThousandAsCurrency = new Currency(twentyThousand);
	v = new Variant(twentyThousandAsCurrency, false);
	vByRef = new Variant(twentyThousandAsCurrency, true);
	if (!(v.toJavaObject() instanceof Currency)) {
		fail(""v.toJavaObject was not Long for currency but was: ""
				+ v.toJavaObject());
	}
	if (!v.toJavaObject().equals(vByRef.toJavaObject())) {
		fail(v.toString() + "" could not make type "" + v.getvt() + "" and ""
				+ vByRef.getvt() + "" java objects come out the same"");
	}
	long twentyThousandDotSeven = twentyThousand + 700;
	Currency twentyThousandDotSevenAsCurrency = new Currency(
			twentyThousandDotSeven);
	// use the primitive constructor
	v = new Variant(twentyThousandDotSevenAsCurrency);
	assertEquals(""failed test with "" + twentyThousandDotSeven,
			twentyThousandDotSeven, v.getCurrency().longValue());

}","/**
 * do some testing around currencies
 */
public void testCurrencyHandling() 
{
    // create a new currency
    Currency currency = new Currency(""USD"");

    // set the currency value
    currency.setValue(100.0);

    // print the currency value
    System.out.println(""Currency value: "" + currency.getValue());

    // add some tax
    double tax = 10.0;
    currency.addValue(tax);

    // print the currency value with tax
    System.out.println(""Currency value with tax: "" + currency.getValue());

    // subtract some discount
    double discount = 20.0;
    currency.subtractValue(discount);

    // print the currency value with tax and discount
    System.out.println(""Currency value with tax and discount: "" + currency.getValue());
}   ",56,False
"/**
 * @return the error value 
 * @throws IllegalStateException if variant is not of the requested type
 */
public int getError(){
    if (!isA(VariantError)) illegal(""getError"", ""VariantError"");
    return ((Integer) value).intValue();
}","/**
 * @return the error value 
 * @throws IllegalStateException if variant is not of the requested type
 */
public int getError() 
{
    if (variant != Variant.ERROR)
    {
        throw new IllegalStateException(""Variant is not of type ERROR"");
    }
    return error;
}   ",57,True
"/**
 * 64 bit Longs only available on x64. 64 bit long support added 1.14
 *
 * @return returns the value as a long
 * @throws IllegalStateException if variant is not of the requested type
 */
public long getLong(){
    if (!isA(VariantLongInt) && !(isA(VariantUnsignedLong))) illegal(""getLong"", ""VariantLongInt"");
    return ((Long) value).longValue();
}","/**
 * 64 bit Longs only available on x64. 64 bit long support added 1.14
 *
 * @return returns the value as a long
 * @throws IllegalStateException if variant is not of the requested type
 */
public long getLong() 
{
    if (variant != Variant.LONG)
    {
        throw new IllegalStateException(""Variant is not a long"");
    }
    return value;
}   ",59,True
"/**
 * similar to post, but does not check subscription status, and takes command as a arg
 * This function should ONLY be called for message id >= MSG_CONTROL_FIRST
 * because these messages do not contain an updateid
 * @param command the command to send
 * @param data the data associated with the command
 */
protected void send_data(int command, byte[] data){
   try {
      if (command >= MSG_CONTROL_FIRST) {
         dos.writeInt(8 + data.length);
         dos.writeInt(command);
         dos.write(data);
         dos.flush();
         logln(""send_data- cmd: "" + command + "" datasize: "" + data.length, LINFO3);
         stats[0][command]++;
      }
      else {
         logln(""post should be used for command "" + command + "", not send_data.  Data not sent."", LERROR);
      }
   } catch (Exception ex) {
      logex(ex);
   }
}","/**
 * similar to post, but does not check subscription status, and takes command as a arg
 * This function should ONLY be called for message id >= MSG_CONTROL_FIRST
 * because these messages do not contain an updateid
 * @param command the command to send
 * @param data the data associated with the command
 */
protected void send_data(int command, byte[] data) 
{
    if (data == null)
    {
        data = new byte[0];
    }

    byte[] packet = new byte[2 + data.length];
    packet[0] = (byte)command;
    packet[1] = (byte)data.length;
    System.arraycopy(data, 0, packet, 2, data.length);

    try
    {
        out.write(packet);
        out.flush();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",61,False
"/**
 * run this is the main thread for the Client class, it continually loops, receiving commands
 * and performing appropriate actions for each command
 */
public void run(){
   try {
      main_loop:
      while (true) {
         CollabreateOutputStream os = new CollabreateOutputStream();
         int len = dis.readInt();
         int command = dis.readInt();
         logln(""received data len: "" + len + "", cmd: "" + command, LDEBUG);
         if (command < MAX_COMMAND && command > 0) {
            stats[1][command]++;
         }
         len -= 8;
         if (command < MSG_CONTROL_FIRST) {
            byte[] data = new byte[len];
            dis.readFully(data);
            os.writeInt(len + 16);
            os.writeInt(command);
            os.writeLong(0);  //this is where the updateid will get inserted
            os.write(data);
            //only accept commands if the client is authenticated
            if (authenticated && (publish > 0)) {
               //only post if this client chose to publish, 
               //(though they really shouldn't have sent any data if they are not publishing)
               if (checkPermissions(command, publish)) { 
                  logln(""posting command "" + command + "" (allowed to  publish) "", LDEBUG);
                  cm.post(this, command, os.toByteArray());
               }
               else {
                  logln(""not allowed to perform command: "" + command, LINFO);
                      // if (errorAlreadySentMask
                      // send_error(""you are not allowed to byte patch"");
                      // errorAlreadySentMask |= MASK_BYTE_PATCHED;
                      // logln(""sent errors is "" + errorAlreadySentMask);
               }
            }
            else {
               logln(""Client "" + hash + "":"" + conn.getInetAddress().getHostAddress()
                                  + "":"" + conn.getPort() + "" skipping post command."", LINFO);
            }
         }
         else { //server only command
            switch (command) {
               case MSG_PROJECT_NEW_REQUEST: {
                  logln(""in NEW PROJECT REQUEST"", LDEBUG);
                  byte[] md5 = new byte[MD5_SIZE];
                  try {
                     dis.readFully(md5);
                     hash = Utils.toHexString(md5);
                     String desc = dis.readUTF();
                     long pub = dis.readLong() & 0x7FFFFFFF;
                     long sub = dis.readLong() & 0x7FFFFFFF;
                     if (!authenticated) {
                        //nice try!!
                        break;
                     }
                     logln(""desired new project pub "" + pub + "", and sub "" + sub);
                     int lpid = cm.addProject(this, hash, desc, pub, sub);
                     if (lpid >= 0) {
                        logln(""NEW PROJECT REQUEST success"", LINFO);
                        os.writeInt(JOIN_REPLY_SUCCESS);
                        os.write(Utils.toByteArray(gpid));
                     }
                     else {
                        logln(""NEW PROJECT REQUEST fail"", LINFO);
                        os.writeInt(JOIN_REPLY_FAIL);
                     }
                     send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                  } catch (Exception ex) {
                     logln(""Malformed NEW PROJECT REQUEST - failed to read md5"", LERROR);
                     send_error(""Malformed NEW_PROJECT_REQUEST"");
                     break;
                  }
                  break;
               }
               case MSG_PROJECT_JOIN_REQUEST: {
                  int lpid = dis.readInt();
                  long tpub = dis.readLong() & 0x7FFFFFFF;
                  long tsub = dis.readLong() & 0x7FFFFFFF; 
                  if (!authenticated) {
                     //nice try!!
                     break;
                  }
                  rpublish = tpub;
                  rsubscribe = tsub;
                  logln(""attempting to join project "" + lpid, LINFO);
                  if (cm.joinProject(this, lpid) >= 0 ) {
                     os.writeInt(JOIN_REPLY_SUCCESS);
                     byte gp[] = new byte[GPID_SIZE];
                     gp = Utils.toByteArray(gpid); 
                     os.write(gp);
                     logln(""...success"" + lpid, LINFO);
                  }
                  else {
                     os.writeInt(JOIN_REPLY_FAIL);
                     logln(""...failed"" + lpid, LINFO);
                  }
                  send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                  break;               
               }
               case MSG_PROJECT_REJOIN_REQUEST: {
                  logln(""in PROJECT_REJOIN_REQUEST"", LDEBUG);
                  byte gp[] = new byte[GPID_SIZE];
                  int rejoingbasic = 0;
                  try {
                     dis.readFully(gp);
                     String gpid = Utils.toHexString(gp);
                     if ( Utils.isNumeric(gpid) ) {
                        if ( Integer.parseInt(gpid) == 0 ) { 
                           //basic mode pid was stored in netnode
                           send_error(""This instance of IDA connected in basic mode, cannot reconnect."");
                           break;
                        }
                     }
                     int lpid = cm.gpid2lpid(gpid);
                     long tpub = dis.readLong() & 0x7FFFFFFF;
                     long tsub = dis.readLong() & 0x7FFFFFFF; 
                     if (!authenticated) {
                        logln(""unauthorized project rejoin request"", LERROR);
                        send_error(""Authenication required for this operation"");
                        break;
                     }
                     rpublish = tpub;
                     rsubscribe = tsub; 
                     logln(""plugin requested rpub: "" + rpublish + "" rsub: "" + rsubscribe);
                     if (cm.joinProject(this, lpid) >= 0 ) {
                        os.writeInt(JOIN_REPLY_SUCCESS);
                        os.write(gp);
                        send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                     }
                     else {
                        os.writeInt(JOIN_REPLY_FAIL);
                        send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                        send_error(""Tried to join a project that doesn't exist on this server:"" + gpid);
                        send_fatal(""This idb is associated with a project not found on this server.\n Maybe you connected to the wrong collabREate server,\n or maybe the project has been deleted..."");
                        break main_loop;
                     }
                  } catch (Exception e) {
                     logln(""Malformed REJOIN REQUEST - failed to read gpid"", LERROR);
                     send_error(""Malformed PROJECT_REJOIN"");
                  }
                  break;               
               }
               case MSG_PROJECT_SNAPSHOT_REQUEST: {
                  logln(""in SNAPSHOT REQ"", LDEBUG);
                  String desc = dis.readUTF();
                  long lastupdateid = dis.readLong();
                  if (!authenticated) {
                     logln(""unauthorized project snapshot request"", LERROR);
                     send_error(""Authenication required for this operation"");
                     os.writeInt(PROJECT_SNAPSHOT_FAIL);
                     send_data(MSG_PROJECT_SNAPSHOT_REPLY, os.toByteArray());
                     break;
                  }
                  if (lastupdateid <= 0 ) {
                     logln(""attempt to add snapshot with 0 or less updates applied"", LINFO);
                     send_error(""snapshots with 0 or less updates are not allowed - start a new project instead"");
                     os.writeInt(PROJECT_SNAPSHOT_FAIL);
                     send_data(MSG_PROJECT_SNAPSHOT_REPLY, os.toByteArray());
                     break;
                  }
                  if (cm.snapProject(this, lastupdateid, desc) >= 0) { 
                     os.writeInt(PROJECT_SNAPSHOT_SUCCESS);
                  }
                  else {
                     os.writeInt(PROJECT_SNAPSHOT_FAIL);
                  }
                  send_data(MSG_PROJECT_SNAPSHOT_REPLY, os.toByteArray());
                  break;
               }
               case MSG_PROJECT_FORK_REQUEST: {
                  long lastupdateid = dis.readLong();
                  String desc = dis.readUTF();
                  logln(""in FORK REQUEST"", LDEBUG);
                  if (!authenticated) {
                     logln(""unauthorized project fork request"", LERROR);
                     send_error(""Authenication required for this operation"");
                     os.writeInt(JOIN_REPLY_FAIL);
                     send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                     break;
                  }

                  //if the user set these at the time of the fork
                  //they would be read here.  Instead we allow the owner to
                  //manage permissions at any time via the modal dialog box
                  //long pub = dis.readLong() & 0x7FFFFFFF;
                  //long sub = dis.readLong() & 0x7FFFFFFF;
                  //if (cm.forkProject(this, lastupdateid, desc, pub, sub) >= 0) { 
                  if (cm.forkProject(this, lastupdateid, desc) >= 0) { 
                     //on successfull fork, join the 'new' project automatically
                     os.writeInt(JOIN_REPLY_SUCCESS);
                     os.write(Utils.toByteArray(gpid));
                  }
                  else {
                     os.writeInt(JOIN_REPLY_FAIL);
                  }
                  send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                  break;
               }
               case MSG_PROJECT_SNAPFORK_REQUEST: {
                  logln(""in SNAPFORK REQUEST"", LDEBUG);
                  int lpid = dis.readInt();
                  String desc = dis.readUTF();
                  long pub = dis.readLong() & 0x7FFFFFFF;
                  long sub = dis.readLong() & 0x7FFFFFFF;
                  if (!authenticated) {
                     logln(""unauthorized project snapfork request"", LERROR);
                     send_error(""Authenication required for this operation"");
                     os.writeInt(JOIN_REPLY_FAIL);
                     send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                     break;
                  }
                  logln(""got "" + lpid + "": "" + desc, LDEBUG);
                  if (cm.snapforkProject(this, lpid, desc, pub, sub) >= 0) { 
                     //on successfull fork from snapshop, join the 'new' project automatically
                     os.writeInt(JOIN_REPLY_SUCCESS);
                     os.write(Utils.toByteArray(gpid));
                  }
                  else {
                     os.writeInt(JOIN_REPLY_FAIL);
                  }
                  send_data(MSG_PROJECT_JOIN_REPLY, os.toByteArray());
                  break;
               }
               case MSG_PROJECT_LEAVE: {
                  logln(""in PROJECT LEAVE"", LDEBUG);
                  if (!authenticated) {
                     logln(""unauthorized project leave request"", LERROR);
                     send_error(""Authenication required for this operation"");
                     break;
                  }
                  cm.remove(this);
                  break;
               }
               case MSG_PROJECT_JOIN_REPLY:                 
                  break;
               case MSG_AUTH_REQUEST:
                  logln(""in AUTH REQUEST"", LDEBUG);
                  int pluginversion = dis.readInt();
                  if (pluginversion != PROTOCOL_VERSION) {
                     send_error(""Version mismatch. plugin: "" + pluginversion + "" server: "" + PROTOCOL_VERSION);
                     logln(""Version mismatch. plugin: "" + pluginversion + "" server: "" + PROTOCOL_VERSION, LERROR);
                     break main_loop;
                  }
                  if (!authenticated) {
                     byte resp[] = new byte[MD5_SIZE];
                     username = dis.readUTF();
                     logln(""got user"" + username, LDEBUG);
                     try {
                        dis.readFully(resp);
                     } catch (Exception ex) {
                        logln(""Malformed AUTH REQUEST - failed to read hmac response"", LERROR);
                        send_error(""Malformed AUTH_REQUEST"");
                        break main_loop;  //disconnect
                     }

                     uid = cm.authenticate(this, username, challenge, resp);
                     if (uid != INVALID_USER) {
                        authenticated = true;
                        //logln(""uid set to ""+ uid);
                        os.writeInt(AUTH_REPLY_SUCCESS);
                     }
                     else {
                        os.writeInt(AUTH_REPLY_FAIL);
                        authTries--;
                     }
                     send_data(MSG_AUTH_REPLY, os.toByteArray());
                     if (authTries == 0) {
                        logln(""too many auth attempts for "" + this.getUser(), LERROR);
                        break main_loop;
                     }
                  }
                  else {
                     logln(""recv AUTH REQUEST when already authenticated"", LERROR);
                     send_error(""Attempt to Authenticate, when already authenticated"");
                  }                     
                  break;
               case MSG_PROJECT_LIST:
                  if (len != MD5_SIZE) { //len + cmd alread accounted for
                     send_error(""Malformed Project getlist request"");
                  }
                  else {
                     byte[] md5 = new byte[MD5_SIZE];
                     try {
                        dis.readFully(md5);
                     } catch (Exception ex) {
                        logln(""Malformed MSG_PROJECT_LIST - failed to read file md5"", LERROR);
                        send_error(""Malformed MSG_PROJECT_LIST"");
                        break main_loop;  //disconnect
                     }
                     if (!authenticated) {
                        //nice try!!
                        break;
                     }
                     hash = Utils.toHexString(md5);
                     logln(""project hash: "" + hash, LINFO4);                     
                     Vector<ProjectInfo> plist = cm.getProjectList(hash);
                     int nump = plist.size();
                     os.writeInt(nump);   //send number of elements to come
                     logln("" Found  "" + nump + "" projects"", LINFO3);
                     //create list of projects
                     for (ProjectInfo pi : plist) {
                        log("" "" + pi.lpid + "" ""+ pi.desc, LINFO4);
                        os.writeInt(pi.lpid);
                        os.writeLong(pi.snapupdateid);
                        if (pi.parent > 0) {
                           if (pi.snapupdateid > 0) {
                              os.writeUTF(""[-] "" + pi.desc + "" (SNAP of '"" + pi.pdesc + ""'@""+ pi.snapupdateid + "" updates])""); 
                              log(""[-] "" + pi.desc + "" (snapshot of ("" + pi.parent + "")'"" + pi.pdesc+""' [""+ pi.snapupdateid + "" updates]) "", LDEBUG); 
                           }
                           else {
                              os.writeUTF(""["" + pi.connected + ""] "" + pi.desc + "" (FORK of '"" + pi.pdesc + ""')""); 
                              log(""["" + pi.connected + ""] "" + pi.desc + "" (forked from ("" + pi.parent + "") '"" + pi.pdesc +""')"", LDEBUG); 
                           }
                        }
                        else {
                           os.writeUTF(""["" + pi.connected + ""] "" + pi.desc);
                        }
                        //since the user permissions may already limit the eventual effective permissions
                        //only show the user the maximum attainable by this particular user (mask)
                        //upublish = usubscribe = FULL_PERMISSIONS;  //quick BASIC mode test
                        os.writeLong(pi.pub & upublish);
                        os.writeLong(pi.sub & usubscribe);
                        logln("""", LDEBUG);
                        logln(""pP "" + pi.pub + "" pS "" + pi.sub, LINFO4);
                        logln(""uP "" + upublish + "" uS "" + usubscribe, LINFO4);
                     }
                     //also append list of permissions supported by this server
                     os.writeInt(permStrings.length);
                     for ( int i = 0; i < permStrings.length; i++) {
                        os.writeUTF(permStrings[i]);
                     }

                     send_data(MSG_PROJECT_LIST, os.toByteArray());
                  }
                  break;
               case MSG_SEND_UPDATES: {
                  long lastupdate = dis.readLong();
                  if (!authenticated) {
                     //nice try!!
                     break;
                  }
                  logln(""Received SEND_UPDATES request for "" + lastupdate + "" to current"", LINFO1);
                  cm.sendLatestUpdates(this, lastupdate);
                     
                  break;
               }
               case MSG_SET_REQ_PERMS: {
                  logln(""Received SET_REQ_PERMS request"", LINFO1);
                  long tpub = dis.readLong() & 0x7FFFFFFF;
                  long tsub = dis.readLong() & 0x7FFFFFFF;
                  if (!authenticated) {
                     logln(""unauthorized get req perms request"",LERROR);
                     send_error(""Authenication required for this operation"");
                     break;
                  }

                  rpublish = tpub;
                  rsubscribe = tsub;
                  ProjectInfo pi = cm.getProjectInfo(pid);
                  logln(""effective publish  : "" + 
                        Long.toHexString(pi.pub) + "" & "" + 
                        Long.toHexString(rpublish) + "" & "" + 
                        Long.toHexString(upublish) + "" = "" + 
                        Long.toHexString(pi.pub & upublish & rpublish),LINFO1);
                  logln(""effective subscribe: "" + 
                        Long.toHexString(pi.sub) + "" & "" + 
                        Long.toHexString(rsubscribe) + "" & "" + 
                        Long.toHexString(usubscribe) + "" = "" + 
                        Long.toHexString(pi.sub & usubscribe & rsubscribe),LINFO1);

                  if ( uid != pi.owner ) {
                     setPub(pi.pub & upublish & rpublish);
                     setSub(pi.sub & usubscribe & rsubscribe);
                  }
                  else {
                     logln(""not honoring SET_REQ_PERMS for owner"", LINFO1);
                     send_error(""You are the owner.  FULL permissions granted."");
                  }

                  break;
               }
               case MSG_GET_REQ_PERMS: {
                  logln(""Received GET_REQ_PERMS request"", LINFO1);
                  if (!authenticated) {
                     logln(""unauthorized get req perms request"",LERROR);
                     send_error(""Authenication required for this operation"");
                     break;
                  }
                  //send the two requested permissions
                  os.writeLong(rpublish);
                  os.writeLong(rsubscribe); 
                  //send the max possible values for requested permissions (mask)
                  ProjectInfo pi = cm.getProjectInfo(pid);
                  os.writeLong(pi.pub & upublish);
                  os.writeLong(pi.sub & usubscribe);
                  //also append list of permissions supported by this server
                  os.writeInt(permStrings.length);
                  for (int i = 0; i < permStrings.length; i++) {
                     os.writeUTF(permStrings[i]);
                  }
                  send_data(MSG_GET_REQ_PERMS_REPLY, os.toByteArray());
                  break;
               }
               case MSG_GET_PROJ_PERMS: {
                  logln(""Received GET_PROJ_PERMS request"", LINFO1);
                  if (!authenticated) {
                     logln(""unauthorized get project perms request"",LERROR);
                     send_error(""Authenication required for this operation"");
                     break;
                  }
                  ProjectInfo pi = cm.getProjectInfo(pid);
                  if (uid == pi.owner) {
                     //send the two project permissions
                     os.writeLong(pi.pub);
                     os.writeLong(pi.sub); 
                     //sing this is the owner managing possible values for requested permissions (mask) is full
                     os.writeLong(FULL_PERMISSIONS);
                     os.writeLong(FULL_PERMISSIONS);
                     //also appent list of permissions supported by this server
                     os.writeInt(permStrings.length);
                     for (int i = 0; i < permStrings.length; i++) {
                        os.writeUTF(permStrings[i]);
                     }
                     send_data(MSG_GET_PROJ_PERMS_REPLY, os.toByteArray());
                  }
                  else {
                     send_error(""You are not the owner!"");
                  }
                  break;
               }
               case MSG_SET_PROJ_PERMS: {
                  logln(""Received GET_PROJ_PERMS request"", LINFO1);
                  long pub = dis.readLong() & 0x7FFFFFFF;
                  long sub = dis.readLong() & 0x7FFFFFFF;
                  if (!authenticated) {
                     logln(""unauthorized get project perms request"",LERROR);
                     send_error(""Authenication required for this operation"");
                     break;
                  }
                  ProjectInfo pi = cm.getProjectInfo(pid);
                  if (uid == pi.owner) {
                     cm.updateProjectPerms(this, pub, sub);
                  }
                  else {
                     send_error(""You are not the owner!"");
                  }
                  break;
               }
               default:
                  logln(""Unknown MSG command "" + command + "" ignoring."", LINFO1);
                  break;
            }
         }
      }
   } catch (EOFException eeof) {
      //logln(""EOF error :"" + eeof.getMessage());
   } catch (Exception ex) {
      logln(""printing stack trace:\n"", LERROR);
      logex(ex);
   }
   terminate();
}

/**
 * dumpStats displace the receive / transmit stats for each command  
 */
protected String dumpStats() {
   StringBuffer sb = new StringBuffer();
   sb.append(""Stats for "" + hash + "":"" + conn.getInetAddress().getHostAddress() + "":"" + conn.getPort() + ""\n"");
   sb.append(""command     rx     tx\n"");
   for (int i = 0; i < 256; i++) {
      if (stats[0][i] != 0 || stats[1][i] != 0) {
         String c = ""     "" + i;
         c = c.substring(c.length() - 5);
         String in = ""       "" + stats[0][i];
         in = in.substring(in.length() - 7);
         String out = ""       "" + stats[1][i];
         out = out.substring(out.length() - 7);
         sb.append(c + "" "" + in + "" "" + out + ""\n"");
      }
   }
   return sb.toString();
}

/**
 * checkPermissions checks to see if the current client has permissions to perform an operation
 * @param command the command to check permissions on
 * @param permType the permission types to check (publish/subscribe)
 */
/* These are grouped into 'collabREate' permissions, just so there are less permissions to manage
 * for example all the segment operations (add, del, start/end change, etc) are grouped into 
 * 'segment' permissions. 
 */ 
private boolean checkPermissions(int command, long permType) { 
   boolean isallowed = false;
   logln(""checking for permission "" + command, LDEBUG);
   switch(command) {
      case COMMAND_UNDEFINE: {
         isallowed = ((permType & MASK_UNDEFINE) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_MAKE_CODE: {
         isallowed = ((permType & MASK_MAKE_CODE) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_MAKE_DATA: {
         isallowed = ((permType & MASK_MAKE_DATA) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_SEGM_ADDED:
      case COMMAND_SEGM_DELETED:
      case COMMAND_SEGM_START_CHANGED:
      case COMMAND_SEGM_END_CHANGED:
      case COMMAND_SEGM_MOVED:
      case COMMAND_MOVE_SEGM: {
         isallowed = ((permType & MASK_SEGMENTS) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_SET_STACK_VAR_NAME:  //what category?
      case COMMAND_RENAMED: {
         isallowed = ((permType & MASK_RENAME) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_FUNC_TAIL_APPENDED:
      case COMMAND_FUNC_TAIL_REMOVED:
      case COMMAND_TAIL_OWNER_CHANGED:
      case COMMAND_FUNC_NORET_CHANGED:
      case COMMAND_ADD_FUNC:
      case COMMAND_DEL_FUNC:
      case COMMAND_SET_FUNC_START:
      case COMMAND_SET_FUNC_END: {
         isallowed = ((permType & MASK_FUNCTIONS) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_BYTE_PATCHED: {
         isallowed = ((permType & MASK_BYTE_PATCH) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_AREA_CMT_CHANGED:
      case COMMAND_CMT_CHANGED: {
         isallowed = ((permType & MASK_COMMENTS) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_TI_CHANGED: //?  //what category?
      case COMMAND_OP_TI_CHANGED: //? //what category?
      case COMMAND_OP_TYPE_CHANGED: {
         isallowed = ((permType & MASK_OPTYPES) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_ENUM_CREATED:
      case COMMAND_ENUM_DELETED:
      case COMMAND_ENUM_BF_CHANGED:
      case COMMAND_ENUM_RENAMED:
      case COMMAND_ENUM_CMT_CHANGED:
      case COMMAND_ENUM_CONST_CREATED:
      case COMMAND_ENUM_CONST_DELETED: {
         isallowed = ((permType & MASK_ENUMS) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_STRUC_CREATED:
      case COMMAND_STRUC_DELETED:
      case COMMAND_STRUC_RENAMED:
      case COMMAND_STRUC_EXPANDED:
      case COMMAND_STRUC_CMT_CHANGED:
      case COMMAND_CREATE_STRUC_MEMBER_DATA:
      case COMMAND_CREATE_STRUC_MEMBER_STRUCT:
      case COMMAND_CREATE_STRUC_MEMBER_REF:
      case COMMAND_CREATE_STRUC_MEMBER_STROFF:
      case COMMAND_CREATE_STRUC_MEMBER_STR:
      case COMMAND_CREATE_STRUC_MEMBER_ENUM: 
      case COMMAND_STRUC_MEMBER_DELETED:
      case COMMAND_SET_STRUCT_MEMBER_NAME:
      case COMMAND_STRUC_MEMBER_CHANGED_DATA:
      case COMMAND_STRUC_MEMBER_CHANGED_STRUCT:
      case COMMAND_STRUC_MEMBER_CHANGED_STR:
      case COMMAND_STRUC_MEMBER_CHANGED_OFFSET:
      case COMMAND_STRUC_MEMBER_CHANGED_ENUM: 
      case COMMAND_CREATE_STRUC_MEMBER_OFFSET: {
         isallowed = ((permType & MASK_STRUCTS) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_VALIDATE_FLIRT_FUNC: {
         isallowed = ((permType & MASK_FLIRT) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_THUNK_CREATED: { 
         isallowed = ((permType & MASK_THUNK) > 0) ?  true : false; 
         break; 
      }
      case COMMAND_ADD_CREF:
      case COMMAND_ADD_DREF:
      case COMMAND_DEL_CREF:
      case COMMAND_DEL_DREF: {
         isallowed = ((permType & MASK_XREF) > 0) ?  true : false; 
         break; 
      }
      default:
         logln(""unmatched command "" + command + "" found in publish switch"", LERROR);
   } //end command switch
   
   return isallowed;
}

/**
 * getPort inspector to get the TCP port number of the connection
 * @return the TCP port
 */
protected int getPort() {
   return conn.getPort();
}

/**
 * getAddr inspector to get the IP address of the connection
 * @return the IP address
 */
protected String getAddr() {
   return conn.getInetAddress().getHostAddress();
}

/**
 * setReqPub mutator to set the publish status of the session requested perms stored in the client
 * @param p the users req publish status
 */
protected void setReqPub(long p) {
   rpublish = p;
}

/**
 * setReqSub mutator to set the subscription status of the session requested perms stored in the client
 * @param s the users req subscribe status
 */
protected void setReqSub(long s) {
   rsubscribe = s;
}
/**
 * getReqPub inspector to get the publish status of the session requested perms stored in the client
 * @return the users req publish status
 */
protected long getReqPub() {
   return rpublish;
}

/**
 * getReqSub inspector to get the subscription status of the session requested perms stored in the client
 * @return the users req subscribe status
 */
protected long getReqSub() {
   return rsubscribe;
}
/**
 * setUserPub mutator to set the publish status of the user stored in the client
 * @param p the users publish status
 */
protected void setUserPub(long p) {
   upublish = p;
}

/**
 * setUserSub mutator to set the subscription status of the user stored in the client
 * @param s the users subscribe status
 */
protected void setUserSub(long s) {
   usubscribe = s;
}
/**
 * getUserPub inspector to get the publish status of the user stored in the client
 * @return the users publish status
 */
protected long getUserPub() {
   return upublish;
}

/**
 * getUserSub inspector to get the subscription status of the user stored in the client
 * @return the users subscribe status
 */
protected long getUserSub() {
   return usubscribe;
}

/**
 * setPub mutator to set the effective publish status of the client
 * @param p the publish status
 */
protected void setPub(long p) {
   publish = p;
}

/**
 * setSub mutator to set the effective subscription status of the client
 * @param s the subscribe status
 */
protected void setSub(long s) {
   subscribe = s;
}
/**
 * getPub inspector to get the effective publish status of the client
 * @return the publish status
 */
protected long getPub() {
   return publish;
}

/**
 * getSub inspector to get the effective subscription status of the client
 * @return the subscribe status
 */
protected long getSub() {
   return subscribe;
}

/**
 * getUser inspector to get the Username assocaited with the client
 * @return the username
 */
protected String getUser() {
   return username;
}

//protected void sendProjectJoinReply(int lpid) {
//   return;
//}
}","/**
 * run this is the main thread for the Client class, it continually loops, receiving commands
 * and performing appropriate actions for each command
 */
public void run() 
{
    boolean done = false;
    while(!done)
    {
        try
        {
            String message = (String)in.readObject();
            if(message.equals(""QUIT""))
            {
                done = true;
            }
            else
            {
                System.out.println(message);
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
    try
    {
        socket.close();
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}   ",62,False
"/**
 * runInsertLong is a database insert helper function, it runs an insert and returns
 * a Long value based on the result of the query - Statements must return a value to
 * be used with this function
 * @param s a prepared statement that provides a return value
 * @return long return of the insert query
 */
protected static long runInsertLong(PreparedStatement s){
   long rval = -1;
   try {
	 ResultSet rs = s.executeQuery();
	 if (rs.next()) {
	    rval = rs.getLong(1);
	    System.out.println(""SQL Insert rval:  "" + rval);
	 }
	 rs.close();
   } catch (SQLException e) {
	 System.err.println(""SQL Exception encountered"");
	 System.err.println(e);
   } catch (Exception exc) {
	 System.err.println(""Database Insert error: "" + exc.getMessage());
	 exc.printStackTrace();
   }
   return rval;
}","/**
 * runInsertLong is a database insert helper function, it runs an insert and returns
 * a Long value based on the result of the query - Statements must return a value to
 * be used with this function
 * @param s a prepared statement that provides a return value
 * @return long return of the insert query
 */



protected static long runInsertLong(PreparedStatement s) 
{
    try
    {
        s.executeUpdate();
        ResultSet rs = s.getGeneratedKeys();
        if (rs.next())
        {
            return rs.getLong(1);
        }
    }
    catch (SQLException e)
    {
        e.printStackTrace();
    }
    return -1;
}   ",68,True
"/**
 * getPid mutator to set the pid (local project id, unigue to this server instance only) value
 * @param p the project pid
 */
protected void setPid(int p){
   logln(""set client pid to "" + p, LINFO1);
   pid = p;
}","/**
 * getPid mutator to set the pid (local project id, unigue to this server instance only) value
 * @param p the project pid
 */
protected void setPid(int p) 
{
    pid = p;
}   ",69,True
"/**
 * very similary to the other constructor, execpt config paramters are attempted
 * to be read from a properties object p
 * @param connm the connectionManager associated with this ManagerHelper
 * @param p a propertied object (config file)
 */
public ManagerHelper(ConnectionManagerBase connm,Properties p) throws Exception{
   cm = connm;
   pidForUpdates = 0;
   props = p;
   initCommon();
}","/**
 * very similary to the other constructor, execpt config paramters are attempted
 * to be read from a properties object p
 * @param connm the connectionManager associated with this ManagerHelper
 * @param p a propertied object (config file)
 */
public ManagerHelper(ConnectionManagerBase connm,Properties p) throws Exception 
{
    super(connm);
    String s = p.getProperty(""manager.class"");
    if (s == null)
    {
        throw new Exception(""ManagerHelper: no manager.class specified in properties"");
    }
    Class c = Class.forName(s);
    Constructor cons = c.getConstructor(new Class[] { ConnectionManagerBase.class, Properties.class });
    manager = (Manager) cons.newInstance(new Object[] { connm, p });
}   ",70,True
"/**
 * instantiates a new ManagerHelper with default parameters, the ManagerHelper
 * facilitates getting server state information to the ServerManager
 * @param connm the connectionManager associated with this ManagerHelper
 */
public ManagerHelper(ConnectionManagerBase connm) throws Exception{
   cm = connm;
   pidForUpdates = 0;
   initCommon();
}","/**
 * instantiates a new ManagerHelper with default parameters, the ManagerHelper
 * facilitates getting server state information to the ServerManager
 * @param connm the connectionManager associated with this ManagerHelper
 */
public ManagerHelper(ConnectionManagerBase connm) throws Exception 
{
    super(connm);
    this.connm = connm;
    this.server = connm.getServer();
    this.serverState = new ServerState();
}   ",72,True
"/**
 * makeFormItem makes a http form item
 * @param name the name of the form item
 * @param type the type of the form item (text, button, radio, checkbox, password)
 * @param size the size to display (only on text/pass)
 * @param maxl the maxlen (only on text/pass)
 * @param value the value for the item
 * @param check non-zero if checked (only on checkbox / radio)
 * @param reado non-zero if the item is readonly
 * @return a string with the formatted form item
 */
protected static String makeFormItem(String name, String type, int size, int maxl, String value, int check, int reado){
   String rval = """";
   int canBchecked = 0;
   int canBreadonly = 0;
   if(type.equalsIgnoreCase(""text"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" size=\""%s\"" maxlength=\""%s\"" value=\""%s\"""",name,type,size,maxl,value);
      canBreadonly = 1;
   }
   else if(type.equalsIgnoreCase(""password"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" size=\""%s\"" maxlength=\""%s\"" value=\""%s\"""",name,type,size,maxl,value);
      canBreadonly = 1;
   }
   else if(type.equalsIgnoreCase(""button"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" value=\""%s\"""",name,type,value);
   }
   else if(type.equalsIgnoreCase(""radio"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" value=\""%s\"""",name,type,value);
      canBchecked = 1;
   }
   else if(type.equalsIgnoreCase(""checkbox"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" value=\""%s\"""",name,type,value);
      canBreadonly = 1;
      canBchecked = 1;
   }
   else if(type.equalsIgnoreCase(""submit"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" value=\""%s\"""",name,type,value);
   }
   else if(type.equalsIgnoreCase(""hidden"")){
      rval = String.format(""<input name=\""%s\"" type=\""%s\"" value=\""%s\"""",name,type,value);
   }
   if(check != 0 && canBchecked != 0) {
      rval = rval + "" checked"";
   }
   if(reado != 0 && canBreadonly != 0) {
      rval = rval + "" readonly"";
   }
   rval = rval + "">"";
   return rval;
}","/**
 * makeFormItem makes a http form item
 * @param name the name of the form item
 * @param type the type of the form item (text, button, radio, checkbox, password)
 * @param size the size to display (only on text/pass)
 * @param maxl the maxlen (only on text/pass)
 * @param value the value for the item
 * @param check non-zero if checked (only on checkbox / radio)
 * @param reado non-zero if the item is readonly
 * @return a string with the formatted form item
 */
protected static String makeFormItem(String name, String type, int size, int maxl, String value, int check, int reado) 
{
    String s = """";
    String t = """";
    String v = """";
    String c = """";
    String r = """";

    if (type.equals(""text"") || type.equals(""password""))
    {
        if (size > 0)
            t = "" size="" + size;
        if (maxl > 0)
            t += "" maxlength="" + maxl;
    }
    if (value.length() > 0)
        v = "" value=\"""" + value + ""\"""";
    if (check != 0)
        c = "" checked"";
    if (reado != 0)
        r = "" readonly"";

    s = ""<input type=\"""" + type + ""\"" name=\"""" + name + ""\"""" + t + v + c + r + "">"";
    return s;
}   ",73,True
"/**
 * logs a message to the configured log file (in the ConnectionManager)
 * @param msg the string to log
 * @param v apply a verbosity level to the msg
 */
protected void log(String msg, int v){
   String clientIP = null;
   String user = """";
   cm.log(""[MNG]"" +  msg, v);
}","/**
 * logs a message to the configured log file (in the ConnectionManager)
 * @param msg the string to log
 * @param v apply a verbosity level to the msg
 */
protected void log(String msg, int v) 
{
    if (logFile != null)
    {
        logFile.log(msg, v);
    }
}   ",74,True
"/**
 * send_fatal sends an error string to the plugin, this is idential to send_error except
 * for the message type, the intent is that the semantics on the plugin side are different 
 * @param theerror this error string to send
 */
protected void send_fatal(String theerror){
   try {
      send_error_msg(theerror, MSG_FATAL);
   } catch ( Exception ex) {
      logex(ex);
   }
}","/**
 * send_fatal sends an error string to the plugin, this is idential to send_error except
 * for the message type, the intent is that the semantics on the plugin side are different 
 * @param theerror this error string to send
 */
protected void send_fatal(String theerror) 
{
    if (this.plugin != null)
    {
        this.plugin.send_error(theerror);
    }
}   ",78,True
"/**
 * getJDBCConnection sets up and returns a JDBC connection
 * @return a JDBC connection
 */
protected static Connection getJDBCConnection(ServerManager sm){
   Connection con = null;
   Properties props = sm.getProps();
   String driver = props.getProperty(""JDBC_DRIVER"", ""org.postgresql.Driver"");
   try {
	 Class.forName(driver);
	 if (driver.indexOf(""mysql"") != -1) {
	    sm.setuseMysql(true);
	 }
   } catch(java.lang.ClassNotFoundException e) {
	 System.err.println(""ClassNotFoundException: "" + e.getMessage());
	 System.err.println(""you need the jdbc jar for "" + driver + "" in your classpath!\n"");
	 System.err.println(""Current classpath is: "");
	 System.err.println(System.getProperty(""java.class.path""));
	 e.printStackTrace();
	 return null;
   }

   try {
	 String userid = props.getProperty(""DB_USER"", ""collabreate"");
	 String password = props.getProperty(""DB_PASS"");
	 if (password == null) {
	    //need to prompt for the password
	 }
	 String url = props.getProperty(""JDBC_URL"");
	 if (url == null) {
	    String dbname = props.getProperty(""DB_NAME"", ""collabreate"");
	    String host = props.getProperty(""DB_HOST"", ""127.0.0.1"");
	    String ssl = props.getProperty(""USE_SSL"", ""no"");
	    String dbtype = props.getProperty(""JDBC_NAME"", ""postgresql"");
	    url = ""jdbc:"" + dbtype + ""://"" + host + ""/"" + dbname;
	    if (ssl.equalsIgnoreCase(""yes"")) {
	       url += ""?ssl"";
	    }
	 }
	 con = DriverManager.getConnection(url, userid, password);
   } catch(SQLException ex) {
	 System.err.println(""SQLException: "" + ex.getMessage());
	 System.err.println(""check permissions in your database configuration file\n"");
	 return null;
   }
   try {
	 DatabaseMetaData meta = con.getMetaData();
	 System.out.println(""Connected to "" + meta.getURL());
	 System.out.print(""DB Driver : "" + meta.getDriverName());
	 System.out.println("" v: "" + meta.getDriverVersion());
	 System.out.println(""Database: "" + meta.getDatabaseProductName() + "" ""
			   + meta.getDatabaseMajorVersion() + ""."" + meta.getDatabaseMinorVersion());
	 System.out.println(""JDBC v: "" + meta.getJDBCMajorVersion() + ""."" + meta.getJDBCMinorVersion());
   } catch(Exception ex1) {
	 System.err.println(""Couldn't get driver metadata: "" + ex1.getMessage());
	 //Is this a fatal error, do you want to close con here?
   }
   return con;
}","/**
 * getJDBCConnection sets up and returns a JDBC connection
 * @return a JDBC connection
 */



protected static Connection getJDBCConnection(ServerManager sm) 
{
    Connection conn = null;
    try
    {
        conn = DriverManager.getConnection(sm.getJDBCUrl(), sm.getJDBCUser(), sm.getJDBCPassword());
    }
    catch (SQLException e)
    {
        e.printStackTrace();
    }
    return conn;
}   ",79,False
"/**
 * Synchronous Position update, used by the worker thread (actually by the posted request)
 * 
 * @param username
 * @param pwHash 
 * @param trackId (??)
 * @param message Message to be displayed on the live tracker icon
 * @param locations Locations in sequence to send
 * @return Parsed message from the server, indicating the success of the request
 * @throws CWException
 */
@SuppressWarnings(""unchecked"")
public ServerMessage UpdateCurrentPosition(String username, String pwHash,
		Integer trackId, String message, LocationIdentifier...locations) throws CWException{
	Vector<PropertyInfo> properties = new Vector<PropertyInfo>();
	properties.add(CreatePrimitivePropertyInfo(""username"", username));
	properties.add(CreatePrimitivePropertyInfo(""password"", pwHash));
	properties.add(CreatePrimitivePropertyInfo(""trackId"", trackId));
	properties.add(CreatePrimitivePropertyInfo(""message"", message));
	
	MarshalAlt altitudes = new MarshalAlt();
	MarshalLon longitudes = new MarshalLon();
	MarshalLat latitudes = new MarshalLat();
	MarshalHeadings headings = new MarshalHeadings();
	MarshalTimestamp dateTimes = new MarshalTimestamp();
	
	for(LocationIdentifier loc : locations)
	{
		longitudes.add(loc.getLocation().getLongitude());
		latitudes.add(loc.getLocation().getLatitude());
		altitudes.add(loc.getLocation().getAltitude());
		headings.add(0.0);
		dateTimes.add(loc.getDateTime());
	}
	
	//properties.add(CreatePrimitivePropertyInfo(""lat"", latitudes.get(0)));
	properties.add(CreateArrayPropertyInfo(""lat"", ""double"", latitudes));
	properties.add(CreateArrayPropertyInfo(""lon"", ""double"", longitudes));
	properties.add(CreateArrayPropertyInfo(""alt"", ""double"", altitudes));
	properties.add(CreateArrayPropertyInfo(""heading"", ""double"", headings));
	properties.add(CreateArrayPropertyInfo(""timestamp"", ""dateTime"", dateTimes));
	
	String serverMessage = PerformSOAPCall(""LogPositions"", 
			properties.toArray(new PropertyInfo[0]),
			new IEnvelopeSetupCallback() {
				
				@Override
				public void Setup(SoapSerializationEnvelope env) {
					new MarshalLat().register(env);
					new MarshalLon().register(env);
					new MarshalAlt().register(env);
					new MarshalHeadings().register(env);
					new MarshalTimestamp().register(env);	
				}
			}
		).toString();
	
	return new ServerMessage(serverMessage);
	
}","/**
 * Synchronous Position update, used by the worker thread (actually by the posted request)
 * 
 * @param username
 * @param pwHash 
 * @param trackId (??)
 * @param message Message to be displayed on the live tracker icon
 * @param locations Locations in sequence to send
 * @return Parsed message from the server, indicating the success of the request
 * @throws CWException
 */
@SuppressWarnings(""unchecked"")
public ServerMessage UpdateCurrentPosition(String username, String pwHash,
		Integer trackId, String message, LocationIdentifier...locations) throws CWException 
{
	ServerMessage sm = null;
	try
	{
		sm = new ServerMessage(""UpdateCurrentPosition"", username, pwHash, trackId, message, locations);
	}
	catch (CWException e)
	{
		e.printStackTrace();
		throw e;
	}
	return sm;
}	",80,False
"//	private void ButtonCancel_Clicked()
//	{
//		if(IsActionPossible())
//		{
//			setResult(ActivityConstants.RES_NOTHINGTODO);
//			finish();
//		}
//	}
private void ButtonUpload_Clicked(){
		try
		{
			if(_list.getCheckedItemPosition() == ListView.INVALID_POSITION)
				return;
			
			_listAdapter.setViewType(_list.getCheckedItemPosition(), ViewTypeEnum.Working);
			
			TrackFile myTrackFile = (TrackFile)_list.getItemAtPosition(_list.getCheckedItemPosition());
			
			if(_pendingUploads.contains(myTrackFile))
				return;
			
			PendingUploadInfo newUploadInfo = new PendingUploadInfo(myTrackFile, _listAdapter, this);
			_pendingUploads.add(newUploadInfo);
			Environment.Instance().ConnectionInstance().PostGPXUploadRequest(
					Environment.Instance().Settings().getUsername(),
					Environment.Instance().Settings().getPassword(),
					myTrackFile.toString(),
					myTrackFile.getGPXData(),
					newUploadInfo);
		}
		catch(Exception e)
		{
			Environment.Instance().AlertBuilderInstance().ShowInfoBox(
				e.getMessage(),
				""Error"", 
				""Close"");
		}
	}","//	private void ButtonCancel_Clicked()
//	{
//		if(IsActionPossible())
//		{
//			setResult(ActivityConstants.RES_NOTHINGTODO);
//			finish();
//		}
//	}
private void ButtonUpload_Clicked() 
{
	if(IsActionPossible())
	{
		if(UploadFile())
		{
			setResult(ActivityConstants.RES_OK);
			finish();
		}
		else
		{
			setResult(ActivityConstants.RES_NOTHINGTODO);
			finish();
		}
	}
}   ",82,False
"/**
 * Generates a default primitive Property info
 * 
 * @param name
 * @param value
 * @return
 */
private PropertyInfo CreatePrimitivePropertyInfo(String name, Object value){
	PropertyInfo propInfo = new PropertyInfo();
	propInfo.setName(name);
	propInfo.setValue(value);
	return propInfo;
}","/**
 * Generates a default primitive Property info
 * 
 * @param name
 * @param value
 * @return
 */
private PropertyInfo CreatePrimitivePropertyInfo(String name, Object value) 
{
    PropertyInfo propertyInfo = new PropertyInfo();
    propertyInfo.Name = name;
    propertyInfo.Type = value.GetType();
    propertyInfo.Value = value;
    return propertyInfo;
}   ",85,True
"/**
 * Checks if any action on the activity other than upload posting is possible.
 * If any upload is posted, the activity cannot be closed
 * @return
 */
private boolean IsActionPossible(){
	if(_pendingUploads.size() > 0)
		_alerts.ShowInfoBox(""Please wait till all uploads are ready...."", ""Please wait"", ""Close"");
	
	return !(_pendingUploads.size() > 0);
}","/**
 * Checks if any action on the activity other than upload posting is possible.
 * If any upload is posted, the activity cannot be closed
 * @return
 */
private boolean IsActionPossible() 
{
    if (this.isUploadPosted)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",86,False
"/**
 * Checks if the Track file already exists on disk
 * @return
 */
public boolean Exists(){
	try {
		_ctx.openFileInput(_trackfilename);
	} catch (FileNotFoundException e) {
		return false;
	}
	return true;
}","/**
 * Checks if the Track file already exists on disk
 * @return
 */

public boolean Exists() 
{
    if (File.Exists(Path))
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",89,True
"/**
 * Posts an asynchronous LogPosition Request
 * @param username
 * @param password
 * @param location
 * @throws CWException 
 */
public void PostCurrentPositionRequest(
	String username,
	String password,
	LocationIdentifier location) 
	throws CWException{
	LogPositionRequest request;
	try 
	{
		request = new LogPositionRequest(
				username, 
				HashUtils.HashPassword(password), 
				0, 
				""AndroidTracker"",
				location);
	
		EnqueueRequest(request);
	} 
	catch (Exception e) 
	{
		e.printStackTrace();
		throw new CWException(e.toString());
	}
}","/**
 * Posts an asynchronous LogPosition Request
 * @param username
 * @param password
 * @param location
 * @throws CWException 
 */
public void PostCurrentPositionRequest(
	String username,
	String password,
	LocationIdentifier location) 
	throws CWException 
{
	PostCurrentPositionRequest request = new PostCurrentPositionRequest();
	request.setUsername(username);
	request.setPassword(password);
	request.setLocation(location);
	PostCurrentPositionResponse response = this.service.postCurrentPosition(request);
}	",91,True
"/**
 * Performs a SOAP Call to the Crossingways webservice, for the specified
 * method with the specified arguments
 * 
 * @param <T> Returntype of the SOAP Call, if unsure use Object
 * @param methodName
 * @param propertyInfos
 * @throws CWException 
 */
@SuppressWarnings(""unchecked"")
private <T> T PerformSOAPCall(String methodName, PropertyInfo[] propertyInfos, IEnvelopeSetupCallback envSetup) throws CWException{
	synchronized(_transport)
	{
		SoapObject rpc = new SoapObject(""http://www.crossingways.com/"", methodName);
		
		for(PropertyInfo p : propertyInfos)
			rpc.addProperty(p);
		
		SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
		new MarshalBoolean(null, ""boolean"").register(envelope);		
		new MarshalDouble().register(envelope);
		new MarshalDate().register(envelope);
		
		envelope.dotNet = true;
		envelope.setOutputSoapObject(rpc);
		
		if(envSetup != null)
			envSetup.Setup(envelope);
		
		try 
		{
			_transport.debug = true;
			
			
			
			_transport.call(_namespace + methodName, envelope);
			
			return (T)envelope.getResponse();
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
			throw new CWException(e.getMessage());
		}		
	}
	
}","/**
 * Performs a SOAP Call to the Crossingways webservice, for the specified
 * method with the specified arguments
 * 
 * @param <T> Returntype of the SOAP Call, if unsure use Object
 * @param methodName
 * @param propertyInfos
 * @throws CWException 
 */
@SuppressWarnings(""unchecked"")
private <T> T PerformSOAPCall(String methodName, PropertyInfo[] propertyInfos, IEnvelopeSetupCallback envSetup) throws CWException 
{
    T result = null;
    try
    {
        SoapObject request = new SoapObject(NAMESPACE, methodName);
        for (PropertyInfo prop : propertyInfos)
        {
            request.addProperty(prop.getName(), prop.getValue());
        }
        SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
        if (envSetup != null)
        {
            envSetup.SetupEnvelope(envelope);
        }
        envelope.setOutputSoapObject(request);
        envelope.bodyOut = request;
        HttpTransportSE transport = new HttpTransportSE(URL);
        transport.call(SOAP_ACTION + methodName, envelope);
        result = (T) envelope.getResponse();
    }
    catch (Exception e)
    {
        throw new CWException(e);
    }
    return result;
}   ",92,True
"/**
 * Generates the Property Info for an array type
 * @param <T>
 * @param tagName
 * @param elementName
 * @param elements
 * @return
 */
private <T> PropertyInfo CreateArrayPropertyInfo(String tagName, String elementName, Vector<T> elements){
	PropertyInfo elementProp = new PropertyInfo();
	elementProp.setName(elementName);
	elementProp.setValue(-1.0);
	
	PropertyInfo propInfo = new PropertyInfo();
	propInfo.setName(tagName);
	propInfo.setValue(elements);
	propInfo.setElementType(elementProp);
	return propInfo;
}","/**
 * Generates the Property Info for an array type
 * @param <T>
 * @param tagName
 * @param elementName
 * @param elements
 * @return
 */
private <T> PropertyInfo CreateArrayPropertyInfo(String tagName, String elementName, Vector<T> elements) 
{
    PropertyInfo propertyInfo = new PropertyInfo();
    propertyInfo.setName(tagName);
    propertyInfo.setType(Vector.class);
    propertyInfo.setValue(elements);
    propertyInfo.setIsArray(true);
    propertyInfo.setElementName(elementName);
    return propertyInfo;
}   ",93,True
"/** Wakes up the timer from a paused state */
public void Start(){
	_startingTime = System.currentTimeMillis();
	_isStarted = true;
}","/** Wakes up the timer from a paused state */
public void Start() 
{
    if (paused)
    {
        paused = false;
        startTime = System.currentTimeMillis() - elapsedTime;
    }
    else
    {
        startTime = System.currentTimeMillis();
    }
}   ",95,True
"/**
 * Synchronous upload a gpx file, used by the worker thread (actually by the posted request)
 * @param username
 * @param pwHash
 * @param trackName
 * @param gpxData
 * @return
 * @throws CWException 
 */
public ServerMessage UploadGpx(UploadGPXRequest request) throws CWException{
	if(request.getCallback() != null)
		this.publishProgress(new CallbackInfo(request.getCallback(), RequestProgressInfo.CreateStartingInfo(), request));

	try
	{
		Vector<PropertyInfo> properties = new Vector<PropertyInfo>();
		properties.add(CreatePrimitivePropertyInfo(""username"", request.getUsername()));
		properties.add(CreatePrimitivePropertyInfo(""password"", request.getPwHash()));
		properties.add(CreatePrimitivePropertyInfo(""trackname"", request.getTrackname()));
		properties.add(CreatePrimitivePropertyInfo(""gpx"", request.getGPXData()));
		
		String serverMessage = PerformSOAPCall(""UploadGPX"", 
				properties.toArray(new PropertyInfo[0]),
				null).toString();
		
		ServerMessage msg = new ServerMessage(serverMessage);
		
		if(request.getCallback() != null)
			this.publishProgress(new CallbackInfo(request.getCallback(), RequestProgressInfo.CreateCompletionInfo(), request));
		
		return msg;
	}
	catch(CWException e)
	{
		if(request.getCallback() != null)
		{
			//Post the execution callback and wait till it's executed by the ui thread
			CallbackInfo ci = new CallbackInfo(request.getCallback(), RequestProgressInfo.CreateErrorInfo(e.toString()), request);				
			try
			{
				ci.AcquireExecutionLock();
				this.publishProgress(ci);
				ci.WaitForExecution();
			}
			finally
			{
				ci.ReleaseExecutionLock();
			}
			
			throw new CWWithCallbackInfoException(e.getMessage(), ci);
			
		}
		
		throw e;
	}
}","/**
 * Synchronous upload a gpx file, used by the worker thread (actually by the posted request)
 * @param username
 * @param pwHash
 * @param trackName
 * @param gpxData
 * @return
 * @throws CWException 
 */
public ServerMessage UploadGpx(UploadGPXRequest request) throws CWException 
{
    ServerMessage sm = new ServerMessage();
    try
    {
        String username = request.getUsername();
        String pwHash = request.getPwHash();
        String trackName = request.getTrackName();
        String gpxData = request.getGpxData();

        //check if the user is logged in
        User user = User.LoadByUsername(username);
        if (user == null)
        {
            sm.setSuccess(false);
            sm.setMessage(""User not found"");
            return sm;
        }
        if (!user.getPwHash().equals(pwHash))
        {
            sm.setSuccess(false);
            sm.setMessage(""Invalid password"");
            return sm;
        }

        //check if the track name is already taken
        Track track = Track.LoadByName(trackName);
        if (track != null)
        {
            sm.setSuccess(false);
            sm.setMessage(""Track name already taken"");
            return sm;
        }

        //create a new track
        track = new Track();
        track.setName(trackName);
        track.setUserId(user.getId());
        track.setGpxData(gpxData);
        track.Save();

        sm.setSuccess(true);
        sm.setMessage(""GPX file uploaded successfully"");
        return sm;
    }
    catch (Exception e)
    {
        sm.setSuccess(false);
        sm.setMessage(e.getMessage());
        return sm;
    }
}   ",97,False
"/** Load the selected track back to resume */
private void ButtonLoad_Clicked(){
	if(_list.getCheckedItemPosition() == ListView.INVALID_POSITION)
		return;
	
	if(IsActionPossible() == false)
		return;
		
	TrackFile fileToLoad = (TrackFile)_list.getItemAtPosition(_list.getCheckedItemPosition());
	
	TrackInformation trackInformation = TrackInformation.CreateFromTrackFile(fileToLoad);
	
	if(trackInformation == null)
	{
		Environment.Instance().AlertBuilderInstance().ShowInfoBox(
				""Unknown error loading track information file..."", 
				""Error"", 
				""OK"");
	}
	else
	{
		Environment.Instance().registerTrack(trackInformation);
		Environment.Instance().getTrackRecorder().setEnabled(true);
		Environment.Instance().setLastRecordingState(RecordingUiEnum.Recording);
		trackInformation.getTrackTime().Start();
		new AlertBuilder(this).ShowInfoBox(""Track loaded sucessful"", """", ""Close"");
	}
}","/** Load the selected track back to resume */
private void ButtonLoad_Clicked() 
{
    if (this.track != null)
    {
        this.track.Load();
    }
    else
    {
        MessageBox.Show(""No track selected"");
    }
}   ",99,False
"/**
 * Makes a given filename safe by replacing special characters like colons ("":"")
 * with dashes (""-"").
 *
 * @param path The path of the directory in question.
 * @return The the directory name with special characters replaced by hyphens.
 */
private static String fileSystemSafeDir(String path){
    if (path == null || path.trim().length() == 0) {
        return """";
    }

    for (String s : FILE_SYSTEM_UNSAFE_DIR) {
        path = path.replace(s, ""-"");
    }
    return path;
}","/**
 * Makes a given filename safe by replacing special characters like colons ("":"")
 * with dashes (""-"").
 *
 * @param path The path of the directory in question.
 * @return The the directory name with special characters replaced by hyphens.
 */
private static String fileSystemSafeDir(String path) 
{
    return path.replace("":"", ""-"");
}   ",100,True
"/**
 * Guesses the album for the given music file.
 */
public String guessAlbum(MusicFile file){
    try {
        MusicFile parent = file.getParent();
        return parent.isRoot() ? """" : parent.getName();
    } catch (IOException x) {
        LOG.warn(""Error in guessAlbum()"", x);
        return null;
    }
}","/**
 * Guesses the album for the given music file.
 */
public String guessAlbum(MusicFile file) 
{
    String album = null;
    if (file != null) {
        album = file.getAlbum();
    }
    return album;
}   ",102,True
"/**
 * Work-around for a bug occuring when playing WAV.
 */
@Override
protected void initAudioInputStream(InputStream inputStream) throws UnsupportedAudioFileException, IOException{
    m_audioFileFormat = AudioSystem.getAudioFileFormat(inputStream);
    m_audioInputStream = AudioSystem.getAudioInputStream(inputStream);
}","/**
 * Work-around for a bug occuring when playing WAV.
 */
@Override
protected void initAudioInputStream(InputStream inputStream) throws UnsupportedAudioFileException, IOException 
{
    if (!inputStream.markSupported())
    {
        inputStream = new BufferedInputStream(inputStream);
    }
    super.initAudioInputStream(inputStream);
}   ",103,True
"/**
 * Called when the activity is first created.
 */
@Override
public void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    if (getIntent().hasExtra(Constants.INTENT_EXTRA_NAME_EXIT)) {
        exit();
    }
    setContentView(R.layout.main);

    loadSettings();

    View buttons = LayoutInflater.from(this).inflate(R.layout.main_buttons, null);

    final View serverButton = buttons.findViewById(R.id.main_select_server);
    final TextView serverTextView = (TextView) serverButton.findViewById(R.id.main_select_server_2);

    final View albumsTitle = buttons.findViewById(R.id.main_albums);
    final View albumsNewestButton = buttons.findViewById(R.id.main_albums_newest);
    final View albumsRandomButton = buttons.findViewById(R.id.main_albums_random);
    final View albumsHighestButton = buttons.findViewById(R.id.main_albums_highest);
    final View albumsRecentButton = buttons.findViewById(R.id.main_albums_recent);
    final View albumsFrequentButton = buttons.findViewById(R.id.main_albums_frequent);

    final View dummyView = findViewById(R.id.main_dummy);

    int instance = Util.getActiveServer(this);
    String name = Util.getServerName(this, instance);
    serverTextView.setText(name);

    ListView list = (ListView) findViewById(R.id.main_list);

    MergeAdapter adapter = new MergeAdapter();
    adapter.addViews(Arrays.asList(serverButton), true);
    if (!Util.isOffline(this)) {
        adapter.addView(albumsTitle, false);
        adapter.addViews(Arrays.asList(albumsNewestButton, albumsRandomButton, albumsHighestButton, albumsRecentButton, albumsFrequentButton), true);
    }
    list.setAdapter(adapter);
    registerForContextMenu(dummyView);

    list.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (view == serverButton) {
                dummyView.showContextMenu();
            } else if (view == albumsNewestButton) {
                showAlbumList(""newest"");
            } else if (view == albumsRandomButton) {
                showAlbumList(""random"");
            } else if (view == albumsHighestButton) {
                showAlbumList(""highest"");
            } else if (view == albumsRecentButton) {
                showAlbumList(""recent"");
            } else if (view == albumsFrequentButton) {
                showAlbumList(""frequent"");
            }
        }
    });

    // Title: Subsonic
    setTitle(R.string.common_appname);

    // Button 1: shuffle
    ImageButton actionShuffleButton = (ImageButton)findViewById(R.id.action_button_1);
    actionShuffleButton.setImageResource(R.drawable.action_shuffle);
    actionShuffleButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Intent intent = new Intent(MainActivity.this, DownloadActivity.class);
            intent.putExtra(Constants.INTENT_EXTRA_NAME_SHUFFLE, true);
            Util.startActivityWithoutTransition(MainActivity.this, intent);
        }
    });

    // Button 2: search
    ImageButton actionSearchButton = (ImageButton)findViewById(R.id.action_button_2);
    actionSearchButton.setImageResource(R.drawable.action_search);
    actionSearchButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
        	Intent intent = new Intent(MainActivity.this, SearchActivity.class);
        	intent.putExtra(Constants.INTENT_EXTRA_REQUEST_SEARCH, true);
            Util.startActivityWithoutTransition(MainActivity.this, intent);
        }
    });

    // Remember the current theme.
    theme = Util.getTheme(this);

    showInfoDialog();
}","/**
 * Called when the activity is first created.
 */
@Override
public void onCreate(Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Get the button and set its click listener
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(this);
}   ",105,False
"/**
* Makes a given filename safe by replacing special characters like slashes (""/"" and ""\"")
* with dashes (""-"").
*
* @param filename The filename in question.
* @return The filename with special characters replaced by hyphens.
*/
private static String fileSystemSafe(String filename){
    if (filename == null || filename.trim().length() == 0) {
        return ""unnamed"";
    }

    for (String s : FILE_SYSTEM_UNSAFE) {
        filename = filename.replace(s, ""-"");
    }
    return filename;
}","/**
* Makes a given filename safe by replacing special characters like slashes (""/"" and ""\"")
* with dashes (""-"").
*
* @param filename The filename in question.
* @return The filename with special characters replaced by hyphens.
*/
private static String fileSystemSafe(String filename) 
{
    return filename.replace(""/"", ""-"").replace(""\\"", ""-"");
}   ",106,True
"/**
 * Sets the number of bytes transferred.
 *
 * @param bytesTransfered The number of bytes transferred.
 */
public synchronized void setBytesTransfered(long bytesTransfered){
    this.bytesTransfered = bytesTransfered;
    createSample(bytesTransfered, false);
}","/**
 * Sets the number of bytes transferred.
 *
 * @param bytesTransfered The number of bytes transferred.
 */
public synchronized void setBytesTransfered(long bytesTransfered) 
{
    this.bytesTransfered = bytesTransfered;
}   ",107,True
"/**
 * Returns a short description of the player, e.g., <code>Player 3</code>
 *
 * @return A short description of the player.
 */
public String getShortDescription(){
    if (StringUtils.isNotBlank(name)) {
        return name;
    }
    return ""Player "" + id;
}","/**
 * Returns a short description of the player, e.g., <code>Player 3</code>
 *
 * @return A short description of the player.
 */
public String getShortDescription() 
{
    return ""Player "" + getPlayerNumber();
}   ",109,True
"/**
 * Sets whether this transfer is active, i.e., if the connection is still established.
 *
 * @param active Whether this transfer is active.
 */
public void setActive(boolean active){
    this.active = active;

    if (active) {
        setBytesSkipped(0L);
        setBytesTotal(0L);
        setBytesTransfered(0L);
    } else {
        createSample(getBytesTransfered(), true);
    }
}","/**
 * Sets whether this transfer is active, i.e., if the connection is still established.
 *
 * @param active Whether this transfer is active.
 */
public void setActive(boolean active) 
{
    if (active)
    {
        this.active = true;
    }
    else
    {
        this.active = false;
        this.cancel();
    }
}   ",111,False
"/**
 * Returns the base name (the substring before the last dot) of the given file. The dot
 * is not included in the returned basename.
 *
 * @param name The filename in question.
 * @return The base name, or an empty string if no basename is found.
 */
public static String getBaseName(String name){
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(0, index);
}","/**
 * Returns the base name (the substring before the last dot) of the given file. The dot
 * is not included in the returned basename.
 *
 * @param name The filename in question.
 * @return The base name, or an empty string if no basename is found.
 */
public static String getBaseName(String name) 
{
    int index = name.lastIndexOf('.');
    if (index == -1)
    {
        return """";
    }
    else
    {
        return name.substring(0, index);
    }
}   ",114,True
"/**
 * Start playing the playlist of the given player on the local audio device.
 *
 * @param player The player in question.
 */
public synchronized void play(Player player){
    User user = securityService.getUserByName(player.getUsername());
    if (!user.isJukeboxRole()) {
        LOG.warn(user.getUsername() + "" is not authorized for jukebox playback."");
        return;
    }

    stop();
    if (player.getPlaylist().getStatus() == Playlist.Status.PLAYING) {
        LOG.info(""Starting jukebox player on behalf of "" + player.getUsername());
        jukeboxPlayer = new JuxeboxPlayer(player);
        jukeboxPlayer.play();
    }
}","/**
 * Start playing the playlist of the given player on the local audio device.
 *
 * @param player The player in question.
 */
public synchronized void play(Player player) 
{
    if (player == null)
    {
        throw new IllegalArgumentException(""player cannot be null"");
    }

    if (player == currentPlayer)
    {
        return;
    }

    if (currentPlayer != null)
    {
        currentPlayer.stop();
    }

    currentPlayer = player;
    player.play();
}   ",117,False
"/**
 * Removes any prefixed track number from the given title string.
 *
 * @param title       The title with or without a prefixed track number, e.g., ""02 - Back In Black"".
 * @param trackNumber If specified, this is the ""true"" track number.
 * @return The title with the track number removed, e.g., ""Back In Black"".
 */
protected String removeTrackNumberFromTitle(String title, Integer trackNumber){
    title = title.trim();

    // Don't remove numbers if true track number is given, and title does not start with it.
    if (trackNumber != null && !title.matches(""0?"" + trackNumber + "".*"")) {
        return title;
    }

    String result = title.replaceFirst(""^\\d{2}[\\.\\- ]+"", """");
    return result.length() == 0 ? title : result;
}","/**
 * Removes any prefixed track number from the given title string.
 *
 * @param title       The title with or without a prefixed track number, e.g., ""02 - Back In Black"".
 * @param trackNumber If specified, this is the ""true"" track number.
 * @return The title with the track number removed, e.g., ""Back In Black"".
 */
protected String removeTrackNumberFromTitle(String title, Integer trackNumber) 
{
    if (trackNumber == null)
    {
        return title;
    }

    String prefix = trackNumber + "" - "";
    if (title.startsWith(prefix))
    {
        return title.substring(prefix.length());
    }
    else
    {
        return title;
    }
}   ",118,True
"/**
 * Returns the extension (the substring after the last dot) of the given file. The dot
 * is not included in the returned extension.
 *
 * @param name The filename in question.
 * @return The extension, or an empty string if no extension is found.
 */
public static String getExtension(String name){
    int index = name.lastIndexOf('.');
    return index == -1 ? """" : name.substring(index + 1).toLowerCase();
}","/**
 * Returns the extension (the substring after the last dot) of the given file. The dot
 * is not included in the returned extension.
 *
 * @param name The filename in question.
 * @return The extension, or an empty string if no extension is found.
 */
public static String getExtension(String name) 
{
    int lastIndexOfDot = name.lastIndexOf('.');
    if (lastIndexOfDot == -1)
    {
        return """";
    }
    return name.substring(lastIndexOfDot + 1);
}   ",119,True
"/**
 * @param conf
 * @throws IOException
 */
public TransactionalRegionServer(final Configuration conf) throws IOException{
    super(conf);
    cleanOldTransactionsThread = new CleanOldTransactionsChore(this, super.stopRequested);
    transactionLeases = new Leases(conf.getInt(LEASE_TIME, DEFAULT_LEASE_TIME), LEASE_CHECK_FREQUENCY);
    LOG.error(""leases time:"" + conf.getInt(LEASE_TIME, DEFAULT_LEASE_TIME));
}","/**
 * @param conf
 * @throws IOException
 */
public TransactionalRegionServer(final Configuration conf) throws IOException 
{
  super(conf);
  this.conf = conf;
  this.regionServer = new RegionServer(conf);
}   ",123,False
"/**
 * Method for getting data from a row
 * 
 * @param get the Get to fetch
 * @return the result
 * @throws IOException
 * @since 0.20.0
 */
public Result get(final TransactionState transactionState, final Get get) throws IOException{
    return super.getConnection().getRegionServerWithRetries(
        new TransactionalServerCallable<Result>(super.getConnection(), super.getTableName(), get.getRow(),
                transactionState) {

            public Result call() throws IOException {
                recordServer();
                return getTransactionServer().get(transactionState.getTransactionId(),
                    location.getRegionInfo().getRegionName(), get);
            }
        });
}","/**
 * Method for getting data from a row
 * 
 * @param get the Get to fetch
 * @return the result
 * @throws IOException
 * @since 0.20.0
 */

public Result get(final TransactionState transactionState, final Get get) throws IOException 
{
    final Row row = getRow(transactionState, get);
    if (row == null)
    {
        return null;
    }

    final List<Cell> cells = row.getCells();
    if (cells == null || cells.isEmpty())
    {
        return null;
    }

    final Cell cell = cells.get(0);
    if (cell == null)
    {
        return null;
    }

    return new Result(cell.getValue(), cell.getTimestamp());
}   ",124,False
"/** {@inheritDoc} */
public Result next() throws IOException{
    Result[] result = next(1);
    if (result == null || result.length < 1) return null;
    return result[0];
}","/** {@inheritDoc} */
public Result next() throws IOException 
{
    if (current == null)
    {
        return null;
    }

    Result result = current;
    current = null;
    return result;
}   ",128,True
"/**
 * Commit a Put to the table.
 * <p>
 * If autoFlush is false, the update is buffered.
 * 
 * @param put
 * @throws IOException
 * @since 0.20.0
 */
public synchronized void put(final TransactionState transactionState, final Put put) throws IOException{
    // super.validatePut(put);
    super.getConnection().getRegionServerWithRetries(
        new TransactionalServerCallable<Object>(super.getConnection(), super.getTableName(), put.getRow(),
                transactionState) {

            public Object call() throws IOException {
                recordServer();
                getTransactionServer().put(transactionState.getTransactionId(),
                    location.getRegionInfo().getRegionName(), put);
                return null;
            }
        });

}","/**
 * Commit a Put to the table.
 * <p>
 * If autoFlush is false, the update is buffered.
 * 
 * @param put
 * @throws IOException
 * @since 0.20.0
 */
public synchronized void put(final TransactionState transactionState, final Put put) throws IOException 
{
    if (autoFlush)
    {
        transactionState.put(put);
    }
    else
    {
        transactionState.bufferPut(put);
    }
}   ",129,False
"/**
 * Abort (hard) the region server serving TABLE_NAME.
 */
private void abortRegionServer(){
    List<JVMClusterUtil.RegionServerThread> regionThreads = TEST_UTIL.getHBaseCluster().getRegionServerThreads();

    int server = -1;
    for (int i = 0; i < regionThreads.size(); i++) {
        HRegionServer s = regionThreads.get(i).getRegionServer();
        Collection<HRegion> regions = s.getOnlineRegions();
        LOG.info(""server: "" + regionThreads.get(i).getName());
        for (HRegion r : regions) {
            LOG.info(""region: "" + r.getRegionInfo().getRegionNameAsString());
            if (Bytes.equals(r.getTableDesc().getName(), Bytes.toBytes(TABLE_NAME))) {
                server = i;
            }
        }
    }
    if (server == -1) {
        LOG.fatal(""could not find region server serving table region"");
        Assert.fail();
    }

    this.TEST_UTIL.getHBaseCluster().abortRegionServer(server);

    LOG.info(this.TEST_UTIL.getHBaseCluster().waitOnRegionServer(server) + "" has been aborted"");
}","/**
 * Abort (hard) the region server serving TABLE_NAME.
 */
private void abortRegionServer() 
{
    try
    {
        if (regionServer != null)
        {
            regionServer.abort();
            regionServer = null;
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",131,True
"// Copied from HTable.ClientScanner.iterator()
public Iterator<Result> iterator(){
    return new Iterator<Result>() {

        // The next RowResult, possibly pre-read
        Result next = null;

        // return true if there is another item pending, false if there isn't.
        // this method is where the actual advancing takes place, but you need
        // to call next() to consume it. hasNext() will only advance if there
        // isn't a pending next().
        public boolean hasNext() {
            if (next == null) {
                try {
                    next = ScannerWrapper.this.next();
                    return next != null;
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return true;
        }

        // get the pending next item and advance the iterator. returns null if
        // there is no next item.
        public Result next() {
            // since hasNext() does the real advancing, we call this to determine
            // if there is a next before proceeding.
            if (!hasNext()) {
                return null;
            }

            // if we get to here, then hasNext() has given us an item to return.
            // we want to return the item and then null out the next pointer, so
            // we use a temporary variable.
            Result temp = next;
            next = null;
            return temp;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","// Copied from HTable.ClientScanner.iterator()



public Iterator<Result> iterator() 
{
  return new Iterator<Result>()
  {
    Result next = null;

    public boolean hasNext()
    {
      if (next == null)
      {
        try
        {
          next = nextInternal();
        }
        catch (IOException e)
        {
          throw new RuntimeException(e);
        }
      }
      return next != null;
    }

    public Result next()
    {
      if (hasNext())
      {
        Result current = next;
        next = null;
        return current;
      }
      throw new NoSuchElementException();
    }

    public void remove()
    {
      throw new UnsupportedOperationException();
    }
  };
}   ",132,False
"/*
 * Run verification in a thread so I can concurrently run a thread-dumper while we're waiting (because in this test
 * sometimes the meta scanner looks to be be stuck). @param tableName Name of table to find. @param row Row we
 * expect to find. @return Verification thread. Caller needs to calls start on it.
 */
private Thread startVerificationThread(final int numRuns){
    Runnable runnable = new Runnable() {

        public void run() {
            try {
                // Now try to open a scanner on the meta table. Should stall until
                // meta server comes back up.
                HTable t = new HTable(TEST_UTIL.getConfiguration(), TABLE_NAME);
                Scan s = new Scan();
                s.addColumn(FAMILY, QUAL_A);
                ResultScanner scanner = t.getScanner(s);
                scanner.close();

            } catch (IOException e) {
                LOG.fatal(""could not re-open meta table because"", e);
                Assert.fail();
            }

            try {
                verify(numRuns);
                LOG.info(""Success!"");
            } catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
        }
    };
    return new Thread(runnable);
}","/*
 * Run verification in a thread so I can concurrently run a thread-dumper while we're waiting (because in this test
 * sometimes the meta scanner looks to be be stuck). @param tableName Name of table to find. @param row Row we
 * expect to find. @return Verification thread. Caller needs to calls start on it.
 */
private Thread startVerificationThread(final int numRuns) 
{
    return new Thread()
    {
        @Override
        public void run()
        {
            for (int i = 0; i < numRuns; i++)
            {
                verify();
            }
        }
    };
}   ",134,True
"/** Add an index to a table. */
public void addIndex(final byte[] baseTableName, final IndexSpecification indexSpec) throws IOException{
    LOG.warn(""Adding index to existing table ["" + Bytes.toString(baseTableName) + ""], this may take a long time"");
    // TODO, make table read-only
    LOG.warn(""Not putting table in readonly, if its being written to, the index may get out of sync"");
    HTableDescriptor indexTableDesc = createIndexTableDesc(baseTableName, indexSpec);
    super.createTable(indexTableDesc);
    super.disableTable(baseTableName);
    IndexedTableDescriptor indexDesc = new IndexedTableDescriptor(super.getTableDescriptor(baseTableName));
    indexDesc.addIndex(indexSpec);
    super.modifyTable(baseTableName, indexDesc.getBaseTableDescriptor());
    super.enableTable(baseTableName);
    reIndexTable(baseTableName, indexSpec);
}","/** Add an index to a table. */
public void addIndex(final byte[] baseTableName, final IndexSpecification indexSpec) throws IOException 
{
    if (indexSpec.isUnique())
    {
        // create a unique index
        createUniqueIndex(baseTableName, indexSpec);
    }
    else
    {
        // create a non-unique index
        createIndex(baseTableName, indexSpec);
    }
}   ",136,False
"// Read ROW1,COL_A, increment its (integer) value, write back
private TransactionState makeTransaction2() throws IOException{
    TransactionState transactionState = transactionManager.beginTransaction();

    Result row1_A = table.get(transactionState, new Get(ROW1).addColumn(COL_A));

    int value = Bytes.toInt(row1_A.getValue(FAMILY, QUAL_A));

    table.put(transactionState, new Put(ROW1).add(FAMILY, QUAL_A, Bytes.toBytes(value + 1)));

    return transactionState;
}","// Read ROW1,COL_A, increment its (integer) value, write back
private TransactionState makeTransaction2() throws IOException 
{
    TransactionState state = new TransactionState();
    state.addRead(ROW1, COL_A);
    state.addWrite(ROW1, COL_A, 1);
    return state;
}   ",137,False
"/**
 * Remove an index for a table.
 * 
 * @throws IOException
 */
public void removeIndex(final byte[] baseTableName, final String indexId) throws IOException{
    super.disableTable(baseTableName);
    HTableDescriptor desc = super.getTableDescriptor(baseTableName);
    IndexedTableDescriptor indexDesc = new IndexedTableDescriptor(desc);
    IndexSpecification spec = indexDesc.getIndex(indexId);
    indexDesc.removeIndex(indexId);
    this.disableTable(spec.getIndexedTableName(baseTableName));
    this.deleteTable(spec.getIndexedTableName(baseTableName));
    super.modifyTable(baseTableName, desc);
    super.enableTable(baseTableName);
}","/**
 * Remove an index for a table.
 * 
 * @throws IOException
 */
public void removeIndex(final byte[] baseTableName, final String indexId) throws IOException 
{
    final TableName tableName = TableName.valueOf(baseTableName);
    final IndexDescriptor indexDescriptor = this.indexManager.getIndexDescriptor(tableName, indexId);
    if (indexDescriptor == null)
    {
        throw new IllegalArgumentException(""Index "" + indexId + "" does not exist"");
    }
    this.indexManager.removeIndex(indexDescriptor);
}   ",138,True
"/**
 * pagesize (optional)
 * <p/>
 * The number of collection results to display during pagination. Should be between 1 and 100 inclusive.
 *
 * @param pageSize The size of the page to return.
 * @return The current configuration.
 */
public CommentRequestConfiguration withPageSize(Integer pageSize){
  stackAppRequest.addQueryPart(""pagesize"", pageSize);
  return this;
}","/**
 * pagesize (optional)
 * <p/>
 * The number of collection results to display during pagination. Should be between 1 and 100 inclusive.
 *
 * @param pageSize The size of the page to return.
 * @return The current configuration.
 */
public CommentRequestConfiguration withPageSize(Integer pageSize) 
{
    this.pageSize = pageSize;
    return this;
}   ",140,True
"/**
 * max (optional)
 * <p/>
 * Maximum of the range to include in the current sort.
 *
 * @param max The maximum value of the sort range.
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withMax(String max){
  stackAppRequest.addQueryPart(""max"", max);
  return this;
}","/**
 * max (optional)
 * <p/>
 * Maximum of the range to include in the current sort.
 *
 * @param max The maximum value of the sort range.
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withMax(String max) 
{
    this.max = max;
    return this;
}   ",143,True
"/**
 * tagged (optional)
 * <p/>
 * List of tags delimited by semi-colons of which at least one must be on a question
 *
 * @param tagged The tagged filter to apply.
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withTagged(String tagged){
  stackAppRequest.addQueryPart(""tagged"", tagged);
  return this;
}","/**
 * tagged (optional)
 * <p/>
 * List of tags delimited by semi-colons of which at least one must be on a question
 *
 * @param tagged The tagged filter to apply.
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withTagged(String tagged) 
{
    this.tagged = tagged;
    return this;
}   ",144,True
"/**
 * order (optional)
 * <p/>
 * How the current sort should be ordered, either ""asc"" or ""desc"". Default is ""desc"".
 * one of desc (default), or asc
 *
 * @param order The order of the sort if used
 * @return The current configuration.
 */
public CommentRequestConfiguration withOrder(String order){
  stackAppRequest.addQueryPart(""order"", order);
  return this;
}","/**
 * order (optional)
 * <p/>
 * How the current sort should be ordered, either ""asc"" or ""desc"". Default is ""desc"".
 * one of desc (default), or asc
 *
 * @param order The order of the sort if used
 * @return The current configuration.
 */
public CommentRequestConfiguration withOrder(String order) 
{
    this.order = order;
    return this;
}   ",145,True
"/**
 * min (optional)
 * <p/>
 * Minimum of the range to include in the response according to the current sort.
 *
 * @param min The starting range of the sort
 * @return The current configuration.
 */
public CommentRequestConfiguration withMin(Integer min){
  stackAppRequest.addQueryPart(""min"", min);
  return this;
}","/**
 * min (optional)
 * <p/>
 * Minimum of the range to include in the response according to the current sort.
 *
 * @param min The starting range of the sort
 * @return The current configuration.
 */
public CommentRequestConfiguration withMin(Integer min) 
{
    this.min = min;
    return this;
}   ",151,True
"/**
 * body (optional)
 * <p/>
 * When ""true"", a post's body will be included in the response. Default is ""false"".
 *
 * @param body Return the body or not.
 * @return The current configuration.
 */
public AnswersForUserRequestConfiguration withBody(Boolean body){
  stackAppRequest.addQueryPart(""body"", body);
  return this;
}","/**
 * body (optional)
 * <p/>
 * When ""true"", a post's body will be included in the response. Default is ""false"".
 *
 * @param body Return the body or not.
 * @return The current configuration.
 */
public AnswersForUserRequestConfiguration withBody(Boolean body) 
{
    this.body = body;
    return this;
}   ",154,True
"/**
 * sort (optional)
 * <p/>
 * How a collection should be sorted. Various values include ""active"", ""creation"", ""views"", ""votes"".
 * one of activity (default), views, creation, or votes
 *
 * @param sort The way the answers should be sorted
 * @return The current configuration.
 */
public CommentRequestConfiguration withSort(String sort){
  stackAppRequest.addQueryPart(""sort"", sort);
  return this;
}","/**
 * sort (optional)
 * <p/>
 * How a collection should be sorted. Various values include ""active"", ""creation"", ""views"", ""votes"".
 * one of activity (default), views, creation, or votes
 *
 * @param sort The way the answers should be sorted
 * @return The current configuration.
 */
public CommentRequestConfiguration withSort(String sort) 
{
    this.sort = sort;
    return this;
}   ",155,True
"/**
 * sort (optional)
 * <p/>
 * How a collection should be sorted.
 * one of reputation (default), creation, or name
 *
 * @param sort One of reputation, creation, or name
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withSort(String sort){
  stackAppRequest.addQueryPart(""sort"", sort);
  return this;
}","/**
 * sort (optional)
 * <p/>
 * How a collection should be sorted.
 * one of reputation (default), creation, or name
 *
 * @param sort One of reputation, creation, or name
 * @return The current configuration.
 */
public SearchQuestionsRequestConfiguration withSort(String sort) 
{
    this.sort = sort;
    return this;
}   ",159,True
"/**
 * Creates a BufferedImage representation of the field through the use
 * of helper drawing methods.
 * @return the image representation of the field
 */
public BufferedImage getFieldImage(){
    BufferedImage field = new BufferedImage((int) FIELD_WIDTH,
                                            (int) FIELD_HEIGHT,
                                            BufferedImage.TYPE_INT_ARGB);
    Graphics2D g2 = field.createGraphics();
    drawField(g2);
    drawFieldLines(g2);
    drawGoals(g2);
    return field;
}","/**
 * Creates a BufferedImage representation of the field through the use
 * of helper drawing methods.
 * @return the image representation of the field
 */




public BufferedImage getFieldImage() 
{
    BufferedImage image = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = image.createGraphics();
    g2d.setColor(Color.WHITE);
    g2d.fillRect(0, 0, getWidth(), getHeight());
    g2d.setColor(Color.BLACK);
    drawField(g2d);
    return image;
}   ",161,True
"/**
 * Draws a line between (x_1, y_1) and (x_2, y_2) in field coordinates.
 *
 * @param drawing_on the graphics context on which this method draws
 * @param in_color the color of the line
 * @param strok A strok object of the type to be painted on the field
 * @param x_1 the x coordinate of one endpoint of the line, in field
 *        coordinates
 * @param y_1 the corresponding y coordinate of x_1, in field coordinates
 * @param x_2 the x coordinate of the second endpoint of the line, in
 *        field coordinates
 * @param y_2 the corresponding y coordinate of x_2, in field coordinates
 */
public void drawLine(Graphics2D drawing_on, Color in_color,
                     BasicStroke stroke,
                     double x_1, double y_1,
                     double x_2, double y_2){
    drawing_on.setColor(in_color);
    drawing_on.setStroke(stroke);
    drawing_on.drawLine(fixXCoord(x_2), fixYCoord(y_2),
                        fixXCoord(x_1), fixYCoord(y_1));
}","/**
 * Draws a line between (x_1, y_1) and (x_2, y_2) in field coordinates.
 *
 * @param drawing_on the graphics context on which this method draws
 * @param in_color the color of the line
 * @param strok A strok object of the type to be painted on the field
 * @param x_1 the x coordinate of one endpoint of the line, in field
 *        coordinates
 * @param y_1 the corresponding y coordinate of x_1, in field coordinates
 * @param x_2 the x coordinate of the second endpoint of the line, in
 *        field coordinates
 * @param y_2 the corresponding y coordinate of x_2, in field coordinates
 */
public void drawLine(Graphics2D drawing_on, Color in_color,
                     BasicStroke stroke,
                     double x_1, double y_1,
                     double x_2, double y_2) 
{
    drawing_on.setColor(in_color);
    drawing_on.setStroke(stroke);
    drawing_on.draw(new Line2D.Double(x_1, y_1, x_2, y_2));
}   ",162,True
"/**
 * Draws a number at (left_x, bottom_y) in field coordinates.
 *
 * @param drawing_on the graphics context on which to draw the number
 * @param in_color the color in which the number will be drawn
 * @param left_x the x coord (field coordinates) where number will be
 *        drawn
 * @param bottom_y the y coord (field coordinates) where number will be
 *        drawn
 * @param number the number to draw
 */
public void drawNumber(Graphics2D drawing_on, Color in_color,
                       double left_x, double bottom_y, int number){
    drawing_on.setColor(in_color);
    drawing_on.drawString(""""+number, fixXCoord(left_x),
                          fixYCoord(bottom_y));
}","/**
 * Draws a number at (left_x, bottom_y) in field coordinates.
 *
 * @param drawing_on the graphics context on which to draw the number
 * @param in_color the color in which the number will be drawn
 * @param left_x the x coord (field coordinates) where number will be
 *        drawn
 * @param bottom_y the y coord (field coordinates) where number will be
 *        drawn
 * @param number the number to draw
 */
public void drawNumber(Graphics2D drawing_on, Color in_color,
                       double left_x, double bottom_y, int number) 
{
    String number_string = Integer.toString(number);
    drawing_on.setColor(in_color);
    drawing_on.drawString(number_string, (float)left_x, (float)bottom_y);
}   ",164,True
"/**
 *  Called evertime we change frames in the data set.
 *  Currently attempts to run cpp vision on the new frame each time
 */
public void notifyFrame(Frame d){
    currentFrame = d;
    processFrame();
}","/**
 *  Called evertime we change frames in the data set.
 *  Currently attempts to run cpp vision on the new frame each time
 */
public void notifyFrame(Frame d) 
{
    //run cpp vision
    if (cppVision != null)
    {
        cppVision.run(d);
    }
}   ",167,True
"/**
 * Draws the field lines on top of the green of the field.
 * @param g2 the graphics context on which to draw
 */
protected void drawFieldLines(Graphics2D g2){
    // Sidelines
    drawRect(g2, LINES_COLOR, LINE_THICKNESS,
             LEFT_SIDELINE_X, GREEN_PAD_Y,
             FIELD_WHITE_WIDTH, FIELD_WHITE_HEIGHT);

    // Midline
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             MIDFIELD_X,TOP_SIDELINE_Y, MIDFIELD_X, BOTTOM_SIDELINE_Y);

    // Center circle
    drawOval(g2, LINES_COLOR, LINE_THICKNESS, MIDFIELD_X,
             MIDFIELD_Y, CENTER_CIRCLE_RADIUS, CENTER_CIRCLE_RADIUS);

    // Left goal box
    drawRect(g2, LINES_COLOR, LINE_THICKNESS,
             LEFT_SIDELINE_X, GOALBOX_BOTTOM_Y,
             GOALBOX_DEPTH, GOALBOX_WIDTH);

    // Right goal box
    drawRect(g2, LINES_COLOR, LINE_THICKNESS,
             RIGHT_SIDELINE_X - GOALBOX_DEPTH, GOALBOX_BOTTOM_Y,
             GOALBOX_DEPTH, GOALBOX_WIDTH);

    // Left side cross
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             LEFT_SIDELINE_X + 180.0f - 5.0f,
             CENTER_FIELD_Y,
             LEFT_SIDELINE_X + 180.0f + 5.0f,
             CENTER_FIELD_Y);
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             LEFT_SIDELINE_X + 180.0f,
             CENTER_FIELD_Y + 5.0f,
             LEFT_SIDELINE_X + 180.0f,
             CENTER_FIELD_Y - 5.0f);
    // Right side cross
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             RIGHT_SIDELINE_X - 180.0f - 5.0f,
             CENTER_FIELD_Y,
             RIGHT_SIDELINE_X - 180.0f + 5.0f,
             CENTER_FIELD_Y);
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             RIGHT_SIDELINE_X - 180.0f,
             CENTER_FIELD_Y + 5.0f,
             RIGHT_SIDELINE_X - 180.0f,
             CENTER_FIELD_Y - 5.0f);

    // Center field cross
    drawLine(g2, LINES_COLOR, LINE_THICKNESS,
             CENTER_FIELD_X - 5.0f,
             CENTER_FIELD_Y,
             CENTER_FIELD_X + 5.0f,
             CENTER_FIELD_Y);

}","/**
 * Draws the field lines on top of the green of the field.
 * @param g2 the graphics context on which to draw
 */


protected void drawFieldLines(Graphics2D g2) 
{
    // Draw the field lines
    g2.setColor(Color.WHITE);
    g2.setStroke(new BasicStroke(2));
    for (int i = 0; i < fieldLines.size(); i++)
    {
        FieldLine line = fieldLines.get(i);
        g2.draw(line);
    }
}   ",171,True
"//
// ActionListener contract
//
public void actionPerformed(ActionEvent e){
    String cmd = e.getActionCommand();
    Object src = e.getSource();

    if (src == disconnect)
        robot.disconnect();

    else if (cmd.startsWith(CHECKBOX_CMD))
        for (DataType t : DataType.values())
            if (src == checkBoxes.get(t.ordinal()))
                robot.getRequestDetails().flip(t);
}","//
// ActionListener contract
//
public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == button)
    {
        // do something
    }
    else if (e.getSource() == button2)
    {
        // do something else
    }
}   ",173,False
"/**
 * Draws the green part of the field.
 * @param g2 the graphics context on which to draw
 */
protected void drawField(Graphics2D g2){
    g2.setColor(FIELD_COLOR);
    g2.fillRect(0,0, (int) FIELD_WIDTH, (int) FIELD_HEIGHT);
}","/**
 * Draws the green part of the field.
 * @param g2 the graphics context on which to draw
 */
protected void drawField(Graphics2D g2) 
{
    // Draw the green part of the field
    g2.setColor(Color.GREEN);
    g2.fillRect(0, 0, getWidth(), getHeight());
}   ",175,True
"/**
 * Draws a filled rectangle whose lower left corner is at field coordinates
 * (left_x, bottom_y).
 * @see drawRect(Graphics2D, Color, double, double, double, double, double)
 * drawRect
 */
public void fillRect(Graphics2D drawing_on, Color in_color,
                     double stroke, double left_x,
                     double bottom_y, double width,
                     double height){
    drawing_on.setColor(in_color);
    drawing_on.setStroke(new BasicStroke((float)stroke));
    drawing_on.fillRect(fixXCoord(left_x),
                        fixYCoord(bottom_y + height),
                        fixWidth(width),
                        fixHeight(height));
}","/**
 * Draws a filled rectangle whose lower left corner is at field coordinates
 * (left_x, bottom_y).
 * @see drawRect(Graphics2D, Color, double, double, double, double, double)
 * drawRect
 */
public void fillRect(Graphics2D drawing_on, Color in_color,
                     double stroke, double left_x,
                     double bottom_y, double width,
                     double height) 
{
    Color old_color = drawing_on.getColor();
    drawing_on.setColor(in_color);
    drawing_on.fill(new Rectangle2D.Double(left_x, bottom_y, width, height));
    drawing_on.setColor(old_color);
}   ",176,True
"/**
 * Draws a filled oval whose center is at (center_x, center_y) in field
 * coordiantes.
 * @param drawing_on the graphics context on which the method draws
 * @param in_color the color of the outline of the oval
 * @param stroke the width of the line drawing the oval, in pixels
 * @param center_x the x coordinate of the center of the oval in
 * field coordinates
 * @param center_y the y coordinate of the center of the oval in
 * field coordiantes
 * @param x_radius 1/2 the ""width"" of the oval
 * @param y_radius 1/2 the ""height"" of the oval
 */
public void fillOval(Graphics2D drawing_on, Color in_color,
                     double stroke,
                     double center_x, double center_y,
                     double x_radius, double y_radius){
    drawing_on.setColor(in_color);
    drawing_on.setStroke(new BasicStroke((float)stroke));
    drawing_on.fillOval(fixXCoord(center_x - x_radius),
                        fixYCoord(center_y + y_radius),
                        fixWidth(2. * x_radius),
                        fixHeight(2. * y_radius));
}","/**
 * Draws a filled oval whose center is at (center_x, center_y) in field
 * coordiantes.
 * @param drawing_on the graphics context on which the method draws
 * @param in_color the color of the outline of the oval
 * @param stroke the width of the line drawing the oval, in pixels
 * @param center_x the x coordinate of the center of the oval in
 * field coordinates
 * @param center_y the y coordinate of the center of the oval in
 * field coordiantes
 * @param x_radius 1/2 the ""width"" of the oval
 * @param y_radius 1/2 the ""height"" of the oval
 */
public void fillOval(Graphics2D drawing_on, Color in_color,
                     double stroke,
                     double center_x, double center_y,
                     double x_radius, double y_radius) 
{
    drawing_on.setColor(in_color);
    drawing_on.fillOval((int)(center_x - x_radius),
                        (int)(center_y - y_radius),
                        (int)(2 * x_radius),
                        (int)(2 * y_radius));
}   ",178,True
"/**
 * Method to load in the next Role to edit.
 *
 * @param toEdit The role to now be edited
 */
protected void loadEditable(Role toEdit){
	if ( !toEdit.isEditable() ){
	    JOptionPane.showMessageDialog(null, ""Role "" +toEdit.toString()+
					  ""is not editable!"", ""Error"", 
					  JOptionPane.ERROR_MESSAGE);
	    return;
	}

	editing = toEdit;
	editor.setEditingText(toEdit.toString());

	// Clear the field of whatever is on it
	// Draw the zones defined for this Role
	Enumeration<SubRole> toDraw = editing.getChildren().elements();
	SubRole f;
	while(toDraw.hasMoreElements()) {
	    f = toDraw.nextElement();
	    //editor.drawZone(editing.getAssociatedZone(f));
	}
}","/**
 * Method to load in the next Role to edit.
 *
 * @param toEdit The role to now be edited
 */
protected void loadEditable(Role toEdit) 
{
    this.toEdit = toEdit;
    this.nameField.setText(toEdit.getName());
    this.descriptionField.setText(toEdit.getDescription());
    this.editing = true;
}   ",179,False
"/**
 * Get the optional boolean value associated with an index.
 * It returns the defaultValue if there is no value at that index or if
 * it is not a Boolean or the String ""true"" or ""false"" (case insensitive).
 *
 * @param index The index must be between 0 and length() - 1.
 * @param defaultValue     A boolean default.
 * @return      The truth.
 */
public boolean optBoolean(int index, boolean defaultValue){
    try {
        return getBoolean(index);
    } catch (Exception e) {
        return defaultValue;
    }
}","/**
 * Get the optional boolean value associated with an index.
 * It returns the defaultValue if there is no value at that index or if
 * it is not a Boolean or the String ""true"" or ""false"" (case insensitive).
 *
 * @param index The index must be between 0 and length() - 1.
 * @param defaultValue     A boolean default.
 * @return      The truth.
 */
public boolean optBoolean(int index, boolean defaultValue) 
{
    try
    {
        return getBoolean(index);
    }
    catch (Exception e)
    {
        return defaultValue;
    }
}   ",183,True
"/**
 * Put or replace a boolean value in the JSONArray. If the index is greater
 * than the length of the JSONArray, then null elements will be added as
 * necessary to pad it out.
 * @param index The subscript.
 * @param value A boolean value.
 * @return this.
 * @throws JSONException If the index is negative.
 */
public JSONArray put(int index, boolean value) throws JSONException{
    put(index, value ? Boolean.TRUE : Boolean.FALSE);
    return this;
}","/**
 * Put or replace a boolean value in the JSONArray. If the index is greater
 * than the length of the JSONArray, then null elements will be added as
 * necessary to pad it out.
 * @param index The subscript.
 * @param value A boolean value.
 * @return this.
 * @throws JSONException If the index is negative.
 */
public JSONArray put(int index, boolean value) throws JSONException 
{
    put(index, Boolean.valueOf(value));
    return this;
}   ",184,True
"/**
 * Get the optional JSONArray associated with an index.
 * @param index subscript
 * @return      A JSONArray value, or null if the index has no value,
 * or if the value is not a JSONArray.
 */
public JSONArray optJSONArray(int index){
    Object o = opt(index);
    return o instanceof JSONArray ? (JSONArray)o : null;
}","/**
 * Get the optional JSONArray associated with an index.
 * @param index subscript
 * @return      A JSONArray value, or null if the index has no value,
 * or if the value is not a JSONArray.
 */
public JSONArray optJSONArray(int index) 
{
    Object o = opt(index);
    if (o instanceof JSONArray)
    {
        return (JSONArray)o;
    }
    return null;
}   ",185,True
"/**
 * Append an object value. This increases the array's length by one.
 * @param value An object value.  The value should be a
 *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
 *  JSONObject.NULL object.
 * @return this.
 */
public JSONArray put(Object value){
    this.myArrayList.add(value);
    return this;
}","/**
 * Append an object value. This increases the array's length by one.
 * @param value An object value.  The value should be a
 *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
 *  JSONObject.NULL object.
 * @return this.
 */
public JSONArray put(Object value) 
{
    JSONObject.testValidity(value);
    this.myArrayList.add(value);
    return this;
}   ",186,True
"/**
 * Put a value in the JSONArray, where the value will be a
 * JSONArray which is produced from a Collection.
 * @param index The subscript.
 * @param value A Collection value.
 * @return      this.
 * @throws JSONException If the index is negative or if the value is
 * not finite.
 */
public JSONArray put(int index, Collection value) throws JSONException{
    put(index, new JSONArray(value));
    return this;
}","/**
 * Put a value in the JSONArray, where the value will be a
 * JSONArray which is produced from a Collection.
 * @param index The subscript.
 * @param value A Collection value.
 * @return      this.
 * @throws JSONException If the index is negative or if the value is
 * not finite.
 */
public JSONArray put(int index, Collection value) throws JSONException 
{
    JSONArray array = new JSONArray();
    for (Object o : value)
    {
        array.put(o);
    }
    return this.put(index, array);
}   ",190,True
"/**
 * Construct a JSONArray from an array with a bean.
 * The array should have Java Beans.
 * 
 * @throws JSONException If not an array.
 */
public JSONArray(Object array,boolean includeSuperClass) throws JSONException{
    this();
    if (array.getClass().isArray()) {
        int length = Array.getLength(array);
        for (int i = 0; i < length; i += 1) {
            Object o = Array.get(array, i);
            if (JSONObject.isStandardProperty(o.getClass())) {
                this.myArrayList.add(o);  
            } else {
                this.myArrayList.add(new JSONObject(o,includeSuperClass));  
            }
        }
    } else {
        throw new JSONException(""JSONArray initial value should be a string or collection or array."");
    }
}","/**
 * Construct a JSONArray from an array with a bean.
 * The array should have Java Beans.
 * 
 * @throws JSONException If not an array.
 */
public JSONArray(Object array,boolean includeSuperClass) throws JSONException 
{
    JSONArray ja = new JSONArray();
    Class<?> type = array.getClass().getComponentType();
    if(type == null)
    {
        throw new JSONException(""Array values were not beans."");
    }
    if(type.isPrimitive() || type == String.class || type.isEnum())
    {
        throw new JSONException(""Array values cannot be primitives, String, or Enums."");
    }
    if(includeSuperClass)
    {
        while(type != null)
        {
            for(Object o : (Object[])array)
            {
                ja.put(toJSONObject(o, type));
            }
            type = type.getSuperclass();
        }
    }
    else
    {
        for(Object o : (Object[])array)
        {
            ja.put(toJSONObject(o, type));
        }
    }
    return ja;
}   ",191,False
"/**
 * Put or replace a long value. If the index is greater than the length of
 *  the JSONArray, then null elements will be added as necessary to pad
 *  it out.
 * @param index The subscript.
 * @param value A long value.
 * @return this.
 * @throws JSONException If the index is negative.
 */
public JSONArray put(int index, long value) throws JSONException{
    put(index, new Long(value));
    return this;
}","/**
 * Put or replace a long value. If the index is greater than the length of
 *  the JSONArray, then null elements will be added as necessary to pad
 *  it out.
 * @param index The subscript.
 * @param value A long value.
 * @return this.
 * @throws JSONException If the index is negative.
 */
public JSONArray put(int index, long value) throws JSONException 
{
    return put(index, new Long(value));
}   ",199,True
"/* This is called immediately after onCreate() when the app is started
	 * or after the app comes back from a pause.
	 */
@Override
	protected void onResume(){
		//handler.post(updateView);

		android.provider.Settings.System.putInt(getContentResolver(), android.provider.Settings.System.END_BUTTON_BEHAVIOR, END_DISABLED);
		keyguard.disableKeyguard();
		wakelock.acquire();
		Log.i(""Interview"", ""onResume"");
		super.onResume();
		
	}","/* This is called immediately after onCreate() when the app is started
	 * or after the app comes back from a pause.
	 */
@Override
	protected void onResume() 
{
    super.onResume();
    // Start the game loop
    gameLoopThread = new GameLoopThread(this);
    gameLoopThread.start();
}	",202,False
"/**
 * Call when the surface has been destroyed
 */
public void shutdown(GL10 gl){
    if ( gl != null) {
        if (mState > STATE_NEW) {
            int[] textures = new int[1];
            textures[0] = mTextureID;
            gl.glDeleteTextures(1, textures, 0);
            mState = STATE_NEW;
        }
    }
}","/**
 * Call when the surface has been destroyed
 */
public void shutdown(GL10 gl) 
{
    if (mProgram != null)
    {
        mProgram.shutdown(gl);
        mProgram = null;
    }
}   ",208,True
"/* Handles item selections */
public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
    case BREAK_DELAY:
    	promptTimes = 0;
    	entry.setDelayStop(System.currentTimeMillis());
        handler.removeCallbacks(startInterview);
        handler.post(startInterview);
        

		entry.setDelayStop(System.currentTimeMillis());
		Log.i(""launchStartDialog"", ""set delay stop time"");

		if (delayMenu != null) {
			delayMenu.clear();
			delayMenu.close();
			delayMenu = null;
		}
        
        return true;
    case CANCEL:
//	    	delayMenu = null;
        return true;
    }
    return false;
}","/* Handles item selections */
public boolean onOptionsItemSelected(MenuItem item) 
{
    switch (item.getItemId())
    {
    case R.id.action_settings:
        return true;
    }
    return super.onOptionsItemSelected(item);
}   ",209,True
"// override the keydown event listener to capture keypresses
// disables all keys except HOME, END and POWER. END is handled by
// changing the system settings for end button behavior, home and 
// power need to be researched...
@Override
public boolean onKeyDown(int keyCode, KeyEvent event){
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        // disable the back button while in the interview
    	if (!debugMode)
    		return true;
    }
    if (keyCode == KeyEvent.KEYCODE_CALL) {
    	// disable the call button
    	return true;
    }
    if (keyCode == KeyEvent.KEYCODE_CAMERA) {
    	// disable camera
    	return true;
    }
    if (keyCode == KeyEvent.KEYCODE_POWER) {
    	// don't know if this can be disabled here
    	return true;
    }
    if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    	// disable search
    	return true;
    }
    return super.onKeyDown(keyCode, event);
}","// override the keydown event listener to capture keypresses
// disables all keys except HOME, END and POWER. END is handled by
// changing the system settings for end button behavior, home and 
// power need to be researched...
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) 
{
    if (keyCode == KeyEvent.KEYCODE_HOME)
    {
        return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_END)
    {
        return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_POWER)
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",211,True
"/**
 * Call to initialize the class.
 * Call whenever the surface has been created.
 *
 * @param gl
 */
public void initialize(GL10 gl){
    mState = STATE_INITIALIZED;
    int[] textures = new int[1];
    gl.glGenTextures(1, textures, 0);
    mTextureID = textures[0];
    gl.glBindTexture(GL10.GL_TEXTURE_2D, mTextureID);

    // Use Nearest for performance.
    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER,
            GL10.GL_NEAREST);
    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER,
            GL10.GL_NEAREST);

    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S,
            GL10.GL_CLAMP_TO_EDGE);
    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T,
            GL10.GL_CLAMP_TO_EDGE);

    gl.glTexEnvf(GL10.GL_TEXTURE_ENV, GL10.GL_TEXTURE_ENV_MODE,
            GL10.GL_REPLACE);
                
}","/**
 * Call to initialize the class.
 * Call whenever the surface has been created.
 *
 * @param gl
 */
public void initialize(GL10 gl) 
{
    // Set the background frame color
    gl.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
    gl.glEnable(GL10.GL_DEPTH_TEST);
    gl.glDepthFunc(GL10.GL_LEQUAL);

    // Initialize the cube
    cube = new Cube();
}   ",212,False
"//	public void setMissed() {
//		missed = true;
//		abandoned = false;
//		completed = false;
//	}
//	
//	public void setAbandoned() {
//		missed = false;
//		abandoned = true;
//		completed = false;
//	}
//	
//	public void setCompleted() {
//		missed = false;
//		abandoned = false;
//		completed = true;
//	}
public void setResponse(int index, Serializable value, long time){
		Log.d(""InterviewData"", ""index = "" + index);
//		if (index < selectedResponse.length) {
			selectedResponse[index] = value;
			responseTime[index] = time;
//		}
	}","//	public void setMissed() {
//		missed = true;
//		abandoned = false;
//		completed = false;
//	}
//	
//	public void setAbandoned() {
//		missed = false;
//		abandoned = true;
//		completed = false;
//	}
//	
//	public void setCompleted() {
//		missed = false;
//		abandoned = false;
//		completed = true;
//	}
public void setResponse(int index, Serializable value, long time) 
{
	if (index >= 0 && index < responses.length)
	{
		responses[index] = value;
		times[index] = time;
	}
}   ",213,True
"/* Creates the menu items */
public boolean onCreateOptionsMenu(Menu menu){
    if (state == DELAYED) {
		menu.add(0, BREAK_DELAY, 0, ""Break Delay"");
	    menu.add(0, CANCEL, 0, ""Cancel"");
	    delayMenu = menu;
    }
    return true;
}","/* Creates the menu items */

public boolean onCreateOptionsMenu(Menu menu) 
{
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu, menu);
    return true;
}   ",214,True
"/**
 * Begin drawing labels. Sets the OpenGL state for rapid drawing.
 *
 * @param gl
 * @param viewWidth
 * @param viewHeight
 */
public void beginDrawing(GL10 gl, float viewWidth, float viewHeight){
    checkState(STATE_INITIALIZED, STATE_DRAWING);
    gl.glBindTexture(GL10.GL_TEXTURE_2D, mTextureID);
    gl.glShadeModel(GL10.GL_FLAT);
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
    gl.glColor4x(0x10000, 0x10000, 0x10000, 0x10000);
    gl.glMatrixMode(GL10.GL_PROJECTION);
    gl.glPushMatrix();
    gl.glLoadIdentity();
    gl.glOrthof(0.0f, viewWidth, 0.0f, viewHeight, 0.0f, 1.0f);
    gl.glMatrixMode(GL10.GL_MODELVIEW);
    gl.glPushMatrix();
    gl.glLoadIdentity();
    // Magic offsets to promote consistent rasterization.
    //gl.glTranslatef(0.375f, 0.375f, 0.0f);
}","/**
 * Begin drawing labels. Sets the OpenGL state for rapid drawing.
 *
 * @param gl
 * @param viewWidth
 * @param viewHeight
 */
public void beginDrawing(GL10 gl, float viewWidth, float viewHeight) 
{
    gl.glMatrixMode(GL10.GL_PROJECTION);
    gl.glLoadIdentity();
    gl.glOrthof(0, viewWidth, 0, viewHeight, -1, 1);
    gl.glMatrixMode(GL10.GL_MODELVIEW);
    gl.glLoadIdentity();
}   ",217,True
"/**
 * Call to end adding labels. Must be called before drawing starts.
 *
 * @param gl
 */
public void endAdding(GL10 gl){
    checkState(STATE_ADDING, STATE_INITIALIZED);
    gl.glBindTexture(GL10.GL_TEXTURE_2D, mTextureID);
    GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, mBitmap, 0);
    // Reclaim storage used by bitmap and canvas.
    mBitmap.recycle();
    mBitmap = null;
    mCanvas = null;
}","/**
 * Call to end adding labels. Must be called before drawing starts.
 *
 * @param gl
 */
public void endAdding(GL10 gl) 
{
    if (mLabelMaker != null)
    {
        mLabelMaker.endAdding(gl);
        mLabelMaker = null;
    }
}   ",218,True
"/**
 * Overrides {@link SensorEventListener} to retrieve sensor Readings.
 * @param event 
 */
public void onSensorChanged(SensorEvent event){
	// TODO what about the multiplier
	
	// I don't think we can use event.timestamp.
	// It seems event.timestamp is the # of nanoseconds since the device was booted, 
	// rather than # of nanoseconds since the epoch.
	// long timestamp = event.timestamp / 1000000;   // convert to milliseconds
	
	long timestamp = System.currentTimeMillis();  // assume this is close to the real timestamp
	
	if (compassX!= null) {
		compassX.addValue((int)(event.values[SensorManager.DATA_X]*MULTIPLIER), timestamp);	
	}
	if (compassY!= null) {
		compassY.addValue((int)(event.values[SensorManager.DATA_Y]*MULTIPLIER), timestamp);	
	}
	if (compassZ!= null) {
		compassZ.addValue((int)(event.values[SensorManager.DATA_Z]*MULTIPLIER), timestamp);	
	}
	if (magnitude!= null) {
		magnitude.addValue((int)Math.floor(
				Math.sqrt(event.values[SensorManager.DATA_X]*event.values[SensorManager.DATA_X]+
						event.values[SensorManager.DATA_Y]*event.values[SensorManager.DATA_Y]+
						event.values[SensorManager.DATA_Z]*event.values[SensorManager.DATA_Z])
						*MULTIPLIER), timestamp);	
	}
}","/**
 * Overrides {@link SensorEventListener} to retrieve sensor Readings.
 * @param event 
 */
public void onSensorChanged(SensorEvent event) 
{
    if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER)
    {
        // get the values of acceleration from the sensor
        x = event.values[0];
        y = event.values[1];
        z = event.values[2];
    }
}   ",219,False
"/**
 * Add 10 new playlists with unsorted title order
 */
public void addNewPlaylist() throws Exception{
  Instrumentation inst = getInstrumentation();      
  for (int i=0; i< MusicPlayerNames.NO_OF_PLAYLIST; i++){
    inst.invokeContextMenuAction(getActivity(), MusicUtils.Defs.NEW_PLAYLIST, 0);
    Thread.sleep(MusicPlayerNames.WAIT_SHORT_TIME);
    //Remove the default playlist name
    for (int j=0; j< MusicPlayerNames.DEFAULT_PLAYLIST_LENGTH; j++)
      inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DEL);
    inst.sendStringSync(MusicPlayerNames.unsortedPlaylistTitle[i]);
    inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
    inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);
    Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);
    inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
    Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);
  }
}","/**
 * Add 10 new playlists with unsorted title order
 */

public void addNewPlaylist() throws Exception 
{
    for (int i = 0; i < 10; i++) {
        String title = ""Playlist "" + (i + 1);
        String description = ""Description for Playlist "" + (i + 1);
        Playlist playlist = new Playlist(title, description);
        playlistRepository.save(playlist);
    }
}   ",222,True
"/**
 * Test case 3: Delete a song
 * Test case precondition: Copy a song and rescan the sdcard
 * Verification: The song is deleted from the sdcard and mediastore
 */
@LargeTest
public void testDeleteSong() throws Exception{
  Instrumentation inst = getInstrumentation();      
  Cursor mCursor;
  
  //Copy a song from the golden directory
  Log.v(TAG, ""Copy a temp file to the sdcard"");
  File goldenfile = new File(MusicPlayerNames.GOLDENSONG);
  File toBeDeleteSong = new File(MusicPlayerNames.DELETESONG);
  copy(goldenfile, toBeDeleteSong);
  rescanSdcard();
   
  //Delete the file from music player
  Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);
  inst.sendStringSync(MusicPlayerNames.TOBEDELETESONGNAME);
  Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);
  inst.invokeContextMenuAction(getActivity(), MusicUtils.Defs.DELETE_ITEM, 0);
  inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
  inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);
  Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);
  
  //Clear the search string
  for (int j=0; j< MusicPlayerNames.TOBEDELETESONGNAME.length(); j++)
      inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DEL);
  
  //Verfiy the item is removed from sdcard
  File checkDeletedFile = new File(MusicPlayerNames.DELETESONG);
  assertFalse(TAG, checkDeletedFile.exists());
  
  ContentResolver resolver = getActivity().getContentResolver();
  if (resolver == null) {
    System.out.println(""resolver = null"");
  } else {
    String whereclause = MediaStore.Audio.Media.DISPLAY_NAME + "" = '"" + 
    MusicPlayerNames.TOBEDELETESONGNAME + ""'"";
    mCursor = resolver.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
       null, whereclause, null, null);
    boolean isEmptyCursor = mCursor.moveToFirst();
    assertFalse(TAG,isEmptyCursor);
  }     
}","/**
 * Test case 3: Delete a song
 * Test case precondition: Copy a song and rescan the sdcard
 * Verification: The song is deleted from the sdcard and mediastore
 */
@LargeTest
public void testDeleteSong() throws Exception 
{
    String songName = ""testDeleteSong"";
    String songPath = copySong(songName);
    File songFile = new File(songPath);
    assertTrue(""Cannot find the song file"", songFile.exists());
    long songId = getSongId(songName);
    assertTrue(""Cannot get song id"", songId != -1);
    deleteSong(songId);
    assertFalse(""The song file is not deleted"", songFile.exists());
    songId = getSongId(songName);
    assertTrue(""The song is not deleted from mediastore"", songId == -1);
}   ",223,False
"/*
 * Returns true if a file is currently opened for playback (regardless
 * of whether it's playing or paused).
 */
public static boolean isMusicLoaded(){
    if (MusicUtils.sService != null) {
        try {
            return sService.getPath() != null;
        } catch (RemoteException ex) {
        }
    }
    return false;
}","/*
 * Returns true if a file is currently opened for playback (regardless
 * of whether it's playing or paused).
 */
public static boolean isMusicLoaded() 
{
    if (music != null)
    {
        return true;
    }
    return false;
}   ",227,True
"/**
 * Link up various button actions using {@link PendingIntents}.
 * 
 * @param playerActive True if player is active in background, which means
 *            widget click will launch {@link MediaPlaybackActivity},
 *            otherwise we launch {@link MusicBrowserActivity}.
 */
private void linkButtons(Context context, RemoteViews views, boolean playerActive){
    // Connect up various buttons and touch events
    Intent intent;
    PendingIntent pendingIntent;
    
    final ComponentName serviceName = new ComponentName(context, MediaPlaybackService.class);
    
    if (playerActive) {
        intent = new Intent(context, MediaPlaybackActivity.class);
        pendingIntent = PendingIntent.getActivity(context,
                0 /* no requestCode */, intent, 0 /* no flags */);
        views.setOnClickPendingIntent(R.id.album_appwidget, pendingIntent);
    } else {
        intent = new Intent(context, MusicBrowserActivity.class);
        pendingIntent = PendingIntent.getActivity(context,
                0 /* no requestCode */, intent, 0 /* no flags */);
        views.setOnClickPendingIntent(R.id.album_appwidget, pendingIntent);
    }
    
    intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);
    intent.setComponent(serviceName);
    pendingIntent = PendingIntent.getService(context,
            0 /* no requestCode */, intent, 0 /* no flags */);
    views.setOnClickPendingIntent(R.id.control_play, pendingIntent);
    
    intent = new Intent(MediaPlaybackService.NEXT_ACTION);
    intent.setComponent(serviceName);
    pendingIntent = PendingIntent.getService(context,
            0 /* no requestCode */, intent, 0 /* no flags */);
    views.setOnClickPendingIntent(R.id.control_next, pendingIntent);
}","/**
 * Link up various button actions using {@link PendingIntents}.
 * 
 * @param playerActive True if player is active in background, which means
 *            widget click will launch {@link MediaPlaybackActivity},
 *            otherwise we launch {@link MusicBrowserActivity}.
 */


private void linkButtons(Context context, RemoteViews views, boolean playerActive) 
{
    Class<?> activityClass = playerActive ? MediaPlaybackActivity.class : MusicBrowserActivity.class;
    Intent intent = new Intent(context, activityClass);
    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
    views.setOnClickPendingIntent(R.id.widget, pendingIntent);
}   ",228,True
"/**
 * Check against {@link AppWidgetManager} if there are any instances of this widget.
 */
private boolean hasInstances(Context context){
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    int[] appWidgetIds = appWidgetManager.getAppWidgetIds(THIS_APPWIDGET);
    return (appWidgetIds.length > 0);
}","/**
 * Check against {@link AppWidgetManager} if there are any instances of this widget.
 */

private boolean hasInstances(Context context) 
{
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    int[] appWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context, getClass()));
    return (appWidgetIds.length > 0);
}   ",230,True
"/*
 * Restore size and visibility for all listitems
 */
private void unExpandViews(boolean deletion){
    for (int i = 0;; i++) {
        View v = getChildAt(i);
        if (v == null) {
            if (deletion) {
                // HACK force update of mItemCount
                int position = getFirstVisiblePosition();
                int y = getChildAt(0).getTop();
                setAdapter(getAdapter());
                setSelectionFromTop(position, y);
                // end hack
            }
            layoutChildren(); // force children to be recreated where needed
            v = getChildAt(i);
            if (v == null) {
                break;
            }
        }
        ViewGroup.LayoutParams params = v.getLayoutParams();
        params.height = 64;
        v.setLayoutParams(params);
        v.setVisibility(View.VISIBLE);
    }
}","/*
 * Restore size and visibility for all listitems
 */
private void unExpandViews(boolean deletion) 
{
    int deleteCount = mListView.getCount();

    for (int i = 0; i < deleteCount; ++i)
    {
        View v = mListView.getChildAt(i);
        if (v != null)
        {
            View w = v.findViewById(R.id.list_item);
            if (deletion)
            {
                w.setVisibility(View.VISIBLE);
            }
            else
            {
                w.setVisibility(View.VISIBLE);
            }
        }
    }
}   ",231,False
"/*
 * pointToPosition() doesn't consider invisible views, but we
 * need to, so implement a slightly different version.
 */
private int myPointToPosition(int x, int y){
    Rect frame = mTempRect;
    final int count = getChildCount();
    for (int i = count - 1; i >= 0; i--) {
        final View child = getChildAt(i);
        child.getHitRect(frame);
        if (frame.contains(x, y)) {
            return getFirstVisiblePosition() + i;
        }
    }
    return INVALID_POSITION;
}","/*
 * pointToPosition() doesn't consider invisible views, but we
 * need to, so implement a slightly different version.
 */



private int myPointToPosition(int x, int y) 
{
    Rect frame = new Rect();
    int suggestionsCount = getChildCount();
    for (int i = suggestionsCount - 1; i >= 0; i--) {
        View child = getChildAt(i);
        if (child.getVisibility() == View.VISIBLE) {
            child.getHitRect(frame);
            if (frame.contains(x, y)) {
                return i;
            }
        }
    }
    return INVALID_POSITION;
}   ",232,True
"/**
 * Test case 1: tests the new playlist added with sorted order.
 * Verification: The new playlist title should be sorted in alphabetical order
 */
@LargeTest
public void testAddPlaylist() throws Exception{
  Cursor mCursor;
  addNewPlaylist();
  
  //Verify the new playlist is created, check the playlist table
  String[] cols = new String[] {
      MediaStore.Audio.Playlists.NAME
  };
  ContentResolver resolver = getActivity().getContentResolver();
  if (resolver == null) {
    System.out.println(""resolver = null"");
  } else {
    String whereclause = MediaStore.Audio.Playlists.NAME + "" != ''"";
    mCursor = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
      cols, whereclause, null,
      MediaStore.Audio.Playlists.NAME);
    //Check the new playlist
    mCursor.moveToFirst();
    
    for (int j=0;j<10;j++){
      assertEquals(""New sorted Playlist title:"", MusicPlayerNames.expectedPlaylistTitle[j], mCursor.getString(0)); 
      mCursor.moveToNext();
    }
  }
}","/**
 * Test case 1: tests the new playlist added with sorted order.
 * Verification: The new playlist title should be sorted in alphabetical order
 */

@LargeTest
public void testAddPlaylist() throws Exception 
{
    String[] playlistTitles = {""A"", ""B"", ""C"", ""D"", ""E""};
    for (String title : playlistTitles)
    {
        addPlaylist(title);
    }
    List<String> playlistList = getPlaylistList();
    Assert.assertEquals(playlistTitles.length, playlistList.size());
    for (int i = 0; i < playlistTitles.length; i++)
    {
        Assert.assertEquals(playlistTitles[i], playlistList.get(i));
    }
}   ",235,True
"// Get album art for specified album. This method will not try to
// fall back to getting artwork directly from the file, nor will
// it attempt to repair the database.
private static Bitmap getArtworkQuick(Context context, int album_id, int w, int h){
    // NOTE: There is in fact a 1 pixel border on the right side in the ImageView
    // used to display this drawable. Take it into account now, so we don't have to
    // scale later.
    w -= 1;
    ContentResolver res = context.getContentResolver();
    Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);
    if (uri != null) {
        ParcelFileDescriptor fd = null;
        try {
            fd = res.openFileDescriptor(uri, ""r"");
            int sampleSize = 1;
            
            // Compute the closest power-of-two scale factor 
            // and pass that to sBitmapOptionsCache.inSampleSize, which will
            // result in faster decoding and better quality
            sBitmapOptionsCache.inJustDecodeBounds = true;
            BitmapFactory.decodeFileDescriptor(
                    fd.getFileDescriptor(), null, sBitmapOptionsCache);
            int nextWidth = sBitmapOptionsCache.outWidth >> 1;
            int nextHeight = sBitmapOptionsCache.outHeight >> 1;
            while (nextWidth>w && nextHeight>h) {
                sampleSize <<= 1;
                nextWidth >>= 1;
                nextHeight >>= 1;
            }

            sBitmapOptionsCache.inSampleSize = sampleSize;
            sBitmapOptionsCache.inJustDecodeBounds = false;
            Bitmap b = BitmapFactory.decodeFileDescriptor(
                    fd.getFileDescriptor(), null, sBitmapOptionsCache);

            if (b != null) {
                // finally rescale to exactly the size we need
                if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {
                    Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);
                    // Bitmap.createScaledBitmap() can return the same bitmap
                    if (tmp != b) b.recycle();
                    b = tmp;
                }
            }
            
            return b;
        } catch (FileNotFoundException e) {
        } finally {
            try {
                if (fd != null)
                    fd.close();
            } catch (IOException e) {
            }
        }
    }
    return null;
}","// Get album art for specified album. This method will not try to
// fall back to getting artwork directly from the file, nor will
// it attempt to repair the database.









private static Bitmap getArtworkQuick(Context context, int album_id, int w, int h) 
{
    Bitmap bm = null;
    try {
        final Uri sArtworkUri = Uri.parse(""content://media/external/audio/albumart/"" + album_id);
        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);
        ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, ""r"");
        if (pfd != null) {
            FileDescriptor fd = pfd.getFileDescriptor();
            bm = BitmapFactory.decodeFileDescriptor(fd, null, new BitmapFactory.Options());
            pfd = null;
        }
    } catch (Exception e) {
    }
    if (bm != null) {
        bm = ThumbnailUtils.extractThumbnail(bm, w, h);
    } else {
        bm = getArtwork(context, album_id, w, h, true);
    }
    return bm;
}   ",236,False
"/* Adjust visibility and size to make it appear as though
 * an item is being dragged around and other items are making
 * room for it:
 * If dropping the item would result in it still being in the
 * same place, then make the dragged listitem's size normal,
 * but make the item invisible.
 * Otherwise, if the dragged listitem is still on screen, make
 * it as small as possible and expand the item below the insert
 * point.
 * If the dragged item is not on screen, only expand the item
 * below the current insertpoint.
 */
private void doExpansion(){
    int childnum = mDragPos - getFirstVisiblePosition();
    if (mDragPos > mFirstDragPos) {
        childnum++;
    }

    View first = getChildAt(mFirstDragPos - getFirstVisiblePosition());

    for (int i = 0;; i++) {
        View vv = getChildAt(i);
        if (vv == null) {
            break;
        }
        int height = 64;
        int visibility = View.VISIBLE;
        if (vv.equals(first)) {
            // processing the item that is being dragged
            if (mDragPos == mFirstDragPos) {
                // hovering over the original location
                visibility = View.INVISIBLE;
            } else {
                // not hovering over it
                height = 1;
            }
        } else if (i == childnum) {
            if (mDragPos < getCount() - 1) {
                height = 128;
            }
        }
        ViewGroup.LayoutParams params = vv.getLayoutParams();
        params.height = height;
        vv.setLayoutParams(params);
        vv.setVisibility(visibility);
    }
}","/* Adjust visibility and size to make it appear as though
 * an item is being dragged around and other items are making
 * room for it:
 * If dropping the item would result in it still being in the
 * same place, then make the dragged listitem's size normal,
 * but make the item invisible.
 * Otherwise, if the dragged listitem is still on screen, make
 * it as small as possible and expand the item below the insert
 * point.
 * If the dragged item is not on screen, only expand the item
 * below the current insertpoint.
 */
private void doExpansion() 
{
    if (dropIndex > insertIndex)
    {
        if (dropIndex > insertIndex + 1)
        {
            listitem.setSize(1, 1);
            listitem.setVisible(false);
        }
        else
        {
            listitem.setSize(1, 1);
            expandItemBelowInsert();
        }
    }
    else
    {
        if (dropIndex < insertIndex - 1)
        {
            expandItemBelowInsert();
        }
        else
        {
            listitem.setSize(1, 1);
            listitem.setVisible(false);
        }
    }
}   ",238,True
"/** Called when the activity is first created. */
@Override
public void onCreate(Bundle icicle){
    super.onCreate(icicle);

    final Intent intent = getIntent();
    final String action = intent.getAction();
    if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {
        mCreateShortcut = true;
    }

    requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
    setVolumeControlStream(AudioManager.STREAM_MUSIC);
    MusicUtils.bindToService(this, new ServiceConnection() {
        public void onServiceConnected(ComponentName classname, IBinder obj) {
            if (Intent.ACTION_VIEW.equals(action)) {
                long id = Long.parseLong(intent.getExtras().getString(""playlist""));
                if (id == RECENTLY_ADDED_PLAYLIST) {
                    playRecentlyAdded();
                } else if (id == PODCASTS_PLAYLIST) {
                    playPodcasts();
                } else if (id == ALL_SONGS_PLAYLIST) {
                    int [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);
                    if (list != null) {
                        MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);
                    }
                } else {
                    MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);
                }
                finish();
            }
        }

        public void onServiceDisconnected(ComponentName classname) {
        }
    
    });
    IntentFilter f = new IntentFilter();
    f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);
    f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);
    f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
    f.addDataScheme(""file"");
    registerReceiver(mScanListener, f);

    setContentView(R.layout.media_picker_activity);
    ListView lv = getListView();
    lv.setOnCreateContextMenuListener(this);
    lv.setTextFilterEnabled(true);

    mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();
    if (mAdapter == null) {
        //Log.i(""@@@"", ""starting query"");
        mAdapter = new PlaylistListAdapter(
                getApplication(),
                this,
                R.layout.track_list_item,
                mPlaylistCursor,
                new String[] { MediaStore.Audio.Playlists.NAME},
                new int[] { android.R.id.text1 });
        setListAdapter(mAdapter);
        setTitle(R.string.working_playlists);
        getPlaylistCursor(mAdapter.getQueryHandler(), null);
    } else {
        mAdapter.setActivity(this);
        setListAdapter(mAdapter);
        mPlaylistCursor = mAdapter.getCursor();
        // If mPlaylistCursor is null, this can be because it doesn't have
        // a cursor yet (because the initial query that sets its cursor
        // is still in progress), or because the query failed.
        // In order to not flash the error dialog at the user for the
        // first case, simply retry the query when the cursor is null.
        // Worst case, we end up doing the same query twice.
        if (mPlaylistCursor != null) {
            init(mPlaylistCursor);
        } else {
            setTitle(R.string.working_playlists);
            getPlaylistCursor(mAdapter.getQueryHandler(), null);
        }
    }
}","/** Called when the activity is first created. */

@Override
public void onCreate(Bundle icicle) 
{
    super.onCreate(icicle);

    // Create the view
    setContentView(R.layout.main);

    // Create the model
    model = new Model();

    // Create the controller
    controller = new Controller(model);

    // Create the view
    view = new View(this, model, controller);
}   ",239,False
"/****************************************************************
 * calculates the new position of each disk
 *
 * works by adding ddx to dx and ddy to dy. then applys friction,
 * checks bounds, calcs collisions, fixes overlapping, etc etc
 *
 * returns boolean indicating still movement on board.
 ****************************************************************/
public void calcPositions(){
    //try {
			//System.out.println(""Calc Positions"");
        int a, b;
        Circle i, j;

        for  ( a = 0 ; a < circles.size() ; a++ ) {
            i = (Circle)circles.elementAt( a );
            //System.out.println(""Looking at the "" + i.name);

            // check if circle is moving
            if (i.dy != 0 || i.dx != 0) {
                i.y += i.dy;
                i.x += i.dx;

                if ( friction ) doFriction(i);
            }

				//check for the ball falling in a pocket
				if ( checkPockets(i) ) {
					//System.out.println(""A = "" + a);
					//System.out.println(""queBallIndex = "" + table.queBallIndex );
					i.dx = 0;
					i.dy = 0;
					circles.remove(a);
					if ( a == table.queBallIndex ) {
						table.scratched = true;
						System.out.println(""You scratched the Que Ball!!"");
						table.queBallIndex = -1;
					}
					else {
						//Remove ball
						if ( !table.scratched ) {
							table.queBallIndex = table.findQueBallIndex( circles );
						}
						System.out.println(""The "" + i.name + "" fell in a hole!"");
						table.addToFallen(i);
					}
				}
				else {
					// check bounces
					checkBounds(i);

					// check if circle has collided with any other circle after it
					// It's like this so circles dont collide twice
					for ( b = a+1; b < circles.size() ; b++ ) {
						j = (Circle)circles.elementAt( b );
						//See if they collided
						if (calcCollision(i, j)) {
							// fix possible overlapping
							if ( overlap ) fixOverlap(i, j);
							// Calculate new friction for both circles
							calcFriction(i);
							calcFriction(j);
						}
					}
				}
        }

        checkReady();

    //}
    //catch (Exception ex) {
    //    System.out.println(""ERROR!!!  - "" + ex.getMessage());
    //}
}","/****************************************************************
 * calculates the new position of each disk
 *
 * works by adding ddx to dx and ddy to dy. then applys friction,
 * checks bounds, calcs collisions, fixes overlapping, etc etc
 *
 * returns boolean indicating still movement on board.
 ****************************************************************/
public void calcPositions() 
{
    for (int i = 0; i < disks.length; i++)
    {
        Disk disk = disks[i];
        disk.dx += disk.ddx;
        disk.dy += disk.ddy;
        disk.dx *= disk.friction;
        disk.dy *= disk.friction;
        if (disk.x + disk.dx < 0 || disk.x + disk.dx > boardWidth)
        {
            disk.dx = -disk.dx;
        }
        if (disk.y + disk.dy < 0 || disk.y + disk.dy > boardHeight)
        {
            disk.dy = -disk.dy;
        }
        disk.x += disk.dx;
        disk.y += disk.dy;
    }
    for (int i = 0; i < disks.length; i++)
    {
        Disk disk1 = disks[i];
        for (int j = i + 1; j < disks.length; j++)
        {
            Disk disk2 = disks[j];
            double dx = disk1.x - disk2.x;
            double dy = disk1.y - disk2.y;
            double dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < disk1.radius + disk2.radius)
            {
                double angle = Math.atan2(dy, dx);
                double overlap = disk1.radius + disk2.radius - dist;
                disk1.x -= overlap * Math.cos(angle) / 2;
                disk1.y -= overlap * Math.sin(angle) / 2;
                disk2.x += overlap * Math.cos(angle) / 2;
                disk2.y += overlap * Math.sin(angle) / 2;
            }
        }
    }
    boolean stillMovement = false;
    for (Disk disk : disks)
    {
        if (Math.abs(disk.dx) > 0.1 || Math.abs(disk.dy) > 0.1)
        {
            stillMovement = true;
            break;
        }
    }
    return stillMovement;
}   ",241,False
"/*******************************************************
 * constructor. sets up the panel stuff, adds
 * mouse listenners, starts game engine, etc
 *
 * @param shuffle
 ******************************************************/
public Table(Bouncer bouncer){
    //Always call super
    super();

    //Makes the moving display smoother
    setDoubleBuffered(true);

    //Default bg colour
    setBackground(new Color (51, 102, 51));
    setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));

    //Add mouse listeners
    addMouseListener(this);
    addMouseMotionListener(this);

    //Reference to bouncer
    this.bouncer = bouncer;

		//Initialize the circles.
    circles = new Vector<Circle>();
    
    // Initialize engine
    engine = new Engine( this );

    populateCircles();
    engine.setCircles( circles );

    populatePockets();

    //Start the Engine
    Thread e = new Thread( engine );
		e.setPriority(Thread.NORM_PRIORITY);
    e.start();

    // start thread
    Thread t = new Thread(this);
    t.setPriority(Thread.NORM_PRIORITY);
    t.start();

    // ready!
    ready = true;
}","/*******************************************************
 * constructor. sets up the panel stuff, adds
 * mouse listenners, starts game engine, etc
 *
 * @param shuffle
 ******************************************************/

public Table(Bouncer bouncer) 
{
    this.bouncer = bouncer;
    this.setPreferredSize(new Dimension(WIDTH, HEIGHT));
    this.setBackground(Color.BLACK);
    this.addMouseListener(this);
    this.addMouseMotionListener(this);
    this.setFocusable(true);
    this.addKeyListener(this);
    this.bouncer.start();
}   ",243,False
"/**
 * default constructor.
 * builds the window
 */
public Bouncer(){
    // always call super
    super();

    // makes window look more natural
    try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Exception ex) {
        System.out.println(ex.getMessage());
    }

    // set jframe basics
    setTitle(""Billiard Table"");


    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setLayout(new BorderLayout());

    setSize( WINDOW_X, WINDOW_Y );

    setResizable( true );
    setLocationByPlatform(true);

    // labels
    status = new JLabel(""By: Paul George"", JLabel.CENTER);
    add(status, BorderLayout.SOUTH);

    // table
    table = new Table(this);
    add(table, BorderLayout.CENTER);
    
    // menus
    buildMenus();

    // let's see it!
    setVisible(true);
    requestFocus();
}","/**
 * default constructor.
 * builds the window
 */
public Bouncer() 
{
    buildGUI();
}   ",244,False
"// Play or Re-play the sound effect from the beginning, by rewinding.
public void play(){
   if (volume != Volume.MUTE) {
      if (clip.isRunning())
         clip.stop();   // Stop the player if it is still running
      clip.setFramePosition(0); // rewind to the beginning
      clip.start();     // Start playing
   }
}","// Play or Re-play the sound effect from the beginning, by rewinding.
public void play() 
{
    if (sound != null)
    {
        sound.stop();
        sound.play();
    }
}   ",245,True
"/*********************************************************************
 * calculates the components of the friction on a disk
 *
 * friction is propertional to normal force, which is propertional
 * to acceleration.
 *
 * k is the ratio between velocity and acceleration. this is used
 * because friction always opposes motion so the acceleration is a
 * similar triangle to the velocity. the friction has to be calculated
 * this way otherwise it would change the direction of the sliding disks
 *
 *
 * @param c the Circle
 **********************************************************************/
public void calcFriction( Circle c){
	double k = (c.dx * c.dx + c.dy * c.dy);

	//System.out.println(""Arena Friction is: "" + Arena.CoF);
	k = Math.sqrt(k) * Table.CoF;

	//System.out.println(""k is : "" + k );
	// dividng by zero is bad
	if (k == 0) return;

	// set ddx and ddy
	c.ddy = -c.dy / k;
	c.ddx = -c.dx / k;
    }","/*********************************************************************
 * calculates the components of the friction on a disk
 *
 * friction is propertional to normal force, which is propertional
 * to acceleration.
 *
 * k is the ratio between velocity and acceleration. this is used
 * because friction always opposes motion so the acceleration is a
 * similar triangle to the velocity. the friction has to be calculated
 * this way otherwise it would change the direction of the sliding disks
 *
 *
 * @param c the Circle
 **********************************************************************/
public void calcFriction( Circle c) 
{
  double k = c.getVel().dot(c.getAccel()) / (c.getVel().mag() * c.getAccel().mag());
  double mag = k * c.getMass() * g;
  Friction = c.getVel().getUnitVector().scale(-mag);
}   ",248,True
"/***********************************************************
	 * calculates positions every 6 ms
	 *
	 * works by looping endlessly and timming how long it took
	 * to calc positions and subtract that time from 6 ms and
	 * waits that long before looping again. it has to be done
	 * this way or else calculation times would effect velocity
	 **********************************************************/
public void run(){
		long time;

		while (true) {
			time = System.currentTimeMillis();
			calcPositions();
			time = System.currentTimeMillis() - time;

			// sleep for 6 seconds in total. subtract calculations time
			time = 6 - time;

			// so sleep is never passed a negitive time
			if (time < 0)
				time = 0;

			try {
				Thread.sleep(time, 1);
			} catch (InterruptedException ex) {
				System.out.println(ex.getMessage());
			}
		}
	}","/***********************************************************
	 * calculates positions every 6 ms
	 *
	 * works by looping endlessly and timming how long it took
	 * to calc positions and subtract that time from 6 ms and
	 * waits that long before looping again. it has to be done
	 * this way or else calculation times would effect velocity
	 **********************************************************/
public void run() 
{
	long lastTime = System.currentTimeMillis();
	while (true)
	{
		long time = System.currentTimeMillis();
		if (time - lastTime > 6)
		{
			calcPositions();
			lastTime = System.currentTimeMillis();
		}
	}
}	",249,True
"/**************************************************************
 * applys the force of friction on the sliding disk
 *
 * when dx and ddx have the same sign, it means they have changed to the
 * same direction. friction always opposes motion so when this happens,
 * it means the disk has been stopped due to friction.
 *
 * @param c the Circle
 *************************************************************/
private void doFriction( Circle c ){
    c.dy += c.ddy;
    c.dx += c.ddx;
    // if dx and ddx now have the same sign then stop
    if (c.dx > 0 == c.ddx > 0) {
        c.dx = 0;
        checkReady();
    }
    if (c.dy > 0 == c.ddy > 0) {
        c.dy = 0;
        checkReady();
    }
}","/**************************************************************
 * applys the force of friction on the sliding disk
 *
 * when dx and ddx have the same sign, it means they have changed to the
 * same direction. friction always opposes motion so when this happens,
 * it means the disk has been stopped due to friction.
 *
 * @param c the Circle
 *************************************************************/
private void doFriction( Circle c ) 
{
    if ( c.ddx * c.dx < 0 )
    {
        c.ddx = 0;
    }
}   ",250,True
"/****************************************
* private method to build the menus
***************************************/
private void buildMenus(){
    JMenuBar menubar = new JMenuBar();

    // menus
    JMenu file = new JMenu(""File""),
          opts = new JMenu(""Options""),
          help = new JMenu(""Help"");

    menubar.add(file);
    menubar.add(opts);
    menubar.add(help);

    // file menu
    addMenuItems(file, ""New Game, -, Exit Game"");

    // options menu
    addMenuItems(opts, ""*Friction, *Aim Help, -, *Anti-Overlap, -"");

    // help menu
    addMenuItems(help, ""About"");

    // lets see it!
    setJMenuBar(menubar);
}","/****************************************
* private method to build the menus
***************************************/




private void buildMenus() 
{
    JMenuBar menuBar = new JMenuBar();
    JMenu menu = new JMenu(""File"");
    JMenuItem menuItem = new JMenuItem(""Exit"");
    menuItem.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    menu.add(menuItem);
    menuBar.add(menu);
    setJMenuBar(menuBar);
}   ",258,True
"/**
 * finger[i] = n
 * 
 * @param i
 *            The index to set
 * @param n
 *            The node to set
 */
public void setFinger(int i, TNode n){
    if (i < 0 || i >= fingers.size())
        // Invalid range
        throw new IndexOutOfBoundsException();

    if (i == 0) {
        setSuccessor(n);
        return;
    }

    fingers.set(i, n);
}","/**
 * finger[i] = n
 * 
 * @param i
 *            The index to set
 * @param n
 *            The node to set
 */
public void setFinger(int i, TNode n) 
{
    if (i < 0 || i >= finger.length)
    {
        throw new IllegalArgumentException(""Illegal index "" + i);
    }
    finger[i] = n;
}   ",260,False
"/**
 * Generates a {@link KeyId} from the given String by SHA1 hashing it and concatenating into 64
 * bits.
 * 
 * @param key
 *            a {@link String} to use for generating the {@link KeyId}
 * @return a {@link KeyId} which is a hash of the {@code key}
 */
public static KeyId generateKeyId(String key){
    try {
        KeyId keyId = new KeyId(0);

        MessageDigest md = MessageDigest.getInstance(""SHA"");
        byte[] hash = md.digest(key.getBytes());
        int keySpaceBytes = Constants.KEY_SPACE / 4;
        for (int i = 0; i < Math.min(hash.length, keySpaceBytes); ++i) {
            keyId.setId(keyId.getId() | (((long) hash[i] & 0xff) << (i * 4)));
        }
        return keyId;
    } catch (NoSuchAlgorithmException e) {
        // Will never happen because SHA algorithm exists
        throw new RuntimeException(e);
    }
}","/**
 * Generates a {@link KeyId} from the given String by SHA1 hashing it and concatenating into 64
 * bits.
 * 
 * @param key
 *            a {@link String} to use for generating the {@link KeyId}
 * @return a {@link KeyId} which is a hash of the {@code key}
 */



public static KeyId generateKeyId(String key) 
{
    try
    {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(key.getBytes());
        byte[] digest = md.digest();
        byte[] keyId = new byte[64];
        System.arraycopy(digest, 0, keyId, 0, 20);
        return new KeyId(keyId);
    }
    catch (NoSuchAlgorithmException e)
    {
        throw new RuntimeException(e);
    }
}   ",263,True
"/**
 * Stops the worker threads.
 */
public void kill(){
    stabilize.kill();
    checkPredecessor.kill();
    fixFingers.kill();
}","/**
 * Stops the worker threads.
 */
public void kill() 
{
    for (int i = 0; i < workers.length; i++)
    {
        workers[i].kill();
    }
}   ",265,True
"/**
 * Join {@link Node} with index {@code nodeNum} to the Donut ring referencing the {@Node}
 * with index {@code knownNode} as the known {@link Node} in the ring.
 * 
 * @param nodeNum
 */
public void join(int nodeNum, int knownNode){
    TNode node = testRunner.node(knownNode).getTNode();
    setClosure(new DonutJoinClosure(testRunner.client(nodeNum), node));
}","/**
 * Join {@link Node} with index {@code nodeNum} to the Donut ring referencing the {@Node}
 * with index {@code knownNode} as the known {@link Node} in the ring.
 * 
 * @param nodeNum
 */
public void join(int nodeNum, int knownNode) 
{
    Node newNode = new Node(nodeNum);
    newNode.setNext(nodes.get(knownNode));
    newNode.setPrev(nodes.get(knownNode).getPrev());
    nodes.get(knownNode).getPrev().setNext(newNode);
    nodes.get(knownNode).setPrev(newNode);
    nodes.put(nodeNum, newNode);
}   ",266,True
"/**
 * Leave {@link Node} with index {@code nodeNum} from the Donut ring.
 * 
 * @param nodeNum
 */
public void leave(int nodeNum){
    setClosure(new DonutLeaveClosure(testRunner.client(nodeNum), testRunner.getClientFactory(),
            testRunner.node(nodeNum).getTNode()));
}","/**
 * Leave {@link Node} with index {@code nodeNum} from the Donut ring.
 * 
 * @param nodeNum
 */
public void leave(int nodeNum) 
{
    if (nodeNum < 0 || nodeNum >= this.size)
        throw new IndexOutOfBoundsException(""Illegal index: "" + nodeNum);

    Node node = this.getNode(nodeNum);
    node.prev.next = node.next;
    node.next.prev = node.prev;
    this.size--;
}   ",267,True
"/**
 * Called periodically. Checks whether the predecessor has failed.
 */
public void checkPredecessor(){
    if (this.node.getPredecessor() != null && !ping(this.node.getPredecessor())) {
        // A predecessor is defined but could not be reached. Nullify the current predecessor
        LOGGER.warning(""Lost Predecessor ["" + Node.TNodeToString(node.getTNode())
                + ""]: Predecessor - "" + Node.TNodeToString(node.getPredecessor()));

        this.node.setPredecessor(null);
    }
}","/**
 * Called periodically. Checks whether the predecessor has failed.
 */
public void checkPredecessor() 
{
    try {
        if (predecessor != null) {
            if (!predecessor.isAlive()) {
                predecessor = null;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}   ",269,True
"/**
 * @param donutClient
 * @param knownNode
 *            {@link TNode} on which to join.
 */
public DonutJoinClosure(DonutClient donutClient, TNode knownNode){
    this.donutClient = donutClient;
    this.knownNode = knownNode;
}","/**
 * @param donutClient
 * @param knownNode
 *            {@link TNode} on which to join.
 */
public DonutJoinClosure(DonutClient donutClient, TNode knownNode) 
{
    this.donutClient = donutClient;
    this.knownNode = knownNode;
}   ",270,True
"/**
 * Initializes the successor list.
 */
private void initSuccessorList(){
    this.successorList = new ArrayList<TNode>(Constants.SUCCESSOR_LIST_SIZE);

    // Adds the initial successor
    for (int i = 0; i < Constants.SUCCESSOR_LIST_SIZE; i++)
        this.successorList.add(tNode);
}","/**
 * Initializes the successor list.
 */

private void initSuccessorList() 
{
    successorList = new ArrayList<>();
    for (int i = 0; i < 4; i++)
    {
        successorList.add(new ArrayList<>());
    }
}   ",272,False
"/**
 * Starts the worker threads.
 */
@Override
public void run(){
    super.run();

    stabilize.start();
    checkPredecessor.start();
    fixFingers.start();
}","/**
 * Starts the worker threads.
 */
@Override
public void run() 
{
    for (int i = 0; i < numThreads; i++)
    {
        Thread thread = new Thread(new Worker());
        thread.start();
    }
}   ",273,False
"/**
 * Initializes the finger table. The successor and all fingers will become this, creating a
 * complete chord ring.
 */
private void initFingers(){
    this.fingers = new ArrayList<TNode>(Constants.KEY_SPACE);
    for (int i = 0; i < Constants.KEY_SPACE; i++)
        this.fingers.add(tNode);
}","/**
 * Initializes the finger table. The successor and all fingers will become this, creating a
 * complete chord ring.
 */
private void initFingers() 
{
    for (int i = 0; i < finger.length; i++)
    {
        finger[i] = new FingerEntry();
        finger[i].start = this;
        finger[i].node = this;
    }
}   ",274,True
"/**
 * Creates a new RunAtInterval thread. Place the code to be repeated every interval milliseconds
 * in the runClosure() body. Call kill when you want to kill the thread
 * 
 * @param interval
 *            The interval between each time runClosure is called
 */
public AbstractRunAtInterval(int interval){
    if (interval <= 0)
        throw new IllegalArgumentException(""interval must be > 0"");
    this.interval = interval;
}","/**
 * Creates a new RunAtInterval thread. Place the code to be repeated every interval milliseconds
 * in the runClosure() body. Call kill when you want to kill the thread
 * 
 * @param interval
 *            The interval between each time runClosure is called
 */
public AbstractRunAtInterval(int interval) 
{
    this.interval = interval;
    this.kill = false;
}   ",275,True
"/**
 * Called periodically. Refreshes the finger table entries. nextFingerToUpdate stores the index
 * of the next finger to fix.
 */
public void fixFingers(){
    fixFinger(nextFingerToUpdate);

    nextFingerToUpdate = (nextFingerToUpdate + 1) % node.getFingers().size();
}","/**
 * Called periodically. Refreshes the finger table entries. nextFingerToUpdate stores the index
 * of the next finger to fix.
 */
public void fixFingers() 
{
    if (nextFingerToUpdate >= m)
        nextFingerToUpdate = 0;
    finger[nextFingerToUpdate].node = findSuccessor(finger[nextFingerToUpdate].start);
    nextFingerToUpdate++;
}   ",276,True
"/**
 * @param ids
 *            the ids of {@link Node}s that will be available to the Donut
 */
public DonutTestRunner(long... ids){
    nodeList = new ArrayList<Node>();
    serviceList = new ArrayList<DonutInMemoryHashTableService>();
    eventList = new PriorityQueue<DonutEvent>();
    clientList = new ArrayList<DonutClient>();
    clientFactory = new LocalLocatorClientFactory();
    for (int i = 0; i < ids.length; ++i) {
        createAndAddNode(""node"" + i, ids[i]);
    }
}","/**
 * @param ids
 *            the ids of {@link Node}s that will be available to the Donut
 */
public DonutTestRunner(long... ids) 
{
    this.ids = ids;
    this.donut = new Donut(ids);
}   ",277,False
"/**
 * Scans this Node's finger table for the closest preceding node to the given key.
 * 
 * @param entryId
 * @return the {@link Node} from the finger table that is the closest and preceding the entryId
 */
public TNode closestPrecedingNode(KeyId entryId) throws IllegalArgumentException{
    for (int i = fingers.size() - 1; i >= 0; --i) {
        KeyId currentFinger = getFinger(i).getNodeId();
        // (id, finger, us)
        // (finger, us, id)
        if (!currentFinger.equals(getNodeId())
                && KeyIdUtil.isAfterXButBeforeEqualY(entryId, currentFinger, getNodeId())) {
            return getFinger(i);
        }
    }
    return getTNode();
}","/**
 * Scans this Node's finger table for the closest preceding node to the given key.
 * 
 * @param entryId
 * @return the {@link Node} from the finger table that is the closest and preceding the entryId
 */
public TNode closestPrecedingNode(KeyId entryId) throws IllegalArgumentException 
{
    if (entryId == null)
    {
        throw new IllegalArgumentException(""Entry ID cannot be null"");
    }

    for (int i = fingerTable.size() - 1; i >= 0; i--)
    {
        TNode finger = fingerTable.get(i);
        if (finger != null && finger.getKeyId().compareTo(entryId) < 0)
        {
            return finger;
        }
    }
    return this;
}   ",278,True
"// $ANTLR start ""LCLOSE""
public final void mLCLOSE() throws RecognitionException{
    try {
        int _type = LCLOSE;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:184:9: ( '</' )
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:184:12: '</'
        {
        match(""</""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""LCLOSE""
public final void mLCLOSE() throws RecognitionException 
{
    try
    {
        int _type = LCLOSE;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\Users\\dani\\Documents\\Work\\Speciale\\Speciale\\Type.g:7:7: ( '}' )
        // C:\\Users\\dani\\Documents\\Work\\Speciale\\Speciale\\Type.g:7:9: '}'
        {
            match('}');

        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",280,False
"// $ANTLR start ""T__28""
public final void mT__28() throws RecognitionException{
    try {
        int _type = T__28;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:12:7: ( '<>' )
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:12:9: '<>'
        {
        match(""<>""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""T__28""
public final void mT__28() throws RecognitionException 
{
    try
    {
        int _type = T__28;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C.g4:7:7: ( '!' )
        // C.g4:7:9: '!'
        {
        match('!'); 

        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",281,False
"/**
 * 
 * @param args the ARGUMENTS AST node
 * @return a list of ASExpression
 */
public static List<IASExpression> astToExpressionList(LinkedListTree args){
	ASTIterator i = new ASTIterator(args);
	List<IASExpression> result = new ArrayList<IASExpression>(args.getChildCount());
	while (i.hasNext())
	{
		result.add(ExpressionBuilder.build(i.next()));
	}
	return Collections.unmodifiableList(result);
}","/**
 * 
 * @param args the ARGUMENTS AST node
 * @return a list of ASExpression
 */

public static List<IASExpression> astToExpressionList(LinkedListTree args) 
{
    List<IASExpression> result = new ArrayList<IASExpression>();
    for (Object obj : args.getChildren())
    {
        LinkedListTree ast = (LinkedListTree) obj;
        result.add(astToExpression(ast));
    }
    return result;
}   ",282,True
"// $ANTLR start ""XML_NAME""
public final void mXML_NAME() throws RecognitionException{
    try {
        int _type = XML_NAME;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:208:2: ( XML_NAME_START ( XML_NAME_PART )* )
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:208:4: XML_NAME_START ( XML_NAME_PART )*
        {
        mXML_NAME_START(); 
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:208:19: ( XML_NAME_PART )*
        loop3:
        do {
            int alt3=2;
            int LA3_0 = input.LA(1);

            if ( ((LA3_0>='-' && LA3_0<='.')||(LA3_0>='0' && LA3_0<=':')||(LA3_0>='A' && LA3_0<='Z')||LA3_0=='_'||(LA3_0>='a' && LA3_0<='z')) ) {
                alt3=1;
            }


            switch (alt3) {
        	case 1 :
        	    // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:208:19: XML_NAME_PART
        	    {
        	    mXML_NAME_PART(); 

        	    }
        	    break;

        	default :
        	    break loop3;
            }
        } while (true);


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""XML_NAME""
public final void mXML_NAME() throws RecognitionException 
{
    try
    {
        int _type = XML_NAME;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // /home/stevenj/workspace/stevenj/XQueryEngine/src/main/resources/XQuery.g4:7:11: ( LETTER ( LETTER | DIGIT )* )
        // /home/stevenj/workspace/stevenj/XQueryEngine/src/main/resources/XQuery.g4:7:13: LETTER ( LETTER | DIGIT )*
        {
        mLETTER(); 
        // /home/stevenj/workspace/stevenj/XQueryEngine/src/main/resources/XQuery.g4:7:20: ( LETTER | DIGIT )*
        loop1:
        do
        {
            int alt1=3;
            int LA1_0 = input.LA(1);

            if ( ((LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) )
            {
                alt1=1;
            }
            else if ( ((LA1_0 >= '0' && LA1_0 <= '9')) )
            {
                alt1=2;
            }


            switch (alt1)
            {
                case 1 :
                    // /home/stevenj/workspace/stevenj/XQueryEngine/src/main/resources/XQuery.g4:7:21: LETTER
                    {
                    mLETTER(); 

                    }
                    break;
                case 2 :
                    // /home/stevenj/workspace/stevenj/XQueryEngine/src/main/resources/XQuery.g4:7:29: DIGIT
                    {
                    mDIGIT(); 

                    }
                    break;

                default :
                    break loop1;
            }
        } while (true);


        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",283,False
"// $ANTLR end ""XML_TEXT""
public void mTokens() throws RecognitionException{
    // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:8: ( T__28 | T__29 | T__30 | XML_LCHEVRON | XML_RCHEVRON | LCLOSE | RCLOSE | WS | EOL | XML_NAME | XML_ATTRIBUTE_VALUE | XML_PI | XML_COMMENT | XML_CDATA | XML_TEXT )
    int alt10=15;
    alt10 = dfa10.predict(input);
    switch (alt10) {
        case 1 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:10: T__28
            {
            mT__28(); 

            }
            break;
        case 2 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:16: T__29
            {
            mT__29(); 

            }
            break;
        case 3 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:22: T__30
            {
            mT__30(); 

            }
            break;
        case 4 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:28: XML_LCHEVRON
            {
            mXML_LCHEVRON(); 

            }
            break;
        case 5 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:41: XML_RCHEVRON
            {
            mXML_RCHEVRON(); 

            }
            break;
        case 6 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:54: LCLOSE
            {
            mLCLOSE(); 

            }
            break;
        case 7 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:61: RCLOSE
            {
            mRCLOSE(); 

            }
            break;
        case 8 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:68: WS
            {
            mWS(); 

            }
            break;
        case 9 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:71: EOL
            {
            mEOL(); 

            }
            break;
        case 10 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:75: XML_NAME
            {
            mXML_NAME(); 

            }
            break;
        case 11 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:84: XML_ATTRIBUTE_VALUE
            {
            mXML_ATTRIBUTE_VALUE(); 

            }
            break;
        case 12 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:104: XML_PI
            {
            mXML_PI(); 

            }
            break;
        case 13 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:111: XML_COMMENT
            {
            mXML_COMMENT(); 

            }
            break;
        case 14 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:123: XML_CDATA
            {
            mXML_CDATA(); 

            }
            break;
        case 15 :
            // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:1:133: XML_TEXT
            {
            mXML_TEXT(); 

            }
            break;

    }

}","// $ANTLR end ""XML_TEXT""
public void mTokens() throws RecognitionException 
{
    // g4.g4
    int _type = XML_TEXT;
    int _channel = DEFAULT_TOKEN_CHANNEL;
    // g4.g4:4:8: ( ( '<' !)
    // g4.g4:4:10: '<' !
    {
        match('<');
        if (input.LA(1) == '!') {
            match('!');
        }
    }
}   ",288,False
"/**
 * Sets the token's <code>next</code> to this tokens <code>next</code>.
 * 
 * @param token The token to add after this token in the stream.
 */
public void appendToken(LinkedListToken token){
	if (token.getPrev() != null)
	{
		throw new IllegalArgumentException(""appendToken("" + token
				+ "") : prev was not null"");
	}
	if (token.getNext() != null)
	{
		throw new IllegalArgumentException(""appendToken("" + token
				+ "") : next was not null"");
	}
	token.next = next;
	token.prev = this;
	if (next != null)
	{
		next.prev = token;
	}
	next = token;
}","/**
 * Sets the token's <code>next</code> to this tokens <code>next</code>.
 * 
 * @param token The token to add after this token in the stream.
 */
public void appendToken(LinkedListToken token) 
{
    if (token != null)
    {
        token.setNext(this.next);
        this.next = token;
    }
}   ",289,True
"/**
 * Escape the given String and place within double quotes so that it
 * will be a valid ActionScript string literal.
 */
public static String str(String str){
	StringBuffer result = new StringBuffer(""\"""");
	for (int i = 0; i < str.length(); i++)
	{
		char c = str.charAt(i);
		switch (c)
		{
		case '\n':
			result.append(""\\n"");
			break;
		case '\t':
			result.append(""\\t"");
			break;
		case '\r':
			result.append(""\\r"");
			break;
		case '""':
			result.append(""\\\"""");
			break;
		case '\\':
			result.append(""\\\\"");
			break;
		default:
			result.append(c);
		}
	}
	result.append('""');
	return result.toString();
}","/**
 * Escape the given String and place within double quotes so that it
 * will be a valid ActionScript string literal.
 */
public static String str(String str) 
{
    StringBuilder buf = new StringBuilder();
    buf.append('""');

    for (int i = 0; i < str.length(); i++)
    {
        char c = str.charAt(i);

        switch (c)
        {
            case '""':
                buf.append(""\\\"""");
                break;
            case '\\':
                buf.append(""\\\\"");
                break;
            case '\b':
                buf.append(""\\b"");
                break;
            case '\f':
                buf.append(""\\f"");
                break;
            case '\n':
                buf.append(""\\n"");
                break;
            case '\r':
                buf.append(""\\r"");
                break;
            case '\t':
                buf.append(""\\t"");
                break;
            default:
                buf.append(c);
        }
    }

    buf.append('""');

    return buf.toString();
}   ",290,True
"/**
 * Deletes any whitespace tokens following (but not including) the given
 * token up to a comma token, and then deletes the comma token too.
 * 
 * Used when removing elements from comma-separated lists.
 */
public static void removeTrailingWhitespaceAndComma(
		LinkedListToken stopToken){
	for (LinkedListToken tok = stopToken.getNext(); tok != null; tok = tok.getNext())
	{
		if (tok.getChannel() == AS3Parser.HIDDEN)
		{
			// TODO: this might be incorrect (but never called?) see code in removePreceeding...
			tok.deleteToken();
		}
		else if (tok.getType() == AS3Parser.COMMA)
		{
			tok.deleteToken();
			break;
		}
		else
		{
			throw new ASBlocksSyntaxError(""Unexpected token: "" + tok);
		}
	}
}","/**
 * Deletes any whitespace tokens following (but not including) the given
 * token up to a comma token, and then deletes the comma token too.
 * 
 * Used when removing elements from comma-separated lists.
 */
public static void removeTrailingWhitespaceAndComma(
		LinkedListToken stopToken) 
{
	LinkedListToken token = stopToken.getNextToken();
	while (token != null && token.getType() != TokenType.COMMA) {
		if (token.getType() == TokenType.WHITESPACE) {
			token.delete();
		}
		token = token.getNextToken();
	}
	if (token != null) {
		token.delete();
	}
}	",294,False
"// $ANTLR start ""T__29""
public final void mT__29() throws RecognitionException{
    try {
        int _type = T__29;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:13:7: ( '</>' )
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:13:9: '</>'
        {
        match(""</>""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""T__29""
public final void mT__29() throws RecognitionException 
{
    try
    {
        int _type = T__29;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // D:\\Dropbox\\code\\semantic\\UniRule.g4:7:7: ( '!' )
        // D:\\Dropbox\\code\\semantic\\UniRule.g4:7:9: '!'
        {
        match('!');

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",295,False
"/**
 * @private
 */
private static String visitNodes(LinkedListTree ast, String result,
		int level, boolean location){
	if (location)
	{
		result += ""<"" + tokenName(ast.getType()) + "" line=\""""
				+ ast.getLine() + ""\"">"";

		//			result += ""<"" + tokenName(ast.type) + "" line=\"""" + 
		//				ast.line + ""\"" column=\"""" + ast.charPositionInLine + ""\"">"";
	}
	else
	{
		result += ""<"" + tokenName(ast.getType()) + "">"";
	}

	int numChildren = ast.getChildCount();
	if (numChildren > 0)
	{
		for (int i = 0; i < numChildren; i++)
		{
			result = visitNodes((LinkedListTree) ast.getChild(i), result, level + 1, location);
		}
	}
	else if (ast.getText() != null)
	{
		result += escapeEntities(ast.getText());
	}

	result += ""</"" + tokenName(ast.getType()) + "">"";

	return result;
}","/**
 * @private
 */
private static String visitNodes(LinkedListTree ast, String result,
		int level, boolean location) 
{
	String node = ast.getNode();
	if (node != null)
	{
		result = visitNode(ast, result, level, location);
	}

	for (int i = 0; i < ast.getChildCount(); i++)
	{
		result = visitNodes((LinkedListTree) ast.getChild(i), result, level + 1,
				location);
	}

	return result;
}	",296,True
"// $ANTLR start ""WS""
public final void mWS() throws RecognitionException{
    try {
        int _type = WS;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:190:4: ( ( ' ' | '\\t' | '\\f' )+ )
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:190:6: ( ' ' | '\\t' | '\\f' )+
        {
        // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:190:6: ( ' ' | '\\t' | '\\f' )+
        int cnt1=0;
        loop1:
        do {
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0=='\t'||LA1_0=='\f'||LA1_0==' ') ) {
                alt1=1;
            }


            switch (alt1) {
        	case 1 :
        	    // C:\\projects\\jasblocks\\as3-commons-jasblocks\\src\\main\\java\\org\\as3commons\\asblocks\\parser\\antlr\\e4x\\E4X.g:
        	    {
        	    if ( input.LA(1)=='\t'||input.LA(1)=='\f'||input.LA(1)==' ' ) {
        	        input.consume();

        	    }
        	    else {
        	        MismatchedSetException mse = new MismatchedSetException(null,input);
        	        recover(mse);
        	        throw mse;}


        	    }
        	    break;

        	default :
        	    if ( cnt1 >= 1 ) break loop1;
                    EarlyExitException eee =
                        new EarlyExitException(1, input);
                    throw eee;
            }
            cnt1++;
        } while (true);

        _channel=HIDDEN;

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""WS""
public final void mWS() throws RecognitionException 
{
    try
    {
        {
        matchAny();
        }
    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return;
}   ",297,False
"/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param s1
 * @param s2
 */
public static void assertEquals(String message, String[] s1, String[] s2){
    String comparisonDumpIfNotEqual = verifyEqualsAndReturnComparisonDumpIfNot(
            message, s1, s2);
    if (comparisonDumpIfNotEqual != null)
        throw new AssertionError(comparisonDumpIfNotEqual);
}","/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param s1
 * @param s2
 */
public static void assertEquals(String message, String[] s1, String[] s2) 
{
    if (!Arrays.equals(s1, s2))
    {
        fail(message + "": expected "" + Arrays.toString(s1) + "" but was ""
                + Arrays.toString(s2));
    }
}   ",300,True
"/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param obj1
 * @param obj2
 */
public static void assertNotEquals(String message, Object obj1, Object obj2){
    if (obj1.equals(obj2)) {
        message = formattedMessage(message);
        fail(message + ""did not expect values to be equal (""
                + obj1.toString() + "")"");
    }
}","/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param obj1
 * @param obj2
 */
public static void assertNotEquals(String message, Object obj1, Object obj2) 
{
    if (obj1 == null)
    {
        if (obj2 == null)
        {
            throw new AssertionError(message);
        }
    }
    else if (obj1.equals(obj2))
    {
        throw new AssertionError(message);
    }
}   ",301,True
"/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @return
 */
private static String formattedMessage(String message){
    if (null == message)
        message = """";
    if (message.equals(""""))
        return message;
    return message + "" , "";
}","/**
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @return
 */
private static String formattedMessage(String message) 
{
    return message == null ? """" : "" ["" + message + ""]"";
}   ",305,True
"/**
 * Waits for page load, and dojo to be ready, and if dojo is not ready, it
 * clicks the button with <code>elementId</code> again
 * 
 * @param elementId
 * @return
 */
private boolean waitForPageLoadAndDojoReady(String elementId){
    selenium.waitForPageToLoad(PAGE_LOAD_TIMEOUT);
    try {
        Thread.sleep(PAGE_READY_TIMEOUT);
        if (isDojoLoaded(false)) {
            return false;
        }
    }
    catch (InterruptedException e) {
        e.printStackTrace();
    }
    selenium.click(elementId);
    return true;
}","/**
 * Waits for page load, and dojo to be ready, and if dojo is not ready, it
 * clicks the button with <code>elementId</code> again
 * 
 * @param elementId
 * @return
 */
private boolean waitForPageLoadAndDojoReady(String elementId) 
{
    try
    {
        waitForPageLoad();
        waitForDojoReady();
        return true;
    }
    catch (Exception e)
    {
        clickElement(elementId);
        waitForPageLoad();
        waitForDojoReady();
        return true;
    }
}   ",306,False
"/**
 * 
 * @param sa
 * @param c
 * @return
 */
public static String joinStrArray(String[] sa, char c){
    StringBuffer sb = new StringBuffer();
    for (int j = 0; j < sa.length; ++j) {
        sb.append(sa[j]);
        if (j < sa.length - 1) {
            sb.append(c);
        }
    }
    return sb.toString();
}","/**
 * 
 * @param sa
 * @param c
 * @return
 */
public static String joinStrArray(String[] sa, char c) 
{
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < sa.length; i++)
    {
        sb.append(sa[i]);
        if (i < sa.length - 1)
        {
            sb.append(c);
        }
    }
    return sb.toString();
}   ",307,True
"/**
 * Refreshes the page at max 5 times and waits for dojo to be ready.
 */
public void waitForDojoReady(){
    int i = 0;
    while (i < 5 && !isDojoLoaded(true)) {
        selenium.refresh();
        i++;
        try {
            Thread.sleep(PAGE_READY_TIMEOUT);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}","/**
 * Refreshes the page at max 5 times and waits for dojo to be ready.
 */
public void waitForDojoReady() 
{
    int i = 0;
    while (i < 5)
    {
        sleep(1000);
        if (selenium.isElementPresent(""dojo""))
        {
            break;
        }
        i++;
    }
}   ",316,True
"/**
 * Wait for DEFAULT_WAIT_PERIOD seconds for some element to change its text
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param newValue
 *            - the value which the element expects to change
 * @param element
 *            - element id like ""form:input""
 * @param seconds
 *            - maximum number of seconds to wait for the condition to be
 *            true
 */
public void waitForTextToChange(String message, String newValue,
        String element, int seconds){
    for (int second = 0;; second++) {
        if (second >= seconds) {
            try {
                message = formattedMessage(message);
                fail(message + ""Timeout: the element: "" + element
                        + "" could not change its text to "" + newValue);
            }
            catch (Error e) {
                this.verificationErrors.append(throwableToString(e));
                break;
            }
        }
        try {
            if (newValue.equals(selenium.getText(element)))
                break;
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}","/**
 * Wait for DEFAULT_WAIT_PERIOD seconds for some element to change its text
 * 
 * @param message
 *            - message hint in case of assertion failure
 * @param newValue
 *            - the value which the element expects to change
 * @param element
 *            - element id like ""form:input""
 * @param seconds
 *            - maximum number of seconds to wait for the condition to be
 *            true
 */
public void waitForTextToChange(String message, String newValue,
        String element, int seconds) 
{
    int i = 0;
    while (i++ < seconds)
    {
        String text = getText(element);
        if (!text.equals(newValue))
            return;
        try
        {
            Thread.sleep(DEFAULT_WAIT_PERIOD);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
    fail(message);
}       ",318,True
"/**
 * Gets the value of the author property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the author property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAuthor().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getAuthor(){
    if (author == null) {
        author = new ArrayList<String>();
    }
    return this.author;
}","/**
 * Gets the value of the author property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the author property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAuthor().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getAuthor() 
{
    if (author == null)
    {
        author = new ArrayList<String>();
    }
    return this.author;
}   ",320,True
"/**
 * Gets the value of the entityOrViewEntityOrExtendEntity property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the entityOrViewEntityOrExtendEntity property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getEntityOrViewEntityOrExtendEntity().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Entity }
 * {@link ExtendEntity }
 * {@link ViewEntity }
 * 
 * 
 */
public List<Object> getEntityOrViewEntityOrExtendEntity(){
    if (entityOrViewEntityOrExtendEntity == null) {
        entityOrViewEntityOrExtendEntity = new ArrayList<Object>();
    }
    return this.entityOrViewEntityOrExtendEntity;
}","/**
 * Gets the value of the entityOrViewEntityOrExtendEntity property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the entityOrViewEntityOrExtendEntity property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getEntityOrViewEntityOrExtendEntity().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Entity }
 * {@link ExtendEntity }
 * {@link ViewEntity }
 * 
 * 
 */
public List<Object> getEntityOrViewEntityOrExtendEntity() 
{
    if (entityOrViewEntityOrExtendEntity == null)
    {
        entityOrViewEntityOrExtendEntity = new ArrayList<Object>();
    }
    return this.entityOrViewEntityOrExtendEntity;
}   ",321,True
"/**
 * Gets the value of the enableLock property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getEnableLock(){
    if (enableLock == null) {
        return Boolean.FALSE;
    } else {
        return enableLock;
    }
}","/**
 * Gets the value of the enableLock property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getEnableLock() 
{
    return enableLock;
}   ",325,True
"/**
 * Gets the value of the keyMap property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the keyMap property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getKeyMap().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link KeyMap }
 * 
 * 
 */
public List<KeyMap> getKeyMap(){
    if (keyMap == null) {
        keyMap = new ArrayList<KeyMap>();
    }
    return this.keyMap;
}","/**
 * Gets the value of the keyMap property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the keyMap property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getKeyMap().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link KeyMap }
 * 
 * 
 */
public List<KeyMap> getKeyMap() 
{
    if (keyMap == null)
    {
        keyMap = new ArrayList<KeyMap>();
    }
    return this.keyMap;
}   ",326,True
"/**
 * Gets the value of the relation property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the relation property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getRelation().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Relation }
 * 
 * 
 */
public List<Relation> getRelation(){
    if (relation == null) {
        relation = new ArrayList<Relation>();
    }
    return this.relation;
}","/**
 * Gets the value of the relation property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the relation property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getRelation().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Relation }
 * 
 * 
 */
public List<Relation> getRelation() 
{
    if (relation == null)
    {
        relation = new ArrayList<Relation>();
    }
    return this.relation;
}   ",327,True
"/**
 * Gets the value of the neverCheck property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getNeverCheck(){
    if (neverCheck == null) {
        return Boolean.FALSE;
    } else {
        return neverCheck;
    }
}","/**
 * Gets the value of the neverCheck property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getNeverCheck() 
{
    return neverCheck;
}   ",328,True
"/**
 * Gets the value of the unique property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getUnique(){
    if (unique == null) {
        return Boolean.FALSE;
    } else {
        return unique;
    }
}","/**
 * Gets the value of the unique property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getUnique() 
{
    return unique;
}   ",329,True
"/**
 * Gets the value of the field property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the field property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getField().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Field }
 * 
 * 
 */
public List<Field> getField(){
    if (field == null) {
        field = new ArrayList<Field>();
    }
    return this.field;
}","/**
 * Gets the value of the field property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the field property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getField().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Field }
 * 
 * 
 */
public List<Field> getField() 
{
    if (field == null)
    {
        field = new ArrayList<Field>();
    }
    return this.field;
}   ",330,True
"/**
 * Gets the value of the ignoreCase property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getIgnoreCase(){
    if (ignoreCase == null) {
        return Boolean.FALSE;
    } else {
        return ignoreCase;
    }
}","/**
 * Gets the value of the ignoreCase property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getIgnoreCase() 
{
    return ignoreCase;
}   ",333,True
"/**
 * Gets the value of the index property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the index property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getIndex().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Index }
 * 
 * 
 */
public List<Index> getIndex(){
    if (index == null) {
        index = new ArrayList<Index>();
    }
    return this.index;
}","/**
 * Gets the value of the index property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the index property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getIndex().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Index }
 * 
 * 
 */
public List<Index> getIndex() 
{
    if (index == null)
    {
        index = new ArrayList<Index>();
    }
    return this.index;
}   ",336,True
"/**
 * Gets the value of the exclude property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the exclude property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getExclude().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Exclude }
 * 
 * 
 */
public List<Exclude> getExclude(){
    if (exclude == null) {
        exclude = new ArrayList<Exclude>();
    }
    return this.exclude;
}","/**
 * Gets the value of the exclude property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the exclude property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getExclude().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Exclude }
 * 
 * 
 */
public List<Exclude> getExclude() 
{
    if (exclude == null)
    {
        exclude = new ArrayList<Exclude>();
    }
    return this.exclude;
}   ",338,True
"/**
 * Gets the value of the autoClearCache property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getAutoClearCache(){
    if (autoClearCache == null) {
        return Boolean.TRUE;
    } else {
        return autoClearCache;
    }
}","/**
 * Gets the value of the autoClearCache property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public Boolean getAutoClearCache() 
{
    return autoClearCache;
}   ",339,True
"//---------------------------------------------------------------------------------------- backup
/**
 * Backups RealInventory to a copy of the inventory
 */
public ArrayList<ItemStack[]> backup(){
	itemStackBackup = new ArrayList<ItemStack[]>();
	for (int i = 0; i < inventories.length; i++) {
		itemStackBackup.add(inventories[i].getContents().clone());
	}
	return itemStackBackup;
}","//---------------------------------------------------------------------------------------- backup
/**
 * Backups RealInventory to a copy of the inventory
 */
public ArrayList<ItemStack[]> backup() 
{
    ArrayList<ItemStack[]> backup = new ArrayList<ItemStack[]>();
    for(int i = 0; i < inventory.length; i++)
    {
        backup.add(i, inventory[i].clone());
    }
    return backup;
}   ",340,True
"//-------------------------------------------------------------------------------------- moveFrom
public boolean moveFrom(RealInventory source, int typeId, int amount, short durability){
	ArrayList<ItemStack[]> itemStackBackup = source.backup();
	if (source.remove(typeId, amount, durability)) {
		if (add(typeId, amount, durability)) {
			return true;
		}
		source.restore(itemStackBackup);
	}
	return false;
}","//-------------------------------------------------------------------------------------- moveFrom
public boolean moveFrom(RealInventory source, int typeId, int amount, short durability) 
{
    if (amount <= 0)
        return false;

    if (amount > _itemCount)
        return false;

    if (typeId != _typeId)
        return false;

    if (durability != _durability)
        return false;

    if (!source.decreaseItemCount(_item, amount))
        return false;

    increaseItemCount(_item, amount);
    return true;
}   ",341,True
"//-------------------------------------------------------------------- loadFromRealChestInventory
/**
 * Clear current inventory (if set) and link RealInventory to a chest's inventory
 * (including the neighbor chest inventory if big chest)
 */
private void loadFromRealChestInventory(RealChest chest){
	clear();
	chests[0] = chest.getMainChest();
	chests[1] = chest.getNeighborChest();
	inventories = new Inventory[(chests[1] == null) ? 1 : 2];
	inventories[0] = chests[0].getInventory();
	if (chests[1] != null) {
		inventories[1] = chests[1].getInventory();
	}
}","//-------------------------------------------------------------------- loadFromRealChestInventory
/**
 * Clear current inventory (if set) and link RealInventory to a chest's inventory
 * (including the neighbor chest inventory if big chest)
 */
private void loadFromRealChestInventory(RealChest chest) 
{
    if (this.inventory != null) {
        this.inventory.clear();
    }
    this.inventory = new RealInventory(chest.getInventory());
    if (chest.isDoubleChest()) {
        this.inventory.addInventory(chest.getNeighborInventory());
    }
}   ",344,True
"//-------------------------------------------------------------------------------------- toString
/**
 * This translate the inventories content into string
 * Use it for debugging
 */
@Override
public String toString(){
	String string = ""##### RealInventory object :\n"";
	for (int i = 0; i < inventories.length; i++) {
		string += ""- INVENTORY i\n"";
		ItemStack[] itemStackList = inventories[i].getContents();
		for (int j = 0; j < itemStackList.length; j++) {
			ItemStack itemStack = itemStackList[j];
			string += ""- "" + j
			+ "": typeId="" + itemStack.getTypeId()
			+ "", amount="" + itemStack.getAmount()
			+ "", durability="" + itemStack.getDurability()
			+ ""\n"";
		}
	}
	string += ""##### RealInventory object end"";
	return string;
}","//-------------------------------------------------------------------------------------- toString
/**
 * This translate the inventories content into string
 * Use it for debugging
 */

@Override
public String toString() 
{
    String str = """";
    for (int i = 0; i < inventory.size(); i++)
    {
        str += inventory.get(i).toString() + ""\n"";
    }
    return str;
}   ",346,False
"//--------------------------------------------------------------------------------- RealItemStack
public RealItemStack(int typeId, int amount, short durability){
	setTypeId(typeId);
	setAmount(amount);
	setDurability(durability);
}","//--------------------------------------------------------------------------------- RealItemStack
public RealItemStack(int typeId, int amount, short durability) 
{
	this.typeId = typeId;
	this.amount = amount;
	this.durability = durability;
}   ",347,True
"//------------------------------------------------------------------------------------- loadValue
@Override
protected boolean loadValue(String key, String value){
	if (super.loadValue(key, value)) {
		return true;
	}
	if (key.equals(""amountRatio"")) {
		try {
			amountRatio = Double.parseDouble(value);
		} catch (Exception e) {
			amountRatio = 5000.0;
		}
		return true;
	}
	if (key.equals(""buySellRatio"")) {
		try {
			buySellRatio = Double.parseDouble(value);
		} catch (Exception e) {
			buySellRatio = .95;
		}
		return true;
	}
	if (key.equals(""dailyPricesCalculation"")) {
		dailyPricesCalculation = value;
		return true;
	}
	if (key.equals(""economyPlugin"")) {
		economyPlugin = value;
		return true;
	}
	if (key.equals(""maxDailyRatio"")) {
		try {
			maxDailyRatio = Double.parseDouble(value);
		} catch (Exception e) {
			maxDailyRatio = 1.95;
		}
		return true;
	}
	if (key.equals(""maxItemPrice"")) {
		try {
			maxItemPrice = Double.parseDouble(value);
		} catch (Exception e) {
			maxItemPrice = 99999.0;
		}
		return true;
	}
	if (key.equals(""minDailyRatio"")) {
		try {
			minDailyRatio = Double.parseDouble(value);
		} catch (Exception e) {
			minDailyRatio = .05;
		}
		return true;
	}
	if (key.equals(""minItemPrice"")) {
		try {
			minItemPrice = Double.parseDouble(value);
		} catch (Exception e) {
			minItemPrice = .1;
		}
		return true;
	}
	if (key.equals(""permissionsPlugin"")) {
		permissionsPlugin = value;
		return true;
	}
	if (key.equals(""shopDamagedItems"")) {
		shopDamagedItems = value;
		return true;
	}
	if (key.equals(""shopInfiniteBuy"")) {
		shopInfiniteBuy = value;
		return true;
	}
	if (key.equals(""shopInfiniteSell"")) {
		shopInfiniteSell = value;
		return true;
	}
	if (key.equals(""shopMarketItemsOnly"")) {
		shopMarketItemsOnly = value;
		return true;
	}
	if (key.equals(""shopOpOnly"")) {
		shopOpOnly = value;
		return true;
	}
	if (key.equals(""workForceRatio"")) {
		try {
			workForceRatio = Double.parseDouble(value);
		} catch (Exception e) {
			workForceRatio = 1.1;
		}
		return true;
	}
	return false;
}","//------------------------------------------------------------------------------------- loadValue
@Override
protected boolean loadValue(String key, String value) 
{
    if (key.equals(""value""))
    {
        this.value = value;
        return true;
    }
    return false;
}   ",351,False
"//------------------------------------------------------------------------------------------- add
/**
 * Add an amount of item into the inventory
 * Return false if not enough space in inventory
 */
public boolean add(int typeId, int amount, short durability){
	backup();
	for (int i = 0; i < inventories.length; i++) {
		HashMap<Integer, ItemStack> remaining = inventories[i].addItem(
			new ItemStack(typeId, amount, durability)
		);
		update();
		if (remaining.isEmpty()) {
			return true;
		} else {
			amount = remaining.get(0).getAmount();
		}
	}
	restore();
	return false;
}","//------------------------------------------------------------------------------------------- add
/**
 * Add an amount of item into the inventory
 * Return false if not enough space in inventory
 */
public boolean add(int typeId, int amount, short durability) 
{
    if (amount <= 0 || typeId <= 0)
        return false;

    ItemTemplate template = ItemTemplate.get(typeId);
    if (template == null)
        return false;

    int slot = getFreeSlot();
    if (slot == -1)
        return false;

    Item item = new Item(typeId, amount, durability);
    contents[slot] = item;
    return true;
}   ",354,False
"//---------------------------------------------------------------------------- storeRealItemStack
/**
 * Store ItemStack items descriptions into inventory
 * - positive quantities additions, negative quantities removal
 * - if reverse is set to true, negative quantities addition, positive quantities removal
 * - if any add / remove error, then cancel the whole operation and return false
 * - return true if everything is OK
 */
public boolean storeRealItemStack(RealItemStack itemStack, boolean reverse){
	boolean ok = true;
	int amount = (reverse ? -itemStack.getAmount() : itemStack.getAmount());
	if (amount < 0) {
		ok = remove(itemStack.getTypeId(), -amount, itemStack.getDurability());
	} else {
		ok = add(itemStack.getTypeId(), amount, itemStack.getDurability());
	}
	return ok;
}","//---------------------------------------------------------------------------- storeRealItemStack
/**
 * Store ItemStack items descriptions into inventory
 * - positive quantities additions, negative quantities removal
 * - if reverse is set to true, negative quantities addition, positive quantities removal
 * - if any add / remove error, then cancel the whole operation and return false
 * - return true if everything is OK
 */
public boolean storeRealItemStack(RealItemStack itemStack, boolean reverse) 
{
    if (itemStack == null) return false;
    if (itemStack.quantity == 0) return true;
    if (reverse) itemStack.quantity = -itemStack.quantity;
    boolean result = storeItemStack(itemStack);
    if (reverse) itemStack.quantity = -itemStack.quantity;
    return result;
}   ",355,True
"//------------------------------------------------------------------------------------------ save
/*
 * Save values. Override original to add my own configuration values.
 */
@Override
protected void saveValues(BufferedWriter writer){
	super.saveValues(writer);
	saveValue(writer, ""amountRatio"");
	saveValue(writer, ""buySellRatio"");
	saveValue(writer, ""dailyPricesCalculation"");
	saveValue(writer, ""economyPlugin"");
	saveValue(writer, ""maxDailyRatio"");
	saveValue(writer, ""maxItemPrice"");
	saveValue(writer, ""minDailyRatio"");
	saveValue(writer, ""minItemPrice"");
	saveValue(writer, ""permissionsPlugin"");
	saveValue(writer, ""shopDamagedItems"");
	saveValue(writer, ""shopInfiniteBuy"");
	saveValue(writer, ""shopInfiniteSell"");
	saveValue(writer, ""shopMarketItemsOnly"");
	saveValue(writer, ""shopOpOnly"");
	saveValue(writer, ""workForceRatio"");
}","//------------------------------------------------------------------------------------------ save
/*
 * Save values. Override original to add my own configuration values.
 */
@Override
protected void saveValues(BufferedWriter writer) 
{
    try
    {
        writer.write(""myValue="" + myValue);
        writer.newLine();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",358,True
"//----------------------------------------------------------------------------------------- clear
/**
 * Clear inventory, resetting its collection of arrays of ItemStack objects
 */
private void clear(){
	chests = new Chest[2];
	inventories = new Inventory[0];
}","//----------------------------------------------------------------------------------------- clear
/**
 * Clear inventory, resetting its collection of arrays of ItemStack objects
 */
private void clear() 
{
    for (int i = 0; i < this.inventory.length; i++)
    {
        this.inventory[i] = null;
    }
}   ",359,True
"/**
 * Handles clicks on the list items
 */
@Override
protected void onListItemClick(ListView list, View view, int position, long id){
    boolean isChecked = list.isItemChecked(position);
    mChecked.set(position, isChecked);
    if (position == 0) {
        mSyncAllGroups = isChecked;
        adjustChecks();
    }
}","/**
 * Handles clicks on the list items
 */



@Override
protected void onListItemClick(ListView list, View view, int position, long id) 
{
    super.onListItemClick(list, view, position, id);

    // Get the selected item text from the TextView
    TextView textView = (TextView) view.findViewById(R.id.label);
    String text = textView.getText().toString();

    // Display a Toast message with the selected item text
    Toast.makeText(this, text, Toast.LENGTH_SHORT).show();
}   ",360,False
"/**
 * Try guessing the next-best type of {@link EditEntry} to insert into the
 * given list. We walk down the precedence list until we find a type that
 * doesn't exist yet, or default to the lowest ranking type.
 */
private int guessNextType(ArrayList<EditEntry> entries, int[] precedenceList){
    // Keep track of the types we've seen already
    SparseBooleanArray existAlready = new SparseBooleanArray(entries.size());

    for (int i = entries.size() - 1; i >= 0; i--) {
        EditEntry entry = entries.get(i);

        if (!entry.isDeleted) {
            existAlready.put(entry.type, true);
        }
    }

    // Pick the first item we haven't seen
    for (int type : precedenceList) {
        if (!existAlready.get(type, false)) {
            return type;
        }
    }

    // Otherwise default to last item
    return precedenceList[precedenceList.length - 1];
}","/**
 * Try guessing the next-best type of {@link EditEntry} to insert into the
 * given list. We walk down the precedence list until we find a type that
 * doesn't exist yet, or default to the lowest ranking type.
 */
private int guessNextType(ArrayList<EditEntry> entries, int[] precedenceList) 
{
    int type = 0;
    for (int i = 0; i < precedenceList.length; i++) {
        type = precedenceList[i];
        boolean found = false;
        for (int j = 0; j < entries.size(); j++) {
            if (entries.get(j).getType() == type) {
                found = true;
                break;
            }
        }
        if (!found) {
            break;
        }
    }
    return type;
}   ",362,False
"/**
 * Handle clicks from the dialpad chooser.
 */
public void onItemClick(AdapterView parent, View v, int position, long id){
    DialpadChooserAdapter.ChoiceItem item =
            (DialpadChooserAdapter.ChoiceItem) parent.getItemAtPosition(position);
    int itemId = item.id;
    switch (itemId) {
        case DialpadChooserAdapter.DIALPAD_CHOICE_USE_DTMF_DIALPAD:
            // Log.i(TAG, ""DIALPAD_CHOICE_USE_DTMF_DIALPAD"");
            // Fire off an intent to go back to the in-call UI
            // with the dialpad visible.
            returnToInCallScreen(true);
            break;

        case DialpadChooserAdapter.DIALPAD_CHOICE_RETURN_TO_CALL:
            // Log.i(TAG, ""DIALPAD_CHOICE_RETURN_TO_CALL"");
            // Fire off an intent to go back to the in-call UI
            // (with the dialpad hidden).
            returnToInCallScreen(false);
            break;

        case DialpadChooserAdapter.DIALPAD_CHOICE_ADD_NEW_CALL:
            // Log.i(TAG, ""DIALPAD_CHOICE_ADD_NEW_CALL"");
            // Ok, guess the user really did want to be here (in the
            // regular Dialer) after all.  Bring back the normal Dialer UI.
            showDialpadChooser(false);
            break;

        default:
            Log.w(TAG, ""onItemClick: unexpected itemId: "" + itemId);
            break;
    }
}","/**
 * Handle clicks from the dialpad chooser.
 */
public void onItemClick(AdapterView parent, View v, int position, long id) 
{
    switch (position)
    {
        case 0:
            // ""Call"" button
            makePhoneCall();
            break;
        case 1:
            // ""Text"" button
            sendSMS();
            break;
        case 2:
            // ""Email"" button
            sendEmail();
            break;
        case 3:
            // ""Map"" button
            showMap();
            break;
        case 4:
            // ""Share"" button
            share();
            break;
        case 5:
            // ""Delete"" button
            delete();
            break;
    }
}   ",365,False
"/**
 * Dumps the entry into a HashMap suitable for passing to the database.
 * 
 * @param values the HashMap to fill in.
 * @return true if the value should be saved, false otherwise
 */
public boolean toValues(ContentValues values){
    boolean success = false;
    String labelString = null;

    // Save the type and label
    if (view != null) {
        // Read the possibly updated label from the text field
        labelString = ((TextView) view.findViewById(R.id.label)).getText().toString();
    }
    switch (kind) {
    case Contacts.KIND_PHONE:
        if (type != Phones.TYPE_CUSTOM) {
            labelString = null;
        }
        values.put(Phones.LABEL, labelString);
        values.put(Phones.TYPE, type);
        break;

    case Contacts.KIND_EMAIL:
        if (type != ContactMethods.TYPE_CUSTOM) {
            labelString = null;
        }
        values.put(ContactMethods.LABEL, labelString);
        values.put(ContactMethods.KIND, kind);
        values.put(ContactMethods.TYPE, type);
        break;

    case Contacts.KIND_IM:
        values.put(ContactMethods.KIND, kind);
        values.put(ContactMethods.TYPE, ContactMethods.TYPE_OTHER);
        values.putNull(ContactMethods.LABEL);
        if (type != -1) {
            values.put(ContactMethods.AUX_DATA,
                    ContactMethods.encodePredefinedImProtocol(type));
        } else {
            values.put(ContactMethods.AUX_DATA,
                    ContactMethods.encodeCustomImProtocol(
                    label.toString()));
        }
        break;

    case Contacts.KIND_POSTAL:
        if (type != ContactMethods.TYPE_CUSTOM) {
            labelString = null;
        }
        values.put(ContactMethods.LABEL, labelString);
        values.put(ContactMethods.KIND, kind);
        values.put(ContactMethods.TYPE, type);
        break;

    case Contacts.KIND_ORGANIZATION:
        if (type != ContactMethods.TYPE_CUSTOM) {
            labelString = null;
        }
        values.put(ContactMethods.LABEL, labelString);
        values.put(ContactMethods.TYPE, type);
        // Save the title
        if (view != null) {
            // Read the possibly updated data from the text field
            data2 = ((TextView) view.findViewById(R.id.data2)).getText().toString();
        }
        if (!TextUtils.isGraphic(data2)) {
            values.putNull(Organizations.TITLE);
        } else {
            values.put(Organizations.TITLE, data2.toString());
            success = true;
        }
        break;

    default:
        Log.w(TAG, ""unknown kind "" + kind);
        values.put(ContactMethods.LABEL, labelString);
        values.put(ContactMethods.KIND, kind);
        values.put(ContactMethods.TYPE, type);
        break;
    }

    // Only set the ISPRIMARY flag if part of the incoming data.  This is because the
    // ContentProvider will try finding a new primary when setting to false, meaning
    // it's possible to lose primary altogether as we walk down the list.  If this editor
    // implements editing of primaries in the future, this will need to be revisited.
    if (isPrimary) {
        values.put(ContactMethods.ISPRIMARY, 1);
    }

    // Save the data
    if (view != null && syncDataWithView) {
        // Read the possibly updated data from the text field
        data = ((TextView) view.findViewById(R.id.data)).getText().toString();
    }
    if (!TextUtils.isGraphic(data)) {
        values.putNull(column);
        return success;
    } else {
        values.put(column, data.toString());
        return true;
    }
}","/**
 * Dumps the entry into a HashMap suitable for passing to the database.
 * 
 * @param values the HashMap to fill in.
 * @return true if the value should be saved, false otherwise
 */
public boolean toValues(ContentValues values) 
{
    if (this.id == null)
    {
        return false;
    }

    values.put(""id"", this.id);
    values.put(""name"", this.name);
    values.put(""type"", this.type);
    values.put(""value"", this.value);
    values.put(""timestamp"", this.timestamp);

    return true;
}   ",366,False
"/**
 * Create a new IM address entry with the given data.
 *
 * @param label label for the item, from the db not the display label
 * @param protocol the type used
 * @param data the starting data for the entry, may be null
 * @param uri the uri for the entry if it already exists, may be null
 * @param id the id for the entry if it already exists, 0 it it doesn't
 * @return the new EditEntry
 */
public static final EditEntry newImEntry(EditContactActivity activity,
        String label, int protocol, String data, Uri uri, long id){
    EditEntry entry = new EditEntry(activity, label, protocol, data, uri,
            id);

    entry.hint = activity.getString(R.string.ghostData_im);
    entry.column = ContactMethods.DATA;
    entry.contentDirectory = People.ContactMethods.CONTENT_DIRECTORY;
    entry.kind = Contacts.KIND_IM;
    entry.contentType = EditorInfo.TYPE_CLASS_TEXT
            | EditorInfo.TYPE_TEXT_VARIATION_EMAIL_ADDRESS;
    return entry;
}","/**
 * Create a new IM address entry with the given data.
 *
 * @param label label for the item, from the db not the display label
 * @param protocol the type used
 * @param data the starting data for the entry, may be null
 * @param uri the uri for the entry if it already exists, may be null
 * @param id the id for the entry if it already exists, 0 it it doesn't
 * @return the new EditEntry
 */
public static final EditEntry newImEntry(EditContactActivity activity,
        String label, int protocol, String data, Uri uri, long id) 
{
    EditEntry entry = new EditEntry(activity, label, protocol, data, uri, id);
    entry.setEditType(EditEntry.EDIT_TYPE_IM);
    return entry;
}       ",367,True
"/**
 * Brings up the ""dialpad chooser"" UI in place of the usual Dialer
 * elements (the textfield/button and the dialpad underneath).
 *
 * We show this UI if the user brings up the Dialer while a call is
 * already in progress, since there's a good chance we got here
 * accidentally (and the user really wanted the in-call dialpad instead).
 * So in this situation we display an intermediate UI that lets the user
 * explicitly choose between the in-call dialpad (""Use touch tone
 * keypad"") and the regular Dialer (""Add call"").  (Or, the option ""Return
 * to call in progress"" just goes back to the in-call UI with no dialpad
 * at all.)
 *
 * @param enabled If true, show the ""dialpad chooser"" instead
 *                of the regular Dialer UI
 */
private void showDialpadChooser(boolean enabled){
    if (enabled) {
        // Log.i(TAG, ""Showing dialpad chooser!"");
        mDigits.setVisibility(View.GONE);
        if (mDialpad != null) mDialpad.setVisibility(View.GONE);
        mDialpadChooser.setVisibility(View.VISIBLE);

        // Instantiate the DialpadChooserAdapter and hook it up to the
        // ListView.  We do this only once.
        if (mDialpadChooserAdapter == null) {
            mDialpadChooserAdapter = new DialpadChooserAdapter(this);
            mDialpadChooser.setAdapter(mDialpadChooserAdapter);
        }
    } else {
        // Log.i(TAG, ""Displaying normal Dialer UI."");
        mDigits.setVisibility(View.VISIBLE);
        if (mDialpad != null) mDialpad.setVisibility(View.VISIBLE);
        mDialpadChooser.setVisibility(View.GONE);
    }
}","/**
 * Brings up the ""dialpad chooser"" UI in place of the usual Dialer
 * elements (the textfield/button and the dialpad underneath).
 *
 * We show this UI if the user brings up the Dialer while a call is
 * already in progress, since there's a good chance we got here
 * accidentally (and the user really wanted the in-call dialpad instead).
 * So in this situation we display an intermediate UI that lets the user
 * explicitly choose between the in-call dialpad (""Use touch tone
 * keypad"") and the regular Dialer (""Add call"").  (Or, the option ""Return
 * to call in progress"" just goes back to the in-call UI with no dialpad
 * at all.)
 *
 * @param enabled If true, show the ""dialpad chooser"" instead
 *                of the regular Dialer UI
 */
private void showDialpadChooser(boolean enabled) 
{
    if (enabled)
    {
        if (mDialpadFragment == null)
        {
            mDialpadFragment = new DialpadFragment();
        }
        mDialpadFragment.show(getFragmentManager(), ""tag_dialpad"");
        finish();
    }
    else
    {
        finish();
    }
}   ",369,True
"/**
 * @param parentContext must not be null
 * @param parentHandler must not be null
 */
public VCardExporter(Context parentContext, Handler parentHandler){
    mParentContext = parentContext;
    mParentHandler = parentHandler;
    mTargetDirectory = getString(R.string.config_export_dir);
    mFileNamePrefix = getString(R.string.config_export_file_prefix);
    mFileNameSuffix = getString(R.string.config_export_file_suffix);
    mFileNameExtension = getString(R.string.config_export_file_extension);
    mVCardType = getString(R.string.config_export_vcard_type);

    mExtensionsToConsider = new HashSet<String>();
    mExtensionsToConsider.add(mFileNameExtension);

    final String additionalExtensions =
        getString(R.string.config_export_extensions_to_consider);
    if (!TextUtils.isEmpty(additionalExtensions)) {
        for (String extension : additionalExtensions.split("","")) {
            String trimed = extension.trim();
            if (trimed.length() > 0) {
                mExtensionsToConsider.add(trimed);
            }
        }
    }

    Resources resources = parentContext.getResources();
    mFileIndexMinimum = resources.getInteger(R.integer.config_export_file_min_index);
    mFileIndexMaximum = resources.getInteger(R.integer.config_export_file_max_index);
}","/**
 * @param parentContext must not be null
 * @param parentHandler must not be null
 */
public VCardExporter(Context parentContext, Handler parentHandler) 
{
    this.parentContext = parentContext;
    this.parentHandler = parentHandler;
    this.vCard = new VCard();
}   ",371,False
"//Wysie_Soh: add to contacts button / voicemail depending on what is set
private void initVoicemailButton(){
	mVoicemailButton = (ImageButton)mVoicemailDialAndDeleteRow.findViewById(R.id.voicemailButton);
	mVoicemailButton.setOnClickListener(this);
	
	if (prefs.getString(""vm_button"", ""0"").equals(""0"")) {
		mVoicemailButton.setImageResource(R.drawable.ic_add_contacts);    		
	}
	else if (prefs.getString(""vm_button"", ""0"").equals(""1"")) { //Wysie_Soh: startsWith changed to equals
	        mVoicemailButton.setImageResource(R.drawable.ic_dial_action_sms);
	}
	else if (prefs.getString(""vm_button"", ""0"").equals(""2"")) {
		mVoicemailButton.setImageResource(R.drawable.ic_dial_action_voice_mail);
		
	        if (hasVoicemail()) {
	        	mVoicemailButton.setEnabled(true);
	        } else {
	        	mVoicemailButton.setEnabled(false);
	        	mVoicemailButton.setOnClickListener(null);
	        }
	}
}","//Wysie_Soh: add to contacts button / voicemail depending on what is set

private void initVoicemailButton() 
{
    if (mVoicemailNumber == null)
    {
        mVoicemailButton.setVisibility(View.GONE);
    }
    else
    {
        mVoicemailButton.setOnClickListener(new View.OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                onVoicemailButtonClick();
            }
        });
    }
}   ",372,True
"/**
 * Create a new company entry with the given data.
 */
public static final EditEntry newOrganizationEntry(EditContactActivity activity,
        String label, int type, String company, String title, Uri uri, long id){
    EditEntry entry = new EditEntry(activity, label, type, company, uri,
            id);

    entry.hint = activity.getString(R.string.ghostData_company);
    entry.hint2 = activity.getString(R.string.ghostData_title);
    entry.data2 = title;
    entry.column = Organizations.COMPANY;
    entry.contentDirectory = Organizations.CONTENT_DIRECTORY;
    entry.kind = Contacts.KIND_ORGANIZATION;
    entry.contentType = EditorInfo.TYPE_CLASS_TEXT
            | EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
    return entry;
}","/**
 * Create a new company entry with the given data.
 */
public static final EditEntry newOrganizationEntry(EditContactActivity activity,
        String label, int type, String company, String title, Uri uri, long id) 
{
    EditEntry entry = new EditEntry(activity, label, type, uri, id);
    entry.setCompany(company);
    entry.setTitle(title);
    return entry;
}       ",373,False
"/**
 * Handles clicks on the OK and cancel buttons
 */
public void onClick(View view){
    switch (view.getId()) {
        case R.id.cancel: {
            finish();
            break;
        }
        
        case R.id.ok: {
            // The list isn't setup yet, so just return without doing anything.
            if (mChecked == null) {
                finish();
                return;
            }

            final ContentResolver resolver = getContentResolver();
            if (mSyncAllGroups) {
                // For now we only support a single account and the UI doesn't know what
                // the account name is, so we're using a global setting for SYNC_EVERYTHING.
                // Some day when we add multiple accounts to the UI this should use the per
                // account setting.
                Settings.setSetting(resolver, null, Settings.SYNC_EVERYTHING, ""1"");
            } else {
                ContentValues values = new ContentValues();
                int count = mChecked.size();
                for (int i = 1; i < count; i++) {
                    values.clear();
                    values.put(Groups.SHOULD_SYNC, mChecked.get(i));
                    resolver.update(
                            ContentUris.withAppendedId(Groups.CONTENT_URI, mGroupIds.get(i)),
                            values, null, null);
                }
                // For now we only support a single account and the UI doesn't know what
                // the account name is, so we're using a global setting for SYNC_EVERYTHING.
                // Some day when we add multiple accounts to the UI this should use the per
                // account setting.
                Settings.setSetting(resolver, null, Settings.SYNC_EVERYTHING, ""0"");
            }
            finish();
            break;
        }
    }
}","/**
 * Handles clicks on the OK and cancel buttons
 */
public void onClick(View view) 
{
    switch (view.getId())
    {
        case R.id.okButton:
            // Handle OK button click
            break;
        case R.id.cancelButton:
            // Handle cancel button click
            break;
    }
}   ",374,False
"/**
 * Returns to the in-call UI (where there's presumably a call in
 * progress) in response to the user selecting ""use touch tone keypad""
 * or ""return to call"" from the dialpad chooser.
 */
private void returnToInCallScreen(boolean showDialpad){
    try {
        ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.checkService(""phone""));
        if (phone != null) phone.showCallScreenWithDialpad(showDialpad);
    } catch (RemoteException e) {
        Log.w(TAG, ""phone.showCallScreenWithDialpad() failed"", e);
    }

    // Finally, finish() ourselves so that we don't stay on the
    // activity stack.
    // Note that we do this whether or not the showCallScreenWithDialpad()
    // call above had any effect or not!  (That call is a no-op if the
    // phone is idle, which can happen if the current call ends while
    // the dialpad chooser is up.  In this case we can't show the
    // InCallScreen, and there's no point staying here in the Dialer,
    // so we just take the user back where he came from...)
    finish();
}","/**
 * Returns to the in-call UI (where there's presumably a call in
 * progress) in response to the user selecting ""use touch tone keypad""
 * or ""return to call"" from the dialpad chooser.
 */
private void returnToInCallScreen(boolean showDialpad) 
{
    if (mIsShowingCallScreen) {
        if (showDialpad) {
            mInCallScreen.showDialpad(true);
        } else {
            mInCallScreen.showCallScreen();
        }
        mIsShowingCallScreen = false;
    }
}   ",375,True
"/**
 * Create a new ringtone entry with the given data.
 */
public static final EditEntry newRingtoneEntry(EditContactActivity activity,
        String data, Uri uri){
    EditEntry entry = new EditEntry(activity);

    entry.label = activity.getString(R.string.label_ringtone);
    entry.data = data;
    entry.uri = uri;
    entry.column = People.CUSTOM_RINGTONE;
    entry.kind = KIND_CONTACT;
    entry.isStaticLabel = true;
    entry.syncDataWithView = false;
    entry.lines = -1;
    return entry;
}","/**
 * Create a new ringtone entry with the given data.
 */
public static final EditEntry newRingtoneEntry(EditContactActivity activity,
        String data, Uri uri) 
{
    EditEntry entry = new EditEntry(activity, data, uri);
    entry.setCompletion(true, true);
    return entry;
}       ",376,True
"//Wysie_Soh: Take photo instead of choosing from gallery
private void doTakePhotoAction(){
    // http://2009.hfoss.org/Tutorial:Camera_and_Gallery_Demo
    // http://stackoverflow.com/questions/1050297/how-to-get-the-url-of-the-captured-image
    // http://www.damonkohler.com/2009/02/android-recipes.html
    // http://www.firstclown.us/tag/android/
    // The one I used to get everything working: http://groups.google.com/group/android-developers/msg/2ab62c12ee99ba30 
    
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    
    //Wysie_Soh: Create path for temp file
    mImageCaptureUri = Uri.fromFile(new File(Environment.getExternalStorageDirectory(),
                        ""tmp_contact_"" + String.valueOf(System.currentTimeMillis()) + "".jpg""));
    
    intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, mImageCaptureUri);

    try {
        intent.putExtra(""return-data"", true);
        startActivityForResult(intent, PICK_FROM_CAMERA);
    } catch (ActivityNotFoundException e) {
        //Do nothing for now
    }
}","//Wysie_Soh: Take photo instead of choosing from gallery



private void doTakePhotoAction() 
{
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    File photo = new File(Environment.getExternalStorageDirectory(),  ""Pic.jpg"");
    intent.putExtra(MediaStore.EXTRA_OUTPUT,
            Uri.fromFile(photo));
    imageUri = Uri.fromFile(photo);
    startActivityForResult(intent, TAKE_PHOTO_CODE);
}   ",378,False
"/**
 * Returns the data for the entry
 * @return the data for the entry
 */
public String getData(){
    if (view != null && syncDataWithView) {
        CharSequence text = ((TextView) view.findViewById(R.id.data)).getText();

        if (text != null) {
            return text.toString();
        }
    }

    if (data != null) {
        return data.toString();
    }

    return null;
}","/**
 * Returns the data for the entry
 * @return the data for the entry
 */
public String getData() 
{
    return data;
}   ",379,False
"/**
 * If a key is being grabbed, this method should be called with
 * the appropriate key event. It executes the grab action with
 * the typed character as the parameter.
 */
protected void handleGrabAction(KeyEvent evt){
        // Clear it *before* it is executed so that executeAction()
        // resets the repeat count
        ActionListener _grabAction = grabAction;
        grabAction = null;
        executeAction(_grabAction,evt.getSource(),
                String.valueOf(evt.getKeyChar()));
}","/**
 * If a key is being grabbed, this method should be called with
 * the appropriate key event. It executes the grab action with
 * the typed character as the parameter.
 */
protected void handleGrabAction(KeyEvent evt) 
{
    if (grabAction != null)
    {
        grabAction.execute(evt.getKeyChar());
    }
}   ",380,True
"/**
 * Create text manager class with a textarea.
 * @param textArea texarea component for PDE.
 */
public CompositionTextManager(JEditTextArea textArea){
  this.textArea = textArea;
  prevComposeString = """";
  isInputProcess = false;
  prevCommittedCount = 0;
}","/**
 * Create text manager class with a textarea.
 * @param textArea texarea component for PDE.
 */
public CompositionTextManager(JEditTextArea textArea) 
{
    this.textArea = textArea;
}   ",383,True
"/**
 * Converts a string to a keystroke. The string should be of the
 * form <i>modifiers</i>+<i>shortcut</i> where <i>modifiers</i>
 * is any combination of A for Alt, C for Control, S for Shift
 * or M for Meta, and <i>shortcut</i> is either a single character,
 * or a keycode name from the <code>KeyEvent</code> class, without
 * the <code>VK_</code> prefix.
 * @param keyStroke A string description of the key stroke
 */
public static KeyStroke parseKeyStroke(String keyStroke){
        if(keyStroke == null)
                return null;
        int modifiers = 0;
        int index = keyStroke.indexOf('+');
        if(index != -1)
        {
                for(int i = 0; i < index; i++)
                {
                        switch(Character.toUpperCase(keyStroke
                                .charAt(i)))
                        {
                        case 'A':
                                modifiers |= InputEvent.ALT_MASK;
                                break;
                        case 'C':
                                modifiers |= InputEvent.CTRL_MASK;
                                break;
                        case 'M':
                                modifiers |= InputEvent.META_MASK;
                                break;
                        case 'S':
                                modifiers |= InputEvent.SHIFT_MASK;
                                break;
                        }
                }
        }
        String key = keyStroke.substring(index + 1);
        if(key.length() == 1)
        {
                char ch = Character.toUpperCase(key.charAt(0));
                if(modifiers == 0)
                        return KeyStroke.getKeyStroke(ch);
                else
                        return KeyStroke.getKeyStroke(ch,modifiers);
        }
        else if(key.length() == 0)
        {
                System.err.println(""Invalid key stroke: "" + keyStroke);
                return null;
        }
        else
        {
                int ch;

                try
                {
                        ch = KeyEvent.class.getField(""VK_"".concat(key))
                                .getInt(null);
                }
                catch(Exception e)
                {
                        System.err.println(""Invalid key stroke: ""
                                + keyStroke);
                        return null;
                }

                return KeyStroke.getKeyStroke(ch,modifiers);
        }
}","/**
 * Converts a string to a keystroke. The string should be of the
 * form <i>modifiers</i>+<i>shortcut</i> where <i>modifiers</i>
 * is any combination of A for Alt, C for Control, S for Shift
 * or M for Meta, and <i>shortcut</i> is either a single character,
 * or a keycode name from the <code>KeyEvent</code> class, without
 * the <code>VK_</code> prefix.
 * @param keyStroke A string description of the key stroke
 */

public static KeyStroke parseKeyStroke(String keyStroke) 
{
    int modifiers = 0;
    String keyText = keyStroke;
    if (keyStroke.startsWith(""+""))
    {
        String[] tokens = keyStroke.substring(1).split(""\\+"");
        keyText = tokens[tokens.length - 1];
        for (int i = 0; i < tokens.length - 1; i++)
        {
            String modifier = tokens[i];
            if (""A"".equalsIgnoreCase(modifier))
            {
                modifiers |= InputEvent.ALT_MASK;
            }
            else if (""C"".equalsIgnoreCase(modifier))
            {
                modifiers |= InputEvent.CTRL_MASK;
            }
            else if (""S"".equalsIgnoreCase(modifier))
            {
                modifiers |= InputEvent.SHIFT_MASK;
            }
            else if (""M"".equalsIgnoreCase(modifier))
            {
                modifiers |= InputEvent.META_MASK;
            }
        }
    }
    int keyCode = KeyEvent.getExtendedKeyCodeForChar((int) keyText.charAt(0));
    return KeyStroke.getKeyStroke(keyCode, modifiers);
}   ",385,True
"/**
 * Returns the name of the specified text area action.
 * @param listener The action
 */
public static String getActionName(ActionListener listener){
        Enumeration en = getActions();
        while(en.hasMoreElements())
        {
                String name = (String)en.nextElement();
                ActionListener _listener = getAction(name);
                if(_listener == listener) {
                        return name;
                }
        }
        return null;
}","/**
 * Returns the name of the specified text area action.
 * @param listener The action
 */
public static String getActionName(ActionListener listener) 
{
    if (listener instanceof TextAction)
    {
        TextAction textAction = (TextAction) listener;
        return textAction.getName();
    }
    return null;
}   ",386,True
"/**
 * Adds a key binding to this input handler. The key binding is
 * a list of white space separated key strokes of the form
 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
 * or S for Shift, and key is either a character (a-z) or a field
 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
 * @param keyBinding The key binding
 * @param action The action
 */
public void addKeyBinding(String keyBinding, ActionListener action){
        Hashtable current = bindings;

        StringTokenizer st = new StringTokenizer(keyBinding);
        while(st.hasMoreTokens())
        {
                KeyStroke keyStroke = parseKeyStroke(st.nextToken());
                if(keyStroke == null)
                        return;

                if(st.hasMoreTokens())
                {
                        Object o = current.get(keyStroke);
                        if(o instanceof Hashtable)
                                current = (Hashtable)o;
                        else
                        {
                                o = new Hashtable();
                                current.put(keyStroke,o);
                                current = (Hashtable)o;
                        }
                }
                else
                        current.put(keyStroke,action);
        }
}","/**
 * Adds a key binding to this input handler. The key binding is
 * a list of white space separated key strokes of the form
 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
 * or S for Shift, and key is either a character (a-z) or a field
 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
 * @param keyBinding The key binding
 * @param action The action
 */
public void addKeyBinding(String keyBinding, ActionListener action) 
{
    if (keyBindings == null)
    {
        keyBindings = new HashMap();
    }
    keyBindings.put(keyBinding, action);
}   ",387,True
"// implemented handler methods.  These are basically hooks into existing 
// functionality from the main app, as if it came over from another platform.
public void handleAbout(ApplicationEvent ae){
  if (base != null) {
    ae.setHandled(true);
    base.handleAbout();
  } else {
    throw new IllegalStateException(""handleAbout: Base instance detached from listener"");
  }
}","// implemented handler methods.  These are basically hooks into existing 
// functionality from the main app, as if it came over from another platform.
public void handleAbout(ApplicationEvent ae) 
{
    if (ae instanceof AboutEvent)
    {
        AboutEvent event = (AboutEvent) ae;
        AboutDialog dialog = new AboutDialog(event.getAboutDialog());
        dialog.setVisible(true);
    }
}   ",388,True
"/**
 * Returns the text area that fired the specified event.
 * @param evt The event
 */
public static JEditTextArea getTextArea(EventObject evt){
        if(evt != null)
        {
                Object o = evt.getSource();
                if(o instanceof Component)
                {
                        // find the parent text area
                        Component c = (Component)o;
                        for(;;)
                        {
                                if(c instanceof JEditTextArea)
                                        return (JEditTextArea)c;
                                else if(c == null)
                                        break;
                                if(c instanceof JPopupMenu)
                                        c = ((JPopupMenu)c)
                                                .getInvoker();
                                else
                                        c = c.getParent();
                        }
                }
        }

        // this shouldn't happen
        System.err.println(""BUG: getTextArea() returning null"");
        System.err.println(""Report this to Slava Pestov <sp@gjt.org>"");
        return null;
}","/**
 * Returns the text area that fired the specified event.
 * @param evt The event
 */
public static JEditTextArea getTextArea(EventObject evt) 
{
	JEditTextArea textArea = (JEditTextArea)evt.getSource();
	return textArea;
}   ",390,False
"// use keyTyped to catch when the feller is actually
// added to the text field. with keyTyped, as opposed to
// keyPressed, the keyCode will be zero, even if it's
// enter or backspace or whatever, so the keychar should
// be used instead. grr.
public void keyTyped(KeyEvent event){
  //System.out.println(""got event "" + event);
  int c = event.getKeyChar();

  if (c == KeyEvent.VK_ENTER) {  // accept the input
    String answer = editField.getText();
    editor.getSketch().nameCode(answer);
    unedit();
    event.consume();

    // easier to test the affirmative case than the negative
  } else if ((c == KeyEvent.VK_BACK_SPACE) ||
             (c == KeyEvent.VK_DELETE) ||
             (c == KeyEvent.VK_RIGHT) ||
             (c == KeyEvent.VK_LEFT) ||
             (c == KeyEvent.VK_UP) ||
             (c == KeyEvent.VK_DOWN) ||
             (c == KeyEvent.VK_HOME) ||
             (c == KeyEvent.VK_END) ||
             (c == KeyEvent.VK_SHIFT)) {
    // these events are ignored

    /*
  } else if (c == KeyEvent.VK_ESCAPE) {
    unedit();
    editor.toolbar.clear();
    event.consume();
    */

  } else if (c == KeyEvent.VK_SPACE) {
    String t = editField.getText();
    int start = editField.getSelectionStart();
    int end = editField.getSelectionEnd();
    editField.setText(t.substring(0, start) + ""_"" +
                      t.substring(end));
    editField.setCaretPosition(start+1);
    event.consume();

  } else if ((c == '_') || (c == '.') ||  // allow .pde and .java
             ((c >= 'A') && (c <= 'Z')) ||
             ((c >= 'a') && (c <= 'z'))) {
    // these are ok, allow them through
    
  } else if ((c >= '0') && (c <= '9')) {
    // getCaretPosition == 0 means that it's the first char
    // and the field is empty.
    // getSelectionStart means that it *will be* the first
    // char, because the selection is about to be replaced
    // with whatever is typed.
    if ((editField.getCaretPosition() == 0) ||
        (editField.getSelectionStart() == 0)) {
      // number not allowed as first digit
      //System.out.println(""bad number bad"");
      event.consume();
    }
  } else {
    event.consume();
    //System.out.println(""code is "" + code + ""  char = "" + c);
  }
  //System.out.println(""code is "" + code + ""  char = "" + c);
}","// use keyTyped to catch when the feller is actually
// added to the text field. with keyTyped, as opposed to
// keyPressed, the keyCode will be zero, even if it's
// enter or backspace or whatever, so the keychar should
// be used instead. grr.
public void keyTyped(KeyEvent event) 
{
    if (event.getKeyChar() == KeyEvent.VK_ENTER)
    {
        if (feller.getText().length() > 0)
        {
            feller.setText(feller.getText().substring(0, feller.getText().length() - 1));
        }
    }
}   ",391,False
"/**
 * Executes the specified action, repeating and recording it as
 * necessary.
 * @param listener The action listener
 * @param source The event source
 * @param actionCommand The action command
 */
public void executeAction(ActionListener listener, Object source,
        String actionCommand){
        // create event
        ActionEvent evt = new ActionEvent(source,
                ActionEvent.ACTION_PERFORMED,
                actionCommand);

        // don't do anything if the action is a wrapper
        // (like EditAction.Wrapper)
        if(listener instanceof Wrapper)
        {
                listener.actionPerformed(evt);
                return;
        }

        // remember old values, in case action changes them
        boolean _repeat = repeat;
        int _repeatCount = getRepeatCount();

        // execute the action
        if(listener instanceof InputHandler.NonRepeatable)
                listener.actionPerformed(evt);
        else
        {
                for(int i = 0; i < Math.max(1,repeatCount); i++)
                        listener.actionPerformed(evt);
        }

        // do recording. Notice that we do no recording whatsoever
        // for actions that grab keys
        if(grabAction == null)
        {
                if(recorder != null)
                {
                        if(!(listener instanceof InputHandler.NonRecordable))
                        {
                                if(_repeatCount != 1)
                                        recorder.actionPerformed(REPEAT,String.valueOf(_repeatCount));

                                recorder.actionPerformed(listener,actionCommand);
                        }
                }

                // If repeat was true originally, clear it
                // Otherwise it might have been set by the action, etc
                if(_repeat)
                {
                        repeat = false;
                        repeatCount = 0;
                }
        }
}","/**
 * Executes the specified action, repeating and recording it as
 * necessary.
 * @param listener The action listener
 * @param source The event source
 * @param actionCommand The action command
 */
public void executeAction(ActionListener listener, Object source,
        String actionCommand) 
{
    ActionEvent event = new ActionEvent(source, 0, actionCommand);
    listener.actionPerformed(event);
    if (isRecording())
    {
        getRecorder().recordActionPerformed(event);
    }
}       ",393,False
"/*
public void update() {
  Graphics g = this.getGraphics();
  try {
    setBackground(bgcolor[mode]);
  } catch (NullPointerException e) { } // if not ready yet
  if (g != null) paint(g);
}

public void update(Graphics g) {
  paint(g);
}
*/
public void paintComponent(Graphics screen){
  //if (screen == null) return;
  if (okButton == null) setup();

  //System.out.println(""status.paintComponent"");

  Dimension size = getSize();
  if ((size.width != sizeW) || (size.height != sizeH)) {
    // component has been resized

    if ((size.width > imageW) || (size.height > imageH)) {
      // nix the image and recreate, it's too small
      offscreen = null;

    } else {
      // who cares, just resize
      sizeW = size.width;
      sizeH = size.height;
      setButtonBounds();
    }
  }

  if (offscreen == null) {
    sizeW = size.width;
    sizeH = size.height;
    setButtonBounds();
    imageW = sizeW;
    imageH = sizeH;
    offscreen = createImage(imageW, imageH);
  }

  Graphics g = offscreen.getGraphics();
  if (font == null) {
    font = Theme.getFont(""status.font"");
    //new Font(""SansSerif"", Font.PLAIN, 12));
    g.setFont(font);
    metrics = g.getFontMetrics();
    ascent = metrics.getAscent();
  }

  //setBackground(bgcolor[mode]);  // does nothing

  g.setColor(bgcolor[mode]);
  g.fillRect(0, 0, imageW, imageH);

  g.setColor(fgcolor[mode]);
  g.setFont(font); // needs to be set each time on osx
  g.drawString(message, Preferences.GUI_SMALL, (sizeH + ascent) / 2);

  screen.drawImage(offscreen, 0, 0, null);
}","/*


public void update() {
  Graphics g = this.getGraphics();
  try {
    setBackground(bgcolor[mode]);
  } catch (NullPointerException e) { } // if not ready yet
  if (g != null) paint(g);
}

public void update(Graphics g) {
  paint(g);
}
*/
public void paintComponent(Graphics screen) 
{
    super.paintComponent(screen);
    Graphics2D g2 = (Graphics2D) screen;
    g2.setColor(Color.BLACK);
    g2.fillRect(0, 0, getWidth(), getHeight());
    g2.setColor(Color.WHITE);
    g2.setFont(new Font(""Arial"", Font.BOLD, 20));
    g2.drawString(""Hello, World!"", 100, 100);
} ",394,False
"/**
 * Called when a user begins input from input method.
 * This method initializes text manager.
 * 
 * @param text Text from InputMethodEvent.
 * @param commited_count Numbers of committed characters in text. 
 */
public void beginCompositionText(AttributedCharacterIterator text, int committed_count){
  isInputProcess = true;
  prevComposeString = """";
  initialCaretPosition = textArea.getCaretPosition();
  processCompositionText(text, committed_count);
}","/**
 * Called when a user begins input from input method.
 * This method initializes text manager.
 * 
 * @param text Text from InputMethodEvent.
 * @param commited_count Numbers of committed characters in text. 
 */
public void beginCompositionText(AttributedCharacterIterator text, int committed_count) 
{
    if (text != null)
    {
        textManager = new TextManager(text, committed_count);
    }
}   ",395,True
"/**
 * Handle a key typed event. This inserts the key into the text area.
 */
public void keyTyped(KeyEvent evt){
        int modifiers = evt.getModifiers();
        char c = evt.getKeyChar();

        // this is the apple/cmd key on macosx.. so menu commands
        // were being passed through as legit keys.. added this line
        // in an attempt to prevent.
        if ((modifiers & KeyEvent.META_MASK) != 0) return;

        if (c != KeyEvent.CHAR_UNDEFINED) // &&
          //                (modifiers & KeyEvent.ALT_MASK) == 0)
        {
          if(c >= 0x20 && c != 0x7f)
                {
                        KeyStroke keyStroke = KeyStroke.getKeyStroke(
                                Character.toUpperCase(c));
                        Object o = currentBindings.get(keyStroke);

                        if(o instanceof Hashtable)
                        {
                                currentBindings = (Hashtable)o;
                                return;
                        }
                        else if(o instanceof ActionListener)
                        {
                                currentBindings = bindings;
                                executeAction((ActionListener)o,
                                        evt.getSource(),
                                        String.valueOf(c));
                                return;
                        }

                        currentBindings = bindings;

                        if(grabAction != null)
                        {
                                handleGrabAction(evt);
                                return;
                        }

                        // 0-9 adds another 'digit' to the repeat number
                        if(repeat && Character.isDigit(c))
                        {
                                repeatCount *= 10;
                                repeatCount += (c - '0');
                                return;
                        }

                        executeAction(INSERT_CHAR,evt.getSource(),
                                String.valueOf(evt.getKeyChar()));

                        repeatCount = 0;
                        repeat = false;
                }
        }
}","/**
 * Handle a key typed event. This inserts the key into the text area.
 */
public void keyTyped(KeyEvent evt) 
{
    if (evt.getSource() == textArea) {
        textArea.insert(String.valueOf(evt.getKeyChar()), textArea.getCaretPosition());
    }
}   ",397,False
"// Grab ESC with keyPressed, because it's not making it to keyTyped
public void keyPressed(KeyEvent event){
  if (event.getKeyChar() == KeyEvent.VK_ESCAPE) {
    unedit();
    //editor.toolbar.clear();
    event.consume();
  }
}","// Grab ESC with keyPressed, because it's not making it to keyTyped
public void keyPressed(KeyEvent event) 
{
    int key = event.getKeyCode();
    if (key == KeyEvent.VK_ESCAPE)
    {
        System.exit(0);
    }
}   ",399,True
"/**
 * Check the execution with most recent start time is returned
 */
@Transactional
@Test
public void testGetLastExecution(){
    JobExecution exec1 = new JobExecution(jobInstance);
    exec1.setCreateTime(new Date(0));

    JobExecution exec2 = new JobExecution(jobInstance);
    exec2.setCreateTime(new Date(1));

    dao.saveJobExecution(exec1);
    dao.saveJobExecution(exec2);

    JobExecution last = dao.getLastJobExecution(jobInstance);
    assertEquals(exec2, last);
}","/**
 * Check the execution with most recent start time is returned
 */

@Transactional
@Test
public void testGetLastExecution() 
{
    Execution execution = new Execution();
    execution.setStartTime(new Date());
    executionRepository.save(execution);

    Execution lastExecution = executionRepository.findFirstByJobNameOrderByStartTimeDesc(""testJob"");

    Assert.assertEquals(execution.getStartTime(), lastExecution.getStartTime());
}   ",400,True
"/**
 * @param string
 */
public StepSupport(String string){
    super();
    this.name = string;
}","/**
 * @param string
 */
public StepSupport(String string) 
{
    super();
    this.string = string;
}   ",403,True
"/*
  * Create and retrieve a job instance.
  */
@Transactional
@Test
public void testGetMissingById() throws Exception{

    JobInstance retrievedInstance = dao.getJobInstance(1111111L);
    assertNull(retrievedInstance);

}","/*
  * Create and retrieve a job instance.
  */
@Transactional
@Test
public void testGetMissingById() throws Exception 
{
    JobInstance jobInstance = jobInstanceService.getMissingById(1L);
    Assert.assertNull(jobInstance);
} ",404,True
"/**
 * Update and retrieve job execution - check attributes have changed as
 * expected.
 */
@Transactional
@Test
public void testUpdateExecution(){
    execution.setStatus(BatchStatus.STARTED);
    dao.saveJobExecution(execution);

    execution.setLastUpdated(new Date(0));
    execution.setStatus(BatchStatus.COMPLETED);
    dao.updateJobExecution(execution);

    JobExecution updated = dao.findJobExecutions(jobInstance).get(0);
    assertEquals(execution, updated);
    assertEquals(BatchStatus.COMPLETED, updated.getStatus());
    assertExecutionsAreEqual(execution, updated);
}","/**
 * Update and retrieve job execution - check attributes have changed as
 * expected.
 */


@Transactional
@Test
public void testUpdateExecution() 
{
    JobExecution execution = new JobExecution(jobInstance);
    execution.setStartTime(new Date());
    execution.setStatus(BatchStatus.STARTED);
    jobRepository.updateJobExecution(execution);

    JobExecution retrievedExecution = jobRepository.getJobExecution(jobInstance.getId(), execution.getId());
    assertNotNull(retrievedExecution);
    assertEquals(BatchStatus.STARTED, retrievedExecution.getStatus());
    assertEquals(execution.getStartTime(), retrievedExecution.getStartTime());
}   ",406,True
"/**
 * Save and find a job execution.
 */
@Transactional
@Test
public void testSaveAndFind(){

    execution.setStartTime(new Date(System.currentTimeMillis()));
    execution.setLastUpdated(new Date(System.currentTimeMillis()));
    execution.setExitStatus(ExitStatus.UNKNOWN);
    execution.setEndTime(new Date(System.currentTimeMillis()));
    dao.saveJobExecution(execution);

    List<JobExecution> executions = dao.findJobExecutions(jobInstance);
    assertEquals(1, executions.size());
    assertEquals(execution, executions.get(0));
    assertExecutionsAreEqual(execution, executions.get(0));
}","/**
 * Save and find a job execution.
 */


@Transactional
@Test
public void testSaveAndFind() 
{
    JobExecution jobExecution = new JobExecution();
    jobExecution.setJobId(""jobId"");
    jobExecution.setStartTime(new Date());
    jobExecution.setEndTime(new Date());
    jobExecution.setStatus(BatchStatus.COMPLETED);
    jobExecution.setExitStatus(ExitStatus.COMPLETED);
    jobRepository.save(jobExecution);

    JobExecution foundJobExecution = jobRepository.findOne(jobExecution.getId());
    assertNotNull(foundJobExecution);
    assertEquals(jobExecution.getJobId(), foundJobExecution.getJobId());
    assertEquals(jobExecution.getStartTime(), foundJobExecution.getStartTime());
    assertEquals(jobExecution.getEndTime(), foundJobExecution.getEndTime());
    assertEquals(jobExecution.getStatus(), foundJobExecution.getStatus());
    assertEquals(jobExecution.getExitStatus(), foundJobExecution.getExitStatus());
}   ",407,False
"/*
  * Check to make sure the executions are equal. Normally, comparing the id's
  * is sufficient. However, for testing purposes, especially of a DAO, we
  * need to make sure all the fields are being stored/retrieved correctly.
  */
private void assertExecutionsAreEqual(JobExecution lhs, JobExecution rhs){

    assertEquals(lhs.getId(), rhs.getId());
    assertEquals(lhs.getStartTime(), rhs.getStartTime());
    assertEquals(lhs.getStatus(), rhs.getStatus());
    assertEquals(lhs.getEndTime(), rhs.getEndTime());
    assertEquals(lhs.getCreateTime(), rhs.getCreateTime());
    assertEquals(lhs.getLastUpdated(), rhs.getLastUpdated());
    assertEquals(lhs.getVersion(), rhs.getVersion());
}","/*
  * Check to make sure the executions are equal. Normally, comparing the id's
  * is sufficient. However, for testing purposes, especially of a DAO, we
  * need to make sure all the fields are being stored/retrieved correctly.
  */
private void assertExecutionsAreEqual(JobExecution lhs, JobExecution rhs) 
{
    assertNotNull(lhs);
    assertNotNull(rhs);
    assertEquals(lhs.getId(), rhs.getId());
    assertEquals(lhs.getStartTime(), rhs.getStartTime());
    assertEquals(lhs.getEndTime(), rhs.getEndTime());
    assertEquals(lhs.getExitCode(), rhs.getExitCode());
    assertEquals(lhs.getStatus(), rhs.getStatus());
    assertEquals(lhs.getJobParameters(), rhs.getJobParameters());
    assertEquals(lhs.getJobInstance(), rhs.getJobInstance());
} ",408,True
"/* Invoke callbacks on the object, as though it was configured in the
  * factory
  * @param o object to configure
  * @return object after callbacks have been called on it
  */
private Object getConfigured(Object o){
    if (this.autowireCapableBeanFactory == null) {
        throw new UnsupportedOperationException(
                ""Cannot configure object - not running in an AutowireCapableBeanFactory"");
    }

    autowireCapableBeanFactory.initializeBean(o, null);

    // TODO could replace with ApplicationContextAwareProcessor call if that class were public
    if (this.applicationContext != null) {
        if (o instanceof ResourceLoaderAware) {
            ((ResourceLoaderAware) o).setResourceLoader(this.applicationContext);
        }
        if (o instanceof ApplicationEventPublisherAware) {
            ((ApplicationEventPublisherAware) o).setApplicationEventPublisher(this.applicationContext);
        }
        if (o instanceof MessageSourceAware) {
            ((MessageSourceAware) o).setMessageSource(this.applicationContext);
        }
        if (o instanceof ApplicationContextAware) {
            ((ApplicationContextAware) o).setApplicationContext(this.applicationContext);
        }
    }

    return o;
}","/* Invoke callbacks on the object, as though it was configured in the
  * factory
  * @param o object to configure
  * @return object after callbacks have been called on it
  */
private Object getConfigured(Object o) 
{
    for (Callback callback : callbacks)
    {
        o = callback.configure(o);
    }
    return o;
} ",409,False
"/**
 * Executions should be returned in the reverse order they were saved.
 */
@Transactional
@Test
public void testFindExecutionsOrdering(){

    List<JobExecution> execs = new ArrayList<JobExecution>();

    for (int i = 0; i < 10; i++) {
        JobExecution exec = new JobExecution(jobInstance);
        exec.setCreateTime(new Date(i));
        execs.add(exec);
        dao.saveJobExecution(exec);
    }

    List<JobExecution> retrieved = dao.findJobExecutions(jobInstance);
    Collections.reverse(retrieved);

    for (int i = 0; i < 10; i++) {
        assertExecutionsAreEqual(execs.get(i), retrieved.get(i));
    }

}","/**
 * Executions should be returned in the reverse order they were saved.
 */

@Transactional
@Test
public void testFindExecutionsOrdering() 
{
    final String processInstanceId = ""XXXXXXXX"";
    final String anotherProcessInstanceId = ""XXXXXXXX"";

    createExecution(processInstanceId);
    createExecution(processInstanceId);
    createExecution(anotherProcessInstanceId);

    final List<ExecutionEntity> executions = executionQuery.processInstanceId(processInstanceId).orderByProcessInstanceId().desc().list();

    assertEquals(2, executions.size());
    assertEquals(anotherProcessInstanceId, executions.get(0).getProcessInstanceId());
    assertEquals(processInstanceId, executions.get(1).getProcessInstanceId());
}   ",416,True
"/**
 * Shows the alert and put it into the reference container pendingAlerts
 * with its id for further reference.
 */
public void run(){
    Log.debug(TAG, ""Showing progress dialog: "" + dialogId);
    AlertDialog ad = builder.show();
    pendingAlerts.put(dialogId, ad);
}","/**
 * Shows the alert and put it into the reference container pendingAlerts
 * with its id for further reference.
 */
public void run() 
{
    if (alert != null)
    {
        synchronized (pendingAlerts)
        {
            pendingAlerts.put(alert.getId(), alert);
        }
        alert.show();
    }
}   ",420,True
"/**
 * This method formats an Item tag for delete commands
 * @param key is the item key
 * @return the SyncML item
 */
public String formatItemDelete(String key){

    StringBuffer ret = new StringBuffer();
    
    ret.append(""<Item>\n"")
       .append(""<Source><LocURI>"")
       .append(key)
       .append(""</LocURI></Source>\n"")
       .append(""</Item>\n"");

    return ret.toString();
}","/**
 * This method formats an Item tag for delete commands
 * @param key is the item key
 * @return the SyncML item
 */
public String formatItemDelete(String key) 
{
	String item = ""<Item>\n"";
	item += ""<Target>\n"";
	item += ""<LocURI>"" + key + ""</LocURI>\n"";
	item += ""</Target>\n"";
	item += ""</Item>\n"";
	return item;
}   ",424,True
"/**
 * Format the sync tag preamble. This preamble is essentially the
 * information about source and target sync source
 * @param nextCmdId is the next command id
 * @param sourceName is the local source uri
 * @param sourceUri  is the remote source uri
 * @return the SyncML preamble
 */
public String formatSyncTagPreamble(String nextCmdId,
                                    String sourceName,
                                    String sourceUri){

    StringBuffer syncTag = new StringBuffer();

    syncTag.append(""<CmdID>"").append(nextCmdId)
           .append(""</CmdID>\n"")
           .append(""<Target><LocURI>"")
           .append(sourceUri)
           .append(""</LocURI></Target>\n"")
           .append(""<Source><LocURI>"")
           .append(sourceName)
           .append(""</LocURI></Source>\n"");

    return syncTag.toString();
}","/**
 * Format the sync tag preamble. This preamble is essentially the
 * information about source and target sync source
 * @param nextCmdId is the next command id
 * @param sourceName is the local source uri
 * @param sourceUri  is the remote source uri
 * @return the SyncML preamble
 */
public String formatSyncTagPreamble(String nextCmdId,
                                    String sourceName,
                                    String sourceUri) 
{
    StringBuffer preamble = new StringBuffer();

    preamble.append(""<SyncHdr>"");
    preamble.append(""<VerDTD>1.2</VerDTD>"");
    preamble.append(""<VerProto>SyncML/1.2</VerProto>"");
    preamble.append(""<SessionID>"");
    preamble.append(nextCmdId);
    preamble.append(""</SessionID>"");
    preamble.append(""<Source>"");
    preamble.append(""<LocURI>"");
    preamble.append(sourceName);
    preamble.append(""</LocURI>"");
    preamble.append(""<LocName>"");
    preamble.append(sourceUri);
    preamble.append(""</LocName>"");
    preamble.append(""</Source>"");
    preamble.append(""</SyncHdr>"");

    return preamble.toString();
}   ",426,True
"/**
 * Create a native dialog referencing it from the ones contained into the
 * native dialog reference container ""holdingDialogs"". Call this method 
 * when the onCreateDialog is invocked on the activity that must manage
 * this native dialog.
 * @param id the id of the alert dialog to be created/retrieved
 * @return Dialog the AlertDialog instance corresponding to the given id 
 */
public Dialog createDialog(int id){
    Log.debug(TAG, ""Creating  dialog "" + id);
    Object dialog = holdingDialogs.get(id);
    if (dialog instanceof AlertDialog.Builder) {
        AlertDialog.Builder result = (AlertDialog.Builder) dialog;
        return result.create();
    } else if (dialog instanceof Dialog) {
        Dialog result = (Dialog) dialog;
        return result;
    } else {
        Log.debug(TAG, ""Unknown dialog id: "" + id);
        return null;
    }
}","/**
 * Create a native dialog referencing it from the ones contained into the
 * native dialog reference container ""holdingDialogs"". Call this method 
 * when the onCreateDialog is invocked on the activity that must manage
 * this native dialog.
 * @param id the id of the alert dialog to be created/retrieved
 * @return Dialog the AlertDialog instance corresponding to the given id 
 */
public Dialog createDialog(int id) 
{
    Dialog dialog = null;
    if (holdingDialogs != null)
    {
        dialog = holdingDialogs.get(id);
        if (dialog != null)
        {
            return dialog;
        }
    }
    return super.onCreateDialog(id);
}   ",429,True
"/**
 * Format an item luid.
 * @return the SyncML luid of an item
 */
public String formatItemLuid(String luid){
    StringBuffer ret = new StringBuffer();
    ret.append(""<Source><LocURI>"" + luid + ""</LocURI></Source>\n"");
    return ret.toString();
}","/**
 * Format an item luid.
 * @return the SyncML luid of an item
 */
public String formatItemLuid(String luid) 
{
    if (luid == null)
    {
        return null;
    }
    return luid;
}   ",430,True
"/**
 * Format a ""more data"" element
 * @return the SyncML ""more data"" element
 */
public String formatMoreData(){
    StringBuffer ret = new StringBuffer();
    ret.append(""<"").append(SyncML.TAG_MORE_DATA).append(""/>\n"");
    return ret.toString();
}","/**
 * Format a ""more data"" element
 * @return the SyncML ""more data"" element
 */
public String formatMoreData() 
{
    StringBuffer aBuffer = new StringBuffer();

    aBuffer.append(""<MoreData>\n"");

    aBuffer.append(""</MoreData>\n"");

    return aBuffer.toString();
}   ",431,True
"/**
 * Hide a screen calling the Activity finish method
 * @param screen the Screen to be hidden
 * @throws Exception if the activity related to the encounters
 * any problem
 */
public void hideScreen(Screen screen) throws Exception{
    Activity activity = (Activity) screen.getUiScreen();
    activity.finish();
}","/**
 * Hide a screen calling the Activity finish method
 * @param screen the Screen to be hidden
 * @throws Exception if the activity related to the encounters
 * any problem
 */
public void hideScreen(Screen screen) throws Exception 
{
    if (screen != null)
    {
        screen.finish();
    }
}   ",432,True
"/**
 * Format credentials into a &lt;Cred&gt; tag
 * @param token the authentication token
 * @param md5 true if the credentials are md5
 * @return the XML credential tag
 */
public String formatCredentials(String token, boolean md5){
    // Add <Cred> and <Meta> to the syncHdr
    StringBuffer cred = new StringBuffer(""<Cred>\n"");
    cred.append(""<Meta>"");
    if (md5) {
        cred.append(""<Type xmlns=\""syncml:metinf\"">"").append(SyncML.AUTH_TYPE_MD5).append(""</Type>\n"");
    } else {
        cred.append(""<Type xmlns=\""syncml:metinf\"">"").append(SyncML.AUTH_TYPE_BASIC).append(""</Type>\n"");
        cred.append(""<Format xmlns=\""syncml:metinf\"">b64</Format>\n"");
    }
    cred.append(""</Meta>\n"")
        .append(""<Data>"").append(token).append(""</Data>"")
        .append(""</Cred>\n"");
    return cred.toString();
}","/**
 * Format credentials into a &lt;Cred&gt; tag
 * @param token the authentication token
 * @param md5 true if the credentials are md5
 * @return the XML credential tag
 */
public String formatCredentials(String token, boolean md5) 
{
    StringBuffer buf = new StringBuffer();
    if (md5)
    {
        buf.append(""<Cred md5=\"""");
        buf.append(token);
        buf.append(""\"">"");
    }
    else
    {
        buf.append(""<Cred>"");
        buf.append(token);
    }
    buf.append(""</Cred>"");
    return buf.toString();
}   ",433,True
"/**
 * Create a custom alert dialog based on the given DialogOptions. This kind 
 * of dialog has fixed dialog id that depends on the one set by the caller
 * (Usually an instance of DialogController class). The created dialog is
 * built with a custom title and content and must be managed outside the
 * standard activity dialog management onCreatedialog, but using the
 * acitvity Bundle passed into the native activity methods onCreate() and
 * onSaveInstanceState(). The Funambol Android Client implementation use a
 * DialogController instance and the activity related to the give screen to
 * realize this kind of management
 * @param screen the native alert dialog owner Screen
 * @param message the decription of this dialog options
 * @param options the options array to be displayed to the user
 * @param defaultValue the default selection option int formatted
 * @param dialogId the fixed dialog id set by the caller
 */
public void promptSelection(Screen screen, String message, DialogOption[] options, int defaultValue, int dialogId){
    Activity a = (Activity) screen.getUiScreen();
    AlertDialog.Builder builder = new AlertDialog.Builder(a);
    LinearLayout titleLayout = buildAlertTitle(a, message, 20);

    builder.setCustomTitle(titleLayout);

    LinearLayout builderView = buildAlertContent(options, a, dialogId);

    builder.setView(builderView);

    builder.setCancelable(true);

    builder.setOnCancelListener(new SelectionCancelListener(dialogId));

    a.runOnUiThread(new PromptSelection(builder, dialogId));

}","/**
 * Create a custom alert dialog based on the given DialogOptions. This kind 
 * of dialog has fixed dialog id that depends on the one set by the caller
 * (Usually an instance of DialogController class). The created dialog is
 * built with a custom title and content and must be managed outside the
 * standard activity dialog management onCreatedialog, but using the
 * acitvity Bundle passed into the native activity methods onCreate() and
 * onSaveInstanceState(). The Funambol Android Client implementation use a
 * DialogController instance and the activity related to the give screen to
 * realize this kind of management
 * @param screen the native alert dialog owner Screen
 * @param message the decription of this dialog options
 * @param options the options array to be displayed to the user
 * @param defaultValue the default selection option int formatted
 * @param dialogId the fixed dialog id set by the caller
 */

public void promptSelection(Screen screen, String message, DialogOption[] options, int defaultValue, int dialogId) 
{
    Bundle args = new Bundle();
    args.putInt(""dialogId"", dialogId);
    args.putString(""title"", screen.getTitle());
    args.putString(""message"", message);
    args.putInt(""defaultValue"", defaultValue);
    args.putParcelableArray(""options"", options);
    screen.showDialog(AlertDialogFragment.class, args, dialogId);
}   ",434,False
"/**
 * Constructs the <Put> section of a SyncML initialization message used to
 * carry the device capabilities with the <DevInf> element
 *
 * @param devInf
 *            A reference to the current device configuration (<code>DeviceConfig</code>)
 * @return a String to be added to the initialization SyncML message
 */
public String formatPutDeviceInfo(String cmdId, DeviceConfig devInf, SyncSource source){
    StringBuffer sb = new StringBuffer();

    //TODO: retrieve most values from the passed DeviceConfig object
    sb.append(""<Put>\n"")
      .append(""<CmdID>"").append(cmdId).append(""</CmdID>\n"")
      .append(""<Meta>\n"")
      .append(""<Type xmlns='syncml:metinf'>application/vnd.syncml-devinf+xml</Type>\n"")
      .append(""</Meta>\n"").append(""<Item>\n"")
      .append(""<Source><LocURI>./devinf12</LocURI></Source>\n"")
      .append(""<Data>\n"").append(createDevInf(devInf, source)) //closing all tags
      .append(""</Data>\n"").append(""</Item>\n"").append(""</Put>\n"");

    return sb.toString();
}","/**
 * Constructs the <Put> section of a SyncML initialization message used to
 * carry the device capabilities with the <DevInf> element
 *
 * @param devInf
 *            A reference to the current device configuration (<code>DeviceConfig</code>)
 * @return a String to be added to the initialization SyncML message
 */
public String formatPutDeviceInfo(String cmdId, DeviceConfig devInf, SyncSource source) 
{
    StringBuffer put = new StringBuffer();
    put.append(""<Put>\n"");
    put.append(""<CmdID>"" + cmdId + ""</CmdID>\n"");
    put.append(""<Item>\n"");
    put.append(""<Data>\n"");
    put.append(""<DevInf>\n"");
    put.append(""<VerDTD>1.0</VerDTD>\n"");
    put.append(""<Man>"" + devInf.getDeviceManufacturer() + ""</Man>\n"");
    put.append(""<Mod>"" + devInf.getDeviceModel() + ""</Mod>\n"");
    put.append(""<OEM>"" + devInf.getDeviceOEM() + ""</OEM>\n"");
    put.append(""<FwV>"" + devInf.getFirmwareVersion() + ""</FwV>\n"");
    put.append(""<SwV>"" + devInf.getSoftwareVersion() + ""</SwV>\n"");
    put.append(""<HwV>"" + devInf.getHardwareVersion() + ""</HwV>\n"");
    put.append(""<DevID>"" + devInf.getDeviceId() + ""</DevID>\n"");
    put.append(""<DevTyp>"" + devInf.getDeviceType() + ""</DevTyp>\n"");
    put.append(""<UTC>"" + devInf.getUTC() + ""</UTC>\n"");
    put.append(""<SupportLargeObjs/>"");
    put.append(""</DevInf>\n"");
    put.append(""</Data>\n"");
    put.append(""</Item>\n"");
    put.append(""</Put>\n"");
    return put.toString();
}   ",435,True
"/**
 * Create a native alert dialog with the 2 options ""Yes"" and ""No"".
 * This kind of alert are managed by the activity owner when the call to
 * onCreateDialog is done.
 * @param screen the native alert dialog owner Screen
 * @param question the question to be displayed
 * @param yesAction the runnable that defines the yes option
 * @param noAction the runnable that defines the no option
 * @param timeToWait to be defined
 */
public void askYesNoQuestion(Screen screen, String question,
        Runnable yesAction,
        Runnable noAction, long timeToWait){

    int dialogId = getNextDialogId();
    Activity activity = (Activity) screen.getUiScreen();

    AlertDialog.Builder alert = new AlertDialog.Builder(activity);
    alert.setMessage(question);
    alert.setCancelable(false);
    OnButtonListener yesListener = new OnButtonListener(yesAction);
    OnButtonListener noListener = new OnButtonListener(noAction);
    alert.setPositiveButton(android.R.string.ok, yesListener);
    alert.setNegativeButton(android.R.string.cancel, noListener);

    holdingDialogs.put(dialogId, alert);

    activity.showDialog(dialogId);
}","/**
 * Create a native alert dialog with the 2 options ""Yes"" and ""No"".
 * This kind of alert are managed by the activity owner when the call to
 * onCreateDialog is done.
 * @param screen the native alert dialog owner Screen
 * @param question the question to be displayed
 * @param yesAction the runnable that defines the yes option
 * @param noAction the runnable that defines the no option
 * @param timeToWait to be defined
 */
public void askYesNoQuestion(Screen screen, String question,
        Runnable yesAction,
        Runnable noAction, long timeToWait) 
{
    this.screen = screen;
    this.question = question;
    this.yesAction = yesAction;
    this.noAction = noAction;
    this.timeToWait = timeToWait;
    this.showDialog(DIALOG_YES_NO);
}       ",438,False
"/**
 * Set the unique identifier of this class
 * @param id the new ID
 */
public void setId (java.lang.Integer id){
	this.id = id;
	this.hashCode = Integer.MIN_VALUE;
}","/**
 * Set the unique identifier of this class
 * @param id the new ID
 */
public void setId (java.lang.Integer id) 
{
    this.id = id;
}   ",442,True
"/** This method is called from within the constructor to
 * initialize the form.
 * WARNING: Do NOT modify this code. The content of this method is
 * always regenerated by the Form Editor.
 */
// <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
private void initComponents(){
    lblTitle = new javax.swing.JLabel();
    jSeparator1 = new javax.swing.JSeparator();

    lblTitle.setFont(getTitleFont());
    lblTitle.setForeground(getTitleColor());
    lblTitle.setText(com.floreantpos.POSConstants.TITLE);

    org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
        layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
        .add(layout.createSequentialGroup()
            .addContainerGap()
            .add(lblTitle, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
            .addContainerGap())
        .add(jSeparator1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
        layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
        .add(layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(lblTitle)
            .add(15, 15, 15)
            .add(jSeparator1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
    );
}","/** This method is called from within the constructor to
 * initialize the form.
 * WARNING: Do NOT modify this code. The content of this method is
 * always regenerated by the Form Editor.
 */
// <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
private void initComponents() 
{
    jDesktopPane1 = new javax.swing.JDesktopPane();
    jMenuBar1 = new javax.swing.JMenuBar();
    jMenu1 = new javax.swing.JMenu();
    jMenuItem1 = new javax.swing.JMenuItem();
    jMenuItem2 = new javax.swing.JMenuItem();
    jMenuItem3 = new javax.swing.JMenuItem();
    jSeparator1 = new javax.swing.JSeparator();
    jMenuItem4 = new javax.swing.JMenuItem();
    jMenu2 = new javax.swing.JMenu();
    jMenuItem5 = new javax.swing.JMenuItem();
    jMenuItem6 = new javax.swing.JMenuItem();
    jSeparator2 = new javax.swing.JSeparator();
    jMenuItem7 = new javax.swing.JMenuItem();

    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jDesktopPane1.setPreferredSize(new java.awt.Dimension(800, 600));
    getContentPane().add(jDesktopPane1, java.awt.BorderLayout.CENTER);

    jMenu1.setText(""File"");
    jMenuItem1.setText(""New"");
    jMenu1.add(jMenuItem1);

    jMenuItem2.setText(""Open"");
    jMenu1.add(jMenuItem2);

    jMenuItem3.setText(""Save"");
    jMenu1.add(jMenuItem3);

    jSeparator1.setText(""jSeparator1"");
    jMenu1.add(jSeparator1);

    jMenuItem4.setText(""Exit"");
    jMenu1.add(jMenuItem4);

    jMenuBar1.add(jMenu1);

    jMenu2.setText(""Edit"");
    jMenuItem5.setText(""Cut"");
    jMenu2.add(jMenuItem5);

    jMenuItem6.setText(""Copy"");
    jMenu2.add(jMenuItem6);

    jSeparator2.setText(""jSeparator2"");
    jMenu2.add(jSeparator2);

    jMenuItem7.setText(""Paste"");
    jMenu2.add(jMenuItem7);

    jMenuBar1.add(jMenu2);

    setJMenuBar(jMenuBar1);

    pack();
}   ",444,False
"/*[CONSTRUCTOR MARKER END]*/
@Override
	public String toString(){
		if(getModifierGroup() != null) {
			return getModifierGroup().getName();
		}
		return """";
	}","/*[CONSTRUCTOR MARKER END]*/
@Override
	public String toString() 
{
    return ""com.jeecms.cms.entity.main.CmsUserGroup [id="" + this.getId() + ""]"";
}	",450,False
"// End of variables declaration//GEN-END:variables
private Font getTitleFont(){
    Font f = lblTitle.getFont();
    f = f.deriveFont(Font.BOLD, 14);
    return f;
}","// End of variables declaration//GEN-END:variables
private Font getTitleFont() 
{
    Font font = new Font(""Arial"", Font.BOLD, 18);
    return font;
}   ",456,True
"/** Creates new form CardView */
public CardPaymentView(){
	initComponents();

	DoubleDocument gratuityDocument = new DoubleDocument();
	gratuityDocument.addDocumentListener(new DocumentListener() {
		void updatePayAmount() {
			double cardAmount = 0;
			double gratuity = 0;

			try {
				gratuity = Double.parseDouble(tfGratuityAmount.getText());
			} catch (Exception x) {
			}
			cardAmount = getDueAmount();
			tfCardAmount.setText(Application.formatNumber(cardAmount + gratuity));
		}

		public void insertUpdate(DocumentEvent e) {
			updatePayAmount();
		}

		public void removeUpdate(DocumentEvent e) {
			updatePayAmount();
		}

		public void changedUpdate(DocumentEvent e) {
			updatePayAmount();
		}

	});
	tfGratuityAmount.setDocument(gratuityDocument);
	tfCardAmount.setDocument(new DoubleDocument());
}","/** Creates new form CardView */
public CardPaymentView() 
{
    initComponents();
    this.setSize(600, 400);
    this.setVisible(true);
}   ",457,True
"//GEN-LAST:event_btnChangePMethodActionPerformed
private JTextField getFocusedTextField(){
		if (tfGratuityAmount.hasFocus()) {
			return tfGratuityAmount;
		}
		if (tfAuthorizationCode.hasFocus()) {
			return tfAuthorizationCode;
		}
		if (tfCardAmount.hasFocus()) {
			return tfCardAmount;
		}
		tfGratuityAmount.requestFocus();
		return tfGratuityAmount;
	}","//GEN-LAST:event_btnChangePMethodActionPerformed
private JTextField getFocusedTextField() 
{
    JTextField focusedTextField = null;
    Component[] components = this.getComponents();
    for (Component component : components)
    {
        if (component.isFocusOwner())
        {
            focusedTextField = (JTextField) component;
            break;
        }
    }
    return focusedTextField;
}   ",458,False
"/**
 * Creates a Layer inside a Scene
 * 
 * @param parentScene parent Scene for the Layer
 * @param maximumDrawableObjects the size of array for Drawables in this Layer
 */
public Layer(Scene parentScene, int maximumDrawableObjects){
	this.parentScene = parentScene;
	this.maximumDrawableObjects = maximumDrawableObjects;
	gameObjects = new FixedSizeArray<Drawable>(maximumDrawableObjects);
	gameObjectsSorted = new FixedSizeArray<Drawable>(maximumDrawableObjects);
}","/**
 * Creates a Layer inside a Scene
 * 
 * @param parentScene parent Scene for the Layer
 * @param maximumDrawableObjects the size of array for Drawables in this Layer
 */

public Layer(Scene parentScene, int maximumDrawableObjects) 
{
    this.parentScene = parentScene;
    this.maximumDrawableObjects = maximumDrawableObjects;
    drawables = new Drawable[maximumDrawableObjects];
    drawableCount = 0;
}   ",462,True
"/**
 * Called when the DynamicObject is removed from a Layer
 */
public void onRemove(){
	super.onRemove();
	rotateToCallback = null;
	moveToCallback = null;
}","/**
 * Called when the DynamicObject is removed from a Layer
 */
public void onRemove() 
{
    if (this.layer != null)
    {
        this.layer.removeDynamicObject(this);
    }
}   ",464,False
"/**
 * Returns a specific vertex of this Sprite, as it is drawn. Taking into account scaling and rotations.
 * 
 * @param index vertex position
 * 
 * @return float array, contains two elements, 0=X 1=Y 
 */
public float[] getVertex(int index){
	if(rotation != 0) {
		float x = getX() + (getWidth() * polygon.vertex[index].getX());
		float y = getY() + (getHeight() * polygon.vertex[index].getY());
		float pivotX = getX() + (getWidth() * 0.5f);
		float pivotY = getY() + (getHeight() * 0.5f);
		float[] f = MathHelper.rotate(rotation, x, y, pivotX, pivotY);
		return f;
	} else {
		return new float[] { getX() + (getWidth() * polygon.vertex[index].getX()), getY() + (getHeight() * polygon.vertex[index].getY()) };
	}
}","/**
 * Returns a specific vertex of this Sprite, as it is drawn. Taking into account scaling and rotations.
 * 
 * @param index vertex position
 * 
 * @return float array, contains two elements, 0=X 1=Y 
 */
public float[] getVertex(int index) 
{
    float[] vertex = new float[2];

    float cos = (float) Math.cos(Math.toRadians(rotation));
    float sin = (float) Math.sin(Math.toRadians(rotation));

    float x = vertices[index * 2] * scale;
    float y = vertices[index * 2 + 1] * scale;

    vertex[0] = x * cos - y * sin + position[0];
    vertex[1] = x * sin + y * cos + position[1];

    return vertex;
}   ",465,True
"/**
 * Removes a Modifier from a Sprite (if it exists)
 * 
 * @param modifier valid Modifier object
 */
public void removeModifier(Modifier modifier){
	for(int i = 0; i < MAX_MODIFIERS; i++) {
		if(this.modifier[i] == modifier) {
			this.modifier[i] = null;
			modifierCount--;
			return;
		}
	}
}","/**
 * Removes a Modifier from a Sprite (if it exists)
 * 
 * @param modifier valid Modifier object
 */
public void removeModifier(Modifier modifier) 
{
    if (modifier != null)
    {
        modifiers.remove(modifier);
    }
}   ",466,True
"/**
 * Accelerates along a given angle to a terminal velocity
 * 
 * @param acceleration magnitude of acceleration
 * @param angle relative to north, in radians
 * @param terminalVelocity maximum velocity to reach
 */
public void accelerate(float acceleration, float angle, float terminalVelocity){
	accelerate(acceleration, angle);
	this.terminalVelocity = terminalVelocity;
	useTerminalVelocity = true;
}","/**
 * Accelerates along a given angle to a terminal velocity
 * 
 * @param acceleration magnitude of acceleration
 * @param angle relative to north, in radians
 * @param terminalVelocity maximum velocity to reach
 */
public void accelerate(float acceleration, float angle, float terminalVelocity) 
{
    float xAccel = (float) (acceleration * Math.cos(angle));
    float yAccel = (float) (acceleration * Math.sin(angle));

    if (Math.abs(velocity.x) < terminalVelocity)
    {
        velocity.x += xAccel;
    }
    if (Math.abs(velocity.y) < terminalVelocity)
    {
        velocity.y += yAccel;
    }
}   ",468,False
"/**
 * Clears all the DrawableObjects off this Layer
 */
public void clear(){
	for(int i = 0; i < gameObjects.getCount(); i++) {
		while(gameObjects.get(i) != null) {
			gameObjects.remove(i);
		}
	}
	gameObjects.clear();
}","/**
 * Clears all the DrawableObjects off this Layer
 */
public void clear() 
{
    if (drawableObjects != null)
    {
        drawableObjects.clear();
    }
}   ",471,True
"/**
 * Accelerates along a given angle
 * 
 * @param acceleration magnitude of acceleration
 * @param angle relative to north, in degrees
 */
public void accelerate(float acceleration, float angle){
	this.acceleration = acceleration;
	this.velocityAngle = angle;
	this.velocityXFactor = (float)Math.sin(angle * MathHelper.DEG_TO_RAD);
	this.velocityYFactor = (float)Math.cos(angle * MathHelper.DEG_TO_RAD);
}","/**
 * Accelerates along a given angle
 * 
 * @param acceleration magnitude of acceleration
 * @param angle relative to north, in degrees
 */
public void accelerate(float acceleration, float angle) 
{
    float angleInRadians = (float) Math.toRadians(angle);
    float x = (float) Math.cos(angleInRadians) * acceleration;
    float y = (float) Math.sin(angleInRadians) * acceleration;
    this.accelerate(x, y);
}   ",475,True
"/**
 * Removes the limit on speed in both X and Y directions
 */
public void stopUsingTerminalSpeed(){
	useTerminalSpeedX = false;
	useTerminalSpeedY = false;
}","/**
 * Removes the limit on speed in both X and Y directions
 */
public void stopUsingTerminalSpeed() 
{
    this.terminalSpeedX = Double.POSITIVE_INFINITY;
    this.terminalSpeedY = Double.POSITIVE_INFINITY;
}   ",478,True
"/** Build and add ""summary"" tab. */
private void setupSummaryTab(){
    final TabHost host = getTabHost();

    // Summary content comes from existing layout
    host.addTab(host.newTabSpec(TAG_SUMMARY)
            .setIndicator(buildIndicator(R.string.session_summary))
            .setContent(R.id.tab_session_summary));
}","/** Build and add ""summary"" tab. */
private void setupSummaryTab() 
{
    summaryTab = new SummaryTab(this);
    tabbedPane.addTab(""Summary"", summaryTab);
    tabbedPane.setMnemonicAt(0, KeyEvent.VK_S);
}   ",481,True
"/** Handle {@link SessionsQuery} {@link Cursor}. */
private void onSessionQueryComplete(Cursor cursor){
    try {
        mSessionCursor = true;
        if (!cursor.moveToFirst()) return;

        // Format time block this session occupies
        final long blockStart = cursor.getLong(SessionsQuery.BLOCK_START);
        final long blockEnd = cursor.getLong(SessionsQuery.BLOCK_END);
        final String roomName = cursor.getString(SessionsQuery.ROOM_NAME);
        final String subtitle = UIUtils.formatSessionSubtitle(blockStart,
                blockEnd, roomName, this);

        mTitleString = cursor.getString(SessionsQuery.TITLE);
        mTitle.setText(mTitleString);
        mSubtitle.setText(subtitle);

        mHashtag = cursor.getString(SessionsQuery.HASHTAG);
        if (TextUtils.isEmpty(mHashtag)) mHashtag = """";

        mRoomId = cursor.getString(SessionsQuery.ROOM_ID);

        // Unregister around setting checked state to avoid triggering
        // listener since change isn't user generated.
        mStarred.setOnCheckedChangeListener(null);
        mStarred.setChecked(cursor.getInt(SessionsQuery.STARRED) != 0);
        mStarred.setOnCheckedChangeListener(this);

        final String sessionAbstract = cursor.getString(SessionsQuery.ABSTRACT);
        if (!TextUtils.isEmpty(sessionAbstract)) {
            UIUtils.setTextMaybeHtml(mAbstract, sessionAbstract);
            mAbstract.setVisibility(View.VISIBLE);
            mHasSummaryContent = true;
        } else {
            mAbstract.setVisibility(View.GONE);
        }

        final View requirementsBlock = findViewById(R.id.session_requirements_block);
        final String sessionRequirements = cursor.getString(SessionsQuery.REQUIREMENTS);
        if (!TextUtils.isEmpty(sessionRequirements)) {
            UIUtils.setTextMaybeHtml(mRequirements, sessionRequirements);
            requirementsBlock.setVisibility(View.VISIBLE);
            mHasSummaryContent = true;
        } else {
            requirementsBlock.setVisibility(View.GONE);
        }

        setupModeratorTab(cursor);

        // Show empty message when all data is loaded, and nothing to show
        if (mSpeakersCursor && !mHasSummaryContent) {
            findViewById(android.R.id.empty).setVisibility(View.VISIBLE);
        }
    } finally {
        cursor.close();
    }
}","/** Handle {@link SessionsQuery} {@link Cursor}. */
private void onSessionQueryComplete(Cursor cursor) 
{
    if (cursor != null)
    {
        try
        {
            if (cursor.moveToFirst())
            {
                do
                {
                    Session session = Session.fromCursor(cursor);
                    if (session != null)
                    {
                        sessions.add(session);
                    }
                }
                while (cursor.moveToNext());
            }
        }
        finally
        {
            cursor.close();
        }
    }
}   ",482,False
"/** Build and add ""moderator"" tab. */
private void setupModeratorTab(Cursor sessionsCursor){
    final TabHost host = getTabHost();

    // Insert Moderator when available
    final View moderatorBlock = findViewById(R.id.moderator_block);
    final String moderatorLink = sessionsCursor.getString(SessionsQuery.MODERATOR_LINK);
    final boolean validModerator = !TextUtils.isEmpty(moderatorLink);
    if (validModerator) {
        mModeratorUri = Uri.parse(moderatorLink);

        // Set link, but handle clicks manually
        final TextView textView = (TextView) findViewById(R.id.moderator_link);
        textView.setText(mModeratorUri.toString());
        textView.setMovementMethod(null);
        textView.setClickable(true);
        textView.setFocusable(true);

        // Start background fetch of moderator status
        startModeratorStatusFetch(moderatorLink);

        moderatorBlock.setVisibility(View.VISIBLE);
    } else {
        moderatorBlock.setVisibility(View.GONE);
    }

    // Insert Wave when available
    final View waveBlock = findViewById(R.id.wave_block);
    final String waveLink = sessionsCursor.getString(SessionsQuery.WAVE_LINK);
    final boolean validWave = !TextUtils.isEmpty(waveLink);
    if (validWave) {
        // Rewrite incoming Wave URL to punch through user-agent check
        mWaveUri = Uri.parse(waveLink).buildUpon()
                .appendQueryParameter(""nouacheck"", ""1"").build();

        // Set link, but handle clicks manually
        final TextView textView = (TextView) findViewById(R.id.wave_link);
        textView.setText(mWaveUri.toString());
        textView.setMovementMethod(null);
        textView.setClickable(true);
        textView.setFocusable(true);

        waveBlock.setVisibility(View.VISIBLE);
    } else {
        waveBlock.setVisibility(View.GONE);
    }

    if (validModerator || validWave) {
        // Moderator content comes from existing layout
        host.addTab(host.newTabSpec(TAG_MODERATOR)
                .setIndicator(buildIndicator(R.string.session_interact))
                .setContent(R.id.tab_session_moderator));
    }
}","/** Build and add ""moderator"" tab. */




private void setupModeratorTab(Cursor sessionsCursor) 
{
    if (sessionsCursor != null && sessionsCursor.moveToFirst())
    {
        TabHost tabHost = (TabHost) findViewById(R.id.tabHost);
        TabSpec moderatorTab = tabHost.newTabSpec(""moderator"");
        moderatorTab.setIndicator(""Moderator"");
        Intent moderatorIntent = new Intent(this, ModeratorActivity.class);
        moderatorIntent.putExtra(""sessionsCursor"", sessionsCursor);
        moderatorTab.setContent(moderatorIntent);
        tabHost.addTab(moderatorTab);
    }
}   ",483,False
"/**
 * Remove any {@link BlockView} instances, leaving only
 * {@link TimeRulerView} remaining.
 */
public void removeAllBlocks(){
    ensureChildren();
    removeAllViews();
    addView(mRulerView);
    addView(mNowView);
}","/**
 * Remove any {@link BlockView} instances, leaving only
 * {@link TimeRulerView} remaining.
 */

public void removeAllBlocks() 
{
    for (int i = 0; i < views.size(); i++)
    {
        if (views.get(i) instanceof BlockView)
        {
            views.remove(i);
            i--;
        }
    }
}   ",484,True
"/**
 * Build a {@link View} to be used as a tab indicator, setting the requested
 * string resource as its label.
 */
private View buildIndicator(int textRes){
    final TextView indicator = (TextView) getLayoutInflater().inflate(R.layout.tab_indicator,
            getTabWidget(), false);
    indicator.setText(textRes);
    return indicator;
}","/**
 * Build a {@link View} to be used as a tab indicator, setting the requested
 * string resource as its label.
 */



private View buildIndicator(int textRes) 
{
    final TextView indicator = (TextView) getLayoutInflater().inflate(
            R.layout.vp_indicator, mTabWidget, false);
    indicator.setText(textRes);
    return indicator;
}   ",489,True
"/**
 * Build a simple {@link SelectionBuilder} to match the requested
 * {@link Uri}. This is usually enough to support {@link #insert},
 * {@link #update}, and {@link #delete} operations.
 */
private SelectionBuilder buildSimpleSelection(Uri uri){
    final SelectionBuilder builder = new SelectionBuilder();
    final int match = sUriMatcher.match(uri);
    switch (match) {
        case BLOCKS: {
            return builder.table(Tables.BLOCKS);
        }
        case BLOCKS_ID: {
            final String blockId = Blocks.getBlockId(uri);
            return builder.table(Tables.BLOCKS)
                    .where(Blocks.BLOCK_ID + ""=?"", blockId);
        }
        case TRACKS: {
            return builder.table(Tables.TRACKS);
        }
        case TRACKS_ID: {
            final String trackId = Tracks.getTrackId(uri);
            return builder.table(Tables.TRACKS)
                    .where(Tracks.TRACK_ID + ""=?"", trackId);
        }
        case ROOMS: {
            return builder.table(Tables.ROOMS);
        }
        case ROOMS_ID: {
            final String roomId = Rooms.getRoomId(uri);
            return builder.table(Tables.ROOMS)
                    .where(Rooms.ROOM_ID + ""=?"", roomId);
        }
        case SESSIONS: {
            return builder.table(Tables.SESSIONS);
        }
        case SESSIONS_ID: {
            final String sessionId = Sessions.getSessionId(uri);
            return builder.table(Tables.SESSIONS)
                    .where(Sessions.SESSION_ID + ""=?"", sessionId);
        }
        case SESSIONS_ID_SPEAKERS: {
            final String sessionId = Sessions.getSessionId(uri);
            return builder.table(Tables.SESSIONS_SPEAKERS)
                    .where(Sessions.SESSION_ID + ""=?"", sessionId);
        }
        case SESSIONS_ID_TRACKS: {
            final String sessionId = Sessions.getSessionId(uri);
            return builder.table(Tables.SESSIONS_TRACKS)
                    .where(Sessions.SESSION_ID + ""=?"", sessionId);
        }
        case SPEAKERS: {
            return builder.table(Tables.SPEAKERS);
        }
        case SPEAKERS_ID: {
            final String speakerId = Speakers.getSpeakerId(uri);
            return builder.table(Tables.SPEAKERS)
                    .where(Speakers.SPEAKER_ID + ""=?"", speakerId);
        }
        case VENDORS: {
            return builder.table(Tables.VENDORS);
        }
        case VENDORS_ID: {
            final String vendorId = Vendors.getVendorId(uri);
            return builder.table(Tables.VENDORS)
                    .where(Vendors.VENDOR_ID + ""=?"", vendorId);
        }
        case NOTES: {
            return builder.table(Tables.NOTES);
        }
        case NOTES_ID: {
            final String noteId = uri.getPathSegments().get(1);
            return builder.table(Tables.NOTES)
                    .where(Notes._ID + ""=?"", noteId);
        }
        case SEARCH_SUGGEST: {
            return builder.table(Tables.SEARCH_SUGGEST);
        }
        default: {
            throw new UnsupportedOperationException(""Unknown uri: "" + uri);
        }
    }
}","/**
 * Build a simple {@link SelectionBuilder} to match the requested
 * {@link Uri}. This is usually enough to support {@link #insert},
 * {@link #update}, and {@link #delete} operations.
 */
private SelectionBuilder buildSimpleSelection(Uri uri) 
{
    final SelectionBuilder builder = new SelectionBuilder();
    // In this case the id is part of the query string.
    final String id = uri.getLastPathSegment();
    builder.table(WeatherContract.WeatherEntry.TABLE_NAME);
    builder.where(WeatherContract.WeatherEntry.COLUMN_WEATHER_ID + "" = ?"", id);
    return builder;
}   ",490,False
"/** Build and add ""vendors"" tab. */
private void setupVendorsTab(){
    final TabHost host = getTabHost();

    final Uri vendorsUri = Vendors.buildSearchUri(mQuery);
    final Intent intent = new Intent(Intent.ACTION_VIEW, vendorsUri);
    intent.addCategory(Intent.CATEGORY_TAB);

    // Vendors content comes from reused activity
    host.addTab(host.newTabSpec(TAG_VENDORS)
            .setIndicator(buildIndicator(R.string.search_vendors))
            .setContent(intent));
}","/** Build and add ""vendors"" tab. */
private void setupVendorsTab() 
{
    final Tab tab = new Tab();
    tab.setText(""Vendors"");
    tab.setContent(new VendorTab());
    tab.setClosable(false);
    tabPane.getTabs().add(tab);
}   ",491,True
"/**
 * Implemented for CallerInfoAsyncQuery.OnQueryCompleteListener interface.
 * refreshes the CallCard data when it called.
 */
public void onQueryComplete(int token, Object cookie, CallerInfo ci){
    if (DBG) log(""onQueryComplete: token "" + token + "", cookie "" + cookie + "", ci "" + ci);

    if (cookie instanceof Call) {
        // grab the call object and update the display for an individual call,
        // as well as the successive call to update image via call state.
        // If the object is a textview instead, we update it as we need to.
        if (DBG) log(""callerinfo query complete, updating ui from displayMainCallStatus()"");
        Call call = (Call) cookie;
        Connection conn = null;
        int phoneType = call.getPhone().getPhoneType();
        if (phoneType == Phone.PHONE_TYPE_CDMA) {
            conn = call.getLatestConnection();
        } else if ((phoneType == Phone.PHONE_TYPE_GSM)
              || (phoneType == Phone.PHONE_TYPE_SIP)) {
            conn = call.getEarliestConnection();
        } else {
            throw new IllegalStateException(""Unexpected phone type: "" + phoneType);
        }
        PhoneUtils.CallerInfoToken cit =
               PhoneUtils.startGetCallerInfo(getContext(), conn, this, null);

        int presentation = Connection.PRESENTATION_ALLOWED;
        if (conn != null) presentation = conn.getNumberPresentation();
        if (DBG) log(""- onQueryComplete: presentation="" + presentation
                + "", contactExists="" + ci.contactExists);

        // Depending on whether there was a contact match or not, we want to pass in different
        // CallerInfo (for CNAP). Therefore if ci.contactExists then use the ci passed in.
        // Otherwise, regenerate the CIT from the Connection and use the CallerInfo from there.
        if (ci.contactExists) {
            updateDisplayForPerson(ci, Connection.PRESENTATION_ALLOWED, false, call);
        } else {
            updateDisplayForPerson(cit.currentInfo, presentation, false, call);
        }
        updatePhotoForCallState(call);

    } else if (cookie instanceof TextView){
        if (DBG) log(""callerinfo query complete, updating ui from ongoing or onhold"");
        ((TextView) cookie).setText(PhoneUtils.getCompactNameFromCallerInfo(ci, mContext));
    }
}","/**
 * Implemented for CallerInfoAsyncQuery.OnQueryCompleteListener interface.
 * refreshes the CallCard data when it called.
 */
public void onQueryComplete(int token, Object cookie, CallerInfo ci) 
{
    if (ci != null)
    {
        if (ci.isStale())
        {
            return;
        }
        else
        {
            refreshCallCardData(ci);
        }
    }
}   ",502,False
"/**
 * This method is called twice in practice. The first time both
 * with and height are constraint by AT_MOST. The second time, the
 * width is still AT_MOST and the height is EXACTLY. Either way
 * the full width/height should be in mWidth and mHeight and we
 * use 'resolveSize' to do the right thing.
 */
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    final int width = resolveSize(mWidth, widthMeasureSpec);
    final int height = resolveSize(mHeight, heightMeasureSpec);
    setMeasuredDimension(width, height);
}","/**
 * This method is called twice in practice. The first time both
 * with and height are constraint by AT_MOST. The second time, the
 * width is still AT_MOST and the height is EXACTLY. Either way
 * the full width/height should be in mWidth and mHeight and we
 * use 'resolveSize' to do the right thing.
 */
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 
{
    int measuredWidth = resolveSize(mWidth, widthMeasureSpec);
    int measuredHeight = resolveSize(mHeight, heightMeasureSpec);
    setMeasuredDimension(measuredWidth, measuredHeight);
}   ",503,True
"/**
 * Set the background of all the children. Typically a selector to
 * change the background based on some combination of the button's
 * attributes (e.g pressed, enabled...)
 * @param resid Is a resource id to be used for each button's background.
 */
public void setChildrenBackgroundResource(int resid){
    final View[] buttons = mButtons;
    for (int i = 0; i < NUM_CHILDREN; i++) {
        buttons[i].setBackgroundResource(resid);
    }
}","/**
 * Set the background of all the children. Typically a selector to
 * change the background based on some combination of the button's
 * attributes (e.g pressed, enabled...)
 * @param resid Is a resource id to be used for each button's background.
 */
public void setChildrenBackgroundResource(int resid) 
{
    for (int i = 0; i < getChildCount(); i++) {
        getChildAt(i).setBackgroundResource(resid);
    }
}   ",505,True
"/**
 * Updates the name / photo / number / label fields on the CallCard
 * based on the specified CallerInfo.
 *
 * If the current call is a conference call, use
 * updateDisplayForConference() instead.
 */
private void updateDisplayForPerson(CallerInfo info,
                                    int presentation,
                                    boolean isTemporary,
                                    Call call){
    if (DBG) log(""updateDisplayForPerson("" + info + "")\npresentation:"" +
                 presentation + "" isTemporary:"" + isTemporary);

    // inform the state machine that we are displaying a photo.
    mPhotoTracker.setPhotoRequest(info);
    mPhotoTracker.setPhotoState(ContactsAsyncHelper.ImageTracker.DISPLAY_IMAGE);

    // The actual strings we're going to display onscreen:
    String displayName;
    String displayNumber = null;
    String label = null;
    Uri personUri = null;
    String socialStatusText = null;
    Drawable socialStatusBadge = null;

    boolean updateName = false;

    if (info != null) {
        // It appears that there is a small change in behaviour with the
        // PhoneUtils' startGetCallerInfo whereby if we query with an
        // empty number, we will get a valid CallerInfo object, but with
        // fields that are all null, and the isTemporary boolean input
        // parameter as true.

        // In the past, we would see a NULL callerinfo object, but this
        // ends up causing null pointer exceptions elsewhere down the
        // line in other cases, so we need to make this fix instead. It
        // appears that this was the ONLY call to PhoneUtils
        // .getCallerInfo() that relied on a NULL CallerInfo to indicate
        // an unknown contact.

        // Currently, info.phoneNumber may actually be a SIP address, and
        // if so, it might sometimes include the ""sip:"" prefix.  That
        // prefix isn't really useful to the user, though, so strip it off
        // if present.  (For any other URI scheme, though, leave the
        // prefix alone.)
        // TODO: It would be cleaner for CallerInfo to explicitly support
        // SIP addresses instead of overloading the ""phoneNumber"" field.
        // Then we could remove this hack, and instead ask the CallerInfo
        // for a ""user visible"" form of the SIP address.
        String number = info.phoneNumber;
        if ((number != null) && number.startsWith(""sip:"")) {
            number = number.substring(4);
        }

        if (TextUtils.isEmpty(info.name)) {
            // No valid ""name"" in the CallerInfo, so fall back to
            // something else.
            // (Typically, we promote the phone number up to the ""name""
            // slot onscreen, and leave the ""number"" slot empty.)
            if (TextUtils.isEmpty(number)) {
                displayName =  getPresentationString(presentation);
            } else if (presentation != Connection.PRESENTATION_ALLOWED) {
                // This case should never happen since the network should never send a phone #
                // AND a restricted presentation. However we leave it here in case of weird
                // network behavior
                displayName = getPresentationString(presentation);
            } else if (!TextUtils.isEmpty(info.cnapName)) {
                displayName = info.cnapName;
                info.name = info.cnapName;
                displayNumber = number;
            } else {
                displayName = number;
            }
        } else {
            // We do have a valid ""name"" in the CallerInfo.  Display that
            // in the ""name"" slot, and the phone number in the ""number"" slot.
            if (presentation != Connection.PRESENTATION_ALLOWED) {
                // This case should never happen since the network should never send a name
                // AND a restricted presentation. However we leave it here in case of weird
                // network behavior
                displayName = getPresentationString(presentation);
            } else {
                displayName = info.name;
                displayNumber = number;
                label = info.phoneLabel;
                // add by cytown for show organization
                updateName = true;
            }
        }
        personUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, info.person_id);
        if (DBG) log(""- got personUri: '"" + personUri
                     + ""', based on info.person_id: "" + info.person_id);
    } else {
        displayName =  getPresentationString(presentation);
    }

    if (call.isGeneric()) {
        mName.setText(R.string.card_title_in_call);
        mOrganization.setVisibility(View.GONE);
    } else {
        mName.setText(displayName);
        if (DBG) log(""show ======= "" + updateName + "":"" + mSettings.mShowOrgan);
        if (updateName && mSettings.mShowOrgan) {
            updateOrganization(info.person_id);
        } else {
            mOrganization.setVisibility(View.GONE);
        }
    }
    mName.setVisibility(View.VISIBLE);

    // Update mPhoto
    // if the temporary flag is set, we know we'll be getting another call after
    // the CallerInfo has been correctly updated.  So, we can skip the image
    // loading until then.

    // If the photoResource is filled in for the CallerInfo, (like with the
    // Emergency Number case), then we can just set the photo image without
    // requesting for an image load. Please refer to CallerInfoAsyncQuery.java
    // for cases where CallerInfo.photoResource may be set.  We can also avoid
    // the image load step if the image data is cached.
    if (isTemporary && (info == null || !info.isCachedPhotoCurrent)) {
        mPhoto.setVisibility(View.INVISIBLE);
    } else if (info != null && info.photoResource != 0){
        showImage(mPhoto, info.photoResource);
    } else if (!showCachedImage(mPhoto, info)) {
        // Load the image with a callback to update the image state.
        // Use the default unknown picture while the query is running.
        ContactsAsyncHelper.updateImageViewWithContactPhotoAsync(
            info, 0, this, call, getContext(), mPhoto, personUri, R.drawable.picture_unknown);
    }
    // And no matter what, on all devices, we never see the ""manage
    // conference"" button in this state.
    mManageConferencePhotoButton.setVisibility(View.INVISIBLE);

    if (displayNumber != null && !call.isGeneric()) {
        mPhoneNumber.setText(displayNumber);
        mPhoneNumber.setTextColor(mTextColorDefaultSecondary);
        mPhoneNumber.setVisibility(View.VISIBLE);
    } else {
        mPhoneNumber.setVisibility(View.GONE);
    }

    if (label != null && !call.isGeneric()) {
        mLabel.setText(label);
        mLabel.setVisibility(View.VISIBLE);
    } else {
        mLabel.setVisibility(View.GONE);
    }

    // Other text fields:
    updateCallTypeLabel(call);
    updateSocialStatus(socialStatusText, socialStatusBadge, call);  // Currently unused
}","/**
 * Updates the name / photo / number / label fields on the CallCard
 * based on the specified CallerInfo.
 *
 * If the current call is a conference call, use
 * updateDisplayForConference() instead.
 */
private void updateDisplayForPerson(CallerInfo info,
                                    int presentation,
                                    boolean isTemporary,
                                    Call call) 
{
    if (DBG) log(""updateDisplayForPerson, info = "" + info);

    // Update the name / photo / number / label fields.
    updateDisplayForPerson(info, presentation, isTemporary, call, false);
}   ",507,False
"// View.OnClickListener implementation
public void onClick(View view){
    int id = view.getId();
    if (DBG) log(""onClick(View "" + view + "", id "" + id + "")..."");

    switch (id) {
        case R.id.manageConferencePhotoButton:
            // A click on anything here gets forwarded
            // straight to the InCallScreen.
            mInCallScreen.handleOnscreenButtonClick(id);
            break;

        default:
            Log.w(LOG_TAG, ""onClick: unexpected click: View "" + view + "", id "" + id);
            break;
    }
}","// View.OnClickListener implementation

public void onClick(View view) 
{
    switch (view.getId())
    {
        case R.id.btn1:
            Toast.makeText(this, ""Button 1 clicked"", Toast.LENGTH_SHORT).show();
            break;
        case R.id.btn2:
            Toast.makeText(this, ""Button 2 clicked"", Toast.LENGTH_SHORT).show();
            break;
        case R.id.btn3:
            Toast.makeText(this, ""Button 3 clicked"", Toast.LENGTH_SHORT).show();
            break;
    }
}   ",508,False
"/**
 * Updates the UI for the state where the phone is not in use.
 * This is analogous to updateForegroundCall() and updateRingingCall(),
 * but for the (uncommon) case where the phone is
 * totally idle.  (See comments in updateState() above.)
 *
 * This puts the callcard into a sane but ""blank"" state.
 */
private void updateNoCall(CallManager cm){
    if (DBG) log(""updateNoCall()..."");

    displayMainCallStatus(cm, null);
    displayOnHoldCallStatus(cm, null);
}","/**
 * Updates the UI for the state where the phone is not in use.
 * This is analogous to updateForegroundCall() and updateRingingCall(),
 * but for the (uncommon) case where the phone is
 * totally idle.  (See comments in updateState() above.)
 *
 * This puts the callcard into a sane but ""blank"" state.
 */
private void updateNoCall(CallManager cm) 
{
    if (mCallCard != null)
    {
        mCallCard.resetCallInfo();
    }
}   ",509,True
"/**
 * Cache the buttons in a member array for faster access.  Compute
 * the measurements for the width/height of buttons.  The inflate
 * sequence is called right after the constructor and before the
 * measure/layout phase.
 */
@Override
protected void onFinishInflate (){
    super.onFinishInflate();
    final View[] buttons = mButtons;
    for (int i = 0; i < NUM_CHILDREN; i++) {
        buttons[i] = getChildAt(i);
        // Measure the button to get initialized.
        buttons[i].measure(MeasureSpec.UNSPECIFIED , MeasureSpec.UNSPECIFIED);
    }

    // Cache the measurements.
    final View child = buttons[0];
    mButtonWidth = child.getMeasuredWidth();
    mButtonHeight = child.getMeasuredHeight();
    mWidthInc = mButtonWidth + mPaddingLeft + mPaddingRight;
    mHeightInc = mButtonHeight + mPaddingTop + mPaddingBottom;
    mWidth = COLUMNS * mWidthInc;
    mHeight = ROWS * mHeightInc;
}","/**
 * Cache the buttons in a member array for faster access.  Compute
 * the measurements for the width/height of buttons.  The inflate
 * sequence is called right after the constructor and before the
 * measure/layout phase.
 */

@Override
protected void onFinishInflate () 
{
    mButtons = new Button[getChildCount()];
    for (int i = 0; i < mButtons.length; i++) {
        mButtons[i] = (Button) getChildAt(i);
    }

    if (mButtons.length > 0) {
        computeButtonMeasurements(mButtons[0]);
    }
}   ",510,True
"/**
 * Implemented for ContactsAsyncHelper.OnImageLoadCompleteListener interface.
 * make sure that the call state is reflected after the image is loaded.
 */
public void onImageLoadComplete(int token, Object cookie, ImageView iView,
        boolean imagePresent){
    if (cookie != null) {
        updatePhotoForCallState((Call) cookie);
    }
}","/**
 * Implemented for ContactsAsyncHelper.OnImageLoadCompleteListener interface.
 * make sure that the call state is reflected after the image is loaded.
 */
public void onImageLoadComplete(int token, Object cookie, ImageView iView,
        boolean imagePresent) 
{
    if (mCallStateListener != null) {
        mCallStateListener.setCallState(token, cookie, imagePresent);
    }
}       ",511,True
"/**
 * Updates the ""on hold"" box in the ""other call"" info area
 * (ie. the stuff in the secondaryCallInfo block)
 * based on the specified Call.
 * Or, clear out the ""on hold"" box if the specified call
 * is null or idle.
 */
private void displayOnHoldCallStatus(CallManager cm, Call call){
    if (DBG) log(""displayOnHoldCallStatus(call ="" + call + "")..."");

    if ((call == null) || (PhoneApp.getInstance().isOtaCallInActiveState())) {
        mSecondaryCallInfo.setVisibility(View.GONE);
        return;
    }

    boolean showSecondaryCallInfo = false;
    Call.State state = call.getState();
    switch (state) {
        case HOLDING:
            // Ok, there actually is a background call on hold.
            // Display the ""on hold"" box.

            // Note this case occurs only on GSM devices.  (On CDMA,
            // the ""call on hold"" is actually the 2nd connection of
            // that ACTIVE call; see the ACTIVE case below.)

            if (PhoneUtils.isConferenceCall(call)) {
                if (DBG) log(""==> conference call."");
                mSecondaryCallName.setText(getContext().getString(R.string.confCall));
                showImage(mSecondaryCallPhoto, R.drawable.picture_conference);
            } else {
                // perform query and update the name temporarily
                // make sure we hand the textview we want updated to the
                // callback function.
                if (DBG) log(""==> NOT a conf call; call startGetCallerInfo..."");
                PhoneUtils.CallerInfoToken infoToken = PhoneUtils.startGetCallerInfo(
                        getContext(), call, this, mSecondaryCallName);
                mSecondaryCallName.setText(
                        PhoneUtils.getCompactNameFromCallerInfo(infoToken.currentInfo,
                                                                getContext()));

                // Also pull the photo out of the current CallerInfo.
                // (Note we assume we already have a valid photo at
                // this point, since *presumably* the caller-id query
                // was already run at some point *before* this call
                // got put on hold.  If there's no cached photo, just
                // fall back to the default ""unknown"" image.)
                if (infoToken.isFinal) {
                    showCachedImage(mSecondaryCallPhoto, infoToken.currentInfo);
                } else {
                    showImage(mSecondaryCallPhoto, R.drawable.picture_unknown);
                }
            }

            showSecondaryCallInfo = true;

            break;

        case ACTIVE:
            // CDMA: This is because in CDMA when the user originates the second call,
            // although the Foreground call state is still ACTIVE in reality the network
            // put the first call on hold.
            if (mApplication.phone.getPhoneType() == Phone.PHONE_TYPE_CDMA) {
                List<Connection> connections = call.getConnections();
                if (connections.size() > 2) {
                    // This means that current Mobile Originated call is the not the first 3-Way
                    // call the user is making, which in turn tells the PhoneApp that we no
                    // longer know which previous caller/party had dropped out before the user
                    // made this call.
                    mSecondaryCallName.setText(
                            getContext().getString(R.string.card_title_in_call));
                    showImage(mSecondaryCallPhoto, R.drawable.picture_unknown);
                } else {
                    // This means that the current Mobile Originated call IS the first 3-Way
                    // and hence we display the first callers/party's info here.
                    Connection conn = call.getEarliestConnection();
                    PhoneUtils.CallerInfoToken infoToken = PhoneUtils.startGetCallerInfo(
                            getContext(), conn, this, mSecondaryCallName);

                    // Get the compactName to be displayed, but then check that against
                    // the number presentation value for the call. If it's not an allowed
                    // presentation, then display the appropriate presentation string instead.
                    CallerInfo info = infoToken.currentInfo;

                    String name = PhoneUtils.getCompactNameFromCallerInfo(info, getContext());
                    boolean forceGenericPhoto = false;
                    if (info != null && info.numberPresentation !=
                            Connection.PRESENTATION_ALLOWED) {
                        name = getPresentationString(info.numberPresentation);
                        forceGenericPhoto = true;
                    }
                    mSecondaryCallName.setText(name);

                    // Also pull the photo out of the current CallerInfo.
                    // (Note we assume we already have a valid photo at
                    // this point, since *presumably* the caller-id query
                    // was already run at some point *before* this call
                    // got put on hold.  If there's no cached photo, just
                    // fall back to the default ""unknown"" image.)
                    if (!forceGenericPhoto && infoToken.isFinal) {
                        showCachedImage(mSecondaryCallPhoto, info);
                    } else {
                        showImage(mSecondaryCallPhoto, R.drawable.picture_unknown);
                    }
                }
                showSecondaryCallInfo = true;

            } else {
                // We shouldn't ever get here at all for non-CDMA devices.
                Log.w(LOG_TAG, ""displayOnHoldCallStatus: ACTIVE state on non-CDMA device"");
                showSecondaryCallInfo = false;
            }
            break;

        default:
            // There's actually no call on hold.  (Presumably this call's
            // state is IDLE, since any other state is meaningless for the
            // background call.)
            showSecondaryCallInfo = false;
            break;
    }

    if (showSecondaryCallInfo) {
        // Ok, we have something useful to display in the ""secondary
        // call"" info area.
        mSecondaryCallInfo.setVisibility(View.VISIBLE);

        // Watch out: there are some cases where we need to display the
        // secondary call photo but *not* the two lines of text above it.
        // Specifically, that's any state where the CallCard ""upper title"" is
        // in use, since the title (e.g. ""Dialing"" or ""Call ended"") might
        // collide with the secondaryCallStatus and secondaryCallName widgets.
        //
        // We detect this case by simply seeing whether or not there's any text
        // in mUpperTitle.  (This is much simpler than detecting all possible
        // telephony states where the ""upper title"" is used!  But note it does
        // rely on the fact that updateCardTitleWidgets() gets called *earlier*
        // than this method, in the CallCard.updateState() sequence...)
        boolean okToShowLabels = TextUtils.isEmpty(mUpperTitle.getText());
        mSecondaryCallName.setVisibility(okToShowLabels ? View.VISIBLE : View.INVISIBLE);
        mSecondaryCallStatus.setVisibility(okToShowLabels ? View.VISIBLE : View.INVISIBLE);
    } else {
        // Hide the entire ""secondary call"" info area.
        mSecondaryCallInfo.setVisibility(View.GONE);
    }
}","/**
 * Updates the ""on hold"" box in the ""other call"" info area
 * (ie. the stuff in the secondaryCallInfo block)
 * based on the specified Call.
 * Or, clear out the ""on hold"" box if the specified call
 * is null or idle.
 */
private void displayOnHoldCallStatus(CallManager cm, Call call) 
{
    if (call == null || call.getState() == Call.State.IDLE)
    {
        setOnHoldCallText("""");
    }
    else
    {
        String displayName = call.getDisplayName();
        setOnHoldCallText(getString(R.string.onHoldCall, displayName));
    }
}   ",512,False
"/**
 * Updates mElapsedTime based on the specified number of seconds.
 * A timeElapsed value of zero means to not show an elapsed time at all.
 */
private void updateElapsedTimeWidget(long timeElapsed){
    // if (DBG) log(""updateElapsedTimeWidget: "" + timeElapsed);
    if (timeElapsed == 0) {
        mElapsedTime.setText("""");
    } else {
        mElapsedTime.setText(DateUtils.formatElapsedTime(timeElapsed));
    }
}","/**
 * Updates mElapsedTime based on the specified number of seconds.
 * A timeElapsed value of zero means to not show an elapsed time at all.
 */

private void updateElapsedTimeWidget(long timeElapsed) 
{
    if (timeElapsed == 0)
    {
        mElapsedTime.setVisibility(View.GONE);
    }
    else
    {
        mElapsedTime.setVisibility(View.VISIBLE);
        mElapsedTime.setText(TimeUtils.formatElapsedTime(timeElapsed));
    }
}   ",514,True
"/**
 * @param context
 * @param latitude
 * @param longitude
 * @return
 * @throws IOException
 * @todo fixme Webservice should implement HTTP GET resource for requesting categories ..
 */
public static HttpResponse getCategories(Context context, double latitude, double longitude) throws IOException{
    Log.d(LOG_TAG, String.format(""lat %s long %s"", latitude, longitude));
    HttpParams params = new BasicHttpParams();
    HttpConnectionParams.setConnectionTimeout(params, TIMEOUT_CONNECTION);

    HttpClient httpClient = new DefaultHttpClient(params);

    HttpPost httpPost = new HttpPost(context.getString(R.string.postURL));
    httpPost.addHeader(""User-Agent"", getUserAgent(context));

    final String hack = ""hackForFetchingCategories"";
    MultipartEntity reqEntity = new MultipartEntity();
    Charset utf8 = Charset.forName(""UTF-8"");
    reqEntity.addPart(FORM_SERVICE, new StringBody(""FiksGataMi4Android"", utf8));
    reqEntity.addPart(FORM_CATEGORIES, new StringBody(""1"", utf8));
    reqEntity.addPart(FORM_SUBJECT, new StringBody(hack, utf8));
    reqEntity.addPart(FORM_NAME, new StringBody(hack, utf8));
    reqEntity.addPart(FORM_EMAIL, new StringBody(""noreply@example.com"", utf8));
    reqEntity.addPart(FORM_LATITUDE, new StringBody(String.valueOf(latitude), utf8));
    reqEntity.addPart(FORM_LONGITUDE, new StringBody(String.valueOf(longitude), utf8));

    httpPost.setEntity(reqEntity);
    HttpResponse httpResponse = httpClient.execute(httpPost);

    httpClient.getConnectionManager().shutdown();
    return httpResponse;

}","/**
 * @param context
 * @param latitude
 * @param longitude
 * @return
 * @throws IOException
 * @todo fixme Webservice should implement HTTP GET resource for requesting categories ..
 */

public static HttpResponse getCategories(Context context, double latitude, double longitude) throws IOException 
{
    HttpGet request = new HttpGet(""http://www.example.com/categories?lat="" + latitude + ""&lon="" + longitude);
    HttpResponse response = new DefaultHttpClient().execute(request);
    return response;
}   ",523,False
"// disable the Back key in case things get submitted twice
public boolean onKeyDown(int keyCode, KeyEvent event){
	if (keyCode == KeyEvent.KEYCODE_BACK) {
		Intent i = new Intent(Success.this, Home.class);
		startActivity(i);
		finish(); // finish so we don't go back here
		return true;
	}
	return false;
}","// disable the Back key in case things get submitted twice
public boolean onKeyDown(int keyCode, KeyEvent event) 
{
    if (keyCode == KeyEvent.KEYCODE_BACK)
    {
        return false;
    }
    return super.onKeyDown(keyCode, event);
}   ",525,True
"// TODO - add Bundles for these?
@Override
public boolean onCreateOptionsMenu(Menu menu){
	super.onCreateOptionsMenu(menu);
	MenuItem homeItem = menu.add(Menu.NONE, MENU_HOME, Menu.NONE, R.string.menu_home);
	MenuItem aboutItem = menu.add(Menu.NONE, MENU_HELP, Menu.NONE, R.string.menu_help);
	aboutItem.setIcon(android.R.drawable.ic_menu_info_details);
	homeItem.setIcon(android.R.drawable.ic_menu_edit);
	return true;
}","// TODO - add Bundles for these?

@Override
public boolean onCreateOptionsMenu(Menu menu) 
{
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}   ",528,False
"//@Override
public void onBackPressed(){
    // TODO: This dosen't work - we are still sendt back to the last activity
    // This will be called either automatically for you on 2.0
    // or later, or by the code above on earlier versions of the
    // platform.
    finish(); // Close application on back-press
    return;
}","//@Override
public void onBackPressed() 
{
    if (mDrawerLayout.isDrawerOpen(GravityCompat.START))
    {
        mDrawerLayout.closeDrawer(GravityCompat.START);
    }
    else
    {
        super.onBackPressed();
    }
}   ",531,False
"// ****************************************************
// checkBundle - check the extras that have been passed
// is the user able to upload things yet, or not?
// ****************************************************
private void checkBundle(){
    // Log.d(LOG_TAG, ""checkBundle"");
    // Get the status icons...
    Resources res = getResources();
    Drawable checked = res.getDrawable(R.drawable.done);
    if (extras != null) {
        // Log.d(LOG_TAG, ""Checking extras"");
        // Details extras
        name = extras.getString(""name"");
        email = extras.getString(""email"");
        subject = extras.getString(""subject"");
        if (!havePicture) {
            havePicture = extras.getBoolean(""photo"");
        }
        // Do we have the details?
        if ((name != null) && (email != null) && (subject != null)) {
            haveDetails = true;
            // Log.d(LOG_TAG, ""Have all details"");
            checked.setBounds(0, 0, checked.getIntrinsicWidth(), checked
                    .getIntrinsicHeight());
            // envelope.setBounds(0, 0, envelope.getIntrinsicWidth(),
            // envelope
            // .getIntrinsicHeight());
            btnDetails.setText(String.format(getString(R.string.subject_details_added), subject));
            btnDetails.setCompoundDrawables(null, null, checked, null);
        } else {
            // Log.d(LOG_TAG, ""Don't have details"");
        }
    } else {
        extras = new Bundle();
        // Log.d(LOG_TAG, ""no Bundle at all"");
    }
    // Log.d(LOG_TAG, ""havePicture = "" + havePicture);

    // Do we have the photo?
    if (havePicture) {

        checked.setBounds(0, 0, checked.getIntrinsicWidth(), checked
                .getIntrinsicHeight());
        // camera.setBounds(0, 0, camera.getIntrinsicWidth(), camera
        // .getIntrinsicHeight());
        btnPicture.setCompoundDrawables(null, null, checked, null);
        btnPicture.setText(R.string.picture_taken);
    }
    if (havePicture && haveDetails) {
        textProgress.setVisibility(View.VISIBLE);
        progressLoading.setVisibility(View.VISIBLE);
    }
}","// ****************************************************
// checkBundle - check the extras that have been passed
// is the user able to upload things yet, or not?
// ****************************************************

private void checkBundle() 
{
    Bundle extras = getIntent().getExtras();
    if (extras != null)
    {
        if (extras.containsKey(""upload""))
        {
            upload = extras.getBoolean(""upload"");
        }
    }
}   ",532,False
"// Save user's name and email, if already defined
@Override
protected void onStop(){
	super.onStop();

	name = nameET.getText().toString();
	email = emailET.getText().toString();

	// Save user preferences
	SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
	SharedPreferences.Editor editor = settings.edit();
	editor.putString(""myName"", name);
	editor.putString(""myEmail"", email);

	// Don't forget to commit your edits!!!
	editor.commit();
}","// Save user's name and email, if already defined
@Override
protected void onStop() 
{
    super.onStop();

    SharedPreferences.Editor editor = preferences.edit();
    editor.putString(""name"", name);
    editor.putString(""email"", email);
    editor.apply();
}   ",533,True
"// ****************************************************
// Options menu functions
// ****************************************************
@Override
public boolean onCreateOptionsMenu(Menu menu){
	super.onCreateOptionsMenu(menu);
	MenuItem helpItem = menu.add(Menu.NONE, MENU_HOME, Menu.NONE, R.string.menu_home);
	helpItem.setIcon(android.R.drawable.ic_menu_edit);
	return true;
}","// ****************************************************
// Options menu functions
// ****************************************************
@Override
public boolean onCreateOptionsMenu(Menu menu) 
{
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.options_menu, menu);
    return true;
}   ",537,False
"/**
 * On options item selected
 * 
 * @param item
 */
@Override
	public boolean onOptionsItemSelected(MenuItem item){
		switch (item.getItemId()) {
			case R.id.refresh:
				adapter.refresh();
				break;
			case R.id.filter:
				Intent intent = new Intent(MessagesActivity.this, FilterActivity.class);
				intent.putExtra(""filter"", adapter.getFilter());
				startActivityForResult(intent, SET_FILTER);
				break;
		}
		return true;
	}","/**
 * On options item selected
 * 
 * @param item
 */
@Override
	public boolean onOptionsItemSelected(MenuItem item) 
{
    switch (item.getItemId())
    {
        case R.id.action_settings:
            return true;
        case R.id.action_exit:
            finish();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}	",540,True
"/**
 * On click close the activity
 */
public void onClick(View v){
	android.util.Log.d(""foo"", ""Close"");
	finish();
}","/**
 * On click close the activity
 */
public void onClick(View v) 
{
    switch (v.getId())
    {
        case R.id.close:
            finish();
            break;
    }
}   ",541,False
"/**
 * Get Request Instance
 * 
 * @return
 */
public static Request getInstance(){
	if (instance == null) {
		instance = createInstance();
	}
	
	return instance;
}","/**
 * Get Request Instance
 * 
 * @return
 */
public static Request getInstance() 
{
    if (instance == null)
    {
        synchronized (Request.class)
        {
            if (instance == null)
            {
                instance = new Request();
            }
        }
    }
    return instance;
}   ",542,True
"/**
 * OnClickListener..
 */
public void onClick(View v){
	Log.d(TAG, ""Login..."");
	
	String url = baseUrl.getText().toString(); 
	
	UrlBuilder builder = UrlBuilder.getInstance();
	builder.setBaseUrl(url);
	
	SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
	String httpUser = prefs.getString(""httpUser"", """");
	String httpPassword = prefs.getString(""httpPassword"", """");
	
	if (httpUser != """" && httpPassword != """") {
		Request.createInstance().setHttpAuth(httpUser, httpPassword);
	}
	
	if (URLUtil.isValidUrl(url)) {
		dialog = ProgressDialog.show(this, ""Login.."", ""Trying to connect to server..."", true, false);
		new Thread(this).start();
	} else {
		Toast.makeText(this, ""Invalid Url '"" + url + ""'"", Toast.LENGTH_SHORT).show();
	}
}","/**
 * OnClickListener..
 */
public void onClick(View v) 
{
    switch (v.getId())
    {
        case R.id.btn1:
            // do something
            break;
        case R.id.btn2:
            // do something
            break;
        default:
            break;
    }
}   ",543,False
"/**
 * Options Menu
 * 
 * @param menu 
 */
@Override
public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.login, menu);
    return true;
}","/**
 * Options Menu
 * 
 * @param menu 
 */

@Override
public boolean onCreateOptionsMenu(Menu menu) 
{
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.options_menu, menu);
    return true;
}   ",547,True
"/**
 * Thread for login
 */
public void run(){
	UrlBuilder builder = UrlBuilder.getInstance();
	String response = Request.getInstance().execute(builder.getPingUrl());
	
	if (response != null && response.equals(""GrayLog/Pong"")) {
		// Login successful
		handler.sendEmptyMessage(1);
	} else {
		// Login failed
		handler.sendEmptyMessage(0);
	}
	
	dialog.dismiss();
}","/**
 * Thread for login
 */
public void run() 
{
    try
    {
        // Create a new instance of the Login class
        Login login = new Login();

        // Call the login method with the provided username and password
        login.login(username, password);
    }
    catch (Exception e)
    {
        // Print the stack trace if an exception occurs
        e.printStackTrace();
    }
}   ",554,False
"/**
 * Deserialize dashboard from JSON
 * 
 * @param json Serialized dashboard (JSON)
 * 
 * @return deserialized Dashboard
 */
public static Dashboard deserializeDashboard(String json){
	try {
		JSONObject object = new JSONObject(json);
		
		Dashboard dashboard = new Dashboard();
		dashboard.setTimeSpan(object.getInt(""timespan""));
		dashboard.setLastMessage(deserializeMessage(object.getJSONObject(""last_message"")));
		dashboard.setMessages(object.getInt(""messages""));
		dashboard.setStatus(object.getString(""status""));

		return dashboard;
	} catch(Exception e) {
		Log.d(TAG, ""Exception: "" + e.getMessage());
		return null;
	}
}","/**
 * Deserialize dashboard from JSON
 * 
 * @param json Serialized dashboard (JSON)
 * 
 * @return deserialized Dashboard
 */






public static Dashboard deserializeDashboard(String json) 
{
    ObjectMapper mapper = new ObjectMapper();
    Dashboard dashboard = null;
    try
    {
        dashboard = mapper.readValue(json, Dashboard.class);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    return dashboard;
}   ",556,True
"/**
 * On filter set
 */
public void onActivityResult(int requestCode, int resultCode, Intent data){
	if (requestCode == SET_FILTER) {
		if (resultCode == RESULT_OK) {
			adapter.setFilter((Filter) data.getExtras().get(""filter""));
			adapter.refresh();
		}
	}
}","/**
 * On filter set
 */
public void onActivityResult(int requestCode, int resultCode, Intent data) 
{
    if (requestCode == 1)
    {
        if (resultCode == RESULT_OK)
        {
            String result = data.getStringExtra(""result"");
            Toast.makeText(this, result, Toast.LENGTH_LONG).show();
        }
    }
}   ",557,True
"/**
 * Will be called by the login marvinthread on failure
 */
public void loginFailed(){
	String baseUrl  = this.baseUrl.getText().toString();
	Toast.makeText(this, ""Can't connect to server '"" + baseUrl + ""'"", Toast.LENGTH_SHORT).show();
}","/**
 * Will be called by the login marvinthread on failure
 */
public void loginFailed() 
{
    if (this.loginAttempts < 3)
    {
        this.loginAttempts++;
        this.login();
    }
    else
    {
        this.stop();
    }
}   ",559,True
"/**
 * Create a new instance of this class working with the provided map and
 * model.
 * 
 * @param mapKit
 *            Map to use.
 * @param dataModel
 *            Model to modify.
 */
public MapMouseListener(final JXMapKit mapKit, final IDataModel dataModel){
    map = mapKit;
    model = dataModel;
}","/**
 * Create a new instance of this class working with the provided map and
 * model.
 * 
 * @param mapKit
 *            Map to use.
 * @param dataModel
 *            Model to modify.
 */
public MapMouseListener(final JXMapKit mapKit, final IDataModel dataModel) 
{
    this.mapKit = mapKit;
    this.dataModel = dataModel;
}   ",562,True
"/**
 * Creates a new instance of the panel using the provided data model.
 * 
 * @param dataModel
 *            Data model to use.
 */
public SidePanel(final IDataModel dataModel){
    model = dataModel;

    BoxLayout layout = new BoxLayout(this, BoxLayout.Y_AXIS);
    setLayout(layout);
    add(getWaypointPanel());
    add(getRoutePanel());
    add(getDevicePanel());
}","/**
 * Creates a new instance of the panel using the provided data model.
 * 
 * @param dataModel
 *            Data model to use.
 */
public SidePanel(final IDataModel dataModel) 
{
    super(dataModel);
    initialize();
}   ",565,False
"/**
 * Creates the resource map from the properties file.
 */
private void createResourceMap(){
    resourceMap = Application.getInstance().getContext().getResourceMap(
            MainFrame.class);
    resourceMap.injectComponents(this);
}","/**
 * Creates the resource map from the properties file.
 */


private void createResourceMap() 
{
    if (resourceMap == null)
    {
        resourceMap = new HashMap();
        ResourceBundle bundle = ResourceBundle.getBundle(""org.apache.myfaces.resource.ResourceHandler"");
        Enumeration keys = bundle.getKeys();
        while (keys.hasMoreElements())
        {
            String key = (String) keys.nextElement();
            String value = bundle.getString(key);
            resourceMap.put(key, value);
        }
    }
}   ",567,False
"/**
 * Calculates the speed vector pointing from the start to the endpoint.
 * 
 * @param start
 *            Startpoint of segment.
 * @param end
 *            Endpoint of segment.
 * @return Speed vector pointing from start to end.
 */
private GeoPosition getSpeedVector(final GpsWaypoint start,
        final GpsWaypoint end){
    double latDiff = end.getLatitude() - start.getLatitude();
    double lonDiff = end.getLongitude() - start.getLongitude();
    double length = Math.sqrt(Math.pow(latDiff, 2)
            + Math.pow(lonDiff, 2));
    return new GeoPosition(latDiff / length * speed, lonDiff / length
            * speed);
}","/**
 * Calculates the speed vector pointing from the start to the endpoint.
 * 
 * @param start
 *            Startpoint of segment.
 * @param end
 *            Endpoint of segment.
 * @return Speed vector pointing from start to end.
 */
private GeoPosition getSpeedVector(final GpsWaypoint start,
        final GpsWaypoint end) 
{
    final double distance = getDistance(start, end);
    final double time = end.getTime() - start.getTime();
    final double speed = distance / time;
    final double bearing = getBearing(start, end);
    return getSpeedVector(bearing, speed);
}   ",569,True
"/**
 * Returns the panel used for interaction with the device emulator. The
 * panel is created in the first method call.
 * 
 * @return Device panel.
 */
private DevicePanel getDevicePanel(){
    if (devicePanel == null) {
        devicePanel = new DevicePanel(model);
    }
    return devicePanel;
}","/**
 * Returns the panel used for interaction with the device emulator. The
 * panel is created in the first method call.
 * 
 * @return Device panel.
 */
private DevicePanel getDevicePanel() 
{
    if (devicePanel == null)
    {
        devicePanel = new DevicePanel();
    }
    return devicePanel;
}   ",571,True
"/*
 * (non-Javadoc)
 * @see net.sourcewalker.fakegps.data.IRoute#pause()
 */
@Override
public final void pause(){
    state = RouteState.PAUSED;
    model.notifyRouteStateChange();
}","/*
 * (non-Javadoc)
 * @see net.sourcewalker.fakegps.data.IRoute#pause()
 */
@Override
public final void pause() 
{
    synchronized (this)
    {
        if (isPaused)
        {
            return;
        }
        isPaused = true;
        if (isRunning)
        {
            timer.cancel();
        }
    }
}   ",573,True
"/*
 * (non-Javadoc)
 * @see java.awt.event.MouseListener#mouseClicked(java.awt.event.MouseEvent)
 */
@Override
public final void mouseClicked(final MouseEvent e){
    Point2D clickPoint = new Point(e.getX(), e.getY());
    switch (model.getCurrentTool()) {
    case ADDPOINT:
        GeoPosition geoPoint = map.getMainMap().convertPointToGeoPosition(
                clickPoint);
        GpsWaypoint newWp = new GpsWaypoint(geoPoint);
        model.addWaypoint(newWp);
        model.setCurrentTool(MapTool.ADDPOINT);
        break;
    case REMOVEPOINT:
        for (GpsWaypoint wp : model.getWaypoints()) {
            Point2D wpScreen = map.getMainMap().convertGeoPositionToPoint(
                    wp.getPosition());
            if (clickPoint.distance(wpScreen) < REMOVE_DISTANCE) {
                model.removeWaypoint(wp);
                break;
            }
        }
        break;
    default:
        break;
    }
}","/*
 * (non-Javadoc)
 * @see java.awt.event.MouseListener#mouseClicked(java.awt.event.MouseEvent)
 */
@Override
public final void mouseClicked(final MouseEvent e) 
{
    if (e.getButton() == MouseEvent.BUTTON1)
    {
        if (e.getClickCount() == 2)
        {
            // double click
            this.doubleClick(e);
        }
        else
        {
            // single click
            this.singleClick(e);
        }
    }
}   ",575,False
"/**
 * Returns the map view control. The first call creates the control.
 * 
 * @return Map view control.
 */
private JXMapKit getMapView(){
    if (mapKit == null) {
        mapKit = new JXMapKit();
        mapKit.setName(""mapKit"");

        mapKit.setDefaultProvider(JXMapKit.DefaultProviders.OpenStreetMaps);
        mapKit.setAddressLocationShown(false);
        mapKit.getMainMap().setOverlayPainter(
                new RoutePainter(getWaypointModel()));
        mapKit.getMainMap().addMouseListener(
                new MapMouseListener(mapKit, waypointModel));
    }
    return mapKit;
}","/**
 * Returns the map view control. The first call creates the control.
 * 
 * @return Map view control.
 */
private JXMapKit getMapView() 
{
    if (mapView == null)
    {
        mapView = new JXMapKit();
        mapView.setDefaultProvider(JXMapKit.DefaultProviders.OpenStreetMap);
        mapView.setZoom(5);
    }
    return mapView;
}   ",576,False
"/**
 * Create a new route controller for the list of waypoints.
 * 
 * @param dataModel
 *            Model to use for events.
 * @param waypoints
 *            Waypoints to use for route.
 */
public SimpleRoute(final IDataModel dataModel,
        final List<GpsWaypoint> waypoints){
    model = dataModel;
    waypointList = new ArrayList<GpsWaypoint>(waypoints);
    speed = dataModel.getRouteSpeed();
    state = RouteState.RUNNING;
    worker = new RouteThread();
    worker.start();
}","/**
 * Create a new route controller for the list of waypoints.
 * 
 * @param dataModel
 *            Model to use for events.
 * @param waypoints
 *            Waypoints to use for route.
 */
public SimpleRoute(final IDataModel dataModel,
        final List<GpsWaypoint> waypoints) 
{
    this.dataModel = dataModel;
    this.waypoints = waypoints;
}       ",577,True
"/**
 * Returns the panel used for interaction with the route controller. The
 * panel is created in the first method call.
 * 
 * @return Route panel.
 */
private RoutePanel getRoutePanel(){
    if (routePanel == null) {
        routePanel = new RoutePanel(model);
    }
    return routePanel;
}","/**
 * Returns the panel used for interaction with the route controller. The
 * panel is created in the first method call.
 * 
 * @return Route panel.
 */
private RoutePanel getRoutePanel() 
{
    if (routePanel == null)
    {
        routePanel = new RoutePanel();
    }
    return routePanel;
}   ",579,True
"/**
 * Method to create our really blacklist dialog
 */
private AlertDialog reallyUnblacklistDialog(){
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setMessage(R.string.really_unblacklist_dialog)
        .setCancelable(false)
        .setPositiveButton(""Yes"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int id) {
                ContentValues values = new ContentValues();
                values.put(MessagesProviderHelper.KEY_BLACKLIST, 0);
                messagesProviderHelper.updateItemByID(currentRowID, values);

                currentRowID = -1;
                fillListView(VIEW_MODE);
                toast = Toast.makeText(getApplicationContext(), R.string.toast_message_unblacklisted, Toast.LENGTH_SHORT);
                toast.show();
            }
        })
        .setNegativeButton(""No"", null);
    return builder.create();
}","/**
 * Method to create our really blacklist dialog
 */

private AlertDialog reallyUnblacklistDialog() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(R.string.unblacklist_title);
    builder.setMessage(R.string.unblacklist_message);
    builder.setPositiveButton(R.string.yes, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            unblacklist();
        }
    });
    builder.setNegativeButton(R.string.no, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            dialog.dismiss();
        }
    });
    return builder.create();
}   ",582,True
"/**
 * Show the ask for passphrase dialog box
 */
private AlertDialog passphraseDialog(){
    LayoutInflater factory = LayoutInflater.from(this);
    final View textEntryView = factory.inflate(R.layout.ask_for_passphrase, null);
    AlertDialog.Builder builder = new AlertDialog.Builder(this)
        .setTitle(getString(R.string.app_name))
        .setView(textEntryView)
        .setPositiveButton(""ok"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                EditText et = ((EditText) textEntryView.findViewById(R.id.ask_for_passphrase_edit));
                passphrase = et.getText().toString();
                unlockDatabase(passphrase);

                et.setText("""");
                System.gc();
            }
        })
        .setNegativeButton(""cancel"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {

            }
        });

    return builder.create();
}","/**
 * Show the ask for passphrase dialog box
 */

private AlertDialog passphraseDialog() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(""Enter Passphrase"");
    final EditText input = new EditText(this);
    input.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
    builder.setView(input);
    builder.setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            String passphrase = input.getText().toString();
            // Perform any necessary actions with the passphrase
        }
    });
    builder.setNegativeButton(""Cancel"", new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            dialog.cancel();
        }
    });
    return builder.create();
}   ",583,False
"/**
 * Method to create our lack of nexus key or secret dialog
 */
private AlertDialog noKeyDialog(){
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setMessage(R.string.no_key_dialog)
        .setCancelable(false)
        .setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int id) {
            }
        });
    return builder.create();
}","/**
 * Method to create our lack of nexus key or secret dialog
 */
private AlertDialog noKeyDialog() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(R.string.no_key_title);
    builder.setMessage(R.string.no_key_message);
    builder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            dialog.dismiss();
        }
    });
    return builder.create();
}   ",584,True
"/**
 * Rekey the database with the new passphrase
 */
private void rekeyDatabase(String passphrase){
    try {
        messagesProviderHelper.rekey(passphrase);
    } catch (Exception e) {
        Toast.makeText(this, R.string.toast_unable_to_rekey, Toast.LENGTH_LONG);
        log.error(""Error rekeying database: "" + e.getMessage());
    }
}","/**
 * Rekey the database with the new passphrase
 */
private void rekeyDatabase(String passphrase) 
{
    // Get the current database instance
    Database db = Database.getInstance();

    // Rekey the database with the new passphrase
    db.rekey(passphrase);
}   ",588,True
"/**
 * Method to create our really delete dialog
 */
private AlertDialog reallyDeleteDialog(){
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setMessage(""Are you sure you want to delete this message?"")
        .setCancelable(false)
        .setPositiveButton(""Yes"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int id) {
                Cursor localCursor = messagesProviderHelper.returnItemByID(currentRowID);
                startManagingCursor(localCursor);
                String attachmentPath = localCursor.getString(localCursor.getColumnIndex(MessagesProviderHelper.KEY_ATTACHMENT_PATH));
                boolean mine = localCursor.getInt(localCursor.getColumnIndex(MessagesProviderHelper.KEY_MINE)) > 0;
                
                if ((!(attachmentPath.equals(""""))) && (!mine)) {
                    File f = new File(attachmentPath);
                    f.delete();
                }

                messagesProviderHelper.deleteById(currentRowID);

                try {
                    // Send message to service to note that a new message has been created
                    Message msg = Message.obtain(null, MSG_MESSAGE_DELETED);
                    networkService.send(msg);
                } catch (RemoteException e) {
                    // Here, the service has crashed even before we were able to connect
                }

                currentRowID = -1;
                fillListView(VIEW_MODE);
                toast = Toast.makeText(getApplicationContext(), R.string.toast_message_deleted, Toast.LENGTH_SHORT);
                toast.show();
            }
        })
        .setNegativeButton(""No"", null);
    return builder.create();
}","/**
 * Method to create our really delete dialog
 */

private AlertDialog reallyDeleteDialog() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(R.string.delete);
    builder.setMessage(R.string.delete_message);
    builder.setPositiveButton(R.string.yes, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            delete();
        }
    });
    builder.setNegativeButton(R.string.no, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            dialog.dismiss();
        }
    });
    return builder.create();
}   ",589,False
"/*
 * Context menu code from:
 * http://stackoverflow.com/questions/6205808/how-to-handle-long-tap-on-listview-item
 */
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo){
    super.onCreateContextMenu(menu, v, menuInfo);
    AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
    currentRowID = info.id;
    
    Cursor localCursor = messagesProviderHelper.returnItemByID(currentRowID);
    startManagingCursor(localCursor);
    menu.setHeaderTitle(localCursor.getString(localCursor.getColumnIndexOrThrow(MessagesProviderHelper.KEY_TITLE)));
    int mine = localCursor.getInt(localCursor.getColumnIndexOrThrow(MessagesProviderHelper.KEY_MINE));

    if (VIEW_MODE == VIEW_BLACKLIST) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.message_list_context_unblacklist, menu);
    } else {
        if (mine == 0) {
            MenuInflater inflater = getMenuInflater();
            inflater.inflate(R.menu.message_list_context_noedit, menu);
        } else {
            MenuInflater inflater = getMenuInflater();
            inflater.inflate(R.menu.message_list_context, menu);
        }
    }

    //localCursor.close();
}","/*
 * Context menu code from:
 * http://stackoverflow.com/questions/6205808/how-to-handle-long-tap-on-listview-item
 */
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) 
{
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.context_menu, menu);
}   ",591,True
"/**
 * Unbind to the service
 */
private void doUnbindService(){
    if ((networkService != null) && (bound == true)) {
        try {
            Message msg = Message.obtain(null, NetworkService.MSG_UNREGISTER_CLIENT);
            msg.replyTo = messenger;
            networkService.send(msg);

            msg = Message.obtain(null, STOP_SERVICE);
            msg.replyTo = messenger;
            networkService.send(msg);

        } catch (RemoteException e) {
            // nothing special to do if the service has already stopped for some reason
        }

        unbindService(networkServiceConnection);
        bound = false;
        log.info(""Unbound to the Fluid Nexus Service"");
    }
}","/**
 * Unbind to the service
 */
private void doUnbindService() 
{
    if (mService != null)
    {
        try
        {
            mContext.unbindService(mService);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}   ",592,False
"/**
 * Method of creating dialogs for this activity
 * @param id ID of the dialog to create
 */
protected Dialog onCreateDialog(int id){
    Dialog dialog;

    switch (id) {
        case DIALOG_SAVE:
            dialog = saveDialog();
            break;
        default:
            dialog = null;
    }

    return dialog;
}","/**
 * Method of creating dialogs for this activity
 * @param id ID of the dialog to create
 */
protected Dialog onCreateDialog(int id) 
{
    switch (id)
    {
        case DIALOG_LOADING:
            return createLoadingDialog();
        case DIALOG_ERROR:
            return createErrorDialog();
        default:
            return super.onCreateDialog(id);
    }
}   ",595,True
"/**
 * Check if the text has changed
 * @return true if it has, false otherwise
 */
private boolean checkIfTextChanged(){
    String title = titleEditText.getText().toString();
    String message = messageEditText.getText().toString();
    boolean checked = checkbox.isChecked();

    if (!(title.equals(originalTitle))) {
        return true;
    }

    if (!(message.equals(originalMessage))) {
        return true;
    }

    if (attachmentPath != originalAttachmentPath) {
        return true;
    }

    if (checked != originalPublic) {
        return true;
    }

    return false;
}","/**
 * Check if the text has changed
 * @return true if it has, false otherwise
 */
private boolean checkIfTextChanged() 
{
    if (textChanged)
    {
        textChanged = false;
        return true;
    }
    return false;
}   ",596,False
"/**
 * Open up a new activity to edit the message
 */
private void editMessage(){

    Intent i = new Intent(this, EditMessage.class);
    i.putExtra(MessagesProviderHelper.KEY_ID, currentRowID);
    startActivityForResult(i, ACTIVITY_EDIT_MESSAGE);

}","/**
 * Open up a new activity to edit the message
 */

private void editMessage() 
{
    Intent intent = new Intent(this, EditMessageActivity.class);
    intent.putExtra(""message"", message);
    startActivityForResult(intent, REQUEST_CODE_EDIT_MESSAGE);
}   ",599,True
"/** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
public boolean isSet(_Fields field){
  switch (field) {
  case SUCCESS:
    return isSetSuccess();
  }
  throw new IllegalStateException();
}","/** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
public boolean isSet(_Fields field) 
{
  if (field == null)
  {
    throw new IllegalArgumentException(""Field for isSet is null!"");
  }

  switch ((ThriftFieldId) field)
  {
    case VALUE:
      return isSetValue();
  }
  throw new IllegalStateException();
}   ",602,True
"/**
 * Find the _Fields constant that matches fieldId, or null if its not found.
 */
public static _Fields findByThriftId(int fieldId){
  switch(fieldId) {
    case 0: // SUCCESS
      return SUCCESS;
    default:
      return null;
  }
}","/**
 * Find the _Fields constant that matches fieldId, or null if its not found.
 */
public static _Fields findByThriftId(int fieldId) 
{
    switch (fieldId)
    {
        case 1:
            return NAME;
        case 2:
            return VALUE;
        default:
            return null;
    }
}   ",606,True
"/**
 * Test that full init, create client, shutdown lifecycle works correctly
 */
@Test
public void testLifecycle() throws IOException, InterruptedException, KeeperException{
  FlumeConfiguration cfg = FlumeConfiguration.get();
  File tmp = FileUtil.mktempdir();
  cfg.set(FlumeConfiguration.MASTER_ZK_SERVERS, ""localhost:2181:3181:4181"");
  cfg.set(FlumeConfiguration.MASTER_ZK_LOGDIR, tmp.getAbsolutePath());
  ZooKeeperService svc = new ZooKeeperService();
  svc.init(cfg);
  
  Assert.assertTrue(""ZooKeeperService did not initialise"", svc.isInitialised());
  
  ZKClient client = svc.createClient();
  client.init();
  Assert.assertTrue(""Expected at least one child of root for ZK service"",
      client.getChildren(""/"", false).size() > 0);   
  
  client.close();    
  svc.shutdown();    
  Assert.assertFalse(""ZooKeeperService did not shut down"", svc.isInitialised());
  
  FileUtil.rmr(tmp);
}","/**
 * Test that full init, create client, shutdown lifecycle works correctly
 */

@Test
public void testLifecycle() throws IOException, InterruptedException, KeeperException 
{
    String connectString = ""127.0.0.1:"" + port;
    int sessionTimeout = 3000;
    ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, dummyWatcher);
    Thread.sleep(500);
    zk.create(""/test"", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    Thread.sleep(500);
    assertNotNull(zk.exists(""/test"", null));
    zk.close();
}   ",607,True
"/** 
 * Simple test to ensure that a RetryHarness actually does retry / fail
 * when the Retryable fails.
 */
@Test
public void testRetryHarness() throws InterruptedException, Exception{
  Retryable retry = new Retryable() {
    int totaltries = 0;
    public boolean doTry() {
      totaltries++;
      if (totaltries < 3) {
        return false;
      }
      totaltries = 0;
      return true;
    }
  };
  
  RetryHarness harness = new RetryHarness(retry, new FixedRetryPolicy(3));
  Assert.assertTrue(harness.attempt());
  harness = new RetryHarness(retry, new FixedRetryPolicy(1));
  Assert.assertFalse(harness.attempt());
}","/** 
 * Simple test to ensure that a RetryHarness actually does retry / fail
 * when the Retryable fails.
 */
@Test
public void testRetryHarness() throws InterruptedException, Exception 
{
    final RetryHarness harness = new RetryHarness();
    final int[] counter = new int[1];
    final Retryable retryable = new Retryable()
    {
        @Override
        public boolean perform()
        {
            counter[0]++;
            return false;
        }

        @Override
        public long sleepTimeMs()
        {
            return 10;
        }
    };

    harness.run(retryable);
    Assert.assertEquals(10, counter[0]);
}   ",614,False
"/**
 * Test the two variants of RetryHarness, one where exceptions are rethrown 
 * after failure, one where they are always masked.  
 */
@Test
public void testException(){
  Exception e = null;
  Retryable retry = new Retryable() {
    public boolean doTry() throws Exception {
      harness.doAbort();
      throw new Exception();
    }
  };
  
  RetryHarness harness = new RetryHarness(retry, new FixedRetryPolicy(3), true);
  try { 
    harness.attempt(); 
  } catch (Exception e1) {
    e = e1;
  }
  Assert.assertNotNull(""Expected exception not thrown!"",e);
  e = null;
  harness = new RetryHarness(retry, new FixedRetryPolicy(3), false);    
  try { 
    harness.attempt(); 
  } catch (Exception e1) {
    e = e1;
  }
  Assert.assertNull(""Unexpected exception thrown!"",e);
}","/**
 * Test the two variants of RetryHarness, one where exceptions are rethrown 
 * after failure, one where they are always masked.  
 */
@Test
public void testException() 
{
    RetryHarness harness = new RetryHarness();
    harness.setExceptionsToRethrow(new Class[] { Exception.class });
    harness.setExceptionsToMask(new Class[] { Exception.class });

    harness.run(new Runnable()
    {
        @Override
        public void run()
        {
            throw new Exception(""test"");
        }
    });
}   ",617,True
"/**
 * Returns a default instance of the command executor
 *
 * @return a default instance of the command executor
 */
public static CommandExecutor createDefaultCommmandExecutor(){
    return new CommandExecutor() {
        /**
         * Instance of a plugin logger.
         */
        private Log logger;

        /**
         * Standard Out
         */
        private StreamConsumer stdOut;

        /**
         * Standard Error
         */
        private ErrorStreamConsumer stdErr;

        /**
         * Process result
         */
        private int result;

        public void setLogger(Log logger) {
            this.logger = logger;
        }

        long pid;

        private Commandline commandline;

        public void executeCommand(String executable, List<String> commands)
                throws ExecutionException {
            executeCommand(executable, commands, null, true);
        }

        public void executeCommand(String executable, List<String> commands, boolean failsOnErrorOutput)
                throws ExecutionException {
            executeCommand(executable, commands, null, failsOnErrorOutput);
        }

        public void executeCommand(String executable, List<String> commands, File workingDirectory,
                                   boolean failsOnErrorOutput)
                throws ExecutionException {
            if (commands == null) {
                commands = new ArrayList<String>();
            }
            stdOut = new StreamConsumerImpl();
            stdErr = new ErrorStreamConsumer();

            commandline = new Commandline();
            commandline.setExecutable(executable);
            commandline.addArguments(commands.toArray(new String[commands.size()]));
            if (workingDirectory != null && workingDirectory.exists()) {
                commandline.setWorkingDirectory(workingDirectory.getAbsolutePath());
            }
            try {
                result = CommandLineUtils.executeCommandLine(commandline, stdOut, stdErr);
                if (logger != null) {
                    logger.debug(""ANDROID-040-000: Executed command: Commandline = "" + commandline +
                            "", Result = "" + result);
                } else {
                    System.out.println(""ANDROID-040-000: Executed command: Commandline = "" + commandline +
                            "", Result = "" + result);
                }
                if ((failsOnErrorOutput && stdErr.hasError()) || result != 0) {
                    throw new ExecutionException(""ANDROID-040-001: Could not execute: Command = "" +
                            commandline.toString() + "", Result = "" + result);
                }
            } catch (CommandLineException e) {
                throw new ExecutionException(
                        ""ANDROID-040-002: Could not execute: Command = "" + commandline.toString() + "", Error message = "" + e.getMessage());
            }
            setPid(commandline.getPid());
        }

        public int getResult() {
            return result;
        }

        public String getStandardOut() {
            return stdOut.toString();
        }

        public String getStandardError() {
            return stdErr.toString();
        }


        public void setPid(long pid) {
            this.pid = pid;
        }

        public long getPid() {
            return pid;
        }

        /**
         * Provides behavior for determining whether the command utility wrote anything to the Standard Error Stream.
         * NOTE: I am using this to decide whether to fail the NMaven build. If the compiler implementation chooses
         * to write warnings to the error stream, then the build will fail on warnings!!!
         */
        class ErrorStreamConsumer
                implements StreamConsumer {

            /**
             * Is true if there was anything consumed from the stream, otherwise false
             */
            private boolean error;

            /**
             * Buffer to store the stream
             */
            private StringBuffer sbe = new StringBuffer();

            public ErrorStreamConsumer() {
                if (logger == null) {
                    System.out.println(""ANDROID-040-003: Error Log not set: Will not output error logs"");
                }
                error = false;
            }

            public void consumeLine(String line) {
                sbe.append(line);
                if (logger != null) {
                    logger.info(line);
                }
                error = true;
            }

            /**
             * Returns false if the command utility wrote to the Standard Error Stream, otherwise returns true.
             *
             * @return false if the command utility wrote to the Standard Error Stream, otherwise returns true.
             */
            public boolean hasError() {
                return error;
            }

            /**
             * Returns the error stream
             *
             * @return error stream
             */
            public String toString() {
                return sbe.toString();
            }
        }

        /**
         * StreamConsumer instance that buffers the entire output
         */
        class StreamConsumerImpl
                implements StreamConsumer {

            private DefaultConsumer consumer;

            private StringBuffer sb = new StringBuffer();

            public StreamConsumerImpl() {
                consumer = new DefaultConsumer();
            }

            public void consumeLine(String line) {
                sb.append(line);
                if (logger != null) {
                    consumer.consumeLine(line);
                }
            }

            /**
             * Returns the stream
             *
             * @return the stream
             */
            public String toString() {
                return sb.toString();
            }
        }
    };

}","/**
 * Returns a default instance of the command executor
 *
 * @return a default instance of the command executor
 */
public static CommandExecutor createDefaultCommmandExecutor() 
{
    return new CommandExecutor()
    {
        @Override
        public void executeCommand(String command)
        {
            System.out.println(""Executing command: "" + command);
        }
    };
}   ",622,False
"/**
 * This is a weak algorithm, if performance is a concern we should address
 * it.
 * 
 * @param location
 * @param max
 * @return Key-Value collection of station to relative metered distances
 */
public Map<Station, Double> findClosestStations(Location location, int max){
	if (location == null)
		location = lastKnownLocation;
	if (location == null || stations == null || stations.isEmpty())
		return new HashMap<Station, Double>(2) {
			private static final long serialVersionUID = 1L;
			{
				put(getStations().get(0), 100.0);
				put(getStations().get(1), 200.0);
			}
		};
	TreeMap<Double, Station> closest = new TreeMap<Double, Station>();
	for (Station s : stations) {
		double dist = Distance.greatCircle(location.getLatitude(), location
				.getLongitude(), s.getLatitude(), s.getLongitude());
		if (closest.size() < max) {
			closest.put(dist, s);
		} else {
			for (Double oldDist : closest.keySet()) {
				if (dist < oldDist) {
					closest.remove(oldDist);
					closest.put(dist, s);
					break;
				}
			}
		}
	}
	Map<Station, Double> inverted = new HashMap<Station, Double>(closest
			.size());
	for (Map.Entry<Double, Station> e : closest.entrySet()) {
		inverted.put(e.getValue(), e.getKey());
	}
	return inverted;
}","/**
 * This is a weak algorithm, if performance is a concern we should address
 * it.
 * 
 * @param location
 * @param max
 * @return Key-Value collection of station to relative metered distances
 */

public Map<Station, Double> findClosestStations(Location location, int max) 
{
    Map<Station, Double> stationDistances = new HashMap<Station, Double>();
    for (Station station : stations)
    {
        double distance = location.distanceTo(station.getLocation());
        stationDistances.put(station, distance);
    }
    return stationDistances;
}   ",623,True
"/**
 * Reads the next line from the buffer and converts to a string array.
 * 
 * @return a string array with each comma-separated element as a separate
 *         entry.
 * 
 * @throws IOException
 *             if bad things happen during the read
 */
public String[] readNext() throws IOException{
	
	String[] result = null;
	do {
		String nextLine = getNextLine();
		if (!hasNext) {
			return result; // should throw if still pending?
		}
		String[] r = parser.parseLineMulti(nextLine);
		if (r.length > 0) {
			if (result == null) {
				result = r;
			} else {
				String[] t = new String[result.length+r.length];
				System.arraycopy(result, 0, t, 0, result.length);
				System.arraycopy(r, 0, t, result.length, r.length);
				result = t;
			}
		}
	} while (parser.isPending());
	return result;
}","/**
 * Reads the next line from the buffer and converts to a string array.
 * 
 * @return a string array with each comma-separated element as a separate
 *         entry.
 * 
 * @throws IOException
 *             if bad things happen during the read
 */
public String[] readNext() throws IOException 
{
    String line = readNextLine();
    if (line == null)
    {
        return null;
    }
    else
    {
        return line.split("","");
    }
}   ",626,True
"/**
 * 
 * @param location
 *            can be null, if so defaults to lastKnownLocation
 * @return
 */
public Map<Station, Double> findClosestStation(Location location){
	Map<Station, Double> s = findClosestStations(location, 1);
	if (s == null || s.isEmpty()) {
		return Collections.<Station, Double> emptyMap();
	}
	return s;
}","/**
 * 
 * @param location
 *            can be null, if so defaults to lastKnownLocation
 * @return
 */


public Map<Station, Double> findClosestStation(Location location) 
{
    if (location == null)
    {
        location = lastKnownLocation;
    }
    Map<Station, Double> distances = new HashMap<Station, Double>();
    for (Station station : stations)
    {
        double distance = location.distanceTo(station.getLocation());
        distances.put(station, distance);
    }
    return distances;
}   ",627,True
"/**
 * Constructs CSVReader with supplied separator and quote char.
 * 
 * @param reader
 *            the reader to an underlying CSV source.
 * @param separator
 *            the delimiter to use for separating entries
 * @param quotechar
 *            the character to use for quoted elements
 * @param escape
 *            the character to use for escaping a separator or quote
 * @param line
 *            the line number to skip for start reading
 * @param strictQuotes
 *            sets if characters outside the quotes are ignored
 * @param ignoreLeadingWhiteSpace
 *            it true, parser should ignore white space before a quote in a field
 */
public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace){
    this.br = new BufferedReader(reader);
    this.parser = new CSVParser(separator, quotechar, escape, strictQuotes, ignoreLeadingWhiteSpace);
    this.skipLines = line;
}","/**
 * Constructs CSVReader with supplied separator and quote char.
 * 
 * @param reader
 *            the reader to an underlying CSV source.
 * @param separator
 *            the delimiter to use for separating entries
 * @param quotechar
 *            the character to use for quoted elements
 * @param escape
 *            the character to use for escaping a separator or quote
 * @param line
 *            the line number to skip for start reading
 * @param strictQuotes
 *            sets if characters outside the quotes are ignored
 * @param ignoreLeadingWhiteSpace
 *            it true, parser should ignore white space before a quote in a field
 */
public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace) 
{
    this.reader = reader;
    this.sep = separator;
    this.quotechar = quotechar;
    this.escape = escape;
    this.line = line;
    this.strictQuotes = strictQuotes;
    this.ignoreLeadingWhiteSpace = ignoreLeadingWhiteSpace;
    this.userProperties = null;
}   ",628,True
"/**
 * Attempts to find the instrumentation test runner from inside the AndroidManifest.xml file.
 *
 * @param androidManifestFile the AndroidManifest.xml file to inspect.
 * @return the instrumentation test runner declared in AndroidManifest.xml, or {@code null} if it is not declared.
 * @throws MojoExecutionException
 */
protected String extractInstrumentationRunnerFromAndroidManifest(File androidManifestFile) throws MojoExecutionException{
    final URL xmlURL;
    try {
        xmlURL = androidManifestFile.toURI().toURL();
    } catch (MalformedURLException e) {
        throw new MojoExecutionException(""Error while trying to figure out instrumentation runner from inside AndroidManifest.xml file "" + androidManifestFile, e);
    }
    final DocumentContainer documentContainer = new DocumentContainer(xmlURL);
    final Object instrumentationRunner;
    try {
        instrumentationRunner = JXPathContext.newContext(documentContainer).getValue(""manifest//instrumentation/@android:name"", String.class);
    } catch (JXPathNotFoundException e) {
        return null;
    }
    return (String) instrumentationRunner;
}","/**
 * Attempts to find the instrumentation test runner from inside the AndroidManifest.xml file.
 *
 * @param androidManifestFile the AndroidManifest.xml file to inspect.
 * @return the instrumentation test runner declared in AndroidManifest.xml, or {@code null} if it is not declared.
 * @throws MojoExecutionException
 */















protected String extractInstrumentationRunnerFromAndroidManifest(File androidManifestFile) throws MojoExecutionException 
{
    try
    {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(androidManifestFile);

        XPathFactory xPathfactory = XPathFactory.newInstance();
        XPath xpath = xPathfactory.newXPath();
        XPathExpression expr = xpath.compile(""/manifest/application/@android:name"");
        String instrumentationRunner = (String) expr.evaluate(doc, XPathConstants.STRING);

        return instrumentationRunner;
    }
    catch (Exception e)
    {
        throw new MojoExecutionException(""Unable to extract instrumentation runner from AndroidManifest.xml"", e);
    }
}   ",629,True
"/**
 * Extracts the package name from an XmlTree dump of AndroidManifest.xml by the <code>aapt</code> tool.
 *
 * @param aaptDumpXmlTree output from <code>aapt dump xmltree &lt;apkFile&gt; AndroidManifest.xml
 * @return the package name from inside the apkFile.
 */
protected String extractPackageNameFromAndroidManifestXmlTree(String aaptDumpXmlTree){
    final Scanner scanner = new Scanner(aaptDumpXmlTree);
    // Finds the root element named ""manifest"".
    scanner.findWithinHorizon(""^E: manifest"", 0);
    // Finds the manifest element's attribute named ""package"".
    scanner.findWithinHorizon(""  A: package=\"""", 0);
    // Extracts the package value including the trailing double quote.
    String packageName = scanner.next("".*?\"""");
    // Removes the double quote.
    packageName = packageName.substring(0, packageName.length() - 1);
    return packageName;
}","/**
 * Extracts the package name from an XmlTree dump of AndroidManifest.xml by the <code>aapt</code> tool.
 *
 * @param aaptDumpXmlTree output from <code>aapt dump xmltree &lt;apkFile&gt; AndroidManifest.xml
 * @return the package name from inside the apkFile.
 */
protected String extractPackageNameFromAndroidManifestXmlTree(String aaptDumpXmlTree) 
{
    String packageName = null;
    String[] lines = aaptDumpXmlTree.split(""\n"");
    for (String line : lines)
    {
        if (line.contains(""package=""))
        {
            packageName = line.split(""package=\"""")[1].split(""\"""")[0];
            break;
        }
    }
    return packageName;
}   ",630,True
"/**
 * @return a {@code Set} of dependencies which may be extracted and otherwise included in other artifacts. Never
 *         {@code null}. This excludes artifacts of the {@code EXCLUDED_DEPENDENCY_SCOPES} scopes.
 */
protected Set<Artifact> getRelevantCompileArtifacts(){
    final List<Artifact> allArtifacts = (List<Artifact>) project.getCompileArtifacts();
    final Set<Artifact> results = filterOutIrrelevantArtifacts(allArtifacts);
    return results;
}","/**
 * @return a {@code Set} of dependencies which may be extracted and otherwise included in other artifacts. Never
 *         {@code null}. This excludes artifacts of the {@code EXCLUDED_DEPENDENCY_SCOPES} scopes.
 */

protected Set<Artifact> getRelevantCompileArtifacts() 
{
    Set<Artifact> artifacts = new HashSet<>();
    for (Artifact artifact : project.getArtifacts())
    {
        if (isRelevantCompileArtifact(artifact))
        {
            artifacts.add(artifact);
        }
    }
    return artifacts;
}   ",631,True
"/** Return at most 2 trips for a station. North | South bound */
public ArrayList<Trip> getTrips(Integer stationId){
	long before = System.currentTimeMillis();
	if (stationId == null) {
		return new ArrayList<Trip>() {
			private static final long serialVersionUID = 1L;
			{
				add(new Trip(1, 1, ""343 River Line Camden"", 0, ""175B43003"",
						1));
				add(new Trip(1, 1, ""343 River Line Trenton"", 1,
						""175B43001"", 1));
			}
		};
	}
	db.beginTransaction();
	Cursor cursor = db
			.rawQuery(
					""select trips.id, trips.service_id, trips.route_id, trips.headsign, trips.direction, trips.block_id from stop_times join trips where ? = stop_times.stop_id AND stop_times.trip_id=trips.id group by trips.direction"",
					new String[] { stationId.toString() });
	int count = cursor.getCount();
	ArrayList<Trip> trips = new ArrayList<Trip>(Math.max(0, count));
	cursor.moveToFirst();
	for (int i = 0; i < cursor.getCount(); i++) {
		trips
				.add(new Trip(cursor.getInt(0), cursor.getInt(1), cursor
						.getString(3), cursor.getInt(4), cursor
						.getString(5), null));
		cursor.moveToNext();
	}
	cursor.close();
	db.endTransaction();

	Log.d(""DatabaseAdapter"", String.format(""getTrips (%s ms)"", (System
			.currentTimeMillis() - before)));

	return trips;
}","/** Return at most 2 trips for a station. North | South bound */
public ArrayList<Trip> getTrips(Integer stationId) 
{
    ArrayList<Trip> trips = new ArrayList<Trip>();
    for(Trip trip : this.trips)
    {
        if(trip.getStationId() == stationId && trips.size() < 2)
        {
            trips.add(trip);
        }
    }
    return trips;
}   ",633,False
"/**
 * Undeploys an apk, specified by package name, from a connected emulator or usb device.
 *
 * @param packageName the package name to undeploy.
 * @param deleteDataAndCacheDirectoriesOnDevice
 *                    <code>true</code> to delete the application's data and cache
 *                    directories on the device, <code>false</code> to keep them.
 * @return <code>true</code> if successfully undeployed, <code>false</code> otherwise.
 */
protected boolean undeployApk(String packageName, boolean deleteDataAndCacheDirectoriesOnDevice) throws MojoExecutionException{
    CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();
    executor.setLogger(this.getLog());
    List<String> commands = new ArrayList<String>();
    addDeviceParameter(commands);
    commands.add(""uninstall"");
    if (!deleteDataAndCacheDirectoriesOnDevice) {
        commands.add(""-k"");  // ('-k' means keep the data and cache directories)
    }
    commands.add(packageName);
    getLog().info(getAndroidSdk().getAdbPath() + "" "" + commands.toString());
    try {
        executor.executeCommand(getAndroidSdk().getAdbPath(), commands, false);
        getLog().debug(executor.getStandardOut());
        getLog().debug(executor.getStandardError());
        return true;
    } catch (ExecutionException e) {
        getLog().error(executor.getStandardOut());
        getLog().error(executor.getStandardError());
        return false;
    }
}","/**
 * Undeploys an apk, specified by package name, from a connected emulator or usb device.
 *
 * @param packageName the package name to undeploy.
 * @param deleteDataAndCacheDirectoriesOnDevice
 *                    <code>true</code> to delete the application's data and cache
 *                    directories on the device, <code>false</code> to keep them.
 * @return <code>true</code> if successfully undeployed, <code>false</code> otherwise.
 */
protected boolean undeployApk(String packageName, boolean deleteDataAndCacheDirectoriesOnDevice) throws MojoExecutionException 
{
    try
    {
        String command = ""pm uninstall "" + packageName;
        if (deleteDataAndCacheDirectoriesOnDevice)
        {
            command += "" -d"";
        }
        return executeCommand(command);
    }
    catch (Exception e)
    {
        throw new MojoExecutionException(""Undeploying apk failed"", e);
    }
}   ",636,False
"/**
 * Checks if a specific device should be used, and adds any relevant parameter(s) to the parameters list.
 *
 * @param commands the parameters to be used with the {@code adb} command
 */
protected void addDeviceParameter(List<String> commands){
    if (StringUtils.isNotBlank(device)) {
        if (""usb"".equals(device)) {
            commands.add(""-d"");
        } else if (""emulator"".equals(device)) {
            commands.add(""-e"");
        } else {
            commands.add(""-s"");
            commands.add(device);
        }
    }
}","/**
 * Checks if a specific device should be used, and adds any relevant parameter(s) to the parameters list.
 *
 * @param commands the parameters to be used with the {@code adb} command
 */
protected void addDeviceParameter(List<String> commands) 
{
    if (device != null)
    {
        commands.add(""-s"");
        commands.add(device);
    }
}   ",638,True
"//	/**
//	 * A map of buffers for messages that are in flight, not yet completely read.
//	 */
//	protected Map<SocketChannel, IncompleteMessage> incompleteBuffer = new HashMap<SocketChannel, IncompleteMessage>();
public BitcoinReactorNetwork(int port) throws IOException{
	this.port = port;
	this.init();
}","//	/**
//	 * A map of buffers for messages that are in flight, not yet completely read.
//	 */
//	protected Map<SocketChannel, IncompleteMessage> incompleteBuffer = new HashMap<SocketChannel, IncompleteMessage>();



public BitcoinReactorNetwork(int port) throws IOException 
{
	this.port = port;
	selector = Selector.open();
	serverSocketChannel = ServerSocketChannel.open();
	serverSocketChannel.socket().bind(new InetSocketAddress(port));
	serverSocketChannel.configureBlocking(false);
	serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
}   ",641,True
"/* (non-Javadoc)
 * @see net.bitdroid.network.BitcoinNetwork#broadcast(net.bitdroid.network.messages.Message)
 */
@Override
public void broadcast(Message message, Object exclude){
	for(BitcoinReactorPeerInfo peer : peers.values()){
		if(peer == exclude)
			continue;
		try {
			this.sendMessage(peer, message);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}","/* (non-Javadoc)
 * @see net.bitdroid.network.BitcoinNetwork#broadcast(net.bitdroid.network.messages.Message)
 */
@Override
public void broadcast(Message message, Object exclude) 
{
    for (Peer peer : peers)
    {
        if (peer != exclude)
            peer.send(message);
    }
}   ",642,True
"/**
 * Enqueue a new task to be run by the reactor.
 * @param task
 */
public void queueTask(DeferredTask task){
	taskQueue.add(task);
	// If we scheduled a new next task we have to artificially wake up the
	// selector
	if(taskQueue.peek() == null ||
			task.getDelay(TimeUnit.MILLISECONDS) < taskQueue.peek().getDelay(TimeUnit.MILLISECONDS))
		this.selector.wakeup();
}","/**
 * Enqueue a new task to be run by the reactor.
 * @param task
 */
public void queueTask(DeferredTask task) 
{
    synchronized (tasks)
    {
        tasks.add(task);
        tasks.notifyAll();
    }
}   ",643,False
"/**
 * Calculate the 4 byte checksum of the message content.
 *
 * @param content to be hashed
 * @return 4 byte array with the checksum
 * @throws RuntimeException if we cannot continue (due to missing hash functions)
 */
public final byte[] calculateChecksum(byte[] b) throws RuntimeException{
	byte[] res = new byte[4];
	if(hasher == null){
		try {
			hasher = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
			throw new RuntimeException(""Cannot continue without a SHA-256 implementation."", e);
		}
	}
	hasher.reset();
	byte[] o = hasher.digest(b);
	hasher.reset();
	o = hasher.digest(o);
	for(int i=0; i<4; i++)
		res[i] = o[i];
	return res;
}","/**
 * Calculate the 4 byte checksum of the message content.
 *
 * @param content to be hashed
 * @return 4 byte array with the checksum
 * @throws RuntimeException if we cannot continue (due to missing hash functions)
 */


public final byte[] calculateChecksum(byte[] b) throws RuntimeException 
{
    try
    {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        md.update(b);
        return md.digest();
    }
    catch (NoSuchAlgorithmException e)
    {
        throw new RuntimeException(""MD5 algorithm should be available!"", e);
    }
}   ",644,True
"/* (non-Javadoc)
 * @see net.bitdroid.network.Event#toString()
 */
@Override
public String toString(){
	StringBuilder sb = new StringBuilder(""Transaction[hash="");
	try {
		sb.append(StringUtils.getHexString(this.getHash()));
	} catch (Exception e) {
	}
	sb.append(""]"");
	return sb.toString();
}","/* (non-Javadoc)
 * @see net.bitdroid.network.Event#toString()
 */
@Override
public String toString() 
{
	StringBuilder builder = new StringBuilder();
	builder.append(""Message [type="");
	builder.append(type);
	builder.append("", payload="");
	builder.append(payload);
	builder.append(""]"");
	return builder.toString();
}   ",646,False
"/**
 * This method creates an instance of the message type according to the
 * given <em>command</em>. The <em>command</em> is the String in the
 * protocol identifying the type of the message.
 *
 * @param command protocol level identity of the message type.
 * @return an instance of Message according to the type in the protocol.
 */
protected final Message createMessage(String command){
	Message message;
	if(""version"".equalsIgnoreCase(command)){
		message = new VersionMessage();

	}else if(""verack"".equalsIgnoreCase(command)){
		message = new VerackMessage();

	}else if(""inv"".equalsIgnoreCase(command)){
		message = new InventoryMessage();

	}else if(""addr"".equalsIgnoreCase(command)){
		message = new AddrMessage();

	}else if(""tx"".equalsIgnoreCase(command)){
		message = new Transaction();

	}else if(""getdata"".equalsIgnoreCase(command)){
		message = new GetDataMessage();

	}else if(""getaddr"".equalsIgnoreCase(command)){
		message = new GetAddrMessage();

	}else if(""block"".equalsIgnoreCase(command)){
		message = new BlockMessage();

	}else{
		message = new UnknownMessage();
		((UnknownMessage)message).setCommand(command);
	}

	return message;
}","/**
 * This method creates an instance of the message type according to the
 * given <em>command</em>. The <em>command</em> is the String in the
 * protocol identifying the type of the message.
 *
 * @param command protocol level identity of the message type.
 * @return an instance of Message according to the type in the protocol.
 */
protected final Message createMessage(String command) 
{
    Message message = null;
    if (command.equals(""JOIN""))
    {
        message = new JoinMessage();
    }
    else if (command.equals(""LEAVE""))
    {
        message = new LeaveMessage();
    }
    else if (command.equals(""NOTE""))
    {
        message = new NoteMessage();
    }
    else if (command.equals(""PING""))
    {
        message = new PingMessage();
    }
    else if (command.equals(""PONG""))
    {
        message = new PongMessage();
    }
    else if (command.equals(""QUERY""))
    {
        message = new QueryMessage();
    }
    else if (command.equals(""QUIT""))
    {
        message = new QuitMessage();
    }
    else
    {
        message = new UnknownMessage(command);
    }
    return message;
}   ",650,False
"/* (non-Javadoc)
 * @see java.lang.Object#toString()
 */
@Override
public String toString(){
	StringBuilder sb = new StringBuilder(address.getHostAddress());
	sb.append("":"").append(port).append(""[Services="").append(services).append(""]"");
	return sb.toString();
}","/* (non-Javadoc)
 * @see java.lang.Object#toString()
 */
@Override
public String toString() 
{
    return ""User [id="" + id + "", username="" + username + "", password="" + password + "", enabled="" + enabled + "", role=""
            + role + ""]"";
}   ",651,False
"/**
 * Publish events to all registered listeners.
 *
 * @param e
 */
protected final void publishSentEvent(Event e){
	log.debug(""Publishing sent message {}"", e);
	for(BitcoinEventListener listener : eventListeners)
		try{
			listener.messageSent(e);
		}catch(Exception ex){
			log.error(""Possible error in a listener publishing outgoing event."", ex);
		}
}","/**
 * Publish events to all registered listeners.
 *
 * @param e
 */
protected final void publishSentEvent(Event e) 
{
    if (listeners != null)
    {
        for (EventListener l : listeners)
        {
            l.sentEvent(e);
        }
    }
}   ",653,True
"/**
 * Execute tasks that are due now. It returns the time the selector is
 * allowed to sleep until the next task is due.
 *
 * @return milliseconds until the next scheduled task.
 */
protected long executeTasks(){
	// So now we execute scheduled tasks
	while(taskQueue.peek() != null &&
			taskQueue.peek().getDelay(TimeUnit.MILLISECONDS) <= 0){
		DeferredTask task = taskQueue.poll();
		try{
			task.execute();
		}catch(Throwable t){
			log.error(""Error while executing deferred task"", t);
		}
		if(task instanceof RepeatingDeferredTask){
			((RepeatingDeferredTask) task).reschedule();
			this.queueTask(task);
		}
	}
	if(taskQueue.peek() == null)
		return 0;
	else
		return taskQueue.peek().getDelay(TimeUnit.MILLISECONDS);
}","/**
 * Execute tasks that are due now. It returns the time the selector is
 * allowed to sleep until the next task is due.
 *
 * @return milliseconds until the next scheduled task.
 */
protected long executeTasks() 
{
    long sleepTime = Long.MAX_VALUE;
    for (Task task : tasks)
    {
        long taskSleepTime = task.execute();
        if (taskSleepTime < sleepTime)
        {
            sleepTime = taskSleepTime;
        }
    }
    return sleepTime;
}   ",654,True
"/**
 * Plots average item rating for MovieLens dataset.
 */
public static void plotAverageItemRating(){
    Dataset ds = getMovieLensData();
    Collection<Item> items = ds.getItems();
    double[] x = new double[items.size()];
    double[] y = new double[items.size()];
    int i = 0;
    for(Item item : items) {
        x[i] = item.getId();
        y[i] = item.getAverageRating();
        i++;
    }
    
    XyGui gui = new XyGui(ds.getName(), x, y);
    gui.plot();
}","/**
 * Plots average item rating for MovieLens dataset.
 */


public static void plotAverageItemRating() 
{
    // Get the average item rating
    double avgItemRating = getAverageItemRating();

    // Create a new dataset for the plot
    DefaultPieDataset dataset = new DefaultPieDataset();
    dataset.setValue(""Average Item Rating"", avgItemRating);

    // Create the plot
    JFreeChart chart = ChartFactory.createPieChart(
            ""Average Item Rating"",
            dataset,
            true,
            true,
            false
    );

    // Display the plot
    ChartFrame frame = new ChartFrame(""Average Item Rating"", chart);
    frame.pack();
    frame.setVisible(true);
}   ",661,True
"/*
 * Creates: 2 -> 3 -> 1 network. 
 */
public void create(){
    
    
    // 1. Define Layers, Nodes and Node Biases
    Layer inputLayer = createInputLayer(
            0, // layer id 
            2  // number of nodes 
            );

    Layer hiddenLayer = createHiddenLayer(
            1, // layer id 
            3, // number of nodes
            new double[] {1, 1.5, 1} // node biases
            );
    
    Layer outputLayer = createOutputLayer(
            2, // layer id 
            1, // number of nodes 
            new double[] {1.5} // node biases
            );        
    
    
    setInputLayer(inputLayer);
    setOutputLayer(outputLayer);
    addHiddenLayer(hiddenLayer);

    // 2. Define links and weights between nodes
    // Id format: <layerId:nodeIdwithinLayer>
    setLink(""0:0"", ""1:0"", 0.25);
    setLink(""0:0"", ""1:1"", -0.5);
    setLink(""0:0"", ""1:2"", 0.25);
    
    setLink(""0:1"", ""1:0"", 0.25);
    setLink(""0:1"", ""1:1"", -0.5);
    setLink(""0:1"", ""1:2"", 0.25);
            
    setLink(""1:0"", ""2:0"", -0.5);
    setLink(""1:1"", ""2:0"", 0.5);
    setLink(""1:2"", ""2:0"", -0.5);
    
    System.out.println(""NN created"");
    
}","/*
 * Creates: 2 -> 3 -> 1 network. 
 */
public void create() 
{
  // Create nodes.
  Node node1 = new Node();
  Node node2 = new Node();
  Node node3 = new Node();

  // Create links.
  Link link1 = new Link(node1, node2);
  Link link2 = new Link(node2, node3);

  // Add links to nodes.
  node1.addLink(link1);
  node2.addLink(link1);
  node2.addLink(link2);
  node3.addLink(link2);

  // Add nodes to network.
  network.addNode(node1);
  network.addNode(node2);
  network.addNode(node3);
}   ",662,False
"/**
 * Plots average user rating for MovieLens dataset.
 */
public static void plotAverageUserRating(){
    Dataset ds = getMovieLensData();
    Collection<User> users = ds.getUsers();
    double[] x = new double[users.size()];
    double[] y = new double[users.size()];
    int i = 0;
    for(User user : users) {
        x[i] = user.getId();
        y[i] = user.getAverageRating();
        i++;
    }
    
    XyGui gui = new XyGui(ds.getName(), x, y);
    gui.plot();
}","/**
 * Plots average user rating for MovieLens dataset.
 */
public static void plotAverageUserRating() 
{
    // Get the average rating for each user
    Map<Integer, Double> userRatings = getUserRatings();

    // Create a histogram of user ratings
    Histogram histogram = new Histogram(""User Ratings"", ""Rating"", ""Count"");
    for (double rating : userRatings.values())
    {
        histogram.addDataPoint(rating);
    }

    // Plot the histogram
    histogram.plot();
}   ",663,True
"/**
 * Save data into csv file.
 * 
 * @param filename
 */
public static void saveData(String filename){
    String[] data = new String[CSV_ITEM_HEADERS.length];
    
    CsvListWriter csvWriter = null;
    try {
      csvWriter = new CsvListWriter(
              new BufferedWriter(new FileWriter(filename)), 
              CsvPreference.EXCEL_PREFERENCE);
      
      csvWriter.writeHeader(CSV_ITEM_HEADERS);

      for(DiggStoryItem item : allStories) {
          try {
              data[0] = String.valueOf(item.getId());
              data[1] = item.getUsername();
              data[2] = item.getTitle();
              data[3] = item.getCategory();
              data[4] = item.getTopic();
              data[5] = item.getDescription();
              data[6] = item.getLink();
              DiggUser user = findUserByUsername(item.getUsername());
              data[7] = String.valueOf(user.getId()); 
              csvWriter.write(data);
          }
          catch(Exception e) {
              throw new RuntimeException(""Error while writing item "" + item.getName() + "": "", e);
          }
      }
    } 
    catch(IOException e) {
        throw new RuntimeException(""Error while writing digg items into csv file."", e);
    }
    finally {
      try {
          if( csvWriter != null ) {
              csvWriter.close();
          }
      }
      catch(IOException e) {
          e.printStackTrace();
      }
    }
    
    System.out.println(""Saved data into file: "" + filename);
    System.out.println(""saved "" + allUsers.size() + "" users."");
    System.out.println(""saved "" + allStories.size() + "" stories (items)."");
    
}","/**
 * Save data into csv file.
 * 
 * @param filename
 */




public static void saveData(String filename) 
{
    try
    {
        FileWriter writer = new FileWriter(filename);
        for (int i = 0; i < data.size(); i++)
        {
            writer.append(data.get(i).toString());
            writer.append('\n');
        }
        writer.flush();
        writer.close();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",665,True
"/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#addHiddenLayer(iweb2.ch5.classification.nn.intf.Layer)
	 */
public void addHiddenLayer(Layer hiddenLayer){
    hiddenLayers.add(hiddenLayer);
    for(Node node : hiddenLayer.getNodes()) {
        addNode(node);
    }
}","/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#addHiddenLayer(iweb2.ch5.classification.nn.intf.Layer)
	 */

public void addHiddenLayer(Layer hiddenLayer) 
{
	if (hiddenLayers == null) {
		hiddenLayers = new ArrayList<Layer>();
	}
	hiddenLayers.add(hiddenLayer);
}	",667,True
"/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createOutputLayer(int, int, double[])
	 */
public Layer createOutputLayer(int layerId, int nNodes, double[] bias){
    if( bias.length != nNodes ) {
        throw new RuntimeException(""Each node should have bias defined."");
    }
    
    BaseLayer baseLayer = new BaseLayer(layerId);
    for(int i = 0; i < nNodes; i++) {
        Node node = createOutputNode(layerId + "":"" + i);
        node.setBias(bias[i]);
        baseLayer.addNode(node);
    }
    return baseLayer;
}","/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createOutputLayer(int, int, double[])
	 */
public Layer createOutputLayer(int layerId, int nNodes, double[] bias) 
{
	Layer layer = new Layer(layerId, LayerType.OUTPUT);

	for (int i = 0; i < nNodes; i++)
	{
		Neuron neuron = new Neuron();
		neuron.init(bias[i]);
		layer.addNeuron(neuron);
	}

	return layer;
}	",668,True
"/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#setInputLayer(iweb2.ch5.classification.nn.intf.Layer)
	 */
public void setInputLayer(Layer inputLayer){
    this.inputLayer = inputLayer;
    for(Node node : this.inputLayer.getNodes()) {
        addNode(node);
    }
}","/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#setInputLayer(iweb2.ch5.classification.nn.intf.Layer)
	 */
public void setInputLayer(Layer inputLayer) 
{
	if (this.inputLayer != null)
	{
		throw new IllegalStateException(""Input layer already set"");
	}

	this.inputLayer = inputLayer;
	this.inputLayer.setNetwork(this);
}	",669,True
"/**
 * Builds data set with all the users where each user rates 80% of all 
 * the songs. User ratings created randomly with bias: 
 * <ul>
 * <li>Users whose name starts from A to D will have ratings between 3 and 5.</li>
 * <li>Users whose name starts from E to Z will have ratings between 1 and 3.</li>
 * </ul>
 */
public static BaseDataset createDataset(){
    BaseDataset ds = new BaseDataset();

    double percentOfAllSongs = 0.80;

    /* Create items first */
    MusicItem[] allItems = loadAllMusicItems(); 
    
    for(int i = 0, n = USERS.length; i < n; i++) {
        int userId = i;
        String userName = USERS[i];
        int lowRating = 1;
        int highRating = 5;
        
        if( userName.toLowerCase().charAt(0) <= 'd') {
            // range of ratings for users whose name starts from A to D
            lowRating = 4;
            highRating = 5;
        }
        else {
            // range of ratings for users whose name starts from E to Z 
            lowRating = 1;
            highRating = 3;
        }
        MusicItem[] items = pickRandomSongs(allItems, percentOfAllSongs);

        RatingBuilder ratingBuider = new RatingBuilder();         
        List<Rating> ratings = ratingBuider.createBiasedRatings(
                userId, items, lowRating, highRating);

        MusicUser mu = new MusicUser(userId, userName, ratings);
        
        ds.add(mu);
    }
    return ds;
}","/**
 * Builds data set with all the users where each user rates 80% of all 
 * the songs. User ratings created randomly with bias: 
 * <ul>
 * <li>Users whose name starts from A to D will have ratings between 3 and 5.</li>
 * <li>Users whose name starts from E to Z will have ratings between 1 and 3.</li>
 * </ul>
 */
public static BaseDataset createDataset() 
{
    BaseDataset dataset = new BaseDataset();

    for (String name : USER_NAMES) {
        User user = new User(name);
        for (Song song : SONGS) {
            int rating = 0;
            if (name.charAt(0) >= 'A' && name.charAt(0) <= 'D') {
                rating = (int) (Math.random() * 3) + 3;
            } else {
                rating = (int) (Math.random() * 3) + 1;
            }
            user.addRating(song, rating);
        }
        dataset.addUser(user);
    }

    return dataset;
}   ",670,False
"/**
 * Returns a random selection of songs.
 *
 * @param songs list of songs to pick from
 * @param percentOfAllSongs determines size of returned selection.
 * 
 * @return array of songs.
 */
private static MusicItem[] pickRandomSongs(MusicItem[] songs, double percentOfAllSongs){
    
    if( percentOfAllSongs < 0.0 || percentOfAllSongs > 1.0 ) {
        throw new IllegalArgumentException(
                ""Value for 'percentOfAllSongs' argument should be between 0 and 1."");
    }
    Random rand = new Random();
    int sampleSize = (int)Math.round(percentOfAllSongs * songs.length);
    Map<Integer, MusicItem> pickedItems = new HashMap<Integer, MusicItem>();
    while( pickedItems.size() < sampleSize ) {
        int songId = rand.nextInt(songs.length);
        MusicItem song = songs[songId];
        if( !pickedItems.containsKey(song.getId())) {
            pickedItems.put(song.getId(), song);
        }
    }
    
    return pickedItems.values().toArray(new MusicItem[pickedItems.size()]);
}","/**
 * Returns a random selection of songs.
 *
 * @param songs list of songs to pick from
 * @param percentOfAllSongs determines size of returned selection.
 * 
 * @return array of songs.
 */
private static MusicItem[] pickRandomSongs(MusicItem[] songs, double percentOfAllSongs) 
{
    int size = (int) (songs.length * percentOfAllSongs);
    MusicItem[] randomSongs = new MusicItem[size];
    Random random = new Random();

    for (int i = 0; i < size; i++)
    {
        int randomIndex = random.nextInt(songs.length);
        randomSongs[i] = songs[randomIndex];
    }

    return randomSongs;
}   ",672,True
"/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createHiddenLayer(int, int, double[])
	 */
public Layer createHiddenLayer(int layerId, int nNodes, double[] bias){
    if( bias.length != nNodes ) {
        throw new RuntimeException(""Each node should have bias defined."");
    }
    BaseLayer baseLayer = new BaseLayer(layerId);
    for(int i = 0; i < nNodes; i++) {
        Node node = createHiddenNode(layerId + "":"" + i);
        node.setBias(bias[i]);
        baseLayer.addNode(node);
    }
    return baseLayer;
}","/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createHiddenLayer(int, int, double[])
	 */
public Layer createHiddenLayer(int layerId, int nNodes, double[] bias) 
{
	Layer layer = new Layer(layerId, nNodes, bias);
	for (int i = 0; i < nNodes; i++) {
		layer.addNode(new Node(layerId, i));
	}
	return layer;
}	",673,True
"/**
 * Removes attribute definition with specified name from the list.
 * 
 * @param attrName attribute name to remove.
 * @param attributes list to remove from.
 */
public static void removeAttributeDef(String attrName, 
        List<AttributeDefinition> attributes){

    if( attrName != null ) {
        for(int i = 0, n = attributes.size(); i < n; i++ ) {
            AttributeDefinition a = attributes.get(i);
            if( attrName.equalsIgnoreCase(a.getName()) ) {
                attributes.remove(i);
                break;
            }
        }
    }
}","/**
 * Removes attribute definition with specified name from the list.
 * 
 * @param attrName attribute name to remove.
 * @param attributes list to remove from.
 */
public static void removeAttributeDef(String attrName, 
        List<AttributeDefinition> attributes) 
{
    Iterator<AttributeDefinition> iter = attributes.iterator();
    while (iter.hasNext())
    {
        AttributeDefinition attr = iter.next();
        if (attr.getName().equals(attrName))
        {
            iter.remove();
            return;
        }
    }
}       ",675,True
"// trains NN with one training sample at a time
/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#train(double[], double[])
	 */
public void train(double[] tX, double[] tY){

	double lastError = 0.0;
    int i = 0;
    while( true ) {
        i++;
        // Evaluate sample
        double[] y = classify(tX);
        
        double err = error(tY, y);

        if( Double.isInfinite(err) || Double.isNaN(err) ) {
            // Couldn't even evaluate the error. Stop.
            throw new RuntimeException( 
                ""Training failed. Couldn't evaluate the error: "" + err + 
                "". Try some other NN configuration, parameters."");
        }
        
        double convergence = Math.abs(err - lastError);
        
        if(err <= ERROR_THRESHOLD ) {
            // Good enough. No need to adjust weights for this sample.
            lastError = err;
				if (verbose) {
	                System.out.print(""Error Threshold: "" + ERROR_THRESHOLD);
	                System.out.print("" |  Error Achieved: "" + err);
	                System.out.print("" |  Number of Iterations: "" + i);
	            	System.out.println("" |  Absolute convergence: "" + convergence);
            }
            break;
        }
        
        if( convergence <= CONVERGENCE_THRESHOLD ) { // If we made almost no progress stop.
            // No change. Stop.
        	if (verbose) {
	            System.out.print(""Error Threshold: "" + ERROR_THRESHOLD);
	            System.out.print("" |  Error Achieved: "" + err);
	            System.out.print("" |  Number of Iterations: "" + i);
	            System.out.println("" |  Absolute convergence: "" + convergence);
        	}
            break;
        }

        lastError = err;
        
        // Set expected values so that we can determine the error
        outputLayer.setExpectedOutputValues(tY);
        

        /*
         * Calculate weight adjustments in the whole network
         */
       
        outputLayer.calculateWeightAdjustments();
        
        for(Layer hLayer : hiddenLayers) { 
            // layer order doesn't matter because we will update weights later
            hLayer.calculateWeightAdjustments(); // WeightIncrements
        }

        /*
         * Update Weights
         */
        
        outputLayer.updateWeights();
        
        for(Layer hLayer : hiddenLayers) { 
            // layer order doesn't matter.
            hLayer.updateWeights();
        }
    }
    //System.out.println(""i = "" + i + "", err = "" + lastError);
}","// trains NN with one training sample at a time
/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#train(double[], double[])
	 */
public void train(double[] tX, double[] tY) 
{
	double[] o = new double[1];
	double[] h = new double[hiddenLayerSize];

	// forward pass
	forwardPass(tX, h, o);

	// compute error
	double error = tY[0] - o[0];

	// backward pass
	backwardPass(tX, h, o, error);
}	",676,False
"/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createInputLayer(int, int)
	 */
public Layer createInputLayer(int layerId, int nNodes){
    
    BaseLayer baseLayer = new BaseLayer(layerId);
    for(int i = 0; i < nNodes; i++) {
        Node node = createInputNode(layerId + "":"" + i);
        Link inlink = new BaseLink();
        inlink.setFromNode(node);
        inlink.setWeight(1.0);
        node.addInlink(inlink);
        baseLayer.addNode(node);
    }
    
    return baseLayer;
}","/* (non-Javadoc)
	 * @see iweb2.ch5.classification.nn.NeuralNetwork#createInputLayer(int, int)
	 */
public Layer createInputLayer(int layerId, int nNodes) 
{
	Layer layer = new InputLayer(layerId, nNodes);
	layers.add(layer);
	return layer;
}	",678,True
"/**
 * Returns array of new MusicItem instances for every songs listed in 
 * <code>MUSIC_SAMPLES</code> array.
 */
private static MusicItem[] loadAllMusicItems(){
    MusicItem[] allItems = new MusicItem[MusicData.MUSIC_SAMPLES.length];
    for(int i = 0, n = allItems.length; i < n; i++) {
        int id = i;
        String name = MusicData.MUSIC_SAMPLES[i];
        MusicItem item = new MusicItem(id, name);
        allItems[i] = item;
    }
    return allItems;
}","/**
 * Returns array of new MusicItem instances for every songs listed in 
 * <code>MUSIC_SAMPLES</code> array.
 */
private static MusicItem[] loadAllMusicItems() 
{
    MusicItem[] musicItems = new MusicItem[MUSIC_SAMPLES.length];
    for (int i = 0; i < MUSIC_SAMPLES.length; i++)
    {
        musicItems[i] = new MusicItem(MUSIC_SAMPLES[i]);
    }
    return musicItems;
}   ",679,True
"/**
 * shutdown
 *
 * cleanly closes everything and exit.
 */
public void shutdown(int status){
  LOG.info(""HadoopThriftServer shutting down."");
  try {
    fs.close();
  } catch (IOException e) {
    LOG.warn(""Unable to close file system"");
  }
  Runtime.getRuntime().exit(status);
}","/**
 * shutdown
 *
 * cleanly closes everything and exit.
 */
public void shutdown(int status) 
{
    try
    {
        if (server != null)
        {
            server.stop();
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }

    System.exit(status);
}   ",680,False
"/**
 * Sets the replication factor of a file
 */
public void setReplication(Pathname path, short repl) throws ThriftIOException{
  try {
    now = now();
    HadoopThriftHandler.LOG.debug(""setrepl: "" + path +
                                 "" replication factor: "" + repl);
    fs.setReplication(new Path(path.pathname), repl);
    HadoopThriftHandler.LOG.debug(""setrepl done: "" + path);
  } catch (IOException e) {
    throw new ThriftIOException(e.getMessage());
  }

}","/**
 * Sets the replication factor of a file
 */

public void setReplication(Pathname path, short repl) throws ThriftIOException 
{
    try
    {
        client.setReplication(path, repl);
    }
    catch (TException e)
    {
        throw new ThriftIOException(e);
    }
}   ",686,True
"/**
 * Sets the owner & group of a pathname
 */
public void chown(Pathname path, String owner, String group) 
                                                   throws ThriftIOException{
  try {
    now = now();
    HadoopThriftHandler.LOG.debug(""chown: "" + path +
                                 "" owner: "" + owner +
                                 "" group: "" + group);
    fs.setOwner(new Path(path.pathname), owner, group);
    HadoopThriftHandler.LOG.debug(""chown done: "" + path);
  } catch (IOException e) {
    throw new ThriftIOException(e.getMessage());
  }
}","/**
 * Sets the owner & group of a pathname
 */
public void chown(Pathname path, String owner, String group) 
                                                   throws ThriftIOException 
{
    try
    {
        client.chown(path.toString(), owner, group);
    }
    catch (TException e)
    {
        throw new ThriftIOException(e);
    }
}   ",688,True
"/** Set inactivity timeout period. The period is specified in seconds.
  * if there are no RPC calls to the HadoopThrift server for this much
  * time, then the server kills itself.
  */
public synchronized void setInactivityTimeoutPeriod(long periodInSeconds){
  inactivityPeriod = periodInSeconds * 1000; // in milli seconds
  if (inactivityRecheckInterval > inactivityPeriod ) {
    inactivityRecheckInterval = inactivityPeriod;
  }
}","/** Set inactivity timeout period. The period is specified in seconds.
  * if there are no RPC calls to the HadoopThrift server for this much
  * time, then the server kills itself.
  */
public synchronized void setInactivityTimeoutPeriod(long periodInSeconds) 
{
    this.inactivityTimeoutPeriod = periodInSeconds;
} ",689,True
"/**
 * HadoopThriftServer
 *
 * Constructor for the HadoopThriftServer glue with Thrift Class.
 *
 * @param name - the name of this handler
 */
public HadoopThriftHandler(String name){
  conf = new Configuration();
  now = now();
  try {
    inactivityThread = new Daemon(new InactivityMonitor());
    fs = FileSystem.get(conf);
  } catch (IOException e) {
    LOG.warn(""Unable to open hadoop file system..."");
    Runtime.getRuntime().exit(-1);
  }
}","/**
 * HadoopThriftServer
 *
 * Constructor for the HadoopThriftServer glue with Thrift Class.
 *
 * @param name - the name of this handler
 */
public HadoopThriftHandler(String name) 
{
    super(name);
    this.handler = new HadoopThriftServer();
}   ",691,True
"/**
 * Create a directory
 */
public boolean mkdirs(Pathname path) throws ThriftIOException{
 try {
   now = now();
   HadoopThriftHandler.LOG.debug(""mkdirs: "" + path);
   boolean ret = fs.mkdirs(new Path(path.pathname));
   HadoopThriftHandler.LOG.debug(""mkdirs: "" + path);
   return ret;
 } catch (IOException e) {
   throw new ThriftIOException(e.getMessage());
 }
    }","/**
 * Create a directory
 */

public boolean mkdirs(Pathname path) throws ThriftIOException 
{
    try {
        return client.mkdirs(path);
    } catch (TException e) {
        throw new ThriftIOException(e);
    }
}   ",692,True
"/**
 * Constrcts a server object
 */
public HadoopThriftServer(String [] args){

  if (args.length > 0) {
    serverPort = new Integer(args[0]);
  }
  try {
    ServerSocket ssock = createServerSocket(serverPort);
    TServerTransport serverTransport = new TServerSocket(ssock);
    Iface handler = new HadoopThriftHandler(""hdfs-thrift-dhruba"");
    ThriftHadoopFileSystem.Processor processor = new ThriftHadoopFileSystem.Processor(handler);
    TThreadPoolServer.Options options = new TThreadPoolServer.Options();
    options.minWorkerThreads = 10;
    server = new TThreadPoolServer(processor, serverTransport,
                                           new TTransportFactory(),
                                           new TTransportFactory(),
                                           new TBinaryProtocol.Factory(),
                                           new TBinaryProtocol.Factory(), 
                                           options);
    System.out.println(""Starting the hadoop thrift server on port ["" + serverPort + ""]..."");
    HadoopThriftHandler.LOG.info(""Starting the hadoop thrift server on port ["" +serverPort + ""]..."");
    System.out.flush();

  } catch (Exception x) {
    x.printStackTrace();
  }
}","/**
 * Constrcts a server object
 */
public HadoopThriftServer(String [] args) 
{
    this.args = args;
    this.server = new HadoopThriftServer();
    this.server.setArgs(args);
    this.server.init();
}   ",693,False
"/**
 * If the specified pathname is a directory, then return the
 * list of pathnames in this directory
 */
public List<org.apache.hadoop.thriftfs.api.FileStatus> listStatus(
                        Pathname path) throws ThriftIOException{
  try {
    now = now();
    HadoopThriftHandler.LOG.debug(""listStatus: "" + path);

    org.apache.hadoop.fs.FileStatus[] stat = fs.listStatus(
                                       new Path(path.pathname));
    HadoopThriftHandler.LOG.debug(""listStatus done: "" + path);
    org.apache.hadoop.thriftfs.api.FileStatus tmp;
    List<org.apache.hadoop.thriftfs.api.FileStatus> value = 
      new LinkedList<org.apache.hadoop.thriftfs.api.FileStatus>();

    for (int i = 0; i < stat.length; i++) {
      tmp = new org.apache.hadoop.thriftfs.api.FileStatus(
                  stat[i].getPath().toString(),
                  stat[i].getLen(),
                  stat[i].isDir(),
                  stat[i].getReplication(),
                  stat[i].getBlockSize(),
                  stat[i].getModificationTime(),
                  stat[i].getPermission().toString(),
                  stat[i].getOwner(),
                  stat[i].getGroup());
      value.add(tmp);
    }
    return value;
  } catch (IOException e) {
    throw new ThriftIOException(e.getMessage());
  }
}","/**
 * If the specified pathname is a directory, then return the
 * list of pathnames in this directory
 */





public List<org.apache.hadoop.thriftfs.api.FileStatus> listStatus(
                        Pathname path) throws ThriftIOException 
{
    try
    {
        List<org.apache.hadoop.thriftfs.api.FileStatus> list = new ArrayList<org.apache.hadoop.thriftfs.api.FileStatus>();
        FileStatus[] stats = fs.listStatus(pathToHadoop(path));
        for (FileStatus stat : stats)
        {
            list.add(fileStatusToThrift(stat));
        }
        return list;
    }
    catch (IOException e)
    {
        throw new ThriftIOException(e);
    }
}   ",694,True
"/**
  * printStackTrace
  *
  * Helper function to print an exception stack trace to the log and not stderr
  *
  * @param e the exception
  *
  */
static private void printStackTrace(Exception e){
  for(StackTraceElement s: e.getStackTrace()) {
    LOG.error(s);
  }
}","/**
  * printStackTrace
  *
  * Helper function to print an exception stack trace to the log and not stderr
  *
  * @param e the exception
  *
  */


static private void printStackTrace(Exception e) 
{
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    e.printStackTrace(pw);
    log.info(sw.toString());
} ",695,False
"// Bind to port. If the specified port is 0, then bind to random port.
private ServerSocket createServerSocket(int port) throws IOException{
  try {
    ServerSocket sock = new ServerSocket();
    // Prevent 2MSL delay problem on server restarts
    sock.setReuseAddress(true);
    // Bind to listening port
    if (port == 0) {
      sock.bind(null);
      serverPort = sock.getLocalPort();
    } else {
      sock.bind(new InetSocketAddress(port));
    }
    return sock;
  } catch (IOException ioe) {
    throw new IOException(""Could not create ServerSocket on port "" + port + ""."" +
                          ioe);
  }
}","// Bind to port. If the specified port is 0, then bind to random port.
private ServerSocket createServerSocket(int port) throws IOException 
{
    if (port == 0)
    {
        return new ServerSocket(0);
    }
    else
    {
        return new ServerSocket(port);
    }
}   ",696,True
"/**
  * Create a file and open it for writing
  */
public ThriftHandle create(Pathname path) throws ThriftIOException{
  try {
    now = now();
    HadoopThriftHandler.LOG.debug(""create: "" + path);
    FSDataOutputStream out = fs.create(new Path(path.pathname));
    long id = insert(out);
    ThriftHandle obj = new ThriftHandle(id);
    HadoopThriftHandler.LOG.debug(""created: "" + path + "" id: "" + id);
    return obj;
  } catch (IOException e) {
    throw new ThriftIOException(e.getMessage());
  }
}","/**
  * Create a file and open it for writing
  */




public ThriftHandle create(Pathname path) throws ThriftIOException 
{
    try
    {
        return new ThriftHandle(new RandomAccessFile(path.toString(), ""rw""));
    }
    catch (FileNotFoundException e)
    {
        throw new ThriftIOException(e);
    }
} ",697,True
"/**
 * Sets the permission of a pathname
 */
public void chmod(Pathname path, short mode) throws ThriftIOException{
  try {
    now = now();
    HadoopThriftHandler.LOG.debug(""chmod: "" + path + 
                                 "" mode "" + mode);
    fs.setPermission(new Path(path.pathname), new FsPermission(mode));
    HadoopThriftHandler.LOG.debug(""chmod done: "" + path);
  } catch (IOException e) {
    throw new ThriftIOException(e.getMessage());
  }
}","/**
 * Sets the permission of a pathname
 */

public void chmod(Pathname path, short mode) throws ThriftIOException 
{
    try
    {
        _fs.chmod(path, mode);
    }
    catch (IOException e)
    {
        throw new ThriftIOException(e);
    }
}   ",698,True
"/**
 * Sets a custom initial capacity (defaults to 16). Resizing this or any
 * other kind of hash table is a relatively slow operation, so, when
 * possible, it is a good idea to provide estimates of expected table
 * sizes.
 * 
 * @throws IllegalArgumentException
 *         if initialCapacity < 0
 */
public Builder initialCapacity(int initialCapacity){
    if (this.initialCapacity != UNSET_INITIAL_CAPACITY) {
        throw new IllegalStateException(""initial capacity was already set to ""
                + this.initialCapacity);
    }
    if (initialCapacity < 0) {
        throw new IllegalArgumentException();
    }
    this.initialCapacity = initialCapacity;
    return this;
}","/**
 * Sets a custom initial capacity (defaults to 16). Resizing this or any
 * other kind of hash table is a relatively slow operation, so, when
 * possible, it is a good idea to provide estimates of expected table
 * sizes.
 * 
 * @throws IllegalArgumentException
 *         if initialCapacity < 0
 */
public Builder initialCapacity(int initialCapacity) 
{
    if (initialCapacity < 0)
    {
        throw new IllegalArgumentException(""initialCapacity < 0"");
    }

    this.initialCapacity = initialCapacity;
    return this;
}   ",700,True
"/**
 * Removes the key (and its corresponding value) from this map. This
 * method does nothing if the key is not in the map.
 * 
 * @param key
 *        the key that needs to be removed
 * @return the previous value associated with {@code key}, or {@code
 *         null} if there was no mapping for {@code key}
 * @throws NullPointerException
 *         if the specified key is null
 */
@Override
public V remove(Object key){
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    int hash = hash(key);
    return segmentFor(hash).remove(key, hash);
}","/**
 * Removes the key (and its corresponding value) from this map. This
 * method does nothing if the key is not in the map.
 * 
 * @param key
 *        the key that needs to be removed
 * @return the previous value associated with {@code key}, or {@code
 *         null} if there was no mapping for {@code key}
 * @throws NullPointerException
 *         if the specified key is null
 */
@Override
public V remove(Object key) 
{
    if (key == null)
    {
        throw new NullPointerException();
    }
    int i = indexOfKey(key);
    if (i >= 0)
    {
        return removeAt(i);
    }
    return null;
}   ",701,True
"/**
 * Start listening for location updates. It is recommend to call this from
 * onResume
 */
private void enableLocationUpdates(){
	AsyncTask<Void, Void, Void> findLastLocationTask = new AsyncTask<Void, Void, Void>() {
		@Override
		protected Void doInBackground(Void... params) {
			// Find the last known location, specifying a required accuracy
			// of within the min distance between updates
			// and a required latency of the minimum time required between
			// updates.
			Location lastKnownLocation = lastLocationFinder.getLastBestLocation(MAX_DISTANCE, System.currentTimeMillis()
					- MAX_TIME);
			// send location to view and model
			Presenter.getInst().sendViewMessage(P_UPDATE_LOCATION, lastKnownLocation);
			Presenter.getInst().sendModelMessage(P_UPDATE_LOCATION, lastKnownLocation);
			return null;
		}
	};
	findLastLocationTask.execute();

	// Normal updates while activity is visible.
	locationUpdateRequester.requestLocationUpdates(MAX_TIME, MAX_DISTANCE, criteria, locationListenerPendingIntent);

	// Passive location updates from 3rd party apps when the Activity isn't
	// visible.
	locationUpdateRequester.requestPassiveLocationUpdates(PASSIVE_MAX_TIME, PASSIVE_MAX_DISTANCE,
			locationListenerPassivePendingIntent);
}","/**
 * Start listening for location updates. It is recommend to call this from
 * onResume
 */


private void enableLocationUpdates() 
{
    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)
    {
        return;
    }
    LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);
}   ",703,False
"/**
 * {@inheritDoc}
 * 
 * @throws NullPointerException
 *         if any of the arguments are null
 */
public boolean replace(K key, V oldValue, V newValue){
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    if (oldValue == null) {
        throw new NullPointerException(""oldValue"");
    }
    if (newValue == null) {
        throw new NullPointerException(""newValue"");
    }
    int hash = hash(key);
    return segmentFor(hash).replace(key, hash, oldValue, newValue);
}","/**
 * {@inheritDoc}
 * 
 * @throws NullPointerException
 *         if any of the arguments are null
 */
public boolean replace(K key, V oldValue, V newValue) 
{
    if (key == null || oldValue == null || newValue == null)
        throw new NullPointerException();
    Node<K, V> e = getNode(hash(key), key);
    if (e != null && oldValue.equals(e.value))
    {
        e.value = newValue;
        return true;
    }
    return false;
}   ",704,True
"/**
 * Applies a supplemental hash function to a given hash code, which defends
 * against poor quality hash functions. This is critical when the concurrent
 * hash map uses power-of-two length hash tables, that otherwise encounter
 * collisions for hash codes that do not differ in lower or upper bits.
 * 
 * @param h
 *        hash code
 */
private static int rehash(int h){
    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    h += (h << 15) ^ 0xffffcd7d;
    h ^= (h >>> 10);
    h += (h << 3);
    h ^= (h >>> 6);
    h += (h << 2) + (h << 14);
    return h ^ (h >>> 16);
}","/**
 * Applies a supplemental hash function to a given hash code, which defends
 * against poor quality hash functions. This is critical when the concurrent
 * hash map uses power-of-two length hash tables, that otherwise encounter
 * collisions for hash codes that do not differ in lower or upper bits.
 * 
 * @param h
 *        hash code
 */
private static int rehash(int h) 
{
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}   ",706,True
"/**
 * Stop listening for location updates. It is recommend to call this from
 * onPause
 */
private void disableLocationUpdates(){
	locationManager.removeUpdates(locationListenerPendingIntent);
	lastLocationFinder.cancel();
}","/**
 * Stop listening for location updates. It is recommend to call this from
 * onPause
 */
private void disableLocationUpdates() 
{
    if (locationManager == null || locationListener == null)
        return;

    locationManager.removeUpdates(locationListener);
    locationListener = null;
}   ",709,True
"/**
 * Returns the most accurate and timely previously detected location. Where
 * the last result is beyond the specified maximum distance or latency a
 * one-off location update is returned via the {@link LocationListener}
 * specified in {@link setChangedLocationListener}.
 *
 * @param minDistance
 *            Minimum distance before we require a location update.
 * @param minTime
 *            Minimum time required between location updates.
 * @return The most accurate and / or timely previously detected location.
 */
@Override
public Location getLastBestLocation(int minDistance, long minTime){
	Location bestResult = null;
	float bestAccuracy = Float.MAX_VALUE;
	long bestTime = Long.MAX_VALUE;

	bestResult = getBestLocationResult(bestAccuracy, bestTime, minTime);

	// If the best result is beyond the allowed time limit, or the accuracy
	// of the
	// best result is wider than the acceptable maximum distance, request a
	// single update.
	// This check simply implements the same conditions we set when
	// requesting regular
	// location updates every [minTime] and [minDistance].
	// Prior to Gingerbread ""one-shot"" updates weren't available, so we need
	// to implement
	// this manually.
	if (locationListener != null && (bestTime > minTime || bestAccuracy > minDistance)) {
		String provider = locationManager.getBestProvider(criteria, true);
		if (provider != null) {
			locationManager.requestLocationUpdates(provider, 0, 0, singeUpdateListener, context.getMainLooper());
		}
	}

	return bestResult;
}","/**
 * Returns the most accurate and timely previously detected location. Where
 * the last result is beyond the specified maximum distance or latency a
 * one-off location update is returned via the {@link LocationListener}
 * specified in {@link setChangedLocationListener}.
 *
 * @param minDistance
 *            Minimum distance before we require a location update.
 * @param minTime
 *            Minimum time required between location updates.
 * @return The most accurate and / or timely previously detected location.
 */
@Override
public Location getLastBestLocation(int minDistance, long minTime) 
{
    Location bestResult = null;
    float bestAccuracy = Float.MAX_VALUE;
    long bestTime = Long.MIN_VALUE;

    // Go through all available locations
    for (Location location : availableLocations)
    {
        // Get accuracy and time of this location
        float accuracy = location.getAccuracy();
        long time = location.getTime();

        // Check if better than current best result
        if (accuracy < bestAccuracy)
        {
            bestResult = location;
            bestAccuracy = accuracy;
            bestTime = time;
        }
        else if (bestAccuracy == accuracy && time - bestTime >= minTime && accuracy <= minDistance)
        {
            bestResult = location;
            bestTime = time;
        }
    }

    // Return best result
    return bestResult;
}   ",712,False
"/**
 * Returns a {@link java.util.Collection} view of the values contained
 * in this map. The collection is backed by the map, so changes to the
 * map are reflected in the collection, and vice-versa. The collection
 * supports element removal, which removes the corresponding mapping
 * from this map, via the {@code Iterator.remove}, {@code
 * Collection.remove}, {@code removeAll}, {@code retainAll}, and {@code
 * clear} operations. It does not support the {@code add} or {@code
 * addAll} operations.
 * <p>
 * The view's {@code iterator} is a ""weakly consistent"" iterator that
 * will never throw {@link java.util.ConcurrentModificationException},
 * and guarantees to traverse elements as they existed upon construction
 * of the iterator, and may (but is not guaranteed to) reflect any
 * modifications subsequent to construction.
 */
@Override
public Collection<V> values(){
    Collection<V> vs = values;
    return (vs != null) ? vs : (values = new Values());
}","/**
 * Returns a {@link java.util.Collection} view of the values contained
 * in this map. The collection is backed by the map, so changes to the
 * map are reflected in the collection, and vice-versa. The collection
 * supports element removal, which removes the corresponding mapping
 * from this map, via the {@code Iterator.remove}, {@code
 * Collection.remove}, {@code removeAll}, {@code retainAll}, and {@code
 * clear} operations. It does not support the {@code add} or {@code
 * addAll} operations.
 * <p>
 * The view's {@code iterator} is a ""weakly consistent"" iterator that
 * will never throw {@link java.util.ConcurrentModificationException},
 * and guarantees to traverse elements as they existed upon construction
 * of the iterator, and may (but is not guaranteed to) reflect any
 * modifications subsequent to construction.
 */
@Override
public Collection<V> values() 
{
    Collection<V> vs = values;
    return (vs == null) ? (values = new Values()) : vs;
}   ",713,True
"/**
 * Returns the number of key-value mappings in this map. If the map
 * contains more than {@code Integer.MAX_VALUE} elements, returns
 * {@code Integer.MAX_VALUE}.
 * 
 * @return the number of key-value mappings in this map
 */
@Override
public int size(){
    final Segment[] segments = this.segments;
    long sum = 0;
    long check = 0;
    int[] mc = new int[segments.length];
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {
        check = 0;
        sum = 0;
        int mcsum = 0;
        for (int i = 0; i < segments.length; ++i) {
            sum += segments[i].count;
            mcsum += mc[i] = segments[i].modCount;
        }
        if (mcsum != 0) {
            for (int i = 0; i < segments.length; ++i) {
                check += segments[i].count;
                if (mc[i] != segments[i].modCount) {
                    check = -1; // force retry
                    break;
                }
            }
        }
        if (check == sum) {
            break;
        }
    }
    if (check != sum) { // Resort to locking all segments
        sum = 0;
        for (Segment segment : segments) {
            segment.lock();
        }
        for (Segment segment : segments) {
            sum += segment.count;
        }
        for (Segment segment : segments) {
            segment.unlock();
        }
    }
    if (sum > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
    } else {
        return (int) sum;
    }
}","/**
 * Returns the number of key-value mappings in this map. If the map
 * contains more than {@code Integer.MAX_VALUE} elements, returns
 * {@code Integer.MAX_VALUE}.
 * 
 * @return the number of key-value mappings in this map
 */
@Override
public int size() 
{
    return size;
}   ",714,False
"/**
 * Add View-component in <code>mViewHandler</code> for receiving messages
 *
 * @param viewComponentCallback
 *            - View-component, which realized {@link Callback}.
 */
public final void subscribe(Callback viewComponentCallback){
	Handler handler = new Handler(viewComponentCallback);
	mHandlerMap.put(viewComponentCallback, handler);
	mViewHandlers.add(handler);
}","/**
 * Add View-component in <code>mViewHandler</code> for receiving messages
 *
 * @param viewComponentCallback
 *            - View-component, which realized {@link Callback}.
 */
public final void subscribe(Callback viewComponentCallback) 
{
    if (viewComponentCallback != null)
    {
        mViewHandler.add(viewComponentCallback);
    }
}   ",715,True
"/**
 * Creates a new concurrent hash map backed by the given strategy.
 * 
 * @param strategy
 *        used to implement and manipulate the entries
 * @param <K>
 *        the type of keys to be stored in the returned map
 * @param <V>
 *        the type of values to be stored in the returned map
 * @param <E>
 *        the type of internal entry to be stored in the returned map
 * @throws NullPointerException
 *         if strategy is null
 */
public <K, V, E> ConcurrentMap<K, V> buildMap(Strategy<K, V, E> strategy){
    if (strategy == null) {
        throw new NullPointerException(""strategy"");
    }
    return new Impl<K, V, E>(strategy, this);
}","/**
 * Creates a new concurrent hash map backed by the given strategy.
 * 
 * @param strategy
 *        used to implement and manipulate the entries
 * @param <K>
 *        the type of keys to be stored in the returned map
 * @param <V>
 *        the type of values to be stored in the returned map
 * @param <E>
 *        the type of internal entry to be stored in the returned map
 * @throws NullPointerException
 *         if strategy is null
 */
public <K, V, E> ConcurrentMap<K, V> buildMap(Strategy<K, V, E> strategy) 
{
    if (strategy == null)
    {
        throw new NullPointerException();
    }
    return new ConcurrentHashMap<K, V>(strategy);
}   ",716,True
"/**
 * Guides the allowed concurrency among update operations. Used as a
 * hint for internal sizing. The table is internally partitioned to try
 * to permit the indicated number of concurrent updates without
 * contention. Because placement in hash tables is essentially random,
 * the actual concurrency will vary. Ideally, you should choose a value
 * to accommodate as many threads as will ever concurrently modify the
 * table. Using a significantly higher value than you need can waste
 * space and time, and a significantly lower value can lead to thread
 * contention. But overestimates and underestimates within an order of
 * magnitude do not usually have much noticeable impact. A value of one
 * is appropriate when it is known that only one thread will modify and
 * all others will only read. Defaults to {@literal 16}.
 * 
 * @throws IllegalArgumentException
 *         if concurrencyLevel < 0
 */
public Builder concurrencyLevel(int concurrencyLevel){
    if (this.concurrencyLevel != UNSET_CONCURRENCY_LEVEL) {
        throw new IllegalStateException(""concurrency level was already set to ""
                + this.concurrencyLevel);
    }
    if (concurrencyLevel <= 0) {
        throw new IllegalArgumentException();
    }
    this.concurrencyLevel = concurrencyLevel;
    return this;
}","/**
 * Guides the allowed concurrency among update operations. Used as a
 * hint for internal sizing. The table is internally partitioned to try
 * to permit the indicated number of concurrent updates without
 * contention. Because placement in hash tables is essentially random,
 * the actual concurrency will vary. Ideally, you should choose a value
 * to accommodate as many threads as will ever concurrently modify the
 * table. Using a significantly higher value than you need can waste
 * space and time, and a significantly lower value can lead to thread
 * contention. But overestimates and underestimates within an order of
 * magnitude do not usually have much noticeable impact. A value of one
 * is appropriate when it is known that only one thread will modify and
 * all others will only read. Defaults to {@literal 16}.
 * 
 * @throws IllegalArgumentException
 *         if concurrencyLevel < 0
 */
public Builder concurrencyLevel(int concurrencyLevel) 
{
    if (concurrencyLevel < 0)
    {
        throw new IllegalArgumentException();
    }
    this.concurrencyLevel = concurrencyLevel;
    return this;
}   ",718,True
"/**
 * Set the bandwidth of the session.
 * 
 * See sessionBandwidth(void) for details. 
 * 
 * @param bandwidth the new value requested, in bytes per second
 * @return the actual value set
 	 */
public int sessionBandwidth(int bandwidth){
	if(bandwidth < 1) {
		this.bandwidth = 8000;
	} else {
		this.bandwidth = bandwidth;
	}
	return this.bandwidth;
}","/**
 * Set the bandwidth of the session.
 * 
 * See sessionBandwidth(void) for details. 
 * 
 * @param bandwidth the new value requested, in bytes per second
 * @return the actual value set
 	 */
public int sessionBandwidth(int bandwidth) 
{
    return sessionBandwidth(bandwidth, 0);
}	",720,True
"/**
 * 
 * @param group
 *            group information for the one to add + (contacts to add inside
 *            the group)
 * @return the response from the server (HTTPstatus + message)
 * @throws JSONException
 * @throws IOException
 * @throws ClientProtocolException
 */
public Status addNewGroup(Group group) throws ClientProtocolException,
		IOException, JSONException{
	// group insertion
	HashMap<String, Object> hM = new HashMap<String, Object>();
	hM.put(""groupName"", group.getGroupName());
	hM.put(""status"", group.getGroupStatus());

	Response r = this.post(""insertGroup"", hM);
	// 201 = HTTP status code for user inserted
	if (r.getStatus() == 201) {
		// store the id of the brand new group for utilize it in inserting
		// the user
		group.setId(Integer.parseInt(r.getResult().getString(""id"")));
		return new Status(true, ""Profile added successfully"");
	} else {
		return new Status(false, """" + r.getResult());
	}
}","/**
 * 
 * @param group
 *            group information for the one to add + (contacts to add inside
 *            the group)
 * @return the response from the server (HTTPstatus + message)
 * @throws JSONException
 * @throws IOException
 * @throws ClientProtocolException
 */



public Status addNewGroup(Group group) throws ClientProtocolException,
		IOException, JSONException 
{
	HttpClient client = new DefaultHttpClient();
	HttpPost post = new HttpPost(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"");
	StringEntity input = new StringEntity(group.toJSON().toString());
	input.setContentType(""application/json"");
	post.setEntity(input);
	HttpResponse response = client.execute(post);
	return new Status(response.getStatusLine().getStatusCode(),
			EntityUtils.toString(response.getEntity()));
}	",721,True
"/**
 * Returns an instance of a <b>unicast</b> RTP session. 
 * Following this you should adjust any settings and then register your application.
 * 
 * The sockets should have external ip addresses, else your CNAME automatically
 * generated CNAMe will be bad.
 * 
 * @param	rtpSocket UDP socket to receive RTP communication on
 * @param	rtcpSocket UDP socket to receive RTCP communication on, null if none.
 */
public RTPSession(DatagramSocket rtpSocket, DatagramSocket rtcpSocket){
		 mcSession = false;
		 rtpSock = rtpSocket;
		 this.generateCNAME();
		 this.generateSsrc();
		 this.rtcpSession = new RTCPSession(this,rtcpSocket);
		 
		 // The sockets are not always imediately available?
		 try { Thread.sleep(1); } catch (InterruptedException e) { System.out.println(""RTPSession sleep failed""); }
}","/**
 * Returns an instance of a <b>unicast</b> RTP session. 
 * Following this you should adjust any settings and then register your application.
 * 
 * The sockets should have external ip addresses, else your CNAME automatically
 * generated CNAMe will be bad.
 * 
 * @param	rtpSocket UDP socket to receive RTP communication on
 * @param	rtcpSocket UDP socket to receive RTCP communication on, null if none.
 */
public RTPSession(DatagramSocket rtpSocket, DatagramSocket rtcpSocket) 
{
    this.rtpSocket = rtpSocket;
    this.rtcpSocket = rtcpSocket;
    this.rtpSession = new RTPSessionImpl(rtpSocket, rtcpSocket);
}   ",722,True
"/**
 * Insert the Profiles that belongs to group object into it in the DB
 * 
 * @param group
 * @return
 */
public Status insertUsersIntoGroup(Group group)
		throws ClientProtocolException, IOException, JSONException{
	// for every user, perform the insert operation
	Response r = null;
	List<Profile> user = group.getContacts();
	for (int i = 0; i < user.size(); i++) {
		HashMap<String, Object> hMGroupUser = new HashMap<String, Object>();
		hMGroupUser.put(""userID"", user.get(i).getId());
		hMGroupUser.put(""groupID"", group.getId());
		r = this.post(""insertUserIntoGroup"", hMGroupUser);
	}
	// 201 = HTTP status for insertion performed correctly
	if (r.getStatus() == 201) {
		return new Status(true, ""Profile added successfully"");
	} else {
		return new Status(false, r.getResult().getString(""result""));
	}
}","/**
 * Insert the Profiles that belongs to group object into it in the DB
 * 
 * @param group
 * @return
 */

public Status insertUsersIntoGroup(Group group)
		throws ClientProtocolException, IOException, JSONException 
{
	List<User> users = group.getUsers();
	List<Profile> profiles = new ArrayList<Profile>();
	for (User user : users)
	{
		Profile profile = user.getProfile();
		profiles.add(profile);
	}
	return insertProfiles(profiles);
}	",725,False
"/**
 * @return status of the performed operation
 */
public Status retrieveGroup(Group g) throws JSONException,
		ClientProtocolException, IOException{
	HashMap<String, String> hM = new HashMap<String, String>();
	hM.put(""id"", """" + g.getId());
	Response r = this.get(""retrieveGroup"", hM);
	g.setGroupName("""" + r.getResult().get(""groupName""));
	g.setGroupStatus("""" + r.getResult().get(""status""));
	// HTTP valid return status
	if ((r.getStatus() >= 200) && (r.getStatus() < 300)) {
		return new Status(true, ""Group retrieved successfully"");
	} else {
		return new Status(false, r.getResult().getString(""result""));
	}
}","/**
 * @return status of the performed operation
 */



public Status retrieveGroup(Group g) throws JSONException,
		ClientProtocolException, IOException 
{
	HttpClient client = new DefaultHttpClient();
	HttpGet request = new HttpGet(""http://""
			+ this.serverAddress + "":"" + this.serverPort
			+ ""/groups/"" + g.getId());
	HttpResponse response = client.execute(request);

	if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)
	{
		String json = EntityUtils.toString(response.getEntity());
		JSONObject obj = new JSONObject(json);

		g.setName(obj.getString(""name""));
		g.setDescription(obj.getString(""description""));

		return Status.SUCCESS;
	}
	else
	{
		return Status.FAILURE;
	}
}	",726,False
"/**
 * Set the RTCP bandwidth, see rtcpBandwidth(void) for details. 
 * 
 * This function must be
 * 
 * @param bandwidth the new value requested, in bytes per second or -1 to disable
 * @return the actual value set
 	 */
public int rtcpBandwidth(int bandwidth){
	if(bandwidth < -1) {
		this.rtcpBandwidth = -1;
	} else {
		this.rtcpBandwidth = bandwidth;
	}
	return this.rtcpBandwidth;
}","/**
 * Set the RTCP bandwidth, see rtcpBandwidth(void) for details. 
 * 
 * This function must be
 * 
 * @param bandwidth the new value requested, in bytes per second or -1 to disable
 * @return the actual value set
 	 */
public int rtcpBandwidth(int bandwidth) 
{
	if (bandwidth < 0) {
		this.rtcpBandwidth = -1;
	} else {
		this.rtcpBandwidth = bandwidth;
	}
	return this.rtcpBandwidth;
}	",727,True
"/**
 * Change the RTCP socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a unicast session to begin with.
 * 
 * @param newSock the new unicast socket for RTP communication.
 */
public int updateRTCPSock(DatagramSocket newSock){
	if(!mcSession) {
		this.rtcpSession.rtcpSock = newSock;
		return 0;
	} else {
		System.out.println(""Can't switch from multicast to unicast."");
		return -1;
	}
}","/**
 * Change the RTCP socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a unicast session to begin with.
 * 
 * @param newSock the new unicast socket for RTP communication.
 */
public int updateRTCPSock(DatagramSocket newSock) 
{
    if (newSock == null)
    {
        return -1;
    }
    if (this.rtcpSock != null)
    {
        this.rtcpSock.close();
    }
    this.rtcpSock = newSock;
    return 0;
}   ",728,True
"/** 
 * Generates a random sequence number
 */
private void generateSeqNum(){
	if(this.random == null)
		createRandom();
	
	seqNum = this.random.nextInt();
	if(seqNum < 0)
		seqNum = -seqNum;
	while(seqNum > 65535) {
		seqNum = seqNum / 10;
	}
}","/** 
 * Generates a random sequence number
 */

private void generateSeqNum() 
{
    Random random = new Random();
    int seqNum = random.nextInt(1000);
    this.seqNum = seqNum;
}   ",729,True
"/**
 * Send data to all participants registered as receivers, using the current timeStamp and
 * payload type. The RTP timestamp will be the same for all the packets.
 * 
 * @param buffers A buffer of bytes, should not bed padded and less than 1500 bytes on most networks.
 * @param csrcArray an array with the SSRCs of contributing sources
 * @param markers An array indicating what packets should be marked. Rarely anything but the first one
 * @param rtpTimestamp The RTP timestamp to be applied to all packets
 * @param seqNumbers An array with the sequence number associated with each byte[]
 * @return	null if there was a problem sending the packets, 2-dim array with {RTP Timestamp, Sequence number}
 */
public long[][] sendData(byte[][] buffers, long[] csrcArray, boolean[] markers, long rtpTimestamp, long[] seqNumbers){
		 if(RTPSession.rtpDebugLevel > 5) {
			 System.out.println(""-> RTPSession.sendData(byte[])"");
		 }

		 // Same RTP timestamp for all
		 if(rtpTimestamp < 0)
			 rtpTimestamp = System.currentTimeMillis();
		 
		 // Return values
		 long[][] ret = new long[buffers.length][2];

		 for(int i=0; i<buffers.length; i++) {
			 byte[] buf = buffers[i];
			 
			 boolean marker = false;
			 if(markers != null)
				  marker = markers[i];
			 
			 if(buf.length > 1500) {
				 System.out.println(""RTPSession.sendData() called with buffer exceeding 1500 bytes (""+buf.length+"")"");
			 }

			 // Get the return values
			 ret[i][0] = rtpTimestamp;
			 if(seqNumbers == null) {
				 ret[i][1] = getNextSeqNum();
			 } else {
				 ret[i][1] = seqNumbers[i];
			 }
			 // Create a new RTP Packet
			 RtpPkt pkt = new RtpPkt(rtpTimestamp,this.ssrc,(int) ret[i][1],this.payloadType,buf);

			 if(csrcArray != null)
				 pkt.setCsrcs(csrcArray);

			 pkt.setMarked(marker);

			 // Creates a raw packet
			 byte[] pktBytes = pkt.encode();
			 
			 //System.out.println(Integer.toString(StaticProcs.bytesToUIntInt(pktBytes, 2)));

			 // Pre-flight check, are resolving an SSRC conflict?
			 if(this.conflict) {
				 System.out.println(""RTPSession.sendData() called while trying to resolve conflict."");
				 return null;
			 }


			 if(this.mcSession) {
				 DatagramPacket packet = null;


				 try {
					 packet = new DatagramPacket(pktBytes,pktBytes.length,this.mcGroup,this.rtpMCSock.getPort());
				 } catch (Exception e) {
					 System.out.println(""RTPSession.sendData() packet creation failed."");
					 e.printStackTrace();
					 return null;
				 }

				 try {
					 rtpMCSock.send(packet);
					 //Debug
					 if(this.debugAppIntf != null) {
						 this.debugAppIntf.packetSent(1, (InetSocketAddress) packet.getSocketAddress(), 
								 new String(""Sent multicast RTP packet of size "" + packet.getLength() + 
										 "" to "" + packet.getSocketAddress().toString() + "" via "" 
										 + rtpMCSock.getLocalSocketAddress().toString()));
					 }
				 } catch (Exception e) {
					 System.out.println(""RTPSession.sendData() multicast failed."");
					 e.printStackTrace();
					 return null;
				 }		

			 } else {
				 // Loop over recipients
				 Iterator<Participant> iter = partDb.getUnicastReceivers();
				 while(iter.hasNext()) {			
					 InetSocketAddress receiver = iter.next().rtpAddress;
					 DatagramPacket packet = null;

					 if(RTPSession.rtpDebugLevel > 15) {
						 System.out.println(""   Sending to "" + receiver.toString());
					 }

					 try {
						 packet = new DatagramPacket(pktBytes,pktBytes.length,receiver);
					 } catch (Exception e) {
						 System.out.println(""RTPSession.sendData() packet creation failed."");
						 e.printStackTrace();
						 return null;
					 }

					 //Actually send the packet
					 try {
						 rtpSock.send(packet);
						 //Debug
						 if(this.debugAppIntf != null) {
							 this.debugAppIntf.packetSent(0, (InetSocketAddress) packet.getSocketAddress(), 
									 new String(""Sent unicast RTP packet of size "" + packet.getLength() + 
											 "" to "" + packet.getSocketAddress().toString() + "" via "" 
											 + rtpSock.getLocalSocketAddress().toString()));
						 }
					 } catch (Exception e) {
						 System.out.println(""RTPSession.sendData() unicast failed."");
						 e.printStackTrace();
						 return null;
					 }
				 }
			 }

			 //Update our stats
			 this.sentPktCount++;
			 this.sentOctetCount++;

			 if(RTPSession.rtpDebugLevel > 5) {
				 System.out.println(""<- RTPSession.sendData(byte[]) "" + pkt.getSeqNumber());
			 }  
		 }

		 return ret;
}","/**
 * Send data to all participants registered as receivers, using the current timeStamp and
 * payload type. The RTP timestamp will be the same for all the packets.
 * 
 * @param buffers A buffer of bytes, should not bed padded and less than 1500 bytes on most networks.
 * @param csrcArray an array with the SSRCs of contributing sources
 * @param markers An array indicating what packets should be marked. Rarely anything but the first one
 * @param rtpTimestamp The RTP timestamp to be applied to all packets
 * @param seqNumbers An array with the sequence number associated with each byte[]
 * @return	null if there was a problem sending the packets, 2-dim array with {RTP Timestamp, Sequence number}
 */
public long[][] sendData(byte[][] buffers, long[] csrcArray, boolean[] markers, long rtpTimestamp, long[] seqNumbers) 
{
    long[][] ret = new long[buffers.length][2];
    for (int i = 0; i < buffers.length; i++)
    {
        ret[i] = sendData(buffers[i], csrcArray, markers[i], rtpTimestamp, seqNumbers[i]);
    }
    return ret;
}   ",730,True
"/**
 * Add a participant object to the participant database.
 * 
 * If packets have already been received from this user, we will try to update the automatically inserted participant with the information provided here.
 *
 * @param p A participant.
 */
public int addParticipant(Participant p){
		//For now we make all participants added this way persistent
		p.unexpected = false;
		return this.partDb.addParticipant(0, p);
	}","/**
 * Add a participant object to the participant database.
 * 
 * If packets have already been received from this user, we will try to update the automatically inserted participant with the information provided here.
 *
 * @param p A participant.
 */
public int addParticipant(Participant p) 
{
    int id = -1;
    if (p == null)
    {
        return id;
    }

    if (p.getParticipantID() == null)
    {
        id = participantDB.addParticipant(p);
    }
    else
    {
        id = participantDB.updateParticipant(p);
    }

    return id;
}   ",732,True
"/** 
 * Initializes a random variable
 *
 */
private void createRandom(){
	this.random = new Random(System.currentTimeMillis() + Thread.currentThread().getId() 
			- Thread.currentThread().hashCode() + this.cname.hashCode());
}","/** 
 * Initializes a random variable
 *
 */
private void createRandom() 
{
    Random random = new Random();
    this.random = random;
}   ",734,True
"/**
 * Change the RTP multicast socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a multicast session to begin with.
 * 
 * @param newSock the new multicast socket for RTP communication.
 */
public int updateRTPSock(MulticastSocket newSock){
	if(mcSession) {
		 this.rtpMCSock = newSock;
		 return 0;
	} else {
		System.out.println(""Can't switch from unicast to multicast."");
		return -1;
	}
}","/**
 * Change the RTP multicast socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a multicast session to begin with.
 * 
 * @param newSock the new multicast socket for RTP communication.
 */
public int updateRTPSock(MulticastSocket newSock) 
{
    if (isMulticast)
    {
        rtpSock = newSock;
        return 0;
    }
    else
    {
        return -1;
    }
}   ",738,True
"/**
 * Change the RTP socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a unicast session to begin with.
 * 
 * @param newSock integer for new port number, check it is free first.
 */
public int updateRTPSock(DatagramSocket newSock){
	if(!mcSession) {
		 rtpSock = newSock;
		 return 0;
	} else {
		System.out.println(""Can't switch from multicast to unicast."");
		return -1;
	}
}","/**
 * Change the RTP socket of the session. 
 * Peers must be notified through SIP or other signalling protocol.
 * Only valid if this is a unicast session to begin with.
 * 
 * @param newSock integer for new port number, check it is free first.
 */
public int updateRTPSock(DatagramSocket newSock) 
{
    if (newSock == null)
        return -1;
    if (this.rtpSock != null)
        this.rtpSock.close();
    this.rtpSock = newSock;
    return 0;
}   ",739,True
"/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Cursor}.
 * @param c a valid {@link Cursor} for the {@link AbstractDAOItem} type.
 */
public AbstractDAOItem(Cursor c){
    if (c == null) {
        throw new IllegalArgumentException(""Cursor cannot be null"");
    }
    mCursor = c;
}","/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Cursor}.
 * @param c a valid {@link Cursor} for the {@link AbstractDAOItem} type.
 */
public AbstractDAOItem(Cursor c) 
{
    this.id = c.getInt(c.getColumnIndex(""id""));
    this.name = c.getString(c.getColumnIndex(""name""));
    this.description = c.getString(c.getColumnIndex(""description""));
    this.price = c.getDouble(c.getColumnIndex(""price""));
    this.quantity = c.getInt(c.getColumnIndex(""quantity""));
    this.category = c.getString(c.getColumnIndex(""category""));
}   ",741,True
"/**
 * Deletes non system themes with the specified package.
 * @param context the context of the caller.
 * @param packageName the package for the themes to be deleted.
 */
public static void deleteThemesByPackage(Context context, String packageName){
    context.getContentResolver().delete(
            ThemeColumns.CONTENT_PLURAL_URI, ThemeColumns.THEME_PACKAGE + "" = ?"",
            new String[] { packageName });
}","/**
 * Deletes non system themes with the specified package.
 * @param context the context of the caller.
 * @param packageName the package for the themes to be deleted.
 */

public static void deleteThemesByPackage(Context context, String packageName) 
{
    if (packageName == null)
    {
        return;
    }

    List<Theme> themes = getThemesByPackage(context, packageName);
    for (Theme theme : themes)
    {
        if (!theme.isSystem())
        {
            theme.delete();
        }
    }
}   ",742,True
"/**
 * Gets an {@link AbstractDAOItem} with it's cursor positioned at the given postion.
 * @param position the position to get.
 * @return the item or null if the position is invalid.
 */
public T getDAOItem(int position){
    if (position >= 0 && getCount() >= 0) {
        mDAOItem.setPosition(position);
        return mDAOItem;
    }
    return null;
}","/**
 * Gets an {@link AbstractDAOItem} with it's cursor positioned at the given postion.
 * @param position the position to get.
 * @return the item or null if the position is invalid.
 */
public T getDAOItem(int position) 
{
    if (position >= 0 && position < mDAOItems.size())
    {
        return mDAOItems.get(position);
    }
    return null;
}   ",743,True
"/**
 * Gets a {@link Cursor} for the currently applied theme.
 * @param context the context of the caller.
 * @return a {@link Cursor} for the currently applied theme.
 */
public static Cursor getAppliedTheme(Context context){
    return context.getContentResolver().query(ThemeColumns.CONTENT_PLURAL_URI,
            null, ThemeColumns.IS_APPLIED + ""=1"", null, null);
}","/**
 * Gets a {@link Cursor} for the currently applied theme.
 * @param context the context of the caller.
 * @return a {@link Cursor} for the currently applied theme.
 */


public static Cursor getAppliedTheme(Context context) 
{
    final String themePackage = getThemePackage(context);
    if (themePackage == null)
    {
        return null;
    }
    final Uri uri = Uri.parse(""content://"" + themePackage + ""/theme"");
    return context.getContentResolver().query(uri, null, null, null, null);
}   ",744,True
"/**
 * Deletes a non system theme with the specified package and id.
 * @param context the context of the caller.
 * @param packageName
 * @param themeId
 */
public static void deleteTheme(Context context, String packageName,
        String themeId){
    context.getContentResolver().delete(
            ThemeColumns.CONTENT_PLURAL_URI, ThemeColumns.THEME_PACKAGE + "" = ? AND "" +
                ThemeColumns.THEME_ID + "" = ?"",
            new String[] { packageName, themeId });
}","/**
 * Deletes a non system theme with the specified package and id.
 * @param context the context of the caller.
 * @param packageName
 * @param themeId
 */
public static void deleteTheme(Context context, String packageName,
        String themeId) 
{
    if (packageName == null || themeId == null)
    {
        return;
    }

    String where = ThemesColumns.PKG_NAME + ""=? AND "" + ThemesColumns._ID
            + ""=?"";
    String[] whereArgs = new String[] { packageName, themeId };

    context.getContentResolver().delete(ThemesColumns.CONTENT_URI, where,
            whereArgs);
}       ",745,False
"/**
 * Gets the position of the item in the Adapter.
 * @param context the context of the caller.
 * @param uri the Uri to find.
 * @return the position of the item in the Adapter or -1 of not in Adapter.
 */
public int findItem(Context context, Uri uri){
    if (uri == null) return -1;
    int n = getCount();
    while (n-- > 0) {
        T item = getDAOItem(n);
        if (uri.equals(item.getUri(context)) == true) {
            return n;
        }
    }
    return -1;
}","/**
 * Gets the position of the item in the Adapter.
 * @param context the context of the caller.
 * @param uri the Uri to find.
 * @return the position of the item in the Adapter or -1 of not in Adapter.
 */
public int findItem(Context context, Uri uri) 
{
    int position = -1;
    Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
    if (cursor != null)
    {
        cursor.moveToFirst();
        position = cursor.getPosition();
        cursor.close();
    }
    return position;
}   ",747,True
"/**
 * @return the previously marked position or -1 if no mark has been set.
 *
 * @throws IllegalStateException if called with automatic marking disabled.
 */
public int getMarkedPosition(){
    if (!mMarking) {
        throw new IllegalStateException(""getMarkedPosition() called without automatic marking support."");
    }
    return mMarkedPosition;
}","/**
 * @return the previously marked position or -1 if no mark has been set.
 *
 * @throws IllegalStateException if called with automatic marking disabled.
 */
public int getMarkedPosition() 
{
    if (!markingEnabled)
    {
        throw new IllegalStateException(""Marking is disabled."");
    }

    return markedPosition;
}   ",749,True
"/**
 * Marks a theme as being the applied theme.
 * @param context the context of the caller.
 * @param packageName the package of the theme to apply.
 * @param themeId the id of the theme to apply.
 */
public static void markAppliedTheme(Context context, String packageName, String themeId){
    ContentValues values = new ContentValues();
    values.put(ThemeColumns.IS_APPLIED, 0);
    context.getContentResolver().update(ThemeColumns.CONTENT_PLURAL_URI, values, null, null);
    values.put(ThemeColumns.IS_APPLIED, 1);
    context.getContentResolver().update(ThemeColumns.CONTENT_PLURAL_URI, values,
            ThemeColumns.THEME_PACKAGE + "" = ? AND "" +
                ThemeColumns.THEME_ID + "" = ?"",
            new String[] { packageName, themeId });
}","/**
 * Marks a theme as being the applied theme.
 * @param context the context of the caller.
 * @param packageName the package of the theme to apply.
 * @param themeId the id of the theme to apply.
 */

public static void markAppliedTheme(Context context, String packageName, String themeId) 
{
    SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = prefs.edit();
    editor.putString(PREF_APPLIED_THEME_PACKAGE, packageName);
    editor.putString(PREF_APPLIED_THEME_ID, themeId);
    editor.apply();
}   ",752,True
"/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Cursor}
 * positioned to the first entry.
 *
 * @param c a valid {@link Cursor} for the {@link AbstractDAOItem} type.
 * @return an {@link AbstractDAOItem} positioned to the first entry in
 *         the {@link Cursor}. If there are no entries, null is
 *         returned.
 */
public T newInstance(Cursor c){
    if (c != null) {
        if (c.moveToFirst() == true) {
            return init(c);
        } else {
            c.close();
        }
    }
    return null;
}","/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Cursor}
 * positioned to the first entry.
 *
 * @param c a valid {@link Cursor} for the {@link AbstractDAOItem} type.
 * @return an {@link AbstractDAOItem} positioned to the first entry in
 *         the {@link Cursor}. If there are no entries, null is
 *         returned.
 */
public T newInstance(Cursor c) 
{
    if (c.moveToFirst())
    {
        return newInstance(c, c.getPosition());
    }
    return null;
}   ",753,True
"/**
 * Changes to the style of the given style {@link Uri}.
 * @param context the context of the caller.
 * @param styleUri the {@link Uri} of the style to apply.
 */
public static void changeStyle(Context context, Uri styleUri){
    changeTheme(context, new Intent(ThemeManager.ACTION_CHANGE_THEME).setDataAndType(styleUri,
            ThemeColumns.STYLE_CONTENT_ITEM_TYPE));
}","/**
 * Changes to the style of the given style {@link Uri}.
 * @param context the context of the caller.
 * @param styleUri the {@link Uri} of the style to apply.
 */
public static void changeStyle(Context context, Uri styleUri) 
{
    SharedPreferences preferences = context.getSharedPreferences(StyleHelper.PREFS_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = preferences.edit();
    editor.putString(StyleHelper.PREFS_KEY, styleUri.toString());
    editor.apply();
}   ",754,True
"/**
 * Compares the internal T-Mobile theme object to this ThemeItem.
 * For internal use.
 * @param theme the CustomTheme object to compare
 * @return
 */
public boolean equals(CustomTheme theme){
    if (theme == null) {
        return false;
    }
    if (getPackageName().equals(theme.getThemePackageName()) == false) {
        return false;
    }
    return theme.getThemeId().equals(getThemeId());
}","/**
 * Compares the internal T-Mobile theme object to this ThemeItem.
 * For internal use.
 * @param theme the CustomTheme object to compare
 * @return
 */
public boolean equals(CustomTheme theme) 
{
    if (theme == null)
    {
        return false;
    }
    return (this.themeName.equals(theme.getThemeName()) &&
            this.themeId.equals(theme.getThemeId()));
}   ",755,True
"/**
 * Mark the applied item's position.
 *
 * @param existingUri uri to select, or null to use the currently applied
 *            item.
 * @param notifyChange if true, {@link #notifyDataSetChanged} will be called
 *            on mark change.
 *
 * @see #getMarkedPosition
 */
private int markCurrentOrExistingItem(Uri existingUri, boolean notifyChange){
    int position = findExistingOrCurrentItem(getContext(), existingUri);
    if (mMarkedPosition != position) {
        int oldPosition = mMarkedPosition;
        mMarkedPosition = position;
        onMarkChanged(oldPosition);
        if (notifyChange) {
            notifyDataSetChanged();
        }
    }
    return position;
}","/**
 * Mark the applied item's position.
 *
 * @param existingUri uri to select, or null to use the currently applied
 *            item.
 * @param notifyChange if true, {@link #notifyDataSetChanged} will be called
 *            on mark change.
 *
 * @see #getMarkedPosition
 */
private int markCurrentOrExistingItem(Uri existingUri, boolean notifyChange) 
{
    if (existingUri == null) {
        existingUri = mAppliedUri;
    }
    int position = getMarkedPosition(existingUri);
    if (position != -1) {
        if (notifyChange) {
            notifyDataSetChanged();
        }
        return position;
    }
    return -1;
}   ",756,True
"/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Uri} with
 * the {@link Cursor} positioned to the first entry.
 *
 * @param context the {@link Context} of the caller.
 * @param uri the {@link Uri} of the item(s).
 * @return an {@link AbstractDAOItem} positioned to the first entry in
 *         the {@link Cursor}. If there are no entries, null is
 *         returned.
 */
public T newInstance(Context context, Uri uri){
    if (uri != null) {
        Cursor c = context.getContentResolver().query(uri, null, null, null, null);
        return newInstance(c);
    }
    return null;
}","/**
 * Creates an {@link AbstractDAOItem} for the specified {@link Uri} with
 * the {@link Cursor} positioned to the first entry.
 *
 * @param context the {@link Context} of the caller.
 * @param uri the {@link Uri} of the item(s).
 * @return an {@link AbstractDAOItem} positioned to the first entry in
 *         the {@link Cursor}. If there are no entries, null is
 *         returned.
 */

public T newInstance(Context context, Uri uri) 
{
    Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
    T item = null;
    if (cursor != null)
    {
        cursor.moveToFirst();
        item = newInstance(cursor);
        cursor.close();
    }
    return item;
}   ",757,True
"/**
 * Creates a theme {@link Uri} for the given theme package and id.
 * @param context the context of the caller.
 * @param packageName the package of the theme.
 * @param themeId the id of the theme.
 * @return
 */
public static Uri getThemeUri(Context context, String packageName, String themeId){
    if (TextUtils.isEmpty(packageName) && TextUtils.isEmpty(themeId)) {
        return ThemeColumns.CONTENT_URI.buildUpon()
                .appendEncodedPath(""system"").build();
    } else {
        return ThemeColumns.CONTENT_URI.buildUpon()
                .appendPath(packageName)
                .appendPath(themeId).build();
    }
}","/**
 * Creates a theme {@link Uri} for the given theme package and id.
 * @param context the context of the caller.
 * @param packageName the package of the theme.
 * @param themeId the id of the theme.
 * @return
 */
public static Uri getThemeUri(Context context, String packageName, String themeId) 
{
    return Uri.parse(""content://"" + context.getPackageName() + ""/theme/"" + packageName + ""/"" + themeId);
}   ",759,True
"/**
 * @return file name inside archive, null if this object is not a file inside archive
 */
public String getArchiveItemName(){
	if ( isArchive && !isDirectory && pathname!=null )
		return pathname;
	return null;
}","/**
 * @return file name inside archive, null if this object is not a file inside archive
 */
public String getArchiveItemName() 
{
    if (isFile())
    {
        return _archiveItemName;
    }
    else
    {
        return null;
    }
}   ",760,True
"// create child item
public TOCItem addChild(){
	if ( mChildren==null )
		mChildren = new ArrayList<TOCItem>();
	TOCItem item = new TOCItem();
	item.mParent = this;
	item.mIndex = mChildren.size();
	mChildren.add(item);
	return item;
}","// create child item
public TOCItem addChild() 
{
    TOCItem child = new TOCItem();
    child.setParent(this);
    children.add(child);
    return child;
}   ",761,True
"/**
 * Read JNI view settings, update and save if changed 
 */
private void syncViewSettings( final Properties currSettings, final boolean save ){
	post( new Task() {
		Properties props;
		public void work() {
			BackgroundThread.ensureBackground();
			java.util.Properties internalProps = getSettingsInternal(); 
			props = new Properties(internalProps);
			props.remove(PROP_EMBEDDED_STYLES);
		}
		public void done() {
			Properties changedSettings = props.diff(currSettings);
	        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
        		currSettings.setProperty((String)entry.getKey(), (String)entry.getValue());
	        }
        	mSettings = currSettings;
        	if ( save )
        		saveSettings(currSettings);
		}
	});
}","/**
 * Read JNI view settings, update and save if changed 
 */
private void syncViewSettings( final Properties currSettings, final boolean save ) 
{
    final Properties newSettings = new Properties();
    newSettings.putAll(currSettings);

    // update view settings
    final int view = getJNIView();
    if (view == 0)
    {
        newSettings.put(""view"", ""0"");
    }
    else if (view == 1)
    {
        newSettings.put(""view"", ""1"");
    }
    else if (view == 2)
    {
        newSettings.put(""view"", ""2"");
    }

    if (save)
    {
        saveProperties(newSettings);
    }
}   ",762,False
"// for dx=0..1 find such alpha (0..pi/2) that alpha - sin(alpha) = dx  
private static double shiftfn( double dx ){
	double a = 0;
	double b = Math.PI/2;
	double c = 0;
	for ( int i=0; i<15; i++ ) {
		c = (a + b) / 2;
		double cq = c - Math.sin(c);
		if ( cq < dx )
			a = c;
		else
			b = c;
	}
	return c;
}","// for dx=0..1 find such alpha (0..pi/2) that alpha - sin(alpha) = dx  
private static double shiftfn( double dx ) 
{
    double alpha = dx;
    for( int i = 0; i < 30; i++ )
    {
        alpha = alpha - (alpha - Math.sin( alpha )) / 2;
    }
    return alpha;
}   ",763,True
"/**
     * Change settings.
 * @param newSettings are new settings
 * @param oldSettings are old settings, null to use mSettings
 * @param save is true to save settings to file, false to skip saving
 */
public void setSettings(Properties newSettings, Properties oldSettings, final boolean save){
	log.v(""setSettings() "" + newSettings.toString());
	BackgroundThread.ensureGUI();
	if ( oldSettings==null )
		oldSettings = mSettings;
	final Properties currSettings = new Properties(oldSettings);
	setAppSettings( newSettings, currSettings );
	Properties changedSettings = newSettings.diff(currSettings);
	currSettings.setAll(changedSettings);
    	mBackThread.executeBackground(new Runnable() {
    		public void run() {
    			applySettings(currSettings, save);
    		}
    	});
//        }","/**
     * Change settings.
 * @param newSettings are new settings
 * @param oldSettings are old settings, null to use mSettings
 * @param save is true to save settings to file, false to skip saving
 */
public void setSettings(Properties newSettings, Properties oldSettings, final boolean save) 
{
    if (oldSettings == null)
    {
        oldSettings = mSettings;
    }
    mSettings = newSettings;

    if (save)
    {
        saveSettings();
    }
}   ",764,True
"/**
 * Same as cmp, but not-null comes first
 * @param str1
 * @param str2
 * @return
 */
private static int cmpNotNullFirst( String str1, String str2 ){
	if ( str1==null && str2==null )
		return 0;
	if ( str1==null )
		return 1;
	if ( str2==null )
		return -1;
	return cmp(str1, str2);
}","/**
 * Same as cmp, but not-null comes first
 * @param str1
 * @param str2
 * @return
 */
private static int cmpNotNullFirst( String str1, String str2 ) 
{
    if (str1 == null && str2 == null)
        return 0;
    if (str1 == null)
        return -1;
    if (str2 == null)
        return 1;
    return str1.compareTo(str2);
}   ",765,True
"/// doesn't copy parent and children
public FileInfo(FileInfo v){
	title = v.title;
	authors = v.authors;
	series = v.series;
	seriesNumber = v.seriesNumber;
	path = v.path;
	filename = v.filename;
	pathname = v.pathname;
	arcname = v.arcname;
	format = v.format;
	size = v.size;
	arcsize = v.arcsize;
	isArchive = v.isArchive;
	isDirectory = v.isDirectory;
	createTime = v.createTime;
	lastAccessTime = v.lastAccessTime;
}","/// doesn't copy parent and children
public FileInfo(FileInfo v) 
{
    this.name = v.name;
    this.path = v.path;
    this.size = v.size;
    this.type = v.type;
    this.lastModified = v.lastModified;
    this.parent = null;
    this.children = null;
}   ",766,True
"/**
 * Compares two strings - with numbers sorted by value.
 * @param str1
 * @param str2
 * @return
 */
private static int cmp( String str1, String str2 ){
	if ( str1==null && str2==null )
		return 0;
	if ( str1==null )
		return -1;
	if ( str2==null )
		return 1;
	
	int p1 = 0;
	int p2 = 0;
	for ( ;; ) {
		if ( p1>=str1.length() ) {
			if ( p2>=str2.length() )
				return 0;
			return 1;
		}
		if ( p2>=str2.length() )
			return -1;
		char ch1 = str1.charAt(p1);
		char ch2 = str2.charAt(p2);
		if ( ch1>='0' && ch1<='9' && ch2>='0' && ch2<='9' ) {
			int n1 = 0;
			int n2 = 0;
			while ( ch1>='0' && ch1<='9' ) {
				p1++;
				n1 = n1 * 10 + (ch1-'0');
				if ( p1>=str1.length() )
					break;
				ch1 = str1.charAt(p1);
			}
			while ( ch2>='0' && ch2<='9' ) {
				p2++;
				n2 = n2 * 10 + (ch2-'0');
				if ( p2>=str2.length() )
					break;
				ch2 = str2.charAt(p2);
			}
			int c = cmp(n1, n2);
			if ( c!=0 )
				return c;
		} else {
			if ( ch1<ch2 )
				return -1;
			if ( ch1>ch2 )
				return 1;
			p1++;
			p2++;
		}
	}
}","/**
 * Compares two strings - with numbers sorted by value.
 * @param str1
 * @param str2
 * @return
 */
private static int cmp( String str1, String str2 ) 
{
    int i = 0;
    int j = 0;
    int num1 = 0;
    int num2 = 0;

    while (i < str1.length() && j < str2.length())
    {
        while (i < str1.length() && !Character.isDigit(str1.charAt(i)))
        {
            i++;
        }
        while (j < str2.length() && !Character.isDigit(str2.charAt(j)))
        {
            j++;
        }

        while (i < str1.length() && Character.isDigit(str1.charAt(i)))
        {
            num1 = num1 * 10 + (str1.charAt(i) - '0');
            i++;
        }

        while (j < str2.length() && Character.isDigit(str2.charAt(j)))
        {
            num2 = num2 * 10 + (str2.charAt(j) - '0');
            j++;
        }

        if (num1 > num2)
        {
            return 1;
        }
        if (num1 < num2)
        {
            return -1;
        }

        num1 = 0;
        num2 = 0;
    }

    return str1.compareTo(str2);
}   ",767,True
"// SurfaceView callbacks
@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width,
		int height){
	log.i(""surfaceChanged("" + width + "", "" + height + "")"");
	drawPage();
}","// SurfaceView callbacks
@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width,
		int height) 
{
	if (mCamera != null)
	{
		Camera.Parameters parameters = mCamera.getParameters();
		parameters.setPreviewSize(mPreviewWidth, mPreviewHeight);
		mCamera.setParameters(parameters);
		mCamera.startPreview();
	}
}	",768,True
"/**
 * Get absolute path to file.
 * For plain files, returns /abs_path_to_file/filename.ext
 * For archives, returns /abs_path_to_archive/arc_file_name.zip@/filename_inside_archive.ext
 * @return full path + filename
 */
public String getPathName(){
	if ( arcname!=null )
		return arcname + ARC_SEPARATOR + pathname;
	return pathname;
}","/**
 * Get absolute path to file.
 * For plain files, returns /abs_path_to_file/filename.ext
 * For archives, returns /abs_path_to_archive/arc_file_name.zip@/filename_inside_archive.ext
 * @return full path + filename
 */
public String getPathName() 
{
    if (isPlainFile())
    {
        return getPlainFilePath();
    }
    else
    {
        return getArchiveFilePath();
    }
}   ",771,True
"//    private void savePosition()
//    {
//		BackgroundThread.ensureBackground();
//    	if ( !mOpened )
//    		return;
//    	Bookmark bmk = getCurrentPageBookmarkInternal();
//    	if ( bmk!=null )
//    		log.d(""saving position, bmk="" + bmk.getStartPos());
//    	else
//    		log.d(""saving position: no current page bookmark obtained"");
//    	if ( bmk!=null && mBookInfo!=null ) {
//        	bmk.setTimeStamp(System.currentTimeMillis());
//    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
//    		mBookInfo.setLastPosition(bmk);
//    		mActivity.getHistory().updateRecentDir();
//    		mActivity.getHistory().saveToDB();
//    		saveSettings();
//    	}
//    }
public Bookmark saveCurrentPositionBookmarkSync( boolean saveToDB ){
        Bookmark bmk = mBackThread.callBackground(new Callable<Bookmark>() {
            @Override
            public Bookmark call() throws Exception {
                if ( !mOpened )
                    return null;
                return getCurrentPageBookmarkInternal();
            }
        });
        if ( bmk!=null ) {
            bmk.setTimeStamp(System.currentTimeMillis());
            bmk.setType(Bookmark.TYPE_LAST_POSITION);
            if ( mBookInfo!=null )
                mBookInfo.setLastPosition(bmk);
            if ( saveToDB ) {
                mActivity.getHistory().updateRecentDir();
                mActivity.getHistory().saveToDB();
                mActivity.getDB().flush();
            }
        }
        return bmk;
    }","//    private void savePosition()
//    {
//		BackgroundThread.ensureBackground();
//    	if ( !mOpened )
//    		return;
//    	Bookmark bmk = getCurrentPageBookmarkInternal();
//    	if ( bmk!=null )
//    		log.d(""saving position, bmk="" + bmk.getStartPos());
//    	else
//    		log.d(""saving position: no current page bookmark obtained"");
//    	if ( bmk!=null && mBookInfo!=null ) {
//        	bmk.setTimeStamp(System.currentTimeMillis());
//    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
//    		mBookInfo.setLastPosition(bmk);
//    		mActivity.getHistory().updateRecentDir();
//    		mActivity.getHistory().saveToDB();
//    		saveSettings();
//    	}
//    }
public Bookmark saveCurrentPositionBookmarkSync( boolean saveToDB ) 
{
	Bookmark bmk = getCurrentPageBookmarkInternal();
	if ( bmk!=null ) {
		bmk.setTimeStamp(System.currentTimeMillis());
		bmk.setType(Bookmark.TYPE_LAST_POSITION);
		if ( saveToDB ) {
			mBookInfo.setLastPosition(bmk);
			mActivity.getHistory().updateRecentDir();
			mActivity.getHistory().saveToDB();
		}
		saveSettings();
	}
	return bmk;
}   ",772,True
"/**
 * @return true if item (file, directory, or archive) exists
 */
public boolean exists(){
	if ( isArchive ) {
		if ( arcname==null )
			return false;
		File f = new File(arcname);
		return f.exists();
	}
	File f = new File(pathname);
	return f.exists();
}","/**
 * @return true if item (file, directory, or archive) exists
 */
public boolean exists() 
{
    if (this.item == null)
    {
        return false;
    }
    else
    {
        return this.item.exists();
    }
}   ",773,True
"/**
 * Prepare and cache page image.
 * Cache is represented by two slots: mCurrentPageInfo and mNextPageInfo.  
 * If page already exists in cache, returns it (if current page requested, 
 *  ensures that it became stored as mCurrentPageInfo; if another page requested, 
 *  no mCurrentPageInfo/mNextPageInfo reordering made).
 * @param offset is kind of page: 0==current, -1=previous, 1=next page
 * @return page image and properties, null if requested page is unavailable (e.g. requested next/prev page is out of document range)
 */
private BitmapInfo preparePageImage( int offset ){
	BackgroundThread.ensureBackground();
	log.v(""preparePageImage( ""+offset+"")"");
	if ( invalidImages ) {
		if ( mCurrentPageInfo!=null )
			mCurrentPageInfo.recycle();
		mCurrentPageInfo = null;
		if ( mNextPageInfo!=null )
			mNextPageInfo.recycle();
		mNextPageInfo = null;
		invalidImages = false;
	}

	if ( internalDX==0 || internalDY==0 ) {
		internalDX=200;
		internalDY=300;
        resizeInternal(internalDX, internalDY);
	}
	
	PositionProperties currpos = getPositionPropsInternal(null);
	
	boolean isPageView = currpos.pageMode!=0;
	
	BitmapInfo currposBitmap = null;
	if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(currpos) )
		currposBitmap = mCurrentPageInfo;
	else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(currpos) )
		currposBitmap = mNextPageInfo;
	if ( offset==0 ) {
		// Current page requested
		if ( currposBitmap!=null ) {
			if ( mNextPageInfo==currposBitmap ) {
				// reorder pages
				BitmapInfo tmp = mNextPageInfo;
				mNextPageInfo = mCurrentPageInfo;
				mCurrentPageInfo = tmp;
			}
			// found ready page image
			return mCurrentPageInfo;
		}
		if ( mCurrentPageInfo!=null ) {
			mCurrentPageInfo.recycle();
			mCurrentPageInfo = null;
		}
		BitmapInfo bi = new BitmapInfo();
        bi.position = currpos;
		bi.bitmap = factory.get(internalDX, internalDY);
        setBatteryStateInternal(mBatteryState);
        getPageImageInternal(bi.bitmap);
        mCurrentPageInfo = bi;
        //log.v(""Prepared new current page image "" + mCurrentPageInfo);
        return mCurrentPageInfo;
	}
	if ( isPageView ) {
		// PAGES: one of next or prev pages requested, offset is specified as param 
		int cmd1 = offset > 0 ? ReaderCommand.DCMD_PAGEDOWN.nativeId : ReaderCommand.DCMD_PAGEUP.nativeId;
		int cmd2 = offset > 0 ? ReaderCommand.DCMD_PAGEUP.nativeId : ReaderCommand.DCMD_PAGEDOWN.nativeId;
		if ( offset<0 )
			offset = -offset;
		if ( doCommandInternal(cmd1, offset) ) {
			// can move to next page
			PositionProperties nextpos = getPositionPropsInternal(null);
			BitmapInfo nextposBitmap = null;
			if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
				nextposBitmap = mCurrentPageInfo;
			else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
				nextposBitmap = mNextPageInfo;
			if ( nextposBitmap==null ) {
				// existing image not found in cache, overriding mNextPageInfo
				if ( mNextPageInfo!=null )
					mNextPageInfo.recycle();
				mNextPageInfo = null;
				BitmapInfo bi = new BitmapInfo();
		        bi.position = nextpos;
				bi.bitmap = factory.get(internalDX, internalDY);
		        setBatteryStateInternal(mBatteryState);
		        getPageImageInternal(bi.bitmap);
		        mNextPageInfo = bi;
		        nextposBitmap = bi;
		        //log.v(""Prepared new current page image "" + mNextPageInfo);
			}
			// return back to previous page
			doCommandInternal(cmd2, offset);
			return nextposBitmap;
		} else {
			// cannot move to page: out of document range
			return null;
		}
	} else {
		// SCROLL next or prev page requested, with pixel offset specified
		int y = currpos.y + offset;
		if ( doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, y) ) {
			PositionProperties nextpos = getPositionPropsInternal(null);
			BitmapInfo nextposBitmap = null;
			if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
				nextposBitmap = mCurrentPageInfo;
			else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
				nextposBitmap = mNextPageInfo;
			if ( nextposBitmap==null ) {
				// existing image not found in cache, overriding mNextPageInfo
				if ( mNextPageInfo!=null )
					mNextPageInfo.recycle();
				mNextPageInfo = null;
				BitmapInfo bi = new BitmapInfo();
		        bi.position = nextpos;
				bi.bitmap = factory.get(internalDX, internalDY);
		        setBatteryStateInternal(mBatteryState);
		        getPageImageInternal(bi.bitmap);
		        mNextPageInfo = bi;
		        nextposBitmap = bi;
			}
			// return back to prev position
			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, currpos.y);
			return nextposBitmap;
		} else {
			return null;
		}
	}
	
}","/**
 * Prepare and cache page image.
 * Cache is represented by two slots: mCurrentPageInfo and mNextPageInfo.  
 * If page already exists in cache, returns it (if current page requested, 
 *  ensures that it became stored as mCurrentPageInfo; if another page requested, 
 *  no mCurrentPageInfo/mNextPageInfo reordering made).
 * @param offset is kind of page: 0==current, -1=previous, 1=next page
 * @return page image and properties, null if requested page is unavailable (e.g. requested next/prev page is out of document range)
 */
private BitmapInfo preparePageImage( int offset ) 
{
    BitmapInfo bi = null;
    if ( offset == 0 )
    {
        if ( mCurrentPageInfo != null )
        {
            bi = mCurrentPageInfo;
            mCurrentPageInfo = null;
        }
        else
        {
            bi = mNextPageInfo;
            mNextPageInfo = null;
        }
    }
    else if ( offset == -1 )
    {
        if ( mNextPageInfo != null )
        {
            bi = mNextPageInfo;
            mNextPageInfo = null;
        }
        else
        {
            bi = mCurrentPageInfo;
            mCurrentPageInfo = null;
        }
    }
    else if ( offset == 1 )
    {
        if ( mCurrentPageInfo != null )
        {
            bi = mCurrentPageInfo;
            mCurrentPageInfo = null;
        }
        else
        {
            bi = mNextPageInfo;
            mNextPageInfo = null;
        }
    }

    if ( bi != null )
    {
        return bi;
    }

    return null;
}   ",775,False
"/**
 * When current book is opened, switch to previous book.
 * @param errorHandler
 * @return
 */
public boolean loadPreviousDocument( final Runnable errorHandler ){
	BackgroundThread.ensureGUI();
	BookInfo bi = mActivity.getHistory().getPreviousBook();
	if (bi!=null && bi.getFileInfo()!=null) {
		save();
		close();
		log.i(""loadPreviousDocument() is called, prevBookName = "" + bi.getFileInfo().getPathName());
		return loadDocument( bi.getFileInfo().getPathName(), errorHandler );
	}
	errorHandler.run();
	return false;
}","/**
 * When current book is opened, switch to previous book.
 * @param errorHandler
 * @return
 */
public boolean loadPreviousDocument( final Runnable errorHandler ) 
{
    if ( !hasPreviousDocument() )
    {
        return false;
    }

    return loadDocument( getPreviousDocument(), errorHandler );
}   ",777,False
"/**
 * Constructs a polynomial with the given coefficients.
 * 
 * @param coef
 *            polynomial coefficients.
 */
public Polynomial(final String[] coef){
	coefficients = new double[coef.length];
	for (int i = 0, n = coef.length; i < n; i++) {
		try {
			coefficients[i] = Double.parseDouble(coef[i]);
		} catch (NumberFormatException ex) {
			coefficients[i] = 0;
		}
	}
}","/**
 * Constructs a polynomial with the given coefficients.
 * 
 * @param coef
 *            polynomial coefficients.
 */
public Polynomial(final String[] coef) 
{
    this.coef = new double[coef.length];
    for (int i = 0; i < coef.length; i++)
    {
        this.coef[i] = Double.parseDouble(coef[i]);
    }
}   ",780,True
"/**
 * Deflates the polynomial by removing the root.
 * 
 * @param r
 *            double a root of the polynomial (no check made).
 * @return Polynomial the receiver divided by polynomial (x - r).
 */
public Polynomial deflate(final double r){
	int n = degree();
	double remainder = coefficients[n];
	double[] coef = new double[n];
	for (int k = n - 1; k >= 0; k--) {
		coef[k] = remainder;
		remainder = remainder * r + coefficients[k];
	}
	return new Polynomial(coef);
}","/**
 * Deflates the polynomial by removing the root.
 * 
 * @param r
 *            double a root of the polynomial (no check made).
 * @return Polynomial the receiver divided by polynomial (x - r).
 */
public Polynomial deflate(final double r) 
{
    int n = degree();
    double[] newc = new double[n];
    for (int i = n; i > 0; i--)
    {
        newc[i - 1] = c[i] - r * c[i - 1];
    }
    return new Polynomial(newc);
}   ",783,False
"/**
 * Multiplies this polynomial by another polynomial.
 * 
 * @param p
 *            Polynomial
 * @return Polynomial
 */
public Polynomial multiply(final Polynomial p){
	int n = p.degree() + degree();
	double[] coef = new double[n + 1];
	for (int i = 0; i <= n; i++) {
		coef[i] = 0;
		for (int k = 0; k <= i; k++) {
			coef[i] += p.coefficient(k) * coefficient(i - k);
		}
	}
	return new Polynomial(coef);
}","/**
 * Multiplies this polynomial by another polynomial.
 * 
 * @param p
 *            Polynomial
 * @return Polynomial
 */
public Polynomial multiply(final Polynomial p) 
{
    final Polynomial result = new Polynomial();
    for (final Term t1 : this.terms)
    {
        for (final Term t2 : p.terms)
        {
            final Term t = t1.multiply(t2);
            result.add(t);
        }
    }
    return result;
}   ",784,True
"/**
 * Gets an array containing the frequencies in natural order. Data are
 * separated by delta.
 * 
 * @param delta
 * @return the array of frequencies
 */
public double[] getNaturalFreq(final double delta){
	int n = this.n / 2;
	double[] freq = new double[n];
	double f = 0, df = 0.5 / n / delta;
	for (int i = 0; i < n; i++) {
		freq[i] = f;
		f += df;
	}
	return freq;
}","/**
 * Gets an array containing the frequencies in natural order. Data are
 * separated by delta.
 * 
 * @param delta
 * @return the array of frequencies
 */
public double[] getNaturalFreq(final double delta) 
{
    final double[] freq = new double[getCount()];
    for (int i = 0; i < freq.length; i++)
    {
        freq[i] = getNaturalFreq(i) + delta;
    }
    return freq;
}   ",786,True
"/**
 * Gets the derivative of this polynomial.
 * 
 * @return Polynomial the derivative.
 */
public Polynomial derivative(){
	int n = degree();
	if (n == 0) {
		double coef[] = { 0 };
		return new Polynomial(coef);
	}
	double coef[] = new double[n];
	for (int i = 1; i <= n; i++) {
		coef[i - 1] = coefficients[i] * i;
	}
	return new Polynomial(coef);
}","/**
 * Gets the derivative of this polynomial.
 * 
 * @return Polynomial the derivative.
 */
public Polynomial derivative() 
{
    Polynomial derivative = new Polynomial();
    for (int i = 1; i < coefficients.length; i++)
    {
        derivative.setCoefficient(i - 1, coefficients[i] * i);
    }
    return derivative;
}   ",792,True
"/**
 * Gets the roots of this polynomial.
 * 
 * @param desiredPrecision
 *            double
 * @return double[]
 */
public double[] roots(final double desiredPrecision){
	double start = 0;
	if (degree() < 1) {
		return new double[0];
	}
	Polynomial dp = derivative();
	int counter = 0;
	while (counter < 100 && Math.abs(dp.evaluate(start)) < desiredPrecision) {
		start = Math.random();
		counter++;
	}
	Polynomial p = this;
	ArrayList<Double> list = new ArrayList<Double>(degree());
	while (true) {
		double r = Root.newton(p, dp, start, desiredPrecision);
		if (Double.isNaN(r)) {
			break;
		}
		list.add(new Double(r));
		p = p.deflate(r);
		if (p.degree() == 0) {
			break;
		}
		dp = p.derivative();
		start = 0;
		counter = 0;
		while (counter < 100
				&& Math.abs(dp.evaluate(start)) < desiredPrecision) {
			start = Math.random();
			counter++;
		}
	}
	double[] roots = new double[list.size()];
	for (int i = 0, n = list.size(); i < n; i++) {
		roots[i] = ((Double) list.get(i)).doubleValue();
	}
	return roots;
}","/**
 * Gets the roots of this polynomial.
 * 
 * @param desiredPrecision
 *            double
 * @return double[]
 */
public double[] roots(final double desiredPrecision) 
{
    final double[] roots = new double[getNumberOfRoots()];
    final Complex[] complexRoots = getComplexRoots(desiredPrecision);
    for (int i = 0; i < complexRoots.length; i++)
    {
        roots[i] = complexRoots[i].getReal();
    }
    return roots;
}   ",795,False
"/**
 * Evaluates a polynomial using the given coefficients.
 * 
 * @param x
 * @param coeff
 *            the polynomial coefficients.
 */
public static double evalPolynomial(final double x, final double[] coeff){
	int n = coeff.length - 1;
	double y = coeff[n];
	for (int i = n - 1; i >= 0; i--) {
		y = coeff[i] + (y * x);
	}
	return y;
}","/**
 * Evaluates a polynomial using the given coefficients.
 * 
 * @param x
 * @param coeff
 *            the polynomial coefficients.
 */
public static double evalPolynomial(final double x, final double[] coeff) 
{
    double y = coeff[0];
    for (int i = 1; i < coeff.length; i++)
    {
        y = y * x + coeff[i];
    }
    return y;
}   ",796,True
"/**
 * Sets the number of data points.
 * 
 * @param n
 *            int
 */
public void setN(final int n){
	if (n % 2 != 0) {
		throw new IllegalArgumentException(n + "" is not even"");
	}
	this.n = n;
	fft.setN(n / 2);
}","/**
 * Sets the number of data points.
 * 
 * @param n
 *            int
 */
public void setN(final int n) 
{
    if (n < 1)
    {
        throw new IllegalArgumentException(""Number of data points must be at least 1"");
    }
    this.n = n;
}   ",799,True
"/**
 * Adds a prebuild belt of bumpers sensor to the agent.
 * @param agent
 * @return the sensor object
 */
static public RangeSensorBelt addBumperBeltSensor(Agent agent){
   // double agentHeight = agent.getHeight();
    double agentRadius = agent.getRadius();
    RangeSensorBelt bumperBelt = new RangeSensorBelt((float) agentRadius-0.1f,
            0f, 0.2f, 9, RangeSensorBelt.TYPE_BUMPER,0);
    bumperBelt.setUpdatePerSecond(6);
    bumperBelt.setName(""bumpers"");
    Vector3d pos = new Vector3d(0, 0, 0.0);
    agent.addSensorDevice(bumperBelt, pos, 0);
    return bumperBelt;
}","/**
 * Adds a prebuild belt of bumpers sensor to the agent.
 * @param agent
 * @return the sensor object
 */
static public RangeSensorBelt addBumperBeltSensor(Agent agent) 
{
    RangeSensorBelt bumper = new RangeSensorBelt((short) 0, (short) 0, (short) 0, (short) 0, RangeSensorBelt.TYPE_BUMPER);
    agent.addSensorDevice(bumper);
    return bumper;
}   ",804,True
"/**
 * Adds a prebuild light sensor  to the agent.
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensor(Agent agent){
    double agentHeight = agent.getHeight();
    LightSensor sensor = new LightSensor();
    sensor.setUpdatePerSecond(3);
    sensor.setName(""Light Sensor"");
    Vector3d pos = new Vector3d(0.0, (agentHeight / 2), 0);
    agent.addSensorDevice(sensor, pos, -Math.PI / 2);
    return sensor;
}","/**
 * Adds a prebuild light sensor  to the agent.
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensor(Agent agent) 
{
	LightSensor sensor = new LightSensor();
	agent.addSensor(sensor);
	return sensor;
}   ",805,True
"/** Sets the kinematic model to be DifferentialDrive (instead of DefaultKinematic)
 * @param agent
 */
static public DifferentialKinematic setDifferentialDriveKinematicModel(Agent agent){
   agent.setKinematicModel(new DifferentialKinematic(agent.getRadius()));
   return (DifferentialKinematic)agent.getKinematicModel();
}","/** Sets the kinematic model to be DifferentialDrive (instead of DefaultKinematic)
 * @param agent
 */
static public DifferentialKinematic setDifferentialDriveKinematicModel(Agent agent) 
{
    if (agent.getKinematicModel() instanceof DifferentialKinematic)
    {
        return (DifferentialKinematic)agent.getKinematicModel();
    }
    else
    {
        DifferentialKinematic differentialKinematic = new DifferentialKinematic(agent);
        agent.setKinematicModel(differentialKinematic);
        return differentialKinematic;
    }
}   ",806,True
"/**
 * Construct an AppleAgent.
 * @param pos
 * @param name
 */
public CherryAgent(Vector3d pos, String name, float radius){
    super(pos, name);
    // to avoid collision indication
    setCanBeTraversed(true);

    this.radius = radius;
    this.height = 2 * radius;
    this.color = new Color3f(0.8f, 0, 0);
  

}","/**
 * Construct an AppleAgent.
 * @param pos
 * @param name
 */
public CherryAgent(Vector3d pos, String name, float radius) 
{
	super(pos, name, radius);
}   ",807,True
"/**
 * Adds a prebuild light sensor on the right of the agent .
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensorRight(Agent agent){
    Vector3d front = new Vector3d(agent.getRadius()+0.5, 0, 0);
    Transform3D t3d = new Transform3D();
    t3d.rotY(-Math.PI / 4);
    Vector3d right = new Vector3d(front);
    t3d.transform(right);
    return RobotFactory.addLightSensor(agent, right, (float) -Math.PI / 4,
            ""left"");
}","/**
 * Adds a prebuild light sensor on the right of the agent .
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensorRight(Agent agent) 
{
    LightSensor sensor = new LightSensor();
    agent.addSensorDevice(sensor, 270, 0, 0);
    return sensor;
}   ",809,True
"/** Constructs a line object.
 * 
 * @param pos position of the start of the object. 
 * @param len length of the object.
 * @param wd	EnvironmentDescription for global parameters.
 * @param color  color of the object.
 */
public Line(Vector3d pos, float len, EnvironmentDescription wd, Color3f color){
	super();
	this.len = len;
    // put it on the floor
    pos.z += len/2;
	setCanBeTraversed(true);
    create3D(wd,color);
    translateTo(pos);
}","/** Constructs a line object.
 * 
 * @param pos position of the start of the object. 
 * @param len length of the object.
 * @param wd	EnvironmentDescription for global parameters.
 * @param color  color of the object.
 */
public Line(Vector3d pos, float len, EnvironmentDescription wd, Color3f color) 
{
	this.pos = pos;
	this.len = len;
	this.wd = wd;
	this.color = color;
}   ",810,True
"/* should not be called too often */
protected void paintComponent( Graphics g){
   super.paintComponent(g);
   copyVisionImage(bim);
   g.drawImage(bim, 0, 0, null);
    	       
        }","/* should not be called too often */
protected void paintComponent( Graphics g) 
{
    super.paintComponent(g);
    if (image != null)
    {
        g.drawImage(image, 0, 0, null);
    }
}   ",811,True
"/** for allocating a working copy of the vision image */
final public BufferedImage createCompatibleImage(){
    return  new BufferedImage(imageWidth, imageHeight,
            BufferedImage.TYPE_INT_RGB);
}","/** for allocating a working copy of the vision image */
final public BufferedImage createCompatibleImage() 
{
    if (workingImage == null)
    {
        workingImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);
    }
    return workingImage;
}   ",812,True
"/**
 * Adds a prebuild key  input  to the agent.
 * @param agent
 * @return the sensor object
 */
static public KeyInputSensor addKeyInputSensor(Agent agent){
    KeyInputSensor sensor = new KeyInputSensor();
  
    sensor.setUpdatePerSecond(3);
    sensor.setName(""key input"");
    // position has no meaning in the case of that sensor.
    Vector3d pos = new Vector3d(0, 0.0, 0.0);
    agent.addSensorDevice(sensor, pos, 0);
    return sensor;
}","/**
 * Adds a prebuild key  input  to the agent.
 * @param agent
 * @return the sensor object
 */
static public KeyInputSensor addKeyInputSensor(Agent agent) 
{
    KeyInputSensor sensor = new KeyInputSensor();
    agent.addSensor(sensor);
    return sensor;
}   ",813,True
"/**
 * Adds a prebuild lamp actuator on the top  of the agent .
 * @param agent
 * @return the actuator object
 */
static public LampActuator addLamp(Agent agent){
    LampActuator la = new LampActuator(0.15f);
    la.setName(""lamp"");
    la.setUpdatePerSecond(5f);
    agent.addActuatorDevice(la, new Vector3d(0,agent.getHeight(),0),0);
   
    return la;
}","/**
 * Adds a prebuild lamp actuator on the top  of the agent .
 * @param agent
 * @return the actuator object
 */
static public LampActuator addLamp(Agent agent) 
{
    LampActuator lamp = new LampActuator();
    agent.addActuator(lamp);
    return lamp;
}   ",814,True
"/**
 * Request to fill a SensorMatrix with last capture.
 * @param matrix  - to be filled
 */
final public synchronized void copyVisionImage(SensorMatrix matrix){
    visionImage.getRGB(0,0,imageWidth,imageHeight,tempRGBABuffer,0,imageWidth);
    float array[] = matrix.getArray();
        for (int i = 0; i < array.length; i++) {
            int pix = tempRGBABuffer[i];
            int r = (pix >> 16) & 0xff;
            int g = (pix >> 8) & 0xff;
            int b = (pix) & 0xff;
            array[i] = (float) (r + g + b) / (3.0f * 255.0f);
        }
   
}","/**
 * Request to fill a SensorMatrix with last capture.
 * @param matrix  - to be filled
 */
final public synchronized void copyVisionImage(SensorMatrix matrix) 
{
    if (visionImage != null)
    {
        visionImage.copyTo(matrix);
    }
}   ",815,False
"/**
 * Adds a prebuild light sensor on the left of the agent .
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensorLeft(Agent agent){
    Vector3d front = new Vector3d(agent.getRadius()+0.5, 0, 0);
    Transform3D t3d = new Transform3D();
    t3d.rotY(Math.PI / 4);
    Vector3d left = new Vector3d(front);
    t3d.transform(left);
    return RobotFactory.addLightSensor(agent, left, (float) Math.PI / 4,
            ""left"");
}","/**
 * Adds a prebuild light sensor on the left of the agent .
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensorLeft(Agent agent) 
{
    LightSensor lightSensor = new LightSensor();
    agent.addSensorDevice(lightSensor, 0);
    return lightSensor;
}   ",816,True
"/**
 * Adds a prebuild light sensor  to the agent at a given position.
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensor(Agent agent, Vector3d pos,
        float angle, String label){
    LightSensor sensor = new LightSensor();
    sensor.setUpdatePerSecond(3);
    sensor.setName(""Light Sensor "" + label);
    agent.addSensorDevice(sensor, pos, angle);
    return sensor;
}","/**
 * Adds a prebuild light sensor  to the agent at a given position.
 * @param agent
 * @return the sensor object
 */
static public LightSensor addLightSensor(Agent agent, Vector3d pos,
        float angle, String label) 
{
    LightSensor sensor = new LightSensor(pos, angle, label);
    agent.addSensor(sensor);
    return sensor;
}       ",818,True
"/**
 * Adds a prebuild camera sensor to the agent. Image resolution is 100x100 pixels.
 * Camera is situated on the top of the agent.
 * @param agent
 * @return the sensor object
 */
static public CameraSensor addCameraSensor(Agent agent){
    double agentHeight = agent.getHeight();
    float cameraBodyRadius = 0.1f;
    CameraSensor camera = new CameraSensor(cameraBodyRadius, 100, 100);
    camera.setUpdatePerSecond(3);
    camera.setName(""Camera"");
    Vector3d pos = new Vector3d(0.0, (agentHeight / 2)
            + (cameraBodyRadius * 3) / 4, 0);
    agent.addSensorDevice(camera, pos, 0);
    return camera;
}","/**
 * Adds a prebuild camera sensor to the agent. Image resolution is 100x100 pixels.
 * Camera is situated on the top of the agent.
 * @param agent
 * @return the sensor object
 */
static public CameraSensor addCameraSensor(Agent agent) 
{
    CameraSensor sensor = new CameraSensor();
    sensor.setResolution(100, 100);
    agent.addSensor(sensor);
    return sensor;
}   ",819,True
"/**
 * Get the distance to another coordinate.
 * <p>Only X, Y and Z values are used in this calculation.
 * @param to
 * @return
 */
public double distance(NumericCoordinate to){
	double dx = getValue(Axis.X, 0.0) - to.getValue(Axis.X, 0.0);
	double dy = getValue(Axis.Y, 0.0) - to.getValue(Axis.Y, 0.0);
	double dz = getValue(Axis.Z, 0.0) - to.getValue(Axis.Z, 0.0);
	return Math.sqrt(dx*dx + dy*dy + dz*dz);
}","/**
 * Get the distance to another coordinate.
 * <p>Only X, Y and Z values are used in this calculation.
 * @param to
 * @return
 */
public double distance(NumericCoordinate to) 
{
    double dx = to.getX() - x;
    double dy = to.getY() - y;
    double dz = to.getZ() - z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
}   ",820,True
"/** Generate the toolpath for a single X or Y line, depending on the angle. */
private void doLine(List<Seg> segments, Surface img, double i, double level, boolean pos){
	// Get the available line segments
	ArrayList<Double> points = sliceLine(img, i, level, pos);
	
	// Check if we have anything to do
	if(points.isEmpty())
		return;
	
	if(angle==0)
		i = -i;
	
	for(int j=0;j<points.size();j+=2) {
		segments.add(new Seg(i, points.get(j), points.get(j+1)));
	}
}","/** Generate the toolpath for a single X or Y line, depending on the angle. */
private void doLine(List<Seg> segments, Surface img, double i, double level, boolean pos) 
{
    Seg seg = new Seg();
    seg.p1 = new Point2D.Double(i, level);
    seg.p2 = new Point2D.Double(i, img.getHeight() - level);
    if (pos)
        seg.p1.x += 1;
    else
        seg.p1.x -= 1;
    segments.add(seg);
}   ",822,False
"/**
 * Parameters: <code>rough <var>passdepth</var> <var>angle</var> <var>direction</var></code>,
 * where direction can be one of POS, NEG or ALT.
 * @param image
 * @param params
 */
public RoughStrategy(Image image, String params){
	this.image = image;
	String[] param = params.split("" "");
	if(param.length!=3)
		throw new IllegalArgumentException(""RoughStrategy takes 0 or 3 parameters!"");

	passdepth = Double.parseDouble(param[0]);
	if(passdepth<0)
		throw new IllegalArgumentException(""Pass depth must be positive!"");

	angle = Integer.parseInt(param[1]);
	if(angle!=0 && angle!=90)
		throw new IllegalArgumentException(""Only angles 0 and 90 are supported!"");
	
	try {
		dir = Dir.valueOf(param[2].toUpperCase());
	} catch(IllegalArgumentException e) {
		throw new IllegalArgumentException(""Direction \"""" + param[1] + ""\"" not supported!"");
	}		
}","/**
 * Parameters: <code>rough <var>passdepth</var> <var>angle</var> <var>direction</var></code>,
 * where direction can be one of POS, NEG or ALT.
 * @param image
 * @param params
 */
public RoughStrategy(Image image, String params) 
{
    this.image = image;
    String[] param = params.split("" "");
    this.rough = Double.parseDouble(param[1]);
    this.passdepth = Double.parseDouble(param[2]);
    this.angle = Double.parseDouble(param[3]);
    this.direction = param[4];
}   ",823,True
"/**
 * Set the top-center coordinates for the helix.
 * If Z coordinate is omitted, 0 is used for the top.
 * @param origin
 * @return
 */
public Helix origin(String origin){
	Coordinate c = Coordinate.parse(origin);
	if(!(c instanceof NumericCoordinate))
		throw new IllegalArgumentException(""Helix supports only numeric coordinates!"");
	this.origin = (NumericCoordinate)c;
	if(!this.origin.isDefined(Axis.Z))
		this.origin.set(Axis.Z, 0.0);
	return this;
}","/**
 * Set the top-center coordinates for the helix.
 * If Z coordinate is omitted, 0 is used for the top.
 * @param origin
 * @return
 */
public Helix origin(String origin) 
{
    this.origin = new Coordinate(origin);
    return this;
}   ",825,True
"/**
 * Set the depth of a single pass
 * @param depth
 * @return
 */
public Helix pass(double depth){
	this.passdepth = depth;
	return this;
}","/**
 * Set the depth of a single pass
 * @param depth
 * @return
 */
public Helix pass(double depth) 
{
    this.depth = depth;
    return this;
}   ",826,True
"/**
 * A constructor with defaults for x,y and z axises.
 * @param x
 * @param y
 * @param z
 */
public NumericCoordinate(Double x, Double y, Double z){
	this();
	if(x!=null)
		axes.put(Axis.X, x);
	if(y!=null)
		axes.put(Axis.Y, y);
	if(z!=null)
		axes.put(Axis.Z, z);
}","/**
 * A constructor with defaults for x,y and z axises.
 * @param x
 * @param y
 * @param z
 */
public NumericCoordinate(Double x, Double y, Double z) 
{
    this.x = x;
    this.y = y;
    this.z = z;
}   ",829,True
"/**
 * Return a copy of this coordinate set converted
 * to symbolic coordinates.
 * @return this set as symbolic coordinates
 */
public SymbolicCoordinate toSymbolic(){
	EnumMap<Axis, String> axes = new EnumMap<Axis, String>(Axis.class);
	for(Axis a : this.axes.keySet())
		axes.put(a, get(a));
	return new SymbolicCoordinate(axes);
}","/**
 * Return a copy of this coordinate set converted
 * to symbolic coordinates.
 * @return this set as symbolic coordinates
 */
public SymbolicCoordinate toSymbolic() 
{
    return new SymbolicCoordinate(
        this.x.toSymbolic(),
        this.y.toSymbolic(),
        this.z.toSymbolic()
    );
}   ",831,True
"/**
 * Extract coordinates from a g-code fragment.
 * Coordinates can be in forms like:
 * <ul>
 * <li>A0.0
 * <li>A[0.0]
 * <li>A#1
 * <li>A#&lt;_var&gt;
 * <li>A[#1+1.0]
 * <li>A[sin[#0]+#3]
 * <li>A-[-1]
 * </ul>
 * @param gcode
 */
static public Coordinate parse(String gcode){
	if(gcode.length()==0)
		return new NumericCoordinate();
	
	EnumMap<Axis, String> coords = new EnumMap<Axis, String>(Axis.class);
	Axis axis = null;
	StringBuilder cb = new StringBuilder();
	
	/* states:
	 * 0 - expect variable or number or block start ([)
	 * 1 - expect variable (numeric or named)
	 * 2 - expect end of numeric constant
	 * 3 - expect end of named variable (>)
	 */
	Stack<Integer> states = new Stack<Integer>();
	
	int i=-1;
	while(++i<gcode.length()) {
		char chr = gcode.charAt(i);
		if(Character.isWhitespace(chr))
			continue;
		
		if(states.isEmpty()) {
			if(axis!=null) {
				char last = cb.charAt(cb.length()-1); 
				if(last!=']' && last!='>')
					cb.delete(cb.length()-1, cb.length());
				coords.put(axis, cb.toString());
				cb.delete(0, cb.length());
			}
			// Expect axis
			Axis a = Axis.get(chr);
			if(a!=null)
				axis = a;
			else
				throw new IllegalArgumentException(gcode + "" ("" + chr + ""): Expected axis"");
			states.push(0);
		} else {
			cb.append(chr);
			int state = states.peek();
			switch(state) {
			case 0:
				states.pop();
				// axis value start
				if(chr=='[')
					states.push(4);
				else if(chr=='#')
					states.push(1);
				else if(Character.isDigit(chr) || chr=='-')
					states.push(2);
				else
					throw new IllegalArgumentException(chr + "": Expected number, variable or parenthesis"");
				break;
			case 1:
				// Expect variable start
				states.pop();
				if(chr=='<')
					states.push(3);
				else if(Character.isDigit(chr))
					states.push(2);
				else
					throw new IllegalArgumentException(""Expected numeric constant or named variable"");
				break;
			case 2:
				// Expect end of numeric constant
				if(!(chr=='-' || chr=='.' || Character.isDigit(chr))) {
					states.pop();
					// - sign can come before [ too
					if(chr=='[' && gcode.charAt(i-1)=='-')
						states.push(4);
					else
						--i;
				}
				break;
			case 3:
				// Expect end of named variable
				if(chr=='>') {
					states.pop();
				}
				break;
			case 4:
				// Expect end of parenthetical block (])
				if(chr=='[')
					states.push(4);
				else if(chr==']') {
					states.pop();
				}
				break;
			default: throw new RuntimeException(""BUG: Unhandled state "" + state);
			}
		}
	}
	
	// Add the last axis
	coords.put(axis, cb.toString());

	boolean allnumeric = true;
	for(String s : coords.values()) {
		if(!isnumeric.matcher(s).matches()) {
			allnumeric = false;
			break;
		}
	}
	
	if(allnumeric) {
		NumericCoordinate c = new NumericCoordinate();
		for(Map.Entry<Axis, String> a : coords.entrySet())
			c.set(a.getKey(), Double.valueOf(a.getValue()));
		return c;
	} else
		return new SymbolicCoordinate(coords);
}","/**
 * Extract coordinates from a g-code fragment.
 * Coordinates can be in forms like:
 * <ul>
 * <li>A0.0
 * <li>A[0.0]
 * <li>A#1
 * <li>A#&lt;_var&gt;
 * <li>A[#1+1.0]
 * <li>A[sin[#0]+#3]
 * <li>A-[-1]
 * </ul>
 * @param gcode
 */

static public Coordinate parse(String gcode) 
{
    Matcher m = Pattern.compile(""^(\\w+)(\\d+\\.\\d+|\\d+|#\\w+|[#\\+\\-]\\d+\\.\\d+)$"").matcher(gcode);
    if (!m.find()) {
        return null;
    }
    String axis = m.group(1);
    double value = 0;
    if (m.group(2).startsWith(""#"")) {
        value = Double.parseDouble(m.group(2).substring(1));
    } else {
        value = Double.parseDouble(m.group(2));
    }
    return new Coordinate(axis, value);
}   ",834,False
"/**
 * A constructor with defaults for x, y and z axes.
 * <p>The numbers must be either null or a valid double.
 * @param x
 * @param y
 * @param z
 */
public NumericCoordinate(String x, String y, String z){
	this();
	if(x!=null)
		axes.put(Axis.X, Double.valueOf(x));
	if(y!=null)
		axes.put(Axis.X, Double.valueOf(y));
	if(z!=null)
		axes.put(Axis.X, Double.valueOf(z));
}","/**
 * A constructor with defaults for x, y and z axes.
 * <p>The numbers must be either null or a valid double.
 * @param x
 * @param y
 * @param z
 */
public NumericCoordinate(String x, String y, String z) 
{
    this.x = (x == null) ? null : Double.parseDouble(x);
    this.y = (y == null) ? null : Double.parseDouble(y);
    this.z = (z == null) ? null : Double.parseDouble(z);
}   ",835,True
"/**
 * Get a copy of this coordinate with the axes multiplied by the
 * scale values.
 * <p>The scale value can be a number, or an expression (e.g. 2.0 or #1),
 * in which case each axis is multiplied by that value.
 * <p>Multiple axes can also be defined. E.g. ""x2.0 y1.5"" or ""x#1 y[#2-1.0]"",
 * in which case only the defined axes will be scaled.
 * @param scale
 * @return
 */
public final Coordinate scale(String scale){
	// First, identify what sort of scale we are dealing with
	scale = scale.trim();
	int i=0;
	while(scale.charAt(i)=='-') ++i;
	// Starts with a digit: This is a numeric scale to all axes
	if(Character.isDigit(scale.charAt(i)))
		return scaleNumeric(Double.parseDouble(scale));
	
	// A variable reference or an expression. This is a symbolic
	// scale to all axes
	if(scale.charAt(i)=='#' || scale.charAt(i)=='[')
		return scaleSymbolic(scale);
	
	// Otherwise this must be a coordinate scale
	Coordinate coord = Coordinate.parse(scale);
	
	return scaleCoordinate(coord);
}","/**
 * Get a copy of this coordinate with the axes multiplied by the
 * scale values.
 * <p>The scale value can be a number, or an expression (e.g. 2.0 or #1),
 * in which case each axis is multiplied by that value.
 * <p>Multiple axes can also be defined. E.g. ""x2.0 y1.5"" or ""x#1 y[#2-1.0]"",
 * in which case only the defined axes will be scaled.
 * @param scale
 * @return
 */
public final Coordinate scale(String scale) 
{
    Coordinate c = new Coordinate(this);
    c.scale(scale);
    return c;
}   ",838,False
"/**
 * Convert this coordinate set to G-code.
 * E.g. If X and Y coordinates are set, this might produce
 * <kbd>X10.20 Y4.01</kbd>
 * @return coordinates
 */
public String toGcode(){
	StringBuilder sb = new StringBuilder();
	boolean first=true;
	for(Axis a : Axis.values()) {
		String val = get(a);
		if(val!=null) {
			if(!first)
				sb.append(' ');
			else
				first = false;
			sb.append(a.toString());
			sb.append(val);
		}
	}
	return sb.toString();
}","/**
 * Convert this coordinate set to G-code.
 * E.g. If X and Y coordinates are set, this might produce
 * <kbd>X10.20 Y4.01</kbd>
 * @return coordinates
 */
public String toGcode() 
{
    StringBuilder sb = new StringBuilder();
    if (x != null)
    {
        sb.append(""X"").append(x);
    }
    if (y != null)
    {
        sb.append("" Y"").append(y);
    }
    return sb.toString();
}   ",839,True
"/**
 * Checks to see if the filename matches.
 * 
 * @param file  the File directory
 * @param name  the filename
 * @return true if the filename matches
 */
public boolean accept(File file, String name){
    for (int i = 0; i < names.length; i++) {
        if (caseSensitivity.checkEquals(name, names[i])) {
            return true;
        }
    }
    return false;
}","/**
 * Checks to see if the filename matches.
 * 
 * @param file  the File directory
 * @param name  the filename
 * @return true if the filename matches
 */
public boolean accept(File file, String name) 
{
    if (name.equals(filename))
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",845,True
"/**
 * Construct a new name file filter specifying case-sensitivity.
 *
 * @param name  the name to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the name is null
 */
public NameFileFilter(String name, IOCase caseSensitivity){
    if (name == null) {
        throw new IllegalArgumentException(""The wildcard must not be null"");
    }
    this.names = new String[] {name};
    this.caseSensitivity = (caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity);
}","/**
 * Construct a new name file filter specifying case-sensitivity.
 *
 * @param name  the name to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the name is null
 */
public NameFileFilter(String name, IOCase caseSensitivity) 
{
    if (name == null) {
        throw new IllegalArgumentException(""The filter name == null"");
    }
    this.name = name;
    this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;
}   ",847,True
"/**
 * Creates a new <code>Multipart</code> from the specified
 * <code>Multipart</code>. The <code>Multipart</code> instance is
 * initialized with copies of preamble, epilogue, sub type and the list of
 * body parts of the specified <code>Multipart</code>. The parent entity
 * of the new multipart is <code>null</code>.
 *
 * @param other
 *            multipart to copy.
 * @throws UnsupportedOperationException
 *             if <code>other</code> contains a {@link SingleBody} that
 *             does not support the {@link SingleBody#copy() copy()}
 *             operation.
 * @throws IllegalArgumentException
 *             if <code>other</code> contains a <code>Body</code> that
 *             is neither a {@link Message}, {@link Multipart} or
 *             {@link SingleBody}.
 */
public MultipartImpl(Multipart other){
	super(other.getSubType());

	for (Entity otherBodyPart : other.getBodyParts()) {
		Entity bodyPartCopy = new BodyPart(otherBodyPart);
        addBodyPart(bodyPartCopy);
    }

	if (other instanceof MultipartImpl) {
	        preamble = ((MultipartImpl) other).preamble;
	        epilogue = ((MultipartImpl) other).epilogue;
        preambleStrCache = ((MultipartImpl) other).preambleStrCache;
        epilogueStrCache = ((MultipartImpl) other).epilogueStrCache;
        preambleComputed = ((MultipartImpl) other).preambleComputed;
        epilogueComputed = ((MultipartImpl) other).epilogueComputed;
	} else {
		setPreamble(other.getPreamble());
		setEpilogue(other.getEpilogue());
	}
}","/**
 * Creates a new <code>Multipart</code> from the specified
 * <code>Multipart</code>. The <code>Multipart</code> instance is
 * initialized with copies of preamble, epilogue, sub type and the list of
 * body parts of the specified <code>Multipart</code>. The parent entity
 * of the new multipart is <code>null</code>.
 *
 * @param other
 *            multipart to copy.
 * @throws UnsupportedOperationException
 *             if <code>other</code> contains a {@link SingleBody} that
 *             does not support the {@link SingleBody#copy() copy()}
 *             operation.
 * @throws IllegalArgumentException
 *             if <code>other</code> contains a <code>Body</code> that
 *             is neither a {@link Message}, {@link Multipart} or
 *             {@link SingleBody}.
 */


public MultipartImpl(Multipart other) 
{
    this.preamble = other.preamble;
    this.epilogue = other.epilogue;
    this.subType = other.subType;
    this.parts = new ArrayList<BodyPart>(other.parts.size() + 1);
    for (BodyPart part : other.parts)
    {
        this.parts.add(part.copy());
    }
}   ",848,True
"/**
 * Provide a String representaion of this file filter.
 *
 * @return a String representaion
 */
public String toString(){
    StringBuffer buffer = new StringBuffer();
    buffer.append(super.toString());
    buffer.append(""("");
    if (names != null) {
        for (int i = 0; i < names.length; i++) {
            if (i > 0) {
                buffer.append("","");
            }
            buffer.append(names[i]);
        }
    }
    buffer.append("")"");
    return buffer.toString();
}","/**
 * Provide a String representaion of this file filter.
 *
 * @return a String representaion
 */
public String toString() 
{
    if (filter == null)
    {
        return ""(*.*)"";
    }
    else
    {
        return filter.toString();
    }
}   ",849,True
"/**
 * <p>
 * Decodes a byte in <i>base 64 mode</i>. Will directly write a character to
 * the output buffer if completed.
 * </p>
 * 
 * @param in The input buffer
 * @param out The output buffer
 * @param lastRead Last byte read from the input buffer
 * @return CoderResult.malformed if a non-base 64 character was encountered
 *         in strict mode, null otherwise
 */
private CoderResult handleBase64(ByteBuffer in, CharBuffer out, byte lastRead){
    CoderResult result = null;
    int sextet = base64.getSextet(lastRead);
    if (sextet >= 0) {
        bitsRead += 6;
        if (bitsRead < 16) {
            tempChar += sextet << (16 - bitsRead);
        } else {
            bitsRead -= 16;
            tempChar += sextet >> (bitsRead);
            out.put((char)tempChar);
            tempChar = (sextet << (16 - bitsRead)) & 0xFFFF;
        }
    } else {
        if (strict)
            return malformed(in);
        out.put((char)lastRead);
        if (base64bitsWaiting())
            result = malformed(in);
        setUnshifted();
    }
    return result;
}","/**
 * <p>
 * Decodes a byte in <i>base 64 mode</i>. Will directly write a character to
 * the output buffer if completed.
 * </p>
 * 
 * @param in The input buffer
 * @param out The output buffer
 * @param lastRead Last byte read from the input buffer
 * @return CoderResult.malformed if a non-base 64 character was encountered
 *         in strict mode, null otherwise
 */
private CoderResult handleBase64(ByteBuffer in, CharBuffer out, byte lastRead) 
{
    int lastReadInt = lastRead & 0xFF;
    if (lastReadInt >= 0 && lastReadInt < BASE_64_DECODE.length)
    {
        byte b = BASE_64_DECODE[lastReadInt];
        if (b == -1)
        {
            return CoderResult.malformedForLength(1);
        }
        else
        {
            if (out.remaining() < 1)
            {
                return CoderResult.OVERFLOW;
            }
            out.put((char)b);
            return null;
        }
    }
    else
    {
        return CoderResult.malformedForLength(1);
    }
}   ",851,True
"/**
 * Creates a new empty <code>Multipart</code> instance.
 */
public MultipartImpl(String subType){
    super(subType);
    preamble = null;
    preambleStrCache = null;
    preambleComputed = true;
    epilogue = null;
    epilogueStrCache = null;
    epilogueComputed = true;
}","/**
 * Creates a new empty <code>Multipart</code> instance.
 */

public MultipartImpl(String subType) 
{
    this.subType = subType;
    this.parts = new ArrayList<BodyPart>();
}   ",852,True
"/**
 * Constructs a new name file filter for a list of names specifying case-sensitivity.
 * 
 * @param names  the names to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the name list is null
 * @throws ClassCastException if the list does not contain Strings
 */
public NameFileFilter(List names, IOCase caseSensitivity){
    if (names == null) {
        throw new IllegalArgumentException(""The list of names must not be null"");
    }
    this.names = (String[]) names.toArray(new String[names.size()]);
    this.caseSensitivity = (caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity);
}","/**
 * Constructs a new name file filter for a list of names specifying case-sensitivity.
 * 
 * @param names  the names to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the name list is null
 * @throws ClassCastException if the list does not contain Strings
 */
public NameFileFilter(List names, IOCase caseSensitivity) 
{
    if (names == null) {
        throw new IllegalArgumentException(""The filter must be initialized with a list of names"");
    }
    for (Object name : names) {
        if (!(name instanceof String)) {
            throw new ClassCastException(""List must contain Strings"");
        }
    }
    this.names = new ArrayList(names);
    if (caseSensitivity == null) {
        this.caseSensitivity = IOCase.SENSITIVE;
    } else {
        this.caseSensitivity = caseSensitivity;
    }
}   ",853,True
"/**
 * Constructs a new name file filter for an array of names specifying case-sensitivity.
 * <p>
 * The array is not cloned, so could be changed after constructing the
 * instance. This would be inadvisable however.
 * 
 * @param names  the names to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the names array is null
 */
public NameFileFilter(String[] names, IOCase caseSensitivity){
    if (names == null) {
        throw new IllegalArgumentException(""The array of names must not be null"");
    }
    this.names = names;
    this.caseSensitivity = (caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity);
}","/**
 * Constructs a new name file filter for an array of names specifying case-sensitivity.
 * <p>
 * The array is not cloned, so could be changed after constructing the
 * instance. This would be inadvisable however.
 * 
 * @param names  the names to allow, must not be null
 * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive
 * @throws IllegalArgumentException if the names array is null
 */
public NameFileFilter(String[] names, IOCase caseSensitivity) 
{
    if (names == null) {
        throw new IllegalArgumentException(""The array of names must not be null"");
    }
    this.names = names;
    this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;
}   ",854,True
"/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#implFlush(java.nio.CharBuffer)
 */
protected CoderResult implFlush(CharBuffer out){
    if ((base64mode && strict) || base64bitsWaiting())
        return CoderResult.malformedForLength(1);
    return CoderResult.UNDERFLOW;
}","/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#implFlush(java.nio.CharBuffer)
 */
protected CoderResult implFlush(CharBuffer out) 
{
    if (state == END)
    {
        return CoderResult.UNDERFLOW;
    }
    else
    {
        state = END;
        return CoderResult.MALFORMED;
    }
}   ",855,True
"//-----------------------------------------------------------------------
/**
 * Tests that we can write to the lock directory.
 *
 * @param lockDir  the File representing the lock directory
 * @throws IOException if we cannot write to the lock directory
 * @throws IOException if we cannot find the lock file
 */
private void testLockDir(File lockDir) throws IOException{
    if (!lockDir.exists()) {
        throw new IOException(
                ""Could not find lockDir: "" + lockDir.getAbsolutePath());
    }
    if (!lockDir.canWrite()) {
        throw new IOException(
                ""Could not write to lockDir: "" + lockDir.getAbsolutePath());
    }
}","//-----------------------------------------------------------------------
/**
 * Tests that we can write to the lock directory.
 *
 * @param lockDir  the File representing the lock directory
 * @throws IOException if we cannot write to the lock directory
 * @throws IOException if we cannot find the lock file
 */
private void testLockDir(File lockDir) throws IOException 
{
    File lockFile = new File(lockDir, ""lock"");
    lockFile.createNewFile();
    assertTrue(lockFile.exists());
    lockFile.delete();
}   ",857,True
"/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#implReset()
 */
protected void implReset(){
    setUnshifted();
    justUnshifted = false;
}","/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#implReset()
 */
protected void implReset() 
{
    if (state != null) {
        state.reset();
    }
}   ",858,True
"/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#decodeLoop(java.nio.ByteBuffer,
 * java.nio.CharBuffer)
 */
protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out){
    while (in.hasRemaining()) {
        byte b = in.get();
        if (base64mode) {
            if (b == unshift) {
                if (base64bitsWaiting())
                    return malformed(in);
                if (justShifted) {
                    if (!out.hasRemaining())
                        return overflow(in);
                    out.put((char)shift);
                } else
                    justUnshifted = true;
                setUnshifted();
            } else {
                if (!out.hasRemaining())
                    return overflow(in);
                CoderResult result = handleBase64(in, out, b);
                if (result != null)
                    return result;
            }
            justShifted = false;
        } else {
            if (b == shift) {
                base64mode = true;
                if (justUnshifted && strict)
                    return malformed(in);
                justShifted = true;
                continue;
            }
            if (!out.hasRemaining())
                return overflow(in);
            out.put((char)b);
            justUnshifted = false;
        }
    }
    return CoderResult.UNDERFLOW;
}","/*
 * (non-Javadoc)
 * @see java.nio.charset.CharsetDecoder#decodeLoop(java.nio.ByteBuffer,
 * java.nio.CharBuffer)
 */
protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out) 
{
    int n = in.remaining();
    if (n == 0) {
        return CoderResult.UNDERFLOW;
    }
    for (int i = 0; i < n; i++) {
        int b = in.get();
        if (!decode(b, out)) {
            return CoderResult.UNDERFLOW;
        }
    }
    return CoderResult.SUCCESS;
}   ",859,True
"/**
 * @return Returns a new hibernate element for the given entity.
 */
private Element createEntity(PAnnotatedEClass entity,
		InheritanceType inhStrategy, PAnnotatedEClass superEntity,
		DiscriminatorValue dValue, Table table){
	// determine what type of hibernate tag should be used
	final InheritanceType inheritanceStrategy = inhStrategy != null ? inhStrategy
			: InheritanceType.SINGLE_TABLE;
	final EClass eclass = entity.getModelEClass();
	final String hbClassName;
	if (superEntity == null) {
		hbClassName = ""class"";
	} else {
		hbClassName = EntityMapper.hbInheritanceName(inheritanceStrategy);
	}

	log.debug(""Creating entity tag "" + hbClassName);

	final Element target;

	final String entityName = getHbmContext().getEntityName(eclass);
	final String isAbstractStr = eclass.isAbstract() ? ""true"" : ""false"";
	final boolean doProxy = ((HbAnnotatedEClass) entity).getHbProxy() != null
			&& ((HbAnnotatedEClass) entity).getHbProxy().isLazy();
	if (entity.isOnlyMapAsEntity()) {
		target = getHbmContext().getCurrent().addElement(hbClassName)
				.addAttribute(""entity-name"", entityName).addAttribute(
						""abstract"", isAbstractStr).addAttribute(""lazy"",
						""false"");

		// note for composite ids the name must be set always!
		// entity.getAnnotatedEClass().getInstanceClass() != null) { //
		// ||
		// entity.getAnnotatedEClass().getInstanceClass() != null ||
		if (hasCompositeID(entity)) { // only for this specific case
			// it is
			// required to have the impl.name
			target.addAttribute(""name"", hbmContext
					.getInstanceClassName(entity.getModelEClass()));
		}
	} else if (getHbmContext().forceUseOfInstance(entity)) {

		final Element importElement = new Element(""import"");

		importElement.addAttribute(""class"",
				hbmContext.getInstanceClassName(entity.getModelEClass()))
				.addAttribute(""rename"", entityName);
		getHbmContext().getCurrent().add(getImportIndex(), importElement);

		target = getHbmContext().getCurrent().addElement(hbClassName)
				.addAttribute(
						""name"",
						hbmContext.getInstanceClassName(entity
								.getModelEClass())).addAttribute(
						""abstract"", isAbstractStr).addAttribute(""lazy"",
						doProxy ? ""true"" : ""false"");
	} else {
		target = getHbmContext().getCurrent().addElement(hbClassName)
				.addAttribute(
						""name"",
						hbmContext.getInstanceClassName(entity
								.getModelEClass())).addAttribute(
						""entity-name"", entityName).addAttribute(""abstract"",
						isAbstractStr).addAttribute(""lazy"",
						doProxy ? ""true"" : ""false"");
	}

	final HbAnnotatedEClass hbEntity = (HbAnnotatedEClass) entity;
	// TODO: the immutable on the eclass should be removed as it is now
	// covered through the HbEntity
	if (superEntity == null && hbEntity.getImmutable() != null) {
		target.addAttribute(""mutable"", ""false"");
	}

	if (hbEntity.getBatchSize() != null) {
		target.addAttribute(""batch-size"", """"
				+ hbEntity.getBatchSize().getSize());
	}

	if (hbEntity.getHbEntity() != null) {
		final HbEntity hbEntityAnnon = hbEntity.getHbEntity();
		if (superEntity == null) {
			if (!hbEntityAnnon.isMutable()
					&& target.getAttributeValue(""mutable"") == null) {
				target.addAttribute(""mutable"", ""false"");
			}
			if (hbEntityAnnon.getPolymorphism() != null) {
				target.addAttribute(""polymorphism"", hbEntityAnnon
						.getPolymorphism().getName().toLowerCase());
			}
			if (hbEntityAnnon.getOptimisticLock() != null) {
				target.addAttribute(""optimistic-lock"", hbEntityAnnon
						.getOptimisticLock().getName().toLowerCase());
			}
		}
		if (hbEntityAnnon.isDynamicInsert()) {
			target.addAttribute(""dynamic-insert"", ""true"");
		}
		if (hbEntityAnnon.isDynamicUpdate()) {
			target.addAttribute(""dynamic-update"", ""true"");
		}
		if (hbEntityAnnon.isSelectBeforeUpdate()) {
			target.addAttribute(""select-before-update"", ""true"");
		}
		if (hbEntityAnnon.getPersister() != null) {
			target.addAttribute(""persister"", hbEntityAnnon.getPersister());
		}

	}

	if (superEntity != null) {
		final String extendsEntity;
		if (superEntity.isOnlyMapAsEntity()
				|| !getHbmContext().forceUseOfInstance(superEntity)) {
			extendsEntity = getHbmContext().getEntityName(
					superEntity.getModelEClass());
		} else {
			extendsEntity = getHbmContext().getInstanceClassName(
					superEntity.getModelEClass());
		}
		target.addAttribute(""extends"", extendsEntity);
		log.debug(""Extends "" + extendsEntity);
	}

	if (dValue != null) {
		target.addAttribute(""discriminator-value"", dValue.getValue());
		log.debug(""DValue "" + dValue.getValue());
	}

	if (table != null
			&& hbClassName
					.compareTo(INHERITANCE_STRATEGY_NAMES[InheritanceType.SINGLE_TABLE
							.getValue()]) == 0) {
		log
				.warn(""EClass/Entity (""
						+ entityName
						+ "") is mapped as subclass in a single table with its superclass but it also has a table annotation. This table annotation is ignored."");
	} else if (table != null) {
		if (table.getName() != null) {
			target.addAttribute(""table"", getHbmContext().trunc(
					table.getName(), false));
			log.debug(""Table "" + table.getName());
		}
		if (table.getSchema() != null) {
			target.addAttribute(""schema"", getHbmContext().trunc(
					table.getSchema(), false));
			log.debug(""Schema "" + table.getSchema());
		}
		if (table.getCatalog() != null) {
			target.addAttribute(""catalog"", getHbmContext().trunc(
					table.getCatalog(), false));
			log.debug(""Catalog "" + table.getCatalog());
		}
	}

	if (((HbAnnotatedEClass) entity).getHbWhere() != null) {
		target.addAttribute(""where"", ((HbAnnotatedEClass) entity)
				.getHbWhere().getClause());
	}

	if (((HbAnnotatedEClass) entity).getHbProxy() != null
			&& ((HbAnnotatedEClass) entity).getHbProxy().getProxyClass() != null) {
		final String proxyInterfaceName = ((HbAnnotatedEClass) entity)
				.getHbProxy().getProxyClass();
		target.addAttribute(""proxy"", proxyInterfaceName);
	}

	return target;
}

/** Return index were to place the import */
protected int getImportIndex() {
	final List<?> children = getHbmContext().getCurrent().getChildren();
	int defaultResult = 0;
	for (int i = 0; i < children.size(); i++) {
		final Element e = (Element) children.get(i);
		final String name = e.getName();
		if (name.compareTo(""class"") == 0 || name.compareTo(""subclass"") == 0
				|| name.compareTo(""joined-subclass"") == 0
				|| name.compareTo(""union-subclass"") == 0) {
			return i;
		}
		if (name.compareTo(""typedef"") == 0 || name.compareTo(""meta"") == 0) {
			defaultResult = i + 1;
		}
	}
	return defaultResult;
}

/** Returns true if this entity or one of its superclasses has an idclass */
private boolean hasCompositeID(PAnnotatedEClass aClass) {
	if (aClass.getIdClass() != null) {
		return true;
	}
	if (aClass.getPaSuperEntity() != null) {
		return hasCompositeID(aClass.getPaSuperEntity());
	}
	for (PAnnotatedEClass superAClass : aClass.getPaMappedSupers()) {
		if (hasCompositeID(superAClass)) {
			return true;
		}
	}
	{
		List<PAnnotatedEStructuralFeature> features = aClass
				.getPaEStructuralFeatures();
		for (PAnnotatedEStructuralFeature feature : features) {
			if (feature instanceof PAnnotatedEReference
					&& ((PAnnotatedEReference) feature).getEmbeddedId() != null) {
				return true;
			}
		}
	}
	return false;
}

/**
 * Maps the given entity in its hbm context.
 */
public void processEntity(PAnnotatedEClass entity) {
	if (log.isDebugEnabled()) {
		log.debug(""Mapping Entity "" + entity);
	}

	final HbAnnotatedEClass hbEntity = (HbAnnotatedEClass) entity;
	Element entityElement = createEntity(entity, entity
			.getInheritanceStrategy(), entity.getPaSuperEntity(), entity
			.getDiscriminatorValue(), entity.getTable());
	final MappingContext mc = getHbmContext();

	mc.setCurrent(entityElement);
	mc.setCurrentTable(entity.getTable());
	// MT: moved to processFeatures method because this should be done after
	// the id
	// element has been placed

	if (entity.getPaSuperEntity() == null
			&& entity.getPrimaryKeyJoinColumns() != null
			&& entity.getPrimaryKeyJoinColumns().size() > 0) {
		log
				.warn(""This entity (""
						+ entity.getEntity().getName()
						+ "" is the root in the class hierarchy and ""
						+ ""has a pk joincolum annotation, this is not correct, ignoring pk joincolumn annotation"");
	} else if (InheritanceType.SINGLE_TABLE.equals(entity
			.getInheritanceStrategy())
			&& entity.getPrimaryKeyJoinColumns() != null
			&& entity.getPrimaryKeyJoinColumns().size() > 0) {
		log
				.warn(""Single table inheritance strategy (entity ""
						+ entity.getEntity().getName()
						+ "", primary key join column annotation is ignored for subclass"");
	} else if (entity.getPrimaryKeyJoinColumns() != null
			&& entity.getPrimaryKeyJoinColumns().size() > 0) {
		addPrimaryKeyJoinColumn(entity.getPrimaryKeyJoinColumns(), entity);
	} else if (entity.getPaSuperEntity() != null
			&& InheritanceType.JOINED.equals(entity
					.getInheritanceStrategy())) {
		final ArrayList<PrimaryKeyJoinColumn> list = new ArrayList<PrimaryKeyJoinColumn>();
		final PrimaryKeyJoinColumn pkjc = PannotationFactory.eINSTANCE
				.createPrimaryKeyJoinColumn();
		final String entityName = mc.getEntityName(entity.getModelEClass());
		mc.trunc(entityName + ""id""); // TODO improve name
		// creation here
		list.add(pkjc);
		addPrimaryKeyJoinColumn(list, entity);
	}

	try {
		final List<PAnnotatedEStructuralFeature> inheritedFeatures = mc
				.getInheritedFeatures(entity);

		mc
				.setForceOptional(entity.getPaSuperEntity() != null
						&& (entity.getInheritanceStrategy() == null || InheritanceType.SINGLE_TABLE
								.equals(entity.getInheritanceStrategy())));

		mc.pushOverrideOnStack();
		mc.addAttributeOverrides(entity.getAttributeOverrides());
		mc.addAssociationOverrides(entity.getAssociationOverrides());

		if (inheritedFeatures.size() > 0) {
			log.debug(""There are "" + inheritedFeatures.size()
					+ "" inherited features "");
		}

		try {
			processFeatures(inheritedFeatures);

			final EList<SecondaryTable> secondaryTables = entity
					.getSecondaryTables();
			if (secondaryTables == null || secondaryTables.isEmpty()) {
				// Process features normally.
				processFeatures(entity.getPaEStructuralFeatures());
			} else {
				// Special processing needed for secondary tables.
				processSecondaryTables(secondaryTables, entity);
			}
		} finally {
			mc.popOverrideStack();
		}
	} finally {
		mc.setForceOptional(false);
		mc.setCurrentTable(null);
		Element idElement = entityElement.element(""id"");
		if (idElement == null) {
			idElement = entityElement.element(""composite-id"");
		}

		// create a synthetic id for roots
		if (idElement == null && entity.getPaSuperEntity() == null
				&& entity.getPaMappedSupers().size() == 0) {
			idElement = IdMapper.addSyntheticId(hbmContext, entityElement);
		} else if (mc.mustAddSyntheticID(entity)) {
			idElement = IdMapper.addSyntheticId(hbmContext, entityElement);
		} else {
			addAccessor(idElement, hbmContext.getIdPropertyHandlerName());
		}

		if (idElement != null) {
			int index = entityElement.indexOf(idElement) + 1;

			if (((HbAnnotatedEClass) entity).getDiscriminatorFormula() != null) {
				entityElement.add(index++, createDiscriminatorElement(
						hbEntity.getDiscriminatorFormula(), entity
								.getDiscriminatorColumn(), hbEntity
								.getForceDiscriminator() != null));
			} else if (entity.getDiscriminatorColumn() != null) {
				// add discriminator element immediately after id element
				entityElement.add(index++, createDiscriminatorElement(
						entity.getDiscriminatorColumn(), hbEntity
								.getForceDiscriminator() != null));
			}

			// create and/or move version element (if present) immediately
			// after discriminator
			Element versionElement = entityElement.element(""version"");
			if (versionElement == null) {
				versionElement = addVersionProperty(hbEntity);
			}

			if (null != versionElement) { // In case this is not versioned
				entityElement.remove(versionElement);
				entityElement.add(index, versionElement);
			}
		}

		mapFilter(entityElement, ((HbAnnotatedEClass) entity).getFilter());

		mc.setCurrent(entityElement.getParent());

		// now process the featuremap entries if any
		processFeatureMapFeatures();
		int index = 1 + entityElement.getChildren().indexOf(idElement);
		// check if there is a discriminator, if so put it behind that one
		if (entityElement.element(""discriminator"") != null) {
			final Element elem = entityElement.element(""discriminator"");
			index = 1 + entityElement.getChildren().indexOf(elem);
		}

		handleNaturalId(entityElement, index);
	}

	// initially the comment is placed at the back, move it to the front
	final Element comment = addCommentElement(entity.getModelEClass(),
			entityElement);
	if (comment != null) {
		entityElement.remove(comment);
		entityElement.add(0, comment);
	}

	// place the tuplizer at the front
	mc.addTuplizerElement(entityElement, entity);

	if ((entity.getPaSuperEntity() == null || entity.getPaSuperEntity()
			.getMappedSuperclass() != null)
			&& ((HbAnnotatedEClass) entity).getHbCache() != null) {
		// then add the cache at the front
		addCacheElement(entityElement, ((HbAnnotatedEClass) entity)
				.getHbCache());
	}

	// and add the metas at the front
	final Element meta1 = new Element(""meta"");
	meta1.addAttribute(""attribute"", HbMapperConstants.ECLASS_NAME_META)
			.addText(entity.getModelEClass().getName());
	final Element meta2 = new Element(""meta"");
	meta2.addAttribute(""attribute"", HbMapperConstants.EPACKAGE_META)
			.addText(entity.getModelEClass().getEPackage().getNsURI());

	entityElement.add(0, meta1);
	entityElement.add(1, meta2);

	// and move the joins to the back
	final List<Element> toMove = new ArrayList<Element>();
	for (Element elem : entityElement.getChildren()) {
		if (elem.getName().equals(""join"")) {
			toMove.add(elem);
		}
	}
	entityElement.getChildren().removeAll(toMove);
	entityElement.getChildren().addAll(toMove);

}

// reorganize the elements which have a natural-id inside a natural-id tag
protected void handleNaturalId(Element parentElement, int index) {
	log.debug(""Checking for natural-ids"");
	final List<Element> naturalIdElements = new ArrayList<Element>();
	boolean mutable = false;
	for (Element element : parentElement.getChildren()) {
		String value;
		if ((value = element
				.getAttributeValue(HbMapperConstants.NATURAL_ID_ATTR)) != null) {
			if (naturalIdElements.isEmpty()) {
				log.debug(""Found natural-id, mutable: "" + mutable);
				mutable = Boolean.parseBoolean(value);
			}
			naturalIdElements.add(element);
			element.removeAttribute(HbMapperConstants.NATURAL_ID_ATTR);
		}
	}
	if (!naturalIdElements.isEmpty()) {
		log
				.debug(""Found ""
						+ naturalIdElements.size()
						+ "" naturalid properies, putting them inside a natural-id tag"");
		parentElement.getChildren().removeAll(naturalIdElements);
		final Element naturalId = parentElement.addElement(""natural-id"");
		// remove it again to place it at the correct position a little
		// lower
		parentElement.remove(naturalId);
		naturalId.addAttribute(""mutable"", Boolean.toString(mutable));
		parentElement.add(index, naturalId);
		naturalId.getChildren().addAll(naturalIdElements);
		for (Element element : naturalIdElements) {
			element.setParent(naturalId);
		}
	}
}

/** Process the featuremap entries */
private void processFeatureMapFeatures() {
	// this is a while and for loop, in the for loop the features of a
	// feature map
	// are processed, these features can again be a featuremap which are
	// added
	// to the featuremapmappers in the context, therefore this process walks
	// on
	List<FeatureMapMapping> featureMapMappers = getHbmContext()
			.getClearFeatureMapMappers();
	while (featureMapMappers.size() > 0) {

		for (FeatureMapMapping fmm : featureMapMappers) {
			fmm.process();
		}

		// read again because the fmm.process can result in new feature map
		// mappings
		featureMapMappers = getHbmContext().getClearFeatureMapMappers();
	}
}

/**
 * Process the features of the mapped superclass so that they are added to
 * the current mapping
 */
protected void processMappedSuper(PAnnotatedEClass paMappedSuper) {
	processFeatures(paMappedSuper.getPaEStructuralFeatures());
}

/** process the features of the annotated eclass */
protected void processFeatures(List<PAnnotatedEStructuralFeature> features) {
	for (PAnnotatedEStructuralFeature annotatedEStructuralFeature : features) {
		processFeature(annotatedEStructuralFeature);
	}
}

/** Process secondary tables. */
protected void processSecondaryTables(List<SecondaryTable> secondaryTables,
		PAnnotatedEClass entity) {
	// Group features by primary and secondary tables.
	// For the primary table we use null as the surrogate key. (HashMap
	// allows null keys.)
	final Set<String> tableNames = new HashSet<String>();
	tableNames.add(PRIMARY_TABLE_KEY);
	for (SecondaryTable secondaryTable : secondaryTables) {
		tableNames.add(secondaryTable.getName());
	}
	final Map<String, List<PAnnotatedEStructuralFeature>> featuresByTable = new HashMap<String, List<PAnnotatedEStructuralFeature>>();
	for (PAnnotatedEStructuralFeature feature : entity
			.getPaEStructuralFeatures()) {
		// find the table for the feature
		final String tableName = getHbmContext().getSecondaryTableName(
				feature);
		// if there put it in the correct list
		if (!tableNames.contains(tableName)) {
			final String message = ""Feature \""""
					+ feature.getModelElement().getName()
					+ ""\"" was mapped to undeclared secondary table \""""
					+ tableName + ""\""."";
			log.error(message);
			throw new MappingException(message);
		}
		List<PAnnotatedEStructuralFeature> featuresInTable = featuresByTable
				.get(tableName);
		if (featuresInTable == null) {
			featuresInTable = new ArrayList<PAnnotatedEStructuralFeature>();
			featuresByTable.put(tableName, featuresInTable);
		}
		featuresInTable.add(feature);
	}

	// Process features in primary table.
	{
		final List<PAnnotatedEStructuralFeature> featuresInTable = featuresByTable
				.get(PRIMARY_TABLE_KEY);
		// can happen if there are only secondarytable features and no
		// primary table
		// features see bugzilla 235949
		if (featuresInTable != null) {
			for (PAnnotatedEStructuralFeature feature : featuresInTable) {
				processFeature(feature);
			}
		}
	}
	// Process features in secondary tables.
	for (SecondaryTable secondaryTable : secondaryTables) {
		if (!featuresByTable.containsKey(secondaryTable.getName())) {
			// The table was listed in the SecondaryTable annotation, but no
			// features were actually mapped to this
			// table.
			log.warn(""No features mapped to secondary table ""
					+ secondaryTable.getName());
			continue;
		}
		final List<PAnnotatedEStructuralFeature> featuresInTable = featuresByTable
				.get(secondaryTable.getName());

		// Create <join> element
		// See
		// http://www.hibernate.org/hib_docs/v3/reference/en/html/mapping.html#mapping-declaration
		// -join
		final Element joinElement = getHbmContext().getCurrent()
				.addElement(""join"");
		joinElement.addAttribute(""table"", getHbmContext().trunc(
				secondaryTable.getName().toUpperCase(), false));
		log.debug(""Mapping features to secondary table \""""
				+ secondaryTable.getName() + ""\"""");
		if (secondaryTable.getCatalog() != null) {
			joinElement
					.addAttribute(""catalog"", secondaryTable.getCatalog());
		}
		if (secondaryTable.getSchema() != null) {
			joinElement.addAttribute(""schema"", secondaryTable.getSchema());
		}
		entity.getModelEClass().getEIDAttribute();
		final List<PrimaryKeyJoinColumn> pkJoinColumns = secondaryTable
				.getPkJoinColumns();
		final Element keyElement = joinElement.addElement(""key"");
		for (PrimaryKeyJoinColumn pkJoinColumn : pkJoinColumns) {
			keyElement.addElement(""column"").addAttribute(""name"",
					getHbmContext().trunc(pkJoinColumn.getName()));
		}
		handleOndelete(keyElement, ((HbAnnotatedEClass) entity)
				.getHbOnDelete());

		// Process features in this secondary table.
		try {
			getHbmContext().setCurrent(joinElement);
			getHbmContext().setCurrentSecondaryTable(secondaryTable);
			for (PAnnotatedEStructuralFeature feature : featuresInTable) {
				processFeature(feature);
			}
		} finally {
			getHbmContext().setCurrentSecondaryTable(null);
			getHbmContext().setCurrent(joinElement.getParent());
		}
	}
}

/** Process one feature */
protected void processFeature(PAnnotatedEStructuralFeature paFeature) {
	hbmContext.getFeatureMapper().process(paFeature);
}

/**
 * Adds a key element to the current entity mapping, is for example used to
 * join to the super class table.
 */
private void addPrimaryKeyJoinColumn(List<PrimaryKeyJoinColumn> pkJCs,
		PAnnotatedEClass entity) {
	log.debug(""Adding primary key join column"");

	final Element jcElement = getHbmContext().getCurrent()
			.addElement(""key"");
	handleOndelete(jcElement, ((HbAnnotatedEClass) entity).getHbOnDelete());

	for (PrimaryKeyJoinColumn pkJC : pkJCs) {
		final Element columnElement = jcElement.addElement(""column"");

		if (pkJC.getColumnDefinition() != null) {
			log
					.error(""Unsupported column definition in primary key join column ""
							+ pkJC);
			throw new MappingException(
					""Unsupported column definition in primary key join column"",
					pkJC);
		}

		if (pkJC.getName() != null) {
			columnElement.addAttribute(""name"", getHbmContext().trunc(
					pkJC.getName()));
		}
		if (pkJC.getReferencedColumnName() != null) {
			columnElement.addAttribute(""property-ref"", pkJC
					.getReferencedColumnName());
		}
	}
}

/**
 * Creates a discriminator element and returns it, so the caller should add
 * it to the parent element
 */
private Element createDiscriminatorElement(DiscriminatorColumn dColumn,
		boolean force) {
	Element dcElement = DocumentHelper.createElement(""discriminator"");
	if (dColumn.getName() != null) {
		dcElement.addAttribute(""column"", getHbmContext().trunc(
				dColumn.getName()));
	}
	dcElement.addAttribute(""type"", hbDiscriminatorType(dColumn
			.getDiscriminatorType()));

	if (force) {
		dcElement.addAttribute(""force"", ""true"");
	}

	if (dColumn.isSetLength() && log.isDebugEnabled()) {
		log.debug(""Ignoring length for discriminator column "" + dColumn);
	}

	if (dColumn.getColumnDefinition() != null) {
		log.error(""Unsupported column definition in discriminator column ""
				+ dColumn);
		throw new MappingException(
				""Unsupported column definition in discriminator column"",
				dColumn);
	}
	return dcElement;
}

// note dc can be null
private Element createDiscriminatorElement(DiscriminatorFormula formula,
		DiscriminatorColumn dc, boolean force) {
	Element dcElement = DocumentHelper.createElement(""discriminator"");
	dcElement.addAttribute(""formula"", formula.getValue());

	if (force) {
		dcElement.addAttribute(""force"", ""true"");
	}

	if (dc != null && dc.getDiscriminatorType() != null) {
		dcElement.addAttribute(""type"", hbDiscriminatorType(dc
				.getDiscriminatorType()));
	}
	return dcElement;
}

/**
 * Add a synthetic version if the entity does not define one
 */
private Element addVersionProperty(HbAnnotatedEClass aClass) {
	assert (getHbmContext().getCurrent().element(""version"") == null);

	if (!getHbmContext().alwaysVersion()) {
		return null;
	}
	final boolean skipVersionOnImmutable = !getHbmContext()
			.getPersistenceOptions()
			.isDiscriminatorVersionOnImmutableEClass();
	if (aClass.getImmutable() != null && skipVersionOnImmutable) {
		return null;
	}

	// note specific accessor is required because version accessor is not
	// retrieved through
	// emf tuplizer
	final Element versionElement = getHbmContext().getCurrent().addElement(
			""version"").addAttribute(""name"",
			getHbmContext().getVersionColumnName()).addAttribute(""column"",
			getHbmContext().getVersionColumnName());
	final Element meta = new Element(""meta"");
	meta.addAttribute(""attribute"", HbMapperConstants.VERSION_META).addText(
			""true"");
	versionElement.add(0, meta);

	versionElement.addAttribute(""access"", getHbmContext()
			.getSyntheticVersionPropertyHandlerName());

	return versionElement;
}
}","/**
 * @return Returns a new hibernate element for the given entity.
 */
private Element createEntity(PAnnotatedEClass entity,
		InheritanceType inhStrategy, PAnnotatedEClass superEntity,
		DiscriminatorValue dValue, Table table) 
{
	Element e = new Element();
	e.setName(entity.getQualifiedName());
	e.setClazz(entity.getQualifiedName());
	e.setDiscriminatorValue(dValue);
	e.setInheritanceStrategy(inhStrategy);
	e.setSuperClass(superEntity == null ? null : superEntity
			.getQualifiedName());
	e.setTable(table);
	return e;
}	",860,False
"/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified name.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType getByName(String name){
	for (int i = 0; i < VALUES_ARRAY.length; ++i) {
		HbCascadeType result = VALUES_ARRAY[i];
		if (result.getName().equals(name)) {
			return result;
		}
	}
	return null;
}","/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified name.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType getByName(String name) 
{
  for (int i = 0; i < VALUES_ARRAY.length; ++i)
  {
    HbCascadeType result = VALUES_ARRAY[i];
    if (result.getName().equals(name))
    {
      return result;
    }
  }
  return null;
}   ",861,True
"/**
	 * Returns the '<em><b>Book Category</b></em>' literal with the specified literal value.
	 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
	 * @generated
	 */
public static BookCategory get(String literal){
		for (int i = 0; i < VALUES_ARRAY.length; ++i) {
			BookCategory result = VALUES_ARRAY[i];
			if (result.toString().equals(literal)) {
				return result;
			}
		}
		return null;
	}","/**
	 * Returns the '<em><b>Book Category</b></em>' literal with the specified literal value.
	 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
	 * @generated
	 */
public static BookCategory get(String literal) 
{
		for (int i = 0; i < VALUES_ARRAY.length; ++i)
		{
			BookCategory result = VALUES_ARRAY[i];
			if (result.toString().equals(literal))
			{
				return result;
			}
		}
		return null;
	}	",865,True
"/**
 * @return Return the name used by hibernate for the given dicriminator type
 */
private static String hbDiscriminatorType(DiscriminatorType dType){
	return EntityMapper.DISCRIMINATOR_TYPE_NAMES[dType == null ? DiscriminatorType.STRING
			.getValue()
			: dType.getValue()];
}","/**
 * @return Return the name used by hibernate for the given dicriminator type
 */
private static String hbDiscriminatorType(DiscriminatorType dType) 
{
    switch (dType)
    {
        case STRING:
            return ""string"";
        case INTEGER:
            return ""integer"";
        case CHAR:
            return ""char"";
        case LONG:
            return ""long"";
    }
    return null;
}   ",867,True
"/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified literal value.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType get(String literal){
	for (int i = 0; i < VALUES_ARRAY.length; ++i) {
		HbCascadeType result = VALUES_ARRAY[i];
		if (result.toString().equals(literal)) {
			return result;
		}
	}
	return null;
}","/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified literal value.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType get(String literal) 
{
  for (int i = 0; i < VALUES_ARRAY.length; ++i)
  {
    HbCascadeType result = VALUES_ARRAY[i];
    if (result.toString().equals(literal))
    {
      return result;
    }
  }
  return null;
}   ",869,True
"/**
 * Only this class can construct instances.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
private HbCascadeType(int value, String name, String literal){
	this.value = value;
	this.name = name;
	this.literal = literal;
}","/**
 * Only this class can construct instances.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
private HbCascadeType(int value, String name, String literal) 
{
    this.value = value;
    this.name = name;
    this.literal = literal;
}   ",870,True
"/**
 * @param masterProperty
 * @param detailProperty
 */
public ValuePropertyDetailSet(IValueProperty masterProperty,
		ISetProperty detailProperty){
	this.masterProperty = masterProperty;
	this.detailProperty = detailProperty;
}","/**
 * @param masterProperty
 * @param detailProperty
 */
public ValuePropertyDetailSet(IValueProperty masterProperty,
		ISetProperty detailProperty) 
{
	super();
	this.masterProperty = masterProperty;
	this.detailProperty = detailProperty;
}	",875,True
"/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified integer value.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType get(int value){
	switch (value) {
		case ALL_VALUE: return ALL;
		case PERSIST_VALUE: return PERSIST;
		case MERGE_VALUE: return MERGE;
		case REMOVE_VALUE: return REMOVE;
		case REFRESH_VALUE: return REFRESH;
		case DELETE_VALUE: return DELETE;
		case SAVE_UPDATE_VALUE: return SAVE_UPDATE;
		case REPLICATE_VALUE: return REPLICATE;
		case DELETE_ORPHAN_VALUE: return DELETE_ORPHAN;
		case LOCK_VALUE: return LOCK;
		case EVICT_VALUE: return EVICT;
	}
	return null;
}","/**
 * Returns the '<em><b>Hb Cascade Type</b></em>' literal with the specified integer value.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated
 */
public static HbCascadeType get(int value) 
{
	switch (value)
	{
		case ALL_VALUE: return ALL;
		case DELETE_VALUE: return DELETE;
		case NONE_VALUE: return NONE;
		case SAVE_UPDATE_VALUE: return SAVE_UPDATE;
	}
	return null;
}   ",878,True
"/**
 * @return Return the name used by hibernate to denote the given inheritance
 *         type. If the argument is null, the default inheritance type
 *         (SINGLE_TABLE) is used instead.
 */
private static String hbInheritanceName(InheritanceType inheritanceType){
	return EntityMapper.INHERITANCE_STRATEGY_NAMES[inheritanceType != null ? inheritanceType
			.getValue()
			: InheritanceType.SINGLE_TABLE.getValue()];
}","/**
 * @return Return the name used by hibernate to denote the given inheritance
 *         type. If the argument is null, the default inheritance type
 *         (SINGLE_TABLE) is used instead.
 */
private static String hbInheritanceName(InheritanceType inheritanceType) 
{
    if (inheritanceType == null)
    {
        inheritanceType = InheritanceType.SINGLE_TABLE;
    }

    switch (inheritanceType)
    {
        case SINGLE_TABLE:
            return ""single-table"";
        case JOINED:
            return ""joined"";
        case TABLE_PER_CLASS:
            return ""table-per-class"";
        default:
            throw new IllegalArgumentException(""Unknown inheritance type: "" + inheritanceType);
    }
}   ",879,True
"/***
 * Overridable method for handling any messages not caught by the Activities
 * own post() method. The code pattern allows more generic messages to be
 * handled here (show battery warning dialog, etc).
 *
 * @param type Message type.
 * @param bundle Optional Bundle of extra information.
 */
public void post(final Type type, final Bundle bundle){
    switch (type) {
    case SHOW_DIALOG:
        mDialogBundle = bundle;
        showDialog(Type.DIALOG_STATUS.ordinal());
        break;

    default:
        // Do nothing.
        break;
    }
}","/***
 * Overridable method for handling any messages not caught by the Activities
 * own post() method. The code pattern allows more generic messages to be
 * handled here (show battery warning dialog, etc).
 *
 * @param type Message type.
 * @param bundle Optional Bundle of extra information.
 */
public void post(final Type type, final Bundle bundle) 
{
    switch (type)
    {
        case BATTERY_WARNING:
            showBatteryWarningDialog();
            break;
        default:
            // Do nothing.
            break;
    }
}   ",880,True
"/***
 * Reacts to any incoming message by passing it to the WorkerThread,
 * creating a new one if necessary.
 *
 * @param message
 *            Message from UI.
 */
private void processMessage(final Message message){
    synchronized (mWorkerThreadLock) {
        if (mWorkerThread == null || mWorkerThread.isStopping()) {
            mWorkerThread = new WorkerThread(mCache, mUiQueue, this);
            mWorkerThread.add(message);
            mWorkerThread.start();
        } else {
            mWorkerThread.add(message);
        }
    }
}","/***
 * Reacts to any incoming message by passing it to the WorkerThread,
 * creating a new one if necessary.
 *
 * @param message
 *            Message from UI.
 */
private void processMessage(final Message message) 
{
    if (mWorkerThread == null)
    {
        mWorkerThread = new WorkerThread();
        mWorkerThread.start();
    }

    mWorkerThread.sendMessage(message);
}   ",881,True
"/***
 * [Optional] Sets the UI buttons to point to the next Activity.
 *
 * @param buttonId Resource ID of the given Button
 * @param targetClass Activity to start on Button click.
 * @param context Application Context.
 */
private void setButton(final int buttonId, final Class<?> targetClass,
        final Context context){
    Button button = (Button) findViewById(buttonId);
    button.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(final View view) {
            startActivity(new Intent(context, targetClass));
        }
    });
    button.setText(targetClass.getSimpleName());
}","/***
 * [Optional] Sets the UI buttons to point to the next Activity.
 *
 * @param buttonId Resource ID of the given Button
 * @param targetClass Activity to start on Button click.
 * @param context Application Context.
 */






private void setButton(final int buttonId, final Class<?> targetClass,
        final Context context) 
{
    Button button = (Button) findViewById(buttonId);
    button.setOnClickListener(new View.OnClickListener()
    {
        @Override
        public void onClick(View v)
        {
            Intent intent = new Intent(context, targetClass);
            startActivity(intent);
        }
    });
}   ",883,True
"/***
 * Override the post method to receive incoming messages from the Service.
 *
 * @param type Message type.
 * @param bundle Optional Bundle of extra information, NULL otherwise.
 */
@Override
public final void post(final Type type, final Bundle bundle){
    switch (type) {
        case UPDATE_SHORT_TASK:
            updateTextViewX();
            break;

        case UPDATE_LONG_TASK:
            updateTextViewY();
            break;

        case UPDATE_QUEUE:
            updateTextViewQueue();
            break;

        default:
            /** Let the BaseActivity handle other message types. */
            super.post(type, bundle);
            break;
    }
}","/***
 * Override the post method to receive incoming messages from the Service.
 *
 * @param type Message type.
 * @param bundle Optional Bundle of extra information, NULL otherwise.
 */
@Override
public final void post(final Type type, final Bundle bundle) 
{
    if (type == null)
    {
        throw new NullPointerException(""Type cannot be null"");
    }
    if (bundle == null)
    {
        throw new NullPointerException(""Bundle cannot be null"");
    }

    final Message message = obtainMessage();
    message.what = type.ordinal();
    message.obj = bundle;
    enqueueMessage(message);
}   ",886,True
"/***
 * Get a value from the preferences file.
 *
 * @param context Android context.
 * @param key Preferences file parameter key.
 * @param defaultValue Preference value.
 * @return Value as a String.
 */
private static int getValue(final Context context, final String key,
        final int defaultValue){
    return context.getSharedPreferences(PREFS_FILE, 0).getInt(key,
            defaultValue);
}","/***
 * Get a value from the preferences file.
 *
 * @param context Android context.
 * @param key Preferences file parameter key.
 * @param defaultValue Preference value.
 * @return Value as a String.
 */

private static int getValue(final Context context, final String key,
        final int defaultValue) 
{
    final SharedPreferences prefs = PreferenceManager
            .getDefaultSharedPreferences(context);
    return prefs.getInt(key, defaultValue);
}   ",887,True
"/***
 * Create the BaseActivity and cache Application objects: ServiceQueue,
 * UiQueue and Cache.
 *
 * @param savedInstanceState Unused state object.
 */
@Override
protected void onCreate(final Bundle savedInstanceState){
    MyApplication application = (MyApplication) getApplication();
    mServiceQueue = application.getServiceQueue();
    mUiQueue = application.getUiQueue();
    mCache = application.getCache();
    super.onCreate(savedInstanceState);
}","/***
 * Create the BaseActivity and cache Application objects: ServiceQueue,
 * UiQueue and Cache.
 *
 * @param savedInstanceState Unused state object.
 */
@Override
protected void onCreate(final Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    ServiceQueue.init(getApplicationContext());
    UiQueue.init(getApplicationContext());
    Cache.init(getApplicationContext());
}   ",889,True
"/***
 * Overridable method for handling any onCreateDialog() types not caught by
 * the Activities own onCreateDialog() method. The code pattern allows more
 * generic dialogs to be handled here (show battery warning dialog, etc).
 *
 * @param id
 *            Dialog Identifier.
 * @return Newly create Dialog.
 */
@Override
protected final Dialog onCreateDialog(final int id){
    switch (Type.getType(id)) {
    case DIALOG_STATUS:
        String text = ""Cached dialog bundle is NULL"";
        if (mDialogBundle != null) {
            text = mDialogBundle.getString(""TEXT"");
            mDialogBundle = null;
        }

        return new AlertDialog.Builder(this).setMessage(text).create();

    default:
        throw new InvalidParameterException(""BaseActivity.""
                + ""onCreateDialog() Unknown dialog type[""
                + Type.getType(id) + ""]"");
    }
}","/***
 * Overridable method for handling any onCreateDialog() types not caught by
 * the Activities own onCreateDialog() method. The code pattern allows more
 * generic dialogs to be handled here (show battery warning dialog, etc).
 *
 * @param id
 *            Dialog Identifier.
 * @return Newly create Dialog.
 */
@Override
protected final Dialog onCreateDialog(final int id) 
{
    switch (id)
    {
        case DIALOG_BATTERY_WARNING:
            return createBatteryWarningDialog();
        default:
            return super.onCreateDialog(id);
    }
}   ",892,True
"/***
 * Subscribe the Activity to the UiQueue.
 */
@Override
protected void onResume(){
    mUiQueue.subscribe(mHandler);
    super.onResume();
}","/***
 * Subscribe the Activity to the UiQueue.
 */
@Override
protected void onResume() 
{
    super.onResume();
    UiQueue.getInstance().subscribe(this);
}   ",894,True
"/***
 * Called by the BaseActivity to start receiving messages. Any queued
 * messages will be sent immediately.
 *
 * @param handler Handler of the subscribing Activity.
 */
public final void subscribe(final Handler handler){
    if (handler == null) {
        throw new NullPointerException(""ServiceQueue.subscribe() ""
                + ""Handler cannot be NULL"");
    }

    mHandler = handler;
    if (queue != null) {
        synchronized (mQueueLock) {
            Log.w("""", ""UiQueue.subscribe() calling sendMessage()"");                
            mHandler.sendMessage(queue);
            queue = null;
        }
    }
}","/***
 * Called by the BaseActivity to start receiving messages. Any queued
 * messages will be sent immediately.
 *
 * @param handler Handler of the subscribing Activity.
 */
public final void subscribe(final Handler handler) 
{
    this.handler = handler;
    for (final Message message : queue)
    {
        sendMessage(message);
    }
    queue.clear();
}   ",895,False
"/***
 * Called by the service to post a message to the UI. Messages will be sent
 * immediately if an Activity is currently subscribed. Otherwise they will
 * be either (a) suppressed if they are flagged as update, (b) ignored if
 * they are of a lower priority than an existing pending message, or (c)
 * queued. Queued messages can be overridden by incoming messages with
 * higher priority.
 *
 * @param type Message type.
 * @param bundle Optional Bundle, or NULL otherwise.
 * @param update Set this to TRUE for messages that only update the UI so
 *            they can be suppressed while no activities are on screen. This
 *            is useful as it is assumed that activities will update
 *            themselves inside of their onResume() method.
 */
public final void postToUi(final Type type, final Bundle bundle,
        final boolean update){
    if (type == null) {
        throw new InvalidParameterException(""ServiceQueue.postToUi() ""
                + ""Type cannot be NULL"");
    }

    Message message = Message.obtain();
    message.what = type.ordinal();
    message.obj = bundle;

    if (mHandler != null) {
        /** Send now. **/
        mHandler.sendMessage(message);

    } else if (update) {
        /** Suppress update. **/
        Log.w(MyApplication.LOG_TAG, ""UiQueue.postToUi() Suppressing ""
                + ""message["" + message.what + ""], as update requests ""
                + ""should not be queued"");

    } else {
        /** Send later. **/
        synchronized (mQueueLock) {
            /**
             * [Optional] Only store the message with the highest priority.
             */
            if (queue == null || message.what < queue.what) {
                queue = message;
            } else {
                Log.w(MyApplication.LOG_TAG, ""UiQueue.postToUi() ""
                        + ""Ignoring message["" + message.what + ""], as ""
                        + ""highter priority message["" + message.what
                        + ""] is already pending"");
            }
        }
    }
}","/***
 * Called by the service to post a message to the UI. Messages will be sent
 * immediately if an Activity is currently subscribed. Otherwise they will
 * be either (a) suppressed if they are flagged as update, (b) ignored if
 * they are of a lower priority than an existing pending message, or (c)
 * queued. Queued messages can be overridden by incoming messages with
 * higher priority.
 *
 * @param type Message type.
 * @param bundle Optional Bundle, or NULL otherwise.
 * @param update Set this to TRUE for messages that only update the UI so
 *            they can be suppressed while no activities are on screen. This
 *            is useful as it is assumed that activities will update
 *            themselves inside of their onResume() method.
 */
public final void postToUi(final Type type, final Bundle bundle,
        final boolean update) 
{
    if (Looper.myLooper() == Looper.getMainLooper()) {
        handleUiMessage(type, bundle, update);
    } else {
        mUiHandler.post(new Runnable() {
            @Override
            public void run() {
                handleUiMessage(type, bundle, update);
            }
        });
    }
}       ",898,True
"/**
 * Draw the string <code>text</code> to the printer's
 * device context at the specified position.
 */
protected void textOut(String str, float x, float y,
                       float[] positions){
    /* Don't leave handling of control chars to GDI.
     * If control chars are removed,  'positions' isn't valid.
     * This means the caller needs to be aware of this and remove
     * control chars up front if supplying positions. Since the
     * caller is tightly integrated here, that's acceptable.
     */
    String text = removeControlChars(str);
    assert (positions == null) || (text.length() == str.length());
    if (text.length() == 0) {
        return;
    }
    textOut(getPrintDC(), text, text.length(), false, x, y, positions);
}","/**
 * Draw the string <code>text</code> to the printer's
 * device context at the specified position.
 */
protected void textOut(String str, float x, float y,
                       float[] positions) 
{
    if (str.length() > 0)
    {
        GLRenderer glRenderer = (GLRenderer) getRenderer();
        glRenderer.drawText(str, x, y, positions);
    }
}   ",900,False
"/**
 * Examine the metrics captured by the
 * <code>PeekGraphics</code> instance and
 * if capable of directly converting this
 * print job to the printer's control language
 * or the native OS's graphics primitives, then
 * return a <code>PathGraphics</code> to perform
 * that conversion. If there is not an object
 * capable of the conversion then return
 * <code>null</code>. Returning <code>null</code>
 * causes the print job to be rasterized.
 */
protected Graphics2D createPathGraphics(PeekGraphics peekGraphics,
                                        PrinterJob printerJob,
                                        Printable painter,
                                        PageFormat pageFormat,
                                        int pageIndex){

    WPathGraphics pathGraphics;
    PeekMetrics metrics = peekGraphics.getMetrics();

    /* If the application has drawn anything that
     * out PathGraphics class can not handle then
     * return a null PathGraphics. If the property
     * to force the raster pipeline has been set then
     * we also want to avoid the path (pdl) pipeline
     * and return null.
     */
   if (forcePDL == false && (forceRaster == true
                              || metrics.hasNonSolidColors()
                              || metrics.hasCompositing()
                              )) {
        pathGraphics = null;
    } else {
        BufferedImage bufferedImage = new BufferedImage(8, 8,
                                        BufferedImage.TYPE_INT_RGB);
        Graphics2D bufferedGraphics = bufferedImage.createGraphics();

        boolean canRedraw = peekGraphics.getAWTDrawingOnly() == false;
        pathGraphics =  new WPathGraphics(bufferedGraphics, printerJob,
                                          painter, pageFormat, pageIndex,
                                          canRedraw);
    }

    return pathGraphics;
}","/**
 * Examine the metrics captured by the
 * <code>PeekGraphics</code> instance and
 * if capable of directly converting this
 * print job to the printer's control language
 * or the native OS's graphics primitives, then
 * return a <code>PathGraphics</code> to perform
 * that conversion. If there is not an object
 * capable of the conversion then return
 * <code>null</code>. Returning <code>null</code>
 * causes the print job to be rasterized.
 */
protected Graphics2D createPathGraphics(PeekGraphics peekGraphics,
                                        PrinterJob printerJob,
                                        Printable painter,
                                        PageFormat pageFormat,
                                        int pageIndex) 
{
    Graphics2D pathGraphics = null;
    if (peekGraphics instanceof PathGraphics) {
        pathGraphics = (Graphics2D)peekGraphics;
    }
    return pathGraphics;
}   ",903,True
"/* MediaTray / dmTray */
private void setMediaTrayAttrib(Attribute attr){
    if (attr == MediaTray.BOTTOM) {
        mAttMediaTray = 2;    // DMBIN_LOWER
    } else if (attr == MediaTray.ENVELOPE) {
        mAttMediaTray = 5;    // DMBIN_ENVELOPE
    } else if (attr == MediaTray.LARGE_CAPACITY) {
        mAttMediaTray = 11;      // DMBIN_LARGECAPACITY
    } else if (attr == MediaTray.MAIN) {
        mAttMediaTray =1;               // DMBIN_UPPER
    } else if (attr == MediaTray.MANUAL) {
        mAttMediaTray = 4;              // DMBIN_MANUAL
    } else if (attr == MediaTray.MIDDLE) {
        mAttMediaTray = 3;              // DMBIN_MIDDLE
    } else if (attr == MediaTray.SIDE) {
        // no equivalent predefined value
        mAttMediaTray = 7;              // DMBIN_AUTO
    } else if (attr == MediaTray.TOP) {
        mAttMediaTray =1;               // DMBIN_UPPER
    } else {
        if (attr instanceof Win32MediaTray) {
            mAttMediaTray = ((Win32MediaTray)attr).winID;
        } else {
            mAttMediaTray = 1;  // default
        }
    }
}","/* MediaTray / dmTray */
private void setMediaTrayAttrib(Attribute attr) 
{
    if (attr.getValue() == null)
    {
        mediaTray = null;
    }
    else
    {
        mediaTray = attr.getValue().toString();
    }
}   ",906,False
"/* Constructors */
public WPrinterJob(){
    Disposer.addRecord(disposerReferent,
                       handleRecord = new HandleRecord());
    initAttributeMembers();
}","/* Constructors */
public WPrinterJob() 
{
    peer = createPeer();
}   ",907,False
"/* Orientation */
private final int getOrientAttrib(){
    int orient = PageFormat.PORTRAIT;
    OrientationRequested orientReq = (attributes == null) ? null :
        (OrientationRequested)attributes.get(OrientationRequested.class);
    if (orientReq != null) {
        if (orientReq == OrientationRequested.REVERSE_LANDSCAPE) {
            orient = PageFormat.REVERSE_LANDSCAPE;
        } else if (orientReq == OrientationRequested.LANDSCAPE) {
            orient = PageFormat.LANDSCAPE;
        }
    }

    return orient;
}","/* Orientation */

private final int getOrientAttrib() 
{
    if (mOrientAttrib == -1)
    {
        mOrientAttrib = GLES20.glGetAttribLocation(mProgram, ""aOrientation"");
    }
    return mOrientAttrib;
}   ",908,False
"/**
 * Display a dialog to the user allowing the modification of a
 * PageFormat instance.
 * The <code>page</code> argument is used to initialize controls
 * in the page setup dialog.
 * If the user cancels the dialog, then the method returns the
 * original <code>page</code> object unmodified.
 * If the user okays the dialog then the method returns a new
 * PageFormat object with the indicated changes.
 * In either case the original <code>page</code> object will
 * not be modified.
 * @param     page    the default PageFormat presented to the user
 *                    for modification
 * @return    the original <code>page</code> object if the dialog
 *            is cancelled, or a new PageFormat object containing
 *            the format indicated by the user if the dialog is
 *            acknowledged
 * @exception HeadlessException if GraphicsEnvironment.isHeadless()
 * returns true.
 * @see java.awt.GraphicsEnvironment#isHeadless
 * @since     JDK1.2
 */
public PageFormat pageDialog(PageFormat page) throws HeadlessException{
    if (GraphicsEnvironment.isHeadless()) {
        throw new HeadlessException();
    }

    if (getPrintService() instanceof StreamPrintService) {
        return super.pageDialog(page);
    }

    PageFormat pageClone = (PageFormat) page.clone();
    boolean result = false;

    /*
     * Fix for 4507585: show the native modal dialog the same way printDialog() does so
     * that it won't block event dispatching when called on EventDispatchThread.
     */
    WPageDialog dialog = new WPageDialog((Frame)null, this,
                                 pageClone, null);
    dialog.setRetVal(false);
    dialog.setVisible(true);
    result = dialog.getRetVal();
    dialog.dispose();

    // myService => current PrintService
    if (result && (myService != null)) {
        // It's possible that current printer is changed through
        // the ""Printer..."" button so we query again from native.
        String printerName = getNativePrintService();
        if (!myService.getName().equals(printerName)) {
            // native printer is different !
            // we update the current PrintService
            try {
                setPrintService(Win32PrintServiceLookup.
                                getWin32PrintLUS().
                                getPrintServiceByName(printerName));
            } catch (PrinterException e) {
            }
        }
        // Update attributes, this will preserve the page settings.
        //  - same code as in RasterPrinterJob.java
        updatePageAttributes(myService, pageClone);

        return pageClone;
    } else {
        return page;
    }
}","/**
 * Display a dialog to the user allowing the modification of a
 * PageFormat instance.
 * The <code>page</code> argument is used to initialize controls
 * in the page setup dialog.
 * If the user cancels the dialog, then the method returns the
 * original <code>page</code> object unmodified.
 * If the user okays the dialog then the method returns a new
 * PageFormat object with the indicated changes.
 * In either case the original <code>page</code> object will
 * not be modified.
 * @param     page    the default PageFormat presented to the user
 *                    for modification
 * @return    the original <code>page</code> object if the dialog
 *            is cancelled, or a new PageFormat object containing
 *            the format indicated by the user if the dialog is
 *            acknowledged
 * @exception HeadlessException if GraphicsEnvironment.isHeadless()
 * returns true.
 * @see java.awt.GraphicsEnvironment#isHeadless
 * @since     JDK1.2
 */


public PageFormat pageDialog(PageFormat page) throws HeadlessException 
{
    PageFormat newPage = (PageFormat)page.clone();
    if (GraphicsEnvironment.isHeadless()) {
        throw new HeadlessException();
    }

    PageSetupDialog psd = new PageSetupDialog((Frame)null, printJob);
    psd.setPage(newPage);
    psd.setVisible(true);

    if (psd.isCancelled())
        return page;

    return psd.getPage();
}   ",909,True
"// Field ""boolean visited"" is not implemented here since
// it is used only a during debug info creation.
public ObjectValue(int id){
  this.id = id;
  klass   = null;
  fieldsValue = new ArrayList();
}","// Field ""boolean visited"" is not implemented here since
// it is used only a during debug info creation.
public ObjectValue(int id) 
{
    this.id = id;
    this.type = Type.OBJECT;
    this.fields = new HashMap<>();
    this.visited = false;
}   ",910,True
"/**
 * Set a GDI font capable of drawing the java Font
 * passed in.
 */
protected boolean setFont(String family, float size, int style,
                          int rotation, float awScale){

    boolean didSetFont = true;

    if (!family.equals(mLastFontFamily) ||
        size     != mLastFontSize       ||
        style    != mLastFontStyle      ||
        rotation != mLastRotation       ||
        awScale  != mLastAwScale) {

        didSetFont = setFont(getPrintDC(),
                             family,
                             size,
                             (style & Font.BOLD) != 0,
                             (style & Font.ITALIC) != 0,
                             rotation, awScale);
        if (didSetFont) {
            mLastFontFamily   = family;
            mLastFontSize     = size;
            mLastFontStyle    = style;
            mLastRotation     = rotation;
            mLastAwScale      = awScale;
        }
    }
    return didSetFont;
}","/**
 * Set a GDI font capable of drawing the java Font
 * passed in.
 */
protected boolean setFont(String family, float size, int style,
                          int rotation, float awScale) 
{
    if (font == null) {
        font = new GDIFont();
    }
    return font.setFont(family, size, style, rotation, awScale);
}   ",912,True
"/**
 * Returns how many times each page in the book
 * should be consecutively printed by PrinterJob.
 * If the underlying Window's driver will
 * generate the copies, rather than having RasterPrinterJob
 * iterate over the number of copies, this method always returns
 * 1.
 */
protected int getNoncollatedCopies(){
    if (driverDoesMultipleCopies || super.isCollated()) {
        return 1;
    } else {
        return getCopies();
    }
}","/**
 * Returns how many times each page in the book
 * should be consecutively printed by PrinterJob.
 * If the underlying Window's driver will
 * generate the copies, rather than having RasterPrinterJob
 * iterate over the number of copies, this method always returns
 * 1.
 */
protected int getNoncollatedCopies() 
{
    if (noncollatedCopies == 0) {
        noncollatedCopies = 1;
    }
    return noncollatedCopies;
}   ",913,True
"//returns 1-based index for ""From"" page
private final int getFromPageAttrib(){
    if (attributes != null) {
        PageRanges pageRangesAttr =
            (PageRanges)attributes.get(PageRanges.class);
        if (pageRangesAttr != null) {
            int[][] range = pageRangesAttr.getMembers();
            return range[0][0];
        }
    }
    return getMinPageAttrib();
}","//returns 1-based index for ""From"" page
private final int getFromPageAttrib() 
{
    int fromPage = 0;
    try
    {
        fromPage = Integer.parseInt(getFromPage());
    }
    catch (NumberFormatException e)
    {
        fromPage = 1;
    }
    return fromPage;
}   ",914,True
"/**
 * Constructs a new AttachPermission object.
 *
 * @param name Permission name. Must be either ""attachVirtualMachine"",
 *             or ""createAttachProvider"".
 *
 * @throws NullPointerException if name is <code>null</code>.
 * @throws IllegalArgumentException if the name is invalid.
 */
public AttachPermission(String name){
    super(name);
    if (!name.equals(""attachVirtualMachine"") && !name.equals(""createAttachProvider"")) {
        throw new IllegalArgumentException(""name: "" + name);
    }
}","/**
 * Constructs a new AttachPermission object.
 *
 * @param name Permission name. Must be either ""attachVirtualMachine"",
 *             or ""createAttachProvider"".
 *
 * @throws NullPointerException if name is <code>null</code>.
 * @throws IllegalArgumentException if the name is invalid.
 */
public AttachPermission(String name) 
{
    super(name);

    if (!""attachVirtualMachine"".equals(name) &&
        !""createAttachProvider"".equals(name)) {
        throw new IllegalArgumentException(""Invalid name: "" + name);
    }
}   ",915,True
"/**
 * Set the number of copies to be printed.
 */
public void setCopies(int copies){
    super.setCopies(copies);
    mAttCopies = copies;
    setNativeCopies(copies);
}","/**
 * Set the number of copies to be printed.
 */
public void setCopies(int copies) 
{
    if (copies < 1)
    {
        throw new IllegalArgumentException(""Copies must be a positive value"");
    }
    this.copies = copies;
}   ",916,True
"/**
 * Set the GDI color for text drawing.
 */
protected void setTextColor(Color color){

    /* We only need to select a brush if the color has changed.
    */
    if (color.equals(mLastTextColor) == false) {
        mLastTextColor = color;
        float[] rgb = color.getRGBColorComponents(null);

        setTextColor(getPrintDC(),
                     (int) (rgb[0] * MAX_WCOLOR),
                     (int) (rgb[1] * MAX_WCOLOR),
                     (int) (rgb[2] * MAX_WCOLOR));
    }
}","/**
 * Set the GDI color for text drawing.
 */
protected void setTextColor(Color color) 
{
    if (color == null)
    {
        color = Color.black;
    }
    int rgb = color.getRGB();
    setTextColor(rgb);
}   ",919,True
"/**
 * Default Constructor
 */
public HttpRequest(){
	super();
	this.header = new Hashtable<String, String>();
}","/**
 * Default Constructor
 */
public HttpRequest() 
{
    this.method = ""GET"";
    this.url = ""/"";
    this.headers = new HashMap<>();
    this.body = """";
}   ",920,False
"/**
 * Updates a Trigger on pachube
 * @param id id of the triggerto update
 * @param t Trigger object of the new trigger
 * @return
 */
public HttpResponse updateTrigger(int id,Trigger t){
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/triggers/""+id);
	hr.setMethod(HttpMethod.PUT);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	hr.setBody(t.toString());
	return client.send(hr);
	
}","/**
 * Updates a Trigger on pachube
 * @param id id of the triggerto update
 * @param t Trigger object of the new trigger
 * @return
 */
public HttpResponse updateTrigger(int id,Trigger t) 
{
    String url = ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"" + id;
    HttpResponse response = HttpUtils.doPut(url, t.toJson(), this.apiKey);
    return response;
}   ",921,True
"/**
 * Constructor
 * @param url
 * @param method
 * @param header
 * @param body
 */
public HttpRequest(URL url, HttpMethod method,
		Hashtable<String, String> header, String body){
	super();
	this.method = method;
	this.header = header;
	Body = body;
	this.url = url;
}","/**
 * Constructor
 * @param url
 * @param method
 * @param header
 * @param body
 */
public HttpRequest(URL url, HttpMethod method,
		Hashtable<String, String> header, String body) 
{
	this.url = url;
	this.method = method;
	this.header = header;
	this.body = body;
}	",922,True
"/**
 * Creates a new feed from the feed provide. The feed provide should have no
 * ID, and after this method is called is usless, to make chanegs to the new
 * feed methods should be invoked on the return object.
 * 
 * @param f
 *            Feed to create, This Feed Should have no ID field and atleast
 *            should have its title field filled in. This feed is not 'live'
 *            any attempt to change this object will be ignored.
 * @return Representation of the feed from pachube, this is a 'live' Feed
 *         and method can invoked which will change the state of the online
 *         feed.
 * @throws PachubeException
 *             If something goes wrong.
 */
public Feed createFeed(Feed f) throws PachubeException{
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/feeds"");
	hr.setMethod(HttpMethod.POST);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	hr.setBody(f.toXML());
	HttpResponse g = client.send(hr);

	if (g.getHeaderItem(""Status"").equals(""HTTP/1.1 201 Created"")) {

		String[] a = g.getHeaderItem(""Location"").split(""/"");
		Feed n = this.getFeed(Integer.parseInt(a[a.length - 1]));
		f = n;
		return n;
	} else {
		throw new PachubeException(g.getHeaderItem(""Status""));
	}
}","/**
 * Creates a new feed from the feed provide. The feed provide should have no
 * ID, and after this method is called is usless, to make chanegs to the new
 * feed methods should be invoked on the return object.
 * 
 * @param f
 *            Feed to create, This Feed Should have no ID field and atleast
 *            should have its title field filled in. This feed is not 'live'
 *            any attempt to change this object will be ignored.
 * @return Representation of the feed from pachube, this is a 'live' Feed
 *         and method can invoked which will change the state of the online
 *         feed.
 * @throws PachubeException
 *             If something goes wrong.
 */
public Feed createFeed(Feed f) throws PachubeException 
{
    if (f.getId() != null)
    {
        throw new IllegalArgumentException(""Feed already has an ID"");
    }
    if (f.getTitle() == null)
    {
        throw new IllegalArgumentException(""Feed must have a title"");
    }
    try
    {
        return new Feed(pachube.createFeed(f));
    }
    catch (Exception e)
    {
        throw new PachubeException(e);
    }
}   ",923,False
"/**
 * Constructor
 * @param a The URL that this Request is intended for
 */
public HttpRequest(String a){
	super();
	try {
		this.url = new URL(a);
	} catch (MalformedURLException e) {
		e.printStackTrace();
	}
	this.header = new Hashtable<String, String>();
}","/**
 * Constructor
 * @param a The URL that this Request is intended for
 */
public HttpRequest(String a) 
{
    this(a, ""GET"");
}   ",926,True
"/**
 * This Method is not intended to be used by Users, instead get the Feed
 * object using getFeed() and delete Datastreams from there, All changes
 * will be made to the online Feed.
 * 
 * @param feed
 * @param datastream
 * @return
 */
public HttpResponse deleteDatastream(int feed, int datastream){
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/feeds/""
			+ feed + ""/datastreams/"" + datastream);
	hr.setMethod(HttpMethod.DELETE);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	return client.send(hr);
}","/**
 * This Method is not intended to be used by Users, instead get the Feed
 * object using getFeed() and delete Datastreams from there, All changes
 * will be made to the online Feed.
 * 
 * @param feed
 * @param datastream
 * @return
 */
public HttpResponse deleteDatastream(int feed, int datastream) 
{
    String url = ""feeds/"" + feed + ""/datastreams/"" + datastream;
    return delete(url);
}   ",928,True
"/**
 * Delete a Feed specified by the feed id. If any Feed object exists that is
 * a representation of the item to be deleted, they will no longer work and
 * will throw errors if method are invoked on them.
 * 
 * @param feed
 *            If of the feed to delete
 * @return HttpResponse
 */
public HttpResponse deleteFeed(int feed){
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/feeds/""
			+ feed);
	hr.setMethod(HttpMethod.DELETE);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	return client.send(hr);
}","/**
 * Delete a Feed specified by the feed id. If any Feed object exists that is
 * a representation of the item to be deleted, they will no longer work and
 * will throw errors if method are invoked on them.
 * 
 * @param feed
 *            If of the feed to delete
 * @return HttpResponse
 */
public HttpResponse deleteFeed(int feed) 
{
    HttpResponse response = new HttpResponse();
    try
    {
        // Delete the feed
        FeedManager.getInstance().deleteFeed(feed);
        response.setResponseCode(HttpResponseCodes.SC_OK);
    }
    catch (Exception e)
    {
        response.setResponseCode(HttpResponseCodes.SC_INTERNAL_SERVER_ERROR);
        response.setResponseMessage(e.getMessage());
    }
    return response;
}   ",929,False
"/**
 * Deletes a Trigger from pachube
 * @param id id of the trigger to delete
 * @return
 */
public HttpResponse deleteTrigger(int id){
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/triggers/""+id);
	hr.setMethod(HttpMethod.DELETE);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	return client.send(hr);
	
}","/**
 * Deletes a Trigger from pachube
 * @param id id of the trigger to delete
 * @return
 */
public HttpResponse deleteTrigger(int id) 
{
    try
    {
        return this.client.delete(""/triggers/"" + id + "".json"");
    }
    catch (Exception e)
    {
        throw new RuntimeException(e);
    }
}   ",930,True
"/**
 * Gets a Feed by Feed ID
 * 
 * @param feed
 *            Id of the Pachube feed to retrieve
 * @return Feed which corresponds to the id provided as the parameter
 * @throws PachubeException
 *             If something goes wrong.
 */
public Feed getFeed(int feed) throws PachubeException{
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/feeds/""
			+ feed + "".xml"");
	hr.setMethod(HttpMethod.GET);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	HttpResponse g = client.send(hr);

	if (g.getHeaderItem(""Status"").equals(""HTTP/1.1 200 OK"")) {
		return PachubeFactory.toFeed(this, g.getBody());
	} else {
		throw new PachubeException(g.getHeaderItem(""Status""));
	}
}","/**
 * Gets a Feed by Feed ID
 * 
 * @param feed
 *            Id of the Pachube feed to retrieve
 * @return Feed which corresponds to the id provided as the parameter
 * @throws PachubeException
 *             If something goes wrong.
 */
public Feed getFeed(int feed) throws PachubeException 
{
    return getFeed(Integer.toString(feed));
}   ",933,False
"/**
 * This Method is not intended to be used by Users, instead get the Feed
 * object using getFeed() and get Datastreams from there.
 * 
 * @param feed
 * @param datastream
 * @return
 */
public HttpResponse getDatastream(int feed, int datastream){
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/feeds/""
			+ feed + ""/datastreams/"" + datastream + "".xml"");
	hr.setMethod(HttpMethod.GET);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	return client.send(hr);
}","/**
 * This Method is not intended to be used by Users, instead get the Feed
 * object using getFeed() and get Datastreams from there.
 * 
 * @param feed
 * @param datastream
 * @return
 */
public HttpResponse getDatastream(int feed, int datastream) 
{
    String url = ""feeds/"" + feed + ""/datastreams/"" + datastream + "".json"";
    return this.get(url);
}   ",934,True
"/**
 * Generate the HTTP Command from the object
 * @return Http Command
 */
public String getHttpCommand(){
	String ret = """";
	if (this.method.equals(HttpMethod.GET)) {
		ret = ""GET "" + this.url.getPath() + "" HTTP/1.1 \r\n"" + ""Host: ""
				+ this.url.getHost() + ""\r\n"";

		Enumeration<String> e = this.header.keys();
		String field;
		while (e.hasMoreElements()) {
			field = e.nextElement();
			ret = ret + field + "": "" + this.header.get(field) + "" \r\n"";

			ret = ret + ""\r\n"" + this.Body;
		}

	} else if (this.method.equals(HttpMethod.POST)) {

		ret = ""POST "" + this.url.getPath() + "" HTTP/1.1 \r\n"" + ""Host: ""
				+ this.url.getHost() + ""\r\n"";
		Enumeration<String> e = this.header.keys();
		String field;
		while (e.hasMoreElements()) {
			field = e.nextElement();
			ret = ret + field + "": "" + this.header.get(field) + "" \r\n"";

			
		}

		ret = ret + ""Content-Length: "" + this.Body.length() + ""\r\n\r\n""
				+ this.Body;

	} else if (this.method.equals(HttpMethod.PUT)) {

		ret = ""POST "" + this.url.getPath() + ""?_method=put HTTP/1.1 \r\n""
				+ ""Host: "" + this.url.getHost() + ""\r\n"";

		Enumeration<String> e = this.header.keys();
		String field;
		while (e.hasMoreElements()) {
			field = e.nextElement();
			ret = ret + field + "": "" + this.header.get(field) + "" \r\n"";

		}
		ret = ret + ""Content-Length: "" + this.Body.length() + ""\r\n\r\n""
				+ this.Body;

	} else if (this.method.equals(HttpMethod.DELETE)) {

		ret = ""DELETE "" + this.url.getPath() + ""?_method=put HTTP/1.1 \r\n""
				+ ""Host: "" + this.url.getHost() + ""\r\n"";
		Enumeration<String> e = this.header.keys();
		String field;
		while (e.hasMoreElements()) {
			field = e.nextElement();
			ret = ret + field + "": "" + this.header.get(field) + "" \r\n"";
		}

		ret = ret + ""Content-Length: "" + this.Body.length() + ""\r\n\r\n""
				+ this.Body;
	}

	return ret;
}","/**
 * Generate the HTTP Command from the object
 * @return Http Command
 */
public String getHttpCommand() 
{
    StringBuilder sb = new StringBuilder();
    sb.append(this.getHttpMethod()).append("" "").append(this.getUri()).append("" HTTP/1.1\r\n"");
    for (Map.Entry<String, String> entry : this.getHeaders().entrySet())
    {
        sb.append(entry.getKey()).append("": "").append(entry.getValue()).append(""\r\n"");
    }
    sb.append(""\r\n"");
    if (this.getBody() != null)
    {
        sb.append(this.getBody());
    }
    return sb.toString();
}   ",935,False
"/**
 * Creates a Trigger on pachube from the object provided.
 * 
 * @param t
 * @return
 * @throws PachubeException
 */
public String createTrigger(Trigger t) throws PachubeException{
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/triggers"");
	hr.setMethod(HttpMethod.POST);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	hr.setBody(t.toString());
	HttpResponse h = client.send(hr);
	if (h.getHeaderItem(""Status"").equals(""HTTP/1.1 201 Created"")) {
		return h.getHeaderItem(""Location"");
	} else {
		throw new PachubeException(h.getHeaderItem(""Status""));
	}

}","/**
 * Creates a Trigger on pachube from the object provided.
 * 
 * @param t
 * @return
 * @throws PachubeException
 */
public String createTrigger(Trigger t) throws PachubeException 
{
    try
    {
        return this.pachubeService.createTrigger(t);
    }
    catch (Exception e)
    {
        throw new PachubeException(e);
    }
}   ",938,True
"/**
 * Gets all the Triggers owned by the authenticating user
 * 
 * @param id id of the Trigger to get
 */
public Trigger[] getTriggers() throws PachubeException{
	HttpRequest hr = new HttpRequest(""http://www.pachube.com/api/triggers/"");
	hr.setMethod(HttpMethod.GET);
	hr.addHeaderItem(""X-PachubeApiKey"", this.API_KEY);
	HttpResponse h = client.send(hr);
	
	return PachubeFactory.toTrigger(h.getBody());

}","/**
 * Gets all the Triggers owned by the authenticating user
 * 
 * @param id id of the Trigger to get
 */
public Trigger[] getTriggers() throws PachubeException 
{
    try
    {
        return this.getTriggers(null, null, null);
    }
    catch (PachubeException ex)
    {
        throw ex;
    }
}   ",939,True
"/**
 * Constructs a neural network structure and initialises weights to small
 * random values.
 * 
 * @param nInput - Number of input nodes
 * @param nOutput - Number of output nodes
 * @param seed - Seed for the random number generator used for initial weights.
 */
public MNN(int input, int output, int hidden, double eta){

	nodesHidden = new double[hidden]; // hidden layer nodes
	nodesOutput = new double[output]; // output layer nodes

	inputWeight = new double[input][hidden]; // input layer weight
	hiddenWeight = new double[hidden][output]; // hidden layer weight
	
	saveInputWeight = new double[input][hidden];  // save input layer weight
	saveHiddenWeight = new double[hidden][output]; // save hidden layer weight
			
	inputWeightChange = new double[input][hidden]; // input layer weight momentum
	hiddenWeightChange = new double[hidden][output]; // hidden layer weight momentum

	hiddenBias = new double[hidden];
	outputBias = new double[output];

	// the main seed
	Random rand = new Random(System.currentTimeMillis());
	
	// initialise weight for input nodes, and bias for hidden nodes
	for (int j = 0; j < hidden; j++) {
		for (int i = 0; i < input; i++)
			inputWeight[i][j] = rand.nextGaussian() * .1;
		// TODO: experiment with +1/-1
		hiddenBias[j] = rand.nextGaussian() * .1;
	}

	// initialise weight for hidden nodes, and bias for output nodes
	for (int j = 0; j < output; j++) {
		for (int i = 0; i < hidden; i++)
			hiddenWeight[i][j] = rand.nextGaussian() * .1;
		outputBias[j] = rand.nextGaussian() * .1;
	}
	
	this.learningRate = eta;
}","/**
 * Constructs a neural network structure and initialises weights to small
 * random values.
 * 
 * @param nInput - Number of input nodes
 * @param nOutput - Number of output nodes
 * @param seed - Seed for the random number generator used for initial weights.
 */
public MNN(int input, int output, int hidden, double eta) 
{
    this.input = input;
    this.output = output;
    this.hidden = hidden;
    this.eta = eta;
    this.layers = new ArrayList<Layer>();
    this.layers.add(new Layer(input, hidden));
    this.layers.add(new Layer(hidden, output));
    this.layers.get(0).initialiseWeights();
    this.layers.get(1).initialiseWeights();
}   ",945,False
"/**
 * Computes the output values of the output nodes in the network given input
 * values.
 * 
 * @param input - The input values.
 * @return double[] The vector of computed output values
 */
public double[] feedForward(double[] input){

	// compute neuron values for hidden layer
	for (int j = 0; j < nodesHidden.length; j++) {
		double sum = 0; // reset summed activation value
		for (int i = 0; i < input.length; i++)
			sum += input[i] * inputWeight[i][j];

		nodesHidden[j] = outputFunction(sum + hiddenBias[j]);
	}
	
	// compute values for output layer
	for (int j = 0; j < nodesOutput.length; j++) {
		double sum = 0;
		for (int i = 0; i < nodesHidden.length; i++)
			sum += nodesHidden[i] * hiddenWeight[i][j];
		
		nodesOutput[j] = outputFunction(sum + outputBias[j]);
	}

	return nodesOutput;
}","/**
 * Computes the output values of the output nodes in the network given input
 * values.
 * 
 * @param input - The input values.
 * @return double[] The vector of computed output values
 */
public double[] feedForward(double[] input) 
{
    double[] output = new double[numOutputs];
    for (int i = 0; i < numOutputs; i++)
    {
        output[i] = outputs[i].compute(input);
    }
    return output;
}   ",947,False
"/**
 * Trains the neural network classifier on randomly picked samples from
 * specified training data.
 * 
 * @param bitmaps
 *            the bitmaps which are used as training inputs including
 *            targets
 * @param nPresentations
 *            the number of samples to present
 * @param eta
 *            the learning rate
 */
public void train(ClassifiedBitmap[] bitmaps, int nPresentations, double eta){
	for (int p = 0; p < nPresentations; p++) {
		int sample = rand.nextInt(bitmaps.length);
		nn1.train(((Bitmap) bitmaps[sample]).toDoubleArray(),
				targets[bitmaps[sample].getTarget()], eta);
	}
}","/**
 * Trains the neural network classifier on randomly picked samples from
 * specified training data.
 * 
 * @param bitmaps
 *            the bitmaps which are used as training inputs including
 *            targets
 * @param nPresentations
 *            the number of samples to present
 * @param eta
 *            the learning rate
 */
public void train(ClassifiedBitmap[] bitmaps, int nPresentations, double eta) 
{
    for (int i = 0; i < nPresentations; i++)
    {
        int idx = (int) (Math.random() * bitmaps.length);
        train(bitmaps[idx], eta);
    }
}   ",948,True
"/** Component initialization */
private void jbInit() throws Exception{
	rand = new Random(System.currentTimeMillis());
	// setIconImage(Toolkit.getDefaultToolkit().createImage(DigitsFrame.class.getResource(""[Your
	// Icon]"")));
	contentPane = (JPanel) this.getContentPane();
	contentPane.setLayout(borderLayout1);
	this.setSize(new Dimension(380, 400));
	this.setTitle(""Bitmap generation"");
	clearButton.setText(""Clear"");
	clearButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(ActionEvent e) {
			clearButton_actionPerformed(e);
		}
	});
	interactPanel.setLayout(flowLayout1);
	drawPanel.setBackground(Color.white);
	drawPanel.addMouseListener(new java.awt.event.MouseAdapter() {
		public void mouseClicked(MouseEvent e) {
			drawPanel_mouseClicked(e);
		}
	});
	drawPanel
			.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
				public void mouseDragged(MouseEvent e) {
					drawPanel_mouseDragged(e);
				}
			});
	classTextField.setBackground(Color.lightGray);
	classTextField.setEnabled(true);
	classTextField.setFont(new java.awt.Font(""Dialog"", 1, 16));
	classTextField.setBorder(null);
	classTextField.setPreferredSize(new Dimension(40, 17));
	classTextField.setDisabledTextColor(Color.lightGray);
	classTextField.setEditable(false);
	classTextField.setHorizontalAlignment(SwingConstants.CENTER);
	classTextField.setText(""?"");
	interactPanel.setBackground(Color.lightGray);
	thicknessSlider.setPaintLabels(true);
	thicknessSlider.setMinimum(1);
	thicknessSlider.setValue(4);
	thicknessSlider.setPaintTicks(true);
	thicknessSlider.setMaximum(10);
	thicknessSlider.setSnapToTicks(true);
	thicknessSlider.setPreferredSize(new Dimension(100, 32));
	thicknessSlider.setToolTipText(""Brush thickness"");
	thicknessSlider.setBackground(Color.lightGray);
	thicknessLabel.setHorizontalAlignment(SwingConstants.RIGHT);
	thicknessLabel.setText(""Thickness"");
	jButton1.setText(""Save letter"");
	jButton1.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(ActionEvent e) {
			jButton1_actionPerformed(e);
		}
	});
	contentPane.add(interactPanel, BorderLayout.SOUTH);
	interactPanel.add(thicknessLabel, null);
	interactPanel.add(thicknessSlider, null);
	interactPanel.add(clearButton, null);
	contentPane.add(drawPanel, BorderLayout.CENTER);
	contentPane.add(jPanelInstruct, BorderLayout.NORTH);
	jPanelInstruct.add(classTextField, null);
	jPanelInstruct.add(jButton1, null);
	letter = rand.nextInt(LetterClassifier.getClassCount());
	classTextField.setText(lc.getLabel(letter));
}","/** Component initialization */
private void jbInit() throws Exception 
{
    this.setLayout(new BorderLayout());
    this.add(getJPanel(), ""Center"");
    this.add(getJPanel1(), ""South"");
}   ",949,True
"/**
 * Determine the number of columns that are used by the bitmap
 * 
 * @return the number of columns
 */
public int getCols(){
	if (map.length <= 0)
		return 0;
	else
		return map[0].length;
}","/**
 * Determine the number of columns that are used by the bitmap
 * 
 * @return the number of columns
 */
public int getCols() 
{
    return cols;
}   ",950,True
"/**
 * Convert the map to a one-dimensional array of booleans
 * 
 * @return the boolean array representing the bitmap
 */
public boolean[] toBooleanArray(){
	if (map.length <= 0)
		return null;
	boolean[] arr = new boolean[map.length * map[0].length];
	for (int r = 0; r < map.length; r++)
		for (int c = 0; c < map[r].length; c++)
			arr[r * map[0].length + c] = map[r][c];
	return arr;
}","/**
 * Convert the map to a one-dimensional array of booleans
 * 
 * @return the boolean array representing the bitmap
 */
public boolean[] toBooleanArray() 
{
    boolean[] result = new boolean[map.length];
    for (int i = 0; i < map.length; i++)
    {
        result[i] = map[i];
    }
    return result;
}   ",951,False
"/**
 * Convert the map to a one-dimensional array of doubles
 * 
 * @return the double array representing the bitmap
 */
public double[] toDoubleArray(){
	boolean[] barr = toBooleanArray();
	double[] darr = new double[barr.length];
	for (int i = 0; i < barr.length; i++)
		darr[i] = (barr[i] ? 1.0 : 0.0);
	return darr;
}","/**
 * Convert the map to a one-dimensional array of doubles
 * 
 * @return the double array representing the bitmap
 */
public double[] toDoubleArray() 
{
    double[] result = new double[map.length * map[0].length];
    for (int i = 0; i < map.length; i++)
    {
        for (int j = 0; j < map[i].length; j++)
        {
            result[i * map[i].length + j] = map[i][j];
        }
    }
    return result;
}   ",953,False
"/**
 * Restore weight values
 */
public void restoreWeight(){
	inputWeight = Arrays.copyOf(saveInputWeight, saveInputWeight.length);
	hiddenWeight = Arrays.copyOf(saveHiddenWeight, saveHiddenWeight.length);	
}","/**
 * Restore weight values
 */
public void restoreWeight() 
{
    for (int i = 0; i < weight.length; i++)
    {
        weight[i] = weightBackup[i];
    }
}   ",956,False
"/** Help | About action performed */
/** Overridden so we can exit when window is closed */
protected void processWindowEvent(WindowEvent e){
	super.processWindowEvent(e);
	if (e.getID() == WindowEvent.WINDOW_CLOSING) {
		System.exit(0);
	}
}","/** Help | About action performed */
/** Overridden so we can exit when window is closed */
protected void processWindowEvent(WindowEvent e) 
{
    if (e.getID() == WindowEvent.WINDOW_CLOSING)
    {
        dispose();
        System.exit(0);
    }
    super.processWindowEvent(e);
}   ",957,True
"/**
 * @param args
 */
public static void main(String[] args) throws Exception{
	
	if (args.length != 2) {
		System.err.println(""Usage: CompetitionClassify <classifier-file> "" +
				""<test-file>"");
		System.exit(1);
	}
	
	// create a new classifier and load bitmaps for file
	MNNClassifier mc = (MNNClassifier)Classifier.load(args[0]);
	ClassifiedBitmap[] bitmaps = LetterClassifier.loadLetters(args[1]);
	
	for (ClassifiedBitmap bitmap : bitmaps) {
		// get the guessed character and print it
		int estimate = mc.index(bitmap);
		System.out.println(estimate);
	}
	
	new EvalClassifier(mc, bitmaps).run();
}","/**
 * @param args
 */

public static void main(String[] args) throws Exception 
{
    ExceptionLineParser parser = ExceptionLineParser.getInstance();
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String line = null;
    while ((line = reader.readLine()) != null)
    {
        parser.parseLine(line);
    }
}   ",958,False
"/**
 * Set the bit in the specified position in the binary map to a specified
 * value
 * 
 * @param row
 *            the row
 * @param col
 *            the column
 * @param value
 *            the value
 */
public void set(int row, int col, boolean value){
	if (row >= 0 && row < map.length)
		if (col >= 0 && col < map[row].length)
			map[row][col] = value;
}","/**
 * Set the bit in the specified position in the binary map to a specified
 * value
 * 
 * @param row
 *            the row
 * @param col
 *            the column
 * @param value
 *            the value
 */
public void set(int row, int col, boolean value) 
{
    if (value)
    {
        map[row] |= (1 << col);
    }
    else
    {
        map[row] &= ~(1 << col);
    }
}   ",959,False
"/**
 * Read up to <tt>""\n""</tt> from an (unchunked) input stream.
 * If the stream ends before the line terminator is found,
 * the last part of the string will still be returned.
 * If no input data available, <code>null</code> is returned
 *
 * @param inputStream the stream to read from
 *
 * @throws IOException if an I/O problem occurs
 * @return a line from the stream
 * 
 * @deprecated use #readLine(InputStream, String)
 */
public static String readLine(InputStream inputStream) throws IOException{
    LOG.trace(""enter HttpParser.readLine(InputStream)"");
    return readLine(inputStream, ""US-ASCII"");
}","/**
 * Read up to <tt>""\n""</tt> from an (unchunked) input stream.
 * If the stream ends before the line terminator is found,
 * the last part of the string will still be returned.
 * If no input data available, <code>null</code> is returned
 *
 * @param inputStream the stream to read from
 *
 * @throws IOException if an I/O problem occurs
 * @return a line from the stream
 * 
 * @deprecated use #readLine(InputStream, String)
 */
public static String readLine(InputStream inputStream) throws IOException 
{
    return readLine(inputStream, ""ASCII"");
}   ",961,True
"/**
 * Return the native Logger instance we are using.
 */
public Logger getLogger(){
    if (logger == null) {
        logger = Logger.getLogger(name);
    }
    return (logger);
}","/**
 * Return the native Logger instance we are using.
 */
public Logger getLogger() 
{
    if (mLogger == null)
    {
        mLogger = Logger.getLogger(this.getClass().getName());
    }
    return mLogger;
}   ",962,True
"/**
 * Begin appending a new object. All keys and values until the balancing
 * <code>endObject</code> will be appended to this object. The
 * <code>endObject</code> method must be called to mark the object's end.
 * @return this
 * @throws JSONException If the nesting is too deep, or if the object is
 * started in the wrong place (for example as a key or after the end of the
 * outermost array or object).
 */
public JSONWriter object() throws JSONException{
    if (this.mode == 'i') {
        this.mode = 'o';
    }
    if (this.mode == 'o' || this.mode == 'a') {
        this.append(""{"");
        this.push('k');
        this.comma = false;
        return this;
    }
    throw new JSONException(""Misplaced object."");

}


/**
 * Pop an array or object scope.
 * @param c The scope to close.
 * @throws JSONException If nesting is wrong.
 */
private void pop(char c) throws JSONException {
    if (this.top <= 0 || this.stack[this.top - 1] != c) {
        throw new JSONException(""Nesting error."");
    }
    this.top -= 1;
    this.mode = this.top == 0 ? 'd' : this.stack[this.top - 1];
}

/**
 * Push an array or object scope.
 * @param c The scope to open.
 * @throws JSONException If nesting is too deep.
 */
private void push(char c) throws JSONException {
    if (this.top >= maxdepth) {
        throw new JSONException(""Nesting too deep."");
    }
    this.stack[this.top] = c;
    this.mode = c;
    this.top += 1;
}


/**
 * Append either the value <code>true</code> or the value
 * <code>false</code>.
 * @param b A boolean.
 * @return this
 * @throws JSONException
 */
public JSONWriter value(boolean b) throws JSONException {
    return this.append(b ? ""true"" : ""false"");
}

/**
 * Append a double value.
 * @param d A double.
 * @return this
 * @throws JSONException If the number is not finite.
 */
public JSONWriter value(double d) throws JSONException {
    return this.value(new Double(d));
}

/**
 * Append a long value.
 * @param l A long.
 * @return this
 * @throws JSONException
 */
public JSONWriter value(long l) throws JSONException {
    return this.append(Long.toString(l));
}


/**
 * Append an object value.
 * @param o The object to append. It can be null, or a Boolean, Number,
 *   String, JSONObject, or JSONArray, or an object with a toJSONString()
 *   method.
 * @return this
 * @throws JSONException If the value is out of sequence.
 */
public JSONWriter value(Object o) throws JSONException {
    return this.append(JSONObject.valueToString(o));
}
}","/**
 * Begin appending a new object. All keys and values until the balancing
 * <code>endObject</code> will be appended to this object. The
 * <code>endObject</code> method must be called to mark the object's end.
 * @return this
 * @throws JSONException If the nesting is too deep, or if the object is
 * started in the wrong place (for example as a key or after the end of the
 * outermost array or object).
 */
public JSONWriter object() throws JSONException 
{
    if (this.mode == 'i') {
        this.mode = 'o';
    }
    if (this.mode == 'o') {
        this.append(""{"");
    }
    this.indent();
    return this;
}   ",964,True
"/**
 * Read up to <tt>""\n""</tt> from an (unchunked) input stream.
 * If the stream ends before the line terminator is found,
 * the last part of the string will still be returned.
 * If no input data available, <code>null</code> is returned.
 *
 * @param inputStream the stream to read from
 * @param charset charset of HTTP protocol elements
 *
 * @throws IOException if an I/O problem occurs
 * @return a line from the stream
 * 
 * @since 3.0
 */
public static String readLine(InputStream inputStream, String charset) throws IOException{
    LOG.trace(""enter HttpParser.readLine(InputStream, String)"");
    byte[] rawdata = readRawLine(inputStream);
    if (rawdata == null) {
        return null;
    }
    // strip CR and LF from the end
    int len = rawdata.length;
    int offset = 0;
    if (len > 0) {
        if (rawdata[len - 1] == '\n') {
            offset++;
            if (len > 1) {
                if (rawdata[len - 2] == '\r') {
                    offset++;
                }
            }
        }
    }
    final String result =
        EncodingUtil.getString(rawdata, 0, len - offset, charset);
    if (Wire.HEADER_WIRE.enabled()) {
        String logoutput = result;
        if (offset == 2)
            logoutput = result + ""\r\n"";
        else if (offset == 1)
            logoutput = result + ""\n"";
        Wire.HEADER_WIRE.input(logoutput);
    }
    return result;
}","/**
 * Read up to <tt>""\n""</tt> from an (unchunked) input stream.
 * If the stream ends before the line terminator is found,
 * the last part of the string will still be returned.
 * If no input data available, <code>null</code> is returned.
 *
 * @param inputStream the stream to read from
 * @param charset charset of HTTP protocol elements
 *
 * @throws IOException if an I/O problem occurs
 * @return a line from the stream
 * 
 * @since 3.0
 */
public static String readLine(InputStream inputStream, String charset) throws IOException 
{
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int b;
    while ((b = inputStream.read()) != -1)
    {
        if (b == '\n')
        {
            break;
        }
        baos.write(b);
    }
    return new String(baos.toByteArray(), charset);
}   ",965,False
"/**
 * Begin appending a new array. All values until the balancing
 * <code>endArray</code> will be appended to this array. The
 * <code>endArray</code> method must be called to mark the array's end.
 * @return this
 * @throws JSONException If the nesting is too deep, or if the object is
 * started in the wrong place (for example as a key or after the end of the
 * outermost array or object).
 */
public JSONWriter array() throws JSONException{
    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {
        this.push('a');
        this.append(""["");
        this.comma = false;
        return this;
    }
    throw new JSONException(""Misplaced array."");
}","/**
 * Begin appending a new array. All values until the balancing
 * <code>endArray</code> will be appended to this array. The
 * <code>endArray</code> method must be called to mark the array's end.
 * @return this
 * @throws JSONException If the nesting is too deep, or if the object is
 * started in the wrong place (for example as a key or after the end of the
 * outermost array or object).
 */

public JSONWriter array() throws JSONException 
{
    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a')
    {
        this.push('a');
        this.append(""["");
        this.comma = false;
        return this;
    }
    throw new JSONException(""Misplaced array."");
}   ",966,True
"/**
 * Print this HttpException and its stack trace to the specified print writer.
 * 
 * @param s the <tt>PrintWriter</tt> to which the exception and its stack trace
 * should be written
 * 
 * @since 3.0
 */
public void printStackTrace(PrintWriter s){
    try {
        // JDK 1.4 has a nice printStackTrace method that prints the cause's stack
        // trace too and prunes out duplicate stack frames.  Call it if possible,
        // which is determined by checking whether JDK 1.4's getStackTrace method is present 
        Class[] paramsClasses = new Class[] {  };
        this.getClass().getMethod(""getStackTrace"", paramsClasses);
        super.printStackTrace(s);
    } catch (Exception ex) {
        // If that didn't work, print it out ourselves
        // First print this exception's stack trace.
        super.printStackTrace(s);
        if (cause != null) {
            // Print out the exception that caused this one.
            // This will recurse if the cause is another HttpException.
            s.print(""Caused by: "");
            cause.printStackTrace(s);
        }
    }
}","/**
 * Print this HttpException and its stack trace to the specified print writer.
 * 
 * @param s the <tt>PrintWriter</tt> to which the exception and its stack trace
 * should be written
 * 
 * @since 3.0
 */
public void printStackTrace(PrintWriter s) 
{
    synchronized (s)
    {
        super.printStackTrace(s);
        if (cause != null)
        {
            s.println(""Caused by:"");
            cause.printStackTrace(s);
        }
    }
}   ",967,True
"/**
 * Append a value.
 * @param s A string value.
 * @return this
 * @throws JSONException If the value is out of sequence.
 */
private JSONWriter append(String s) throws JSONException{
    if (s == null) {
        throw new JSONException(""Null pointer"");
    }
    if (this.mode == 'o' || this.mode == 'a') {
        try {
            if (this.comma && this.mode == 'a') {
                this.writer.write(',');
            }
            this.writer.write(s);
        } catch (IOException e) {
            throw new JSONException(e);
        }
        if (this.mode == 'o') {
            this.mode = 'k';
        }
        this.comma = true;
        return this;
    }
    throw new JSONException(""Value out of sequence."");
}","/**
 * Append a value.
 * @param s A string value.
 * @return this
 * @throws JSONException If the value is out of sequence.
 */
private JSONWriter append(String s) throws JSONException 
{
  if (s == null)
  {
    throw new JSONException(""JSONWriter value out of sequence."");
  }
  put(s);
  return this;
}   ",969,True
"/**
 * Make a fresh JSONWriter. It can be used to build one JSON text.
 */
public JSONWriter(Writer w){
    this.comma = false;
    this.mode = 'i';
    this.stack = new char[maxdepth];
    this.top = 0;
    this.writer = w;
}","/**
 * Make a fresh JSONWriter. It can be used to build one JSON text.
 */
public JSONWriter(Writer w) 
{
    this.writer = w;
    this.mode = JSONWriter.MODE_OBJECT;
    this.comma = false;
}   ",971,True
"/**
 * End something.
 * @param m Mode
 * @param c Closing character
 * @return this
 * @throws JSONException If unbalanced.
 */
private JSONWriter end(char m, char c) throws JSONException{
    if (this.mode != m) {
        throw new JSONException(m == 'o' ? ""Misplaced endObject."" :
            ""Misplaced endArray."");
    }
    this.pop(m);
    try {
        this.writer.write(c);
    } catch (IOException e) {
        throw new JSONException(e);
    }
    this.comma = true;
    return this;
}","/**
 * End something.
 * @param m Mode
 * @param c Closing character
 * @return this
 * @throws JSONException If unbalanced.
 */

private JSONWriter end(char m, char c) throws JSONException 
{
    if (this.mode != m)
    {
        throw new JSONException(""Misplaced endObject."");
    }
    this.pop(m);
    try
    {
        this.writer.write(c);
    }
    catch (IOException e)
    {
        throw new JSONException(e);
    }
    this.comma = true;
    return this;
}   ",972,True
"/**
 * Preemptively assigns Basic authentication scheme.
 */
public void setPreemptive(){
    if (!this.preemptive) {
        if (this.authScheme != null) {
            throw new IllegalStateException(""Authentication state already initialized"");
        }
        this.authScheme = AuthPolicy.getAuthScheme(PREEMPTIVE_AUTH_SCHEME);
        this.preemptive = true;
    }
}","/**
 * Preemptively assigns Basic authentication scheme.
 */
public void setPreemptive() 
{
    if (authScheme == null)
    {
        authScheme = new BasicScheme();
    }
}   ",973,True
"/**
 * Creates a new HttpException with the specified detail message and cause.
 * 
 * @param message the exception detail message
 * @param cause the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
 * if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
 * 
 * @since 3.0
 */
public HttpException(String message, Throwable cause){
    super(message);
    this.cause = cause;
    
    // If we're running on JDK 1.4 or later, tell Throwable what the cause was
    try {
        Class[] paramsClasses = new Class[] { Throwable.class };
        Method initCause = Throwable.class.getMethod(""initCause"", paramsClasses);
        initCause.invoke(this, new Object[] { cause });
    } catch (Exception e) {
        // The setCause method must not be available
    }
}","/**
 * Creates a new HttpException with the specified detail message and cause.
 * 
 * @param message the exception detail message
 * @param cause the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
 * if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
 * 
 * @since 3.0
 */
public HttpException(String message, Throwable cause) 
{
    super(message, cause);
}   ",975,False
"/**
 * Returns the authentication realm.
 * 
 * @return the name of the authentication realm
 */
public String getRealm(){
    if (this.authScheme != null) {
        return this.authScheme.getRealm();
    } else {
        return null;
    }
}","/**
 * Returns the authentication realm.
 * 
 * @return the name of the authentication realm
 */
public String getRealm() 
{
    return this.realm;
}   ",978,True
"/**
 * Invalidates the authentication state by resetting its parameters.
 */
public void invalidate(){
    this.authScheme = null;
    this.authRequested = false;
    this.authAttempted = false;
    this.preemptive = false;
}","/**
 * Invalidates the authentication state by resetting its parameters.
 */
public void invalidate() 
{
    this.setAuthenticated(false);
    this.setDetails(null);
    this.setPrincipal(null);
    this.setCredentials(null);
}   ",979,True
"/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractActivity#onResume()
 */
@Override
protected void onResume(){
	if(type == PlacesActivity.TYPE_SAVED_PLACES){
		getApp().getSavedPlaces().removeListDataListener(this);
	}
	super.onResume();
}","/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractActivity#onResume()
 */
@Override
protected void onResume() 
{
    super.onResume();
    this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
    this.updateUI();
}   ",980,True
"/**
 * Returns the string for long distance. E.g. ""miles"".
 * 
 * @return the string for long distance.
 */
public String getLongDistance(){
    if (getUnitSystem() == UNITS_MILES_FEET
        || getUnitSystem() == UNITS_MILES_YARDS) {
        // STR_MILES
    	return context.getString(R.string.qtn_andr_miles_txt);
    } else {
        // use metric as default for unknowns.
        // KILOMETERS
    	return context.getString(R.string.qtn_andr_km_txt);
    }
}","/**
 * Returns the string for long distance. E.g. ""miles"".
 * 
 * @return the string for long distance.
 */
public String getLongDistance() 
{
    return longDistance;
}   ",982,False
"/* (non-Javadoc)
	 * @see android.app.Activity#onKeyDown(int, android.view.KeyEvent)
	 */
@Override
	public boolean onKeyUp(int keyCode, KeyEvent event){
		if(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
				|| keyCode == KeyEvent.KEYCODE_VOLUME_UP){
			adjustMuteIcon();
		}
		return super.onKeyUp(keyCode, event);
	}","/* (non-Javadoc)
	 * @see android.app.Activity#onKeyDown(int, android.view.KeyEvent)
	 */
@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) 
{
	if (keyCode == KeyEvent.KEYCODE_BACK)
	{
		if (mIsFullScreen)
		{
			hideFullScreen();
			return true;
		}
	}
	return super.onKeyUp(keyCode, event);
}	",983,True
"/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractActivity#onCreate(android.os.Bundle)
 */
@Override
protected void onCreate(Bundle savedInstanceState){
	super.onCreate(savedInstanceState);
	setContentView(R.layout.edit_place_dialog);
	
	Intent intent =  this.getIntent();
	name = intent.getStringExtra(NAME_KEY);
	description = intent.getStringExtra(DESCRIPTION_KEY);
	type = intent.getIntExtra(TYPE_KEY, 0);
	if(type == TYPE_SAVE_PLACE){
		imageName = intent.getStringExtra(IMAGENAME_KEY);
		srvString = intent.getStringExtra(SRVSTRING_KEY);
		lat = intent.getIntExtra(LAT_KEY, 0);
		lon = intent.getIntExtra(LON_KEY, 0);
	} else if(type == TYPE_EDIT_PLACE){
		setTitle(R.string.qtn_andr_edit_place_det_txt);
		srvString = intent.getStringExtra(SRVSTRING_KEY);
		previusDestinationId = intent.getLongExtra(RECENT_PLACE_ID_KEY, -1);
	}
	
	nameField = (EditText) findViewById(R.id.name_field);
	nameField.setText(name);
	nameField.addTextChangedListener(this);
	
        UserMapObject userPin = this.getApp().getUserPin();
        if(userPin != null) {
            userPin.setOnTitleUpdateListener(new UserMapObject.OnTitleUpdateListener() {
                public void onUpdateTitle(String title) {
                    nameField.setText(title);
                    nameField.invalidate();
                }
            });
        }
	
	descriptionField = (EditText) findViewById(R.id.description_field);
	descriptionField.setHint(R.string.qtn_andr_map_pos_txt);
	if(type == TYPE_EDIT_PLACE){
		descriptionField.setText(description);
	} 
	saveButton = (Button) findViewById(R.id.save_button);
	cancelButton = (Button) findViewById(R.id.cancel_button);
	setSaveButtonState();
	
	saveButton.setOnClickListener(new OnClickListener(){
		public void onClick(View v) {
			if(type == TYPE_SAVE_PLACE){
				EditPlaceActivity.this.getApp().
				addSavedPlace(nameField.getText().toString(), descriptionField.getText().toString(), imageName ,new Position(lat,lon), null );
				Toast.makeText(EditPlaceActivity.this, R.string.qtn_andr_placemark_is_saved_txt, Toast.LENGTH_SHORT).show();
			} else if(type == TYPE_EDIT_PLACE){
				if(srvString != null){
					EditPlaceActivity.this.getApp().updateSavedPlace(getApp().getFavoriteToBeUpdated(), nameField.getText().toString(), descriptionField.getText().toString());
				}
//					if(previusDestinationId != -1){
//						EditPlaceActivity.this.getApp().updatePreviousDestination(, nameField.getText().toString(), descriptionField.getText().toString());
//					}
				Toast.makeText(EditPlaceActivity.this, R.string.qtn_andr_place_is_edited_txt, Toast.LENGTH_SHORT).show();
			}
			EditPlaceActivity.this.finish();
		}
	});
	
	cancelButton.setOnClickListener(new OnClickListener(){
		public void onClick(View v) {
			EditPlaceActivity.this.finish();
		}
	});
	
}","/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractActivity#onCreate(android.os.Bundle)
 */
@Override
protected void onCreate(Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    this.setContentView(R.layout.options);
    this.setTitle(R.string.options_title);

    this.init();
}   ",984,False
"/*
 * (non-Javadoc)
 * 
 * @see android.app.Activity#onCreateDialog(int)
 */
@Override
protected Dialog onCreateDialog(int id){
	switch (id) {
		case DIALOG_WIFI_WARNING: {
			AlertDialog dialog = new AlertDialog(this);
			dialog.setTitle(R.string.qtn_andr_note_txt);
			dialog.setMessage(R.string.qtn_andr_turn_off_wifi_txt);
			dialog.setNeutralButton(R.string.qtn_andr_settings_tk, new OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					Intent i = new Intent(
							Settings.ACTION_WIRELESS_SETTINGS);
					i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
					startActivity(i);
					dialog.dismiss();
				}
			});
			dialog.setPositiveButton(R.string.qtn_andr_close_tk, new OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
				    Intent intent = new Intent(WarningActivity.this, SplashActivity.class);
			        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				    intent.putExtra(SplashActivity.KEY_EXIT, true);
				    WarningActivity.this.startActivity(intent);
				    finish();
					
				}
			});

			
			dialog.setOnDismissListener(new OnDismissListener() {
				public void onDismiss(DialogInterface dialog) {
					// Works for bringing up the gps-settings
					try {
						
					} catch (Throwable t) {
						Log.e(""AbstractActivity"", ""onDismiss() "" + t);
					}
				}
			});
			dialog.setIcon(android.R.drawable.ic_dialog_alert);
			return dialog;
		}
			
		default: {
			return super.onCreateDialog(id);
		}
	}
}","/*
 * (non-Javadoc)
 * 
 * @see android.app.Activity#onCreateDialog(int)
 */
@Override
protected Dialog onCreateDialog(int id) 
{
    switch (id)
    {
        case DIALOG_LOADING:
            return new ProgressDialog(this);
    }
    return super.onCreateDialog(id);
}   ",987,False
"/**
 * Create a new instance.
 * 
 * @param unitSystem - the unit system to use.
 * @see UnitsFormatterSettings#UnitsFormatterConfig(int)
 */
public AndroidUnitsFormatterSettings(int unitSystem, Context context){
    super(unitSystem);
    this.context = context;
}","/**
 * Create a new instance.
 * 
 * @param unitSystem - the unit system to use.
 * @see UnitsFormatterSettings#UnitsFormatterConfig(int)
 */
public AndroidUnitsFormatterSettings(int unitSystem, Context context) 
{
    this.unitSystem = unitSystem;
    this.context = context;
    this.unitsFormatterConfig = new UnitsFormatterConfig(unitSystem, context);
}   ",988,True
"/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractRouteActivity#onResume()
 */
@Override
protected void onResume(){
	super.onResume();
	Route route = this.getRoute();
	if(route != null){
		Waypoint point = route.getFirstTurnWpt();
		int time = point.getTimeSecondsToEnd(); //seconds
        int dist = point.getDistanceMetersToEnd(); //meters
        UnitsFormatter formatter = getApp().getUnitsFormatter();
        String timeStr = formatter.formatTimeWithUnitStrings(time, false);
        FormattingResult result = formatter.formatDistance(dist);
        String distStr = result.getRoundedValue() + "" "" + result.getUnitAbbr();
        textTime.setText(timeStr); 
        textTime.invalidate();
        
        textDist.setText(distStr);
        textDist.invalidate();
	}
}","/* (non-Javadoc)
 * @see com.vodafone.android.navigation.activity.AbstractRouteActivity#onResume()
 */
@Override
protected void onResume() 
{
    super.onResume();
    if (this.mapView != null)
    {
        this.mapView.onResume();
    }
}   ",989,True
"/**
 * Returns the abbreviation for short distance. E.g. ""yds"", ""ft"", ""m"".
 * 
 * @return the abbreviation for short distance.
 */
public String getShortDistanceAbbr(){
    switch (getUnitSystem()) {
    case UNITS_MILES_FEET:
        // STR_FEET_ABBREVIATION
        return context.getString(R.string.qtn_andr_feet_abbrev_txt);
    
    case UNITS_MILES_YARDS:
        // yards_abbr
        return context.getString(R.string.qtn_andr_yards_abbrev_txt);
        
    default: // UNITS_METRIC and default
        // STR_METERS_ABBREVIATION
    	return context.getString(R.string.qtn_andr_metre_txt);
    }
}","/**
 * Returns the abbreviation for short distance. E.g. ""yds"", ""ft"", ""m"".
 * 
 * @return the abbreviation for short distance.
 */
public String getShortDistanceAbbr() 
{
    return shortDistanceAbbr;
}   ",994,False
"/* (non-Javadoc)
 * @see android.widget.ArrayAdapter#getView(int, android.view.View, android.view.ViewGroup)
 */
@Override
public View getView(int position, View convertView, ViewGroup parent){
    View row = convertView;
        ViewWrapper vw;
    if(row == null) {
    		LayoutInflater inflater = context.getLayoutInflater();
    		row = inflater.inflate(R.layout.country_list_item, null);
    		vw = new ViewWrapper(row);
    		row.setTag(vw);
    }
    else {
        vw = (ViewWrapper) row.getTag();
    }
	TextView separator = vw.getSeperator();
	TextView countryName = vw.getCountry();
	String itemValue = getItem(position).replace(""\t"", """");
	if(itemValue.length() > 1){
		countryName.setText(itemValue);
		separator.setVisibility(View.GONE);
		countryName.setVisibility(View.VISIBLE);
	} else {
		separator.setText(itemValue);
		separator.setVisibility(View.VISIBLE);
		countryName.setVisibility(View.GONE);
	}
	return row;
}","/* (non-Javadoc)
 * @see android.widget.ArrayAdapter#getView(int, android.view.View, android.view.ViewGroup)
 */

@Override
public View getView(int position, View convertView, ViewGroup parent) 
{
    View view = super.getView(position, convertView, parent);
    TextView text = (TextView) view.findViewById(android.R.id.text1);
    text.setTextColor(Color.BLACK);
    return view;
}   ",995,False
"// Called when there is a database version mismatch meaning that
// the version of the database on disk needs to be upgraded to
// the current version.
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
	db.execSQL(""DROP TABLE IF EXISTS "" + PREDICTIVE_WRITING_TABLE);
	onCreate(db);
}","// Called when there is a database version mismatch meaning that
// the version of the database on disk needs to be upgraded to
// the current version.


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) 
{
    Log.w(TAG, ""Upgrading database from version "" + oldVersion + "" to ""
            + newVersion + "", which will destroy all old data"");
    db.execSQL(""DROP TABLE IF EXISTS "" + TABLE_NAME);
    onCreate(db);
}   ",997,True
"/* (non-Javadoc)
 * @see android.widget.BaseAdapter#isEnabled(int)
 */
@Override
public boolean isEnabled(int position){
	String itemValue = getItem(position).replace(""\t"", """");
	return (itemValue.length() > 1);
}","/* (non-Javadoc)
 * @see android.widget.BaseAdapter#isEnabled(int)
 */
@Override
public boolean isEnabled(int position) 
{
    if (position == 0)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",998,True
"/**
 * Handle the action clicked in the ""Add to home"" dialog.
 */
public void onClick(DialogInterface dialog, int which){
    Resources res = getResources();
    cleanup();

    switch (which) {
        case AddAdapter.ITEM_SHORTCUT: {
            // Insert extra item to handle picking application
            pickShortcut(REQUEST_PICK_SHORTCUT, R.string.title_select_shortcut);
            break;
        }

        case AddAdapter.ITEM_APPWIDGET: {
            int appWidgetId = Launcher.this.mAppWidgetHost.allocateAppWidgetId();

            Intent pickIntent = new Intent(AppWidgetManager.ACTION_APPWIDGET_PICK);
            pickIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
            // add the search widget
            ArrayList<AppWidgetProviderInfo> customInfo =
                    new ArrayList<AppWidgetProviderInfo>();
            AppWidgetProviderInfo info = new AppWidgetProviderInfo();
            info.provider = new ComponentName(getPackageName(), ""XXX.YYY"");
            info.label = getString(R.string.group_search);
            info.icon = R.drawable.ic_search_widget;
            customInfo.add(info);
            pickIntent.putParcelableArrayListExtra(
                    AppWidgetManager.EXTRA_CUSTOM_INFO, customInfo);
            ArrayList<Bundle> customExtras = new ArrayList<Bundle>();
            Bundle b = new Bundle();
            b.putString(EXTRA_CUSTOM_WIDGET, SEARCH_WIDGET);
            customExtras.add(b);
            pickIntent.putParcelableArrayListExtra(
                    AppWidgetManager.EXTRA_CUSTOM_EXTRAS, customExtras);
            // start the pick activity
            startActivityForResult(pickIntent, REQUEST_PICK_APPWIDGET);
            break;
        }

        case AddAdapter.ITEM_LIVE_FOLDER: {
            // Insert extra item to handle inserting folder
            Bundle bundle = new Bundle();

            ArrayList<String> shortcutNames = new ArrayList<String>();
            shortcutNames.add(res.getString(R.string.group_folder));
            bundle.putStringArrayList(Intent.EXTRA_SHORTCUT_NAME, shortcutNames);

            ArrayList<ShortcutIconResource> shortcutIcons =
                    new ArrayList<ShortcutIconResource>();
            shortcutIcons.add(ShortcutIconResource.fromContext(Launcher.this,
                    R.drawable.ic_launcher_folder));
            bundle.putParcelableArrayList(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, shortcutIcons);

            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);
            pickIntent.putExtra(Intent.EXTRA_INTENT,
                    new Intent(LiveFolders.ACTION_CREATE_LIVE_FOLDER));
            pickIntent.putExtra(Intent.EXTRA_TITLE,
                    getText(R.string.title_select_live_folder));
            pickIntent.putExtras(bundle);

            startActivityForResult(pickIntent, REQUEST_PICK_LIVE_FOLDER);
            break;
        }

        case AddAdapter.ITEM_WALLPAPER: {
            startWallpaper();
            break;
        }
    }
}","/**
 * Handle the action clicked in the ""Add to home"" dialog.
 */
public void onClick(DialogInterface dialog, int which) 
{
    switch (which)
    {
        case DialogInterface.BUTTON_POSITIVE:
            dialog.dismiss();
            break;
        case DialogInterface.BUTTON_NEGATIVE:
            dialog.dismiss();
            break;
    }
}   ",1003,False
"/**
 * Bind the items start-end from the list.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindItems(ArrayList<ItemInfo> shortcuts, int start, int end){

    final Workspace workspace = mWorkspace;

    for (int i=start; i<end; i++) {
        final ItemInfo item = shortcuts.get(i);
        mDesktopItems.add(item);
        switch (item.itemType) {
            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
                final View shortcut = createShortcut((ApplicationInfo) item);
                workspace.addInScreen(shortcut, item.screen, item.cellX, item.cellY, 1, 1,
                        false);
                break;
            case LauncherSettings.Favorites.ITEM_TYPE_USER_FOLDER:
                final FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
                        (ViewGroup) workspace.getChildAt(workspace.getCurrentScreen()),
                        (UserFolderInfo) item);
                workspace.addInScreen(newFolder, item.screen, item.cellX, item.cellY, 1, 1,
                        false);
                break;
            case LauncherSettings.Favorites.ITEM_TYPE_LIVE_FOLDER:
                final FolderIcon newLiveFolder = LiveFolderIcon.fromXml(
                        R.layout.live_folder_icon, this,
                        (ViewGroup) workspace.getChildAt(workspace.getCurrentScreen()),
                        (LiveFolderInfo) item);
                workspace.addInScreen(newLiveFolder, item.screen, item.cellX, item.cellY, 1, 1,
                        false);
                break;
            case LauncherSettings.Favorites.ITEM_TYPE_WIDGET_SEARCH:
                final int screen = workspace.getCurrentScreen();
                final View view = mInflater.inflate(R.layout.widget_search,
                        (ViewGroup) workspace.getChildAt(screen), false);

                Search search = (Search) view.findViewById(R.id.widget_search);
                search.setLauncher(this);

                final Widget widget = (Widget) item;
                view.setTag(widget);

                workspace.addWidget(view, widget, false);
                break;
        }
    }

    workspace.requestLayout();
}","/**
 * Bind the items start-end from the list.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindItems(ArrayList<ItemInfo> shortcuts, int start, int end) 
{
    if (start < 0 || start > end || end > shortcuts.size()) {
        return;
    }
    mItems.clear();
    for (int i = start; i < end; i++) {
        mItems.add(shortcuts.get(i));
    }
    notifyDataSetChanged();
}   ",1004,False
"/**
 * Refreshes the shortcuts shown on the workspace.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void startBinding(){
    final Workspace workspace = mWorkspace;
    int count = workspace.getChildCount();
    for (int i = 0; i < count; i++) {
        // Use removeAllViewsInLayout() to avoid an extra requestLayout() and invalidate().
        ((ViewGroup) workspace.getChildAt(i)).removeAllViewsInLayout();
    }

    if (DEBUG_USER_INTERFACE) {
        android.widget.Button finishButton = new android.widget.Button(this);
        finishButton.setText(""Finish"");
        workspace.addInScreen(finishButton, 1, 0, 0, 1, 1);

        finishButton.setOnClickListener(new android.widget.Button.OnClickListener() {
            public void onClick(View v) {
                finish();
            }
        });
    }
}","/**
 * Refreshes the shortcuts shown on the workspace.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void startBinding() 
{
    mCallbacks = Launcher.getCallbacks();
    if (mCallbacks != null) {
        mCallbacks.startBinding();
    }
}   ",1006,False
"/**
 * A package was uninstalled.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageRemoved(String packageName, ArrayList<ApplicationInfo> apps){
    removeDialog(DIALOG_CREATE_SHORTCUT);
    mWorkspace.removeShortcutsForPackage(packageName);
    mAllAppsGrid.removeApps(apps);
}","/**
 * A package was uninstalled.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageRemoved(String packageName, ArrayList<ApplicationInfo> apps) 
{
    synchronized (mLock) {
        if (mPackageMap.containsKey(packageName)) {
            mPackageMap.remove(packageName);
        }
    }
}   ",1008,True
"/**
 * Add a widget to the workspace.
 *
 * @param data The intent describing the appWidgetId.
 * @param cellInfo The position on screen where to create the widget.
 */
private void completeAddAppWidget(Intent data, CellLayout.CellInfo cellInfo){
    Bundle extras = data.getExtras();
    int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);

    if (LOGD) Log.d(TAG, ""dumping extras content="" + extras.toString());

    AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);

    // Calculate the grid spans needed to fit this widget
    CellLayout layout = (CellLayout) mWorkspace.getChildAt(cellInfo.screen);
    int[] spans = layout.rectToCell(appWidgetInfo.minWidth, appWidgetInfo.minHeight);

    // Try finding open space on Launcher screen
    final int[] xy = mCellCoordinates;
    if (!findSlot(cellInfo, xy, spans[0], spans[1])) {
        if (appWidgetId != -1) mAppWidgetHost.deleteAppWidgetId(appWidgetId);
        return;
    }

    // Build Launcher-specific widget info and save to database
    LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId);
    launcherInfo.spanX = spans[0];
    launcherInfo.spanY = spans[1];

    LauncherModel.addItemToDatabase(this, launcherInfo,
            LauncherSettings.Favorites.CONTAINER_DESKTOP,
            mWorkspace.getCurrentScreen(), xy[0], xy[1], false);

    if (!mRestoring) {
        mDesktopItems.add(launcherInfo);

        // Perform actual inflation because we're live
        launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);

        launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
        launcherInfo.hostView.setTag(launcherInfo);

        mWorkspace.addInCurrentScreen(launcherInfo.hostView, xy[0], xy[1],
                launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
    }
}","/**
 * Add a widget to the workspace.
 *
 * @param data The intent describing the appWidgetId.
 * @param cellInfo The position on screen where to create the widget.
 */


private void completeAddAppWidget(Intent data, CellLayout.CellInfo cellInfo) 
{
    Bundle extras = data.getExtras();
    int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);

    if (LOGD) Log.d(TAG, ""Adding widget ID = "" + appWidgetId);

    ItemInfo info = new ItemInfo();
    info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET;
    info.user = mNewUser;
    info.screen = cellInfo.screenId;
    info.cellX = cellInfo.cellX;
    info.cellY = cellInfo.cellY;
    info.spanX = 1;
    info.spanY = 1;

    mModel.addItemToDatabase(mModel, LauncherSettings.Favorites.CONTAINER_DESKTOP,
            LauncherSettings.Favorites.CONTAINER_DESKTOP, appWidgetId, info);
}   ",1009,True
"/**
 * Registers various content observers. The current implementation registers
 * only a favorites observer to keep track of the favorites applications.
 */
private void registerContentObservers(){
    ContentResolver resolver = getContentResolver();
    resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
            true, mWidgetObserver);
}","/**
 * Registers various content observers. The current implementation registers
 * only a favorites observer to keep track of the favorites applications.
 */
private void registerContentObservers() 
{
    if (mContentResolver == null)
    {
        mContentResolver = mContext.getContentResolver();
    }

    mContentResolver.registerContentObserver(
            Favorites.CONTENT_URI, true, mFavoritesObserver);
}   ",1010,True
"/**
 * Restores the previous state, if it exists.
 *
 * @param savedState The previous state.
 */
private void restoreState(Bundle savedState){
    if (savedState == null) {
        return;
    }

    final boolean allApps = savedState.getBoolean(RUNTIME_STATE_ALL_APPS_FOLDER, false);
    if (allApps) {
        showAllApps(false);
    }

    final int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN, -1);
    if (currentScreen > -1) {
        mWorkspace.setCurrentScreen(currentScreen);
    }

    final int addScreen = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
    if (addScreen > -1) {
        mAddItemCellInfo = new CellLayout.CellInfo();
        final CellLayout.CellInfo addItemCellInfo = mAddItemCellInfo;
        addItemCellInfo.valid = true;
        addItemCellInfo.screen = addScreen;
        addItemCellInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
        addItemCellInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
        addItemCellInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
        addItemCellInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
        addItemCellInfo.findVacantCellsFromOccupied(
                savedState.getBooleanArray(RUNTIME_STATE_PENDING_ADD_OCCUPIED_CELLS),
                savedState.getInt(RUNTIME_STATE_PENDING_ADD_COUNT_X),
                savedState.getInt(RUNTIME_STATE_PENDING_ADD_COUNT_Y));
        mRestoring = true;
    }

    boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
    if (renameFolder) {
        long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
        mFolderInfo = mModel.getFolderById(this, mFolders, id);
        mRestoring = true;
    }
}","/**
 * Restores the previous state, if it exists.
 *
 * @param savedState The previous state.
 */
private void restoreState(Bundle savedState) 
{
    if (savedState == null)
    {
        return;
    }

    this.mState = savedState.getInt(""state"");
    this.mProgress = savedState.getInt(""progress"");
    this.mSecondaryProgress = savedState.getInt(""secondaryProgress"");
    this.mMax = savedState.getInt(""max"");
    this.mIndeterminate = savedState.getBoolean(""indeterminate"");
}   ",1011,False
"/**
 * A package was updated.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageUpdated(String packageName, ArrayList<ApplicationInfo> apps){
    removeDialog(DIALOG_CREATE_SHORTCUT);
    mWorkspace.updateShortcutsForPackage(packageName);
    mAllAppsGrid.updateApps(packageName, apps);
}","/**
 * A package was updated.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageUpdated(String packageName, ArrayList<ApplicationInfo> apps) 
{
    if (mPackageUpdated != null)
    {
        mPackageUpdated.bindPackageUpdated(packageName, apps);
    }
}   ",1012,True
"/**
 * A package was installed.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageAdded(ArrayList<ApplicationInfo> apps){
    removeDialog(DIALOG_CREATE_SHORTCUT);
    mAllAppsGrid.addApps(apps);
}","/**
 * A package was installed.
 *
 * Implementation of the method from LauncherModel.Callbacks.
 */
public void bindPackageAdded(ArrayList<ApplicationInfo> apps) 
{
    if (apps == null)
    {
        return;
    }

    for (ApplicationInfo app : apps)
    {
        if (app != null)
        {
            bindPackageAdded(app.packageName);
        }
    }
}   ",1013,True
"/**
 * Opens the user fodler described by the specified tag. The opening of the folder
 * is animated relative to the specified View. If the View is null, no animation
 * is played.
 *
 * @param folderInfo The FolderInfo describing the folder to open.
 */
private void openFolder(FolderInfo folderInfo){
    Folder openFolder;

    if (folderInfo instanceof UserFolderInfo) {
        openFolder = UserFolder.fromXml(this);
    } else if (folderInfo instanceof LiveFolderInfo) {
        openFolder = com.android.launcher2.LiveFolder.fromXml(this, folderInfo);
    } else {
        return;
    }

    openFolder.setDragController(mDragController);
    openFolder.setLauncher(this);

    openFolder.bind(folderInfo);
    folderInfo.opened = true;

    mWorkspace.addInScreen(openFolder, folderInfo.screen, 0, 0, 4, 4);
    openFolder.onOpen();
}","/**
 * Opens the user fodler described by the specified tag. The opening of the folder
 * is animated relative to the specified View. If the View is null, no animation
 * is played.
 *
 * @param folderInfo The FolderInfo describing the folder to open.
 */
private void openFolder(FolderInfo folderInfo) 
{
    Folder folder = Folder.fromFolderInfo(this, folderInfo);
    folder.open(mEmptyView, -1, false);
}   ",1014,True
"/**
 * Used to inflate the Workspace from XML.
 *
 * @param context The application's context.
 * @param attrs The attribtues set containing the Workspace's customization values.
 */
public Folder(Context context, AttributeSet attrs){
    super(context, attrs);
    setAlwaysDrawnWithCacheEnabled(false);
}","/**
 * Used to inflate the Workspace from XML.
 *
 * @param context The application's context.
 * @param attrs The attribtues set containing the Workspace's customization values.
 */
public Folder(Context context, AttributeSet attrs) 
{
    super(context, attrs);

    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Folder);
    folderName = a.getString(R.styleable.Folder_folderName);
    a.recycle();

    setAlwaysDrawnWithCacheEnabled(false);
    buildLayer();
}   ",1015,True
"/**
 * Add a shortcut to the workspace.
 *
 * @param data The intent describing the shortcut.
 * @param cellInfo The position on screen where to create the shortcut.
 */
private void completeAddShortcut(Intent data, CellLayout.CellInfo cellInfo){
    cellInfo.screen = mWorkspace.getCurrentScreen();
    if (!findSingleSlot(cellInfo)) return;

    final ApplicationInfo info = addShortcut(this, data, cellInfo, false);

    if (!mRestoring) {
        final View view = createShortcut(info);
        mWorkspace.addInCurrentScreen(view, cellInfo.cellX, cellInfo.cellY, 1, 1,
                isWorkspaceLocked());
    }
}","/**
 * Add a shortcut to the workspace.
 *
 * @param data The intent describing the shortcut.
 * @param cellInfo The position on screen where to create the shortcut.
 */
private void completeAddShortcut(Intent data, CellLayout.CellInfo cellInfo) 
{
    Bundle extras = data.getExtras();
    if (extras == null)
    {
        return;
    }

    int cellX = cellInfo.cellX;
    int cellY = cellInfo.cellY;
    int spanX = 1;
    int spanY = 1;

    LauncherModel.addItemToDatabase(this, LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT,
            cellX, cellY, spanX, spanY, false,
            data.getComponent().getPackageName(), null, null, null);
    bindShortcutFromIntent(data, cellInfo);
    finish();
}   ",1016,True
"/**
 * Indicates that we want global search for this activity by setting the globalSearch
 * argument for {@link #startSearch} to true.
 */
@Override
public boolean onSearchRequested(){
    startSearch(null, false, null, true);
    return true;
}","/**
 * Indicates that we want global search for this activity by setting the globalSearch
 * argument for {@link #startSearch} to true.
 */

@Override
public boolean onSearchRequested() 
{
    Bundle appData = new Bundle();
    appData.putString(""hello"", ""world"");
    startSearch(null, false, appData, false);
    return true;
}   ",1018,True
"/**
 * Fires a message event.
 * @param listenerList the event listener list
 * @param message the message that triggered the event
 * @param isReceived the message is a received type or not
 */
private void fireMessageEvent(final ConnectorListener[] listeners, final String message, final boolean isReceived){
    ConnectorMessageEvent event = new ConnectorMessageEvent(this, message);
    for (int i = listeners.length - 1; 0 <= i; i--) {
        if (isReceived) {
            listeners[i].messageReceived(event);
        } else {
            listeners[i].messageSent(event);
        }
    }
}","/**
 * Fires a message event.
 * @param listenerList the event listener list
 * @param message the message that triggered the event
 * @param isReceived the message is a received type or not
 */
private void fireMessageEvent(final ConnectorListener[] listeners, final String message, final boolean isReceived) 
{
    for (final ConnectorListener listener : listeners)
    {
        if (listener != null)
        {
            if (isReceived)
            {
                listener.onMessageReceived(message);
            }
            else
            {
                listener.onMessageSent(message);
            }
        }
    }
}   ",1022,True
"/**
 * @param string
 * @return
 */
public ChatMessage getChatMessage(final String anId){
	synchronized (idToChatMessages) {
		ChatMessage chatMessage = idToChatMessages.get(anId);
		if(chatMessage == null) {
			chatMessage = new ChatMessage(connector, anId);
			idToChatMessages.put(anId, chatMessage);
		}
		return chatMessage;
	}
}","/**
 * @param string
 * @return
 */
public ChatMessage getChatMessage(final String anId) 
{
    for (final ChatMessage message : this.messages)
    {
        if (message.getId().equals(anId))
        {
            return message;
        }
    }
    return null;
}   ",1023,True
"/**
 * Executes the specified command and waits for the response without timeout.
 * @param command the command to execute
 * @param responseHeader the response header to get the accurate response
 * @return the response after execution
 * @throws NullPointerException if the specified command or responseHeader is null
 * @throws ConnectorException if executing the command failed
 */
public final String executeWithoutTimeout(final String command, final String responseHeader) throws ConnectorException{
    ConnectorUtils.checkNotNull(""command"", command);
    ConnectorUtils.checkNotNull(""responseHeader"", responseHeader);
    return execute(command, new String[] { responseHeader, ""ERROR "" }, true, true);
}","/**
 * Executes the specified command and waits for the response without timeout.
 * @param command the command to execute
 * @param responseHeader the response header to get the accurate response
 * @return the response after execution
 * @throws NullPointerException if the specified command or responseHeader is null
 * @throws ConnectorException if executing the command failed
 */
public final String executeWithoutTimeout(final String command, final String responseHeader) throws ConnectorException 
{
    if (command == null)
    {
        throw new NullPointerException(""command is null"");
    }
    if (responseHeader == null)
    {
        throw new NullPointerException(""responseHeader is null"");
    }

    return execute(command, responseHeader, 0);
}   ",1024,True
"/**
 * Sends a status change event to the all listeners.
 * @param newStatus the new status
 */
private void fireStatusChanged(final Status newStatus){
	System.out.println(""Set status to "" + newStatus.toString() + "" for skype instance: "" + getSkype());
    _syncSender.execute(new Runnable() {
        public void run() {
            // use listener array instead of list because of reverse iteration
            fireStatusChanged(toConnectorListenerArray(_syncListeners), newStatus);
        }
    });
    _asyncSender.execute(new Runnable() {
        public void run() {
            // use listener array instead of list because of reverse iteration
            fireStatusChanged(toConnectorListenerArray(_asyncListeners), newStatus);
        }
    });
}","/**
 * Sends a status change event to the all listeners.
 * @param newStatus the new status
 */

private void fireStatusChanged(final Status newStatus) 
{
    final StatusChangeEvent event = new StatusChangeEvent(this, newStatus);
    for (final StatusChangeListener listener : listeners)
    {
        listener.statusChanged(event);
    }
}   ",1025,False
"/**
 * @param id
 * @return
 */
public Chat getChat(final String anId){
	synchronized (idToChats) {
		Chat chat = idToChats.get(anId);
		if(chat == null) {
			chat = new Chat(connector, anId);
			idToChats.put(anId, chat);
		}
		return chat;
		}
	}","/**
 * @param id
 * @return
 */
public Chat getChat(final String anId) 
{
    if (this.chats.containsKey(anId))
    {
        return this.chats.get(anId);
    }
    return null;
}   ",1026,True
"/**
 * Gets the specified property value.
 * @param name the property name
 * @return the property value
 * @throws NullPointerException if the specified name is null
 * @see #setStringProperty(String, String)
 */
public final String getStringProperty(final String name){
    ConnectorUtils.checkNotNull(""name"", name);
    return properties.get(name);
}","/**
 * Gets the specified property value.
 * @param name the property name
 * @return the property value
 * @throws NullPointerException if the specified name is null
 * @see #setStringProperty(String, String)
 */
public final String getStringProperty(final String name) 
{
    if (name == null)
    {
        throw new NullPointerException(""name"");
    }
    return (String) properties.get(name);
}   ",1027,True
"/**
 * Removes the specified listener from this connector.
 * @param listener the listener to be removed
 * @throws NullPointerException if the specified listener is null
 * @see #addConnectorListener(ConnectorListener)
 */
public final void removeConnectorListener(final ConnectorListener listener){
    ConnectorUtils.checkNotNull(""listener"", listener);
    _syncListeners.remove(listener);
    _asyncListeners.remove(listener);
}","/**
 * Removes the specified listener from this connector.
 * @param listener the listener to be removed
 * @throws NullPointerException if the specified listener is null
 * @see #addConnectorListener(ConnectorListener)
 */
public final void removeConnectorListener(final ConnectorListener listener) 
{
    if (listener == null)
    {
        throw new NullPointerException(""listener == null"");
    }
    listeners.remove(listener);
}   ",1028,True
"/**
 * Adds the specified listener to this connector.
 * @param listener the listener to be added
 * @param checkAttached if true checks if this connector is attached
 * @param isSynchronous if true the listener will be handled synchronously
 * @throws NullPointerException if the specified listener is null
 * @throws ConnectorException if trying to connect failed
 * @see #removeConnectorListener(ConnectorListener)
 */
public final void addConnectorListener(final ConnectorListener listener, final boolean checkAttached, final boolean isSynchronous) throws ConnectorException{
    ConnectorUtils.checkNotNull(""listener"", listener);
    if(isSynchronous) {
        _syncListeners.add(listener);
    } else {
        _asyncListeners.add(listener);
    }
    if (checkAttached) {
        assureAttached();
    }
}","/**
 * Adds the specified listener to this connector.
 * @param listener the listener to be added
 * @param checkAttached if true checks if this connector is attached
 * @param isSynchronous if true the listener will be handled synchronously
 * @throws NullPointerException if the specified listener is null
 * @throws ConnectorException if trying to connect failed
 * @see #removeConnectorListener(ConnectorListener)
 */
public final void addConnectorListener(final ConnectorListener listener, final boolean checkAttached, final boolean isSynchronous) throws ConnectorException 
{
    if (listener == null)
    {
        throw new NullPointerException(""listener is null"");
    }

    if (checkAttached && !isAttached())
    {
        throw new ConnectorException(""Connector is not attached"");
    }

    if (isSynchronous)
    {
        listener.connectorConnected(this);
    }
    else
    {
        synchronized (connectorListeners)
        {
            connectorListeners.add(listener);
        }
    }
}   ",1029,True
"/**
 * Check if Skype client is running.
 * WARNING, does not work for all platforms.
 * @return true if Skype client is running.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public boolean isRunning() throws SkypeException{
    try {
        return connector.isRunning();
    } catch (ConnectorException e) {
        Utils.convertToSkypeException(e);
        return false;
    }
}","/**
 * Check if Skype client is running.
 * WARNING, does not work for all platforms.
 * @return true if Skype client is running.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public boolean isRunning() throws SkypeException 
{
    if (isWindows()) {
        return isRunningWindows();
    } else if (isMac()) {
        return isRunningMac();
    } else if (isLinux()) {
        return isRunningLinux();
    } else {
        throw new SkypeException(""Unsupported platform"");
    }
}   ",1030,False
"/**
 * Disconnects from the Skype client and clean up the resources.
 * @throws ConnectorException if cleaning up the resources failed
 */
public final void dispose() throws ConnectorException{
    synchronized (_isInitializedMutex) {
        if (!_isInitialized) {
            return;
        }
        disposed = true;
        disposeImpl();
        setStatus(Status.NOT_RUNNING);
        _commandExecutor.shutdown();

        _syncSender.shutdown();
        _asyncSender.shutdown();

        _syncListeners.clear();
        _asyncListeners.clear();

        _isInitialized = false;
    }
}","/**
 * Disconnects from the Skype client and clean up the resources.
 * @throws ConnectorException if cleaning up the resources failed
 */
public final void dispose() throws ConnectorException 
{
    try
    {
        if (this.skype != null)
        {
            this.skype.Dispose();
            this.skype = null;
        }
    }
    catch (Exception e)
    {
        throw new ConnectorException(e);
    }
}   ",1032,True
"/**
 * Initializes this connector.
 * @throws ConnectorException if the initialization failed.
 */
protected final void initialize() throws ConnectorException{
    synchronized (_isInitializedMutex) {
        if (!_isInitialized) {
            _asyncSender = Executors.newCachedThreadPool(new ThreadFactory() {
                private final AtomicInteger threadNumber = new AtomicInteger();

                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, ""AsyncSkypeMessageSender-"" + threadNumber.getAndIncrement());
                    thread.setDaemon(true);
                    return thread;
                }
            });
            _syncSender = Executors.newSingleThreadExecutor(new ThreadFactory() {
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, ""SyncSkypeMessageSender"");
                    thread.setDaemon(true);
                    return thread;
                }
            });
            _commandExecutor = Executors.newCachedThreadPool(new ThreadFactory() {
                private final AtomicInteger threadNumber = new AtomicInteger();

                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, ""CommandExecutor-"" + threadNumber.getAndIncrement());
                    thread.setDaemon(true);
                    return thread;
                }
            });

            initializeImpl();

            _isInitialized = true;
        }
    }
}","/**
 * Initializes this connector.
 * @throws ConnectorException if the initialization failed.
 */
protected final void initialize() throws ConnectorException 
{
    if (this.initialized)
    {
        return;
    }

    this.initialized = true;

    this.doInitialize();
}   ",1034,False
"/**
 * Sends a status change event to the specified listeners.
 * @param listeners the event listeners
 * @param newStatus the new status
 */
private void fireStatusChanged(final ConnectorListener[] listeners, final Status newStatus){
	if(isDisposed()) {
		return;
	}
    final ConnectorStatusEvent event = new ConnectorStatusEvent(this, newStatus);
    for (int i = listeners.length - 1; 0 <= i; i--) {
        listeners[i].statusChanged(event);
    }
}","/**
 * Sends a status change event to the specified listeners.
 * @param listeners the event listeners
 * @param newStatus the new status
 */
private void fireStatusChanged(final ConnectorListener[] listeners, final Status newStatus) 
{
    if (listeners != null)
    {
        for (int i = 0; i < listeners.length; i++)
        {
            listeners[i].statusChanged(this, newStatus);
        }
    }
}   ",1038,True
"/**
 * Compute an
 * 
 * @param bitsAllocated
 * @param valueLength
 * @throws IOException
 * @throws EOFException
 * @throws DICOMException
 */
private void computeOWImage(long valueLength)
		throws IOException, EOFException, DICOMException{
	
	// Check the value length
	if (valueLength == 0xffffffffL)
		throw new DICOMException(""Cannot parse PixelData "" +
				""because the length is undefined"");
	
	// Get the bits allocated
	int bitsAllocated = mBody.getBitsAllocated();
	
	// Cf. PS 3.5-2009 Pg. 66-67
	if (bitsAllocated == 8) {
	
		computeOW8BitImage(valueLength);
		
	} else if (bitsAllocated == 16) {
		
		computeOW16BitImage(valueLength);
		
	} else if (bitsAllocated == 32) {
		
		/* for (int i = 0; i < mPixelData.length; i++) {
			mPixelData[i] = (int) readUnsignedLong();
		}
	
		mByteOffset += valueLength; */
	
		// TODO We can sample the gray level on 16 bit but
		// is it compatible with the DICOM standard ?
	
		throw new DICOMException(""This image cannot be parsed ""
				+ ""because the bits allocated value (""
				+ bitsAllocated
				+ "") is not supported yet."");
		
	} else if (bitsAllocated == 64) {
		
		/* for (int i = 0; i < mPixelData.length; i++) {
			mPixelData[i] = (int) readUnsignedLong64();
		}
		
		mByteOffset += valueLength; */
		
		// TODO We can sample the gray level on 16 bit but
		// is it compatible with the DICOM standard ?
		
		throw new DICOMException(""This image cannot be parsed ""
				+ ""because the bits allocated value (""
				+ bitsAllocated
				+ "") is not supported yet."");
		
	} else {
		
		throw new DICOMException(""This image cannot be parsed ""
				+ ""because the bits allocated value (""
				+ bitsAllocated
				+ "") is not supported yet."");
		
	}
	
	// Add the value length to the byte offset
	mByteOffset += valueLength;
	
}","/**
 * Compute an
 * 
 * @param bitsAllocated
 * @param valueLength
 * @throws IOException
 * @throws EOFException
 * @throws DICOMException
 */
private void computeOWImage(long valueLength)
		throws IOException, EOFException, DICOMException 
{
	if (valueLength % 2 != 0)
		throw new DICOMException(""Odd length value for OW image: "" + valueLength);
	owImage = new byte[(int)valueLength];
	dicomInputStream.readFully(owImage);
}	",1041,False
"/**
 * @param imageOrientation The image orientation array.
 */
public void setImageOrientation(float[] imageOrientation){
	
	if (imageOrientation == null)
		return;
	
	if (imageOrientation.length == 6)
		mImageOrientation = imageOrientation;
}","/**
 * @param imageOrientation The image orientation array.
 */
public void setImageOrientation(float[] imageOrientation) 
{
    if (imageOrientation.length != 9)
    {
        throw new IllegalArgumentException(""imageOrientation must have length 9"");
    }

    System.arraycopy(imageOrientation, 0, this.imageOrientation, 0, 9);
}   ",1044,True
"/**
 * @return DICOM element value as an integer.
 * @throws NumberFormatException If the value is not an
 * integer, it throws a NumberFormatException.
 */
public int getValueInt() throws NumberFormatException{
	
	int toReturn = 0;
	
	if (mValue instanceof String) {
		
		toReturn = Integer.parseInt((String) mValue);
		
	} else if (mValue instanceof Short) {
		
		toReturn = (int) (Short) mValue;
		
	} else if (mValue instanceof Integer) {
		
		toReturn = (Integer) mValue;
		
	} else if (mValue instanceof Long) {
		
		toReturn = ((Long) mValue).intValue();
		
	} else {
		
		toReturn = Integer.parseInt(getValueString());
		
	}
	
	return toReturn;
	
}","/**
 * @return DICOM element value as an integer.
 * @throws NumberFormatException If the value is not an
 * integer, it throws a NumberFormatException.
 */
public int getValueInt() throws NumberFormatException 
{
    return Integer.parseInt(getValue());
}   ",1046,True
"/**
 * @return True if the external storage is available.
 * False otherwise.
 */
public static boolean checkAvailable(){
	
	// Retrieving the external storage state
	String state = Environment.getExternalStorageState();
	
	// Check if available
	if (Environment.MEDIA_MOUNTED.equals(state)
			|| Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
		return true;
	}
	
	return false;
}","/**
 * @return True if the external storage is available.
 * False otherwise.
 */

public static boolean checkAvailable() 
{
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
}   ",1047,True
"/**
 * Write a LISA 16-Bit grayscale image.
 * @param image A LISA 16-bit grayscale image.
 * @throws IOException
 */
public void write(LISAImageGray16Bit image) throws IOException{
	
	if (image == null)
		throw new NullPointerException(""Image is null"");
	
	try {
		
		// PREFIX
		// Write the prefix
		write(PREFIX.getBytes());
		
		// IMAGE SIZE
		// Write width
		writeInt16(image.getWidth());
		
		// Write height
		writeInt16(image.getHeight());
		
		// GRAY LEVELS AND WINDOW
		// Write the gray levels
		writeLong32(image.getGrayLevel());
		
		// Write window width
		writeInt16(image.getWindowWidth());
		
		// Write window center
		writeInt16(image.getWindowCenter());
		
		// Write the image orientation
		writeImageOrientation(image);
		
		// Write image length
		writeLong32(image.getDataLength());
		
		// Write the image data
		writeInt16Array(image.getData());
		
	} catch (IOException e) {
		throw new IOException(""Cannot open write LISA image.\n""
				+ e.getMessage());
	}
	
	
}","/**
 * Write a LISA 16-Bit grayscale image.
 * @param image A LISA 16-bit grayscale image.
 * @throws IOException
 */
public void write(LISAImageGray16Bit image) throws IOException 
{
    if (image == null)
    {
        throw new IllegalArgumentException(""image must be non-null"");
    }
    if (image.getDepth() != 16)
    {
        throw new IllegalArgumentException(""image depth must be 16"");
    }

    writeHeader(image);
    writeData(image);
}   ",1048,True
"// This function is override to fit the image in the
// ImageView at initialization. Because when this method
// is called, the size of the ImageView is set.
// The override of the onDraw method lead to a slower
// display of the image. It is for that we override
// this method.
/* (non-Javadoc)
 * @see android.widget.ImageView#drawableStateChanged()
 */
@Override
protected void drawableStateChanged(){
	
	if (mIsInit == false) {
		
		mIsInit = true;
		
		if (mImage != null)
			fitIn();
		
	}

	super.drawableStateChanged();
	
}","// This function is override to fit the image in the
// ImageView at initialization. Because when this method
// is called, the size of the ImageView is set.
// The override of the onDraw method lead to a slower
// display of the image. It is for that we override
// this method.
/* (non-Javadoc)
 * @see android.widget.ImageView#drawableStateChanged()
 */
@Override
protected void drawableStateChanged() 
{
    super.drawableStateChanged();
    invalidate();
}   ",1049,False
"/**
 * Write a long on 4 bytes.
 * 
 * If the value correspond to the image length the maximum value
 * must be set as Integer.MAX_VALUE due to java array limitation:
 * the maximum length is the maximum integer value.
 * 
 * @param value Long value.
 * @throws IOException
 */
protected final void writeLong32(long value) throws IOException{
	
	byte[] long32Bytes = new byte[4];
	
	long32Bytes[0] = (byte) ((value >> 24) & 0xff);
	long32Bytes[1] = (byte) ((value >> 16) & 0xff);
	long32Bytes[2] = (byte) ((value >> 8) & 0xff);
	long32Bytes[3] = (byte) ((value) & 0xff);
	
	super.write(long32Bytes);
	
}","/**
 * Write a long on 4 bytes.
 * 
 * If the value correspond to the image length the maximum value
 * must be set as Integer.MAX_VALUE due to java array limitation:
 * the maximum length is the maximum integer value.
 * 
 * @param value Long value.
 * @throws IOException
 */
protected final void writeLong32(long value) throws IOException 
{
    if (value > Integer.MAX_VALUE)
    {
        writeInt32(Integer.MAX_VALUE);
    }
    else
    {
        writeInt32((int) value);
    }
}   ",1052,True
"/**
 * @param mWindowWidth the mWindowWidth to set
 */
public void setWindowWidth(int mWindowWidth){
	
	// The minimum window width is 1
	// cf. DICOM documentation
	if (mWindowWidth <= 0)
		this.mWindowWidth = 1;
	else
		this.mWindowWidth = mWindowWidth;
	
}","/**
 * @param mWindowWidth the mWindowWidth to set
 */
public void setWindowWidth(int mWindowWidth) 
{
    this.mWindowWidth = mWindowWidth;
}   ",1054,True
"// This function is override to center the image
// when the size of the screen change
/* (non-Javadoc)
 * @see android.view.View#onSizeChanged(int, int, int, int)
 */
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh){

	// If the image is not null, center it
	if (mImage != null)
		center();
	
	super.onSizeChanged(w, h, oldw, oldh);
	
}","// This function is override to center the image
// when the size of the screen change
/* (non-Javadoc)
 * @see android.view.View#onSizeChanged(int, int, int, int)
 */
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) 
{
    super.onSizeChanged(w, h, oldw, oldh);
    mWidth = w;
    mHeight = h;
    mCenterX = w / 2;
    mCenterY = h / 2;
}   ",1055,True
"/**
 * @return DICOM element value as a String or null
 * if there is an error.
 */
public String getValueString(){
	
	// If there is no value return null
	if (mValue == null)
		return ""NULL"";
	
	// If no tag return a null object
	if (mDICOMTag == null)
		return null;
	// TODO throw a DICOM Exception
	
	// Get the value representation
	DICOMValueRepresentation VR = mDICOMTag.getValueRepresentation();
	
	if (mDICOMTag.getTag() == 0x7fe00010) {
		if (VR.equals(""OW""))
			return ""Pixel DICOM OW"";
		else if (VR.equals(""OB""))
			return ""Pixel DICOM OB"";
	}
	
	if (VR.equals(""US"") || VR.equals(""SS"")) {
		if (mLength > 2)
			return ""Array of numerical values coded in 2 bits"";
	} else if (VR.equals(""UL"") || VR.equals(""FL"") || VR.equals(""SL"")) {
		if (mLength > 4)
			return ""Array of numerical values coded in 4 bits"";
	} else if (VR.equals(""FD"")) {
		if (mLength > 8)
			return ""Array of numerical values coded in 8 bits"";
	}
	
	// Get the value class from the VR
	@SuppressWarnings(""rawtypes"")
	Class valueClass = VR.getReturnType();
	
	// If type match return the string representing the value
	if (valueClass.equals(mValue.getClass())) {
		String toReturn = """" + valueClass.cast(mValue);
		return toReturn;
	} else {
		return null;
	}
	
}","/**
 * @return DICOM element value as a String or null
 * if there is an error.
 */
public String getValueString() 
{
    try
    {
        return element.getStringValue();
    }
    catch (Exception e)
    {
        return null;
    }
}   ",1056,False
"/**
 * Write an integer on 2 bytes.
 * @param value Integer value.
 * @throws IOException
 */
protected final void writeInt16(int value) throws IOException{
	
	byte[] int16Bytes = new byte[2];
	
	int16Bytes[0] = (byte) ((value >> 8) & 0xff);
	int16Bytes[1] = (byte) ((value) & 0xff);
	
	super.write(int16Bytes);
	
}","/**
 * Write an integer on 2 bytes.
 * @param value Integer value.
 * @throws IOException
 */
protected final void writeInt16(int value) throws IOException 
{
    writeByte((byte)(value & 0xFF));
    writeByte((byte)((value >> 8) & 0xFF));
}   ",1058,True
"/**
 * Write an array of integer.
 * 
 * Each integer value is coded in 2 bytes.
 * 
 * @param intArray Array of integer values.
 * @throws IOException
 */
protected final void writeInt16Array(int[] intArray) throws IOException{
	
	byte[] intArrayBytes = new byte[intArray.length * 2];
	
	for (int i = 0; i < intArray.length; i ++) {
		
		intArrayBytes[(2 * i) + 0] =
			(byte) ((intArray[i] >> 8) & 0xff);
		
		intArrayBytes[(2 * i) + 1] =
			(byte) ((intArray[i]) & 0xff);
		
	}
	
	super.write(intArrayBytes);
	
}","/**
 * Write an array of integer.
 * 
 * Each integer value is coded in 2 bytes.
 * 
 * @param intArray Array of integer values.
 * @throws IOException
 */
protected final void writeInt16Array(int[] intArray) throws IOException 
{
    for (int i = 0; i < intArray.length; i++)
    {
        writeInt16(intArray[i]);
    }
}   ",1059,True
"// $ANTLR start ""TYPE_LIST""
public final void mTYPE_LIST() throws RecognitionException{
    try {
        int _type = TYPE_LIST;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:14:11: ( 'list' )
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:14:13: 'list'
        {
        match(""list""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""TYPE_LIST""
public final void mTYPE_LIST() throws RecognitionException 
{
    try
    {
        int _type = TYPE_LIST;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\Users\\user\\Desktop\\Univer\\3 course\\2 sem\\КПЗ\\ImageFilter\\src\\ImageFilter\\grammar\\ImageFilter.g4:12:11: ( ( TYPE )+ )
        // C:\\Users\\user\\Desktop\\Univer\\3 course\\2 sem\\КПЗ\\ImageFilter\\src\\ImageFilter\\grammar\\ImageFilter.g4:12:13: ( TYPE )+
        {
        // C:\\Users\\user\\Desktop\\Univer\\3 course\\2 sem\\КПЗ\\ImageFilter\\src\\ImageFilter\\grammar\\ImageFilter.g4:12:13: ( TYPE )+
        int cnt1=0;
        loop1:
        do
        {
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0==TYPE) )
            {
                alt1=1;
            }


            switch (alt1)
            {
                case 1 :
                    // C:\\Users\\user\\Desktop\\Univer\\3 course\\2 sem\\КПЗ\\ImageFilter\\src\\ImageFilter\\grammar\\ImageFilter.g4:12:13: TYPE
                    {
                    mTYPE(); 

                    }
                    break;

                default :
                    if ( cnt1 >= 1 ) break loop1;
                    EarlyExitException eee =
                        new EarlyExitException(1, input);
                    throw eee;
            }
            cnt1++;
        } while (true);


        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",1061,False
"// $ANTLR start ""STRING""
public final void mSTRING() throws RecognitionException{
    try {
        int _type = STRING;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:139:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\'' )
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:139:8: '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\''
        {
        match('\''); 
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:139:13: ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )*
        loop11:
        do {
            int alt11=3;
            int LA11_0 = input.LA(1);

            if ( (LA11_0=='\\') ) {
                alt11=1;
            }
            else if ( ((LA11_0>='\u0000' && LA11_0<='&')||(LA11_0>='(' && LA11_0<='[')||(LA11_0>=']' && LA11_0<='\uFFFF')) ) {
                alt11=2;
            }


            switch (alt11) {
        	case 1 :
        	    // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:139:15: ESC_SEQ
        	    {
        	    mESC_SEQ(); 

        	    }
        	    break;
        	case 2 :
        	    // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:139:25: ~ ( '\\\\' | '\\'' )
        	    {
        	    if ( (input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='\uFFFF') ) {
        	        input.consume();

        	    }
        	    else {
        	        MismatchedSetException mse = new MismatchedSetException(null,input);
        	        recover(mse);
        	        throw mse;}


        	    }
        	    break;

        	default :
        	    break loop11;
            }
        } while (true);

        match('\''); 

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""STRING""
public final void mSTRING() throws RecognitionException 
{
    try
    {
        int _type = STRING;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // /home/brutus729/Documents/FIB/CL/labs/GRADLE/antlr4/src/main/antlr4/Hello.g4:7:7: ( '\""' (~ ( '\""' ) )* '\""' )
        // /home/brutus729/Documents/FIB/CL/labs/GRADLE/antlr4/src/main/antlr4/Hello.g4:7:9: '\""' (~ ( '\""' ) )* '\""'
        {
            match('\""');
            // /home/brutus729/Documents/FIB/CL/labs/GRADLE/antlr4/src/main/antlr4/Hello.g4:7:13: (~ ( '\""' ) )*
            loop1:
            do
            {
                int alt1 = 2;
                int LA1_0 = input.LA(1);
                if (LA1_0 != '\""')
                {
                    alt1 = 1;
                }
                switch (alt1)
                {
                    case 1:
                        // /home/brutus729/Documents/FIB/CL/labs/GRADLE/antlr4/src/main/antlr4/Hello.g4:7:14: ~ ( '\""' )
                    {
                        if (input.LA(1) != '\""')
                        {
                            input.consume();
                        }
                        else
                        {
                            matchedEOF = true;
                        }
                    }
                    break;
                    default:
                        break loop1;
                }
            } while (true);
            match('\""');
            setText(getText().substring(1, getText().length() - 1));
        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
        // do for sure before leaving
    }
}   ",1062,False
"// $ANTLR start ""T__37""
public final void mT__37() throws RecognitionException{
    try {
        int _type = T__37;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:33:7: ( 'data;' )
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:33:9: 'data;'
        {
        match(""data;""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""T__37""
public final void mT__37() throws RecognitionException 
{
    try
    {
        int _type = T__37;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\Users\\Rohin\\Documents\\NetBeansProjects\\CSC 413 Grammar\\Project2.g:7:7: ( '!' )
        // C:\\Users\\Rohin\\Documents\\NetBeansProjects\\CSC 413 Grammar\\Project2.g:7:9: '!'
        {
            match('!');

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",1064,False
"/**
 * BSONifies the given Throwable.
 * 
 * @param throwable The throwable object to BSONify <i>(may be null)</i>.
 * @return The BSONified equivalent of the Throwable object <i>(may be null)</i>.
 */
private DBObject bsonifyThrowable(final Throwable throwable){
    DBObject result = null;
   
    if (throwable != null)
    {
        result = new BasicDBObject();
        
        nullSafePut(result, ""message"",    throwable.getMessage());
        nullSafePut(result, ""stackTrace"", bsonifyStackTrace(throwable.getStackTrace()));
    }
    
    return(result);
}","/**
 * BSONifies the given Throwable.
 * 
 * @param throwable The throwable object to BSONify <i>(may be null)</i>.
 * @return The BSONified equivalent of the Throwable object <i>(may be null)</i>.
 */
private DBObject bsonifyThrowable(final Throwable throwable) 
{
    if (throwable == null)
    {
        return null;
    }

    DBObject throwableBson = new BasicDBObject();
    throwableBson.put(""type"", throwable.getClass().getName());
    throwableBson.put(""message"", throwable.getMessage());
    throwableBson.put(""stacktrace"", throwable.getStackTrace());

    if (throwable.getCause() != null)
    {
        throwableBson.put(""cause"", bsonifyThrowable(throwable.getCause()));
    }

    return throwableBson;
}   ",1065,True
"/**
 * @param port The port to set <i>(must be > 0)</i>.
 */
private void setPort(final int port){
    // PRECONDITIONS
    assert port > 0 : ""port must be > 0"";
    
    // Body
    this.port = port;
}","/**
 * @param port The port to set <i>(must be > 0)</i>.
 */
private void setPort(final int port) 
{
    if (port <= 0)
    {
        throw new IllegalArgumentException(""Port must be > 0"");
    }
    this.port = port;
}   ",1070,True
"// $ANTLR start ""T__35""
public final void mT__35() throws RecognitionException{
    try {
        int _type = T__35;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:31:7: ( ')]' )
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:31:9: ')]'
        {
        match("")]""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""T__35""
public final void mT__35() throws RecognitionException 
{
    try
    {
        int _type = T__35;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C:\\Users\\user\\Desktop\\Unb\\TCC\\tcc\\grammars\\Gramatica.g:11:7: ( 'else' )
        // C:\\Users\\user\\Desktop\\Unb\\TCC\\tcc\\grammars\\Gramatica.g:11:9: 'else'
        {
        match(""else""); 



        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",1071,False
"// $ANTLR start ""T__34""
public final void mT__34() throws RecognitionException{
    try {
        int _type = T__34;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:30:7: ( '(' )
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:30:9: '('
        {
        match('('); 

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally {
    }
}","// $ANTLR start ""T__34""
public final void mT__34() throws RecognitionException 
{
    try
    {
        int _type = T__34;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // C.g4:11:7: ( '!' )
        // C.g4:11:9: '!'
        {
        match('!'); 

        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",1075,True
"// $ANTLR start ""OCTAL_ESC""
public final void mOCTAL_ESC() throws RecognitionException{
    try {
        // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        int alt15=3;
        switch ( input.LA(1) ) {
        case '\\':
            {
            switch ( input.LA(2) ) {
            case '0':
            case '1':
            case '2':
            case '3':
                {
                switch ( input.LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    {
                    switch ( input.LA(4) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                        {
                        alt15=1;
                        }
                        break;
                    default:
                        alt15=2;}

                    }
                    break;
                default:
                    alt15=3;}

                }
                break;
            case '4':
            case '5':
            case '6':
            case '7':
                {
                switch ( input.LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    {
                    alt15=2;
                    }
                    break;
                default:
                    alt15=3;}

                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("""", 15, 1, input);

                throw nvae;
            }

            }
            break;
        default:
            NoViableAltException nvae =
                new NoViableAltException("""", 15, 0, input);

            throw nvae;
        }

        switch (alt15) {
            case 1 :
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
                {
                match('\\'); 
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:14: ( '0' .. '3' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:15: '0' .. '3'
                {
                matchRange('0','3'); 

                }

                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:25: ( '0' .. '7' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:26: '0' .. '7'
                {
                matchRange('0','7'); 

                }

                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:36: ( '0' .. '7' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:157:37: '0' .. '7'
                {
                matchRange('0','7'); 

                }


                }
                break;
            case 2 :
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:158:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
                {
                match('\\'); 
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:158:14: ( '0' .. '7' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:158:15: '0' .. '7'
                {
                matchRange('0','7'); 

                }

                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:158:25: ( '0' .. '7' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:158:26: '0' .. '7'
                {
                matchRange('0','7'); 

                }


                }
                break;
            case 3 :
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:159:9: '\\\\' ( '0' .. '7' )
                {
                match('\\'); 
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:159:14: ( '0' .. '7' )
                // com/lowereast/guiceymongo/data/generator/parser/GuiceyData.g:159:15: '0' .. '7'
                {
                matchRange('0','7'); 

                }


                }
                break;

        }
    }
    finally {
    }
}","// $ANTLR start ""OCTAL_ESC""
public final void mOCTAL_ESC() throws RecognitionException 
{
    try
    {
        // g.g:18:10: ( '\\\\' ( OCTAL_DIGIT ) )
        // g.g:18:12: '\\\\' ( OCTAL_DIGIT )
        {
        match('\\'); 
        matchAny(); 

        }
    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input,re);
    }
    finally
    {
    }
    return ;
}   ",1077,True
"/**
 * Generate an array of Sound3D buffers.
 *
 * @param numBuffers The number of Sound3D buffers to generate.
 *
 * @return an array of (initially enpty) Sound3D buffers.
 */
public static Buffer[] generateBuffers(int numBuffers){
  Buffer[] result = new Buffer[numBuffers];
  int[] arr = new int[numBuffers];
  al.alGenBuffers(numBuffers, arr, 0);

  for (int i = 0; i < numBuffers; i++) {
    result[i] = new Buffer(al, arr[i]);
  }

  return result;
}","/**
 * Generate an array of Sound3D buffers.
 *
 * @param numBuffers The number of Sound3D buffers to generate.
 *
 * @return an array of (initially enpty) Sound3D buffers.
 */
public static Buffer[] generateBuffers(int numBuffers) 
{
    Buffer[] buffers = new Buffer[numBuffers];
    for (int i = 0; i < numBuffers; i++) {
        buffers[i] = new Sound3D();
    }
    return buffers;
}   ",1081,True
"/**
 * Get the default ALC object. This object is used to access most of the 
 * OpenAL context functionality.
 *
 * @return the ALC object
 */
public static ALC getALC() throws ALException{
  initialize();
  if (alc == null) {
    alc = new ALCImpl();
  }
  return alc;
}","/**
 * Get the default ALC object. This object is used to access most of the 
 * OpenAL context functionality.
 *
 * @return the ALC object
 */
public static ALC getALC() throws ALException 
{
    if (defaultALC == null)
    {
        defaultALC = new ALC10();
    }
    return defaultALC;
}   ",1085,True
"/*
 * Test for void alGetBufferi(int, int, IntBuffer)
 */
@Test
public void testAlGetBufferiintintIntBuffer() throws UnsupportedAudioFileException, IOException{
    int[] buffers = new int[1];
    al.alGenBuffers(1, buffers, 0);
    WAVData wd = loadTestWAV();
    al.alBufferData(buffers[0], wd.format, wd.data, wd.size, wd.freq);

    int[] size = new int[1];
    int[] freq = new int[1];
    al.alGetBufferi(buffers[0], AL.AL_SIZE, size, 0);
    al.alGetBufferi(buffers[0], AL.AL_FREQUENCY, freq, 0);
//        assertEquals(wd.size, size[0]);
    assertEquals(wd.freq, freq[0]);

    Exception ex = null;
    try {
        buffers = new int[1];
        al.alGenBuffers(1, buffers, 0);
        wd = loadTestWAV();
        al.alBufferData(buffers[0], wd.format, wd.data, wd.size, wd.freq);
        size = null;
        al.alGetBufferi(buffers[0], AL.AL_SIZE, size, 0);

    } catch (IllegalArgumentException e) {
        ex = e;
    }

    assertNotNull(ex);
    ex = null;
    try {
        buffers = new int[1];
        al.alGenBuffers(1, buffers, 0);
        wd = loadTestWAV();
        al.alBufferData(buffers[0], wd.format, wd.data, wd.size, wd.freq);
        size = new int[1];
        al.alGetBufferi(buffers[0], AL.AL_SIZE, size, 0);

    } catch (IllegalArgumentException e) {
        ex = e;
    }

//         assertNotNull(ex);
}","/*
 * Test for void alGetBufferi(int, int, IntBuffer)
 */

@Test
public void testAlGetBufferiintintIntBuffer() throws UnsupportedAudioFileException, IOException 
{
    ALBuffer alBuffer = ALFactory.getALBuffer();
    IntBuffer buffer = alBuffer.getBufferi(0, 0, 0);
    Assert.assertNotNull(buffer);
}   ",1093,False
"/**
 * Get the listener object associated with this Sound3D environment.
 *
 * @return The listener object.
 */
public static Listener getListener(){
  if (listener == null) {
    listener = new Listener(al);
  }

  return listener;
}","/**
 * Get the listener object associated with this Sound3D environment.
 *
 * @return The listener object.
 */
public static Listener getListener() 
{
    return listener;
}   ",1094,True
"/**
 * Makes the specified context the current context.
 *
 * @param context the context to make current.
 */
public static void makeContextCurrent(Context context){
  ALCcontext realContext = null;

  if (context != null) {
    realContext = context.realContext;
  }

  alc.alcMakeContextCurrent(realContext);
}","/**
 * Makes the specified context the current context.
 *
 * @param context the context to make current.
 */
public static void makeContextCurrent(Context context) 
{
    if (context == null)
    {
        throw new IllegalArgumentException(""context is null"");
    }
    if (context == currentContext)
    {
        return;
    }
    if (context.isDisposed())
    {
        throw new IllegalArgumentException(""context is disposed"");
    }
    currentContext = context;
}   ",1095,False
"/*
 * Test for void alGetBufferi(int, int, int[])
 */
@Test
public void testAlGetBufferiintintintArray() throws UnsupportedAudioFileException, IOException{
    System.out.println(""begin testAlGetBufferiintintintArray"");
    int[] buffers = new int[1];
    al.alGenBuffers(1, buffers, 0);
    WAVData wd = loadTestWAV();
    al.alBufferData(buffers[0], wd.format, wd.data, wd.size, wd.freq);
    int[] size = new int[1];
    int[] freq = new int[1];
    al.alGetBufferi(buffers[0], AL.AL_SIZE, size, 0);
    al.alGetBufferi(buffers[0], AL.AL_FREQUENCY, freq, 0);
//        assertEquals(wd.size, size[0]);
    assertEquals(wd.freq, freq[0]);

    Exception ex = null;
    try {
        buffers = new int[1];
        al.alGenBuffers(1, buffers, 0);
        wd = loadTestWAV();
        al.alBufferData(buffers[0], wd.format, wd.data, wd.size, wd.freq);
        size = null;
        al.alGetBufferi(buffers[0], AL.AL_SIZE, size, 0);

    } catch (IllegalArgumentException e) {
        ex = e;
    }

    assertNotNull(ex);

    System.out.println(""end testAlGetBufferiintintintArray"");
}","/*
 * Test for void alGetBufferi(int, int, int[])
 */
@Test
public void testAlGetBufferiintintintArray() throws UnsupportedAudioFileException, IOException 
{
    int[] values = new int[1];
    alGetBufferi(buffer, AL_FREQUENCY, values);
    assertEquals(22050, values[0]);
}   ",1097,False
"/**
 * Opens the specifified audio device. 
 *
 * @param deviceName The specified device name, On windows this will be 
 * DirectSound3D. We will be automating device discovery in upcoming versions
 * of this class.
 *
 * @return The device described by the specifed name.
 */
public static Device openDevice(String deviceName){
  Device result = null;
  ALCdevice realDevice = alc.alcOpenDevice(deviceName);
  result = new Device(alc, realDevice);

  return result;
}","/**
 * Opens the specifified audio device. 
 *
 * @param deviceName The specified device name, On windows this will be 
 * DirectSound3D. We will be automating device discovery in upcoming versions
 * of this class.
 *
 * @return The device described by the specifed name.
 */
public static Device openDevice(String deviceName) 
{
    Device device = new Device();
    device.setDeviceName(deviceName);
    device.open();
    return device;
}   ",1098,True
"/**
 * Get the ID of the article.
 * 
 * An article ID is the ID submitted in the permalink URL.
 * 
 * @return
 */
public String getID(){
	String id;
	
	try
	{
		id = this.article.getString(""id"");
	}
	catch (Exception e)
	{
		id = null;
	}
	
	return id;
}","/**
 * Get the ID of the article.
 * 
 * An article ID is the ID submitted in the permalink URL.
 * 
 * @return
 */
public String getID() 
{
    String[] parts = this.permalink.split(""/"");
    String lastPart = parts[parts.length - 1];
    return lastPart;
}   ",1102,True
"/**
 * Listener that gets the HTTPResponse and collects modhash and cookie from it
 */
public void loadContent(final String jsonString){
    JSONObject myData = null;
	
    // Try to build a JSONObject from the text
    try 
    {
    	myData = new JSONObject(jsonString);
    }
    catch (Exception e)
    {
        System.out.println(""EXCEPTION"");
        e.printStackTrace();
    }

    if (myData == null)
    {
    	return;
    }
    
    // Process the JSONObject
    try
    {
        // The data node of the JSON object
        myData = myData.getJSONObject(""json"");
        
        JSONArray myErrors = myData.getJSONArray(""errors"");
        
        myData = myData.getJSONObject(""data"");
        
        this.modhash = myData.getString(""modhash"");
        this.redditSession = myData.getString(""cookie"");
        this.loginSuccess = true;
    }
		catch (Exception e)
		{
			this.loginSuccess = false;
		}
		
		Event.trigger(this, ""LOADED"");
	}","/**
 * Listener that gets the HTTPResponse and collects modhash and cookie from it
 */

public void loadContent(final String jsonString) 
{
    try
    {
        JSONObject json = new JSONObject(jsonString);
        modhash = json.getString(""modhash"");
        cookie = json.getString(""cookie"");
    }
    catch (JSONException e)
    {
        e.printStackTrace();
    }
}   ",1105,True
"/**
 * Removes observer listener observing event of object. 
 * 
 * @param object
 * @param event
 * @param listener
 */
public static synchronized void stopObserving(Object object, String event, Listener listener){
	if (Event.objectTable.containsKey(object))
	{
		EventTable eventTable = (EventTable) Event.objectTable.get(object);
		if (eventTable.containsKey(event))
		{
			((ListenerTable) eventTable.get(event)).remove(listener);
		}
	}
}","/**
 * Removes observer listener observing event of object. 
 * 
 * @param object
 * @param event
 * @param listener
 */

public static synchronized void stopObserving(Object object, String event, Listener listener) 
{
    if (object != null && event != null && listener != null)
    {
        List<Listener> listeners = getListeners(object, event);
        if (listeners != null)
        {
            listeners.remove(listener);
        }
    }
}   ",1106,True
"/**
 * Get the URL of the article as a string.
 * 
 * @return
 */
public String getURL(){
    String url = """";
    
    try 
    {
        url = this.article.getString(""url"");
    }
    catch (Exception e)
    {
        System.out.println(""EXCEPTION"");
        e.printStackTrace();
    }
    
    return url;
}","/**
 * Get the URL of the article as a string.
 * 
 * @return
 */
public String getURL() 
{
    return url;
}   ",1107,True
"/**
 * Constructor
 * 
 * @param username
 * @param password
 */
public LoginRedditJSON(String username, String password){
	this.username = username;
	this.password = password;
}","/**
 * Constructor
 * 
 * @param username
 * @param password
 */
public LoginRedditJSON(String username, String password) 
{
    this.username = username;
    this.password = password;
    this.cookie = """";
    this.modhash = """";
}   ",1109,True
"/**
 * Get the number of up votes of the article.
 * 
 * @return
 */
public int getUps(){
    int ups = 0;
    
    try
    {
        ups = this.article.getInt(""ups"");
    }
    catch (Exception e)
    {
        System.out.println(""EXCEPTION"");
        e.printStackTrace();
    }
    
    return ups;
}","/**
 * Get the number of up votes of the article.
 * 
 * @return
 */
public int getUps() 
{
    return ups;
}   ",1110,True
"/**
 * Get the domain of the article.
 * 
 * @return
 */
public String getDomain(){
	String domain;
	
	try
	{
		domain = this.article.getString(""domain"");
	}
	catch (Exception e)
	{
		domain = null;
	}
	
	return domain;
}","/**
 * Get the domain of the article.
 * 
 * @return
 */
public String getDomain() 
{
    if (this.domain == null)
    {
        return """";
    }
    return this.domain;
}   ",1111,True
"/**
 * This constructor sets up the display.
 */
public LoginScreen(){
    super();
    
    this.unameEditField.setLabel(""Username: "");
    this.unameEditField.setMargin(24,0,0,8);
    
    this.pwEditField.setLabel(""Password: "");
    this.pwEditField.setMargin(12,0,0,8);
    
    // Login button with listener
    ButtonField loginButton = new ButtonField(
    	""Login to Reddit"", 
    	ButtonField.FIELD_HCENTER|ButtonField.CONSUME_CLICK
    );
    loginButton.setMargin(16,0,0,0);
    loginButton.setChangeListener( new FieldChangeListener()
	{
		/**
	 	* Called the login button is pressed
	 	*/
		public void fieldChanged(Field field, int context)
		{
				makeSessionLogin();
		}
	});

    this.add(unameEditField);
    this.add(pwEditField);
    this.add(loginButton);
    
    Event.observe(RedditSession.getInstance(), ""LOGIN"", this.loginListener);
}","/**
 * This constructor sets up the display.
 */
public LoginScreen() 
{
    super();
    this.setSize(800, 600);
    this.setTitle(""Login"");
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setResizable(false);
    this.setLocationRelativeTo(null);
    this.setLayout(null);
    this.setVisible(true);
}   ",1112,False
"/**
 * Get the number of comments.
 * 
 * @return
 */
public int getNumComments(){
    int numComments = 0;
    
    try 
    {
        numComments = this.article.getInt(""num_comments"");
    }
    catch (Exception e)
    {
        System.out.println(""EXCEPTION"");
        e.printStackTrace();
    }
    
    return numComments;
}","/**
 * Get the number of comments.
 * 
 * @return
 */
public int getNumComments() 
{
    return numComments;
}   ",1114,True
"/**
 * Get the score of the article.
 * 
 * @return
 */
public int getScore(){
    int score = 0;
    
    try 
    {
        score = this.article.getInt(""score"");
    }
    catch (Exception e)
    {
        System.out.println(""EXCEPTION"");
        e.printStackTrace();
    }
    
    return score;
}","/**
 * Get the score of the article.
 * 
 * @return
 */
public int getScore() 
{
    return score;
}   ",1115,True
"/**
 * Get the rating of the article as a percentage.
 * 
 * This calculates the percentage of voters who liked the article.
 * 
 * @return
 */
public int getRating(){
    int ups = this.getUps();
    int downs = this.getDowns();
    
    int rating = 0;
    
    rating = (int) java.lang.Math.floor(
            100*(double)ups/(double)(downs+ups));
    
    return rating;
}","/**
 * Get the rating of the article as a percentage.
 * 
 * This calculates the percentage of voters who liked the article.
 * 
 * @return
 */
public int getRating() 
{
    int totalVotes = getLikes() + getDislikes();
    if (totalVotes == 0)
    {
        return 0;
    }
    return (int) Math.round((double) getLikes() / totalVotes * 100);
}   ",1117,False
"/**
 * Trigger an event in an object.
 * 
 * Runs all listeners of an event in an object.
 * 
 * @param object  Observed object.
 * @param event  Observed event.
 */
public static synchronized void trigger(Object object, String event){
	// Get the objects event table
	EventTable eventTable = (EventTable) Event.objectTable.get(object);
	if (eventTable != null) {
		// Get the events listener table
		ListenerTable listenerTable = (ListenerTable) eventTable.get(event);
		if (listenerTable != null) {
			// Execute all listener callbacks.
			Enumeration set = listenerTable.elements();
			Listener listener;
			while (set.hasMoreElements()) {
				listener = (Listener) set.nextElement();
				listener.callback(object);
			}
		}
	}
}","/**
 * Trigger an event in an object.
 * 
 * Runs all listeners of an event in an object.
 * 
 * @param object  Observed object.
 * @param event  Observed event.
 */
public static synchronized void trigger(Object object, String event) 
{
    if (listeners.containsKey(object))
    {
        if (listeners.get(object).containsKey(event))
        {
            for (Listener listener : listeners.get(object).get(event))
            {
                listener.run();
            }
        }
    }
}   ",1118,False
"/**
 * Returns the URI of an element (SAX flavor)
 *
 * @param attrs the element's attributes that hold the location information
 * @return the element's URI or ""<code>[unknown location]</code>"" if <code>attrs</code>
 *         has no location information.
 */
public static String getURI(Attributes attrs){
    String src = attrs.getValue(URI, SRC_ATTR);
    return src != null ? src : LocationUtils.UNKNOWN_STRING;
}","/**
 * Returns the URI of an element (SAX flavor)
 *
 * @param attrs the element's attributes that hold the location information
 * @return the element's URI or ""<code>[unknown location]</code>"" if <code>attrs</code>
 *         has no location information.
 */
public static String getURI(Attributes attrs) 
{
    String uri = attrs.getValue(""uri"");
    if (uri == null) {
        uri = attrs.getValue(0);
    }
    return uri != null ? uri : ""[unknown location]"";
}   ",1127,True
"/**
 * Extracts the identifier from an index row key.
 *
 * @param bytes byte array containing an encoded row key at its end (and arbitrary bytes before that).
 *              Note that this method modifies the bytes in case inverted is true!
 * @param inverted indicates if the bits in the row key are inverted (can be the case for descending ordering)
 */
public static byte[] decode(byte[] bytes, boolean inverted){
    if (inverted) {
        for (int i = 0; i < Bytes.SIZEOF_INT; i++) {
            int pos = bytes.length - i - 1;
            bytes[pos] = bytes[pos] ^= 0xFF;
        }
    }

    int keyLength = Bytes.toInt(bytes, bytes.length - Bytes.SIZEOF_INT);
    byte[] result = new byte[keyLength];
    System.arraycopy(bytes, bytes.length - keyLength - Bytes.SIZEOF_INT, result, 0, keyLength);
    
    if (inverted) {
        for (int j = 0; j < result.length; j++) {
            result[j] ^= 0xFF;
        }
    }

    return result;
}","/**
 * Extracts the identifier from an index row key.
 *
 * @param bytes byte array containing an encoded row key at its end (and arbitrary bytes before that).
 *              Note that this method modifies the bytes in case inverted is true!
 * @param inverted indicates if the bits in the row key are inverted (can be the case for descending ordering)
 */
public static byte[] decode(byte[] bytes, boolean inverted) 
{
    if (inverted)
        invert(bytes);

    return Arrays.copyOf(bytes, bytes.length - 4);
}   ",1128,True
"/**
 * Add location attributes to a set of SAX attributes.
 *
 * @param locator the <code>Locator</code> (can be null)
 * @param attrs the <code>Attributes</code> where locator information should be added
 */
public static Attributes addLocationAttributes(Locator locator, Attributes attrs){
    if (locator == null || attrs.getIndex(URI, SRC_ATTR) != -1) {
        // No location information known, or already has it
        return attrs;
    }

    // Get an AttributeImpl so that we can add new attributes.
    AttributesImpl newAttrs = attrs instanceof AttributesImpl ?
        (AttributesImpl)attrs : new AttributesImpl(attrs);

    newAttrs.addAttribute(URI, SRC_ATTR, Q_SRC_ATTR, ""CDATA"", locator.getSystemId());
    newAttrs.addAttribute(URI, LINE_ATTR, Q_LINE_ATTR, ""CDATA"", Integer.toString(locator.getLineNumber()));
    newAttrs.addAttribute(URI, COL_ATTR, Q_COL_ATTR, ""CDATA"", Integer.toString(locator.getColumnNumber()));

    return newAttrs;
}","/**
 * Add location attributes to a set of SAX attributes.
 *
 * @param locator the <code>Locator</code> (can be null)
 * @param attrs the <code>Attributes</code> where locator information should be added
 */
public static Attributes addLocationAttributes(Locator locator, Attributes attrs) 
{
    if (locator != null) {
        String systemId = locator.getSystemId();
        if (systemId != null) {
            attrs = addAttribute(attrs, ""systemId"", systemId);
        }
        String publicId = locator.getPublicId();
        if (publicId != null) {
            attrs = addAttribute(attrs, ""publicId"", publicId);
        }
        int lineNumber = locator.getLineNumber();
        if (lineNumber != -1) {
            attrs = addAttribute(attrs, ""lineNumber"", Integer.toString(lineNumber));
        }
        int columnNumber = locator.getColumnNumber();
        if (columnNumber != -1) {
            attrs = addAttribute(attrs, ""columnNumber"", Integer.toString(columnNumber));
        }
    }
    return attrs;
}   ",1129,True
"/**
 * Returns the column number of an element (SAX flavor)
 *
 * @param attrs the element's attributes that hold the location information
 * @return the element's column number or <code>-1</code> if <code>attrs</code>
 *         has no location information.
 */
public static int getColumn(Attributes attrs){
    String col = attrs.getValue(URI, COL_ATTR);
    return col != null ? Integer.parseInt(col) : -1;
}","/**
 * Returns the column number of an element (SAX flavor)
 *
 * @param attrs the element's attributes that hold the location information
 * @return the element's column number or <code>-1</code> if <code>attrs</code>
 *         has no location information.
 */

public static int getColumn(Attributes attrs) 
{
    int col = -1;
    if (attrs != null) {
        SourceLocator locator = attrs.getSourceLocator();
        if (locator != null) {
            col = locator.getColumnNumber();
        }
    }
    return col;
}   ",1132,True
"/**
 * Retrieves an Index.
 *
 * @throws IndexNotFoundException if the index does not exist
 */
public Index getIndex(String table, String name) throws IOException, IndexNotFoundException{
  Get get = new Get(Bytes.toBytes(IndexDefinition.buildIndexName(table, name)));
  Result result = metaTable.get(get);

  if (result.isEmpty())
    throw new IndexNotFoundException(table, name);

  byte[] jsonData = result.getValue(Bytes.toBytes(""meta""), Bytes.toBytes(""conf""));
  IndexDefinition indexDef = deserialize(table, name, jsonData);

  HTable htable = new HTable(hbaseConf, dataTableName);
  Index index = new Index(htable, indexDef);
  return index;
}","/**
 * Retrieves an Index.
 *
 * @throws IndexNotFoundException if the index does not exist
 */
public Index getIndex(String table, String name) throws IOException, IndexNotFoundException 
{
    Index index = indexCache.get(table, name);
    if (index == null)
    {
        throw new IndexNotFoundException(table, name);
    }
    return index;
}   ",1133,False
"/**
 * Code to print out a complete bit representation of a byte,
 * including leading zeros.
 *
 * <p>Copied from
 * http://manniwood.wordpress.com/2009/10/21/javas-long-tobinarystringlong-l-come-on-guys/
 */
private String toBinaryString(byte val){
    StringBuilder sb = new StringBuilder(8);
    for (int i = 7; i >= 0; i--) {
        sb.append((testBit(val, i) == 0) ? '0' : '1');
    }
    return sb.toString();
}","/**
 * Code to print out a complete bit representation of a byte,
 * including leading zeros.
 *
 * <p>Copied from
 * http://manniwood.wordpress.com/2009/10/21/javas-long-tobinarystringlong-l-come-on-guys/
 */
private String toBinaryString(byte val) 
{
    StringBuilder sb = new StringBuilder();
    for (int i = 7; i >= 0; i--)
    {
        sb.append(val >> i & 1);
    }
    return sb.toString();
}   ",1135,True
"/**
 * Test searching on a subset of the fields.
 */
@Test
public void testPartialQuery() throws Exception{
    final String INDEX_NAME = ""partialQuery"";
    IndexManager indexManager = new IndexManager(TEST_UTIL.getConfiguration());

    IndexDefinition indexDef = new IndexDefinition(INDEX_NAME, INDEX_NAME);
    indexDef.addStringField(""field1"");
    indexDef.addIntegerField(""field2"");
    indexDef.addStringField(""field3"");

    indexManager.createIndex(indexDef);

    Index index = indexManager.getIndex(INDEX_NAME, INDEX_NAME);

    for (int i = 0; i < 3; i++) {
        IndexEntry entry = new IndexEntry();
        entry.addField(""field1"", ""value A "" + i);
        entry.addField(""field2"", 10 + i);
        entry.addField(""field3"", ""value B "" + i);
        index.addEntry(entry, Bytes.toBytes(""key"" + i));
    }

    // Search only on the leftmost field
    {
        Query query = new Query();
        query.addEqualsCondition(""field1"", ""value A 0"");
        QueryResult result = index.performQuery(query);
        assertResultIds(result, ""key0"");
    }

    // Search only on the two leftmost fields
    {
        Query query = new Query();
        query.addEqualsCondition(""field1"", ""value A 0"");
        query.addEqualsCondition(""field2"", 10);
        QueryResult result = index.performQuery(query);
        assertResultIds(result, ""key0"");
    }

    // Search only on the two leftmost fields, with range query on the second
    {
        Query query = new Query();
        query.addEqualsCondition(""field1"", ""value A 0"");
        query.setRangeCondition(""field2"", 9, 11);
        QueryResult result = index.performQuery(query);
        assertResultIds(result, ""key0"");
    }

    // Try searching on just the second field, should give error
    {
        Query query = new Query();
        query.addEqualsCondition(""field2"", 10);
        try {
            index.performQuery(query);
            fail(""Exception expected"");
        } catch (MalformedQueryException e) {
            //System.out.println(e.getMessage());
        }
    }

    // Try searching on just the second field, should give error
    {
        Query query = new Query();
        query.setRangeCondition(""field2"", 9, 11);
        try {
            index.performQuery(query);
            fail(""Exception expected"");
        } catch (MalformedQueryException e) {
            //System.out.println(e.getMessage());
        }
    }

    // Try not using all fields from left to right, should give error
    {
        Query query = new Query();
        query.addEqualsCondition(""field1"", ""value A 0"");
        // skip field 2
        query.addEqualsCondition(""field3"", ""value B 0"");
        try {
            index.performQuery(query);
            fail(""Exception expected"");
        } catch (MalformedQueryException e) {
            //System.out.println(e.getMessage());
        }
    }

    // Try not using all fields from left to right, should give error
    {
        Query query = new Query();
        query.addEqualsCondition(""field1"", ""value A 0"");
        // skip field 2
        query.setRangeCondition(""field3"", ""a"", ""b"");
        try {
            index.performQuery(query);
            fail(""Exception expected"");
        } catch (MalformedQueryException e) {
            //System.out.println(e.getMessage());
        }
    }
}","/**
 * Test searching on a subset of the fields.
 */
@Test
public void testPartialQuery() throws Exception 
{
    // Create a new search query
    SearchQuery query = new SearchQuery();
    query.setQuery(""test"");
    query.setSearchFields(new String[] { ""title"", ""content"" });

    // Perform the search
    SearchResult result = searchService.search(query);

    // Assert the search results
    Assert.assertEquals(1, result.getTotalHits());
    Assert.assertEquals(1, result.getResults().size());
    Assert.assertEquals(""Test document"", result.getResults().get(0).getTitle());
}   ",1137,False
"/**
 * Create repository manager with given build repositories
 *
 * @param repositories
 */
@DataBoundConstructor
public RepositoryManager(List<BuildRepository> repositories){
	if (repositories != null)
		repos = Collections.unmodifiableList(repositories);
	else
		repos = Collections.emptyList();
}","/**
 * Create repository manager with given build repositories
 *
 * @param repositories
 */



@DataBoundConstructor
public RepositoryManager(List<BuildRepository> repositories) 
{
    this.repositories = new ArrayList<>(repositories);
    this.repositories.sort(Comparator.comparing(BuildRepository::getUrl));
}   ",1143,True
"/**
 * Create commit log writer
 * 
 * @param writer
 *            must be non-null
 */
public CommitLogWriter(Writer writer){
	if (writer == null)
		throw new IllegalArgumentException(""Writer cannot be null"");
	gson = GsonUtils.getGson();
	jsonWriter = new JsonWriter(writer);
}","/**
 * Create commit log writer
 * 
 * @param writer
 *            must be non-null
 */
public CommitLogWriter(Writer writer) 
{
    if (writer == null)
    {
        throw new IllegalArgumentException(""writer must be non-null"");
    }
    this.writer = writer;
}   ",1144,True
"/**
 * Write commit. Null commits will be ignored.
 * 
 * @param commit
 * @return this commit log writer
 * @throws IOException
 */
public CommitLogWriter write(Commit commit) throws IOException{
	if (commit == null)
		return this;
	if (first) {
		jsonWriter.beginArray();
		first = false;
	}
	try {
		gson.toJson(commit, Commit.class, jsonWriter);
	} catch (JsonIOException e) {
		throw new IOException(e);
	}
	return this;
}","/**
 * Write commit. Null commits will be ignored.
 * 
 * @param commit
 * @return this commit log writer
 * @throws IOException
 */
public CommitLogWriter write(Commit commit) throws IOException 
{
    if (commit != null)
    {
        commit.write(out);
    }
    return this;
}   ",1145,False
"/**
 * Test polling a {@link BuildRepository} with no new changes
 *
 * @throws Exception
 */
@Test
public void noChanges() throws Exception{
	RevCommit commit = git.add(""file.txt"", ""a"");
	BuildRepository repo = new BuildRepository(git.repo().getDirectory()
			.toURI().toString(), ""refs/heads/master"", null);
	CloneOperation clone = new CloneOperation(repo);
	File dir = git.tempDirectory();
	assertNotNull(clone.invoke(dir, null));
	BuildRepositoryState state = new BuildRepositoryState();
	state.put(repo, commit);
	PollOperation op = new PollOperation(state,
			Collections.singletonList(repo));
	assertEquals(PollingResult.NO_CHANGES, op.invoke(dir, null));
}","/**
 * Test polling a {@link BuildRepository} with no new changes
 *
 * @throws Exception
 */
@Test
public void noChanges() throws Exception 
{
    final BuildRepository repository = new BuildRepository();
    final BuildRepository.PollResult result = repository.poll();
    Assert.assertEquals(0, result.getChanges().size());
    Assert.assertEquals(BuildRepository.PollResult.NO_CHANGES, result);
}   ",1153,False
"/**
 * Test polling with an empty repository state
 *
 * @throws Exception
 */
@Test
public void emptyState() throws Exception{
	git.add(""file.txt"", ""a"");
	BuildRepository repo = new BuildRepository(git.repo().getDirectory()
			.toURI().toString(), ""refs/heads/master"", null);
	CloneOperation clone = new CloneOperation(repo);
	File dir = git.tempDirectory();
	assertNotNull(clone.invoke(dir, null));
	PollOperation op = new PollOperation(new BuildRepositoryState(),
			Collections.singletonList(repo));
	assertEquals(PollingResult.BUILD_NOW, op.invoke(dir, null));
}","/**
 * Test polling with an empty repository state
 *
 * @throws Exception
 */
@Test
public void emptyState() throws Exception 
{
    final RepositoryState state = new RepositoryState();
    final RepositoryStatePoller poller = new RepositoryStatePoller();
    final RepositoryState result = poller.poll(state);
    Assert.assertEquals(state, result);
}   ",1156,False
"/**
 * Create poll operation using given baseline
 *
 * @param baseline
 * @param repos
 */
public PollOperation(BuildRepositoryState baseline,
		List<BuildRepository> repos){
	if (baseline == null)
		throw new IllegalArgumentException(""Baseline cannot be null"");
	if (repos == null)
		throw new IllegalArgumentException(""Repos cannot be null"");
	state = baseline;
	this.repos = repos;
}","/**
 * Create poll operation using given baseline
 *
 * @param baseline
 * @param repos
 */
public PollOperation(BuildRepositoryState baseline,
		List<BuildRepository> repos) 
{
	this.baseline = baseline;
	this.repos = repos;
}	",1157,True
"/**
 * Create commit file from diff entry
 * 
 * @param entry
 */
public CommitFile(DiffEntry entry){
	type = entry.getChangeType();
	switch (type) {
	case ADD:
		oldPath = null;
		newPath = entry.getNewPath();
		break;
	case DELETE:
		oldPath = entry.getOldPath();
		newPath = null;
		break;
	case COPY:
	case MODIFY:
	case RENAME:
	default:
		oldPath = entry.getOldPath();
		newPath = entry.getNewPath();
		break;
	}
}","/**
 * Create commit file from diff entry
 * 
 * @param entry
 */
public CommitFile(DiffEntry entry) 
{
    this.changeType = entry.getChangeType();
    this.oldPath = entry.getOldPath();
    this.newPath = entry.getNewPath();
    this.oldId = entry.getOldId();
    this.newId = entry.getNewId();
}   ",1158,True
"/**
 * @Around methodsToLog
 */
public Object logMethod(StaticJoinPoint joinPoint) throws Throwable{
    MemberSignature signature = (MemberSignature) joinPoint.getSignature();
    indent();
    System.out.println(
            ""--> ""
            + joinPoint.getCalleeClass().getName()
            + ""::""
            + signature.getName()
    );
    m_level++;
    final Object result = joinPoint.proceed();
    m_level--;
    indent();
    System.out.println(
            ""<-- ""
            + joinPoint.getCalleeClass().getName()
            + ""::""
            + signature.getName()
    );
    return result;
}","/**
 * @Around methodsToLog
 */

public Object logMethod(StaticJoinPoint joinPoint) throws Throwable 
{
    String methodName = joinPoint.getSignature().getName();
    Object[] args = joinPoint.getArgs();

    System.out.println(""Calling method: "" + methodName + "" with arguments: "" + Arrays.toString(args));

    Object result = joinPoint.proceed();

    System.out.println(""Method "" + methodName + "" returned: "" + result);

    return result;
}   ",1161,True
"/**
 * Returns the return type.
 *
 * @return the return type
 */
public ClassInfo getReturnType(){
    if (m_returnType == null) {
        Class returnTypeClass = ((Method) m_member).getReturnType();
        if (m_classInfoRepository.hasClassInfo(returnTypeClass.getName())) {
            m_returnType = m_classInfoRepository.getClassInfo(returnTypeClass.getName());
        } else {
            m_returnType = JavaClassInfo.getClassInfo(returnTypeClass);
            m_classInfoRepository.addClassInfo(m_returnType);
        }
    }
    return m_returnType;
}","/**
 * Returns the return type.
 *
 * @return the return type
 */
public ClassInfo getReturnType() 
{
    return returnType;
}   ",1162,False
"/**
 * Creates the getSignature method.
 */
protected void createGetSignatureMethod(){
	MethodVisitor cv = m_cw.visitMethod(ACC_PUBLIC,
	                                  GET_SIGNATURE_METHOD_NAME,
	                                  GET_SIGNATURE_METHOD_SIGNATURE,
	                                  null,
	                                  null);

	cv.visitFieldInsn(GETSTATIC,
	                  m_joinPointClassName,
	                  SIGNATURE_FIELD_NAME,
	                  STATICINITIALIZATION_SIGNATURE_IMPL_CLASS_SIGNATURE);
	cv.visitInsn(ARETURN);
	cv.visitMaxs(0, 0);
}","/**
 * Creates the getSignature method.
 */
protected void createGetSignatureMethod() 
{
    Method method = new Method();
    method.setAccess(""public"");
    method.setReturnType(new Type(""String""));
    method.setName(""getSignature"");

    this.getSignatureMethod = method;
}   ",1163,False
"/**
 * Return the annotation with a specific name for a specific constructor.
 *
 * @param annotationName  the annotation name
 * @param constructorInfo the ConstructorInfo object to find the annotation on.
 * @return the annotation or null
 */
public static Annotation getAnnotation(final String annotationName, final ConstructorInfo constructorInfo){
    return constructorInfo.getDeclaringType().getAnnotationReader().getConstructorAnnotation(
            annotationName,
            constructorInfo.getSignature(),
            constructorInfo.getDeclaringType().getClassLoader()
    );
}","/**
 * Return the annotation with a specific name for a specific constructor.
 *
 * @param annotationName  the annotation name
 * @param constructorInfo the ConstructorInfo object to find the annotation on.
 * @return the annotation or null
 */
public static Annotation getAnnotation(final String annotationName, final ConstructorInfo constructorInfo) 
{
    if (constructorInfo != null)
    {
        for (Annotation annotation : constructorInfo.getAnnotations())
        {
            if (annotation.getName().equals(annotationName))
            {
                return annotation;
            }
        }
    }
    return null;
}   ",1167,True
"/**
 * Returns the method info for the method specified.
 *
 * @param method the method
 * @return the method info
 */
public static MethodInfo getMethodInfo(final Method method){
    Class declaringClass = method.getDeclaringClass();
    JavaClassInfoRepository repository = JavaClassInfoRepository.getRepository(declaringClass.getClassLoader());
    ClassInfo classInfo = repository.getClassInfo(declaringClass.getName());
    if (classInfo == null) {
        classInfo = JavaClassInfo.getClassInfo(declaringClass);
    }
    return classInfo.getMethod(ReflectHelper.calculateHash(method));
}","/**
 * Returns the method info for the method specified.
 *
 * @param method the method
 * @return the method info
 */
public static MethodInfo getMethodInfo(final Method method) 
{
    if (method == null)
    {
        return null;
    }
    return new MethodInfo(method);
}   ",1168,False
"/**
 * Creates the getRtti method
 */
protected void createGetRttiMethod(){
	MethodVisitor cv = m_cw.visitMethod(ACC_PUBLIC,
	                                  GET_RTTI_METHOD_NAME,
	                                  GET_RTTI_METHOD_SIGNATURE,
	                                  null,
	                                  null
	);

	// new StaticInitializationRttiImpl
	cv.visitTypeInsn(NEW, STATICINITIALIZATION_RTTI_IMPL_CLASS_NAME);
	cv.visitInsn(DUP);
	cv.visitFieldInsn(GETSTATIC,
	                  m_joinPointClassName,
	                  SIGNATURE_FIELD_NAME,
	                  STATICINITIALIZATION_SIGNATURE_IMPL_CLASS_SIGNATURE);
        cv.visitMethodInsn(INVOKESPECIAL, 
                           STATICINITIALIZATION_RTTI_IMPL_CLASS_NAME, 
                           INIT_METHOD_NAME,
                           STATICINITIALIZATION_RTTI_IMPL_INIT_SIGNATURE
        );
        
	cv.visitInsn(ARETURN);
	cv.visitMaxs(0, 0);
}","/**
 * Creates the getRtti method
 */
protected void createGetRttiMethod() 
{
    MethodGen getRttiMethod = il.addMethod(""getRtti"", Type.VOID, new Type[] {}, null, null);
    getRttiMethod.getInstructionList().append(InstructionConstants.ARETURN);
}   ",1170,False
"/**
 * @AfterThrowing(type=""java.lang.IllegalArgumentException"", pointcut=""methodsToLog"")
 */
public void logAfterThrowingIAE(final StaticJoinPoint joinPoint) throws Throwable{
    MemberSignature signature = (MemberSignature) joinPoint.getSignature();
    System.out.println(
            ""AFTER THROWING IAE: ""
            + joinPoint.getCalleeClass().getName()
            + ""::""
            + signature.getName()
    );
}","/**
 * @AfterThrowing(type=""java.lang.IllegalArgumentException"", pointcut=""methodsToLog"")
 */
public void logAfterThrowingIAE(final StaticJoinPoint joinPoint) throws Throwable 
{
    final String methodName = joinPoint.getSignature().getName();
    final Object[] args = joinPoint.getArgs();
    final StringBuilder sb = new StringBuilder();
    sb.append(""AfterThrowing: "");
    sb.append(methodName);
    sb.append(""("");
    for (int i = 0; i < args.length; i++)
    {
        sb.append(args[i]);
        if (i < args.length - 1)
        {
            sb.append("", "");
        }
    }
    sb.append("")"");
    System.out.println(sb.toString());
}   ",1171,True
"/**
 * Returns the parameter types.
 *
 * @return the parameter types
 */
public ClassInfo[] getParameterTypes(){
    if (m_parameterTypes == null) {
        Class[] parameterTypes = ((Method) m_member).getParameterTypes();
        m_parameterTypes = new ClassInfo[parameterTypes.length];
        for (int i = 0; i < parameterTypes.length; i++) {
            Class parameterType = parameterTypes[i];
            ClassInfo metaData;
            if (m_classInfoRepository.hasClassInfo(parameterType.getName())) {
                metaData = m_classInfoRepository.getClassInfo(parameterType.getName());
            } else {
                metaData = JavaClassInfo.getClassInfo(parameterType);
                m_classInfoRepository.addClassInfo(metaData);
            }
            m_parameterTypes[i] = metaData;
        }
    }
    return m_parameterTypes;
}","/**
 * Returns the parameter types.
 *
 * @return the parameter types
 */
public ClassInfo[] getParameterTypes() 
{
    return parameterTypes;
}   ",1172,False
"/**
 * Creates join point specific fields.
 */
protected void createJoinPointSpecificFields(){
    m_fieldNames = new String[0];
    
	m_cw.visitField(ACC_PRIVATE + ACC_STATIC,
					SIGNATURE_FIELD_NAME,
					STATICINITIALIZATION_SIGNATURE_IMPL_CLASS_SIGNATURE,
					null,
					null);
}","/**
 * Creates join point specific fields.
 */
protected void createJoinPointSpecificFields() 
{
    if (this.joinPointSpecificFields == null)
    {
        this.joinPointSpecificFields = new ArrayList<JoinPointField>();
    }
}   ",1176,True
"/**
 * Creates the signature for the join point.
 * 
 * @param cv
 */
protected void createSignature(final MethodVisitor cv){
	cv.visitFieldInsn(GETSTATIC,
	                  m_joinPointClassName,
	                  TARGET_CLASS_FIELD_NAME_IN_JP,
	                  CLASS_CLASS_SIGNATURE);
	cv.visitMethodInsn(INVOKESTATIC,
	                   SIGNATURE_FACTORY_CLASS,
	                   NEW_STATICINITIALIZATION_SIGNATURE_METHOD_NAME,
	                   NEW_STATICINITIALIZATION_SIGNATURE_METHOD_SIGNATURE);
	cv.visitFieldInsn(PUTSTATIC,
	                  m_joinPointClassName,
	                  SIGNATURE_FIELD_NAME,
	                  STATICINITIALIZATION_SIGNATURE_IMPL_CLASS_SIGNATURE);
}","/**
 * Creates the signature for the join point.
 * 
 * @param cv
 */
protected void createSignature(final MethodVisitor cv) 
{
    String desc = Type.getMethodDescriptor(method);
    cv.visitVarInsn(Opcodes.ALOAD, 0);
    cv.visitFieldInsn(Opcodes.GETFIELD, owner, name, desc);
}   ",1177,False
"// v has at least 1 edge to given cluster
protected boolean intDegNotZero(Node v, byte c){
	for (Relationship e : v.getRelationships()) {

		Node u = e.getOtherNode(v);
		byte uColor = (Byte) u.getProperty(Consts.COLOR);

		if (c == uColor)
			return true;

	}

	return false;
}","// v has at least 1 edge to given cluster
protected boolean intDegNotZero(Node v, byte c) 
{
    if (c == 0)
        return (v.getDeg() > 0);
    else
        return (v.getDeg(c) > 0);
}   ",1180,False
"// Literal implementation of pseudo code. Too complex/convoluted to be used
// p is used to find jMax. Smaller p -> larger jMax
private void evoPartitionOld(Double theta, Double p){

	// Set W(j) = W(0) = V
	Long volumeG = getVolumeG((byte) -1);

	Long m = volumeG / 2;

	// Set j = 0
	Integer j = 0;

	// Set conductance = theta/7
	Double conductance = theta / 7;

	// [WHILE] j < 12.m.Ceil( lg(1/p) ) [AND] volumeWj >= (3/4)volumeG
	Double jMax = 12 * m * Math.ceil(Math.log10(1.0 / p));

	Long volumeWj = volumeG;

	System.out.printf(""evoPartition[theta=%f,p=%f]\n"", theta, p);
	System.out.printf(""            [conduct=%f,jMax=%f,volWj=%d]\n"",
			conductance, jMax, volumeWj);

	while ((j < jMax) && (volumeWj >= (3.0 / 4.0) * (double) volumeG)) {

		System.out.printf(
				""evoPartition[j=%d,jMax=%f,volWj=%d, 3/4volG[%f]]\n%s\n"",
				j, jMax, volumeWj, (3.0 / 4.0) * (double) volumeG,
				nodesToStr());

		Transaction tx = transNeo.beginTx();

		try {

			// -> D(j) = evoNibble(G[W(j-1)], conductance)
			DataStructEvoPartition Dj = evoNibble(conductance, volumeWj);

			j++;

			// -> Set j = j+1
			if (Dj != null) {
				System.out.printf(
						""\n\tevoNibble returned. |D%d|[%d], volD%d[%d]\n"",
						j, Dj.getS().size(), j, Dj.getVolume());
				System.out.printf(""\t%s\n\n"", dToStr(Dj.getS()));

				// -> W(j) = W(j-1) - D(j)
				clusterColor++;
				updateClusterAlloc(Dj.getS(), clusterColor);

				volumeWj -= Dj.getVolume();

				tx.success();
			} else
				System.out.printf(
						""\n\tevoNibble returned. D(%d) = null!\n\n"", j);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			tx.finish();
		}

	}

	System.out
			.printf(
					""\nevoPartition[volWj=%d, 3/4volG[%f], volG[%d]]\n%s\n\n"",
					volumeWj, (3.0 / 4.0) * (double) volumeG, volumeG,
					nodesToStr());

	// Set D = D(1) U ... U D(j)
	// In this implementation vertices are colored rather than removed,
	// so there is no need to perform a Union operation

	// TODO Tidy up the unallocated vertices here?
}","// Literal implementation of pseudo code. Too complex/convoluted to be used
// p is used to find jMax. Smaller p -> larger jMax
private void evoPartitionOld(Double theta, Double p) 
{
    int jMax = (int) Math.ceil(Math.log(1 / p) / Math.log(1 - theta));
    int n = 1;
    int j = 0;
    while (n < jMax)
    {
        j++;
        n = (int) Math.ceil(n * (1 - theta) / (1 - Math.pow(theta, j)));
    }
}   ",1181,False
"// ***********************************************************
// *****************PRINT OUTS********************************
// ***********************************************************
private String getClusterSizes(){
	String result = ""[ "";

	for (byte c = 0; c < config.getClusterCount(); c++) {
		result = String.format(""%s%d "", result, clusterSizes.get(c));
	}

	return String.format(""%s]"", result);
}","// ***********************************************************
// *****************PRINT OUTS********************************
// ***********************************************************
private String getClusterSizes() 
{
    String s = """";
    for (int i = 0; i < clusterSizes.length; i++)
    {
        s += clusterSizes[i] + "" "";
    }
    return s;
}   ",1183,True
"// NOTE Currently load is diffused EQUALLY (ignores edge weights)
protected void diffuseLoadToNeighbours(Node node){

	int neighbourCount = 0;
	for (Relationship rel : node.getRelationships()) {
		neighbourCount++;
	}

	if (neighbourCount == 0)
		return;

	ArrayList<Double> lV = l.get(node.getId());
	ArrayList<Double> wV = w.get(node.getId());

	for (byte i = 0; i < config.getClusterCount(); i++) {
		double lVPerNeighbour = lV.get(i) / neighbourCount;
		double wVPerNeighbour = wV.get(i) / neighbourCount;

		for (Relationship rel : node.getRelationships()) {

			Node otherNode = rel.getOtherNode(node);

			ArrayList<Double> lVOther = l.get(otherNode.getId());
			ArrayList<Double> wVOther = w.get(otherNode.getId());

			lVOther.set(i, lVOther.get(i) + lVPerNeighbour);
			wVOther.set(i, wVOther.get(i) + wVPerNeighbour);
		}
	}

}","// NOTE Currently load is diffused EQUALLY (ignores edge weights)
protected void diffuseLoadToNeighbours(Node node) 
{
    double load = node.getLoad();
    double diffusedLoad = load / node.getNeighbours().size();
    for (Node neighbour : node.getNeighbours())
    {
        neighbour.setLoad(neighbour.getLoad() + diffusedLoad);
    }
}   ",1185,False
"// ***********************************************************
// *****************PRINT OUTS / DEBUGGING********************
// ***********************************************************
protected String getConfigStr(){
	return String
			.format(
					""DiDiC [FOST_ITERS=%d, FOSB_ITERS=%d, MAX_CLUSTERS=%d, TIME_STEPS=%d]%n"",
					config.getFOSTIterations(), config.getFOSBIterations(),
					config.getClusterCount(), config.getMaxIterations());
}","// ***********************************************************
// *****************PRINT OUTS / DEBUGGING********************
// ***********************************************************
protected String getConfigStr() 
{
    String configStr = ""Config: "";
    for (int i = 0; i < config.length; i++)
    {
        configStr += config[i] + "" "";
    }
    return configStr;
}   ",1186,False
"// Assign to cluster:
// * Associated with highest load value
protected byte allocateClusterBasic(ArrayList<Double> wC,
		ArrayList<Double> lC){
	byte maxC = 0;
	double maxW = 0.0;

	for (byte c = 0; c < wC.size(); c++) {

		double loadTotal = wC.get(c);

		if (loadTotal > maxW) {
			maxW = loadTotal;
			maxC = c;
		}
	}

	return maxC;
}","// Assign to cluster:
// * Associated with highest load value
protected byte allocateClusterBasic(ArrayList<Double> wC,
		ArrayList<Double> lC) 
{
	byte cluster = 0;
	double max = 0;
	for (int i = 0; i < lC.size(); i++)
	{
		if (lC.get(i) > max)
		{
			max = lC.get(i);
			cluster = (byte) i;
		}
	}
	return cluster;
}	",1188,False
"// Choose random vertex from remaining (unpartitioned) vertices
// Choose vertex with probability P(X=x) = d(x)/volume(G)
protected Node getRandomNode(){
	Double randVal = expGenVertex.nextValue();

	long randIndex = Math.round(randVal * (nodes.size() - 1));

	// Exponential distribution can result in randIndex > 1.0
	// Default to node with highest degree in this case
	if (randIndex >= nodes.size())
		randIndex = 0;

	if (nodes.size() == 0)
		return null;

	return transNeo.getNodeById(nodes.get((int) randIndex));
}","// Choose random vertex from remaining (unpartitioned) vertices
// Choose vertex with probability P(X=x) = d(x)/volume(G)
protected Node getRandomNode() 
{
    int numVertices = this.graph.getNumVertices();
    int numRemainingVertices = this.graph.getNumRemainingVertices();
    int numRemainingEdges = this.graph.getNumRemainingEdges();

    int randomIndex = this.random.nextInt(numRemainingVertices);
    Node randomNode = this.graph.getVertex(randomIndex);

    return randomNode;
}   ",1189,False
"// Optimized version. Find vDeg once only
protected double alphaE(Node u, int vDeg){
	// alphaE = 1/max{deg(u),deg(v)};
	double uDeg = getDeg(u);

	return 1.0 / Math.max(uDeg, vDeg);
}","// Optimized version. Find vDeg once only
protected double alphaE(Node u, int vDeg) 
{
    double alpha = 0;
    for (int i = 0; i < vDeg; i++) {
        alpha += u.getNeighbor(i).getWeight();
    }
    return alpha;
}   ",1193,False
"// Color all nodes in Dj with color j
protected void updateClusterAlloc(ArrayList<Long> Dj, Byte j)
		throws Exception{

	for (Long vID : Dj) {

		Node v = transNeo.getNodeById(vID);
		v.setProperty(Consts.COLOR, j);

		if (nodes.remove(vID) == false) {
			throw new Exception(String.format(
					""Could not remove node %d from nodes"", vID));
		}

	}

}","// Color all nodes in Dj with color j
protected void updateClusterAlloc(ArrayList<Long> Dj, Byte j)
		throws Exception 
{
	for (Long i : Dj)
	{
		this.updateNodeAlloc(i, j);
	}
}	",1194,True
"/**
 * Indicates that the specified entity has been mentioned.
 * @param e The entity which has been mentioned.
 */
public void mentionEntity(DiscourseEntity e){
  if (entities.remove(e)) {
    entities.add(0,e);
  }
  else {
    System.err.println(""DiscourseModel.mentionEntity: failed to remove ""+e);
  }
}","/**
 * Indicates that the specified entity has been mentioned.
 * @param e The entity which has been mentioned.
 */
public void mentionEntity(DiscourseEntity e) 
{
    if (!mentionedEntities.contains(e)) {
        mentionedEntities.add(e);
    }
}   ",1200,True
"/**
 * Tests {@link Sequence#compareTo(Sequence)}.
 */
public void testCompareTo(){
  Sequence lowScore = new Sequence();
  lowScore.add(""A"", 1d);
  lowScore.add(""B"", 2d);
  lowScore.add(""C"", 3d);

  Sequence highScore = new Sequence();
  lowScore.add(""A"", 7d);
  lowScore.add(""B"", 8d);
  lowScore.add(""C"", 9d);

  assertEquals(-1, lowScore.compareTo(highScore));
  assertEquals(1, highScore.compareTo(lowScore));
  assertEquals(0, highScore.compareTo(highScore));
}","/**
 * Tests {@link Sequence#compareTo(Sequence)}.
 */
public void testCompareTo() 
{
    Sequence seq1 = new Sequence(3);
    Sequence seq2 = new Sequence(3);
    Sequence seq3 = new Sequence(4);
    Sequence seq4 = new Sequence(2);

    assertEquals(0, seq1.compareTo(seq2));
    assertTrue(seq1.compareTo(seq3) < 0);
    assertTrue(seq1.compareTo(seq4) > 0);
}   ",1203,True
"/**
 * Returns the entities in the discourse model.
 * @return the entities in the discourse model.
 */
public DiscourseEntity[] getEntities(){
  DiscourseEntity[] des = new DiscourseEntity[entities.size()];
  entities.toArray(des);
  return(des);
}","/**
 * Returns the entities in the discourse model.
 * @return the entities in the discourse model.
 */
public DiscourseEntity[] getEntities() 
{
    return m_entities;
}   ",1205,True
"/**
 * Creates {@link Entry}s form the given {@link InputStream} and
 * forwards these {@link Entry}s to the {@link EntryInserter}.
 *
 * After creation is finished the provided {@link InputStream} is closed.
 *
 * @param in
 * @param inserter
 *
 * @throws IOException
 * @throws InvalidFormatException
 */
public static void create(InputStream in, EntryInserter inserter)
    throws IOException, InvalidFormatException{

  DictionaryContenthandler profileContentHandler =
      new DictionaryContenthandler(inserter);

  XMLReader xmlReader;
  try {
    xmlReader = XMLReaderFactory.createXMLReader();
    xmlReader.setContentHandler(profileContentHandler);
    xmlReader.parse(new InputSource(in));
  }
  catch (SAXException e) {
    throw new InvalidFormatException(""The profile data stream has "" +
          ""an invalid format!"", e);
  }
}","/**
 * Creates {@link Entry}s form the given {@link InputStream} and
 * forwards these {@link Entry}s to the {@link EntryInserter}.
 *
 * After creation is finished the provided {@link InputStream} is closed.
 *
 * @param in
 * @param inserter
 *
 * @throws IOException
 * @throws InvalidFormatException
 */

public static void create(InputStream in, EntryInserter inserter)
    throws IOException, InvalidFormatException 
{
    try (InputStream is = in) {
        EntryReader reader = new EntryReader(is);
        Entry entry;
        while ((entry = reader.nextEntry()) != null) {
            inserter.insert(entry);
        }
    }
}   ",1206,False
"/**
 * Checks that {@link Sequence#toString()} is executable.
 */
public void testToString(){
  new Sequence().toString();

  Sequence sequence = new Sequence();
  sequence.add(""test"", 0.1d);
  sequence.toString();
}","/**
 * Checks that {@link Sequence#toString()} is executable.
 */
public void testToString() 
{
    Sequence seq = new Sequence();
    seq.add(""a"");
    seq.add(""b"");
    seq.add(""c"");
    assertEquals(""(a, b, c)"", seq.toString());
}   ",1207,True
"/**
 * Creates a dictionary which contains all {@link StringList}s which
 * are in the current {@link NGramModel}.
 *
 * @param caseSensitive Specifies whether case distinctions should be kept in the creation of the dictionary.
 *
 * @return a dictionary of the ngrams
 */
public Dictionary toDictionary(boolean caseSensitive){

  Dictionary dict = new Dictionary(caseSensitive);

  for (Iterator<StringList> it = iterator(); it.hasNext();) {
    dict.put((StringList)it.next());
  }

  return dict;
}","/**
 * Creates a dictionary which contains all {@link StringList}s which
 * are in the current {@link NGramModel}.
 *
 * @param caseSensitive Specifies whether case distinctions should be kept in the creation of the dictionary.
 *
 * @return a dictionary of the ngrams
 */
public Dictionary toDictionary(boolean caseSensitive) 
{
    Dictionary dictionary = new Dictionary(caseSensitive);
    for (StringList ngram : ngrams)
    {
        dictionary.add(ngram.toString());
    }
    return dictionary;
}   ",1210,True
"/**
 * Represents this objects as human readable {@link String}.
 */
public String toString(){
  return ""Accuracy:"" + wordAccuracy.mean() +
      "" Number of Samples: "" + wordAccuracy.count();
}","/**
 * Represents this objects as human readable {@link String}.
 */
public String toString() 
{
    return ""MyObject{"" +
            ""id="" + id +
            "", name='"" + name + '\'' +
            "", value="" + value +
            '}';
}   ",1211,False
"/**
 * Retrieves the total count of all Ngrams.
 *
 * @return total count of all ngrams
 */
public int numberOfGrams(){
  int counter = 0;

  for (Iterator<StringList> it = iterator(); it.hasNext();) {

    StringList ngram = it.next();

    counter += getCount(ngram);
  }

  return counter;
}","/**
 * Retrieves the total count of all Ngrams.
 *
 * @return total count of all ngrams
 */
public int numberOfGrams() 
{
    int count = 0;
    for (int i = 0; i < ngrams.length; i++) {
        count += ngrams[i].size();
    }
    return count;
}   ",1213,True
"/**
 * Helper function for getContext.
 */
private void addCharPreds(String key, char c, List<String> preds){
  preds.add(key + ""="" + c);
  if (Character.isLetter(c)) {
    preds.add(key+""_alpha"");
    if (Character.isUpperCase(c)) {
      preds.add(key+""_caps"");
    }
  }
  else if (Character.isDigit(c)) {
    preds.add(key+""_num"");
  }
  else if (Character.isWhitespace(c)) {
    preds.add(key+""_ws"");
  }
  else {
    if (c=='.' || c=='?' || c=='!') {
      preds.add(key+""_eos"");
    }
    else if (c=='`' || c=='""' || c=='\'') {
      preds.add(key+""_quote"");
    }
    else if (c=='[' || c=='{' || c=='(') {
      preds.add(key+""_lp"");
    }
    else if (c==']' || c=='}' || c==')') {
      preds.add(key+""_rp"");
    }
  }
}","/**
 * Helper function for getContext.
 */
private void addCharPreds(String key, char c, List<String> preds) 
{
    if (key.length() == 0)
    {
        preds.add(c + """");
    }
    else
    {
        preds.add(key + c);
    }
}   ",1217,True
"/**
 * Reads all {@link POSSample} objects from the stream
 * and evaluates each {@link POSSample} object with
 * {@link #evaluateSample(POSSample)} method.
 *
 * @param samples the stream of reference {@link POSSample} which
 * should be evaluated.
 */
public void evaluate(ObjectStream<POSSample> samples) throws ObjectStreamException{
  POSSample sample;
  while ((sample = samples.read()) != null) {
    evaluateSample(sample);
  }
}","/**
 * Reads all {@link POSSample} objects from the stream
 * and evaluates each {@link POSSample} object with
 * {@link #evaluateSample(POSSample)} method.
 *
 * @param samples the stream of reference {@link POSSample} which
 * should be evaluated.
 */
public void evaluate(ObjectStream<POSSample> samples) throws ObjectStreamException 
{
    while (samples.hasNext()) {
        POSSample sample = samples.next();
        evaluateSample(sample);
    }
}   ",1219,True
"/**
 * Construct with a class and criteria binder that return exactly one result. Use this for fetch
 * instructions, scalar results, or if the persistent object ID is not available. Criteria that
 * return more than one result will produce exceptions. Criteria that return no result
 * will produce a null object.
 * @param objectClass class of object for root criteria
 * @param criteriaBuilder builder to apply criteria restrictions
 */
public HibernateObjectModel(Class objectClass, CriteriaBuilder criteriaBuilder){
	this.objectClass = objectClass;
	this.criteriaBuilder = criteriaBuilder;
}","/**
 * Construct with a class and criteria binder that return exactly one result. Use this for fetch
 * instructions, scalar results, or if the persistent object ID is not available. Criteria that
 * return more than one result will produce exceptions. Criteria that return no result
 * will produce a null object.
 * @param objectClass class of object for root criteria
 * @param criteriaBuilder builder to apply criteria restrictions
 */
public HibernateObjectModel(Class objectClass, CriteriaBuilder criteriaBuilder) 
{
    this.objectClass = objectClass;
    this.criteriaBuilder = criteriaBuilder;
}   ",1224,True
"/**
 * @param object The object to bind properties of
 * @param properties The properties list to associate
 */
public PropertyQueryBinder(final Object object, final String[] properties){
	this.object = object;
	this.properties = properties;
}","/**
 * @param object The object to bind properties of
 * @param properties The properties list to associate
 */
public PropertyQueryBinder(final Object object, final String[] properties) 
{
    this.object = object;
    this.properties = properties;
}   ",1225,True
"/** Compares contained objects if present, otherwise calls super-implementation.*/
@Override
public boolean equals(Object obj){
	Object target = getObject();
	if (target != null && obj instanceof HibernateObjectModel)
		return target.equals(((HibernateObjectModel)obj).getObject());
	return super.equals(obj);
}","/** Compares contained objects if present, otherwise calls super-implementation.*/
@Override
public boolean equals(Object obj) 
{
    if (obj instanceof AbstractContainer)
    {
        AbstractContainer other = (AbstractContainer) obj;
        return Objects.equals(this.contained, other.contained);
    }
    return super.equals(obj);
}   ",1226,False
"/**
 * Return user object by matching against a ""username"" property. Override
 * if you have a differently named property.
 * @return DataUser for the given username. 
 */
@SuppressWarnings(""unchecked"")
public DataUser getUser(String username){
	try {
		Query q = Query.select().where(""username = ?"", username).limit(1);
		DataUser[] users = (DataUser[]) Databinder.getEntityManager().find(
				(Class<? extends RawEntity>)getUserClass(),q);
		if (users.length == 0)
			return null;
		return users[0];
	} catch (SQLException e) {
		throw new WicketRuntimeException(e);
	}
}","/**
 * Return user object by matching against a ""username"" property. Override
 * if you have a differently named property.
 * @return DataUser for the given username. 
 */
@SuppressWarnings(""unchecked"")
public DataUser getUser(String username) 
{
    Criteria crit = getSession().createCriteria(DataUser.class);
    crit.add(Restrictions.eq(""username"", username));
    return (DataUser)crit.uniqueResult();
}   ",1227,False
"/**
 * Internal initialization. Client applications should not normally override
 * or call this method.
 */
@Override
protected void internalInit(){
	super.internalInit();
	authInit();
}","/**
 * Internal initialization. Client applications should not normally override
 * or call this method.
 */
@Override
protected void internalInit() 
{
    super.internalInit();

    // initialize the default configuration
    if (defaultConfiguration == null)
    {
        defaultConfiguration = new Configuration();
    }
}   ",1228,True
"/** Use the given model (must not be read-only ) for the search string */
public SearchPanel(final String id, final IModel searchModel){
	super(id, searchModel);
	add(new SearchForm(""searchForm""));
}","/** Use the given model (must not be read-only ) for the search string */
public SearchPanel(final String id, final IModel searchModel) 
{
	this(id, searchModel, null);
}   ",1229,True
"/**
 * Sets Wicket's security strategy for role authorization and appoints this 
 * object as the unauthorized instatiation listener. Called automatically on start-up.
 */
protected void authInit(){
	getSecuritySettings().setAuthorizationStrategy(new RoleAuthorizationStrategy(this));
	getSecuritySettings().setUnauthorizedComponentInstantiationListener(this);
}","/**
 * Sets Wicket's security strategy for role authorization and appoints this 
 * object as the unauthorized instatiation listener. Called automatically on start-up.
 */
protected void authInit() 
{
    WicketSession.get().setAuthorizationStrategy(new MyAuthorizationStrategy(this));
    getApplicationSettings().setUnauthorizedComponentInstantiationListener(this);
}   ",1232,True
"/**
 * Create a model bound to the given class and entity id. If nothing matches
 * the id the model object will be null.
 * @param objectClass class to be loaded and stored by Hibernate
 * @param entityId id of the persistent object
 */
public HibernateObjectModel(Class objectClass, Serializable entityId){
	this.objectClass = objectClass;
	this.objectId = entityId;
}","/**
 * Create a model bound to the given class and entity id. If nothing matches
 * the id the model object will be null.
 * @param objectClass class to be loaded and stored by Hibernate
 * @param entityId id of the persistent object
 */
public HibernateObjectModel(Class objectClass, Serializable entityId) 
{
    this.objectClass = objectClass;
    this.entityId = entityId;
    this.object = loadObject();
}   ",1233,True
"/**
 * Disassociates this object from any persistent object, but retains the class
 * for constructing a blank copy if requested.
 * @see HibernateObjectModel#HibernateObjectModel(Class objectClass)
 * @see #isBound()
 */
public void unbind(){
	objectId = null;
	queryBuilder = null;
	criteriaBuilder = null;
	retainedObject = null;
	detach();
}","/**
 * Disassociates this object from any persistent object, but retains the class
 * for constructing a blank copy if requested.
 * @see HibernateObjectModel#HibernateObjectModel(Class objectClass)
 * @see #isBound()
 */
public void unbind() 
{
    if (isBound())
    {
        this.objectClass = null;
        this.object = null;
    }
}   ",1235,True
"/**
 * Load the object through Hibernate, contruct a new instance if it is not
 * bound to an id, or use unsaved retained object. Returns null if no
 * criteria needed to load or construct an object are available.
 */
@SuppressWarnings(""unchecked"")
@Override
protected T load(){
	if (objectClass == null && queryBuilder == null)
		return null;	// can't load without one of these
	try {
		if (!isBound()) {
			if (retainUnsaved && retainedObject != null)
				return retainedObject;
			else if (retainUnsaved) try {
				return retainedObject = (T) objectClass.newInstance();
			} catch (ClassCastException e) {
				throw new WicketRuntimeException(""Unsaved entity must be Serializable or retainUnsaved set to false; see HibernateObjectModel javadocs."");
			}
			else
				return (T) objectClass.newInstance();
		}
	} catch (ClassCastException e) {
		throw new RuntimeException(""Retaining unsaved model objects requires that they be Serializable."", e);
	} catch (Throwable e) {
		throw new RuntimeException(""Unable to instantiate object. Does it have a default constructor?"", e);
	}
	Session sess = Databinder.getHibernateSession(factoryKey);
	if (objectId != null) {
		return (T) sess.get(objectClass, objectId);
	}

	if(criteriaBuilder != null) {
		Criteria criteria = sess.createCriteria(objectClass);
		criteriaBuilder.build(criteria);
		return (T) criteria.uniqueResult();
	}

	return (T) queryBuilder.build(sess).uniqueResult();
}","/**
 * Load the object through Hibernate, contruct a new instance if it is not
 * bound to an id, or use unsaved retained object. Returns null if no
 * criteria needed to load or construct an object are available.
 */
@SuppressWarnings(""unchecked"")
@Override
protected T load() 
{
    if (id != null)
    {
        return (T) HibernateUtil.getSession().get(clazz, id);
    }
    else if (retained != null)
    {
        return retained;
    }
    else
    {
        return null;
    }
}   ",1236,False
"/**
 * Set a factory key other than the default (null).
 * @param key session factory key
 * @return this, for chaining
 */
public HibernateObjectModel setFactoryKey(Object key){
	this.factoryKey = key;
	return this;
}","/**
 * Set a factory key other than the default (null).
 * @param key session factory key
 * @return this, for chaining
 */
public HibernateObjectModel setFactoryKey(Object key) 
{
    if (key == null)
    {
        throw new IllegalArgumentException(""Factory key cannot be null"");
    }
    this.factoryKey = key;
    return this;
}   ",1237,True
"/**
 * Creates a simple, one attribute set trigger. Just used to reduce the amount of coding required :)
 * 
 * @param paramName
 *            Name of the parameter to create the trigger from
 * @param paramVal
 *            The value of said triggered
 * @param required
 *            Whether this trigger triggered means that the parameter must be used
 * @return The newly created trigger
 */
public static Trigger CreateSimpleTrigger(String paramName, String paramVal, boolean required){
	HashMap params = new HashMap();
	params.put(paramName, paramVal);
	return new Trigger(params, required);
}","/**
 * Creates a simple, one attribute set trigger. Just used to reduce the amount of coding required :)
 * 
 * @param paramName
 *            Name of the parameter to create the trigger from
 * @param paramVal
 *            The value of said triggered
 * @param required
 *            Whether this trigger triggered means that the parameter must be used
 * @return The newly created trigger
 */
public static Trigger CreateSimpleTrigger(String paramName, String paramVal, boolean required) 
{
    Trigger trigger = new Trigger();
    trigger.setParamName(paramName);
    trigger.setParamValue(paramVal);
    trigger.setRequired(required);
    return trigger;
}   ",1241,True
"/**
 * Compares two maps. Looks like AbstractMap::equals() doesn't work correctly!
 * 
 * @param m1
 *            First map to check
 * @param m2
 *            Second map for the comparison
 * @return true/false if they're equal or not
 */
private boolean mapsEqual(Map m1, Map m2){
	// boolean retVal = false;
	
	if (!m1.keySet().equals(m2.keySet())) {
		return false;
	}
	
	Iterator m1Iter = m1.keySet().iterator();
	while (m1Iter.hasNext()) {
		Object key = m1Iter.next();
		if (m1.get(key) == null)
			return false;
		if (m2.get(key) == null)
			return false;
		
		if (!m1.get(key).equals(m2.get(key))) {
			return false;
		}
	}
	
	return true;
}","/**
 * Compares two maps. Looks like AbstractMap::equals() doesn't work correctly!
 * 
 * @param m1
 *            First map to check
 * @param m2
 *            Second map for the comparison
 * @return true/false if they're equal or not
 */
private boolean mapsEqual(Map m1, Map m2) 
{
    if (m1.size() != m2.size())
    {
        return false;
    }

    for (Object key : m1.keySet())
    {
        if (!m1.get(key).equals(m2.get(key)))
        {
            return false;
        }
    }

    return true;
}   ",1245,True
"/**
 * Checks to see if the passed object is equal to this value
 */
public boolean equals(Object obj){
	if (obj instanceof Value) {
		// if the name is the same and the type is the same
		// assume its the same
		if (((Value) obj).getValue().equals(this.value)) {
			return true;
		}
	}
	
	return false;
}","/**
 * Checks to see if the passed object is equal to this value
 */
public boolean equals(Object obj) 
{
    if (obj instanceof Integer)
    {
        Integer i = (Integer) obj;
        return value == i.intValue();
    }
    return false;
}   ",1250,True
"/**
 * Constructs a new Tag with the specified name and whether or not it is a single tag or not (i.e. &lt;cfbreak&gt;).
 * 
 * @param name
 *            The name of the tag
 * @param single
 *            Is the tag a single tag or not
 */
public Tag(String name, boolean single){
	super(name);
	this.single = single;
}","/**
 * Constructs a new Tag with the specified name and whether or not it is a single tag or not (i.e. &lt;cfbreak&gt;).
 * 
 * @param name
 *            The name of the tag
 * @param single
 *            Is the tag a single tag or not
 */
public Tag(String name, boolean single) 
{
    this.name = name;
    this.single = single;
}   ",1253,True
"/**
 * This gets a string array of supported types. This is mostly used in the radio display on the project settings. It
 * builds a string array from the key and label attributes in the dictionary config file
 * 
 * @return {key, label} array
 */
public static String[][] getConfiguredDictionaries(){
	NodeList cfmltypes = dictionaryConfig.getElementById(CFDIC_KEY).getChildNodes();
	
	byte typeslen = (byte) cfmltypes.getLength();
	
	String[][] options = new String[typeslen][2];
	
	for (byte z = 0; z < typeslen; z++) {
		String key = cfmltypes.item(z).getAttributes().getNamedItem(""key"").getNodeValue();
		String label = cfmltypes.item(z).getAttributes().getNamedItem(""label"").getNodeValue();
		
		options[z][0] = label;
		options[z][1] = key;
	}
	
	return options;
}","/**
 * This gets a string array of supported types. This is mostly used in the radio display on the project settings. It
 * builds a string array from the key and label attributes in the dictionary config file
 * 
 * @return {key, label} array
 */
public static String[][] getConfiguredDictionaries() 
{
    String[][] supportedTypes = new String[ProjectSettings.getSupportedDictionaries().size()][2];
    int i = 0;
    for (Map.Entry<String, String> entry : ProjectSettings.getSupportedDictionaries().entrySet())
    {
        supportedTypes[i][0] = entry.getKey();
        supportedTypes[i][1] = entry.getValue();
        i++;
    }
    return supportedTypes;
}   ",1254,False
"/**
 * Parse the project's main properties file
 * @return Object that contains all of the configuration parameters
 */
public static Properties getConfig(){
	try {
		Properties mainConfig = new Properties();
		// Load the config.properties file and return the Properties object
		mainConfig.load(new FileInputStream(""build/classes/org/cl/nm417/config/config.properties""));
		return mainConfig;
	} catch (Exception ex) {
		ex.printStackTrace();
	}
	return null;
}","/**
 * Parse the project's main properties file
 * @return Object that contains all of the configuration parameters
 */


public static Properties getConfig() 
{
    if (config == null)
    {
        config = new Properties();
        try
        {
            config.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(""main.properties""));
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
    return config;
}   ",1260,True
"/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#equals(java.lang.Object)
 */
public boolean equals(Object obj){
    if (this == obj) return true;
    if (obj == null) return false;
    
    if (!(obj instanceof ISynset)) return false;
    final ISynset other = (ISynset) obj;
    
    if (fGloss == null) {
        if (other.getGloss() != null) return false;
    } else if (!fGloss.equals(other.getGloss())) return false;
    
    if (!fID.equals(other.getID())) return false;
    if (!fWords.equals(other.getWords())) return false;
    if (fIsAdjSat != other.isAdjectiveSatellite()) return false;
    if (!synsetMap.equals(other.getRelatedMap())) return false;
    return true;
}","/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#equals(java.lang.Object)
 */
public boolean equals(Object obj) 
{
    if (obj == null)
    {
        return false;
    }
    if (getClass() != obj.getClass())
    {
        return false;
    }
    final MyObject other = (MyObject) obj;
    if (this.id != other.id)
    {
        return false;
    }
    return true;
}   ",1263,False
"/**
 * Returns the singleton instance of this class, instantiating it if
 * necessary.
 */
public static ExceptionLineParser getInstance(){
	if (fInstance == null) fInstance = new ExceptionLineParser();
	return fInstance;
}","/**
 * Returns the singleton instance of this class, instantiating it if
 * necessary.
 */
public static ExceptionLineParser getInstance() 
{
    if (instance == null)
    {
        instance = new ExceptionLineParser();
    }
    return instance;
}   ",1264,True
"/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#toString()
 */
public String toString(){
    StringBuffer buffer = new StringBuffer();
    buffer.append(""SYNSET{"");
    buffer.append(fID.toString());
    buffer.append("" : Words["");
    for (IWord word : fWords) {
        buffer.append(word.toString());
        buffer.append("", "");
    }
    buffer.replace(buffer.length() - 2, buffer.length(), ""]}"");

    return buffer.toString();
}","/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#toString()
 */
public String toString() 
{
    return ""User [id="" + id + "", name="" + name + "", email="" + email + "", password="" + password + "", active="" + active
            + "", roles="" + roles + ""]"";
}   ",1266,False
"/**
 * @throws NullPointerException if the argument is <code>null</code>
 */
public ExceptionEntryProxy(IExceptionEntryProxy proxy){
	fSurface = proxy.getSurfaceForm();
	fRoots = proxy.getRootForms();
}","/**
 * @throws NullPointerException if the argument is <code>null</code>
 */
public ExceptionEntryProxy(IExceptionEntryProxy proxy) 
{
    if (proxy == null)
    {
        throw new NullPointerException(""proxy"");
    }
    this.proxy = proxy;
}   ",1268,False
"/**
 * The arguments, and the contents of the array, cannot be null, otherwise
 * it will throw an NullPointerException or IllegalArgumentException.
 */
public ExceptionEntryProxy(String surfaceForm, String ... rootForms){
	if (surfaceForm == null) throw new NullPointerException();
	for(String form : rootForms){
		if (form == null || form.length() == 0)	throw new IllegalArgumentException();
	}
	
	fSurface = surfaceForm;
	fRoots = Collections.unmodifiableList(Arrays.asList(rootForms));
}","/**
 * The arguments, and the contents of the array, cannot be null, otherwise
 * it will throw an NullPointerException or IllegalArgumentException.
 */
public ExceptionEntryProxy(String surfaceForm, String ... rootForms) 
{
    if (surfaceForm == null || rootForms == null)
    {
        throw new NullPointerException(""Arguments cannot be null."");
    }

    this.surfaceForm = surfaceForm;
    this.rootForms = rootForms;
}   ",1269,True
"/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#hashCode()
 */
public int hashCode(){
    final int PRIME = 31;
    int result = 1;
    result = PRIME * result + ((fGloss == null) ? 0 : fGloss.hashCode());
    result = PRIME * result + (fIsAdjSat ? 1231 : 1237);
    result = PRIME * result + fID.hashCode();
    result = PRIME * result + fWords.hashCode();
    result = PRIME * result + synsetMap.hashCode();
    return result;
}","/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#hashCode()
 */
public int hashCode() 
{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    return result;
}   ",1272,False
"/**
 * @throws NullPointerException if any argument is <code>null</code>
 */
public Synset(ISynsetID id, ILexFile lexFile, boolean isAdjSat, boolean isAdjHead, String gloss, 
		List<IWord> words, Map<IPointer, ? extends List<ISynsetID>> ids){
	
	if(id == null || lexFile == null || gloss == null) throw new NullPointerException();
    if(isAdjSat && isAdjHead) throw new IllegalArgumentException();
    if((isAdjSat || isAdjHead) && lexFile.getNumber() != 0) throw new IllegalArgumentException();
    
    fID = id;
    fLexFile = lexFile;
    fGloss = gloss;
    fIsAdjSat = isAdjSat;
    fIsAdjHead = isAdjHead;

    // copy words
    fWords = Collections.unmodifiableList(words); // takes care of null pointer in words

    Set<ISynsetID> hiddenSet = null;
    Map<IPointer, List<ISynsetID>> hiddenMap = null;
    // fill synset map
    if(ids != null){
    	hiddenSet = new LinkedHashSet<ISynsetID>();
    	hiddenMap = new HashMap<IPointer, List<ISynsetID>>(ids.size());
    	for(Entry<IPointer, ? extends List<ISynsetID>> entry : ids.entrySet()){
    		if(entry.getValue() == null || entry.getValue().isEmpty()) continue;
    		hiddenMap.put(entry.getKey(), Collections.unmodifiableList(new ArrayList<ISynsetID>(entry.getValue())));
    		hiddenSet.addAll(entry.getValue());
    	}
    }
    allRelated = (hiddenSet != null && !hiddenSet.isEmpty()) ? Collections.unmodifiableList(new ArrayList<ISynsetID>(hiddenSet)) : Collections.<ISynsetID>emptyList();
    synsetMap = (hiddenMap != null && !hiddenMap.isEmpty()) ? Collections.unmodifiableMap(hiddenMap) : Collections.<IPointer, List<ISynsetID>>emptyMap();
}","/**
 * @throws NullPointerException if any argument is <code>null</code>
 */
public Synset(ISynsetID id, ILexFile lexFile, boolean isAdjSat, boolean isAdjHead, String gloss, 
		List<IWord> words, Map<IPointer, ? extends List<ISynsetID>> ids) 
{
	super(id, lexFile, isAdjSat, isAdjHead, gloss, words, ids);
}	",1279,True
"/**
 * 1. Create entries in roster groups
 * 2. Iterate on all the entries and remove them from the roster
 * 3. Check that the number of entries and groups is zero
 */
public void testDeleteAllRosterEntries() throws Exception{
    // Add a new roster entry
    Roster roster = getConnection(0).getRoster();
    roster.createEntry(getBareJID(1), ""gato11"", new String[] { ""Friends"" });
    roster.createEntry(getBareJID(2), ""gato12"", new String[] { ""Family"" });

    // Wait up to 2 seconds to receive new roster contacts
    long initial = System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000  && roster.getEntryCount() != 2) {
        Thread.sleep(100);
    }

    assertEquals(""Wrong number of entries in connection 0"", 2, roster.getEntryCount());

    // Wait up to 2 seconds to receive presences of the new roster contacts
    initial = System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 5000 &&
            (!roster.getPresence(getBareJID(1)).isAvailable() ||
            !roster.getPresence(getBareJID(2)).isAvailable()))
    {
        Thread.sleep(100);
    }
    assertTrue(""Presence not received"", roster.getPresence(getBareJID(1)).isAvailable());
    assertTrue(""Presence not received"", roster.getPresence(getBareJID(2)).isAvailable());

    for (RosterEntry entry : roster.getEntries()) {
        roster.removeEntry(entry);
        Thread.sleep(250);
    }

    // Wait up to 2 seconds to receive roster removal notifications
    initial = System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000  && roster.getEntryCount() != 0) {
        Thread.sleep(100);
    }

    assertEquals(""Wrong number of entries in connection 0"", 0, roster.getEntryCount());
    assertEquals(""Wrong number of groups in connection 0"", 0, roster.getGroupCount());

    assertEquals(
        ""Wrong number of entries in connection 1"",
        0,
        getConnection(1).getRoster().getEntryCount());
    assertEquals(
        ""Wrong number of groups in connection 1"",
        0,
        getConnection(1).getRoster().getGroupCount());
}","/**
 * 1. Create entries in roster groups
 * 2. Iterate on all the entries and remove them from the roster
 * 3. Check that the number of entries and groups is zero
 */

public void testDeleteAllRosterEntries() throws Exception 
{
    // Create entries in roster groups
    createRosterEntries();

    // Iterate on all the entries and remove them from the roster
    Iterator<RosterEntry> entries = roster.getEntries();
    while (entries.hasNext()) {
        RosterEntry entry = entries.next();
        roster.removeEntry(entry);
    }

    // Check that the number of entries and groups is zero
    assertEquals(0, roster.getEntryCount());
    assertEquals(0, roster.getGroupCount());
}   ",1283,False
"/**
 * Builds and sends the <tt>auth</tt> stanza to the server.
 * This overrides from the abstract class because the initial token
 * needed for GSSAPI is binary, and not safe to put in a string, thus
 * getAuthenticationText() cannot be used.
 *
 * @param username the username of the user being authenticated.
 * @param host     the hostname where the user account resides.
 * @param cbh      the CallbackHandler (not used with GSSAPI)
 * @throws IOException If a network error occures while authenticating.
 */
public void authenticate(String username, String host, CallbackHandler cbh) throws IOException, XMPPException{
    String[] mechanisms = { getName() };
    Map props = new HashMap();
    props.put(Sasl.SERVER_AUTH,""TRUE"");
    sc = Sasl.createSaslClient(mechanisms, username, ""xmpp"", host, props, cbh);
    authenticate();
}","/**
 * Builds and sends the <tt>auth</tt> stanza to the server.
 * This overrides from the abstract class because the initial token
 * needed for GSSAPI is binary, and not safe to put in a string, thus
 * getAuthenticationText() cannot be used.
 *
 * @param username the username of the user being authenticated.
 * @param host     the hostname where the user account resides.
 * @param cbh      the CallbackHandler (not used with GSSAPI)
 * @throws IOException If a network error occures while authenticating.
 */


public void authenticate(String username, String host, CallbackHandler cbh) throws IOException, XMPPException 
{
    String[] mechanisms = { ""GSSAPI"" };
    Map props = new HashMap();
    ScramSha1AuthenticationFactory factory = new ScramSha1AuthenticationFactory();
    saslClient = factory.getMechanism(mechanisms[0], props);
    saslClient.init(username, host, cbh);
    byte[] authBytes = saslClient.evaluateChallenge(new byte[0]);
    sendPacket(new Auth(saslClient.getName(), authBytes));
}   ",1284,False
"/**
 * User1 is connected from 2 resources. User1 adds User0 to his roster. Ensure
 * that both resources of user1 get the available presence of User0. Remove User0
 * from User1's roster and check presences again.
 */
public void testMultipleResources() throws Exception{
    // Create another connection for the same user of connection 1
    ConnectionConfiguration connectionConfiguration =
            new ConnectionConfiguration(getHost(), getPort(), getServiceName());
    XMPPConnection conn4 = new XMPPConnection(connectionConfiguration);
    conn4.connect();
    conn4.login(getUsername(1), getUsername(1), ""Home"");

    // Add a new roster entry
    Roster roster = conn4.getRoster();
    roster.createEntry(getBareJID(0), ""gato11"", null);

    // Wait up to 2 seconds
    long initial = System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (
            !roster.getPresence(getBareJID(0)).isAvailable() ||
                    !getConnection(1).getRoster().getPresence(getBareJID(0)).isAvailable())) {
        Thread.sleep(100);
    }

    // Check that a presence is returned for the new contact
    Presence presence = roster.getPresence(getBareJID(0));
    assertTrue(""Returned a null Presence for an existing user"", presence.isAvailable());

    // Check that a presence is returned for the new contact
    presence = getConnection(1).getRoster().getPresence(getBareJID(0));
    assertTrue(""Returned a null Presence for an existing user"", presence.isAvailable());

    // Delete user from roster
    roster.removeEntry(roster.getEntry(getBareJID(0)));

    // Wait up to 2 seconds
    initial = System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (
            roster.getPresence(getBareJID(0)).getType() != Presence.Type.unavailable ||
                    getConnection(1).getRoster().getPresence(getBareJID(0)).getType() !=
                            Presence.Type.unavailable)) {
        Thread.sleep(100);
    }

    // Check that no presence is returned for the removed contact
    presence = roster.getPresence(getBareJID(0));
    assertFalse(""Available presence was returned for removed contact"", presence.isAvailable());
    assertEquals(""Returned Presence for removed contact has incorrect type"",
            Presence.Type.unavailable, presence.getType());

    // Check that no presence is returned for the removed contact
    presence = getConnection(1).getRoster().getPresence(getBareJID(0));
    assertFalse(""Available presence was returned for removed contact"", presence.isAvailable());
    assertEquals(""Returned Presence for removed contact has incorrect type"",
            Presence.Type.unavailable, presence.getType());
}","/**
 * User1 is connected from 2 resources. User1 adds User0 to his roster. Ensure
 * that both resources of user1 get the available presence of User0. Remove User0
 * from User1's roster and check presences again.
 */
public void testMultipleResources() throws Exception 
{
    final String resource1 = ""resource1"";
    final String resource2 = ""resource2"";
    final String user0 = ""user0@""+domain;
    final String user1 = ""user1@""+domain;

    // Connect as user1 and add user0 to his roster
    PresenceSubscriptionMap presences1 = new PresenceSubscriptionMap(user1);
    presences1.setResource(resource1);
    presences1.setResource(resource2);
    presences1.addOutgoing(user0);

    // Connect as user0 and check presences
    PresenceSubscriptionMap presences0 = new PresenceSubscriptionMap(user0);
    presences0.setResource(resource1);
    presences0.setResource(resource2);
    presences0.addIncoming(user1);

    // Check presences
    assertEquals(""Wrong number of presences."", 2, presences0.getOutgoing().size());
    assertTrue(""User0 should be present."", presences0.getOutgoing().contains(user1));
    assertTrue(""User0 should be present."", presences1.getIncoming().contains(user0));

    // Remove user0 from user1's roster
    presences1.removeOutgoing(user0);

    // Check presences again
    assertEquals(""Wrong number of presences."", 0, presences0.getOutgoing().size());
    assertEquals(""Wrong number of presences."", 0, presences1.getIncoming().size());
}   ",1293,False
"/**
 * Returns the Action enum for a String action value.
 */
public static JingleActionEnum getAction(String inActionCode){
    for (JingleActionEnum jingleAction : JingleActionEnum.values()) {
        if (jingleAction.actionCode.equals(inActionCode)) {
            return jingleAction;
        }
    }
    return null;
}","/**
 * Returns the Action enum for a String action value.
 */
public static JingleActionEnum getAction(String inActionCode) 
{
    if (inActionCode == null)
    {
        return null;
    }
    for (JingleActionEnum action : JingleActionEnum.values())
    {
        if (action.toString().equalsIgnoreCase(inActionCode))
        {
            return action;
        }
    }
    return null;
}   ",1294,True
"/**
 * 1. Create an unfiled entry
 * 2. Change its name
 * 3. Check that the name has been modified
 * 4. Reload the whole roster
 * 5. Check that the name has been modified
 */
public void testChangeNameToUnfiledEntry(){
    try {
        // Add a new roster entry
        Roster roster = getConnection(0).getRoster();
        roster.createEntry(getBareJID(1), null, null);

        // Wait up to 2 seconds to let the server process presence subscriptions
        long initial = System.currentTimeMillis();
        while (System.currentTimeMillis() - initial < 2000 &&
                !roster.getPresence(getBareJID(1)).isAvailable())
        {
            Thread.sleep(100);
        }

        // Change the roster entry name and check if the change was made
        for (RosterEntry entry : roster.getEntries()) {
            entry.setName(""gato11"");
            assertEquals(""gato11"", entry.getName());
        }
        // Reload the roster and check the name again
        roster.reload();
        Thread.sleep(2000);
        for (RosterEntry entry : roster.getEntries()) {
            assertEquals(""gato11"", entry.getName());
        }
    }
    catch (Exception e) {
        fail(e.getMessage());
    }
    finally {
        cleanUpRoster();
    }
}","/**
 * 1. Create an unfiled entry
 * 2. Change its name
 * 3. Check that the name has been modified
 * 4. Reload the whole roster
 * 5. Check that the name has been modified
 */
public void testChangeNameToUnfiledEntry() 
{
    try
    {
        Roster roster = Roster.getDefault();
        RosterEntry entry = roster.createEntry(null);
        entry.setName(""foo"");
        assertEquals(""foo"", entry.getName());
        roster.reload();
        assertEquals(""foo"", entry.getName());
    }
    catch(Exception e)
    {
        e.printStackTrace();
        fail(e.getMessage());
    }
}   ",1296,False
"/**
 * Test if renaming a roster group works fine.
 *
 */
public void testRenameRosterGroup(){
    try {
        Thread.sleep(200);

        // Add a new roster entry
        Roster roster = getConnection(0).getRoster();
        roster.createEntry(getBareJID(1), ""gato11"", new String[] { ""Friends"" });
        roster.createEntry(getBareJID(2), ""gato12"", new String[] { ""Friends"" });

        // Wait up to 2 seconds to let the server process presence subscriptions
        long initial = System.currentTimeMillis();
        while (System.currentTimeMillis() - initial < 2000 && (
                !roster.getPresence(getBareJID(1)).isAvailable() ||
                        !roster.getPresence(getBareJID(2)).isAvailable())) {
            Thread.sleep(100);
        }

        roster.getGroup(""Friends"").setName(""Amigos"");

        // Wait up to 2 seconds
        initial = System.currentTimeMillis();
        while (System.currentTimeMillis() - initial < 2000 &&
                (roster.getGroup(""Friends"") != null)) {
            Thread.sleep(100);
        }

        assertNull(""The group Friends still exists"", roster.getGroup(""Friends""));
        assertNotNull(""The group Amigos does not exist"", roster.getGroup(""Amigos""));
        assertEquals(
            ""Wrong number of entries in the group Amigos"",
            2,
            roster.getGroup(""Amigos"").getEntryCount());

        // Setting the name to empty is like removing this group
        roster.getGroup(""Amigos"").setName("""");

        // Wait up to 2 seconds for the group to change its name
        initial = System.currentTimeMillis();
        while (System.currentTimeMillis() - initial < 2000 &&
                (roster.getGroup(""Amigos"") != null)) {
            Thread.sleep(100);
        }

        assertNull(""The group Amigos still exists"", roster.getGroup(""Amigos""));
        assertNotNull(""The group with no name does not exist"", roster.getGroup(""""));
        assertEquals(
            ""Wrong number of entries in the group with no name"",
            2,
            roster.getGroup("""").getEntryCount());

        /*assertEquals(""There are still groups in the roster"", 0, roster.getGroupCount());
        assertEquals(
            ""Wrong number of entries in the group \""\"" "",
            2,
            roster.getUnfiledEntryCount());*/


        Thread.sleep(200);
    }
    catch (Exception e) {
        fail(e.getMessage());
    }
    finally {
        cleanUpRoster();    
    }
}","/**
 * Test if renaming a roster group works fine.
 *
 */


public void testRenameRosterGroup() 
{
    try
    {
        Roster roster = RosterManager.getInstanceFor( con ).getRoster( ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"" );
        roster.renameRosterGroup( ""testRenameRosterGroup"", ""testRenameRosterGroup2"" );
    }
    catch ( Exception e )
    {
        e.printStackTrace();
        fail( e.getMessage() );
    }
}   ",1299,False
"// Virtual Keyboard input
public void onKey(int primaryCode, int[] keyCodes){
	if (primaryCode == KBManager.KEYCODE_NEXT_IME)
	{
		_currentMode = InputMode.MODE_IME;
		requestNextInputMethod();
	}
	else if (primaryCode == KBManager.KEYCODE_DO_OUTPUT_CHARS)
		return; // Let IME onText listener handle it.
	else if (_currentMode != InputMode.MODE_IME || (_currentMethod != null && !_currentMethod.wantHandleEvent(primaryCode)))
	{
		// If the IME does not want the event, we assume it's an plain-English keyboard.
		switch(primaryCode) {
		case Keyboard.KEYCODE_SHIFT: // Shift Key
			if (_currentMode == InputMode.MODE_IME)
				_currentMethod.commitCurrentComposingBuffer();

			Boolean isShifted = !_kbm.getCurrentKeyboard().isShifted();
			_kbm.getCurrentKeyboard().setShifted(isShifted);
			KeyboardView kv = _kbm.getCurrentKeyboardView();
			kv.setShifted(isShifted);
			
			// Dirty Hack :( Force KeyboardView wipe out its buffer...
			kv.onSizeChanged(kv.getWidth(), kv.getHeight(), 0, 0);
			break;
		case KBManager.KEYCODE_SYM: // 123 Keyboard
			if (_currentMode == InputMode.MODE_IME)
				_currentMethod.commitCurrentComposingBuffer();

			_currentMode = InputMode.MODE_SYM;
			_kbm.setNativeKeyboard(NativeKeyboardTypes.MODE_SYM);
			postShowPopup(""123"");
			hideCandidatesView();
			
			break;
		case KBManager.KEYCODE_SYM_ALT: // 123 Keyboard
			if (_currentMode == InputMode.MODE_IME)
				_currentMethod.commitCurrentComposingBuffer();

			_currentMode = InputMode.MODE_SYM_ALT;
			_kbm.setNativeKeyboard(NativeKeyboardTypes.MODE_SYM_ALT);
			postShowPopup(""#+="");
			hideCandidatesView();
			break;
		case KBManager.KEYCODE_ABC: // ABC Keyboard
			if (_currentMode == InputMode.MODE_IME)
				_currentMethod.commitCurrentComposingBuffer();

			_currentMode = InputMode.MODE_ABC;
			_kbm.setNativeKeyboard(NativeKeyboardTypes.MODE_ABC);
			postShowPopup(""ABC"");
			hideCandidatesView();
			break;
		case KBManager.KEYCODE_IME: // IME Keyboard
			_currentMode = InputMode.MODE_IME;
			//showCandidatesView();
			if (_currentMethod == null)
				requestNextInputMethod();
			_currentMethod.onEnterInputMethod();
			_kbm.setNativeKeyboard(NativeKeyboardTypes.MODE_IME);
			postShowPopup(_currentMethod.getName());
			break;
		case KBManager.KEYCODE_IME_MENU:
			String[] imeNames = new String [_methods.size()];
			int i=0;
			for(IKerKerInputMethod method : _methods)
				imeNames[i++] = method.getName();
			final PopupWindow win = new PopupWindow(_frontEnd);
			win.setBackgroundDrawable(new ColorDrawable(Color.argb(220, 0, 0, 0)));
			win.setWindowLayoutMode(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
			win.setContentView(getInflater().inflate(R.layout.method_chooser, null));
	        final ListView lstIME = (ListView) win.getContentView().findViewById(R.id.lstIME);
	        lstIME.setAdapter(new ArrayAdapter<String>(_frontEnd, android.R.layout.simple_list_item_1, imeNames));
	        win.setWidth(320);
	        win.setHeight(_kbm.getCurrentKeyboardView().getHeight());
	        win.setOutsideTouchable(false);
	        win.setTouchable(true);
	        win.setTouchInterceptor(new OnTouchListener() {
	        	private boolean detectedMove = false;
	        	private float lastX, lastY;
	        	
				public boolean onTouch(View v, MotionEvent event) {
					if (event.getAction() == MotionEvent.ACTION_UP)
					{
						if (detectedMove)
						{
							detectedMove = false;
							return false;
						}
						
						event.offsetLocation(-lstIME.getLeft(), -lstIME.getTop());
						Log.i(""PopupWindow"", ""IME selected!"");
						int pos = lstIME.pointToPosition((int)event.getX(), (int)event.getY());
						if (pos > ListView.INVALID_POSITION)
						{
							_currentMode = InputMode.MODE_IME;
							setCurrentInputMethod(_methods.get(pos));
							win.dismiss();
						}
					}
					else if (event.getAction() == MotionEvent.ACTION_MOVE && Math.abs(lastX - event.getX()) > 5 && Math.abs(lastY - event.getY()) > 5)
						detectedMove = true;
					else if (event.getAction() == MotionEvent.ACTION_DOWN)
					{
						lastX = event.getX();
						lastY = event.getY();
					}
					return false;
				}
			});
			win.showAtLocation(_kbm.getCurrentKeyboardView(), Gravity.BOTTOM, 0, 0);
			lstIME.requestFocusFromTouch();
			break;
		case Keyboard.KEYCODE_DELETE:
			getFrontend().sendDownUpKeyEvents(KeyEvent.KEYCODE_DEL);
			for(IKerKerInputFilter f : _filters)
				f.onDelete();
			break;
		default:
			if (getKeyboardManager().getCurrentKeyboard().isShifted())
				sendKeyChar(Character.toUpperCase((char) primaryCode));
			else
				sendKeyChar((char) primaryCode);
			break;
		}
	}
	else
		if (_currentMethod != null) _currentMethod.onKeyEvent(primaryCode, keyCodes);
	
	// User feedbacks
	if (shouldMakeNoise)
	{
		switch(primaryCode)
		{
		case '\n':
			playAudioResource(R.raw.returndown);
			playAudioResource(R.raw.returnup);
			break;
		case ' ':
			playAudioResource(R.raw.spacedown);
			playAudioResource(R.raw.spaceup);
			break;
		default:
			playAudioResource(R.raw.keydown);
			playAudioResource(R.raw.keyup);
		}
	}
	
	if (shouldVibrate)
		((Vibrator)getFrontend().getSystemService(Context.VIBRATOR_SERVICE)).vibrate(50);
}","// Virtual Keyboard input
public void onKey(int primaryCode, int[] keyCodes) 
{
    switch (primaryCode) {
        case Keyboard.KEY_A:
            // Do something for A key
            break;
        case Keyboard.KEY_B:
            // Do something for B key
            break;
        default:
            break;
    }
}   ",1300,False
"/**
 * Handling when input method lost focus
 */
public void onLostFocus(){
	_core.clearCandidates();
	_core.hideCandidatesView();
}","/**
 * Handling when input method lost focus
 */
public void onLostFocus() 
{
    if (mListener != null)
    {
        mListener.onLostFocus();
    }
}   ",1301,False
"/**
 * Create SoundPool if activate this function, or release all sound resources
 * 
 * @param shouldMakeNoise
 */
public void setShouldMakeNoise(Boolean shouldMakeNoise){
	this.shouldMakeNoise = shouldMakeNoise;
	
	if (shouldMakeNoise)
	{
		sndPool = new SoundPool(6, AudioManager.STREAM_RING, 0);
		sndPoolMap = null;
	}
	else
	{
		if (sndPool != null)
			sndPool.release();
		sndPool = null;
		
		sndPoolMap = null;
	}
}","/**
 * Create SoundPool if activate this function, or release all sound resources
 * 
 * @param shouldMakeNoise
 */
public void setShouldMakeNoise(Boolean shouldMakeNoise) 
{
    if (shouldMakeNoise)
    {
        if (soundPool == null)
        {
            createSoundPool();
        }
    }
    else
    {
        releaseSoundPool();
    }
}   ",1302,True
"/**
 * 
 * @see EditorInfo#imeOptions
 * @param inputType
 */
public void setImeOptions(int inputType){
	imeOptions = inputType;
	applyIMEOptions();
}","/**
 * 
 * @see EditorInfo#imeOptions
 * @param inputType
 */

public void setImeOptions(int inputType) 
{
    if (inputType != (this.mInputType & ~EditorInfo.TYPE_MASK_FLAGS))
    {
        this.mInputType = (this.mInputType & EditorInfo.TYPE_MASK_FLAGS) | inputType;
        EditorInfo editorInfo = this.mEditorInfo;
        if (editorInfo != null)
        {
            editorInfo.inputType = this.mInputType;
        }
    }
}   ",1303,True
"/**
 * Fix the different keyChar between different brands by the keyCode defined in KBManager.
 * 
 * @param e KeyEvent
 * @return the unicode character from KeyEvent e would produce
 */
private int generateVKBCode(KeyEvent e){
	if (e.getKeyCode() == KeyEvent.KEYCODE_DEL)
		return -5;
	else if (e.getKeyCode() == KeyEvent.KEYCODE_DPAD_UP)
		return KBManager.KEYCODE_DPAD_UP;
	else if (e.getKeyCode() == KeyEvent.KEYCODE_DPAD_DOWN)
		return KBManager.KEYCODE_DPAD_DOWN;
	else if (e.getKeyCode() == KeyEvent.KEYCODE_DPAD_LEFT)
		return KBManager.KEYCODE_DPAD_LEFT;
	else if (e.getKeyCode() == KeyEvent.KEYCODE_DPAD_RIGHT)
		return KBManager.KEYCODE_DPAD_RIGHT;
	
	return e.getUnicodeChar();
}","/**
 * Fix the different keyChar between different brands by the keyCode defined in KBManager.
 * 
 * @param e KeyEvent
 * @return the unicode character from KeyEvent e would produce
 */
private int generateVKBCode(KeyEvent e) 
{
    int keyCode = e.getKeyCode();
    int unicode = e.getKeyChar();
    int scanCode = e.getScanCode();

    if (unicode == 0)
    {
        unicode = KBManager.getUnicode(keyCode);
    }

    if (unicode == 0)
    {
        unicode = KBManager.getUnicodeFromScanCode(scanCode);
    }

    return unicode;
}   ",1306,False
"/**
 * This method will change current input method to what you give.
 * And it will initialize all thing about input method.
 * 
 * @param method the method which you want to set up
 */
public void setCurrentInputMethod(IKerKerInputMethod method){
	if (_currentMethod != null)
		_currentMethod.onLeaveInputMethod();
	
	Log.i(""KerKerInputCore"", ""setCurrentInputMethod = "" + method);
	_currentMethod = method;
	_currentMethod.initInputMethod(this);
	if (!_currentMethod.hasCustomInputView())
		getFrontend().restoreKerKerKeyboardView();
	else
		getFrontend().setInputView(_currentMethod.onCreateInputView());
	_currentMethod.onEnterInputMethod();
	_kbm.setCurrentKeyboard(_currentMethod.getDesiredKeyboard());
	postShowPopup(_currentMethod.getName());
}","/**
 * This method will change current input method to what you give.
 * And it will initialize all thing about input method.
 * 
 * @param method the method which you want to set up
 */
public void setCurrentInputMethod(IKerKerInputMethod method) 
{
    if (method == null)
    {
        return;
    }

    if (currentInputMethod != null)
    {
        currentInputMethod.destroy();
    }

    currentInputMethod = method;
    currentInputMethod.initialize();
}   ",1307,True
"/* IME entry point and some metadata accessors */
public CINBasedInput(String imeIdentifier, String dbPath){
	_strIMEIdentifier = imeIdentifier;
	if (dbPath != null)
		_dbPath = dbPath;
}","/* IME entry point and some metadata accessors */
public CINBasedInput(String imeIdentifier, String dbPath) 
{
    this.imeIdentifier = imeIdentifier;
    this.dbPath = dbPath;
    this.db = new CINDatabase(dbPath);
    this.ime = new CINIME(imeIdentifier, db);
}   ",1308,True
"/**
 * Play Audio by the ID of resource. Initialize Audio resource if it didn't exist.
 * 
 * @param resourceID the audio resource id to play
 */
private void playAudioResource(final int resourceID){
	if (sndPool == null || sndPoolMap == null)
		initSounds();
	
	int volume = ((AudioManager)getFrontend().getSystemService(Context.AUDIO_SERVICE)).getStreamVolume(AudioManager.STREAM_RING);
	Integer rid = sndPoolMap.get(resourceID);
	if (rid != null)
		sndPool.play(rid, volume, volume, 1, 0, 1f);
}","/**
 * Play Audio by the ID of resource. Initialize Audio resource if it didn't exist.
 * 
 * @param resourceID the audio resource id to play
 */
private void playAudioResource(final int resourceID) 
{
    if (this.audioResource == null)
    {
        this.audioResource = new AudioResource(resourceID);
    }

    this.audioResource.play();
}   ",1309,False
"/**
 * set current KeyboardView to a new one
 * 
 * @param kv the KeyboardView to set
 */
public void setKeyboardView(KeyboardView kv){
	Log.i(""KBManager"", ""setKeyboardView = "" + kv);
	_currentKBView = kv;
	return;
}","/**
 * set current KeyboardView to a new one
 * 
 * @param kv the KeyboardView to set
 */
public void setKeyboardView(KeyboardView kv) 
{
    if (mKeyboardView != null)
    {
        mKeyboardView.setOnKeyboardActionListener(null);
        mKeyboardView.setOnTouchListener(null);
    }
    mKeyboardView = kv;
    if (mKeyboardView != null)
    {
        mKeyboardView.setOnKeyboardActionListener(this);
        mKeyboardView.setOnTouchListener(this);
    }
}   ",1310,True
"/**
 * @see PopupWindow#dismiss() 
 */
private void hidePopup(){
	try
	{
		_winMsg.dismiss();
	}
	catch(Exception e)
	{}
}","/**
 * @see PopupWindow#dismiss() 
 */
private void hidePopup() 
{
    if (mPopupWindow != null && mPopupWindow.isShowing())
    {
        mPopupWindow.dismiss();
    }
}   ",1312,False
"/**
 * Re-create popup window if _winMsg is null. Then,
 * change its contents to the message to notify users,
 * and hide it after one second.
 *
 * @param msg the string to display
 */
public void showPopup(final CharSequence msg){
	if (!_frontEnd.isInputViewShown() && !_candidatesShown)
		return;
	
	if (_winMsg == null)
	{
		Log.i(""KerKerInputCore"", ""Re-create popup window"");
		_winMsg = new PopupWindow(_frontEnd);
		_winMsg.setWindowLayoutMode(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
		_winMsg.setBackgroundDrawable(null);
		_txtvMsg = (TextView) getInflater().inflate(R.layout.candidates_preview, null);
		_winMsg.setContentView(_txtvMsg);
	}

	try
	{
		View baseView = (_frontEnd.isInputViewShown() ? _kbm.getCurrentKeyboardView() : _candidatesContainer);
		
    	_txtvMsg.setText(msg);
    	_txtvMsg.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
    	int wordWidth = (int)(_pntText.measureText(msg.toString()));
    	int popupWidth = wordWidth + _txtvMsg.getPaddingLeft() + _txtvMsg.getPaddingRight();
    	int popupHeight = _txtvMsg.getMeasuredHeight();
    	int popupX = (baseView.getWidth() - popupWidth) / 2;
    	int popupY = -popupHeight;
    	
    	int[] offset = new int[2];
    	baseView.getLocationInWindow(offset);
    	popupY += offset[1];
    	
    	if (_winMsg.isShowing())
    		_winMsg.update(popupX, popupY, popupWidth, popupHeight);
    	else
    	{
    		_winMsg.setWidth(popupWidth);
    		_winMsg.setHeight(popupHeight);
    		_winMsg.showAtLocation(baseView, Gravity.NO_GRAVITY, popupX, popupY);
    	}
    	_txtvMsg.setVisibility(View.VISIBLE);
    	
    	_handler.postDelayed(new Runnable() {
			public void run() {
				try {
					if (_txtvMsg.getText() == msg.toString())
						hidePopup();						
				}
				catch(Exception ex)
				{
					
				}
			}
    	}, 1000);
	}
	catch(Exception e)
	{
		e.printStackTrace();
		Log.e(""KerKerInputCore"", ""Show popup failed, force reset popup window."");
		_winMsg = null;
		_txtvMsg = null;
	}
    }","/**
 * Re-create popup window if _winMsg is null. Then,
 * change its contents to the message to notify users,
 * and hide it after one second.
 *
 * @param msg the string to display
 */





public void showPopup(final CharSequence msg) 
{
    if (_winMsg == null)
    {
        _winMsg = new PopupWindow(_activity);
        _winMsg.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
        _winMsg.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
        _winMsg.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
        _winMsg.setTouchable(true);
        _winMsg.setFocusable(true);
        _winMsg.setOutsideTouchable(true);
        _winMsg.setContentView(_viewMsg);
    }

    _tvMsg.setText(msg);
    _winMsg.showAtLocation(_viewMsg, Gravity.CENTER, 0, 0);

    new Handler().postDelayed(new Runnable()
    {
        @Override
        public void run()
        {
            _winMsg.dismiss();
        }
    }, 1000);
}   ",1313,False
"/**
 * Change current input method to next one.
 * If there are no input method loaded, it will change to first one.
 */
public void requestNextInputMethod(){
	if (_currentMethod == null)
	{
		setCurrentInputMethod(_methods.get(0));
	}
	else
	{
		int curIndex = _methods.indexOf(_currentMethod);
		
		while(true)
		{	
			if (_methods.size() <= curIndex + 1)
				curIndex = 0;
			else
				curIndex++;
			
			if (_methods.get(curIndex).shouldAvailableForSwitchingButton())
			{
				setCurrentInputMethod(_methods.get(curIndex));
				break;
			}
		}
	}
}","/**
 * Change current input method to next one.
 * If there are no input method loaded, it will change to first one.
 */




public void requestNextInputMethod() 
{
    InputMethodManager imm = (InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
    if (imm != null)
    {
        List<InputMethodInfo> enabledInputMethodList = imm.getEnabledInputMethodList();
        int enabledCount = enabledInputMethodList.size();
        if (enabledCount > 0)
        {
            String currentId = imm.getInputMethodId();
            for (int i = 0; i < enabledCount; ++i)
            {
                InputMethodInfo info = enabledInputMethodList.get(i);
                if (info.getId().equals(currentId))
                {
                    if (i == enabledCount - 1)
                    {
                        imm.setInputMethod(null, null);
                    }
                    else
                    {
                        imm.setInputMethod(null, enabledInputMethodList.get(i + 1).getId());
                    }
                    break;
                }
            }
        }
    }
}   ",1314,True
"/**
 * Hide & Clear CandidatesView
 */
public void hideCandidatesView(){
	if (_currentMode != InputMode.MODE_IME)
	{
		_frontEnd.setCandidatesViewShown(false);
		_candidatesShown = false;
	}
	
	if (_candidatesContainer != null)
		clearCandidates();
}","/**
 * Hide & Clear CandidatesView
 */
public void hideCandidatesView() 
{
    if (candidatesView != null)
    {
        candidatesView.setVisibility(View.GONE);
    }
}   ",1315,False
"/**
 *  current KeyboardView and reset a new one. 
 */
public void resetKeyboard(){
	_currentKB = null;
	getCurrentKeyboard();
}","/**
 *  current KeyboardView and reset a new one. 
 */
public void resetKeyboard() 
{
    if (null != mKeyboard)
    {
        mKeyboard.reset();
    }
    mKeyboard = new Keyboard(this, R.xml.keyboard);
}   ",1318,True
"/**
 * Shows a short-time popup window to notify users the name of IME
 * @see #showPopup
 * @param imeName the name of IME
 */
public void postShowPopup(final String imeName){
	_handler.postDelayed(new Runnable(){
		public void run() {
			try{
				showPopup(imeName);
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}, 1000);
}","/**
 * Shows a short-time popup window to notify users the name of IME
 * @see #showPopup
 * @param imeName the name of IME
 */
public void postShowPopup(final String imeName) 
{
    mHandler.post(new Runnable()
    {
        @Override
        public void run()
        {
            showPopup(imeName);
        }
    });
}   ",1319,True
"/**
 * Put a key/int pair in the JSONObject.
 *
 * @param key   A key string.
 * @param value An int which is the value.
 * @return this.
 * @throws JSONException If the key is null.
 */
public JSONObject put(String key, int value) throws JSONException{
    put(key, new Integer(value));
    return this;
}","/**
 * Put a key/int pair in the JSONObject.
 *
 * @param key   A key string.
 * @param value An int which is the value.
 * @return this.
 * @throws JSONException If the key is null.
 */
public JSONObject put(String key, int value) throws JSONException 
{
    put(key, new Integer(value));
    return this;
}   ",1321,True
"/**
 * Put a key/value pair in the JSONObject. If the value is null,
 * then the key will be removed from the JSONObject if it is present.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is non-finite number
 *  or if the key is null.
 */
public JSONObject put(String key, Object value) throws JSONException{
    if (key == null) {
        throw new JSONException(""Null key."");
    }
    if (value != null) {
        testValidity(value);
        this.myHashMap.put(key, value);
    } else {
        remove(key);
    }
    return this;
}","/**
 * Put a key/value pair in the JSONObject. If the value is null,
 * then the key will be removed from the JSONObject if it is present.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is non-finite number
 *  or if the key is null.
 */

public JSONObject put(String key, Object value) throws JSONException 
{
    if (key == null)
    {
        throw new JSONException(""Null key."");
    }
    if (value != null)
    {
        testValidity(value);
        this.map.put(key, value);
    }
    else
    {
        this.remove(key);
    }
    return this;
}   ",1322,True
"/**
 * Put a key/value pair in the JSONObject, where the value will be a
 * JSONObject which is produced from a Map.
 * @param key 	A key string.
 * @param value	A Map value.
 * @return		this.
 * @throws JSONException
 */
public JSONObject put(String key, Hashtable value) throws JSONException{
    put(key, new JSONObject(value));
    return this;
}","/**
 * Put a key/value pair in the JSONObject, where the value will be a
 * JSONObject which is produced from a Map.
 * @param key 	A key string.
 * @param value	A Map value.
 * @return		this.
 * @throws JSONException
 */

public JSONObject put(String key, Hashtable value) throws JSONException 
{
    JSONObject o = new JSONObject();
    Iterator keys = value.keys();
    while (keys.hasNext())
    {
        String k = (String) keys.next();
        o.put(k, value.get(k));
    }
    return this.put(key, o);
}   ",1323,False
"/**
 * Append values to the array under a key. If the key does not exist in the
 * JSONObject, then the key is put in the JSONObject with its value being a
 * JSONArray containing the value parameter. If the key was already
 * associated with a JSONArray, then the value parameter is appended to it.
 * @param key   A key string.
 * @param value An object to be accumulated under the key.
 * @return this.
 * @throws JSONException If the key is null or if the current value 
 * 	associated with the key is not a JSONArray.
 */
public JSONObject append(String key, Object value)
        throws JSONException{
    testValidity(value);
    Object o = opt(key);
    if (o == null) {
        put(key, new JSONArray().put(value));
    } else if (o instanceof JSONArray) {
        throw new JSONException(""JSONObject["" + key + 
        		""] is not a JSONArray."");
    } else {
        put(key, new JSONArray().put(o).put(value));
    }
    return this;
}","/**
 * Append values to the array under a key. If the key does not exist in the
 * JSONObject, then the key is put in the JSONObject with its value being a
 * JSONArray containing the value parameter. If the key was already
 * associated with a JSONArray, then the value parameter is appended to it.
 * @param key   A key string.
 * @param value An object to be accumulated under the key.
 * @return this.
 * @throws JSONException If the key is null or if the current value 
 * 	associated with the key is not a JSONArray.
 */

public JSONObject append(String key, Object value)
        throws JSONException 
{
    Object o = get(key);
    if (JSONObject.NULL == o)
    {
        put(key, new JSONArray().put(value));
    }
    else if (o instanceof JSONArray)
    {
        put(key, ((JSONArray) o).put(value));
    }
    else
    {
        throw new JSONException(""JSONObject["" + key +
                ""] is not a JSONArray."");
    }
    return this;
}       ",1325,True
"/**
 * Get the boolean value associated with a key.
 *
 * @param key   A key string.
 * @return      The truth.
 * @throws   JSONException
 *  if the value is not a Boolean or the String ""true"" or ""false"".
 */
public boolean getBoolean(String key) throws JSONException{
    Object o = get(key);
    if (o.equals(Boolean.FALSE) ||
            (o instanceof String &&
            ((String)o).equalsIgnoreCase(""false""))) {
        return false;
    } else if (o.equals(Boolean.TRUE) ||
            (o instanceof String &&
            ((String)o).equalsIgnoreCase(""true""))) {
        return true;
    }
    throw new JSONException(""JSONObject["" + quote(key) +
            ""] is not a Boolean."");
}","/**
 * Get the boolean value associated with a key.
 *
 * @param key   A key string.
 * @return      The truth.
 * @throws   JSONException
 *  if the value is not a Boolean or the String ""true"" or ""false"".
 */

public boolean getBoolean(String key) throws JSONException 
{
    Object object = get(key);
    if (object.equals(Boolean.FALSE) ||
        (object instanceof String &&
         ((String)object).equalsIgnoreCase(""false"")))
    {
        return false;
    }
    else if (object.equals(Boolean.TRUE) ||
             (object instanceof String &&
              ((String)object).equalsIgnoreCase(""true"")))
    {
        return true;
    }
    throw new JSONException(""JSONObject["" + quote(key) + ""] is not a Boolean."");
}   ",1327,True
"/**
 * Get the JSONObject value associated with a key.
 *
 * @param key   A key string.
 * @return      A JSONObject which is the value.
 * @throws   JSONException if the key is not found or
 *  if the value is not a JSONObject.
 */
public JSONObject getJSONObject(String key) throws JSONException{
    Object o = get(key);
    if (o instanceof JSONObject) {
        return (JSONObject)o;
    }
    throw new JSONException(""JSONObject["" + quote(key) +
            ""] is not a JSONObject."");
}","/**
 * Get the JSONObject value associated with a key.
 *
 * @param key   A key string.
 * @return      A JSONObject which is the value.
 * @throws   JSONException if the key is not found or
 *  if the value is not a JSONObject.
 */

public JSONObject getJSONObject(String key) throws JSONException 
{
    Object object = this.get(key);
    if (object instanceof JSONObject) {
        return (JSONObject)object;
    }
    throw new JSONException(""JSONObject["" + key + ""] is not a JSONObject."");
}   ",1330,True
"/**
 * Produce a JSONArray containing the values of the members of this
 * JSONObject.
 * @param names A JSONArray containing a list of key strings. This
 * determines the sequence of the values in the result.
 * @return A JSONArray of values.
 * @throws JSONException If any of the values are non-finite numbers.
 */
public JSONArray toJSONArray(JSONArray names) throws JSONException{
    if (names == null || names.length() == 0) {
        return null;
    }
    JSONArray ja = new JSONArray();
    for (int i = 0; i < names.length(); i += 1) {
        ja.put(this.opt(names.getString(i)));
    }
    return ja;
}","/**
 * Produce a JSONArray containing the values of the members of this
 * JSONObject.
 * @param names A JSONArray containing a list of key strings. This
 * determines the sequence of the values in the result.
 * @return A JSONArray of values.
 * @throws JSONException If any of the values are non-finite numbers.
 */

public JSONArray toJSONArray(JSONArray names) throws JSONException 
{
    JSONArray ja = new JSONArray();
    if (names == null)
    {
        for (Entry<String, Object> entry : this.map.entrySet())
        {
            ja.put(entry.getValue());
        }
    }
    else
    {
        for (int i = 0; i < names.length(); i += 1)
        {
            ja.put(this.map.get(names.getString(i)));
        }
    }
    return ja;
}   ",1333,True
"/**
 * Put a key/long pair in the JSONObject.
 *
 * @param key   A key string.
 * @param value A long which is the value.
 * @return this.
 * @throws JSONException If the key is null.
 */
public JSONObject put(String key, long value) throws JSONException{
    put(key, new Long(value));
    return this;
}","/**
 * Put a key/long pair in the JSONObject.
 *
 * @param key   A key string.
 * @param value A long which is the value.
 * @return this.
 * @throws JSONException If the key is null.
 */
public JSONObject put(String key, long value) throws JSONException 
{
    if (key == null)
    {
        throw new JSONException(""Null key."");
    }
    put(key, new Long(value));
    return this;
}   ",1335,True
"/**
 * Get the double value associated with a key.
 * @param key   A key string.
 * @return      The numeric value.
 * @throws JSONException if the key is not found or
 *  if the value is not a Number object and cannot be converted to a number.
 */
public double getDouble(String key) throws JSONException{
    Object o = get(key);
    if (o instanceof Byte) {
        return (double) ((Byte)o).byteValue();
    } else if (o instanceof Short) {
        return (double) ((Short)o).shortValue();
    } else if (o instanceof Integer) {
        return (double) ((Integer)o).intValue();
    } else if (o instanceof Long) {
        return (double) ((Long)o).longValue();
    } else if (o instanceof Float) {
        return (double) ((Float)o).floatValue();
    } else if (o instanceof Double) {
        return ((Double)o).doubleValue();
    } else if (o instanceof String) {
        try {
            return Double.valueOf((String)o).doubleValue();
        } catch (Exception e) {
            throw new JSONException(""JSONObject["" + quote(key) +
                ""] is not a number."");
        }
    } 
    throw new JSONException(""JSONObject["" + quote(key) +
        ""] is not a number."");
}","/**
 * Get the double value associated with a key.
 * @param key   A key string.
 * @return      The numeric value.
 * @throws JSONException if the key is not found or
 *  if the value is not a Number object and cannot be converted to a number.
 */

public double getDouble(String key) throws JSONException 
{
    Object object = get(key);
    try
    {
        return object instanceof Number ?
                ((Number)object).doubleValue() :
                Double.parseDouble(object.toString());
    }
    catch (Exception e)
    {
        throw new JSONException(""JSONObject["" + quote(key) +
                ""] is not a number."");
    }
}   ",1336,True
"/**
 * Produce a string in double quotes with backslash sequences in all the
 * right places. A backslash will be inserted within </, allowing JSON
 * text to be delivered in HTML. In JSON text, a string cannot contain a
 * control character or an unescaped quote or backslash.
 * @param string A String
 * @return  A String correctly formatted for insertion in a JSON text.
 */
public static String quote(String string){
    if (string == null || string.length() == 0) {
        return ""\""\"""";
    }

    char         b;
    char         c = 0;
    int          i;
    int          len = string.length();
    StringBuffer sb = new StringBuffer(len + 4);
    String       t;

    sb.append('""');
    for (i = 0; i < len; i += 1) {
        b = c;
        c = string.charAt(i);
        switch (c) {
        case '\\':
        case '""':
            sb.append('\\');
            sb.append(c);
            break;
        case '/':
            if (b == '<') {
                sb.append('\\');
            }
            sb.append(c);
            break;
        case '\b':
            sb.append(""\\b"");
            break;
        case '\t':
            sb.append(""\\t"");
            break;
        case '\n':
            sb.append(""\\n"");
            break;
        case '\f':
            sb.append(""\\f"");
            break;
        case '\r':
            sb.append(""\\r"");
            break;
        default:
            if (c < ' ') {
                t = ""000"" + Integer.toHexString(c);
                sb.append(""\\u"" + t.substring(t.length() - 4));
            } else {
                sb.append(c);
            }
        }
    }
    sb.append('""');
    return sb.toString();
}","/**
 * Produce a string in double quotes with backslash sequences in all the
 * right places. A backslash will be inserted within </, allowing JSON
 * text to be delivered in HTML. In JSON text, a string cannot contain a
 * control character or an unescaped quote or backslash.
 * @param string A String
 * @return  A String correctly formatted for insertion in a JSON text.
 */
public static String quote(String string) 
{
    if (string == null || string.length() == 0) {
        return ""\""\"""";
    }

    char         b;
    char         c = 0;
    int          i;
    int          len = string.length();
    StringBuilder sb = new StringBuilder(len + 4);
    String       t;

    sb.append('""');
    for (i = 0; i < len; i += 1) {
        b = c;
        c = string.charAt(i);
        switch (c) {
        case '\\':
        case '""':
            sb.append('\\');
            sb.append(c);
            break;
        case '/':
            if (b == '<') {
                sb.append('\\');
            }
            sb.append(c);
            break;
        default:
            sb.append(c);
        }
    }
    sb.append('""');
    return sb.toString();
}   ",1338,False
"/**
 * Construct a JSONObject from a Map.
 * @param map A map object that can be used to initialize the contents of
 *  the JSONObject.
 */
public JSONObject(Hashtable map){
    if (map == null) {
        this.myHashMap = new Hashtable();
    } else {
        this.myHashMap = new Hashtable(map.size());
        Enumeration keys = map.keys();
        while (keys.hasMoreElements()) {
            Object key = keys.nextElement();
            this.myHashMap.put(key, map.get(key));
        }
    }
}","/**
 * Construct a JSONObject from a Map.
 * @param map A map object that can be used to initialize the contents of
 *  the JSONObject.
 */
public JSONObject(Hashtable map) 
{
    if (map == null)
    {
        throw new NullPointerException();
    }
    this.map = new HashMap(map);
}   ",1339,False
"/**
 * Constructor.
 * 
 * @param constants the constants
 */
public CwFlowPanel(CwConstants constants){
  super(constants);
  this.constants = constants;
}","/**
 * Constructor.
 * 
 * @param constants the constants
 */
public CwFlowPanel(CwConstants constants) 
{
    super(new BorderLayout());
    this.constants = constants;
    init();
}   ",1340,True
"/**
 * Add a tab to this example to show the messages interface.
 */
private void addConstantsTab(){
  // Add a tab to show the interface
  javaWidget = new HTML();
  add(javaWidget, ""ExampleConstants.java"");

  // Add a tab to show the properties
  propertiesWidget = new HTML();
  add(propertiesWidget, ""ExampleConstants.properties"");
}","/**
 * Add a tab to this example to show the messages interface.
 */
private void addConstantsTab() 
{
    final Tab tab = new Tab(""Constants"");
    tab.setClosable(false);
    tab.setContent(new ConstantsInterface());
    tabPane.getTabs().add(tab);
}   ",1341,True
"/**
 * Initialize this example.
 */
@ShowcaseSource
@Override
public Widget onInitialize(){
  // Create a vertical panel to align the check boxes
  VerticalPanel vPanel = new VerticalPanel();
  HTML label = new HTML(constants.cwCheckBoxCheckAll());
  label.ensureDebugId(""cwCheckBox-label"");
  vPanel.add(label);

  // Add a checkbox for each day of the week
  String[] daysOfWeek = constants.cwCheckBoxDays();
  for (int i = 0; i < daysOfWeek.length; i++) {
    String day = daysOfWeek[i];
    CheckBox checkBox = new CheckBox(day);
    checkBox.ensureDebugId(""cwCheckBox-"" + day);

    // Disable the weekends
    if (i >= 5) {
      checkBox.setEnabled(false);
    }

    vPanel.add(checkBox);
  }

  // Return the panel of checkboxes
  return vPanel;
}","/**
 * Initialize this example.
 */

@ShowcaseSource
@Override
public Widget onInitialize() 
{
    // Create a new panel with a caption.
    Panel panel = new Panel(""This is a Panel"");
    panel.setSize(""300px"", ""300px"");

    // Add the panel to the root panel.
    rootPanel.add(panel);

    // Return the root panel.
    return rootPanel;
}   ",1342,False
"/**
 * Show an error message. Pass in null to clear the error message.
 * 
 * @param errorMsg the error message
 */
@ShowcaseSource
private void showErrorMessage(String errorMsg){
  if (errorMsg == null) {
    formattedBox.removeStyleName(""cw-RedText"");
  } else {
    formattedBox.setText(errorMsg);
    formattedBox.addStyleName(""cw-RedText"");
  }
}","/**
 * Show an error message. Pass in null to clear the error message.
 * 
 * @param errorMsg the error message
 */
@ShowcaseSource
private void showErrorMessage(String errorMsg) 
{
    if (errorMsg == null)
    {
        errorLabel.setText("""");
    }
    else
    {
        errorLabel.setText(errorMsg);
    }
}   ",1357,False
"/**
 * Update the formatted value based on the user entered value and pattern.
 */
@SuppressWarnings(""deprecation"")
@ShowcaseSource
private void updateFormattedValue(){
  String sValue = valueBox.getText();
  if (!sValue.equals("""")) {
    try {
      Date date = new Date(sValue);
      String formattedValue = activeFormat.format(date);
      formattedBox.setText(formattedValue);
      showErrorMessage(null);
    } catch (IllegalArgumentException e) {
      showErrorMessage(constants.cwDateTimeFormatFailedToParseInput());
    }
  } else {
    formattedBox.setText(""<None>"");
  }
}","/**
 * Update the formatted value based on the user entered value and pattern.
 */



@SuppressWarnings(""deprecation"")
@ShowcaseSource
private void updateFormattedValue() 
{
    try
    {
        // Get the value from the text field
        String value = textField.getText();

        // Create a formatter for the pattern
        MaskFormatter formatter = new MaskFormatter(pattern);

        // Create a default formatter factory
        DefaultFormatterFactory factory = new DefaultFormatterFactory(formatter);

        // Set the formatter factory to the text field
        textField.setFormatterFactory(factory);

        // Update the formatted value
        textField.setValue(value);
    }
    catch (ParseException e)
    {
        // Handle the parse exception
        e.printStackTrace();
    }
}   ",1359,False
"// $ANTLR start ""pair""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:70:1: pair : key '=' value -> ^( PAIR key value ) ;
public final GuiceyDataParser.pair_return pair() throws RecognitionException{
    GuiceyDataParser.pair_return retval = new GuiceyDataParser.pair_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    Token char_literal51=null;
    GuiceyDataParser.key_return key50 = null;

    GuiceyDataParser.value_return value52 = null;


    Object char_literal51_tree=null;
    RewriteRuleTokenStream stream_36=new RewriteRuleTokenStream(adaptor,""token 36"");
    RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,""rule value"");
    RewriteRuleSubtreeStream stream_key=new RewriteRuleSubtreeStream(adaptor,""rule key"");
    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:71:2: ( key '=' value -> ^( PAIR key value ) )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:71:4: key '=' value
        {
        pushFollow(FOLLOW_key_in_pair428);
        key50=key();

        state._fsp--;
        if (state.failed) return retval;
        if ( state.backtracking==0 ) stream_key.add(key50.getTree());
        char_literal51=(Token)match(input,36,FOLLOW_36_in_pair430); if (state.failed) return retval; 
        if ( state.backtracking==0 ) stream_36.add(char_literal51);

        pushFollow(FOLLOW_value_in_pair432);
        value52=value();

        state._fsp--;
        if (state.failed) return retval;
        if ( state.backtracking==0 ) stream_value.add(value52.getTree());


        // AST REWRITE
        // elements: key, value
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        if ( state.backtracking==0 ) {
        retval.tree = root_0;
        RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,""rule retval"",retval!=null?retval.tree:null);

        root_0 = (Object)adaptor.nil();
        // 71:18: -> ^( PAIR key value )
        {
            // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:71:21: ^( PAIR key value )
            {
            Object root_1 = (Object)adaptor.nil();
            root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PAIR, ""PAIR""), root_1);

            adaptor.addChild(root_1, stream_key.nextTree());
            adaptor.addChild(root_1, stream_value.nextTree());

            adaptor.addChild(root_0, root_1);
            }

        }

        retval.tree = root_0;}
        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""pair""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:70:1: pair : key '=' value -> ^( PAIR key value ) ;

public final GuiceyDataParser.pair_return pair() throws RecognitionException 
{
    GuiceyDataParser.pair_return retval = new GuiceyDataParser.pair_return();
    retval.start = input.LT(1) ;

    GuiceyDataParser.key_return key1 =null;

    GuiceyDataParser.value_return value2 =null;


    try
    {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:71:5: ( key '=' value -> ^( PAIR key value ) )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:71:7: key '=' value
        {
        pushFollow(FOLLOW_key_in_pair110);
        key1=key();

        state._fsp--;

        match(input,15,FOLLOW_15_in_pair112); 
        pushFollow(FOLLOW_value_in_pair115);
        value2=value();

        state._fsp--;


        retval.st = (CommonTree)adaptor.newCommonTree((CommonToken)retval.start);
        adaptor.addChild(retval.st, key1.st);
        adaptor.addChild(retval.st, value2.st);

        adaptor.addChild(root_0, retval.st);
        }

        retval.stop = input.LT(-1) ;

        retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input,re);
    }
    finally
    {
    }
    return retval;
}   ",1361,False
"// $ANTLR start synpred21_GuiceyData
public final void synpred21_GuiceyData_fragment() throws RecognitionException{   
    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:91:4: ( type 'data;' )
    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:91:4: type 'data;'
    {
    pushFollow(FOLLOW_type_in_synpred21_GuiceyData488);
    type();

    state._fsp--;
    if (state.failed) return ;
    match(input,37,FOLLOW_37_in_synpred21_GuiceyData490); if (state.failed) return ;

    }
}","// $ANTLR start synpred21_GuiceyData
public final void synpred21_GuiceyData_fragment() throws RecognitionException 
{
    // synpred21_GuiceyData.g:27:4: ( WS )
    // synpred21_GuiceyData.g:27:4: WS
    {
    match(input,WS,FOLLOW_WS_in_synpred21_GuiceyData123); if (state.failed) return ;

    }
}   ",1363,False
"// $ANTLR start ""comment""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:59:1: comment : (~ ( '*/' ) )* ;
public final GuiceyDataParser.comment_return comment() throws RecognitionException{
    GuiceyDataParser.comment_return retval = new GuiceyDataParser.comment_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    Token set34=null;

    Object set34_tree=null;

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:2: ( (~ ( '*/' ) )* )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:4: (~ ( '*/' ) )*
        {
        root_0 = (Object)adaptor.nil();

        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:4: (~ ( '*/' ) )*
        loop14:
        do {
            int alt14=2;
            switch ( input.LA(1) ) {
            case DATA:
            case TYPE_MAP:
            case TYPE_SET:
            case TYPE_LIST:
            case PARAMETERIZED_TYPE:
            case TYPE_PRIMITIVE:
            case PROPERTY:
            case OPTION:
            case COMMENT:
            case PAIR:
            case ENUM:
            case ID:
            case INT:
            case FLOAT:
            case STRING:
            case TYPE:
            case WS:
            case EXPONENT:
            case ESC_SEQ:
            case HEX_DIGIT:
            case UNICODE_ESC:
            case OCTAL_ESC:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
                {
                alt14=1;
                }
                break;

            }

            switch (alt14) {
        	case 1 :
        	    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:0:0: ~ ( '*/' )
        	    {
        	    set34=(Token)input.LT(1);
        	    if ( (input.LA(1)>=DATA && input.LA(1)<=30)||(input.LA(1)>=32 && input.LA(1)<=43) ) {
        	        input.consume();
        	        if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set34));
        	        state.errorRecovery=false;state.failed=false;
        	    }
        	    else {
        	        if (state.backtracking>0) {state.failed=true; return retval;}
        	        MismatchedSetException mse = new MismatchedSetException(null,input);
        	        throw mse;
        	    }


        	    }
        	    break;

        	default :
        	    break loop14;
            }
        } while (true);


        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""comment""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:59:1: comment : (~ ( '*/' ) )* ;
public final GuiceyDataParser.comment_return comment() throws RecognitionException 
{
    GuiceyDataParser.comment_return retval = new GuiceyDataParser.comment_return();
    retval.start = input.LT(1);

    try
    {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:5: ( (~ ( '*/' ) )* )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:7: ~ ( '*/' )*
        {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:60:7: ~ ( '*/' )*
        loop1:
        do
        {
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( ((LA1_0 >= '\u0000' && LA1_0 <= ')')||(LA1_0 >= '+' && LA1_0 <= '\uFFFF')) )
            {
                alt1=1;
            }

            switch (alt1)
            {
                case 1 :
                    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:
                    {
                    if ( (input.LA(1) >= '\u0000' && input.LA(1) <= ')')||(input.LA(1) >= '+' && input.LA(1) <= '\uFFFF') )
                    {
                        input.consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        throw mse;
                    }

                    }
                    break;

                default :
                    break loop1;
            }
        } while (true);

        }

        retval.stop = input.LT(-1);

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return retval;
}   ",1369,True
"// $ANTLR start ""start""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:31:1: start : ( entry )+ EOF ;
public final GuiceyDataParser.start_return start() throws RecognitionException{
    GuiceyDataParser.start_return retval = new GuiceyDataParser.start_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    Token EOF2=null;
    GuiceyDataParser.entry_return entry1 = null;


    Object EOF2_tree=null;

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:2: ( ( entry )+ EOF )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:4: ( entry )+ EOF
        {
        root_0 = (Object)adaptor.nil();

        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:4: ( entry )+
        int cnt1=0;
        loop1:
        do {
            int alt1=2;
            switch ( input.LA(1) ) {
            case DATA:
            case ENUM:
            case 30:
                {
                alt1=1;
                }
                break;

            }

            switch (alt1) {
        	case 1 :
        	    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:0:0: entry
        	    {
        	    pushFollow(FOLLOW_entry_in_start121);
        	    entry1=entry();

        	    state._fsp--;
        	    if (state.failed) return retval;
        	    if ( state.backtracking==0 ) adaptor.addChild(root_0, entry1.getTree());

        	    }
        	    break;

        	default :
        	    if ( cnt1 >= 1 ) break loop1;
        	    if (state.backtracking>0) {state.failed=true; return retval;}
                    EarlyExitException eee =
                        new EarlyExitException(1, input);
                    throw eee;
            }
            cnt1++;
        } while (true);

        EOF2=(Token)match(input,EOF,FOLLOW_EOF_in_start124); if (state.failed) return retval;
        if ( state.backtracking==0 ) {
        EOF2_tree = (Object)adaptor.create(EOF2);
        adaptor.addChild(root_0, EOF2_tree);
        }

        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""start""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:31:1: start : ( entry )+ EOF ;
public final GuiceyDataParser.start_return start() throws RecognitionException 
{
    GuiceyDataParser.start_return retval = new GuiceyDataParser.start_return();
    retval.start = input.LT(1);

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:2: ( ( entry )+ EOF )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:4: ( entry )+ EOF
        {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:4: ( entry )+
        int cnt1=0;
        loop1:
        do {
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0==ID) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 :
                    // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:32:4: entry
                    {
                    pushFollow(FOLLOW_entry_in_start51);
                    entry();

                    state._fsp--;


                    }
                    break;

                default :
                    if ( cnt1 >= 1 ) break loop1;
                    EarlyExitException eee =
                        new EarlyExitException(1, input);
                    throw eee;
            }
            cnt1++;
        } while (true);

        match(input,EOF,FOLLOW_EOF_in_start55); 

        }

        retval.stop = input.LT(-1);

    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
    }
    finally {
    }
    return retval;
}   ",1370,True
"// $ANTLR start ""value""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:77:1: value : ( INT | FLOAT | STRING );
public final GuiceyDataParser.value_return value() throws RecognitionException{
    GuiceyDataParser.value_return retval = new GuiceyDataParser.value_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    Token set54=null;

    Object set54_tree=null;

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:78:2: ( INT | FLOAT | STRING )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:
        {
        root_0 = (Object)adaptor.nil();

        set54=(Token)input.LT(1);
        if ( (input.LA(1)>=INT && input.LA(1)<=STRING) ) {
            input.consume();
            if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set54));
            state.errorRecovery=false;state.failed=false;
        }
        else {
            if (state.backtracking>0) {state.failed=true; return retval;}
            MismatchedSetException mse = new MismatchedSetException(null,input);
            throw mse;
        }


        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""value""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:77:1: value : ( INT | FLOAT | STRING );
public final GuiceyDataParser.value_return value() throws RecognitionException 
{
    GuiceyDataParser.value_return retval = new GuiceyDataParser.value_return();
    retval.start = input.LT(1) ;

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:77:7: ( INT | FLOAT | STRING )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:
        {
        if ( input.LA(1)==INT||input.LA(1)==FLOAT||input.LA(1)==STRING ) {
            input.consume();
            state.errorRecovery=false;
        }
        else {
            MismatchedSetException mse = new MismatchedSetException(null, input);
            throw mse;
        }


        }

        retval.stop = input.LT(-1) ;

    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
    }
    finally {
    }
    return retval;
}   ",1374,True
"// Delegated rules
public final boolean synpred21_GuiceyData(){
    state.backtracking++;
    int start = input.mark();
    try {
        synpred21_GuiceyData_fragment(); // can never throw exception
    } catch (RecognitionException re) {
        System.err.println(""impossible: ""+re);
    }
    boolean success = !state.failed;
    input.rewind(start);
    state.backtracking--;
    state.failed=false;
    return success;
}","// Delegated rules




public final boolean synpred21_GuiceyData() 
{
    final Stack<Object> stack = new Stack<Object>();
    final List<Object> list = new ArrayList<Object>();
    final Map<String, Object> map = new HashMap<String, Object>();

    final DelegatedRule rule = new DelegatedRule(stack, list, map);
    return rule.matches(null, null, null);
}   ",1375,True
"// $ANTLR start ""key""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:74:1: key : ID ;
public final GuiceyDataParser.key_return key() throws RecognitionException{
    GuiceyDataParser.key_return retval = new GuiceyDataParser.key_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    Token ID53=null;

    Object ID53_tree=null;

    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:75:2: ( ID )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:75:4: ID
        {
        root_0 = (Object)adaptor.nil();

        ID53=(Token)match(input,ID,FOLLOW_ID_in_key454); if (state.failed) return retval;
        if ( state.backtracking==0 ) {
        ID53_tree = (Object)adaptor.create(ID53);
        adaptor.addChild(root_0, ID53_tree);
        }

        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""key""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:74:1: key : ID ;
public final GuiceyDataParser.key_return key() throws RecognitionException 
{
    GuiceyDataParser.key_return retval = new GuiceyDataParser.key_return();
    retval.start = input.LT(1);

    try
    {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:74:5: ( ID )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:74:7: ID
        {
        match(input,ID,FOLLOW_ID_in_key73); 

        }

        retval.stop = input.LT(-1);

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input,re);
    }
    finally
    {
    }
    return retval;
}   ",1376,True
"/**
 * Perform necessary set up tasks before each test runs.
 */
@Before
public void setUp(){
    	//Configure com.mattinsler.guiceymongo.data.generator
        GENERATOR.setSourceDirectory(OUTPUT);
        GENERATOR.setOutputPackage(PACKAGE);
        GENERATOR.setFileExtensions(FILE_EXTENSION);

        try {
        	//Delete anything in the output directory
		FileUtils.deleteDirectory(new File(OUTPUT));
	} catch (IOException e) {
		e.printStackTrace();
		Assert.fail(""Could not clear output directory for test."");
	}
}","/**
 * Perform necessary set up tasks before each test runs.
 */
@Before
public void setUp() 
{
    // Create a new instance of the Calculator class
    calculator = new Calculator();
}   ",1377,False
"// $ANTLR start ""key_type""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:95:1: key_type : type ;
public final GuiceyDataParser.key_type_return key_type() throws RecognitionException{
    GuiceyDataParser.key_type_return retval = new GuiceyDataParser.key_type_return();
    retval.start = input.LT(1);

    Object root_0 = null;

    GuiceyDataParser.type_return type60 = null;



    try {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:96:2: ( type )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:96:4: type
        {
        root_0 = (Object)adaptor.nil();

        pushFollow(FOLLOW_type_in_key_type530);
        type60=type();

        state._fsp--;
        if (state.failed) return retval;
        if ( state.backtracking==0 ) adaptor.addChild(root_0, type60.getTree());

        }

        retval.stop = input.LT(-1);

        if ( state.backtracking==0 ) {

        retval.tree = (Object)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
        }
    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""key_type""
// com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:95:1: key_type : type ;
public final GuiceyDataParser.key_type_return key_type() throws RecognitionException 
{
    GuiceyDataParser.key_type_return retval = new GuiceyDataParser.key_type_return();
    retval.start = input.LT(1);

    try
    {
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:95:10: ( type )
        // com/mattinsler/guiceymongo/data/generator/parser/GuiceyData.g:95:12: type
        {
        pushFollow(FOLLOW_type_in_key_type120);
        type();

        state._fsp--;


        }

        retval.stop = input.LT(-1);

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return retval;
}   ",1378,True
"/**
 * @param engineName
 * @param engine
 * @return hosts
 * @throws IOException
 * @throws JMXException
 */
private String hosts(String engineName, ObjectName engine)
        throws RuntimeException, IOException{
    StringBuilder s = new StringBuilder();

    SortedSet<ObjectName> hosts = query(engineName + "":type=Host,host=*"");

    for (ObjectName host : hosts) {

        String hostname = (String) attribute(host, ""name"");

        if (getConfig().isOptionSet(""hostname"")) {
            if (!getConfig().getOptionValue(""hostname"").equals(hostname))
                continue;
        }

        s.append(""\n  Host:"");
        s.append(hostname);

        String[] aliases = (String[]) attribute(host, ""aliases"");
        ObjectName[] webapps = (ObjectName[]) attribute(host, ""children"");

        if (super.getConfig().isOptionSet(""verbose"")) {
            s.append(""\n   Aliases["");
            boolean first = true;
            for (String alias : aliases) {
                if (!first)
                    s.append("","");
                s.append(alias);
                first = false;
            }
            s.append(""]"");
        }

        if ((getConfig().isOptionSet(""webapps"") || getConfig().isOptionSet(
                ""webapp""))
                && (webapps.length > 0)) {
            s.append(webapps(engineName, hostname, webapps));
            if (hosts.size() > 1) {
                s.append(""\n"");
            }
        }
        else {
            if (getConfig().isOptionSet(""verbose"")) {
                s.append(""\n   "");
            }
            else {
                s.append("" - "");
            }
            s.append(webapps.length);
            s.append("" applications"");
        }

    }

    return s.toString();

}","/**
 * @param engineName
 * @param engine
 * @return hosts
 * @throws IOException
 * @throws JMXException
 */
private String hosts(String engineName, ObjectName engine)
        throws RuntimeException, IOException 
{
    String hosts = null;
    try
    {
        hosts = (String) mbsc.getAttribute(engine, ""Hosts"");
    }
    catch (Exception e)
    {
        throw new RuntimeException(""Failed to get hosts for engine ""
                + engineName, e);
    }
    return hosts;
}       ",1384,False
"/*
 * (non-Javadoc)
 * 
 * @see
 * org.pidster.tomcat.util.cli.CommandConfig#getOptionValue(java.lang.String
 * )
 */
@Override
public final String getOptionValue(String name){
    for (Option option : options.keySet()) {
        if (option.name().equals(name)) {
            return options.get(option);
        }
    }
    return null;
}","/*
 * (non-Javadoc)
 * 
 * @see
 * org.pidster.tomcat.util.cli.CommandConfig#getOptionValue(java.lang.String
 * )
 */
@Override
public final String getOptionValue(String name) 
{
    if (options.containsKey(name))
    {
        return options.get(name);
    }
    else
    {
        return null;
    }
}   ",1385,True
"/**
 * @param executors
 * @return content
 */
private String executors(SortedSet<ObjectName> executors){
    StringBuilder s = new StringBuilder();

    if (executors.size() > 0) {

        for (ObjectName executor : executors) {

            String name = (String) attribute(executor, ""name"");
            int activeCount = (Integer) attribute(executor, ""activeCount"");
            int maxThreads = (Integer) attribute(executor, ""maxThreads"");
            int minSpareThreads = (Integer) attribute(executor,
                    ""minSpareThreads"");

            int queueSize = (Integer) attribute(executor, ""queueSize"");
            int poolSize = (Integer) attribute(executor, ""poolSize"");
            int corePoolSize = (Integer) attribute(executor, ""corePoolSize"");
            int largestPoolSize = (Integer) attribute(executor,
                    ""largestPoolSize"");

            s.append(""\n  Executor: "");
            s.append(name);
            s.append(String
                    .format("" [active:%d, pool:%d, init:%d, largest:%d, max:%d, spare:%d; queue:%d]"",
                            activeCount, poolSize, corePoolSize,
                            largestPoolSize, maxThreads, minSpareThreads,
                            queueSize));
        }
    }

    return s.toString();
}","/**
 * @param executors
 * @return content
 */
private String executors(SortedSet<ObjectName> executors) 
{
    StringBuilder content = new StringBuilder();
    for (ObjectName on : executors)
    {
        try
        {
            content.append(on.getKeyProperty(""type"")).append("" : "").append(on.getKeyProperty(""name"")).append(""\n"");
        }
        catch (MalformedObjectNameException e)
        {
            // Should never happen
            throw new RuntimeException(e);
        }
    }
    return content.toString();
}   ",1386,False
"/**
 * @param engineName
 * @param engine
 * @return engine
 * @throws IOException
 * @throws JMXException
 */
private String connectors(String engineName, ObjectName engine)
        throws RuntimeException, IOException{
    StringBuilder s = new StringBuilder();

    SortedSet<ObjectName> executors = query(engineName + "":type=Executor,*"");

    if (executors.size() > 0) {
        s.append(executors(executors));
    }

    SortedSet<ObjectName> connectors = query(engineName
            + "":type=Connector,*"");

    for (ObjectName connector : connectors) {
        String address = (String) attribute(connector, ""address"");
        Integer port = (Integer) attribute(connector, ""port"");

        SortedSet<ObjectName> protocolHandlers = query(engineName
                + "":type=ProtocolHandler,port="" + port);
        ObjectName protocolHandler = protocolHandlers.first();
        String name = (String) attribute(protocolHandler, ""name"");

        s.append(String.format(""\n  Connector:%-8s ["",
                attribute(connector, ""protocol"")));

        if (address == null) {
            address = ""0.0.0.0"";
        }

        s.append(String.format(""%s::%s:%s, secure=%s, redirect=%s]"",
                attribute(connector, ""scheme""), address, port,
                attribute(connector, ""secure""),
                attribute(connector, ""redirectPort"")));

        if (super.getConfig().isOptionSet(""threads"")) {
            SortedSet<ObjectName> threadPools = query(engineName
                    + "":type=ThreadPool,name="" + name);
            s.append(threads(engineName, threadPools));
        }
    }

    return s.toString();
}","/**
 * @param engineName
 * @param engine
 * @return engine
 * @throws IOException
 * @throws JMXException
 */
private String connectors(String engineName, ObjectName engine)
        throws RuntimeException, IOException 
{
    String connectors = """";
    ObjectName[] connectorsNames = (ObjectName[]) server.invoke(engine,
            ""listConnectors"", null, null);
    for (ObjectName connectorName : connectorsNames)
    {
        String connector = (String) server.invoke(engine, ""getConnector"",
                new Object[] { connectorName },
                new String[] { ""java.lang.String"" });
        connectors += connector;
    }
    return connectors;
}       ",1387,True
"/**
 * @param environment
 * @param environment
 * @param arguments
 * @param options
 */
public CommandConfigImpl(Environment environment, String name,
        List<String> arguments, Map<Option, String> options){
    this.environment = environment;
    this.name = name;
    this.arguments = arguments;
    this.options = options;
}","/**
 * @param environment
 * @param environment
 * @param arguments
 * @param options
 */
public CommandConfigImpl(Environment environment, String name,
        List<String> arguments, Map<Option, String> options) 
{
    this.environment = environment;
    this.name = name;
    this.arguments = arguments;
    this.options = options;
}       ",1389,True
"/**
 * @param webapps
 * @return
 * @throws IOException
 */
private String webapps(String engineName, String hostname,
        ObjectName[] webapps) throws IOException{

    StringBuilder s = new StringBuilder();

    SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");

    if (isVerbose()) {
        s.append(""\n   application ---- path ------------ state sessions - total ---- proctime init -- tldscan ----------- started"");
    }
    else {
        s.append(""\n   application ---- path ------------ state sessions - startup ------------ started"");
    }

    for (ObjectName webapp : webapps) {

        // Hacks to get around v6.0 to v7.0 transition
        Object stateObj = attribute(webapp, ""state"");

        String appState = ""unknown"";
        if (stateObj instanceof Integer) {
            appState = WEBAPP_STATES[(Integer) stateObj];
        }
        else if (stateObj.getClass().isEnum()) {
            appState = ((Enum<?>) stateObj).name().toLowerCase();
        }

        if (""stopped"".equalsIgnoreCase(appState)) {
            appState = appState + ""!"";
        }

        String path = """";
        String started = """";
        String docBase = (String) attribute(webapp, ""docBase"");

        if (getConfig().isOptionSet(""webapp"")) {
            if (!getConfig().getOptionValue(""webapp"").equals(docBase))
                continue;
        }

        s.append(""\n   "");

        // ------------------------------------------------------

        String activeSessions = """";
        String totalSessions = """";
        String processingTime = """";
        String initTime = """";
        String startupTime = """";
        String tldScanTime = """";

        if (""STARTED"".equalsIgnoreCase(appState)) {
            appState = ""ok"";
            path = (String) attribute(webapp, ""path"");
            Long startTime = (Long) attribute(webapp, ""startTime"");
            started = sdf.format(new Date(startTime));

            if (path.isEmpty())
                path = ""/"";

            String query = engineName + "":type=Manager,path="" + path
                    + "",host="" + hostname;

            SortedSet<ObjectName> managers = query(query);
            ObjectName manager = managers.first();

            activeSessions = String.valueOf(attribute(manager,
                    ""activeSessions""));
            totalSessions = String.valueOf(attribute(manager,
                    ""sessionCounter""));

            processingTime = String.valueOf(attribute(manager,
                    ""processingTime""));

            startupTime = attribute(webapp, ""startupTime"") + ""ms"";
            tldScanTime = attribute(webapp, ""tldScanTime"") + ""ms"";
            initTime = ((Long) attribute(webapp, ""startupTime"") + (Long) attribute(
                    webapp, ""tldScanTime"")) + ""ms"";

        }

        if (isVerbose()) {
            s.append(String.format(
                    ""%-16s %-17s %-5s %-10s %-10s %-8s %-7s %-6s %20s"",
                    docBase, path, appState, activeSessions, totalSessions,
                    processingTime, startupTime, tldScanTime, started));
        }
        else {
            s.append(String.format(""%-16s %-17s %-5s %-10s %-7s %20s"",
                    docBase, path, appState, activeSessions, initTime,
                    started));
        }

    }

    return s.toString();
}","/**
 * @param webapps
 * @return
 * @throws IOException
 */
private String webapps(String engineName, String hostname,
        ObjectName[] webapps) throws IOException 
{
    StringBuilder sb = new StringBuilder();
    sb.append(""<h1>Web Apps</h1>"");
    sb.append(""<table border=1 cellspacing=0 cellpadding=5>"");
    sb.append(""<tr><th>Context Path</th><th>State</th><th>Session Timeout</th><th>Session Cookie Path</th></tr>"");
    for (ObjectName oname : webapps)
    {
        String contextPath = (String) mbs.getAttribute(oname, ""path"");
        String state = (String) mbs.getAttribute(oname, ""state"");
        Integer sessionTimeout = (Integer) mbs.getAttribute(oname, ""sessionTimeout"");
        String sessionCookiePath = (String) mbs.getAttribute(oname, ""sessionCookiePath"");
        sb.append(""<tr><td>"").append(contextPath).append(""</td><td>"").append(state).append(""</td><td>"").append(sessionTimeout).append(""</td><td>"").append(sessionCookiePath).append(""</td></tr>"");
    }
    sb.append(""</table>"");
    return sb.toString();
}   ",1391,False
"/**
 * @param service
 * @return str
 * @throws IOException
 * @throws JMXException
 */
private String engines(ObjectName service) throws RuntimeException,
        IOException{

    StringBuilder s = new StringBuilder();

    SortedSet<ObjectName> engines = query(service.getDomain()
            + "":type=Engine"");

    for (ObjectName engine : engines) {

        String engineName = (String) attribute(engine, ""name"");

        s.append(String.format(""\n Engine:%1s"", engineName));

        s.append("" ["");
        s.append(""defaultHost="");
        s.append(attribute(engine, ""defaultHost""));

        Object jvmRoute = attribute(engine, ""jvmRoute"");
        if (jvmRoute != null) {
            s.append("", jvmRoute="");
            s.append(jvmRoute);
        }
        if (super.getConfig().isOptionSet(""verbose"")) {
            s.append("", baseDir="");
            s.append(attribute(engine, ""baseDir""));

        }
        s.append(""]"");
        s.append("""");

        if (super.getConfig().isOptionSet(""connectors"")) {
            s.append(connectors(engineName, engine));
        }

        s.append(hosts(engineName, engine));

    }

    return s.toString();
}","/**
 * @param service
 * @return str
 * @throws IOException
 * @throws JMXException
 */
private String engines(ObjectName service) throws RuntimeException,
        IOException 
{
    String str = """";
    try
    {
        str = (String) mbsc.getAttribute(service, ""Engines"");
    }
    catch (Exception e)
    {
        throw new RuntimeException(e);
    }
    return str;
}   ",1394,False
"/*
 * (non-Javadoc)
 * 
 * @see
 * org.pidster.tomcat.util.cli.CommandConfig#getOption(java.lang.String)
 */
@Override
public final Option getOption(String name){
    for (Option option : options.keySet()) {
        if (option.name().equals(name)) {
            return option;
        }
    }
    return null;
}","/*
 * (non-Javadoc)
 * 
 * @see
 * org.pidster.tomcat.util.cli.CommandConfig#getOption(java.lang.String)
 */
@Override
public final Option getOption(String name) 
{
    for (Option option : options)
    {
        if (option.getName().equals(name))
        {
            return option;
        }
    }
    return null;
}   ",1397,True
"/**
 * @param server
 * @param s
 * @throws IOException
 * @throws RuntimeException
 */
private String datasources(ObjectName server) throws IOException,
        RuntimeException{

    StringBuilder s = new StringBuilder();

    SortedSet<ObjectName> globalResources = query(server.getDomain()
            + "":type=Resource,resourcetype=Global,*"");

    if (getConfig().isOptionSet(""datasources"")
            && globalResources.size() > 0) {
        s.append(""\nGlobal Resources:"");
        for (ObjectName global : globalResources) {

            String name = attribute(global, ""name"");
            String type = attribute(global, ""type"");

            String dsq = server.getDomain() + "":type=DataSource,name=\""""
                    + name + ""\"",class="" + type;

            SortedSet<ObjectName> dataSources = query(dsq, null);
            for (ObjectName ds : dataSources) {
                s.append(String
                        .format(""\n %-25s[init:%s, now:%s, mxA:%s, idl:%s, mnI:%s, mxI:%s]"",
                                name, attribute(ds, ""initialSize""), 0,
                                attribute(ds, ""numActive""),
                                attribute(ds, ""maxActive""),
                                attribute(ds, ""numIdle""),
                                attribute(ds, ""minIdle""),
                                attribute(ds, ""maxIdle"")));
                if (isVerbose()) {
                    s.append(""\n - "");
                    s.append(attribute(ds, ""url""));
                }
            }
        }
    }

    return s.toString();
}","/**
 * @param server
 * @param s
 * @throws IOException
 * @throws RuntimeException
 */
private String datasources(ObjectName server) throws IOException,
        RuntimeException 
{
    ObjectName[] datasources = (ObjectName[]) server.invoke(""listDataSources"",
            null, null);
    StringBuilder sb = new StringBuilder();
    for (ObjectName datasource : datasources)
    {
        ObjectName[] tables = (ObjectName[]) server.invoke(
                ""listTables"", new Object[]{datasource}, new String[]{""java.lang.String""});
        sb.append(""\tDatasource: "").append(datasource).append(""\n"");
        for (ObjectName table : tables)
        {
            sb.append(""\t\tTable: "").append(table).append(""\n"");
        }
    }
    return sb.toString();
}   ",1399,False
"/**
 * Draws a circle representing an agent's political views location and lines representing the groups
 * @param g Graphics objects
 * @param agent_c colour of the lines joining the agents
 * @param players TreeMap of the AbstractAgents to draw
 */
private void drawGroupLines(Graphics g, Color agent_c,
				TreeMap<String, AbstractAgent> players){
	double x1, y1, x2, y2;
	Rectangle rect = g.getClipBounds();
	int size = 0;

	for (Map.Entry<String, AbstractAgent> entry1 : players.entrySet())
	{
		PublicAgentDataModel agent1_dm = entry1.getValue().getDataModel();

		if (agent1_dm.getGroupId() != null && PublicEnvironmentConnection.getInstance().getGroupById(
						agent1_dm.getGroupId()).getMemberList().size() > 1)
		{

			for (Map.Entry<String, AbstractAgent> entry2 : players.entrySet())
			{
				PublicAgentDataModel agent2_dm = entry2.getValue().getDataModel();

				if (agent2_dm.getGroupId() != null)
				{
					if (!entry1.getKey().equals(entry2.getKey()) && agent1_dm.getGroupId().equals(
									agent2_dm.getGroupId()))
					{
						g.setColor(agent_c);
						x1 = agent1_dm.getEconomicBelief() * (rect.width / correction);
						x2 = agent2_dm.getEconomicBelief() * (rect.width / correction);
						y1 = agent1_dm.getSocialBelief() * (rect.height / correction);
						y2 = agent2_dm.getSocialBelief() * (rect.height / correction);
						g.drawLine((int)x1 + 1, (int)y1 + 1, (int)x2 + 1, (int)y2 + 1);
						size = PublicEnvironmentConnection.getInstance().getGroupById(
										agent1_dm.getGroupId()).getMemberList().size();

						float hue = getGroupColour(agent1_dm.getGroupId());
						g.setColor(Color.getHSBColor(hue, 1, 1));
						boolean ldr = false;
						for (String LeaderId : PublicEnvironmentConnection.getInstance().getGroupById(
										agent1_dm.getGroupId()).getPanel()) //draw if not a leader
						{
							if (LeaderId.equals(entry1.getValue().getId()))
							{
								ldr = true;
							}
						}
						if (!ldr)
						{
							drawAgent(g, entry1.getValue(), 3);
						}
					}
				}
			}
		}
	}
}","/**
 * Draws a circle representing an agent's political views location and lines representing the groups
 * @param g Graphics objects
 * @param agent_c colour of the lines joining the agents
 * @param players TreeMap of the AbstractAgents to draw
 */
private void drawGroupLines(Graphics g, Color agent_c,
				TreeMap<String, AbstractAgent> players) 
{
	for (AbstractAgent player : players.values())
	{
		if (player.getGroup() != null)
		{
			AbstractAgent group = player.getGroup();
			g.setColor(agent_c);
			g.drawLine((int) player.getX(), (int) player.getY(),
					(int) group.getX(), (int) group.getY());
		}
	}
}	",1400,False
"/**
 * Run per-step-in-simulation code that changes the plugin's state.
 * Get new information from the alive agents of the simulation
 */
@Override
public void execute(){
	// Add/remove new/old players
	try
	{
		updatePoliticalPlayers();
	}
	catch (Exception e)
	{
		System.out.println(""Error updating Political Players: "" + e.getMessage());
	}

	repaint();

	if (this.outputdirectory != null && (PublicEnvironmentConnection.getInstance().getRoundsPassed() % 50 == 0))
	{
		writeToPNG();
	}
}","/**
 * Run per-step-in-simulation code that changes the plugin's state.
 * Get new information from the alive agents of the simulation
 */
@Override
public void execute() 
{
    // Get the current simulation step
    int step = (int) this.getContext().getSimulation().getSimulationStep();

    // Check if it's time to update the plugin
    if (step % updateInterval == 0)
    {
        // Get the alive agents of the simulation
        List<Agent> agents = this.getContext().getSimulation().getAliveAgents();

        // Update the plugin's state with the new agent information
        this.updatePluginState(agents);
    }
}   ",1401,False
"/**
 * Removes an {@link AbstractAgent agents} or {@link AbstractGroupAgent group}
 * from the simulation
 * @param id The id of the participant to remove
 * @return Whether the {@link Participant} could be removed
 * @see #registerParticipant(ise.mace.tokens.RegistrationRequest)
 * @see UnregisterRequest
 * @see Death
 */
public boolean removeParticipant(String id){
	if (agents.remove(id) == null)
	{
		return (agentGroups.remove(id) != null);
	}
	return true;
}","/**
 * Removes an {@link AbstractAgent agents} or {@link AbstractGroupAgent group}
 * from the simulation
 * @param id The id of the participant to remove
 * @return Whether the {@link Participant} could be removed
 * @see #registerParticipant(ise.mace.tokens.RegistrationRequest)
 * @see UnregisterRequest
 * @see Death
 */
public boolean removeParticipant(String id) 
{
    if (participants.containsKey(id))
    {
        participants.remove(id);
        return true;
    }
    return false;
}   ",1402,True
"/**
 * Generates a (possibly non-unique) player name
 * @return New player name
 */
public synchronized static String getName(){
	if (!hasRandomised)
	{
		sort(foreNames);
		sort(lastNames);
		hasRandomised = true;
	}
	String fName = foreNames[foreNameIndex];
	String lName = lastNames[lastNameIndex];

	if (rand.nextBoolean())
	{
		foreNameIndex++;
		if (foreNameIndex == foreNames.length) foreNameIndex = 0;
	}
	else
	{
		lastNameIndex++;
		if (lastNameIndex == lastNames.length) lastNameIndex = 0;
	}
	return fName + ' ' + lName;
}","/**
 * Generates a (possibly non-unique) player name
 * @return New player name
 */
public synchronized static String getName() 
{
    return ""Player "" + (int)(Math.random() * 1000);
}   ",1403,True
"/**
 * Finds what food types are available to hunt
 * @return set of available food.
 * @see #getFoodById(java.util.UUID)
 */
public Set<Food> availableFoods(){
	return Collections.unmodifiableSet(new HashSet<Food>(
					availableFoodTypes.values()));
}","/**
 * Finds what food types are available to hunt
 * @return set of available food.
 * @see #getFoodById(java.util.UUID)
 */

public Set<Food> availableFoods() 
{
    Set<Food> availableFoods = new HashSet<>();
    for (Food food : Food.values())
    {
        if (food.getCalories() > 0)
        {
            availableFoods.add(food);
        }
    }
    return availableFoods;
}   ",1404,True
"/**
 * Draws a rectangle representing an group-agent's political views location and lines representing the groups
 * @param g Graphics objects
 */
private void drawAgentGroups(Graphics g){
	try
	{
		if (!agent_groups.isEmpty())
		{
			drawGroupLines(g, Color.BLUE, agent_groups);
		}
	}
	catch (Exception e)
	{
		System.out.println(""Error in agent-groups: "" + e.getMessage());
	}
}","/**
 * Draws a rectangle representing an group-agent's political views location and lines representing the groups
 * @param g Graphics objects
 */
private void drawAgentGroups(Graphics g) 
{
    if (groupAgent != null)
    {
        g.setColor(Color.BLACK);
        g.drawRect(groupAgent.getX() - 2, groupAgent.getY() - 2, 4, 4);

        for (Group group : groupAgent.getGroups())
        {
            g.drawLine(groupAgent.getX(), groupAgent.getY(), group.getX(), group.getY());
        }
    }
}   ",1405,True
"/**
 * Initialises a plugin that was stored using the SimpleXML framework, making
 * it ready to be used in the visualisation of a simulation
 * @param sim The simulation to which this plugin will belong
 */
@Override
public void initialise(Simulation sim){
	System.out.println("" -Initialising Political Compass Plugin...."");

	this.sim = sim;
	this.en = (Environment)sim.environment;
	setBackground(Color.CYAN);

	repaint();
}","/**
 * Initialises a plugin that was stored using the SimpleXML framework, making
 * it ready to be used in the visualisation of a simulation
 * @param sim The simulation to which this plugin will belong
 */
@Override
public void initialise(Simulation sim) 
{
    if (this.plugin != null)
    {
        this.plugin.initialise(sim);
    }
}   ",1406,True
"/**
 * Creates a new environment data model for constructing an {@link
 * Environment} in a {@link Simulation}
 * @param environmentName The name to give the environment
 * @param availableFoodTypes The food that agents can hunt {@link
 * #availableFoods()}
 * @param allowedGroupTypes The groups for use. {@link
 * #getAllowedGroupTypes()}
 * @param foodConsumedPerAdvice Amount of food consumed when an {@link
 * AbstractAgent agent} {@link AbstractAgent#seekAvice(java.lang.String) seeks
 * adive}. See {@link #foodConsumedPerAdvice}
 */
public EnvironmentDataModel(String environmentName,
    HashMap<String, Food> availableFoodTypes,
    ArrayList<Class<? extends AbstractGroupAgent>> allowedGroupTypes,
    double foodConsumedPerAdvice){
	super(environmentName, ""ISE Game of Life Enviroment Data Model"", 0);
	this.availableFoodTypes = availableFoodTypes;

	this.agentGroups = new HashMap<String, PublicGroupDataModel>();
	this.allowedGroupTypes = allowedGroupTypes;

	this.turn = TurnType.firstTurn;
	this.rounds = 0;
	this.id = UUID.randomUUID().toString();
}","/**
 * Creates a new environment data model for constructing an {@link
 * Environment} in a {@link Simulation}
 * @param environmentName The name to give the environment
 * @param availableFoodTypes The food that agents can hunt {@link
 * #availableFoods()}
 * @param allowedGroupTypes The groups for use. {@link
 * #getAllowedGroupTypes()}
 * @param foodConsumedPerAdvice Amount of food consumed when an {@link
 * AbstractAgent agent} {@link AbstractAgent#seekAvice(java.lang.String) seeks
 * adive}. See {@link #foodConsumedPerAdvice}
 */
public EnvironmentDataModel(String environmentName,
    HashMap<String, Food> availableFoodTypes,
    ArrayList<Class<? extends AbstractGroupAgent>> allowedGroupTypes,
    double foodConsumedPerAdvice) 
{
    this.environmentName = environmentName;
    this.availableFoodTypes = availableFoodTypes;
    this.allowedGroupTypes = allowedGroupTypes;
    this.foodConsumedPerAdvice = foodConsumedPerAdvice;
}   ",1407,True
"/**
 * Updates the time in the model
 * @param time New cycle time
 */
@Override
public void setTime(long time){
	super.setTime(time);
	if (time == 0)
	{
		turn = TurnType.firstTurn;
		return;
	}

	TurnType[] t = TurnType.values();

	int next = turn.ordinal() + 1;
	if (next == t.length)
	{
		next = 0;
		rounds++;
	}

	turn = t[next];
}","/**
 * Updates the time in the model
 * @param time New cycle time
 */
@Override
public void setTime(long time) 
{
    if (time < 0)
    {
        throw new IllegalArgumentException(""Time cannot be negative"");
    }
    this.time = time;
}   ",1408,True
"/**
 * Draw everything to the screen
 * @param g Graphics object
 */
@Override
public void paint(Graphics g){
	// Clear everything and set the clip
	g.setColor(Color.LIGHT_GRAY);
	g.fillRect(0, 0, getWidth(), getHeight());
	g.setClip(shift, shift, getWidth() - shift, getHeight() - shift);

	// Draw social and economic axis
	Rectangle rect = g.getClipBounds();
	g.setColor(Color.YELLOW);
	g.drawLine((int)(rect.width / (correction * 2)), 0,
					(int)(rect.width / (correction * 2)), rect.height);
	g.drawLine(0, (int)(rect.height / (correction * 2)), rect.width,
					(int)(rect.height / (correction * 2)));



	// Draw all agents agents
	try
	{
		if (CompassControl.agent_button)
		{
			for (Map.Entry<String, AbstractAgent> entry : p_players.entrySet())
			{
				g.setColor(Color.BLUE);
				if (entry.getValue().getDataModel().getGroupId() == null)
					drawAgent(g, entry.getValue(), 2);
			}

			// Draw agent connections + groupped agents

			drawGroupLines(g, Color.RED, p_players);
			drawLeaders(g);
		}
		if (CompassControl.group_button)
		{
			drawAgentGroups(g);
		}

	}
	catch (Exception e)
	{
		System.out.println(
						""Error in Drawing the agents,lines or groups: "" + e.getMessage());
	}
}","/**
 * Draw everything to the screen
 * @param g Graphics object
 */

@Override
public void paint(Graphics g) 
{
    super.paint(g);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setColor(Color.black);
    g2d.fillRect(0, 0, d.width, d.height);
    g2d.setColor(Color.green);
    g2d.fillOval(x, y, 30, 30);
}   ",1410,False
"/**
 * Sets everything up
 * @param agent The agent that applied
 * @param accepted Whether they were accepted
 */
public RespondToApplication(String agent, boolean accepted){
	this.agent = agent;
	this.accepted = accepted;
}","/**
 * Sets everything up
 * @param agent The agent that applied
 * @param accepted Whether they were accepted
 */
public RespondToApplication(String agent, boolean accepted) 
{
    this.agent = agent;
    this.accepted = accepted;
}   ",1411,True
"/**
 * Adds new players and removes dead players since the last cycle.
 */
private void updatePoliticalPlayers(){
	SortedSet<String> active_agent_ids = sim.getactiveParticipantIdSet();

	// Add any new agents
	for (String id : active_agent_ids)
	{
		if (!p_players.containsKey(id))
		{
			if (PublicEnvironmentConnection.getInstance().isAgentId(id))
				p_players.put(id, (AbstractAgent)sim.getPlayer(id));
			else
				agent_groups.put(id, (AbstractAgent)sim.getPlayer(id));
		}
	}

	// Delete agents which are no longer active
	p_players.keySet().retainAll(active_agent_ids);
	agent_groups.keySet().retainAll(active_agent_ids);
}","/**
 * Adds new players and removes dead players since the last cycle.
 */
private void updatePoliticalPlayers() 
{
    for (Player player : players)
    {
        if (player.isDead())
        {
            politicalPlayers.remove(player);
        }
        else
        {
            politicalPlayers.add(player);
        }
    }
}   ",1412,True
"/**
 * {@inheritDoc}
 * @see ise.mace.neuralnetworks.Neuron#activationFunction(double, double)
 */
@Override
public double activationFunction(double sum, double offset){
	if (sum > offset)
	{
		return 1.0f;
	}
	return 0.0f;
}","/**
 * {@inheritDoc}
 * @see ise.mace.neuralnetworks.Neuron#activationFunction(double, double)
 */
@Override
public double activationFunction(double sum, double offset) 
{
    double activation = 1 / (1 + Math.exp(-sum - offset));
    return activation;
}   ",1414,True
"/*
 * creates a group for free agents.
 */
private void createFreeAgentGroup(){
	int groupid = 0;
	wrap.groupAdd(""FreeAgentsGroup"", groupid, round);
	//required to allow idMap to work for agents with no group
	groupIdMap.put(null, groupid);
}","/*
 * creates a group for free agents.
 */
private void createFreeAgentGroup() 
{
    Group freeAgentGroup = new Group(""Free Agents"");
    for (Player player : players)
    {
        if (player.getTeam() == null)
        {
            freeAgentGroup.addPlayer(player);
        }
    }
    groups.add(freeAgentGroup);
}   ",1415,True
"/**
 * Creates a new hunt action, which indicates that an agent is going to hunt
 * a particular type of food
 * @param type The type of food to hunt
 */
public Hunt(Food type){
	super();
	foodType = type.getId();
}","/**
 * Creates a new hunt action, which indicates that an agent is going to hunt
 * a particular type of food
 * @param type The type of food to hunt
 */
public Hunt(Food type) 
{
    this.type = type;
}   ",1416,True
"/**
 * Random sorting utility function
 * @param values The array to randomising
 */
private static void sort(String[] values){
	int i;
	String temp;
	for (i = 0; i < values.length; i++)
	{
		int r = (rand.nextInt() & 0x7FFFFFFF) % values.length;
		temp = values[i];
		values[i] = values[r];
		values[r] = temp;
	}
}","/**
 * Random sorting utility function
 * @param values The array to randomising
 */
private static void sort(String[] values) 
{
    for (int i = 0; i < values.length; i++)
    {
        int randomIndex = (int) (Math.random() * values.length);
        String temp = values[i];
        values[i] = values[randomIndex];
        values[randomIndex] = temp;
    }
}   ",1418,True
"/**
 * Creates a new Hunting team
 * Note that such teams are a subset of a group, and that agents cannot be in
 * more than one team at once.
 * @param members The members of the team
 */
public HuntingTeam(List<String> members){
	this.members = Collections.unmodifiableList(members);
	this.orderedTarget = orderedTarget;
}","/**
 * Creates a new Hunting team
 * Note that such teams are a subset of a group, and that agents cannot be in
 * more than one team at once.
 * @param members The members of the team
 */
public HuntingTeam(List<String> members) 
{
    this.members = members;
}   ",1419,True
"/**
 * Evaluates the value of this bind variable.  This is just a thin-wrapper around:
 * {@link #getValue(Object,Query)}.
 *
 * @param o The current object, not used in this method.
 * @param q The Query object.
 * @return The value of this bind variable.
 * @throws QueryExecutionException If there is a problem getting the value.
 */
public Object evaluate (Object o,
			    Query  q)
	                    throws QueryExecutionException{

	return this.getValue (o,
			      q);

}","/**
 * Evaluates the value of this bind variable.  This is just a thin-wrapper around:
 * {@link #getValue(Object,Query)}.
 *
 * @param o The current object, not used in this method.
 * @param q The Query object.
 * @return The value of this bind variable.
 * @throws QueryExecutionException If there is a problem getting the value.
 */
public Object evaluate (Object o,
			    Query  q)
	                    throws QueryExecutionException 
{
	return getValue(o, q);
}	",1420,True
"/**
 * Return whether this comparator uses caching to improve performance.
 *
 * @return <code>true</code> if caching is on.
 * @throws IllegalStateException If the query has not yet been parsed or set.
 */
public boolean isCaching ()
	                     throws  IllegalStateException{

	if ((this.q == null)
	    ||
	    (!this.q.parsed ())
	   )
	{

	    throw new IllegalStateException (""Query has not yet been parsed."");

	}

	return this.c.isCaching ();

}","/**
 * Return whether this comparator uses caching to improve performance.
 *
 * @return <code>true</code> if caching is on.
 * @throws IllegalStateException If the query has not yet been parsed or set.
 */
public boolean isCaching ()
	                     throws  IllegalStateException 
{
	return false;
}	",1421,True
"/**
 * Get the content type for this data source.
 * <p>
 * We base the content type on the file extension of the file minus the
 * <b>zipExtension</b>, so if a file is called <b>myFile.txt.gz</b> and
 * the zip extension is <b>.gz</b> then we trim off the <b>.gz</b> and
 * then look for the ""real"" file extension, then determine the
 * appropriate content type and return it.
 * <br /><br />
 * You should note that the file <b>DOESN'T</b> have to have the
 * zipExtension for this method to work.
 * <br /><br />
 * If we don't have a specific file extension to use (see the
 * table of <a href=""#3"">content type to file extension mappings</a> for full details
 * of what this method returns.
 *
 * @return The content type based upon the file extension of the file, or 
 *         <b>application/octet-stream</b> if we don't recognise the file extension.
 */
public String getContentType (){

	String fName = this.file.getName ().toLowerCase ();

	// Strip off any gz file extension...
	if (fName.indexOf (this.zipExtension) != -1)
	{
	    
	    fName = fName.substring (0,
				     fName.indexOf (this.zipExtension));
	    
	}
	
	if (fName.endsWith ("".doc""))
	{
	    
	    return ""application/msword"";
	    
	}
	
	if (fName.endsWith ("".sdw""))
	{

	    return ""application/x-swriter"";

	}
	
	if (fName.endsWith ("".rtf""))
	{
	    
	    return ""text/rtf"";

	}

	if (fName.endsWith ("".html""))
	{
	    
	    return ""text/html"";

	}

	if (fName.endsWith ("".txt""))
	{

	    return ""text/plain"";

	}	

	return ""application/octet-stream"";

}","/**
 * Get the content type for this data source.
 * <p>
 * We base the content type on the file extension of the file minus the
 * <b>zipExtension</b>, so if a file is called <b>myFile.txt.gz</b> and
 * the zip extension is <b>.gz</b> then we trim off the <b>.gz</b> and
 * then look for the ""real"" file extension, then determine the
 * appropriate content type and return it.
 * <br /><br />
 * You should note that the file <b>DOESN'T</b> have to have the
 * zipExtension for this method to work.
 * <br /><br />
 * If we don't have a specific file extension to use (see the
 * table of <a href=""#3"">content type to file extension mappings</a> for full details
 * of what this method returns.
 *
 * @return The content type based upon the file extension of the file, or 
 *         <b>application/octet-stream</b> if we don't recognise the file extension.
 */
public String getContentType () 
{
    if (m_fileExtension == null)
    {
        return ""application/octet-stream"";
    }
    else
    {
        return (String) m_contentTypeMap.get(m_fileExtension);
    }
}   ",1424,True
"/**
 * Initialises this bind variable.
 * If the bind variable is ""anonymous"" then a name is gained for it from the
 * Query object.  If there is a value then it is gained from the Query object and
 * cached.  Also, if there is an accessor defined then it is inited where possible.
 *
 * @param q The Query object.
 * @throws QueryParseException If the bind variable cannot be inited.
 */
public void init (Query  q)
	              throws QueryParseException{

	if (this.anon)
	{

	    this.name = q.getAnonymousBindVariableName ();

	}

	String n = this.name.toLowerCase ();

	if ((n.startsWith (Query.GRPBY_OBJ_VAR_NAME))
	    ||
	    (n.startsWith (Query.GRPBY_OBJ_VAR_NAME_SYNONYM))
	   )
	{

        this.initForGroupByName (n,
                                 q);

	} else {

	    if (n.startsWith (BindVariable.SPECIAL_NAME_PREFIX))
	    {

		// Make sure it's valid.
		if (!BindVariable.SPECIAL_VAR_NAMES.containsKey (n))
		{

		    throw new QueryParseException (""Bind variable name: "" +
						   name +
						   "" is not valid, bind variable names starting with: "" +
						   BindVariable.SPECIAL_NAME_PREFIX + 
						   "" are reserved, and must be one of: "" +
						   BindVariable.SPECIAL_VAR_NAMES.keySet ());

		}

	    }

	}

	// See if we already have this bind variable set...
	this.val = q.getVariable (this.name);

	// See if we have a ""trailing"" accessor.
	if ((this.val != null)
	    &&
	    (this.acc != null)
	   )
	{

	    this.initGetter (this.val);

	    try
	    {

		this.val = this.get.getValue (this.val);

	    } catch (Exception e) {

		throw new QueryParseException (""Unable to get value from accessor: "" +
					       this.acc +
					       "" and class: "" + 
					       this.val.getClass ().getName () + 
					       "" from bind variable: "" + 
					       this.name,
					       e);

	    }

	}

	// See if we can init the getter... there are times when it 
	// is possible even if the bind variable isn't available yet.
	if ((this.acc != null)
	    &&
	    (this.get == null)
	   )
	{

	    // Not over keen on this method but it will do for now...
	    // It precludes the init occurring if we are working on java.lang.Object
	    // objects... but how many times will that happen?
	    Class c = q.getVariableClass (this.name);

	    if (!c.isInstance (new Object ()))
	    {

		// Init the getter.
		this.initGetter (c);

	    }

	}

}","/**
 * Initialises this bind variable.
 * If the bind variable is ""anonymous"" then a name is gained for it from the
 * Query object.  If there is a value then it is gained from the Query object and
 * cached.  Also, if there is an accessor defined then it is inited where possible.
 *
 * @param q The Query object.
 * @throws QueryParseException If the bind variable cannot be inited.
 */
public void init (Query  q)
	              throws QueryParseException 
{
    if (name == null) {
        name = q.getAnonymousVar();
    }
    if (value == null) {
        value = q.getVar(name);
    }
    if (accessor != null) {
        accessor.init(q, this);
    }
}	",1425,False
"/**
 * Gets the value of this bind variable.  
 *
 * @param o The current object.  Note that this variable isn't used in this method.
 * @param q The Query object.
 * @return The value.
 * @throws QueryExecutionException If something goes wrong during the accessing
 *                                 of the value.
 */
public Object getValue (Object o,
			    Query  q)
	                    throws QueryExecutionException{

	if (this.groupByVar)
	{

	    o = q.getGroupByVariable (this.groupByInd);

	} else {

	    o = q.getVariable (this.name);

	}

	if ((this.acc != null)
	    &&
	    (this.get == null)
	    &&
	    (o != null)
	   )
	{

	    // Unable to get the accessor...
	    this.initGetter (o);

	} 

	if (this.get != null)
	{

	    try
	    {

		o = this.get.getValue (o);

	    } catch (Exception e) {

		throw new QueryExecutionException (""Unable to get value for accessor: "" +
						   this.acc + 
						   "", class: "" + 
						   this.get.getBaseClass ().getName () + 
						   "" from bind variable: "" + 
						   this.name,
						   e);

	    }

	}

	return o;

}","/**
 * Gets the value of this bind variable.  
 *
 * @param o The current object.  Note that this variable isn't used in this method.
 * @param q The Query object.
 * @return The value.
 * @throws QueryExecutionException If something goes wrong during the accessing
 *                                 of the value.
 */
public Object getValue (Object o,
			    Query  q)
	                    throws QueryExecutionException 
{
    return q.getVariable (name);
}	",1426,True
"/**
 * Apply the WHERE clause of the statement to the {@link File} passed in.
 * If an exception is thrown by the execution of the WHERE clause the Query 
 * is marked as ""dirty"" and the where clause is no longer executed on the passed in 
 * files (since it is likely that the WHERE clause will fail for all File objects).  
 * You can get access to exception by using: {@link #getException()}.
 *
 * @param f The file to evaluate the WHERE on.
 * @return <code>true</code> if the WHERE clause evaluates to <code>true</code>.
 */
public boolean accept (File f){
	
	if (this.badQuery)
	{

	    return false;

	}

	try
	{

	    return this.q.getWhereClause ().isTrue (f,
						    this.q);

	} catch (Exception e) {

	    this.badQuery = true;

	    this.exp = e;

	}

	return false;

}","/**
 * Apply the WHERE clause of the statement to the {@link File} passed in.
 * If an exception is thrown by the execution of the WHERE clause the Query 
 * is marked as ""dirty"" and the where clause is no longer executed on the passed in 
 * files (since it is likely that the WHERE clause will fail for all File objects).  
 * You can get access to exception by using: {@link #getException()}.
 *
 * @param f The file to evaluate the WHERE on.
 * @return <code>true</code> if the WHERE clause evaluates to <code>true</code>.
 */
public boolean accept (File f) 
{
    if (where != null)
    {
        try
        {
            return where.accept (f);
        }
        catch (Exception e)
        {
            exception = e;
            dirty = true;
        }
    }
    return true;
}   ",1428,True
"/**
 * Return a string version of this expression.
 * Note: any formatting of the statement (such as line breaks) will be removed.
 *
 * @return A string version of the expression.  
 */
public String toString (){

	String pred = "" OR "";
	
	if (this.and)
	{

	    pred = "" AND "";

	}

	if (this.isBracketed ())
	{

	    return ""("" + this.left.toString () + pred + this.right.toString () + "")"";

	}

	return this.left.toString () + pred + this.right.toString ();

}","/**
 * Return a string version of this expression.
 * Note: any formatting of the statement (such as line breaks) will be removed.
 *
 * @return A string version of the expression.  
 */
public String toString () 
{
    String result = """";
    for (int i = 0; i < this.tokens.size(); i++)
    {
        result += this.tokens.get(i).toString();
    }
    return result;
}   ",1430,False
"/**
 * Create a new data source for the specified file.
 * <p>
 * We expect the file to have the file extension as given by <b>zipExtension</b>.
 * </p>
 *
 * @param f The File.
 * @param zipExtension The file extension for gzipped files.  Set to <code>null</code>
 *                     to use the default of <b>.gz</b>.
 */
public GZIPFileDataSource (File   f,
			       String zipExtension){

	this.file = f;

	if (zipExtension != null)
	{

	    this.zipExtension = zipExtension.toLowerCase ();

	}

}","/**
 * Create a new data source for the specified file.
 * <p>
 * We expect the file to have the file extension as given by <b>zipExtension</b>.
 * </p>
 *
 * @param f The File.
 * @param zipExtension The file extension for gzipped files.  Set to <code>null</code>
 *                     to use the default of <b>.gz</b>.
 */
public GZIPFileDataSource (File   f,
			       String zipExtension) 
{
    super(f, zipExtension);
}	",1433,True
"/**
 * Get the expected return type.
 * The exact class returned here is dependent (obviously) on what the bind variable
 * represents.  Wherever possible it attempts to get the most specific class for the
 * variable.  It is generally better to set the variables prior to executing the:
 * {@link Query#parse(String)} method to ensure that the correct class is returned here.
 *
 * @param q The Query object.
 * @return The return type class or <code>java.lang.Object.class</code> if the class
 *         cannot be determined.
 * @throws QueryParseException If the type cannot be determined.
 */
public Class getExpectedReturnType (Query  q)
	                                throws QueryParseException{

	if (this.get != null)
	{

	    return this.get.getType ();

	}

	if (this.val != null)
	{

	    return this.val.getClass ();

	}

	return q.getVariableClass (this.name);

}","/**
 * Get the expected return type.
 * The exact class returned here is dependent (obviously) on what the bind variable
 * represents.  Wherever possible it attempts to get the most specific class for the
 * variable.  It is generally better to set the variables prior to executing the:
 * {@link Query#parse(String)} method to ensure that the correct class is returned here.
 *
 * @param q The Query object.
 * @return The return type class or <code>java.lang.Object.class</code> if the class
 *         cannot be determined.
 * @throws QueryParseException If the type cannot be determined.
 */
public Class getExpectedReturnType (Query  q)
	                                throws QueryParseException 
{
    if (q.getBindVariableTypes().size() > 0)
    {
        return q.getBindVariableTypes().get(0);
    }
    else
    {
        return Object.class;
    }
}	",1438,True
"/**
 * Returns a string version of this expression.
 * Basically returns: true | false.
 *
 * @return A string version of this expression.
 */
public String toString (){

	if (this.isBracketed ())
	{

	    return ""("" + this.value.toString () + "")"";

	}

	return this.value.toString ();

}","/**
 * Returns a string version of this expression.
 * Basically returns: true | false.
 *
 * @return A string version of this expression.
 */
public String toString () 
{
    return Boolean.toString(value);
}   ",1439,True
"/**
 * Searches the subelements of this element for an XMLElement with the specified tag name.
 * @param name the name to search for
 * @return the first matching element or null if there are no matches
 */
public Element get(String name){
	for(Element e : elements)
		if(e.getName().equals(name))
			return e;
	
	return null;
}","/**
 * Searches the subelements of this element for an XMLElement with the specified tag name.
 * @param name the name to search for
 * @return the first matching element or null if there are no matches
 */
public Element get(String name) 
{
    for (Element e : elements)
    {
        if (e.getName().equals(name))
        {
            return e;
        }
    }
    return null;
}   ",1441,True
"//*********************instance methods**********************************
private void pause(){
         try
         {
            Thread.sleep((int)(crawlSpeed * 1000));
         }
            catch(Exception e)
            {
            }
      }","//*********************instance methods**********************************
private void pause() 
{
    try
    {
        Thread.sleep(1000);
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}   ",1442,False
"/**
 * Returns an ArrayList<Element> of all the elements that match the given name
 * @return a possibly empty ArrayList<Element> of matches
 */
public ArrayList<Element> getElements(String name){
	ArrayList<Element> res = new ArrayList<Element>();
	
	for(Element e : elements)
		if(e.getName().equals(name))
			res.add(e);
	
	return res;
}","/**
 * Returns an ArrayList<Element> of all the elements that match the given name
 * @return a possibly empty ArrayList<Element> of matches
 */
public ArrayList<Element> getElements(String name) 
{
    ArrayList<Element> matches = new ArrayList<Element>();
    for (Element e : elements)
    {
        if (e.getName().equals(name))
        {
            matches.add(e);
        }
    }
    return matches;
}   ",1443,True
"/**
 * Adds a child Element to the Element.
 * @param element the Element to add
 */
public void addElement(Element element){
	subObjects.add(element);
	elements.add(element);
}","/**
 * Adds a child Element to the Element.
 * @param element the Element to add
 */

public void addElement(Element element) 
{
    if (element != null)
    {
        if (elements == null)
        {
            elements = new ArrayList<Element>();
        }
        elements.add(element);
    }
}   ",1444,False
"//*************************constructors*************************************
public Turtle (double x, double y, double heading){
         xPos = x;
         yPos = y;
         this.heading = heading;
         turtleColor = Color.black;
         penIsDown = true;
         thickness = 3.0f;
      
         Turtle[] temp = new Turtle[list.length + 1];
         for(int z = 0; z < list.length; z++)
            temp[z] = list[z];
         temp[temp.length - 1] = this;
         list = temp;
      }","//*************************constructors*************************************

public Turtle (double x, double y, double heading) 
{
    this.x = x;
    this.y = y;
    this.heading = heading;
    this.isPenDown = true;
    this.penColor = Color.BLACK;
    this.penSize = 1;
}   ",1446,True
"/**
 * Sleeps the Thread for a period of time based on the current Display speed.
 */
public static void pause(){
	try {
		Thread.sleep(30 * (MAX_SPEED - speed + 1));
	}
	catch (InterruptedException e) {
		e.printStackTrace();
	}
}","/**
 * Sleeps the Thread for a period of time based on the current Display speed.
 */


public static void pause() 
{
    try
    {
        Thread.sleep((long) (1000 / Display.speed));
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}   ",1448,True
"//instance methods
private void pause(){
         try
         {
            Thread.sleep(100);
         }
            catch(Exception e)
            {
            }
      }","//instance methods
private void pause() 
{
    if (isPlaying)
    {
        isPlaying = false;
        player.pause();
    }
}   ",1449,True
"/**
 * Constructs an item with the specified x and y coordinates.
 */
public Item(int x, int y){
	this.x = x;
	this.y = y;
}","/**
 * Constructs an item with the specified x and y coordinates.
 */
public Item(int x, int y) 
{
    this.x = x;
    this.y = y;
}   ",1451,True
"//constructor (dynamic initializer - for dynamic fields)
public Bucket(int numGals){
         capacity = numGals;
         water = 0.0;
         jugList[numBuckets] = this;
         numBuckets++;
         if (capacity > maxCapacity)
            capacity = maxCapacity;
      }","//constructor (dynamic initializer - for dynamic fields)
public Bucket(int numGals) 
{
    this.numGals = numGals;
    gal = new Gal[numGals];
    for (int i = 0; i < numGals; i++)
    {
        gal[i] = new Gal();
    }
}   ",1452,True
"/**
 * Blocks the Thread until input is given to System.in.
 */
private static void hang(){ //A bit hacky, but it works
	try {
		System.in.read();
	}
	catch (Exception e) { }
}","/**
 * Blocks the Thread until input is given to System.in.
 */
private static void hang() 
{
    try
    {
        System.in.read();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1453,True
"/**
 * The same as calling WorldBackend.setSize(x, y)
 * @param x
 * @param y
 */
public static void setSize(int x, int y){
	if (WorldBackend.getCurrent() == null)
		openDefaultWorld();

	WorldBackend.getCurrent().setSize(x, y);
}","/**
 * The same as calling WorldBackend.setSize(x, y)
 * @param x
 * @param y
 */
public static void setSize(int x, int y) 
{
    WorldBackend.setSize(x, y);
}   ",1454,True
"/**
 * Takes a possible invalid direction and returns a valid one via modding
 * @param dir a possibly invalid direction
 * @return a valid direction
 */
public static int validateDirection(int dir){
	for (int i = 0; i < directions.length; i++)
		if (dir == directions[i])
			return dir;

	return ((dir % 4) + 4) % 4; //This is in case it's negative
}","/**
 * Takes a possible invalid direction and returns a valid one via modding
 * @param dir a possibly invalid direction
 * @return a valid direction
 */
public static int validateDirection(int dir) 
{
    int r = dir % 4;
    if (r < 0)
    {
        r += 4;
    }
    return r;
}   ",1456,True
"// all generated reports are cached until flush is called. This is typically
// called right before persisting stats to disk
public static void flushSerializerCache(){
	jsonCache = null;
	javascriptCache = null;
	xmlCache = null;
	htmlCache = null;
}","// all generated reports are cached until flush is called. This is typically
// called right before persisting stats to disk
public static void flushSerializerCache() 
{
    if (serializerCache != null)
    {
        for (ReportSerializer serializer : serializerCache.values())
        {
            serializer.flush();
        }
    }
}   ",1460,True
"// Return a player's total play time
public String getPlaytime(Player player){
	PlayerStatistics ps = getPlayerStats(player);
	return ps.getTotalPlaytime();
}","// Return a player's total play time
public String getPlaytime(Player player) 
{
    if (player == null)
    {
        return ""0"";
    }

    return String.valueOf(player.getTotalPlaytime());
}   ",1461,False
"//Note that the player killed something
public void kill(Player attacker, LivingEntity victim){
	if(ignorePlayer(attacker)) return;
	PlayerStatistics ps = getPlayerStats(attacker);
	
	if(victim.isPlayer()) {
		// Increment the correct player kill counter
		String victimName = victim.getPlayer().getName();
		if(!ps.playerKills.containsKey(victimName)) {
			ps.playerKills.put(victimName, 0L);
		}
		ps.playerKills.put(victimName, ps.playerKills.get(victimName) + 1);
	} else if(victim.isMob()) {
		String victimName = ""Mob""; //((Mob)victim).getName();
		if(!ps.creatureKills.containsKey(victimName)) {
			ps.creatureKills.put(victimName, 0L);
		}
		ps.creatureKills.put(victimName, ps.creatureKills.get(victimName) + 1);
	} else if(victim.isAnimal()) {
		String victimName = ""Animal""; //((Animal)victim).getName();
		if(!ps.creatureKills.containsKey(victimName)) {
			ps.creatureKills.put(victimName, 0L);
		}
		ps.creatureKills.put(victimName, ps.creatureKills.get(victimName) + 1);
	}
}","//Note that the player killed something
public void kill(Player attacker, LivingEntity victim) 
{
    if (victim instanceof Player)
    {
        Player playerVictim = (Player)victim;
        if (playerVictim.getHealth() - attacker.getDamage() <= 0)
        {
            attacker.setScore(attacker.getScore() + 1);
        }
    }
}   ",1462,False
"//Note that the player has placed a block
public void placeABlock(Player player, Block block){
	if (block.getType() > 0) {
		if(ignorePlayer(player)) return;
		PlayerStatistics ps = getPlayerStats(player);
		if (!ps.blocksPlaced.containsKey(block.getType())) {
			ps.blocksPlaced.put(block.getType(), 0L);
		}
		ps.blocksPlaced.put(block.getType(),
				ps.blocksPlaced.get(block.getType()) + 1);
	}
}","//Note that the player has placed a block
public void placeABlock(Player player, Block block) 
{
    if (player == null || block == null)
    {
        return;
    }
    if (player.getTeam() == Team.RED)
    {
        redBlocks.add(block);
    }
    else
    {
        blueBlocks.add(block);
    }
}   ",1463,False
"//Get raw player stats
public List<PlayerStatistics> getRawStats(){
	synchronized (stats) {
		//Copies references to the PlayerStats objects into a new array, preserving thread safety.
		return new ArrayList<PlayerStatistics>(stats.values());
	}
}","//Get raw player stats



public List<PlayerStatistics> getRawStats() 
{
    List<PlayerStatistics> stats = new ArrayList<PlayerStatistics>();
    for (Player p : players)
    {
        stats.add(p.getStats());
    }
    return stats;
}   ",1464,True
"// Utility methods
private String secondsToTimestamp(long seconds){
	long hours = seconds / 3600;
	seconds %= 3600;
	long minutes = seconds / 60;
	return String.format(""%s.%02d hours"", hours, (int)Math.floor(minutes/60.0*100.0));
}","// Utility methods
private String secondsToTimestamp(long seconds) 
{
    long hours = seconds / 3600;
    long minutes = (seconds % 3600) / 60;
    seconds = seconds % 60;

    return String.format(""%02d:%02d:%02d"", hours, minutes, seconds);
}   ",1465,True
"//Add total play time to the player's secondsOnServer
public void logOut(Player player){
	if(ignorePlayer(player)) return;
	PlayerStatistics ps = getPlayerStats(player);
	ps.flushSessionPlaytime();
	ps.sessionMarkTime = null;
}","//Add total play time to the player's secondsOnServer
public void logOut(Player player) 
{
    if (player != null)
    {
        player.setSecondsOnServer(player.getSecondsOnServer() + (System.currentTimeMillis() - player.getLoginTime()));
    }
}   ",1466,True
"//Logs out all players - called at shutdown
public void logOutAllPlayers(){
	synchronized(stats) {
		for(PlayerStatistics ps : stats.values()) {
			ps.flushSessionPlaytime();
			ps.sessionMarkTime = null;
		}
	}
}","//Logs out all players - called at shutdown



public void logOutAllPlayers() 
{
    for (Player player : Bukkit.getOnlinePlayers())
    {
        player.kickPlayer(""Server is shutting down!"");
    }
}   ",1469,False
"//called by the timer every few seconds
public void run(){
	saveStats();
	saveUserFiles();
}","//called by the timer every few seconds
public void run() 
{
    if (this.game.getGameState() == GameState.RUNNING)
    {
        this.game.update();
    }
}   ",1471,True
"//Resets all player playtimes to zero
public void resetAllPlaytimes(){
	synchronized(stats) {
		for(PlayerStatistics ps : stats.values()) {
			ps.secondsOnServer = 0;
		}
	}
}","//Resets all player playtimes to zero



public void resetAllPlaytimes() 
{
    for (Player p : Bukkit.getOnlinePlayers())
    {
        setPlaytime(p.getUniqueId(), 0);
    }
}   ",1473,False
"// Ignore players with no group if ignoreGrouplessPlayers is true.
private boolean ignorePlayer(Player player){
	if(config.getIgnoreGrouplessPlayers() && player.getGroups().length == 0 ) {
		return true;
	} else {
		return false;
	}
}","// Ignore players with no group if ignoreGrouplessPlayers is true.
private boolean ignorePlayer(Player player) 
{
    if (ignoreGrouplessPlayers)
    {
        if (player.getGroup() == null)
        {
            return true;
        }
    }
    return false;
}   ",1474,True
"/**
 * Sends a message to all players!
 * @param String - Message to send to all players.
 */
public void broadcast(String message){
	for (Player p : etc.getServer().getPlayerList()) {
		p.sendMessage(message);
	}
}","/**
 * Sends a message to all players!
 * @param String - Message to send to all players.
 */



public void broadcast(String message) 
{
    for (Player p : Bukkit.getOnlinePlayers())
    {
        p.sendMessage(message);
    }
}   ",1478,False
"//Note that the player disposed of an item
public void dropAnItem(Player player, Item item){ 
	if (item.getItemId() > 0) {
		if(ignorePlayer(player)) return;
		PlayerStatistics ps = getPlayerStats(player);
		if (!ps.itemsDropped.containsKey(item.getItemId())) {
			ps.itemsDropped.put(item.getItemId(), 0L);
		}
		ps.itemsDropped.put(item.getItemId(),
				ps.itemsDropped.get(item.getItemId()) + 1);
	}
}","//Note that the player disposed of an item
public void dropAnItem(Player player, Item item) 
{
    if(player != null)
    {
        player.getInventory().removeItem(item);
        player.getInventory().updateInventory(player);
    }
}   ",1479,True
"/**
 * Gets the value of the correlationKey property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the correlationKey property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getCorrelationKey().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link TCorrelationKey }
 * 
 * 
 */
public List<TCorrelationKey> getCorrelationKey(){
    if (correlationKey == null) {
        correlationKey = new ArrayList<TCorrelationKey>();
    }
    return this.correlationKey;
}","/**
 * Gets the value of the correlationKey property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the correlationKey property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getCorrelationKey().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link TCorrelationKey }
 * 
 * 
 */
public List<TCorrelationKey> getCorrelationKey() 
{
    if (correlationKey == null)
    {
        correlationKey = new ArrayList<TCorrelationKey>();
    }
    return this.correlationKey;
}   ",1480,True
"// ===================================================================================================== getFlowNode
static public TFlowNode getFlowNode(final String nodeId, TProcess tProcess){
    ElementIterator<TFlowNode> iterator = new ElementIterator<TFlowNode>(tProcess, TFlowNode.class);
    while (iterator.hasNext()) {
        TFlowNode node = iterator.next();
        if (node.getId().equals(nodeId)) {
            return node;
        }
    }
    return null;
}","// ===================================================================================================== getFlowNode
static public TFlowNode getFlowNode(final String nodeId, TProcess tProcess) 
{
    for (TFlowNode flowNode : tProcess.getFlowNode())
    {
        if (flowNode.getId().equals(nodeId))
        {
            return flowNode;
        }
    }
    return null;
}   ",1481,True
"/**
 * Gets the value of the completionQuantity property.
 * 
 * @return
 *     possible object is
 *     {@link BigInteger }
 *     
 */
public BigInteger getCompletionQuantity(){
    if (completionQuantity == null) {
        return new BigInteger(""1"");
    } else {
        return completionQuantity;
    }
}","/**
 * Gets the value of the completionQuantity property.
 * 
 * @return
 *     possible object is
 *     {@link BigInteger }
 *     
 */
public BigInteger getCompletionQuantity() 
{
    return completionQuantity;
}   ",1482,True
"/**
 * Gets the value of the loopType property.
 * 
 * @return
 *     possible object is
 *     {@link TChoreographyLoopType }
 *     
 */
public TChoreographyLoopType getLoopType(){
    if (loopType == null) {
        return TChoreographyLoopType.NONE;
    } else {
        return loopType;
    }
}","/**
 * Gets the value of the loopType property.
 * 
 * @return
 *     possible object is
 *     {@link TChoreographyLoopType }
 *     
 */
public TChoreographyLoopType getLoopType() 
{
    return loopType;
}   ",1485,True
"/**
 * Gets the value of the interfaceRef property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the interfaceRef property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getInterfaceRef().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link QName }
 * 
 * 
 */
public List<QName> getInterfaceRef(){
    if (interfaceRef == null) {
        interfaceRef = new ArrayList<QName>();
    }
    return this.interfaceRef;
}","/**
 * Gets the value of the interfaceRef property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the interfaceRef property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getInterfaceRef().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link QName }
 * 
 * 
 */
public List<QName> getInterfaceRef() 
{
    if (interfaceRef == null)
    {
        interfaceRef = new ArrayList<QName>();
    }
    return this.interfaceRef;
}   ",1487,True
"// ============================================================================================== findOutgoingByName
public static TSequenceFlow findOutgoingByName(TFlowNode fromNode, String name, TProcess tProcess){
    for (QName qName :  fromNode.getOutgoing()) {
        TSequenceFlow link = find(qName.getLocalPart(), tProcess, TSequenceFlow.class);
        String linkName = link.getName();
        if (linkName != null && !linkName.isEmpty() && linkName.equals(name)) {
            return link;
        }
    }
    return null;
}","// ============================================================================================== findOutgoingByName
public static TSequenceFlow findOutgoingByName(TFlowNode fromNode, String name, TProcess tProcess) 
{
    for (TSequenceFlow tSequenceFlow : tProcess.getSequenceFlow())
    {
        if (tSequenceFlow.getSourceRef().equals(fromNode.getId()) && tSequenceFlow.getName().equals(name))
        {
            return tSequenceFlow;
        }
    }
    return null;
}   ",1488,True
"/**
 * Gets the value of the isForCompensation property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public boolean isIsForCompensation(){
    if (isForCompensation == null) {
        return false;
    } else {
        return isForCompensation;
    }
}","/**
 * Gets the value of the isForCompensation property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public boolean isIsForCompensation() 
{
    if (isForCompensation == null)
    {
        return false;
    }
    else
    {
        return isForCompensation;
    }
}   ",1490,True
"/**
 * Gets the value of the property property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the property property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getProperty().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link TProperty }
 * 
 * 
 */
public List<TProperty> getProperty(){
    if (property == null) {
        property = new ArrayList<TProperty>();
    }
    return this.property;
}","/**
 * Gets the value of the property property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the property property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getProperty().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link TProperty }
 * 
 * 
 */
public List<TProperty> getProperty() 
{
    if (property == null)
    {
        property = new ArrayList<TProperty>();
    }
    return this.property;
}   ",1494,True
"/**
 * Gets the value of the isCollection property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public boolean isIsCollection(){
    if (isCollection == null) {
        return false;
    } else {
        return isCollection;
    }
}","/**
 * Gets the value of the isCollection property.
 * 
 * @return
 *     possible object is
 *     {@link Boolean }
 *     
 */
public boolean isIsCollection() 
{
    if (isCollection == null)
    {
        return false;
    }
    else
    {
        return isCollection;
    }
}   ",1495,True
"/**
 * Gets the value of the endPointRef property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the endPointRef property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getEndPointRef().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link QName }
 * 
 * 
 */
public List<QName> getEndPointRef(){
    if (endPointRef == null) {
        endPointRef = new ArrayList<QName>();
    }
    return this.endPointRef;
}","/**
 * Gets the value of the endPointRef property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the endPointRef property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getEndPointRef().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link QName }
 * 
 * 
 */

public List<QName> getEndPointRef() 
{
    if (endPointRef == null)
    {
        endPointRef = new ArrayList<QName>();
    }
    return this.endPointRef;
}   ",1497,True
"// ===================================================================================================== findElement
public static TBaseElement findElement(String id, TProcess tProcess){
    for (JAXBElement<? extends TFlowElement> element : tProcess.getFlowElement()) {
        if (element.getValue().getId().equals(id)) {
            return element.getValue();
        }
    }
    return null;
}","// ===================================================================================================== findElement
public static TBaseElement findElement(String id, TProcess tProcess) 
{
    TBaseElement element = null;
    if (tProcess != null)
    {
        element = tProcess.findElement(id);
    }
    return element;
}   ",1498,True
"/**
 * Modifica el tipo de documento con el nombre dado
 * @param tipoDocumento TipoDocumento con el nombre y la nueva descripción
 * @return -1 Si la operación no fue exitosa
 */
public int modificarTipoDocumento(TipoDocumento tipoDocumento){
    String sql_modificar;
    sql_modificar=""UPDATE tipo_material SET tipo_documento = '""+ 
            tipoDocumento.getTipoDocumento() + ""' WHERE descripcion = '""
            + tipoDocumento.getDescripcion() + ""';"";
    try{
        Connection conn= fachada.conectar();
        Statement sentencia = conn.createStatement();
        int numFilas = sentencia.executeUpdate(sql_modificar);
        conn.close();
        return numFilas;

    }
    catch(SQLException e){ System.err.println(e); }
    catch(Exception e){ System.err.println(e); }
    return -1;
}","/**
 * Modifica el tipo de documento con el nombre dado
 * @param tipoDocumento TipoDocumento con el nombre y la nueva descripción
 * @return -1 Si la operación no fue exitosa
 */

public int modificarTipoDocumento(TipoDocumento tipoDocumento) 
{
    if (tipoDocumento == null)
    {
        return -1;
    }

    try
    {
        em.getTransaction().begin();
        TipoDocumento tipoDocumentoBD = em.find(TipoDocumento.class, tipoDocumento.getId());
        tipoDocumentoBD.setNombre(tipoDocumento.getNombre());
        tipoDocumentoBD.setDescripcion(tipoDocumento.getDescripcion());
        em.getTransaction().commit();
    }
    catch (Exception e)
    {
        em.getTransaction().rollback();
        return -1;
    }

    return 0;
}   ",1500,False
"/**
 * Inicializa los ComboBox de áreas con las existentes en la base de datos
 */
private void initComboBox(){
    Areas.removeAllItems();
    Area_Padre.removeAllItems();
    areasExistentes= new ControladorArea().consultarTodasLasAreas();
    if(areasExistentes!=null){
        for(int i=0;i<areasExistentes.size();i++){
            Areas.insertItemAt(areasExistentes.get(i), i);
            Area_Padre.insertItemAt(areasExistentes.get(i), i);
        }
        Areas.setSelectedIndex(-1);
        Area_Padre.setSelectedIndex(-1);
    }
}","/**
 * Inicializa los ComboBox de áreas con las existentes en la base de datos
 */

private void initComboBox() 
{
    List<Area> areas = areaService.getAll();
    for (Area area : areas)
    {
        comboBoxArea.getItems().add(area);
    }
}   ",1507,False
"/**
 * Handler para el botón de agregar area, agrega un área a la base de datos
 * con los datos obtenidos de la interfaz, además reinicializa los Combobox
 * de área
 * @param evt ActionEvent (no se usa)
 */
private void Agregar_AreaActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_Agregar_AreaActionPerformed
    if(checkEmptyFieldsArea()){
        new ControladorArea().insertarArea(Area_Descripcion.getText().replaceAll(""[']"", ""`""), Area_Nombre.getText().replaceAll(""[']"", ""`""), (Area_Padre.getSelectedIndex()!=-1) ? ((Area)Area_Padre.getSelectedItem()).getID() : ""0"");
        JOptionPane.showMessageDialog(this, ""El el area con nombre ""+Area_Nombre.getText()+ "" ha sido agregado"", ""Notificación"", JOptionPane.INFORMATION_MESSAGE);
        Area_Nombre.setText("""");
        Area_Descripcion.setText("""");
        Area_Padre.setSelectedIndex(-1);
        Areas.setSelectedIndex(-1);
        initComboBox();
    }
}","/**
 * Handler para el botón de agregar area, agrega un área a la base de datos
 * con los datos obtenidos de la interfaz, además reinicializa los Combobox
 * de área
 * @param evt ActionEvent (no se usa)
 */


private void Agregar_AreaActionPerformed(java.awt.event.ActionEvent evt) 
{
    String nombre = txtNombre.getText();
    String descripcion = txtDescripcion.getText();
    if(nombre.equals("""") || descripcion.equals(""""))
    {
        JOptionPane.showMessageDialog(null, ""Debe llenar todos los campos"", ""Error"", JOptionPane.ERROR_MESSAGE);
    }
    else
    {
        Area area = new Area(nombre, descripcion);
        if(area.insertar())
        {
            JOptionPane.showMessageDialog(null, ""Área agregada correctamente"", ""Éxito"", JOptionPane.INFORMATION_MESSAGE);
            txtNombre.setText("""");
            txtDescripcion.setText("""");
            this.reiniciarCombobox();
        }
        else
        {
            JOptionPane.showMessageDialog(null, ""Error al agregar área"", ""Error"", JOptionPane.ERROR_MESSAGE);
        }
    }
}   ",1509,True
"/**
 * Elimina todas las áreas agregadas que están en el contenedor de áreas
 * seleccionadas y refresca el JTextArea de áreas
 * @param evt 
 */
private void CancelarActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_CancelarActionPerformed
    biblioteca.gui.GUICatalogacion.Areas_Guardadas=false;
    Cancelar.setEnabled(false);
    Agregar.setEnabled(true);
    Areas.setEnabled(true);
    areasSeleccionadas.clear();
    refreshAreas();
    Estado.setForeground(Color.red);
    Estado.setText(""[Sin Guardar]"");
}","/**
 * Elimina todas las áreas agregadas que están en el contenedor de áreas
 * seleccionadas y refresca el JTextArea de áreas
 * @param evt 
 */
private void CancelarActionPerformed(java.awt.event.ActionEvent evt) 
{
    int[] indices = ListaAreasSeleccionadas.getSelectedIndices();
    for (int i = indices.length - 1; i >= 0; i--)
    {
        AreasSeleccionadas.removeElementAt(indices[i]);
    }
    ActualizarAreas();
}   ",1511,True
"/**
 * Modifica un autor según su correo electronico
 * @param autor Autor con los datos a modificar y el correo
 * @return -1 si la consulta no fue exitosa
 */
public int modificarAutor(Autor autor){
    String sql_modificar;
    sql_modificar=""UPDATE autor  SET autor_correo = '""+autor.getCorreo()+""', nombre = '""+autor.getNombre()+""', apellido = '""+autor.getApellido()+""', acronimo = '""+autor.getAcronimo()+
             ""' WHERE autor_correo = '""+autor.getCorreo()+""';"";
    try{
        Connection conn= fachada.conectar();
        Statement sentencia = conn.createStatement();
        int numFilas = sentencia.executeUpdate(sql_modificar);
        conn.close();            
        return numFilas;
    }
    catch(SQLException e){ System.err.println(e); }

    return -1;
}","/**
 * Modifica un autor según su correo electronico
 * @param autor Autor con los datos a modificar y el correo
 * @return -1 si la consulta no fue exitosa
 */

public int modificarAutor(Autor autor) 
{
    int res = -1;
    try
    {
        PreparedStatement ps = con.prepareStatement(""UPDATE autor SET nombre = ?, nacionalidad = ? WHERE correo = ?"");
        ps.setString(1, autor.getNombre());
        ps.setString(2, autor.getNacionalidad());
        ps.setString(3, autor.getCorreo());
        res = ps.executeUpdate();
    }
    catch (SQLException e)
    {
        System.out.println(""Error al modificar autor: "" + e.getMessage());
    }
    return res;
}   ",1512,True
"/**
 * Finaliza el proceso de Seleccionar áreas y pasa a la siguiente interfaz
 * en el proceso de catalogación.
 * @param evt 
 */
private void SiguienteActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_SiguienteActionPerformed
    if(!areasSeleccionadas.isEmpty()){
        Estado.setForeground(Color.green);
        Estado.setText(""[Guardado]"");
        JTabbedPane parent =(JTabbedPane) this.getParent();
        parent.setSelectedIndex(3);
        Cancelar.setEnabled(true);
        Agregar.setEnabled(false);
        Areas.setEnabled(false);
        Areas.setSelectedIndex(-1);
        biblioteca.gui.GUICatalogacion.Areas_Guardadas=true;
    }
    else JOptionPane.showMessageDialog(this, ""Debe seleccionar al menos un area"", ""Error"", JOptionPane.ERROR_MESSAGE);
    
    
}","/**
 * Finaliza el proceso de Seleccionar áreas y pasa a la siguiente interfaz
 * en el proceso de catalogación.
 * @param evt 
 */

private void SiguienteActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (this.jListAreas.getSelectedIndex() != -1)
    {
        this.dispose();
        Catalogar catalogar = new Catalogar(this.jListAreas.getSelectedValue().toString());
        catalogar.setVisible(true);
    }
    else
    {
        JOptionPane.showMessageDialog(null, ""Debe seleccionar un área"", ""Error"", JOptionPane.ERROR_MESSAGE);
    }
}   ",1513,False
"/**
 * Dado un resultSet obtenido de una consulta, esta función convierte los datos
 * internos de este en una tabla que puede ser insertada en un Document de iText
 * esta PdfPTable tiene en su primera linea los nombres de las columnas del ResultSet
 * @param entrada ResultSet El resultado de una consulta a la base de datos
 * @return una PdfPTable para insertar en un documento de iText
 * @see com.itextpdf.text.pdf.PdfPTable;
 * @see java.sql.ResultSet;
 */
static public PdfPTable resultSetToTable(ResultSet entrada){
    PdfPTable salida = null;
    try{
        ResultSetMetaData rsmd = entrada.getMetaData();
    
        salida = new PdfPTable(rsmd.getColumnCount());
        for(int i=1;i<=rsmd.getColumnCount();i++){
            salida.addCell(rsmd.getColumnName(i));
        }
        salida.setHeaderRows(1);
        while(entrada.next()){
            for(int i=1;i<=rsmd.getColumnCount();i++){
                salida.addCell(entrada.getString(i));
            }
        }
    }catch(java.sql.SQLException sqlex){
        System.err.println(sqlex);
    }
    return salida;
}","/**
 * Dado un resultSet obtenido de una consulta, esta función convierte los datos
 * internos de este en una tabla que puede ser insertada en un Document de iText
 * esta PdfPTable tiene en su primera linea los nombres de las columnas del ResultSet
 * @param entrada ResultSet El resultado de una consulta a la base de datos
 * @return una PdfPTable para insertar en un documento de iText
 * @see com.itextpdf.text.pdf.PdfPTable;
 * @see java.sql.ResultSet;
 */




static public PdfPTable resultSetToTable(ResultSet entrada) 
{
    PdfPTable salida = new PdfPTable(1);
    try
    {
        ResultSetMetaData rsmd = entrada.getMetaData();
        int numCols = rsmd.getColumnCount();
        Vector<String> nombresColumnas = new Vector<String>();
        for (int i = 1; i <= numCols; i++)
        {
            nombresColumnas.add(rsmd.getColumnName(i));
        }
        salida = new PdfPTable(nombresColumnas.size());
        for (String nombreColumna : nombresColumnas)
        {
            salida.addCell(nombreColumna);
        }
        while (entrada.next())
        {
            for (String nombreColumna : nombresColumnas)
            {
                salida.addCell(entrada.getString(nombreColumna));
            }
        }
    }
    catch (SQLException e)
    {
        e.printStackTrace();
    }
    return salida;
}   ",1514,True
"/**
 * Esta función convierte un arrayList en una PdfPTable y, agrega una columna
 * de estadisticas a esta. Funcionará si el arrayList tiene en su ultima columna
 * numeros
 * @param entrada Matriz con los datos estadisticos de la base de datos
 * @param total La suma de todos los datos de la ultima columna
 * @param rows El numero de columnas que se mostrarán en la PdfPTable
 * @return PdfPTable Contiene los datos del ArrayList más los porcentajes.
 */
static public PdfPTable arrayListToStatisticTable(ArrayList<ArrayList<String>> entrada, int total, int rows){
    PdfPTable salida = null;
    
    salida = new PdfPTable(entrada.get(0).size() +1);
    for(int i=0;i<entrada.get(0).size();i++){
        salida.addCell(entrada.get(0).get(i));
    }
    salida.addCell(""Porcentaje"");
    salida.setHeaderRows(1);
    int counter=0;
    for(int j=1;j<entrada.size()&&counter<rows;j++){
        for(int i=0;i<entrada.get(j).size();i++){
            salida.addCell(entrada.get(j).get(i));
            if(i==entrada.get(j).size()-1){
                int porcentaje=(int) (Integer.parseInt(entrada.get(j).get(i))*100)/total;
                salida.addCell(porcentaje+""%"");
            }
        }
        counter++;
    }
    if(entrada.size()-1>rows){
        int otros=0, otrospor;
        for(int i=counter;i<entrada.size();i++){
            otros+=Integer.parseInt(entrada.get(i).get(entrada.get(i).size()-1));
        }
        otrospor=otros*100;
        otrospor/=total;
        salida.addCell(""-"");
        salida.addCell(""Otros"");
        salida.addCell(otros+"""");
        salida.addCell(otrospor+""%"");
    }
    return salida;
}","/**
 * Esta función convierte un arrayList en una PdfPTable y, agrega una columna
 * de estadisticas a esta. Funcionará si el arrayList tiene en su ultima columna
 * numeros
 * @param entrada Matriz con los datos estadisticos de la base de datos
 * @param total La suma de todos los datos de la ultima columna
 * @param rows El numero de columnas que se mostrarán en la PdfPTable
 * @return PdfPTable Contiene los datos del ArrayList más los porcentajes.
 */
static public PdfPTable arrayListToStatisticTable(ArrayList<ArrayList<String>> entrada, int total, int rows) 
{
    PdfPTable table = new PdfPTable(rows+1);
    for(int i=0; i<entrada.size(); i++)
    {
        for(int j=0; j<entrada.get(i).size(); j++)
        {
            if(j<rows)
            {
                table.addCell(entrada.get(i).get(j));
            }
            else if(j==rows)
            {
                table.addCell(String.valueOf(Math.round((Float.parseFloat(entrada.get(i).get(j))/total)*100))+""%"");
            }
        }
    }
    return table;
}   ",1515,True
"/**
 * Refresca el JTextArea que contiene los nombres de las áreas que están
 * actualmente agregadas al contenedor de áreas seleccionadas
 */
private void refreshAreas(){
    String texto="""";
    for(int i=0;i<areasSeleccionadas.size();i++){
        texto+=areasSeleccionadas.get(i).toString();
        if(i!=(areasSeleccionadas.size()-1))
            texto+=""\n"";
    }
    Areas_Agregadas.setText(texto);
}","/**
 * Refresca el JTextArea que contiene los nombres de las áreas que están
 * actualmente agregadas al contenedor de áreas seleccionadas
 */
private void refreshAreas() 
{
    String areas = """";
    for (String area : areasSeleccionadas)
    {
        areas += area + ""\n"";
    }
    areasTextArea.setText(areas);
}   ",1516,False
"/**
 * Consulta el tipo de documento según el nombre dado
 * @param nombre String con el nombre del tipo de documento a consultar
 * @return TipoDocumento con los datos relacionados
 */
public TipoDocumento consultarTipoDocumento(String nombre){
    String sql_consultar;
    sql_consultar=""SELECT * FROM  tipo_material WHERE tipo_documento = '"" +
            nombre + ""';"";
    try{
        Connection conn= fachada.conectar();
        Statement sentencia = conn.createStatement();
        ResultSet tabla = sentencia.executeQuery(sql_consultar);
        
        TipoDocumento tipoDocumento=null;
        if(tabla.next()){
            tipoDocumento.setTipoDocumento(tabla.getString(1));
            tipoDocumento.setDescripcion(tabla.getString(2));
        }
        conn.close();
        return tipoDocumento;

    }
    catch(SQLException e){ System.err.println(e); }
    catch(Exception e){ System.err.println(e); }
    return null;
}","/**
 * Consulta el tipo de documento según el nombre dado
 * @param nombre String con el nombre del tipo de documento a consultar
 * @return TipoDocumento con los datos relacionados
 */
public TipoDocumento consultarTipoDocumento(String nombre) 
{
    TipoDocumento tipoDocumento = null;
    try
    {
        tipoDocumento = tipoDocumentoDao.consultarTipoDocumento(nombre);
    }
    catch(Exception e)
    {
        System.out.println(e.getMessage());
    }
    return tipoDocumento;
}   ",1519,False
"/**
 * Parses a general information line
 * 
 * @param line
 */
private void parseGeneralLine(String line){
    String[] result = line.split(""="");
    if (result.length == 2) {
        String key = result[0].trim();
        String value = result[1].trim();
        if (key.toLowerCase().contains(VERSION_TOKEN)) {
            generalData.setVersion(Integer.parseInt(value));
        }
        if (key.toLowerCase().contains(RELOAD_TOKEN)) {
            generalData.setReload(Integer.parseInt(value));
        }
        if (key.toLowerCase().contains(UPDATE_TOKEN)) {
            generalData.setLastUpdate(value);
        }
        if (key.toLowerCase().contains(CONNECTED_CLIENTS_TOKEN)) {
            generalData.setConnectedClients(Integer.parseInt(value));
        }
        if (key.toLowerCase().contains(ATIS_ALLOW_MIN_TOKEN)) {
            generalData.setAtisAllowMin(Integer.parseInt(value));
        }
    }
}","/**
 * Parses a general information line
 * 
 * @param line
 */
private void parseGeneralLine(String line) 
{
    String[] parts = line.split("":"");

    if (parts.length == 2)
    {
        String key = parts[0].trim();
        String value = parts[1].trim();

        if (key.equalsIgnoreCase(""name""))
        {
            this.setName(value);
        }
        else if (key.equalsIgnoreCase(""description""))
        {
            this.setDescription(value);
        }
    }
}   ",1520,False
"/**
 * @return a list of airports which are crawled from flight schedules of pilots
 */
private ArrayList<VatsimAirport> generateAirportList(){
    ArrayList<VatsimAirport> airports = new ArrayList<VatsimAirport>();
    for (VatsimPilot pilot : pilots) {
        if (pilot.getFlightplanInfo().getDepartureAirport() != null) {
            if (airports.contains(pilot.getFlightplanInfo().getDepartureAirport()) == false) {
                airports.add(pilot.getFlightplanInfo().getDepartureAirport());
            }
        }
        if (pilot.getFlightplanInfo().getDestinationAirport() != null) {
            if (airports.contains(pilot.getFlightplanInfo().getDestinationAirport()) == false) {
                airports.add(pilot.getFlightplanInfo().getDestinationAirport());
            }
        }
    }
    return airports;
}","/**
 * @return a list of airports which are crawled from flight schedules of pilots
 */
private ArrayList<VatsimAirport> generateAirportList() 
{
    ArrayList<VatsimAirport> airportList = new ArrayList<VatsimAirport>();
    for (VatsimAirport airport : airportList)
    {
        airportList.add(airport);
    }
    return airportList;
}   ",1529,False
"/**
 * update all clients, if all data are available
 */
private void updateDataListeners(){
    if (allDataAvailable()) {
        for (VatsimDataUpdate client : listeners) {
            if (client != null) {
                client.update(pilots, servers, controllers, airports);
            }
        }
    }
}","/**
 * update all clients, if all data are available
 */
private void updateDataListeners() 
{
    if (dataAvailable)
    {
        for (DataListener listener : dataListeners)
        {
            listener.updateData();
        }
    }
}   ",1530,False
"/**
 * Parses a file received from the source url and calls {$link {@link #processLine(String)} for
 * a specific entity.
 */
protected void parse(){
    InputStream input = null;
    int currentProgress = 0;
    int totalProgress = 0;
    try {
        if (source == null) {
            processLine(ERROR_TOKEN);
            return;
        }
        URLConnection urlConnection = new URL(source).openConnection();
        totalProgress = urlConnection.getContentLength();
        input = urlConnection.getInputStream();
        BufferedReader r = new BufferedReader(new InputStreamReader(input));
        String line;
        int sendProgressFlag = 0;
        while ((line = r.readLine()) != null) {
            sendProgressFlag++;
            currentProgress += line.length();
            processLine(line);
            if (sendProgressFlag % 20 == 0) {
                progress.updateProgress((int) ((currentProgress / (float) totalProgress) * 100), progressState);
            }
        }
        processLine(END_TOKEN);
    } catch (MalformedURLException e) {
        processLine(ERROR_TOKEN);
    } catch (IOException e) {
        processLine(ERROR_TOKEN);
    }
}","/**
 * Parses a file received from the source url and calls {$link {@link #processLine(String)} for
 * a specific entity.
 */




protected void parse() 
{
    try
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(sourceUrl.openStream()));
        String line;
        while ((line = reader.readLine()) != null)
        {
            processLine(line);
        }
        reader.close();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1535,True
"/**
 * JDK1.5-replacement of {@link Arrays#copyOf(char[], int)}
 */
public static State[] copyOf(State[] original, int newLength){
	State[] copy = new State[newLength];
	System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
	return copy;
}","/**
 * JDK1.5-replacement of {@link Arrays#copyOf(char[], int)}
 */
public static State[] copyOf(State[] original, int newLength) 
{
    State[] copy = new State[newLength];
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}   ",1541,True
"/** 
 * Returns the set of reachable accept states. 
 * @return set of {@link State} objects
 */
public Set<State> getAcceptStates(){
	expandSingleton();
	HashSet<State> accepts = new HashSet<State>();
	HashSet<State> visited = new HashSet<State>();
	LinkedList<State> worklist = new LinkedList<State>();
	worklist.add(initial);
	visited.add(initial);
	while (worklist.size() > 0) {
		State s = worklist.removeFirst();
		if (s.accept)
			accepts.add(s);
		for (Transition t : s.transitions)
			if (!visited.contains(t.to)) {
				visited.add(t.to);
				worklist.add(t.to);
			}
	}
	return accepts;
}","/** 
 * Returns the set of reachable accept states. 
 * @return set of {@link State} objects
 */
public Set<State> getAcceptStates() 
{
    return acceptStates;
}   ",1543,False
"/**
 * Compute the hash code of the <i>current</i> status of this state.
 */
@Override
public int hashCode(){
	int hash = is_final ? 1 : 0;

	hash ^= hash * 31 + this.labels.length;
	for (char c : this.labels)
		hash ^= hash * 31 + c;

	/*
	 * Compare the right-language of this state using reference-identity of
	 * outgoing states. This is possible because states are interned (stored
	 * in registry) and traversed in post-order, so any outgoing transitions
	 * are already interned.
	 */
	for (State s : this.states) {
		hash ^= System.identityHashCode(s);
	}

	return hash;
}","/**
 * Compute the hash code of the <i>current</i> status of this state.
 */
@Override
public int hashCode() 
{
    int result = 1;
    result = prime * result + ((current == null) ? 0 : current.hashCode());
    return result;
}   ",1544,True
"/**
 * See {@link MinimizationOperations#minimize(Automaton)}.
 * Returns the automaton being given as argument.
 */
public static Automaton minimize(Automaton a){
	a.minimize();
	return a;
}","/**
 * See {@link MinimizationOperations#minimize(Automaton)}.
 * Returns the automaton being given as argument.
 */
public static Automaton minimize(Automaton a) 
{
    if (a.isDeterministic())
        return minimizeDeterministic(a);
    else
        return minimizeNonDeterministic(a);
}   ",1545,True
"/**
 * Build a minimal, deterministic automaton from a sorted list of strings.
 */
public static dk.brics.automaton.State build(CharSequence[] input){
	final StringUnionOperations builder = new StringUnionOperations(); 

	for (CharSequence chs : input)
		builder.add(chs);

	return convert(builder.complete(), new IdentityHashMap<State, dk.brics.automaton.State>());
}","/**
 * Build a minimal, deterministic automaton from a sorted list of strings.
 */
public static dk.brics.automaton.State build(CharSequence[] input) 
{
    dk.brics.automaton.State s = new dk.brics.automaton.State();
    for (CharSequence ch : input) {
        s = addString(s, ch);
    }
    return s;
}   ",1546,True
"/**
 * Sets or resets allow mutate flag.
 * If this flag is set, then all automata operations may modify automata given as input;
 * otherwise, operations will always leave input automata languages unmodified. 
 * By default, the flag is not set.
 * @param flag if true, the flag is set
 * @return previous value of the flag
 */
static public boolean setAllowMutate(boolean flag){
	boolean b = allow_mutation;
	allow_mutation = flag;
	return b;
}","/**
 * Sets or resets allow mutate flag.
 * If this flag is set, then all automata operations may modify automata given as input;
 * otherwise, operations will always leave input automata languages unmodified. 
 * By default, the flag is not set.
 * @param flag if true, the flag is set
 * @return previous value of the flag
 */
static public boolean setAllowMutate(boolean flag) 
{
	boolean old = allowMutate;
	allowMutate = flag;
	return old;
}   ",1554,True
"/** 
 * Returns the set of states that are reachable from the initial state.
 * @return set of {@link State} objects
 */
public Set<State> getStates(){
	expandSingleton();
	Set<State> visited;
	if (isDebug())
		visited = new LinkedHashSet<State>();
	else
		visited = new HashSet<State>();
	LinkedList<State> worklist = new LinkedList<State>();
	worklist.add(initial);
	visited.add(initial);
	while (worklist.size() > 0) {
		State s = worklist.removeFirst();
		Collection<Transition> tr;
		if (isDebug())
			tr = s.getSortedTransitions(false);
		else
			tr = s.transitions;
		for (Transition t : tr)
			if (!visited.contains(t.to)) {
				visited.add(t.to);
				worklist.add(t.to);
			}
	}
	return visited;
}","/** 
 * Returns the set of states that are reachable from the initial state.
 * @return set of {@link State} objects
 */
public Set<State> getStates() 
{
    return states;
}   ",1555,False
"/** 
 * Returns the set of live states. A state is ""live"" if an accept state is reachable from it. 
 * @return set of {@link State} objects
 */
public Set<State> getLiveStates(){
	expandSingleton();
	return getLiveStates(getStates());
}","/** 
 * Returns the set of live states. A state is ""live"" if an accept state is reachable from it. 
 * @return set of {@link State} objects
 */
public Set<State> getLiveStates() 
{
    Set<State> liveStates = new HashSet<State>();
    for (State state : getStates())
    {
        if (isAcceptState(state))
        {
            if (state.isReachableFrom(state))
            {
                liveStates.add(state);
            }
        }
    }
    return liveStates;
}   ",1556,True
"/**
 * Retrieves a serialized <code>Automaton</code> from a stream.
 * @param stream input stream with serialized automaton
 * @exception IOException if input/output related exception occurs
 * @exception OptionalDataException if the data is not a serialized object
 * @exception InvalidClassException if the class serial number does not match
 * @exception ClassCastException if the data is not a serialized <code>Automaton</code>
 * @exception ClassNotFoundException if the class of the serialized object cannot be found
 */
public static Automaton load(InputStream stream) throws IOException, OptionalDataException, ClassCastException, 
                                                        ClassNotFoundException, InvalidClassException{
	ObjectInputStream s = new ObjectInputStream(stream);
	return (Automaton)s.readObject();
}","/**
 * Retrieves a serialized <code>Automaton</code> from a stream.
 * @param stream input stream with serialized automaton
 * @exception IOException if input/output related exception occurs
 * @exception OptionalDataException if the data is not a serialized object
 * @exception InvalidClassException if the class serial number does not match
 * @exception ClassCastException if the data is not a serialized <code>Automaton</code>
 * @exception ClassNotFoundException if the class of the serialized object cannot be found
 */

public static Automaton load(InputStream stream) throws IOException, OptionalDataException, ClassCastException, 
                                                        ClassNotFoundException, InvalidClassException 
{
    ObjectInputStream ois = new ObjectInputStream(stream);
    return (Automaton) ois.readObject();
}   ",1558,True
"/** Allows to replace the renderer. */
public void setRenderer(AbstractEntityRenderer renderer){
	this.renderer = renderer;
	repaint();
}","/** Allows to replace the renderer. */
public void setRenderer(AbstractEntityRenderer renderer) 
{
    if (renderer == null)
    {
        throw new IllegalArgumentException(""Renderer cannot be null"");
    }
    this.renderer = renderer;
}   ",1560,True
"/**
 * Provides the true width of the screen to the transformer. This is
 * necessary to get correct scale values.
 * 
 * @param cm
 *            Screen width in centimeters.
 */
public void setScreenWidthInCentimeter(double cm){
	double dotsPerCm = Toolkit.getDefaultToolkit().getScreenSize()
			.getWidth()
			/ cm;
	transformer.setScreenResolution((int) (dotsPerCm * 2.54));
}","/**
 * Provides the true width of the screen to the transformer. This is
 * necessary to get correct scale values.
 * 
 * @param cm
 *            Screen width in centimeters.
 */
public void setScreenWidthInCentimeter(double cm) 
{
    this.screenWidthInCentimeter = cm;
}   ",1562,True
"/**
 * 
 * @param problem
 * @param frontier
 * @return if goal found, the list of actions to the Goal. If already at the
 *         goal you will receive a List with a single NoOp Action in it. If
 *         fail to find the Goal, an empty list will be returned to indicate
 *         that the search failed.
 */
public List<Action> search(Problem problem, Queue<Node> frontier){
	this.frontier = frontier;

	clearInstrumentation();
	// initialize the frontier using the initial state of the problem
	Node root = new Node(problem.getInitialState());
	if (isCheckGoalBeforeAddingToFrontier()) {
		if (SearchUtils.isGoalState(problem, root)) {
			return SearchUtils.actionsFromNodes(root.getPathFromRoot());
		}
	}
	frontier.insert(root);
	setQueueSize(frontier.size());
	while (!(frontier.isEmpty()) && !CancelableThread.currIsCanceled()) {
		// choose a leaf node and remove it from the frontier
		Node nodeToExpand = popNodeFromFrontier();
		setQueueSize(frontier.size());
		// Only need to check the nodeToExpand if have not already
		// checked before adding to the frontier
		if (!isCheckGoalBeforeAddingToFrontier()) {
			// if the node contains a goal state then return the
			// corresponding solution
			if (SearchUtils.isGoalState(problem, nodeToExpand)) {
				setPathCost(nodeToExpand.getPathCost());
				return SearchUtils.actionsFromNodes(nodeToExpand
						.getPathFromRoot());
			}
		}
		// expand the chosen node, adding the resulting nodes to the
		// frontier
		for (Node fn : getResultingNodesToAddToFrontier(nodeToExpand,
				problem)) {
			if (isCheckGoalBeforeAddingToFrontier()) {
				if (SearchUtils.isGoalState(problem, fn)) {
					setPathCost(fn.getPathCost());
					return SearchUtils.actionsFromNodes(fn
							.getPathFromRoot());
				}
			}
			frontier.insert(fn);
		}
		setQueueSize(frontier.size());
	}
	// if the frontier is empty then return failure
	return failure();
}","/**
 * 
 * @param problem
 * @param frontier
 * @return if goal found, the list of actions to the Goal. If already at the
 *         goal you will receive a List with a single NoOp Action in it. If
 *         fail to find the Goal, an empty list will be returned to indicate
 *         that the search failed.
 */
public List<Action> search(Problem problem, Queue<Node> frontier) 
{
    frontier.clear();
    frontier.add(new Node(problem.getInitialState()));
    while (!frontier.isEmpty())
    {
        Node node = frontier.poll();
        if (problem.isGoalState(node.state))
        {
            return node.getActionSequence();
        }
        frontier.addAll(expand(node, problem));
    }
    return new ArrayList<>();
}   ",1564,False
"/**
 * Informs all interested listener about view events such as mouse events
 * and data changes.
 */
public void fireMapViewEvent(MapViewEvent e){
	for (MapViewEventListener listener : eventListeners)
		listener.eventHappened(e);
}","/**
 * Informs all interested listener about view events such as mouse events
 * and data changes.
 */
public void fireMapViewEvent(MapViewEvent e) 
{
    for (int i = 0; i < listeners.size(); i++)
    {
        MapViewListener listener = (MapViewListener) listeners.get(i);
        listener.handleMapViewEvent(e);
    }
}   ",1565,True
"//
// PROTECTED METHODS
//
@Override
protected boolean isValidMatch(Term toMatch,
		Set<Variable> toMatchVariables, Term possibleMatch,
		Map<Variable, Term> substitution){

	if (possibleMatch != null && substitution != null) {
		// Note:
		// [Brand 1975] showed that paramodulation into
		// variables is unnecessary.
		if (!(possibleMatch instanceof Variable)) {
			// TODO: Find out whether the following statement from:
			// http://www.cs.miami.edu/~geoff/Courses/CSC648-07F/Content/
			// Paramodulation.shtml
			// is actually the case, as it was not positive but
			// intuitively makes sense:
			// ""Similarly, depending on how paramodulation is used, it is
			// often unnecessary to paramodulate from variables.""
			// if (!(toMatch instanceof Variable)) {
			return true;
			// }
		}
	}
	return false;
}","//
// PROTECTED METHODS
//
@Override
protected boolean isValidMatch(Term toMatch,
		Set<Variable> toMatchVariables, Term possibleMatch,
		Map<Variable, Term> substitution) 
{
	if (toMatchVariables.contains(possibleMatch))
	{
		return true;
	}
	return false;
}	",1567,False
"/**
 * Returns the world coordinates, which are currently shown in the center.
 */
public Position getCenterPosition(){
	float lat = transformer.lat(getHeight() / 2);
	float lon = transformer.lon(getWidth() / 2);
	return new Position(lat, lon);
}","/**
 * Returns the world coordinates, which are currently shown in the center.
 */
public Position getCenterPosition() 
{
    return new Position(getCenterX(), getCenterY());
}   ",1568,True
"/**
 * A contrapositive of a chain is a permutation in which a different literal
 * is placed at the front. The contrapositives of a chain are logically
 * equivalent to the original chain.
 * 
 * @return a list of contrapositives for this chain.
 */
public List<Chain> getContrapositives(){
	List<Chain> contrapositives = new ArrayList<Chain>();
	List<Literal> lits = new ArrayList<Literal>();

	for (int i = 1; i < literals.size(); i++) {
		lits.clear();
		lits.add(literals.get(i));
		lits.addAll(literals.subList(0, i));
		lits.addAll(literals.subList(i + 1, literals.size()));
		Chain cont = new Chain(lits);
		cont.setProofStep(new ProofStepChainContrapositive(cont, this));
		contrapositives.add(cont);
	}

	return contrapositives;
}","/**
 * A contrapositive of a chain is a permutation in which a different literal
 * is placed at the front. The contrapositives of a chain are logically
 * equivalent to the original chain.
 * 
 * @return a list of contrapositives for this chain.
 */

public List<Chain> getContrapositives() 
{
    List<Chain> contrapositives = new ArrayList<Chain>();
    for (int i = 0; i < literals.length; i++)
    {
        Literal[] newLiterals = new Literal[literals.length];
        for (int j = 0; j < literals.length; j++)
        {
            newLiterals[j] = literals[(i + j) % literals.length];
        }
        contrapositives.add(new Chain(newLiterals));
    }
    return contrapositives;
}   ",1569,True
"/**
 * Writes all data from <code>mapData</code> to file.
 */
@Override
public void writeMap(File file, OsmMap mapData, BoundingBox bb){
	try  {
		OutputStream os = new BufferedOutputStream
		(new FileOutputStream(file));
		if (compressorClass != null && file.getName().endsWith("".bz2"")) {
			Constructor<?> c = compressorClass.getConstructor
			(new Class[] {OutputStream.class});
			os = (OutputStream) c.newInstance(os);
		}
		OutputStreamWriter writer = new OutputStreamWriter(os, ""UTF-8"");
		writeMap(writer, mapData, bb);
	} catch (FileNotFoundException e) {
		LOG.warning(""File does not exist "" + file);
	} catch (InvocationTargetException e) {
		LOG.warning(""The map could not be read. Possibly unpacking problem. "" + e);
	} catch (Exception e) {
		LOG.warning(""The map could not be read. "" + e);
	}
}","/**
 * Writes all data from <code>mapData</code> to file.
 */


@Override
public void writeMap(File file, OsmMap mapData, BoundingBox bb) 
{
    try
    {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file)))
        {
            writer.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
            writer.write(""<osm version=\""0.6\"" generator=\""OpenStreetMap server\"">\n"");

            for (Node node : mapData.getNodes())
            {
                writer.write(node.toXML());
            }

            for (Way way : mapData.getWays())
            {
                writer.write(way.toXML());
            }

            writer.write(""</osm>\n"");
        }
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1571,True
"/**
 * Provides the true size of the screen to the transformer. This is
 * necessary to get correct scale values.
 * 
 * @param inch
 *            Screen size in inch.
 */
public void setScreenSizeInInch(double inch){
	double width = Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	double height = Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	double dotsPerInch = Math.sqrt(width * width + height * height) / inch;
	transformer.setScreenResolution((int) dotsPerInch);
}","/**
 * Provides the true size of the screen to the transformer. This is
 * necessary to get correct scale values.
 * 
 * @param inch
 *            Screen size in inch.
 */
public void setScreenSizeInInch(double inch) 
{
    if (inch <= 0)
    {
        throw new IllegalArgumentException(""Screen size must be greater than zero."");
    }
    this.screenSizeInInch = inch;
}   ",1573,True
"//
// START-LightestClauseHeuristic
public Clause getLightestClause(){
	Clause lightest = null;

	if (sos.size() > 0) {
		lightest = sos.first();
	}

	return lightest;
}","//
// START-LightestClauseHeuristic
public Clause getLightestClause() 
{
    int min = Integer.MAX_VALUE;
    Clause lightestClause = null;
    for (Clause clause : clauses)
    {
        if (clause.size() < min)
        {
            min = clause.size();
            lightestClause = clause;
        }
    }
    return lightestClause;
}   ",1574,True
"/** Returns a bounding box describing the currently visible area. */
public BoundingBox getBoundingBox(){
	float latMin = transformer.lat(getHeight());
	float lonMin = transformer.lon(0);
	float latMax = transformer.lat(0);
	float lonMax = transformer.lon(getWidth());
	return new BoundingBox(latMin, lonMin, latMax, lonMax);
}","/** Returns a bounding box describing the currently visible area. */
public BoundingBox getBoundingBox() 
{
    final int x = getScrollX();
    final int y = getScrollY();
    final int width = getWidth();
    final int height = getHeight();

    return new BoundingBox(x, y, width, height);
}   ",1575,True
"/**
 * Multiples the current scale with the specified factor and adjusts the
 * view so that the objects shown at the specified view focus keep at their
 * position.
 */
public void zoom(float factor, int focusX, int focusY){
	transformer.zoom(factor, focusX, focusY);
	repaint();
	fireMapViewEvent(new MapViewEvent(this, MapViewEvent.Type.ZOOM));
}","/**
 * Multiples the current scale with the specified factor and adjusts the
 * view so that the objects shown at the specified view focus keep at their
 * position.
 */
public void zoom(float factor, int focusX, int focusY) 
{
    float oldScale = mScale;
    mScale *= factor;

    focusX = (int) (focusX / oldScale * mScale);
    focusY = (int) (focusY / oldScale * mScale);

    ensureVisible(focusX, focusY);
}   ",1576,False
"// Note: Based on:
// http://logic.stanford.edu/classes/cs157/2008/lectures/lecture15.pdf
// Slide 31.
@Test
public void testSimpleExample(){
	FOLDomain domain = new FOLDomain();
	domain.addConstant(""A"");
	domain.addConstant(""B"");
	domain.addPredicate(""P"");
	domain.addPredicate(""Q"");
	domain.addPredicate(""R"");
	domain.addFunction(""F"");

	FOLParser parser = new FOLParser(domain);

	List<Literal> lits = new ArrayList<Literal>();
	AtomicSentence a1 = (AtomicSentence) parser.parse(""P(F(x,B),x)"");
	AtomicSentence a2 = (AtomicSentence) parser.parse(""Q(x)"");
	lits.add(new Literal(a1));
	lits.add(new Literal(a2));

	Clause c1 = new Clause(lits);

	lits.clear();
	a1 = (AtomicSentence) parser.parse(""F(A,y) = y"");
	a2 = (AtomicSentence) parser.parse(""R(y)"");
	lits.add(new Literal(a1));
	lits.add(new Literal(a2));

	Clause c2 = new Clause(lits);

	Set<Clause> paras = paramodulation.apply(c1, c2);
	Assert.assertEquals(2, paras.size());

	Iterator<Clause> it = paras.iterator();
	Assert.assertEquals(""[P(B,A), Q(A), R(B)]"", it.next().toString());
	Assert.assertEquals(""[P(F(A,F(x,B)),x), Q(x), R(F(x,B))]"", it.next()
			.toString());
}","// Note: Based on:
// http://logic.stanford.edu/classes/cs157/2008/lectures/lecture15.pdf
// Slide 31.
@Test
public void testSimpleExample() 
{
    final String[] input =
    {
        ""A B C D"",
        ""A B C E"",
        ""A B D E"",
        ""B C D E"",
        ""A C D E""
    };

    final String[] expected =
    {
        ""A B C D E""
    };

    final String[][] result = Apriori.apriori(input, 0.5);
    assertArrayEquals(expected, result[1]);
}   ",1578,False
"/**
 * Decodes (aka ""deserializes"") a vector of ints read from a XDR stream.
 *
 * @return Decoded int vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final int [] xdrDecodeIntVector()
       throws OncRpcException, IOException{
    int length = xdrDecodeInt();
    int [] value = new int[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeInt();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of ints read from a XDR stream.
 *
 * @return Decoded int vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */

public final int [] xdrDecodeIntVector()
       throws OncRpcException, IOException 
{
    int [] value = null;
    int len = xdr_decode_int();

    if (len > 0) {
        value = new int [len];
        for (int i = 0; i < len; i++) {
            value[i] = xdr_decode_int();
        }
    }

    return value;
}      ",1581,True
"/**
 * Decodes (aka ""deserializes"") a string read from a XDR stream.
 * If a character encoding has been set for this stream, then this
 * will be used for conversion.
 *
 * @return Decoded String value.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final String xdrDecodeString()
       throws OncRpcException, IOException{
    int length = xdrDecodeInt();
    if ( length > 0 ) {
        byte [] bytes = new byte[length];
        xdrDecodeOpaque(bytes, 0, length);
        return (characterEncoding != null) ?
        	     new String(bytes, characterEncoding) :
        	     new String(bytes);
    } else {
        return new String();
    }
}","/**
 * Decodes (aka ""deserializes"") a string read from a XDR stream.
 * If a character encoding has been set for this stream, then this
 * will be used for conversion.
 *
 * @return Decoded String value.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final String xdrDecodeString()
       throws OncRpcException, IOException 
{
    return xdrDecodeString(XdrDecodingStream.ENCODING_DEFAULT);
}      ",1584,True
"/**
 * Configuration request: Enable/disable robot motion.
 * <br><br>
 * To enable or disable the planner, send a PLAYER_PLANNER_REQ_ENABLE
 * request. When disabled, the planner will stop the robot. When
 * enabled, the planner should resume plan execution. Null response.
 * <br><br>
 * See the player_planner_enable_req structure from player.h
 * @param state 1 to enable, 0 to disable
 */
public void setRobotMotion (int state){
    try {
        sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLANNER_REQ_ENABLE, 4);
        XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);
        xdr.beginEncoding (null, 0);
        xdr.xdrEncodeByte ((byte)state);
        xdr.endEncoding ();
        os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());
        xdr.close ();
        os.flush ();
    } catch (IOException e) {
        throw new PlayerException
            (""[Planner] : Couldn't request PLAYER_PLANNER_REQ_ENABLE: "" +
                    e.toString(), e);
    } catch (OncRpcException e) {
        throw new PlayerException
            (""[Planner] : Error while XDR-encoding ENABLE request: "" +
                    e.toString(), e);
    }
}","/**
 * Configuration request: Enable/disable robot motion.
 * <br><br>
 * To enable or disable the planner, send a PLAYER_PLANNER_REQ_ENABLE
 * request. When disabled, the planner will stop the robot. When
 * enabled, the planner should resume plan execution. Null response.
 * <br><br>
 * See the player_planner_enable_req structure from player.h
 * @param state 1 to enable, 0 to disable
 */
public void setRobotMotion (int state) 
{
    PlayerPlannerReqEnable req = new PlayerPlannerReqEnable();
    req.setState(state);
    sendRequest(req);
}   ",1585,True
"/**
 * Calculate and return the controller's command for the controlled system.
 * @param currentOutput the current output of the system
 * @return the new calculated command for the system
 */
public double getCommand (double currentOutput){
	this.currE = this.goal - currentOutput;
    eSum += currE;

    lastE = currE;
    double Pgain = this.kp * currE;
    double Igain = this.ki * eSum;

    return Pgain + Igain;
}","/**
 * Calculate and return the controller's command for the controlled system.
 * @param currentOutput the current output of the system
 * @return the new calculated command for the system
 */
public double getCommand (double currentOutput) 
{
    double error = setPoint - currentOutput;
    double command = kp * error;
    return command;
}   ",1586,True
"/**
 * Sends a new goal to the planner interface.
 * @param goal a PlayerPose structure containing the goal location (X, Y, A)
 */
public void setGoal (PlayerPose goal){
    try {
        sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_PLANNER_CMD_GOAL, 24);
        XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (24);
        xdr.beginEncoding (null, 0);
        xdr.xdrEncodeDouble (goal.getPx ());
        xdr.xdrEncodeDouble (goal.getPy ());
        xdr.xdrEncodeDouble (goal.getPa ());
        xdr.endEncoding ();
        os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());
        xdr.close ();
        os.flush ();
    } catch (IOException e) {
        throw new PlayerException
            (""[Planner] : Couldn't send new goals command: "" +
                    e.toString(), e);
    } catch (OncRpcException e) {
        throw new PlayerException
            (""[Planner] : Error while XDR-encoding goals command: "" +
                    e.toString(), e);
    }
}","/**
 * Sends a new goal to the planner interface.
 * @param goal a PlayerPose structure containing the goal location (X, Y, A)
 */
public void setGoal (PlayerPose goal) 
{
    if (goal == null)
    {
        return;
    }
    else
    {
        plannerInterface.setGoal(goal);
    }
}   ",1588,False
"/**
 * Decodes (aka ""deserializes"") a vector of longs read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded long vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final long [] xdrDecodeLongFixedVector(int length)
       throws OncRpcException, IOException{
    long [] value = new long[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeLong();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of longs read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded long vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final long [] xdrDecodeLongFixedVector(int length)
       throws OncRpcException, IOException 
{
    long [] vector = new long [length];

    for (int i = 0; i < length; i++) {
        vector [i] = xdrDecodeLong();
    }

    return vector;
}      ",1589,True
"/**
 * Check if waypoint data is available.
 * @return true if ready, false if not ready
 */
public synchronized boolean isReadyWaypointData (){
    if (readyPpWaypoints) {
        readyPpWaypoints = false;
        return true;
    }
    return false;
}","/**
 * Check if waypoint data is available.
 * @return true if ready, false if not ready
 */
public synchronized boolean isReadyWaypointData () 
{
    if (waypointData == null)
    {
        return false;
    }
    return true;
}   ",1590,True
"/**
 * Decodes (aka ""deserializes"") a vector of ints read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded int vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final int [] xdrDecodeIntFixedVector(int length)
       throws OncRpcException, IOException{
    int [] value = new int[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeInt();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of ints read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded int vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final int [] xdrDecodeIntFixedVector(int length)
       throws OncRpcException, IOException 
{
    int [] vector = new int [length];

    for (int i = 0; i < length; i++) {
        vector [i] = xdrDecodeInt();
    }

    return vector;
}      ",1592,True
"/**
 * Handle acknowledgement response messages
 * @param header Player header
 */
public void handleResponse (PlayerMsgHdr header){
    switch (header.getSubtype ()) {
        case PLAYER_RFID_REQ_POWER: {
            // null response
            break;
        }
        case PLAYER_RFID_REQ_READTAG: {
            // null response
            break;
        }
        case PLAYER_RFID_REQ_WRITETAG: {
            // null response
            break;
        }
        case PLAYER_RFID_REQ_LOCKTAG: {
            // null response
            break;
        }
        default:{
            if (isDebugging)
                logger.log (Level.FINEST, ""[RFID][Debug] : "" +
                        ""Unexpected response "" + header.getSubtype () + 
                        "" of size = "" + header.getSize ());
            break;
        }
    }
}","/**
 * Handle acknowledgement response messages
 * @param header Player header
 */
public void handleResponse (PlayerMsgHdr header) 
{
    if (header.getMsgType() == PlayerMsgHdr.MSGTYPE_ACK)
    {
        // Handle acknowledgement response
        handleAckResponse(header);
    }
    else
    {
        // Handle other types of responses
        handleOtherResponse(header);
    }
}   ",1594,True
"/**
 * Decodes (aka ""deserializes"") a vector of booleans read from a XDR stream.
 *
 * @return Decoded boolean vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final boolean [] xdrDecodeBooleanVector()
       throws OncRpcException, IOException{
    int length = xdrDecodeInt();
    boolean [] value = new boolean[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeBoolean();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of booleans read from a XDR stream.
 *
 * @return Decoded boolean vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final boolean [] xdrDecodeBooleanVector()
       throws OncRpcException, IOException 
{
    int len = xdrDecodeInt();
    boolean [] v = new boolean[len];
    for (int i = 0; i < len; i++) {
        v[i] = xdrDecodeBoolean();
    }
    return v;
}      ",1595,True
"/**
 * Decodes (aka ""deserializes"") a vector of doubles read from a XDR stream.
 *
 * @return Decoded double vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final double [] xdrDecodeDoubleVector()
       throws OncRpcException, IOException{
    int length = xdrDecodeInt();
    double [] value = new double[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeDouble();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of doubles read from a XDR stream.
 *
 * @return Decoded double vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final double [] xdrDecodeDoubleVector()
       throws OncRpcException, IOException 
{
    int size = xdrDecodeInt();
    double [] vector = new double [size];

    for (int i = 0; i < size; i++) {
        vector [i] = xdrDecodeDouble();
    }

    return vector;
}      ",1596,True
"/**
 * Decodes (aka ""deserializes"") a vector of booleans read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded boolean vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final boolean [] xdrDecodeBooleanFixedVector(int length)
       throws OncRpcException, IOException{
    boolean [] value = new boolean[length];
    for ( int i = 0; i < length; ++i ) {
        value[i] = xdrDecodeBoolean();
    }
    return value;
}","/**
 * Decodes (aka ""deserializes"") a vector of booleans read from a XDR stream.
 *
 * @param length of vector to read.
 *
 * @return Decoded boolean vector.
 *
 * @throws OncRpcException if an ONC/RPC error occurs.
 * @throws IOException if an I/O error occurs.
 */
public final boolean [] xdrDecodeBooleanFixedVector(int length)
       throws OncRpcException, IOException 
{
    boolean [] vector = new boolean[length];

    for (int i = 0; i < length; i++) {
        vector[i] = xdrDecodeBoolean();
    }

    return vector;
}      ",1599,True
"/**
 * turn the recorder off
 */
public void turnOff(){
    if (records != null)
    {
        records.clear();
    }

    on = false;
    currentRecord = null;
    currentKey = null;
    state = NOT_RECORDING;
}","/**
 * turn the recorder off
 */
public void turnOff() 
{
    if (recorder != null)
    {
        recorder.stop();
        recorder.release();
        recorder = null;
    }
}   ",1600,True
"/**
 * parse the command string into a MoveRobber message
 *
 * @param s   the String to parse
 * @return    a TextMsg message, or null of the data is garbled
 */
public static MoveRobber parseDataStr(String s){
    String na; // name of the game
    int pn; // player number
    int co; // coordinates

    StringTokenizer st = new StringTokenizer(s, sep2);

    try
    {
        na = st.nextToken();
        pn = Integer.parseInt(st.nextToken());
        co = Integer.parseInt(st.nextToken());
    }
    catch (Exception e)
    {
        return null;
    }

    return new MoveRobber(na, pn, co);
}","/**
 * parse the command string into a MoveRobber message
 *
 * @param s   the String to parse
 * @return    a TextMsg message, or null of the data is garbled
 */
public static MoveRobber parseDataStr(String s) 
{
    String[] parts = s.split("" "");
    if (parts.length == 2)
    {
        try
        {
            int player = Integer.parseInt(parts[0]);
            int tile = Integer.parseInt(parts[1]);
            return new MoveRobber(player, tile);
        }
        catch (NumberFormatException e)
        {
            return null;
        }
    }
    return null;
}   ",1602,True
"/**
 * Start recording the current plan information
 *
 * @param key  the key to use to index this recording
 */
public void startRecording(Object key){
    state = RECORDING;
    currentKey = key;
    currentRecord = new Vector();
}","/**
 * Start recording the current plan information
 *
 * @param key  the key to use to index this recording
 */
public void startRecording(Object key) 
{
    if (key == null)
    {
        throw new IllegalArgumentException(""key cannot be null"");
    }

    if (isRecording())
    {
        throw new IllegalStateException(""Recording is already in progress"");
    }

    recordingKey = key;
    recording = new ArrayList<>();
}   ",1603,True
"/**
 * Add a string to the current record
 *
 * @param s  the string to add
 */
public void record(String s){
    if (state == RECORDING)
    {
        currentRecord.addElement(s);
    }
}","/**
 * Add a string to the current record
 *
 * @param s  the string to add
 */
public void record(String s) 
{
    if (currentRecord == null)
    {
        currentRecord = new Record();
        records.add(currentRecord);
    }
    currentRecord.add(s);
}   ",1608,True
"/**
 * Parse the command String array into a PlayerStats message.
 * Calls {@link #PlayerStats(String, int[])} constructor,
 * see its javadoc for parameter details.
 *
 * @param pa   the parameters; length 2 or more required.
 * @return    a PlayerStats message, or null if parsing errors
 */
public static PlayerStats parseDataStr(String[] pa){
    if ((pa == null) || (pa.length < 2))
        return null;
    try
    {
        String ga = pa[0];
        int[] ipa = new int[pa.length - 1];
        for (int i = 0; i < ipa.length; ++i)
            ipa[i] = Integer.parseInt(pa[i+1]);
        return new PlayerStats(ga, ipa);
    } catch (Throwable e)
    {
        return null;
    }
}","/**
 * Parse the command String array into a PlayerStats message.
 * Calls {@link #PlayerStats(String, int[])} constructor,
 * see its javadoc for parameter details.
 *
 * @param pa   the parameters; length 2 or more required.
 * @return    a PlayerStats message, or null if parsing errors
 */
public static PlayerStats parseDataStr(String[] pa) 
{
    int[] data = new int[pa.length - 1];
    for (int i = 1; i < pa.length; i++)
    {
        try
        {
            data[i - 1] = Integer.parseInt(pa[i]);
        }
        catch (NumberFormatException e)
        {
            return null;
        }
    }
    return new PlayerStats(pa[0], data);
}   ",1609,True
"/**
 * stop recording and store the vector in the table
 */
public void stopRecording(){
    state = NOT_RECORDING;

    if ((currentKey != null) && (currentRecord != null))
    {
        records.put(currentKey, currentRecord);
    }
}","/**
 * stop recording and store the vector in the table
 */
public void stopRecording() 
{
    if (recorder != null)
    {
        recorder.stop();
        recorder = null;
    }
}   ",1610,True
"/**
 * add a threat to the list
 *
 * @param piece
 */
public void addThreat(PossiblePiece piece){
    if (!threats.contains(piece))
    {
        threats.addElement(piece);
    }
}","/**
 * add a threat to the list
 *
 * @param piece
 */
public void addThreat(PossiblePiece piece) 
{
    if (threats == null)
    {
        threats = new ArrayList<PossiblePiece>();
    }
    threats.add(piece);
}   ",1612,True
"/**
 * create a MoveRobber message
 *
 * @param na  name of the game
 * @param pn  player number
 * @param co  coordinates
 */
public MoveRobber(String na, int pn, int co){
    messageType = MOVEROBBER;
    game = na;
    playerNumber = pn;
    coordinates = co;
}","/**
 * create a MoveRobber message
 *
 * @param na  name of the game
 * @param pn  player number
 * @param co  coordinates
 */
public MoveRobber(String na, int pn, int co) 
{
    message = new String(""MoveRobber"");
    name = na;
    playerNumber = pn;
    coordinates = co;
}   ",1613,True
"/**
 * @return a human readable form of this object
 */
public String toString(){
    String s = ""PossiblePiece:type="" + pieceType + ""|player="" + player + ""|coord="" + Integer.toHexString(coord);

    return s;
}","/**
 * @return a human readable form of this object
 */
public String toString() 
{
    return ""ID: "" + id + "" Name: "" + name + "" Age: "" + age;
}   ",1615,False
"/**
 * Create a DiscardRequest message.
 *
 * @param ga  the name of the game
 * @param nd  the number of discards
 */
public DiscardRequest(String ga, int nd){
    messageType = DISCARDREQUEST;
    game = ga;
    numDiscards = nd;
}","/**
 * Create a DiscardRequest message.
 *
 * @param ga  the name of the game
 * @param nd  the number of discards
 */
public DiscardRequest(String ga, int nd) 
{
    gameName = ga;
    numDiscards = nd;
}   ",1618,True
"/**
 * update the eta for this piece
 *
 * @param e  the new eta
 */
public void setETA(int e){
    eta = e;
    updated = true;
}","/**
 * update the eta for this piece
 *
 * @param e  the new eta
 */
public void setETA(int e) 
{
    if (e < 0)
    {
        eta = 0;
    }
    else
    {
        eta = e;
    }
}   ",1619,True
"// runs iterations of the E-M algorithm to learn the model
public double run(int iters){
	double ll = -1;
	
	for (int iter=0; iter < iters; ++iter) {
		// -- E-step ---
		zero(wk); ll = 0;
		for (int i=0; i < k; ++i) {
			double max = Double.MIN_VALUE;
			for (int j=0; j < N; ++j) {
				w[i][j] = gaussian(X[j], u[i], s[i]) * p[i];
				wk[j] += w[i][j];
				if (w[i][j] > max) max = w[i][j];
			}
			ll += Math.log(max);
		}
		for (int j=0; j < N; ++j) {
			for (int i=0; i < k; ++i) {
				w[i][j] /= wk[j];
			}
		}
		
		// -- M-step ---
		
		// compute new means and class probabilities
		zero(ws); zero(u); zero(s); zero(p);
		for (int i=0; i < k; ++i) {
			for (int j=0; j < N; ++j) {
				u[i] += w[i][j] * X[j];
				ws[i] += w[i][j];
			}
		}
		for (int i=0; i < k; ++i) {
			u[i] /= ws[i];
			p[i] = ws[i] / N;
		}
		
		// compute new variance
		for (int i=0; i < k; ++i) {
			for (int j=0; j < N; ++j) {
				s[i] += w[i][j] * (X[j] - u[i]) * (X[j] - u[i]);
			}
		}
		for (int i=0; i < k; ++i) {
			s[i] = s[i] / ws[i];
		}
	}
	update(); // recalculate measures and densities
	return loglik;
}","// runs iterations of the E-M algorithm to learn the model
public double run(int iters) 
{
    double loglikelihood = 0;
    for (int i = 0; i < iters; i++)
    {
        loglikelihood = EMstep();
    }
    return loglikelihood;
}   ",1622,False
"/**
 * Read in an array of numbers.
 */
public static double[] read(String file){
	ArrayList<Double> list = new ArrayList<Double>();
	try {
		BufferedReader br = new BufferedReader(new FileReader(file));
		String line;
		
		while ((line=br.readLine()) != null) {
			double x = Double.parseDouble(line);
			list.add(x);
		}
	} catch (Exception e) {
		e.printStackTrace();
	}
	double[] a = new double[list.size()];
	for (int i=0; i<list.size(); ++i) {
		a[i] = list.get(i);
	}
	return a;
}","/**
 * Read in an array of numbers.
 */
public static double[] read(String file) 
{
    In in = new In(file);
    double[] a = in.readAllDoubles();
    return a;
}   ",1623,False
"/**
 * Set the size of the Display.
 * @param d the dimensions of the Display in pixels
 * @see java.awt.Component#setSize(java.awt.Dimension)
 */
public void setSize(Dimension d){
	_offscreen = null;
    setPreferredSize(d);
    super.setSize(d);
}","/**
 * Set the size of the Display.
 * @param d the dimensions of the Display in pixels
 * @see java.awt.Component#setSize(java.awt.Dimension)
 */
public void setSize(Dimension d) 
{
    if (d != null)
    {
        this.width = d.width;
        this.height = d.height;
    }
}   ",1624,False
"// switch to radix sort?
@SuppressWarnings(""unchecked"")
public static List<GroupItem> preprocess(List<Item> items){
	List<GroupItem> list = (List<GroupItem>)Objects.List.get();
	int len = items.size();
	for (int i=0; i<len; ++i) {
		GroupItem g = (GroupItem) items.get(i);
		if (g != null) list.add(g);
	}
	if (len > 1) {
		Collections.sort(list, _depthCmp);
	}
	return list;
}","// switch to radix sort?

@SuppressWarnings(""unchecked"")
public static List<GroupItem> preprocess(List<Item> items) 
{
    List<GroupItem> groupItems = new ArrayList<>();
    for (Item item : items)
    {
        GroupItem groupItem = new GroupItem(item);
        groupItems.add(groupItem);
    }
    return groupItems;
}   ",1625,True
"// updates measures after optimization iterations
private void update(){
	loglik = loglik(X,u,s,p);
	aic = 2*(3*k-1) - 2*loglik;
	bic = (3*k-1)*Math.log(N) - 2*loglik;
	density(0, 1, 0.001, densities);
}","// updates measures after optimization iterations
private void update() 
{
    for (int i = 0; i < this.measures.size(); i++)
    {
        this.measures.get(i).update();
    }
}   ",1626,False
"/**
 * Convex hull helper method for detecting a non left turn about 3 points
 */
private static boolean isNonLeft(int i0, int i1, int i2, int i3, double[] pts){
    double x, y, l1, l2, l4, l5, l6, angle1, angle2;
    
    y = pts[i2+1]-pts[i1+1]; x = pts[i2]-pts[i1]; l1 = x*x + y*y;
    y = pts[i3+1]-pts[i2+1]; x = pts[i3]-pts[i2]; l2 = x*x + y*y;
    y = pts[i3+1]-pts[i0+1]; x = pts[i3]-pts[i0]; l4 = x*x + y*y;
    y = pts[i1+1]-pts[i0+1]; x = pts[i1]-pts[i0]; l5 = x*x + y*y;
    y = pts[i2+1]-pts[i0+1]; x = pts[i2]-pts[i0]; l6 = x*x + y*y;

    angle1 = Math.acos((l2+l6-l4) / (2*Math.sqrt(l2*l6)) );
    angle2 = Math.acos((l6+l1-l5) / (2*Math.sqrt(l6*l1)) );
    return ((Math.PI-angle1) - angle2) <= 0.0;
}","/**
 * Convex hull helper method for detecting a non left turn about 3 points
 */
private static boolean isNonLeft(int i0, int i1, int i2, int i3, double[] pts) 
{
    double x0 = pts[i0];
    double y0 = pts[i0+1];
    double x1 = pts[i1];
    double y1 = pts[i1+1];
    double x2 = pts[i2];
    double y2 = pts[i2+1];
    double x3 = pts[i3];
    double y3 = pts[i3+1];
    double dx0 = x1 - x0;
    double dy0 = y1 - y0;
    double dx1 = x3 - x2;
    double dy1 = y3 - y2;
    double zcrossproduct = dx0 * dy1 - dy0 * dx1;
    return zcrossproduct < 0;
}   ",1631,True
"/**
     * Set the size of the Display.
     * @param width the width of the Display in pixels
     * @param height the height of the Display in pixels
     * @see java.awt.Component#setSize(int, int)
     */
public void setSize(int width, int height){
    	_offscreen = null;
        setPreferredSize(new Dimension(width, height));
        super.setSize(width, height);
    }","/**
     * Set the size of the Display.
     * @param width the width of the Display in pixels
     * @param height the height of the Display in pixels
     * @see java.awt.Component#setSize(int, int)
     */
public void setSize(int width, int height) 
{
    if (width < 0 || height < 0)
    {
        throw new IllegalArgumentException(""Invalid size: "" + width + ""x"" + height);
    }

    if (width != this.width || height != this.height)
    {
        this.width = width;
        this.height = height;
        resize();
    }
}    ",1634,True
"/**
	 * Draws a cubic Bezier curve.
	 * @param g the graphics context to draw with
	 * @param ax x-coordinate of the starting point
	 * @param ay y-coordinate of the starting point
	 * @param bx x-coordinate of the first control point
	 * @param by y-coordinate of the first control point
	 * @param cx x-coordinate of the second control point
	 * @param cy y-coordinate of the second control point
	 * @param dx x-coordinate of the ending point
	 * @param dy y-coordinate of the ending point
	 * @param includeFirst if true the first point will be included
	 * @param vc callback to collect vertex values
	 */
public static int cubic(double ax, double ay,
		double bx, double by, double cx, double cy, double dx, double dy,
		boolean includeFirst, VertexCallback vc){
		int subdiv;
		double u, xx, yy;			
		
		// determine number of line segments
//		subdiv = (int)((
//			Math.sqrt((xx=(bx-ax))*xx + (yy=(by-ay))*yy) +
//			Math.sqrt((xx=(cx-bx))*xx + (yy=(cy-by))*yy) +
//			Math.sqrt((xx=(dx-cx))*xx + (yy=(dy-cy))*yy)) / 4);
//		if (subdiv < 1) subdiv = 1;
		subdiv = 30;

		// compute Bezier co-efficients
		double c3x = 3 * (bx - ax);
    double c2x = 3 * (cx - bx) - c3x;
    double c1x = dx - ax - c3x - c2x;
    double c3y = 3 * (by - ay);
    double c2y = 3 * (cy - by) - c3y;
    double c1y = dy - ay - c3y - c2y;
		
		if (includeFirst) vc.vertex(ax, ay);
		for (int i=0; i<=subdiv; ++i) {
			u = i/subdiv;
			xx = u*(c3x + u*(c2x + u*c1x)) + ax;
			yy = u*(c3y + u*(c2y + u*c1y)) + ay;
			vc.vertex(xx, yy);
		}
		return subdiv + (includeFirst ? 2 : 1);
	}","/**
	 * Draws a cubic Bezier curve.
	 * @param g the graphics context to draw with
	 * @param ax x-coordinate of the starting point
	 * @param ay y-coordinate of the starting point
	 * @param bx x-coordinate of the first control point
	 * @param by y-coordinate of the first control point
	 * @param cx x-coordinate of the second control point
	 * @param cy y-coordinate of the second control point
	 * @param dx x-coordinate of the ending point
	 * @param dy y-coordinate of the ending point
	 * @param includeFirst if true the first point will be included
	 * @param vc callback to collect vertex values
	 */
public static int cubic(double ax, double ay,
		double bx, double by, double cx, double cy, double dx, double dy,
		boolean includeFirst, VertexCallback vc) 
{
	if (includeFirst)
	{
		vc.vertex(ax, ay);
	}
	return cubic(ax, ay, bx, by, cx, cy, dx, dy, vc);
}	",1638,True
"/**
 * Computes the 2D convex hull of a set of points using Graham's
 * scanning algorithm. The algorithm has been implemented as described
 * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
 * 
 * The running time of this algorithm is O(n log n), where n is
 * the number of input points.
 * 
 * @param pts
 * @return the convex hull of the input points
 */
public static double[] convexHull(double[] pts, int len, 
        float[] angles, int[] idx, int[] stack){
    // check arguments
    int plen = len/2 - 1;
    if (len < 6) {
        throw new IllegalArgumentException(
                ""Input must have at least 3 points"");
    }
    if (angles.length < plen || idx.length < plen || stack.length < len/2) {
        throw new IllegalArgumentException(
                ""Pre-allocated data structure too small"");
    }
    
    int i0 = 0;
    // find the starting ref point: leftmost point with the minimum y coord
    for (int i=2; i<len; i += 2) {
        if (pts[i+1] < pts[i0+1]) {
            i0 = i;
        } else if (pts[i+1] == pts[i0+1]) {
            i0 = (pts[i] < pts[i0] ? i : i0);
        }
    }
    
    // calculate polar angles from ref point and sort
    for (int i=0, j=0; i<len; i+=2) {
        if (i == i0) continue;
        angles[j] = (float)Math.atan2(pts[i+1]-pts[i0+1], pts[i]-pts[i0]);
        idx[j++]  = i;
    }
    sort(angles,idx,plen);
    
    // toss out duplicated angles
    float angle = angles[0];
    int ti = 0, tj = idx[0];
    for (int i=1; i<plen; i++) {
        int j = idx[i];
        if (angle == angles[i]) {
            // keep whichever angle corresponds to the most distant
            // point from the reference point
            double x1 = pts[tj]   - pts[i0];
            double y1 = pts[tj+1] - pts[i0+1];
            double x2 = pts[j]    - pts[i0];
            double y2 = pts[j+1]  - pts[i0+1];
            double d1 = x1*x1 + y1*y1;
            double d2 = x2*x2 + y2*y2;
            if ( d1 >= d2 ) {
                idx[i] = -1;
            } else {
                idx[ti] = -1;
                angle = angles[i];
                ti = i;
                tj = j;
            }
        } else {
            angle = angles[i];
            ti = i;
            tj = j;
        }
    }
    
    // initialize our stack
    int sp = 0;
    stack[sp++] = i0;
    int j = 0;
    for (int k=0; k<2; j++) {
        if (idx[j] != -1) {
            stack[sp++] = idx[j];
            k++;
        }
    }
    
    // do graham's scan
    for (; j < plen; j++) {
        if (idx[j] == -1) continue; // skip tossed out points
        while (isNonLeft(i0, stack[sp-2], stack[sp-1], idx[j], pts)) {
            sp--;
        }
        stack[sp++] = idx[j];
    }

    // construct the hull
    double[] hull = new double[2*sp];
    for ( int i=0; i<sp; i++ ) {
        hull[2*i]   = pts[stack[i]];
        hull[2*i+1] = pts[stack[i]+1];
    }
    
    return hull;
}","/**
 * Computes the 2D convex hull of a set of points using Graham's
 * scanning algorithm. The algorithm has been implemented as described
 * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
 * 
 * The running time of this algorithm is O(n log n), where n is
 * the number of input points.
 * 
 * @param pts
 * @return the convex hull of the input points
 */
public static double[] convexHull(double[] pts, int len, 
        float[] angles, int[] idx, int[] stack) 
{
    int i, j, k, h;
    int top = -1;
    int n = len >> 1;

    // Sort the points by their polar angles
    for (i = 1; i < n; i++) {
        k = idx[i];
        j = i;
        while (j > 0 && angles[idx[j - 1]] > angles[k]) {
            idx[j] = idx[j - 1];
            j--;
        }
        idx[j] = k;
    }

    // Initialize the stack
    stack[++top] = 0;
    stack[++top] = 1;

    // Graham's scanning algorithm
    for (i = 2; i < n; i++) {
        while (top > 0 && crossProduct(pts, stack[top - 1], stack[top], idx[i]) <= 0) {
            top--;
        }
        stack[++top] = idx[i];
    }

    // Construct the convex hull
    double[] hull = new double[(top + 1) * 2];
    for (i = 0; i <= top; i++) {
        h = stack[i] * 2;
        hull[h] = pts[h];
        hull[h + 1] = pts[h + 1];
    }

    return hull;
}       ",1639,True
"// TODO: SqlDataType class?
public static int getSqlType(DataType dataType){
	switch(dataType)
	{
		case BOOLEAN: return java.sql.Types.BOOLEAN;
		case DATE: return java.sql.Types.DATE;
		case DOUBLE: return java.sql.Types.DOUBLE;
		case FLOAT: return java.sql.Types.FLOAT;
		case INTEGER: return java.sql.Types.INTEGER;
		case BYTE: return java.sql.Types.TINYINT;
		case STRING: return java.sql.Types.VARCHAR;
	}
	
	return java.sql.Types.NULL;
}","// TODO: SqlDataType class?
public static int getSqlType(DataType dataType) 
{
    switch (dataType)
    {
        case INT:
            return Types.INTEGER;
        case LONG:
            return Types.BIGINT;
        case FLOAT:
            return Types.FLOAT;
        case DOUBLE:
            return Types.DOUBLE;
        case STRING:
            return Types.VARCHAR;
        case BOOLEAN:
            return Types.BOOLEAN;
        case DATE:
            return Types.DATE;
        case DATETIME:
            return Types.TIMESTAMP;
        default:
            throw new IllegalArgumentException(""Unsupported data type: "" + dataType);
    }
}   ",1643,False
"/**
 * Adds a Portal to this world.
 * 
 * You *should* only call this if this Portal's Location
 * is in this world!
 * 
 * Also, this does not check for duplicates- it's just a 
 * quick add to the transient list, meant to stay in sync
 * with the Portal Location world values.
 * 
 * @param portal the portal to add to this world
 */
public void addPortal(Portal portal){
	if (portals == null)
	{
		portals = new ArrayList<Portal>();
	}
	portals.add(portal);
}","/**
 * Adds a Portal to this world.
 * 
 * You *should* only call this if this Portal's Location
 * is in this world!
 * 
 * Also, this does not check for duplicates- it's just a 
 * quick add to the transient list, meant to stay in sync
 * with the Portal Location world values.
 * 
 * @param portal the portal to add to this world
 */

public void addPortal(Portal portal) 
{
    if (portals == null)
    {
        portals = new ArrayList<Portal>();
    }
    portals.add(portal);
}   ",1644,True
"/**
 * Sets the default value for this node
 *
 * @param value New default value
 */
public void setDefault(final Object value){
    if (isValid(value)) {
        map.put(""default"", value);
    } else {
        throw new IllegalArgumentException(""Default value is not of correct type"");
    }
}","/**
 * Sets the default value for this node
 *
 * @param value New default value
 */
public void setDefault(final Object value) 
{
    if (value == null)
    {
        throw new IllegalArgumentException(""Default value cannot be null"");
    }
    this.defaultValue = value;
}   ",1646,True
"/*
 * Protected members
 */
protected DataTable getClassTable(){
	DataTable classTable = new DataTable(getTableName());
	return classTable;
}","/*
 * Protected members
 */
protected DataTable getClassTable() 
{
    return classTable;
}   ",1647,True
"/**
 * Whew! Ok, took me a while to figure out  I needed this...
 * 
 * getIdData will recurse down objects-as-id reference chains. This is for persisting
 * in the data store.
 * 
 * getId will return the actual id value, which is how data is cached internally.
 * 
 * A VERY important distinction! You look up object-as-id objects using their id instance,
 * not the id of their id (of that id's id, etc...)
 */
public Object getIdData(Object o){
	Object value = null;
	PersistedField field = idField;
	if (field != null)
	{
		if (field instanceof PersistedReference)
		{
			PersistedReference ref = (PersistedReference)field;
			Object refId = idField.get(o);
			if (ref.getReferenceType() != null)
			{
				return ref.getReferenceType().getIdData(refId);
			}
		}
		else
		{
			value = idField.get(o);				
		}
	}
	return value;
}","/**
 * Whew! Ok, took me a while to figure out  I needed this...
 * 
 * getIdData will recurse down objects-as-id reference chains. This is for persisting
 * in the data store.
 * 
 * getId will return the actual id value, which is how data is cached internally.
 * 
 * A VERY
 * not the id of their id (of that id's id, etc...)
 */
public Object getIdData(Object o) 
{
    if (o instanceof Id)
    {
        Id id = (Id) o;
        return id.getIdData();
    }
    return o;
}   ",1649,False
"/* Shut down Persistence, save data, clear cache
 * 
 * @see org.bukkit.plugin.Plugin#onDisable()
 */
public void onDisable(){
	if (persistence != null)
	{
		persistence.save();
		persistence.clear();
		persistence.disconnect();
	}
}","/* Shut down Persistence, save data, clear cache
 * 
 * @see org.bukkit.plugin.Plugin#onDisable()
 */
public void onDisable() 
{
    // Shut down Persistence
    Persistence.shutdown();

    // Save data
    Data.save();

    // Clear cache
    Cache.clear();
}   ",1650,True
"/*
 * Player teleportation
 */
public BlockVector mapLocation(NetherWorld from, NetherWorld to, BlockVector target){
	double fromScale = from.getScale();
	double toScale = to.getScale();
	
	if (fromScale == 0 || toScale == 0) return target;
	
	int originalY = target.getBlockY();
	Vector transformed = new Vector(target.getBlockX(), target.getBlockY(), target.getBlockZ());
	
	// First, offset to center on local spawn (making sure there is one set)
	
	BlockVector fromSpawn = from.getWorld().getSpawn();
	if (fromSpawn != null)
	{
		transformed.subtract(fromSpawn);
	}
	
	// Apply additional offset
	BlockVector fromOffset = from.getCenterOffset();
	if (fromOffset != null)
	{
		transformed.subtract(fromOffset);
	}
	
	// Scale
	if (fromScale != 0 && toScale != 0)
	{
		transformed.multiply(fromScale / toScale);
	}
	
	// Unwind
	
	BlockVector toOffset = to.getCenterOffset();
	if (toOffset != null)
	{
		transformed.add(toOffset);
	}
	
	BlockVector toSpawn = to.getWorld().getSpawn();
	if (toSpawn != null)
	{
		transformed.add(toSpawn);
	}
	
	transformed.setY(originalY);
	
	return new BlockVector(transformed);
}","/*
 * Player teleportation
 */
public BlockVector mapLocation(NetherWorld from, NetherWorld to, BlockVector target) 
{
    BlockVector result = null;
    if (from != null && to != null && target != null)
    {
        result = new BlockVector(target.getX() * (to.getWidth() / from.getWidth()), target.getY(), target.getZ() * (to.getDepth() / from.getDepth()));
    }
    return result;
}   ",1653,False
"/* Process player quit and join messages.
 * 
 * @see org.bukkit.plugin.java.JavaPlugin#onCommand(org.bukkit.command.CommandSender, org.bukkit.command.Command, java.lang.String, java.lang.String[])
 */
@Override
public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] parameters){
	if (listeners == null)
	{
		listeners = new ArrayList<Object>();
		listeners.add(handler);
		listeners.add(getPermissions());
	}
	return utilities.dispatch(listeners, sender, cmd.getName(), parameters);
}","/* Process player quit and join messages.
 * 
 * @see org.bukkit.plugin.java.JavaPlugin#onCommand(org.bukkit.command.CommandSender, org.bukkit.command.Command, java.lang.String, java.lang.String[])
 */
@Override
public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] parameters) 
{
    if (cmd.getName().equalsIgnoreCase(""quit""))
    {
        if (parameters.length == 0)
        {
            if (sender instanceof Player)
            {
                Player player = (Player) sender;
                player.quit();
            }
            else
            {
                sender.sendMessage(""This command can only be used by a player."");
            }
        }
        else
        {
            sender.sendMessage(""Usage: /quit"");
        }
        return true;
    }
    else if (cmd.getName().equalsIgnoreCase(""join""))
    {
        if (parameters.length == 1)
        {
            if (sender instanceof Player)
            {
                Player player = (Player) sender;
                player.join(parameters[0]);
            }
            else
            {
                sender.sendMessage(""This command can only be used by a player."");
            }
        }
        else
        {
            sender.sendMessage(""Usage: /join <player>"");
        }
        return true;
    }
    return false;
}   ",1655,True
"/*
 * Hrm.. this compiles... but Maven doesn't like it.... ???
 * 
 * [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.0.2:compile (default-compile) on project Persistence: Compilation failure
 * [ERROR] /Users/nathan/Documents/Code/Eclipse/Bukkit/BukkitPlugins/PersistencePlugin/src/main/java/com/elmakers/mine/bukkit/plugins/persistence/dao/ProfileData.java:[33,25] type parameters of <T>T cannot be determined; no unique maximal instance exists for type variable T with upper bounds T,java.lang.Object
 * [ERROR] -> [Help 1]
     *
     * Disabling for now, not working yet anyway (at an API level)
 */
/*
public <T> T get(final String key)
{
	if (this.profile == null)
	{
		return null;
	}

	return this.profile.get(key);
}
*/
public boolean isSet(final String key){
	if (this.profile == null)
	{
		return false;
	}

	return profile.isSet(key);
}","/*
 * Hrm.. this compiles... but Maven doesn't like it.... ???
 * 
 * [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.0.2:compile (default-compile) on project Persistence: Compilation failure
 * [ERROR] /Users/nathan/Documents/Code/Eclipse/Bukkit/BukkitPlugins/PersistencePlugin/src/main/java/com/elmakers/mine/bukkit/plugins/persistence/dao/ProfileData.java:[33,25] type parameters of <T>T cannot be determined; no unique maximal instance exists for type variable T with upper bounds T,java.lang.Object
 * [ERROR] -> [Help 1]
     *
     * Disabling for now, not working yet anyway (at an API level)
 */
/*
public <T> T get(final String key)
{
	if (this.profile == null)
	{
		return null;
	}

	return this.profile.get(key);
}
*/
public boolean isSet(final String key) 
{
	if (this.profile == null)
	{
		return false;
	}

	return this.profile.containsKey(key);
}	",1656,True
"/**
 * Retrieve the singleton Persistence instance.
 * 
 * Use this function to get a reference to Persistence, which you can use to access the Persistence API.
 * 
 * @see com.elmakers.mine.craftbukkit.persistence.Persistence
 * 
 * @return The singleton instance of Persistence
 */
public Persistence getPersistence(){
	if (persistence == null)
	{
		persistence = Persistence.getInstance();
	}
	return persistence;
}","/**
 * Retrieve the singleton Persistence instance.
 * 
 * Use this function to get a reference to Persistence, which you can use to access the Persistence API.
 * 
 * @see com.elmakers.mine.craftbukkit.persistence.Persistence
 * 
 * @return The singleton instance of Persistence
 */
public Persistence getPersistence() 
{
    if (persistence == null)
    {
        persistence = new Persistence();
    }
    return persistence;
}   ",1657,True
"/**
 * Convert a SQL data type to a DataType.
 * 
 * Only converts supported DataTypes.
 * 
 * TODO: Move this to a SqlData type class, allow
 * stores to override type conversion
 * 
 * @param sqlType The java.sql.Type value to convert
 * @return A DataType value, or DataType.NULL if invalid
 */
public static DataType getTypeFromSqlType(int sqlType){
	DataType dataType = DataType.NULL;
	
	switch(sqlType)
	{
		case java.sql.Types.BOOLEAN:
			dataType = DataType.BOOLEAN;
			break;
		case java.sql.Types.BIT:
			dataType = DataType.BOOLEAN;
			break;	
		case java.sql.Types.TINYINT:
			dataType = DataType.BYTE;
			break;	
		case java.sql.Types.DATE:
			dataType = DataType.DATE;
			break;
		case java.sql.Types.DECIMAL:
			dataType = DataType.DOUBLE;
			break;	
		case java.sql.Types.DOUBLE:
			dataType = DataType.DOUBLE;
			break;	
		case java.sql.Types.FLOAT:
			dataType = DataType.DOUBLE;
			break;	
		case java.sql.Types.INTEGER:
			dataType = DataType.INTEGER;
			break;	
		case java.sql.Types.JAVA_OBJECT:
			dataType = DataType.OBJECT;
			break;	
		case java.sql.Types.LONGNVARCHAR:
			dataType = DataType.STRING;
			break;	
		case java.sql.Types.LONGVARCHAR:
			dataType = DataType.STRING;
			break;	
		case java.sql.Types.NCHAR:
			dataType = DataType.STRING;
			break;	
		case java.sql.Types.NULL:
			dataType = DataType.NULL;
			break;	
		case java.sql.Types.NUMERIC:
			dataType = DataType.INTEGER;
			break;	
		case java.sql.Types.REAL:
			dataType = DataType.DOUBLE;
			break;	
		case java.sql.Types.ROWID:
			dataType = DataType.INTEGER;
			break;	
		case java.sql.Types.SMALLINT:
			dataType = DataType.INTEGER;
			break;	
		case java.sql.Types.TIME:
			dataType = DataType.DATE;
			break;	
		case java.sql.Types.TIMESTAMP:
			dataType = DataType.DATE;
			break;	
		case java.sql.Types.VARCHAR:
			dataType = DataType.STRING;
			break;	
	}
	
	return dataType;
}","/**
 * Convert a SQL data type to a DataType.
 * 
 * Only converts supported DataTypes.
 * 
 * TODO: Move this to a SqlData type class, allow
 * stores to override type conversion
 * 
 * @param sqlType The java.sql.Type value to convert
 * @return A DataType value, or DataType.NULL if invalid
 */
public static DataType getTypeFromSqlType(int sqlType) 
{
    switch (sqlType)
    {
        case Types.BIGINT:
            return DataType.BIGINT;
        case Types.BINARY:
            return DataType.BINARY;
        case Types.BIT:
            return DataType.BOOLEAN;
        case Types.CHAR:
            return DataType.STRING;
        case Types.DATE:
            return DataType.DATE;
        case Types.DOUBLE:
            return DataType.DOUBLE;
        case Types.FLOAT:
            return DataType.DOUBLE;
        case Types.INTEGER:
            return DataType.INTEGER;
        case Types.LONGVARBINARY:
            return DataType.BINARY;
        case Types.LONGVARCHAR:
            return DataType.STRING;
        case Types.NULL:
            return DataType.NULL;
        case Types.NUMERIC:
            return DataType.DOUBLE;
        case Types.OTHER:
            return DataType.OBJECT;
        case Types.REAL:
            return DataType.DOUBLE;
        case Types.SMALLINT:
            return DataType.INTEGER;
        case Types.TIME:
            return DataType.TIME;
        case Types.TIMESTAMP:
            return DataType.TIMESTAMP;
        case Types.TINYINT:
            return DataType.INTEGER;
        case Types.VARBINARY:
            return DataType.BINARY;
        case Types.VARCHAR:
            return DataType.STRING;
        default:
            return DataType.NULL;
    }
}   ",1658,True
"/**
 * Will create a table if it does not exist, and migrate data as
 * necessary if it does exist.
 * 
 * @param table The table definition. If this differs from the stored definition, data migration will occur.
 * @return true if success
 * @see #tableExists(DataTable)
 */
public boolean migrateEntity(DataTable table, PersistedClass entity){
	if (!tableExists(table.getName())) 
	{
		create(table);
		return true;
	}
	
	// Migrate data
	DataTable currentTable = getTableHeader(table.getName());
	DataRow tableHeader = table.getHeader();
	DataRow currentHeader = currentTable.getHeader();
	if (tableHeader.isMigrationRequired(currentHeader))
	{
		MigrationInfo migrateInfo = entity.getMigrationInfo();
		
		// TODO: Support types other than auto reset
		if (migrateInfo == null)
		{
			log.info(""Persistence: Auto-migrating entity "" + entity.getSchema() + ""."" + entity.getName());
			
			/* TODO!
			String autoBackupTable = table.getName() + ""_autoBackup"";
			if (tableExists(autoBackupTable))
			{
				drop(autoBackupTable);
			}
			currentTable.setName(autoBackupTable);
			create(currentTable);
			*/
			drop(currentTable.getName());
			create(table);
		}
		else
		{
			// Custom migration not supported- just dump error.
			logMigrateError(entity.getSchemaName(), entity.getName());
		}
	}
	
	return true;
}","/**
 * Will create a table if it does not exist, and migrate data as
 * necessary if it does exist.
 * 
 * @param table The table definition. If this differs from the stored definition, data migration will occur.
 * @return true if success
 * @see #tableExists(DataTable)
 */
public boolean migrateEntity(DataTable table, PersistedClass entity) 
{
    if (tableExists(table))
    {
        return migrateData(table, entity);
    }
    else
    {
        return createTable(table, entity);
    }
}   ",1659,False
"/*
 param@ key -- value whose hash is used to fill
 the filter_.
 This is a general purpose API.
 */
public void add(String key){
    if ( !isPresent(key) )
        ++count_;
    for (int i = 0; i < hashes_; ++i)
    {
        ISimpleHash hash = hashLibrary_.get(i);
        int hashValue = hash.hash(key);
        int index = Math.abs(hashValue % size_);
        byte value = (filter_[index] == 0xFF) ? filter_[index] : (byte)( (++filter_[index]) & 0xFF );
        filter_[index] = value;
    }
}","/*
 param@ key -- value whose hash is used to fill
 the filter_.
 This is a general purpose API.
 */
public void add(String key) 
{
    int h = hash(key);
    int i = indexFor(h, table.length);
    Entry e = table[i];
    table[i] = new Entry(key, e);
    if (e == null)
        size++;
}   ",1660,False
"/**
 * This method is part of IFailureDetectionEventListener interface. This is invoked
 * by the Failure Detector when it convicts an end point.
 * 
 * param @ endpoint end point that is convicted.
*/
public void convict(EndPoint endpoint){
    EndPointState epState = endPointStateMap_.get(endpoint);
    if ( epState != null )
    {
        if ( !epState.isAlive() && epState.isAGossiper() )
        {
            /*
             * just to be sure - is invoked just to make sure that
             * it was called atleast once.
            */
            if ( liveEndpoints_.contains(endpoint) )
            {
                logger_.info(""EndPoint "" + endpoint + "" is now dead."");
                isAlive(endpoint, epState, false);
                
                /* Notify an endpoint is dead to interested parties. */
                EndPointState deltaState = new EndPointState(epState.getHeartBeatState());
                doNotifications(endpoint, deltaState);
            }
            epState.isAGossiper(false);
        }
    }
}","/**
 * This method is part of IFailureDetectionEventListener interface. This is invoked
 * by the Failure Detector when it convicts an end point.
 * 
 * param @ endpoint end point that is convicted.
*/
public void convict(EndPoint endpoint) 
{
    if (endpoint == null)
    {
        return;
    }
    if (this.endPoints.contains(endpoint))
    {
        this.endPoints.remove(endpoint);
    }
}   ",1661,False
"/*
 * The following methods are used for compact representation
 * of BloomFilter. This is essential, since we want to determine
 * the size of the serialized Bloom Filter blob before it is
 * populated armed with the knowledge of how many elements are
 * going to reside in it.
 */
public void serialize(BloomFilter bf, DataOutput dos)
        throws IOException{
    /* write out the count of the BloomFilter */
    dos.writeInt(bf.count());
    /* write the number of hash functions used */
    dos.writeInt(bf.hashes());
    /* write the size of the BloomFilter */
    dos.writeInt(bf.size());
    BitSet.serializer().serialize(bf.filter(), dos);
}","/*
 * The following methods are used for compact representation
 * of BloomFilter. This is essential, since we want to determine
 * the size of the serialized Bloom Filter blob before it is
 * populated armed with the knowledge of how many elements are
 * going to reside in it.
 */
public void serialize(BloomFilter bf, DataOutput dos)
        throws IOException 
{
    dos.writeInt(bf.getNumHashFunctions());
    dos.writeInt(bf.getNumBits());
    BitSet bs = bf.getBitSet();
    byte[] bytes = bs.toByteArray();
    dos.writeInt(bytes.length);
    dos.write(bytes);
}       ",1663,True
"/**
 * Return a new TokenMetadata object reflecting a new token for the given
 * endpoint.
 */
public TokenMetadata update(BigInteger token, EndPoint endpoint){
    TreeMap<BigInteger, EndPoint> newTTEP =
        new TreeMap<BigInteger, EndPoint>(tokenToEndPointMap_);
    Map<EndPoint, BigInteger> newEPTT =
        new HashMap<EndPoint, BigInteger>(endPointToTokenMap_);

    BigInteger oldToken = endPointToTokenMap_.get(endpoint);
    if ( oldToken != null )
        newTTEP.remove(oldToken);
    newTTEP.put(token, endpoint);
    newEPTT.put(endpoint, token);

    return new TokenMetadata(newTTEP, newEPTT);
}","/**
 * Return a new TokenMetadata object reflecting a new token for the given
 * endpoint.
 */
public TokenMetadata update(BigInteger token, EndPoint endpoint) 
{
    TokenMetadata tm = new TokenMetadata();
    tm.token = token;
    tm.endPoint = endpoint;
    return tm;
}   ",1664,True
"/*
 * Read buffers from the input stream into the byte buffer.
 */
public void run(){
    ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.bufferSize_);
    try
    {
        int bytesRead = httpChannel_.read(readBuffer);
        readBuffer.flip();
        if ( readBuffer.remaining() > 0 )
            HttpConnection.this.parse(readBuffer);
    }
    catch ( IOException ex )
    {
        logger_.warn(LogUtil.throwableToString(ex));
    }
}","/*
 * Read buffers from the input stream into the byte buffer.
 */
public void run() 
{
    try
    {
        int bytesRead;
        while ( (bytesRead = in.read(buffer)) != -1 )
        {
            out.write(buffer, 0, bytesRead);
        }
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1671,False
"/*
 *  Read called on the Selector thread. This is called
 *  when there is some HTTP request that needs to be
 *  processed.
*/
public void read(SelectionKey key){
    if ( httpKey_ == null )
    {
        httpKey_ = key;
        httpChannel_ = (SocketChannel)key.channel();
    }
    /* deregister interest for read */
    key.interestOps( key.interestOps() & ( ~SelectionKey.OP_READ ) );
    /* Add a task to process the HTTP request */
    MessagingService.getReadExecutor().execute(httpReader_);
}","/*
 *  Read called on the Selector thread. This is called
 *  when there is some HTTP request that needs to be
 *  processed.
*/

public void read(SelectionKey key) 
{
    // Server socket channel
    ServerSocketChannel server = (ServerSocketChannel) key.channel();
    SocketChannel client = null;
    try
    {
        client = server.accept();
        client.configureBlocking(false);
        client.register(selector, SelectionKey.OP_READ);
    }
    catch (IOException ex)
    {
        // Handle exception
    }
}   ",1672,False
"/**
 * Remove the entries in the two maps.
 * @param endpoint
 */
public TokenMetadata remove(EndPoint endpoint){
    TreeMap<BigInteger, EndPoint> newTTEP =
        new TreeMap<BigInteger, EndPoint>(tokenToEndPointMap_);
    Map<EndPoint, BigInteger> newEPTT =
        new HashMap<EndPoint, BigInteger>(endPointToTokenMap_);

    BigInteger oldToken = endPointToTokenMap_.get(endpoint);
    if ( oldToken != null )
        newTTEP.remove(oldToken);
    newEPTT.remove(endpoint);

    return new TokenMetadata(newTTEP, newEPTT);
}","/**
 * Remove the entries in the two maps.
 * @param endpoint
 */
public TokenMetadata remove(EndPoint endpoint) 
{
    TokenMetadata removed = tokens.get(endpoint);
    tokens.remove(endpoint);
    lockTokens.remove(endpoint);
    return removed;
}   ",1673,False
"// HttpStartLineParser.Callback interface implementation
public void onStartLine(String method, String path, String query, String version){
    logger_.debug(""Startline method="" + method + "" path="" + path + "" query="" + query + "" version="" + version);

    if (method.startsWith(""HTTP""))
    {
            // response
            currentMsgType_ = HttpMessageType.RESPONSE;
            currentResponse_ = new HttpResponse();
            currentResponse_.setStartLine(method, path, version);
    }
    else
    {
            // request
            currentMsgType_ = HttpMessageType.REQUEST;
            currentRequest_ = new HttpRequest();
            currentRequest_.setStartLine(method, path, query, version);
    }
}","// HttpStartLineParser.Callback interface implementation
public void onStartLine(String method, String path, String query, String version) 
{
    this.method = method;
    this.path = path;
    this.query = query;
    this.version = version;
}   ",1674,True
"/**
 * This method is used to forcibly remove a node from the membership
 * set. He is forgotten locally immediately.
 * 
 * param@ ep the endpoint to be removed from membership.
 */
public synchronized void removeFromMembership(EndPoint ep){
    endPointStateMap_.remove(ep);
    liveEndpoints_.remove(ep);
    unreachableEndpoints_ .remove(ep);
}","/**
 * This method is used to forcibly remove a node from the membership
 * set. He is forgotten locally immediately.
 * 
 * param@ ep the endpoint to be removed from membership.
 */
public synchronized void removeFromMembership(EndPoint ep) 
{
    if (members.contains(ep))
    {
        members.remove(ep);
    }
}   ",1677,True
"/*
 * This method for resolving read data should look at the timestamps of each
 * of the columns that are read and should pick up columns with the latest
 * timestamp. For those columns where the timestamp is not the latest a
 * repair request should be scheduled.
 * 
 */
public Row resolve(List<Message> responses) throws DigestMismatchException{
        long startTime = System.currentTimeMillis();
	Row retRow = null;
	List<Row> rowList = new ArrayList<Row>();
	List<EndPoint> endPoints = new ArrayList<EndPoint>();
	String key = null;
	String table = null;
	byte[] digest = new byte[0];
	boolean isDigestQuery = false;
        
        /*
	 * Populate the list of rows from each of the messages.
	 * Check to see if there is a digest query. If a digest 
         * query exists then we need to compare the digest with 
         * the digest of the data that is received.
        */
        DataInputBuffer bufIn = new DataInputBuffer();
	for (Message response : responses)
	{					            
            byte[] body = (byte[])response.getMessageBody()[0];            
            bufIn.reset(body, body.length);
            try
            {
                long start = System.currentTimeMillis();
                ReadResponseMessage result = ReadResponseMessage.serializer().deserialize(bufIn);            
                logger_.debug( ""Response deserialization time : "" + (System.currentTimeMillis() - start) + "" ms."");
    			if(!result.isDigestQuery())
    			{
    				rowList.add(result.row());
    				endPoints.add(response.getFrom());
    				key = result.row().key();
    				table = result.table();
    			}
    			else
    			{
    				digest = result.digest();
    				isDigestQuery = true;
    			}
            }
            catch( IOException ex )
            {
                logger_.info(LogUtil.throwableToString(ex));
            }
	}
	// If there was a digest query compare it withh all the data digests 
	// If there is a mismatch then throw an exception so that read repair can happen.
	if(isDigestQuery)
	{
		for(Row row: rowList)
		{
			if( !Arrays.equals(row.digest(), digest) )
			{
				throw new DigestMismatchException(""The Digest does not match"");
			}
		}
	}
	
        /* If the rowList is empty then we had some exception above. */
        if ( rowList.isEmpty() )
        {
            return retRow;
        }
        
        /* Now calculate the resolved row */
	retRow = new Row(key);		
	for (Row row : rowList)
	{
		retRow.repair(row);
	}
        // At this point we have the return row.
	// Now we need to calculate the differnce 
	// so that we can schedule read repairs 
	
	for (int i = 0 ; i < rowList.size(); i++)
	{
		// calculate the difference , since retRow is the resolved
		// row it can be used as the super set , remember no deletes 
		// will happen with diff its only for additions so far 
		// TODO : handle deletes 
		Row diffRow = rowList.get(i).diff(retRow);
		if(diffRow == null) // no repair needs to happen
			continue;
		// create the row mutation message based on the diff and schedule a read repair 
		RowMutation rowMutation = new RowMutation(table, key);            			
    	Map<String, ColumnFamily> columnFamilies = diffRow.getColumnFamilies();

            for ( Map.Entry<String, ColumnFamily> entry : columnFamilies.entrySet() )
            {
                rowMutation.add(entry.getKey(), entry.getValue());
            }
            RowMutationMessage rowMutationMessage = new RowMutationMessage(rowMutation);
        // schedule the read repair
        ReadRepairManager.instance().schedule(endPoints.get(i),rowMutationMessage);
	}
        logger_.info(""resolve: "" + (System.currentTimeMillis() - startTime)
                + "" ms."");
	return retRow;
}","/*
 * This method for resolving read data should look at the timestamps of each
 * of the columns that are read and should pick up columns with the latest
 * timestamp. For those columns where the timestamp is not the latest a
 * repair request should be scheduled.
 * 
 */
public Row resolve(List<Message> responses) throws DigestMismatchException 
{
    Row resolved = null;
    long latestTimestamp = Long.MIN_VALUE;

    for (Message message : responses)
    {
        Row row = message.payload;
        long timestamp = row.getTimestamp();

        if (timestamp > latestTimestamp)
        {
            latestTimestamp = timestamp;
            resolved = row;
        }
    }

    if (resolved == null)
    {
        throw new DigestMismatchException(""No responses to resolve"");
    }

    return resolved;
}   ",1678,False
"/**
 * Given the number of keys that need to be transferred say, 1000
 * and given the smallest key stored we need the hash of the 1000th
 * key greater than the smallest key in the sorted order in the primary
 * range.
 * 
 * @param keyCount number of keys after which token is required.
 * @return token.
*/
public static BigInteger getTokenBasedOnPrimaryCount(int keyCount){
    List<String> indexedPrimaryKeys = getIndexedPrimaryKeys();
    int index = keyCount / SSTable.indexInterval();
    String key = (index >= indexedPrimaryKeys.size()) ? indexedPrimaryKeys.get( indexedPrimaryKeys.size() - 1 ) : indexedPrimaryKeys.get(index);
    logger_.debug(""Hashing key "" + key + "" ..."");
    return StorageService.instance().hash(key);
}","/**
 * Given the number of keys that need to be transferred say, 1000
 * and given the smallest key stored we need the hash of the 1000th
 * key greater than the smallest key in the sorted order in the primary
 * range.
 * 
 * @param keyCount number of keys after which token is required.
 * @return token.
*/
public static BigInteger getTokenBasedOnPrimaryCount(int keyCount) 
{
    BigInteger token = BigInteger.ZERO;
    if (keyCount <= 0)
        return token;
    token = BigInteger.valueOf(keyCount).multiply(BigInteger.valueOf(2));
    return token;
}   ",1679,True
"/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawText(java.lang.String, int, int, int, int, java.lang.String)
 */
public void drawText(String str, int x, int y, int maxWidth, int anchor, String suffix){
	
	//TODO: Check this implementation when a test client is up and running. 
	
	if ((anchor & ANCHOR_RIGHT) == ANCHOR_RIGHT ) {
        x -= m_Graphics.getFont().getAdvance( str );
    } else if ((anchor & ANCHOR_HCENTER) == ANCHOR_HCENTER ) {
        x -= m_Graphics.getFont().getAdvance( str ) / 2;
    }
    
    if((anchor & ANCHOR_BOTTOM) == ANCHOR_BOTTOM) {
        y -= m_Graphics.getFont().getHeight();
    } else if ((anchor & ANCHOR_BASELINE) == ANCHOR_BASELINE) {
        y -= m_Graphics.getFont().getBaseline();
    }
    
    final int strWidth = m_Graphics.getFont().getAdvance(str);
    if(strWidth > maxWidth) {
    	if(suffix != null) {
    		maxWidth -= m_Graphics.getFont().getAdvance(suffix);
    		if(maxWidth <= 0)
    			throw new IllegalArgumentException(""maxWidth are less then the size of the suffix!"");
    		
    		int index = m_Graphics.drawText(str, x, y, DrawStyle.TOP | DrawStyle.LEFT, maxWidth);
    		int sw = m_Graphics.getFont().getAdvance(str.substring(0, index));
    		m_Graphics.drawText(suffix, x+sw, y, DrawStyle.TOP | DrawStyle.LEFT, maxWidth);        		        		
    	} else {
    		m_Graphics.drawText(str, x, y, DrawStyle.TOP | DrawStyle.LEFT, maxWidth);
    	}        	
    } else {
    	m_Graphics.drawText(str, x, y, DrawStyle.TOP | DrawStyle.LEFT, maxWidth);
    }        
	}","/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawText(java.lang.String, int, int, int, int, java.lang.String)
 */
public void drawText(String str, int x, int y, int maxWidth, int anchor, String suffix) 
{
    int textWidth = getTextWidth(str);
    int textHeight = getTextHeight(str);
    int textX = x;
    int textY = y;

    switch (anchor)
    {
        case Graphics.TOP|Graphics.LEFT:
            break;
        case Graphics.TOP|Graphics.HCENTER:
            textX = x - textWidth / 2;
            break;
        case Graphics.TOP|Graphics.RIGHT:
            textX = x - textWidth;
            break;
        case Graphics.VCENTER|Graphics.LEFT:
            textY = y - textHeight / 2;
            break;
        case Graphics.VCENTER|Graphics.HCENTER:
            textX = x - textWidth / 2;
            textY = y - textHeight / 2;
            break;
        case Graphics.VCENTER|Graphics.RIGHT:
            textX = x - textWidth;
            textY = y - textHeight / 2;
            break;
        case Graphics.BOTTOM|Graphics.LEFT:
            textY = y - textHeight;
            break;
        case Graphics.BOTTOM|Graphics.HCENTER:
            textX = x - textWidth / 2;
            textY = y - textHeight;
            break;
        case Graphics.BOTTOM|Graphics.RIGHT:
            textX = x - textWidth;
            textY = y - textHeight;
            break;
    }

    drawText(str, textX, textY, maxWidth, suffix);
}   ",1680,True
"/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawText(java.lang.String, int, int, int, int)
 */
public void drawText(String str, int x, int y, int maxWidth, int anchor){
    if (( anchor & ANCHOR_RIGHT ) == ANCHOR_RIGHT ) {
        x -= m_Graphics.getFont().getAdvance( str );
    } else if (( anchor & ANCHOR_HCENTER ) == ANCHOR_HCENTER ) {
        x -= m_Graphics.getFont().getAdvance( str ) / 2;
    }
    
    if(( anchor & ANCHOR_BOTTOM) == ANCHOR_BOTTOM) {
        y -= m_Graphics.getFont().getHeight();
    } else if (( anchor & ANCHOR_BASELINE) == ANCHOR_BASELINE) {
        y -= m_Graphics.getFont().getBaseline();
    }
    
    m_Graphics.drawText(str, x, y, DrawStyle.TOP | DrawStyle.LEFT, maxWidth);
}","/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawText(java.lang.String, int, int, int, int)
 */
public void drawText(String str, int x, int y, int maxWidth, int anchor) 
{
    int textWidth = this.font.stringWidth(str);
    int textHeight = this.font.getHeight();

    int textX = x;
    int textY = y;

    if (anchor == Graphics.TOP | anchor == Graphics.BOTTOM) {
        textX -= textWidth / 2;
    } else if (anchor == Graphics.BOTTOM) {
        textY -= textHeight;
    }

    this.canvas.drawText(str, textX, textY, this.paint);
}   ",1682,True
"/* (non-Javadoc)
 * @see com.wayfinder.pal.network.http.HttpEntity#getContent()
 */
public InputStream getContent() throws IllegalStateException, IOException{
	if (m_inStream != null) {
            throw new IllegalStateException(""InputStream has already been opened"");
        }
        return (m_inStream = m_conn.openInputStream());
}","/* (non-Javadoc)
 * @see com.wayfinder.pal.network.http.HttpEntity#getContent()
 */
public InputStream getContent() throws IllegalStateException, IOException 
{
    if (this.content == null)
    {
        throw new IllegalStateException(""Content has not been set"");
    }
    return this.content;
}   ",1683,True
"/* (non-Javadoc)
 * @see com.wayfinder.pal.network.info.TGPPInfo#supportsCurrentMNC()
 */
public boolean supportsCurrentMNC(){
    if (canExtractNetInfo()) {
        if (RadioInfo.getCurrentNetworkIndex() < 0) {
        	return false;
        }
        if (RadioInfo.getCurrentNetworkIndex() 
                >= RadioInfo.getNumberOfNetworks()) {
        	return false;
        }
        return true;
    }
    return false;
}","/* (non-Javadoc)
 * @see com.wayfinder.pal.network.info.TGPPInfo#supportsCurrentMNC()
 */
public boolean supportsCurrentMNC() 
{
    if (m_currentMNC == null)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",1686,False
"/* (non-Javadoc)
 * @see com.wayfinder.pal.network.http.StatusLine#getReasonPhrase()
 */
public String getReasonPhrase(){
	try {
            return m_conn.getResponseMessage();
        } catch (IOException e) {
            return null;
        }
}","/* (non-Javadoc)
 * @see com.wayfinder.pal.network.http.StatusLine#getReasonPhrase()
 */
public String getReasonPhrase() 
{
    if (reasonPhrase == null)
    {
        return ""OK"";
    }
    return reasonPhrase;
}   ",1690,True
"/* (non-Javadoc)
 * @see com.wayfinder.pal.network.info.TGPPInfo#supportsCurrentMCC()
 */
public boolean supportsCurrentMCC(){
    if (canExtractNetInfo()) {
        //XXX: Sometimes RadioInfo.getCurrentNetworkIndex() returns some invalid
        //value causing an IllegalArgumetException to be thrown when trying to
        //get the MCC (and probably the MNC too, but MCC is requested first and 
        //it fails at that point). Check if we get a reasonable network index
        //first.
        if (RadioInfo.getCurrentNetworkIndex() < 0) return false;

        //not sure about this check though, RadioInfo.getNumberOfNetworks() could
        //have the same problems as RadioInfo.getCurrentNetworkIndex()
        if (RadioInfo.getCurrentNetworkIndex() 
                >= RadioInfo.getNumberOfNetworks()) return false;
        
        return true;
    }
    return false;
}","/* (non-Javadoc)
 * @see com.wayfinder.pal.network.info.TGPPInfo#supportsCurrentMCC()
 */
public boolean supportsCurrentMCC() 
{
    if (m_currentMCC == null)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",1694,False
"/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphicsFactory#createWFImage(java.lang.String)
 */
public WFImage createWFImage(String resourceName){
    Bitmap b = Bitmap.getBitmapResource(
            ApplicationDescriptor.currentApplicationDescriptor().getModuleName(),
            resourceName);
    if(b != null) {
        return new BlackBerryImage(b);
    }
    return null;
}","/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphicsFactory#createWFImage(java.lang.String)
 */
public WFImage createWFImage(String resourceName) 
{
    WFImage image = null;
    try
    {
        image = new WFImageImpl(resourceName);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return image;
}   ",1695,False
"/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawRGB(int[], int, int, int, int, int, int, boolean)
 */
public void drawRGB(int[] argbData, int offset, int scanlength, int x, int y, 
		int width, int height, boolean processAlpha){

    if(processAlpha) {
        m_Graphics.drawARGB(argbData, offset, scanlength, x, y, width, height);
    } else {
        m_Graphics.drawRGB(argbData, offset, scanlength, x, y, width, height);
    }

}","/*
 * (non-Javadoc)
 * @see com.wayfinder.pal.graphics.WFGraphics#drawRGB(int[], int, int, int, int, int, int, boolean)
 */
public void drawRGB(int[] argbData, int offset, int scanlength, int x, int y, 
		int width, int height, boolean processAlpha) 
{
    if (argbData == null)
        throw new NullPointerException(""null array"");
    if (width == 0 || height == 0)
        return;
    if (x < 0 || y < 0 || x + width > this.width || y + height > this.height)
        throw new IllegalArgumentException(""Invalid coordinates"");
    if (scanlength < 0 || scanlength > argbData.length - offset)
        throw new IllegalArgumentException(""Invalid scanlength"");
    if (offset < 0 || offset + scanlength > argbData.length)
        throw new IllegalArgumentException(""Invalid offset"");

    if (processAlpha)
    {
        for (int i = 0; i < height; i++)
        {
            int lineOffset = offset + i * scanlength;
            for (int j = 0; j < width; j++)
            {
                int argb = argbData[lineOffset + j];
                int a = (argb >> 24) & 0xff;
                int r = (argb >> 16) & 0xff;
                int g = (argb >> 8) & 0xff;
                int b = argb & 0xff;
                int pixel = (a << 24) | (r << 16) | (g << 8) | b;
                this.setPixel(x + j, y + i, pixel);
            }
        }
    }
    else
    {
        for (int i = 0; i < height; i++)
        {
            int lineOffset = offset + i * scanlength;
            for (int j = 0; j < width; j++)
            {
                int argb = argbData[lineOffset + j];
                int r = (argb >> 16) & 0xff;
                int g = (argb >> 8) & 0xff;
                int b = argb & 0xff;
                int pixel = (r << 16) | (g << 8) | b;
                this.setPixel(x + j, y + i, pixel);
            }
        }
    }
}	",1698,True
"/**
 * Add nodes that contains loaded data into the vector specified by the 
 * parameter. 
 * 
 * @param v the vector where the data will be loaded into. 
 */
public synchronized void getAllNodesThatContainsLoadedEntrys(Vector v){ 
    iHasBeenSplit = false;
    
    if(iNode != null) {
        if(iNode.getAllEntrys() != null) {                
            v.addElement(iNode);
        }
    } else {
        for(int i=0; i<4; i++) {
            if(iQTQuater[i] != null) {
                iQTQuater[i].getAllNodesThatContainsLoadedEntrys(v);
            }
        }
    }
}","/**
 * Add nodes that contains loaded data into the vector specified by the 
 * parameter. 
 * 
 * @param v the vector where the data will be loaded into. 
 */
public synchronized void getAllNodesThatContainsLoadedEntrys(Vector v) 
{
    for (int i = 0; i < nodes.size(); i++)
    {
        Node node = (Node) nodes.elementAt(i);
        if (node.isLoaded())
        {
            v.addElement(node);
        }
    }
}   ",1708,True
"/* (non-Javadoc)
 * @see java.lang.Thread#run()
 */
public void run(){
    if(LOG.isDebug()) {
        LOG.debug(""WorkThread.run()"", m_threadName + "" started"");
    }
    
    while(!m_shouldDie) {
        if(LOG.isTrace()) {
            LOG.trace(""WorkThread.run()"", m_threadName + "" fetching next work"");
        }

        Work w = m_scheduler.getNextWork(m_threadNbr);
        if(w != null) {
            try {
                if(LOG.isTrace()) {
                    LOG.trace(""WorkThread.run()"", 
                            m_threadName + "" executing work: "" 
                            + w.toString());
                }

                w.run();
                
                if(LOG.isTrace()) {
                    LOG.trace(""WorkThread.run()"", m_threadName + 
                            "" finished executing work: "" + w.toString());
                }

            } catch(Throwable t) {
                if(LOG.isError()) {
                    LOG.error(""WorkThread.run()"", 
                            m_threadName + "" caught exception "" + 
                            t.toString() + "" from scheduled work: "" 
                            + w.toString());
                    LOG.logException(Level.ERROR, ""WorkThread.run()"", t);
                }
            }

            // in case the runnable changes the priority
            Thread.currentThread().setPriority(Thread.NORM_PRIORITY);

            if(w.shouldBeRescheduled()) {
                m_scheduler.schedule(w);
            } else {
                m_scheduler.workCompleted(w);
            }
        }
        Thread.yield();
    }
    m_scheduler.threadExiting(m_threadNbr);
    if(LOG.isDebug()) {
        LOG.debug(""WorkThread.run()"", m_threadName + "" stopped"");
    }
}","/* (non-Javadoc)
 * @see java.lang.Thread#run()
 */
public void run() 
{
    while (true)
    {
        try
        {
            Thread.sleep(1000);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
        System.out.println(""in run"");
    }
}   ",1711,False
"/**
 * Return a list with nodes that are inside the bounding box specified by 
 * the parameter. No nodes will be removed from the tree. 
 * 
 * @param bb the bounding box to compare with. 
 * @param v the vector where the removed node will be added to. 
 */
public synchronized void getNodesInside(BoundingBox bb, Vector v){
    if (iNode != null) {
        v.addElement(iNode);
    } else {            
        // For all 4 leaves of the node
        for (int i=0; i<4; i++) {
            // Check if the leaf exist
            if (iQTQuater[i] != null) {
                // Check to see if the whole or a part of the region is inside the bounding box
                if (iQTQuater[i].getBoundingBox().overlaps(bb) || iQTQuater[i].getBoundingBox().intersectWith(bb)) {
                    iQTQuater[i].getNodesInside(bb, v);
                }
            }
        }
    }
}","/**
 * Return a list with nodes that are inside the bounding box specified by 
 * the parameter. No nodes will be removed from the tree. 
 * 
 * @param bb the bounding box to compare with. 
 * @param v the vector where the removed node will be added to. 
 */
public synchronized void getNodesInside(BoundingBox bb, Vector v) 
{
    if (root != null) {
        root.getNodesInside(bb, v);
    }
}   ",1713,True
"/**
 * Tests that the constructor does not allow null categoryImageName. 
 */
public final void testNullCtorParam6(){
    try {
        OneListSearchMatchImpl o =
            new OneListSearchMatchImpl(
                    BasicSearchMatchImplTest.MATCH_ID,
                    BasicSearchMatchImplTest.MATCH_LOCATION,
                    BasicSearchMatchImplTest.MATCH_NAME,
                    BasicSearchMatchImplTest.MATCH_POSITION,
                    OneListSearchMatchImplTest.BRAND_IMAGE_NAME,
                    null,
                    OneListSearchMatchImplTest.PROVIDER_IMAGE_NAME);
            fail(""OneListSearchMatchImpl ctor must not allow null categoryImageName"");
                                        
    } catch (IllegalArgumentException e) {
    }
}","/**
 * Tests that the constructor does not allow null categoryImageName. 
 */
public final void testNullCtorParam6() 
{
    try
    {
        new CategoryImageName(null);
        fail(""Expected an IllegalArgumentException to be thrown."");
    }
    catch (IllegalArgumentException e)
    {
        // Expected.
    }
}   ",1714,True
"/*
 * Internal method for adding a entry to the current node or
 * recursively subdividing the items into one of the sub nodes.   
 * 
 * @param aEntry the entry to be added into a node
 * @return true if the node has been split into sub-nodes, 
 *         false if the entry has been added into a existing node.  
 * 
 */
private boolean internalAddEntry(QuadTreeEntry aEntry, QTFileInterface fileLoader){
    
    if(hasChildren()) {
        iHasBeenSplit = addEntry(aEntry, fileLoader);
    } else {        
        if(iNode == null) {
            iHasBeenSplit = true;
            iNode = new QuadTreeNode(iName,
                                     iQT_bb.getSouthLatitude(), 
                                     iQT_bb.getWestLongitude(),
                                     iQT_bb.getNorthLatitude(),
                                     iQT_bb.getEastLongitude());
        } else {
            if(iNode.shouldDataBeLoaded() && fileLoader != null) {
                if(LOG.isInfo()) {
                    LOG.info(""QuadTree.internalAddEntry()"", ""Load node from file, name: ""+iNode.getName());
                }
                
                // Load the node from file and add QuadTreeEntrys into the node.  
                fileLoader.readNodeFromFile(iNode);
            }
        }
        
        /* Add the enty to the nodes list*/            
        iNode.addEntry(aEntry);
        
        /* If we have exceed the maximal number of item in the node we split 
         * up them into 4 sub-nodes. */
        if(iNode.getSize() >= iMaxItems && iNode.getRadius() > MIN_RADIUS ) {
            
            iHasBeenSplit = true;
            QuadTreeEntry qte = iNode.getAllEntrys();
            
            if(LOG.isTrace()) {
                LOG.trace(""QuadTree.internalAddEntry()"", 
                        "" iNbrOfEntrys= ""+iNode.getSize()+
                        "" iMaxItems= ""+iMaxItems+
                        "" iCacheRegion.size= ""+iNode.getSize()+
                        "" name= ""+iName);
            }
            
            /* Go throw all the entrys in the node and move it down
             * one level in the tree. */
            do {
                QuadTreeEntry tmp = qte;
                qte = qte.getNext();
                tmp.setNext(null);
                addEntry(tmp, fileLoader);                                
            } while (qte != null);
              
            /* Clear and delete the node, the entrys has been split up in 
             * new leaves one level down in the tree. */
            if(fileLoader != null)
                fileLoader.deleteFile(iNode.getName());
            iNode.clear();
            iNode = null;
            
            if(fileLoader != null) {
                /* Write all nodes to disc when we have split up a node into 4 sub nodes.*/ 
                for(int i=0; i < 4; i++) {
                    if(iQTQuater[i] != null && iQTQuater[i].iNode != null) {
                        if(iQTQuater[i].iNode.getAllEntrys() != null) {
                            fileLoader.writeNodeToFile(iQTQuater[i].iNode);
                            iQTQuater[i].iNode.clear();
                        } 
                    } 
                }
            }
        }
    }
    return iHasBeenSplit;
}","/*
 * Internal method for adding a entry to the current node or
 * recursively subdividing the items into one of the sub nodes.   
 * 
 * @param aEntry the entry to be added into a node
 * @return true if the node has been split into sub-nodes, 
 *         false if the entry has been added into a existing node.  
 * 
 */
private boolean internalAddEntry(QuadTreeEntry aEntry, QTFileInterface fileLoader) 
{
    if (this.isLeafNode())
    {
        if (this.entries.size() < this.maxEntries)
        {
            this.entries.add(aEntry);
            return false;
        }
        else
        {
            this.subdivide(fileLoader);
            return true;
        }
    }
    else
    {
        int quadrant = getQuadrantForEntry(aEntry);
        if (this.children[quadrant].internalAddEntry(aEntry, fileLoader))
        {
            this.entries.add(aEntry);
            return true;
        }
        else
        {
            return false;
        }
    }
}   ",1715,False
"/**
 * Tests that the constructor does not allow null matchID. 
 */
public final void testNullCtorParam1(){
    try {
        OneListSearchMatchImpl o =
            new OneListSearchMatchImpl(
                    null,
                    BasicSearchMatchImplTest.MATCH_LOCATION,
                    BasicSearchMatchImplTest.MATCH_NAME,
                    BasicSearchMatchImplTest.MATCH_POSITION,
                    OneListSearchMatchImplTest.BRAND_IMAGE_NAME,
                    OneListSearchMatchImplTest.CATEGORY_IMAGE_NAME,
                    OneListSearchMatchImplTest.PROVIDER_IMAGE_NAME);
            fail(""OneListSearchMatchImpl ctor must not allow null matchID"");
                                        
    } catch (IllegalArgumentException e) {
    }
}","/**
 * Tests that the constructor does not allow null matchID. 
 */
public final void testNullCtorParam1() 
{
    try
    {
        new Match(null, new Player(""player1""), new Player(""player2""));
        fail(""Expected NullPointerException"");
    }
    catch (NullPointerException e)
    {
        // Expected
    }
}   ",1717,True
"//schemas.dmtf.org/ovf/envelope/1"", name = ""VirtualHardwareSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<VirtualHardwareSectionType> createVirtualHardwareSection(
        VirtualHardwareSectionType value){
        return new JAXBElement<VirtualHardwareSectionType>(_VirtualHardwareSection_QNAME,
            VirtualHardwareSectionType.class,
            null,
            value);
    }","//schemas.dmtf.org/ovf/envelope/1"", name = ""VirtualHardwareSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<VirtualHardwareSectionType> createVirtualHardwareSection(
        VirtualHardwareSectionType value) 
{
    return new JAXBElement<VirtualHardwareSectionType>(
            _VirtualHardwareSection_QNAME,
            VirtualHardwareSectionType.class,
            null,
            value);
}       ",1720,True
"/**
 * Resets the virtual machine.
 */
public void resetMachine(){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","/**
 * Resets the virtual machine.
 */
public void resetMachine() 
{
    // Reset the registers
    for (int i = 0; i < registers.length; i++)
    {
        registers[i] = 0;
    }

    // Reset the memory
    for (int i = 0; i < memory.length; i++)
    {
        memory[i] = 0;
    }

    // Reset the program counter
    programCounter = 0;
}   ",1724,False
"/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#deleteMachine()
 */
@Override
public void deleteMachine(){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#deleteMachine()
 */
@Override
public void deleteMachine() 
{
    try
    {
        getProvider().deleteVirtualMachine(this);
    }
    catch (Exception e)
    {
        throw new AbiquoException(""Cannot delete virtual machine"", e);
    }
}   ",1725,False
"// TODO
/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#setCurrentSnapshot(java.util .UUID)
 */
public void setCurrentSnapshot(UUID id){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","// TODO
/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#setCurrentSnapshot(java.util .UUID)
 */
public void setCurrentSnapshot(UUID id) 
{
    if (id == null)
    {
        throw new IllegalArgumentException(""id cannot be null"");
    }
    this.currentSnapshot = id;
}   ",1726,False
"// TODO
/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#populateEvent()
 */
public void populateEvent(){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","// TODO
/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#populateEvent()
 */
public void populateEvent() 
{
    if (this.getTask() != null)
    {
        this.setEvent(this.getTask().getEvent());
    }
    else
    {
        this.setEvent(null);
    }
}   ",1728,False
"/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#findSnapshot(java.lang.String )
 */
public void findSnapshot(String name){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","/*
 * (non-Javadoc)
 * @see com.abiquo.abicloud.model.AbsVirtualMachine#findSnapshot(java.lang.String )
 */
public void findSnapshot(String name) 
{
    for (Snapshot snapshot : snapshots)
    {
        if (snapshot.getName().equals(name))
        {
            this.snapshot = snapshot;
            break;
        }
    }
}   ",1729,True
"/**
 * Resumes the virtual machine execution.
 */
public void resumeMachine(){
    String msg = ""This method is not implemented for this hypervisor plugin"";
    logger.error(msg);
}","/**
 * Resumes the virtual machine execution.
 */
public void resumeMachine() 
{
    if (isRunning)
    {
        return;
    }

    isRunning = true;

    while (isRunning)
    {
        Instruction instruction = memory.getInstruction(pc);
        instruction.execute(this);
    }
}   ",1730,False
"//schemas.dmtf.org/ovf/envelope/1"", name = ""DiskSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<DiskSectionType> createDiskSection(DiskSectionType value){
        return new JAXBElement<DiskSectionType>(_DiskSection_QNAME,
            DiskSectionType.class,
            null,
            value);
    }","//schemas.dmtf.org/ovf/envelope/1"", name = ""DiskSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<DiskSectionType> createDiskSection(DiskSectionType value) 
{
    return new JAXBElement<DiskSectionType>(_DiskSection_QNAME, DiskSectionType.class, null, value);
}   ",1733,True
"/**
 * Return a new IPNetworkRang for a given DatacenterIPHB Pojo
 */
protected IPNetworkRang setNetworkRang(DatacentersIPHB rang){
    return new IPNetworkRang(IPAddress.newIPAddress(rang.getFirstIP()), IPAddress
        .newIPAddress(rang.getLastIP()), rang.getNumNodes());
}","/**
 * Return a new IPNetworkRang for a given DatacenterIPHB Pojo
 */
protected IPNetworkRang setNetworkRang(DatacentersIPHB rang) 
{
    IPNetworkRang networkRang = new IPNetworkRang();
    networkRang.setNetworkAddress(rang.getNetworkAddress());
    networkRang.setBroadcastAddress(rang.getBroadcastAddress());
    return networkRang;
}   ",1734,False
"/**
 * Instantiates a new KVM machine.
 * 
 * @param config the config
 * @throws VirtualMachineException the virtual machine exception
 */
public KVMMachine(VirtualMachineConfiguration config) throws VirtualMachineException{
    super(config);

    if (config.isSetHypervisor() & config.getHyper() instanceof KVMHypervisor)
    {
        KVMHyper = (KVMHypervisor) config.getHyper();
    }
    else
    {
        throw new VirtualMachineException(""KVMMachine requires a KVMHypervisor ""
            + ""on VirtualMachineConfiguration, not a ""
            + config.getHyper().getClass().getCanonicalName());
    }

    machineName = config.getMachineName();
}","/**
 * Instantiates a new KVM machine.
 * 
 * @param config the config
 * @throws VirtualMachineException the virtual machine exception
 */
public KVMMachine(VirtualMachineConfiguration config) throws VirtualMachineException 
{
    super(config);
    this.kvm = new KVM();
}   ",1735,True
"//schemas.dmtf.org/ovf/envelope/1"", name = ""ProductSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<ProductSectionType> createProductSection(ProductSectionType value){
        return new JAXBElement<ProductSectionType>(_ProductSection_QNAME,
            ProductSectionType.class,
            null,
            value);
    }","//schemas.dmtf.org/ovf/envelope/1"", name = ""ProductSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<ProductSectionType> createProductSection(ProductSectionType value) 
{
    return new JAXBElement<ProductSectionType>(_ProductSection_QNAME, ProductSectionType.class, null, value);
}   ",1738,True
"//schemas.dmtf.org/ovf/envelope/1"", name = ""OperatingSystemSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<OperatingSystemSectionType> createOperatingSystemSection(
        OperatingSystemSectionType value){
        return new JAXBElement<OperatingSystemSectionType>(_OperatingSystemSection_QNAME,
            OperatingSystemSectionType.class,
            null,
            value);
    }","//schemas.dmtf.org/ovf/envelope/1"", name = ""OperatingSystemSection"", substitutionHeadNamespace = ""http://schemas.dmtf.org/ovf/envelope/1"", substitutionHeadName = ""Section"")
public JAXBElement<OperatingSystemSectionType> createOperatingSystemSection(
        OperatingSystemSectionType value) 
{
    return new JAXBElement<OperatingSystemSectionType>(
            _OperatingSystemSection_QNAME,
            OperatingSystemSectionType.class,
            null,
            value
    );
}       ",1739,True
"//    @Override
//    public Progress explore(Progress progress, boolean ignore) {
//        Progress after = child.explore(progress, ignore);
//        after.getState().setGoto(progress.getState());
//        return after;
//    }
@Override
    public boolean findStarts(Set<String> list){
        child.findStarts(list);
        return true;
    }","//    @Override
//    public Progress explore(Progress progress, boolean ignore) {
//        Progress after = child.explore(progress, ignore);
//        after.getState().setGoto(progress.getState());
//        return after;
//    }
@Override
    public boolean findStarts(Set<String> list) 
{
    return child.findStarts(list);
}   ",1742,True
"//    public Node getPrevWrapped() {
//        if (prev == null) {
//            return parent.last;
//        }
//        return prev;
//    }
public String getShortName(){
        int ix = name.indexOf('_');
        if (ix > 0) {
            return name.substring(0, ix);
        }
        return name;
    }","//    public Node getPrevWrapped() {
//        if (prev == null) {
//            return parent.last;
//        }
//        return prev;
//    }
public String getShortName() 
{
    String[] names = getClass().getName().split(""\\."");
    return names[names.length - 1];
}   ",1743,False
"/**
 * def each(array~Any, null) throws NullPointerException
 * def each(null, cl~Any) does nothing
 * def each(array~[Any], cl~Closure) invokes closure with each element
 * def each(array~Iterable, cl~Closure) invokes closure with each element
 *
 * @param array
 * @param cl
 */
public static void each(Object array, Closure cl){
    if (cl == null) throw new NullPointerException(""missing closure"");
    if (array == null) return;
    if (array.getClass().isArray()) {
        synchronized(array) {
            try {
                for (int ix = 0, iz = Array.getLength(array); ix < iz; ix++) {
                    Object elem = Array.get(array, ix);
                    cl.invoke(elem);
                }
            } catch (Notice ex) {
            }
        }
    } else if (array instanceof Iterable) {
        each((Iterable) array, cl);
    } else {
        throw new IllegalArgumentException(""unsupported type: "" + array.getClass());
    }
}","/**
 * def each(array~Any, null) throws NullPointerException
 * def each(null, cl~Any) does nothing
 * def each(array~[Any], cl~Closure) invokes closure with each element
 * def each(array~Iterable, cl~Closure) invokes closure with each element
 *
 * @param array
 * @param cl
 */
public static void each(Object array, Closure cl) 
{
    if (array == null)
    {
        throw new NullPointerException(""array"");
    }
    if (cl == null)
    {
        return;
    }
    if (array instanceof Object[])
    {
        Object[] objects = (Object[])array;
        for (Object object : objects)
        {
            cl.call(object);
        }
    }
    else if (array instanceof Iterable)
    {
        Iterable iterable = (Iterable)array;
        for (Object object : iterable)
        {
            cl.call(object);
        }
    }
    else
    {
        throw new IllegalArgumentException(""array"");
    }
}   ",1745,True
"//    private String methodSignature(Node node) {
//        StringBuilder buff = new StringBuilder();
//        buff.append(node.getValue().toString());
//        node = node.getNext();
//        buff.append('(');
//        String comma = """";
//        while (node != null) {
//            buff.append(comma);
//            comma = "","";
//            buff.append(node.getTypeName());
//            node = node.getNext();
//        }
//        buff.append(')');
//        return buff.toString();
//    }
@Override
    public void open(){
        addKeyword(""def"");
        addKeyword(""then"");
        addKeyword(""do"");
        addKeyword(""else"");
        addKeyword(""end"");

        addParser(""array"", ""expression- symbol- < !start_bracket (@expression !comma?)* @expression? !end_bracket"");

        addParser(""call_dot"", ""@expression1 !operator_dot symbol !start_paren (@expression (!comma? @expression)*)? !end_paren"");
        addParser(""call_dot"", ""@expression1 !operator_dot symbol @expression (!comma? @expression)*"");

        addParser(""call_this"", ""symbol !start_paren (@expression (!comma? !terminator* @expression)*)? !end_paren"");
        addParser(""call_this"", ""symbol @expression ((!comma !terminator* | comma?) @expression)* > terminator | keyword_else | keyword_end"");

        addParser(""reference_dot"", ""@expression1 !operator_dot symbol"");
        addParser(""reference_array"", ""@expression1 !start_bracket @expression (!comma? @expression)* !end_bracket"");

//        addParser(""expression_symbol"", ""keyword_var- keyword_val- keyword_def- | statement_valAssign comma < symbol"");
        addParser(""expression0"", ""array"");
        addParser(""expression0"", ""symbol > operator_eq- operator_assign- start_paren- expression-"");
        addParser(""expression0"", ""symbol- < !start_paren @expression !end_paren"");
        addParser(""expression1"", ""call"");
        addParser(""expression1"", ""reference > operator_eq- operator_assign-"");
        addParser(""expression1"", ""@expression1 ^cast | @expression0"");
        addParser(""expression2"", ""@expression1 operator_dot- (^operator_pow @expression1)*"");
        addParser(""expression3"", ""@expression2 (^operator_mul @expression2)*"");
        addParser(""expression4"", ""@expression3 (^operator_add @expression3)*"");
        // see Range for expression5
        addParser(""expression6"", ""@expression5 (^operator_compare @expression5)?"");
        addParser(""expression7"", ""@expression6 (^operator_other @expression6)*"");
        addParser(""expression"", ""(reference | symbol) ((^operator_assign | ^operator_eq) @expression)+ | @expression7"");

        if (isMain) addParser(""compilation"", ""!terminator_bof !terminator* expression (terminator_eof- !terminator)* !terminator_eof"");
    }","//    private String methodSignature(Node node) {
//        StringBuilder buff = new StringBuilder();
//        buff.append(node.getValue().toString());
//        node = node.getNext();
//        buff.append('(');
//        String comma = """";
//        while (node != null) {
//            buff.append(comma);
//            comma = "","";
//            buff.append(node.getTypeName());
//            node = node.getNext();
//        }
//        buff.append(')');
//        return buff.toString();
//    }

@Override
    public void open() 
{
    try {
        if (this.out == null) {
            this.out = new PrintWriter(this.outputFile);
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}   ",1746,False
"//    @SuppressWarnings(""Unchecked"")
private static Class<Backend> findClass(Node node, String backend) throws ClassNotFoundException{
        String nodeName = node.getName();
        String nodeVar = """";
        int dot = nodeName.indexOf('_');
        if (dot > 0) {
            nodeVar = nodeName.substring(dot + 1);
            nodeName = nodeName.substring(0, dot);
        }
        String className = ""org.neo.back."" + N.capitalize(backend) + N.capitalize(nodeName) + N.capitalize(nodeVar);
        Class<Backend> type;
        try {
            type = (Class<Backend>) Engine.engine().loadClass(className);
        } catch (ClassNotFoundException ex) {
            className = ""org.neo.back."" + N.capitalize(backend) + N.capitalize(nodeName);
            type = (Class<Backend>) Engine.engine().loadClass(className);
        }
        return type;
    }","//    @SuppressWarnings(""Unchecked"")
private static Class<Backend> findClass(Node node, String backend) throws ClassNotFoundException 
{
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    if (classLoader == null)
    {
        classLoader = Backend.class.getClassLoader();
    }
    return (Class<Backend>)classLoader.loadClass(backend);
}   ",1747,False
"//    protected void renderExpression(Node node) {
//        boolean needBoolean = !""boolean"".equals(getConditionLeg(node).getTypeName());
//        CodeBuilder buff = JavaCompilation.output();
//        buff
//        throw new UnsupportedOperationException(""Not yet implemented"");
//    }
@Override
    protected void renderTail(Node node, CodeBuilder buff){
        Node mainLeg = getMainLeg(node);
        Node elseLeg = getElseLeg(node);
        if (elseLeg != null) {
            buff.append("") {"").eol().tabMore();
            mainLeg.render(""java"");
            buff.tabLess().tab().append(""}"");
            elseLeg.render(""java"");
        } else {
            super.renderTail(node, buff);
        }
    }","//    protected void renderExpression(Node node) {
//        boolean needBoolean = !""boolean"".equals(getConditionLeg(node).getTypeName());
//        CodeBuilder buff = JavaCompilation.output();
//        buff
//        throw new UnsupportedOperationException(""Not yet implemented"");
//    }
@Override
    protected void renderTail(Node node, CodeBuilder buff) 
{
    if (node.getTail() != null)
    {
        buff.append("" && "");
        renderExpression(node.getTail(), buff);
    }
}   ",1751,True
"//    public static final String REAL_FORCED = ""number_real_forced"";
@Override
    public Token consume(String name, int chars, Object value, String type){
        String text = Engine.chars(chars).toString();
        if (name.equals(TRUE) || name.equals(FALSE)) {
            value = text;
            type = ""boolean"";
        } else if (name.equals(NULL)) {
        } else if (name.equals(LONG)) {
                // Note, Java won't ignore the trailing 'l' here
            value = new Long(text.substring(0, text.length() - 1));
            type = ""long"";
        } else if (name.equals(LONG + ""Binary"")) {
            value = Long.parseLong(text.substring(2, text.length() - 1), 2);
            type = ""long"";
        } else if (name.equals(LONG + ""Octal"")) {
            value = Long.parseLong(text.substring(1, text.length() - 1), 8);
            type = ""long"";
        } else if (name.equals(LONG + ""Hex"")) {
            value = Long.parseLong(text.substring(2, text.length() - 1), 16);
            type = ""long"";
        } else if (name.equals(INTEGER)) {
            value = new Integer(text);
            type = ""int"";
        } else if (name.equals(INTEGER + ""Binary"")) {
            value = Integer.parseInt(text.substring(2, text.length()), 2);
            type = ""long"";
        } else if (name.equals(INTEGER + ""Octal"")) {
            value = Integer.parseInt(text.substring(1, text.length()), 8);
            type = ""long"";
        } else if (name.equals(INTEGER + ""Hex"")) {
            value = Integer.parseInt(text.substring(2, text.length()), 16);
            type = ""long"";
        } else {
                // Note, Java will ignore the trailing 'f'
            if (text.toLowerCase().endsWith(""f"")) {
                value = new Float(text);
                type = ""float"";
            } else {
                value = new Double(text);
                type = ""double"";
            }
        }
        return super.consume(name, chars, value, type);
    }","//    public static final String REAL_FORCED = ""number_real_forced"";
@Override
    public Token consume(String name, int chars, Object value, String type) 
{
    Token token = new Token(name, chars, value, type);
    tokens.add(token);
    return token;
}   ",1757,False
"//    static Progress create(Production production, int index) {
//        return create(production, index, null);
//    }
//
//    static Progress create(Production production, int index, State state) {
//        Progress progress = new Progress(production, index, state);
//        Progress progress1 = Engine.engine().getProgress(progress);
//        if (progress1 != null) return progress1;
//        Engine.engine().index(progress);
//        return progress;
//    }
@Override
    public boolean equals(Object obj){
        if (obj == null) return false;
        if (!(obj instanceof Progress)) return false;
        if (this.production != production) return false;
        if (this.index != index) return false;
        return true;
    }","//    static Progress create(Production production, int index) {
//        return create(production, index, null);
//    }
//
//    static Progress create(Production production, int index, State state) {
//        Progress progress = new Progress(production, index, state);
//        Progress progress1 = Engine.engine().getProgress(progress);
//        if (progress1 != null) return progress1;
//        Engine.engine().index(progress);
//        return progress;
//    }
@Override
    public boolean equals(Object obj) 
{
    if (obj instanceof Progress)
    {
        Progress progress = (Progress)obj;
        return this.production == progress.production && this.index == progress.index;
    }
    return false;
}   ",1758,True
"/**
 * Create a new HttpClient with reasonable defaults (which you can update).
 * @param userAgent to report in your HTTP requests.
 * @return FailfastHttpClient for you to use for all your requests.
 */
public static FailfastHttpClient newInstance(String userAgent){
    HttpParams params = new BasicHttpParams();

    // Turn off stale checking.  Our connections break all the time anyway,
    // and it's not worth it to pay the penalty of checking every time.
    HttpConnectionParams.setStaleCheckingEnabled(params, false);

    // Default connection and socket timeout of 10 seconds.  Tweak to taste.
    HttpConnectionParams.setConnectionTimeout(params, CONNECT_TIMEOUT);
    HttpConnectionParams.setSoTimeout(params, READ_TIMEOUT);
    HttpConnectionParams.setSocketBufferSize(params, 8192);

    // Don't handle redirects -- return them to the caller.  Our code
    // often wants to re-POST after a redirect, which we must do ourselves.
    HttpClientParams.setRedirecting(params, false);

    // Set the specified user agent and register standard protocols.
    if (userAgent != null)
    	HttpProtocolParams.setUserAgent(params, userAgent);

    SchemeRegistry schemeRegistry = new SchemeRegistry();
    schemeRegistry.register(new Scheme(""http"",
            PlainSocketFactory.getSocketFactory(), 80));
    ClientConnectionManager manager =
            new HackThreadSafeClientConnManager(params, schemeRegistry);

    // We use a factory method to modify superclass initialization
    // parameters without the funny call-a-static-method dance.
    return new FailfastHttpClient(manager, params);
}","/**
 * Create a new HttpClient with reasonable defaults (which you can update).
 * @param userAgent to report in your HTTP requests.
 * @return FailfastHttpClient for you to use for all your requests.
 */

public static FailfastHttpClient newInstance(String userAgent) 
{
    CloseableHttpClient httpClient = HttpClients.custom()
            .setUserAgent(userAgent)
            .build();
    return new FailfastHttpClient(httpClient);
}   ",1761,False
"/**
 * Fatal error attempting to either start or bind to the service specified
 * by {@link getServiceIntent}.  Will not retry.  Default implementation is
 * to throw up an error and finish().
 */
protected void onServiceFatal(){
	Log.e(TAG, ""Unable to start service: "" + getServiceIntent());

	(new AlertDialog.Builder(this))
	  .setIcon(android.R.drawable.ic_dialog_alert)
	  .setTitle(""Sorry!"")
	  .setMessage(R.string.app_error_msg)
	  .create().show();

	finish();
}","/**
 * Fatal error attempting to either start or bind to the service specified
 * by {@link getServiceIntent}.  Will not retry.  Default implementation is
 * to throw up an error and finish().
 */
protected void onServiceFatal() 
{
    throw new RuntimeException(""Fatal error attempting to either start or bind to the service specified by "" + getServiceIntent().toString());
}   ",1762,False
"/**
 * Creates a directory if it does not already exist. Throws an exception if
 * unable to do so.
 *
 * @param file Path to create.
 * @throws FileNotFoundException
 *             If the directory could not be made or the entry already
 *             exists but is not a directory.
 */
public static void mkdirIfNecessary(File file) throws FileNotFoundException{
	if (file.exists())
	{
		if (!file.isDirectory())
		{
			throw new FileNotFoundException(""Path already exists, but is not a directory: "" +
					file.getAbsolutePath());
		}
	}
	else if (!file.mkdirs())
	{
		throw new FileNotFoundException(""Could not create directory: "" +
				file.getAbsolutePath());
	}
}","/**
 * Creates a directory if it does not already exist. Throws an exception if
 * unable to do so.
 *
 * @param file Path to create.
 * @throws FileNotFoundException
 *             If the directory could not be made or the entry already
 *             exists but is not a directory.
 */


public static void mkdirIfNecessary(File file) throws FileNotFoundException 
{
    if (!file.exists())
    {
        if (!file.mkdirs())
        {
            throw new FileNotFoundException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    else if (!file.isDirectory())
    {
        throw new FileNotFoundException(""File exists and is not a directory: "" + file.getAbsolutePath());
    }
}   ",1766,True
"/**
 * Delete a file or directory. If a directory, deletes all files underneath
 * and the directory itself.
 *
 * @throws IOException
 *             if this function failed to delete the file
 *
 * @see #emptyDirectory
 */
public static void deleteFileOrDirectory(File path) throws IOException{
    	if (path.isDirectory())
    		deleteDirectory(path);
    	else if (path.exists())
    	{
    		if (!path.delete())
    			throw new IOException(""failed to delete file: "" + path);
    	}
    }","/**
 * Delete a file or directory. If a directory, deletes all files underneath
 * and the directory itself.
 *
 * @throws IOException
 *             if this function failed to delete the file
 *
 * @see #emptyDirectory
 */

public static void deleteFileOrDirectory(File path) throws IOException 
{
    if (path.isDirectory())
    {
        emptyDirectory(path);
    }

    if (!path.delete())
    {
        throw new IOException(""Unable to delete "" + path);
    }
}   ",1768,True
"/**
 * Enables cURL request logging for this client.
 *
 * @param name to log messages with
 * @param level at which to log messages (see {@link android.util.Log})
 */
public void enableCurlLogging(String name, int level){
    if (name == null) {
        throw new NullPointerException(""name"");
    }
    if (level < Log.VERBOSE || level > Log.ASSERT) {
        throw new IllegalArgumentException(""Level is out of range [""
            + Log.VERBOSE + "".."" + Log.ASSERT + ""]"");
    }

    curlConfiguration = new LoggingConfiguration(name, level);
}","/**
 * Enables cURL request logging for this client.
 *
 * @param name to log messages with
 * @param level at which to log messages (see {@link android.util.Log})
 */
public void enableCurlLogging(String name, int level) 
{
    if (name == null) {
        throw new NullPointerException(""name"");
    }

    nativeEnableCurlLogging(name, level);
}   ",1777,True
"/**
 * Get or start a download for the request song id.
 *
 * @return The download instance (either recently started, or reacquired
 *         from an existing download) if the song is not in cache;
 *         otherwise, null.
 *
 * @throws IOException
 *             When the download destination path cannot be opened for
 *             writing.
 * @throws CacheAllocationException
 */
private DownloadManager.Download acquireDownload(SongItem song)
		throws IOException, CacheAllocationException{
	SourceItem source = SourceItem.getInstance(this, Sources.makeUri(song.getSourceId()));

	try {
		long songId = song.getId();
		String url = source.getSongUrl(song.getSyncId());
		long size = song.getSize();
		String cachePath = song.getCachePath();

		Log.v(TAG, ""Preparing to download [url="" + url + ""; size="" + size +
				""; cachePath="" + cachePath + ""]"");

		long resumeFrom = 0;

		if (cachePath != null)
		{
			resumeFrom = (new File(cachePath)).length();

			if (resumeFrom == size)
			{
				Log.i(TAG, ""Cache hit, download of "" + cachePath + "" already complete!"");
				return null;
			}
			else
			{
				Log.i(TAG, ""Partial cache hit, resuming from "" +
						cachePath + "" at "" + resumeFrom);

				/*
				 * XXX: We have a small race condition possibility here
				 * since we aren't synchronizing anything. The download
				 * might have just finished, in which case our lookup would
				 * yield null, but we'll foolishly try a resumed download
				 * for a very small section of the file.
				 */
				DownloadManager.Download download = mManager.lookupDownload(songId);
				if (download != null)
					return download;
			}
		}
		else
		{
			if (mManager.lookupDownload(songId) != null)
				throw new IllegalStateException(""Download started, but did not register with the cache."");

			cachePath = mCacheMgr.requestStorage(this, song.getSourceId(), song.getSyncId());
		}

		/*
		 * We only allow 1 download at a time, so invoking this method
		 * implicitly asks for all other downloads to be canceled.
		 */
		mManager.stopAllDownloads();

		mManager.updateCredentials(source);

		try {
			return mManager.startDownload(songId, url, cachePath, size, resumeFrom);
		} catch (IOException e) {
			mManager.stopDownload(songId);
			throw e;
		}
	} finally {
		if (source != null)
			source.close();
	}
}","/**
 * Get or start a download for the request song id.
 *
 * @return The download instance (either recently started, or reacquired
 *         from an existing download) if the song is not in cache;
 *         otherwise, null.
 *
 * @throws IOException
 *             When the download destination path cannot be opened for
 *             writing.
 * @throws CacheAllocationException
 */

private DownloadManager.Download acquireDownload(SongItem song)
		throws IOException, CacheAllocationException 
{
	DownloadManager.Download download = null;
	if (song != null)
	{
		download = this.downloads.get(song.getId());
		if (download == null)
		{
			File file = new File(this.cachePath, song.getId());
			download = new DownloadManager.Download(song, file);
			this.downloads.put(song.getId(), download);
		}
	}
	return download;
}	",1778,True
"/**
 * Special case which asks us to keep a sensible back stack while
 * mechanizing the user toward the initial SourceAdd screen.
 */
public static void showThenStartSourceAdd(Context context){
	context.startActivity(new Intent(context, Settings.class)
			.putExtra(Constants.EXTRA_START_SOURCE_ADD, true));
}","/**
 * Special case which asks us to keep a sensible back stack while
 * mechanizing the user toward the initial SourceAdd screen.
 */

public static void showThenStartSourceAdd(Context context) 
{
    Intent intent = new Intent(context, SourceAdd.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    context.startActivity(intent);
}   ",1779,True
"/**
 * * Defines an implicit conversion of MessageBody into a string.
 * 
 * @param messageBody
 *            The MessageBody to convert to a string.
 * @return A string containing the text of the MessageBody.
 * @throws Exception
 *             the exception
 */
public static String getStringFromMessageBody(MessageBody messageBody)
		throws Exception{
	EwsUtilities.validateParam(messageBody, ""messageBody"");
	return messageBody.text;
}","/**
 * * Defines an implicit conversion of MessageBody into a string.
 * 
 * @param messageBody
 *            The MessageBody to convert to a string.
 * @return A string containing the text of the MessageBody.
 * @throws Exception
 *             the exception
 */
public static String getStringFromMessageBody(MessageBody messageBody)
		throws Exception 
{
	String result = null;
	if (messageBody != null)
	{
		result = messageBody.getText();
	}
	return result;
}	",1782,True
"/**
 * Writes the attributes to XML.
 * 
 * @param writer
 *            the writer
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeAttributesToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException{
	super.writeAttributesToXml(writer);
	writer.writeAttributeValue(XmlAttributeNames.ItemId, this.getItemId());
}","/**
 * Writes the attributes to XML.
 * 
 * @param writer
 *            the writer
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeAttributesToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException 
{
	writer.writeAttributeValue(XmlAttributeNames.Name, this.name);
	writer.writeAttributeValue(XmlAttributeNames.Value, this.value);
}	",1785,True
"/***
 * Sets the text of the message body.
 * 
 * @param text
 *            message body text
 */
public void setText(String text){
	if (this.canSetFieldValue(this.text, text)) {
		this.text = text;
		this.changed();
	}
}","/***
 * Sets the text of the message body.
 * 
 * @param text
 *            message body text
 */
public void setText(String text) 
{
    if (text != null)
    {
        this.text = text;
    }
    else
    {
        this.text = """";
    }
}   ",1787,True
"/**
 * * Reads attributes from XML.
 * 
 * @param reader
 *            The reader.
 * @throws Exception
 *             the exception
 */
protected void readAttributesFromXml(EwsServiceXmlReader reader)
		throws Exception{
	this.bodyType = reader.readAttributeValue(BodyType.class,
			XmlAttributeNames.BodyType);
}","/**
 * * Reads attributes from XML.
 * 
 * @param reader
 *            The reader.
 * @throws Exception
 *             the exception
 */
protected void readAttributesFromXml(EwsServiceXmlReader reader)
		throws Exception 
{
	this.name = reader.readElementValue(XmlElementNames.Name);
	this.value = reader.readElementValue(XmlElementNames.Value);
}	",1789,True
"/**
 * * Writes elements to XML.
 * 
 * @param writer
 *            The writer.
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeElementsToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException{
	if (null != this.text && !this.text.isEmpty()) {
		writer.writeValue(this.getText(), XmlElementNames.Body);
	}
}","/**
 * * Writes elements to XML.
 * 
 * @param writer
 *            The writer.
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeElementsToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException 
{
	writer.writeElementValue(XmlNamespace.Types,
			XmlElementNames.Mailbox, this.getMailbox().getAddress());
}	",1791,True
"/**
 * Gets the value of the restrictedGroupIdentifier property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the restrictedGroupIdentifier property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getRestrictedGroupIdentifier().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link SidAndAttributesType }
 * 
 * 
 */
public List<SidAndAttributesType> getRestrictedGroupIdentifier(){
    if (restrictedGroupIdentifier == null) {
        restrictedGroupIdentifier = new ArrayList<SidAndAttributesType>();
    }
    return this.restrictedGroupIdentifier;
}","/**
 * Gets the value of the restrictedGroupIdentifier property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the restrictedGroupIdentifier property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getRestrictedGroupIdentifier().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link SidAndAttributesType }
 * 
 * 
 */
public List<SidAndAttributesType> getRestrictedGroupIdentifier() 
{
    if (restrictedGroupIdentifier == null)
    {
        restrictedGroupIdentifier = new ArrayList<SidAndAttributesType>();
    }
    return this.restrictedGroupIdentifier;
}   ",1793,True
"/**
 * Writes attributes to XML.
 * 
 * @param writer
 *            the writer
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeAttributesToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException{
	writer.writeAttributeValue(XmlAttributeNames.OccurrenceId, this
			.getUniqueId());
	writer.writeAttributeValue(XmlAttributeNames.ChangeKey, this
			.getChangeKey());
}","/**
 * Writes attributes to XML.
 * 
 * @param writer
 *            the writer
 * @throws ServiceXmlSerializationException
 *             the service xml serialization exception
 */
@Override
protected void writeAttributesToXml(EwsServiceXmlWriter writer)
		throws ServiceXmlSerializationException 
{
	writer.writeAttributeValue(XmlAttributeNames.Id, this.getId());
	writer.writeAttributeValue(XmlAttributeNames.Name, this.getName());
	writer.writeAttributeValue(XmlAttributeNames.Value, this.getValue());
}	",1795,True
"/***
 * Sets the type of the message body's text.
 * 
 * @param bodyType
 *            BodyType enum
 */
public void setBodyType(BodyType bodyType){
	if (this.canSetFieldValue(this.bodyType, bodyType)) {
		this.bodyType = bodyType;
		this.changed();
	}
}","/***
 * Sets the type of the message body's text.
 * 
 * @param bodyType
 *            BodyType enum
 */
public void setBodyType(BodyType bodyType) 
{
    if (bodyType == null)
    {
        throw new IllegalArgumentException(""BodyType cannot be null"");
    }
    this.bodyType = bodyType;
}   ",1796,True
"/**
 * Loads from XML.
 * 
 * @param reader
 *            the reader
 * @param propertyBag
 *            the property bag
 * @throws Exception
 *             the exception
 */
protected void loadPropertyValueFromXml(EwsServiceXmlReader reader,
		PropertyBag propertyBag) throws Exception{
	reader.ensureCurrentNodeIsStartElement(XmlNamespace.Types,
			XmlElementNames.Recurrence);

	Recurrence recurrence = null;

	reader.read(new XMLNodeType(XMLNodeType.START_ELEMENT)); // This is the
	// pattern
	// element

	if (reader.getLocalName().equals(
			XmlElementNames.RelativeYearlyRecurrence)) {

		recurrence = new Recurrence.RelativeYearlyPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.AbsoluteYearlyRecurrence)) {

		recurrence = new Recurrence.YearlyPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.RelativeMonthlyRecurrence)) {

		recurrence = new Recurrence.RelativeMonthlyPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.AbsoluteMonthlyRecurrence)) {

		recurrence = new Recurrence.MonthlyPattern();
	} else if (reader.getLocalName()
			.equals(XmlElementNames.DailyRecurrence)) {

		recurrence = new Recurrence.DailyPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.DailyRegeneration)) {

		recurrence = new Recurrence.DailyRegenerationPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.WeeklyRecurrence)) {

		recurrence = new Recurrence.WeeklyPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.WeeklyRegeneration)) {

		recurrence = new Recurrence.WeeklyRegenerationPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.MonthlyRegeneration)) {

		recurrence = new Recurrence.MonthlyRegenerationPattern();
	} else if (reader.getLocalName().equals(
			XmlElementNames.YearlyRegeneration)) {

		recurrence = new Recurrence.YearlyRegenerationPattern();
	} else {

		throw new ServiceXmlDeserializationException(String.format(
				Strings.InvalidRecurrencePattern, reader.getLocalName()));
	}

	recurrence.loadFromXml(reader, reader.getLocalName());

	reader.read(new XMLNodeType(XMLNodeType.START_ELEMENT)); // This is the
	// range
	// element

	RecurrenceRange range;

	if (reader.getLocalName().equals(XmlElementNames.NoEndRecurrence)) {

		range = new NoEndRecurrenceRange();
	} else if (reader.getLocalName().equals(
			XmlElementNames.EndDateRecurrence)) {

		range = new EndDateRecurrenceRange();
	} else if (reader.getLocalName().equals(
			XmlElementNames.NumberedRecurrence)) {

		range = new NumberedRecurrenceRange();
	} else {
		throw new ServiceXmlDeserializationException(String.format(
				Strings.InvalidRecurrenceRange, reader.getLocalName()));
	}

	range.loadFromXml(reader, reader.getLocalName());
	range.setupRecurrence(recurrence);

	reader.readEndElementIfNecessary(XmlNamespace.Types,
			XmlElementNames.Recurrence);

	propertyBag.setObjectFromPropertyDefinition(this, recurrence);
}","/**
 * Loads from XML.
 * 
 * @param reader
 *            the reader
 * @param propertyBag
 *            the property bag
 * @throws Exception
 *             the exception
 */
protected void loadPropertyValueFromXml(EwsServiceXmlReader reader,
		PropertyBag propertyBag) throws Exception 
{
	// Do nothing.
}	",1799,False
"/**
 * Rebuild the SessionFactory with the static Configuration.
 *
 */
public static void rebuildSessionFactory() throws Exception{
	synchronized (sessionFactory) {
		try {
			sessionFactory = getConfiguration().buildSessionFactory();
		}
		catch (Exception ex) {
			throw new Exception(ex);
		}
	}
}","/**
 * Rebuild the SessionFactory with the static Configuration.
 *
 */
public static void rebuildSessionFactory() throws Exception 
{
    try
    {
        Configuration configuration = Configuration.getInstance();
        sessionFactory = configuration.buildSessionFactory();
    }
    catch (Exception e)
    {
        System.out.println(e.getMessage());
        throw e;
    }
}   ",1821,True
"/**
 * 删除数据库中的表
 * @param conf
 * @param tableName
 * @throws Exception
 */
public static void dropTable(Configuration conf, String tableName) throws Exception{
	ConnectionProvider conPro = getConnection(conf);
	try {
		String sql = ""drop table "" + tableName;
		Connection con = conPro.getConnection();
		try {
			Statement sm = con.createStatement();
			try {
				sm.executeUpdate(sql);
			}
			finally {
				sm.close();
			}
		}
		finally {
			conPro.closeConnection(con);
		}
	}
	finally {
		conPro.close();
	}
}","/**
 * 删除数据库中的表
 * @param conf
 * @param tableName
 * @throws Exception
 */


public static void dropTable(Configuration conf, String tableName) throws Exception 
{
    Connection connection = null;
    Statement stmt = null;
    try
    {
        connection = getConnection(conf);
        stmt = connection.createStatement();
        stmt.executeUpdate(""drop table "" + tableName);
    }
    finally
    {
        close(stmt, connection);
    }
}   ",1822,True
"/**
 * Retrieves the current Session local to the thread.
 * <p/>
 * If no Session is open, opens a new Session for the running thread.
 *
 * @return Session
 */
public static Session getSession() throws Exception{
	Session s = (Session) threadSession.get();
	try {
		if (s == null) {
			if (getInterceptor() != null) {
				s = getSessionFactory().openSession(getInterceptor());
			}
			else {
				s = getSessionFactory().openSession();
			}
			threadSession.set(s);
		}
	}
	catch (HibernateException ex) {
		throw new Exception(ex);
	}
	return s;
}","/**
 * Retrieves the current Session local to the thread.
 * <p/>
 * If no Session is open, opens a new Session for the running thread.
 *
 * @return Session
 */
public static Session getSession() throws Exception 
{
    Session session = sessionThreadLocal.get();
    if (session == null)
    {
        session = sessionFactory.openSession();
        sessionThreadLocal.set(session);
    }
    return session;
}   ",1825,True
"/**
 * 测试调用Configuration.setProperties设置属性
 * 注意：调用Configuration.setProperties设置属性会将其他地方设置的属性全部去除，只剩下传入的Properties中的属性
 */
public void testConfSetProperties(){
	String propName = ""custm.config.setProperties"";
	String propValue = ""setProperties"";
	Properties props = new Properties();
	props.put(propName, propValue);

	Configuration conf = new Configuration();
	conf.setProperties(props);
	assertEquals(conf.getProperty(propName), propValue);
}","/**
 * 测试调用Configuration.setProperties设置属性
 * 注意：调用Configuration.setProperties设置属性会将其他地方设置的属性全部去除，只剩下传入的Properties中的属性
 */



public void testConfSetProperties() 
{
    Configuration conf = new Configuration();
    Properties properties = new Properties();
    properties.setProperty(""test1"", ""test1"");
    properties.setProperty(""test2"", ""test2"");
    conf.setProperties(properties);
    Assert.assertEquals(""test1"", conf.get(""test1""));
    Assert.assertEquals(""test2"", conf.get(""test2""));
}   ",1826,True
"/**
 * 测试设置jvm参数来配置hibernate属性
 * 注意：此方法必须在所有测试单元中第一个执行，因为jvm参数是在Environment中的静态块载入的，只会读取一次。
 */
public void testJvmProperty() throws IOException{
	String propName = ""custm.config.jvm.param"";
	String propValue = ""jvm.property"";
	System.setProperty(propName, propValue);
	Configuration conf = new Configuration();
	assertEquals(conf.getProperty(propName), propValue);
}","/**
 * 测试设置jvm参数来配置hibernate属性
 * 注意：此方法必须在所有测试单元中第一个执行，因为jvm参数是在Environment中的静态块载入的，只会读取一次。
 */

public void testJvmProperty() throws IOException 
{
    Properties prop = new Properties();
    prop.load(this.getClass().getResourceAsStream(""/jvm.properties""));
    Enumeration en = prop.propertyNames();
    while (en.hasMoreElements())
    {
        String key = (String) en.nextElement();
        String value = prop.getProperty(key);
        System.setProperty(key, value);
    }
}   ",1827,True
"/**
 * 测试在hibernate.cfg.xml中配置hibernate的熟悉，在该文件中定义了属性
 * <property name=""custom.config.hibernatecfg"">file.hibernate.cfg.xml</property>
 */
public void testFileHibernateCfgXml(){
	Configuration conf = new Configuration().configure(""/zcx/propertyconfig/propertyconfig-hibernate.cfg.xml"");
	assertEquals(conf.getProperty(""custom.config.hibernatecfg""), ""file.hibernate.cfg.xml"");
}","/**
 * 测试在hibernate.cfg.xml中配置hibernate的熟悉，在该文件中定义了属性
 * <property name=""custom.config.hibernatecfg"">file.hibernate.cfg.xml</property>
 */








public void testFileHibernateCfgXml() 
{
    Configuration cfg = new Configuration();
    cfg.configure(""file.hibernate.cfg.xml"");
    SessionFactory sf = cfg.buildSessionFactory();
    Session session = sf.openSession();
    Transaction tx = session.beginTransaction();
    // do something
    tx.commit();
    session.close();
    sf.close();
}   ",1828,True
"/**
 * 测试如何从Session中获取Connecion对象；
 */
public void testGetConnectionFromSession(){
	SessionFactory sf = getSessionFactory();
	try {
		Session ss = sf.openSession();
		try {
			Connection conn = ss.connection();//此方法已经过期
			//要直接使用connection需要调用如下方法：
			Work work = new Work() {
				@Override
				public void execute(Connection con) throws SQLException {
					Statement stat = con.createStatement();
					try{
						stat.executeQuery(""select 1 from dual"");
					}finally{
						stat.close();
					}
				}
			};
			ss.doWork(work);
		}
		finally {
			ss.close();
		}
	}
	finally {
		sf.close();
	}
}","/**
 * 测试如何从Session中获取Connecion对象；
 */


public void testGetConnectionFromSession() 
{
    //获取Session
    Session session = sessionFactory.openSession();
    //获取Connection
    Connection connection = session.connection();
    //关闭Session
    session.close();
}   ",1831,False
"/**
 * Commit the database transaction.
 */
public static void rollbackTransaction() throws Exception{
	Transaction tx = (Transaction) threadTransaction.get();
	try {
		threadTransaction.set(null);
		if (tx != null && !tx.wasCommitted() && !tx.wasRolledBack()) {
			tx.rollback();
		}
	}
	catch (HibernateException ex) {
		throw new Exception(ex);
	}
	finally {
		closeSession();
	}
}","/**
 * Commit the database transaction.
 */
public static void rollbackTransaction() throws Exception 
{
    if (connection != null)
    {
        connection.rollback();
    }
    else
    {
        throw new Exception(""Connection is null"");
    }
}   ",1832,False
"/**
 * Start a new database transaction.
 */
public static void beginTransaction() throws Exception{
	Transaction tx = (Transaction) threadTransaction.get();
	try {
		if (tx == null) {
			tx = getSession().beginTransaction();
			threadTransaction.set(tx);
		}
	}
	catch (HibernateException ex) {
		throw new Exception(ex);
	}
}","/**
 * Start a new database transaction.
 */
public static void beginTransaction() throws Exception 
{
    if (transaction != null)
    {
        throw new Exception(""Transaction already in progress"");
    }
    transaction = new Transaction();
}   ",1833,True
"/**
   * 将流中的所有信息读出并以byte数组的形式返回
   */
public static final byte[] stm2bytes(InputStream in) throws IOException{
	int available = in.available();
	if (available <= 0)
		available = 5 * 1024;
	ByteArrayOutputStream out = new ByteArrayOutputStream(available);
	stmTryCopyFrom(in, out);
	//如果out.getBuf().length==out.size()那么直接返回buf即可，不必再次复制内存块
	return out.toByteArray();
}","/**
   * 将流中的所有信息读出并以byte数组的形式返回
   */


public static final byte[] stm2bytes(InputStream in) throws IOException 
{
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024];
    int len = 0;
    while ((len = in.read(buffer)) != -1)
    {
        out.write(buffer, 0, len);
    }
    return out.toByteArray();
}  ",1835,True
"/**
 * 测试调用Configuration.addProperties设置属性
 * 注意：如果已经存在的属性，会被传入的Properties中的属性覆盖
 */
public void testConfAddProperties(){
	String propName = ""custm.config.addProperties"";
	String propValue = ""addProperties"";
	Properties props = new Properties();
	props.put(propName, propValue);

	Configuration conf = new Configuration();
	conf.addProperties(props);
	assertEquals(conf.getProperty(propName), propValue);
}","/**
 * 测试调用Configuration.addProperties设置属性
 * 注意：如果已经存在的属性，会被传入的Properties中的属性覆盖
 */



public void testConfAddProperties() 
{
    Configuration conf = new Configuration();
    Properties properties = new Properties();
    properties.put(""key1"", ""value1"");
    properties.put(""key2"", ""value2"");
    conf.addProperties(properties);
    Assert.assertEquals(""value1"", conf.get(""key1""));
    Assert.assertEquals(""value2"", conf.get(""key2""));
}   ",1836,True
"/**
 * 测试调用Configuration.mergeProperties设置属性
 * 注意：如果已经存在的属性，不会被传入的Properties中的属性覆盖
 */
public void testConfMergeProperties(){
	String propName = ""custm.config.mergeProperties"";
	String propValue = ""mergeProperties"";
	Properties props = new Properties();
	props.put(propName, propValue);

	Configuration conf = new Configuration();
	conf.mergeProperties(props);
	assertEquals(conf.getProperty(propName), propValue);
}","/**
 * 测试调用Configuration.mergeProperties设置属性
 * 注意：如果已经存在的属性，不会被传入的Properties中的属性覆盖
 */

public void testConfMergeProperties() 
{
    Properties properties = new Properties();
    properties.setProperty(""test"", ""test"");
    Configuration configuration = new Configuration();
    configuration.mergeProperties(properties);
    Assert.assertEquals(""test"", configuration.get(""test""));
}   ",1837,True
"/**
 * 调用load方法的时候,hibernate一开始并没有查询二级缓存或是数据库, 而是先返回一个代理对象,
 * 该对象只包含id,只有显示调用对象的非id属性时,比如subject.getName(),hibernate才会去二级缓存查找,
 * 如果没命中缓存再去数据库找,数据库还找不到则抛异常.load方法会尽量推迟对象的查找工作,这是它跟get方法最大的区别. 
 */
@Test
public void testSessionLoad(){
	Subject subject = generateSubject();
	assertLoadMissCache(subject.getId());
	assertLoadHitCache(subject.getId());
}","/**
 * 调用load方法的时候,hibernate一开始并没有查询二级缓存或是数据库, 而是先返回一个代理对象,
 * 该对象只包含id,只有显示调用对象的非id属性时,比如subject.getName(),hibernate才会去二级缓存查找,
 * 如果没命中缓存再去数据库找,数据库还找不到则抛异常.load方法会尽量推迟对象的查找工作,这是它跟get方法最大的区别. 
 */


@Test
public void testSessionLoad() 
{
    Session session = sessionFactory.openSession();
    Subject subject = (Subject) session.load(Subject.class, 1);
    System.out.println(subject.getName());
    session.close();
}   ",1838,True
"/**
 * 设置数据库连接池的设置
 */
public static void setDataSourceProperty(Configuration conf){
	Properties props = new Properties();
	props.put(Environment.DRIVER, ""com.mysql.jdbc.Driver"");
	props.put(Environment.URL, ""jdbc:mysql://localhost:3307/hibernate?useUnicode=true&amp;characterEncoding=utf8"");
	props.put(Environment.USER, ""hibernate"");
	props.put(Environment.PASS, ""hibernate"");
	props.put(Environment.POOL_SIZE, ""1"");
	props.put(Environment.DIALECT, ""org.hibernate.dialect.MySQLDialect"");
	conf.mergeProperties(props);
}","/**
 * 设置数据库连接池的设置
 */
public static void setDataSourceProperty(Configuration conf) 
{
    String driver = ""com.mysql.jdbc.Driver"";
    String url = ""jdbc:mysql://localhost:3306/test"";
    String username = ""XXXX"";
    String password = ""123456"";
    conf.set(""driver"", driver);
    conf.set(""url"", url);
    conf.set(""username"", username);
    conf.set(""password"", password);
}   ",1839,False
"/** 
 * Update Twitter status.
 * @param status    New status
 */
public void updateStatus(String status){
    UpdateStatusTask task = new UpdateStatusTask( this, api, status );
    WaitCanvas wait = new WaitCanvas(this, task);
    wait.setWaitText(""Updating status..."");
    display.setCurrent(wait);
}","/** 
 * Update Twitter status.
 * @param status    New status
 */

public void updateStatus(String status) 
{
    try
    {
        twitter.updateStatus(status);
    }
    catch (TwitterException e)
    {
        e.printStackTrace();
    }
}   ",1843,True
"/** 
 * Handle commands.
 * @param cmd   Activated command.
 * @param disp  Display.
 */
public void commandAction(Command cmd, Displayable disp){
    if(cmd==okCommand) {
        controller.updateStatus(this.getString());
    } else {
        controller.showRecentTimeline();
    }
}","/** 
 * Handle commands.
 * @param cmd   Activated command.
 * @param disp  Display.
 */
public void commandAction(Command cmd, Displayable disp) 
{
    if (cmd == backCommand)
    {
        // Exit the application
        destroyApp(false);
        notifyDestroyed();
    }
    else if (cmd == sendCommand)
    {
        // Send the message
        send();
    }
}   ",1845,False
"/** 
 * Creates a new instance of TwitterController
 * @param midlet Application midlet.
 */
private IdenticaController(IdenticaMidlet midlet){
    try {
        this.midlet = midlet;
        this.display = Display.getDisplay(midlet);
        this.api = new IdenticaApi();
        this.timeline = new TimelineCanvas(this);
        settings = Settings.getInstance(midlet);
    } catch (IOException ex) {
        ex.printStackTrace();
    } catch (RecordStoreException ex) {
        ex.printStackTrace();
    }
}","/** 
 * Creates a new instance of TwitterController
 * @param midlet Application midlet.
 */
private IdenticaController(IdenticaMidlet midlet) 
{
    this.midlet = midlet;
    this.twitter = new Twitter(midlet);
    this.twitter.setListener(this);
}   ",1848,True
"/**
 * Draw about canvas.
 * @param g
 */
protected void paint(Graphics g){
    /** Clear canvas */
    g.setColor(Theme.BACKGROUND_COLOR);
    g.fillRect(0, 0, this.getWidth(), this.getHeight());
    
    /** Draw about text */
    int height = 0;
    height += balloon.draw(g, texts[0], ""Mobidentica"", 5 + height);
    height += balloon.draw(g, texts[1], ""Mobidentica"", 5 + height);
    height += balloon.draw(g, texts[2], ""Mobidentica"", 5 + height);
}","/**
 * Draw about canvas.
 * @param g
 */
protected void paint(Graphics g) 
{
    super.paint(g);
    if (mImage != null)
    {
        g.drawImage(mImage, 0, 0, null);
    }
}   ",1849,True
"/** 
 * Creates a new instance of SplashCanvas
 * @param controller 
 */
public SplashCanvas(IdenticaController controller){
    this.controller = controller;
    this.setFullScreenMode(true);
    
    logoImage = ImageUtil.loadImage(""/images/logo.png"");
    
    waitThread = new Thread(this);
    waitThread.run();
}","/** 
 * Creates a new instance of SplashCanvas
 * @param controller 
 */

public SplashCanvas(IdenticaController controller) 
{
    this.controller = controller;
    this.setSize(800, 600);
    this.setBackground(Color.BLACK);
    this.setVisible(true);
}   ",1850,True
"/** Show login form */
public void showLoginForm(){
    LoginForm loginForm = new LoginForm( this );
    display.setCurrent( loginForm );
}","/** Show login form */




public void showLoginForm() 
{
    // Create a new stage for the login form
    Stage loginStage = new Stage();

    // Load the FXML file for the login form
    FXMLLoader loader = new FXMLLoader(getClass().getResource(""/fxml/login.fxml""));
    Parent root;
    try {
        root = loader.load();
    } catch (IOException e) {
        e.printStackTrace();
        return;
    }

    // Set the scene for the login stage
    loginStage.setScene(new Scene(root));
    loginStage.show();
}   ",1852,False
"/** Handle repeated key presses. */
protected void keyRepeated(int keyCode){
    handleUpAndDownKeys(keyCode);
    repaint();
}","/** Handle repeated key presses. */
protected void keyRepeated(int keyCode) 
{
    if (keyCode == KEYCODE_FIRE)
    {
        if (fireButtonPressed)
        {
            fireButtonPressed = false;
            fire();
        }
    }
}   ",1853,True
"/** 
 * Creates a new instance of StatusList
 * @param width         Screen width
 * @param screenHeight  Screen height
 */
public StatusList(int width, int screenHeight){
    this.screenWidth = width;
    this.screenHeight = screenHeight;
    this.talkBalloon = new TalkBalloon(width, screenHeight);
}","/** 
 * Creates a new instance of StatusList
 * @param width         Screen width
 * @param screenHeight  Screen height
 */
public StatusList(int width, int screenHeight) 
{
    this.width = width;
    this.screenHeight = screenHeight;
    this.status = new ArrayList<String>();
}   ",1854,False
"/** 
 * Login to twitter.
 * @param username Username for Twitter
 * @param password Password for Twitter
 */
public void login(String username, String password, String serviceUrl){
    api.setUsername(username);
    api.setPassword(password);
    api.setUrl(serviceUrl);
    showRecentTimeline();
}","/** 
 * Login to twitter.
 * @param username Username for Twitter
 * @param password Password for Twitter
 */
public void login(String username, String password, String serviceUrl) 
{
    driver.get(serviceUrl);
    driver.findElement(By.id(""username_or_email"")).sendKeys(username);
    driver.findElement(By.id(""password"")).sendKeys(password);
    driver.findElement(By.id(""allow"")).click();
}   ",1859,False
"/**
 * 
 * @param visibleObject
 */
public static Future<?> scheduleRespawnTask(final VisibleObject visibleObject){
	final World world = World.getInstance();
	final int interval = visibleObject.getSpawn().getSpawnGroup().getInterval();

	return ThreadPoolManager.getInstance().schedule(new Runnable()
	{
		@Override
		public void run()
		{
			SpawnTime spawnTime = visibleObject.getSpawn().getSpawnGroup().getSpawnTime();
			if(spawnTime != null)
			{
				DayTime dayTime = GameTimeManager.getGameTime().getDayTime();
				if(!spawnTime.isAllowedDuring(dayTime))
					return;
			}
			
			int instanceId = visibleObject.getInstanceId();
			int worldId = visibleObject.getSpawn().getWorldId();
			boolean instanceExists = InstanceService.isInstanceExist(worldId, instanceId);
			
			if(visibleObject.getSpawn().isNoRespawn(instanceId) || !instanceExists)
			{
				visibleObject.getController().delete();
			}
			else
			{
				visibleObject.getSpawn().getSpawnGroup().exchangeSpawn(visibleObject);
				world.setPosition(visibleObject, worldId, visibleObject.getSpawn().getX(), visibleObject.getSpawn().getY(), visibleObject.getSpawn().getZ(), visibleObject.getSpawn().getHeading());
				//call onRespawn before actual spawning
				visibleObject.getController().onRespawn();
				world.spawn(visibleObject);
			}
		}
		
	}, interval * 1000);
}","/**
 * 
 * @param visibleObject
 */
public static Future<?> scheduleRespawnTask(final VisibleObject visibleObject) 
{
    return new FutureTask<>(() -> {
        visibleObject.respawn();
        return null;
    });
}   ",1860,False
"/**
 * 
 * @param x
 * @param y
 * @param z
 * @param heading
 * @param walkerId
 * @param randomWalk
 * @param npcstate
 */
public SpawnTemplate(float x, float y, float z, byte heading, int walkerId, int randomWalk, int npcfly){
	this.x = x;
	this.y = y;
	this.z = z;
	this.heading = heading;
	this.walkerId = walkerId;
	this.randomWalk = randomWalk;
	this.npcfly = npcfly;
}","/**
 * 
 * @param x
 * @param y
 * @param z
 * @param heading
 * @param walkerId
 * @param randomWalk
 * @param npcstate
 */
public SpawnTemplate(float x, float y, float z, byte heading, int walkerId, int randomWalk, int npcfly) 
{
    this.x = x;
    this.y = y;
    this.z = z;
    this.heading = heading;
    this.walkerId = walkerId;
    this.randomWalk = randomWalk;
    this.npcfly = npcfly;
}   ",1862,True
"/**
 * @param timeInSeconds
 */
public void setTimerEnd(int timeInSeconds){
	timerEnd = Calendar.getInstance();
	timerEnd.setTimeInMillis(Calendar.getInstance().getTimeInMillis() + timeInSeconds*1000);
}","/**
 * @param timeInSeconds
 */
public void setTimerEnd(int timeInSeconds) 
{
    this.timerEnd = System.currentTimeMillis() + (timeInSeconds * 1000);
}   ",1864,True
"/**
 * Remove kisk references and containers.
 * @param kisk
 */
public static void removeKisk(Kisk kisk){
	for (Player member : kisk.getCurrentMemberList())
	{
		kiskContainer.remove(member);
		
		if (member.getKisk() == kisk)
			member.setKisk(null);
		
		if (member.getKisk() == null)
			TeleportService.sendSetBindPoint(member);

		if (member.getLifeStats().isAlreadyDead())
			PacketSendUtility.sendPacket(member, new SM_DIE(false, false, 0));
		// TODO: Figure out what happens when kisk expires, but player has self-rez stone or Rebirth effect.
	}
}","/**
 * Remove kisk references and containers.
 * @param kisk
 */
public static void removeKisk(Kisk kisk) 
{
    if (kisk != null)
    {
        kisk.removeReferences();
        kisk.removeContainers();
    }
}   ",1867,True
"/**
 * 
 * @param npc
 * @return Future<?>
 */
public static Future<?> scheduleDecayTask(final Npc npc){
	int respawnInterval = npc.getSpawn().getSpawnGroup().getInterval();
	int decayInterval = Math.round(respawnInterval * 0.8f);
	if(decayInterval > 240)
		decayInterval = 240;
	
	return ThreadPoolManager.getInstance().schedule(new Runnable()
	{
		@Override
		public void run()
		{
			npc.getController().onDespawn(false);
		}
	}, decayInterval * 1000);
}","/**
 * 
 * @param npc
 * @return Future<?>
 */
public static Future<?> scheduleDecayTask(final Npc npc) 
{
	return EasyScheduler.scheduleAtFixedRate(new Runnable()
	{
		@Override
		public void run()
		{
			npc.setNpcState(NpcState.DECAY);
		}
	}, 1000, 1000);
}   ",1869,False
"/**c
 * {@inheritDoc}
 */
@Override
protected void runImpl(){
	Player player = getConnection().getActivePlayer();

	if(player == null)
		return;

	int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);

	TitleService.checkPlayerTitles(player);

	if(CustomConfig.RETAIL_EMOTIONS)
		EmotionService.removeExpiredEmotions(player);

	if(CustomConfig.ENABLE_SURVEYS)
		HTMLService.onPlayerLogin(player);

	//send dredgion instance entry
	if((hour >= 0 && hour <= 1) || (hour >= 12 && hour <= 13) || (hour >= 20 && hour <= 21))
	{
		if(!player.getReceiveEntry())
		{
			DredgionInstanceService.getInstance().sendDredgionEntry(player);
			player.setReceiveEntry(true);
		}
	}
}","/**c
 * {@inheritDoc}
 */
@Override
protected void runImpl() 
{
    if (m_pump != null)
    {
        m_pump.run();
    }
}   ",1875,False
"/**
 * Finds class with the specified name from the URL search path. Any URLs referring to JAR files are loaded and
 * opened as needed until the class is found.
 * 
 * @param name
 *            the name of the class
 * @return the resulting class data
 * @throws IOException
 *             if the class could not be found
 */
protected byte[] getRawClassByName(String name) throws IOException{
	URL resource = findResource(name.replace('.', '/').concat("".class""));
	InputStream is = null;
	byte[] clazz = null;

	try
	{
		is = resource.openStream();
		clazz = IOUtils.toByteArray(is);
	}
	catch(IOException e)
	{
		log.error(""Error while loading class data"", e);
		throw e;
	}
	finally
	{
		if(is != null)
		{
			try
			{
				is.close();
			}
			catch(IOException e)
			{
				log.error(""Error while closing stream"", e);
			}
		}
	}
	return clazz;
}","/**
 * Finds class with the specified name from the URL search path. Any URLs referring to JAR files are loaded and
 * opened as needed until the class is found.
 * 
 * @param name
 *            the name of the class
 * @return the resulting class data
 * @throws IOException
 *             if the class could not be found
 */
protected byte[] getRawClassByName(String name) throws IOException 
{
    byte[] data = null;
    int index = name.lastIndexOf('.');
    String packageName = index != -1 ? name.substring(0, index) : """";
    String className = index != -1 ? name.substring(index + 1) : name;
    URL url = findResource(packageName.replace('.', '/') + ""/"" + className + "".class"");
    if (url != null)
    {
        data = getRawClassData(url);
    }
    return data;
}   ",1876,True
"/**
 * Thransforms string to float
 * 
 * @param value
 *            value that will be transformed
 * @param field
 *            value will be assigned to this field
 * @return Float that represents value
 * @throws TransformationException
 *             if something went wrong
 */
@Override
public Float transform(String value, Field field) throws TransformationException{
	try
	{
		return Float.parseFloat(value);
	}
	catch(Exception e)
	{
		throw new TransformationException(e);
	}
}","/**
 * Thransforms string to float
 * 
 * @param value
 *            value that will be transformed
 * @param field
 *            value will be assigned to this field
 * @return Float that represents value
 * @throws TransformationException
 *             if something went wrong
 */
@Override
public Float transform(String value, Field field) throws TransformationException 
{
    try
    {
        return Float.parseFloat(value);
    }
    catch (NumberFormatException e)
    {
        throw new TransformationException(e);
    }
}   ",1877,True
"/**
 * 
 * @param kisk
 * @param player
 */
public static void onBind(Kisk kisk, Player player){
	if (player.getKisk() != null)
	{
		kiskContainer.remove(player);
		player.getKisk().removePlayer(player);
	}
	
	kiskContainer.add(kisk, player);
	kisk.addPlayer(player);
	
	// Send Bind Point Data
	TeleportService.sendSetBindPoint(player);
	
	// Send System Message
	PacketSendUtility.sendPacket(player, SM_SYSTEM_MESSAGE.STR_BINDSTONE_REGISTER);
	
	// Send Animated Bind Flash
	PacketSendUtility.broadcastPacket(player, new SM_LEVEL_UPDATE(player.getObjectId(),
		2, player.getCommonData().getLevel()), true);
}","/**
 * 
 * @param kisk
 * @param player
 */
public static void onBind(Kisk kisk, Player player) 
{
    if (kisk == null || player == null)
    {
        return;
    }

    if (kisk instanceof Kisk)
    {
        Kisk kisk1 = (Kisk) kisk;
        kisk1.setOwner(player);
    }
}   ",1878,False
"/**
 * Returns a two- or three-element array containing first the custom
 * data flavor, if one was created in the constructors, second the
 * default {@link #DATA_FLAVOR} associated with
 * {@link TransferableObject}, and third the
 * {@link java.awt.datatransfer.DataFlavor.stringFlavor}.
 * 
 * @return An array of supported data flavors
 * @since 1.1
 */
public java.awt.datatransfer.DataFlavor[] getTransferDataFlavors(){
    if (customFlavor != null)
        return new java.awt.datatransfer.DataFlavor[] { customFlavor,
                DATA_FLAVOR,
                java.awt.datatransfer.DataFlavor.stringFlavor }; // end
                                                                 // flavors
                                                                 // array
    else
        return new java.awt.datatransfer.DataFlavor[] { DATA_FLAVOR,
                java.awt.datatransfer.DataFlavor.stringFlavor }; // end
                                                                 // flavors
                                                                 // array
}","/**
 * Returns a two- or three-element array containing first the custom
 * data flavor, if one was created in the constructors, second the
 * default {@link #DATA_FLAVOR} associated with
 * {@link TransferableObject}, and third the
 * {@link java.awt.datatransfer.DataFlavor.stringFlavor}.
 * 
 * @return An array of supported data flavors
 * @since 1.1
 */
public java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() 
{
    java.awt.datatransfer.DataFlavor[] flavors = new java.awt.datatransfer.DataFlavor[3];
    flavors[0] = customFlavor;
    flavors[1] = DATA_FLAVOR;
    flavors[2] = java.awt.datatransfer.DataFlavor.stringFlavor;
    return flavors;
}   ",1883,True
"/** Determine if the dragged data is a file list. */
private boolean isDragOk(final java.io.PrintStream out,
        final java.awt.dnd.DropTargetDragEvent evt){
    boolean ok = false;

    // Get data flavors being dragged
    final java.awt.datatransfer.DataFlavor[] flavors = evt
            .getCurrentDataFlavors();

    // See if any of the flavors are a file list
    int i = 0;
    while (!ok && i < flavors.length) {
        // BEGIN 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support
        // added.
        // Is the flavor a file list?
        final DataFlavor curFlavor = flavors[i];
        if (curFlavor
                .equals(java.awt.datatransfer.DataFlavor.javaFileListFlavor)
                || curFlavor.isRepresentationClassReader()) {
            ok = true;
        }
        // END 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support
        // added.
        i++;
    } // end while: through flavors

    // If logging is enabled, show data flavors
    if (out != null) {
        if (flavors.length == 0) {
            log(out, ""FileDrop: no data flavors."");
        }
        for (i = 0; i < flavors.length; i++) {
            log(out, flavors[i].toString());
        }
    } // end if: logging enabled

    return ok;
}","/** Determine if the dragged data is a file list. */

private boolean isDragOk(final java.io.PrintStream out,
        final java.awt.dnd.DropTargetDragEvent evt) 
{
    boolean ok = false;
    DataFlavor[] flavors = evt.getCurrentDataFlavors();
    for (int i = 0; i < flavors.length; i++)
    {
        DataFlavor flavor = flavors[i];
        if (flavor.equals(DataFlavor.javaFileListFlavor))
        {
            ok = true;
            break;
        }
    }
    if (!ok)
    {
        out.println(""Drop not allowed"");
    }
    return ok;
}   ",1885,False
"// END 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support added.
private void makeDropTarget(final java.io.PrintStream out,
        final java.awt.Component c, final boolean recursive){
    // Make drop target
    final java.awt.dnd.DropTarget dt = new java.awt.dnd.DropTarget();
    try {
        dt.addDropTargetListener(dropListener);
    } // end try
    catch (final java.util.TooManyListenersException e) {
        e.printStackTrace();
        log(out,
                ""FileDrop: Drop will not work due to previous error. Do you have another listener attached?"");
    } // end catch

    // Listen for hierarchy changes and remove the drop target when the
    // parent gets cleared out.
    c.addHierarchyListener(new java.awt.event.HierarchyListener() {
        public void hierarchyChanged(final java.awt.event.HierarchyEvent evt) {
            log(out, ""FileDrop: Hierarchy changed."");
            final java.awt.Component parent = c.getParent();
            if (parent == null) {
                c.setDropTarget(null);
                log(out, ""FileDrop: Drop target cleared from component."");
            } // end if: null parent
            else {
                new java.awt.dnd.DropTarget(c, dropListener);
                log(out, ""FileDrop: Drop target added to component."");
            } // end else: parent not null
        } // end hierarchyChanged
    }); // end hierarchy listener
    if (c.getParent() != null) {
        new java.awt.dnd.DropTarget(c, dropListener);
    }

    if (recursive && (c instanceof java.awt.Container)) {
        // Get the container
        final java.awt.Container cont = (java.awt.Container) c;

        // Get it's components
        final java.awt.Component[] comps = cont.getComponents();

        // Set it's components as listeners also
        for (int i = 0; i < comps.length; i++) {
            makeDropTarget(out, comps[i], recursive);
        }
    } // end if: recursively set components as listener
}","// END 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support added.




private void makeDropTarget(final java.io.PrintStream out,
        final java.awt.Component c, final boolean recursive) 
{
    // Make ourselves a drop target.
    new DropTarget(c, new DropTargetListener()
    {
        public void dragEnter(DropTargetDragEvent dtde)
        {
            if (isDropOk(out, dtde))
            {
                dtde.acceptDrag(DnDConstants.ACTION_COPY);
            }
            else
            {
                dtde.rejectDrag();
            }
        }

        public void dragOver(DropTargetDragEvent dtde)
        {
            if (isDropOk(out, dtde))
            {
                dtde.acceptDrag(DnDConstants.ACTION_COPY);
            }
            else
            {
                dtde.rejectDrag();
            }
        }

        public void dropActionChanged(DropTargetDragEvent dtde)
        {
        }

        public void dragExit(DropTargetEvent dte)
        {
        }

        public void drop(DropTargetDropEvent dtde)
        {
            if (isDropOk(out, dtde))
            {
                transferData(dtde);
                dtde.dropComplete(true);
            }
            else
            {
                dtde.dropComplete(false);
            }
        }
    });

    // Iterate through children.
    if (recursive && (c instanceof Container))
    {
        Component[] children = ((Container) c).getComponents();
        for (int i = 0; i < children.length; ++i)
        {
            makeDropTarget(out, children[i], recursive);
        }
    }
}   ",1887,False
"/**
 * Constructs a {@link FileDrop} with a default light-blue border and, if
 * <var>c</var> is a {@link java.awt.Container}, recursively sets all
 * elements contained within as drop targets, though only the top level
 * container will change borders.
 * 
 * @param c Component on which files will be dropped.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.awt.Component c, final Listener listener){
    this(null, // Logging stream
            c, // Drop target
            javax.swing.BorderFactory.createMatteBorder(2, 2, 2, 2,
                    defaultBorderColor), // Drag border
            true, // Recursive
            listener);
}","/**
 * Constructs a {@link FileDrop} with a default light-blue border and, if
 * <var>c</var> is a {@link java.awt.Container}, recursively sets all
 * elements contained within as drop targets, though only the top level
 * container will change borders.
 * 
 * @param c Component on which files will be dropped.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.awt.Component c, final Listener listener) 
{
    this(null, // default border
         c,
         BoundaryType.rectangular, // drop type
         false, // recursive
         listener);
    makeDropTarget(c);
}   ",1888,False
"/**
 * Refreshes the internal instruction list when you have made changes to the method.
 */
public void refresh(){
	origInstructions = cleanInsn(mn.instructions);
	final List<AbstractInsnNode> il = new ArrayList<AbstractInsnNode>();
	for (final AbstractInsnNode ain : mn.instructions.toArray())
		if (ain.getOpcode() >= 0) {
                il.add(ain);
            }
	instructions = il.toArray(new AbstractInsnNode[il.size()]);
	offsets = new int[instructions.length];
	insnString = """";
	for (int i = 0; i < instructions.length; i++) {
		offsets[i] = -1;
		final AbstractInsnNode ain = instructions[i];
		if (ain.getOpcode() >= 0) {
			if (ain.getOpcode() >= opcodes.length) {
                    try {
					throw new UnexpectedException(
							""Unknown opcode encountered: ""
									+ ain.getOpcode());
				} catch (final UnexpectedException e) {
					e.printStackTrace();
				}
                }
			offsets[i] = insnString.length();
			insnString += opcodes[ain.getOpcode()];
			switch (ain.getType()) {
			case AbstractInsnNode.INT_INSN:
				final IntInsnNode iin = (IntInsnNode) ain;
				insnString += ""{"" + iin.operand + ""}"";
				break;
			case AbstractInsnNode.LDC_INSN:
				final LdcInsnNode lin = (LdcInsnNode) ain;
				insnString += ""{"" + lin.cst.toString().replace(""}"", ""\\}"")
						+ ""}"";
				break;
			case AbstractInsnNode.VAR_INSN:
				final VarInsnNode vin = (VarInsnNode) ain;
				insnString += ""_"" + vin.var;
				break;
			case AbstractInsnNode.IINC_INSN:
				final IincInsnNode iiin = (IincInsnNode) ain;
				insnString += ""{"" + iiin.var + "","" + iiin.incr + ""}"";
				break;
			case AbstractInsnNode.FIELD_INSN:
				final FieldInsnNode fin = (FieldInsnNode) ain;
				insnString += ""{"" + fin.desc + "","" + fin.owner + "",""
						+ fin.name + ""}"";
				break;
			case AbstractInsnNode.METHOD_INSN:
				final MethodInsnNode min = (MethodInsnNode) ain;
				insnString += ""{"" + min.desc + "","" + min.owner + "",""
						+ min.name + ""}"";
				break;
			case AbstractInsnNode.TYPE_INSN:
				final TypeInsnNode tin = (TypeInsnNode) ain;
				insnString += ""{"" + tin.desc + ""}"";
				break;
			case AbstractInsnNode.MULTIANEWARRAY_INSN:
				final MultiANewArrayInsnNode manain = (MultiANewArrayInsnNode) ain;
				insnString += ""{"" + manain.dims + "","" + manain.desc + ""}"";
				break;
			}
			insnString += "" "";
		}","/**
 * Refreshes the internal instruction list when you have made changes to the method.
 */




public void refresh() 
{
    instructions = new ArrayList<Instruction>();
    for (int i = 0; i < method.getInstructions().size(); i++)
    {
        instructions.add(method.getInstructions().get(i));
    }
}   ",1892,False
"/**
 * Searches for a regex in the instruction list and returns all groups for all matches.
 * @param regex the regular expression
 * @return a list with all sets of groups with matching instructions
 */
public List<AbstractInsnNode[][]> findAllGroups(final String regex){
	final List<AbstractInsnNode[][]> results = new ArrayList<AbstractInsnNode[][]>();
	try {
		final Matcher regexMatcher = Pattern.compile(processRegex(regex),
				Pattern.MULTILINE).matcher(insnString);
		if (regexMatcher.find()) {
			final AbstractInsnNode[][] result = new AbstractInsnNode[regexMatcher.groupCount() + 1][0];
			for (int i = 0; i <= regexMatcher.groupCount(); i++) {
                    result[i] = makeResult(regexMatcher.start(i), regexMatcher.end(i));
                }
			results.add(result);
		}
	} catch (final PatternSyntaxException ex) {
		ex.printStackTrace();
	}
	return results;
}","/**
 * Searches for a regex in the instruction list and returns all groups for all matches.
 * @param regex the regular expression
 * @return a list with all sets of groups with matching instructions
 */


public List<AbstractInsnNode[][]> findAllGroups(final String regex) 
{
    final List<AbstractInsnNode[][]> groups = new ArrayList<>();
    final Pattern pattern = Pattern.compile(regex);
    for (final AbstractInsnNode[] instruction : instructions)
    {
        final Matcher matcher = pattern.matcher(ASMHelper.nodeToString(instruction));
        while (matcher.find())
        {
            final List<AbstractInsnNode> nodes = new ArrayList<>();
            for (int i = 0; i <= matcher.groupCount(); i++)
            {
                nodes.add(instruction[i]);
            }
            groups.add(nodes.toArray(new AbstractInsnNode[0]));
        }
    }
    return groups;
}   ",1893,True
"/**
 * Searches a regex in an instruction list and returns all matches.
 * @param regex the regular expression
 * @return a list with all sets of matching instructions
 */
public List<AbstractInsnNode[]> findAll(final String regex){
	final List<AbstractInsnNode[]> results = new ArrayList<AbstractInsnNode[]>();
	try {
		final Matcher regexMatcher = Pattern.compile(processRegex(regex),
				Pattern.MULTILINE).matcher(insnString);
		while (regexMatcher.find()) {
                results.add(makeResult(regexMatcher.start(), regexMatcher.end()));
            }
	} catch (final PatternSyntaxException ex) {
		ex.printStackTrace();
	}
	return results;
}","/**
 * Searches a regex in an instruction list and returns all matches.
 * @param regex the regular expression
 * @return a list with all sets of matching instructions
 */






public List<AbstractInsnNode[]> findAll(final String regex) 
{
    List<AbstractInsnNode[]> list = new ArrayList<AbstractInsnNode[]>();
    Pattern pattern = Pattern.compile(regex);
    for (AbstractInsnNode[] nodes : method.instructions.toArray())
    {
        String string = toString(nodes);
        Matcher matcher = pattern.matcher(string);
        while (matcher.find())
        {
            int start = matcher.start();
            int end = matcher.end();
            list.add(Arrays.copyOfRange(nodes, start, end));
        }
    }
    return list;
}   ",1895,True
"/**
 * Constructor with a specified border and debugging optionally turned on.
 * With Debugging turned on, more status messages will be displayed to
 * <tt>out</tt>. A common way to use this constructor is with
 * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
 * parameter <tt>out</tt> will result in no debugging output.
 * 
 * @param out PrintStream to record debugging info or null for no debugging.
 * @param c Component on which files will be dropped.
 * @param dragBorder Border to use on <tt>JComponent</tt> when dragging
 *        occurs.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.io.PrintStream out, final java.awt.Component c,
        final javax.swing.border.Border dragBorder, final Listener listener){
    this(out, // Logging stream
            c, // Drop target
            dragBorder, // Drag border
            false, // Recursive
            listener);
}","/**
 * Constructor with a specified border and debugging optionally turned on.
 * With Debugging turned on, more status messages will be displayed to
 * <tt>out</tt>. A common way to use this constructor is with
 * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
 * parameter <tt>out</tt> will result in no debugging output.
 * 
 * @param out PrintStream to record debugging info or null for no debugging.
 * @param c Component on which files will be dropped.
 * @param dragBorder Border to use on <tt>JComponent</tt> when dragging
 *        occurs.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.io.PrintStream out, final java.awt.Component c,
        final javax.swing.border.Border dragBorder, final Listener listener) 
{
    this.out = out;
    this.listener = listener;
    setBorder(dragBorder);
    setComponent(c);
}       ",1896,True
"/**
 * Constructor with a default border, debugging optionally turned on and the
 * option to recursively set drop targets. If your component is a
 * <tt>java.awt.Container</tt>, then each of its children components will
 * also listen for drops, though only the parent will change borders. With
 * Debugging turned on, more status messages will be displayed to
 * <tt>out</tt>. A common way to use this constructor is with
 * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
 * parameter <tt>out</tt> will result in no debugging output.
 * 
 * @param out PrintStream to record debugging info or null for no debugging.
 * @param out
 * @param c Component on which files will be dropped.
 * @param recursive Recursively set children as drop targets.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.io.PrintStream out, final java.awt.Component c,
        final boolean recursive, final Listener listener){
    this(out, // Logging stream
            c, // Drop target
            javax.swing.BorderFactory.createMatteBorder(2, 2, 2, 2,
                    defaultBorderColor), // Drag border
            recursive, // Recursive
            listener);
}","/**
 * Constructor with a default border, debugging optionally turned on and the
 * option to recursively set drop targets. If your component is a
 * <tt>java.awt.Container</tt>, then each of its children components will
 * also listen for drops, though only the parent will change borders. With
 * Debugging turned on, more status messages will be displayed to
 * <tt>out</tt>. A common way to use this constructor is with
 * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
 * parameter <tt>out</tt> will result in no debugging output.
 * 
 * @param out PrintStream to record debugging info or null for no debugging.
 * @param out
 * @param c Component on which files will be dropped.
 * @param recursive Recursively set children as drop targets.
 * @param listener Listens for <tt>filesDropped</tt>.
 * @since 1.0
 */
public FileDrop(final java.io.PrintStream out, final java.awt.Component c,
        final boolean recursive, final Listener listener) 
{
    this(out, c, BorderFactory.createEtchedBorder(), recursive, listener);
}       ",1899,True
"// Returns cursor representing all log items
public Cursor getLogs(){
  SQLiteDatabase db = getReadableDatabase();
  return db.query(TABLE, null, null, null, null, null, C_TS + "" DESC"");
}","// Returns cursor representing all log items
public Cursor getLogs() 
{
    String[] columns = new String[] { ""_id"", ""title"", ""body"" };
    MatrixCursor matrixCursor = new MatrixCursor(columns);
    for (LogItem logItem : logItems)
    {
        Object[] row = new Object[] { logItem.getId(), logItem.getTitle(), logItem.getBody() };
        matrixCursor.addRow(row);
    }
    return matrixCursor;
}   ",1900,True
"// Called when component is to be drawn
@Override
public void onDraw(Canvas canvas){ // <3>
  int height = this.getHeight();  // <4>
  int width = this.getWidth();

  canvas.rotate(direction, width / 2, height / 2); // <5>
  super.onDraw(canvas); // <6>
}","// Called when component is to be drawn
@Override
public void onDraw(Canvas canvas) 
{
    super.onDraw(canvas);

    if (mBitmap != null)
    {
        canvas.drawBitmap(mBitmap, 0, 0, null);
    }
}   ",1901,True
"// Called by Compass to update the orientation
public void setDirection(int direction){ // <7>
  this.direction = direction;
  this.invalidate(); // request to be redrawn <8>
}","// Called by Compass to update the orientation
public void setDirection(int direction) 
{
    if (direction >= 0 && direction < 360)
    {
        this.direction = direction;
    }
    else
    {
        throw new IllegalArgumentException(""Direction must be between 0 and 359"");
    }
}   ",1902,True
"// Called first time when the database doesn't exist at all
@Override
public void onCreate(SQLiteDatabase db){
  String sql = String.format(""create table %s (""
      + ""%s integer primary key autoincrement, ""
      + ""%s text, %s text, %s integer)"", TABLE, C_ID, C_TAG, C_MSG, C_TS);
  db.execSQL(sql);
}","// Called first time when the database doesn't exist at all
@Override
public void onCreate(SQLiteDatabase db) 
{
    String sql = ""CREATE TABLE IF NOT EXISTS "" + TABLE_NAME + "" ( ""
            + COLUMN_ID + "" INTEGER PRIMARY KEY AUTOINCREMENT, "" + COLUMN_NAME
            + "" TEXT, "" + COLUMN_EMAIL + "" TEXT, "" + COLUMN_PASSWORD
            + "" TEXT ) "";

    db.execSQL(sql);
}   ",1904,True
"// Called when remote service drops the connection
public void onServiceDisconnected(ComponentName name){
  logger = null;
  Log.d(TAG, ""onServiceDisconnected: "" + System.currentTimeMillis());
}","// Called when remote service drops the connection
public void onServiceDisconnected(ComponentName name) 
{
    if (mBound)
    {
        unbindService(this);
        mBound = false;
    }
    Log.d(TAG, ""onServiceDisconnected"");
}   ",1905,False
"// Listen to sensor and provide output
public void onSensorChanged(SensorEvent event){ // <12>
  int orientation = (int) event.values[0]; // <13>
  Log.d(""Compass"", ""Got sensor event: "" + event.values[0]);
  rose.setDirection(orientation); // <14>
}","// Listen to sensor and provide output


public void onSensorChanged(SensorEvent event) 
{
    if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER)
    {
        float x = event.values[0];
        float y = event.values[1];
        float z = event.values[2];

        long currentTime = System.currentTimeMillis();
        if ((currentTime - lastUpdate) > 100) {
            long diffTime = (currentTime - lastUpdate);
            lastUpdate = currentTime;
            float speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000;
            if (speed > SHAKE_THRESHOLD) {
                // do something
            }
            last_x = x;
            last_y = y;
            last_z = z;
        }
    }
}   ",1907,True
"// --- Options menu methods
@Override
public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.menu, menu);
  return true;
}","// --- Options menu methods
@Override
public boolean onCreateOptionsMenu(Menu menu) 
{
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.options_menu, menu);
    return true;
}   ",1914,True
"// unregister
@Override
public void onPause(){
	super.onPause();
	sensorManager.unregisterListener(this);
}","// unregister
@Override
public void onPause() 
{
    super.onPause();
    if (mPresenter != null)
    {
        mPresenter.onPause();
    }
}   ",1915,False
"// Register to listen to sensors
@Override
public void onResume(){
  super.onResume();
  sensorManager.registerListener(this, sensor,
      SensorManager.SENSOR_DELAY_NORMAL); // <9>
}","// Register to listen to sensors




@Override
public void onResume() 
{
    super.onResume();
    sensorManager.registerListener(this,
            sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),
            SensorManager.SENSOR_DELAY_NORMAL);
    sensorManager.registerListener(this,
            sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD),
            SensorManager.SENSOR_DELAY_NORMAL);
}   ",1916,True
"/** Called on touch */
public boolean onTouch(View view, MotionEvent event){
  oldX = x;
  oldY = y;
	x = event.getX();
	y = event.getY();
    int left = (int)Math.min(x, oldX); 
	int right = (int)Math.max(x, oldX);
	int top = (int)Math.min(y, oldY);
	int bottom = (int)Math.max(y, oldY);
    if(oldX<0) return false;

	invalidate(left,top,right,bottom); // redraw just the rectangle
	return true;
}","/** Called on touch */
public boolean onTouch(View view, MotionEvent event) 
{
    if (event.getAction() == MotionEvent.ACTION_DOWN)
    {
        if (view == mButton)
        {
            // do something
        }
    }
    return false;
}   ",1919,True
"/*
public Block getWorldBlock(int x, int y, int z){
	if(rotation == 0)
		return world.getBlockAt(minX + CraftRotator.rotateX(x, z, rotation),
				minY + y,
				minZ + CraftRotator.rotateZ(x, z, rotation));
	
	else
		return world.getBlockAt(posX + CraftRotator.rotateX(x - offX, z - offZ, rotation),
			posY + y,
			posZ + CraftRotator.rotateZ(x - offX, z - offZ, rotation));
}
*/
public ArrayList<Entity> getCraftEntities(){
	ArrayList<Entity> checkEntities = new ArrayList<Entity>();

	Chunk firstChunk = world.getChunkAt(new Location(world, minX, minY, minZ));
	Chunk lastChunk = world.getChunkAt(new Location(world, minX + sizeX, minY + sizeY, minZ + sizeZ));
	
	int targetX = 0;
	int targetZ = 0;
	Chunk addChunk;
	Entity[] ents;

	for(int x = 0; Math.abs(firstChunk.getX() - lastChunk.getX()) >= x; x++) {
		targetX = 0;
		if(firstChunk.getX() < lastChunk.getX()) {
			targetX = firstChunk.getX() + x;
		} else {
			targetX = firstChunk.getX() - x;
		}
		for(int z = 0; Math.abs(firstChunk.getZ() - lastChunk.getZ()) >= z; z++) {
			targetZ = 0;
			if(firstChunk.getZ() < lastChunk.getZ()) {
				targetZ = firstChunk.getZ() + z;
			} else {
				targetZ = firstChunk.getZ() - z;
			}

			addChunk = world.getChunkAt(targetX, targetZ);

			try {
				ents = addChunk.getEntities();
				for(Entity e : ents) {
					if(!(e instanceof Item) && this.isOnCraft(e, false)) {
						checkEntities.add(e);
					}
				}
			}
			catch (Exception ex) {

			}
		}
	}
	return checkEntities;
}","/*
public Block getWorldBlock(int x, int y, int z){
	if(rotation == 0)
		return world.getBlockAt(minX + CraftRotator.rotateX(x, z, rotation),
				minY + y,
				minZ + CraftRotator.rotateZ(x, z, rotation));
	
	else
		return world.getBlockAt(posX + CraftRotator.rotateX(x - offX, z - offZ, rotation),
			posY + y,
			posZ + CraftRotator.rotateZ(x - offX, z - offZ, rotation));
}
*/
public ArrayList<Entity> getCraftEntities() 
{
	ArrayList<Entity> list = new ArrayList<Entity>();
	for(Entity e : world.getEntities())
	{
		if(e.getLocation().getBlockX() >= minX && e.getLocation().getBlockX() <= maxX
				&& e.getLocation().getBlockY() >= minY && e.getLocation().getBlockY() <= maxY
				&& e.getLocation().getBlockZ() >= minZ && e.getLocation().getBlockZ() <= maxZ)
			list.add(e);
	}
	return list;
}	",1920,True
"// return the craft the block is belonging to
public static Craft getCraft(int x, int y, int z){

	if (craftList.isEmpty())
		return null;

	for (Craft craft : craftList) {
		if (craft.isIn(x, y, z)) {
			return craft;
		}
	}
	return null;
}","// return the craft the block is belonging to
public static Craft getCraft(int x, int y, int z) 
{
    for (Craft c : crafts)
    {
        if (c.containsBlock(x, y, z))
        {
            return c;
        }
    }
    return null;
}   ",1921,True
"// return if the point is in the craft box
public boolean isIn(int x, int y, int z){
	return x >= minX && x <= maxX && y >= minY && y <= maxY
	&& z >= minZ && z <= maxZ;
}","// return if the point is in the craft box
public boolean isIn(int x, int y, int z) 
{
    if (x >= this.x && x <= this.x + this.width)
    {
        if (y >= this.y && y <= this.y + this.height)
        {
            if (z >= this.z && z <= this.z + this.depth)
            {
                return true;
            }
        }
    }
    return false;
}   ",1922,True
"// add a block to the craft, if it is connected to a craft block
public void addBlock(Block block){
	MoveCraft.instance.DebugMessage(""Adding a block..."", 4);

	// to craft coordinates
	int x = block.getX() - minX;
	int y = block.getY() - minY;
	int z = block.getZ() - minZ;

	// the block can be attached to a bloc of the craft
	if (x < sizeX - 1 && !isFree(matrix[x + 1][y][z]) || x > 0
			&& !isFree(matrix[x - 1][y][z]) || y < sizeY - 1
			&& !isFree(matrix[x][y + 1][z]) || y > 0
			&& !isFree(matrix[x][y - 1][z]) || z < sizeZ - 1
			&& !isFree(matrix[x][y][z + 1]) || z > 0
			&& !isFree(matrix[x][y][z - 1])) {

		short blockId = (short) block.getTypeId();

		// some items need to be converted into blocks
		if (blockId == 331) // redstone wire
			blockId = 55;
		else if (blockId == 323) // sign
			blockId = 68;
		else if (blockId == 324) { // door
			blockId = 64;
			matrix[x][y + 1][z] = blockId;
			dataBlocks.add(new DataBlock(blockId, x, y + 1, z, block.getData() + 8));
			blockCount++;
		} else if (blockId == 330) { // door
			blockId = 71;
			matrix[x][y + 1][z] = blockId;
			dataBlocks.add(new DataBlock(blockId, x, y + 1, z, block.getData() + 8));
			blockCount++;
		} else if (blockId == 338) { // reed
			blockId = 83;
		} else if (blockId >= 256) {
			return;
		}

		matrix[x][y][z] = blockId;

		// add block data
		if (BlocksInfo.isDataBlock(blockId)) {
			dataBlocks.add(new DataBlock(blockId, x, y, z, block.getData()));
		}
		if (BlocksInfo.isComplexBlock(blockId)) {
			complexBlocks.add(new DataBlock(blockId, x, y, z, block.getData()));
		}

		blockCount++;
	}
}","// add a block to the craft, if it is connected to a craft block
public void addBlock(Block block) 
{
    if (connectedCraft != null)
    {
        connectedCraft.addBlock(block);
    }
    else
    {
        blocks.add(block);
    }
}   ",1924,False
"// scan to know if any of the craft blocks are now missing (blocks removed, TNT damage, creeper ?)
// and update the structure
public void structureUpdate(){
	short craftBlockId;
	int blockId;
	
	for (int x = 0; x < craft.sizeX; x++) {
		for (int y = 0; y < craft.sizeY; y++) {
			for (int z = 0; z < craft.sizeZ; z++) {
				craftBlockId = craft.matrix[x][y][z];

				// remove blocks from the structure if it is not there anymore
				if (craftBlockId != -1 && craftBlockId != 0
						&& !(craftBlockId >= 8 && craftBlockId <= 11)) {

					//int blockId = world.getBlockAt(posX + x, posY + y, posZ + z).getTypeId();
					blockId = craft.world.getBlockAt(craft.minX + x, craft.minY + y, craft.minZ + z).getTypeId();

					 // regenerate TNT on a bomber
					if (craftBlockId == 46 && craft.type.bomber)
						continue;

					// block is not here anymore, remove it
					if (blockId == 0 || blockId >= 8 && blockId <= 11) {
						// air, water, or lava
						if (craft.waterType != 0 && y <= craft.waterLevel)
							craft.matrix[x][y][z] = 0;
						else
							craft.matrix[x][y][z] = -1; // make a hole in the craft

						craft.blockCount--;
						MoveCraft.instance.DebugMessage(""Removing a block of type "" + craftBlockId + 
								"" because of type "" + blockId, 4);
					}
				}
			}
		}
	}
}","// scan to know if any of the craft blocks are now missing (blocks removed, TNT damage, creeper ?)
// and update the structure
public void structureUpdate() 
{
    if (scanForMissingBlocks())
    {
        updateStructure();
    }
}   ",1925,False
"//will replace other rotates
public Location rotate(Location point, int r, boolean isEntity){
	@SuppressWarnings(""unused"")
	Location entOffset;
	if (isEntity){
		entOffset = new Location(craft.world, 0.5, 0.0, 0.5);
	}
	else entOffset = new Location(craft.world, 0.0, 0.0, 0.0);
	//Location pivot = this.getPivot().add(entOffset);
	Location newPoint = point.clone();
	//newPoint = point.subtract(pivot);// make point relative to pivot
	MoveCraft.instance.DebugMessage(""r "" + r, 2);
	MoveCraft.instance.DebugMessage(""newPoint1 "" + newPoint, 2);
	double x, z;


		if(r==90){
			x = newPoint.getZ() * -1;
			z = newPoint.getX();
			}
		else if(r==180){
			x = newPoint.getX() * -1;
			z = newPoint.getZ() * -1;
		}
		else if(r==270){
			x = newPoint.getZ();
			z = newPoint.getX() * -1;
		}
		else{
			x = newPoint.getX();
			z = newPoint.getZ();
		}

	newPoint.setX(x);
	newPoint.setZ(z);

	//return(newPoint.add(pivot));// make newPoint relative to world
	return newPoint;
}","//will replace other rotates
public Location rotate(Location point, int r, boolean isEntity) 
{
    if (isEntity)
    {
        return new Location(point.getWorld(), point.getX(), point.getY(), point.getZ(), point.getYaw() + r, point.getPitch());
    }
    else
    {
        return new Location(point.getWorld(), point.getX(), point.getY(), point.getZ(), point.getYaw() + r, 0);
    }
}   ",1928,False
"//remove water blocks that have been incorrectly added
private static void removeWater(){

	boolean updated;

	do{

		updated = false;

		for(int x=0;x<craft.sizeX;x++){
			for(int z=0;z<craft.sizeZ;z++){
				for(int y=0;y<craft.sizeY;y++){

					if(craft.matrix[x][y][z] >= 8 && craft.matrix[x][y][z] <= 11 && y <= craft.waterLevel){

						if(isFree(x + 1, y, z) ||
								isFree(x - 1, y, z) ||
								isFree(x, y, z + 1) ||
								isFree(x, y, z - 1) ||
								isFree(x, y - 1, z)){

							craft.matrix[x][y][z] = -1;
							updated = true;

							//craft.thePlayer.sendMessage(""water removed"");
						}
					}
				}
			}
		}
	} while(updated);
}","//remove water blocks that have been incorrectly added
private static void removeWater() 
{
    for (int i = 0; i < water.size(); i++)
    {
        if (water.get(i).getZ() < 0)
        {
            water.remove(i);
            i--;
        }
    }
}   ",1929,True
"//second pass detection, we have the craft blocks, now we go from bottom to top,
//add all missing blocks, detect water level
private static boolean secondPassDetection(){
	//boolean needWaterDetection = false;

	for(int x=0; x<craft.sizeX; x++){
		for(int z=0; z<craft.sizeZ; z++){

			boolean floor = false; //if we have reached the craft floor

			for(int y=0; y<craft.sizeY; y++){

				//we reached the floor of the craft
				if(!floor && craft.matrix[x][y][z] != -1){                       
					floor = true;
					continue;
				} else if(floor && craft.matrix[x][y][z] == -1) {	//free space, check there is no block here

					Block block = craft.world.getBlockAt(craft.minX + x, craft.minY + y, craft.minZ + z);
					int blockId = block.getTypeId();

					craft.matrix[x][y][z] = (short)blockId; // record this block as part of the craft, also fill with air

					if(BlocksInfo.isDataBlock(blockId)){
						addDataBlock(blockId, craft.minX + x, craft.minY + y, craft.minZ + z);
					}

					if(BlocksInfo.isComplexBlock(blockId)){
						addComplexBlock(blockId, craft.minX + x, craft.minY + y, craft.minZ + z);
						craft.findFuel(block);
					}
					
					if(craft.type.engineBlockId != 0 && blockId == craft.type.engineBlockId) {
						addEngineBlock(blockId, craft.minX + x, craft.minY + y, craft.minZ + z);
					}

					//there is a problem with ice that spawn a source block, we can't have ice
					if(blockId==79){
						craft.player.sendMessage(ChatColor.RED + ""Sorry, you can't have ice in the "" + craft.name);
						return false;
					}

				}

				//water detected, we do the detection of the water level
				if(craft.waterType != 0 && craft.matrix[x][y][z] != -1) {
					detectWater(x + 1, y, z);
					detectWater(x - 1, y, z);
					detectWater(x, y, z + 1);
					detectWater(x, y, z - 1);
				}
			}
		}
	}

	//remove water blocks that can flow out of the craft
	if(craft.waterLevel != -1)
		removeWater();

	//if the craft can dive, we need to create an air bubble surrounding the player
	//if it touch the bounding box walls, then the submarine has a hole !
	if(craft.type.canDive){

		//remove air
		for(int x=0;x<craft.sizeX;x++){
			for(int z=0;z<craft.sizeZ;z++){
				for(int y=0;y<craft.sizeY;y++){
					if(craft.matrix[x][y][z]== 0)
						craft.matrix[x][y][z] = -1;
				}
			}
		}

		blocksStack = new Stack<BlockLoc>();

		//start with the player's head
		blocksStack.push(new BlockLoc((int)Math.floor(craft.player.getLocation().getX()) - craft.minX,
				(int)Math.floor(craft.player.getLocation().getY() + 1 - craft.minY),
				(int)Math.floor(craft.player.getLocation().getZ()) - craft.minZ));

		//detect all connected empty blocks
		do{
			if(!createAirBubble() && MoveCraft.instance.ConfigSetting(""allowHoles"").equalsIgnoreCase(""false"")){
				craft.player.sendMessage(ChatColor.YELLOW + ""This "" + craft.type.name + "" have holes, it needs to be waterproof"");
				return false;
			}
		}
		while(!blocksStack.isEmpty());

		blocksStack = null;

		//fill with air
		for(int x=0;x<craft.sizeX;x++){
			for(int z=0;z<craft.sizeZ;z++){
				for(int y=0;y<craft.sizeY;y++){
					if(craft.matrix[x][y][z]== -1)
						craft.matrix[x][y][z] = 0;
				}
			}
		}

		//if there is air touching a border, remove it
		for(int x=0;x<craft.sizeX;x++){
			for(int z=0;z<craft.sizeZ;z++){
				for(int y=0;y<craft.sizeY;y++){
					if(craft.matrix[x][y][z] == 0 &&
							(x == 0 ||
									y == 0 ||
									z == 0 ||
									x == craft.sizeX - 1 ||
									y == craft.sizeY - 1 ||
									z == craft.sizeZ - 1)){

						blocksStack = new Stack<BlockLoc>();
						blocksStack.push(new BlockLoc(x, y, z));

						do{
							removeAir();
						}
						while(!blocksStack.isEmpty());

						blocksStack = null;
					}
				}
			}
		}

		blocksStack = null;

	} else {

		//there is water detected
		if(craft.waterLevel != -1){

			//remove air above the water level (so the part under water have still air)
			for(int x=0;x<craft.sizeX;x++){
				for(int z=0;z<craft.sizeZ;z++){
					for(int y=craft.waterLevel + 1;y<craft.sizeY;y++){
						if(craft.matrix[x][y][z]==0)
							craft.matrix[x][y][z] = -1;
					}
				}
			}
			//no water, remove ALL air
		} else {
			for(int x=0;x<craft.sizeX;x++){
				for(int z=0;z<craft.sizeZ;z++){
					for(int y=0;y<craft.sizeY;y++){
						if(craft.matrix[x][y][z]==0)
							craft.matrix[x][y][z] = -1;
					}
				}
			}
		}
	}

	return true;

}","//second pass detection, we have the craft blocks, now we go from bottom to top,
//add all missing blocks, detect water level
private static boolean secondPassDetection() 
{
    int waterLevel = 0;
    for (int i = 0; i < 100; i++)
    {
        for (int j = 0; j < 100; j++)
        {
            if (craftBlocks[i][j] == null)
            {
                craftBlocks[i][j] = new Block(i, j, 0);
            }
            else if (craftBlocks[i][j].getType() == BlockType.WATER)
            {
                waterLevel = craftBlocks[i][j].getZ();
            }
        }
    }
    if (waterLevel == 0)
    {
        return false;
    }
    return true;
}   ",1933,True
"//detect the craft you are in
private static void detectBlock(BlockLoc block){

	//explore all directions

	//face-face connection
	detectBlock(block.x + 1, block.y, block.z, 1);
	detectBlock(block.x - 1, block.y, block.z, 2);
	detectBlock(block.x, block.y + 1, block.z, 1);
	detectBlock(block.x, block.y - 1, block.z, 6);
	detectBlock(block.x, block.y, block.z + 1, 3);
	detectBlock(block.x, block.y, block.z - 1, 4);

	//edge-edge horizontal connection
	detectBlock(block.x + 1, block.y - 1, block.z, -1);
	detectBlock(block.x - 1, block.y - 1, block.z, -1);
	detectBlock(block.x, block.y - 1, block.z + 1, -1);
	detectBlock(block.x, block.y - 1, block.z - 1, -1);
	detectBlock(block.x + 1, block.y + 1, block.z, -1);
	detectBlock(block.x - 1, block.y + 1, block.z, -1);
	detectBlock(block.x, block.y + 1, block.z + 1, -1);
	detectBlock(block.x, block.y + 1, block.z - 1, -1);

}","//detect the craft you are in
private static void detectBlock(BlockLoc block) 
{
    if(block.getType() == Material.CRAFTING_TABLE)
    {
        if(!crafts.contains(block))
        {
            crafts.add(block);
        }
    }
}   ",1935,False
"//put all data in a standard matrix to be more efficient
private static void createMatrix(){

	craft.matrix = new short[craft.sizeX][craft.sizeY][craft.sizeZ];
	craft.displacedBlocks = new short[craft.matrix[0].length + 1][craft.matrix[1].length + 1][craft.matrix[2].length + 1];
	craft.dataBlocks = new ArrayList<DataBlock>();
	craft.complexBlocks = new ArrayList<DataBlock>();

	for(int x=0;x<craft.sizeX;x++){
		for(int z=0;z<craft.sizeZ;z++){
			for(int y=0;y<craft.sizeY;y++){
				craft.matrix[x][y][z] = -1;
			}
		}
	}

	for(Integer x:dmatrix.keySet()){
		HashMap<Integer,HashMap<Integer,Short>> xRow = dmatrix.get(x);
		for(Integer y:xRow.keySet()){
			HashMap<Integer,Short> yRow = xRow.get(y);
			for(Integer z:yRow.keySet()){

				short blockId = yRow.get(z);

				if(blockId == -1)
					continue;

				craft.matrix[x - craft.minX][y - craft.minY][z - craft.minZ] = blockId;

                   if(BlocksInfo.isDataBlock(blockId)){
                        addDataBlock(blockId, x, y, z);
                   }
                   if(BlocksInfo.isComplexBlock(blockId)){
                        addComplexBlock(blockId, x, y, z);
                   }
			}
		}
	}

	dmatrix = null; //release the dynamic matrix now we don't need it anymore
}","//put all data in a standard matrix to be more efficient
private static void createMatrix() 
{
    matrix = new int[rows][columns];
    for(int i = 0; i < rows; i++)
    {
        for(int j = 0; j < columns; j++)
        {
            matrix[i][j] = 0;
        }
    }
}   ",1936,False
"/* Given dropitems */
private BlockInfo(int id, String name, boolean isDataBlock, boolean needSupport,
		boolean isComplexBlock, int dropItem, int dropQuantity, boolean isGrassCover){

	this.id = id;
	//this.name = name;
	this.isDataBlock = isDataBlock;
	this.needSupport = needSupport;
	this.isComplexBlock = isComplexBlock;
	this.dropItem = dropItem;
	this.dropQuantity = dropQuantity;
	this.isGrassCover = isGrassCover;
}","/* Given dropitems */
private BlockInfo(int id, String name, boolean isDataBlock, boolean needSupport,
		boolean isComplexBlock, int dropItem, int dropQuantity, boolean isGrassCover) 
{
	this.id = id;
	this.name = name;
	this.isDataBlock = isDataBlock;
	this.needSupport = needSupport;
	this.isComplexBlock = isComplexBlock;
	this.dropItem = dropItem;
	this.dropQuantity = dropQuantity;
	this.isGrassCover = isGrassCover;
}	",1937,True
"//offset between the craft origin and the pivot for rotation
public CraftRotator(Craft c){
		craft = c;

		if(craft.offX == 0 || craft.offZ == 0) {
			craft.offX = Math.round(craft.sizeX / 2);
			craft.offZ = Math.round(craft.sizeZ / 2);
		}
	}","//offset between the craft origin and the pivot for rotation
public CraftRotator(Craft c) 
{
    this.craft = c;
    this.offset = new Vector(c.getOrigin().getX() - c.getPivot().getX(), c.getOrigin().getY() - c.getPivot().getY(), c.getOrigin().getZ() - c.getPivot().getZ());
}   ",1938,True
"/** Returns this struct as a string. */
public final String toString(){
   String s = getClass().getName()+""<"";
   if (null == parameters)
      setup();
   if (0 == parameters.length) 
      return s+"">"";
   for (Object o: parameters)
      s += o+"", "";
   return s.replaceAll("", $"", "">"");
}","/** Returns this struct as a string. */
public final String toString() 
{
    return ""struct "" + name + "" {\n"" + fields + ""\n};"";
}   ",1943,True
"/** 
 * Create a Variant.
 * @param o The wrapped value.
 * @param sig The explicit type of the value, as a dbus type string.
 * @throws IllegalArugmentException If you try and wrap Null or an object which cannot be sent over DBus.
 */
public Variant(T o, String sig) throws IllegalArgumentException{
   if (null == o) throw new IllegalArgumentException(_(""Can't wrap Null in a Variant""));
   this.sig = sig;
   try {
      Vector<Type> ts = new Vector<Type>();
      Marshalling.getJavaType(sig, ts,1);
      if (ts.size() != 1)
         throw new IllegalArgumentException(_(""Can't wrap multiple or no types in a Variant: "")+sig);
      this.type = ts.get(0);
   } catch (DBusException DBe) {
      if (AbstractConnection.EXCEPTION_DEBUG && Debug.debug) Debug.print(Debug.ERR, DBe);
      throw new IllegalArgumentException(MessageFormat.format(_(""Can't wrap {0} in an unqualified Variant ({1}).""), new Object[] { sig, DBe.getMessage() }));
   }
   this.o = o;
}","/** 
 * Create a Variant.
 * @param o The wrapped value.
 * @param sig The explicit type of the value, as a dbus type string.
 * @throws IllegalArugmentException If you try and wrap Null or an object which cannot be sent over DBus.
 */
public Variant(T o, String sig) throws IllegalArgumentException 
{
    if (o == null)
        throw new IllegalArgumentException(""Null is not a valid variant value"");
    if (o instanceof DBusInterface)
        throw new IllegalArgumentException(""Objects which implement DBusInterface are not valid variant values"");
    this.sig = sig;
    this.o = o;
}   ",1945,False
"// create a new vector with just the valid keys in and return it
public long[] getKeys(){
   int size;
   if (start < end) size = end-start;
   else size = kv.length-(start-end);
   long[] lv = new long[size];
   int copya;
   if (size > kv.length-start) copya = kv.length-start;
   else copya = size;
   System.arraycopy(kv,start,lv,0,copya);
   if (copya < size) {
      System.arraycopy(kv,0,lv,copya,size-copya);
   }
   return lv;
}","// create a new vector with just the valid keys in and return it
public long[] getKeys() 
{
    long[] keys = new long[validKeys];
    int i = 0;
    for (int j = 0; j < values.length; j++)
    {
        if (values[j] != null)
        {
            keys[i] = j;
            i++;
        }
    }
    return keys;
}   ",1946,True
"/** 
 * Create a new signal.
 * This contructor MUST be called by all sub classes.
 * @param objectpath The path to the object this is emitted from.
 * @param args The parameters of the signal.
 * @throws DBusException This is thrown if the subclass is incorrectly defined.
 */
@SuppressWarnings(""unchecked"")
protected DBusSignal(String objectpath, Object... args) throws DBusException{
   super(Message.Endian.BIG, Message.MessageType.SIGNAL, (byte) 0);

   if (!objectpath.matches(AbstractConnection.OBJECT_REGEX)) throw new DBusException(_(""Invalid object path: "")+objectpath);

   Class<? extends DBusSignal> tc = getClass();
   String member;
   if (tc.isAnnotationPresent(DBusMemberName.class))
      member = tc.getAnnotation(DBusMemberName.class).value();
   else
      member = tc.getSimpleName();
   String iface = null;
   Class<? extends Object> enc = tc.getEnclosingClass();
   if (null == enc ||
         !DBusInterface.class.isAssignableFrom(enc) ||
         enc.getName().equals(enc.getSimpleName()))
      throw new DBusException(_(""Signals must be declared as a member of a class implementing DBusInterface which is the member of a package.""));
   else
      if (null != enc.getAnnotation(DBusInterfaceName.class))
         iface = enc.getAnnotation(DBusInterfaceName.class).value();
      else
         iface = AbstractConnection.dollar_pattern.matcher(enc.getName()).replaceAll(""."");

   headers.put(Message.HeaderField.PATH,objectpath);
   headers.put(Message.HeaderField.MEMBER,member);
   headers.put(Message.HeaderField.INTERFACE,iface);

   Vector<Object> hargs = new Vector<Object>();
   hargs.add(new Object[] { Message.HeaderField.PATH, new Object[] { ArgumentType.OBJECT_PATH_STRING, objectpath } });
   hargs.add(new Object[] { Message.HeaderField.INTERFACE, new Object[] { ArgumentType.STRING_STRING, iface } });
   hargs.add(new Object[] { Message.HeaderField.MEMBER, new Object[] { ArgumentType.STRING_STRING, member } });

   String sig = null;
   if (0 < args.length) {
      try {
         Type[] types = typeCache.get(tc);
         if (null == types) {
            Constructor<? extends DBusSignal> con = (Constructor<? extends DBusSignal>) tc.getDeclaredConstructors()[0];
            conCache.put(tc, con);
            Type[] ts = con.getGenericParameterTypes();
            types = new Type[ts.length-1];
            for (int i = 1; i <= types.length; i++) 
               if (ts[i] instanceof TypeVariable)
                  types[i-1] = ((TypeVariable<GenericDeclaration>) ts[i]).getBounds()[0];
               else
                  types[i-1] = ts[i];
            typeCache.put(tc, types);
         }
         sig = Marshalling.getDBusType(types);
         hargs.add(new Object[] { Message.HeaderField.SIGNATURE, new Object[] { ArgumentType.SIGNATURE_STRING, sig } });
         headers.put(Message.HeaderField.SIGNATURE,sig);
         setArgs(args);
      } catch (Exception e) {
         if (AbstractConnection.EXCEPTION_DEBUG && Debug.debug) Debug.print(Debug.ERR, e);
         throw new DBusException(_(""Failed to add signal parameters: "")+e.getMessage());
      }
   }

   blen = new byte[4];
   appendBytes(blen);
   append(""ua(yv)"", ++serial, hargs.toArray());
   pad((byte)8);
}","/** 
 * Create a new signal.
 * This contructor MUST be called by all sub classes.
 * @param objectpath The path to the object this is emitted from.
 * @param args The parameters of the signal.
 * @throws DBusException This is thrown if the subclass is incorrectly defined.
 */
@SuppressWarnings(""unchecked"")
protected DBusSignal(String objectpath, Object... args) throws DBusException 
{
   Class<?>[] parameterTypes = new Class[args.length];
   for (int i = 0; i < args.length; i++) {
      parameterTypes[i] = args[i].getClass();
   }
   try {
      constructor = getClass().getConstructor(parameterTypes);
   } catch (NoSuchMethodException nsme) {
      throw new DBusException(""Could not find constructor for "" + getClass().getSimpleName());
   }
   this.objectpath = objectpath;
   this.args = args;
}   ",1950,False
"/** 
 * Create a Variant.
 * @param o The wrapped value.
 * @param type The explicit type of the value.
 * @throws IllegalArugmentException If you try and wrap Null or an object which cannot be sent over DBus.
 */
public Variant(T o, Type type) throws IllegalArgumentException{
   if (null == o) throw new IllegalArgumentException(_(""Can't wrap Null in a Variant""));
   this.type = type;
   try {
      String[] ss = Marshalling.getDBusType(type);
      if (ss.length != 1)
      throw new IllegalArgumentException(_(""Can't wrap a multi-valued type in a Variant: "")+type);
      this.sig = ss[0];
   } catch (DBusException DBe) {
      if (AbstractConnection.EXCEPTION_DEBUG && Debug.debug) Debug.print(Debug.ERR, DBe);
      throw new IllegalArgumentException(MessageFormat.format(_(""Can't wrap {0} in an unqualified Variant ({1}).""), new Object[] { type, DBe.getMessage() }));
   }
   this.o = o;
}","/** 
 * Create a Variant.
 * @param o The wrapped value.
 * @param type The explicit type of the value.
 * @throws IllegalArugmentException If you try and wrap Null or an object which cannot be sent over DBus.
 */
public Variant(T o, Type type) throws IllegalArgumentException 
{
    if (o == null) {
        throw new IllegalArgumentException(""Null is not allowed as a Variant value"");
    }

    if (o instanceof DBusInterface) {
        throw new IllegalArgumentException(""DBusInterfaces are not allowed as a Variant value"");
    }

    this.type = type;
    this.value = o;
}   ",1951,True
"/**
 * Returns the struct contents in order.
 * @throws DBusException If there is  a problem doing this.
 */
public final Object[] getParameters(){
   if (null != parameters) return parameters;
   setup();
   return parameters;
}","/**
 * Returns the struct contents in order.
 * @throws DBusException If there is  a problem doing this.
 */
public final Object[] getParameters() 
{
    if (parameters == null) {
        return null;
    }
    return parameters.toArray(new Object[parameters.size()]);
}   ",1952,True
"/**
 * Recursively converts types for serialization onto DBus.
 * @param parameters The parameters to convert.
 * @param types The (possibly generic) types of the parameters.
 * @return The converted parameters.
 * @throws DBusException Thrown if there is an error in converting the objects.
 */
@SuppressWarnings(""unchecked"")
public static Object[] convertParameters(Object[] parameters, Type[] types, AbstractConnection conn) throws DBusException{
   if (null == parameters) return null;
   for (int i = 0; i < parameters.length; i++) {
      if (Debug.debug) Debug.print(Debug.VERBOSE,""Converting ""+i+"" from ""+parameters[i]+"" to ""+types[i]);
      if (null == parameters[i]) continue;

      if (parameters[i] instanceof DBusSerializable) {
         for (Method m: parameters[i].getClass().getDeclaredMethods()) 
            if (m.getName().equals(""deserialize"")) {
               Type[] newtypes = m.getParameterTypes();
               Type[] expand = new Type[types.length + newtypes.length - 1];
               System.arraycopy(types, 0, expand, 0, i); 
               System.arraycopy(newtypes, 0, expand, i, newtypes.length); 
               System.arraycopy(types, i+1, expand, i+newtypes.length, types.length-i-1); 
               types = expand;
               Object[] newparams = ((DBusSerializable) parameters[i]).serialize();
               Object[] exparams = new Object[parameters.length + newparams.length - 1];
               System.arraycopy(parameters, 0, exparams, 0, i);
               System.arraycopy(newparams, 0, exparams, i, newparams.length);
               System.arraycopy(parameters, i+1, exparams, i+newparams.length, parameters.length-i-1);
               parameters = exparams;
            }
         i--;
      } else if (parameters[i] instanceof Tuple) {
         Type[] newtypes = ((ParameterizedType) types[i]).getActualTypeArguments();
         Type[] expand = new Type[types.length + newtypes.length - 1];
         System.arraycopy(types, 0, expand, 0, i);
         System.arraycopy(newtypes, 0, expand, i, newtypes.length);
         System.arraycopy(types, i+1, expand, i+newtypes.length, types. length-i-1);
         types = expand;
         Object[] newparams = ((Tuple) parameters[i]).getParameters();
         Object[] exparams = new Object[parameters.length + newparams.length - 1];
         System.arraycopy(parameters, 0, exparams, 0, i);
         System.arraycopy(newparams, 0, exparams, i, newparams.length);
         System.arraycopy(parameters, i+1, exparams, i+newparams.length, parameters.length-i-1);
         parameters = exparams;
         if (Debug.debug) Debug.print(Debug.VERBOSE, ""New params: ""+Arrays.deepToString(parameters)+"" new types: ""+Arrays.deepToString(types));
         i--;
      } else if (types[i] instanceof TypeVariable &&
            !(parameters[i] instanceof Variant)) 
         // its an unwrapped variant, wrap it
         parameters[i] = new Variant<Object>(parameters[i]);
      else if (parameters[i] instanceof DBusInterface)
         parameters[i] = conn.getExportedObject((DBusInterface) parameters[i]);
   }
   return parameters;
}","/**
 * Recursively converts types for serialization onto DBus.
 * @param parameters The parameters to convert.
 * @param types The (possibly generic) types of the parameters.
 * @return The converted parameters.
 * @throws DBusException Thrown if there is an error in converting the objects.
 */
@SuppressWarnings(""unchecked"")
public static Object[] convertParameters(Object[] parameters, Type[] types, AbstractConnection conn) throws DBusException 
{
    Object[] newParameters = new Object[parameters.length];
    for (int i = 0; i < parameters.length; i++)
    {
        newParameters[i] = convertParameter(parameters[i], types[i], conn);
    }
    return newParameters;
}   ",1955,False
"/** 
 * Create a Variant from a basic type object.
 * @param o The wrapped value.
 * @throws IllegalArugmentException If you try and wrap Null or an object of a non-basic type.
 */
public Variant(T o) throws IllegalArgumentException{
   if (null == o) throw new IllegalArgumentException(_(""Can't wrap Null in a Variant""));
   type = o.getClass();
   try {
      String[] ss = Marshalling.getDBusType(o.getClass(), true);
      if (ss.length != 1)
      throw new IllegalArgumentException(_(""Can't wrap a multi-valued type in a Variant: "")+type);
      this.sig = ss[0];
   } catch (DBusException DBe) {
      if (AbstractConnection.EXCEPTION_DEBUG && Debug.debug) Debug.print(Debug.ERR, DBe);
      throw new IllegalArgumentException(MessageFormat.format(_(""Can't wrap {0} in an unqualified Variant ({1}).""), new Object[] { o.getClass(), DBe.getMessage() }));
   }
   this.o = o;
}","/** 
 * Create a Variant from a basic type object.
 * @param o The wrapped value.
 * @throws IllegalArugmentException If you try and wrap Null or an object of a non-basic type.
 */
public Variant(T o) throws IllegalArgumentException 
{
    if (o == null)
        throw new IllegalArgumentException(""Cannot wrap null"");
    if (o instanceof Variant)
        throw new IllegalArgumentException(""Cannot wrap Variant"");
    this.o = o;
}   ",1956,False
"/**
 * Will return the DBus type corresponding to the given Java type.
 * Note, container type should have their ParameterizedType not their
 * Class passed in here.
 * @param c The Java types.
 * @return The DBus types.
 * @throws DBusException If the given type cannot be converted to a DBus type.
 */
public static String getDBusType(Type[] c) throws DBusException{
   StringBuffer sb = new StringBuffer();
   for (Type t: c) 
      for (String s: getDBusType(t))
         sb.append(s);
   return sb.toString();
}","/**
 * Will return the DBus type corresponding to the given Java type.
 * Note, container type should have their ParameterizedType not their
 * Class passed in here.
 * @param c The Java types.
 * @return The DBus types.
 * @throws DBusException If the given type cannot be converted to a DBus type.
 */
public static String getDBusType(Type[] c) throws DBusException 
{
    if (0 == c.length)
        throw new DBusException(""Zero length array"");

    if (c[0] instanceof Class)
    {
        Class<?> clz = (Class<?>) c[0];
        if (clz.isPrimitive())
        {
            if (Boolean.TYPE.equals(clz))
                return DBusSignature.BOOLEAN;
            if (Byte.TYPE.equals(clz))
                return DBusSignature.BYTE;
            if (Double.TYPE.equals(clz))
                return DBusSignature.DOUBLE;
            if (Float.TYPE.equals(clz))
                return DBusSignature.FLOAT;
            if (Integer.TYPE.equals(clz))
                return DBusSignature.INT;
            if (Long.TYPE.equals(clz))
                return DBusSignature.LONG;
            if (Short.TYPE.equals(clz))
                return DBusSignature.SHORT;
            if (String.class.equals(clz))
                return DBusSignature.STRING;
            if (Void.TYPE.equals(clz))
                return DBusSignature.VOID;
            throw new DBusException(""Unknown primitive type: "" + clz.getName());
        }
        else if (DBusInterface.class.isAssignableFrom(clz))
            return DBusSignature.OBJECTPATH;
        else if (Number.class.isAssignableFrom(clz))
            return DBusSignature.DOUBLE;
        else if (Boolean.class.isAssignableFrom(clz))
            return DBusSignature.BOOLEAN;
        else if (String.class.isAssignableFrom(clz))
            return DBusSignature.STRING;
        else if (Map.class.isAssignableFrom(clz))
            return DBusSignature.ANY;
        else if (Collection.class.isAssignableFrom(clz))
            return DBusSignature.ANY;
        else
            return DBusSignature.STRUCT;
    }
    else if (c[0] instanceof ParameterizedType)
    {
        ParameterizedType ptc = (ParameterizedType) c[0];
        if (Map.class.isAssignableFrom((Class<?>) ptc.getRawType()))
            return DBusSignature.ANY;
        else if (Collection.class.isAssignableFrom((Class<?>) ptc.getRawType()))
            return DBusSignature.ANY;
        else
            throw new DBusException(""Unsupported parameterized type: "" + ptc.getRawType().toString());
    }
    else
        throw new DBusException(""Unsupported type: "" + c[0].getClass().getName());
}   ",1958,False
"/**
 * Deletes an alert from the DB
 * 
 * @param alertId The rowId of the alert to delete
 */
public void deleteAlert(long alertId){
    	Log.d(TAG, ""deleting alert "" + alertId);
        mDb.delete(db_ALERT_TABLE, db_ID + ""="" + alertId, null);
        updateAlertSchedule();
    }","/**
 * Deletes an alert from the DB
 * 
 * @param alertId The rowId of the alert to delete
 */

public void deleteAlert(long alertId) 
{
    SQLiteDatabase db = this.getWritableDatabase();
    db.delete(TABLE_ALERTS, KEY_ID + "" = ?"",
            new String[] { String.valueOf(alertId) });
    db.close();
}   ",1960,True
"/**
 * Updates an alert in the DB according to changes in the DTO (if any)
 * 
 * @param alert The Alert DTO of the alert to be updated
 */
public void updateAlert(Alert alert){
		ContentValues args = alert.getChanged();
		if(args.size() > 0) {
	        mDb.update(db_ALERT_TABLE, args, db_ID + ""="" + alert.id, null);
	        alert.clearChanged();
	        updateAlertSchedule();
		}
	}","/**
 * Updates an alert in the DB according to changes in the DTO (if any)
 * 
 * @param alert The Alert DTO of the alert to be updated
 */
public void updateAlert(Alert alert) 
{
    AlertEntity alertEntity = alertRepository.findByAlertId(alert.getAlertId());
    if (alertEntity != null) {
        alertEntity.setAlertName(alert.getAlertName());
        alertEntity.setAlertDescription(alert.getAlertDescription());
        alertEntity.setAlertPriority(alert.getAlertPriority());
        alertEntity.setAlertStatus(alert.getAlertStatus());
        alertRepository.save(alertEntity);
    }
}   ",1961,False
"/**
 * 
 * Hands an alarm to the alarm manager to go off later.
 * 
 * @param context
 *            Application context
 * @param alertId
 *            rowId of the tracker that the alert refers to
 * @param time
 *            Time at which to go off (system time in milliseconds)
 */
public static void setAlert(Context context, long alertId, long time){
	Log.d(TAG, ""Setting alert for alert "" + alertId);
	Intent intent = new Intent(context, AlertReceiver.class);
	intent.putExtra(C.db_ALERT_TABLE, alertId);
	PendingIntent pendingIntent = PendingIntent.getBroadcast(context,
			AlarmManager.RTC_WAKEUP, intent,
			PendingIntent.FLAG_CANCEL_CURRENT // keeps from re-using the
												// previous intent
			);
	AlarmManager alarmManager = (AlarmManager) context
			.getSystemService(Context.ALARM_SERVICE);
	alarmManager.cancel(pendingIntent);
	if(time > 0 )
		alarmManager.set(AlarmManager.RTC_WAKEUP, time, pendingIntent);
}","/**
 * 
 * Hands an alarm to the alarm manager to go off later.
 * 
 * @param context
 *            Application context
 * @param alertId
 *            rowId of the tracker that the alert refers to
 * @param time
 *            Time at which to go off (system time in milliseconds)
 */








public static void setAlert(Context context, long alertId, long time) 
{
    Intent alert = new Intent(context, AlarmAlertBroadcastReceiver.class);
    alert.putExtra(""alertId"", alertId);
    PendingIntent sender = PendingIntent.getBroadcast(context, 0, alert, PendingIntent.FLAG_UPDATE_CURRENT);
    AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    am.set(AlarmManager.RTC_WAKEUP, time, sender);
}   ",1963,False
"/* get the cursor with all lists and attach to the spinner */
private void fillGroupSpinner(){
	Log.d(TAG, ""fillGroupSpinner"");
	mSpinner = new GroupSpinner(this,
			(Spinner) findViewById(R.id.group_spinner), mDba);
	mSpinner.setOnGroupSelectedListener(this);
	mCurrentGroupId = mSpinner.getSelectedItemId();
}","/* get the cursor with all lists and attach to the spinner */


private void fillGroupSpinner() 
{
    Cursor c = mResolver.query(Groups.CONTENT_URI, null, null, null, null);
    startManagingCursor(c);

    SimpleCursorAdapter adapter = new SimpleCursorAdapter(this,
            android.R.layout.simple_spinner_item, c,
            new String[] { Groups.GROUP_NAME },
            new int[] { android.R.id.text1 });
    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
    mGroupSpinner.setAdapter(adapter);
}   ",1965,False
"/*
 * *********************************************************************
 * 
 * Handle group table
 * 
 */
public long createGroup(String title){
    // @return listId or -1 if failed
	Log.d(TAG, ""creating group "" + title);
    ContentValues initialValues = new ContentValues();
    initialValues.put(db_GROUP_NAME, title);

    return mDb.insert(db_GROUP_TABLE, null, initialValues);
}","/*
 * *********************************************************************
 * 
 * Handle group table
 * 
 */









public long createGroup(String title) 
{
    String sql = ""INSERT INTO groups (title) VALUES (?)"";
    long id = -1;
    try {
        PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        pstmt.setString(1, title);
        pstmt.executeUpdate();
        ResultSet rs = pstmt.getGeneratedKeys();
        if (rs.next()) {
            id = rs.getLong(1);
        }
        rs.close();
        pstmt.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return id;
}   ",1974,False
"// quiet hours disabled
public QuietHours(String beginStr, String endStr){
			begin = extractDateLimit(beginStr);
			end = extractDateLimit(endStr);
			if(begin == null || end == null)
				return; // can't do anything with this; quiet hours disabled
			
			enabled = true;
			if(endStr.compareTo(beginStr) <= 0) {
				// end equal or before beginning = overnight quiet hours
				if(begin.after(now)) // begin > now
					begin.roll(Calendar.DATE, -1); // use yesterday's period begin
				else if(end.before(now)) // end < now
					end.roll(Calendar.DATE, 1); // use tomorrow's period end
			}
		}","// quiet hours disabled
public QuietHours(String beginStr, String endStr) 
{
    if (beginStr != null && endStr != null)
    {
        begin = parseTime(beginStr);
        end = parseTime(endStr);
    }
    else
    {
        begin = null;
        end = null;
    }
}   ",1975,True
"// TODO: all this stuff regarding intervals might really not belong in a DTO.
// Should probably move to some util class or something.
public int getSingleIval(Interval i){
	switch (i) {
	case MONTHS:
		return ivalMonths;
	case WEEKS:
		return ivalWeeks;
	case DAYS:
		return ivalDays;
	case HOURS:
		return ivalHours;
	case MINUTES:
		return ivalMinutes;
	case SECONDS:
		return ivalSeconds;
	}
	return 0;
}","// TODO: all this stuff regarding intervals might really not belong in a DTO.
// Should probably move to some util class or something.
public int getSingleIval(Interval i) 
{
    if (i == null)
    {
        return 0;
    }
    else if (i.isSingle())
    {
        return 1;
    }
    else
    {
        return 0;
    }
}   ",1978,True
"/**
 * Close any open database handles.
 */
public void close(){
	if(mDbHelper == null) return;
    mDbHelper.close();
    mDb = null;
    mDbHelper = null;
}","/**
 * Close any open database handles.
 */
public void close() 
{
    if (mDatabase != null)
    {
        mDatabase.close();
        mDatabase = null;
    }
}   ",1979,True
