code1,code2,repo,predictions
"/**
 * Animate child views from side to side (based on the provided corner parameter), alternating left to right and right to left on each row.
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean indicating if the selection is reversed
 * @param corner {@link com.willowtreeapps.spruce.sort.CorneredSort.Corner Corner} value to start from
 */
public SnakeSort(long interObjectDelay, boolean reversed, Corner corner){
    super(interObjectDelay, reversed, corner);
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
}","/**
 * Animate child views from side to side (based on the provided corner parameter), alternating left to right and right to left on each row.
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean indicating if the selection is reversed
 * @param corner {@link com.willowtreeapps.spruce.sort.CorneredSort.Corner Corner} value to start from
 */
public SnakeSort(long interObjectDelay, boolean reversed, Corner corner) 
{
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
    this.corner = corner;
}   ",0,True
"/**
 * excludeViews to exclude the view with Ids as a list of integers
 *
 * @param exclusionList list of ids that are excluded from the choreographed spruce animation.
 * @param mode          there are two modes for exclusion
 *                      1. R_L_MODE : In this mode, you can set the positions of the list view
 *                      / recycler view that is to be excluded/
 *                      2. NORMAL_MODE : This mode is used to exclude the views from view groups
 *                      other than recycler view/ list view.
 * @return SpruceBuilder object
 */
public SpruceBuilder excludeViews(@NonNull List<Integer> exclusionList, int mode){
    exclusionHelper.initialize(exclusionList, mode);
    return this;
}","/**
 * excludeViews to exclude the view with Ids as a list of integers
 *
 * @param exclusionList list of ids that are excluded from the choreographed spruce animation.
 * @param mode          there are two modes for exclusion
 *                      1. R_L_MODE : In this mode, you can set the positions of the list view
 *                      / recycler view that is to be excluded/
 *                      2. NORMAL_MODE : This mode is used to exclude the views from view groups
 *                      other than recycler view/ list view.
 * @return SpruceBuilder object
 */
public SpruceBuilder excludeViews(@NonNull List<Integer> exclusionList, int mode) 
{
    if (mode == R_L_MODE)
    {
        this.exclusionListRL = exclusionList;
    }
    else if (mode == NORMAL_MODE)
    {
        this.exclusionList = exclusionList;
    }
    return this;
}   ",2,True
"/**
 * isToBeIncluded function works in 2 modes,
 * 1. ID mode : exclude if the ID is present.
 * 2. Index mode: exclude a specific index.
 *
 * @param view  the view to be checked for exclusion.
 * @param index index of the view/
 * @return true of the view is to be included else excluded.
 */
public boolean isToBeIncluded(View view, int index){
    if (mode == NORMAL_MODE) {
        return view != null && !exclusionMap.containsKey(view.getId());
    } else if (mode == R_L_MODE) {
        return view != null && !exclusionMap.containsKey(index);
    }
    return false;
}","/**
 * isToBeIncluded function works in 2 modes,
 * 1. ID mode : exclude if the ID is present.
 * 2. Index mode: exclude a specific index.
 *
 * @param view  the view to be checked for exclusion.
 * @param index index of the view/
 * @return true of the view is to be included else excluded.
 */
public boolean isToBeIncluded(View view, int index) 
{
    if (mMode == ID_MODE)
    {
        return !mIds.contains(view.getId());
    }
    else
    {
        return index != mIndex;
    }
}   ",3,False
"/**
 * filterViews function will filter out the {@link HashMap} exclusionMap from the parent view group.
 *
 * @param viewGroup parent view group
 * @return returns filtered list of type view
 */
public List<View> filterViews(ViewGroup viewGroup){
    List<View> children = new ArrayList<>();

    /*
     * The reason why we use hash map for the comparison is because
     * HashMap has complexity of O(1) for insertion and lookup.
     * this will keep the overall complexity as O(n).
     */
    for (int index = 0; index < viewGroup.getChildCount(); index++) {
        View view = viewGroup.getChildAt(index);
        if (isToBeIncluded(view, index))
            children.add(view);
    }
    return children;
}","/**
 * filterViews function will filter out the {@link HashMap} exclusionMap from the parent view group.
 *
 * @param viewGroup parent view group
 * @return returns filtered list of type view
 */

public List<View> filterViews(ViewGroup viewGroup) 
{
    List<View> filteredViews = new ArrayList<>();
    for (int i = 0; i < viewGroup.getChildCount(); i++)
    {
        View child = viewGroup.getChildAt(i);
        if (!exclusionMap.containsKey(child.getId()))
        {
            filteredViews.add(child);
        }
    }
    return filteredViews;
}   ",4,True
"/**
 * Establishes the delay between object animations and their direction based on distance,
 * delay, and a value from the Direction enum
 * @param interObjectDelay delay between object animations
 * @param reversed flag to indicate if the animation should be reversed
 * @param direction enum value of the direction the animation should start from and end with
 */
public LinearSort(long interObjectDelay, boolean reversed, Direction direction){
    super(interObjectDelay, reversed);
    if (direction == null) {
        throw new NullPointerException(""Direction can't be null and must be of a valid type"");
    }
    this.direction = direction;
}","/**
 * Establishes the delay between object animations and their direction based on distance,
 * delay, and a value from the Direction enum
 * @param interObjectDelay delay between object animations
 * @param reversed flag to indicate if the animation should be reversed
 * @param direction enum value of the direction the animation should start from and end with
 */
public LinearSort(long interObjectDelay, boolean reversed, Direction direction) 
{
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
    this.direction = direction;
}   ",5,True
"/**
 * Animate child views from side to side (based on the provided corner parameter).
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean indicating if the selection is reversed
 * @param corner {@link com.willowtreeapps.spruce.sort.CorneredSort.Corner Corner} value to start from
 */
public InlineSort(long interObjectDelay, boolean reversed, Corner corner){
    super(interObjectDelay, reversed, corner);
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
}","/**
 * Animate child views from side to side (based on the provided corner parameter).
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean indicating if the selection is reversed
 * @param corner {@link com.willowtreeapps.spruce.sort.CorneredSort.Corner Corner} value to start from
 */
public InlineSort(long interObjectDelay, boolean reversed, Corner corner) 
{
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
    this.corner = corner;
}   ",6,True
"/**
 * Apply one to many animations to the ViewGroup
 *
 * @param animators Animator array to apply to the ViewGroup children
 * @return SpruceBuilder object
 */
public SpruceBuilder animateWith(Animator... animators){
    this.animators = animators;
    return this;
}","/**
 * Apply one to many animations to the ViewGroup
 *
 * @param animators Animator array to apply to the ViewGroup children
 * @return SpruceBuilder object
 */
public SpruceBuilder animateWith(Animator... animators) 
{
    if (animators == null || animators.length == 0)
    {
        throw new IllegalArgumentException(""Animators cannot be null or empty"");
    }

    this.animators = animators;
    return this;
}   ",8,True
"/**
 * addInterpolator adds the interpolator to the {@link AnimatorSet}, This gives the user
 * complete control over the overall flow of the animation.
 * <p>
 * A {@link LinearInterpolator} is substituted of the user doesn't add an interpolator.
 *
 * @param interpolator interpolator for the animation set.
 * @return SpruceBuilder object
 */
public SpruceBuilder addInterpolator(Interpolator interpolator){
    this.interpolator = interpolator;
    return this;
}","/**
 * addInterpolator adds the interpolator to the {@link AnimatorSet}, This gives the user
 * complete control over the overall flow of the animation.
 * <p>
 * A {@link LinearInterpolator} is substituted of the user doesn't add an interpolator.
 *
 * @param interpolator interpolator for the animation set.
 * @return SpruceBuilder object
 */

public SpruceBuilder addInterpolator(Interpolator interpolator) 
{
    if (interpolator == null)
    {
        this.interpolator = new LinearInterpolator();
    }
    else
    {
        this.interpolator = interpolator;
    }
    return this;
}   ",10,True
"/**
 * Animates views in a corner like fashion. The views near the starting corner will animate first.
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean
 * @param corner Corner enum value {@link Corner corner}
 */
public CorneredSort(long interObjectDelay, boolean reversed, Corner corner){
    super(interObjectDelay, reversed);
    if (corner == null) {
        throw new NullPointerException(""Corner can't be null and must be a valid type"");
    }
    this.interObjectDelay = interObjectDelay;
    this.corner = corner;
    this.reversed = reversed;
}","/**
 * Animates views in a corner like fashion. The views near the starting corner will animate first.
 *
 * @param interObjectDelay long delay between objects
 * @param reversed boolean
 * @param corner Corner enum value {@link Corner corner}
 */
public CorneredSort(long interObjectDelay, boolean reversed, Corner corner) 
{
    this.interObjectDelay = interObjectDelay;
    this.reversed = reversed;
    this.corner = corner;
}   ",11,True
"/**
 * Creates a Spruce instance and starts the sequence of animations
 *
 * @return Spruce The Spruce object to apply operations to.
 */
public Animator start(){
    Spruce spruce = new Spruce(this);
    return spruce.animatorSet;
}","/**
 * Creates a Spruce instance and starts the sequence of animations
 *
 * @return Spruce The Spruce object to apply operations to.
 */
public Animator start() 
{
    Spruce spruce = new Spruce();
    spruce.start();
    return spruce;
}   ",12,True
"/**
 * Get the point that's closest to the start point
 *
 * @param children List of views to sort by distance
 * @return PointF of the distance between a point and 0, 0
 */
public PointF getDistancePoint(ViewGroup parent, List<View> children){
    PointF distancePoint = new PointF(0, 0);
    return translate(distancePoint, children);
}","/**
 * Get the point that's closest to the start point
 *
 * @param children List of views to sort by distance
 * @return PointF of the distance between a point and 0, 0
 */
public PointF getDistancePoint(ViewGroup parent, List<View> children) 
{
    PointF closestPoint = new PointF(0, 0);
    float closestDistance = Float.MAX_VALUE;

    for (View child : children)
    {
        PointF point = new PointF(child.getX(), child.getY());
        float distance = getDistance(point, new PointF(0, 0));

        if (distance < closestDistance)
        {
            closestDistance = distance;
            closestPoint = point;
        }
    }

    return closestPoint;
}   ",13,True
"/**
 * This method is used to set the interpolator for {@link Spruce} builder.
 */
private void initInterpolatorSelection(){
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        /*
         * Path Interpolator is only supported only versions >=
         * {@link Build.VERSION_CODES.LOLLIPOP}
         */
        final InterpolatorSelector selector = new InterpolatorSelector();

        builderSingle = new AlertDialog.Builder(getActivity());
        builderSingle.setTitle(getResources().getString(R.string.interpolator));
        final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<>(getContext(),
                android.R.layout.select_dialog_singlechoice);
        arrayAdapter.addAll(getResources().getStringArray(R.array.interpolator_array));
        builderSingle.setNegativeButton(getResources().getString(R.string.cancel), new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        });

        builderSingle.setAdapter(arrayAdapter, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                btnInterpolator.setText(arrayAdapter.getItem(which));
                interpolator = selector.getInterpolatorMap(which);
                dialog.dismiss();
            }
        });
        initializeInterpolatorClickListener();
    } else {
        // Don't need to show, user can use predefined interpolator from the framework.
        btnInterpolator.setVisibility(View.GONE);
    }

}","/**
 * This method is used to set the interpolator for {@link Spruce} builder.
 */

private void initInterpolatorSelection() 
{
    this.interpolator = new ChoiceBox<>();
    this.interpolator.getItems().addAll(Interpolator.EASE_BOTH, Interpolator.EASE_IN, Interpolator.EASE_OUT, Interpolator.LINEAR);
    this.interpolator.setValue(Interpolator.EASE_BOTH);
    this.interpolator.setMinWidth(150);
}   ",14,True
"/**
 * getExclusionViews method has a predefined set of Id that will be excluded from the
 * choreography.
 *
 * @return returns the list of ids to be excluded.
 */
private List<Integer> getExclusionViews(){
    List<Integer> ids = new ArrayList<>();
    if (excludeView.isChecked()) {
        ids.add(1);
        ids.add(10);
        ids.add(17);
        ids.add(21);
        ids.add(26);
        ids.add(30);
    }
    return ids;
}","/**
 * getExclusionViews method has a predefined set of Id that will be excluded from the
 * choreography.
 *
 * @return returns the list of ids to be excluded.
 */
private List<Integer> getExclusionViews() 
{
    List<Integer> excludedIds = new ArrayList<>();
    excludedIds.add(R.id.action_search);
    excludedIds.add(R.id.action_settings);
    return excludedIds;
}   ",15,True
"/**
 * SortFunction to animate the ViewGroup
 *
 * @param function subclass of SortFunction to be applied to the ViewGroup
 * @return SpruceBuilder object
 */
public SpruceBuilder sortWith(SortFunction function){
    this.sortFunction = function;
    return this;
}","/**
 * SortFunction to animate the ViewGroup
 *
 * @param function subclass of SortFunction to be applied to the ViewGroup
 * @return SpruceBuilder object
 */
public SpruceBuilder sortWith(SortFunction function) 
{
    this.sortFunction = function;
    return this;
}   ",17,True
"/**
 * This method is used to setup click listener for the interpolator selection button.
 */
private void initializeInterpolatorClickListener(){
    btnInterpolator.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            builderSingle.show();
        }
    });
}","/**
 * This method is used to setup click listener for the interpolator selection button.
 */

private void initializeInterpolatorClickListener() 
{
    interpolatorButton.setOnClickListener(new View.OnClickListener()
    {
        @Override
        public void onClick(View v)
        {
            if (interpolatorMenu.getVisibility() == View.VISIBLE)
            {
                interpolatorMenu.setVisibility(View.GONE);
            }
            else
            {
                interpolatorMenu.setVisibility(View.VISIBLE);
            }
        }
    });
}   ",18,True
"/**
 * This method is used to initialize the exclusion module.
 *
 * @param exclusionList list of items to be excluded.
 * @param mode          mode in which the exclusion works.
 */
public void initialize(List<Integer> exclusionList, int mode){
    /*
     * making hash-map from the given list.
     * This is to cut down the complexity in the future.
     */
    this.mode = mode;
    for (Integer id : exclusionList) {
        exclusionMap.put(id, true);
    }
}","/**
 * This method is used to initialize the exclusion module.
 *
 * @param exclusionList list of items to be excluded.
 * @param mode          mode in which the exclusion works.
 */
public void initialize(List<Integer> exclusionList, int mode) 
{
    this.exclusionList = exclusionList;
    this.mode = mode;
}   ",19,True
"/**
 * @return true if execution tree prefetching is enabled
 */
protected boolean isExecutionTreePrefetchEnabled(){
  return Context.getProcessEngineConfiguration()
    .isExecutionTreePrefetchEnabled();
}","/**
 * @return true if execution tree prefetching is enabled
 */
protected boolean isExecutionTreePrefetchEnabled() 
{
    return executionTreePrefetchEnabled;
}   ",20,True
"// toString /////////////////////////////////////////////////////////////
public String toString(){
  if (isCaseInstanceExecution()) {
    return ""CaseInstance[""+getToStringIdentity()+""]"";
  } else {
    return ""CaseExecution[""+getToStringIdentity()+""]"";
  }
}","// toString /////////////////////////////////////////////////////////////
public String toString() 
{
    String str = """";
    for (int i = 0; i < size; i++)
    {
        str += data[i] + "" "";
    }
    return str;
}   ",23,False
"// sub-/super- case instance ////////////////////////////////////////////////////
public CaseExecutionEntity getSubCaseInstance(){
  ensureSubCaseInstanceInitialized();
  return subCaseInstance;
}","// sub-/super- case instance ////////////////////////////////////////////////////
public CaseExecutionEntity getSubCaseInstance() 
{
    if (subCaseInstances != null && !subCaseInstances.isEmpty())
    {
        return subCaseInstances.iterator().next();
    }
    return null;
}   ",24,True
"/**
 * +-----+   +-----+   +-------+
 * | one |-->| two |-->| three |
 * +-----+   +-----+   +-------+
 */
@Test
public void testScopeActivity(){

  ActivityInstanceVerification verifier = new ActivityInstanceVerification();

  PvmProcessDefinition processDefinition = new ProcessDefinitionBuilder()
    .createActivity(""one"")
      .initial()
      .behavior(new Automatic())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .transition(""two"")
    .endActivity()
    .createActivity(""two"")
      .scope()
      .behavior(new WaitState())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .transition(""three"")
    .endActivity()
    .createActivity(""three"")
      .behavior(new End())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
    .endActivity()
  .buildProcessDefinition();

  PvmProcessInstance processInstance = processDefinition.createProcessInstance();
  processInstance.start();

  PvmExecution childExecution = processInstance.findExecution(""two"");
  String parentActivityInstanceId = ((ExecutionImpl)childExecution).getParentActivityInstanceId();
  assertEquals(((ExecutionImpl)processInstance).getId(), parentActivityInstanceId);

  childExecution.signal(null, null);

  verifier.assertStartInstanceCount(1, ""one"");
  verifier.assertStartInstanceCount(1, ""two"");
  verifier.assertProcessInstanceParent(""two"", processInstance);
  verifier.assertStartInstanceCount(1, ""three"");

}","/**
 * +-----+   +-----+   +-------+
 * | one |-->| two |-->| three |
 * +-----+   +-----+   +-------+
 */
@Test
public void testScopeActivity() 
{
    ScopeActivity activity = new ScopeActivity();
    activity.setScope(new Scope(""one"", ""two"", ""three""));
    assertEquals(""one"", activity.getScope().getFirst());
    assertEquals(""two"", activity.getScope().getSecond());
    assertEquals(""three"", activity.getScope().getThird());
}   ",25,True
"// sentry /////////////////////////////////////////////////////////////////////////
public List<CaseSentryPartEntity> getCaseSentryParts(){
  ensureCaseSentryPartsInitialized();
  return caseSentryParts;
}","// sentry /////////////////////////////////////////////////////////////////////////

public List<CaseSentryPartEntity> getCaseSentryParts() 
{
    if (caseSentryParts == null)
    {
        caseSentryParts = new ArrayList<CaseSentryPartEntity>();
    }
    return caseSentryParts;
}   ",28,True
"/**
 * Creates a meter only for database collection.
 */
public void createDbMeter(String name){
  Meter dbMeter = new Meter(name);
  dbMeters.put(name, dbMeter);
}","/**
 * Creates a meter only for database collection.
 */
public void createDbMeter(String name) 
{
    if (name == null)
    {
        throw new IllegalArgumentException(""Meter name cannot be null"");
    }
    Meter meter = new Meter(name, null);
    meters.put(name, meter);
}   ",29,True
"// parent ////////////////////////////////////////////////////////////////////
public CaseExecutionEntity getParent(){
  ensureParentInitialized();
  return parent;
}","// parent ////////////////////////////////////////////////////////////////////
public CaseExecutionEntity getParent() 
{
    ensureParentLoaded();
    return parent;
}   ",31,True
"// sub process instance ///////////////////////////////////////////////////
public ExecutionEntity getSubProcessInstance(){
  ensureSubProcessInstanceInitialized();
  return subProcessInstance;
}","// sub process instance ///////////////////////////////////////////////////
public ExecutionEntity getSubProcessInstance() 
{
    if (this.subProcessInstance == null)
    {
        this.subProcessInstance = new ExecutionEntity();
    }
    return this.subProcessInstance;
}   ",32,True
"/**
 *           +-------------------------------------------------------+
 *           | embedded subprocess                                   |
 *           |                  +--------------------------------+   |
 *           |                  | nested embedded subprocess     |   |
 * +-----+   | +-----------+    |  +-----------+   +---------+   |   |   +---+
 * |start|-->| |startInside|--> |  |startInside|-->|endInside|   |   |-->|end|
 * +-----+   | +-----------+    |  +-----------+   +---------+   |   |   +---+
 *           |                  +--------------------------------+   |
 *           |                                                       |
 *           +-------------------------------------------------------+
 */
@Test
public void testNestedSubProcessNoEnd(){

  ActivityInstanceVerification verifier = new ActivityInstanceVerification();

  PvmProcessDefinition processDefinition = new ProcessDefinitionBuilder()
    .createActivity(""start"")
      .initial()
      .behavior(new Automatic())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .transition(""embeddedsubprocess"")
    .endActivity()
    .createActivity(""embeddedsubprocess"")
      .scope()
      .behavior(new EmbeddedSubProcess())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .createActivity(""startInside"")
        .behavior(new Automatic())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
        .transition(""nestedSubProcess"")
      .endActivity()
        .createActivity(""nestedSubProcess"")
        .scope()
        .behavior(new EmbeddedSubProcess())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
        .createActivity(""startNestedInside"")
          .behavior(new Automatic())
          .executionListener(ExecutionListener.EVENTNAME_START, verifier)
          .executionListener(ExecutionListener.EVENTNAME_END, verifier)
          .transition(""endInside"")
          .endActivity()
        .createActivity(""endInside"")
          .behavior(new End())
          .executionListener(ExecutionListener.EVENTNAME_START, verifier)
          .executionListener(ExecutionListener.EVENTNAME_END, verifier)
          .endActivity()
      .endActivity()
    .transition(""end"")
    .endActivity()
    .createActivity(""end"")
      .behavior(new End())
       .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
    .endActivity()
  .buildProcessDefinition();

  PvmProcessInstance processInstance = processDefinition.createProcessInstance();
  processInstance.start();
  assertTrue(processInstance.isEnded());

  verifier.assertStartInstanceCount(1, ""start"");
  verifier.assertProcessInstanceParent(""start"", processInstance);
  verifier.assertStartInstanceCount(1, ""embeddedsubprocess"");
  verifier.assertProcessInstanceParent(""embeddedsubprocess"", processInstance);
  verifier.assertStartInstanceCount(1, ""startInside"");
  verifier.assertParent(""startInside"", ""embeddedsubprocess"");
  verifier.assertStartInstanceCount(1, ""nestedSubProcess"");
  verifier.assertParent(""nestedSubProcess"", ""embeddedsubprocess"");
  verifier.assertStartInstanceCount(1, ""startNestedInside"");
  verifier.assertParent(""startNestedInside"", ""nestedSubProcess"");
  verifier.assertStartInstanceCount(1, ""endInside"");
  verifier.assertParent(""endInside"", ""nestedSubProcess"");
  verifier.assertStartInstanceCount(1, ""end"");
  verifier.assertProcessInstanceParent(""end"", processInstance);
}","/**
 *           +-------------------------------------------------------+
 *           | embedded subprocess                                   |
 *           |                  +--------------------------------+   |
 *           |                  | nested embedded subprocess     |   |
 * +-----+   | +-----------+    |  +-----------+   +---------+   |   |   +---+
 * |start|-->| |startInside|--> |  |startInside|-->|endInside|   |   |-->|end|
 * +-----+   | +-----------+    |  +-----------+   +---------+   |   |   +---+
 *           |                  +--------------------------------+   |
 *           |                                                       |
 *           +-------------------------------------------------------+
 */
@Test
public void testNestedSubProcessNoEnd() 
{
    ProcessInstance process = runtimeService.startProcessInstanceByKey(""embedded_subprocess"");

    Task task = taskService.createTaskQuery().singleResult();
    assertEquals(""start"", task.getName());

    taskService.complete(task.getId());

    task = taskService.createTaskQuery().singleResult();
    assertEquals(""startInside"", task.getName());

    taskService.complete(task.getId());

    task = taskService.createTaskQuery().singleResult();
    assertEquals(""startInside"", task.getName());

    taskService.complete(task.getId());

    assertProcessEnded(process.getId());
}   ",33,True
"/**
 *           +-------------------------------------------------+
 *           | embeddedsubprocess        +----------+          |
 *           |                     +---->|endInside1|          |
 *           |                     |     +----------+          |
 *           |                     |                           |
 * +-----+   |  +-----------+   +----+   +----+   +----------+ |   +---+
 * |start|-->|  |startInside|-->|fork|-->|wait|-->|endInside2| |-->|end|
 * +-----+   |  +-----------+   +----+   +----+   +----------+ |   +---+
 *           |                     |                           |
 *           |                     |     +----------+          |
 *           |                     +---->|endInside3|          |
 *           |                           +----------+          |
 *           +-------------------------------------------------+
 */
@Test
public void testMultipleConcurrentEndsInsideEmbeddedSubProcessWithWaitState(){

  ActivityInstanceVerification verifier = new ActivityInstanceVerification();

  PvmProcessDefinition processDefinition = new ProcessDefinitionBuilder()
    .createActivity(""start"")
      .initial()
      .behavior(new Automatic())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .transition(""embeddedsubprocess"")
    .endActivity()
    .createActivity(""embeddedsubprocess"")
      .scope()
      .behavior(new EmbeddedSubProcess())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .createActivity(""startInside"")
        .behavior(new Automatic())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
        .transition(""fork"")
      .endActivity()
      .createActivity(""fork"")
        .behavior(new ParallelGateway())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
        .transition(""endInside1"")
        .transition(""wait"")
        .transition(""endInside3"")
      .endActivity()
      .createActivity(""endInside1"")
        .behavior(new End())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .endActivity()
      .createActivity(""wait"")
        .behavior(new WaitState())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
        .transition(""endInside2"")
      .endActivity()
      .createActivity(""endInside2"")
        .behavior(new End())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .endActivity()
      .createActivity(""endInside3"")
        .behavior(new End())
        .executionListener(ExecutionListener.EVENTNAME_START, verifier)
        .executionListener(ExecutionListener.EVENTNAME_END, verifier)
      .endActivity()
      .transition(""end"")
    .endActivity()
    .createActivity(""end"")
      .behavior(new End())
      .executionListener(ExecutionListener.EVENTNAME_START, verifier)
      .executionListener(ExecutionListener.EVENTNAME_END, verifier)
    .endActivity()
  .buildProcessDefinition();

  PvmProcessInstance processInstance = processDefinition.createProcessInstance();
  processInstance.start();

  assertFalse(processInstance.isEnded());
  PvmExecution execution = processInstance.findExecution(""wait"");
  execution.signal(null, null);

  assertTrue(processInstance.isEnded());

  verifier.assertStartInstanceCount(1, ""start"");
  verifier.assertProcessInstanceParent(""start"", processInstance);

  verifier.assertStartInstanceCount(1, ""embeddedsubprocess"");
  verifier.assertProcessInstanceParent(""embeddedsubprocess"", processInstance);

  verifier.assertStartInstanceCount(1, ""startInside"");
  verifier.assertParent(""startInside"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""fork"");
  verifier.assertParent(""fork"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""wait"");
  verifier.assertParent(""wait"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""endInside1"");
  verifier.assertParent(""endInside1"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""endInside2"");
  verifier.assertParent(""endInside2"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""endInside3"");
  verifier.assertParent(""endInside3"", ""embeddedsubprocess"");

  verifier.assertStartInstanceCount(1, ""end"");
  verifier.assertProcessInstanceParent(""end"", processInstance);

}","/**
 *           +-------------------------------------------------+
 *           | embeddedsubprocess        +----------+          |
 *           |                     +---->|endInside1|          |
 *           |                     |     +----------+          |
 *           |                     |                           |
 * +-----+   |  +-----------+   +----+   +----+   +----------+ |   +---+
 * |start|-->|  |startInside|-->|fork|-->|wait|-->|endInside2| |-->|end|
 * +-----+   |  +-----------+   +----+   +----+   +----------+ |   +---+
 *           |                     |                           |
 *           |                     |     +----------+          |
 *           |                     +---->|endInside3|          |
 *           |                           +----------+          |
 *           +-------------------------------------------------+
 */
@Test
public void testMultipleConcurrentEndsInsideEmbeddedSubProcessWithWaitState() 
{
    EmbeddedSubprocessTestProcess process = new EmbeddedSubprocessTestProcess(getEngine());
    process.setResource(""embeddedsubprocess.bpmn"");
    process.addVariable(""endInside1"", new Boolean(false));
    process.addVariable(""endInside2"", new Boolean(false));
    process.addVariable(""endInside3"", new Boolean(false));
    process.start();
    Assert.assertTrue(process.isVariable(""endInside1"", Boolean.TRUE));
    Assert.assertTrue(process.isVariable(""endInside2"", Boolean.TRUE));
    Assert.assertTrue(process.isVariable(""endInside3"", Boolean.TRUE));
}   ",34,False
"/**
 * @see ExecutionEntity#ensureExecutionTreeInitialized
 */
protected void ensureCaseExecutionTreeInitialized(){
  List<CaseExecutionEntity> executions = Context.getCommandContext()
    .getCaseExecutionManager()
    .findChildCaseExecutionsByCaseInstanceId(caseInstanceId);

  CaseExecutionEntity caseInstance = null;

  Map<String, CaseExecutionEntity> executionMap = new HashMap<String, CaseExecutionEntity>();
  for (CaseExecutionEntity execution : executions) {
    execution.caseExecutions = new ArrayList<CaseExecutionEntity>();
    executionMap.put(execution.getId(), execution);
    if(execution.isCaseInstanceExecution()) {
      caseInstance = execution;
    }
  }

  for (CaseExecutionEntity execution : executions) {
    String parentId = execution.getParentId();
    CaseExecutionEntity parent = executionMap.get(parentId);
    if(!execution.isCaseInstanceExecution()) {
      execution.caseInstance = caseInstance;
      execution.parent = parent;
      parent.caseExecutions.add(execution);
    } else {
      execution.caseInstance = execution;
    }
  }
}","/**
 * @see ExecutionEntity#ensureExecutionTreeInitialized
 */
protected void ensureCaseExecutionTreeInitialized() 
{
    if (!caseExecutionTreeInitialized)
    {
        initializeCaseExecutionTree();
    }
}   ",36,False
"/**
 * This assumes that all children have been fetched
 */
protected boolean matches(ExecutionTree tree){
  // match activity id
  String actualActivityId = tree.getActivityId();
  if (expectedActivityId == null && actualActivityId != null) {
    return false;
  } else if (expectedActivityId != null && !expectedActivityId.equals(tree.getActivityId())) {
    return false;
  }

  if (expectedId != null && !expectedId.equals(tree.getId())) {
    return false;
  }


  // match is scope
  if (expectedIsScope != null && !expectedIsScope.equals(tree.isScope())) {
    return false;
  }

  if (expectedIsConcurrent != null && !expectedIsConcurrent.equals(tree.isConcurrent())) {
    return false;
  }

  if (expectedIsEventScope != null && !expectedIsEventScope.equals(tree.isEventScope())) {
    return false;
  }

  // match children
  if (tree.getExecutions().size() != childAssertions.size()) {
    return false;
  }

  List<ExecutionTreeStructureAssertion> unmatchedChildAssertions = new ArrayList<ExecutionTreeStructureAssertion>(childAssertions);
  for (ExecutionTree child : tree.getExecutions()) {
    for (ExecutionTreeStructureAssertion childAssertion : unmatchedChildAssertions) {
      if (childAssertion.matches(child)) {
        unmatchedChildAssertions.remove(childAssertion);
        break;
      }
    }
  }

  if (!unmatchedChildAssertions.isEmpty()) {
    return false;
  }

  return true;
}","/**
 * This assumes that all children have been fetched
 */
protected boolean matches(ExecutionTree tree) 
{
    if (tree == null)
    {
        return false;
    }
    if (tree instanceof ExecutionTree)
    {
        return matches((ExecutionTree) tree);
    }
    return false;
}   ",37,False
"// setters, initializers etc.
protected void createUserOperationLog(DeploymentBuilderImpl deploymentBuilder, Deployment deployment, CommandContext commandContext){
  UserOperationLogManager logManager = commandContext.getOperationLogManager();

  List<PropertyChange> properties = new ArrayList<>();

  PropertyChange filterDuplicate = new PropertyChange(""duplicateFilterEnabled"", null, deploymentBuilder.isDuplicateFilterEnabled());
  properties.add(filterDuplicate);

  if (deploymentBuilder.isDuplicateFilterEnabled()) {
    PropertyChange deployChangedOnly = new PropertyChange(""deployChangedOnly"", null, deploymentBuilder.isDeployChangedOnly());
    properties.add(deployChangedOnly);
  }

  logManager.logDeploymentOperation(UserOperationLogEntry.OPERATION_TYPE_CREATE, deployment.getId(), properties);
}","// setters, initializers etc.
protected void createUserOperationLog(DeploymentBuilderImpl deploymentBuilder, Deployment deployment, CommandContext commandContext) 
{
    OperationLogEntry entry = new OperationLogEntry(deploymentBuilder, deployment, commandContext);
    deploymentBuilder.getOperationLog().addEntry(entry);
    deploymentBuilder.getDeployment().setOperationLogEntry(entry);
}   ",38,True
"/**
 * Creates a meter for both database and telemetry collection.
 */
public void createMeter(String name){
  Meter dbMeter = new Meter(name);
  dbMeters.put(name, dbMeter);

  Meter telemetryMeter = new Meter(name);
  telemetryMeters.put(name, telemetryMeter);
}","/**
 * Creates a meter for both database and telemetry collection.
 */
public void createMeter(String name) 
{
    Meter meter = Metrics.globalRegistry.get(name);
    if (meter == null)
    {
        meter = Metrics.meter(name);
        Metrics.globalRegistry.register(name, meter);
    }
}   ",39,True
"/**
 * @hide
 */
//@Deprecated
public ConcurrentHashMap<Integer, EventRecord> getEvents(){
    dirtySerializedFlag = true;
    return events;
}","/**
 * @hide
 */
//@Deprecated
public ConcurrentHashMap<Integer, EventRecord> getEvents() 
{
    return events;
}   ",41,True
"//@Deprecated
public static DexFieldDescriptor guessFieldByNewInstance(byte[] buf, DexMethodDescriptor method, Class<?> instanceClass) throws NoSuchMethodException{
    if (instanceClass == null) throw new NullPointerException(""instanceClass == null"");
    return guessFieldByNewInstance(buf, method, ""L"" + instanceClass.getName().replace('.', '/') + "";"");
}","//@Deprecated
public static DexFieldDescriptor guessFieldByNewInstance(byte[] buf, DexMethodDescriptor method, Class<?> instanceClass) throws NoSuchMethodException 
{
    try
    {
        Object instance = instanceClass.newInstance();
        return guessFieldByNewInstance(buf, method, instance);
    } catch (InstantiationException e)
    {
        e.printStackTrace();
    } catch (IllegalAccessException e)
    {
        e.printStackTrace();
    }
    return null;
}   ",45,True
"/*public static int getResourceId(Context context,String name,String type,String packageName){
 Resources themeResources=null;
 PackageManager pm=context.getPackageManager();
 try{
 themeResources=pm.getResourcesForApplication(packageName);
 return themeResources.getIdentifier(name,type,packageName);
 }catch(PackageManager.NameNotFoundException e){}
 return 0;
 }*/
public void doRequestFlRefresh(){
        boolean inLogin;
        inLogin = (Utils.getLongAccountUin() == mUin);
        if (!inLogin) {
            logi(""doRequestFlRefresh but uin("" + mUin + "") isn't logged in."");
            return;
        }
        try {
            //log(""Request friendlist update for "" + mUin + "" ..."");
            invoke_virtual_any(Utils.getFriendListHandler(), true, true, boolean.class, boolean.class, void.class);
        } catch (Exception e) {
            log(e);
        }
    }","/*public static int getResourceId(Context context,String name,String type,String packageName){
 Resources themeResources=null;
 PackageManager pm=context.getPackageManager();
 try{
 themeResources=pm.getResourcesForApplication(packageName);
 return themeResources.getIdentifier(name,type,packageName);
 }catch(PackageManager.NameNotFoundException e){}
 return 0;
 }*/
public void doRequestFlRefresh() 
{
    if (mFlRefresh != null)
    {
        mFlRefresh.requestLayout();
        mFlRefresh.invalidate();
    }
}   ",46,False
"//struct DexCode {
//0   u2  registersSize;
//2   u2  insSize;
//4   u2  outsSize;
//6   u2  triesSize;
//8   u4  debugInfoOff;       /* file offset to debug info stream */
//12  u4  insnsSize;          /* size of the insns array, in u2 units */
//16  u2  insns[1];
//    /* followed by optional u2 padding */
//    /* followed by try_item[triesSize] */
//    /* followed by uleb128 handlersSize */
//    /* followed by catch_handler_item[handlersSize] */
//};
public static boolean hasClassInDex(byte[] dex, String clz){
    if (!clz.endsWith("";"")) {
        clz = ""L"" + clz.replace('.', '/') + "";"";
    }
    int classDefsSize = readLe32(dex, 0x60);
    int classDefsOff = readLe32(dex, 0x64);
    for (int cn = 0; cn < classDefsSize; cn++) {
        int classIdx = readLe32(dex, classDefsOff + cn * 32);
        String c = readType(dex, classIdx);
        if (clz.equals(c)) return true;
    }
    return false;
}","//struct DexCode {
//0   u2  registersSize;
//2   u2  insSize;
//4   u2  outsSize;
//6   u2  triesSize;
//8   u4  debugInfoOff;       /* file offset to debug info stream */
//12  u4  insnsSize;          /* size of the insns array, in u2 units */
//16  u2  insns[1];
//    /* followed by optional u2 padding */
//    /* followed by try_item[triesSize] */
//    /* followed by uleb128 handlersSize */
//    /* followed by catch_handler_item[handlersSize] */
//};
public static boolean hasClassInDex(byte[] dex, String clz) 
{
    try {
        DexFileReader dfr = new DexFileReader(dex);
        for (String className : dfr.getClassNames()) {
            if (className.equals(clz)) {
                return true;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}   ",52,False
"//Return the size 1 or 2
public static int readUtf8_len(byte[] src, int p, int[] ret){
    byte b = src[p];
    if ((0x80 & b) != 0) {
        ret[0] = (b & 0x7f) << 8 | (src[p + 1] & 0xFF);
        return 2;
    } else {
        ret[0] = b & 0xFF;
        return 1;
    }
}","//Return the size 1 or 2
public static int readUtf8_len(byte[] src, int p, int[] ret) 
{
    int b0 = src[p] & 0xFF;
    if (b0 < 0x80) {
        ret[0] = 1;
        return 1;
    } else if ((b0 & 0xE0) == 0xC0) {
        ret[0] = 2;
        return 2;
    } else {
        throw new IllegalArgumentException(""Invalid UTF-8 start byte: "" + Integer.toHexString(b0));
    }
}   ",54,True
"/**
 * @param buf       the byte array containing the whole dex file
 * @param opcodeOff offset relative to {@code buf}
 * @param verify    whether to verify if the {@code opcodeOff} is aligned to opcode,
 *                  return {@code null} if the offset failed the verification
 * @return
 */
@Nullable
public static DexMethodDescriptor getDexMethodByOpOffset(byte[] buf, int opcodeOff, boolean verify){
    int methodIdsSize = readLe32(buf, 0x58);
    int methodIdsOff = readLe32(buf, 0x5c);
    int classDefsSize = readLe32(buf, 0x60);
    int classDefsOff = readLe32(buf, 0x64);
    int[] p = new int[1];
    int[] ret = new int[1];
    int[] co = new int[1];
    for (int cn = 0; cn < classDefsSize; cn++) {
        int classIdx = readLe32(buf, classDefsOff + cn * 32);
        int classDataOff = readLe32(buf, classDefsOff + cn * 32 + 24);
        p[0] = classDataOff;
        if (classDataOff == 0) continue;
        int fieldIdx = 0;
        int staticFieldsSize = readUleb128(buf, p),
                instanceFieldsSize = readUleb128(buf, p),
                directMethodsSize = readUleb128(buf, p),
                virtualMethodsSize = readUleb128(buf, p);
        for (int fn = 0; fn < staticFieldsSize + instanceFieldsSize; fn++) {
            fieldIdx += readUleb128(buf, p);
            int accessFlags = readUleb128(buf, p);
        }
        int methodIdx = 0;
        for (int mn = 0; mn < directMethodsSize; mn++) {
            methodIdx += readUleb128(buf, p);
            int accessFlags = readUleb128(buf, p);
            int codeOff = co[0] = readUleb128(buf, p);
            if (codeOff == 0) continue;
            int insnsSize = readLe32(buf, codeOff + 12);
            if (codeOff + 16 <= opcodeOff && opcodeOff <= codeOff + 16 + insnsSize * 2) {
                if (verify && !verifyOpcodeOffset(buf, codeOff + 16, insnsSize * 2, opcodeOff)) {
                    return null;
                }
                String clz = readType(buf, classIdx);
                int pMethodId = methodIdsOff + 8 * methodIdx;
                String name = readString(buf, readLe32(buf, pMethodId + 4));
                String sig = readProto(buf, readLe16(buf, pMethodId + 2));
                return new DexMethodDescriptor(clz, name, sig);
            }
        }
        methodIdx = 0;
        for (int mn = 0; mn < virtualMethodsSize; mn++) {
            methodIdx += readUleb128(buf, p);
            int accessFlags = readUleb128(buf, p);
            int codeOff = co[0] = readUleb128(buf, p);
            if (codeOff == 0) continue;
            int insnsSize = readLe32(buf, codeOff + 12);
            if (codeOff + 16 <= opcodeOff && opcodeOff <= codeOff + 16 + insnsSize * 2) {
                if (verify && !verifyOpcodeOffset(buf, codeOff + 16, insnsSize * 2, opcodeOff)) {
                    return null;
                }
                String clz = readType(buf, classIdx);
                int pMethodId = methodIdsOff + 8 * methodIdx;
                String name = readString(buf, readLe32(buf, pMethodId + 4));
                String sig = readProto(buf, readLe16(buf, pMethodId + 2));
                return new DexMethodDescriptor(clz, name, sig);
            }
        }
    }
    return null;
}","/**
 * @param buf       the byte array containing the whole dex file
 * @param opcodeOff offset relative to {@code buf}
 * @param verify    whether to verify if the {@code opcodeOff} is aligned to opcode,
 *                  return {@code null} if the offset failed the verification
 * @return
 */
@Nullable
public static DexMethodDescriptor getDexMethodByOpOffset(byte[] buf, int opcodeOff, boolean verify) 
{
    if (verify && (opcodeOff & 0x1) != 0)
    {
        return null;
    }

    int offset = opcodeOff >> 1;
    int protoIdx = buf[offset] & 0xFF;
    int nameIdx = Util.readUShort(buf, offset + 1);
    int classIdx = Util.readUShort(buf, offset + 3);

    return new DexMethodDescriptor(protoIdx, nameIdx, classIdx);
}   ",55,True
"/**
 * Send a broadcast meaning a file was changed
 *
 * @param file FILE_*
 * @param uin  0 for a common file
 * @param what 0 for unspecified
 */
public static void onFileChanged(int file, long uin, int what){
    Context ctx = getApplication();
    Intent changed = new Intent(SYNC_FILE_CHANGED);
    changed.setPackage(ctx.getPackageName());
    initId();
    changed.putExtra(""id"", myId);
    changed.putExtra(""file"", file);
    changed.putExtra(""uin"", uin);
    changed.putExtra(""what"", what);
    ctx.sendBroadcast(changed);
    //log(""Tx: file changed "" + file);
}","/**
 * Send a broadcast meaning a file was changed
 *
 * @param file FILE_*
 * @param uin  0 for a common file
 * @param what 0 for unspecified
 */
public static void onFileChanged(int file, long uin, int what) 
{
    if (file == FILE_COMMON)
    {
        if (uin == 0)
        {
            if (what == 0)
            {
                // Common file changed
                // Do something
            }
        }
    }
}   ",57,False
"//    public static int getUid() {
//        try {
//            return Libcore.os.getuid();
//        } catch (Throwable e) {
//            return android.os.Process.myUid();
//        }
//    }
public static void initId(){
        if (myId == 0) {
            myId = (int) ((Math.random()) * (Integer.MAX_VALUE / 4));
        }
    }","//    public static int getUid() {
//        try {
//            return Libcore.os.getuid();
//        } catch (Throwable e) {
//            return android.os.Process.myUid();
//        }
//    }
public static void initId() 
{
    if (id == null)
    {
        id = UUID.randomUUID().toString();
    }
}   ",58,True
"/**
 * Set the new color
 *
 * @param color The newly selected color
 */
public void saveValue(@ColorInt int color){
    this.color = color;
    persistInt(this.color);
    notifyChanged();
    callChangeListener(color);
}","/**
 * Set the new color
 *
 * @param color The newly selected color
 */
public void saveValue(@ColorInt int color) 
{
    this.color = color;
    if (mListener != null)
    {
        mListener.onColorSelected(color);
    }
}   ",59,True
"/**
 * Select the Accept header's value from the given accepts array:
 *   if JSON exists in the given array, use it;
 *   otherwise use all of them (joining into a string)
 *
 * @param accepts The accepts array to select from
 * @return The Accept header to use. If the given array is empty,
 *   null will be returned (not to set the Accept header explicitly).
 */
public String selectHeaderAccept(String[] accepts){
  if (accepts.length == 0) {
    return null;
  }
  for (String accept : accepts) {
    if (isJsonMime(accept)) {
      return accept;
    }
  }
  return StringUtil.join(accepts, "","");
}","/**
 * Select the Accept header's value from the given accepts array:
 *   if JSON exists in the given array, use it;
 *   otherwise use all of them (joining into a string)
 *
 * @param accepts The accepts array to select from
 * @return The Accept header to use. If the given array is empty,
 *   null will be returned (not to set the Accept header explicitly).
 */
public String selectHeaderAccept(String[] accepts) 
{
    if (accepts.length == 0)
    {
        return null;
    }

    for (String accept : accepts)
    {
        if (""application/json"".equals(accept))
        {
            return ""application/json"";
        }
    }

    return StringUtils.join(accepts, "","");
}   ",64,True
"/**
 * Download file from the given response.
 * @param response Response
 * @return File
 * @throws ApiException If fail to read file content from response and write to disk
 */
public File downloadFileFromResponse(Response response) throws ApiException{
  try {
    File file = prepareDownloadFile(response);
    Files.copy(response.readEntity(InputStream.class), file.toPath(), StandardCopyOption.REPLACE_EXISTING);
    return file;
  } catch (IOException e) {
    throw new ApiException(e);
  }
}","/**
 * Download file from the given response.
 * @param response Response
 * @return File
 * @throws ApiException If fail to read file content from response and write to disk
 */


public File downloadFileFromResponse(Response response) throws ApiException 
{
    String contentType = response.headers().get(""Content-Type"").get(0);
    String disposition = response.headers().get(""Content-Disposition"").get(0);
    String fileName = getFileNameFromDispositionHeader(disposition);
    File file = new File(System.getProperty(""java.io.tmpdir""), fileName);
    BufferedSink sink = Okio.buffer(Okio.sink(file));
    try {
        sink.writeAll(response.body().source());
        sink.flush();
    } catch (IOException e) {
        throw new ApiException(e);
    }
    return file;
}   ",68,False
"/**
 * Set the date format used to parse/format date parameters.
 * @param dateFormat Date format
 * @return API client
 */
public ApiClient setDateFormat(DateFormat dateFormat){
  this.dateFormat = dateFormat;
  // also set the date format for model (de)serialization with Date properties
  this.json.setDateFormat((DateFormat) dateFormat.clone());
  return this;
}","/**
 * Set the date format used to parse/format date parameters.
 * @param dateFormat Date format
 * @return API client
 */
public ApiClient setDateFormat(DateFormat dateFormat) 
{
    this.dateFormat = dateFormat;
    return this;
}   ",71,False
"/*
 * Format to {@code Pair} objects.
 * @param collectionFormat Collection format
 * @param name Name
 * @param value Value
 * @return List of pairs
 */
public List<Pair> parameterToPairs(String collectionFormat, String name, Object value){
  List<Pair> params = new ArrayList<Pair>();

  // preconditions
  if (name == null || name.isEmpty() || value == null) return params;

  Collection valueCollection;
  if (value instanceof Collection) {
    valueCollection = (Collection) value;
  } else {
    params.add(new Pair(name, parameterToString(value)));
    return params;
  }

  if (valueCollection.isEmpty()){
    return params;
  }

  // get the collection format (default: csv)
  String format = (collectionFormat == null || collectionFormat.isEmpty() ? ""csv"" : collectionFormat);

  // create the params based on the collection format
  if (""multi"".equals(format)) {
    for (Object item : valueCollection) {
      params.add(new Pair(name, parameterToString(item)));
    }

    return params;
  }

  String delimiter = "","";

  if (""csv"".equals(format)) {
    delimiter = "","";
  } else if (""ssv"".equals(format)) {
    delimiter = "" "";
  } else if (""tsv"".equals(format)) {
    delimiter = ""\t"";
  } else if (""pipes"".equals(format)) {
    delimiter = ""|"";
  }

  StringBuilder sb = new StringBuilder() ;
  for (Object item : valueCollection) {
    sb.append(delimiter);
    sb.append(parameterToString(item));
  }

  params.add(new Pair(name, sb.substring(1)));

  return params;
}","/*
 * Format to {@code Pair} objects.
 * @param collectionFormat Collection format
 * @param name Name
 * @param value Value
 * @return List of pairs
 */

public List<Pair> parameterToPairs(String collectionFormat, String name, Object value) 
{
    List<Pair> params = new ArrayList<>();

    // If the value is a collection, handle each element separately
    if (value instanceof Collection) {
        Collection<?> valueCollection = (Collection<?>) value;
        for (Object item : valueCollection) {
            params.add(new Pair(name, parameterToString(collectionFormat, null, item)));
        }
        return params;
    }

    // Otherwise, treat the value as a single element
    params.add(new Pair(name, parameterToString(collectionFormat, null, value)));
    return params;
}   ",72,False
"/**
 * Set the User-Agent header's value (by adding to the default header map).
 * @param userAgent Http user agent
 * @return API client
 */
public ApiClient setUserAgent(String userAgent){
  addDefaultHeader(""User-Agent"", userAgent);
  return this;
}","/**
 * Set the User-Agent header's value (by adding to the default header map).
 * @param userAgent Http user agent
 * @return API client
 */
public ApiClient setUserAgent(String userAgent) 
{
    addDefaultHeader(""User-Agent"", userAgent);
    return this;
}   ",77,True
"/**
 * Deserialize response body to Java object according to the Content-Type.
 * @param <T> Type
 * @param response Response
 * @param returnType Return type
 * @return Deserialize object
 * @throws ApiException API exception
 */
@SuppressWarnings(""unchecked"")
public <T> T deserialize(Response response, GenericType<T> returnType) throws ApiException{
  if (response == null || returnType == null) {
    return null;
  }

  if (""byte[]"".equals(returnType.toString())) {
    // Handle binary response (byte array).
    return (T) response.readEntity(byte[].class);
  } else if (returnType.getRawType() == File.class) {
    // Handle file downloading.
    T file = (T) downloadFileFromResponse(response);
    return file;
  }

  String contentType = null;
  List<Object> contentTypes = response.getHeaders().get(""Content-Type"");
  if (contentTypes != null && !contentTypes.isEmpty())
    contentType = String.valueOf(contentTypes.get(0));

  return response.readEntity(returnType);
}","/**
 * Deserialize response body to Java object according to the Content-Type.
 * @param <T> Type
 * @param response Response
 * @param returnType Return type
 * @return Deserialize object
 * @throws ApiException API exception
 */
@SuppressWarnings(""unchecked"")
public <T> T deserialize(Response response, GenericType<T> returnType) throws ApiException 
{
    if (response == null || returnType == null) {
        return null;
    }

    if (""application/json"".equalsIgnoreCase(response.getContentType())) {
        return (T) gson.fromJson(response.getBody(), returnType.getType());
    } else if (""application/xml"".equalsIgnoreCase(response.getContentType())) {
        return (T) xmlMapper.readValue(response.getBody(), returnType.getType());
    } else {
        throw new ApiException(500, ""unknown content type: "" + response.getContentType());
    }
}   ",78,False
"/**
 * Format the given parameter object into string.
 * @param param Object
 * @return Object in string format
 */
public String parameterToString(Object param){
  if (param == null) {
    return """";
  } else if (param instanceof Date) {
    return formatDate((Date) param);
  } else if (param instanceof Collection) {
    StringBuilder b = new StringBuilder();
    for(Object o : (Collection)param) {
      if(b.length() > 0) {
        b.append(',');
      }
      b.append(String.valueOf(o));
    }
    return b.toString();
  } else {
    return String.valueOf(param);
  }
}","/**
 * Format the given parameter object into string.
 * @param param Object
 * @return Object in string format
 */
public String parameterToString(Object param) 
{
    if (param == null)
    {
        return ""null"";
    }
    else if (param instanceof Date)
    {
        return String.valueOf(((Date) param).getTime());
    }
    else
    {
        return String.valueOf(param);
    }
}   ",79,True
"/**
 * GLOB pattern supports *, ** and ? wild cards.
 * Leading and trailing ** have special meaning, consecutive separator become optional.
 */
protected static String wildCardTranslate(String pattern){
    String separator = ""."";
    StringBuffer sb = new StringBuffer();
    String es = escape(separator);
    // special starter
    Matcher ss = Pattern.compile(""^([*][*]["" + es + ""]).*"").matcher(pattern);
    if (ss.matches()) {
        pattern = pattern.substring(ss.group(1).length());
        // make leading sep optional
        sb.append(""(.*["" + es + ""])?"");
    }
    // special trailer
    Matcher st = Pattern.compile("".*(["" + es + ""][*][*])$"").matcher(pattern);
    boolean useSt = false;
    if (st.matches()) {
        pattern = pattern.substring(0, st.start(1));
        useSt = true;
    }

    for(int i = 0; i != pattern.length(); ++i) {
        char c = pattern.charAt(i);
        if (c == '?') {
            sb.append(""[^"" + es + ""]"");
        }
        else if (c == '*') {
            if (i + 1 < pattern.length() && pattern.charAt(i+1) == '*') {
                i++;
                // **
                sb.append("".*"");
            }
            else {
                sb.append(""[^"" + es + ""]*"");
            }
        }
        else {
            if (c == '$') {
                sb.append(""\\$"");
            }
            else if (Character.isJavaIdentifierPart(c) || Character.isWhitespace(c)) {
                sb.append(c);
            }
            else {
                sb.append('\\').append(c);
            }
        }
    }

    if (useSt) {
        sb.append(""(["" + es + ""].*)?"");
    }

    return sb.toString();
}","/**
 * GLOB pattern supports *, ** and ? wild cards.
 * Leading and trailing ** have special meaning, consecutive separator become optional.
 */
protected static String wildCardTranslate(String pattern) 
{
    StringBuilder sb = new StringBuilder();
    char[] chars = pattern.toCharArray();
    char lastChar = 0;
    for (char c : chars)
    {
        if (c == '*' && lastChar == '*')
        {
            continue;
        }
        else if (c == '?' || c == '*' || c == ',')
        {
            sb.append('.');
        }
        else if (c == '**')
        {
            if (lastChar == '*')
            {
                sb.append("".*"");
            }
            else
            {
                sb.append(""[^/]*"");
            }
        }
        else
        {
            sb.append(c);
        }
        lastChar = c;
    }
    return sb.toString();
}   ",80,True
"/**
 * Method called after an object field has been output, but
 * before the value is output.
 *<p>
 * Default handling (without pretty-printing) will output a single
 * colon to separate the two. Pretty-printer is
 * to output a colon as well, but can surround that with other
 * (white-space) decoration.
 */
@Override
public void writeObjectFieldValueSeparator(JsonGenerator jg)
    throws IOException, JsonGenerationException{
    if (_spacesInObjectEntries) {
        jg.writeRaw("" : "");
    } else {
        jg.writeRaw(':');
    }
}","/**
 * Method called after an object field has been output, but
 * before the value is output.
 *<p>
 * Default handling (without pretty-printing) will output a single
 * colon to separate the two. Pretty-printer is
 * to output a colon as well, but can surround that with other
 * (white-space) decoration.
 */
@Override
public void writeObjectFieldValueSeparator(JsonGenerator jg)
    throws IOException, JsonGenerationException 
{
    jg.writeRaw(':');
    if (_spacesInObjectEntries) {
        jg.writeRaw("" "");
    }
}   ",81,True
"/**
 * Method called after an array value has been completely
 * output, and before another value is to be output.
 *<p>
 * Default handling (without pretty-printing) will output a single
 * comma to separate the two. Pretty-printer is
 * to output a comma as well, but can surround that with other
 * (white-space) decoration.
 */
@Override
public void writeArrayValueSeparator(JsonGenerator jg)
    throws IOException, JsonGenerationException{
    jg.writeRaw(',');
    _arrayIndenter.writeIndentation(jg, _nesting);
}","/**
 * Method called after an array value has been completely
 * output, and before another value is to be output.
 *<p>
 * Default handling (without pretty-printing) will output a single
 * comma to separate the two. Pretty-printer is
 * to output a comma as well, but can surround that with other
 * (white-space) decoration.
 */
@Override
public void writeArrayValueSeparator(JsonGenerator jg)
    throws IOException, JsonGenerationException 
{
    jg.writeRaw(',');
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeArrayValueSeparator(jg);
    }
}   ",82,True
"/*
/**********************************************************
/* Life-cycle
/**********************************************************
 */
protected JsonWriteContext(int type, JsonWriteContext parent){
    super();
    _type = type;
    _parent = parent;
    _index = -1;
}","/*
/**********************************************************
/* Life-cycle
/**********************************************************
 */
protected JsonWriteContext(int type, JsonWriteContext parent) 
{
    _type = type;
    _parent = parent;
    _lineNr = parent._lineNr;
    _columnNr = parent._columnNr;
}   ",85,True
"/**
 * Helper method that can be used to get a copy of standard JSON
 * escape definitions; this is useful when just wanting to slightly
 * customize definitions. Caller can modify this array as it sees
 * fit and usually returns modified instance via {@link #getEscapeCodesForAscii}
 */
public static int[] standardAsciiEscapesForJSON(){
    int[] esc = CharTypes.get7BitOutputEscapes();
    int len = esc.length;
    int[] result = new int[len];
    System.arraycopy(esc, 0, result, 0, esc.length);
    return result;
}","/**
 * Helper method that can be used to get a copy of standard JSON
 * escape definitions; this is useful when just wanting to slightly
 * customize definitions. Caller can modify this array as it sees
 * fit and usually returns modified instance via {@link #getEscapeCodesForAscii}
 */
public static int[] standardAsciiEscapesForJSON() 
{
    int[] esc = standardAsciiEscapes;
    return Arrays.copyOf(esc, esc.length);
}   ",88,True
"// // // Internally used abstract methods
protected final void appendDesc(StringBuilder sb){
    if (_type == TYPE_OBJECT) {
        sb.append('{');
        if (_currentName != null) {
            sb.append('""');
            // !!! TODO: Name chars should be escaped?
            sb.append(_currentName);
            sb.append('""');
        } else {
            sb.append('?');
        }
        sb.append('}');
    } else if (_type == TYPE_ARRAY) {
        sb.append('[');
        sb.append(getCurrentIndex());
        sb.append(']');
    } else {
        // nah, ROOT:
        sb.append(""/"");
    }
}","// // // Internally used abstract methods
protected final void appendDesc(StringBuilder sb) 
{
    if (mType != null)
    {
        sb.append('(');
        sb.append(mType);
        sb.append(')');
    }
}   ",89,True
"// special hack to workaround Java module system
private void breakCage(String... args){
    if (""false"".equalsIgnoreCase(System.getProperty(""sjk.breakCage"", ""true""))) {
        // do not break
        return;
    }
    RuntimeMXBean rtBean = ManagementFactory.getRuntimeMXBean();
    String spec = rtBean.getSpecVersion();
    if (spec.startsWith(""1."")) {
        // good classic Java
        if (verbose) {
            System.err.println(""Java version "" + spec + "" skipping cage break"");
        }
        return;
    }
    else {
        if (getModulesUnlockCommand().length > 0) {
            // we need to unlock some modules
            StringBuilder sb = new StringBuilder();
            for(String a: rtBean.getInputArguments()) {
                if (sb.length() > 0) {
                    sb.append("" "");
                }
                sb.append(a);
            }
            if (isUnlocked(sb.toString())) {
                // modules are unlocked
                if (verbose) {
                    System.err.println(""All required modules are unlocked, skipping cage break"");
                }
                return;
            }
            else {
                // break cage
                List<String> command = new ArrayList<String>();
                File jhome = new File(System.getProperty(""java.home""));
                File jbin = new File(jhome, ""bin/java"");
                command.add(jbin.getPath());
                for(String m: getModulesUnlockCommand()) {
                    command.add(""--add-opens"");
                    command.add(m);
                }
                command.add(""-Dsjk.breakCage=false"");
                command.add(""-cp"");
                command.add(rtBean.getClassPath());
                command.addAll(rtBean.getInputArguments());
                command.add(this.getClass().getName());
                command.addAll(Arrays.asList(args));

                System.err.println(""Restarting java with unlocked package access"");
                if (verbose) {
                    System.err.println(""Exec command: "" + formatCmd(command));
                }

                ProcessSpawner.start(command);
            }
        }
    }
}","// special hack to workaround Java module system
private void breakCage(String... args) 
{
    if (args.length == 0)
    {
        System.out.println(""No arguments provided"");
        return;
    }

    System.out.println(""Arguments:"");
    for (String arg : args)
    {
        System.out.println(arg);
    }
}   ",93,False
"/**
 * Optimize conjunction into single frame matcher where possible.
 */
private StackFrameMatcher produceConjunctionMatcher(Op node){
    List<String> pattern = new ArrayList<String>();
    while(node.toc == TokenType.COMMA && node.right.toc == TokenType.PATTERN) {
        pattern.add(refinePattern(node.right.body));
        node = node.left;
    }

    if (pattern.isEmpty()) {
        return filterFactory.matcherConjunction(produceMatcher(node), produceMatcher(node.right));
    }
    else {
        if (node.toc == TokenType.PATTERN) {
            pattern.add(refinePattern(node.body));
            node = null;
        }
        StackFrameMatcher f = filterFactory.patternFrameMatcher(pattern);
        return node == null ? f : filterFactory.matcherConjunction(f, produceMatcher(node));
    }
}","/**
 * Optimize conjunction into single frame matcher where possible.
 */
private StackFrameMatcher produceConjunctionMatcher(Op node) 
{
    StackFrameMatcher leftMatcher = produceMatcher(node.getLeft());
    StackFrameMatcher rightMatcher = produceMatcher(node.getRight());

    if (leftMatcher != null && rightMatcher != null)
    {
        return new ConjunctionMatcher(leftMatcher, rightMatcher);
    }
    else
    {
        return null;
    }
}   ",94,True
"/**
 * Overridden to provide developer writeable ""JsonPath"" representation
 * of the context.
 */
@Override
public final String toString(){
    StringBuilder sb = new StringBuilder(64);
    appendDesc(sb);
    return sb.toString();
}","/**
 * Overridden to provide developer writeable ""JsonPath"" representation
 * of the context.
 */
@Override
public final String toString() 
{
    return JsonPathUtils.convertToJsonPath(this);
}   ",99,True
"/**
 * Sets this Controller's {@link RetainViewMode}, which will influence when its view will be released.
 * This is useful when a Controller's view hierarchy is expensive to tear down and rebuild.
 */
public void setRetainViewMode(@NonNull RetainViewMode retainViewMode){
    this.retainViewMode = retainViewMode != null ? retainViewMode : RetainViewMode.RELEASE_DETACH;
    if (this.retainViewMode == RetainViewMode.RELEASE_DETACH && !attached) {
        removeViewReference();
    }
}","/**
 * Sets this Controller's {@link RetainViewMode}, which will influence when its view will be released.
 * This is useful when a Controller's view hierarchy is expensive to tear down and rebuild.
 */
public void setRetainViewMode(@NonNull RetainViewMode retainViewMode) 
{
    if (retainViewMode == null)
    {
        throw new IllegalArgumentException(""retainViewMode cannot be null"");
    }

    this.retainViewMode = retainViewMode;
}   ",102,True
"/**
 * Retrieves the child {@link Router} for the given container/tag combination. Note that multiple
 * routers should not exist in the same container unless a lot of care is taken to maintain order
 * between them. Avoid using the same container unless you have a great reason to do so (ex: ViewPagers).
 * The only time this method will return {@code null} is when the child router does not exist prior
 * to calling this method and the createIfNeeded parameter is set to false.
 *
 * @param container      The ViewGroup that hosts the child Router
 * @param tag            The router's tag or {@code null} if none is needed
 * @param createIfNeeded If true, a router will be created if one does not yet exist. Else {@code null} will be returned in this case.
 */
@Nullable
public final Router getChildRouter(@NonNull ViewGroup container, @Nullable String tag, boolean createIfNeeded){
    @IdRes final int containerId = container.getId();
    if (containerId == View.NO_ID) {
        throw new IllegalStateException(""You must set an id on your container."");
    }

    ControllerHostedRouter childRouter = null;
    for (ControllerHostedRouter router : childRouters) {
        if (router.getHostId() == containerId && TextUtils.equals(tag, router.getTag())) {
            childRouter = router;
            break;
        }
    }

    if (childRouter == null) {
        if (createIfNeeded) {
            childRouter = new ControllerHostedRouter(container.getId(), tag);
            childRouter.setHostContainer(this, container);
            childRouters.add(childRouter);

            if (isPerformingExitTransition) {
                childRouter.setDetachFrozen(true);
            }
        }
    } else if (!childRouter.hasHost()) {
        childRouter.setHostContainer(this, container);
        childRouter.rebindIfNeeded();
    }

    return childRouter;
}","/**
 * Retrieves the child {@link Router} for the given container/tag combination. Note that multiple
 * routers should not exist in the same container unless a lot of care is taken to maintain order
 * between them. Avoid using the same container unless you have a great reason to do so (ex: ViewPagers).
 * The only time this method will return {@code null} is when the child router does not exist prior
 * to calling this method and the createIfNeeded parameter is set to false.
 *
 * @param container      The ViewGroup that hosts the child Router
 * @param tag            The router's tag or {@code null} if none is needed
 * @param createIfNeeded If true, a router will be created if one does not yet exist. Else {@code null} will be returned in this case.
 */
@Nullable
public final Router getChildRouter(@NonNull ViewGroup container, @Nullable String tag, boolean createIfNeeded) 
{
    if (tag == null)
    {
        tag = """";
    }

    Router router = getChildRouter(container, tag);
    if (router == null && createIfNeeded)
    {
        router = createChildRouter(container, tag);
    }

    return router;
}   ",103,True
"/**
 * Returns the Application Context derived from the host Activity or {@code null} if this Controller
 * has not yet been attached to an Activity or if the Activity has been destroyed.
 */
@Nullable
public final Context getApplicationContext(){
    Activity activity = getActivity();
    return activity != null ? activity.getApplicationContext() : null;
}","/**
 * Returns the Application Context derived from the host Activity or {@code null} if this Controller
 * has not yet been attached to an Activity or if the Activity has been destroyed.
 */


@Nullable
public final Context getApplicationContext() 
{
    Activity activity = getActivity();
    return activity == null ? null : activity.getApplicationContext();
}   ",105,True
"/**
 * Optional target for this Controller. One reason this could be used is to send results back to the Controller
 * that started this one. Target Controllers are retained across instances. It is recommended
 * that Controllers enforce that their target Controller conform to a specific Interface.
 *
 * @param target The Controller that is the target of this one.
 */
public void setTargetController(@Nullable Controller target){
    if (targetInstanceId != null) {
        throw new RuntimeException(""Target controller already set. A controller's target may only be set once."");
    }

    targetInstanceId = target != null ? target.getInstanceId() : null;
}","/**
 * Optional target for this Controller. One reason this could be used is to send results back to the Controller
 * that started this one. Target Controllers are retained across instances. It is recommended
 * that Controllers enforce that their target Controller conform to a specific Interface.
 *
 * @param target The Controller that is the target of this one.
 */
public void setTargetController(@Nullable Controller target) 
{
    if (target != null)
    {
        this.target = target;
    }
}   ",106,True
"/**
 * Sets whether or not this controller's menu items should be visible. This is useful for hiding the
 * controller's options menu items when its UI is hidden, and not just when it is detached from the
 * window (the default).
 *
 * @param optionsMenuHidden Defaults to false. If true, this controller's menu items will not be shown.
 */
public final void setOptionsMenuHidden(boolean optionsMenuHidden){
    boolean invalidate = attached && hasOptionsMenu && this.optionsMenuHidden != optionsMenuHidden;

    this.optionsMenuHidden = optionsMenuHidden;

    if (invalidate) {
        router.invalidateOptionsMenu();
    }
}","/**
 * Sets whether or not this controller's menu items should be visible. This is useful for hiding the
 * controller's options menu items when its UI is hidden, and not just when it is detached from the
 * window (the default).
 *
 * @param optionsMenuHidden Defaults to false. If true, this controller's menu items will not be shown.
 */
public final void setOptionsMenuHidden(boolean optionsMenuHidden) 
{
    if (mOptionsMenuHidden != optionsMenuHidden)
    {
        mOptionsMenuHidden = optionsMenuHidden;
        onOptionsMenuHiddenChanged();
    }
}   ",107,True
"/**
 * Constructor that takes arguments that need to be retained across restarts.
 *
 * @param args Any arguments that need to be retained.
 */
protected Controller(@Nullable Bundle args){
    this.args = args != null ? args : new Bundle(getClass().getClassLoader());
    instanceId = UUID.randomUUID().toString();
    ensureRequiredConstructor();
}","/**
 * Constructor that takes arguments that need to be retained across restarts.
 *
 * @param args Any arguments that need to be retained.
 */
protected Controller(@Nullable Bundle args) 
{
    this.args = args;
}   ",109,True
"/**
 * Returns the target Controller that was set with the {@link #setTargetController(Controller)}
 * method or {@code null} if this Controller has no target.
 *
 * @return This Controller's target
 */
@Nullable
public final Controller getTargetController(){
    if (targetInstanceId != null) {
        return router.getRootRouter().getControllerWithInstanceId(targetInstanceId);
    }
    return null;
}","/**
 * Returns the target Controller that was set with the {@link #setTargetController(Controller)}
 * method or {@code null} if this Controller has no target.
 *
 * @return This Controller's target
 */
@Nullable
public final Controller getTargetController() 
{
    return this.targetController;
}   ",110,True
"/**
 * Calls startActivity(Intent) from this Controller's host Activity.
 */
public final void startActivity(@NonNull final Intent intent){
    executeWithRouter(new RouterRequiringFunc() {
        @Override
        public void execute() {
            router.startActivity(intent);
        }
    });
}","/**
 * Calls startActivity(Intent) from this Controller's host Activity.
 */

public final void startActivity(@NonNull final Intent intent) 
{
    final Activity activity = this.activityWeakReference.get();
    if (activity != null)
    {
        activity.startActivity(intent);
    }
}   ",112,True
"/**
 * Registers this Controller to handle onActivityResult responses. Calling this method is NOT
 * necessary when calling {@link #startActivityForResult(Intent, int)}
 *
 * @param requestCode The request code being registered for.
 */
public final void registerForActivityResult(final int requestCode){
    executeWithRouter(new RouterRequiringFunc() {
        @Override
        public void execute() {
            router.registerForActivityResult(instanceId, requestCode);
        }
    });
}","/**
 * Registers this Controller to handle onActivityResult responses. Calling this method is NOT
 * necessary when calling {@link #startActivityForResult(Intent, int)}
 *
 * @param requestCode The request code being registered for.
 */
public final void registerForActivityResult(final int requestCode) 
{
    if (this.activityResultCallbacks == null)
    {
        this.activityResultCallbacks = new SparseArrayCompat<ActivityResultCallback>();
    }

    this.activityResultCallbacks.put(requestCode, null);
}   ",113,False
"/**
 * Calls startActivityForResult(Intent, int, Bundle) from this Controller's host Activity.
 */
public final void startActivityForResult(@NonNull final Intent intent, final int requestCode, @Nullable final Bundle options){
    executeWithRouter(new RouterRequiringFunc() {
        @Override
        public void execute() {
            router.startActivityForResult(instanceId, intent, requestCode, options);
        }
    });
}","/**
 * Calls startActivityForResult(Intent, int, Bundle) from this Controller's host Activity.
 */

public final void startActivityForResult(@NonNull final Intent intent, final int requestCode, @Nullable final Bundle options) 
{
    final Activity activity = this.getHost();
    if (activity != null)
    {
        activity.startActivityForResult(intent, requestCode, options);
    }
}   ",114,True
"/**
 * Registers/unregisters for participation in populating the options menu by receiving options-related
 * callbacks, such as {@link #onCreateOptionsMenu(Menu, MenuInflater)}
 *
 * @param hasOptionsMenu If true, this controller's options menu callbacks will be called.
 */
public final void setHasOptionsMenu(boolean hasOptionsMenu){
    boolean invalidate = attached && !optionsMenuHidden && this.hasOptionsMenu != hasOptionsMenu;

    this.hasOptionsMenu = hasOptionsMenu;

    if (invalidate) {
        router.invalidateOptionsMenu();
    }
}","/**
 * Registers/unregisters for participation in populating the options menu by receiving options-related
 * callbacks, such as {@link #onCreateOptionsMenu(Menu, MenuInflater)}
 *
 * @param hasOptionsMenu If true, this controller's options menu callbacks will be called.
 */
public final void setHasOptionsMenu(boolean hasOptionsMenu) 
{
    if (mHasOptionsMenu != hasOptionsMenu)
    {
        mHasOptionsMenu = hasOptionsMenu;
        if (mHost != null)
        {
            mHost.onMenuVisibilityChanged(hasOptionsMenu);
        }
    }
}   ",115,True
"/**
 * Should be overridden if this Controller needs to handle the back button being pressed.
 *
 * @return True if this Controller has consumed the back button press, otherwise false
 */
public boolean handleBack(){
    List<RouterTransaction> childTransactions = new ArrayList<>();

    for (ControllerHostedRouter childRouter : childRouters) {
        childTransactions.addAll(childRouter.getBackstack());
    }

    Collections.sort(childTransactions, new Comparator<RouterTransaction>() {
        @Override
        public int compare(RouterTransaction o1, RouterTransaction o2) {
            return o2.getTransactionIndex() - o1.getTransactionIndex();
        }
    });

    for (RouterTransaction transaction : childTransactions) {
        Controller childController = transaction.controller();

        if (childController.isAttached() && childController.getRouter().handleBack()) {
            return true;
        }
    }

    return false;
}","/**
 * Should be overridden if this Controller needs to handle the back button being pressed.
 *
 * @return True if this Controller has consumed the back button press, otherwise false
 */
public boolean handleBack() 
{
    return false;
}   ",117,False
"/**
 * Gets a formatted, human readable file size String
 *
 * @param size long, the size of the file in bytes
 * @return String a formatted, human readable file size
 */
public static String getHumanReadableSize(long size){
    if (size <= 0) {
        return ""0"";
    }
    final String[] units = new String[] { ""B"", ""KB"", ""MB"", ""GB"", ""TB"" };
    int digitGroups = (int) (Math.log10(size) / Math.log10(1024));
    return new DecimalFormat(""#,##0.#"").format(size / Math.pow(1024, digitGroups)) + "" "" + units[digitGroups];
}","/**
 * Gets a formatted, human readable file size String
 *
 * @param size long, the size of the file in bytes
 * @return String a formatted, human readable file size
 */
public static String getHumanReadableSize(long size) 
{
    final String[] units = new String[] { ""B"", ""KB"", ""MB"", ""GB"", ""TB"" };
    int index = 0;
    double fileSize = size;
    while (fileSize >= 1024 && index < units.length - 1)
    {
        fileSize /= 1024;
        index++;
    }
    return String.format(""%.2f %s"", fileSize, units[index]);
}   ",126,True
"/**
 * Recursively delete a File
 *
 * @param fileOrDirectory the file or directory to delete
 * @return true id the deletion was successful
 */
private static boolean DeleteRecursive(File fileOrDirectory){
    if (fileOrDirectory == null) {
        return false;
    } else if (fileOrDirectory.isDirectory()) {
        File[] fileList = fileOrDirectory.listFiles();
        if (fileList != null) {
            for (File child : fileList)
                DeleteRecursive(child);
        }
    }
    return fileOrDirectory.delete();
}","/**
 * Recursively delete a File
 *
 * @param fileOrDirectory the file or directory to delete
 * @return true id the deletion was successful
 */
private static boolean DeleteRecursive(File fileOrDirectory) 
{
    if (fileOrDirectory.isDirectory())
    {
        for (File child : fileOrDirectory.listFiles())
        {
            DeleteRecursive(child);
        }
    }

    return fileOrDirectory.delete();
}   ",127,True
"/**
 * Returns the name of a string, excluding the extension
 *
 * @param name the name (path) of the file
 * @return the name of the file, excluding the extension
 */
public static String getName(String name){
    String ext = getExtension(name);
    if (ext == null) {
        return name;
    }
    return name.substring(0, name.length() - ext.length() - 1);
}","/**
 * Returns the name of a string, excluding the extension
 *
 * @param name the name (path) of the file
 * @return the name of the file, excluding the extension
 */
public static String getName(String name) 
{
    int index = name.lastIndexOf('.');
    if (index == -1)
    {
        return name;
    }
    return name.substring(0, index);
}   ",128,True
"/**
 * An {@link FileFilter} which only accepts directories & supported audio filetypes, based on extension
 */
public static FileFilter getAudioFilter(){
    return file -> {
        if (!file.isHidden() && file.canRead()) {
            if (file.isDirectory()) {
                return true;
            } else {
                String ext = getExtension(file.getName());
                for (String allowedExtension : sExtensions) {
                    if (!TextUtils.isEmpty(ext)) {
                        if (allowedExtension.equalsIgnoreCase(ext)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
}","/**
 * An {@link FileFilter} which only accepts directories & supported audio filetypes, based on extension
 */
public static FileFilter getAudioFilter() 
{
    return new FileFilter()
    {
        @Override
        public boolean accept(File f)
        {
            if (f.isDirectory())
            {
                return true;
            }
            String extension = getExtension(f);
            if (extension != null)
            {
                return isAudioFiletype(extension);
            }
            return false;
        }

        @Override
        public String getDescription()
        {
            return ""Audio files"";
        }
    };
}   ",134,False
"/** 打开通知栏消息*/
@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
private void newHongBaoNotification(Notification notification){
    isReceivingHongbao = true;
    //以下是精华，将微信的通知栏消息打开
    PendingIntent pendingIntent = notification.contentIntent;
    boolean lock = NotifyHelper.isLockScreen(getContext());

    if(!lock) {
        NotifyHelper.send(pendingIntent);
    } else {
        NotifyHelper.showNotify(getContext(), String.valueOf(notification.tickerText), pendingIntent);
    }

    if(lock || getConfig().getWechatMode() != Config.WX_MODE_0) {
        NotifyHelper.playEffect(getContext(), getConfig());
    }
}","/** 打开通知栏消息*/

@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
private void newHongBaoNotification(Notification notification) 
{
    try
    {
        Field field = notification.getClass().getDeclaredField(""extraNotification"");
        Object extraNotification = field.get(notification);
        Method method = extraNotification.getClass().getDeclaredMethod(""setAutoCancel"", boolean.class);
        method.invoke(extraNotification, true);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",141,False
"/** 打开辅助服务的设置*/
private void openAccessibilityServiceSettings(){
    try {
        Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);
        startActivity(intent);
        Toast.makeText(this, R.string.tips, Toast.LENGTH_LONG).show();
    } catch (Exception e) {
        e.printStackTrace();
    }
}","/** 打开辅助服务的设置*/



private void openAccessibilityServiceSettings() 
{
    try
    {
        Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);
        startActivity(intent);
        Toast.makeText(this, ""打开����服务的设置"", Toast.LENGTH_SHORT).show();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",143,True
"/** 更新微信包信息*/
private void updatePackageInfo(){
    try {
        mWechatPackageInfo = getContext().getPackageManager().getPackageInfo(WECHAT_PACKAGENAME, 0);
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
}","/** 更新微信包信息*/
private void updatePackageInfo() 
{
    if (mPackageInfo == null)
    {
        mPackageInfo = new PackageInfo();
    }
    mPackageInfo.appName = getString(R.string.app_name);
    mPackageInfo.packageName = getPackageName();
    mPackageInfo.versionName = getVersionName();
    mPackageInfo.versionCode = getVersionCode();
    mPackageInfo.targetSdkVersion = Build.VERSION.SDK_INT;
}   ",145,False
"/** 获取抢微信红包的模式*/
public int getWechatMode(){
    int defaultValue = 0;
    String result = preferences.getString(KEY_WECHAT_MODE, String.valueOf(defaultValue));
    try {
        return Integer.parseInt(result);
    } catch (Exception e) {}
    return defaultValue;
}","/** 获取抢微信红包的模式*/
public int getWechatMode() 
{
    if (this.getWechatMode == null)
    {
        return 0;
    }
    return this.getWechatMode;
}   ",146,True
"/** 显示捐赠的对话框*/
private void showDonateDialog(){
    final Dialog dialog = new Dialog(this, R.style.QR_Dialog_Theme);
    View view = getLayoutInflater().inflate(R.layout.donate_dialog_layout, null);
    view.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            dialog.dismiss();
        }
    });
    view.setOnLongClickListener(new View.OnLongClickListener() {

        @Override
        public boolean onLongClick(View v) {
            File output = new File(android.os.Environment.getExternalStorageDirectory(), ""codeboy_wechatpay_qr.jpg"");
            if(!output.exists()) {
                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.wechatpay_qr);
                BitmapUtils.saveBitmap(MainActivity.this, output, bitmap);
            }
            Toast.makeText(MainActivity.this, ""已保存到:"" + output.getAbsolutePath(), Toast.LENGTH_LONG).show();
            return true;
        }
    });
    dialog.setContentView(view);
    dialog.show();
}","/** 显示捐赠的对话框*/


private void showDonateDialog() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(""����"");
    builder.setMessage(""如果这个项目对你有用，请��作者���������表示�������！"");
    builder.setPositiveButton(""支付��"", new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            Uri uri = Uri.parse(""alipayqr://platformapi/startapp?saId=XXXXXXXX&qrcode=https%3A%2F%2Fqr.alipay.com%2Ftsx04129w8jzjgqgjzjxh46"");
            Intent intent = new Intent(Intent.ACTION_VIEW, uri);
            startActivity(intent);
        }
    });
    builder.setNegativeButton(""取消"", null);
    builder.show();
}   ",147,False
"/** 是否为锁屏或黑屏状态*/
public static boolean isLockScreen(Context context){
    KeyguardManager km = getKeyguardManager(context);

    return km.inKeyguardRestrictedInputMode() || !isScreenOn(context);
}","/** 是否为锁屏或黑屏状态*/

public static boolean isLockScreen(Context context) 
{
    KeyguardManager km = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
    return km.inKeyguardRestrictedInputMode();
}   ",148,True
"/** 微信打开红包后的事件*/
public int getWechatAfterOpenHongBaoEvent(){
    int defaultValue = 0;
    String result =  preferences.getString(KEY_WECHAT_AFTER_OPEN_HONGBAO, String.valueOf(defaultValue));
    try {
        return Integer.parseInt(result);
    } catch (Exception e) {}
    return defaultValue;
}","/** 微信打开红包后的事件*/
public int getWechatAfterOpenHongBaoEvent() 
{
    if (mWechatAfterOpenHongBaoEvent == 0)
    {
        mWechatAfterOpenHongBaoEvent = 1;
    }
    return mWechatAfterOpenHongBaoEvent;
}   ",149,True
"/** 打开通知栏设置*/
@TargetApi(Build.VERSION_CODES.LOLLIPOP_MR1)
private void openNotificationServiceSettings(){
    try {
        Intent intent = new Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);
        startActivity(intent);
        Toast.makeText(this, R.string.tips, Toast.LENGTH_LONG).show();
    } catch (Exception e) {
        e.printStackTrace();
    }
}","/** 打开通知栏设置*/

@TargetApi(Build.VERSION_CODES.LOLLIPOP_MR1)
private void openNotificationServiceSettings() 
{
    Intent intent = new Intent();
    intent.setAction(""android.settings.APP_NOTIFICATION_SETTINGS"");
    intent.putExtra(""app_package"", getPackageName());
    intent.putExtra(""app_uid"", getApplicationInfo().uid);
    startActivity(intent);
}   ",151,True
"/** 获取微信的版本*/
private int getWechatVersion(){
    if(mWechatPackageInfo == null) {
        return 0;
    }
    return mWechatPackageInfo.versionCode;
}","/** 获取微信的版本*/





private int getWechatVersion() 
{
    PackageManager packageManager = context.getPackageManager();
    List<PackageInfo> packageInfoList = packageManager.getInstalledPackages(0);
    for (PackageInfo packageInfo : packageInfoList)
    {
        if (packageInfo.packageName.equals(""com.tencent.mm""))
        {
            return packageInfo.versionCode;
        }
    }
    return 0;
}   ",155,True
"/**
 * 点击聊天里的红包后，显示的界面
 * */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
private void handleLuckyMoneyReceive(){
    AccessibilityNodeInfo nodeInfo = getService().getRootInActiveWindow();
    if(nodeInfo == null) {
        Log.w(TAG, ""rootWindow为空"");
        return;
    }

    AccessibilityNodeInfo targetNode = null;

    int event = getConfig().getWechatAfterOpenHongBaoEvent();
    int wechatVersion = getWechatVersion();
    if(event == Config.WX_AFTER_OPEN_HONGBAO) { //拆红包
        if (wechatVersion < USE_ID_MIN_VERSION) {
            targetNode = AccessibilityHelper.findNodeInfosByText(nodeInfo, ""拆红包"");
        } else {
            String buttonId = ""com.tencent.mm:id/b43"";

            if(wechatVersion == 700) {
                buttonId = ""com.tencent.mm:id/b2c"";
            }

            if(buttonId != null) {
                targetNode = AccessibilityHelper.findNodeInfosById(nodeInfo, buttonId);
            }

            if(targetNode == null) {
                //分别对应固定金额的红包 拼手气红包
                AccessibilityNodeInfo textNode = AccessibilityHelper.findNodeInfosByTexts(nodeInfo, ""发了一个红包"", ""给你发了一个红包"", ""发了一个红包，金额随机"");

                if(textNode != null) {
                    for (int i = 0; i < textNode.getChildCount(); i++) {
                        AccessibilityNodeInfo node = textNode.getChild(i);
                        if (BUTTON_CLASS_NAME.equals(node.getClassName())) {
                            targetNode = node;
                            break;
                        }
                    }
                }
            }

            if(targetNode == null) { //通过组件查找
                targetNode = AccessibilityHelper.findNodeInfosByClassName(nodeInfo, BUTTON_CLASS_NAME);
            }
        }
    } else if(event == Config.WX_AFTER_OPEN_SEE) { //看一看
        if(getWechatVersion() < USE_ID_MIN_VERSION) { //低版本才有 看大家手气的功能
            targetNode = AccessibilityHelper.findNodeInfosByText(nodeInfo, ""看看大家的手气"");
        }
    } else if(event == Config.WX_AFTER_OPEN_NONE) {
        return;
    }

    if(targetNode != null) {
        final AccessibilityNodeInfo n = targetNode;
        long sDelayTime = getConfig().getWechatOpenDelayTime();
        if(sDelayTime != 0) {
            getHandler().postDelayed(new Runnable() {
                @Override
                public void run() {
                    AccessibilityHelper.performClick(n);
                }
            }, sDelayTime);
        } else {
            AccessibilityHelper.performClick(n);
        }
        if(event == Config.WX_AFTER_OPEN_HONGBAO) {
            QHBApplication.eventStatistics(getContext(), ""open_hongbao"");
        } else {
            QHBApplication.eventStatistics(getContext(), ""open_see"");
        }
    }
}","/**
 * 点击聊天里的红包后，显示的界面
 * */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
private void handleLuckyMoneyReceive() 
{
    if (mLuckyMoneyReceiveDialog == null)
    {
        mLuckyMoneyReceiveDialog = new LuckyMoneyReceiveDialog(getActivity());
        mLuckyMoneyReceiveDialog.setOnDismissListener(new DialogInterface.OnDismissListener()
        {
            @Override
            public void onDismiss(DialogInterface dialog)
            {
                mLuckyMoneyReceiveDialog = null;
            }
        });
    }
    mLuckyMoneyReceiveDialog.show();
}   ",158,False
"/**
 * Marshaled name for compatibility with repository.
 * @return get JSON name either specified or default.
 */
public String getMarshaledName(){
  String serializedName = getSerializedName();
  if (!serializedName.isEmpty()) {
    return serializedName;
  }
  return names.raw;
}","/**
 * Marshaled name for compatibility with repository.
 * @return get JSON name either specified or default.
 */
public String getMarshaledName() 
{
    if (this.marshaledName != null)
    {
        return this.marshaledName;
    }
    else
    {
        return this.getDefaultName();
    }
}   ",165,True
"/**
 * {@code $set} functionality but on a non-scalar Object
 */
@Test
public void setListNonScalar() throws Exception{
  String id = ""i1"";
  ImmutableItem item = ImmutableItem.builder().id(id).addList(""l1"").addTags(ImmutableTag.of(""t1"")).build();

  check(repository.upsert(item).getUnchecked()).is(1);

  repository.update(repository.criteria().id(id))
      .setTags(Collections.<Item.Tag>emptyList())
      .updateFirst()
      .getUnchecked();

  check(findById(id).tags()).isEmpty();

  Set<Item.Tag> set1 = Collections.<Item.Tag>singleton(ImmutableTag.of(""t2""));
  repository.update(repository.criteria().id(id))
      .setTags(set1)
      .updateFirst()
      .getUnchecked();

  check(findById(id).tags()).hasAll(set1);

  List<? extends Item.Tag> set2 = Arrays.asList(ImmutableTag.of(""t3""), ImmutableTag.of(""t4""));

  repository.update(repository.criteria().id(id))
      .setTags(set2)
      .updateFirst()
      .getUnchecked();

  check(findById(id).tags()).hasAll(set2);
}","/**
 * {@code $set} functionality but on a non-scalar Object
 */
@Test
public void setListNonScalar() throws Exception 
{
    final String path = ""/set/list/non-scalar"";
    final String value = ""value"";
    final String value2 = ""value2"";

    final ObjectNode node = this.initJsonNode();
    node.putArray(path).add(value).add(value2);

    this.updateAndCheck(node, path, value2);
}   ",167,False
"/**
 * Gson library reads numbers lazily when using generic
 * {@link com.google.gson.internal.bind.TypeAdapters#JSON_ELEMENT} type adapter.
 * Number is read as string and then wrapped inside {@link LazilyParsedNumber}. This inefficiency
 * should only occur if reading numbers with generic JSON element API
 * and not using generated type adapters.
 * @see LazilyParsedNumber
 * @see com.google.gson.internal.bind.TypeAdapters#JSON_ELEMENT
 */
private String scalarToString(){
  final BsonType type = delegate.getCurrentBsonType();
  switch (type) {
  case STRING:
    return delegate.readString();
  case SYMBOL:
    return delegate.readSymbol();
  case INT32:
    return Integer.toString(delegate.readInt32());
  case INT64:
    return Long.toString(delegate.readInt64());
  case DOUBLE:
    return Double.toString(delegate.readDouble());
  case DECIMAL128:
    return delegate.readDecimal128().toString();
  case REGULAR_EXPRESSION:
    return delegate.readRegularExpression().getPattern();
  case OBJECT_ID:
    return delegate.readObjectId().toHexString();
  default:
    throw new IllegalStateException(""Unknown scalar type to be converted to string: "" + type);
  }
}","/**
 * Gson library reads numbers lazily when using generic
 * {@link com.google.gson.internal.bind.TypeAdapters#JSON_ELEMENT} type adapter.
 * Number is read as string and then wrapped inside {@link LazilyParsedNumber}. This inefficiency
 * should only occur if reading numbers with generic JSON element API
 * and not using generated type adapters.
 * @see LazilyParsedNumber
 * @see com.google.gson.internal.bind.TypeAdapters#JSON_ELEMENT
 */
private String scalarToString() 
{
    if (value instanceof LazilyParsedNumber) {
        return ((LazilyParsedNumber) value).value;
    } else {
        return value.toString();
    }
}   ",169,True
"/**
 * Performs several json read / writes in binary format
 */
private void compare(String json) throws IOException{
  jacksonThenBson(json);
  bsonThenJackson(json);
  jacksonThenJackson(json);
}","/**
 * Performs several json read / writes in binary format
 */









private void compare(String json) throws IOException 
{
    // write json to binary
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(json);
    oos.flush();
    byte[] binary = baos.toByteArray();

    // read binary back to json
    ByteArrayInputStream bais = new ByteArrayInputStream(binary);
    ObjectInputStream ois = new ObjectInputStream(bais);
    Object o = ois.readObject();

    Assert.assertEquals(json, o);
}   ",170,True
"/**
 * Return list of path members starting with root (excluded) to current element (included).
 * For root path returns empty list.
 */
public List<Member> members(){
  ImmutableList.Builder<Member> parents = ImmutableList.builder();
  Path current = this;
  while (!current.isRoot()) {
    parents.add((Member) current.element());
    current = current.parent;
  }
  return parents.build().reverse();
}","/**
 * Return list of path members starting with root (excluded) to current element (included).
 * For root path returns empty list.
 */


public List<Member> members() 
{
    if (parent == null)
    {
        return Collections.emptyList();
    }
    List<Member> members = parent.members();
    members.add(this);
    return members;
}   ",172,True
"/**
 * Checks {@code $push} functionality of repository
 */
@Test
public void addToList() throws Exception{
  String id = ""i1"";
  ImmutableItem item = ImmutableItem.builder().id(id).addList(""l1"").build();

  check(repository.upsert(item).getUnchecked()).is(1);

  push(id, Collections.singleton(""l2""));
  check(findById(id).list()).hasAll(""l1"", ""l2"");

  push(id, Arrays.asList(""l3"", ""l4""));
  check(findById(id).list()).hasAll(""l1"", ""l2"", ""l3"", ""l4"");
}","/**
 * Checks {@code $push} functionality of repository
 */
@Test
public void addToList() throws Exception 
{
    final String id = ""1"";
    final String name = ""name"";
    final String value = ""value"";

    final TestObject to = new TestObject(id, name, value);

    final TestObject result = repository.save(to);

    Assert.assertNotNull(result);
    Assert.assertEquals(id, result.getId());
    Assert.assertEquals(name, result.getName());
    Assert.assertEquals(value, result.getValue());

    final TestObject found = repository.findById(id).get();

    Assert.assertNotNull(found);
    Assert.assertEquals(id, found.getId());
    Assert.assertEquals(name, found.getName());
    Assert.assertEquals(value, found.getValue());
}   ",173,False
"/**
 * Criteria templates are always generated as top-level class (separate file).
 * Construct criteria name from {@linkplain TypeMirror}
 *
 * @return fully qualified criteria (template) class name
 */
private static String topLevelCriteriaClassName(TypeMirror type){
  DeclaredType declaredType = MoreTypes.asDeclared(type);
  Element element = declaredType.asElement();
  do {
    element = element.getEnclosingElement();
  } while (element.getKind() != ElementKind.PACKAGE);

  String packagePrefix = """";
  if (!element.getSimpleName().contentEquals("""")) {
    packagePrefix = MoreElements.asPackage(element).getQualifiedName() + ""."";
  }

  // package name + type name + ""CriteriaTemplate""
  return packagePrefix + declaredType.asElement().getSimpleName().toString() + ""CriteriaTemplate"";
}","/**
 * Criteria templates are always generated as top-level class (separate file).
 * Construct criteria name from {@linkplain TypeMirror}
 *
 * @return fully qualified criteria (template) class name
 */
private static String topLevelCriteriaClassName(TypeMirror type) 
{
    String className = type.toString();
    int lastDot = className.lastIndexOf('.');
    return className.substring(lastDot + 1) + ""Criteria"";
}   ",174,True
"/**
 * Create new instance of path with {@code member} appended
 */
public Path append(Member member){
  Objects.requireNonNull(member, ""member"");
  Preconditions.checkArgument(member instanceof AnnotatedElement, ""Expected %s to implement %s"", member.getClass(), AnnotatedElement.class);
  return new Path(this, (AnnotatedElement) member);
}","/**
 * Create new instance of path with {@code member} appended
 */


public Path append(Member member) 
{
    List<Member> members = new ArrayList<>(this.members);
    members.add(member);
    return new Path(members);
}   ",176,True
"/**
 * Create repository using lambda for customization
 */
private PersonRepository createRepository(Function<GeodeSetup.Builder, GeodeSetup.Builder> fn){
  RegionResolver resolver = new LocalResolver(RegionResolver.defaultResolver(cache));
  GeodeSetup.Builder setup = fn.apply(GeodeSetup.builder().regionResolver(resolver));
  AutocreateRegion autocreate = new AutocreateRegion(cache);
  Backend backend = WithSessionCallback.wrap(new GeodeBackend(setup.build()), autocreate);
  return new PersonRepository(backend);
}","/**
 * Create repository using lambda for customization
 */
private PersonRepository createRepository(Function<GeodeSetup.Builder, GeodeSetup.Builder> fn) 
{
    GeodeSetup.Builder builder = new GeodeSetup.Builder();
    builder = fn.apply(builder);
    return new PersonRepository(builder.build());
}   ",177,True
"/**
 * persist empty Optional of Date
 */
@Test
public void nullDate(){
  final Jackson expected = ImmutableJackson.builder()
          .id(ObjectId.get())
          .prop1(""prop11"")
          .prop2(""prop22"")
          .build();

  repository.insert(expected).getUnchecked();

  final Jackson actual = repository.findAll()
          .fetchAll().getUnchecked().get(0);

  check(expected.date().asSet()).isEmpty();
  check(expected).is(actual);
  final BsonDocument doc = collection.find().first();
  check(doc.keySet()).hasContentInAnyOrder(""_id"", ""prop1"", ""prop2"", ""date"", ""uuid"");
  check(doc.get(""date"")).is(BsonNull.VALUE);
}","/**
 * persist empty Optional of Date
 */





@Test
public void nullDate() 
{
    Optional<Date> nullDate = Optional.ofNullable(null);
    entityManager.persist(nullDate);
}   ",178,False
"/**
 * Close statement
 *
 * @param statement the statement to be closed or null
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> close(Statement statement) throws SQLException{
    if (statement != null) {
        statement.close();
    }
    return this;
}","/**
 * Close statement
 *
 * @param statement the statement to be closed or null
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> close(Statement statement) throws SQLException 
{
    if (statement != null)
    {
        statement.close();
    }
    return this;
}   ",180,True
"/**
 * Close read connection
 */
@Override
public StandardSource<C> closeReading(){
    try {
        if (readConnection != null && !readConnection.isClosed()) {
            // always commit before close to finish cursors/transactions
            if (!readConnection.getAutoCommit()) {
                readConnection.commit();
            }
            readConnection.close();
        }
    } catch (SQLException e) {
        logger.warn(""while closing read connection: "" + e.getMessage());
    }
    return this;
}","/**
 * Close read connection
 */

@Override
public StandardSource<C> closeReading() 
{
    if (this.reader != null)
    {
        try
        {
            this.reader.close();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
    }
    return this;
}   ",182,False
"/**
 * Prepare an update statement
 *
 * @param sql the SQL statement
 * @return a prepared statement
 * @throws SQLException when SQL execution gives an error
 */
@Override
public PreparedStatement prepareUpdate(String sql) throws SQLException{
    Connection connection = getConnectionForWriting();
    if (connection == null) {
        throw new SQLException(""can't connect to source "" + url);
    }
    return connection.prepareStatement(sql);
}","/**
 * Prepare an update statement
 *
 * @param sql the SQL statement
 * @return a prepared statement
 * @throws SQLException when SQL execution gives an error
 */
@Override
public PreparedStatement prepareUpdate(String sql) throws SQLException 
{
    return prepareStatement(sql);
}   ",184,True
"/**
 * Prepare a query statement
 *
 * @param sql the SQL statement
 * @return a prepared statement
 * @throws SQLException when SQL execution gives an error
 */
@Override
public PreparedStatement prepareQuery(String sql) throws SQLException{
    Connection connection = getConnectionForReading();
    if (connection == null) {
        throw new SQLException(""can't connect to source "" + url);
    }
    logger.debug(""preparing statement with SQL {}"", sql);
    int type = ""TYPE_FORWARD_ONLY"".equals(getResultSetType()) ?
            ResultSet.TYPE_FORWARD_ONLY : ""TYPE_SCROLL_SENSITIVE"".equals(getResultSetType()) ?
            ResultSet.TYPE_SCROLL_SENSITIVE : ""TYPE_SCROLL_INSENSITIVE"".equals(getResultSetType()) ?
            ResultSet.TYPE_SCROLL_INSENSITIVE : ResultSet.TYPE_FORWARD_ONLY;
    int concurrency = ""CONCUR_READ_ONLY"".equals(getResultSetConcurrency()) ?
            ResultSet.CONCUR_READ_ONLY : ResultSet.CONCUR_UPDATABLE;
    return connection.prepareStatement(sql, type, concurrency);
}","/**
 * Prepare a query statement
 *
 * @param sql the SQL statement
 * @return a prepared statement
 * @throws SQLException when SQL execution gives an error
 */
@Override
public PreparedStatement prepareQuery(String sql) throws SQLException 
{
    PreparedStatement statement = connection.prepareStatement(sql);
    return statement;
}   ",186,True
"/**
 * Fetch, issue SQL statements.
 *
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public void fetch() throws SQLException, IOException{
    logger.debug(""fetching, {} SQL commands"", getStatements().size());
    DateTime dateTime = new DateTime();
    try {
        for (SQLCommand command : getStatements()) {
            try {
                if (command.isCallable()) {
                    logger.debug(""{} executing callable SQL: {}"", this, command);
                    executeCallable(command);
                } else if (!command.getParameters().isEmpty()) {
                    logger.debug(""{} executing SQL with params: {}"", this, command);
                    executeWithParameter(command);
                } else {
                    logger.debug(""{} executing SQL without params: {}"", this, command);
                    execute(command);
                }
                if (sourceMetric != null) {
                    sourceMetric.getSucceeded().inc();
                    sourceMetric.setLastExecutionStart(dateTime);
                    sourceMetric.setLastExecutionEnd(new DateTime());
                }
            } catch (SQLRecoverableException e) {
                long millis = getMaxRetryWait().getMillis();
                logger.warn(""retrying after "" + millis / 1000 + "" seconds, got exception "", e);
                Thread.sleep(getMaxRetryWait().getMillis());
                if (command.isCallable()) {
                    logger.debug(""retrying, executing callable SQL: {}"", command);
                    executeCallable(command);
                } else if (!command.getParameters().isEmpty()) {
                    logger.debug(""retrying, executing SQL with params: {}"", command);
                    executeWithParameter(command);
                } else {
                    logger.debug(""retrying, executing SQL without params: {}"", command);
                    execute(command);
                }
                if (sourceMetric != null) {
                    sourceMetric.getSucceeded().inc();
                    sourceMetric.setLastExecutionStart(dateTime);
                    sourceMetric.setLastExecutionEnd(new DateTime());
                }
            }
        }
    } catch (Exception e) {
        if (sourceMetric != null) {
            sourceMetric.getFailed().inc();
            sourceMetric.setLastExecutionStart(dateTime);
            sourceMetric.setLastExecutionEnd(new DateTime());
        }
        throw new IOException(e);
    } finally {
        if (sourceMetric != null) {
            sourceMetric.incCounter();
        }
    }
}","/**
 * Fetch, issue SQL statements.
 *
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public void fetch() throws SQLException, IOException 
{
    if (this.statement != null)
    {
        this.statement.close();
    }
    this.statement = this.connection.createStatement();
    this.resultSet = this.statement.executeQuery(this.sql);
}   ",189,False
"/**
 * Execute SQL query command with parameter binding.
 *
 * @param command the SQL command
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
private void executeWithParameter(SQLCommand command) throws Exception{
    PreparedStatement statement = null;
    ResultSet results = null;
    try {
        if (command.isQuery()) {
            statement = prepareQuery(command.getSQL());
            bind(statement, command.getParameters());
            logger.info(""execute sql is {} "", statement.toString());
            results = executeQuery(statement);
            SinkKeyValueStreamListener<Object, Object> listener = new SinkKeyValueStreamListener<Object, Object>()
                    .output(context.getSink())
                    .shouldIgnoreNull(shouldIgnoreNull())
                    .shouldDetectGeo(shouldDetectGeo())
                    .shouldDetectJson(shouldDetectJson());
            merge(command, results, listener);
        } else {
            statement = prepareUpdate(command.getSQL());
            bind(statement, command.getParameters());
            executeUpdate(statement);
        }
    } finally {
        close(results);
        close(statement);
    }
}","/**
 * Execute SQL query command with parameter binding.
 *
 * @param command the SQL command
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */


private void executeWithParameter(SQLCommand command) throws Exception 
{
    try (PreparedStatement statement = connection.prepareStatement(command.getQuery()))
    {
        for (int i = 0; i < command.getParameters().size(); i++)
        {
            statement.setObject(i + 1, command.getParameters().get(i));
        }
        statement.execute();
    }
}   ",191,True
"/**
 * Parse of value of result set
 *
 * @param result the result set
 * @param i      the offset in the result set
 * @param type   the JDBC type
 * @param locale the locale to use for parsing
 * @return The parse value
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public Object parseType(ResultSet result, Integer i, int type, Locale locale)
        throws SQLException, IOException, ParseException{
    logger.trace(""i={} type={}"", i, type);
    switch (type) {
        /**
         * The JDBC types CHAR, VARCHAR, and LONGVARCHAR are closely
         * related. CHAR represents a small, fixed-length character string,
         * VARCHAR represents a small, variable-length character string, and
         * LONGVARCHAR represents a large, variable-length character string.
         */
        case Types.CHAR:
        case Types.VARCHAR:
        case Types.LONGVARCHAR: {
            return result.getString(i);
        }
        case Types.NCHAR:
        case Types.NVARCHAR:
        case Types.LONGNVARCHAR: {
            return result.getNString(i);
        }
        /**
         * The JDBC types BINARY, VARBINARY, and LONGVARBINARY are closely
         * related. BINARY represents a small, fixed-length binary value,
         * VARBINARY represents a small, variable-length binary value, and
         * LONGVARBINARY represents a large, variable-length binary value
         */
        case Types.BINARY:
        case Types.VARBINARY:
        case Types.LONGVARBINARY: {
            byte[] b = result.getBytes(i);
            return shouldTreatBinaryAsString() ? (b != null ? new String(b) : null) : b;
        }
        /**
         * The JDBC type ARRAY represents the SQL3 type ARRAY.
         *
         * An ARRAY value is mapped to an instance of the Array interface in
         * the Java programming language. If a driver follows the standard
         * implementation, an Array object logically points to an ARRAY
         * value on the server rather than containing the elements of the
         * ARRAY object, which can greatly increase efficiency. The Array
         * interface contains methods for materializing the elements of the
         * ARRAY object on the client in the form of either an array or a
         * ResultSet object.
         */
        case Types.ARRAY: {
            Array arr = result.getArray(i);
            return arr == null ? null : arr.getArray();
        }
        /**
         * The JDBC type BIGINT represents a 64-bit signed integer value
         * between -9223372036854775808 and 9223372036854775807.
         *
         * The corresponding SQL type BIGINT is a nonstandard extension to
         * SQL. In practice the SQL BIGINT type is not yet currently
         * implemented by any of the major databases, and we recommend that
         * its use be avoided in code that is intended to be portable.
         *
         * The recommended Java mapping for the BIGINT type is as a Java
         * long.
         */
        case Types.BIGINT: {
            Object o = result.getLong(i);
            return result.wasNull() ? null : o;
        }
        /**
         * The JDBC type BIT represents a single bit value that can be zero
         * or one.
         *
         * SQL-92 defines an SQL BIT type. However, unlike the JDBC BIT
         * type, this SQL-92 BIT type can be used as a parameterized type to
         * define a fixed-length binary string. Fortunately, SQL-92 also
         * permits the use of the simple non-parameterized BIT type to
         * represent a single binary digit, and this usage corresponds to
         * the JDBC BIT type. Unfortunately, the SQL-92 BIT type is only
         * required in ""full"" SQL-92 and is currently supported by only a
         * subset of the major databases. Portable code may therefore prefer
         * to use the JDBC SMALLINT type, which is widely supported.
         */
        case Types.BIT: {
            try {
                Object o = result.getInt(i);
                return result.wasNull() ? null : o;
            } catch (Exception e) {
                String exceptionClassName = e.getClass().getName();
                // postgresql can not handle boolean, it will throw PSQLException, something like ""Bad value for type int : t""
                if (""org.postgresql.util.PSQLException"".equals(exceptionClassName)) {
                    return ""t"".equals(result.getString(i));
                }
                throw new IOException(e);
            }
        }
        /**
         * The JDBC type BOOLEAN, which is new in the JDBC 3.0 API, maps to
         * a boolean in the Java programming language. It provides a
         * representation of true and false, and therefore is a better match
         * than the JDBC type BIT, which is either 1 or 0.
         */
        case Types.BOOLEAN: {
            return result.getBoolean(i);
        }
        /**
         * The JDBC type BLOB represents an SQL3 BLOB (Binary Large Object).
         *
         * A JDBC BLOB value is mapped to an instance of the Blob interface
         * in the Java programming language. If a driver follows the
         * standard implementation, a Blob object logically points to the
         * BLOB value on the server rather than containing its binary data,
         * greatly improving efficiency. The Blob interface provides methods
         * for materializing the BLOB data on the client when that is
         * desired.
         */
        case Types.BLOB: {
            Blob blob = result.getBlob(i);
            if (blob != null) {
                long n = blob.length();
                if (n > Integer.MAX_VALUE) {
                    throw new IOException(""can't process blob larger than Integer.MAX_VALUE"");
                }
                byte[] tab = blob.getBytes(1, (int) n);
                blob.free();
                return tab;
            }
            break;
        }
        /**
         * The JDBC type CLOB represents the SQL3 type CLOB (Character Large
         * Object).
         *
         * A JDBC CLOB value is mapped to an instance of the Clob interface
         * in the Java programming language. If a driver follows the
         * standard implementation, a Clob object logically points to the
         * CLOB value on the server rather than containing its character
         * data, greatly improving efficiency. Two of the methods on the
         * Clob interface materialize the data of a CLOB object on the
         * client.
         */
        case Types.CLOB: {
            Clob clob = result.getClob(i);
            if (clob != null) {
                long n = clob.length();
                if (n > Integer.MAX_VALUE) {
                    throw new IOException(""can't process clob larger than Integer.MAX_VALUE"");
                }
                String str = clob.getSubString(1, (int) n);
                clob.free();
                return str;
            }
            break;
        }
        case Types.NCLOB: {
            NClob nclob = result.getNClob(i);
            if (nclob != null) {
                long n = nclob.length();
                if (n > Integer.MAX_VALUE) {
                    throw new IOException(""can't process nclob larger than Integer.MAX_VALUE"");
                }
                String str = nclob.getSubString(1, (int) n);
                nclob.free();
                return str;
            }
            break;
        }
        /**
         * The JDBC type DATALINK, new in the JDBC 3.0 API, is a column
         * value that references a file that is outside of a data source but
         * is managed by the data source. It maps to the Java type
         * java.net.URL and provides a way to manage external files. For
         * instance, if the data source is a DBMS, the concurrency controls
         * it enforces on its own data can be applied to the external file
         * as well.
         *
         * A DATALINK value is retrieved from a ResultSet object with the
         * ResultSet methods getURL or getObject. If the Java platform does
         * not support the type of URL returned by getURL or getObject, a
         * DATALINK value can be retrieved as a String object with the
         * method getString.
         *
         * java.net.URL values are stored in a database using the method
         * setURL. If the Java platform does not support the type of URL
         * being set, the method setString can be used instead.
         *
         *
         */
        case Types.DATALINK: {
            return result.getURL(i);
        }
        /**
         * The JDBC DATE type represents a date consisting of day, month,
         * and year. The corresponding SQL DATE type is defined in SQL-92,
         * but it is implemented by only a subset of the major databases.
         * Some databases offer alternative SQL types that support similar
         * semantics.
         */
        case Types.DATE: {
            try {
                Date d = result.getDate(i, calendar);
                return d != null ? formatDate(d.getTime()) : null;
            } catch (SQLException e) {
                return null;
            }
        }
        case Types.TIME: {
            try {
                Time t = result.getTime(i, calendar);
                return t != null ? formatDate(t.getTime()) : null;
            } catch (SQLException e) {
                return null;
            }
        }
        case Types.TIMESTAMP: {
            try {
                Timestamp t = result.getTimestamp(i, calendar);
                return t != null ? formatDate(t.getTime()) : null;
            } catch (SQLException e) {
                // java.sql.SQLException: Cannot convert value '0000-00-00 00:00:00' from column ... to TIMESTAMP.
                return null;
            }
        }
        /**
         * The JDBC types DECIMAL and NUMERIC are very similar. They both
         * represent fixed-precision decimal values.
         *
         * The corresponding SQL types DECIMAL and NUMERIC are defined in
         * SQL-92 and are very widely implemented. These SQL types take
         * precision and scale parameters. The precision is the total number
         * of decimal digits supported, and the scale is the number of
         * decimal digits after the decimal point. For most DBMSs, the scale
         * is less than or equal to the precision. So for example, the value
         * ""12.345"" has a precision of 5 and a scale of 3, and the value
         * "".11"" has a precision of 2 and a scale of 2. JDBC requires that
         * all DECIMAL and NUMERIC types support both a precision and a
         * scale of at least 15.
         *
         * The sole distinction between DECIMAL and NUMERIC is that the
         * SQL-92 specification requires that NUMERIC types be represented
         * with exactly the specified precision, whereas for DECIMAL types,
         * it allows an implementation to add additional precision beyond
         * that specified when the type was created. Thus a column created
         * with type NUMERIC(12,4) will always be represented with exactly
         * 12 digits, whereas a column created with type DECIMAL(12,4) might
         * be represented by some larger number of digits.
         *
         * The recommended Java mapping for the DECIMAL and NUMERIC types is
         * java.math.BigDecimal. The java.math.BigDecimal type provides math
         * operations to allow BigDecimal types to be added, subtracted,
         * multiplied, and divided with other BigDecimal types, with integer
         * types, and with floating point types.
         *
         * The method recommended for retrieving DECIMAL and NUMERIC values
         * is ResultSet.getBigDecimal. JDBC also allows access to these SQL
         * types as simple Strings or arrays of char. Thus, Java programmers
         * can use getString to receive a DECIMAL or NUMERIC result.
         * However, this makes the common case where DECIMAL or NUMERIC are
         * used for currency values rather awkward, since it means that
         * application writers have to perform math on strings. It is also
         * possible to retrieve these SQL types as any of the Java numeric
         * types.
         */
        case Types.DECIMAL:
        case Types.NUMERIC: {
            BigDecimal bd = null;
            try {
                // getBigDecimal() should get obsolete. Most seem to use getString/getObject anyway...
                bd = result.getBigDecimal(i);
            } catch (NullPointerException e) {
                // But is it true? JDBC NPE exists since 13 years?
                // http://forums.codeguru.com/archive/index.php/t-32443.html
                // Null values are driving us nuts in JDBC:
                // http://stackoverflow.com/questions/2777214/when-accessing-resultsets-in-jdbc-is-there-an-elegant-way-to-distinguish-betwee
            }
            if (bd == null || result.wasNull()) {
                return null;
            }
            if (getScale() >= 0) {
                bd = bd.setScale(getScale(), getRounding());
                try {
                    long l = bd.longValueExact();
                    if (Long.toString(l).equals(result.getString(i))) {
                        // convert to long if possible
                        return l;
                    } else {
                        // convert to double (with precision loss)
                        return bd.doubleValue();
                    }
                } catch (ArithmeticException e) {
                    return bd.doubleValue();
                }
            } else {
                return bd.toPlainString();
            }
        }
        /**
         * The JDBC type DOUBLE represents a ""double precision"" floating
         * point number that supports 15 digits of mantissa.
         *
         * The corresponding SQL type is DOUBLE PRECISION, which is defined
         * in SQL-92 and is widely supported by the major databases. The
         * SQL-92 standard leaves the precision of DOUBLE PRECISION up to
         * the implementation, but in practice all the major databases
         * supporting DOUBLE PRECISION support a mantissa precision of at
         * least 15 digits.
         *
         * The recommended Java mapping for the DOUBLE type is as a Java
         * double.
         */
        case Types.DOUBLE: {
            String s = result.getString(i);
            if (result.wasNull() || s == null) {
                return null;
            }
            NumberFormat format = NumberFormat.getInstance(locale);
            Number number = format.parse(s);
            return number.doubleValue();
        }
        /**
         * The JDBC type FLOAT is basically equivalent to the JDBC type
         * DOUBLE. We provided both FLOAT and DOUBLE in a possibly misguided
         * attempt at consistency with previous database APIs. FLOAT
         * represents a ""double precision"" floating point number that
         * supports 15 digits of mantissa.
         *
         * The corresponding SQL type FLOAT is defined in SQL-92. The SQL-92
         * standard leaves the precision of FLOAT up to the implementation,
         * but in practice all the major databases supporting FLOAT support
         * a mantissa precision of at least 15 digits.
         *
         * The recommended Java mapping for the FLOAT type is as a Java
         * double. However, because of the potential confusion between the
         * double precision SQL FLOAT and the single precision Java float,
         * we recommend that JDBC programmers should normally use the JDBC
         * DOUBLE type in preference to FLOAT.
         */
        case Types.FLOAT: {
            String s = result.getString(i);
            if (result.wasNull() || s == null) {
                return null;
            }
            NumberFormat format = NumberFormat.getInstance(locale);
            Number number = format.parse(s);
            return number.doubleValue();
        }
        /**
         * The JDBC type JAVA_OBJECT, added in the JDBC 2.0 core API, makes
         * it easier to use objects in the Java programming language as
         * values in a database. JAVA_OBJECT is simply a type code for an
         * instance of a class defined in the Java programming language that
         * is stored as a database object. The type JAVA_OBJECT is used by a
         * database whose type system has been extended so that it can store
         * Java objects directly. The JAVA_OBJECT value may be stored as a
         * serialized Java object, or it may be stored in some
         * vendor-specific format.
         *
         * The type JAVA_OBJECT is one of the possible values for the column
         * DATA_TYPE in the ResultSet objects returned by various
         * DatabaseMetaData methods, including getTypeInfo, getColumns, and
         * getUDTs. The method getUDTs, part of the new JDBC 2.0 core API,
         * will return information about the Java objects contained in a
         * particular schema when it is given the appropriate parameters.
         * Having this information available facilitates using a Java class
         * as a database type.
         */
        case Types.OTHER:
        case Types.JAVA_OBJECT: {
            return result.getObject(i);
        }
        /**
         * The JDBC type REAL represents a ""single precision"" floating point
         * number that supports seven digits of mantissa.
         *
         * The corresponding SQL type REAL is defined in SQL-92 and is
         * widely, though not universally, supported by the major databases.
         * The SQL-92 standard leaves the precision of REAL up to the
         * implementation, but in practice all the major databases
         * supporting REAL support a mantissa precision of at least seven
         * digits.
         *
         * The recommended Java mapping for the REAL type is as a Java
         * float.
         */
        case Types.REAL: {
            String s = result.getString(i);
            if (result.wasNull() || s == null) {
                return null;
            }
            NumberFormat format = NumberFormat.getInstance(locale);
            Number number = format.parse(s);
            return number.doubleValue();
        }
        /**
         * The JDBC type TINYINT represents an 8-bit integer value between 0
         * and 255 that may be signed or unsigned.
         *
         * The corresponding SQL type, TINYINT, is currently supported by
         * only a subset of the major databases. Portable code may therefore
         * prefer to use the JDBC SMALLINT type, which is widely supported.
         *
         * The recommended Java mapping for the JDBC TINYINT type is as
         * either a Java byte or a Java short. The 8-bit Java byte type
         * represents a signed value from -128 to 127, so it may not always
         * be appropriate for larger TINYINT values, whereas the 16-bit Java
         * short will always be able to hold all TINYINT values.
         */
        /**
         * The JDBC type SMALLINT represents a 16-bit signed integer value
         * between -32768 and 32767.
         *
         * The corresponding SQL type, SMALLINT, is defined in SQL-92 and is
         * supported by all the major databases. The SQL-92 standard leaves
         * the precision of SMALLINT up to the implementation, but in
         * practice, all the major databases support at least 16 bits.
         *
         * The recommended Java mapping for the JDBC SMALLINT type is as a
         * Java short.
         */
        /**
         * The JDBC type INTEGER represents a 32-bit signed integer value
         * ranging between -2147483648 and 2147483647.
         *
         * The corresponding SQL type, INTEGER, is defined in SQL-92 and is
         * widely supported by all the major databases. The SQL-92 standard
         * leaves the precision of INTEGER up to the implementation, but in
         * practice all the major databases support at least 32 bits.
         *
         * The recommended Java mapping for the INTEGER type is as a Java
         * int.
         */
        case Types.TINYINT:
        case Types.SMALLINT:
        case Types.INTEGER: {
            try {
                Integer integer = result.getInt(i);
                return result.wasNull() ? null : integer;
            } catch (SQLDataException e) {
                Long l = result.getLong(i);
                return result.wasNull() ? null : l;
            }
        }

        case Types.SQLXML: {
            SQLXML xml = result.getSQLXML(i);
            return xml != null ? xml.getString() : null;
        }

        case Types.NULL: {
            return null;
        }
        /**
         * The JDBC type DISTINCT field (Types class)>DISTINCT represents
         * the SQL3 type DISTINCT.
         *
         * The standard mapping for a DISTINCT type is to the Java type to
         * which the base type of a DISTINCT object would be mapped. For
         * example, a DISTINCT type based on a CHAR would be mapped to a
         * String object, and a DISTINCT type based on an SQL INTEGER would
         * be mapped to an int.
         *
         * The DISTINCT type may optionally have a custom mapping to a class
         * in the Java programming language. A custom mapping consists of a
         * class that implements the interface SQLData and an entry in a
         * java.util.Map object.
         */
        case Types.DISTINCT: {
            logger.warn(""JDBC type not implemented: {}"", type);
            return null;
        }
        /**
         * The JDBC type STRUCT represents the SQL99 structured type. An SQL
         * structured type, which is defined by a user with a CREATE TYPE
         * statement, consists of one or more attributes. These attributes
         * may be any SQL data type, built-in or user-defined.
         *
         * The standard mapping for the SQL type STRUCT is to a Struct
         * object in the Java programming language. A Struct object contains
         * a value for each attribute of the STRUCT value it represents.
         *
         * A STRUCT value may optionally be custom mapped to a class in the
         * Java programming language, and each attribute in the STRUCT may
         * be mapped to a field in the class. A custom mapping consists of a
         * class that implements the interface SQLData and an entry in a
         * java.util.Map object.
         *
         *
         */
        case Types.STRUCT: {
            logger.warn(""JDBC type not implemented: {}"", type);
            return null;
        }
        case Types.REF: {
            logger.warn(""JDBC type not implemented: {}"", type);
            return null;
        }
        case Types.ROWID: {
            logger.warn(""JDBC type not implemented: {}"", type);
            return null;
        }
        default: {
            logger.warn(""unknown JDBC type ignored: {}"", type);
            return null;
        }
    }
    return null;
}","/**
 * Parse of value of result set
 *
 * @param result the result set
 * @param i      the offset in the result set
 * @param type   the JDBC type
 * @param locale the locale to use for parsing
 * @return The parse value
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public Object parseType(ResultSet result, Integer i, int type, Locale locale)
        throws SQLException, IOException, ParseException 
{
    Object value = result.getObject(i, type);
    if (value == null)
    {
        return null;
    }
    else
    {
        return value;
    }
}       ",192,False
"/**
 * Get JDBC connection for reading
 *
 * @return the connection
 * @throws SQLException when SQL execution gives an error
 */
@Override
public synchronized Connection getConnectionForReading() throws SQLException{
    boolean invalid = readConnection == null || readConnection.isClosed();
    try {
        invalid = invalid || !readConnection.isValid(5);
    } catch (AbstractMethodError e) {
        // old/buggy JDBC driver
        logger.debug(e.getMessage());
    } catch (SQLFeatureNotSupportedException e) {
        // postgresql does not support isValid()
        logger.debug(e.getMessage());
    }
    if (invalid) {
        int retries = getRetries();
        while (retries > 0) {
            retries--;
            try {
                if (user != null) {
                    Properties properties = new Properties();
                    properties.put(""user"", user);
                    if (password != null) {
                        properties.put(""password"", password);
                    }
                    if (getConnectionProperties() != null) {
                        properties.putAll(getConnectionProperties());
                    }
                    readConnection = DriverManager.getConnection(url, properties);
                } else {
                    readConnection = DriverManager.getConnection(url);
                }
                DatabaseMetaData metaData = readConnection.getMetaData();
                if (shouldPrepareDatabaseMetadata()) {
                    prepare(metaData);
                }
                if (metaData.getTimeDateFunctions().contains(""TIMESTAMPDIFF"")) {
                    setTimestampDiffSupported(true);
                }
                // ""readonly"" is required by MySQL for large result streaming
                readConnection.setReadOnly(true);
                // Postgresql cursor mode condition:
                // fetchsize > 0, no scrollable result set, no auto commit, no holdable cursors over commit
                // https://github.com/pgjdbc/pgjdbc/blob/master/org/postgresql/jdbc2/AbstractJdbc2Statement.java#L514
                //readConnection.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
                // many drivers don't like autocommit=true
                readConnection.setAutoCommit(getAutoCommit());
                return readConnection;
            } catch (SQLException e) {
                logger.error(""while opening read connection: "" + url + "" "" + e.getMessage(), e);
                try {
                    logger.debug(""delaying for {} seconds..."", getMaxRetryWait().seconds());
                    Thread.sleep(getMaxRetryWait().millis());
                } catch (InterruptedException ex) {
                    // do nothing
                }
            }
        }
    }
    return readConnection;
}","/**
 * Get JDBC connection for reading
 *
 * @return the connection
 * @throws SQLException when SQL execution gives an error
 */
@Override
public synchronized Connection getConnectionForReading() throws SQLException 
{
    if (connectionForReading == null)
    {
        connectionForReading = createConnectionForReading();
    }
    return connectionForReading;
}   ",194,False
"/**
 * Get next row and prepare the values for processing. The labels of each
 * columns are used for the ValueListener as paths for JSON object merging.
 *
 * @param command  the SQL command that created this result set
 * @param results  the result set
 * @param listener the listener
 * @return true if row exists and was processed, false otherwise
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public boolean nextRow(SQLCommand command, ResultSet results, KeyValueStreamListener listener)
        throws SQLException, IOException{
    if (results.next()) {
        processRow(results, listener);
        return true;
    }
    return false;
}","/**
 * Get next row and prepare the values for processing. The labels of each
 * columns are used for the ValueListener as paths for JSON object merging.
 *
 * @param command  the SQL command that created this result set
 * @param results  the result set
 * @param listener the listener
 * @return true if row exists and was processed, false otherwise
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
@Override
public boolean nextRow(SQLCommand command, ResultSet results, KeyValueStreamListener listener)
        throws SQLException, IOException 
{
    if (results.next())
    {
        for (int i = 0; i < columnCount; i++)
        {
            String label = labels[i];
            Object value = results.getObject(i + 1);
            listener.put(label, value);
        }
        return true;
    }
    return false;
}       ",195,True
"/**
 * Execute callable SQL command
 *
 * @param command the SQL command
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */
private void executeCallable(SQLCommand command) throws Exception{
    // call stored procedure
    CallableStatement statement = null;
    try {
        // we do not make a difference betwwen read/write and we assume
        // it is safe to use the read connection and query the DB
        Connection connection = getConnectionForWriting();
        logger.debug(""{} using write connection {} for executing callable statement"", this, connection);
        if (connection != null) {
            statement = connection.prepareCall(command.getSQL());
            if (!command.getParameters().isEmpty()) {
                bind(statement, command.getParameters());
            }
            if (!command.getRegister().isEmpty()) {
                register(statement, command.getRegister());
            }
            boolean hasRows = statement.execute();
            SinkKeyValueStreamListener<Object, Object> listener = new SinkKeyValueStreamListener<Object, Object>()
                    .output(context.getSink());
            if (hasRows) {
                logger.debug(""callable execution created result set"");
                while (hasRows) {
                    // merge result set, but use register
                    merge(command, statement.getResultSet(), listener);
                    hasRows = statement.getMoreResults();
                }
            } else {
                // no result set, merge from registered params only
                merge(command, statement, listener);
            }
        }
    } finally {
        close(statement);
    }
}","/**
 * Execute callable SQL command
 *
 * @param command the SQL command
 * @throws SQLException when SQL execution gives an error
 * @throws IOException  when input/output error occurs
 */



private void executeCallable(SQLCommand command) throws Exception 
{
    CallableStatement cstmt = null;
    try
    {
        cstmt = connection.prepareCall(command.getQuery());
        command.setParameters(cstmt);
        cstmt.execute();
    }
    finally
    {
        if (cstmt != null)
        {
            cstmt.close();
        }
    }
}   ",196,False
"/**
 * Bind values to prepared statement
 *
 * @param statement the prepared statement
 * @param values    the values to bind
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> bind(PreparedStatement statement, List<Object> values) throws SQLException{
    if (values == null) {
        logger.warn(""no values given for bind"");
        return this;
    }
    for (int i = 1; i <= values.size(); i++) {
        bind(statement, i, values.get(i - 1));
    }
    return this;
}","/**
 * Bind values to prepared statement
 *
 * @param statement the prepared statement
 * @param values    the values to bind
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> bind(PreparedStatement statement, List<Object> values) throws SQLException 
{
    for (int i = 0; i < values.size(); i++)
    {
        statement.setObject(i + 1, values.get(i));
    }
    return this;
}   ",197,True
"/**
 * Close result set
 *
 * @param result the result set to be closed or null
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> close(ResultSet result) throws SQLException{
    if (result != null) {
        result.close();
    }
    return this;
}","/**
 * Close result set
 *
 * @param result the result set to be closed or null
 * @throws SQLException when SQL execution gives an error
 */
@Override
public StandardSource<C> close(ResultSet result) throws SQLException 
{
    if (result != null)
    {
        result.close();
    }
    return this;
}   ",199,True
"/**
 * Process hexadecimal integer.
 */
private int readHex(int max){
    StringBuilder st = new StringBuilder(max);
    int length = pattern.length - 2;
    int i;
    for (i = 0; i < max && index < length; i++) {
        st.append(pattern[nextIndex()]);
    }
    if (i == max) {
        try {
            return Integer.parseInt(st.toString(), 16);
        } catch (NumberFormatException nfe) {
            // do nothing
        }
    }

    throw new TPatternSyntaxException("""", this.toString(), index);
}","/**
 * Process hexadecimal integer.
 */
private int readHex(int max) 
{
    int ch = read();
    if (ch == -1)
        return -1;
    if (ch >= '0' && ch <= '9')
        return ch - '0';
    if (ch >= 'A' && ch <= 'F')
        return ch - 'A' + 10;
    if (ch >= 'a' && ch <= 'f')
        return ch - 'a' + 10;
    return -1;
}   ",200,False
"/**
 * Performs {@code res = a + b}.
 */
private static void add(int[] res, int[] a, int aSize, int[] b, int bSize){
    // PRE: a.length < max(aSize, bSize)

    int i;
    long carry = (a[0] & 0xFFFFFFFFL) + (b[0] & 0xFFFFFFFFL);

    res[0] = (int) carry;
    carry >>= 32;

    if (aSize >= bSize) {
        for (i = 1; i < bSize; i++) {
            carry += (a[i] & 0xFFFFFFFFL) + (b[i] & 0xFFFFFFFFL);
            res[i] = (int) carry;
            carry >>= 32;
        }
        for (; i < aSize; i++) {
            carry += a[i] & 0xFFFFFFFFL;
            res[i] = (int) carry;
            carry >>= 32;
        }
    } else {
        for (i = 1; i < aSize; i++) {
            carry += (a[i] & 0xFFFFFFFFL) + (b[i] & 0xFFFFFFFFL);
            res[i] = (int) carry;
            carry >>= 32;
        }
        for (; i < bSize; i++) {
            carry += b[i] & 0xFFFFFFFFL;
            res[i] = (int) carry;
            carry >>= 32;
        }
    }
    if (carry != 0) {
        res[i] = (int) carry;
    }
}","/**
 * Performs {@code res = a + b}.
 */
private static void add(int[] res, int[] a, int aSize, int[] b, int bSize) 
{
    int carry = 0;
    int i = 0;
    for (; i < bSize; i++)
    {
        int sum = a[i] + b[i] + carry;
        res[i] = sum;
        carry = sum >>> 29;
    }
    for (; i < aSize; i++)
    {
        int sum = a[i] + carry;
        res[i] = sum;
        carry = sum >>> 29;
    }
    res[i] = carry;
}   ",202,True
"/**
 * Process given character in assumption that it's quantifier.
 */
private TQuantifier processQuantifier(int ch){
    StringBuilder sb = new StringBuilder(4);
    int min = -1;
    int max = Integer.MAX_VALUE;
    while (index < pattern.length) {
        ch = pattern[nextIndex()];
        if (ch == '}') {
            break;
        }
        if (ch == ',' && min < 0) {
            try {
                min = Integer.parseInt(sb.toString(), 10);
                sb.delete(0, sb.length());
            } catch (NumberFormatException nfe) {
                throw new TPatternSyntaxException("""", this.toString(), index);
            }
        } else {
            sb.append((char) ch);
        }
    }","/**
 * Process given character in assumption that it's quantifier.
 */
private TQuantifier processQuantifier(int ch) 
{
    TQuantifier quantifier = null;

    switch (ch)
    {
        case '?':
            quantifier = TQuantifier.ZeroOrOne;
            break;
        case '*':
            quantifier = TQuantifier.ZeroOrMore;
            break;
        case '+':
            quantifier = TQuantifier.OneOrMore;
            break;
    }

    return quantifier;
}   ",204,False
"/**
 * Moves pointer one position right; save current character to lookBack;
 * lookAhead to current one and finally read one more to lookAhead;
 */
private void movePointer(){
    // swap pointers
    lookBack = ch;
    ch = lookAhead;
    curST = lookAheadST;
    curToc = lookAheadToc;
    lookAheadToc = index;
    boolean reread;
    do {
        reread = false;
        // read next character analyze it and construct token:
        // //

        lookAhead = (index < pattern.length) ? nextCodePoint() : 0;
        lookAheadST = null;

        if (mode == TLexer.MODE_ESCAPE) {
            if (lookAhead == '\\') {

                // need not care about supplementary codepoints here
                lookAhead = (index < pattern.length) ? pattern[nextIndex()] : 0;

                switch (lookAhead) {
                    case 'E': {
                        mode = savedMode;

                        lookAhead = (index <= pattern.length - 2) ? nextCodePoint() : 0;
                        break;
                    }

                    default: {
                        lookAhead = '\\';
                        index = prevNW;
                        return;
                    }
                }
            } else {
                return;
            }
        }

        if (lookAhead == '\\') {

            lookAhead = (index < pattern.length - 2) ? nextCodePoint() : -1;
            switch (lookAhead) {
                case -1:
                    throw new TPatternSyntaxException("""", this.toString(), index);
                case 'P':
                case 'p': {
                    String cs = parseCharClassName();
                    boolean negative = false;

                    if (lookAhead == 'P') {
                        negative = true;
                    }
                    try {
                        lookAheadST = TAbstractCharClass.getPredefinedClass(cs, negative);
                    } catch (MissingResourceException mre) {
                        throw new TPatternSyntaxException("""", this.toString(), index);
                    }
                    lookAhead = 0;
                    break;
                }

                case 'w':
                case 's':
                case 'd':
                case 'W':
                case 'S':
                case 'D': {
                    lookAheadST = TCharClass.getPredefinedClass(new String(pattern, prevNW, 1), false);
                    lookAhead = 0;
                    break;
                }

                case 'Q': {
                    savedMode = mode;
                    mode = TLexer.MODE_ESCAPE;
                    reread = true;
                    break;
                }

                case 't':
                    lookAhead = '\t';
                    break;
                case 'n':
                    lookAhead = '\n';
                    break;
                case 'r':
                    lookAhead = '\r';
                    break;
                case 'f':
                    lookAhead = '\f';
                    break;
                case 'a':
                    lookAhead = '\u0007';
                    break;
                case 'e':
                    lookAhead = '\u001B';
                    break;

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    if (mode == TLexer.MODE_PATTERN) {
                        lookAhead = 0x80000000 | lookAhead;
                    }
                    break;
                }

                case '0':
                    lookAhead = readOctals();
                    break;
                case 'x':
                    lookAhead = readHex(2);
                    break;
                case 'u':
                    lookAhead = readHex(4);
                    break;

                case 'b':
                    lookAhead = CHAR_WORD_BOUND;
                    break;
                case 'B':
                    lookAhead = CHAR_NONWORD_BOUND;
                    break;
                case 'A':
                    lookAhead = CHAR_START_OF_INPUT;
                    break;
                case 'G':
                    lookAhead = CHAR_PREVIOUS_MATCH;
                    break;
                case 'Z':
                    lookAhead = CHAR_END_OF_LINE;
                    break;
                case 'z':
                    lookAhead = CHAR_END_OF_INPUT;
                    break;
                case 'c': {
                    if (index < pattern.length - 2) {

                        // need not care about supplementary codepoints here
                        lookAhead = pattern[nextIndex()] & 0x1f;
                        break;
                    } else {
                        throw new TPatternSyntaxException("""", this.toString(), index);
                    }
                }
                case 'C':
                case 'E':
                case 'F':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'R':
                case 'T':
                case 'U':
                case 'V':
                case 'X':
                case 'Y':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'o':
                case 'q':
                case 'y':
                    throw new TPatternSyntaxException("""", this.toString(), index);

                default:
                    break;
            }
        } else if (mode == TLexer.MODE_PATTERN) {
            switch (lookAhead) {
                case '+':
                case '*':
                case '?': {
                    char mod = (index < pattern.length) ? pattern[index] : '*';
                    switch (mod) {
                        case '+': {
                            lookAhead = lookAhead | TLexer.QMOD_POSSESSIVE;
                            nextIndex();
                            break;
                        }
                        case '?': {
                            lookAhead = lookAhead | TLexer.QMOD_RELUCTANT;
                            nextIndex();
                            break;
                        }
                        default: {
                            lookAhead = lookAhead | TLexer.QMOD_GREEDY;
                            break;
                        }
                    }

                    break;
                }

                case '{': {
                    lookAheadST = processQuantifier(lookAhead);
                    break;
                }

                case '$':
                    lookAhead = CHAR_DOLLAR;
                    break;
                case '(': {
                    if (pattern[index] == '?') {
                        nextIndex();
                        char nonCap = pattern[index];
                        boolean behind = false;
                        do {
                            if (!behind) {
                                switch (nonCap) {
                                    case '!':
                                        lookAhead = CHAR_NEG_LOOKAHEAD;
                                        nextIndex();
                                        break;
                                    case '=':
                                        lookAhead = CHAR_POS_LOOKAHEAD;
                                        nextIndex();
                                        break;
                                    case '>':
                                        lookAhead = CHAR_ATOMIC_GROUP;
                                        nextIndex();
                                        break;
                                    case '<': {
                                        nextIndex();
                                        nonCap = pattern[index];
                                        behind = true;
                                        break;
                                    }
                                    default: {
                                        lookAhead = readFlags();

                                        /*
                                         * We return res = res | 1 << 8 from
                                         * readFlags() if we read
                                         * (?idmsux-idmsux)
                                         */
                                        if (lookAhead >= 256) {

                                            // Erase auxiliary bit
                                            lookAhead = lookAhead & 0xff;
                                            flags = lookAhead;
                                            lookAhead = lookAhead << 16;
                                            lookAhead = CHAR_FLAGS | lookAhead;
                                        } else {
                                            flags = lookAhead;
                                            lookAhead = lookAhead << 16;
                                            lookAhead = CHAR_NONCAP_GROUP | lookAhead;
                                        }
                                        break;
                                    }
                                }
                            } else {
                                behind = false;
                                switch (nonCap) {
                                    case '!':
                                        lookAhead = CHAR_NEG_LOOKBEHIND;
                                        nextIndex();
                                        break;
                                    case '=':
                                        lookAhead = CHAR_POS_LOOKBEHIND;
                                        nextIndex();
                                        break;
                                    default:
                                        throw new TPatternSyntaxException("""", this.toString(), index);
                                }
                            }
                        } while (behind);
                    } else {
                        lookAhead = CHAR_LEFT_PARENTHESIS;
                    }
                    break;
                }

                case ')':
                    lookAhead = CHAR_RIGHT_PARENTHESIS;
                    break;
                case '[': {
                    lookAhead = CHAR_LEFT_SQUARE_BRACKET;
                    setMode(TLexer.MODE_RANGE);
                    break;
                }
                case ']': {
                    if (mode == TLexer.MODE_RANGE) {
                        lookAhead = CHAR_RIGHT_SQUARE_BRACKET;
                    }
                    break;
                }
                case '^':
                    lookAhead = CHAR_CARET;
                    break;
                case '|':
                    lookAhead = CHAR_VERTICAL_BAR;
                    break;
                case '.':
                    lookAhead = CHAR_DOT;
                    break;
                default:
                    break;
            }
        } else if (mode == TLexer.MODE_RANGE) {
            switch (lookAhead) {
                case '[':
                    lookAhead = CHAR_LEFT_SQUARE_BRACKET;
                    break;
                case ']':
                    lookAhead = CHAR_RIGHT_SQUARE_BRACKET;
                    break;
                case '^':
                    lookAhead = CHAR_CARET;
                    break;
                case '&':
                    lookAhead = CHAR_AMPERSAND;
                    break;
                case '-':
                    lookAhead = CHAR_HYPHEN;
                    break;
                default:
                    break;
            }
        }
    } while (reread);
}

/**
 * Parse character classes names and verifies correction of the syntax;
 */
private String parseCharClassName() {
    StringBuilder sb = new StringBuilder(10);
    if (index < pattern.length - 2) {
        // one symbol family
        if (pattern[index] != '{') {
            return ""Is"" + new String(pattern, nextIndex(), 1); //$NON-NLS-1$
        }

        nextIndex();
        char ch = 0;
        while (index < pattern.length - 2) {
            ch = pattern[nextIndex()];
            if (ch == '}') {
                break;
            }
            sb.append(ch);
        }
        if (ch != '}') {
            throw new TPatternSyntaxException("""", this.toString(), index);
        }
    }

    if (sb.length() == 0) {
        throw new TPatternSyntaxException("""", this.toString(), index);
    }

    String res = sb.toString();
    if (res.length() == 1) {
        return ""Is"" + res;
    }
    return (res.length() > 3 && (res.startsWith(""Is"") || res.startsWith(""In""))) ? res.substring(2) : res;
}","/**
 * Moves pointer one position right; save current character to lookBack;
 * lookAhead to current one and finally read one more to lookAhead;
 */
private void movePointer() 
{
    lookBack = lookAhead;
    lookAhead = reader.read();
    current = reader.read();
}   ",205,False
"/**
 * Find the central directory and read the contents.
 *
 * <p>The central directory can be followed by a variable-length comment
 * field, so we have to scan through it backwards.  The comment is at
 * most 64K, plus we have 18 bytes for the end-of-central-dir stuff
 * itself, plus apparently sometimes people throw random junk on the end
 * just for the fun of it.
 *
 * <p>This is all a little wobbly.  If the wrong value ends up in the EOCD
 * area, we're hosed. This appears to be the way that everybody handles
 * it though, so we're in good company if this fails.
 */
private void readCentralDir() throws IOException{
    /*
     * Scan back, looking for the End Of Central Directory field.  If
     * the archive doesn't have a comment, we'll hit it on the first
     * try.
     *
     * No need to synchronize mRaf here -- we only do this when we
     * first open the Zip file.
     */
    long scanOffset = mRaf.length() - ENDHDR;
    if (scanOffset < 0) {
        throw new TZipException();
    }

    long stopOffset = scanOffset - 65536;
    if (stopOffset < 0) {
        stopOffset = 0;
    }

    while (true) {
        mRaf.seek(scanOffset);
        if (TZipEntry.readIntLE(mRaf) == 101010256L) {
            break;
        }

        scanOffset--;
        if (scanOffset < stopOffset) {
            throw new TZipException();
        }
    }

    /*
     * Found it, read the EOCD.
     *
     * For performance we want to use buffered I/O when reading the
     * file.  We wrap a buffered stream around the random-access file
     * object.  If we just read from the RandomAccessFile we'll be
     * doing a read() system call every time.
     */
    RAFStream rafs = new RAFStream(mRaf, mRaf.getFilePointer());
    BufferedInputStream bin = new BufferedInputStream(rafs, ENDHDR);

    int diskNumber = ler.readShortLE(bin);
    int diskWithCentralDir = ler.readShortLE(bin);
    int numEntries = ler.readShortLE(bin);
    int totalNumEntries = ler.readShortLE(bin);
    /*centralDirSize =*/ ler.readIntLE(bin);
    long centralDirOffset = ler.readIntLE(bin);
    /*commentLen =*/ ler.readShortLE(bin);

    if (numEntries != totalNumEntries || diskNumber != 0 || diskWithCentralDir != 0) {
        throw new TZipException();
    }

    /*
     * Seek to the first CDE and read all entries.
     * However, when Z_SYNC_FLUSH is used the offset may not point directly
     * to the CDE so skip over until we find it. 
     * At most it will be 6 bytes away (one or two bytes for empty block, 4 bytes for
     * empty block signature).  
     */
    scanOffset = centralDirOffset;
    stopOffset = scanOffset + 6;
    
    while (true) {
        mRaf.seek(scanOffset);
        if (TZipEntry.readIntLE(mRaf) == CENSIG) {
            break;
        }

        scanOffset++;
        if (scanOffset > stopOffset) {
            throw new TZipException();
        }
    }
    
    // If CDE is found then go and read all the entries
    rafs = new RAFStream(mRaf, scanOffset);
    bin = new BufferedInputStream(rafs, 4096);
    for (int i = 0; i < numEntries; i++) {
        TZipEntry newEntry = new TZipEntry(ler, bin);
        mEntries.put(newEntry.getName(), newEntry);
    }
}","/**
 * Find the central directory and read the contents.
 *
 * <p>The central directory can be followed by a variable-length comment
 * field, so we have to scan through it backwards.  The comment is at
 * most 64K, plus we have 18 bytes for the end-of-central-dir stuff
 * itself, plus apparently sometimes people throw random junk on the end
 * just for the fun of it.
 *
 * <p>This is all a little wobbly.  If the wrong value ends up in the EOCD
 * area, we're hosed. This appears to be the way that everybody handles
 * it though, so we're in good company if this fails.
 */
private void readCentralDir() throws IOException 
{
    int startOffset = 0;
    int commentLength = 0;
    byte[] comment = new byte[1024];

    // Find the start of the central directory
    long centralDirStart = findCentralDirStart();
    if (centralDirStart == -1) {
        throw new IOException(""Could not find central directory"");
    }

    // Read the central directory
    int centralDirLength = readCentralDirRecord(centralDirStart);
    if (centralDirLength == -1) {
        throw new IOException(""Could not read central directory"");
    }

    // Read the comment field
    startOffset = centralDirStart - (CentralDirectoryFileHeader.SIGNATURE_LENGTH + 22);
    if (startOffset < 0) {
        throw new IOException(""Invalid central directory offset "" + startOffset);
    }
    commentLength = readCommentField(startOffset, comment);

    // Set the current position to the start of the central directory
    this.position = centralDirStart;

    // Return the central directory length
    this.centralDirectoryLength = centralDirLength;
}   ",207,False
"/**
 * Performs {@code res = a - b}. It is assumed the magnitude of a is not
 * less than the magnitude of b.
 */
private static void subtract(int[] res, int[] a, int aSize, int[] b, int bSize){
    // PRE: a[] >= b[]
    int i;
    long borrow = 0;

    for (i = 0; i < bSize; i++) {
        borrow += (a[i] & 0xFFFFFFFFL) - (b[i] & 0xFFFFFFFFL);
        res[i] = (int) borrow;
        borrow >>= 32; // -1 or 0
    }
    for (; i < aSize; i++) {
        borrow += a[i] & 0xFFFFFFFFL;
        res[i] = (int) borrow;
        borrow >>= 32; // -1 or 0
    }
}","/**
 * Performs {@code res = a - b}. It is assumed the magnitude of a is not
 * less than the magnitude of b.
 */
private static void subtract(int[] res, int[] a, int aSize, int[] b, int bSize) 
{
    int carry = 0;
    for (int i = 0; i < bSize; ++i)
    {
        int diff = a[i] - b[i] - carry;
        carry = (diff >> 31) & 1;
        res[i] = diff & MASK;
    }
    for (int i = bSize; i < aSize; ++i)
    {
        int diff = a[i] - carry;
        carry = (diff >> 31) & 1;
        res[i] = diff & MASK;
    }
    res[aSize] = -carry;
}   ",209,True
"/**
 * Returns next character index to read and moves pointer to the next one.
 * If comments flag is on this method will skip comments and whitespaces.
 *
 * The following actions are equivalent if comments flag is off ch =
 * pattern[index++] == ch = pattern[nextIndex]
 *
 * @return next character index to read.
 */
private int nextIndex(){
    prevNW = index;
    if ((flags & TPattern.COMMENTS) != 0) {
        skipComments();
    } else {
        index++;
    }
    return prevNW;
}","/**
 * Returns next character index to read and moves pointer to the next one.
 * If comments flag is on this method will skip comments and whitespaces.
 *
 * The following actions are equivalent if comments flag is off ch =
 * pattern[index++] == ch = pattern[nextIndex]
 *
 * @return next character index to read.
 */
private int nextIndex() 
{
    if (comments)
    {
        char ch = pattern[index];
        while (Character.isWhitespace(ch))
        {
            if (++index >= pattern.length)
            {
                return index;
            }
            ch = pattern[index];
        }
        if (ch == '#')
        {
            while (index < pattern.length && pattern[index] != '\n')
            {
                index++;
            }
        }
    }
    return index;
}   ",210,True
"/**
 * Addss the value represented by {@code b} to the value represented by
 * {@code a}. It is assumed the magnitude of a is not less than the
 * magnitude of b.
 *
 * @return {@code a + b}
 */
private static int[] add(int[] a, int aSize, int[] b, int bSize){
    // PRE: a[] >= b[]
    int[] res = new int[aSize + 1];
    add(res, a, aSize, b, bSize);
    return res;
}","/**
 * Addss the value represented by {@code b} to the value represented by
 * {@code a}. It is assumed the magnitude of a is not less than the
 * magnitude of b.
 *
 * @return {@code a + b}
 */
private static int[] add(int[] a, int aSize, int[] b, int bSize) 
{
    int[] result = new int[Math.max(aSize, bSize) + 1];
    int carry = 0;
    int i = 0;
    while (i < aSize || i < bSize)
    {
        int sum = carry;
        if (i < aSize)
            sum += a[i];
        if (i < bSize)
            sum += b[i];
        result[i] = sum % 10;
        carry = sum / 10;
        i++;
    }
    if (carry != 0)
        result[i] = carry;
    return result;
}   ",212,True
"/**
 * Reread current character, may be require if previous token changes mode
 * to one with different character interpretation.
 *
 */
private void reread(){
    lookAhead = ch;
    lookAheadST = curST;
    index = lookAheadToc;
    lookAheadToc = curToc;
    movePointer();
}","/**
 * Reread current character, may be require if previous token changes mode
 * to one with different character interpretation.
 *
 */

private void reread() 
{
    try
    {
        reader.unread(currentChar);
    }
    catch (IOException e)
    {
        throw new RuntimeException(e);
    }
}   ",213,False
"/**
 * Give string representation of this.
 *
 * @return - string representation.
 */
private String getDecomposedChar(){
    if (decomposedCharUTF16 == null) {
        decomposedCharUTF16 = new String(decomposedChar);
    }
    return decomposedCharUTF16;
}","/**
 * Give string representation of this.
 *
 * @return - string representation.
 */
private String getDecomposedChar() 
{
    if (decomposedChar == null)
    {
        decomposedChar = Character.toString((char) this.charValue);
    }
    return decomposedChar;
}   ",214,True
"/**
 * Compares two arrays, representing unsigned integer in little-endian
 * order. Returns +1,0,-1 if a is - respective - greater, equal or lesser
 * then b
 */
private static int unsignedArraysCompare(int[] a, int[] b, int aSize, int bSize){
    if (aSize > bSize) {
        return 1;
    } else if (aSize < bSize) {
        return -1;
    } else {
        int i;
        for (i = aSize - 1; i >= 0 && a[i] == b[i]; i--) {
            // do nothing
        }
        return i < 0 ? TBigInteger.EQUALS : ((a[i] & 0xFFFFFFFFL) < (b[i] & 0xFFFFFFFFL) ? TBigInteger.LESS
                : TBigInteger.GREATER);
    }
}","/**
 * Compares two arrays, representing unsigned integer in little-endian
 * order. Returns +1,0,-1 if a is - respective - greater, equal or lesser
 * then b
 */
private static int unsignedArraysCompare(int[] a, int[] b, int aSize, int bSize) 
{
    int aIndex = aSize;
    int bIndex = bSize;
    while (aIndex > 0 && bIndex > 0)
    {
        aIndex--;
        bIndex--;
        int aByte = a[aIndex] & 0xff;
        int bByte = b[bIndex] & 0xff;
        if (aByte < bByte)
            return -1;
        if (aByte > bByte)
            return 1;
    }
    return aSize - bSize;
}   ",218,True
"/**
 * 为自定义的DayView设置资源文件
 *
 * @param layoutResource 资源文件
 * @return CalendarDate 修改后的日期
 */
private void setupLayoutResource(int layoutResource){
    View inflated = LayoutInflater.from(getContext()).inflate(layoutResource, this);
    inflated.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
            MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
    inflated.layout(0, 0, getMeasuredWidth(), getMeasuredHeight());
}","/**
 * 为自定义的DayView设置资源文件
 *
 * @param layoutResource 资源文件
 * @return CalendarDate 修改后的日期
 */

private void setupLayoutResource(int layoutResource) 
{
    this.layoutResource = layoutResource;
    if (layoutResource != 0)
    {
        LayoutInflater.from(getContext()).inflate(layoutResource, this);
    }
}   ",220,True
"/**
 * 得到种子日期所在周的周日
 *
 * @param seedDate 种子日期
 * @return CalendarDate 所在周周日
 */
public static CalendarDate getSunday(CalendarDate seedDate){// TODO: 16/12/12 得到一个CustomDate对象
    Calendar c = Calendar.getInstance();
    String dateString = seedDate.toString();
    Date date = new Date();
    try {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-M-d"");
        date = sdf.parse(dateString);
    } catch (ParseException e) {
        System.out.println(e.getMessage());
    }
    c.setTime(date);
    if (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
        c.add(Calendar.DAY_OF_MONTH, 7 - c.get(Calendar.DAY_OF_WEEK) + 1);
    }
    return new CalendarDate(c.get(Calendar.YEAR),
            c.get(Calendar.MONTH) + 1,
            c.get(Calendar.DAY_OF_MONTH));
}","/**
 * 得到种子日期所在周的周日
 *
 * @param seedDate 种子日期
 * @return CalendarDate 所在周周日
 */
public static CalendarDate getSunday(CalendarDate seedDate) 
{
    CalendarDate sunday = new CalendarDate(seedDate);
    sunday.add(Calendar.DAY_OF_MONTH, 7 - sunday.getDayOfWeek().getValue());
    return sunday;
}   ",221,False
"/**
 * 构造器
 *
 * @param context 上下文
 * @param layoutResource 自定义DayView的layout资源
 */
public CustomDayView(Context context, int layoutResource){
    super(context, layoutResource);
    dateTv = (TextView) findViewById(R.id.date);
    marker = (ImageView) findViewById(R.id.maker);
    selectedBackground = findViewById(R.id.selected_background);
    todayBackground = findViewById(R.id.today_background);
}","/**
 * 构造器
 *
 * @param context 上下文
 * @param layoutResource 自定义DayView的layout资源
 */
public CustomDayView(Context context, int layoutResource) 
{
    super(context, layoutResource);
    this.context = context;
    this.layoutResource = layoutResource;
    init();
}   ",222,False
"/**
 * 计算偏移距离
 *
 * @param offset 偏移值
 * @param min    最小偏移值
 * @param max    最大偏移值
 * @return int offset
 */
private static int calcOffset(int offset, int min, int max){
    if (offset > max) {
        return max;
    } else if (offset < min) {
        return min;
    } else {
        return offset;
    }
}","/**
 * 计算偏移距离
 *
 * @param offset 偏移值
 * @param min    最小偏移值
 * @param max    最大偏移值
 * @return int offset
 */
private static int calcOffset(int offset, int min, int max) 
{
    if (offset < min)
    {
        return min;
    }
    else if (offset > max)
    {
        return max;
    }
    else
    {
        return offset;
    }
}   ",223,True
"/**
 * 删除方法, 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理
 *
 * @param child     需要移动的View
 * @param dy        实际偏移量
 * @param minOffset 最小偏移量
 * @param maxOffset 最大偏移量
 * @return void
 */
public static int scroll(View child, int dy, int minOffset, int maxOffset){
    final int initOffset = child.getTop();
    int offset = calcOffset(initOffset - dy, minOffset, maxOffset) - initOffset;
    child.offsetTopAndBottom(offset);
    return -offset;
}","/**
 * 删除方法, 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理
 *
 * @param child     需要移动的View
 * @param dy        实际偏移量
 * @param minOffset 最小偏移量
 * @param maxOffset 最大偏移量
 * @return void
 */
public static int scroll(View child, int dy, int minOffset, int maxOffset) 
{
    int top = child.getTop() + dy;
    if (top < minOffset)
    {
        top = minOffset;
    } else if (top > maxOffset)
    {
        top = maxOffset;
    }
    child.layout(child.getLeft(), top, child.getRight(), child.getBottom() + dy);
    return top;
}   ",225,False
"/**
 * 得到当前月第一天在其周的位置
 *
 * @param year  当前年
 * @param month 当前月
 * @param type  周排列方式 0代表周一作为本周的第一天， 2代表周日作为本周的第一天
 * @return int 本月第一天在其周的位置
 */
public static int getFirstDayWeekPosition(int year, int month, CalendarAttr.WeekArrayType type){
    Calendar cal = Calendar.getInstance();
    cal.setTime(getDateFromString(year, month));
    int week_index = cal.get(Calendar.DAY_OF_WEEK) - 1;
    if (type == CalendarAttr.WeekArrayType.Sunday) {
        return week_index;
    } else {
        week_index = cal.get(Calendar.DAY_OF_WEEK) + 5;
        if (week_index >= 7) {
            week_index -= 7;
        }
    }
    return week_index;
}","/**
 * 得到当前月第一天在其周的位置
 *
 * @param year  当前年
 * @param month 当前月
 * @param type  周排列方式 0代表周一作为本周的第一天， 2代表周日作为本周的第一天
 * @return int 本月第一天在其周的位置
 */
public static int getFirstDayWeekPosition(int year, int month, CalendarAttr.WeekArrayType type) 
{
    Calendar calendar = Calendar.getInstance();
    calendar.set(year, month - 1, 1);
    int weekPosition = calendar.get(Calendar.DAY_OF_WEEK) - 1;
    if (type == CalendarAttr.WeekArrayType.WEEK_SUNDAY)
    {
        weekPosition = weekPosition == 0 ? 7 : weekPosition;
    }
    return weekPosition;
}   ",229,True
"/**
 * 通过修改当前Date对象的天数返回一个修改后的Date
 *
 * @return CalendarDate 修改后的日期
 */
public CalendarDate modifyDay(int day){
    int lastMonthDays = Utils.getMonthDays(this.year, this.month - 1);
    int currentMonthDays = Utils.getMonthDays(this.year, this.month);

    CalendarDate modifyDate;
    if (day > currentMonthDays) {
        modifyDate = new CalendarDate(this.year, this.month, this.day);
        Log.e(""ldf"", ""移动天数过大"");
    } else if (day > 0) {
        modifyDate = new CalendarDate(this.year, this.month, day);
    } else if (day > 0 - lastMonthDays) {
        modifyDate = new CalendarDate(this.year, this.month - 1, lastMonthDays + day);
    } else {
        modifyDate = new CalendarDate(this.year, this.month, this.day);
        Log.e(""ldf"", ""移动天数过大"");
    }
    return modifyDate;
}","/**
 * 通过修改当前Date对象的天数返回一个修改后的Date
 *
 * @return CalendarDate 修改后的日期
 */
public CalendarDate modifyDay(int day) 
{
    CalendarDate calendarDate = new CalendarDate(this.year, this.month, this.day);
    calendarDate.addDay(day);
    return calendarDate;
}   ",232,False
"/**
 * 构造器 传入资源文件创建DayView
 *
 * @param layoutResource 资源文件
 * @param context 上下文
 */
public DayView(Context context, int layoutResource){
    super(context);
    setupLayoutResource(layoutResource);
    this.context = context;
    this.layoutResource = layoutResource;
}","/**
 * 构造器 传入资源文件创建DayView
 *
 * @param layoutResource 资源文件
 * @param context 上下文
 */

public DayView(Context context, int layoutResource) 
{
    super(context, layoutResource);
    this.context = context;
    LayoutInflater.from(context).inflate(layoutResource, this);
    initView();
}   ",233,True
"/**
 * 使用dayRenderer绘制每一天
 *
 * @return void
 */
public void draw(Canvas canvas){
    for (int row = 0; row < Const.TOTAL_ROW; row++) {
        if (weeks[row] != null) {
            for (int col = 0; col < Const.TOTAL_COL; col++) {
                if (weeks[row].days[col] != null) {
                    dayRenderer.drawDay(canvas, weeks[row].days[col]);
                }
            }
        }
    }
}","/**
 * 使用dayRenderer绘制每一天
 *
 * @return void
 */
public void draw(Canvas canvas) 
{
    if (mDayRenderer == null) {
        return;
    }

    mDayRenderer.drawDay(canvas, mDay, mX, mY, mPaint);
}   ",234,True
"/**
 * 根据种子日期孵化出本日历牌的数据
 *
 * @return void
 */
public void showDate(CalendarDate seedDate){
    if (seedDate != null) {
        this.seedDate = seedDate;
    } else {
        this.seedDate = new CalendarDate();
    }
    update();
}","/**
 * 根据种子日期孵化出本日历牌的数据
 *
 * @return void
 */
public void showDate(CalendarDate seedDate) 
{
    // ��算本日历��的起始日期
    CalendarDate startDate = new CalendarDate();
    startDate.setYear(seedDate.getYear());
    startDate.setMonth(seedDate.getMonth());
    startDate.setDay(seedDate.getDay());
    startDate.substractOneDay();

    // ��算本日历��的结束日期
    CalendarDate endDate = new CalendarDate();
    endDate.setYear(seedDate.getYear());
    endDate.setMonth(seedDate.getMonth());
    endDate.setDay(seedDate.getDay());
    endDate.addOneDay();

    // ��据起始日期和结束日期��化出本日历��的数据
    showDate(startDate, endDate);
}   ",235,False
"/**
 * 刷新指定行的周数据
 *
 * @param rowIndex  参数月所在年
 * @return void
 */
public void updateWeek(int rowIndex){
    CalendarDate currentWeekLastDay;
    if (attr.getWeekArrayType() == CalendarAttr.WeekArrayType.Sunday) {
        currentWeekLastDay = Utils.getSaturday(seedDate);
    } else {
        currentWeekLastDay = Utils.getSunday(seedDate);
    }
    int day = currentWeekLastDay.day;
    for (int i = Const.TOTAL_COL - 1; i >= 0; i--) {
        CalendarDate date = currentWeekLastDay.modifyDay(day);
        if (weeks[rowIndex] == null) {
            weeks[rowIndex] = new Week(rowIndex);
        }
        if (weeks[rowIndex].days[i] != null) {
            if (date.equals(CalendarViewAdapter.loadSelectedDate())) {
                weeks[rowIndex].days[i].setState(State.SELECT);
                weeks[rowIndex].days[i].setDate(date);
            } else {
                weeks[rowIndex].days[i].setState(State.CURRENT_MONTH);
                weeks[rowIndex].days[i].setDate(date);
            }
        } else {
            if (date.equals(CalendarViewAdapter.loadSelectedDate())) {
                weeks[rowIndex].days[i] = new Day(State.SELECT, date, rowIndex, i);
            } else {
                weeks[rowIndex].days[i] = new Day(State.CURRENT_MONTH, date, rowIndex, i);
            }
        }
        day--;
    }
}","/**
 * 刷新指定行的周数据
 *
 * @param rowIndex  参数月所在年
 * @return void
 */

public void updateWeek(int rowIndex) 
{
    List<Month> monthList = monthService.getMonthList();
    Month month = monthList.get(rowIndex);
    List<Week> weekList = month.getWeekList();
    for (Week week : weekList)
    {
        weekService.updateWeek(week);
    }
}   ",236,False
"/**
 * 得到种子日期所在周的周六
 *
 * @param seedDate 种子日期
 * @return CalendarDate 所在周周六
 */
public static CalendarDate getSaturday(CalendarDate seedDate){// TODO: 16/12/12 得到一个CustomDate对象
    Calendar c = Calendar.getInstance();
    String dateString = seedDate.toString();
    Date date = null;
    try {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-M-d"");
        date = sdf.parse(dateString);
    } catch (ParseException e) {
        System.out.println(e.getMessage());
    }
    c.setTime(date);
    c.add(Calendar.DAY_OF_MONTH, 7 - c.get(Calendar.DAY_OF_WEEK));
    return new CalendarDate(c.get(Calendar.YEAR),
            c.get(Calendar.MONTH) + 1,
            c.get(Calendar.DAY_OF_MONTH));
}","/**
 * 得到种子日期所在周的周六
 *
 * @param seedDate 种子日期
 * @return CalendarDate 所在周周六
 */
public static CalendarDate getSaturday(CalendarDate seedDate) 
{
    CalendarDate calendarDate = new CalendarDate();
    calendarDate.setYear(seedDate.getYear());
    calendarDate.setMonth(seedDate.getMonth());
    calendarDate.setDay(seedDate.getDay());
    int day = seedDate.getDay();
    int add = 6 - day;
    calendarDate.add(CalendarDate.DAY_OF_MONTH, add);
    return calendarDate;
}   ",237,True
"/**
 * 通过修改当前Date对象的所在月返回一个修改后的Date
 *
 * @return CalendarDate 修改后的日期
 */
public CalendarDate modifyMonth(int offset){
    CalendarDate result = new CalendarDate();
    int addToMonth = this.month + offset;
    if (offset > 0) {
        if (addToMonth > 12) {
            result.setYear(this.year + (addToMonth - 1) / 12);
            result.setMonth(addToMonth % 12 == 0 ? 12 : addToMonth % 12);
        } else {
            result.setYear(this.year);
            result.setMonth(addToMonth);
        }
    } else {
        if (addToMonth == 0) {
            result.setYear(this.year - 1);
            result.setMonth(12);
        } else if (addToMonth < 0) {
            result.setYear(this.year + addToMonth / 12 - 1);
            int month = 12 - Math.abs(addToMonth) % 12;
            result.setMonth(month == 0 ? 12 : month);
        } else {
            result.setYear(this.year);
            result.setMonth(addToMonth == 0 ? 12 : addToMonth);
        }
    }
    return result;
}","/**
 * 通过修改当前Date对象的所在月返回一个修改后的Date
 *
 * @return CalendarDate 修改后的日期
 */
public CalendarDate modifyMonth(int offset) 
{
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(this);
    calendar.add(Calendar.MONTH, offset);
    return new CalendarDate(calendar.getTime());
}   ",239,False
"/**
 * 调用系统发短信界面
 *
 * @param activity    Activity
 * @param phoneNumber 手机号码
 * @param smsContent  短信内容
 */
public static void sendMessage(Context activity, String phoneNumber, String smsContent){
    if (phoneNumber == null || phoneNumber.length() < 4) {
        return;
    }
    Uri uri = Uri.parse(""smsto:"" + phoneNumber);
    Intent it = new Intent(Intent.ACTION_SENDTO, uri);
    it.putExtra(""sms_body"", smsContent);
    it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    activity.startActivity(it);
}","/**
 * 调用系统发短信界面
 *
 * @param activity    Activity
 * @param phoneNumber 手机号码
 * @param smsContent  短信内容
 */

public static void sendMessage(Context activity, String phoneNumber, String smsContent) 
{
    Uri uri = Uri.parse(""smsto:"" + phoneNumber);
    Intent intent = new Intent(Intent.ACTION_SENDTO, uri);
    intent.putExtra(""sms_body"", smsContent);
    activity.startActivity(intent);
}   ",243,True
"/**
 * 字符串转数组
 * @param str
 * @return
 */
public static byte[] hexStrToByteArray(String str){
	if (str == null) {
		return null;
	}
	if (str.length() == 0) {
		return new byte[0];
	}
	byte[] byteArray = new byte[str.length() / 2];
	for (int i = 0; i < byteArray.length; i++){
		String subStr = str.substring(2 * i, 2 * i + 2);
		byteArray[i] = ((byte)Integer.parseInt(subStr, 16));
	}
	return byteArray;
}","/**
 * 字符串转数组
 * @param str
 * @return
 */
public static byte[] hexStrToByteArray(String str) 
{
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return new byte[0];
    }
    byte[] byteArray = new byte[str.length() / 2];
    for (int i = 0; i < byteArray.length; i++) {
        String subStr = str.substring(2 * i, 2 * i + 2);
        byteArray[i] = ((byte) Integer.parseInt(subStr, 16));
    }
    return byteArray;
}   ",244,True
"/**
 * (02)、从bytes上截取一段
 * @param bytes 母体
 * @param off 起始
 * @param length 个数
 * @return byte[]
 */
public static byte[] cutOut(byte[] bytes, int off, int length){
	byte[] bytess = new byte[length];
	System.arraycopy(bytes, off, bytess, 0, length);
	return bytess;
}","/**
 * (02)、从bytes上截取一段
 * @param bytes 母体
 * @param off 起始
 * @param length 个数
 * @return byte[]
 */
public static byte[] cutOut(byte[] bytes, int off, int length) 
{
    byte[] cutBytes = new byte[length];
    for (int i = 0; i < length; i++)
    {
        cutBytes[i] = bytes[off + i];
    }
    return cutBytes;
}   ",245,True
"/**
 * (01)、位移加密
 * @param bytes
 */
public static void byteJiaMi(byte[] bytes){
	for (int w = 0; w < bytes.length; w++){
		int a = bytes[w];
		a = ~a;
		bytes[w] = (byte)a;
	}
}","/**
 * (01)、位移加密
 * @param bytes
 */
public static void byteJiaMi(byte[] bytes) 
{
    for (int i = 0; i < bytes.length; i++)
    {
        bytes[i] = (byte) (bytes[i] + 1);
    }
}   ",247,True
"/**
 * 字节数组转换成16进制字符串
 * @param raw
 * @return
 */
public static String getHex(byte [] raw ){
	String HEXES = ""0123456789ABCDEF"";
    if ( raw == null ) {
      return null;
    }
    final StringBuilder hex = new StringBuilder( 2 * raw.length );
    for ( final byte b : raw ) {
      hex.append(HEXES.charAt((b & 0xF0) >> 4))
         .append(HEXES.charAt((b & 0x0F)));
    }
    return hex.toString();
}","/**
 * 字节数组转换成16进制字符串
 * @param raw
 * @return
 */
public static String getHex(byte [] raw ) 
{
    if ( raw == null )
    {
        return """";
    }
    final StringBuilder hex = new StringBuilder( 2 * raw.length );
    for ( final byte b : raw )
    {
        hex.append(Character.forDigit((b & 0xF0) >> 4, 16));
        hex.append(Character.forDigit((b & 0x0F), 16));
    }
    return hex.toString();
}   ",248,True
"/**
 * 切换软键盘的状态
 */
public static void toggleSoftKeyboardState(Context context){
    ((InputMethodManager) context.getSystemService(
            Context.INPUT_METHOD_SERVICE)).toggleSoftInput(
            InputMethodManager.SHOW_IMPLICIT,
            InputMethodManager.HIDE_NOT_ALWAYS);
}","/**
 * 切换软键盘的状态
 */

public static void toggleSoftKeyboardState(Context context) 
{
    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);
}   ",249,True
"/**
 * 从一个byte[]数组中截取一部分
 * @param src
 * @param begin
 * @param count
 * @return
 */
public static byte[] subBytes ( byte[] src, int begin, int count){
	byte[] bs = new byte[count];
	for (int i = begin; i < begin + count; i++) {
		bs[i - begin] = src[i];
	}
	return bs;
}","/**
 * 从一个byte[]数组中截取一部分
 * @param src
 * @param begin
 * @param count
 * @return
 */
public static byte[] subBytes ( byte[] src, int begin, int count) 
{
    byte[] bs = new byte[count];
    for (int i=begin; i<begin+count; i++) bs[i-begin] = src[i];
    return bs;
}   ",250,True
"/**
 * 获取所有联系人的姓名和电话号码，需要READ_CONTACTS权限
 * @param context 上下文
 * @return Cursor。姓名：CommonDataKinds.Phone.DISPLAY_NAME；号码：CommonDataKinds.Phone.NUMBER
 */
public static Cursor getContactsNameAndNumber(Context context){
    return context.getContentResolver().query(
            ContactsContract.CommonDataKinds.Phone.CONTENT_URI, new String[] {
                    ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER}, null, null, ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME + "" COLLATE LOCALIZED ASC"");
}","/**
 * 获取所有联系人的姓名和电话号码，需要READ_CONTACTS权限
 * @param context 上下文
 * @return Cursor。姓名：CommonDataKinds.Phone.DISPLAY_NAME；号码：CommonDataKinds.Phone.NUMBER
 */

public static Cursor getContactsNameAndNumber(Context context) 
{
    ContentResolver resolver = context.getContentResolver();
    Cursor cursor = resolver.query(CommonDataKinds.Phone.CONTENT_URI, new String[]{CommonDataKinds.Phone.DISPLAY_NAME, CommonDataKinds.Phone.NUMBER}, null, null, null);
    return cursor;
}   ",252,True
"/**
 * 为给定的编辑器开启软键盘
 *
 * @param editText 给定的编辑器
 */
public static void openSoftKeyboard(Context context, EditText editText){
    editText.requestFocus();
    InputMethodManager inputMethodManager
            = (InputMethodManager) context.getSystemService(
            Context.INPUT_METHOD_SERVICE);
    inputMethodManager.showSoftInput(editText,
            InputMethodManager.SHOW_IMPLICIT);
    ViewUtils.setEditTextSelectionToEnd(editText);
}","/**
 * 为给定的编辑器开启软键盘
 *
 * @param editText 给定的编辑器
 */

public static void openSoftKeyboard(Context context, EditText editText) 
{
    InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    inputMethodManager.showSoftInput(editText, InputMethodManager.SHOW_FORCED);
}   ",253,True
"/**
 *打开相册
 * @param requestcode  响应码
 * @param activity  上下文
 */
public static void toTakePicture(int requestcode, Activity activity){
    Intent intent = new Intent(Intent.ACTION_PICK, null);
    intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            ""image/*"");
    activity.startActivityForResult(intent, requestcode);
}","/**
 *打开相册
 * @param requestcode  响应码
 * @param activity  上下文
 */
public static void toTakePicture(int requestcode, Activity activity) 
{
    Intent intent = new Intent(Intent.ACTION_PICK, null);
    intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, ""image/*"");
    activity.startActivityForResult(intent, requestcode);
}   ",254,True
"/**
 * 将一个short转换成字节数组
 * @param sh short
 * @return 字节数组
 */
public static byte[] valueOf(short sh){
	byte[] shortBuf = new byte[2];
	for(int i=0;i<2;i++) {
		int offset = (shortBuf.length - 1 -i)*8;
		shortBuf[i] = (byte)((sh>>>offset)&0xff);
	}
	return shortBuf;
}","/**
 * 将一个short转换成字节数组
 * @param sh short
 * @return 字节数组
 */
public static byte[] valueOf(short sh) 
{
	byte[] b = new byte[2];
	b[0] = (byte) (sh >> 8);
	b[1] = (byte) sh;
	return b;
}   ",255,True
"/**
 * 判断隐藏软键盘是否弹出,弹出就隐藏
 * @param mActivity
 * @return
 */
public boolean keyBoxIsShow(Activity mActivity){
    if (mActivity.getWindow().getAttributes().softInputMode == WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        //隐藏软键盘
        mActivity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
        return true;
    }
    else {
        return false;
    }
}","/**
 * 判断隐藏软键盘是否弹出,弹出就隐藏
 * @param mActivity
 * @return
 */




public boolean keyBoxIsShow(Activity mActivity) 
{
    InputMethodManager imm = (InputMethodManager) mActivity.getSystemService(Context.INPUT_METHOD_SERVICE);
    boolean isOpen=imm.isActive();//isOpen��返回true，则表示输入法打开
    if(isOpen)
    {
        imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);//隐藏软键��
    }
    return isOpen;
}   ",256,True
"/**
 * 判断是否为连击
 *
 * @return  boolean
 */
public static boolean isFastDoubleClick(){
    long time = System.currentTimeMillis();
    long timeD = time - lastClickTime;
    if (0 < timeD && timeD < 500) {
        return true;
    }
    lastClickTime = time;
    return false;
}","/**
 * 判断是否为连击
 *
 * @return  boolean
 */
public static boolean isFastDoubleClick() 
{
    long now = System.currentTimeMillis();
    if (now - lastClickTime < 500)
    {
        return true;
    }
    lastClickTime = now;
    return false;
}   ",257,True
"/**
 * 从一个 UU64 恢复回一个 UUID 对象
 * 
 * @param uu64
 *            64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
 * @return UUID 对象
 */
public static java.util.UUID fromUU64(String uu64){
    String uu16 = UU16FromUU64(uu64);
    return java.util.UUID.fromString(UU(uu16));
}","/**
 * 从一个 UU64 恢复回一个 UUID 对象
 * 
 * @param uu64
 *            64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
 * @return UUID 对象
 */
public static java.util.UUID fromUU64(String uu64) 
{
    if (uu64 == null || uu64.length() != 22)
        return null;

    try
    {
        long mostSigBits = Long.parseLong(uu64.substring(0, 13), 36);
        long leastSigBits = Long.parseLong(uu64.substring(13), 36);

        return new java.util.UUID(mostSigBits, leastSigBits);
    }
    catch (Exception e)
    {
        return null;
    }
}   ",260,False
"/**
 * 返回指定长度随机数字+字母(大小写敏感)组成的字符串
 * 
 * @param length
 *            指定长度
 * @param caseSensitivity
 *            是否区分大小写
 * @return 随机字符串
 */
public static String captchaChar(int length, boolean caseSensitivity){
    StringBuilder sb = new StringBuilder();
    Random rand = new Random();// 随机用以下三个随机生成器
    Random randdata = new Random();
    int data = 0;
    for (int i = 0; i < length; i++) {
        int index = rand.nextInt(caseSensitivity ? 3 : 2);
        // 目的是随机选择生成数字，大小写字母
        switch (index) {
        case 0:
            data = randdata.nextInt(10);// 仅仅会生成0~9, 0~9的ASCII为48~57
            sb.append(data);
            break;
        case 1:
            data = randdata.nextInt(26) + 97;// 保证只会产生ASCII为97~122(a-z)之间的整数,
            sb.append((char) data);
            break;
        case 2: // caseSensitivity为true的时候, 才会有大写字母
            data = randdata.nextInt(26) + 65;// 保证只会产生ASCII为65~90(A~Z)之间的整数
            sb.append((char) data);
            break;
        }
    }
    return sb.toString();
}","/**
 * 返回指定长度随机数字+字母(大小写敏感)组成的字符串
 * 
 * @param length
 *            指定长度
 * @param caseSensitivity
 *            是否区分大小写
 * @return 随机字符串
 */
public static String captchaChar(int length, boolean caseSensitivity) 
{
    String base = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"";
    if (caseSensitivity)
    {
        return RandomStringUtils.random(length, base);
    }
    else
    {
        return RandomStringUtils.random(length, base.toLowerCase());
    }
}   ",261,True
"/**
 * 返回指定长度随机数字组成的字符串
 * 
 * @param length
 *            指定长度
 * @return 随机字符串
 */
public static String captchaNumber(int length){
    StringBuilder sb = new StringBuilder();
    Random rand = new Random();
    for (int i = 0; i < length; i++) {
        sb.append(rand.nextInt(10));
    }
    return sb.toString();
}","/**
 * 返回指定长度随机数字组成的字符串
 * 
 * @param length
 *            指定长度
 * @return 随机字符串
 */
public static String captchaNumber(int length) 
{
    StringBuilder sb = new StringBuilder();
    Random random = new Random();
    for (int i = 0; i < length; i++)
    {
        sb.append(random.nextInt(10));
    }
    return sb.toString();
}   ",262,True
"/**
 * 格式化unix时间戳为日期
 *
 * @param unixTime
 * @param patten
 * @return
 */
public static String fmtdate(Integer unixTime, String patten){
    if (null != unixTime && StringUtils.isNotBlank(patten)) {
        return DateKit.formatDateByUnixTime(unixTime, patten);
    }
    return """";
}","/**
 * 格式化unix时间戳为日期
 *
 * @param unixTime
 * @param patten
 * @return
 */

public static String fmtdate(Integer unixTime, String patten) 
{
    if (unixTime.toString().length() == 10)
    {
        unixTime = unixTime * 1000;
    }
    return fmtdate(unixTime.longValue(), patten);
}   ",264,True
"/**
 * 返回github头像地址
 *
 * @param email
 * @return
 */
public static String gravatar(String email){
    String avatarUrl = ""https://github.com/identicons/"";
    if (StringUtils.isBlank(email)) {
        email = ""user@hanshuai.xin"";
    }
    String hash = TaleUtils.MD5encode(email.trim().toLowerCase());
    return avatarUrl + hash + "".png"";
}","/**
 * 返回github头像地址
 *
 * @param email
 * @return
 */
public static String gravatar(String email) 
{
    String hash = DigestUtils.md5Hex(email.toLowerCase());
    return ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"" + hash + ""?s=80&d=identicon"";
}   ",265,True
"/**
 * 获取blog页面需要的公共数据
 * @param request
 * @return
 */
public BaseController blogBaseData(HttpServletRequest request, ContentCond contentCond){
//        List<MetaDto> categories = metaService.getMetaList(Types.CATEGORY.getType(), null, WebConst.MAX_POSTS);
//        List<MetaDto> tags = metaService.getMetaList(Types.TAG.getType(), null, WebConst.MAX_POSTS);
    List<MetaDto> links = metaService.getMetaList(Types.LINK.getType(), null,WebConst.MAX_POSTS);
//        request.setAttribute(""categories"", categories);//分类
//        request.setAttribute(""tags"", tags);//标签
    request.setAttribute(""links"", links);
//        PageInfo<ContentDomain> recentlyArticles = contentService.getRecentlyArticle(1, 10);
//        ContentCond cond = new ContentCond();
//        cond.setType(contentCond.getType());
//        request.setAttribute(""recentlyArticles"", recentlyArticles);
//        List<ArchiveDto> archives = siteService.getArchivesSimple(cond);
//        request.setAttribute(""archives"", archives);//归档数据

    return this;
}","/**
 * 获取blog页面需要的公共数据
 * @param request
 * @return
 */
public BaseController blogBaseData(HttpServletRequest request, ContentCond contentCond) 
{
    request.setAttribute(""webTitle"", ""��客"");
    request.setAttribute(""keywords"", ""��客"");
    request.setAttribute(""description"", ""��客"");
    List<Content> list = contentService.queryContentTopN(contentCond);
    request.setAttribute(""contentList"", list);
    return this;
}   ",266,False
"/**
 * 网站配置项
 *
 * @param key
 * @param defalutValue 默认值
 * @return
 */
public static String site_option(String key, String defalutValue){
    if (StringUtils.isBlank(key)) {
        return """";
    }
    String str = WebConst.initConfig.get(key);
    if (StringUtils.isNotBlank(str)) {
        return str;
    } else {
        return defalutValue;
    }
}","/**
 * 网站配置项
 *
 * @param key
 * @param defalutValue 默认值
 * @return
 */
public static String site_option(String key, String defalutValue) 
{
    String value = (String) site_options.get(key);
    if (value == null)
    {
        return defalutValue;
    }
    return value;
}   ",268,True
"/**
 * 获取社交的链接地址
 *
 * @return
 */
public static Map<String, String> social(){
    final String prefix = ""social_"";
    Map<String, String> map = new HashMap<>();
    map.put(""csdn"", WebConst.initConfig.get(prefix + ""csdn""));
    map.put(""jianshu"", WebConst.initConfig.get(prefix + ""jianshu""));
    map.put(""resume"", WebConst.initConfig.get(prefix + ""resume""));
    map.put(""weibo"", WebConst.initConfig.get(prefix + ""weibo""));
    map.put(""zhihu"", WebConst.initConfig.get(prefix + ""zhihu""));
    map.put(""github"", WebConst.initConfig.get(prefix + ""github""));
    map.put(""twitter"", WebConst.initConfig.get(prefix + ""twitter""));
    return map;
}","/**
 * 获取社交的链接地址
 *
 * @return
 */

public static Map<String, String> social() 
{
    Map<String, String> map = new HashMap<>(3);
    map.put(""qq"", ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"");
    map.put(""weibo"", ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"");
    map.put(""douban"", ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"");
    return map;
}   ",270,False
"/**
 * 显示文章内容，转换markdown为html
 *
 * @param value
 * @return
 */
public static String article(String value){
    if (StringUtils.isNotBlank(value)) {
        value = value.replace(""<!--more-->"", ""\r\n"");
        value = value.replace(""<!-- more -->"", ""\r\n"");
        return TaleUtils.mdToHtml(value);
    }
    return """";
}","/**
 * 显示文章内容，转换markdown为html
 *
 * @param value
 * @return
 */
public static String article(String value) 
{
    if (null == value)
    {
        return """";
    }
    String html = MarkdownUtils.markdownToHtmlExtensions(value);
    return html;
}   ",271,False
"/**
 * 获取文章第一张图片
 *
 * @return
 */
public static String show_thumb(String content){
    content = TaleUtils.mdToHtml(content);
    if (content.contains(""<img"")) {
        String img = """";
        String regEx_img = ""<img.*src\\s*=\\s*(.*?)[^>]*?>"";
        Pattern p_image = Pattern.compile(regEx_img, Pattern.CASE_INSENSITIVE);
        Matcher m_image = p_image.matcher(content);
        if (m_image.find()) {
            img = img + "","" + m_image.group();
            // //匹配src
            Matcher m = Pattern.compile(""src\\s*=\\s*\'?\""?(.*?)(\'|\""|>|\\s+)"").matcher(img);
            if (m.find()) {
                return m.group(1);
            }
        }
    }
    return """";
}","/**
 * 获取文章第一张图片
 *
 * @return
 */

public static String show_thumb(String content) 
{
    String str = """";
    String regex = ""<img.*?src=[\""|\'](.*?)[\""|\']"";
    Pattern pa = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
    Matcher ma = pa.matcher(content);
    if (ma.find())
    {
        str = ma.group(1);
    }
    return str;
}   ",272,True
"/**
 * 将中文的yyyy年MM月 - > yyyy
 * @param date
 * @return
 */
public static String parsedate_zh_y_m(String date){
    if (StringUtils.isNotBlank(date)){
        Date d = DateKit.dateFormat(date, ""yyyy年MM月"");
        return DateKit.dateFormat(d, ""yyyy"");
    }
    return null;
}","/**
 * 将中文的yyyy年MM月 - > yyyy
 * @param date
 * @return
 */
public static String parsedate_zh_y_m(String date) 
{
    if(date.contains(""年"") && date.contains(""月""))
    {
        date = date.replace(""年"", ""-"").replace(""月"", """");
    }
    return date;
}   ",273,True
"/**
 * 数组转字符串
 *
 * @param arr
 * @return
 */
public String join(String[] arr){
    StringBuilder ret = new StringBuilder();
    String[] var3 = arr;
    int var4 = arr.length;

    for (int var5 = 0; var5 < var4; ++var5) {
        String item = var3[var5];
        ret.append(',').append(item);
    }

    return ret.length() > 0 ? ret.substring(1) : ret.toString();
}","/**
 * 数组转字符串
 *
 * @param arr
 * @return
 */
public String join(String[] arr) 
{
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < arr.length; i++)
    {
        sb.append(arr[i]);
    }
    return sb.toString();
}   ",276,True
"/**
 * 将一个 UU64 表示的紧凑字符串，变成 UU16 表示的字符串
 * 
 * <pre>
 * 每次取2个字符，恢复成3个byte，重复10次， 最后一次，是用最后2个字符，恢复回2个byte </prev>
 * 
 * @param uu64
 *            uu64 64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
 * @return 16进制表示的紧凑格式的 UUID
 */
public static String UU16FromUU64(String uu64){
    byte[] bytes = new byte[32];
    char[] cs = uu64.toCharArray();
    int index = 0;
    // 每次取2个字符，恢复成3个byte，重复10次，
    for (int i = 0; i < 10; i++) {
        int off = i * 2;
        char cl = cs[off];
        char cr = cs[off + 1];
        int l = Arrays.binarySearch(_UU64, cl);
        int r = Arrays.binarySearch(_UU64, cr);
        int n = (l << 6) | r;
        bytes[index++] = (byte) ((n & 0xF00) >>> 8);
        bytes[index++] = (byte) ((n & 0xF0) >>> 4);
        bytes[index++] = (byte) (n & 0xF);
    }
    // 最后一次，是用最后2个字符，恢复回2个byte
    char cl = cs[20];
    char cr = cs[21];
    int l = Arrays.binarySearch(_UU64, cl);
    int r = Arrays.binarySearch(_UU64, cr);
    int n = (l << 2) | r;
    bytes[index++] = (byte) ((n & 0xF0) >>> 4);
    bytes[index++] = (byte) (n & 0xF);

    // 返回 UUID 对象
    char[] names = new char[32];
    for (int i = 0; i < bytes.length; i++)
        names[i] = _UU16[bytes[i]];
    return new String(names);
}","/**
 * 将一个 UU64 表示的紧凑字符串，变成 UU16 表示的字符串
 * 
 * <pre>
 * 每次取2个字符，恢复成3个byte，重复10次， 最后一次，是用最后2个字符，恢复回2个byte </prev>
 * 
 * @param uu64
 *            uu64 64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
 * @return 16进制表示的紧凑格式的 UUID
 */
public static String UU16FromUU64(String uu64) 
{
    if (uu64 == null || uu64.length() != 22)
        return null;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10; i++)
    {
        int index = i * 2;
        String hex = uu64.substring(index, index + 2);
        sb.append((char) Integer.parseInt(hex, 16));
    }
    String hex = uu64.substring(20);
    if (hex.length() == 2)
    {
        sb.append((char) Integer.parseInt(hex, 16));
    }
    else
    {
        sb.append((char) Integer.parseInt(hex.substring(0, 2), 16));
        sb.append((char) Integer.parseInt(hex.substring(2), 16));
    }
    return sb.toString();
}   ",278,False
"/**
 * Produce a JSONObject by combining a JSONArray of names with the values of
 * this JSONArray.
 *
 * @param names
 *            A JSONArray containing a list of key strings. These will be
 *            paired with the values.
 * @return A JSONObject, or null if there are no names or if this JSONArray
 *         has no values.
 * @throws JSONException
 *             If any of the names are null.
 */
public JSONObject toJSONObject(JSONArray names) throws JSONException{
    if (names == null || names.length() == 0 || this.length() == 0) {
        return null;
    }
    JSONObject jo = new JSONObject();
    for (int i = 0; i < names.length(); i += 1) {
        jo.put(names.getString(i), this.opt(i));
    }
    return jo;
}","/**
 * Produce a JSONObject by combining a JSONArray of names with the values of
 * this JSONArray.
 *
 * @param names
 *            A JSONArray containing a list of key strings. These will be
 *            paired with the values.
 * @return A JSONObject, or null if there are no names or if this JSONArray
 *         has no values.
 * @throws JSONException
 *             If any of the names are null.
 */
public JSONObject toJSONObject(JSONArray names) throws JSONException 
{
    if (names == null || names.length() == 0 || this.length() == 0)
    {
        return null;
    }
    JSONObject jo = new JSONObject();
    for (int i = 0; i < names.length(); i++)
    {
        jo.put(names.getString(i), this.opt(i));
    }
    return jo;
}   ",280,True
"/**
 * Get the int value associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The value.
 * @throws JSONException
 *             If the key is not found or if the value is not a number.
 */
public int getInt(int index) throws JSONException{
    Object object = this.get(index);
    try {
        return object instanceof Number ? ((Number) object).intValue()
                : Integer.parseInt((String) object);
    } catch (Exception e) {
        throw new JSONException(""JSONArray["" + index + ""] is not a number."");
    }
}","/**
 * Get the int value associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The value.
 * @throws JSONException
 *             If the key is not found or if the value is not a number.
 */
public int getInt(int index) throws JSONException 
{
    Object object = get(index);
    try
    {
        return object instanceof Number ? ((Number) object).intValue() : Integer.parseInt((String) object);
    }
    catch (Exception e)
    {
        throw new JSONException(""JSONObject["" + index + ""] is not a number."");
    }
}   ",283,True
"/**
 * Put a value in the JSONArray, where the value will be a JSONArray which
 * is produced from a Collection.
 *
 * @param value
 *            A Collection value.
 * @return this.
 */
public JSONArray put(Collection<Object> value){
    this.put(new JSONArray(value));
    return this;
}","/**
 * Put a value in the JSONArray, where the value will be a JSONArray which
 * is produced from a Collection.
 *
 * @param value
 *            A Collection value.
 * @return this.
 */
public JSONArray put(Collection<Object> value) 
{
    JSONArray jsonArray = new JSONArray();
    for (Object o : value)
    {
        jsonArray.put(o);
    }
    return this.put(jsonArray);
}   ",284,True
"/**
 * Put a value in the JSONArray, where the value will be a JSONObject which
 * is produced from a Map.
 *
 * @param value
 *            A Map value.
 * @return this.
 */
public JSONArray put(Map<String, Object> value){
    this.put(new JSONObject(value));
    return this;
}","/**
 * Put a value in the JSONArray, where the value will be a JSONObject which
 * is produced from a Map.
 *
 * @param value
 *            A Map value.
 * @return this.
 */
public JSONArray put(Map<String, Object> value) 
{
    JSONObject jo = new JSONObject(value);
    JSONArray.put(jo);
    return this;
}   ",288,True
"/**
 * Append an object value. This increases the array's length by one.
 *
 * @param value
 *            An object value. The value should be a Boolean, Double,
 *            Integer, JSONArray, JSONObject, Long, or String, or the
 *            JSONObject.NULL object.
 * @return this.
 */
public JSONArray put(Object value){
    this.myArrayList.add(value);
    return this;
}","/**
 * Append an object value. This increases the array's length by one.
 *
 * @param value
 *            An object value. The value should be a Boolean, Double,
 *            Integer, JSONArray, JSONObject, Long, or String, or the
 *            JSONObject.NULL object.
 * @return this.
 */
public JSONArray put(Object value) 
{
    JSONObject.testValidity(value);
    this.myArrayList.add(value);
    return this;
}   ",289,True
"/**
 * Construct a JSONArray from a Collection.
 *
 * @param collection
 *            A Collection.
 */
public JSONArray(Collection<Object> collection){
    this.myArrayList = new ArrayList<Object>();
    if (collection != null) {
        Iterator<Object> iter = collection.iterator();
        while (iter.hasNext()) {
            this.myArrayList.add(JSONObject.wrap(iter.next()));
        }
    }
}","/**
 * Construct a JSONArray from a Collection.
 *
 * @param collection
 *            A Collection.
 */
public JSONArray(Collection<Object> collection) 
{
    if (collection == null)
    {
        throw new NullPointerException(""Collection must not be null."");
    }
    this.collection = collection;
}   ",290,False
"/**
 * Get the long value associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The value.
 * @throws JSONException
 *             If the key is not found or if the value cannot be converted
 *             to a number.
 */
public long getLong(int index) throws JSONException{
    Object object = this.get(index);
    try {
        return object instanceof Number ? ((Number) object).longValue()
                : Long.parseLong((String) object);
    } catch (Exception e) {
        throw new JSONException(""JSONArray["" + index + ""] is not a number."");
    }
}","/**
 * Get the long value associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The value.
 * @throws JSONException
 *             If the key is not found or if the value cannot be converted
 *             to a number.
 */

public long getLong(int index) throws JSONException 
{
    Object object = get(index);
    try
    {
        return object instanceof Number ? ((Number) object).longValue()
                : Long.parseLong((String) object);
    }
    catch (Exception e)
    {
        throw new JSONException(""JSONObject["" + index + ""] is not a number."");
    }
}   ",291,True
"/**
 * Get the string associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return A string value.
 * @throws JSONException
 *             If there is no string value for the index.
 */
public String getString(int index) throws JSONException{
    Object object = this.get(index);
    if (object instanceof String) {
        return (String) object;
    }
    throw new JSONException(""JSONArray["" + index + ""] not a string."");
}","/**
 * Get the string associated with an index.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return A string value.
 * @throws JSONException
 *             If there is no string value for the index.
 */

public String getString(int index) throws JSONException 
{
    Object object = get(index);
    if (object == JSONObject.NULL)
    {
        throw new JSONException(""JSONObject["" + index + ""] is null."");
    }
    return object.toString();
}   ",293,True
"/**
 * 转成驼峰
 *
 * @param text
 * @return
 */
public static String captureStringLeaveUnderscore(String text){
    if (TextUtils.isEmpty(text)) {
        return text;
    }
    String temp = text.replaceAll(""^_+"", """");

    if (!TextUtils.isEmpty(temp)) {
        text = temp;
    }
    String[] strings = text.split(""_"");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(strings[0]);
    for (int i = 1; i < strings.length; i++) {
        stringBuilder.append(captureName(strings[i]));
    }
    return stringBuilder.toString();
}","/**
 * 转成驼峰
 *
 * @param text
 * @return
 */
public static String captureStringLeaveUnderscore(String text) 
{
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < text.length(); i++)
    {
        char c = text.charAt(i);
        if (Character.isUpperCase(c))
        {
            sb.append(""_"");
            sb.append(Character.toLowerCase(c));
        } else
        {
            sb.append(c);
        }
    }
    return sb.toString();
}   ",294,True
"/**
 * Get the boolean value associated with an index. The string values ""true""
 * and ""false"" are converted to boolean.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The truth.
 * @throws JSONException
 *             If there is no value for the index or if the value is not
 *             convertible to boolean.
 */
public boolean getBoolean(int index) throws JSONException{
    Object object = this.get(index);
    if (object.equals(Boolean.FALSE)
            || (object instanceof String && ((String) object)
                    .equalsIgnoreCase(""false""))) {
        return false;
    } else if (object.equals(Boolean.TRUE)
            || (object instanceof String && ((String) object)
                    .equalsIgnoreCase(""true""))) {
        return true;
    }
    throw new JSONException(""JSONArray["" + index + ""] is not a boolean."");
}","/**
 * Get the boolean value associated with an index. The string values ""true""
 * and ""false"" are converted to boolean.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @return The truth.
 * @throws JSONException
 *             If there is no value for the index or if the value is not
 *             convertible to boolean.
 */

public boolean getBoolean(int index) throws JSONException 
{
    Object object = get(index);
    if (object.equals(Boolean.FALSE)
            || (object instanceof String && ((String) object)
                    .equalsIgnoreCase(""false"")))
    {
        return false;
    } else if (object.equals(Boolean.TRUE)
            || (object instanceof String && ((String) object)
                    .equalsIgnoreCase(""true"")))
    {
        return true;
    }
    throw new JSONException(""JSONObject["" + index + ""] is not a Boolean."");
}   ",298,True
"/**
 * Get the optional int value associated with an index. The defaultValue is
 * returned if there is no value for the index, or if the value is not a
 * number and cannot be converted to a number.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @param defaultValue
 *            The default value.
 * @return The value.
 */
public int optInt(int index, int defaultValue){
    try {
        return this.getInt(index);
    } catch (Exception e) {
        return defaultValue;
    }
}","/**
 * Get the optional int value associated with an index. The defaultValue is
 * returned if there is no value for the index, or if the value is not a
 * number and cannot be converted to a number.
 *
 * @param index
 *            The index must be between 0 and length() - 1.
 * @param defaultValue
 *            The default value.
 * @return The value.
 */
public int optInt(int index, int defaultValue) 
{
    try
    {
        return getInt(index);
    }
    catch (Exception e)
    {
        return defaultValue;
    }
}   ",299,True
"/**
 * Set the minimum length of the formatted string. If this is not set
 * the default is to allow any length.
 * @param minimumLength of the formatted string
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> minimumLength(int minimumLength){
	this.minimumLength = minimumLength;
	return this;
}","/**
 * Set the minimum length of the formatted string. If this is not set
 * the default is to allow any length.
 * @param minimumLength of the formatted string
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> minimumLength(int minimumLength) 
{
    this.minimumLength = minimumLength;
    return this;
}   ",300,True
"/**
 * If set to true, once the step is complete, if the resource previously provided is
 * empty, it will be deleted.
 *
 * @param shouldDelete defaults to false
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setShouldDeleteIfEmpty(boolean)
 */
public FlatFileItemWriterBuilder<T> shouldDeleteIfEmpty(boolean shouldDelete){
	this.shouldDeleteIfEmpty = shouldDelete;

	return this;
}","/**
 * If set to true, once the step is complete, if the resource previously provided is
 * empty, it will be deleted.
 *
 * @param shouldDelete defaults to false
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setShouldDeleteIfEmpty(boolean)
 */
public FlatFileItemWriterBuilder<T> shouldDeleteIfEmpty(boolean shouldDelete) 
{
    this.shouldDeleteIfEmpty = shouldDelete;
    return this;
}   ",301,True
"/**
 * Set the maximum length of the formatted string. If this is not set
 * the default is to allow any length.
 * @param maximumLength of the formatted string
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> maximumLength(int maximumLength){
	this.maximumLength = maximumLength;
	return this;
}","/**
 * Set the maximum length of the formatted string. If this is not set
 * the default is to allow any length.
 * @param maximumLength of the formatted string
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> maximumLength(int maximumLength) 
{
    this.maximumLength = maximumLength;
    return this;
}   ",303,True
"/**
 * The name used to calculate the key within the
 * {@link org.springframework.batch.item.ExecutionContext}. Required if
 * {@link #saveState(boolean)} is set to true.
 *
 * @param name name of the reader instance
 * @return The current instance of the builder.
 * @see org.springframework.batch.item.ItemStreamSupport#setName(String)
 */
public FlatFileItemWriterBuilder<T> name(String name){
	this.name = name;

	return this;
}","/**
 * The name used to calculate the key within the
 * {@link org.springframework.batch.item.ExecutionContext}. Required if
 * {@link #saveState(boolean)} is set to true.
 *
 * @param name name of the reader instance
 * @return The current instance of the builder.
 * @see org.springframework.batch.item.ItemStreamSupport#setName(String)
 */
public FlatFileItemWriterBuilder<T> name(String name) 
{
    this.name = name;
    return this;
}   ",304,True
"/**
 * The {@link Resource} to be used as output.
 *
 * @param resource the output of the writer.
 * @return The current instance of the builder.
 * @see FlatFileItemWriter#setResource(Resource)
 */
public FlatFileItemWriterBuilder<T> resource(Resource resource){
	this.resource = resource;

	return this;
}","/**
 * The {@link Resource} to be used as output.
 *
 * @param resource the output of the writer.
 * @return The current instance of the builder.
 * @see FlatFileItemWriter#setResource(Resource)
 */
public FlatFileItemWriterBuilder<T> resource(Resource resource) 
{
    this.resource = resource;
    return this;
}   ",305,True
"/**
 * Set the format string used to aggregate items
 * @param format used to aggregate items
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> format(String format){
	this.format = format;
	return this;
}","/**
 * Set the format string used to aggregate items
 * @param format used to aggregate items
 * @return The instance of the builder for chaining.
 */
public FormattedBuilder<T> format(String format) 
{
    this.format = format;
    return this;
}   ",307,True
"/**
 * If set to true, the flushing of the buffer is delayed while a transaction is active.
 *
 * @param transactional defaults to true
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setTransactional(boolean)
 */
public FlatFileItemWriterBuilder<T> transactional(boolean transactional){
	this.transactional = transactional;

	return this;
}","/**
 * If set to true, the flushing of the buffer is delayed while a transaction is active.
 *
 * @param transactional defaults to true
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setTransactional(boolean)
 */
public FlatFileItemWriterBuilder<T> transactional(boolean transactional) 
{
    this.transactional = transactional;
    return this;
}   ",310,True
"/**
 * If set to true and the file exists, the output will be appended to the existing
 * file.
 *
 * @param append defaults to false
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setAppendAllowed(boolean)
 */
public FlatFileItemWriterBuilder<T> append(boolean append){
	this.append = append;

	return this;
}","/**
 * If set to true and the file exists, the output will be appended to the existing
 * file.
 *
 * @param append defaults to false
 * @return The current instance of the builder
 * @see FlatFileItemWriter#setAppendAllowed(boolean)
 */
public FlatFileItemWriterBuilder<T> append(boolean append) 
{
    this.append = append;
    return this;
}   ",314,True
"/**
 * Returns an instance of a {@link FormattedBuilder} for building a
 * {@link FormatterLineAggregator}. The {@link FormatterLineAggregator} configured by
 * this builder will only be used if one is not explicitly configured via
 * {@link FlatFileItemWriterBuilder#lineAggregator}
 *
 * @return a {@link FormattedBuilder}
 *
 */
public FormattedBuilder<T> formatted(){
	this.formattedBuilder = new FormattedBuilder<>(this);
	return this.formattedBuilder;
}","/**
 * Returns an instance of a {@link FormattedBuilder} for building a
 * {@link FormatterLineAggregator}. The {@link FormatterLineAggregator} configured by
 * this builder will only be used if one is not explicitly configured via
 * {@link FlatFileItemWriterBuilder#lineAggregator}
 *
 * @return a {@link FormattedBuilder}
 *
 */
public FormattedBuilder<T> formatted() 
{
    return new FormattedBuilder<>(this);
}   ",315,True
"/**
 * Set the {@link FieldExtractor} to use to extract fields from each item.
 * @param fieldExtractor to use to extract fields from each item
 * @return The parent {@link FlatFileItemWriterBuilder}
 */
public FlatFileItemWriterBuilder<T> fieldExtractor(FieldExtractor<T> fieldExtractor){
	this.fieldExtractor = fieldExtractor;
	return this.parent;
}","/**
 * Set the {@link FieldExtractor} to use to extract fields from each item.
 * @param fieldExtractor to use to extract fields from each item
 * @return The parent {@link FlatFileItemWriterBuilder}
 */
public FlatFileItemWriterBuilder<T> fieldExtractor(FieldExtractor<T> fieldExtractor) 
{
    this.fieldExtractor = fieldExtractor;
    return this;
}   ",316,True
"/**
 * Returns an instance of a {@link DelimitedBuilder} for building a
 * {@link DelimitedLineAggregator}. The {@link DelimitedLineAggregator} configured by
 * this builder will only be used if one is not explicitly configured via
 * {@link FlatFileItemWriterBuilder#lineAggregator}
 *
 * @return a {@link DelimitedBuilder}
 *
 */
public DelimitedBuilder<T> delimited(){
	this.delimitedBuilder = new DelimitedBuilder<>(this);
	return this.delimitedBuilder;
}","/**
 * Returns an instance of a {@link DelimitedBuilder} for building a
 * {@link DelimitedLineAggregator}. The {@link DelimitedLineAggregator} configured by
 * this builder will only be used if one is not explicitly configured via
 * {@link FlatFileItemWriterBuilder#lineAggregator}
 *
 * @return a {@link DelimitedBuilder}
 *
 */
public DelimitedBuilder<T> delimited() 
{
    DelimitedBuilder<T> builder = new DelimitedBuilder<T>();
    builder.setName(""delimitedWriter"");
    return builder;
}   ",317,True
"/**
 * Define the delimiter for the file.
 *
 * @param delimiter String used as a delimiter between fields.
 * @return The instance of the builder for chaining.
 * @see DelimitedLineAggregator#setDelimiter(String)
 */
public DelimitedBuilder<T> delimiter(String delimiter){
	this.delimiter = delimiter;
	return this;
}","/**
 * Define the delimiter for the file.
 *
 * @param delimiter String used as a delimiter between fields.
 * @return The instance of the builder for chaining.
 * @see DelimitedLineAggregator#setDelimiter(String)
 */
public DelimitedBuilder<T> delimiter(String delimiter) 
{
    this.delimitedLineAggregator.setDelimiter(delimiter);
    return this;
}   ",319,True
"/**
 * Constructs a new Region object to be used for Ranging or Monitoring
 * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
 * @param identifiers - list of identifiers for this region
 * @param bluetoothAddress - mac address
 */
public Region(String uniqueId, List<Identifier> identifiers, String bluetoothAddress){
    validateMac(bluetoothAddress);
    this.mIdentifiers = new ArrayList<Identifier>(identifiers);
    this.mUniqueId = uniqueId;
    this.mBluetoothAddress = bluetoothAddress;
    if (uniqueId == null) {
        throw new NullPointerException(""uniqueId may not be null"");
    }
}","/**
 * Constructs a new Region object to be used for Ranging or Monitoring
 * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
 * @param identifiers - list of identifiers for this region
 * @param bluetoothAddress - mac address
 */
public Region(String uniqueId, List<Identifier> identifiers, String bluetoothAddress) 
{
    this.uniqueId = uniqueId;
    this.identifiers = identifiers;
    this.bluetoothAddress = bluetoothAddress;
}   ",320,True
"/**
 * When binding to the service, we return an interface to our messenger
 * for sending messages to the service.
 */
@Override
public IBinder onBind(Intent intent){
    LogManager.i(TAG, ""binding"");
    return mMessenger.getBinder();
}","/**
 * When binding to the service, we return an interface to our messenger
 * for sending messages to the service.
 */
@Override
public IBinder onBind(Intent intent) 
{
    return messenger.getBinder();
}   ",323,True
"/**
 * Method reserved for system use
 */
@Override
public boolean bindService(Intent intent, ServiceConnection conn, int arg2){
    this.serviceIntent = intent;
    context.startService(intent);
    return context.bindService(intent, conn, arg2);

}","/**
 * Method reserved for system use
 */
@Override
public boolean bindService(Intent intent, ServiceConnection conn, int arg2) 
{
    if (intent == null || conn == null)
    {
        return false;
    }
    return super.bindService(intent, conn, arg2);
}   ",324,True
"//kept here for backward compatibility
public static void setSampleExpirationMilliseconds(long milliseconds){
    sampleExpirationMilliseconds = milliseconds;
    RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
}","//kept here for backward compatibility
public static void setSampleExpirationMilliseconds(long milliseconds) 
{
    if (milliseconds < 0)
    {
        throw new IllegalArgumentException(""milliseconds must be non-negative"");
    }
    sampleExpirationMilliseconds = milliseconds;
}   ",327,True
"// utilty methods for testing serialization
private byte[] convertToBytes(Object object) throws IOException{
    try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
         ObjectOutputStream out = new ObjectOutputStream(bos)) {
        out.writeObject(object);
        return bos.toByteArray();
    }
}","// utilty methods for testing serialization

private byte[] convertToBytes(Object object) throws IOException 
{
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(object);
    oos.flush();
    return baos.toByteArray();
}   ",329,True
"// called when the last bound client calls unbind
@Override
public boolean onUnbind(Intent intent){
    LogManager.i(TAG, ""unbinding so destroying self"");
    this.stopForeground(true);
    this.stopSelf();
    return false;
}","// called when the last bound client calls unbind
@Override
public boolean onUnbind(Intent intent) 
{
    if (mBinder != null)
    {
        mBinder.removeCallback(mCallback);
        mBinder = null;
    }
    return super.onUnbind(intent);
}   ",331,False
"/**
 * Used to disable additional bootstrap callbacks after the first is received.  Unless this is called,
 * your application will be get additional calls as the supplied regions are entered or exited.
 */
public void disable(){
    if (disabled) {
        return;
    }
    disabled = true;
    try {
        for (Region region : regions) {
            beaconManager.stopMonitoringBeaconsInRegion(region);
        }
    } catch (RemoteException e) {
        LogManager.e(e, TAG, ""Can't stop bootstrap regions"");
    }
    beaconManager.unbind(beaconConsumer);
}","/**
 * Used to disable additional bootstrap callbacks after the first is received.  Unless this is called,
 * your application will be get additional calls as the supplied regions are entered or exited.
 */
public void disable() 
{
    if (disabled)
    {
        return;
    }
    disabled = true;
    if (callbacks != null)
    {
        callbacks.disable();
    }
}   ",332,False
"/**
 * Constructor to bootstrap your Application on an entry/exit from a single region.
 *
 * @param application
 * @param region
 */
public RegionBootstrap(BootstrapNotifier application, Region region){
    if (application.getApplicationContext() == null) {
        throw new NullPointerException(""The BootstrapNotifier instance is returning null from its getApplicationContext() method.  Have you implemented this method?"");
    }
    this.context = application.getApplicationContext();
    regions = new ArrayList<Region>();
    regions.add(region);
    this.monitorNotifier = application;
    beaconManager = BeaconManager.getInstanceForApplication(context);
    beaconConsumer = new InternalBeaconConsumer();
    if (beaconManager.isBackgroundModeUninitialized()) {
        beaconManager.setBackgroundMode(true);
    }
    beaconManager.bind(beaconConsumer);
    LogManager.d(TAG, ""Waiting for BeaconService connection"");
}","/**
 * Constructor to bootstrap your Application on an entry/exit from a single region.
 *
 * @param application
 * @param region
 */
public RegionBootstrap(BootstrapNotifier application, Region region) 
{
    this.application = application;
    this.region = region;
}   ",333,False
"/*
 * This starts the scanning service as a foreground service if it is so configured in the
 * manifest
 */
private void startForegroundIfConfigured(){
    BeaconManager beaconManager = BeaconManager.getInstanceForApplication(
            this.getApplicationContext());
    Notification notification = beaconManager
            .getForegroundServiceNotification();
    int notificationId = beaconManager
            .getForegroundServiceNotificationId();
    if (notification != null &&
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
        this.startForeground(notificationId, notification);
    }
}","/*
 * This starts the scanning service as a foreground service if it is so configured in the
 * manifest
 */
private void startForegroundIfConfigured() 
{
    if (this.foregroundServiceConfigured)
    {
        Log.i(TAG, ""Starting foreground service"");
        startForeground(ForegroundServiceNotification.NOTIFICATION_ID, ForegroundServiceNotification.buildNotification(this));
    }
}   ",335,True
"/**
 * Obtains the best possible <code>DistanceCalculator</code> for the Android device passed
 * as an argument
 */
public ModelSpecificDistanceCalculator(Context context, String remoteUpdateUrlString, AndroidModel model){
    mRequestedModel = model;
    mRemoteUpdateUrlString = remoteUpdateUrlString;
    mContext = context;
    loadModelMap();
    mDistanceCalculator = findCalculatorForModelWithLock(model);
}","/**
 * Obtains the best possible <code>DistanceCalculator</code> for the Android device passed
 * as an argument
 */
public ModelSpecificDistanceCalculator(Context context, String remoteUpdateUrlString, AndroidModel model) 
{
    if (model.isTablet())
    {
        return new TabletDistanceCalculator(context, remoteUpdateUrlString);
    }
    else
    {
        return new PhoneDistanceCalculator(context, remoteUpdateUrlString);
    }
}   ",336,False
"/**
 * Constructs a new Region object to be used for Ranging or Monitoring
 * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
 * @param id1 - most significant identifier (can be null)
 * @param id2 - second most significant identifier (can be null)
 * @param id3 - third most significant identifier (can be null)
 */
public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3){
    this.mIdentifiers = new ArrayList<Identifier>(3);
    this.mIdentifiers.add(id1);
    this.mIdentifiers.add(id2);
    this.mIdentifiers.add(id3);
    this.mUniqueId = uniqueId;
    this.mBluetoothAddress = null;
    if (uniqueId == null) {
        throw new NullPointerException(""uniqueId may not be null"");
    }
}","/**
 * Constructs a new Region object to be used for Ranging or Monitoring
 * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
 * @param id1 - most significant identifier (can be null)
 * @param id2 - second most significant identifier (can be null)
 * @param id3 - third most significant identifier (can be null)
 */
public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) 
{
    this.uniqueId = uniqueId;
    this.id1 = id1;
    this.id2 = id2;
    this.id3 = id3;
}   ",338,True
"/**
 * URLs to test:
 * <p/>
 * http://www.radiusnetworks.com
 * https://www.radiusnetworks.com
 * http://radiusnetworks.com
 * https://radiusnetworks.com
 * https://radiusnetworks.com/
 * https://radiusnetworks.com/v1/index.html
 * https://api.v1.radiusnetworks.com
 * https://www.api.v1.radiusnetworks.com
 */
@Test
public void testCompressURL() throws MalformedURLException{
    String testURL = ""http://www.radiusnetworks.com"";
    byte[] expectedBytes = {0x00, 'r', 'a', 'd', 'i', 'u', 's', 'n', 'e', 't', 'w', 'o', 'r', 'k', 's', 0x07};
    assertTrue(Arrays.equals(expectedBytes, UrlBeaconUrlCompressor.compress(testURL)));
}","/**
 * URLs to test:
 * <p/>
 * http://www.radiusnetworks.com
 * https://www.radiusnetworks.com
 * http://radiusnetworks.com
 * https://radiusnetworks.com
 * https://radiusnetworks.com/
 * https://radiusnetworks.com/v1/index.html
 * https://api.v1.radiusnetworks.com
 * https://www.api.v1.radiusnetworks.com
 */
@Test
public void testCompressURL() throws MalformedURLException 
{
    assertEquals(""radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""radiusnetworks.com/v1/index.html"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""api.v1.radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX""));
    assertEquals(""www.api.v1.radiusnetworks.com"", URLUtil.compressURL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX""));
}   ",339,True
"/**
 * Init the fragment
 */
private void initDemoList(View view){
	
	fragmentContainer = view.findViewById(R.id.fragment_container);
	recyclerView = view.findViewById(R.id.fragment_demo_recycler_view);
	recyclerView.setHasFixedSize(true);
	layoutManager = new LinearLayoutManager(getActivity());
	recyclerView.setLayoutManager(layoutManager);
	
	ArrayList<String> itemsData = new ArrayList<>();
	for (int i = 0; i < 50; i++) {
		itemsData.add(""Fragment "" + getArguments().getInt(""index"", -1) + "" / Item "" + i);
	}
	
	DemoAdapter adapter = new DemoAdapter(itemsData);
	recyclerView.setAdapter(adapter);
}","/**
 * Init the fragment
 */


private void initDemoList(View view) 
{
    ListView listView = (ListView) view.findViewById(R.id.listview);
    ArrayList<String> list = new ArrayList<String>();
    for (int i = 0; i < 20; i++)
    {
        list.add(""Item "" + i);
    }
    listView.setAdapter(new ArrayAdapter<String>(getActivity(),
            android.R.layout.simple_list_item_1, list));
}   ",341,True
"/**
 * Update alpha
 */
public static void updateAlpha(final View view, float fromValue, float toValue){
	ValueAnimator animator = ValueAnimator.ofFloat(fromValue, toValue);
	animator.setDuration(150);
	animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator valueAnimator) {
			float animatedValue = (float) valueAnimator.getAnimatedValue();
			view.setAlpha(animatedValue);
		}
	});
	animator.start();
}","/**
 * Update alpha
 */
public static void updateAlpha(final View view, float fromValue, float toValue) 
{
    final AlphaAnimation alphaAnimation = new AlphaAnimation(fromValue, toValue);
    alphaAnimation.setDuration(300);
    view.startAnimation(alphaAnimation);
}   ",344,True
"/**
 * Get the height of the buttons bar
 *
 * @param context Context
 * @return
 */
public static int getSoftButtonsBarSizePort(Context context){
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
		DisplayMetrics metrics = new DisplayMetrics();
		Window window = unwrap(context).getWindow();
		window.getWindowManager().getDefaultDisplay().getMetrics(metrics);
		int usableHeight = metrics.heightPixels;
		window.getWindowManager().getDefaultDisplay().getRealMetrics(metrics);
		int realHeight = metrics.heightPixels;
		if (realHeight > usableHeight)
			return realHeight - usableHeight;
		else
			return 0;
	}
	return 0;
}","/**
 * Get the height of the buttons bar
 *
 * @param context Context
 * @return
 */
public static int getSoftButtonsBarSizePort(Context context) 
{
    int result = 0;
    int resourceId = context.getResources().getIdentifier(""navigation_bar_height"", ""dimen"", ""android"");
    if (resourceId > 0)
    {
        result = context.getResources().getDimensionPixelSize(resourceId);
    }
    return result;
}   ",345,False
"/**
 * Update text color with animation
 */
public static void updateTextColor(final TextView textView, @ColorInt int fromColor,
                                   @ColorInt int toColor){
	ValueAnimator colorAnimation = ValueAnimator.ofObject(new ArgbEvaluator(), fromColor, toColor);
	colorAnimation.setDuration(150);
	colorAnimation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator animator) {
			textView.setTextColor((Integer) animator.getAnimatedValue());
		}
	});
	colorAnimation.start();
}","/**
 * Update text color with animation
 */


public static void updateTextColor(final TextView textView, @ColorInt int fromColor,
                                   @ColorInt int toColor) 
{
    ValueAnimator animator = ValueAnimator.ofObject(new ArgbEvaluator(), fromColor, toColor);
    animator.setDuration(1500);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()
    {
        @Override
        public void onAnimationUpdate(ValueAnimator animation)
        {
            int color = (int) animation.getAnimatedValue();
            textView.setTextColor(color);
        }
    });
    animator.start();
}   ",346,True
"/**
 * Update text size with animation
 */
public static void updateTextSize(final TextView textView, float fromSize, float toSize){
	ValueAnimator animator = ValueAnimator.ofFloat(fromSize, toSize);
	animator.setDuration(150);
	animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator valueAnimator) {
			float animatedValue = (float) valueAnimator.getAnimatedValue();
			textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, animatedValue);
		}
	});
	animator.start();
}","/**
 * Update text size with animation
 */


public static void updateTextSize(final TextView textView, float fromSize, float toSize) 
{
    ValueAnimator animator = ValueAnimator.ofFloat(fromSize, toSize);
    animator.setDuration(300);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()
    {
        @Override
        public void onAnimationUpdate(ValueAnimator animation)
        {
            float animatedValue = (float) animation.getAnimatedValue();
            textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, animatedValue);
        }
    });
    animator.start();
}   ",349,True
"/**
 * Called when a fragment will be hidden
 */
public void willBeHidden(){
	if (fragmentContainer != null) {
		Animation fadeOut = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_out);
		fragmentContainer.startAnimation(fadeOut);
	}
}","/**
 * Called when a fragment will be hidden
 */
public void willBeHidden() 
{
    if (mFragment != null)
    {
        mFragment.willBeHidden();
    }
}   ",353,True
"/**
 * Return a tint drawable
 *
 * @param drawable
 * @param color
 * @param forceTint
 * @return
 */
public static Drawable getTintDrawable(Drawable drawable, @ColorInt int color, boolean forceTint){
	if (forceTint) {
		drawable.clearColorFilter();
		drawable.mutate().setColorFilter(color, PorterDuff.Mode.SRC_IN);
		drawable.invalidateSelf();
		return drawable;
	}
	Drawable wrapDrawable = DrawableCompat.wrap(drawable).mutate();
	DrawableCompat.setTint(wrapDrawable, color);
	return wrapDrawable;
}","/**
 * Return a tint drawable
 *
 * @param drawable
 * @param color
 * @param forceTint
 * @return
 */
public static Drawable getTintDrawable(Drawable drawable, @ColorInt int color, boolean forceTint) 
{
    if (forceTint || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP)
    {
        drawable = DrawableCompat.wrap(drawable).mutate();
        DrawableCompat.setTint(drawable, color);
    }
    return drawable;
}   ",354,True
"/**
 * Check if the status bar is translucent
 *
 * @param context Context
 * @return
 */
public static boolean isTranslucentStatusBar(Context context){
	Window w = unwrap(context).getWindow();
	WindowManager.LayoutParams lp = w.getAttributes();
	int flags = lp.flags;
	if ((flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) {
		return true;
	}

	return false;
}","/**
 * Check if the status bar is translucent
 *
 * @param context Context
 * @return
 */
public static boolean isTranslucentStatusBar(Context context) 
{
    int res = context.getResources().getIdentifier(""config_enableTranslucentStatusBar"", ""bool"", ""android"");
    return res > 0 && context.getResources().getBoolean(res);
}   ",355,True
"/**
 * Update bottom margin with animation
 */
public static void updateBottomMargin(final View view, int fromMargin, int toMargin, int duration){
	ValueAnimator animator = ValueAnimator.ofFloat(fromMargin, toMargin);
	animator.setDuration(duration);
	animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator valueAnimator) {
			float animatedValue = (float) valueAnimator.getAnimatedValue();
			if (view.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
				ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
				p.setMargins(p.leftMargin, p.topMargin, p.rightMargin, (int) animatedValue);
				view.requestLayout();
			}
		}
	});
	animator.start();
}","/**
 * Update bottom margin with animation
 */

public static void updateBottomMargin(final View view, int fromMargin, int toMargin, int duration) 
{
    ValueAnimator animator = ValueAnimator.ofInt(fromMargin, toMargin);
    animator.setDuration(duration);

    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()
    {
        @Override
        public void onAnimationUpdate(ValueAnimator animation)
        {
            int animatedValue = (int) animation.getAnimatedValue();
            ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
            params.bottomMargin = animatedValue;
            view.setLayoutParams(params);
        }
    });

    animator.start();
}   ",356,True
"/**
 * Constructor
 *
 * @param title    String
 * @param drawable Drawable
 */
public AHBottomNavigationItem(String title, Drawable drawable){
	this.title = title;
	this.drawable = drawable;
}","/**
 * Constructor
 *
 * @param title    String
 * @param drawable Drawable
 */

public AHBottomNavigationItem(String title, Drawable drawable) 
{
    this.title = title;
    this.drawable = drawable;
    this.color = Color.parseColor(""#FFFFFF"");
}   ",357,True
"/**
 * @param title    Title
 * @param resource Drawable resource
 * @param color    Background color
 */
@Deprecated
public AHBottomNavigationItem(String title, @DrawableRes int resource, @ColorRes int color){
	this.title = title;
	this.drawableRes = resource;
	this.color = color;
}","/**
 * @param title    Title
 * @param resource Drawable resource
 * @param color    Background color
 */
@Deprecated
public AHBottomNavigationItem(String title, @DrawableRes int resource, @ColorRes int color) 
{
    this(title, ContextCompat.getDrawable(AHContext.getCurrentActivity(), resource), ContextCompat.getColor(AHContext.getCurrentActivity(), color));
}   ",358,True
"/**
 * 文件是否存在
 * @param path
 * @return
 */
public static boolean fileIsExists(String path){
    try {
        File f = new File(path);
        if (!f.exists()) {
            return false;
        }
    } catch (Exception e) {

        return false;
    }
    return true;
}","/**
 * 文件是否存在
 * @param path
 * @return
 */

public static boolean fileIsExists(String path) 
{
    File f = new File(path);
    if(!f.exists())
    {
        return false;
    }
    return true;
}   ",360,True
"/**
 * 请求获取列表数据
 * @param type
 * @param id
 * @param startPage
 */
@Override
public void getNewsListDataRequest(String type, String id, int startPage){
     mRxManage.add(mModel.getNewsListData(type,id,startPage).subscribe(new RxSubscriber<List<NewsSummary>>(mContext,false) {
         @Override
         public void onStart() {
             super.onStart();
             mView.showLoading(mContext.getString(R.string.loading));
         }

         @Override
         protected void _onNext(List<NewsSummary> newsSummaries) {
             mView.returnNewsListData(newsSummaries);
             mView.stopLoading();
         }

         @Override
         protected void _onError(String message) {
             mView.showErrorTip(message);
         }
     }));
}","/**
 * 请求获取列表数据
 * @param type
 * @param id
 * @param startPage
 */


@Override
public void getNewsListDataRequest(String type, String id, int startPage) 
{
    Map<String, Object> map = new HashMap<>();
    map.put(""type"", type);
    map.put(""id"", id);
    map.put(""startPage"", startPage);
    map.put(""url"", ApiConstants.URL_NEWS_LIST);
    map.put(""request"", ""getNewsListDataRequest"");
    getRequest(map, null);
}   ",362,False
"/**
 * 将内容写入文件
 *
 * @param filePath eg:/mnt/sdcard/demo.txt
 * @param content  内容
 */
public static void writeFileSdcard(String filePath, String content, boolean isAppend){
    try {
        FileOutputStream fout = new FileOutputStream(filePath, isAppend);
        byte[] bytes = content.getBytes();
        fout.write(bytes);
        fout.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}","/**
 * 将内容写入文件
 *
 * @param filePath eg:/mnt/sdcard/demo.txt
 * @param content  内容
 */






public static void writeFileSdcard(String filePath, String content, boolean isAppend) 
{
    try
    {
        File file = new File(filePath);
        if (!file.exists())
        {
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file, isAppend);
        fw.write(content);
        fw.flush();
        fw.close();
    } catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",363,True
"/**
 * 文件拷贝
 *
 * @param src  源文件
 * @param desc 目的文件
 */
public static void fileChannelCopy(File src, File desc){
    FileInputStream fi = null;
    FileOutputStream fo = null;
    try {
        fi = new FileInputStream(src);
        fo = new FileOutputStream(desc);
        FileChannel in = fi.getChannel();//得到对应的文件通道
        FileChannel out = fo.getChannel();//得到对应的文件通道
        in.transferTo(0, in.size(), out);//连接两个通道，并且从in通道读取，然后写入out通道
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (fo != null) fo.close();
            if (fi != null) fi.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}","/**
 * 文件拷贝
 *
 * @param src  源文件
 * @param desc 目的文件
 */






public static void fileChannelCopy(File src, File desc) 
{
    try
    {
        FileInputStream fis = new FileInputStream(src);
        FileOutputStream fos = new FileOutputStream(desc);
        FileChannel inChannel = fis.getChannel();
        FileChannel outChannel = fos.getChannel();
        inChannel.transferTo(0, inChannel.size(), outChannel);
        inChannel.close();
        outChannel.close();
        fis.close();
        fos.close();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",364,True
"/**
 * 获取文件内容
 *
 * @param path
 * @return
 */
public static String getFileOutputString(String path){
    try {
        BufferedReader bufferedReader = new BufferedReader(new FileReader(path), 8192);
        StringBuilder sb = new StringBuilder();
        String line = null;
        while ((line = bufferedReader.readLine()) != null) {
            sb.append(""\n"").append(line);
        }
        bufferedReader.close();
        return sb.toString();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}","/**
 * 获取文件内容
 *
 * @param path
 * @return
 */




public static String getFileOutputString(String path) 
{
    StringBuilder sb = new StringBuilder();
    try
    {
        File file = new File(path);
        if (!file.exists())
        {
            return null;
        }
        BufferedReader br = new BufferedReader(new FileReader(file));
        String line = """";
        while ((line = br.readLine()) != null)
        {
            sb.append(line);
        }
        br.close();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return sb.toString();
}   ",365,False
"//Get alpha color
private static int calculateStatusBarColor(int color, int alpha){
    float a = 1 - alpha / 255f;
    int red = color >> 16 & 0xff;
    int green = color >> 8 & 0xff;
    int blue = color & 0xff;
    red = (int) (red * a + 0.5);
    green = (int) (green * a + 0.5);
    blue = (int) (blue * a + 0.5);
    return 0xff << 24 | red << 16 | green << 8 | blue;
}","//Get alpha color

private static int calculateStatusBarColor(int color, int alpha) 
{
    float[] hsv = new float[3];
    Color.colorToHSV(color, hsv);
    hsv[2] = hsv[2] * alpha / 255f;
    return Color.HSVToColor(hsv);
}   ",366,True
"/**
 * Get activity from context object
 *
 * @param context something
 * @return object of Activity or null if it is not Activity
 */
public static Activity scanForActivity(Context context){
    if (context == null) return null;

    if (context instanceof Activity) {
        return (Activity) context;
    } else if (context instanceof ContextWrapper) {
        return scanForActivity(((ContextWrapper) context).getBaseContext());
    }

    return null;
}","/**
 * Get activity from context object
 *
 * @param context something
 * @return object of Activity or null if it is not Activity
 */

public static Activity scanForActivity(Context context) 
{
    if (context == null)
    {
        return null;
    }
    else if (context instanceof Activity)
    {
        return (Activity) context;
    }
    else if (context instanceof ContextWrapper)
    {
        return scanForActivity(((ContextWrapper) context).getBaseContext());
    }

    return null;
}   ",368,True
"/**
 * 删除指定文件，如果是文件夹，则递归删除
 *
 * @param file
 * @return
 * @throws IOException
 */
public static boolean deleteFileOrDirectory(File file) throws IOException{
    try {
        if (file != null && file.isFile()) {
            return file.delete();
        }
        if (file != null && file.isDirectory()) {
            File[] childFiles = file.listFiles();
            // 删除空文件夹
            if (childFiles == null || childFiles.length == 0) {
                return file.delete();
            }
            // 递归删除文件夹下的子文件
            for (int i = 0; i < childFiles.length; i++) {
                deleteFileOrDirectory(childFiles[i]);
            }
            return file.delete();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}","/**
 * 删除指定文件，如果是文件夹，则递归删除
 *
 * @param file
 * @return
 * @throws IOException
 */
public static boolean deleteFileOrDirectory(File file) throws IOException 
{
    if (file.isFile())
    {
        return deleteFile(file);
    }
    else
    {
        return deleteDirectory(file);
    }
}   ",371,True
"/**
 * Get AppCompatActivity from context
 *
 * @param context
 * @return AppCompatActivity if it's not null
 */
public static AppCompatActivity getAppCompActivity(Context context){
    if (context == null) return null;
    if (context instanceof AppCompatActivity) {
        return (AppCompatActivity) context;
    } else if (context instanceof ContextThemeWrapper) {
        return getAppCompActivity(((ContextThemeWrapper) context).getBaseContext());
    }
    return null;
}","/**
 * Get AppCompatActivity from context
 *
 * @param context
 * @return AppCompatActivity if it's not null
 */
public static AppCompatActivity getAppCompActivity(Context context) 
{
    if (context == null)
    {
        return null;
    }
    if (context instanceof AppCompatActivity)
    {
        return (AppCompatActivity) context;
    } else if (context instanceof ContextThemeWrapper)
    {
        return getAppCompActivity(((ContextThemeWrapper) context).getBaseContext());
    }
    return null;
}   ",373,True
"/**
 * 获取Raw下的文件内容
 *
 * @param context
 * @param resId
 * @return 文件内容
 */
public static String getFileFromRaw(Context context, int resId){
    if (context == null) {
        return null;
    }

    StringBuilder s = new StringBuilder();
    try {
        InputStreamReader in = new InputStreamReader(context.getResources().openRawResource(resId));
        BufferedReader br = new BufferedReader(in);
        String line;
        while ((line = br.readLine()) != null) {
            s.append(line);
        }
        return s.toString();
    } catch (IOException e) {
        e.printStackTrace();
        return null;
    }
}","/**
 * 获取Raw下的文件内容
 *
 * @param context
 * @param resId
 * @return 文件内容
 */

public static String getFileFromRaw(Context context, int resId) 
{
    String r = """";
    try
    {
        InputStream in = context.getResources().openRawResource(resId);
        int length = in.available();
        byte[] buffer = new byte[length];
        in.read(buffer);
        r = new String(buffer, ""UTF-8"");
        in.close();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return r;
}   ",374,False
"/**
 * change to full screen mode
 * @param hideStatusBarBackground hide status bar alpha Background when SDK > 21, true if hide it
 */
public static void translucentStatusBar(Activity activity, boolean hideStatusBarBackground){
    Window window = activity.getWindow();
    ViewGroup mContentView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);

    //set child View not fill the system window
    View mChildView = mContentView.getChildAt(0);
    if (mChildView != null) {
        ViewCompat.setFitsSystemWindows(mChildView, false);
    }

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        int statusBarHeight = getStatusBarHeight(activity);

        //First translucent status bar.
        window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            //After LOLLIPOP just set LayoutParams.
            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
            if (hideStatusBarBackground) {
                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
                window.setStatusBarColor(COLOR_TRANSLUCENT);
            } else {
                window.setStatusBarColor(calculateStatusBarColor(COLOR_TRANSLUCENT, DEFAULT_COLOR_ALPHA));
            }
            //must call requestApplyInsets, otherwise it will have space in screen bottom
            if (mChildView != null) {
                ViewCompat.requestApplyInsets(mChildView);
            }
        } else {
            ViewGroup mDecorView = (ViewGroup) window.getDecorView();
            if (mDecorView.getTag() != null && mDecorView.getTag() instanceof Boolean && (Boolean)mDecorView.getTag()) {
                mChildView = mDecorView.getChildAt(0);
                //remove fake status bar view.
                mContentView.removeView(mChildView);
                mChildView = mContentView.getChildAt(0);
                if (mChildView != null) {
                    FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mChildView.getLayoutParams();
                    //cancel the margin top
                    if (lp != null && lp.topMargin >= statusBarHeight) {
                        lp.topMargin -= statusBarHeight;
                        mChildView.setLayoutParams(lp);
                    }
                }
                mDecorView.setTag(false);
            }
        }
    }
}","/**
 * change to full screen mode
 * @param hideStatusBarBackground hide status bar alpha Background when SDK > 21, true if hide it
 */


public static void translucentStatusBar(Activity activity, boolean hideStatusBarBackground) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
    {
        View decorView = activity.getWindow().getDecorView();
        int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;
        if (hideStatusBarBackground)
        {
            option |= View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        }
        decorView.setSystemUiVisibility(option);
        activity.getWindow().setStatusBarColor(Color.TRANSPARENT);
    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)
    {
        WindowManager.LayoutParams localLayoutParams = activity.getWindow().getAttributes();
        localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);
    }
}   ",377,False
"/**
 * 递归创建文件夹
 *
 * @param dirPath
 * @return 创建失败返回""""
 */
public static String createDir(String dirPath){
    try {
        File file = new File(dirPath);
        if (file.getParentFile().exists()) {
            LogUtils.i(""----- 创建文件夹"" + file.getAbsolutePath());
            file.mkdir();
            return file.getAbsolutePath();
        } else {
            createDir(file.getParentFile().getAbsolutePath());
            LogUtils.i(""----- 创建文件夹"" + file.getAbsolutePath());
            file.mkdir();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return dirPath;
}","/**
 * 递归创建文件夹
 *
 * @param dirPath
 * @return 创建失败返回""""
 */

public static String createDir(String dirPath) 
{
    try
    {
        File dir = new File(dirPath);
        if (!dir.exists())
        {
            if (!dir.mkdirs())
            {
                return """";
            }
        }
        return dirPath;
    }
    catch (Exception e)
    {
        return """";
    }
}   ",378,False
"//Get status bar height
public static int getStatusBarHeight(Context context){
    int result = 0;
    int resId = context.getResources().getIdentifier(""status_bar_height"", ""dimen"", ""android"");
    if (resId > 0) {
        result = context.getResources().getDimensionPixelOffset(resId);
    }
    return result;
}","//Get status bar height
public static int getStatusBarHeight(Context context) 
{
    int result = 0;
    int resourceId = context.getResources().getIdentifier(""status_bar_height"", ""dimen"", ""android"");
    if (resourceId > 0)
    {
        result = context.getResources().getDimensionPixelSize(resourceId);
    }
    return result;
}   ",379,True
"/**
 * Adds {@link ContentResolverTypeMapping} for some type.
 *
 * @param type        type.
 * @param typeMapping mapping for type.
 * @param <T>         type.
 * @return builder.
 */
@NonNull
public <T> CompleteBuilder addTypeMapping(@NonNull Class<T> type, @NonNull ContentResolverTypeMapping<T> typeMapping){
    checkNotNull(type, ""Please specify type"");
    checkNotNull(typeMapping, ""Please specify type mapping"");

    if (this.typeMapping == null) {
        this.typeMapping = new HashMap<Class<?>, ContentResolverTypeMapping<?>>();
    }

    this.typeMapping.put(type, typeMapping);

    return this;
}","/**
 * Adds {@link ContentResolverTypeMapping} for some type.
 *
 * @param type        type.
 * @param typeMapping mapping for type.
 * @param <T>         type.
 * @return builder.
 */
@NonNull
public <T> CompleteBuilder addTypeMapping(@NonNull Class<T> type, @NonNull ContentResolverTypeMapping<T> typeMapping) 
{
    this.typeMappings.put(type, typeMapping);
    return this;
}   ",380,True
"/**
 * Provides a scheduler on which {@link io.reactivex.Flowable} / {@link io.reactivex.Single}
 * or {@link io.reactivex.Completable} will be subscribed.
 * <p/>
 * @see com.pushtorefresh.storio3.operations.PreparedOperation#asRxFlowable(BackpressureStrategy)
 * @see com.pushtorefresh.storio3.operations.PreparedOperation#asRxSingle()
 * @see PreparedCompletableOperation#asRxCompletable()
 *
 * @return the scheduler or {@code null} if it isn't needed to apply it.
 */
@NonNull
public CompleteBuilder defaultRxScheduler(@Nullable Scheduler defaultRxScheduler){
    this.defaultRxScheduler = defaultRxScheduler;
    return this;
}","/**
 * Provides a scheduler on which {@link io.reactivex.Flowable} / {@link io.reactivex.Single}
 * or {@link io.reactivex.Completable} will be subscribed.
 * <p/>
 * @see com.pushtorefresh.storio3.operations.PreparedOperation#asRxFlowable(BackpressureStrategy)
 * @see com.pushtorefresh.storio3.operations.PreparedOperation#asRxSingle()
 * @see PreparedCompletableOperation#asRxCompletable()
 *
 * @return the scheduler or {@code null} if it isn't needed to apply it.
 */
@NonNull
public CompleteBuilder defaultRxScheduler(@Nullable Scheduler defaultRxScheduler) 
{
    this.defaultRxScheduler = defaultRxScheduler;
    return this;
}   ",381,True
"/**
 * {@inheritDoc}
 */
@WorkerThread
@SuppressLint(""Recycle"")
@NonNull
@Override
public Cursor query(@NonNull Query query){
    Cursor cursor = contentResolver.query(
            query.uri(),
            nullableArrayOfStringsFromListOfStrings(query.columns()),
            nullableString(query.where()),
            nullableArrayOfStringsFromListOfStrings(query.whereArgs()),
            nullableString(query.sortOrder())
    );

    if (cursor == null) {
        throw new IllegalStateException(""Cursor returned by content provider is null"");
    }

    return cursor;
}","/**
 * {@inheritDoc}
 */
@WorkerThread
@SuppressLint(""Recycle"")
@NonNull
@Override
public Cursor query(@NonNull Query query) 
{
    final String[] projection = new String[query.getColumns().size()];
    final String[] selectionArgs = new String[query.getValues().size()];
    final String selection = buildSelection(query, projection, selectionArgs);

    return mContentResolver.query(
            query.getUri(),
            projection,
            selection,
            selectionArgs,
            query.getSortOrder());
}   ",383,False
"/**
 * Optional: Specifies {@link TypeMappingFinder} for low level usage.
 *
 * @param typeMappingFinder non-null custom implementation of {@link TypeMappingFinder}.
 * @return builder.
 */
@NonNull
public CompleteBuilder typeMappingFinder(@NonNull TypeMappingFinder typeMappingFinder){
    checkNotNull(typeMappingFinder, ""Please specify typeMappingFinder"");

    this.typeMappingFinder = typeMappingFinder;

    return this;
}","/**
 * Optional: Specifies {@link TypeMappingFinder} for low level usage.
 *
 * @param typeMappingFinder non-null custom implementation of {@link TypeMappingFinder}.
 * @return builder.
 */
@NonNull
public CompleteBuilder typeMappingFinder(@NonNull TypeMappingFinder typeMappingFinder) 
{
    this.typeMappingFinder = typeMappingFinder;
    return this;
}   ",386,True
"// We suggest to keep one instance of StorIO (SQLite or ContentResolver)
// It's thread safe and so on, so just share it.
// But if you need you can have multiple instances of StorIO
// (SQLite or ContentResolver) with different settings such as type mapping, logging and so on.
// But keep in mind that different instances of StorIOSQLite won't share notifications!
@Provides
@NonNull
@Singleton
public StorIOSQLite provideStorIOSQLite(@NonNull SQLiteOpenHelper sqLiteOpenHelper){
    final CarStorIOSQLitePutResolver carStorIOSQLitePutResolver = new CarStorIOSQLitePutResolver();
    final CarStorIOSQLiteGetResolver carStorIOSQLiteGetResolver = new CarStorIOSQLiteGetResolver();

    final PersonStorIOSQLitePutResolver personStorIOSQLitePutResolver = new PersonStorIOSQLitePutResolver();
    final PersonStorIOSQLiteGetResolver personStorIOSQLiteGetResolver = new PersonStorIOSQLiteGetResolver();

    final CarPersonRelationPutResolver carPersonRelationPutResolver = new CarPersonRelationPutResolver();

    return DefaultStorIOSQLite.builder()
            .sqliteOpenHelper(sqLiteOpenHelper)
            .addTypeMapping(Tweet.class, new TweetSQLiteTypeMapping())
            .addTypeMapping(User.class, new UserSQLiteTypeMapping())
            .addTypeMapping(TweetWithUser.class, SQLiteTypeMapping.<TweetWithUser>builder()
                    .putResolver(new TweetWithUserPutResolver())
                    .getResolver(new TweetWithUserGetResolver())
                    .deleteResolver(new TweetWithUserDeleteResolver())
                    .build())

            .addTypeMapping(Person.class, SQLiteTypeMapping.<Person>builder()
                    .putResolver(new PersonRelationsPutResolver(carStorIOSQLitePutResolver, carPersonRelationPutResolver))
                    .getResolver(new PersonRelationsGetResolver(carStorIOSQLiteGetResolver))
                    .deleteResolver(new PersonRelationsDeleteResolver())
                    .build())
            .addTypeMapping(Car.class, SQLiteTypeMapping.<Car>builder()
                    .putResolver(new CarRelationsPutResolver(personStorIOSQLitePutResolver, carPersonRelationPutResolver))
                    .getResolver(new CarRelationsGetResolver(personStorIOSQLiteGetResolver))
                    .deleteResolver(new CarRelationsDeleteResolver())

                    .build()
            )
            .build();
}","// We suggest to keep one instance of StorIO (SQLite or ContentResolver)
// It's thread safe and so on, so just share it.
// But if you need you can have multiple instances of StorIO
// (SQLite or ContentResolver) with different settings such as type mapping, logging and so on.
// But keep in mind that different instances of StorIOSQLite won't share notifications!
@Provides
@NonNull
@Singleton
public StorIOSQLite provideStorIOSQLite(@NonNull SQLiteOpenHelper sqLiteOpenHelper) 
{
    return storIOSQLite;
}   ",389,True
"/**
 * Builds new instance of {@link DefaultStorIOContentResolver}.
 *
 * @return new instance of {@link DefaultStorIOContentResolver}.
 */
@NonNull
public DefaultStorIOContentResolver build(){
    if (contentObserverHandler == null) {
        final HandlerThread handlerThread = new HandlerThread(""StorIOContentResolverNotificationsThread"");
        handlerThread.start(); // multithreading: don't block me, bro!
        contentObserverHandler = new Handler(handlerThread.getLooper());
    }

    if (typeMappingFinder == null) {
        typeMappingFinder = new TypeMappingFinderImpl();
    }
    if (typeMapping != null) {
        typeMappingFinder.directTypeMapping(unmodifiableMap(typeMapping));
    }

    return new DefaultStorIOContentResolver(contentResolver, contentObserverHandler, typeMappingFinder, defaultRxScheduler, interceptors);
}","/**
 * Builds new instance of {@link DefaultStorIOContentResolver}.
 *
 * @return new instance of {@link DefaultStorIOContentResolver}.
 */
@NonNull
public DefaultStorIOContentResolver build() 
{
    return new DefaultStorIOContentResolver(
            mStorIO,
            mQueryExecutor,
            mInsertExecutor,
            mUpdateExecutor,
            mDeleteExecutor
    );
}   ",391,False
"/**
 * Optional: Adds {@link Interceptor} to all database operation.
 * Multiple interceptors would be called in the order they were added.
 *
 * @param interceptor non-null custom implementation of {@link Interceptor}.
 * @return builder.
 */
@NonNull
public CompleteBuilder addInterceptor(@NonNull Interceptor interceptor){
    interceptors.add(interceptor);
    return this;
}","/**
 * Optional: Adds {@link Interceptor} to all database operation.
 * Multiple interceptors would be called in the order they were added.
 *
 * @param interceptor non-null custom implementation of {@link Interceptor}.
 * @return builder.
 */
@NonNull
public CompleteBuilder addInterceptor(@NonNull Interceptor interceptor) 
{
    this.interceptors.add(interceptor);
    return this;
}   ",396,True
"/**
 * Verifies behavior of {@link DefaultPutResolver} for ""insert""
 */
@Test
public void insert() throws Exception{
    final StorIOContentResolver storIOContentResolver = mock(StorIOContentResolver.class);
    final StorIOContentResolver.LowLevel lowLevel = mock(StorIOContentResolver.LowLevel.class);
    final TestItem testItem = new TestItem(null); // item without id, should be inserted

    when(storIOContentResolver.lowLevel())
            .thenReturn(lowLevel);

    final Uri expectedInsertedUri = mock(Uri.class);

    final Query expectedQuery = Query.builder()
            .uri(TestItem.CONTENT_URI)
            .where(TestItem.COLUMN_ID + "" = ?"")
            .whereArgs(testItem.getId())
            .build();

    final Cursor cursor = mock(Cursor.class);

    when(lowLevel.query(eq(expectedQuery)))
            .thenReturn(cursor);

    when(cursor.getCount())
            .thenReturn(0); // No results -> insert should be performed

    when(lowLevel.insert(any(InsertQuery.class), any(ContentValues.class)))
            .thenReturn(expectedInsertedUri);

    final InsertQuery expectedInsertQuery = InsertQuery.builder()
            .uri(TestItem.CONTENT_URI)
            .build();

    final PutResolver<TestItem> putResolver = new DefaultPutResolver<TestItem>() {
        @NonNull
        @Override
        protected InsertQuery mapToInsertQuery(@NonNull TestItem object) {
            return expectedInsertQuery;
        }

        @NonNull
        @Override
        protected UpdateQuery mapToUpdateQuery(@NonNull TestItem object) {
            return UpdateQuery.builder()
                    .uri(TestItem.CONTENT_URI)
                    .where(TestItem.COLUMN_ID + "" = ?"")
                    .whereArgs(object.getId())
                    .build();
        }

        @NonNull
        @Override
        protected ContentValues mapToContentValues(@NonNull TestItem object) {
            try {
                return TestItem.MAP_TO_CONTENT_VALUES.apply(object);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    };

    final ContentValues expectedContentValues = TestItem.MAP_TO_CONTENT_VALUES.apply(testItem);

    // Performing Put that should ""insert""
    final PutResult putResult = putResolver.performPut(storIOContentResolver, testItem);

    // checks that it asks db for results
    verify(lowLevel).query(eq(expectedQuery));

    // checks that cursor was closed
    verify(cursor).close();

    // only one query should occur
    verify(lowLevel).query(any(Query.class));

    // checks that required insert was performed
    verify(lowLevel).insert(eq(expectedInsertQuery), eq(expectedContentValues));

    // only one insert should occur
    verify(lowLevel).insert(any(InsertQuery.class), any(ContentValues.class));

    // no updates should occur
    verify(lowLevel, never()).update(any(UpdateQuery.class), any(ContentValues.class));

    // put result checks
    assertThat(putResult.wasInserted()).isTrue();
    assertThat(putResult.wasUpdated()).isFalse();

    assertThat(putResult.insertedUri()).isEqualTo(expectedInsertedUri);
    assertThat(putResult.numberOfRowsUpdated()).isNull();
}","/**
 * Verifies behavior of {@link DefaultPutResolver} for ""insert""
 */
@Test
public void insert() throws Exception 
{
    // Create a new instance of DefaultPutResolver
    DefaultPutResolver resolver = new DefaultPutResolver();

    // Create a new instance of DefaultPut
    DefaultPut put = new DefaultPut();

    // Call the insert method with the put instance
    resolver.insert(put);

    // Verify that the insert method was called on the put instance
    verify(put).insert();
}   ",397,False
"/**
 * Checks that passed string is not null and not empty,
 * throws {@link NullPointerException} or {@link IllegalStateException} with passed message
 * if string is null or empty.
 *
 * @param value   a string to check
 * @param message exception message if object is null
 */
public static void checkNotEmpty(@Nullable String value, @NonNull String message){
    if (value == null) {
        throw new NullPointerException(message);
    } else if (value.length() == 0) {
        throw new IllegalStateException(message);
    }
}","/**
 * Checks that passed string is not null and not empty,
 * throws {@link NullPointerException} or {@link IllegalStateException} with passed message
 * if string is null or empty.
 *
 * @param value   a string to check
 * @param message exception message if object is null
 */
public static void checkNotEmpty(@Nullable String value, @NonNull String message) 
{
    if (value == null)
    {
        throw new NullPointerException(message);
    }
    if (value.isEmpty())
    {
        throw new IllegalStateException(message);
    }
}   ",398,True
"/**
 * Get the value of one of the fields.
 *
 * @param fieldName
 *     the field name. E.g ""PPid"", ""Uid"", ""Groups"".
 * @return The value of the field or {@code null}.
 */
public String getValue(String fieldName){
  String[] lines = content.split(""\n"");
  for (String line : lines) {
    if (line.startsWith(fieldName + "":"")) {
      return line.split(fieldName + "":"")[1].trim();
    }
  }
  return null;
}","/**
 * Get the value of one of the fields.
 *
 * @param fieldName
 *     the field name. E.g ""PPid"", ""Uid"", ""Groups"".
 * @return The value of the field or {@code null}.
 */
public String getValue(String fieldName) 
{
    switch (fieldName)
    {
        case ""PPid"":
            return PPid;
        case ""Uid"":
            return Uid;
        case ""Groups"":
            return Groups;
        default:
            return null;
    }
}   ",400,False
"/**
 * @return a list of all running app processes on the device.
 */
public static List<AndroidAppProcess> getRunningAppProcesses(){
    List<AndroidAppProcess> processes = new ArrayList<>();
    File[] files = new File(""/proc"").listFiles();
    for (File file : files) {
        if (file.isDirectory()) {
            int pid;
            try {
                pid = Integer.parseInt(file.getName());
            } catch (NumberFormatException e) {
                continue;
            }
            try {
                processes.add(new AndroidAppProcess(pid));
            } catch (AndroidAppProcess.NotAndroidAppProcessException ignored) {
            } catch (IOException e) {
                log(e, ""Error reading from /proc/%d."", pid);
                // System apps will not be readable on Android 5.0+ if SELinux is enforcing.
                // You will need root access or an elevated SELinux context to read all files under /proc.
            }
        }
    }
    return processes;
}","/**
 * @return a list of all running app processes on the device.
 */



public static List<AndroidAppProcess> getRunningAppProcesses() 
{
    List<AndroidAppProcess> processes = new ArrayList<>();
    File[] files = new File(""/proc"").listFiles();
    for (File file : files)
    {
        if (file.isDirectory())
        {
            try
            {
                int pid = Integer.parseInt(file.getName());
                processes.add(new AndroidAppProcess(pid));
            }
            catch (NumberFormatException e)
            {
                // Ignore directories that are not process IDs
            }
        }
    }
    return processes;
}   ",403,False
"/**
 * @return The process' GID or -1 if parsing the GID failed.
 */
public int getGid(){
  try {
    return Integer.parseInt(getValue(""Gid"").split(""\\s+"")[0]);
  } catch (Exception e) {
    return -1;
  }
}","/**
 * @return The process' GID or -1 if parsing the GID failed.
 */
public int getGid() 
{
    try
    {
        return Integer.parseInt(this.gid);
    }
    catch (NumberFormatException e)
    {
        return -1;
    }
}   ",406,True
"/**
 * Read the contents of a file.
 *
 * @param path
 *     the absolute path to the file.
 * @return the contents of the file.
 * @throws IOException
 *     if an error occurred while reading.
 */
protected static String readFile(String path) throws IOException{
  BufferedReader reader = null;
  try {
    StringBuilder output = new StringBuilder();
    reader = new BufferedReader(new FileReader(path));
    for (String line = reader.readLine(), newLine = """"; line != null; line = reader.readLine()) {
      output.append(newLine).append(line);
      newLine = ""\n"";
    }
    return output.toString();
  } finally {
    if (reader != null) {
      reader.close();
    }
  }
}","/**
 * Read the contents of a file.
 *
 * @param path
 *     the absolute path to the file.
 * @return the contents of the file.
 * @throws IOException
 *     if an error occurred while reading.
 */




protected static String readFile(String path) throws IOException 
{
    StringBuilder fileContents = new StringBuilder();
    BufferedReader reader = new BufferedReader(new FileReader(path));
    try
    {
        String line = reader.readLine();
        while (line != null)
        {
            fileContents.append(line).append(""\n"");
            line = reader.readLine();
        }
    }
    finally
    {
        reader.close();
    }
    return fileContents.toString();
}   ",407,True
"/**
 * Send a log message if logging is enabled.
 *
 * @param error   An exception to log
 * @param message the message to log
 * @param args    list of arguments to pass to the formatter
 */
public static void log(Throwable error, String message, Object... args){
    if (loggingEnabled) {
        Log.d(TAG, args.length == 0 ? message : String.format(message, args), error);
    }
}","/**
 * Send a log message if logging is enabled.
 *
 * @param error   An exception to log
 * @param message the message to log
 * @param args    list of arguments to pass to the formatter
 */
public static void log(Throwable error, String message, Object... args) 
{
    if (Log.isEnabled())
    {
        Log.log(error, message, args);
    }
}   ",409,True
"/**
 * Send a log message if logging is enabled.
 *
 * @param message the message to log
 * @param args    list of arguments to pass to the formatter
 */
public static void log(String message, Object... args){
    if (loggingEnabled) {
        Log.d(TAG, args.length == 0 ? message : String.format(message, args));
    }
}","/**
 * Send a log message if logging is enabled.
 *
 * @param message the message to log
 * @param args    list of arguments to pass to the formatter
 */

public static void log(String message, Object... args) 
{
    if (log.isDebugEnabled())
    {
        log.debug(MessageFormat.format(message, args));
    }
}   ",410,True
"/**
 * 方法6：无意中看到乌云上有人提的一个漏洞，Linux系统内核会把process进程信息保存在/proc目录下，使用Shell命令去获取的他，再根据进程的属性判断是否为前台
 *
 * @param packageName 需要检查是否位于栈顶的App的包名
 */
public static boolean getLinuxCoreInfo(Context context, String packageName){

    List<AndroidAppProcess> processes = ProcessManager.getRunningForegroundApps(context);
    for (AndroidAppProcess appProcess : processes) {
        if (appProcess.getPackageName().equals(packageName) && appProcess.foreground) {
            return true;
        }
    }
    return false;

}","/**
 * 方法6：无意中看到乌云上有人提的一个漏洞，Linux系统内核会把process进程信息保存在/proc目录下，使用Shell命令去获取的他，再根据进程的属性判断是否为前台
 *
 * @param packageName 需要检查是否位于栈顶的App的包名
 */
public static boolean getLinuxCoreInfo(Context context, String packageName) 
{
    if (context == null || TextUtils.isEmpty(packageName))
    {
        return false;
    }

    String processName = getProcessName(context, android.os.Process.myPid());
    return !TextUtils.isEmpty(processName) && processName.equalsIgnoreCase(packageName);
}   ",415,False
"/**
 * 判断是否有用权限
 *
 * @param context 上下文参数
 */
@TargetApi(Build.VERSION_CODES.KITKAT)
private static boolean HavaPermissionForTest(Context context){
    try {
        PackageManager packageManager = context.getPackageManager();
        ApplicationInfo applicationInfo = packageManager.getApplicationInfo(context.getPackageName(), 0);
        AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);
        int mode = appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, applicationInfo.uid, applicationInfo.packageName);
        return (mode == AppOpsManager.MODE_ALLOWED);
    } catch (PackageManager.NameNotFoundException e) {
        return true;
    }
}","/**
 * 判断是否有用权限
 *
 * @param context 上下文参数
 */
@TargetApi(Build.VERSION_CODES.KITKAT)
private static boolean HavaPermissionForTest(Context context) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
    {
        return Settings.canDrawOverlays(context);
    } else
    {
        return true;
    }
}   ",416,False
"/**
 * Get a list of user apps running in the foreground.
 *
 * @param ctx the application context
 * @return a list of user apps that are in the foreground.
 */
public static List<AndroidAppProcess> getRunningForegroundApps(Context ctx){
    List<AndroidAppProcess> processes = new ArrayList<>();
    File[] files = new File(""/proc"").listFiles();
    PackageManager pm = ctx.getPackageManager();
    for (File file : files) {
        if (file.isDirectory()) {
            int pid;
            try {
                pid = Integer.parseInt(file.getName());
            } catch (NumberFormatException e) {
                continue;
            }
            try {
                AndroidAppProcess process = new AndroidAppProcess(pid);
                if (process.foreground
                        // ignore system processes. First app user starts at 10000.
                        && (process.uid < 1000 || process.uid > 9999)
                        // ignore processes that are not running in the default app process.
                        && !process.name.contains("":"")
                        // Ignore processes that the user cannot launch.
                        && pm.getLaunchIntentForPackage(process.getPackageName()) != null) {
                    processes.add(process);
                }
            } catch (AndroidAppProcess.NotAndroidAppProcessException ignored) {
            } catch (IOException e) {
                log(e, ""Error reading from /proc/%d."", pid);
                // System apps will not be readable on Android 5.0+ if SELinux is enforcing.
                // You will need root access or an elevated SELinux context to read all files under /proc.
            }
        }
    }
    return processes;
}","/**
 * Get a list of user apps running in the foreground.
 *
 * @param ctx the application context
 * @return a list of user apps that are in the foreground.
 */
public static List<AndroidAppProcess> getRunningForegroundApps(Context ctx) 
{
    List<AndroidAppProcess> result = Lists.newArrayList();
    AndroidProcesses processes = new AndroidProcesses();
    for (AndroidAppProcess process : processes.getRunningAppProcesses())
    {
        if (process.foreground)
        {
            result.add(process);
        }
    }
    return result;
}   ",417,True
"/**
 * @return a list of <i>all</i> processes running on the device.
 */
public static List<AndroidProcess> getRunningProcesses(){
    List<AndroidProcess> processes = new ArrayList<>();
    File[] files = new File(""/proc"").listFiles();
    for (File file : files) {
        if (file.isDirectory()) {
            int pid;
            try {
                pid = Integer.parseInt(file.getName());
            } catch (NumberFormatException e) {
                continue;
            }
            try {
                processes.add(new AndroidProcess(pid));
            } catch (IOException e) {
                log(e, ""Error reading from /proc/%d."", pid);
                // System apps will not be readable on Android 5.0+ if SELinux is enforcing.
                // You will need root access or an elevated SELinux context to read all files under /proc.
            }
        }
    }
    return processes;
}","/**
 * @return a list of <i>all</i> processes running on the device.
 */




public static List<AndroidProcess> getRunningProcesses() 
{
    List<AndroidProcess> processes = new ArrayList<>();
    try
    {
        File dir = new File(""/proc"");
        File[] files = dir.listFiles();
        for (File file : files)
        {
            if (file.isDirectory())
            {
                try
                {
                    int pid = Integer.parseInt(file.getName());
                    processes.add(new AndroidProcess(pid));
                }
                catch (NumberFormatException e)
                {
                    // Not a process directory
                }
            }
        }
    }
    catch (Exception e)
    {
        Log.e(TAG, ""Error getting running processes"", e);
    }
    return processes;
}   ",418,False
"/**
 * Returns a list of application processes that are running on the device.
 * <p/>
 * <p><b>NOTE:</b> On Lollipop (SDK 22) this does not provide
 * {@link RunningAppProcessInfo#pkgList},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru},
 * {@link RunningAppProcessInfo#importanceReasonCode},
 * {@link RunningAppProcessInfo#importanceReasonComponent},
 * {@link RunningAppProcessInfo#importanceReasonPid},
 * etc. If you need more process information try using
 * {@link #getRunningAppProcesses()} or {@link android.app.usage.UsageStatsManager}</p>
 *
 * @param ctx the application context
 * @return a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
public static List<RunningAppProcessInfo> getRunningAppProcessInfo(Context ctx){
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
        List<AndroidAppProcess> runningAppProcesses = ProcessManager.getRunningAppProcesses();
        List<RunningAppProcessInfo> appProcessInfos = new ArrayList<>();
        for (AndroidAppProcess process : runningAppProcesses) {
            RunningAppProcessInfo info = new RunningAppProcessInfo(process.name, process.pid, null);
            info.uid = process.uid;
            // TODO: Get more information about the process. pkgList, importance, lru, etc.
            appProcessInfos.add(info);
        }
        return appProcessInfos;
    }
    ActivityManager am = (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);
    return am.getRunningAppProcesses();
}","/**
 * Returns a list of application processes that are running on the device.
 * <p/>
 * <p><b>NOTE:</b> On Lollipop (SDK 22) this does not provide
 * {@link RunningAppProcessInfo#pkgList},
 * {@link RunningAppProcessInfo#
 * {@link RunningAppProcessInfo#lru},
 * {@link RunningAppProcessInfo#
 * {@link RunningAppProcessInfo#
 * {@link RunningAppProcessInfo#
 * etc. If you need more process information try using
 * {@link #getRunningAppProcesses()} or {@link android.app.usage.UsageStatsManager}</p>
 *
 * @param ctx the application context
 * @return a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
public static List<RunningAppProcessInfo> getRunningAppProcessInfo(Context ctx) 
{
    final ActivityManager am = (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);
    return am.getRunningAppProcesses();
}   ",419,True
"/**
 * Inserts a new {@link PortabilityJob} keyed by its job ID in the store.
 *
 * <p>To update an existing {@link PortabilityJob} instead, use {@link JobStore#update}.
 *
 * @throws IOException if a job already exists for {@code job}'s ID, or if there was a different
 *     problem inserting the job.
 */
@Override
public void createJob(UUID jobId, PortabilityJob job) throws IOException{
  Preconditions.checkNotNull(jobId);
  monitor.debug(() -> format(""Creating job %s in local storage"", jobId));
  if (JOB_MAP.get(jobId) != null) {
    throw new IOException(""An entry already exists for jobId: "" + jobId);
  }
  JOB_MAP.put(jobId, job.toMap());
}","/**
 * Inserts a new {@link PortabilityJob} keyed by its job ID in the store.
 *
 * <p>To update an existing {@link PortabilityJob} instead, use {@link JobStore#update}.
 *
 * @throws IOException if a job already exists for {@code job}'s ID, or if there was a different
 *     problem inserting the job.
 */

@Override
public void createJob(UUID jobId, PortabilityJob job) throws IOException 
{
    try {
        jobStore.put(jobId, job);
    } catch (ExecutionException e) {
        throw new IOException(e);
    }
}   ",420,True
"// Store any album data in the cache because Flickr only allows you to create an album with a
// photo in it, so we have to wait for the first photo to create the album
private void storeAlbumbs(UUID jobId, Collection<PhotoAlbum> albums) throws IOException{
  for (PhotoAlbum album : albums) {
    jobStore.create(
        jobId,
        ORIGINAL_ALBUM_PREFIX + album.getId(),
        new FlickrTempPhotoData(album.getName(), album.getDescription()));
  }
}","// Store any album data in the cache because Flickr only allows you to create an album with a
// photo in it, so we have to wait for the first photo to create the album
private void storeAlbumbs(UUID jobId, Collection<PhotoAlbum> albums) throws IOException 
{
    if (albums != null)
    {
        for (PhotoAlbum album : albums)
        {
            storeAlbum(jobId, album);
        }
    }
}   ",421,True
"// For descriptions of scopes see: https://developers.deezer.com/api/permissions
@Override
public Map<String, Set<String>> getExportScopes(){
  return ImmutableMap.<String, Set<String>>builder()
      .put(""PLAYLISTS"", ImmutableSet.of(""offline_access,manage_library""))
      .build();
}","// For descriptions of scopes see: https://developers.deezer.com/api/permissions



@Override
public Map<String, Set<String>> getExportScopes() 
{
    Map<String, Set<String>> scopes = new HashMap<>();

    Set<String> basic = new HashSet<>();
    basic.add(""basic_access"");
    scopes.put(""basic"", basic);

    Set<String> email = new HashSet<>();
    email.add(""email"");
    scopes.put(""email"", email);

    Set<String> listeningHistory = new HashSet<>();
    listeningHistory.add(""listening_history"");
    scopes.put(""listening_history"", listeningHistory);

    return scopes;
}   ",425,False
"// Uploads a single DataChunk to an upload URL
// PUT to {photoUploadUrl}
// HEADERS
// Content-Length: {chunk size in bytes}
// Content-Range: bytes {begin}-{end}/{total size}
// body={bytes}
private Response uploadChunk(DataChunk chunk, String photoUploadUrl, int totalFileSize, String mediaType)
        throws IOException, DestinationMemoryFullException{

  Request.Builder uploadRequestBuilder = new Request.Builder().url(photoUploadUrl);
  uploadRequestBuilder.header(""Authorization"", ""Bearer "" + credential.getAccessToken());

  // put chunk data in
  RequestBody uploadChunkBody = RequestBody.create(MediaType.parse(mediaType), chunk.getData(), 0, chunk.getSize());
  uploadRequestBuilder.put(uploadChunkBody);

  // set chunk data headers, indicating size and chunk range
  final String contentRange =
      String.format(""bytes %d-%d/%d"", chunk.getStart(), chunk.getEnd(), totalFileSize);
  uploadRequestBuilder.header(""Content-Range"", contentRange);
  uploadRequestBuilder.header(""Content-Length"", String.format(""%d"", chunk.getSize()));

  // upload the chunk
  Response chunkResponse = client.newCall(uploadRequestBuilder.build()).execute();
  Preconditions.checkNotNull(chunkResponse, ""chunkResponse is null"");
  if (chunkResponse.code() == 401) {
    // If there was an unauthorized error, then try refreshing the creds
    credentialFactory.refreshCredential(credential);
    monitor.info(() -> ""Refreshed authorization token successfuly"");

    // update auth info, reupload chunk
    uploadRequestBuilder.header(""Authorization"", ""Bearer "" + credential.getAccessToken());
    chunkResponse = client.newCall(uploadRequestBuilder.build()).execute();
  }
  int chunkCode = chunkResponse.code();
  if (chunkCode == 507 && chunkResponse.message().contains(""Insufficient Storage"")) {
    throw new DestinationMemoryFullException(
        ""Microsoft destination storage limit reached"",
        new IOException(
            String.format(
                ""Got error code %d  with message: %s"", chunkCode, chunkResponse.message())));
  } else if (chunkCode < 200 || chunkCode > 299) {
    throw new IOException(
        ""Got error code: ""
            + chunkCode
            + "" message: ""
            + chunkResponse.message()
            + "" body: ""
            + chunkResponse.body().string());
  } else if (chunkCode == 200 || chunkCode == 201 || chunkCode == 202) {
    monitor.info(
        () ->
            String.format(
                ""Uploaded chunk %s-%s successfuly, code %d"",
                chunk.getStart(), chunk.getEnd(), chunkCode));
  }
  return chunkResponse;
}","// Uploads a single DataChunk to an upload URL
// PUT to {photoUploadUrl}
// HEADERS
// Content-Length: {chunk size in bytes}
// Content-Range: bytes {begin}-{end}/{total size}
// body={bytes}

private Response uploadChunk(DataChunk chunk, String photoUploadUrl, int totalFileSize, String mediaType)
        throws IOException, DestinationMemoryFullException 
{
    HttpPut put = new HttpPut(photoUploadUrl);
    put.setHeader(""Content-Length"", String.valueOf(chunk.getSize()));
    put.setHeader(""Content-Range"", ""bytes "" + chunk.getBegin() + ""-"" + chunk.getEnd() + ""/"" + totalFileSize);
    put.setEntity(new ByteArrayEntity(chunk.getBytes()));

    return httpClient.execute(put);
}       ",426,True
"/**
 * Finds the ID of the first {@link PortabilityJob} in state {@code jobState} in the map, or null
 * if none found.
 */
@Override
public synchronized UUID findFirst(JobAuthorization.State jobState){
  // Mimic an index lookup
  for (Entry<UUID, Map<String, Object>> job : JOB_MAP.entrySet()) {
    Map<String, Object> properties = job.getValue();
    State state = State.valueOf(properties.get(PortabilityJob.AUTHORIZATION_STATE).toString());
    UUID jobKey = job.getKey();
    monitor.debug(
        () ->
            format(
                ""Looking up first job in state %s: found job %s (state %s)"",
                jobState, jobKey, state));
    if (state == jobState) {
      return jobKey;
    }
  }
  return null;
}","/**
 * Finds the ID of the first {@link PortabilityJob} in state {@code jobState} in the map, or null
 * if none found.
 */
@Override
public synchronized UUID findFirst(JobAuthorization.State jobState) 
{
    for (Map.Entry<UUID, PortabilityJob> entry : jobs.entrySet())
    {
        if (entry.getValue().getState() == jobState)
        {
            return entry.getKey();
        }
    }
    return null;
}   ",427,True
"/**
 * Verifies a {@code PortabilityJob} already exists for {@code jobId}, and updates the entry to
 * {@code job}. If {@code validator} is non-null, validator.validate() is called first, as part of
 * the atomic update.
 *
 * @throws IOException if a job didn't already exist for {@code jobId} or there was a problem
 *     updating it
 * @throws IllegalStateException if validator.validate() failed
 */
@Override
protected synchronized void updateJob(
    UUID jobId, PortabilityJob job, JobUpdateValidator validator) throws IOException{
  Preconditions.checkNotNull(jobId);
  try {
    Map<String, Object> previousEntry = JOB_MAP.replace(jobId, job.toMap());
    if (previousEntry == null) {
      throw new IOException(""jobId: "" + jobId + "" didn't exist in the map"");
    }
    if (validator != null) {
      PortabilityJob previousJob = PortabilityJob.fromMap(previousEntry);
      validator.validate(previousJob, job);
    }
  } catch (NullPointerException | IllegalStateException e) {
    throw new IOException(""Couldn't update jobId: "" + jobId, e);
  }
}","/**
 * Verifies a {@code PortabilityJob} already exists for {@code jobId}, and updates the entry to
 * {@code job}. If {@code validator} is non-null, validator.validate() is called first, as part of
 * the atomic update.
 *
 * @throws IOException if a job didn't already exist for {@code jobId} or there was a problem
 *     updating it
 * @throws IllegalStateException if validator.validate() failed
 */


@Override
protected synchronized void updateJob(
    UUID jobId, PortabilityJob job, JobUpdateValidator validator) throws IOException 
{
  if (validator != null)
  {
    validator.validate();
  }

  if (!jobs.containsKey(jobId))
  {
    throw new IOException(""Job "" + jobId + "" doesn't exist"");
  }

  jobs.put(jobId, job);
}   ",428,True
"/**
 * Gets an input stream to an image, given its URL. Used by {@link FlickrPhotosImporter} to
 * upload the image.
 */
public BufferedInputStream get(String urlStr) throws IOException{
  URL url = new URL(urlStr);
  HttpURLConnection conn = (HttpURLConnection) url.openConnection();
  conn.connect();
  return new BufferedInputStream(conn.getInputStream());
}","/**
 * Gets an input stream to an image, given its URL. Used by {@link FlickrPhotos
 * upload the image.
 */


public BufferedInputStream get(String urlStr) throws IOException 
{
    URL url = new URL(urlStr);
    URLConnection conn = url.openConnection();
    return new BufferedInputStream(conn.getInputStream());
}   ",429,True
"/**
 * Ctor.
 *
 * @param type the result type
 */
public ExportResult(ResultType type){
  verifyNonErrorResultType(type);
  this.type = type;
}","/**
 * Ctor.
 *
 * @param type the result type
 */
public ExportResult(ResultType type) 
{
    this.type = type;
    this.data = null;
    this.error = null;
}   ",431,True
"/**
 * Ctor.
 *
 * @param type the result type
 * @param exportedData the exported data
 */
public ExportResult(ResultType type, T exportedData){
  verifyNonErrorResultType(type);
  this.type = type;
  this.exportedData = exportedData;
}","/**
 * Ctor.
 *
 * @param type the result type
 * @param exportedData the exported data
 */
public ExportResult(ResultType type, T exportedData) 
{
    this.type = type;
    this.exportedData = exportedData;
}   ",433,True
"/**
 * Returns the best {@link RetryStrategy} for a given Throwable.  If there are no matches, returns
 * the default RetryStrategy.
 *
 * Right now it just looks at the message in the Throwable and tries to find a matching regex in
 * its internal library.  Later on it will use more and more of the Throwable to make a decision.
 */
public RetryStrategy checkoutRetryStrategy(Throwable throwable){
  // TODO: determine retry strategy based on full information in Throwable
  for (RetryMapping mapping : retryMappings) {
    if (mapping.matchesThrowable(throwable)) {
      return mapping.getStrategy();
    }
  }
  return defaultRetryStrategy;
}","/**
 * Returns the best {@link RetryStrategy} for a given Throwable.  If there are no matches, returns
 * the default RetryStrategy.
 *
 * Right now it just looks at the message in the Throwable and tries to find a matching regex in
 * its internal library.  Later on it will use more and more of the Throwable to make a decision.
 */


public RetryStrategy checkoutRetryStrategy(Throwable throwable) 
{
    if (throwable == null)
    {
        return defaultRetryStrategy;
    }

    String message = throwable.getMessage();
    if (message == null)
    {
        return defaultRetryStrategy;
    }

    for (Map.Entry<Pattern, RetryStrategy> entry : retryStrategies.entrySet())
    {
        if (entry.getKey().matcher(message).matches())
        {
            return entry.getValue();
        }
    }

    return defaultRetryStrategy;
}   ",436,True
"/**
 * Ctor.
 *
 * @param throwable the throwable from execution
 */
public ExportResult(Throwable throwable){
  this.type = ResultType.ERROR;
  this.throwable = Optional.of(throwable);
}","/**
 * Ctor.
 *
 * @param throwable the throwable from execution
 */
public ExportResult(Throwable throwable) 
{
    this.success = false;
    this.throwable = throwable;
    this.message = throwable.getMessage();
}   ",437,True
"/**
 * Returns the job for the id or null if not found.
 *
 * @param jobId the job id
 */
@Override
public PortabilityJob findJob(UUID jobId){
  if (!JOB_MAP.containsKey(jobId)) {
    return null;
  }
  return PortabilityJob.fromMap(JOB_MAP.get(jobId));
}","/**
 * Returns the job for the id or null if not found.
 *
 * @param jobId the job id
 */
@Override
public PortabilityJob findJob(UUID jobId) 
{
    return this.jobs.get(jobId);
}   ",439,True
"// A key Generator and a single value:
public MapData(Generator<K> genK, V value, int quantity){
  for(int i = 0; i < quantity; i++) {
    put(genK.next(), value);
  }
}","// A key Generator and a single value:
public MapData(Generator<K> genK, V value, int quantity) 
{
    this.genK = genK;
    this.value = value;
    this.quantity = quantity;
    for(int i = 0; i < quantity; i++)
    {
        put(genK.next(), value);
    }
}   ",440,True
"/**
 * 长期存活对象进入老年代
 *
 * -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
 * Eden为8M，当分配allocation3 = new byte[4* _1MB]，触发minor GC，allocation1进入到Survivor空间中
 * 第二次allocation3 = new byte[4* _1MB]，再次触发minor GC 旧的4M对象被回收，因为MaxTenuringThreshold设置为1，allocation1进入到老年代
 *
 */
public static void testTenuringThreshold(){
    byte[] allocation1, allocation2, allocation3;
    allocation1 = new byte[_1MB /4];
    allocation2 = new byte[4* _1MB];
    allocation3 = new byte[4* _1MB];
    allocation3 = null;
    allocation3 = new byte[4* _1MB];
}","/**
 * 长期存活对象进入老年代
 *
 * -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
 * Eden为8M，当分配allocation3 = new byte[4* _1MB]，触发minor GC，allocation1进入到Survivor空间中
 * 第二次allocation3 = new byte[4* _1MB]，再次触发minor GC 旧的4M对象被回收，因为MaxTenuringThreshold设置为1，allocation1进入到老年代
 *
 */
public static void testTenuringThreshold() 
{
    byte[] allocation1, allocation2, allocation3;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[4 * _1MB];
    allocation3 = null;
    allocation3 = new byte[4 * _1MB];
}   ",441,True
"// Convert a String array to a TestParam array:
public static TestParam[] array(String[] values){
  int[] vals = new int[values.length];
  for(int i = 0; i < vals.length; i++)
    vals[i] = Integer.decode(values[i]);
  return array(vals);
}","// Convert a String array to a TestParam array:
public static TestParam[] array(String[] values) 
{
    int[] vals = new int[values.length];
    for(int i = 0; i < vals.length; i++)
        vals[i] = Integer.decode(values[i]);
    return array(vals);
}   ",443,True
"/**
 * 一维压缩 完全背包
 * 此处不需要从大到小遍历，因为物品可以多次放入背包，因此取得状态为第i个物品遍历体积的前序状态。
 * @param n
 * @param m
 * @param v
 * @param val
 * @return
 */
public int getMaxPackageValue2(int n,int m ,int[]v, int [] val){
    int[] dp = new int[m + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = v[i-1]; j <= m; j++) {
            dp[j] = Math.max(dp[j], dp[j-v[i-1]] + val [i-1]);
        }
    }
    return dp[m];
}","/**
 * 一维压缩 完全背包
 * 此处不需要从大到小遍历，因为物品可以多次放入背包，因此取得状态为第i个物品遍历体积的前序状态。
 * @param n
 * @param m
 * @param v
 * @param val
 * @return
 */
public int getMaxPackageValue2(int n,int m ,int[]v, int [] val) 
{
    int []dp=new int[m+1];
    for(int i=0;i<n;i++)
    {
        for(int j=v[i];j<=m;j++)
        {
            dp[j]=Math.max(dp[j],dp[j-v[i]]+val[i]);
        }
    }
    return dp[m];
}   ",445,True
"// An Iterable and a single value:
public MapData(Iterable<K> genK, V value){
  for(K key : genK) {
    put(key, value);
  }
}","// An Iterable and a single value:
public MapData(Iterable<K> genK, V value) 
{
    this.u = genK.iterator();
    this.next = null;
    this.value = value;
}   ",447,True
"/**
 * 01 背包一维数组的解法
 * 注意需要逆序处理，因为原先的二维压缩成一维，在开始第i个物品的遍历时，dp存储的为i-1个物品的最大价值。
 * 若使用顺序遍历，则i-1个物品的最大价值会被覆盖，每次放进物品取 dp[j-v[i-1]] 的数据是往前取，因此需要逆序遍历
 * f[j] = max(f[j], f[j-v[i]])
 * @param n
 * @param m
 * @param v
 * @param val
 * @return
 */
public int getMaxValueOfPackage2(int n, int m, int[] v, int[] val){
    int[] dp = new int[m + 1];
    for (int i = 1; i <= n; i++) {
        //优化使用j>=v[i-1], 仅需要查看 v[i-1] ~ m 这个体积区间的最大价值是否需要更新
        for (int j = m; j >=v[i-1]; j--) {
            dp[j] = Math.max(dp[j], dp[j-v[i-1]] + val[i-1]);
        }
    }
    return dp[m];
}","/**
 * 01 背包一维数组的解法
 * 注意需要逆序处理，因为原先的二维压缩成一维，在开始第i个物品的遍历时，dp存储的为i-1个物品的最大价值。
 * 若使用顺序遍历，则i-1个物品的最大价值会被覆盖，每次放进物品取 dp[j-v[i-1]] 的数据是往前取，因此需要逆序遍历
 * f[j] = max(f[j], f[j-v[i]])
 * @param n
 * @param m
 * @param v
 * @param val
 * @return
 */
public int getMaxValueOfPackage2(int n, int m, int[] v, int[] val) 
{
    int[] dp = new int[m+1];
    for(int i=1; i<=n; i++)
    {
        for(int j=m; j>=v[i-1]; j--)
        {
            dp[j] = Math.max(dp[j], dp[j-v[i-1]]+val[i-1]);
        }
    }
    return dp[m];
}   ",450,False
"/**
 * 动态空间担保
 * -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:HandlePromotionFailure
 * jdk6之后 -XX:HandlePromotionFailure 参数作废。
 */
public static void testHandlePromotion(){
    byte[] allocation1, allocation2, allocation3, allocation4,allocation5,allocation6,allocation7;
    allocation1 = new byte[2* _1MB];
    allocation2 = new byte[2* _1MB];
    allocation3 = new byte[2* _1MB];
    allocation1 = null;
    allocation4 = new byte[2* _1MB];
    allocation5 = new byte[2* _1MB];
    allocation6 = new byte[2* _1MB];
    allocation4 = null;
    allocation5 = null;
    allocation6 = null;
    allocation7 = new byte[2* _1MB];
}","/**
 * 动态空间担保
 * -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:HandlePromotionFailure
 * jdk6之后 -XX:HandlePromotionFailure 参数作废。
 */
public static void testHandlePromotion() 
{
    byte[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation1 = null;
    allocation4 = new byte[2 * _1MB];
    allocation5 = new byte[2 * _1MB];
    allocation6 = new byte[2 * _1MB];
    allocation4 = null;
    allocation7 = new byte[2 * _1MB];
}   ",453,True
"/**
 * 桶排序
 * 1. 获取最大最小树，桶的空间
 * 2. num[i] -min 定位桶索引，添加当前树到桶中。
 * 3. 使用索引扫描每个桶位，更新到排序数组中
 * @param nums
 */
public static void sort(int[] nums){
    int len = nums.length;
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    for (int num : nums) {
        min = Math.min(num, min);
        max = Math.max(num, max);
    }
    ArrayList<Integer>[] buckets = new ArrayList[max-min +1];
    for (int i = 0; i < buckets.length; i++) {
        buckets[i] = new ArrayList<>();
    }
    for (int i = 0; i < len; i++) {
        buckets[nums[i]-min].add(nums[i]);
    }
    for (int i = 0,j = 0; i < buckets.length; i++) {
        List<Integer> curList = buckets[i];
        int index = 0;
        while (!curList.isEmpty() && index< curList.size()){
            nums[j++] = curList.get(index++);
        }
    }
}","/**
 * 桶排序
 * 1. 获取最大最小树，桶的空间
 * 2. num[i] -min 定位桶索引，添加当前树到桶中。
 * 3. 使用索引扫描每个桶位，更新到排序数组中
 * @param nums
 */
public static void sort(int[] nums) 
{
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for(int num : nums)
    {
        max = Math.max(max, num);
        min = Math.min(min, num);
    }
    int bucketNum = max - min + 1;
    int[] bucket = new int[bucketNum];
    for(int num : nums)
    {
        bucket[num - min]++;
    }
    int idx = 0;
    for(int i = 0; i < bucketNum; i++)
    {
        while(bucket[i] > 0)
        {
            nums[idx++] = i + min;
            bucket[i]--;
        }
    }
}   ",455,True
"// An Iterable and a value Generator:
public MapData(Iterable<K> genK, Generator<V> genV){
  for(K key : genK) {
    put(key, genV.next());
  }
}","// An Iterable and a value Generator:
public MapData(Iterable<K> genK, Generator<V> genV) 
{
    this.genK = genK.iterator();
    this.genV = genV;
}   ",456,True
"/**
 * 多重背包三维数组版本较难理解  见备注
 * @param n
 * @param m
 * @param v
 * @param val
 * @param nums
 * @return
 */
public int getMaxValueOfPackage3(int n, int m, int[] v, int[] val, int[] nums){
    //取得物品中最大的数量
    int maxNum = Arrays.stream(nums).max().getAsInt();
    int[][][]dp = new int[n+1][m+1][maxNum+1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            for (int k = 1; k <=maxNum; k++) {
                // 如果体积满足 j>= k*v[i-1], 判断放k个物品进背包
                if(j>=k*v[i-1]) {
                    // 与i-1个物品放进max数量的最大价值比较。
                    dp[i][j][k] = Math.max(dp[i-1][j][maxNum], dp[i-1][j-k*v[i-1]][k] + k*val[i-1]);
                } else {
                    //若j无法放入k个物品，比较i-1个物品的放进max数量的最大价值 与  第i个物品放进k-1个物品的最大价值
                    // 这样默认[i][j][maxNum] 保证获取到前i个物品的最大价值
                    dp[i][j][k] = Math.max(dp[i-1][j][maxNum],dp[i][j][k-1]);
                }
            }
        }
    }
    return dp[n][m][maxNum];
}","/**
 * 多重背包三维数组版本较难理解  见备注
 * @param n
 * @param m
 * @param v
 * @param val
 * @param nums
 * @return
 */
public int getMaxValueOfPackage3(int n, int m, int[] v, int[] val, int[] nums) 
{
    int[][][] dp = new int[n+1][m+1][m+1];
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
        {
            for(int k=1; k<=m; k++)
            {
                if(j<v[i])
                {
                    dp[i][j][k] = dp[i-1][j][k];
                }
                else
                {
                    dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-v[i]][k-1]+val[i]);
                }
            }
        }
    }
    return dp[n][m][m];
}   ",459,False
"/** Test for <code>equals(Object)</code> method. */
public void testObject(){
  Metadata meta1 = new Metadata();
  Metadata meta2 = new Metadata();
  assertFalse(meta1.equals(null));
  assertFalse(meta1.equals(""String""));
  assertTrue(meta1.equals(meta2));
  meta1.add(""name-one"", ""value-1.1"");
  assertFalse(meta1.equals(meta2));
  meta2.add(""name-one"", ""value-1.1"");
  assertTrue(meta1.equals(meta2));
  meta1.add(""name-one"", ""value-1.2"");
  assertFalse(meta1.equals(meta2));
  meta2.add(""name-one"", ""value-1.2"");
  assertTrue(meta1.equals(meta2));
  meta1.add(""name-two"", ""value-2.1"");
  assertFalse(meta1.equals(meta2));
  meta2.add(""name-two"", ""value-2.1"");
  assertTrue(meta1.equals(meta2));
  meta1.add(""name-two"", ""value-2.2"");
  assertFalse(meta1.equals(meta2));
  meta2.add(""name-two"", ""value-2.x"");
  assertFalse(meta1.equals(meta2));
}","/** Test for <code>equals(Object)</code> method. */
public void testObject() 
{
    final Object obj = new Object();
    final Object obj2 = new Object();

    assertTrue(obj.equals(obj));
    assertFalse(obj.equals(obj2));
    assertFalse(obj.equals(null));
}   ",460,False
"/* ---------------------------------- *
 * <implementation:Configurable> *
 * ---------------------------------- */
private void setRobotNames(String[] robotNames){
  this.robotNames= new HashMap();
  for (int i= 0; i < robotNames.length; i++) {
    this.robotNames.put(robotNames[i].toLowerCase(), new Integer(i));
  }
  // always make sure ""*"" is included
  if (!this.robotNames.containsKey(""*""))
    this.robotNames.put(""*"", new Integer(robotNames.length));
}","/* ---------------------------------- *
 * <implementation:Configurable> *
 * ---------------------------------- */
private void setRobotNames(String[] robotNames) 
{
    this.robotNames = new String[robotNames.length];
    for (int i = 0; i < robotNames.length; i++)
    {
        this.robotNames[i] = robotNames[i];
    }
}   ",461,True
"/**
 *  Returns <code>false</code> if the <code>robots.txt</code> file
 *  prohibits us from accessing the given <code>url</code>, or
 *  <code>true</code> otherwise.
 */
public boolean isAllowed(URL url){
  String path = url.getPath();                  // check rules
  if ((path == null) || """".equals(path)) {
    path= ""/"";
  }
  return isAllowed(path);
}","/**
 *  Returns <code>false</code> if the <code>robots.txt</code> file
 *  prohibits us from accessing the given <code>url</code>, or
 *  <code>true</code> otherwise.
 */

public boolean isAllowed(URL url) 
{
    try
    {
        return robots.isAllowed(url);
    }
    catch (IOException e)
    {
        return false;
    }
}   ",462,True
"/** Test for <code>setAll(Properties)</code> method. */
public void testSetProperties(){
  String[] values = null;
  Metadata meta = new Metadata();
  Properties props = new Properties();

  meta.setAll(props);
  assertEquals(0, meta.size());

  props.setProperty(""name-one"", ""value1.1"");
  meta.setAll(props);
  assertEquals(1, meta.size());
  values = meta.getValues(""name-one"");
  assertEquals(1, values.length);
  assertEquals(""value1.1"", values[0]);

  props.setProperty(""name-two"", ""value2.1"");
  meta.setAll(props);
  assertEquals(2, meta.size());
  values = meta.getValues(""name-one"");
  assertEquals(1, values.length);
  assertEquals(""value1.1"", values[0]);
  values = meta.getValues(""name-two"");
  assertEquals(1, values.length);
  assertEquals(""value2.1"", values[0]);
}","/** Test for <code>setAll(Properties)</code> method. */
public void testSetProperties() 
{
    Properties props = new Properties();
    props.setProperty(""name"", ""John Doe"");
    props.setProperty(""age"", ""30"");
    props.setProperty(""gender"", ""Male"");

    Person person = new Person();
    person.setAll(props);

    assertEquals(""John Doe"", person.getName());
    assertEquals(30, person.getAge());
    assertEquals(""Male"", person.getGender());
}   ",468,False
"/**
 * Set the {@link Configuration} object
 */
public void setConf(Configuration conf){
  this.conf = conf;

  deduplicate = conf.getBoolean(""anchorIndexingFilter.deduplicate"", false);
  LOG.info(""Anchor deduplication is: "" + (deduplicate ? ""on"" : ""off""));
}","/**
 * Set the {@link Configuration} object
 */
public void setConf(Configuration conf) 
{
    this.conf = conf;
    this.conf.set(""mapreduce.input.fileinputformat.split.minsize"", String.valueOf(32 * 1024 * 1024));
    this.conf.set(""mapreduce.input.fileinputformat.split.maxsize"", String.valueOf(32 * 1024 * 1024));
}   ",469,False
"/**
 * Calls the {@link FeedParser} on a sample RSS file and checks that there are
 * 3 {@link ParseResult} entries including the below 2 links:
 * <ul>
 * <li>http://www-scf.usc.edu/~mattmann/</li>
 * <li>http://www.nutch.org</li>
 * </ul>
 * 
 * 
 * @throws ProtocolNotFound
 *           If the {@link Protocol}Layer cannot be loaded (required to fetch
 *           the {@link Content} for the RSS file).
 * @throws ParseException
 *           If the {@link Parser}Layer cannot be loaded.
 */
public void testParseFetchChannel() throws ProtocolNotFound, ParseException{
  String urlString;
  Protocol protocol;
  Content content;
  ParseResult parseResult;

  Configuration conf = NutchConfiguration.create();
  for (int i = 0; i < sampleFiles.length; i++) {
    urlString = ""file:"" + sampleDir + fileSeparator + sampleFiles[i];
    urlString = urlString.replace('\\', '/');

    protocol = new ProtocolFactory(conf).getProtocol(urlString);
    content = protocol.getProtocolOutput(new Text(urlString),
        new CrawlDatum()).getContent();

    parseResult = new ParseUtil(conf).parseByExtensionId(""feed"", content);

    assertEquals(3, parseResult.size());

    boolean hasLink1 = false, hasLink2 = false, hasLink3=false;

    for (Iterator<Map.Entry<Text, Parse>> j = parseResult.iterator(); j
        .hasNext();) {
      Map.Entry<Text, Parse> entry = j.next();
      if (entry.getKey().toString().equals(
          ""http://www-scf.usc.edu/~mattmann/"")) {
        hasLink1 = true;
      } else if (entry.getKey().toString().equals(""http://www.nutch.org/"")) {
        hasLink2 = true;
      }
      else if(entry.getKey().toString().equals(urlString)){
        hasLink3 = true;
      }

      assertNotNull(entry.getValue());
      assertNotNull(entry.getValue().getData());
    }

    if (!hasLink1 || !hasLink2 || !hasLink3) {
      fail(""Outlinks read from sample rss file are not correct!"");
    }
  }

}","/**
 * Calls the {@link FeedParser} on a sample RSS file and checks that there are
 * 3 {@link ParseResult} entries including the below 2 links:
 * <ul>
 * <li>http://www-scf.usc.edu/~mattmann/</li>
 * <li>http://www.nutch.org</li>
 * </ul>
 * 
 * 
 * @throws ProtocolNotFound
 *           If the {@link Protocol}Layer cannot be loaded (required to fetch
 *           the {@link Content} for the RSS file).
 * @throws ParseException
 *           If the {@link Parser}Layer cannot be loaded.
 */


public void testParseFetchChannel() throws ProtocolNotFound, ParseException 
{
    // Create a new instance of the FeedParser
    FeedParser parser = new FeedParser();

    // Set the URL of the RSS file to fetch
    String url = ""file:////home/mattmann/Downloads/rss.xml"";

    // Fetch the content of the RSS file
    Content content = Protocol.fetchContent(new URL(url));

    // Parse the content and get the list of ParseResult entries
    List<ParseResult> results = parser.parseFetchChannel(content);

    // Assert that there are 3 ParseResult entries
    Assert.assertEquals(3, results.size());

    // Assert that the first ParseResult entry has the expected link
    Assert.assertEquals(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"", results.get(0).getLink().toString());

    // Assert that the second ParseResult entry has the expected link
    Assert.assertEquals(""XXXXXXXXXXXXXXXXXXXX"", results.get(1).getLink().toString());
}   ",472,True
"/** Test for <code>names</code> method. */
public void testNames(){
  String[] names = null;
  Metadata meta = new Metadata();
  names = meta.names();
  assertEquals(0, names.length);

  meta.add(""name-one"", ""value"");
  names = meta.names();
  assertEquals(1, names.length);
  assertEquals(""name-one"", names[0]);
  meta.add(""name-two"", ""value"");
  names = meta.names();
  assertEquals(2, names.length);
}","/** Test for <code>names</code> method. */
public void testNames() 
{
    String[] names = _type.names();
    assertNotNull(names);
    assertEquals(2, names.length);
    assertEquals(""name"", names[0]);
    assertEquals(""value"", names[1]);
}   ",476,True
"/**
 * Returns PathFilter that passes directories through.
 */
public static PathFilter getPassDirectoriesFilter(final FileSystem fs){
    return new PathFilter() {
        public boolean accept(final Path path) {
            try {
                return fs.getFileStatus(path).isDir();
            } catch (IOException ioe) {
                return false;
            }
        }

    };
}","/**
 * Returns PathFilter that passes directories through.
 */

public static PathFilter getPassDirectoriesFilter(final FileSystem fs) 
{
    return new PathFilter()
    {
        @Override
        public boolean accept(Path path)
        {
            try
            {
                return fs.getFileStatus(path).isDirectory();
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
        }
    };
}   ",478,True
"//是否开启 md5 ，seckillId
public ExposerRsp(boolean exposed, String md5, long seckillId){
    this.exposed = exposed;
    this.md5 = md5;
    this.seckillId = seckillId;
}","//是否开启 md5 ，seckillId
public ExposerRsp(boolean exposed, String md5, long seckillId) 
{
    this.exposed = exposed;
    this.md5 = md5;
    this.seckillId = seckillId;
}   ",480,True
"/**
 * <p>
 * 读取控制台内容
 * </p>
 */
public static String scanner(String tip){
    Scanner scanner = new Scanner(System.in);
    StringBuilder help = new StringBuilder();
    help.append(""请输入"" + tip + ""："");
    System.out.println(help.toString());
    if (scanner.hasNext()) {
        String ipt = scanner.next();
        if (StringUtils.isNotEmpty(ipt)) {
            return ipt;
        }
    }
    throw new MybatisPlusException(""请输入正确的"" + tip + ""！"");
}","/**
 * <p>
 * 读取控制台内容
 * </p>
 */

public static String scanner(String tip) 
{
    Scanner scanner = new Scanner(System.in);
    StringBuilder help = new StringBuilder();
    help.append(""请输入"" + tip + ""："");
    System.out.println(help.toString());
    if (scanner.hasNext())
    {
        String ipt = scanner.next();
        if (!StringUtils.isEmpty(ipt))
        {
            return ipt;
        }
    }
    return """";
}   ",481,True
"/**
 * 向指定URL发送get请求
 * @param url发送请求的URL
 * @param param请求参数 格式满足name1=value&name2=value2 的形式
 * @return URL代表远程资源的响应
 */
public static String sendGet(String url,String param){
	String result="""";
	String urlName = url;
	if(param != null){
		urlName = url + ""?"" + param;
	}
	try {
		URL realUrl = new URL(urlName);
		//打开与URL的连接
		URLConnection conn = realUrl.openConnection();
		//设置通用的请求属性
		conn.setRequestProperty(""accept"", ""*/*"");
		conn.setRequestProperty(""connection"", ""Keep-Alive"");
		conn.setRequestProperty(""user-agent"", ""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1""
				+ ""; SV1)"");
		//建立实际的连接
		conn.connect();
		//获取所有的响应头字段
		Map<String, List<String>> map = conn.getHeaderFields();
		for(String key : map.keySet()){
			System.out.println(key + ""--->"" + map.get(key));
		}
		try(BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(),""utf-8""))){
			String line;
			while((line = in.readLine()) != null){
				result += ""\n"" +line;
			}
		}
	} catch (Exception e) {
		System.out.println(""发送请求异常"");
		e.printStackTrace();
	}
	return result;
}","/**
 * 向指定URL发送get请求
 * @param url发送请求的URL
 * @param param请求参数 格式满足name1=value&name2=value2 的形式
 * @return URL代表远程资源的响应
 */



public static String sendGet(String url,String param) 
{
    String result = """";
    BufferedReader in = null;
    try
    {
        String urlNameString = url + ""?"" + param;
        URL realUrl = new URL(urlNameString);
        URLConnection connection = realUrl.openConnection();
        connection.setRequestProperty(""accept"", ""*/*"");
        connection.setRequestProperty(""connection"", ""Keep-Alive"");
        connection.setRequestProperty(""user-agent"",
                ""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)"");
        connection.connect();
        in = new BufferedReader(new InputStreamReader(
                connection.getInputStream()));
        String line;
        while ((line = in.readLine()) != null)
        {
            result += line;
        }
    } catch (Exception e)
    {
        System.out.println(""发送GET请求出现异常！"" + e);
        e.printStackTrace();
    }
    finally
    {
        try
        {
            if (in != null)
            {
                in.close();
            }
        } catch (Exception e2)
        {
            e2.printStackTrace();
        }
    }
    return result;
}   ",483,True
"//初始化，创建服务器
public void init(){
	try {
		port = Integer.parseInt(prop.getProperty(""port""));
		server = new ServerSocket(port);
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}","//初始化，创建服务器



public void init() 
{
    try
    {
        serverSocket = new ServerSocket(port);
        System.out.println(""服务器已启动"");
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",484,True
"/**
 * cookie管理对象
 * @return
 */
public CookieRememberMeManager rememberMeManager(){
    CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager();
    cookieRememberMeManager.setCookie(rememberMeCookie());
    // rememberMe cookie加密的密钥
    cookieRememberMeManager.setCipherKey(Base64.decode(""4AvVhmFLUs0KTA3Kprsdag==""));
    return cookieRememberMeManager;
}","/**
 * cookie管理对象
 * @return
 */
public CookieRememberMeManager rememberMeManager() 
{
	CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager();
	cookieRememberMeManager.setCookie(rememberMeCookie());
	return cookieRememberMeManager;
}   ",492,False
"/**"", ""anon"");
        filterChainDefinitionMap.put(""/js/**"", ""anon"");
        filterChainDefinitionMap.put(""/fonts/**"", ""anon"");
        filterChainDefinitionMap.put(""/img/**"", ""anon"");
        // druid数据源监控页面不拦截
        filterChainDefinitionMap.put(""/druid/**"", ""anon"");
        // 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了
        filterChainDefinitionMap.put(""/logout"", ""logout"");
        filterChainDefinitionMap.put(""/"", ""anon"");
        // 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl
        filterChainDefinitionMap.put(""/**"", ""user"");
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置 SecurityManager 加载自定义 Realm
     *
     * @return
     */
@Bean
    public SecurityManager securityManager(){
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        // 加载 shiroRealm
        securityManager.setRealm(shiroRealm());
        // 加载 cookie
        securityManager.setRememberMeManager(rememberMeManager());
        // 加载 redisManager
        securityManager.setCacheManager(cacheManager());
        // 加载 SessionManager
        securityManager.setSessionManager(sessionManager());
        return securityManager;
    }","/**"", ""anon"");

        filterChainDefinitionMap.put(""/js/**"", ""anon"");
        filterChainDefinitionMap.put(""/fonts/**"", ""anon"");
        filterChainDefinitionMap.put(""/img/**"", ""anon"");
        // druid数据源监控页面不拦截
        filterChainDefinitionMap.put(""/druid/**"", ""anon"");
        // 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了
        filterChainDefinitionMap.put(""/logout"", ""logout"");
        filterChainDefinitionMap.put(""/"", ""anon"");
        // 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl
        filterChainDefinitionMap.put(""/**"", ""user"");
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置 SecurityManager 加载自定义 Realm
     *
     * @return
     */
@Bean
    public SecurityManager securityManager() 
{
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    securityManager.setRealm(myShiroRealm());
    return securityManager;
}   ",493,True
"/**
 * 向指定的URL发送Post请求
 * @param url 发送请求的url
 * @param param 请求参数 ，格式满足 name1=value1&name2=value2的形式
 * @return URL代表远程资源的响应
 */
public static String sendPost(String url,String param){
	String result = """";
	try {
		URL realUrl = new URL(url);
		//打开和URL之间的连接
		URLConnection conn = realUrl.openConnection();
		//设置通用的请求属性
		conn.setRequestProperty(""accept"", ""*/*"");
		conn.setRequestProperty(""connection"", ""Keep-Alive"");
		conn.setRequestProperty(""user-agent"", ""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1""
				+ ""; SV1)"");
		//发送post请求必须设置如下两行
		conn.setDoOutput(true);
		conn.setDoInput(true);
		try(//获取URLConnection对象对应的输出流
				PrintWriter out = new PrintWriter(conn.getOutputStream())
		){
			//发送请求参数
			out.print(param);
			//flush输出流的缓冲
			out.flush();
		}
		try(//定义BufferedReader输入流来读取URL的响应
				BufferedReader in = new BufferedReader(
						new InputStreamReader(conn.getInputStream(), ""utf-8""))
		){
			String line;
			while((line = in.readLine()) != null){
				result += ""\n"" + line;
			}
		}
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}

	return result;
}","/**
 * 向指定的URL发送Post请求
 * @param url 发送请求的url
 * @param param 请求参数 ，格式满足 name1=value1&name2=value2的形式
 * @return URL代表远程资源的响应
 */










public static String sendPost(String url,String param) 
{
    PrintWriter out = null;
    BufferedReader in = null;
    String result = """";
    try
    {
        URL realUrl = new URL(url);
        //打开和URL之间的连接
        URLConnection conn = realUrl.openConnection();
        //设置通用的请求属性
        conn.setRequestProperty(""accept"", ""*/*"");
        conn.setRequestProperty(""connection"", ""Keep-Alive"");
        conn.setRequestProperty(""user-agent"", ""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)"");
        //发送POST请求必��设置如下两行
        conn.setDoOutput(true);
        conn.setDoInput(true);
        //获取URLConnection对象对应的输出流
        out = new PrintWriter(conn.getOutputStream());
        //发送请求参数
        out.print(param);
        //flush输出流的����
        out.flush();
        //定义BufferedReader输入流来读取URL的��应
        in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line;
        while ((line = in.readLine()) != null)
        {
            result += line;
        }
    }
    catch (Exception e)
    {
        System.out.println(""发送POST请求出现异常！"" + e);
        e.printStackTrace();
    }
    //使用finally��来关闭输出流、输入流
    finally
    {
        try
        {
            if (out != null)
            {
                out.close();
            }
            if (in != null)
            {
                in.close();
            }
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
        }
    }
    return result;
}   ",494,True
"//	测试是否获得慕课问答页面源码
//	测试是否获取问题的url
public static void main(String[] args){
		String url = ""http://www.imooc.com/wenda"";
		String regex = ""class=\""content\"".+?href=\""(.+?)\"".+?</a>"";
		String result = getSource(url);
		List<String> wendaUrl = getImoocPage(result,regex);
		System.out.println(wendaUrl);
	}","//	测试是否获得慕课问答页面源码
//	测试是否获取问题的url
public static void main(String[] args) 
{
	String url = ""http://www.zhihu.com/question/21199990"";
	String result = SpiderUtils.getHtml(url);
	System.out.println(result);
}   ",495,False
"//	没有用到
/**
 * 获取问题页面url
 * @param quesSource 页面源码
 * @param regex      匹配正则表达式
 * @return
 */
public static List<String> getImoocPage(String quesSource,String regex){
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(quesSource);
		List<String> quesUrl = new ArrayList<String>();
		while(matcher.find()){
			String url = ""http://www.imooc.com""+matcher.group(1);
			quesUrl.add(url);
		}
//		System.out.println(quesUrl);	
		return quesUrl;
	}","//	没有用到
/**
 * 获取问题页面url
 * @param quesSource 页面源码
 * @param regex      匹配正则表达式
 * @return
 */






public static List<String> getImoocPage(String quesSource,String regex) 
{
	List<String> list = new ArrayList<String>();
	Pattern pattern = Pattern.compile(regex);
	Matcher matcher = pattern.matcher(quesSource);
	while (matcher.find())
	{
		list.add(matcher.group());
	}
	return list;
}   ",496,False
"/**
     *  Close the single hibernate session instance.
     *
     *  @throws HibernateException
     */
public static void closeSession() throws Exception{
    	SqlSession session = (SqlSession) threadLocal.get();
        threadLocal.set(null);

        if (session != null) {
            session.close();
        }
    }","/**
     *  Close the single hibernate session instance.
     *
     *  @throws HibernateException
     */
public static void closeSession() throws Exception 
{
    if (session != null)
    {
        session.close();
    }
}    ",497,True
"//集成测试代码完整逻辑，注意重复执行
@Test
public void seckillLogic() throws Exception{
    long id = 1004;
    ExposerRsp exposerRsp = seckillService.exprotSeckillUrl(id);
    if(exposerRsp.isExposed()){
        logger.info(""expose={}"",exposerRsp);
        long phone = 13023217863L;
        String md5 = ""9f26737a177b65c934341b48e4cdf21c"";
        try {
            SeckillExecutionRsp executionRsp = seckillService.executeSeckill(id, phone, md5);
            logger.info(""result={}"",executionRsp);
        } catch (RepeatKillException e){
            logger.error(e.getMessage(), e);
        } catch (SeckillCloseException e){
            logger.error(e.getMessage(), e);
        }
    }else{
        logger.warn(""expose={}"",exposerRsp);
    }


    //exposed=true,
    // md5='9f26737a177b65c934341b48e4cdf21c',
    // seckillId=1004,
    // now=0,
    // start=0,
    // end=0
}","//集成测试代码完整逻辑，注意重复执行
@Test
public void seckillLogic() throws Exception 
{
    long id = 1001;
    Exposer exposer = seckillService.exportSeckillUrl(id);
    if(exposer.isExposed())
    {
        long phone = 13502171131L;
        String md5 = exposer.getMd5();
        try
        {
            SeckillExecution seckillExecution = seckillService.executeSeckill(id, phone, md5);
            System.out.println(seckillExecution);
        }
        catch (RepeatKillException e)
        {
            e.printStackTrace();
        }
        catch (SeckillCloseException e)
        {
            e.printStackTrace();
        }
    }
    else
    {
        System.out.println(""exposer = "" + exposer);
    }
}   ",498,True
"/**
     *  Rebuild hibernate session factory
     *
     */
public static void rebuildSessionFactory(){
	try {
		InputStream is = Resources.getResourceAsStream(configFile);
		sessionFactory = builder.build(is);
	} catch (Exception e) {
		System.err
				.println(""%%%% Error Creating SessionFactory %%%%"");
		e.printStackTrace();
	}
}","/**
     *  Rebuild hibernate session factory
     *
     */

public static void rebuildSessionFactory() 
{
    synchronized (sessionFactory)
    {
        Configuration configuration = new Configuration();
        configuration.configure();
        serviceRegistry = new ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();
        sessionFactory = configuration.buildSessionFactory(serviceRegistry);
    }
}    ",499,True
"/**
 * Constructs TreePath from Status String.
 * @param pathString
 * @return a TreePath, or null if there is an error.
 */
private TreePath generatePath(String pathString){
    List<String> nodes = parsePathString(pathString);
    if (nodes == null)
    {
        return null;
    }
    Object obj = rootNode;
    TreePath treePath = new TreePath(obj);
    for (String node : nodes)
    {
        obj = searchNode(obj, node);
        if (obj == null)
        {
            return null;
        }
        treePath = treePath.pathByAddingChild(obj);
    }
    return treePath;
}","/**
 * Constructs TreePath from Status String.
 * @param pathString
 * @return a TreePath, or null if there is an error.
 */
private TreePath generatePath(String pathString) 
{
    TreePath path = null;
    String[] pathComponents = pathString.split("":"");
    Object[] pathArray = new Object[pathComponents.length];
    for (int i = 0; i < pathArray.length; i++)
    {
        if (pathComponents[i].equals(""null""))
        {
            pathArray[i] = null;
        }
        else
        {
            pathArray[i] = pathComponents[i];
        }
    }
    path = new TreePath(pathArray);
    return path;
}   ",501,False
"/**
 * This will set the contents of this page.
 *
 * @param contents Array of new contents of the page.
 */
public void setContents(List<PDStream> contents){
    COSArray array = new COSArray();
    contents.forEach(array::add);
    page.setItem(COSName.CONTENTS, array);
}","/**
 * This will set the contents of this page.
 *
 * @param contents Array of new contents of the page.
 */

public void setContents(List<PDStream> contents) 
{
    this.contents = new ArrayList<PDStream>();
    for (PDStream stream : contents)
    {
        this.contents.add(stream);
    }
}   ",503,True
"/**
 * This will set the mediaBox for this page.
 * 
 * @param mediaBox The new mediaBox for this page.
 */
public void setMediaBox(PDRectangle mediaBox){
    this.mediaBox = mediaBox;
    if (mediaBox == null)
    {
        page.removeItem(COSName.MEDIA_BOX);
    }
    else
    {
        page.setItem(COSName.MEDIA_BOX, mediaBox);
    }
}","/**
 * This will set the mediaBox for this page.
 * 
 * @param mediaBox The new mediaBox for this page.
 */
public void setMediaBox(PDRectangle mediaBox) 
{
    if (mediaBox == null)
    {
        this.mediaBox = null;
    }
    else
    {
        this.mediaBox = new PDRectangle(mediaBox);
    }
}   ",505,True
"/**
 * Get the user unit. This is a positive number that shall give the size of default user space
 * units, in multiples of 1/72 inch. This is supported by PDF 1.6 and higher.
 *
 * @param userUnit
 * throws IllegalArgumentException if the parameter is not positive.
 */
public void setUserUnit(float userUnit){
    if (userUnit <= 0)
    {
        throw new IllegalArgumentException(""User unit must be positive"");
    }
    page.setFloat(COSName.USER_UNIT, userUnit);
}","/**
 * Get the user unit. This is a positive number that shall give the size of default user space
 * units, in multiples of 1/72 inch. This is supported by PDF 1.6 and higher.
 *
 * @param userUnit
 * throws IllegalArgumentException if the parameter is not positive.
 */
public void setUserUnit(float userUnit) 
{
    if (userUnit <= 0)
    {
        throw new IllegalArgumentException(""UserUnit must be a positive number"");
    }
    this.userUnit = userUnit;
}   ",507,False
"/**
 * Get the viewports.
 *
 * @return a list of viewports or null if there is no /VP entry.
 */
public List<PDViewportDictionary> getViewports(){
    COSBase base = page.getDictionaryObject(COSName.VP);
    if (!(base instanceof COSArray))
    {
        return null;
    }
    COSArray array = (COSArray) base;
    List<PDViewportDictionary> viewports = new ArrayList<>();
    for (int i = 0; i < array.size(); ++i)
    {
        COSBase base2 = array.getObject(i);
        if (base2 instanceof COSDictionary)
        {
            viewports.add(new PDViewportDictionary((COSDictionary) base2));
        }
        else
        {
            LOG.warn(""Array element "" + base2 + "" is skipped, must be a (viewport) dictionary"");
        }
    }
    return viewports;
}","/**
 * Get the viewports.
 *
 * @return a list of viewports or null if there is no /VP entry.
 */











public List<PDViewportDictionary> getViewports() 
{
    COSArray array = (COSArray) dictionary.getDictionaryObject(COSName.VP);
    if (array != null)
    {
        List<PDViewportDictionary> viewports = new ArrayList<PDViewportDictionary>();
        for (int i = 0; i < array.size(); i++)
        {
            COSDictionary viewportDictionary = (COSDictionary) array.get(i);
            PDViewportDictionary viewport = new PDViewportDictionary(viewportDictionary);
            viewports.add(viewport);
        }
        return viewports;
    }
    return null;
}   ",509,True
"/**
 * This will set the resources for this page.
 * 
 * @param resources The new resources for this page.
 */
public void setResources(PDResources resources){
    pageResources = resources;
    if (resources != null)
    {
        page.setItem(COSName.RESOURCES, resources);
    }
    else
    {
        page.removeItem(COSName.RESOURCES);
    }
}","/**
 * This will set the resources for this page.
 * 
 * @param resources The new resources for this page.
 */
public void setResources(PDResources resources) 
{
    if (resources == null)
    {
        throw new IllegalArgumentException(""Resources cannot be null"");
    }
    this.resources = resources;
}   ",510,False
"/**
 * Returns the content stream(s) of this page as a single input stream.
 *
 * @return An InputStream, never null. Multiple content streams are concatenated and separated
 * with a newline. An empty stream is returned if the page doesn't have any content stream.
 * @throws IOException If the stream could not be read
 */
@Override
public InputStream getContents() throws IOException{
    COSBase base = page.getDictionaryObject(COSName.CONTENTS);
    if (base instanceof COSStream)
    {
        return ((COSStream)base).createInputStream();
    }
    else if (base instanceof COSArray && ((COSArray) base).size() > 0)
    {
        COSArray streams = (COSArray)base;
        byte[] delimiter = new byte[] { '\n' };
        List<InputStream> inputStreams = new ArrayList<>();
        for (int i = 0; i < streams.size(); i++)
        {
            COSBase strm = streams.getObject(i);
            if (strm instanceof COSStream)
            {
                COSStream stream = (COSStream) strm;
                inputStreams.add(stream.createInputStream());
                inputStreams.add(new ByteArrayInputStream(delimiter));
            }
        }
        return new SequenceInputStream(Collections.enumeration(inputStreams));
    }
    return new ByteArrayInputStream(new byte[0]);
}","/**
 * Returns the content stream(s) of this page as a single input stream.
 *
 * @return An InputStream, never null. Multiple content streams are concatenated and separated
 * with a newline. An empty stream is returned if the page doesn't have any content stream.
 * @throws IOException If the stream could not be read
 */



@Override
public InputStream getContents() throws IOException 
{
    if (contents == null)
    {
        return new ByteArrayInputStream(new byte[0]);
    }
    if (contents.size() == 1)
    {
        return contents.get(0).getStream();
    }
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    for (PDStream stream : contents)
    {
        out.write(stream.getStream().readAllBytes());
        out.write('\n');
    }
    return new ByteArrayInputStream(out.toByteArray());
}   ",512,False
"/**
 * Get the user unit. This is a positive number that shall give the size of default user space
 * units, in multiples of 1/72 inch, or 1 if it hasn't been set. This is supported by PDF 1.6
 * and higher.
 *
 * @return the user unit.
 */
public float getUserUnit(){
    float userUnit = page.getFloat(COSName.USER_UNIT, 1.0f);
    return userUnit > 0 ? userUnit : 1.0f;
}","/**
 * Get the user unit. This is a positive number that shall give the size of default user space
 * units, in multiples of 1/72 inch, or 1 if it hasn't been set. This is supported by PDF 1.6
 * and higher.
 *
 * @return the user unit.
 */
public float getUserUnit() 
{
    return userUnit;
}   ",514,False
"/**
 * Returns the content streams which make up this page.
 * 
 * @return content stream iterator
 */
public Iterator<PDStream> getContentStreams(){
    List<PDStream> streams = new ArrayList<>();
    COSBase base = page.getDictionaryObject(COSName.CONTENTS);
    if (base instanceof COSStream)
    {
        streams.add(new PDStream((COSStream) base));
    }
    else if (base instanceof COSArray && ((COSArray) base).size() > 0)
    {
        COSArray array = (COSArray)base;
        for (int i = 0; i < array.size(); i++)
        {
            COSStream stream = (COSStream) array.getObject(i);
            streams.add(new PDStream(stream));
        }
    }
    return streams.iterator();
}","/**
 * Returns the content streams which make up this page.
 * 
 * @return content stream iterator
 */





public Iterator<PDStream> getContentStreams() 
{
    List<PDStream> list = new ArrayList<PDStream>();
    for (PDStream stream : streams)
    {
        if (stream.getStream() instanceof PDPageContentStream)
        {
            list.add(stream);
        }
    }
    return list.iterator();
}   ",517,False
"/**
 * Fixes the error by assigning the result of the call to the receiver reference, or deleting the
 * method call.
 */
private Description describe(MethodInvocationTree methodInvocationTree, VisitorState state){
  // Find the root of the field access chain, i.e. a.intern().trim() ==> a.
  ExpressionTree identifierExpr = ASTHelpers.getRootAssignable(methodInvocationTree);
  String identifierStr = null;
  Type identifierType = null;
  if (identifierExpr != null) {
    identifierStr = state.getSourceForNode(identifierExpr);
    if (identifierExpr instanceof JCIdent) {
      identifierType = ((JCIdent) identifierExpr).sym.type;
    } else if (identifierExpr instanceof JCFieldAccess) {
      identifierType = ((JCFieldAccess) identifierExpr).sym.type;
    } else {
      throw new IllegalStateException(""Expected a JCIdent or a JCFieldAccess"");
    }
  }

  Type returnType = getReturnType(((JCMethodInvocation) methodInvocationTree).getMethodSelect());

  Fix fix;
  if (identifierStr != null
      && !""this"".equals(identifierStr)
      && returnType != null
      && state.getTypes().isAssignable(returnType, identifierType)) {
    // Fix by assigning the assigning the result of the call to the root receiver reference.
    fix = SuggestedFix.prefixWith(methodInvocationTree, identifierStr + "" = "");
  } else {
    // Unclear what the programmer intended.  Delete since we don't know what else to do.
    Tree parent = state.getPath().getParentPath().getLeaf();
    fix = SuggestedFix.delete(parent);
  }
  return describeMatch(methodInvocationTree, fix);
}","/**
 * Fixes the error by assigning the result of the call to the receiver reference, or deleting the
 * method call.
 */
private Description describe(MethodInvocationTree methodInvocationTree, VisitorState state) 
{
    ExpressionTree receiver = methodInvocationTree.getMethodSelect();
    if (receiver.getKind() == Tree.Kind.IDENTIFIER) {
        return describe((IdentifierTree)receiver, methodInvocationTree, state);
    }
    return describe(receiver, methodInvocationTree, state);
}   ",520,False
"// subscribeWith only works IFF the argument passed implements Disposable
public void subscribeWithOnlyDisposable(){
  Observer<Integer> o =
      Observable.just(1)
          .subscribeWith(
              new DisposableObserver<Integer>() {

                @Override
                public void onNext(Integer integer) {}

                @Override
                public void onError(Throwable e) {}

                @Override
                public void onComplete() {}
              });
  DisposableObserver<Integer> o2 =
      Observable.just(1)
          .subscribeWith(
              new DisposableObserver<Integer>() {

                @Override
                public void onNext(Integer integer) {}

                @Override
                public void onError(Throwable e) {}

                @Override
                public void onComplete() {}
              });
}","// subscribeWith only works IFF the argument passed implements Disposable

public void subscribeWithOnlyDisposable() 
{
    Observable.just(1, 2, 3, 4)
            .subscribeWith(new DisposableObserver<Integer>() {
                @Override
                public void onNext(Integer integer) {
                    System.out.println(integer);
                }

                @Override
                public void onError(Throwable e) {
                    System.out.println(""Error: "" + e.getMessage());
                }

                @Override
                public void onComplete() {
                    System.out.println(""Completed"");
                }
            });
}   ",521,True
"/**
 * Builds the error message with the consumer class.
 *
 * @param consumer the class of the consumer
 * @return the error message string
 */
public static String composeMessage(String consumer){
  return ""It is not allowed to subscribe with a(n) ""
      + consumer
      + "" multiple times. ""
      + ""Please create a fresh instance of ""
      + consumer
      + "" and subscribe that to the target source instead."";
}","/**
 * Builds the error message with the consumer class.
 *
 * @param consumer the class of the consumer
 * @return the error message string
 */
public static String composeMessage(String consumer) 
{
    return ""The class "" + consumer + "" is not a valid consumer."";
}   ",523,False
"/**
 * Overload for resolving lifecycle providers allows configuration of checking ""end"" boundaries of
 * lifecycles. That is, they will ensure that the lifecycle has both started and not ended, and
 * otherwise will throw one of {@link LifecycleNotStartedException} (if {@link
 * LifecycleScopeProvider#peekLifecycle() peekLifecycle} returns {@code null}) or {@link
 * LifecycleEndedException} if the lifecycle is ended. To configure the runtime behavior of these
 * exceptions, see {@link AutoDisposePlugins}.
 *
 * <p><em>Note:</em> This resolves the scope immediately, so consider deferring execution as
 * needed, such as using {@link Completable#defer(Supplier) defer}.
 *
 * @param provider the {@link LifecycleScopeProvider} to resolve.
 * @param checkEndBoundary whether or not to check that the lifecycle has ended
 * @param <E> the lifecycle event type
 * @return a resolved {@link CompletableSource} representation of a given provider
 * @throws OutsideScopeException if the {@link LifecycleScopeProvider#correspondingEvents()}
 *     throws an {@link OutsideScopeException} during resolution.
 */
public static <E> CompletableSource resolveScopeFromLifecycle(
    final LifecycleScopeProvider<E> provider, final boolean checkEndBoundary)
    throws OutsideScopeException{
  E lastEvent = provider.peekLifecycle();
  CorrespondingEventsFunction<E> eventsFunction = provider.correspondingEvents();
  if (lastEvent == null) {
    throw new LifecycleNotStartedException();
  }
  E endEvent;
  try {
    endEvent = eventsFunction.apply(lastEvent);
  } catch (Exception e) {
    if (checkEndBoundary && e instanceof LifecycleEndedException) {
      Consumer<? super OutsideScopeException> handler =
          AutoDisposePlugins.getOutsideScopeHandler();
      if (handler != null) {
        try {
          handler.accept((LifecycleEndedException) e);

          // Swallowed the end exception, just silently dispose immediately.
          return Completable.complete();
        } catch (Throwable e1) {
          return Completable.error(e1);
        }
      }
      throw e;
    }
    return Completable.error(e);
  }
  return resolveScopeFromLifecycle(provider.lifecycle(), endEvent);
}","/**
 * Overload for resolving lifecycle providers allows configuration of checking ""end"" boundaries of
 * lifecycles. That is, they will ensure that the lifecycle has both started and not ended, and
 * otherwise will throw one of {@link LifecycleNotStartedException} (if {@link
 * LifecycleScopeProvider#peekLifecycle() peekLifecycle} returns {@code null}) or {@link
 * LifecycleEndedException} if the lifecycle is ended. To configure the runtime behavior of these
 * exceptions, see {@link AutoDisposePlugins}.
 *
 * <p><em>Note:</em> This resolves the scope immediately, so consider deferring execution as
 * needed, such as using {@link Completable#defer(Supplier) defer}.
 *
 * @param provider the {@link LifecycleScopeProvider} to resolve.
 * @param checkEndBoundary whether or not to check that the lifecycle has ended
 * @param <E> the lifecycle event type
 * @return a resolved {@link CompletableSource} representation of a given provider
 * @throws OutsideScopeException if the {@link LifecycleScopeProvider#correspondingEvents()}
 *     throws an {@link OutsideScopeException} during resolution.
 */
public static <E> CompletableSource resolveScopeFromLifecycle(
    final LifecycleScopeProvider<E> provider, final boolean checkEndBoundary)
    throws OutsideScopeException 
{
    return Completable.defer(() -> {
        final E event = provider.peekLifecycle();
        if (event == null)
        {
            throw new LifecycleNotStartedException();
        }
        if (checkEndBoundary && provider.correspondingEvents().isEndEvent(event))
        {
            throw new LifecycleEndedException();
        }
        return provider.lifecycle();
    });
}   ",524,True
"/**
 * Atomically updates the target upstream AtomicReference from null to the non-null
 * next Subscription, otherwise cancels next and reports a ProtocolViolationException
 * if the AtomicReference doesn't contain the shared cancelled indicator.
 *
 * @param upstream the target AtomicReference to update
 * @param next the Subscription to set on it atomically
 * @param subscriber the class of the consumer to have a personalized
 * error message if the upstream already contains a non-cancelled Subscription.
 * @return true if successful, false if the content of the AtomicReference was non null
 */
public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber){
  AutoDisposeUtil.checkNotNull(next, ""next is null"");
  if (!upstream.compareAndSet(null, next)) {
    next.cancel();
    if (upstream.get() != AutoSubscriptionHelper.CANCELLED) {
      reportDoubleSubscription(subscriber);
    }
    return false;
  }
  return true;
}","/**
 * Atomically updates the target upstream AtomicReference from null to the non-null
 * next Subscription, otherwise cancels next and reports a ProtocolViolationException
 * if the AtomicReference doesn't contain the shared cancelled indicator.
 *
 * @param upstream the target AtomicReference to update
 * @param next the Subscription to set on it atomically
 * @param subscriber the class of the consumer to have a personalized
 * error message if the upstream already contains a non-cancelled Subscription.
 * @return true if successful, false if the content of the AtomicReference was non null
 */

public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) 
{
    Objects.requireNonNull(next, ""next is null"");
    if (!upstream.compareAndSet(null, next)) {
        next.cancel();
        reportSubscriptionProblem(subscriber, ""Subscription already set!"");
        return false;
    }
    return true;
}   ",525,True
"/**
 * Extracts the {@link Type} of the return value for {@link MethodInvocationTree} or {@link
 * MemberReferenceTree}, then checks it against {@link #capturedTypeAllowed(Type, VisitorState)}.
 */
private boolean isValidReturnValueType(ExpressionTree tree, VisitorState state){
  Type returnType = null;
  if (tree instanceof MethodInvocationTree) {
    returnType = getReturnType(((JCMethodInvocation) tree).getMethodSelect());
  } else if (tree instanceof MemberReferenceTree) {
    // Get the return type of the target referenced interface
    returnType =
        state.getTypes().findDescriptorType(((JCMemberReference) tree).type).getReturnType();
  }
  if (returnType != null) {
    return capturedTypeAllowed(returnType, state);
  }
  return true;
}","/**
 * Extracts the {@link Type} of the return value for {@link MethodInvocationTree} or {@link
 * MemberReferenceTree}, then checks it against {@link #capturedTypeAllowed(Type, VisitorState)}.
 */
private boolean isValidReturnValueType(ExpressionTree tree, VisitorState state) 
{
    Type type = getReturnType(tree, state);
    return capturedTypeAllowed(type, state);
}   ",526,True
"/**
 * @return a {@link Completable} representation of the given {@code scopeProvider}. This will be
 *     deferred appropriately and handle {@link OutsideScopeException OutsideScopeExceptions}.
 */
public static Completable completableOf(ScopeProvider scopeProvider){
  return Completable.defer(
      () -> {
        try {
          return scopeProvider.requestScope();
        } catch (OutsideScopeException e) {
          Consumer<? super OutsideScopeException> handler =
              AutoDisposePlugins.getOutsideScopeHandler();
          if (handler != null) {
            handler.accept(e);
            return Completable.complete();
          } else {
            return Completable.error(e);
          }
        }
      });
}","/**
 * @return a {@link Completable} representation of the given {@code scopeProvider}. This will be
 *     deferred appropriately and handle {@link OutsideScopeException OutsideScopeExceptions}.
 */
public static Completable completableOf(ScopeProvider scopeProvider) 
{
    return Completable.defer(() -> {
        try
        {
            return Completable.complete();
        }
        catch (OutsideScopeException e)
        {
            return Completable.error(e);
        }
    });
}   ",531,False
"/**
 * Cancels the Subscription set via onSubscribe or makes sure a Subscription set asynchronously
 * (later) is cancelled immediately.
 *
 * <p>This method is thread-safe and can be exposed as a public API.
 */
@Override
public void cancel(){
  AutoDisposableHelper.dispose(scopeDisposable);
  AutoSubscriptionHelper.cancel(mainSubscription);
}","/**
 * Cancels the Subscription set via onSubscribe or makes sure a Subscription set asynchronously
 * (later) is cancelled immediately.
 *
 * <p>This method is thread-safe and can be exposed as a public API.
 */
@Override
public void cancel() 
{
    Subscription s = get();
    if (s != null)
    {
        s.cancel();
    }
}   ",533,True
"/**
 * Don't match the method that is invoked through {@code Mockito.verify(t)} or {@code
 * doReturn(val).when(t)}.
 */
private static boolean mockitoInvocation(Tree tree, VisitorState state){
  if (!(tree instanceof JCMethodInvocation)) {
    return false;
  }
  JCMethodInvocation invocation = (JCMethodInvocation) tree;
  if (!(invocation.getMethodSelect() instanceof JCFieldAccess)) {
    return false;
  }
  ExpressionTree receiver = ASTHelpers.getReceiver(invocation);
  return MOCKITO_MATCHER.matches(receiver, state);
}","/**
 * Don't match the method that is invoked through {@code Mockito.verify(t)} or {@code
 * doReturn(val).when(t)}.
 */

private static boolean mockitoInvocation(Tree tree, VisitorState state) 
{
    if (tree.getParent() instanceof MethodInvocationTree) {
        MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree.getParent();
        if (methodInvocationTree.getMethodSelect() == tree) {
            return true;
        }
    }
    return false;
}   ",537,True
"/**
 * @param fillInStacktrace {@code true} to fill in stacktraces in {@link OutsideScopeException}s.
 *     {@code false} to disable them (and use them as signals only). Disabling them, if you don't
 *     care about the stacktraces, can result in some minor performance improvements.
 */
public static void setFillInOutsideScopeExceptionStacktraces(boolean fillInStacktrace){
  if (lockdown) {
    throw new IllegalStateException(""Plugins can't be changed anymore"");
  }
  fillInOutsideScopeExceptionStacktraces = fillInStacktrace;
}","/**
 * @param fillInStacktrace {@code true} to fill in stacktraces in {@link OutsideScopeException}s.
 *     {@code false} to disable them (and use them as signals only). Disabling them, if you don't
 *     care about the stacktraces, can result in some minor performance improvements.
 */
public static void setFillInOutsideScopeExceptionStacktraces(boolean fillInStacktrace) 
{
    if (fillInStacktrace)
    {
        OutsideScopeException.fillInStacktrace = true;
    }
    else
    {
        OutsideScopeException.fillInStacktrace = false;
    }
}   ",538,True
"/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:45
 */
public Constant constant(){
  ASTNode$State state = state();
  try {
		throw new UnsupportedOperationException();
	}
  finally {
  }
}","/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:45
 */
public Constant constant() 
{
    if (this instanceof Constant) {
        return (Constant) this;
    }
    return null;
}   ",540,True
"/**
 * @ast method 
 * 
 */
public CatchParameterDeclaration(Modifiers p0, List<Access> p1, String p2){
  setChild(p0, 0);
  setChild(p1, 1);
  setID(p2);
}","/**
 * @ast method 
 * 
 */
public CatchParameterDeclaration(Modifiers p0, List<Access> p1, String p2) 
{
    super(p0, p1, p2);
}   ",541,True
"/**
	 * Duplicate declaration checking for catch parameters.
	 * @ast method 
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:186
 */
public void nameCheck(){
		SimpleSet decls = outerScope().lookupVariable(name());
		for(Iterator iter = decls.iterator(); iter.hasNext(); ) {
			Variable var = (Variable)iter.next();
			if (var instanceof VariableDeclaration) {
				VariableDeclaration decl = (VariableDeclaration)var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error(""duplicate declaration of ""+
						""catch parameter ""+name());
			} else if (var instanceof ParameterDeclaration) {
				ParameterDeclaration decl = (ParameterDeclaration)var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error(""duplicate declaration of ""+
						""catch parameter ""+name());
			} else if (var instanceof CatchParameterDeclaration) {
				CatchParameterDeclaration decl = (CatchParameterDeclaration)var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error(""duplicate declaration of ""+
						""catch parameter ""+name());
			}
		}

		// 8.4.1  
		if (!lookupVariable(name()).contains(this))
			error(""duplicate declaration of catch parameter "" +
					name());
	}","/**
	 * Duplicate declaration checking for catch parameters.
	 * @ast method 
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:186
 */
public void nameCheck() 
{
    if (!sourceFile().equals(parserPackage().getName()))
        error(""catch parameter must be declared in the same file as the multi-catch type"");
    super.nameCheck();
}	",542,False
"/** Write a segment of the given String. */
public void write(String s, int off, int len) throws IOException{
  for (int i = off; i < off + len; i++) {
    write(s.charAt(i));
  }
}","/** Write a segment of the given String. */
public void write(String s, int off, int len) throws IOException 
{
    if (len > 0) {
        if (off < 0 || len < 0 || off + len > s.length()) {
            throw new IndexOutOfBoundsException();
        }
        while (len > 0) {
            int segmentLen = Math.min(len, MAX_SEGMENT_SIZE);
            stream.writeUTF(s.substring(off, off + segmentLen));
            len -= segmentLen;
            off += segmentLen;
        }
    }
}   ",545,True
"/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:35
 */
public boolean isVolatile(){
  ASTNode$State state = state();
  try {  return getModifiers().isVolatile();  }
  finally {
  }
}","/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:35
 */
public boolean isVolatile() 
{
    ASTNode$State state = state();
    try {
        return getModifiers().isVolatile();
    } finally {
    }
}   ",546,True
"/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:37
 */
public boolean isStatic(){
  ASTNode$State state = state();
  try {  return false;  }
  finally {
  }
}","/**
 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:37
 */
public boolean isStatic() 
{
    ASTNode$State state = state();
    try {  return getBlock().isStatic();  }
    finally { }
}   ",548,True
"/**
 * Replaces the TypeAccess list element at index {@code i} with the new node {@code node}.
 * @param node The new node to replace the old list element.
 * @param i The list index of the node to be replaced.
 * @apilevel high-level
 * @ast method 
 * 
 */
public void setTypeAccess(Access node, int i){
  List<Access> list = getTypeAccessList();
  list.setChild(node, i);
}","/**
 * Replaces the TypeAccess list element at index {@code i} with the new node {@code node}.
 * @param node The new node to replace the old list element.
 * @param i The list index of the node to be replaced.
 * @apilevel high-level
 * @ast method 
 * 
 */
public void setTypeAccess(Access node, int i) 
{
    List<Access> list = getTypeAccessList();
    list.setChild(node, i);
}   ",549,True
"/*
 * Deals with cases in which a local is assigned a value from a static field int local = field int local = class.field
 */
public void inStaticFieldRef(StaticFieldRef sfr){
  if (inDefinitionStmt && (definedLocal != null)) {
    SootField field = sfr.getField();
    info.setFieldName(definedLocal, field.getName());
  }
}","/*
 * Deals with cases in which a local is assigned a value from a static field int local = field int local = class.field
 */
public void inStaticFieldRef(StaticFieldRef sfr) 
{
    ConstantValue cv = sfr.getConstantValue();
    if (cv != null)
    {
        // the field is a constant value
        int value = (int) cv.getLongValue();
        if (value == 0)
        {
            // the field is zero, so the local is zero
            return;
        }
        else
        {
            // the field is not zero, so the local is the field value
            return;
        }
    }
    else
    {
        // the field is not a constant value
        return;
    }
}   ",550,False
"/**
	 * The catch parameter of a multi-catch clause is implicitly final.
	 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:34
 */
public boolean isFinal(){
  ASTNode$State state = state();
  try {  return true;  }
  finally {
  }
}","/**
	 * The catch parameter of a multi-catch clause is implicitly final.
	 * @attribute syn
 * @aspect MultiCatch
 * @declaredat /Users/eric/Documents/workspaces/clara-soot/JastAddJ/Java7Frontend/MultiCatch.jrag:34
 */
public boolean isFinal() 
{
    return true;
}	",552,True
"// Find multi called methods relavant to recusive method invocation
private void finder2(PegCallGraph pcg){

  pcg.trim();
  Set<SootMethod> first = new HashSet<SootMethod>();
  Set<SootMethod> second = new HashSet<SootMethod>();
  // Visit each node
  Iterator it = pcg.iterator();
  while (it.hasNext()) {
    SootMethod s = (SootMethod) it.next();

    if (!second.contains(s)) {

      visitNode(s, pcg, first, second);
    }
  }

}","// Find multi called methods relavant to recusive method invocation
private void finder2(PegCallGraph pcg) 
{
    for (PegMethod m : pcg.getMethods())
    {
        if (m.isRecursive())
        {
            for (PegMethod m2 : pcg.getMethods())
            {
                if (m2.isCalledBy(m))
                {
                    System.out.println(m2.getName() + "" is called by "" + m.getName());
                }
            }
        }
    }
}   ",553,True
"/*
 * Check the key of the switch statement to see if its a local
 */
public void inASTSwitchNode(ASTSwitchNode node){
  Value key = node.get_Key();
  if (key instanceof Local) {
    info.setHeuristic((Local) key, infoGatheringAnalysis.SWITCH);
  }
}","/*
 * Check the key of the switch statement to see if its a local
 */
public void inASTSwitchNode(ASTSwitchNode node) 
{
    ASTExpressionNode key = node.getKey();
    if (key instanceof ASTLocalNameNode)
    {
        ASTLocalNameNode local = (ASTLocalNameNode) key;
        String name = local.getLocalName();
        if (name != null)
        {
            checkLocalName(name, local);
        }
    }
    else
    {
        inASTExpressionNode(key);
    }
}   ",554,True
"/*
 * The method checks whether a particular ConditionExpr is a comparison of a local with a boolean If so the local is
 * returned
 */
private Local checkBooleanUse(ConditionExpr condition){
  boolean booleanUse = false;

  // check whether the condition qualifies as a boolean use
  if (condition instanceof NeExpr || condition instanceof EqExpr) {
    Value op1 = condition.getOp1();
    Value op2 = condition.getOp2();
    if (op1 instanceof DIntConstant) {
      Type op1Type = ((DIntConstant) op1).type;
      if (op1Type instanceof BooleanType) {
        booleanUse = true;
      }
    } else if (op2 instanceof DIntConstant) {
      Type op2Type = ((DIntConstant) op2).type;
      if (op2Type instanceof BooleanType) {
        booleanUse = true;
      }
    }
    if (booleanUse) {
      // at this point we know that one of the values op1 or op2 was a boolean
      // check whether the other is a local
      if (op1 instanceof Local) {
        return (Local) op1;
      } else if (op2 instanceof Local) {
        return (Local) op2;
      }
    } else {
      return null;// meaning no local used as boolean found
    }
  }
  return null; // meaning no local used as boolean found
}","/*
 * The method checks whether a particular ConditionExpr is a comparison of a local with a boolean If so the local is
 * returned
 */
private Local checkBooleanUse(ConditionExpr condition) 
{
    Value value = condition.getOp1();
    if (value instanceof Local)
    {
        Local local = (Local) value;
        if (condition.getOp2() instanceof Constant)
        {
            Constant constant = (Constant) condition.getOp2();
            if (constant.getValue() instanceof Boolean)
            {
                return local;
            }
        }
    }
    return null;
}   ",555,True
"/**
 * @param from
 * @param to
 */
public AssignEdge(final VarNode from, final VarNode to){
  this.src = from;
  this.dst = to;
}","/**
 * @param from
 * @param to
 */
public AssignEdge(final VarNode from, final VarNode to) 
{
    this.from = from;
    this.to = to;
}   ",556,True
"/**
 * 设置虚线宽度
 *
 * @param strokeDashWidth
 * @return
 */
public T setStrokeDashWidth(float strokeDashWidth){
    this.mStrokeDashWidth = strokeDashWidth;
    return (T) this;
}","/**
 * 设置虚线宽度
 *
 * @param strokeDashWidth
 * @return
 */
public T setStrokeDashWidth(float strokeDashWidth) 
{
    this.strokeDashWidth = strokeDashWidth;
    return (T) this;
}   ",561,True
"/**
 * 设置右上圆角
 *
 * @param radius
 * @return
 */
public T setTopRightRadius(float radius){
    this.mTopRightRadius = radius;
    return (T) this;
}","/**
 * 设置右上圆角
 *
 * @param radius
 * @return
 */
public T setTopRightRadius(float radius) 
{
    this.topRightRadius = radius;
    return (T) this;
}   ",563,True
"/**
 * 设置整体圆角弧度
 *
 * @param radius
 * @return
 */
public T setRadius(float radius){
    this.mRadius = radius;
    return (T) this;
}","/**
 * 设置整体圆角弧度
 *
 * @param radius
 * @return
 */
public T setRadius(float radius) 
{
    this.radius = radius;
    invalidate();
    return (T) this;
}   ",565,True
"/**
 * ratiox = 0.2, ratioy = 0.55 为调试值
 * 单次路径效果图： http://cubic-bezier.com/#.2,.55,.8,.45
 * 可自行调整，配合动画的整体时长，调出比较接近自由落体的效果
 */
public MultiDecelerateAccelerateInterpolator(){
    this(new PointF(0, 0),
            new PointF(1, 1),
            0.2f,
            0.55f);
}","/**
 * ratiox = 0.2, ratioy = 0.55 为调试值
 * 单次路径效果图： http://cubic-bezier.com/#.2,.55,.8,.45
 * 可自行调整，配合动画的整体时长，调出比较接近自由落体的效果
 */
public MultiDecelerateAccelerateInterpolator() 
{
    mRatioX = 0.2f;
    mRatioY = 0.55f;
}   ",566,True
"/**
 * 是否默认开启水波纹
 *
 * @return
 */
private boolean getDefaultRippleEnable(){
    boolean enable = !(mView instanceof CompoundButton) && !(mView instanceof EditText);
    return enable;
}","/**
 * 是否默认开启水波纹
 *
 * @return
 */


private boolean getDefaultRippleEnable() 
{
    TypedArray a = getContext().obtainStyledAttributes(new int[]{R.attr.defaultRippleEnable});
    boolean rippleEnable = a.getBoolean(0, false);
    a.recycle();
    return rippleEnable;
}   ",568,False
"/**
 * @param selected
 */
public void setSelected(boolean selected){
    if (mView != null) {
        if (mSelected != selected) {
            mSelected = selected;
            if (mOnSelectedChangeListener != null) {
                mOnSelectedChangeListener.onSelectedChanged(mView, mSelected);
            }
        }
    }
    init();
}","/**
 * @param selected
 */

public void setSelected(boolean selected) 
{
    if (selected)
    {
        this.setBackground(Color.LIGHT_GRAY);
    }
    else
    {
        this.setBackground(Color.WHITE);
    }
}   ",569,False
"/**
 * 设置按下状态背景色
 *
 * @param color
 * @return
 */
public T setBackgroundPressedColor(int color){
    this.mBackgroundPressedColor = color;
    return (T) this;
}","/**
 * 设置按下状态背景色
 *
 * @param color
 * @return
 */
public T setBackgroundPressedColor(int color) 
{
    this.mBackgroundPressedColor = color;
    return (T) this;
}   ",571,True
"/**
 * 设置shape属性
 * 设置完所有属性后调用设置背景
 */
public void init(){
    //获取view当前drawable--用于判断是否通过默认属性设置背景
    Drawable mDrawable = mView.getBackground();
    //判断是否使用自定义颜色值
    boolean isSetBg = mBackgroundColor != Integer.MAX_VALUE
            || mBackgroundPressedColor != Integer.MAX_VALUE
            || mBackgroundDisabledColor != Integer.MAX_VALUE
            || mBackgroundSelectedColor != Integer.MAX_VALUE
            || mStrokeWidth > 0 || mRadius > 0
            || mTopLeftRadius > 0 || mTopLeftRadius > 0 || mBottomLeftRadius > 0 || mBottomRightRadius > 0;

    setDrawable(mBackgroundChecked, mBackgroundCheckedColor, mStrokeCheckedColor);
    setDrawable(mBackgroundSelected, mBackgroundPressedColor, mStrokeSelectedColor);
    setDrawable(mBackground, mBackgroundColor, mStrokeColor);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
            && mRippleEnable && mView.isEnabled() && !mView.isSelected()) {//5.0以上且设置水波属性并且可操作
        RippleDrawable rippleDrawable = new RippleDrawable(
                new ColorStateList(
                        new int[][]{
                                new int[]{mStatePressed},
                                new int[]{}
                        },
                        new int[]{
                                mRippleColor != Integer.MAX_VALUE ? mRippleColor : mBackgroundPressedColor,
                                mRippleColor
                        }
                )
                , getContentDrawable(mDrawable, isSetBg)
                , null);
        mView.setBackground(rippleDrawable);
    } else {
        if (!isSetBg) {
            return;
        }
        StateListDrawable mStateDrawable = new StateListDrawable();
        mStateDrawable.setEnterFadeDuration(mEnterFadeDuration);
        mStateDrawable.setExitFadeDuration(mExitFadeDuration);
        if (mBackgroundPressedColor != Integer.MAX_VALUE || mStrokePressedColor != Integer.MAX_VALUE) {
            setDrawable(mBackgroundPressed, mBackgroundPressedColor, mStrokePressedColor);
            mStateDrawable.addState(new int[]{mStatePressed}, mBackgroundPressed);
        }
        if (mBackgroundSelectedColor != Integer.MAX_VALUE || mStrokeSelectedColor != Integer.MAX_VALUE) {
            setDrawable(mBackgroundSelected, mBackgroundSelectedColor, mStrokeSelectedColor);
            mStateDrawable.addState(new int[]{mStateSelected}, mBackgroundSelected);
        }
        if (mBackgroundCheckedColor != Integer.MAX_VALUE || mStrokeCheckedColor != Integer.MAX_VALUE) {
            setDrawable(mBackgroundChecked, mBackgroundCheckedColor, mStrokeCheckedColor);
            mStateDrawable.addState(new int[]{mStateChecked}, mBackgroundChecked);
        }
        if (mBackgroundDisabledColor != Integer.MAX_VALUE || mStrokeDisabledColor != Integer.MAX_VALUE) {
            setDrawable(mBackgroundDisabled, mBackgroundDisabledColor, mStrokeDisabledColor);
            mStateDrawable.addState(new int[]{mStateDisabled}, mBackgroundDisabled);
        }
        mStateDrawable.addState(new int[]{}, mBackground);//默认状态--放置在最后否则其它状态不生效
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            mView.setBackground(mStateDrawable);
        } else {
            mView.setBackgroundDrawable(mStateDrawable);
        }
    }
    return;
}","/**
 * 设置shape属性
 * 设置完所有属性后调用设置背景
 */
public void init() 
{
    setShape();
    setBg();
}   ",572,False
"/**
 * 设置水波纹颜色 5.0以上支持
 *
 * @param color
 * @return
 */
public T setRippleColor(int color){
    this.mRippleColor = color;
    return (T) this;
}","/**
 * 设置水波纹颜色 5.0以上支持
 *
 * @param color
 * @return
 */
public T setRippleColor(int color) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
    {
        rippleColor = color;
    }
    return (T) this;
}   ",573,True
"/**
 * 构造PathInterpolator
 * @param segmentLength
 * @return
 */
public Interpolator createInterpolator(float[] segmentLength){
    Path p = createPath(segmentLength);
    Interpolator inter = PathInterpolatorCompat.create(p);
    return inter;
}","/**
 * 构造PathInterpolator
 * @param segmentLength
 * @return
 */

public Interpolator createInterpolator(float[] segmentLength) 
{
    if (segmentLength.length == 1)
    {
        return new PathInterpolator(segmentLength[0], segmentLength[0]);
    }
    else if (segmentLength.length == 2)
    {
        return new PathInterpolator(segmentLength[0], segmentLength[1]);
    }
    else
    {
        return new PathInterpolator(segmentLength);
    }
}   ",575,True
"/**
 * 设置边框checked状态颜色
 *
 * @param strokeCheckedColor
 * @return
 */
public T setStrokeCheckedColor(int strokeCheckedColor){
    this.mStrokeCheckedColor = strokeCheckedColor;
    return (T) this;
}","/**
 * 设置边框checked状态颜色
 *
 * @param strokeCheckedColor
 * @return
 */
public T setStrokeCheckedColor(int strokeCheckedColor) 
{
    this.strokeCheckedColor = strokeCheckedColor;
    return (T) this;
}   ",576,True
"/**
 * 设置选中状态变换监听
 *
 * @param listener
 * @return
 */
public T setOnSelectedChangeListener(OnSelectedChangeListener listener){
    this.mOnSelectedChangeListener = listener;
    return (T) this;
}","/**
 * 设置选中状态变换监听
 *
 * @param listener
 * @return
 */
public T setOnSelectedChangeListener(OnSelectedChangeListener listener) 
{
    this.listener = listener;
    return (T) this;
}   ",578,True
"/** Test.
 * @throws ServletException e
 * @throws IOException e */
@Test
public void testDoFilterWithSession() throws ServletException, IOException{
	final HttpServletRequest request = createNiceMock(HttpServletRequest.class);
	final HttpSession session = createNiceMock(HttpSession.class);
	expect(request.getSession(false)).andReturn(session).anyTimes();
	expect(request.getLocale()).andReturn(Locale.FRANCE);
	replay(session);
	doFilter(request);
	verify(session);
}","/** Test.
 * @throws ServletException e
 * @throws IOException e */
@Test
public void testDoFilterWithSession() throws ServletException, IOException 
{
    final HttpServletRequest request = mock(HttpServletRequest.class);
    final HttpServletResponse response = mock(HttpServletResponse.class);
    final FilterChain filterChain = mock(FilterChain.class);
    final HttpSession session = mock(HttpSession.class);

    when(request.getSession()).thenReturn(session);
    when(session.getAttribute(""user"")).thenReturn(""user"");

    final MyFilter filter = new MyFilter();
    filter.doFilter(request, response, filterChain);

    verify(filterChain).doFilter(request, response);
}   ",581,False
"/**
 * Initialisation.
 */
@Before
public void setUp(){
	Utils.initialize();
	final ServletContext context = createNiceMock(ServletContext.class);
	expect(context.getMajorVersion()).andReturn(2).anyTimes();
	expect(context.getMinorVersion()).andReturn(5).anyTimes();
	expect(context.getServletContextName()).andReturn(""test webapp"").anyTimes();
	expect(context.getServerInfo()).andReturn(""mockJetty"").anyTimes();
	expect(context.getContextPath()).andReturn(""/test"").anyTimes();
	replay(context);
	Parameters.initialize(context);
}","/**
 * Initialisation.
 */
@Before
public void setUp() 
{
    // Create a new instance of the class to test
    testClass = new ClassToTest();
}   ",598,False
"/**
 * 是否关闭标签点击事件，默认开启
 *
 * @param disableHeaderClick true为关闭标签点击事件，false为开启标签点击事件
 * @return 构建者
 */
public Builder disableHeaderClick(boolean disableHeaderClick){
    this.disableHeaderClick = disableHeaderClick;
    return this;
}","/**
 * 是否关闭标签点击事件，默认开启
 *
 * @param disableHeaderClick true为关闭标签点击事件，false为开启标签点击事件
 * @return 构建者
 */
public Builder disableHeaderClick(boolean disableHeaderClick) 
{
    this.disableHeaderClick = disableHeaderClick;
    return this;
}   ",602,True
"/**
 * 更新点击范围的顶部和底部
 *
 * @param offset 偏差
 */
public void invalidTopAndBottom(int offset){
    for (int i = 0; i < mBoundsArray.size(); i++) {
        final ClickBounds bounds = mBoundsArray.valueAt(i);
        bounds.setTop(bounds.getFirstTop() + offset);
        bounds.setBottom(bounds.getFirstBottom() + offset);
    }
}","/**
 * 更新点击范围的顶部和底部
 *
 * @param offset 偏差
 */
public void invalidTopAndBottom(int offset) 
{
    if (mTopView != null)
    {
        mTopView.updateTopView(offset);
    }
    if (mBottomView != null)
    {
        mBottomView.updateBottomView(offset);
    }
}   ",604,True
"/**
 * 构造方法
 *
 * @param pinnedHeaderId   小标签对应的ID
 * @param pinnedHeaderType 粘性标签的类型
 */
public Builder(int pinnedHeaderId, int pinnedHeaderType){
    this.pinnedHeaderId = pinnedHeaderId;
    this.pinnedHeaderType = pinnedHeaderType;
}","/**
 * 构造方法
 *
 * @param pinnedHeaderId   小标签对应的ID
 * @param pinnedHeaderType 粘性标签的类型
 */
public Builder(int pinnedHeaderId, int pinnedHeaderType) 
{
    this.pinnedHeaderId = pinnedHeaderId;
    this.pinnedHeaderType = pinnedHeaderType;
}   ",608,True
"// 查找标签的位置
private int findPinnedHeaderPosition(int fromPosition){

    for (int position = fromPosition; position >= 0; position--) {
        // 从这个位置开始递减，只要一查到有位置type为标签，立即返回此标签位置
        final int viewType = mAdapter.getItemViewType(position);
        // 检查是否是标签类型
        if (isPinnedViewType(viewType)) {
            // 是标签类型，返回位置
            return position;
        }
    }

    return -1;
}","// 查找标签的位置
private int findPinnedHeaderPosition(int fromPosition) 
{
    int position = fromPosition;

    for (int i = fromPosition; i < dataList.size(); i++)
    {
        if (dataList.get(i).getIsPinned())
        {
            position = i;
            break;
        }
    }

    return position;
}   ",609,True
"/**
 * 适用于网格布局，用于判断是否是第一列
 *
 * @param parent
 * @param pos
 * @param spanCount
 * @return
 */
private boolean isFirstColumn(RecyclerView parent, int pos, int spanCount){
    RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();
    if (layoutManager instanceof GridLayoutManager) {
        final int headerPosition = findPinnedHeaderPosition(pos);
        if (headerPosition >= 0 && (pos - (headerPosition + 1)) % spanCount == 0) {
            // 找到头部位置减去包括头部位置之前的个数
            return true;
        }
    }
    return false;
}","/**
 * 适用于网格布局，用于判断是否是第一列
 *
 * @param parent
 * @param pos
 * @param spanCount
 * @return
 */
private boolean isFirstColumn(RecyclerView parent, int pos, int spanCount) 
{
    RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();
    if (layoutManager instanceof GridLayoutManager)
    {
        int spanSize = ((GridLayoutManager) layoutManager).getSpanSizeLookup().getSpanSize(pos);
        return spanSize == spanCount;
    }
    return false;
}   ",611,True
"/**
 * 设置对应的View的点击范围
 *
 * @param id   View的ID
 * @param view 点击的View
 */
public void setClickBounds(int id, View view){
    ClickBounds bounds;
    if (mBoundsArray.get(id) == null) {
        bounds = new ClickBounds(view, view.getLeft(), view.getTop(), view.getLeft() + view.getMeasuredWidth(), view.getTop() + view.getMeasuredHeight());
        mBoundsArray.put(id, bounds);
    } else {
        bounds = mBoundsArray.get(id);
        bounds.setBounds(view.getLeft(), view.getTop(), view.getLeft() + view.getMeasuredWidth(), view.getTop() + view.getMeasuredHeight());
    }
}","/**
 * 设置对应的View的点击范围
 *
 * @param id   View的ID
 * @param view 点击的View
 */

public void setClickBounds(int id, View view) 
{
    if (id == 0 || view == null)
    {
        return;
    }
    if (mClickBounds == null)
    {
        mClickBounds = new SparseArray<>();
    }
    mClickBounds.put(id, view);
}   ",615,True
"// 测量标签高度
private void measurePinnedHeader(){

    // 2.测量标签
    mPinnedHeaderView = mPinnedHeaderParentView.findViewById(mPinnedHeaderId);
    // 获取标签的布局属性
    ViewGroup.LayoutParams lp = mPinnedHeaderView.getLayoutParams();
    if (lp == null) {
        lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        mPinnedHeaderView.setLayoutParams(lp);
    }

    if (lp instanceof ViewGroup.MarginLayoutParams) {
        final ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) lp;
        mHeaderLeftMargin = mlp.leftMargin;
        mHeaderRightMargin = mlp.rightMargin;
        mHeaderTopMargin = mlp.topMargin;
        mHeaderBottomMargin = mlp.bottomMargin;
    }

    // 设置高度
    int heightMode = View.MeasureSpec.getMode(lp.height);
    int heightSize = View.MeasureSpec.getSize(lp.height);

    switch (heightMode) {
        case View.MeasureSpec.UNSPECIFIED:
            heightMode = View.MeasureSpec.EXACTLY;
            break;
        case View.MeasureSpec.EXACTLY:
            heightMode = View.MeasureSpec.EXACTLY;
            break;
        case View.MeasureSpec.AT_MOST:
            heightMode = View.MeasureSpec.AT_MOST;
            break;
        default:
            heightMode = View.MeasureSpec.AT_MOST;
            break;
    }

    // 最大高度为mPinnedHeaderParentView的高度减去padding
    int maxHeight = mPinnedHeaderParentView.getMeasuredHeight() - mPinnedHeaderParentView.getPaddingTop() - mPinnedHeaderParentView.getPaddingBottom();
    heightSize = Math.min(heightSize, maxHeight);

    int hs = View.MeasureSpec.makeMeasureSpec(heightSize, heightMode);

    // 设置宽度
    int widthMode = View.MeasureSpec.getMode(lp.width);
    int widthSize = View.MeasureSpec.getSize(lp.width);

    switch (widthMode) {
        case View.MeasureSpec.UNSPECIFIED:
            widthMode = View.MeasureSpec.EXACTLY;
            break;
        case View.MeasureSpec.EXACTLY:
            widthMode = View.MeasureSpec.EXACTLY;
            break;
        case View.MeasureSpec.AT_MOST:
            widthMode = View.MeasureSpec.AT_MOST;
            break;
        default:
            widthMode = View.MeasureSpec.AT_MOST;
            break;
    }

    int maxWidth = mPinnedHeaderParentView.getMeasuredWidth() - mPinnedHeaderParentView.getPaddingLeft() - mPinnedHeaderParentView.getPaddingRight();
    widthSize = Math.min(widthSize, maxWidth);

    int ws = View.MeasureSpec.makeMeasureSpec(widthSize, widthMode);

    // 强制测量
    mPinnedHeaderView.measure(ws, hs);

}","// 测量标签高度
private void measurePinnedHeader() 
{
    if (pinnedHeader == null)
    {
        return;
    }
    int widthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY);
    int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    pinnedHeader.measure(widthMeasureSpec, heightMeasureSpec);
    pinnedHeaderHeight = pinnedHeader.getMeasuredHeight();
}   ",619,False
"/**
 * Constructs the clock with custom configuration parameters.
 *
 * @param maxMeasurementRetries  the maximum number of times that this clock will attempt to re-sample the initial
 *                               time values.
 * @param measurementThresholdNs the desired accuracy window for the initial clock samples.
 * @param resampleIntervalNs     the desired interval before the samples are automatically recalculated. The seed
 *                               recalculation enables the system to minimise clock drift if the system clock is
 *                               updated.
 */
public OffsetEpochNanoClock(
    final int maxMeasurementRetries, final long measurementThresholdNs, final long resampleIntervalNs){
    this.maxMeasurementRetries = maxMeasurementRetries;
    this.measurementThresholdNs = measurementThresholdNs;
    this.resampleIntervalNs = resampleIntervalNs;

    sample();
}","/**
 * Constructs the clock with custom configuration parameters.
 *
 * @param maxMeasurementRetries  the maximum number of times that this clock will attempt to re-sample the initial
 *                               time values.
 * @param measurementThresholdNs the desired accuracy window for the initial clock samples.
 * @param resampleIntervalNs     the desired interval before the samples are automatically recalculated. The seed
 *                               recalculation enables the system to minimise clock drift if the system clock is
 *                               updated.
 */
public OffsetEpochNanoClock(
    final int maxMeasurementRetries, final long measurementThresholdNs, final long resampleIntervalNs) 
{
    this.maxMeasurementRetries = maxMeasurementRetries;
    this.measurementThresholdNs = measurementThresholdNs;
    this.resampleIntervalNs = resampleIntervalNs;
    this.offsetEpochNanoClock = new OffsetEpochNanoClock();
}   ",620,True
"/**
 * Programmatically signal awaiting threads on the latch associated with this barrier.
 */
public void signal(){
    synchronized (LATCHES)
    {
        LATCHES.remove(latch);
        latch.countDown();
    }
}","/**
 * Programmatically signal awaiting threads on the latch associated with this barrier.
 */
public void signal() 
{
    synchronized (this)
    {
        if (awaiting > 0)
        {
            awaiting--;
            notifyAll();
        }
    }
}   ",633,True
"// Generated suite to test conformity to the java.util.Set interface
public static TestSuite suite(){
    return mapTestSuite(new TestMapGenerator<Integer, Integer>()
    {
        public Integer[] createKeyArray(final int length)
        {
            return new Integer[length];
        }

        public Integer[] createValueArray(final int length)
        {
            return new Integer[length];
        }

        public SampleElements<Map.Entry<Integer, Integer>> samples()
        {
            return new SampleElements<>(
                Helpers.mapEntry(1, 123),
                Helpers.mapEntry(2, 234),
                Helpers.mapEntry(3, 345),
                Helpers.mapEntry(345, 6),
                Helpers.mapEntry(777, 666));
        }

        public Map<Integer, Integer> create(final Object... entries)
        {
            final Int2NullableObjectHashMap<Integer> map = new Int2NullableObjectHashMap<>(
                entries.length * 2, Hashing.DEFAULT_LOAD_FACTOR, false);

            for (final Object o : entries)
            {
                @SuppressWarnings(""unchecked"")
                final Map.Entry<Integer, Integer> e = (Map.Entry<Integer, Integer>)o;
                map.put(e.getKey(), e.getValue());
            }

            return map;
        }

        @SuppressWarnings({""unchecked"", ""rawtypes""})
        public Map.Entry<Integer, Integer>[] createArray(final int length)
        {
            return new Map.Entry[length];
        }

        public Iterable<Map.Entry<Integer, Integer>> order(final List<Map.Entry<Integer, Integer>> insertionOrder)
        {
            return insertionOrder;
        }
    }, Int2NullableObjectHashMap.class.getSimpleName());
}","// Generated suite to test conformity to the java.util.Set interface
public static TestSuite suite() 
{
    TestSuite suite = new TestSuite(""Test for java.util"");
    suite.addTestSuite(SetTest.class);
    suite.addTestSuite(HashSetTest.class);
    suite.addTestSuite(TreeSetTest.class);
    suite.addTestSuite(LinkedHashSetTest.class);
    return suite;
}   ",634,False
"/**
 * @param defaultScheme {@link RouterUri} 没有指定scheme时，则使用这里设置的defaultScheme
 * @param defaultHost   {@link RouterUri} 没有指定host时，则使用这里设置的defaultHost
 */
public DefaultRootUriHandler(Context context,
                             @Nullable String defaultScheme, @Nullable String defaultHost){
    super(context);
    mPageAnnotationHandler = createPageAnnotationHandler();
    mUriAnnotationHandler = createUriAnnotationHandler(defaultScheme, defaultHost);
    mRegexAnnotationHandler = createRegexAnnotationHandler();

    // 按优先级排序，数字越大越先执行

    // 处理RouterPage注解定义的内部页面跳转，如果注解没定义，直接结束分发
    addChildHandler(mPageAnnotationHandler, 300);
    // 处理RouterUri注解定义的URI跳转，如果注解没定义，继续分发到后面的Handler
    addChildHandler(mUriAnnotationHandler, 200);
    // 处理RouterRegex注解定义的正则匹配
    addChildHandler(mRegexAnnotationHandler, 100);
    // 添加其他用户自定义Handler...

    // 都没有处理，则尝试使用默认的StartUriHandler直接启动Uri
    addChildHandler(new StartUriHandler(), -100);
    // 全局OnCompleteListener，用于输出跳转失败提示信息
    setGlobalOnCompleteListener(DefaultOnCompleteListener.INSTANCE);
}","/**
 * @param defaultScheme {@link RouterUri} 没有指定scheme时，则使用这里设置的defaultScheme
 * @param defaultHost   {@link RouterUri} 没有指定host时，则使用这里设置的defaultHost
 */
public DefaultRootUriHandler(Context context,
                             @Nullable String defaultScheme, @Nullable String defaultHost) 
{
    this.context = context;
    this.defaultScheme = defaultScheme;
    this.defaultHost = defaultHost;
}   ",643,True
"/**
 * @param activity 父activity
 * @param uri      地址
 */
public FragmentTransactionUriRequest(@NonNull Activity activity, String uri){
    super(activity, uri);
    mFragmentManager = activity.getFragmentManager();
}","/**
 * @param activity 父activity
 * @param uri      地址
 */
public FragmentTransactionUriRequest(@NonNull Activity activity, String uri) 
{
    super(activity);
    this.uri = uri;
}   ",645,True
"/**
 * 创建Handler。格式：<code>""com.demo.TestActivity""</code> 或 <code>new TestHandler()</code>
 */
public CodeBlock buildHandler(boolean isActivity, Symbol.ClassSymbol cls){
    CodeBlock.Builder b = CodeBlock.builder();
    if (isActivity) {
        b.add(""$S"", cls.className());
    } else {
        b.add(""new $T()"", cls);
    }
    return b.build();
}","/**
 * 创建Handler。格式：<code>""com.demo.TestActivity""</code> 或 <code>new TestHandler()</code>
 */
public CodeBlock buildHandler(boolean isActivity, Symbol.ClassSymbol cls) 
{
    if (isActivity)
    {
        return new CodeBlock.Builder()
                .addStatement(""new $T()"", cls)
                .build();
    }
    else
    {
        return new CodeBlock.Builder()
                .addStatement(""new $T()"", cls)
                .build();
    }
}   ",649,True
"/**
 * @see LazyInitHelper#lazyInit()
 */
public void lazyInit(){
    mPageAnnotationHandler.lazyInit();
    mUriAnnotationHandler.lazyInit();
    mRegexAnnotationHandler.lazyInit();
}","/**
 * @see LazyInitHelper#lazyInit()
 */
public void lazyInit() 
{
    if (this.lazyInitHelper == null)
    {
        synchronized (this)
        {
            if (this.lazyInitHelper == null)
            {
                this.lazyInitHelper = new LazyInitHelper();
            }
        }
    }
}   ",653,False
"/**
 * 注册一个子节点
 *
 * @param regex        正则表达式
 * @param target       支持ActivityClassName、ActivityClass、UriHandler
 * @param exported     是否允许外部跳转
 * @param priority     优先级
 * @param interceptors 要添加的interceptor
 */
public void register(String regex, Object target, boolean exported, int priority,
                     UriInterceptor... interceptors){
    Pattern pattern = compile(regex);
    if (pattern != null) {
        UriHandler innerHandler = UriTargetTools.parse(target, exported, interceptors);
        if (innerHandler != null) {
            RegexWrapperHandler handler = new RegexWrapperHandler(pattern, priority,
                    innerHandler);
            addChildHandler(handler, priority);
        }
    }
}","/**
 * 注册一个子节点
 *
 * @param regex        正则表达式
 * @param target       支持ActivityClassName、ActivityClass、UriHandler
 * @param exported     是否允许外部跳转
 * @param priority     优先级
 * @param interceptors 要添加的interceptor
 */
public void register(String regex, Object target, boolean exported, int priority,
                     UriInterceptor... interceptors) 
{
    if (target instanceof String)
    {
        register(regex, (String) target, exported, priority, interceptors);
    } else if (target instanceof Class)
    {
        register(regex, (Class<?>) target, exported, priority, interceptors);
    } else
    {
        throw new IllegalArgumentException(""target must be String or Class"");
    }
}   ",655,True
"/**
 * 处理URI。通常不需要覆写本方法。
 *
 * @param request  URI跳转请求
 * @param callback 处理完成后的回调
 */
public void handle(@NonNull final UriRequest request, @NonNull final UriCallback callback){
    if (shouldHandle(request)) {
        Debugger.i(""%s: handle request %s"", this, request);
        if (mInterceptor != null && !request.isSkipInterceptors()) {
            mInterceptor.intercept(request, new UriCallback() {
                @Override
                public void onNext() {
                    handleInternal(request, callback);
                }

                @Override
                public void onComplete(int result) {
                    callback.onComplete(result);
                }
            });
        } else {
            handleInternal(request, callback);
        }
    } else {
        Debugger.i(""%s: ignore request %s"", this, request);
        callback.onNext();
    }
}","/**
 * 处理URI。通常不需要覆写本方法。
 *
 * @param request  URI跳转请求
 * @param callback 处理完成后的回调
 */
public void handle(@NonNull final UriRequest request, @NonNull final UriCallback callback) 
{
    if (request == null || callback == null)
    {
        return;
    }
    if (request.getUri() == null)
    {
        callback.onFailure(new NullPointerException(""uri is null""));
        return;
    }
    if (request.getUri().getScheme() == null)
    {
        callback.onFailure(new NullPointerException(""scheme is null""));
        return;
    }
    if (request.getUri().getScheme().equals(""http""))
    {
        handleHttp(request, callback);
    }
    else if (request.getUri().getScheme().equals(""https""))
    {
        handleHttps(request, callback);
    }
    else
    {
        callback.onFailure(new UnsupportedOperationException(""unsupported scheme: "" + request.getUri().getScheme()));
    }
}   ",657,False
"/**
 * Sends a {@link Crouton} within a {@link Message}.
 *
 * @param crouton
 *     The {@link Crouton} that should be sent.
 * @param messageId
 *     The {@link Message} id.
 */
private void sendMessage(Crouton crouton, final int messageId){
  final Message message = obtainMessage(messageId);
  message.obj = crouton;
  sendMessage(message);
}","/**
 * Sends a {@link Crouton} within a {@link Message}.
 *
 * @param crouton
 *     The {@link Crouton} that should be sent.
 * @param messageId
 *     The {@link Message} id.
 */
private void sendMessage(Crouton crouton, final int messageId) 
{
    final Message message = new Message();
    message.what = messageId;
    message.obj = crouton;

    mHandler.sendMessage(message);
}   ",661,True
"/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param customView
 *     The custom {@link View} to display
 * @param viewGroup
 *     The {@link ViewGroup} that this {@link Crouton} should be added to.
 * @param configuration
 *     The {@link Configuration} for this {@link Crouton}.
 */
private Crouton(final Activity activity, final View customView, final ViewGroup viewGroup,
                final Configuration configuration){
  if ((activity == null) || (customView == null)) {
    throw new IllegalArgumentException(NULL_PARAMETERS_ARE_NOT_ACCEPTED);
  }

  this.activity = activity;
  this.customView = customView;
  this.viewGroup = viewGroup;
  this.style = new Style.Builder().build();
  this.text = null;
  this.configuration = configuration;
}","/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param customView
 *     The custom {@link View} to display
 * @param viewGroup
 *     The {@link ViewGroup} that this {@link Crouton} should be added to.
 * @param configuration
 *     The {@link Configuration} for this {@link Crouton}.
 */
private Crouton(final Activity activity, final View customView, final ViewGroup viewGroup,
                final Configuration configuration) 
{
    this.activity = activity;
    this.customView = customView;
    this.viewGroup = viewGroup;
    this.configuration = configuration;

    this.view = new CroutonView(activity, customView, configuration);
    this.view.setOnClickListener(this);
    this.view.setOnTouchListener(this);
    this.view.setClickable(true);

    this.viewGroup.addView(this.view);
}   ",663,True
"/**
 * Load the {@link Typeface} and apply to a spannable.
 */
public TypefaceSpan(Context context, String typefaceName){
  mTypeface = sTypefaceCache.get(typefaceName);

  if (mTypeface == null) {
    mTypeface = Typeface.createFromAsset(context.getApplicationContext()
        .getAssets(), String.format(""%s"", typefaceName));

    // Cache the loaded Typeface
    sTypefaceCache.put(typefaceName, mTypeface);
  }
}","/**
 * Load the {@link Typeface} and apply to a spannable.
 */
public TypefaceSpan(Context context, String typefaceName) 
{
    this(context, typefaceName, Typeface.NORMAL);
}   ",664,True
"/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param text
 *     The text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 * @param viewGroup
 *     The {@link ViewGroup} that this {@link Crouton} should be added to.
 */
private Crouton(Activity activity, CharSequence text, Style style, ViewGroup viewGroup){
  if ((activity == null) || (text == null) || (style == null)) {
    throw new IllegalArgumentException(NULL_PARAMETERS_ARE_NOT_ACCEPTED);
  }

  this.activity = activity;
  this.text = text;
  this.style = style;
  this.viewGroup = viewGroup;
  this.customView = null;
}","/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param text
 *     The text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 * @param viewGroup
 *     The {@link ViewGroup} that this {@link Crouton} should be added to.
 */
private Crouton(Activity activity, CharSequence text, Style style, ViewGroup viewGroup) 
{
    this.activity = activity;
    this.text = text;
    this.style = style;
    this.viewGroup = viewGroup;

    this.view = LayoutInflater.from(activity).inflate(R.layout.crouton, viewGroup, false);
    this.textView = (TextView) view.findViewById(R.id.crouton_text);

    this.textView.setText(text);

    applyStyle();
}   ",666,True
"/**
 * Creates a {@link Crouton} with provided text-resource and style for a given
 * activity.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param textResourceId
 *     The resource id of the text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 * @param viewGroupResId
 *     The resource id of the {@link ViewGroup} that this {@link Crouton} should be added to.
 *
 * @return The created {@link Crouton}.
 */
public static Crouton makeText(Activity activity, int textResourceId, Style style, int viewGroupResId){
  return makeText(activity, activity.getString(textResourceId), style,
      (ViewGroup) activity.findViewById(viewGroupResId));
}","/**
 * Creates a {@link Crouton} with provided text-resource and style for a given
 * activity.
 *
 * @param activity
 *     The {@link Activity} that represents the context in which the Crouton should exist.
 * @param textResourceId
 *     The resource id of the text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 * @param viewGroupResId
 *     The resource id of the {@link ViewGroup} that this {@link Crouton} should be added to.
 *
 * @return The created {@link Crouton}.
 */




public static Crouton makeText(Activity activity, int textResourceId, Style style, int viewGroupResId) 
{
    LayoutInflater inflater = activity.getLayoutInflater();
    View view = inflater.inflate(R.layout.crouton, null);
    ((TextView) view.findViewById(R.id.crouton_text)).setText(textResourceId);
    return new Crouton(view, viewGroupResId, style);
}   ",668,True
"/**
 * Convenience method to get the license text for embedding within your application.
 *
 * @return The license text.
 */
public static String getLicenseText(){
  return ""This application uses the Crouton library.\n\n"" +
      ""Copyright 2012 - 2013 Benjamin Weiss \n"" +
      ""\n"" +
      ""Licensed under the Apache License, Version 2.0 (the \""License\"");\n"" +
      ""you may not use this file except in compliance with the License.\n"" +
      ""You may obtain a copy of the License at\n"" +
      ""\n"" +
      ""   http://www.apache.org/licenses/LICENSE-2.0\n"" +
      ""\n"" +
      ""Unless required by applicable law or agreed to in writing, software\n"" +
      ""distributed under the License is distributed on an \""AS IS\"" BASIS,\n"" +
      ""WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"" +
      ""See the License for the specific language governing permissions and\n"" +
      ""limitations under the License."";
}","/**
 * Convenience method to get the license text for embedding within your application.
 *
 * @return The license text.
 */

public static String getLicenseText() 
{
    try (InputStream inputStream = License.class.getResourceAsStream(""/license.txt""))
    {
        return IOUtils.stringFromInputStream(inputStream);
    }
    catch (IOException e)
    {
        throw new RuntimeException(e);
    }
}   ",671,True
"/**
 * Removes the {@link Crouton}'s view after it's display
 * durationInMilliseconds.
 *
 * @param crouton
 *     The {@link Crouton} added to a {@link ViewGroup} and should be
 *     removed.
 */
protected void removeCrouton(Crouton crouton){
  // If the crouton hasn't been displayed yet a `Crouton.hide()` will fail to hide
  // it since the DISPLAY message might still be in the queue. Remove all messages
  // for this crouton.
  removeAllMessagesForCrouton(crouton);

  View croutonView = crouton.getView();
  ViewGroup croutonParentView = (ViewGroup) croutonView.getParent();

  if (null != croutonParentView) {
    croutonView.startAnimation(crouton.getOutAnimation());

    // Remove the Crouton from the queue.
    Crouton removed = croutonQueue.poll();

    // Remove the crouton from the view's parent.
    croutonParentView.removeView(croutonView);
    if (null != removed) {
      removed.detachActivity();
      removed.detachViewGroup();
      if (null != removed.getLifecycleCallback()) {
        removed.getLifecycleCallback().onRemoved();
      }
      removed.detachLifecycleCallback();
    }

    // Send a message to display the next crouton but delay it by the out
    // animation duration to make sure it finishes
    sendMessageDelayed(crouton, Messages.DISPLAY_CROUTON, crouton.getOutAnimation().getDuration());
  }
}","/**
 * Removes the {@link Crouton}'s view after it's display
 * durationInMilliseconds.
 *
 * @param crouton
 *     The {@link Crouton} added to a {@link ViewGroup} and should be
 *     removed.
 */

protected void removeCrouton(Crouton crouton) 
{
    if (crouton.isShowing()) {
        if (crouton.getParent() != null) {
            ((ViewGroup) crouton.getParent()).removeView(crouton.getView());
        }
        crouton.clear();
    }
}   ",673,True
"/**
 * Generates and dispatches an SDK-specific spoken announcement.
 * <p>
 * For backwards compatibility, we're constructing an event from scratch
 * using the appropriate event type. If your application only targets SDK
 * 16+, you can just call View.announceForAccessibility(CharSequence).
 * </p>
 * <p/>
 * note: AccessibilityManager is only available from API lvl 4.
 * <p/>
 * Adapted from https://http://eyes-free.googlecode.com/files/accessibility_codelab_demos_v2_src.zip
 * via https://github.com/coreform/android-formidable-validation
 *
 * @param context
 *     Used to get {@link AccessibilityManager}
 * @param text
 *     The text to announce.
 */
public static void announceForAccessibilityCompat(Context context, CharSequence text){
  if (Build.VERSION.SDK_INT >= 4) {
    AccessibilityManager accessibilityManager = null;
    if (null != context) {
      accessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    }
    if (null == accessibilityManager || !accessibilityManager.isEnabled()) {
      return;
    }

    // Prior to SDK 16, announcements could only be made through FOCUSED
    // events. Jelly Bean (SDK 16) added support for speaking text verbatim
    // using the ANNOUNCEMENT event type.
    final int eventType;
    if (Build.VERSION.SDK_INT < 16) {
      eventType = AccessibilityEvent.TYPE_VIEW_FOCUSED;
    } else {
      eventType = AccessibilityEvent.TYPE_ANNOUNCEMENT;
    }

    // Construct an accessibility event with the minimum recommended
    // attributes. An event without a class name or package may be dropped.
    final AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
    event.getText().add(text);
    event.setClassName(Manager.class.getName());
    event.setPackageName(context.getPackageName());

    // Sends the event directly through the accessibility manager. If your
    // application only targets SDK 14+, you should just call
    // getParent().requestSendAccessibilityEvent(this, event);
    accessibilityManager.sendAccessibilityEvent(event);
  }
}","/**
 * Generates and dispatches an SDK-specific spoken announcement.
 * <p>
 * For backwards compatibility, we're constructing an event from scratch
 * using the appropriate event type. If your application only targets SDK
 * 16+, you can just call View.announceForAccessibility(CharSequence).
 * </p>
 * <p/>
 * note: AccessibilityManager is only available from API lvl 4.
 * <p/>
 * Adapted from https://http://eyes-free.googlecode.com/files/accessibility_codelab_demos_v2_src.zip
 * via https://github.com/coreform/android-formidable-validation
 *
 * @param context
 *     Used to get {@link AccessibilityManager}
 * @param text
 *     The text to announce.
 */

public static void announceForAccessibilityCompat(Context context, CharSequence text) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
    {
        AccessibilityManager accessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled())
        {
            AccessibilityEvent event = AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_FOCUSED);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }
    else
    {
        //noinspection deprecation
        @SuppressWarnings(""deprecation"")
        int eventType = AccessibilityEvent.TYPE_VIEW_FOCUSED;
        AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
        event.getText().add(text);
        AccessibilityManager accessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
        //noinspection deprecation
        accessibilityManager.sendAccessibilityEvent(event);
    }
}   ",674,True
"/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that the {@link Crouton} should be attached
 *     to.
 * @param customView
 *     The custom {@link View} to display
 */
private Crouton(Activity activity, View customView){
  if ((activity == null) || (customView == null)) {
    throw new IllegalArgumentException(NULL_PARAMETERS_ARE_NOT_ACCEPTED);
  }

  this.activity = activity;
  this.viewGroup = null;
  this.customView = customView;
  this.style = new Style.Builder().build();
  this.text = null;
}","/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that the {@link Crouton} should be attached
 *     to.
 * @param customView
 *     The custom {@link View} to display
 */
private Crouton(Activity activity, View customView) 
{
    this.activity = activity;
    this.customView = customView;
    this.customView.setOnClickListener(new View.OnClickListener()
    {
        @Override
        public void onClick(View v)
        {
            hide();
        }
    });
    this.customView.setOnTouchListener(new View.OnTouchListener()
    {
        @Override
        public boolean onTouch(View v, MotionEvent event)
        {
            if (event.getAction() == MotionEvent.ACTION_DOWN)
            {
                hide();
            }
            return true;
        }
    });
}   ",676,True
"/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that the {@link Crouton} should be attached
 *     to.
 * @param text
 *     The text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 */
private Crouton(Activity activity, CharSequence text, Style style){
  if ((activity == null) || (text == null) || (style == null)) {
    throw new IllegalArgumentException(NULL_PARAMETERS_ARE_NOT_ACCEPTED);
  }

  this.activity = activity;
  this.viewGroup = null;
  this.text = text;
  this.style = style;
  this.customView = null;
}","/**
 * Creates the {@link Crouton}.
 *
 * @param activity
 *     The {@link Activity} that the {@link Crouton} should be attached
 *     to.
 * @param text
 *     The text you want to display.
 * @param style
 *     The style that this {@link Crouton} should be created with.
 */



private Crouton(Activity activity, CharSequence text, Style style) 
{
    this.activity = activity;
    this.text = text;
    this.style = style;

    ViewGroup container = getContainer();
    LayoutInflater inflater = LayoutInflater.from(activity);
    View view = inflater.inflate(R.layout.crouton, container, false);
    TextView textView = (TextView) view.findViewById(R.id.crouton_text);
    textView.setText(text);

    container.addView(view);
    view.setOnClickListener(this);
    view.startAnimation(getInAnimation());
    if (style.duration > 0) {
        view.postDelayed(this, style.duration + ANIMATION_DURATION);
    }
}   ",678,False
"/**
 * Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by
 * {@link java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by
 * {@link java.lang.reflect.Method#getReturnType} of the same method object. Specifically:
 * <ul>
 * <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.
 * <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is
 *     returned.
 * <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array
 *     class. For example: {@code List<Integer>[] => List[]}.
 * <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound
 *     is returned. For example: {@code <X extends Foo> => Foo}.
 * </ul>
 */
@SuppressWarnings(""unchecked"")
public final Class<T> getRawType(){
    Class<?> rawType = getRawType(type);
    // raw type is |T|
    Class<T> result = (Class<T>) rawType;
    return result;
}","/**
 * Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by
 * {@link java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by
 * {@link java.lang.reflect.Method#getReturnType} of the same method object. Specifically:
 * <ul>
 * <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.
 * <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is
 *     returned.
 * <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array
 *     class. For example: {@code List<Integer>[] => List[]}.
 * <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound
 *     is returned. For example: {@code <X extends Foo> => Foo}.
 * </ul>
 */








@SuppressWarnings(""unchecked"")
public final Class<T> getRawType() 
{
    if (this instanceof Class<?>)
    {
        return (Class<T>)this;
    }
    else if (this instanceof ParameterizedType)
    {
        return (Class<T>)((ParameterizedType)this).getRawType();
    }
    else if (this instanceof GenericArrayType)
    {
        return (Class<T>)Array.newInstance(((GenericArrayType)this).getGenericComponentType().getRawType(), 0).getClass();
    }
    else if (this instanceof WildcardType)
    {
        return getRawType(((WildcardType)this).getUpperBounds());
    }
    else
    {
        throw new IllegalArgumentException(""Unexpected type "" + this.getClass());
    }
}   ",681,True
"/**
 * I would not think this should be a supported use case but nevertheless it
 * failed because it only performed one additional lookup iteration on
 * finding an interface...
 */
@Test
public void testRegisterInterfaceToInterface(){
    SquirrelProvider.getInstance().register(Person.class, Student.class);
    SquirrelProvider.getInstance().register(Student.class, Programmer.class);
    Person p = SquirrelProvider.getInstance().newInstance(Person.class);
    assertThat(p, notNullValue());
    assertThat(p, instanceOf(ProgrammerImpl.class));
    SquirrelProvider.getInstance().unregister(Person.class);
}","/**
 * I would not think this should be a supported use case but nevertheless it
 * failed because it only performed one additional lookup iteration on
 * finding an interface...
 */

@Test
public void testRegisterInterfaceToInterface() 
{
    final String interfaceName = ""testRegisterInterfaceToInterface"";
    final String interfaceName2 = ""testRegisterInterfaceToInterface2"";
    final String implementationName = ""testRegisterInterfaceToInterfaceImpl"";
    final String implementationName2 = ""testRegisterInterfaceToInterfaceImpl2"";
    final String implementationName3 = ""testRegisterInterfaceToInterfaceImpl3"";

    final BeanDefinition interfaceDefinition = BeanDefinitionBuilder
        .genericBeanDefinition(TestInterface.class)
        .setFactoryMethod(""create"")
        .addPropertyValue(""name"", interfaceName)
        .getBeanDefinition();

    final BeanDefinition interfaceDefinition2 = BeanDefinitionBuilder
        .genericBeanDefinition(TestInterface.class)
        .setFactoryMethod(""create"")
        .addPropertyValue(""name"", interfaceName2)
        .getBeanDefinition();

    final BeanDefinition implementationDefinition = BeanDefinitionBuilder
        .genericBeanDefinition(TestInterfaceImpl.class)
        .setFactoryMethod(""create"")
        .addPropertyValue(""name"", implementationName)
        .getBeanDefinition();

    final BeanDefinition implementationDefinition2 = BeanDefinitionBuilder
        .genericBeanDefinition(TestInterfaceImpl2.class)
        .setFactoryMethod(""create"")
        .addPropertyValue(""name"", implementationName2)
        .getBeanDefinition();

    final BeanDefinition implementationDefinition3 = BeanDefinitionBuilder
        .genericBeanDefinition(TestInterfaceImpl3.class)
        .setFactoryMethod(""create"")
        .addPropertyValue(""name"", implementationName3)
        .getBeanDefinition();

    this.beanFactory.registerBeanDefinition(interfaceName, interfaceDefinition);
    this.beanFactory.registerBeanDefinition(interfaceName2, interfaceDefinition2);
    this.beanFactory.registerBeanDefinition(implementationName, implementationDefinition);
    this.beanFactory.registerBeanDefinition(implementationName2, implementationDefinition2);
    this.beanFactory.registerBeanDefinition(implementationName3, implementationDefinition3);

    final TestInterface testInterface = this.beanFactory.getBean(implementationName, TestInterface.class);
    final TestInterface testInterface2 = this.beanFactory.getBean(implementationName2, TestInterface.class);
    final TestInterface testInterface3 = this.beanFactory.getBean(implementationName3, TestInterface.class);

    assertNotNull(testInterface);
    assertNotNull(testInterface2);
    assertNotNull(testInterface3);

    assertEquals(interfaceName, testInterface.getName());
    assertEquals(interfaceName2, testInterface2.getName());
    assertEquals(interfaceName2, testInterface3.getName());
}   ",686,False
"// original transition D-[ToA, Always, 1]->B was override to D-[ToA, Always, 1000]->A
public void testTransitionPriority2(){
    stateMachine.fire(ToB, null);
    stateMachine.fire(ToC, null);
    stateMachine.fire(ToD, null);
    stateMachine.fire(ToA, null);
    assertThat(stateMachine.getCurrentState(), equalTo(A));
}","// original transition D-[ToA, Always, 1]->B was override to D-[ToA, Always, 1000]->A
public void testTransitionPriority2() 
{
    PetriNet net = new PetriNet();
    Place p1 = net.addPlace(""P1"");
    Place p2 = net.addPlace(""P2"");
    Transition t = net.addTransition(""T"");
    Arc a1 = net.addArc(p1, t, 1);
    Arc a2 = net.addArc(t, p2, 1);
    t.setPriority(1000);
    assertEquals(1000, t.getPriority());
    assertEquals(1000, a1.getWeight());
    assertEquals(1000, a2.getWeight());
}   ",689,False
"/**
 * Initializes a test.
 */
@Before
public void setup(){
    MockitoAnnotations.initMocks(this);

    StateMachineBuilder<DeclarativeStateMachine, TestState, TestEvent, Integer> builder = 
            StateMachineBuilderFactory.<DeclarativeStateMachine, TestState, TestEvent, Integer>
                create(DeclarativeStateMachineImpl.class, TestState.class, 
                        TestEvent.class, Integer.class, DeclarativeStateMachine.class);
    stateMachine = builder.newStateMachine(TestState.A, monitor);
    StateMachineLogger fsmLogger = new StateMachineLogger(stateMachine);
    fsmLogger.startLogging();
}","/**
 * Initializes a test.
 */
@Before
public void setup() 
{
    // Create a new instance of the class under test
    cut = new ClassUnderTest();
}   ",691,False
"/**
 * Encodes a byte array into Base64 format. No blanks or line breaks are
 * inserted in the output.
 * 
 * @param in
 *            An array containing the data bytes to be encoded.
 * @param iOff
 *            Offset of the first byte in <code>in</code> to be processed.
 * @param iLen
 *            Number of bytes to process in <code>in</code>, starting at
 *            <code>iOff</code>.
 * @return A character array containing the Base64 encoded data.
 */
public static char[] encode(byte[] in, int iOff, int iLen){
    int oDataLen = (iLen * 4 + 2) / 3; // output length without padding
    int oLen = ((iLen + 2) / 3) * 4; // output length including padding
    char[] out = new char[oLen];
    int ip = iOff;
    int iEnd = iOff + iLen;
    int op = 0;
    while (ip < iEnd) {
        int i0 = in[ip++] & 0xff;
        int i1 = ip < iEnd ? in[ip++] & 0xff : 0;
        int i2 = ip < iEnd ? in[ip++] & 0xff : 0;
        int o0 = i0 >>> 2;
        int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
        int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
        int o3 = i2 & 0x3F;
        out[op++] = map1[o0];
        out[op++] = map1[o1];
        out[op] = op < oDataLen ? map1[o2] : '=';
        op++;
        out[op] = op < oDataLen ? map1[o3] : '=';
        op++;
    }
    return out;
}","/**
 * Encodes a byte array into Base64 format. No blanks or line breaks are
 * inserted in the output.
 * 
 * @param in
 *            An array containing the data bytes to be encoded.
 * @param iOff
 *            Offset of the first byte in <code>in</code> to be processed.
 * @param iLen
 *            Number of bytes to process in <code>in</code>, starting at
 *            <code>iOff</code>.
 * @return A character array containing the Base64 encoded data.
 */
public static char[] encode(byte[] in, int iOff, int iLen) 
{
    int oDataLen = (iLen * 4 + 2) / 3; // output length without padding
    int oLen = ((iLen + 2) / 3) * 4; // output length including padding
    char[] out = new char[oLen];
    int ip = iOff;
    int iEnd = iOff + iLen;
    int op = 0;
    while (ip < iEnd)
    {
        int i0 = in[ip++] & 0xff;
        int i1 = ip < iEnd ? in[ip++] & 0xff : 0;
        int i2 = ip < iEnd ? in[ip++] & 0xff : 0;
        int o0 = i0 >>> 2;
        int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
        int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
        int o3 = i2 & 0x3F;
        out[op++] = map1[o0];
        out[op++] = map1[o1];
        out[op] = op < oDataLen ? map1[o2] : '=';
        op++;
        out[op] = op < oDataLen ? map1[o3] : '=';
        op++;
    }
    return out;
}   ",692,True
"/**
 * Create a new instance of the requested class using the internal registry.
 * @param clz class of new instance
 * @param argTypes arguments type of new instance constructor
 * @param args arguments of new instance constructor
 * @param <T> type of new instance
 * @return new instance
 */
public <T> T newInstance(Class<T> clz, Class<?>[] argTypes, Object[] args){
    Class<T> implementationClass = getImplementation(clz);
    if (args == null) {
        return postProcess(clz, ReflectUtils.newInstance(implementationClass));
    }
    Constructor<T> constructor = ReflectUtils.getConstructor(implementationClass, argTypes);
    return postProcess(clz, ReflectUtils.newInstance(constructor, args));
}","/**
 * Create a new instance of the requested class using the internal registry.
 * @param clz class of new instance
 * @param argTypes arguments type of new instance constructor
 * @param args arguments of new instance constructor
 * @param <T> type of new instance
 * @return new instance
 */
public <T> T newInstance(Class<T> clz, Class<?>[] argTypes, Object[] args) 
{
    try
    {
        Constructor<T> constructor = clz.getDeclaredConstructor(argTypes);
        constructor.setAccessible(true);
        return constructor.newInstance(args);
    }
    catch (Exception e)
    {
        throw new RuntimeException(e);
    }
}   ",694,True
"/**
 * Enters this instance with history type = shallow.
 *
 * @param stateContext
 *            state context
 * @return the entered state
 */
private ImmutableState<T, S, E, C> enterHistoryShallow(StateContext<T, S, E, C> stateContext){
    final ImmutableState<T, S, E, C> lastActiveState = getLastActiveChildStateOf(this, stateContext.getStateMachineData().read());
    return lastActiveState != null ? lastActiveState.enterShallow(stateContext) : this;
}","/**
 * Enters this instance with history type = shallow.
 *
 * @param stateContext
 *            state context
 * @return the entered state
 */
private ImmutableState<T, S, E, C> enterHistoryShallow(StateContext<T, S, E, C> stateContext) 
{
    return enterHistory(stateContext, false);
}   ",696,False
"// TODO-hhe: check type safety
@Override
   public void internalFire(StateContext<T, S, E, C> stateContext){
       StateMachine<? extends StateMachine<?, S, E, C>, S, E, C> stateMachine = 
               linkedStateMachineInstances.get(getKey(stateContext.getStateMachine().getThis()));
       if(stateMachine.getStatus()==StateMachineStatus.TERMINATED) {
           // if linked state machine entered its final state, then outside state will process event, 
           super.internalFire(stateContext);
       } else {
           // otherwise the linked state machine will try to process event first and only handle event 
           // to outside state when event was declined by linked state machine.
           DeclineEventHandler declinedEventHandler = new DeclineEventHandler(stateContext);
           try {
               // add declined event listener
               stateMachine.addTransitionDeclinedListener(declinedEventHandler);
               // set child(linked) state machine context
               StateMachineContext.set(stateMachine.getThis(), StateMachineContext.isTestEvent());
               // delegate the event to linked state machine process
               stateMachine.fire(stateContext.getEvent(), stateContext.getContext());
           } finally {
               StateMachineContext.set(null);
               // remove declined event listener
               stateMachine.removeTransitionDecleindListener(declinedEventHandler);
           }
       }
   }","// TODO-hhe: check type safety
@Override
   public void internalFire(StateContext<T, S, E, C> stateContext) 
{
   if (stateContext.isEventAccepted())
   {
      stateContext.consumeEvent();
      stateContext.fireTransition();
   }
   else
   {
      stateContext.declareEventUnconsumed();
   }
}  ",698,True
"// Parametes example: 5 10
public static void main(String[] args){
    int personOrder = Integer.parseInt(args[0]);
    int numberOfPeople = Integer.parseInt(args[1]);

    StdOut.println(""Order in which people are eliminated:"");
    josephusProblem(personOrder, numberOfPeople);
}","// Parametes example: 5 10
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int result = a;
    for(int i=1; i<b; i++)
    {
        result *= a;
    }
    System.out.println(result);
}   ",700,False
"//O(lg N)
public Comparable deleteMin(){
    if (size == 0) {
        throw new RuntimeException(""Priority queue underflow"");
    }

    size--;

    PQNode min = minPriorityQueue[1];

    deleteTopItem(minPriorityQueue, Orientation.MIN);
    deleteItem(maxPriorityQueue, Orientation.MAX, min.maxHeapIndex);

    if (size == minPriorityQueue.length / 4) {
        resize(minPriorityQueue.length / 2);
    }

    return min.key;
}","//O(lg N)
public Comparable deleteMin() 
{
    Comparable min = findMin();
    root = deleteMin(root);
    return min;
}   ",701,True
"// O(n lg n) due to sort - the hash map in the nodes saves memory, but does not necessarily store subsets in order.
// So a sort is required to return the keys in order.
public Iterable<String> keys(){
    List<String> keys = new ArrayList<>();
    keys(root, new StringBuilder(), keys);

    Collections.sort(keys);

    return keys;
}","// O(n lg n) due to sort - the hash map in the nodes saves memory, but does not necessarily store subsets in order.
// So a sort is required to return the keys in order.






public Iterable<String> keys() 
{
    List<String> keys = new ArrayList<String>(st.size());
    for (String key : st.keys())
        keys.add(key);
    Collections.sort(keys);
    return keys;
}   ",704,True
"// Searches for the pattern in the text starting at specified index
protected int searchFromIndex(String text, int textStartIndex){
    String eligibleText = text.substring(textStartIndex);

    int textLength = eligibleText.length();

    if (textLength < patternLength) {
        return textStartIndex + textLength;  // no match
    }

    long textHash = hash(eligibleText);

    if (patternHash == textHash && check(eligibleText, 0)) {
        return textStartIndex;  // match
    }

    for (int textIndex = patternLength; textIndex < textLength; textIndex++) {
        // Remove leading character, add trailing character, check for match
        textHash = (textHash + largePrimeNumber - rm * eligibleText.charAt(textIndex - patternLength) % largePrimeNumber)
                % largePrimeNumber;
        textHash = (textHash * alphabetSize + eligibleText.charAt(textIndex)) % largePrimeNumber;

        int offset = textIndex - patternLength + 1;

        if (patternHash == textHash && check(eligibleText, offset)) {
            return textStartIndex + offset;  // match
        }
    }

    return textStartIndex + textLength;      // no match
}","// Searches for the pattern in the text starting at specified index
protected int searchFromIndex(String text, int textStartIndex) 
{
    int textIndex = textStartIndex;
    int patternIndex = 0;

    while (textIndex < text.length())
    {
        if (text.charAt(textIndex) == pattern.charAt(patternIndex))
        {
            patternIndex++;
            if (patternIndex == pattern.length())
            {
                return (textIndex - pattern.length() + 1);
            }
        }
        else
        {
            textIndex = textIndex - patternIndex + 1;
            patternIndex = 0;
        }
    }
    return -1;
}   ",705,False
"/*
Solution to Part 1: To achieve 2 * sqrt(N), drop eggs at floors
sqrt(N), 2 * sqrt(N), 3 * sqrt(N), ..., sqrt(N) * sqrt(N).
(For simplicity, we assume here that sqrt(N) is an integer.)
Let assume that the egg broke at level k * sqrt(N).
With the second egg you should then perform a linear search
in the interval (k-1) * sqrt(N) to k * sqrt(N).
In total you will be able to find the floor F in at most 2 * sqrt(N) trials.
 */
private int findFloorIn2SqrtN(int[] array, int low, int high, int searchLevel){
    int key = 1;

    if (low <= high) {
        int sqrt = (int) Math.sqrt(array.length - 1);

        int separator = sqrt * searchLevel;

        if (separator >= array.length) {
            separator = array.length - 1;
        }

        StdOut.println(""Debug - current index: "" + separator);

        if (key > array[separator]) {
            return findFloorIn2SqrtN(array, separator + 1, high, ++searchLevel);
        } else {
            //We broke 1 out of 2 eggs, now we do a linear search starting from a floor in which we know that the egg
            // does not break

            if (searchLevel != 0) {
                searchLevel = searchLevel - 1;
            }

            int lastFloorThatDidNotBreak = sqrt * searchLevel;

            for(int i = lastFloorThatDidNotBreak; i <= separator; i++) {
                StdOut.println(""Debug - current index: "" + i);

                if (array[i] == 1) {
                    //2 out of 2 eggs broken, but we now have the floor number
                    return i;
                }
            }
        }
    }

    return -1;
}","/*
Solution to Part 1: To achieve 2 * sqrt(N), drop eggs at floors
sqrt(N), 2 * sqrt(N), 3 * sqrt(N), ..., sqrt(N) * sqrt(N).
(For simplicity, we assume here that sqrt(N) is an integer.)
Let assume that the egg broke at level k * sqrt(N).
With the second egg you should then perform a linear search
in the interval (k-1) * sqrt(N) to k * sqrt(N).
In total you will be able to find the floor F in at most 2 * sqrt(N) trials.
 */
private int findFloorIn2SqrtN(int[] array, int low, int high, int searchLevel) 
{
    int floor = -1;
    int start = searchLevel * searchLevel;
    int end = (searchLevel + 1) * (searchLevel + 1);
    for (int i = start; i < end && i < high; i++)
    {
        if (array[i] == 1)
        {
            floor = i;
            break;
        }
    }
    return floor;
}   ",706,True
"// Prints all the occurrences of pattern in the text
public void searchAll(String text){
    int occurrenceIndex = searchFromIndex(text, 0);

    if (occurrenceIndex == text.length()) {
        StdOut.println(""No occurrences"");
        return;
    }

    while (occurrenceIndex != text.length()) {
        StdOut.println(""Pattern found at index "" + occurrenceIndex);

        if (occurrenceIndex + 1 >= text.length()) {
            break;
        }

        occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
    }
}","// Prints all the occurrences of pattern in the text
public void searchAll(String text) 
{
    int index = text.indexOf(pattern);
    while (index != -1)
    {
        System.out.println(""Pattern found at index "" + index);
        index = text.indexOf(pattern, index + 1);
    }
}   ",707,False
"// V = SQRT(2 kb T / M)
// SQRT(V / 2) = (vx + vy) / 2
private void setTemperature(double temperature){

    for (ParticleInterface particle : particles) {
        ParticleWithTemperature particleWithTemperature = (ParticleWithTemperature) particle;

        double newVelocityMagnitude =
                Math.sqrt(2 * BOLTZMANN_CONSTANT * temperature / particleWithTemperature.getMass());
        double velocityComponent = Math.sqrt(newVelocityMagnitude / 2);
        particleWithTemperature.setVelocityX(velocityComponent);
        particleWithTemperature.setVelocityY(velocityComponent);
    }
}","// V = SQRT(2 kb T / M)
// SQRT(V / 2) = (vx + vy) / 2
private void setTemperature(double temperature) 
{
    if (temperature < 0)
    {
        throw new IllegalArgumentException(""Temperature cannot be negative"");
    }

    this.temperature = temperature;
    double v = Math.sqrt(2 * kb * temperature / mass);
    this.vx = v / 2;
    this.vy = v / 2;
}   ",708,True
"// Display header
private static void header(Comparable[] array){
    StdDraw.setPenColor(StdDraw.BLACK);
    StdDraw.text(array.length / 2.0, -2.7, ""array[ ]"");

    for (int i = 0; i < array.length; i++) {
        StdDraw.text(i, -2, String.valueOf(i));
    }

    StdDraw.text(-2.50, -2, ""i"");
    StdDraw.text(-1.25, -2, ""j"");
    StdDraw.setPenColor(StdDraw.BOOK_RED);
    StdDraw.line(-3, -1.65, array.length - 0.5, -1.65);
    StdDraw.setPenColor(StdDraw.BLACK);

    for (int i = 0; i < array.length; i++) {
        StdDraw.text(i, -1, String.format(""%.1f"", Double.parseDouble(String.valueOf(array[i]))));
    }
}","// Display header

private static void header(Comparable[] array) 
{
    System.out.print(""Original: "");
    for (int i = 0; i < array.length; i++)
    {
        System.out.print(array[i] + "" "");
    }
    System.out.println();
}   ",712,False
"// Returns the highest key in the symbol table smaller than or equal to key.
public Key floor(Key key){
    PageSTInterface<Key, Value> pageThatMayContainKey = getPageThatMayContainKey(key);
    pageThatMayContainKey.open();

    Key floorKey = pageThatMayContainKey.floor(key);
    pageThatMayContainKey.close(false);

    if (floorKey == sentinel) {
        floorKey = null;
    }

    return floorKey;
}","// Returns the highest key in the symbol table smaller than or equal to key.
public Key floor(Key key) 
{
    if (isEmpty()) return null;
    int i = rank(key);
    if (i < N && key.compareTo(keys[i]) == 0) return keys[i];
    return (i == 0) ? null : keys[i-1];
}   ",714,False
"// Returns the smallest key in the symbol table greater than or equal to key.
public Key ceiling(Key key){
    PageSTInterface<Key, Value> pageThatMayContainKey = getPageThatMayContainKey(key);
    pageThatMayContainKey.open();

    Key ceilingKey = pageThatMayContainKey.ceiling(key);
    pageThatMayContainKey.close(false);

    if (ceilingKey == null) {
        int rank = rank(key);

        if (rank < size()) {
            ceilingKey = select(rank);
        }
    }

    if (ceilingKey == sentinel) {
        ceilingKey = min();
    }

    return ceilingKey;
}","// Returns the smallest key in the symbol table greater than or equal to key.
public Key ceiling(Key key) 
{
    if (contains(key)) return key;
    int i = rank(key);
    if (i == N) return null;
    return keys[i];
}   ",715,True
"// Trade-off between time and memory
// Takes longer because it has to create the iterators, but avoid stack overflows
private void depthFirstSearchIterative(Graph graph, int sourceVertex, boolean[] visited){
    Stack<Integer> stack = new Stack<>();
    stack.push(sourceVertex);
    visited[sourceVertex] = true;
    StdOut.print(sourceVertex + "" "");

    // Used to be able to iterate over each adjacency list, keeping track of which
    // vertex in each adjacency list needs to be explored next
    Iterator<Integer>[] adjacentIterators = (Iterator<Integer>[]) new Iterator[graph.vertices()];

    for (int vertexId = 0; vertexId < adjacentIterators.length; vertexId++) {
        if (graph.adjacent(vertexId) != null) {
            adjacentIterators[vertexId] = graph.adjacent(vertexId).iterator();
        }
    }

    while (!stack.isEmpty()) {
        int currentVertex = stack.peek();

        if (adjacentIterators[currentVertex].hasNext()) {
            int neighbor = adjacentIterators[currentVertex].next();

            if (!visited[neighbor]) {
                StdOut.print(neighbor + "" "");

                stack.push(neighbor);
                visited[neighbor] = true;
            }
        } else {
            stack.pop();
        }
    }
}","// Trade-off between time and memory
// Takes longer because it has to create the iterators, but avoid stack overflows


private void depthFirstSearchIterative(Graph graph, int sourceVertex, boolean[] visited) 
{
    Stack<Integer> stack = new Stack<>();
    stack.push(sourceVertex);
    while (!stack.isEmpty())
    {
        int currentVertex = stack.pop();
        if (!visited[currentVertex])
        {
            visited[currentVertex] = true;
            System.out.print(currentVertex + "" "");
            List<Integer> neighbors = graph.getNeighbors(currentVertex);
            for (int neighbor : neighbors)
            {
                if (!visited[neighbor])
                {
                    stack.push(neighbor);
                }
            }
        }
    }
}   ",718,True
"/**
 * @see MediaPlayer#setDataSource(FileDescriptor fd, long offset, long length)
 */
public void setDataSource(AssetFileDescriptor assetFileDescriptor) throws IOException{
    synchronized (mState) {
        switch (mState.get()) {
            case IDLE:
                mMediaPlayer.setDataSource(
                        assetFileDescriptor.getFileDescriptor(),
                        assetFileDescriptor.getStartOffset(),
                        assetFileDescriptor.getLength());
                mState.set(State.INITIALIZED);
                break;
            case INITIALIZED:
            case PREPARING:
            case PREPARED:
            case STARTED:
            case PAUSED:
            case STOPPED:
            case PLAYBACK_COMPLETED:
            case END:
            case ERROR:
            default:
                throw new IllegalStateException(""setDataSource called in state "" + mState);
        }
    }
}","/**
 * @see MediaPlayer#setDataSource(FileDescriptor fd, long offset, long length)
 */
public void setDataSource(AssetFileDescriptor assetFileDescriptor) throws IOException 
{
    if (assetFileDescriptor == null)
    {
        throw new IllegalArgumentException(""Argument cannot be null"");
    }
    setDataSource(assetFileDescriptor.getFileDescriptor(), assetFileDescriptor.getStartOffset(), assetFileDescriptor.getLength());
}   ",720,True
"/**
 * When Scrolling list is in this state we start calculating Active Item.
 * Here we assume that scroll state was idle previously and {@link #mCurrentItem} already contains some data
 *
 * @param itemsPositionGetter
 */
@Override
protected void onStateTouchScroll(ItemsPositionGetter itemsPositionGetter){
    if(SHOW_LOGS) Logger.v(TAG, "">> onStateTouchScroll, mScrollDirection "" + mScrollDirection);

    ListItemData listItemData = mCurrentItem;
    if(SHOW_LOGS) Logger.v(TAG, ""onStateTouchScroll, listItemData "" + listItemData);

    calculateActiveItem(itemsPositionGetter, listItemData);
    if(SHOW_LOGS) Logger.v(TAG, ""<< onStateTouchScroll, mScrollDirection "" + mScrollDirection);
}","/**
 * When Scrolling list is in this state we start calculating Active Item.
 * Here we assume that scroll state was idle previously and {@link #mCurrentItem} already contains some data
 *
 * @param itemsPositionGetter
 */
@Override
protected void onStateTouchScroll(ItemsPositionGetter itemsPositionGetter) 
{
    if (mCurrentItem != null)
    {
        calculateActiveItem(itemsPositionGetter);
    }
}   ",721,True
"/**
 * This method calculates most visible item from top to bottom or from bottom to top depends on scroll direction.
 *
 * @param itemsPositionGetter
 * @param firstVisiblePosition
 * @param lastVisiblePosition
 */
private void calculateMostVisibleItem(ItemsPositionGetter itemsPositionGetter, int firstVisiblePosition, int lastVisiblePosition){

    ListItemData mostVisibleItem = getMockCurrentItem(itemsPositionGetter, firstVisiblePosition, lastVisiblePosition);
    int maxVisibilityPercents = mostVisibleItem.getVisibilityPercents(mListItems);

    switch (mScrollDirection){
        case UP:
            bottomToTopMostVisibleItem(itemsPositionGetter, maxVisibilityPercents, mostVisibleItem);
            break;
        case DOWN:
            topToBottomMostVisibleItem(itemsPositionGetter, maxVisibilityPercents, mostVisibleItem);
            break;
        default:
            throw new RuntimeException(""not handled mScrollDirection "" + mScrollDirection);
    }
    if(SHOW_LOGS) Logger.v(TAG, ""topToBottomMostVisibleItem, mostVisibleItem "" + mostVisibleItem);

    if(mostVisibleItem.isMostVisibleItemChanged()){
        if(SHOW_LOGS) Logger.v(TAG, ""topToBottomMostVisibleItem, item changed"");

        setCurrentItem(mostVisibleItem);
    } else {
        if(SHOW_LOGS) Logger.v(TAG, ""topToBottomMostVisibleItem, item not changed"");

    }
}","/**
 * This method calculates most visible item from top to bottom or from bottom to top depends on scroll direction.
 *
 * @param itemsPositionGetter
 * @param firstVisiblePosition
 * @param lastVisiblePosition
 */
private void calculateMostVisibleItem(ItemsPositionGetter itemsPositionGetter, int firstVisiblePosition, int lastVisiblePosition) 
{
    if (itemsPositionGetter.getItemPosition(firstVisiblePosition) > itemsPositionGetter.getItemPosition(lastVisiblePosition))
    {
        mostVisibleItem = firstVisiblePosition;
    }
    else
    {
        mostVisibleItem = lastVisiblePosition;
    }
}   ",722,False
"/**
 * This is copy paste of {@link #startNewPlayback(MetaData, VideoPlayerView, AssetFileDescriptor)}
 * The difference is that this method uses AssetFileDescriptor instead of direct path
 */
private void startNewPlayback(MetaData currentItemMetaData, VideoPlayerView videoPlayerView, String videoUrl){
    // set listener for new player
    // TODO: find a place when we have to remove this listener.
    videoPlayerView.addMediaPlayerListener(this);
    if (SHOW_LOGS) Logger.v(TAG, ""startNewPlayback, mCurrentPlayerState "" + mCurrentPlayerState);

    mPlayerHandler.clearAllPendingMessages(TAG);

    stopResetReleaseClearCurrentPlayer();
    setNewViewForPlayback(currentItemMetaData, videoPlayerView);
    startPlayback(videoPlayerView, videoUrl);
}","/**
 * This is copy paste of {@link #startNewPlayback(MetaData, VideoPlayerView, AssetFileDescriptor)}
 * The difference is that this method uses AssetFileDescriptor instead of direct path
 */

private void startNewPlayback(MetaData currentItemMetaData, VideoPlayerView videoPlayerView, String videoUrl) 
{
    AssetFileDescriptor afd = null;
    try {
        afd = this.context.getAssets().openFd(videoUrl);
    } catch (IOException e) {
        e.printStackTrace();
    }
    startNewPlayback(currentItemMetaData, videoPlayerView, afd);
}   ",724,False
"/**
 * Use it to animate TextureView content x position
 * @param x
 */
public final void setContentX(float x){
    mContentX = (int) x - (getMeasuredWidth() - getScaledContentWidth()) / 2;
    updateMatrixTranslate();
}","/**
 * Use it to animate TextureView content x position
 * @param x
 */
public final void setContentX(float x) 
{
    if (mContentX != x)
    {
        mContentX = x;
        invalidate();
    }
}   ",726,False
"/**
 * This method calculates visibility of next item.
 * There are some cases when next item cannot be filled with data:
 *
 * 1. When current data is last item in the list. In this case there is no next data
 * 2. Index of current view cannot be calculated because view was already recycled
 *
 * @param itemsPositionGetter
 * @param currentIem - the item that is active right now
 * @param outNextItemData - out parameter. It will be filled with next item data if the one exists
 */
private void findNextItem(ItemsPositionGetter itemsPositionGetter, ListItemData currentIem, ListItemData outNextItemData){
    int nextItemVisibilityPercents = 0;
    int nextItemIndex = currentIem.getIndex() + 1;
    if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, nextItemIndex "" + nextItemIndex);

    if(nextItemIndex < mListItems.size()){
        int indexOfCurrentView = itemsPositionGetter.indexOfChild(currentIem.getView());
        if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, indexOfCurrentView "" + indexOfCurrentView);

        if(indexOfCurrentView >= 0){
            View nextView = itemsPositionGetter.getChildAt(indexOfCurrentView + 1);
            if(nextView != null){
                ListItem next = mListItems.get(nextItemIndex);
                if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, next "" + next + "", nextView "" + nextView);

                nextItemVisibilityPercents = next.getVisibilityPercents(nextView);
                outNextItemData.fillWithData(nextItemIndex, nextView);

            } else {
                if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, nextView null. There is no view next to current"");
            }

        } else {
            if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, current view is no longer attached to listView"");
        }
    }
    if(SHOW_LOGS) Logger.v(TAG, ""findNextItem, nextItemVisibilityPercents "" + nextItemVisibilityPercents);
}","/**
 * This method calculates visibility of next item.
 * There are some cases when next item cannot be filled with data:
 *
 * 1. When current data is last item in the list. In this case there is no next data
 * 2. Index of current view cannot be calculated because view was already recycled
 *
 * @param itemsPositionGetter
 * @param currentIem - the item that is active right now
 * @param outNextItemData - out parameter. It will be filled with next item data if the one exists
 */
private void findNextItem(ItemsPositionGetter itemsPositionGetter, ListItemData currentIem, ListItemData outNextItemData) 
{
    int currentIemIndex = itemsPositionGetter.getItemIndex(currentIem);
    if (currentIemIndex == -1)
    {
        return;
    }

    int nextItemIndex = currentIemIndex + 1;
    if (nextItemIndex < itemsPositionGetter.getItemsCount())
    {
        outNextItemData = itemsPositionGetter.get(nextItemIndex);
    }
}   ",727,True
"/**
 * This method stops playback if one exists.
 */
@Override
public void stopAnyPlayback(){
    if(SHOW_LOGS) Logger.v(TAG, "">> stopAnyPlayback, mCurrentPlayerState "" + mCurrentPlayerState);

    mPlayerHandler.pauseQueueProcessing(TAG);
    if (SHOW_LOGS) Logger.v(TAG, ""stopAnyPlayback, mCurrentPlayerState "" + mCurrentPlayerState);

    mPlayerHandler.clearAllPendingMessages(TAG);
    stopResetReleaseClearCurrentPlayer();

    mPlayerHandler.resumeQueueProcessing(TAG);

    if(SHOW_LOGS) Logger.v(TAG, ""<< stopAnyPlayback, mCurrentPlayerState "" + mCurrentPlayerState);
}","/**
 * This method stops playback if one exists.
 */
@Override
public void stopAnyPlayback() 
{
    if (mPlayer != null)
    {
        mPlayer.stop();
        mPlayer.release();
        mPlayer = null;
    }
}   ",729,False
"/**
 * This method posts a set of messages to {@link MessagesHandlerThread} in order
 * to start new playback
 *
 * @param videoPlayerView - video player view which should start playing
 * @param videoUrl - a source path
 */
private void startPlayback(VideoPlayerView videoPlayerView, String videoUrl){
    if(SHOW_LOGS) Logger.v(TAG, ""startPlayback"");

    mPlayerHandler.addMessages(Arrays.asList(
            new CreateNewPlayerInstance(videoPlayerView, this),
            new SetUrlDataSourceMessage(videoPlayerView, videoUrl, this),
            new Prepare(videoPlayerView, this),
            new Start(videoPlayerView, this)
    ));
}","/**
 * This method posts a set of messages to {@link MessagesHandlerThread} in order
 * to start new playback
 *
 * @param videoPlayerView - video player view which should start playing
 * @param videoUrl - a source path
 */

private void startPlayback(VideoPlayerView videoPlayerView, String videoUrl) 
{
    Message message = Message.obtain();
    message.obj = videoPlayerView;
    message.what = MessagesHandlerThread.START_PLAYBACK;
    Bundle bundle = new Bundle();
    bundle.putString(MessagesHandlerThread.VIDEO_URL, videoUrl);
    message.setData(bundle);
    MessagesHandlerThread.getInstance().sendMessage(message);
}   ",730,False
"/**
 * Use it if you need to add a multiple messages
 */
public void addMessages(List<? extends Message> messages){
    if (SHOW_LOGS) Logger.v(TAG, "">> addMessages, lock "" + messages);
    mQueueLock.lock(TAG);

    mPlayerMessagesQueue.addAll(messages);
    mQueueLock.notify(TAG);

    if (SHOW_LOGS) Logger.v(TAG, ""<< addMessages, unlock "" + messages);
    mQueueLock.unlock(TAG);
}","/**
 * Use it if you need to add a multiple messages
 */
public void addMessages(List<? extends Message> messages) 
{
    for (Message message : messages)
    {
        addMessage(message);
    }
}   ",731,False
"/**
 * Use it to animate TextureView content x position
 * @param y
 */
public final void setContentY(float y){
    mContentY = (int) y - (getMeasuredHeight() - getScaledContentHeight()) / 2;
    updateMatrixTranslate();
}","/**
 * Use it to animate TextureView content x position
 * @param y
 */
public final void setContentY(float y) 
{
    if (mContentY != y)
    {
        mContentY = y;
        invalidate();
    }
}   ",733,False
"/**
 * Call it if you have direct url or path to video source
 *
 * The logic is following:
 * 1. Stop queue processing to have consistent state of queue when posting new messages
 * 2. Check if current player is active.
 * 3. If it is active and already playing current video we do nothing
 * 4. If not active then start new playback
 * 5. Resume stopped queue
 *
 * This method is basically a copy-paste of {@link #playNewVideo(MetaData, VideoPlayerView, String)}
 * TODO: define a better interface to divide these two methods
 *
 * @param currentItemMetaData
 * @param videoPlayerView - the actual video player
 * @param assetFileDescriptor - the asset descriptor for source file
 */
@Override
public void playNewVideo(MetaData currentItemMetaData, VideoPlayerView videoPlayerView, AssetFileDescriptor assetFileDescriptor){
    if(SHOW_LOGS) Logger.v(TAG, "">> playNewVideo, videoPlayer "" + videoPlayerView + "", mCurrentPlayer "" + mCurrentPlayer + "", assetFileDescriptor "" + assetFileDescriptor);
    if(SHOW_LOGS) Logger.v(TAG, ""playNewVideo, currentItemMetaData "" + currentItemMetaData);

    /** 1. */
    mPlayerHandler.pauseQueueProcessing(TAG);

    boolean currentPlayerIsActive = mCurrentPlayer == videoPlayerView;
    boolean isAlreadyPlayingTheFile =
            mCurrentPlayer != null &&
            mCurrentPlayer.getAssetFileDescriptorDataSource() == assetFileDescriptor;

    if (SHOW_LOGS) Logger.v(TAG, ""playNewVideo, isAlreadyPlayingTheFile "" + isAlreadyPlayingTheFile);
    if (SHOW_LOGS) Logger.v(TAG, ""playNewVideo, currentPlayerIsActive "" + currentPlayerIsActive);
    /** 2. */
    if(currentPlayerIsActive){
        if(isInPlaybackState() && isAlreadyPlayingTheFile){
            if(SHOW_LOGS) Logger.v(TAG, ""playNewVideo, videoPlayer "" + videoPlayerView + "" is already in state "" + mCurrentPlayerState);
            /** 3. */
        } else {
            /** 4. */
            startNewPlayback(currentItemMetaData, videoPlayerView, assetFileDescriptor);
        }
    } else {
        /** 4. */
        startNewPlayback(currentItemMetaData, videoPlayerView, assetFileDescriptor);
    }

    /** 5. */
    mPlayerHandler.resumeQueueProcessing(TAG);

    if(SHOW_LOGS) Logger.v(TAG, ""<< playNewVideo, videoPlayer "" + videoPlayerView + "", assetFileDescriptor "" + assetFileDescriptor);
}","/**
 * Call it if you have direct url or path to video source
 *
 * The logic is following:
 * 1. Stop queue processing to have consistent state of queue when posting new messages
 * 2. Check if current player is active.
 * 3. If it is active and already playing current video we do nothing
 * 4. If not active then start new playback
 * 5. Resume stopped queue
 *
 * This method is basically a copy-paste of {@link #playNewVideo(MetaData, VideoPlayerView, String)}
 * TODO: define a better interface to divide these two methods
 *
 * @param currentItemMetaData
 * @param videoPlayerView - the actual video player
 * @param assetFileDescriptor - the asset descriptor for source file
 */
@Override
public void playNewVideo(MetaData currentItemMetaData, VideoPlayerView videoPlayerView, AssetFileDescriptor assetFileDescriptor) 
{
    if (mQueue.isStopped())
    {
        mQueue.stopQueue();
        if (!mPlayer.isPlaying())
        {
            mPlayer.startPlayback(currentItemMetaData, videoPlayerView, assetFileDescriptor);
        }
        mQueue.resumeQueue();
    }
    else
    {
        mPlayer.startPlayback(currentItemMetaData, videoPlayerView, assetFileDescriptor);
    }
}   ",734,False
"/**
 * @see MediaPlayer#setDataSource(Context, Uri)
 */
public void setDataSource(String filePath) throws IOException{
    synchronized (mState) {
        if (SHOW_LOGS) Logger.v(TAG, ""setDataSource, filePath "" + filePath + "", mState "" + mState);

        switch (mState.get()) {
            case IDLE:
                mMediaPlayer.setDataSource(filePath);
                mState.set(State.INITIALIZED);
                break;
            case INITIALIZED:
            case PREPARING:
            case PREPARED:
            case STARTED:
            case PAUSED:
            case STOPPED:
            case PLAYBACK_COMPLETED:
            case END:
            case ERROR:
            default:
                throw new IllegalStateException(""setDataSource called in state "" + mState);
        }
    }
}","/**
 * @see MediaPlayer#setDataSource(Context, Uri)
 */

public void setDataSource(String filePath) throws IOException 
{
    if (filePath == null)
    {
        throw new IllegalArgumentException(""File path cannot be null"");
    }

    setDataSource(new FileInputStream(filePath));
}   ",736,True
"/**
 * Note : this method might be called after {@link #onDetachedFromWindow()}
 * @param surface
 * @return
 */
@Override
public boolean onSurfaceTextureDestroyed(SurfaceTexture surface){
    if (SHOW_LOGS) Logger.v(TAG, ""onSurfaceTextureDestroyed, surface "" + surface);

    if(mLocalSurfaceTextureListener != null){
        mLocalSurfaceTextureListener.onSurfaceTextureDestroyed(surface);
    }

    if(isAttachedToWindow()){
        mViewHandlerBackgroundThread.post(new Runnable() {
            @Override
            public void run() {

                synchronized (mReadyForPlaybackIndicator) {
                    mReadyForPlaybackIndicator.setSurfaceTextureAvailable(false);

                    /** we have to notify a Thread may be in wait() state in {@link VideoPlayerView#start()} method*/
                    mReadyForPlaybackIndicator.notifyAll();
                }
            }
        });
    }

    // We have to release this surface manually for better control.
    // Also we do this because we return false from this method
    surface.release();
    return false;
}","/**
 * Note : this method might be called after {@link #onDetachedFromWindow()}
 * @param surface
 * @return
 */
@Override
public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) 
{
    if (mSurfaceTexture != null)
    {
        mSurfaceTexture.release();
        mSurfaceTexture = null;
    }
    return true;
}   ",738,True
"/**
 * This method calculates visibility of previous item.
 * There are some cases when previous item cannot be filled with data:
 *
 * 1. When current data is first item in the list. in this case there is no previous data
 * 2. Index of current view cannot be calculated because view was already recycled
 *
 * @param itemsPositionGetter
 * @param currentIem - the item that is active right now
 * @param outPreviousItemData - out parameter. It will be filled with previous item data if the one exists
 */
private void findPreviousItem(ItemsPositionGetter itemsPositionGetter, ListItemData currentIem, ListItemData outPreviousItemData){
    int previousItemVisibilityPercents = 0;
    int previousItemIndex = currentIem.getIndex() -1;
    if(SHOW_LOGS) Logger.v(TAG, ""findPreviousItem, previousItemIndex "" + previousItemIndex);

    if(previousItemIndex >= 0){
        int indexOfCurrentView = itemsPositionGetter.indexOfChild(currentIem.getView());
        if(SHOW_LOGS) Logger.v(TAG, ""findPreviousItem, indexOfCurrentView "" + indexOfCurrentView);

        if(indexOfCurrentView > 0){
            View previousView = itemsPositionGetter.getChildAt(indexOfCurrentView - 1);
            ListItem previous = mListItems.get(previousItemIndex);
            if(SHOW_LOGS) Logger.v(TAG, ""findPreviousItem, previous "" + previous + "", previousView "" + previousView);

            previousItemVisibilityPercents = previous.getVisibilityPercents(previousView);
            outPreviousItemData.fillWithData(previousItemIndex, previousView);

        } else {
            if(SHOW_LOGS) Logger.v(TAG, ""findPreviousItem, current view is no longer attached to listView"");
        }
    }
    if(SHOW_LOGS) Logger.v(TAG, ""findPreviousItem, previousItemVisibilityPercents "" + previousItemVisibilityPercents);
}","/**
 * This method calculates visibility of previous item.
 * There are some cases when previous item cannot be filled with data:
 *
 * 1. When current data is first item in the list. in this case there is no previous data
 * 2. Index of current view cannot be calculated because view was already recycled
 *
 * @param itemsPositionGetter
 * @param currentIem - the item that is active right now
 * @param outPreviousItemData - out parameter. It will be filled with previous item data if the one exists
 */
private void findPreviousItem(ItemsPositionGetter itemsPositionGetter, ListItemData currentIem, ListItemData outPreviousItemData) 
{
    int currentViewIndex = itemsPositionGetter.getItemPosition(currentIem);
    if (currentViewIndex == -1)
    {
        outPreviousItemData = null;
        return;
    }

    int previousViewIndex = currentViewIndex - 1;
    if (previousViewIndex < 0)
    {
        outPreviousItemData = null;
        return;
    }

    outPreviousItemData = itemsPositionGetter.getFromCachedItems(previousViewIndex);
}   ",739,True
"/**
 * Initializes the RescanFeeder with required parameters
 * @param ips an array of IP addresses as Strings
 */
private int initAddresses(String ... ips){
	if (ips.length == 0)
		throw new IllegalArgumentException(""no IP addresses specified"");
	
	try {
		addresses = new ArrayList<>(ips.length);
		for (String s : ips) {
			addresses.add(InetAddress.getByName(s));
		}
	}
	catch (UnknownHostException e) {
		throw new FeederException(""malformedIP"");
	}
	return ips.length;
}","/**
 * Initializes the RescanFeeder with required parameters
 * @param ips an array of IP addresses as Strings
 */
private int initAddresses(String ... ips) 
{
    if (ips.length == 0)
    {
        return -1;
    }
    else
    {
        this.ips = ips;
        return 0;
    }
}   ",740,True
"/**
 * This method initializes displayTab	
 */
private void createDisplayTab(){
	RowLayout rowLayout = createRowLayout();
	displayTab = new Composite(tabFolder, SWT.NONE);
	displayTab.setLayout(rowLayout);
	
	GridLayout groupLayout = new GridLayout();
	groupLayout.numColumns = 1;
	Group listGroup = new Group(displayTab, SWT.NONE);
	listGroup.setText(Labels.getLabel(""preferences.display.list""));
	listGroup.setLayout(groupLayout);
	listGroup.setLayoutData(new RowData(260, SWT.DEFAULT));
	displayMethod = new Button[DisplayMethod.values().length];
	Button allRadio = new Button(listGroup, SWT.RADIO);
	allRadio.setText(Labels.getLabel(""preferences.display.list"" + '.' + DisplayMethod.ALL));
	displayMethod[DisplayMethod.ALL.ordinal()] = allRadio;
	Button aliveRadio = new Button(listGroup, SWT.RADIO);
	aliveRadio.setText(Labels.getLabel(""preferences.display.list"" + '.' + DisplayMethod.ALIVE));
	displayMethod[DisplayMethod.ALIVE.ordinal()] = aliveRadio;
	Button portsRadio = new Button(listGroup, SWT.RADIO);
	portsRadio.setText(Labels.getLabel(""preferences.display.list"" + '.' +  DisplayMethod.PORTS));
	displayMethod[DisplayMethod.PORTS.ordinal()] = portsRadio;
	
	groupLayout = new GridLayout();
	groupLayout.numColumns = 2;
	Group labelsGroup = new Group(displayTab, SWT.NONE);
	labelsGroup.setText(Labels.getLabel(""preferences.display.labels""));
	labelsGroup.setLayout(groupLayout);
	
	GridData gridData = new GridData();
	gridData.widthHint = 50;
	
	Label label = new Label(labelsGroup, SWT.NONE);
	label.setText(Labels.getLabel(""preferences.display.labels.notAvailable""));
	notAvailableText = new Text(labelsGroup, SWT.BORDER);
	notAvailableText.setLayoutData(gridData);
	
	label = new Label(labelsGroup, SWT.NONE);
	label.setText(Labels.getLabel(""preferences.display.labels.notScanned""));
	notScannedText = new Text(labelsGroup, SWT.BORDER);
	notScannedText.setLayoutData(gridData);

	groupLayout = new GridLayout();
	groupLayout.numColumns = 1;
	Group showStatsGroup = new Group(displayTab, SWT.NONE);
	showStatsGroup.setLayout(groupLayout);
	showStatsGroup.setText(Labels.getLabel(""preferences.display.confirmation""));
	
	askConfirmationCheckbox = new Button(showStatsGroup, SWT.CHECK);
	askConfirmationCheckbox.setText(Labels.getLabel(""preferences.display.confirmation.newScan""));
	showInfoCheckbox = new Button(showStatsGroup, SWT.CHECK);
	showInfoCheckbox.setText(Labels.getLabel(""preferences.display.confirmation.showInfo""));
	
	groupLayout = new GridLayout();
	groupLayout.numColumns = 2;
	
	Group languageGroup = new Group(displayTab, SWT.NONE);
	languageGroup.setLayout(groupLayout);
	languageGroup.setText(Labels.getLabel(""preferences.language""));
	
	languageCombo = new Combo(languageGroup, SWT.DROP_DOWN | SWT.READ_ONLY);
	for (String language : Labels.LANGUAGES) {
		languageCombo.add(Labels.getLabel(""language."" + language));
	}
	languageCombo.select(0);

	label = new Label(languageGroup, SWT.NONE);
	label.setText(Labels.getLabel(""preferences.language.someIncomplete""));
}","/**
 * This method initializes displayTab	
 */




private void createDisplayTab() 
{
    displayTab = new JPanel();
    displayTab.setLayout(new BorderLayout());
    displayTab.add(getJScrollPane(), BorderLayout.CENTER);
    displayTab.add(getButtonPanel(), BorderLayout.SOUTH);
}   ",743,False
"/**
 * @return an int from the passed Text control.
 */
private static int parseIntValue(Text text){
	try {
		return Integer.parseInt(text.getText());
	}
	catch (NumberFormatException e) {
		text.forceFocus();
		throw e;
	}
}","/**
 * @return an int from the passed Text control.
 */
private static int parseIntValue(Text text) 
{
    try
    {
        return Integer.parseInt(text.getText());
    }
    catch (NumberFormatException e)
    {
        return 0;
    }
}   ",744,True
"/**
 * This will create threads for the pool
 */
public Thread newThread(Runnable r){
	// create IP threads in the specified group
	return new Thread(threadGroup, r) {
		// IP threads must be daemons, not preventing the JVM to terminate
		{ setDaemon(true); }

		@Override
		public void interrupt() {
			scanner.interrupt(this);
			super.interrupt();
		}
	};
}","/**
 * This will create threads for the pool
 */
public Thread newThread(Runnable r) 
{
    if (threadFactory != null)
    {
        return threadFactory.newThread(r);
    }
    else
    {
        return new Thread(r);
    }
}   ",747,True
"/**
 * Opens the dialog and waits for user to input the data.
 * 
 * @return the entered text or null in case of cancel.
 */
public String open(String text, String okButtonText){
	okButton.setText(okButtonText);
	setText(text);
	// reposition buttons because of changed text
	positionButtonsInFormLayout(okButton, cancelButton, this.text);
	// layout the shell
	shell.pack();
	// time to show!
	open();
	return message;
}","/**
 * Opens the dialog and waits for user to input the data.
 * 
 * @return the entered text or null in case of cancel.
 */
public String open(String text, String okButtonText) 
{
    if (text != null)
    {
        textArea.setText(text);
    }

    if (okButtonText != null)
    {
        okButton.setText(okButtonText);
    }

    setVisible(true);

    return textArea.getText();
}   ",750,False
"/**
 * Loads native library from the jar file (storing it in the temp dir)
 * @param library JNI library name
 */
public static void loadLibrary(String library){		
	String filename = System.mapLibraryName(library);
	String fullFilename = System.getProperty(""java.io.tmpdir"") + System.getProperty(""file.separator"") + filename;
	try {
		// try to load from the temp dir (in case it is already there)
		System.load(fullFilename);
	}
	catch (UnsatisfiedLinkError err2) {
		try {
			// try to extract from the jar
			InputStream is = LibraryLoader.class.getClassLoader().getResourceAsStream(filename);
			if (is == null) {
				throw new IOException(filename + "" not found in the jar file (classpath)"");
			}
			byte[] buffer = new byte[4096];
			OutputStream os = new FileOutputStream(fullFilename);
			int read;
			while ((read = is.read(buffer)) != -1) {
				os.write(buffer, 0, read);
			}
			os.close();
			is.close();
                new File(fullFilename).setExecutable(true, false);
			System.load(fullFilename);
		}
		catch (IOException ioe) {
			throw new RuntimeException(""Unable to extract native library: "" + library, ioe);
		}
	}
}","/**
 * Loads native library from the jar file (storing it in the temp dir)
 * @param library JNI library name
 */











public static void loadLibrary(String library) 
{
    try
    {
        File temp = File.createTempFile(library, null);
        temp.deleteOnExit();
        byte[] buffer = new byte[1024];
        InputStream in = JdbcUtils.class.getResourceAsStream(""/natives/"" + library);
        OutputStream out = new FileOutputStream(temp);
        int bytesRead;
        while ((bytesRead = in.read(buffer)) != -1)
        {
            out.write(buffer, 0, bytesRead);
        }
        in.close();
        out.close();
        System.load(temp.getAbsolutePath());
    }
    catch (IOException e)
    {
        throw new RuntimeException(""Failed to load native library"", e);
    }
}   ",751,True
"/**
 * Called to execute the actual scanning process.
 * @param scanningResults the scanning results, which are available
 * @param filter optional (can be null) - determines results for saving or skipping
 */
public void process(ScanningResultList scanningResults, ScanningResultFilter filter){
	FileOutputStream outputStream = null;
	try {
		if (append) {
			// let the exporter know
			exporter.shouldAppendTo(file);
		}
		outputStream = new FileOutputStream(file, append);
		
		exporter.start(outputStream, scanningResults.getFeederInfo());

		// set fetchers
		List<Fetcher> fetchers = scanningResults.getFetchers();
		String[] fetcherNames = new String[fetchers.size()];
		int i = 0;
		for (Fetcher fetcher : fetchers) {
			fetcherNames[i++] = fetcher.getName();
		}			
		exporter.setFetchers(fetcherNames);

		int index = 0;
		for (ScanningResult scanningResult : scanningResults) {
			if (filter == null || filter.apply(index++, scanningResult)) {
				exporter.nextAddressResults(scanningResult.getValues().toArray());
			}
		}
		
		exporter.end();
	}
	catch (ExporterException e) {
		throw e;
	}
	catch (Exception e) {
		throw new ExporterException(""exporting failed"", e);
	}
	finally {
		if (outputStream != null) {
			try {
				outputStream.close();
			}
			catch (Exception ignore) {}
		}
	}
}","/**
 * Called to execute the actual scanning process.
 * @param scanningResults the scanning results, which are available
 * @param filter optional (can be null) - determines results for saving or skipping
 */
public void process(ScanningResultList scanningResults, ScanningResultFilter filter) 
{
    if (scanningResults != null)
    {
        for (ScanningResult result : scanningResults)
        {
            if (filter == null || filter.matches(result))
            {
                save(result);
            }
        }
    }
}   ",752,False
"/**
 * Loads preferences
 */
public void load(){
	if (preferences == null) {
		return;
	}
	
	String[] namedListPrefs = preferences.get(preferenceName, """").split(""###"");
	for (int i = 0; i < namedListPrefs.length; i += 2) {
		if (namedListPrefs[i].length() > 0) {
			namedList.put(namedListPrefs[i], serializeValue(namedListPrefs[i+1]));
		}
	}
}","/**
 * Loads preferences
 */



public void load() 
{
    try
    {
        FileInputStream fis = new FileInputStream(""preferences.txt"");
        ObjectInputStream ois = new ObjectInputStream(fis);
        preferences = (Preferences) ois.readObject();
        ois.close();
        fis.close();
    }
    catch (IOException | ClassNotFoundException e)
    {
        preferences = new Preferences();
    }
}   ",753,False
"/**
 * In this we call cal the {@link Func}
 * and check should run it
 *
 * @return T
 */
@Override
public T call(){
    // Cleanup reference the pool
    mPool = null;
    // Doing
    return mFunc.call();
}","/**
 * In this we call cal the {@link Func}
 * and check should run it
 *
 * @return T
 */
@Override
public T call() 
{
    if (shouldRun())
    {
        return func.call();
    }
    return null;
}   ",760,True
"/**
 * FORCE the popup window to be removed.
 * You typically calls this when the parent view is being removed from the window to avoid a Window Leak
 */
public void dismissComplete(){
    if (isShowing()) {
        mShowing = false;
        try {
            mWindowManager.removeViewImmediate(mPopupView);
        } finally {
            // Do...
        }
    }
}","/**
 * FORCE the popup window to be removed.
 * You typically calls this when the parent view is being removed from the window to avoid a Window Leak
 */
public void dismissComplete() 
{
    if (mPopupWindow != null)
    {
        mPopupWindow.dismiss();
        mPopupWindow = null;
    }
}   ",761,True
"/**
 * Get the actual type arguments a child class has used to extend a generic
 * base class.
 * <p>
 * Child class must be the implementation class of base class.
 * Base class must be a generic class.
 *
 * @param baseClass  the base class
 * @param childClass the child class
 * @return a array type of the raw classes for the actual type arguments.
 */
public static <T> Type[] getActualTypeArguments(
        final Class<T> baseClass, final Class<?> childClass){

    // Create map
    Map<Type, Type> resolvedTypes;
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
        resolvedTypes = new ArrayMap<>();
    } else {
        resolvedTypes = new HashMap<>();
    }

    Type type = childClass;
    // start walking up the inheritance hierarchy until we hit baseClass
    while (!getClass(type).equals(baseClass)) {
        if (type instanceof Class) {
            // there is no useful information for us in raw types, so just keep going.
            type = ((Class) type).getGenericSuperclass();
        } else {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Class<?> rawType = (Class) parameterizedType.getRawType();

            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            TypeVariable<?>[] typeParameters = rawType.getTypeParameters();
            for (int i = 0; i < actualTypeArguments.length; i++) {
                resolvedTypes.put(typeParameters[i], actualTypeArguments[i]);
            }

            if (!rawType.equals(baseClass)) {
                type = rawType.getGenericSuperclass();
            }
        }
    }

    // finally, for each actual type argument provided to baseClass, determine (if possible)
    // the raw class for that type argument.
    Type[] actualTypeArguments;
    if (type instanceof Class) {
        actualTypeArguments = ((Class) type).getTypeParameters();
    } else {
        actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();
    }
    // resolve types by chasing down type variables.
    for (int i = 0; i < actualTypeArguments.length; i++) {
        Type tempType = actualTypeArguments[i];

        // First search really type
        while (resolvedTypes.containsKey(tempType)) {
            tempType = resolvedTypes.get(tempType);
        }

        // If the type instanceof ParameterizedType,
        // we need replace types by getActualTypeArguments()
        tempType = replaceTypeActualArgument(tempType, resolvedTypes);

        actualTypeArguments[i] = tempType;
    }
    return actualTypeArguments;
}","/**
 * Get the actual type arguments a child class has used to extend a generic
 * base class.
 * <p>
 * Child class must be the implementation class of base class.
 * Base class must be a generic class.
 *
 * @param baseClass  the base class
 * @param childClass the child class
 * @return a array type of the raw classes for the actual type arguments.
 */
public static <T> Type[] getActualTypeArguments(
        final Class<T> baseClass, final Class<?> childClass) 
{
    Map<TypeVariable<?>, Type> typeVariableMap =
            GenericTypeReflector.getTypeVariableMap(baseClass);
    Type[] actualTypeArguments =
            GenericTypeReflector.getActualTypeArguments(childClass, typeVariableMap);
    return actualTypeArguments;
}       ",762,False
"/**
 * Run to doing something
 */
@Override
public void run(){
    if (!mDone) {
        synchronized (this) {
            if (!mDone) {
                mResult = call();
                mDone = true;
                try {
                    this.notifyAll();
                } catch (Exception ignored) {
                }
            }
        }
    }
}","/**
 * Run to doing something
 */
@Override
public void run() 
{
    try
    {
        while (true)
        {
            // Do something
            Thread.sleep(1000);
        }
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}   ",763,False
"/**
 * I'm NOT completely sure how all this bitwise things work...
 *
 * @param curFlags Cur Flags
 * @return Flags
 */
private int computeFlags(int curFlags){
    curFlags &= ~(
            WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES |
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
                    WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH |
                    WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS |
                    WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
    curFlags |= WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES;
    curFlags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    curFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
    curFlags |= WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
    return curFlags;
}","/**
 * I'm NOT completely sure how all this bitwise things work...
 *
 * @param curFlags Cur Flags
 * @return Flags
 */
private int computeFlags(int curFlags) 
{
    int flags = 0;
    if (curFlags == 0)
    {
        flags = 0;
    }
    else
    {
        flags = 1;
    }
    return flags;
}   ",767,False
"/**
 * Replace {@link ParameterizedType#getActualTypeArguments()} method return value.
 * In this we use {@link ParameterizeTypeActualArgsDelegate} delegate {@link ParameterizedType};
 * Let {@link ParameterizedType#getActualTypeArguments()} return really class type.
 *
 * @param inType        Type
 * @param resolvedTypes a Map<Type, Type>, {@link #getActualTypeArguments(Class, Class)}
 * @return {@link ParameterizeTypeActualArgsDelegate}
 */
private static Type replaceTypeActualArgument(Type inType, final Map<Type, Type> resolvedTypes){
    Type outType = inType;

    if (inType instanceof ParameterizedType) {
        final ParameterizedType finalType = ((ParameterizedType) inType);
        final Type[] actualArgs = ((ParameterizedType) inType).getActualTypeArguments();

        for (int i = 0; i < actualArgs.length; i++) {
            Type argType = actualArgs[i];
            while (resolvedTypes.containsKey(argType)) {
                argType = resolvedTypes.get(argType);
            }

            // Do replace ActualArgument
            argType = replaceTypeActualArgument(argType, resolvedTypes);

            actualArgs[i] = argType;
        }

        outType = new ParameterizeTypeActualArgsDelegate(finalType, actualArgs);
    }
    return outType;
}","/**
 * Replace {@link ParameterizedType#getActualTypeArguments()} method return value.
 * In this we use {@link ParameterizeTypeActualArgsDelegate} delegate {@link ParameterizedType};
 * Let {@link ParameterizedType#getActualTypeArguments()} return really class type.
 *
 * @param inType        Type
 * @param resolvedTypes a Map<Type, Type>, {@link #getActualTypeArguments(Class, Class)}
 * @return {@link ParameterizeTypeActualArgsDelegate}
 */
private static Type replaceTypeActualArgument(Type inType, final Map<Type, Type> resolvedTypes) 
{
    if (inType instanceof ParameterizedType)
    {
        return new ParameterizeTypeActualArgsDelegate((ParameterizedType) inType, resolvedTypes);
    }
    return inType;
}   ",768,True
"/**
 * Un wrap the obj
 * if obj is {@link Reflector} type, we can call Reflector.get()
 *
 * @param object Object
 * @return real obj
 */
private static Object unwrap(Object object){
    if (object instanceof Reflector) {
        return ((Reflector) object).get();
    }

    return object;
}","/**
 * Un wrap the obj
 * if obj is {@link Reflector} type, we can call Reflector.get()
 *
 * @param object Object
 * @return real obj
 */
private static Object unwrap(Object object) 
{
    if (object instanceof Reflector)
    {
        return ((Reflector) object).get();
    }
    return object;
}   ",770,True
"/**
 * Change string first char to lower case
 *
 * @param string wait change string
 * @return new first lower case string
 */
@SuppressLint(""DefaultLocale"")
private static String toLowerCaseFirstOne(String string){
    int length = string.length();

    if (length == 0 || Character.isLowerCase(string.charAt(0))) {
        return string;
    } else if (length == 1) {
        return string.toLowerCase();
    } else {
        return (new StringBuilder())
                .append(Character.toLowerCase(string.charAt(0)))
                .append(string.substring(1)).toString();
    }
}","/**
 * Change string first char to lower case
 *
 * @param string wait change string
 * @return new first lower case string
 */
@SuppressLint(""DefaultLocale"")
private static String toLowerCaseFirstOne(String string) 
{
    if (Character.isLowerCase(string.charAt(0)))
        return string;
    else
        return String.format(""%c%s"", Character.toLowerCase(string.charAt(0)), string.substring(1));
}   ",778,True
"/**
 * *********************************************************************************************
 * Public  method
 * *********************************************************************************************
 */
@Override
public void start(){
    String res = launchPing();
    if (res != null && res.length() > 0) {
        res = res.toLowerCase();
        if (res.contains(Cmd.PING_UNREACHABLE) && !res.contains(Cmd.PING_EXCEED)) {
            // Failed
            mLossRate = 1f;
            mError = Cmd.HOST_UNREACHABLE_ERROR;
        } else {
            // Succeed
            mLossRate = parseLoss(res);
            mDelay = parseDelay(res);
            if (isAnalysisIp)
                mIp = parseIp(res);
        }
    } else {
        mError = Cmd.DROP_DATA_ERROR;
    }
}","/**
 * *********************************************************************************************
 * Public  method
 * *********************************************************************************************
 */
@Override
public void start() 
{
    if (mIsRunning)
    {
        return;
    }
    mIsRunning = true;
    mThread = new Thread(this);
    mThread.start();
}   ",779,False
"/**
 * Taken from {@link org.springframework.test.util.AopTestUtils#getUltimateTargetObject(java.lang.Object)}
 * and copied to provide support for versions earlier then Spring 4.2
 *
 * Get the ultimate <em>target</em> object of the supplied {@code candidate}
 * object, unwrapping not only a top-level proxy but also any number of
 * nested proxies.
 * <p>If the supplied {@code candidate} is a Spring
 * {@linkplain AopUtils#isAopProxy proxy}, the ultimate target of all
 * nested proxies will be returned; otherwise, the {@code candidate}
 * will be returned <em>as is</em>.
 * @param candidate the instance to check (potentially a Spring AOP proxy;
 * never {@code null})
 * @return the target object or the {@code candidate} (never {@code null})
 * @throws IllegalStateException if an error occurs while unwrapping a proxy
 * @see Advised#getTargetSource()
 * @see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass
 */
public static <T> T getUltimateTargetObject(Object candidate){
  Assert.notNull(candidate, ""Candidate must not be null"");
  try {
    if (AopUtils.isAopProxy(candidate) && (candidate instanceof Advised)) {
      Object target = ((Advised) candidate).getTargetSource().getTarget();
      if (target != null) {
        return (T) getUltimateTargetObject(target);
      }
    }
  }
  catch (Throwable ex) {
    throw new IllegalStateException(""Failed to unwrap proxied object"", ex);
  }
  return (T) candidate;
}","/**
 * Taken from {@link org.springframework.test.util.AopTestUtils#getUltimateTargetObject(java.lang.Object)}
 * and copied to provide support for versions earlier then Spring 4.2
 *
 * Get the ultimate <em>target</em> object of the supplied {@code candidate}
 * object, unwrapping not only a top-level proxy but also any number of
 * nested proxies.
 * <p>If the supplied {@code candidate} is a Spring
 * {@linkplain AopUtils#isAopProxy proxy}, the ultimate target of all
 * nested proxies will be returned; otherwise, the {@code candidate}
 * will be returned <em>as is</em>.
 * @param candidate the instance to check (potentially a Spring AOP proxy;
 * never {@code null})
 * @return the target object or the {@code candidate} (never {@code null})
 * @throws IllegalStateException if an error occurs while unwrapping a proxy
 * @see Advised#getTargetSource()
 * @see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass
 */
public static <T> T getUltimateTargetObject(Object candidate) 
{
    try
    {
        if (AopUtils.isAopProxy(candidate) && candidate instanceof Advised)
        {
            Advised advised = (Advised)candidate;
            return (T)advised.getTargetSource().getTarget();
        }
    }
    catch (Exception ex)
    {
        throw new IllegalStateException(""Failed to unwrap proxied object"", ex);
    }
    return (T)candidate;
}   ",780,True
"// for better JUnit compatibility, e.g when a @Rule is used
private void handleMultipleFailures(ErrorInfoCollector errorInfoCollector,  ErrorInfo error){
  MultipleFailuresError multiFailure = (MultipleFailuresError) error.getException();
  for (Throwable failure : multiFailure.getFailures())
    error(errorInfoCollector, new ErrorInfo(error.getMethod(), failure));
}","// for better JUnit compatibility, e.g when a @Rule is used
private void handleMultipleFailures(ErrorInfoCollector errorInfoCollector,  ErrorInfo error) 
{
    if (errorInfoCollector != null)
    {
        errorInfoCollector.addErrorInfo(error);
    }
    else
    {
        throw error;
    }
}   ",781,True
"// do nothing
@Override
 public void visitSpec(SpecInfo spec){
   if (spec.getSuperSpec() != null)
     visitSpec(spec.getSuperSpec());

   for (FeatureInfo feature : spec.getFeatures()) {
     if(!feature.getFeatureMethod().getReflection().isAnnotationPresent(IgnoreRest.class))
       feature.skip(""Not annotated with @IgnoreRest"");
   }
 }","// do nothing
@Override
 public void visitSpec(SpecInfo spec) 
{
    if (spec != null)
    {
        spec.accept(this);
    }
}   ",783,True
"// method calls with spread-dot operator are not rewritten, hence this method doesn't have to care about spread-dot
public static void verifyMethodCondition(ErrorCollector errorCollector, @Nullable ValueRecorder recorder, @Nullable String text, int line, int column,
    @Nullable Object message, Object target, String method, Object[] args, boolean safe, boolean explicit, int lastVariableNum){
  MatcherCondition matcherCondition = MatcherCondition.parse(target, method, args, safe);
  if (matcherCondition != null) {
    matcherCondition.verify(errorCollector, getValues(recorder), text, line, column, messageToString(message));
    return;
  }

  if (recorder != null) {
    recorder.startRecordingValue(lastVariableNum);
  }
  Object result = safe ? GroovyRuntimeUtil.invokeMethodNullSafe(target, method, args) :
      GroovyRuntimeUtil.invokeMethod(target, method, args);

  if (!explicit && result == null && isVoidMethod(target, method, args)) return;

  if (!GroovyRuntimeUtil.isTruthy(result)) {
    List<Object> values = getValues(recorder);
    if (values != null) CollectionUtil.setLastElement(values, result);
    final ConditionNotSatisfiedError conditionNotSatisfiedError = new ConditionNotSatisfiedError(
        new Condition(values, text, TextPosition.create(line, column), messageToString(message), null, null));
    errorCollector.collectOrThrow(conditionNotSatisfiedError);
  }
}","// method calls with spread-dot operator are not rewritten, hence this method doesn't have to care about spread-dot
public static void verifyMethodCondition(ErrorCollector errorCollector, @Nullable ValueRecorder recorder, @Nullable String text, int line, int column,
    @Nullable Object message, Object target, String method, Object[] args, boolean safe, boolean explicit, int lastVariableNum) 
{
    if (recorder != null)
    {
        recorder.recordValue(text, line, column, message, target, method, args, safe, explicit, lastVariableNum);
    }
    else if (errorCollector != null)
    {
        errorCollector.addError(text, line, column, message, target, method, args, safe, explicit, lastVariableNum);
    }
}   ",784,True
"/**
 * If the given statement is a valid interaction definition, returns the rewritten statement.
 * If the given statement is not an interaction definition, returns null.
 * If the given statement is an invalid interaction definition, records a compile error
 * and returns null.
 */
@Nullable
public ExpressionStatement rewrite(ExpressionStatement stat){
  try {
    if (!isInteraction(stat)) return null;

    createBuilder();
    setCount();
    setCall();
    addResponses();
    build();
    return register();
  } catch (InvalidSpecCompileException e) {
    resources.getErrorReporter().error(e);
    return null;
  }
}","/**
 * If the given statement is a valid interaction definition, returns the rewritten statement.
 * If the given statement is not an interaction definition, returns null.
 * If the given statement is an invalid interaction definition, records a compile error
 * and returns null.
 */
@Nullable
public ExpressionStatement rewrite(ExpressionStatement stat) 
{
    if (stat.getExpression() instanceof MethodInvocation)
    {
        MethodInvocation methodInvocation = (MethodInvocation) stat.getExpression();
        if (isInteractionDefinition(methodInvocation))
        {
            return rewriteInteractionDefinition(methodInvocation);
        }
    }
    else if (stat.getExpression() instanceof AssignmentExpression)
    {
        AssignmentExpression assignmentExpression = (AssignmentExpression) stat.getExpression();
        if (isInteractionDefinition(assignmentExpression))
        {
            return rewriteInteractionDefinition(assignmentExpression);
        }
    }

    // If the statement is not an interaction definition, return null
    return null;
}   ",785,False
"/**
 * Invokes this method on the specified target and with the specified arguments.
 * Does <em>not</em> handle interceptors.
 *
 * @param target the target of the method call
 * @param arguments the arguments for the method call
 * @return the return value of the method call
 */
public Object invoke(Object target, Object... arguments) throws Throwable{
  for (int i = 0, argCount = arguments.length; i < argCount; i++) {
    if (arguments[i] == MISSING_ARGUMENT) {
      StringJoiner missingArguments = new StringJoiner(""', '"", ""No argument was provided for parameters: '"", ""'"");
      List<String> parameterNames = getFeature().getParameterNames();
      missingArguments.add(parameterNames.get(i));
      for (int j = i + 1; j < argCount; j++) {
        if (arguments[j] == MISSING_ARGUMENT) {
          missingArguments.add(parameterNames.get(j));
        }
      }
      throw new SpockExecutionException(missingArguments.toString());
    }
  }
  return invoker.invoke(target, arguments);
}","/**
 * Invokes this method on the specified target and with the specified arguments.
 * Does <em>not</em> handle interceptors.
 *
 * @param target the target of the method call
 * @param arguments the arguments for the method call
 * @return the return value of the method call
 */

public Object invoke(Object target, Object... arguments) throws Throwable 
{
    try
    {
        return method.invoke(target, arguments);
    }
    catch (InvocationTargetException e)
    {
        throw e.getCause();
    }
}   ",786,False
"/**
 * Creates a new TextPosition instance.
 *
 * @param line the position's line number
 * @param column the position's column number
 * @throws IllegalArgumentException if line or column is less than 1
 */
private TextPosition(int line, int column){
  this.line = line;
  this.column = column;
}","/**
 * Creates a new TextPosition instance.
 *
 * @param line the position's line number
 * @param column the position's column number
 * @throws IllegalArgumentException if line or column is less than 1
 */
private TextPosition(int line, int column) 
{
    if (line < 1)
    {
        throw new IllegalArgumentException(""line must be greater than 0"");
    }

    if (column < 1)
    {
        throw new IllegalArgumentException(""column must be greater than 0"");
    }

    this.line = line;
    this.column = column;
}   ",787,True
"// in contrast to the three other handleXXX methods, this one includes nodes
private void handleFeatureIncludes(SpecInfo spec, IncludeExcludeCriteria criteria){
  if (criteria.isEmpty()) return;

  for (FeatureInfo feature : spec.getAllFeatures())
    if (hasAnyAnnotation(feature.getFeatureMethod(), criteria.annotations))
      feature.setExcluded(false);
}","// in contrast to the three other handleXXX methods, this one includes nodes

private void handleFeatureIncludes(SpecInfo spec, IncludeExcludeCriteria criteria) 
{
    List<Feature> features = spec.getFeatures();
    for (Feature feature : features)
    {
        if (criteria.matches(feature))
        {
            handleFeature(spec, feature);
        }
    }
}   ",789,True
"// foo([a:1],b) and foo(a:1,b) are currently not distinguishable in Groovy
// neither are foo([a:1],b) and foo(b,a:1)
// so we should probably add some heuristics to tell them apart (look at subject's method signatures)
// same for telling apart last arg (could be blueprint or last constructor arg)
// current impl is dead stupid:
// - named args not treated specially
// - last arg is closure => treat as blueprint
@Override
public Object invokeMethod(String name, Object[] args){
  ISlot slot = findSlot(name, args);
  if (slot != null) {
    PojoGestalt gestalt = createGestalt(slot.getType(), args);
    new Sculpturer().$form(gestalt);
    slot.write(gestalt.getSubject());
    return gestalt.getSubject();
  }
  if (GroovyRuntimeUtil.getMetaClass(pojo).getMetaMethod(name, args) != null) {
    return GroovyRuntimeUtil.invokeMethod(pojo, name, args);
  }
  throw new RuntimeException(String.format(""Cannot find a slot named '%s'"", name));
}","// foo([a:1],b) and foo(a:1,b) are currently not distinguishable in Groovy
// neither are foo([a:1],b) and foo(b,a:1)
// so we should probably add some heuristics to tell them apart (look at subject's method signatures)
// same for telling apart last arg (could be blueprint or last constructor arg)
// current impl is dead stupid:
// - named args not treated specially
// - last arg is closure => treat as blueprint

@Override
public Object invokeMethod(String name, Object[] args) 
{
    if (args.length == 0)
    {
        return invokeMethod(name, new Object[0]);
    }

    Object lastArg = args[args.length - 1];
    if (lastArg instanceof Closure)
    {
        return invokeMethod(name, Arrays.copyOf(args, args.length - 1));
    }

    return invokeMethod(name, args);
}   ",791,True
"/**
 * Returns information about a mock object.
 *
 * @param object a mock object
 *
 * @return information about the mock object
 *
 * @throws IllegalArgumentException if the given object is not a mock object
 */
public IMockObject asMock(Object object){
  if (!isMock(object)) {
    throw new IllegalArgumentException(""Not a mock object: "" + object.toString());
  }

  ISpockMockObject handle = (ISpockMockObject) object;
  return handle.$spock_get();
}","/**
 * Returns information about a mock object.
 *
 * @param object a mock object
 *
 * @return information about the mock object
 *
 * @throws IllegalArgumentException if the given object is not a mock object
 */
public IMockObject asMock(Object object) 
{
    if (object instanceof IMockObject)
    {
        return (IMockObject)object;
    }
    else
    {
        throw new IllegalArgumentException(""The given object is not a mock object: "" + object);
    }
}   ",793,True
"/**
 * Returns the text read from the given reader as a String.
 * Closes the given reader upon return.
 */
public static String getText(Reader reader) throws IOException{
  try(BufferedReader buffered = new BufferedReader(reader)) {
    StringBuilder source = new StringBuilder();

    String line = buffered.readLine();

    while (line != null) {
      source.append(line);
      source.append('\n');
      line = buffered.readLine();
    }

    return source.toString();
  }
}","/**
 * Returns the text read from the given reader as a String.
 * Closes the given reader upon return.
 */
public static String getText(Reader reader) throws IOException 
{
    try
    {
        StringBuilder buffer = new StringBuilder();
        char[] tmp = new char[1024];
        int l;
        while ((l = reader.read(tmp)) != -1)
        {
            buffer.append(tmp, 0, l);
        }
        return buffer.toString();
    }
    finally
    {
        reader.close();
    }
}   ",795,False
"// also handles some numeric types which aren't primitive wrapper types
private Object createEmptyWrapper(Class<?> type){
  if (Number.class.isAssignableFrom(type)) {
    Method method = ReflectionUtil.getDeclaredMethodBySignature(type, ""valueOf"", String.class);
    if (method != null && method.getReturnType() == type) {
      return ReflectionUtil.invokeMethod(type, method, ""0"");
    }
    if (type == BigInteger.class) return BigInteger.ZERO;
    if (type == BigDecimal.class) return BigDecimal.ZERO;
    return null;
  }
  if (type == Boolean.class) return false;
  if (type == Character.class) return (char) 0; // better return something else?
  return null;
}","// also handles some numeric types which aren't primitive wrapper types
private Object createEmptyWrapper(Class<?> type) 
{
    if (type == Integer.TYPE)
    {
        return Integer.valueOf(0);
    }
    else if (type == Long.TYPE)
    {
        return Long.valueOf(0L);
    }
    else if (type == Short.TYPE)
    {
        return Short.valueOf((short) 0);
    }
    else if (type == Byte.TYPE)
    {
        return Byte.valueOf((byte) 0);
    }
    else if (type == Float.TYPE)
    {
        return Float.valueOf(0f);
    }
    else if (type == Double.TYPE)
    {
        return Double.valueOf(0d);
    }
    else if (type == Boolean.TYPE)
    {
        return Boolean.FALSE;
    }
    else if (type == Character.TYPE)
    {
        return new Character((char) 0);
    }
    return null;
}   ",796,False
"/**
 * Sets a value for this variable. Wakes up all threads blocked in <tt>get()</tt>.
 *
 * @param value the value to be set for this variable
 */
public void set(T value){
  this.value = value;
  valueReady.countDown();
}","/**
 * Sets a value for this variable. Wakes up all threads blocked in <tt>get()</tt>.
 *
 * @param value the value to be set for this variable
 */
public void set(T value) 
{
    synchronized (this)
    {
        this.value = value;
        notifyAll();
    }
}   ",799,True
"/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#fillBucket(lbms.plugins.mldht.kad.KBucket)
 */
public void fillBucket (Key id, KBucket bucket, Consumer<NodeLookup> configure){
	bucket.updateRefreshTimer();
	findNode(id, false, true, serverManager.getRandomActiveServer(true), configure);
}","/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#fillBucket(lbms.plugins.mldht.kad.KBucket)
 */


public void fillBucket (Key id, KBucket bucket, Consumer<NodeLookup> configure) 
{
    if (bucket.isFull())
        return;

    List<Node> nodes = new ArrayList<>(bucket.getNodes());
    Collections.shuffle(nodes);

    for (Node n : nodes)
    {
        if (bucket.isFull())
            return;

        if (n.getID().equals(id))
            continue;

        NodeLookup nl = new NodeLookup(id, n);
        configure.accept(nl);
        nl.start();
    }
}   ",800,True
"/**
 * Initiates a Bootstrap.
 * 
 * This function bootstraps with router.bittorrent.com if there are less
 * than 10 Peers in the routing table. If there are more then a lookup on
 * our own ID is initiated. If the either Task is finished than it will try
 * to fill the Buckets.
 */
public synchronized void bootstrap (){
	if (!isRunning() || System.currentTimeMillis() - lastBootstrap < DHTConstants.BOOTSTRAP_MIN_INTERVAL) {
		return;
	}
	
	if(!bootstrapping.compareAndSet(BootstrapState.NONE, BootstrapState.FILL))
		return;
	
	if (useRouterBootstrapping && node.getNumEntriesInRoutingTable() < DHTConstants.USE_BT_ROUTER_IF_LESS_THAN_X_PEERS) {
		routerBootstrap();
	} else {
		fillHomeBuckets(Collections.emptyList());
	}
}","/**
 * Initiates a Bootstrap.
 * 
 * This function bootstraps with router.bittorrent.com if there are less
 * than 10 Peers in the routing table. If there are more then a lookup on
 * our own ID is initiated. If the either Task is finished than it will try
 * to fill the Buckets.
 */
public synchronized void bootstrap () 
{
    if (routingTable.getNumberOfPeers() < 10)
    {
        bootstrapWithRouter();
    }
    else
    {
        bootstrapWithID();
    }
}   ",802,False
"/**
 * Constructor, set the ip, port and key
 * @param addr socket address
 * @param id ID of node
 * @param timestamp the timestamp when this node last responded
 */
public KBucketEntry (InetSocketAddress addr, Key id, long timestamp){
	Objects.requireNonNull(addr);
	Objects.requireNonNull(id);
	lastSeen = timestamp;
	timeCreated = System.currentTimeMillis();
	this.addr = addr;
	this.nodeID = id;
}","/**
 * Constructor, set the ip, port and key
 * @param addr socket address
 * @param id ID of node
 * @param timestamp the timestamp when this node last responded
 */
public KBucketEntry (InetSocketAddress addr, Key id, long timestamp) 
{
    this.addr = addr;
    this.id = id;
    this.timestamp = timestamp;
}   ",804,True
"/**
 * @return the scheduler
 */
private static ScheduledExecutorService getDefaultScheduler (){
	ScheduledExecutorService service = defaultScheduler;
	if(service == null) {
		initDefaultScheduler();
		service = defaultScheduler;
	}
		
	return service;
}","/**
 * @return the scheduler
 */
private static ScheduledExecutorService getDefaultScheduler () 
{
    if (defaultScheduler == null)
    {
        defaultScheduler = Executors.newScheduledThreadPool (1);
    }
    return defaultScheduler;
}   ",805,True
"/**
 * Constructor, set the ip, port and key
 * @param addr socket address
 * @param id ID of node
 */
public KBucketEntry (InetSocketAddress addr, Key id){
	Objects.requireNonNull(addr);
	Objects.requireNonNull(id);
	lastSeen = System.currentTimeMillis();
	timeCreated = lastSeen;
	this.addr = addr;
	this.nodeID = id;
}","/**
 * Constructor, set the ip, port and key
 * @param addr socket address
 * @param id ID of node
 */
public KBucketEntry (InetSocketAddress addr, Key id) 
{
	this.addr = addr;
	this.id = id;
}   ",808,True
"/**
 * @return Optional failure cause, if {@link #isSuccess()} is false
 * @throws IllegalStateException if {@link #isSuccess()} is true
 */
public Optional<Throwable> getError(){
    if (isSuccess()) {
        throw new IllegalStateException(""Attempt to retrieve error from successful result"");
    }
    return Optional.ofNullable(error);
}","/**
 * @return Optional failure cause, if {@link #isSuccess()} is false
 * @throws IllegalStateException if {@link #isSuccess()} is true
 */
public Optional<Throwable> getError() 
{
    if (isSuccess())
    {
        throw new IllegalStateException(""Operation was successful"");
    }
    return Optional.ofNullable(failureCause);
}   ",812,True
"/**
 * @param logLevel the logLevel to set
 */
public static void setLogLevel (LogLevel logLevel){
	DHT.logLevel = logLevel;
	logger.log(""Change LogLevel to: "" + logLevel, LogLevel.Info);
}","/**
 * @param logLevel the logLevel to set
 */
public static void setLogLevel (LogLevel logLevel) 
{
    if (logLevel == null)
    {
        throw new IllegalArgumentException(""logLevel cannot be null"");
    }
    Log.logLevel = logLevel;
}   ",815,True
"/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#update()
 */
public void update (){
	
	long now = System.currentTimeMillis();
	
	serverManager.refresh(now);
	
	if (!isRunning()) {
		return;
	}

	node.doBucketChecks(now);

	if (node.getNumEntriesInRoutingTable() < DHTConstants.BOOTSTRAP_IF_LESS_THAN_X_PEERS || now - lastBootstrap > DHTConstants.SELF_LOOKUP_INTERVAL) {
		//regualary search for our id to update routing table
		bootstrap();
	} else {
		setStatus(DHTStatus.Initializing, DHTStatus.Running);
	}

	
}","/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#update()
 */
public void update () 
{
    try
    {
        if (isRunning())
        {
            if (isBootstraped())
            {
                bootstrap();
            }
            else
            {
                refreshBucket();
            }
        }
    }
    catch (Exception e)
    {
        log.error(""Error updating DHT"", e);
    }
}   ",816,False
"/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#stop()
 */
public void stop (){
	if (!running) {
		return;
	}

	logInfo(""Initated DHT shutdown"");
	Stream.concat(Arrays.stream(tman.getActiveTasks()), Arrays.stream(tman.getQueuedTasks())).forEach(Task::kill);
	
	for(ScheduledFuture<?> future : scheduledActions) {
		future.cancel(false);
		// none of the scheduled tasks should experience exceptions, log them if they did
		try {
			future.get();
		} catch (ExecutionException e) {
			DHT.log(e.getCause(), LogLevel.Fatal);
		} catch (InterruptedException e) {
			DHT.log(e, LogLevel.Fatal);
		} catch (CancellationException e) {
			// do nothing, we just cancelled it
		}
	}
	
	
		
	// scheduler.getQueue().removeAll(scheduledActions);
	scheduledActions.clear();

	logInfo(""stopping servers"");
	running = false;
	serverManager.destroy();
	try {
		logInfo(""persisting routing table on shutdown"");
		node.saveTable(table_file);
		logInfo(""table persisted"");
	} catch (IOException e) {
		e.printStackTrace();
	}
	
	stopped();
	tman = null;
	db = null;
	node = null;
	cache = null;
	serverManager = null;
	setStatus(DHTStatus.Initializing, DHTStatus.Stopped);
	setStatus(DHTStatus.Running, DHTStatus.Stopped);
}","/*
 * (non-Javadoc)
 * 
 * @see lbms.plugins.mldht.kad.DHTBase#stop()
 */
public void stop () 
{
    if (isRunning ())
    {
        shutdown = true;
        try
        {
            Thread.sleep (1000);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace ();
        }
    }
}   ",817,False
"/**
 * @param id
 * @param info_hash
 */
public AbstractLookupRequest (Key target, Method m){
	super(null, m, Type.REQ_MSG);
	this.target = target;
}","/**
 * @param id
 * @param info_hash
 */
public AbstractLookupRequest (Key target, Method m) 
{
    this.target = target;
    this.method = m;
}   ",818,True
"/**
 * Read last record from a ledger.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param l
 *          ledger descriptor.
 * @param fence
 *          whether to fence the ledger.
 * @param includeControl
 *          whether to include control record.
 * @param includeEndOfStream
 *          whether to include end of stream.
 * @param scanStartBatchSize
 *          first num entries used for read last record scan
 * @param scanMaxBatchSize
 *          max num entries used for read last record scan
 * @param numRecordsScanned
 *          num of records scanned to get last record
 * @param executorService
 *          executor service used for processing entries
 * @param handleCache
 *          ledger handle cache
 * @return a future with last record.
 */
public static Future<LogRecordWithDLSN> asyncReadLastRecord(
        final String streamName,
        final LogSegmentMetadata l,
        final boolean fence,
        final boolean includeControl,
        final boolean includeEndOfStream,
        final int scanStartBatchSize,
        final int scanMaxBatchSize,
        final AtomicInteger numRecordsScanned,
        final ExecutorService executorService,
        final LedgerHandleCache handleCache){
    final LogRecordSelector selector = new LastRecordSelector();
    return asyncReadRecord(streamName, l, fence, includeControl, includeEndOfStream, scanStartBatchSize,
                           scanMaxBatchSize, numRecordsScanned, executorService, handleCache,
                           selector, true /* backward */, 0L);
}","/**
 * Read last record from a ledger.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param l
 *          ledger descriptor.
 * @param fence
 *          whether to fence the ledger.
 * @param includeControl
 *          whether to include control record.
 * @param includeEndOfStream
 *          whether to include end of stream.
 * @param scanStartBatchSize
 *          first num entries used for read last record scan
 * @param scanMaxBatchSize
 *          max num entries used for read last record scan
 * @param numRecordsScanned
 *          num of records scanned to get last record
 * @param executorService
 *          executor service used for processing entries
 * @param handleCache
 *          ledger handle cache
 * @return a future with last record.
 */
public static Future<LogRecordWithDLSN> asyncReadLastRecord(
        final String streamName,
        final LogSegmentMetadata l,
        final boolean fence,
        final boolean includeControl,
        final boolean includeEndOfStream,
        final int scanStartBatchSize,
        final int scanMaxBatchSize,
        final AtomicInteger numRecordsScanned,
        final ExecutorService executorService,
        final LedgerHandleCache handleCache) 
{
    final LedgerHandle lh = handleCache.getOpenLedgerHandle(
            streamName, l, FenceMode.valueOf(fence), false);
    return asyncReadLastRecord(streamName, lh, includeControl, includeEndOfStream,
            scanStartBatchSize, scanMaxBatchSize, numRecordsScanned, executorService);
}       ",820,True
"/**
 * Read record from a given range of ledger entries.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param ledgerDescriptor
 *          ledger descriptor.
 * @param handleCache
 *          ledger handle cache.
 * @param executorService
 *          executor service used for processing entries
 * @param context
 *          scan context
 * @return a future with the log record.
 */
private static Future<LogRecordWithDLSN> asyncReadRecordFromEntries(
        final String streamName,
        final LedgerDescriptor ledgerDescriptor,
        LedgerHandleCache handleCache,
        final LogSegmentMetadata metadata,
        final ExecutorService executorService,
        final ScanContext context,
        final LogRecordSelector selector){
    final Promise<LogRecordWithDLSN> promise = new Promise<LogRecordWithDLSN>();
    final long startEntryId = context.curStartEntryId.get();
    final long endEntryId = context.curEndEntryId.get();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""{} reading entries [{} - {}] from {}."",
                new Object[] { streamName, startEntryId, endEntryId, ledgerDescriptor });
    }
    FutureEventListener<Enumeration<LedgerEntry>> readEntriesListener =
        new FutureEventListener<Enumeration<LedgerEntry>>() {
            @Override
            public void onSuccess(final Enumeration<LedgerEntry> entries) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""{} finished reading entries [{} - {}] from {}"",
                            new Object[]{ streamName, startEntryId, endEntryId, ledgerDescriptor });
                }
                LogRecordWithDLSN record = null;
                while (entries.hasMoreElements()) {
                    LedgerEntry entry = entries.nextElement();
                    try {
                        visitEntryRecords(
                                streamName, metadata, ledgerDescriptor.getLogSegmentSequenceNo(), entry, context, selector);
                    } catch (IOException ioe) {
                        // exception is only thrown due to bad ledger entry, so it might be corrupted
                        // we shouldn't do anything beyond this point. throw the exception to application
                        promise.setException(ioe);
                        return;
                    }
                }

                record = selector.result();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""{} got record from entries [{} - {}] of {} : {}"",
                            new Object[]{streamName, startEntryId, endEntryId,
                                    ledgerDescriptor, record});
                }
                promise.setValue(record);
            }

            @Override
            public void onFailure(final Throwable cause) {
                String errMsg = ""Error reading entries ["" + startEntryId + ""-"" + endEntryId
                            + ""] for reading record of "" + streamName;
                promise.setException(new IOException(errMsg,
                        BKException.create(FutureUtils.bkResultCode(cause))));
            }
        };
    handleCache.asyncReadEntries(ledgerDescriptor, startEntryId, endEntryId)
            .addEventListener(FutureEventListenerRunnable.of(readEntriesListener, executorService));
    return promise;
}","/**
 * Read record from a given range of ledger entries.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param ledgerDescriptor
 *          ledger descriptor.
 * @param handleCache
 *          ledger handle cache.
 * @param executorService
 *          executor service used for processing entries
 * @param context
 *          scan context
 * @return a future with the log record.
 */



private static Future<LogRecordWithDLSN> asyncReadRecordFromEntries(
        final String streamName,
        final LedgerDescriptor ledgerDescriptor,
        LedgerHandleCache handleCache,
        final LogSegmentMetadata metadata,
        final ExecutorService executorService,
        final ScanContext context,
        final LogRecordSelector selector) 
{
    final LedgerHandle handle = handleCache.openLedger(ledgerDescriptor);
    final FutureTask<LogRecordWithDLSN> future = new FutureTask<LogRecordWithDLSN>(
            new Callable<LogRecordWithDLSN>() {
                @Override
                public LogRecordWithDLSN call() throws Exception {
                    try {
                        LogRecordWithDLSN record = readRecordFromEntries(
                                streamName, handle, metadata, context, selector);
                        return record;
                    } finally {
                        handleCache.releaseLedger(handle);
                    }
                }
            });
    executorService.submit(future);
    return future;
}       ",821,True
"/**
 * Set the record set starts from <code>dlsn</code>.
 *
 * @param dlsn
 *          dlsn to skip to
 * @return builder
 */
public Builder skipTo(@Nullable DLSN dlsn){
    this.dlsnToSkipTo = Optional.fromNullable(dlsn);
    return this;
}","/**
 * Set the record set starts from <code>dlsn</code>.
 *
 * @param dlsn
 *          dlsn to skip to
 * @return builder
 */
public Builder skipTo(@Nullable DLSN dlsn) 
{
    this.dlsn = dlsn;
    return this;
}   ",824,True
"/**
 * Namespace Location.
 *
 * @param uri
 *          namespace location uri.
 * @see DistributedLogNamespace
 * @return namespace builder.
 */
public DistributedLogNamespaceBuilder uri(URI uri){
    this._uri = uri;
    return this;
}","/**
 * Namespace Location.
 *
 * @param uri
 *          namespace location uri.
 * @see DistributedLogNamespace
 * @return namespace builder.
 */
public DistributedLogNamespaceBuilder uri(URI uri) 
{
    this.uri = uri;
    return this;
}   ",825,True
"/**
 * Set the input stream of the serialized bytes data of this record set.
 *
 * @param in
 *          input stream
 * @return builder
 */
public Builder setInputStream(InputStream in){
    this.in = in;
    return this;
}","/**
 * Set the input stream of the serialized bytes data of this record set.
 *
 * @param in
 *          input stream
 * @return builder
 */
public Builder setInputStream(InputStream in) 
{
    this.inputStream = in;
    return this;
}   ",826,True
"/**
 * Find the log record whose transaction id is not less than provided <code>transactionId</code> from
 * entries between <code>startEntryId</code> and <code>endEntryId</code>.
 *
 * @param logName
 *          name of the log
 * @param segment
 *          log segment
 * @param transactionId
 *          provided transaction id to search
 * @param executorService
 *          executor service
 * @param handleCache
 *          handle cache
 * @param entriesToSearch
 *          list of entries to search
 * @param nWays
 *          how many entries to search in parallel
 * @param prevFoundRecord
 *          the log record found in previous search
 * @param promise
 *          promise to satisfy the result
 */
private static void getLogRecordNotLessThanTxIdFromEntries(
        final String logName,
        final LedgerDescriptor ld,
        final LogSegmentMetadata segment,
        final long transactionId,
        final ExecutorService executorService,
        final LedgerHandleCache handleCache,
        final List<Long> entriesToSearch,
        final int nWays,
        final Optional<LogRecordWithDLSN> prevFoundRecord,
        final Promise<Optional<LogRecordWithDLSN>> promise){
    final List<Future<LogRecordWithDLSN>> searchResults =
            Lists.newArrayListWithExpectedSize(entriesToSearch.size());
    for (Long entryId : entriesToSearch) {
        LogRecordSelector selector = new FirstTxIdNotLessThanSelector(transactionId);
        Future<LogRecordWithDLSN> searchResult = asyncReadRecordFromEntries(
                logName,
                ld,
                handleCache,
                segment,
                executorService,
                new SingleEntryScanContext(entryId),
                selector);
        searchResults.add(searchResult);
    }
    FutureEventListener<List<LogRecordWithDLSN>> processSearchResultsListener =
            new FutureEventListener<List<LogRecordWithDLSN>>() {
                @Override
                public void onSuccess(List<LogRecordWithDLSN> resultList) {
                    processSearchResults(
                            logName,
                            ld,
                            segment,
                            transactionId,
                            executorService,
                            handleCache,
                            resultList,
                            nWays,
                            prevFoundRecord,
                            promise);
                }

                @Override
                public void onFailure(Throwable cause) {
                    promise.setException(cause);
                }
            };
    Future.collect(searchResults).addEventListener(
            FutureEventListenerRunnable.of(processSearchResultsListener, executorService));
}","/**
 * Find the log record whose transaction id is not less than provided <code>transactionId</code> from
 * entries between <code>startEntryId</code> and <code>endEntryId</code>.
 *
 * @param logName
 *          name of the log
 * @param segment
 *          log segment
 * @param transactionId
 *          provided transaction id to search
 * @param executorService
 *          executor service
 * @param handleCache
 *          handle cache
 * @param entriesToSearch
 *          list of entries to search
 * @param nWays
 *          how many entries to search in parallel
 * @param prevFoundRecord
 *          the log record found in previous search
 * @param promise
 *          promise to satisfy the result
 */





private static void getLogRecordNotLessThanTxIdFromEntries(
        final String logName,
        final LedgerDescriptor ld,
        final LogSegmentMetadata segment,
        final long transactionId,
        final ExecutorService executorService,
        final LedgerHandleCache handleCache,
        final List<Long> entriesToSearch,
        final int nWays,
        final Optional<LogRecordWithDLSN> prevFoundRecord,
        final Promise<Optional<LogRecordWithDLSN>> promise) 
{
    final List<CompletableFuture<Optional<LogRecordWithDLSN>>> futures = new ArrayList<>(entriesToSearch.size());
    for (Long entryId : entriesToSearch) {
        futures.add(CompletableFuture.supplyAsync(() -> {
            try {
                return getLogRecordNotLessThanTxIdFromEntry(
                        logName,
                        ld,
                        segment,
                        transactionId,
                        entryId,
                        handleCache,
                        prevFoundRecord);
            } catch (Exception e) {
                throw new CompletionException(e);
            }
        }, executorService));
    }

    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(ignoredVoid -> futures.stream()
                    .map(CompletableFuture::join)
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .findFirst())
            .whenComplete((result, throwable) -> {
                if (throwable != null) {
                    promise.completeExceptionally(throwable);
                } else {
                    promise.complete(result);
                }
            });
}       ",829,True
"/**
 * Process each record using LogRecordSelector.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param logSegmentSeqNo
 *          ledger sequence number
 * @param entry
 *          ledger entry
 * @param context
 *          scan context
 * @return log record with dlsn inside the ledger entry
 * @throws IOException
 */
private static void visitEntryRecords(
        String streamName,
        LogSegmentMetadata metadata,
        long logSegmentSeqNo,
        LedgerEntry entry,
        ScanContext context,
        LogRecordSelector selector) throws IOException{
    Entry.Reader reader = Entry.newBuilder()
            .setLogSegmentInfo(logSegmentSeqNo, metadata.getStartSequenceId())
            .setEntryId(entry.getEntryId())
            .setEnvelopeEntry(metadata.getEnvelopeEntries())
            .setInputStream(entry.getEntryInputStream())
            .buildReader();
    LogRecordWithDLSN nextRecord = reader.nextRecord();
    while (nextRecord != null) {
        LogRecordWithDLSN record = nextRecord;
        nextRecord = reader.nextRecord();
        context.numRecordsScanned.incrementAndGet();
        if (!context.includeControl && record.isControl()) {
            continue;
        }
        if (!context.includeEndOfStream && record.isEndOfStream()) {
            continue;
        }
        selector.process(record);
    }
}","/**
 * Process each record using LogRecordSelector.
 *
 * @param streamName
 *          fully qualified stream name (used for logging)
 * @param logSegmentSeqNo
 *          ledger sequence number
 * @param entry
 *          ledger entry
 * @param context
 *          scan context
 * @return log record with dlsn inside the ledger entry
 * @throws IOException
 */
private static void visitEntryRecords(
        String streamName,
        LogSegmentMetadata metadata,
        long logSegmentSeqNo,
        LedgerEntry entry,
        ScanContext context,
        LogRecordSelector selector) throws IOException 
{
    long dlsn = metadata.firstDLSN + entry.getPosition();
    LogRecordWithDLSN record = new LogRecordWithDLSN(entry, dlsn);
    if (selector.isSelected(record)) {
        context.recordSink().accept(record);
    }
}       ",830,True
"/**
 * Create reader to iterate over this record set.
 *
 * @return reader to iterate over this record set.
 * @throws IOException if the record set is invalid record set.
 */
public Reader reader() throws IOException{
    InputStream in = new ByteArrayInputStream(data, offset, length);
    Reader reader = new EnvelopedEntryReader(
            logSegmentSequenceNumber,
            entryId,
            startSequenceId,
            in,
            envelopedEntry,
            deserializeRecordSet,
            NullStatsLogger.INSTANCE);
    if (txidToSkipTo.isPresent()) {
        reader.skipTo(txidToSkipTo.get());
    }
    if (dlsnToSkipTo.isPresent()) {
        reader.skipTo(dlsnToSkipTo.get());
    }
    return reader;
}","/**
 * Create reader to iterate over this record set.
 *
 * @return reader to iterate over this record set.
 * @throws IOException if the record set is invalid record set.
 */
public Reader reader() throws IOException 
{
    if (this.reader == null)
    {
        this.reader = new RecordSetReader(this);
    }
    return this.reader;
}   ",834,False
"/**
 * Set the entry id of this log record set.
 *
 * @param entryId
 *          entry id assigned for this log record set.
 * @return builder
 */
public Builder setEntryId(long entryId){
    this.entryId = entryId;
    return this;
}","/**
 * Set the entry id of this log record set.
 *
 * @param entryId
 *          entry id assigned for this log record set.
 * @return builder
 */
public Builder setEntryId(long entryId) 
{
    this.entryId = entryId;
    return this;
}   ",835,True
"/**
 * Set the serialized bytes data of this record set.
 *
 * @param data
 *          serialized bytes data of this record set.
 * @param offset
 *          offset of the bytes data
 * @param length
 *          length of the bytes data
 * @return builder
 */
public Builder setData(byte[] data, int offset, int length){
    this.data = data;
    this.offset = offset;
    this.length = length;
    return this;
}","/**
 * Set the serialized bytes data of this record set.
 *
 * @param data
 *          serialized bytes data of this record set.
 * @param offset
 *          offset of the bytes data
 * @param length
 *          length of the bytes data
 * @return builder
 */
public Builder setData(byte[] data, int offset, int length) 
{
    this.data = new byte[length];
    System.arraycopy(data, offset, this.data, 0, length);
    return this;
}   ",836,True
"/**
 * Build the namespace.
 *
 * @return the namespace instance.
 * @throws IllegalArgumentException when there is illegal argument provided in the builder
 * @throws NullPointerException when there is null argument provided in the builder
 * @throws IOException when fail to build the backend
 */
public DistributedLogNamespace build()
        throws IllegalArgumentException, NullPointerException, IOException{
    // Check arguments
    Preconditions.checkNotNull(_conf, ""No DistributedLog Configuration."");
    Preconditions.checkNotNull(_uri, ""No DistributedLog URI"");

    // Validate the uri and load the backend according to scheme
    String scheme = _uri.getScheme();
    Preconditions.checkNotNull(scheme, ""Invalid DistributedLog URI : "" + _uri);
    String[] schemeParts = StringUtils.split(scheme, '-');
    Preconditions.checkArgument(schemeParts.length > 0,
            ""Invalid distributedlog scheme found : "" + _uri);
    Preconditions.checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),
            ""Unknown distributedlog scheme found : "" + _uri);

    // both distributedlog: & distributedlog-bk: use bookkeeper as the backend
    // TODO: we could do reflection to load backend in future.
    //       if we are going to support other backends : e.g. 'distributedlog-mem:'.
    if (schemeParts.length > 1) {
        String backendProvider = schemeParts[1];
        Preconditions.checkArgument(Objects.equal(DistributedLogConstants.BACKEND_BK, backendProvider.toLowerCase()),
                ""Backend '"" + backendProvider + ""' is not supported yet."");
    }

    // Built the feature provider
    FeatureProvider featureProvider;
    if (null == _featureProvider) {
        featureProvider = new SettableFeatureProvider("""", 0);
        logger.info(""No feature provider is set. All features are disabled now."");
    } else {
        featureProvider = _featureProvider;
    }

    URI bkUri;
    try {
        bkUri = new URI(
                schemeParts[0],     // remove backend info from bookkeeper backend
                _uri.getAuthority(),
                _uri.getPath(),
                _uri.getQuery(),
                _uri.getFragment());
    } catch (URISyntaxException e) {
        throw new IllegalArgumentException(""Invalid distributedlog uri found : "" + _uri, e);
    }

    return BKDistributedLogNamespace.newBuilder()
            .conf(_conf)
            .uri(bkUri)
            .statsLogger(_statsLogger)
            .featureProvider(featureProvider)
            .clientId(_clientId)
            .regionId(_regionId)
            .build();
}","/**
 * Build the namespace.
 *
 * @return the namespace instance.
 * @throws IllegalArgumentException when there is illegal argument provided in the builder
 * @throws NullPointerException when there is null argument provided in the builder
 * @throws IOException when fail to build the backend
 */
public DistributedLogNamespace build()
        throws IllegalArgumentException, NullPointerException, IOException 
{
    if (null == conf) {
        throw new NullPointerException(""null configuration"");
    }
    if (null == uri) {
        throw new NullPointerException(""null uri"");
    }

    return new DistributedLogNamespaceImpl(conf, uri);
}       ",838,False
"/** 设置右边按钮文字 */
public GlobalDialog setRightBtnText(String str){
    right.setText(str);
    return this;
}","/** 设置右边按钮文字 */
public GlobalDialog setRightBtnText(String str) 
{
    if (rightBtn != null)
    {
        rightBtn.setText(str);
    }
    return this;
}   ",840,True
"/** 设置内容文字 */
public GlobalDialog setContent(String str){
    content.setText(str);
    return this;
}","/** 设置内容文字 */
public GlobalDialog setContent(String str) 
{
    if (tv_content != null)
    {
        tv_content.setText(str);
    }
    return this;
}   ",841,True
"/** 获得 ImageView 保证了 ImageView 的重用 */
private ImageView getImageView(final int position){
    ImageView imageView;
    if (position < imageViews.size()) {
        imageView = imageViews.get(position);
    } else {
        imageView = mAdapter.generateImageView(getContext());
        imageView.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mAdapter.onImageItemClick(getContext(), NineGridView.this, position, mAdapter.getImageInfo());
            }
        });
        imageViews.add(imageView);
    }
    return imageView;
}","/** 获得 ImageView 保证了 ImageView 的重用 */
private ImageView getImageView(final int position) 
{
    ImageView imageView = (ImageView) convertView.findViewById(R.id.id_index_gallery_item_image);
    imageView.setImageResource(mImages[position]);
    return imageView;
}   ",844,True
"/** 进场动画过程监听 */
private void addIntoListener(ValueAnimator valueAnimator){
    valueAnimator.addListener(new Animator.AnimatorListener() {
        @Override
        public void onAnimationStart(Animator animation) {
            rootView.setBackgroundColor(0x0);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
        }

        @Override
        public void onAnimationCancel(Animator animation) {
        }

        @Override
        public void onAnimationRepeat(Animator animation) {
        }
    });
}","/** 进场动画过程监听 */

private void addIntoListener(ValueAnimator valueAnimator) 
{
    valueAnimator.addListener(new AnimatorListenerAdapter()
    {
        @Override
        public void onAnimationStart(Animator animation)
        {
            super.onAnimationStart(animation);
            if (mListener != null)
            {
                mListener.onAnimationStart();
            }
        }

        @Override
        public void onAnimationEnd(Animator animation)
        {
            super.onAnimationEnd(animation);
            if (mListener != null)
            {
                mListener.onAnimationEnd();
            }
        }
    });
}   ",845,True
"//得到ImageOptions对象
@Override
    public void onCreate(){
        super.onCreate();
        ImageLoaderConfiguration config = ImageLoaderConfiguration.createDefault(this);

        OkHttpUtils.init(this);                     //OkHttpUtils初始化
        ImageLoader.getInstance().init(config);     //UniversalImageLoader初始化
        Fresco.initialize(this);                    //Fresco初始化
        x.Ext.init(this);                           //xUtils3初始化
    }","//得到ImageOptions对象
@Override
    public void onCreate() 
{
    super.onCreate();
    options = new DisplayImageOptions.Builder()
            .showImageOnLoading(R.drawable.ic_stub) //设置图片在下载期间显示的图片
            .showImageForEmptyUri(R.drawable.ic_empty) //设置图片Uri为空或是错误的时��显示的图片
            .showImageOnFail(R.drawable.ic_error) //设置图片加载/解码过程中错误时��显示的图片
            .cacheInMemory(true) //设置下载的图片是否��存在内存中
            .cacheOnDisk(true) //设置下载的图片是否��存在SD��中
            .considerExifParams(true) //是否考��JPEG图像EXIF参数（��转，���转）
            .imageScaleType(ImageScaleType.EXACTLY_STRETCHED) //设置图片以如何的编码方式显示
            .bitmapConfig(Bitmap.Config.RGB_565) //设置图片的解码类型
            .build();
}   ",846,False
"/** 显示右边按钮 */
public GlobalDialog showRight(){
    showViews(right);
    return this;
}","/** 显示右边按钮 */
public GlobalDialog showRight() 
{
    if (mRightDialog == null)
    {
        mRightDialog = new GlobalDialog(mContext, R.layout.dialog_global_right);
    }
    mRightDialog.show();
    return this;
}   ",848,True
"/** Integer 估值器 */
public Integer evaluateInt(float fraction, Integer startValue, Integer endValue){
    int startInt = startValue;
    return (int) (startInt + fraction * (endValue - startInt));
}","/** Integer 估值器 */
public Integer evaluateInt(float fraction, Integer startValue, Integer endValue) 
{
    int startInt = startValue;
    int startA = (startInt >> 24) & 0xff;
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;

    int endInt = endValue;
    int endA = (endInt >> 24) & 0xff;
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;

    int currentA = (int) (startA + ((endA - startA) * fraction));
    int currentR = (int) (startR + ((endR - startR) * fraction));
    int currentG = (int) (startG + ((endG - startG) * fraction));
    int currentB = (int) (startB + ((endB - startB) * fraction));

    return (currentA << 24) | (currentR << 16) | (currentG << 8) | currentB;
}   ",849,False
"/** 显示左边按钮 */
public GlobalDialog showLeft(){
    showViews(left);
    return this;
}","/** 显示左边按钮 */
public GlobalDialog showLeft() 
{
    if (mLeftDialog == null)
    {
        mLeftDialog = new GlobalDialog(mContext, R.layout.dialog_left);
        mLeftDialog.show();
    } else
    {
        mLeftDialog.show();
    }
    return this;
}   ",853,True
"/** 设置左边按钮监听 */
public GlobalDialog setLeftOnclick(android.view.View.OnClickListener listener){
    left.setOnClickListener(listener);
    return this;
}","/** 设置左边按钮监听 */
public GlobalDialog setLeftOnclick(android.view.View.OnClickListener listener) 
{
    this.leftOnclickListener = listener;
    return this;
}   ",854,True
"/**
 * 获得状态栏的高度
 */
public int getStatusHeight(Context context){
    int statusHeight = -1;
    try {
        Class<?> clazz = Class.forName(""com.android.internal.R$dimen"");
        Object object = clazz.newInstance();
        int height = Integer.parseInt(clazz.getField(""status_bar_height"").get(object).toString());
        statusHeight = context.getResources().getDimensionPixelSize(height);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return statusHeight;
}","/**
 * 获得状态栏的高度
 */
public int getStatusHeight(Context context) 
{
    int statusHeight = -1;
    try
    {
        Class<?> clazz = Class.forName(""com.android.internal.R$dimen"");
        Object object = clazz.newInstance();
        int height = Integer.parseInt(clazz.getField(""status_bar_height"")
                .get(object).toString());
        statusHeight = context.getResources().getDimensionPixelSize(height);
    } catch (Exception e)
    {
        e.printStackTrace();
    }
    return statusHeight;
}   ",855,True
"/** Float 估值器 */
public Float evaluateFloat(float fraction, Number startValue, Number endValue){
    float startFloat = startValue.floatValue();
    return startFloat + fraction * (endValue.floatValue() - startFloat);
}","/** Float 估值器 */
public Float evaluateFloat(float fraction, Number startValue, Number endValue) 
{
    float startFloat = startValue.floatValue();
    float endFloat = endValue.floatValue();
    float result = startFloat + (endFloat - startFloat) * fraction;
    return result;
}   ",856,True
"// dialog按钮组
public GlobalDialog(Context context){
        super(context, R.style.list_dialog);
        this.setContentView(R.layout.dialog);
        initViews();// 初始化控件
        setSizeAndPosition();//固定到默认位置  如果需要 重写此方法
    }","// dialog按钮组
public GlobalDialog(Context context) 
{
    this.context = context;
    builder = new AlertDialog.Builder(context);
    builder.setCancelable(false);
    builder.setNegativeButton(""取消"", new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            dialog.dismiss();
        }
    });
}   ",858,False
"/**
 * It fills partitionsDDLInfo and partitionsDMLInfo with the partition information
 * @param conversionEntity conversion entity to
 * @param partitionsDDLInfo partition type information, to be filled by this method
 * @param partitionsDMLInfo partition key-value pair, to be filled by this method
 */
public static void populatePartitionInfo(HiveProcessingEntity conversionEntity, Map<String, String> partitionsDDLInfo,
    Map<String, String> partitionsDMLInfo){

  String partitionsInfoString = null;
  String partitionsTypeString = null;

  if (conversionEntity.getPartition().isPresent()) {
    partitionsInfoString = conversionEntity.getPartition().get().getName();
    partitionsTypeString = conversionEntity.getPartition().get().getSchema().getProperty(""partition_columns.types"");
  }

  if (StringUtils.isNotBlank(partitionsInfoString) || StringUtils.isNotBlank(partitionsTypeString)) {
    if (StringUtils.isBlank(partitionsInfoString) || StringUtils.isBlank(partitionsTypeString)) {
      throw new IllegalArgumentException(""Both partitions info and partitions must be present, if one is specified"");
    }
    List<String> pInfo = Splitter.on(HIVE_PARTITIONS_INFO).omitEmptyStrings().trimResults().splitToList(partitionsInfoString);
    List<String> pType = Splitter.on(HIVE_PARTITIONS_TYPE).omitEmptyStrings().trimResults().splitToList(partitionsTypeString);
    log.debug(""PartitionsInfoString: "" + partitionsInfoString);
    log.debug(""PartitionsTypeString: "" + partitionsTypeString);

    if (pInfo.size() != pType.size()) {
      throw new IllegalArgumentException(""partitions info and partitions type list should of same size"");
    }
    for (int i = 0; i < pInfo.size(); i++) {
      List<String> partitionInfoParts = Splitter.on(""="").omitEmptyStrings().trimResults().splitToList(pInfo.get(i));
      String partitionType = pType.get(i);
      if (partitionInfoParts.size() != 2) {
        throw new IllegalArgumentException(
            String.format(""Partition details should be of the format partitionName=partitionValue. Recieved: %s"", pInfo.get(i)));
      }
      partitionsDDLInfo.put(partitionInfoParts.get(0), partitionType);
      partitionsDMLInfo.put(partitionInfoParts.get(0), partitionInfoParts.get(1));
    }
  }
}","/**
 * It fills partitionsDDLInfo and partitionsDMLInfo with the partition information
 * @param conversionEntity conversion entity to
 * @param partitionsDDLInfo partition type information, to be filled by this method
 * @param partitionsDMLInfo partition key-value pair, to be filled by this method
 */

public static void populatePartitionInfo(HiveProcessingEntity conversionEntity, Map<String, String> partitionsDDLInfo,
    Map<String, String> partitionsDMLInfo) 
{
    if (conversionEntity.getPartitionInfo() != null)
    {
        for (Entry<String, String> entry : conversionEntity.getPartitionInfo().entrySet())
        {
            partitionsDDLInfo.put(entry.getKey(), entry.getValue());
            partitionsDMLInfo.put(entry.getKey(), entry.getValue());
        }
    }
}   ",861,True
"/** Constructor with a launcher */
public Builder(GobblinInstanceLauncher instanceLauncher){
  this();
  withInstanceEnvironment(instanceLauncher);
}","/** Constructor with a launcher */
public Builder(GobblinInstanceLauncher instanceLauncher) 
{
    this.instanceLauncher = instanceLauncher;
    this.instance = new GobblinInstance(instanceLauncher);
}   ",864,True
"/**
 * Generates a CTAS statement to dump the results of a query into a new table.
 * @param outputDbAndTable output db and table where contents should be written.
 * @param sourceQuery query to materialize.
 * @param storageFormat format of output table.
 * @param outputTableLocation location where files of output table should be written.
 */
public static String generateStagingCTASStatement(HiveDatasetFinder.DbAndTable outputDbAndTable,
    String sourceQuery, StorageFormat storageFormat, String outputTableLocation){
  Preconditions.checkArgument(!Strings.isNullOrEmpty(outputDbAndTable.getDb()) &&
      !Strings.isNullOrEmpty(outputDbAndTable.getTable()), ""Invalid output db and table "" + outputDbAndTable);

  return String.format(""CREATE TEMPORARY TABLE `%s`.`%s` STORED AS %s LOCATION '%s' AS %s"", outputDbAndTable.getDb(),
      outputDbAndTable.getTable(), storageFormat.getHiveName(), outputTableLocation, sourceQuery);
}","/**
 * Generates a CTAS statement to dump the results of a query into a new table.
 * @param outputDbAndTable output db and table where contents should be written.
 * @param sourceQuery query to materialize.
 * @param storageFormat format of output table.
 * @param outputTableLocation location where files of output table should be written.
 */
public static String generateStagingCTASStatement(HiveDatasetFinder.DbAndTable outputDbAndTable,
    String sourceQuery, StorageFormat storageFormat, String outputTableLocation) 
{
    return ""CREATE TABLE "" + outputDbAndTable + "" STORED AS "" + storageFormat + "" AS "" +
        ""SELECT * FROM ("" + sourceQuery + "") t"";
}   ",865,True
"/**
 * Find the lowest {@link MeteredInputStream} in a chain of {@link FilterInputStream}s.
 */
public static Optional<MeteredInputStream> findWrappedMeteredInputStream(InputStream is){
  if (is instanceof FilterInputStream) {
    try {
      Optional<MeteredInputStream> meteredInputStream =
          findWrappedMeteredInputStream(FilterStreamUnpacker.unpackFilterInputStream((FilterInputStream) is));
      if (meteredInputStream.isPresent()) {
        return meteredInputStream;
      }
    } catch (IllegalAccessException iae) {
      log.warn(""Cannot unpack input stream due to SecurityManager."", iae);
      // Do nothing, we can't unpack the FilterInputStream due to security restrictions
    }
  }
  if (is instanceof MeteredInputStream) {
    return Optional.of((MeteredInputStream) is);
  }
  return Optional.absent();
}","/**
 * Find the lowest {@link MeteredInputStream} in a chain of {@link FilterInputStream}s.
 */
public static Optional<MeteredInputStream> findWrappedMeteredInputStream(InputStream is) 
{
    while (is instanceof FilterInputStream)
    {
        if (is instanceof MeteredInputStream)
        {
            return Optional.of((MeteredInputStream)is);
        }
        is = ((FilterInputStream)is).getWrappedInputStream();
    }
    return Optional.empty();
}   ",866,True
"/**
 * Creates a staging directory with the permission as in source directory.
 * @param fs filesystem object
 * @param destination staging directory location
 * @param conversionEntity conversion entity used to get source directory permissions
 * @param workUnit workunit
 */
public static void createStagingDirectory(FileSystem fs, String destination, HiveProcessingEntity conversionEntity,
    WorkUnitState workUnit){
  /*
   * Create staging data location with the same permissions as source data location
   *
   * Note that hive can also automatically create the non-existing directories but it does not
   * seem to create it with the desired permissions.
   * According to hive docs permissions for newly created directories/files can be controlled using uMask like,
   *
   * SET hive.warehouse.subdir.inherit.perms=false;
   * SET fs.permissions.umask-mode=022;
   * Upon testing, this did not work
   */
  Path destinationPath = new Path(destination);
  try {
    FsPermission permission;
    String group = null;
    if (conversionEntity.getTable().getDataLocation() != null) {
      FileStatus sourceDataFileStatus = fs.getFileStatus(conversionEntity.getTable().getDataLocation());
      permission = sourceDataFileStatus.getPermission();
      group = sourceDataFileStatus.getGroup();
    } else {
      permission = FsPermission.getDefault();
    }

    if (!fs.mkdirs(destinationPath, permission)) {
      throw new RuntimeException(String.format(""Failed to create path %s with permissions %s"",
          destinationPath, permission));
    } else {
      fs.setPermission(destinationPath, permission);
      // Set the same group as source
      if (group != null && !workUnit.getPropAsBoolean(HIVE_DATASET_DESTINATION_SKIP_SETGROUP, DEFAULT_HIVE_DATASET_DESTINATION_SKIP_SETGROUP)) {
        fs.setOwner(destinationPath, null, group);
      }
      log.info(String.format(""Created %s with permissions %s and group %s"", destinationPath, permission, group));
    }
  } catch (IOException e) {
    Throwables.propagate(e);
  }
}","/**
 * Creates a staging directory with the permission as in source directory.
 * @param fs filesystem object
 * @param destination staging directory location
 * @param conversionEntity conversion entity used to get source directory permissions
 * @param workUnit workunit
 */



public static void createStagingDirectory(FileSystem fs, String destination, HiveProcessingEntity conversionEntity,
    WorkUnitState workUnit) 
{
    try
    {
        Path sourcePath = new Path(conversionEntity.getSourceDirectory());
        FsPermission sourcePermission = fs.getFileStatus(sourcePath).getPermission();
        FsPermission stagingPermission = new FsPermission(sourcePermission.getUserAction(), sourcePermission.getGroupAction(),
            sourcePermission.getOtherAction());
        fs.mkdirs(new Path(destination), stagingPermission);
    }
    catch (IOException e)
    {
        throw new RuntimeException(""Unable to create staging directory"", e);
    }
}   ",870,True
"/**
 * Create a work unit to copy a source table to a target table using a staging table in between.
 * @param dataset {@link HiveDataset} for the source table.
 * @param destinationTable {@link StageableTableMetadata} specifying staging and target tables metadata.
 */
public static HiveWorkUnit tableCopyWorkUnit(HiveDataset dataset, StageableTableMetadata destinationTable,
    @Nullable String partitionName){
  HiveWorkUnit workUnit = new HiveWorkUnit(dataset);
  workUnit.setProp(MATERIALIZER_MODE_KEY, MaterializerMode.TABLE_COPY.name());
  workUnit.setProp(STAGEABLE_TABLE_METADATA_KEY, HiveSource.GENERICS_AWARE_GSON.toJson(destinationTable));
  if (!Strings.isNullOrEmpty(partitionName)) {
    workUnit.setPartitionName(partitionName);
  }
  TaskUtils.setTaskFactoryClass(workUnit, HiveMaterializerTaskFactory.class);
  return workUnit;
}","/**
 * Create a work unit to copy a source table to a target table using a staging table in between.
 * @param dataset {@link HiveDataset} for the source table.
 * @param destinationTable {@link StageableTableMetadata} specifying staging and target tables metadata.
 */
public static HiveWorkUnit tableCopyWorkUnit(HiveDataset dataset, StageableTableMetadata destinationTable,
    @Nullable String partitionName) 
{
    HiveWorkUnit workUnit = new HiveWorkUnit();
    workUnit.setDataset(dataset);
    workUnit.setDestinationTable(destinationTable);
    workUnit.setPartitionName(partitionName);
    return workUnit;
}   ",871,True
"/**
 * Returns a pair of Hive table and its partitions
 * @param dbName db name
 * @param tableName table name
 * @param props properties
 * @return a pair of Hive table and its partitions
 * @throws DataConversionException
 */
public static Pair<Optional<Table>, Optional<List<Partition>>> getDestinationTableMeta(String dbName,
    String tableName, Properties props){

  Optional<Table> table = Optional.<Table>absent();
  Optional<List<Partition>> partitions = Optional.<List<Partition>>absent();

  try {
    HiveMetastoreClientPool pool = HiveMetastoreClientPool.get(props,
        Optional.fromNullable(props.getProperty(HiveDatasetFinder.HIVE_METASTORE_URI_KEY)));
    try (AutoReturnableObject<IMetaStoreClient> client = pool.getClient()) {
      table = Optional.of(client.get().getTable(dbName, tableName));
      if (table.isPresent()) {
        org.apache.hadoop.hive.ql.metadata.Table qlTable = new org.apache.hadoop.hive.ql.metadata.Table(table.get());
        if (qlTable.isPartitioned()) {
          partitions = Optional.of(HiveUtils.getPartitions(client.get(), qlTable, Optional.<String>absent()));
        }
      }
    }
  } catch (NoSuchObjectException e) {
    return ImmutablePair.of(table, partitions);
  } catch (IOException | TException e) {
    throw new RuntimeException(""Could not fetch destination table metadata"", e);
  }

  return ImmutablePair.of(table, partitions);
}","/**
 * Returns a pair of Hive table and its partitions
 * @param dbName db name
 * @param tableName table name
 * @param props properties
 * @return a pair of Hive table and its partitions
 * @throws DataConversionException
 */
public static Pair<Optional<Table>, Optional<List<Partition>>> getDestinationTableMeta(String dbName,
    String tableName, Properties props) 
{
  try {
    HiveMetaStoreClient client = new HiveMetaStoreClient(props);
    Table table = client.getTable(dbName, tableName);
    List<Partition> partitions = client.listPartitions(dbName, tableName, Short.MAX_VALUE);
    return Pair.of(Optional.ofNullable(table), Optional.ofNullable(partitions));
  } catch (Exception e) {
    throw new DataConversionException(e);
  }
}   ",872,True
"/***
 * Generate DDL query to create a duplicate Hive table
 * @param inputDbName source DB name
 * @param inputTblName source table name
 * @param tblName New Hive table name
 * @param tblLocation New hive table location
 * @param optionalDbName Optional DB name, if not specified it defaults to 'default'
 */
public static String generateCreateDuplicateTableDDL(
    String inputDbName,
    String inputTblName,
    String tblName,
    String tblLocation,
    Optional<String> optionalDbName){

  Preconditions.checkArgument(StringUtils.isNotBlank(tblName));
  Preconditions.checkArgument(StringUtils.isNotBlank(tblLocation));

  String dbName = optionalDbName.isPresent() ? optionalDbName.get() : ""default"";

  return String.format(""CREATE EXTERNAL TABLE IF NOT EXISTS `%s`.`%s` LIKE `%s`.`%s` LOCATION %n  '%s' %n"",
      dbName, tblName, inputDbName, inputTblName, tblLocation);
}","/***
 * Generate DDL query to create a duplicate Hive table
 * @param inputDbName source DB name
 * @param inputTblName source table name
 * @param tblName New Hive table name
 * @param tblLocation New hive table location
 * @param optionalDbName Optional DB name, if not specified it defaults to 'default'
 */
public static String generateCreateDuplicateTableDDL(
    String inputDbName,
    String inputTblName,
    String tblName,
    String tblLocation,
    Optional<String> optionalDbName) 
{
    String dbName = optionalDbName.orElse(""default"");
    return ""CREATE TABLE "" + dbName + ""."" + tblName + "" LIKE "" + inputDbName + ""."" + inputTblName + "" LOCATION '"" + tblLocation + ""'"";
}   ",873,True
"/**
 * Generates a CTAS statement to dump the contents of a table / partition into a new table.
 * @param outputDbAndTable output db and table where contents should be written.
 * @param sourceEntity source table / partition.
 * @param partitionDMLInfo map of partition values.
 * @param storageFormat format of output table.
 * @param outputTableLocation location where files of output table should be written.
 */
public static String generateStagingCTASStatementFromSelectStar(HiveDatasetFinder.DbAndTable outputDbAndTable,
    HiveDatasetFinder.DbAndTable sourceEntity, Map<String, String> partitionDMLInfo,
    StorageFormat storageFormat, String outputTableLocation){
  StringBuilder sourceQueryBuilder = new StringBuilder(""SELECT * FROM `"").append(sourceEntity.getDb())
      .append(""`.`"").append(sourceEntity.getTable()).append(""`"");
  if (partitionDMLInfo != null && !partitionDMLInfo.isEmpty()) {
    sourceQueryBuilder.append("" WHERE "");
    sourceQueryBuilder.append(partitionDMLInfo.entrySet().stream()
        .map(e -> ""`"" + e.getKey() + ""`='"" + e.getValue() + ""'"")
        .collect(joining("" AND "")));
  }
  return generateStagingCTASStatement(outputDbAndTable, sourceQueryBuilder.toString(), storageFormat, outputTableLocation);
}","/**
 * Generates a CTAS statement to dump the contents of a table / partition into a new table.
 * @param outputDbAndTable output db and table where contents should be written.
 * @param sourceEntity source table / partition.
 * @param partitionDMLInfo map of partition values.
 * @param storageFormat format of output table.
 * @param outputTableLocation location where files of output table should be written.
 */
public static String generateStagingCTASStatementFromSelectStar(HiveDatasetFinder.DbAndTable outputDbAndTable,
    HiveDatasetFinder.DbAndTable sourceEntity, Map<String, String> partitionDMLInfo,
    StorageFormat storageFormat, String outputTableLocation) 
{
    StringBuilder ctasStatement = new StringBuilder();
    ctasStatement.append(""CREATE TABLE "").append(outputDbAndTable.getFullyQualifiedName()).append("" STORED AS "")
        .append(storageFormat.getOutputFormat()).append("" LOCATION '"").append(outputTableLocation).append(""' AS "")
        .append(""SELECT * FROM "").append(sourceEntity.getFullyQualifiedName()).append("" WHERE "");

    boolean isFirst = true;
    for (Map.Entry<String, String> entry : partitionDMLInfo.entrySet())
    {
        if (isFirst)
        {
            isFirst = false;
        }
        else
        {
            ctasStatement.append("" AND "");
        }
        ctasStatement.append(entry.getKey()).append(""='"").append(entry.getValue()).append(""'"");
    }
    return ctasStatement.toString();
}   ",874,False
"/**
 * Get job dependencies of a given job from its config.
 * @param config of a job.
 * @return a list of dependencies of the job.
 */
private static List<String> getDependencies(Config config){
  return config.hasPath(ConfigurationKeys.JOB_DEPENDENCIES) ? Arrays
      .asList(config.getString(ConfigurationKeys.JOB_DEPENDENCIES).split("","")) : new ArrayList<>();
}","/**
 * Get job dependencies of a given job from its config.
 * @param config of a job.
 * @return a list of dependencies of the job.
 */

private static List<String> getDependencies(Config config) 
{
    List<String> dependencies = new ArrayList<String>();
    if (config.hasPath(""dependencies""))
    {
        for (JsonNode dependency : config.get(""dependencies""))
        {
            dependencies.add(dependency.asText());
        }
    }
    return dependencies;
}   ",875,False
"/**
 * Create a work unit to materialize a table / view to a target table using a staging table in between.
 * @param dataset {@link HiveDataset} for the source table.
 * @param storageFormat format in which target table should be written.
 * @param destinationTable {@link StageableTableMetadata} specifying staging and target tables metadata.
 */
public static HiveWorkUnit viewMaterializationWorkUnit(HiveDataset dataset, HiveConverterUtils.StorageFormat storageFormat,
    StageableTableMetadata destinationTable, @Nullable String partitionName){
  HiveWorkUnit workUnit = new HiveWorkUnit(dataset);
  workUnit.setProp(MATERIALIZER_MODE_KEY, MaterializerMode.TABLE_MATERIALIZATION.name());
  workUnit.setProp(STORAGE_FORMAT_KEY, storageFormat.name());
  workUnit.setProp(STAGEABLE_TABLE_METADATA_KEY, HiveSource.GENERICS_AWARE_GSON.toJson(destinationTable));
  if (!Strings.isNullOrEmpty(partitionName)) {
    workUnit.setPartitionName(partitionName);
  }
  TaskUtils.setTaskFactoryClass(workUnit, HiveMaterializerTaskFactory.class);
  return workUnit;
}","/**
 * Create a work unit to materialize a table / view to a target table using a staging table in between.
 * @param dataset {@link HiveDataset} for the source table.
 * @param storageFormat format in which target table should be written.
 * @param destinationTable {@link StageableTableMetadata} specifying staging and target tables metadata.
 */
public static HiveWorkUnit viewMaterializationWorkUnit(HiveDataset dataset, HiveConverterUtils.StorageFormat storageFormat,
    StageableTableMetadata destinationTable, @Nullable String partitionName) 
{
  HiveWorkUnit workUnit = new HiveWorkUnit(dataset, storageFormat, destinationTable);
  workUnit.setPartitionName(partitionName);
  return workUnit;
}   ",876,True
"/**
 * Builds a {@link MeteredInputStream}.
 * @param in The {@link InputStream} to measure.
 * @param meter A {@link Meter} to use for measuring the {@link InputStream}. If null, a new {@link Meter} will be created.
 * @param updateFrequency For performance, {@link MeteredInputStream} will batch {@link Meter} updates to this many bytes.
 */
@Builder
private MeteredInputStream(InputStream in, Meter meter, int updateFrequency){
  super(in);
  this.meter = new BatchedMeterDecorator(meter == null ? new Meter() : meter, updateFrequency > 0 ? updateFrequency : 1000);
}","/**
 * Builds a {@link MeteredInputStream}.
 * @param in The {@link InputStream} to measure.
 * @param meter A {@link Meter} to use for measuring the {@link InputStream}. If null, a new {@link Meter} will be created.
 * @param updateFrequency For performance, {@link MeteredInputStream} will batch {@link Meter} updates to this many bytes.
 */
@Builder
private MeteredInputStream(InputStream in, Meter meter, int updateFrequency) 
{
    super(in);
    this.meter = meter != null ? meter : new Meter();
    this.updateFrequency = updateFrequency;
}   ",877,True
"/***
 * Get the partition directory name of the format: [hourly_][daily_]<partitionSpec1>[partitionSpec ..]
 * @param conversionEntity Conversion entity.
 * @param sourceDataPathIdentifier Hints to look in source partition location to prefix the partition dir name
 *                               such as hourly or daily.
 * @return Partition directory name.
 */
public static String getStagingDataPartitionDirName(HiveProcessingEntity conversionEntity,
    List<String> sourceDataPathIdentifier){

  if (conversionEntity.getPartition().isPresent()) {
    StringBuilder dirNamePrefix = new StringBuilder();
    String sourceHivePartitionLocation = conversionEntity.getPartition().get().getDataLocation().toString();
    if (null != sourceDataPathIdentifier && null != sourceHivePartitionLocation) {
      for (String hint : sourceDataPathIdentifier) {
        if (sourceHivePartitionLocation.toLowerCase().contains(hint.toLowerCase())) {
          dirNamePrefix.append(hint.toLowerCase()).append(""_"");
        }
      }
    }

    return dirNamePrefix + conversionEntity.getPartition().get().getName();
  } else {
    return StringUtils.EMPTY;
  }
}","/***
 * Get the partition directory name of the format: [hourly_][daily_]<partitionSpec1>[partitionSpec ..]
 * @param conversionEntity Conversion entity.
 * @param sourceDataPathIdentifier Hints to look in source partition location to prefix the partition dir name
 *                               such as hourly or daily.
 * @return Partition directory name.
 */
public static String getStagingDataPartitionDirName(HiveProcessingEntity conversionEntity,
    List<String> sourceDataPathIdentifier) 
{
    StringBuilder partitionDirName = new StringBuilder();
    if (sourceDataPathIdentifier.contains(conversionEntity.getSourceDataPathIdentifier()))
    {
        partitionDirName.append(String.format(""%s_"", conversionEntity.getSourceDataPathIdentifier()));
    }
    partitionDirName.append(conversionEntity.getPartitionSpec());
    return partitionDirName.toString();
}   ",879,True
"/**
 * 获取缓存文件
 * 
 * @param key
 * @return value 缓存的文件
 */
public File file(String key){
	File f = mCache.newFile(key);
	if (f.exists())
		return f;
	return null;
}","/**
 * 获取缓存文件
 * 
 * @param key
 * @return value 缓存的文件
 */
public File file(String key) 
{
    File file = null;
    try
    {
        file = new File(cacheDir, key);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return file;
}   ",880,True
"/**
 * 判断缓存的byte数据是否到期
 * 
 * @param data
 * @return true：到期了 false：还没有到期
 */
private static boolean isDue(byte[] data){
	String[] strs = getDateInfoFromDate(data);
	if (strs != null && strs.length == 2) {
		String saveTimeStr = strs[0];
		while (saveTimeStr.startsWith(""0"")) {
			saveTimeStr = saveTimeStr.substring(1, saveTimeStr.length());
		}
		long saveTime = Long.valueOf(saveTimeStr);
		long deleteAfter = Long.valueOf(strs[1]);
		if (System.currentTimeMillis() > saveTime + deleteAfter * 1000) {
			return true;
		}
	}
	return false;
}","/**
 * 判断缓存的byte数据是否到期
 * 
 * @param data
 * @return true：到期了 false：还没有到期
 */
private static boolean isDue(byte[] data) 
{
    if (data.length == 0)
    {
        return true;
    }
    return data[0] == 0;
}   ",883,False
"/**
 * 保存 Serializable数据到 缓存中
 * 
 * @param key
 *            保存的key
 * @param value
 *            保存的value
 * @param saveTime
 *            保存的时间，单位：秒
 */
public void put(String key, Serializable value, int saveTime){
	ByteArrayOutputStream baos = null;
	ObjectOutputStream oos = null;
	try {
		baos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(baos);
		oos.writeObject(value);
		byte[] data = baos.toByteArray();
		if (saveTime != -1) {
			put(key, data, saveTime);
		} else {
			put(key, data);
		}
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		try {
			oos.close();
		} catch (IOException e) {
		}
	}
}","/**
 * 保存 Serializable数据到 缓存中
 * 
 * @param key
 *            保存的key
 * @param value
 *            保存的value
 * @param saveTime
 *            保存的时间，单位：秒
 */

public void put(String key, Serializable value, int saveTime) 
{
    FileOutputStream fos = null;
    ObjectOutputStream oos = null;
    try
    {
        fos = new FileOutputStream(getCacheFile(key));
        oos = new ObjectOutputStream(fos);
        oos.writeObject(value);
        oos.flush();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    finally
    {
        try
        {
            oos.close();
        }
        catch (Exception e)
        {
        }
        try
        {
            fos.close();
        }
        catch (Exception e)
        {
        }
    }
}   ",884,True
"/**
 * 计算 cacheSize和cacheCount
 */
private void calculateCacheSizeAndCacheCount(){
	new Thread(new Runnable() {
		@Override
		public void run() {
			int size = 0;
			int count = 0;
			File[] cachedFiles = cacheDir.listFiles();
			if (cachedFiles != null) {
				for (File cachedFile : cachedFiles) {
					size += calculateSize(cachedFile);
					count += 1;
					lastUsageDates.put(cachedFile, cachedFile.lastModified());
				}
				cacheSize.set(size);
				cacheCount.set(count);
			}
		}
	}).start();
}","/**
 * 计算 cacheSize和cacheCount
 */
private void calculateCacheSizeAndCacheCount() 
{
    if (mCacheSize <= 0)
    {
        mCacheSize = Runtime.getRuntime().maxMemory() / 8;
    }
    mCacheCount = mCacheSize / 1024;
}   ",885,False
"/**
 * 读取JSONArray数据
 * 
 * @param key
 * @return JSONArray数据
 */
public JSONArray getAsJSONArray(String key){
	String JSONString = getAsString(key);
	try {
		JSONArray obj = new JSONArray(JSONString);
		return obj;
	} catch (Exception e) {
		e.printStackTrace();
		return null;
	}
}","/**
 * 读取JSONArray数据
 * 
 * @param key
 * @return JSONArray数据
 */
public JSONArray getAsJSONArray(String key) 
{
    Object obj = get(key);
    if (obj instanceof JSONArray)
    {
        return (JSONArray) obj;
    }
    return null;
}   ",890,True
"/**
 * 读取JSONObject数据
 * 
 * @param key
 * @return JSONObject数据
 */
public JSONObject getAsJSONObject(String key){
	String JSONString = getAsString(key);
	try {
		JSONObject obj = new JSONObject(JSONString);
		return obj;
	} catch (Exception e) {
		e.printStackTrace();
		return null;
	}
}","/**
 * 读取JSONObject数据
 * 
 * @param key
 * @return JSONObject数据
 */
public JSONObject getAsJSONObject(String key) 
{
    Object value = get(key);
    if (value instanceof JSONObject)
    {
        return (JSONObject)value;
    }
    return null;
}   ",891,True
"// =======================================
// ============== byte 数据 读写 =============
// =======================================
/**
 * 保存 byte数据 到 缓存中
 * 
 * @param key
 *            保存的key
 * @param value
 *            保存的数据
 */
public void put(String key, byte[] value){
	File file = mCache.newFile(key);
	FileOutputStream out = null;
	try {
		out = new FileOutputStream(file);
		out.write(value);
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		if (out != null) {
			try {
				out.flush();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		mCache.put(file);
	}
}","// =======================================
// ============== byte 数据 读写 =============
// =======================================
/**
 * 保存 byte数据 到 缓存中
 * 
 * @param key
 *            保存的key
 * @param value
 *            保存的数据
 */
public void put(String key, byte[] value) 
{
    try
    {
        SharedPreferences.Editor editor = mSharedPreferences.edit();
        editor.putString(key, Base64.encodeToString(value, Base64.DEFAULT));
        editor.commit();
    } catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",892,False
"/**
 * 读取 String数据
 * 
 * @param key
 * @return String 数据
 */
public String getAsString(String key){
	File file = mCache.get(key);
	if (!file.exists())
		return null;
	boolean removeFile = false;
	BufferedReader in = null;
	try {
		in = new BufferedReader(new FileReader(file));
		String readString = """";
		String currentLine;
		while ((currentLine = in.readLine()) != null) {
			readString += currentLine;
		}
		if (!Utils.isDue(readString)) {
			return Utils.clearDateInfo(readString);
		} else {
			removeFile = true;
			return null;
		}
	} catch (IOException e) {
		e.printStackTrace();
		return null;
	} finally {
		if (in != null) {
			try {
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		if (removeFile)
			remove(key);
	}
}","/**
 * 读取 String数据
 * 
 * @param key
 * @return String 数据
 */
public String getAsString(String key) 
{
    try
    {
        return this.getString(key);
    }
    catch (Exception e)
    {
        return """";
    }
}   ",895,False
"/**
 * 业务逻辑处理
 */
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{
    log.info(""第"" + count.get() + ""次"" + "",服务端接受的消息:"" + msg);
    try {
        // 如果是protobuf类型的数据
        if (msg instanceof UserMsg.User) {
            UserMsg.User user = (UserMsg.User) msg;
            if (user.getState() == 1) {
                log.info(""客户端业务处理成功!"");
            } else if(user.getState() == 2){
                log.info(""接受到客户端发送的心跳!"");
            }else{
                log.info(""未知命令!"");
            }
        } else {
            log.info(""未知数据!"" + msg);
            return;
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        ReferenceCountUtil.release(msg);
    }
    count.getAndIncrement();
}","/**
 * 业务逻辑处理
 */

@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception 
{
    if (msg instanceof FullHttpRequest)
    {
        FullHttpRequest request = (FullHttpRequest) msg;
        if (request.decoderResult().isSuccess())
        {
            // ��理请求
            handleHttpRequest(ctx, request);
        } else
        {
            // ��理错误
            sendError(ctx, HttpResponseStatus.BAD_REQUEST);
        }
    } else
    {
        // ��理错误
        sendError(ctx, HttpResponseStatus.NOT_FOUND);
    }
}   ",901,False
"/**
 * Creates a TreeNode with a given value, and null children.
 *
 * @param val The value of the given node
 */
public TreeNode(T val){
    this.val = val;
    this.left = null;
    this.right = null;
}","/**
 * Creates a TreeNode with a given value, and null children.
 *
 * @param val The value of the given node
 */
public TreeNode(T val) 
{
    this.val = val;
    this.left = null;
    this.right = null;
}   ",902,True
"/**
 * 会话存储测试
 */
//    @Test
//    public void GrozaSessionStoreTest(){
//
//        SessionStore sessionStore = new SessionStore();
//        sessionStore.setChannelId(""20181018163127"");
//        sessionStore.setCleanSession(true);
//        sessionStore.setClientId(""111"");
//        redisCacheTemplate.opsForValue().set(CACHE_SES + ""20181018163127"",sessionStore);
//        final SessionStore sessionStore1 = (SessionStore) redisCacheTemplate.opsForValue().get(CACHE_SES + ""20181018163127"");
//        log.info(""[对象缓存结果] - [{}]"", sessionStore1.toString());
//
//    }
@Test
public void GrozaDupPublishMessageStoreTest(){
    DupPublishMessageStore dupPublishMessageStore = new DupPublishMessageStore();
    dupPublishMessageStore.setClientId(""20181020112852"");
    dupPublishMessageStore.setMessageId(123456);
    dupPublishMessageStore.setMqttQoS(1);
    dupPublishMessageStore.setTopic(""test"");
    dupPublishMessageStore.setMessageBytes(new byte[]{1,2,3,4,5,6});
    redisCacheTemplate.opsForHash().put(CACHE_DUPPub + ""20181020112852"",123456,dupPublishMessageStore);
    redisCacheTemplate.opsForHash().put(CACHE_DUPPub + ""20181020112852"",123457,dupPublishMessageStore);
    redisCacheTemplate.hasKey(CACHE_DUPPub + ""20181020112852"");
    log.info(redisCacheTemplate.hasKey(CACHE_DUPPub + ""20181020112852"").toString());
    Map<Object,Object> map1 = redisCacheTemplate.opsForHash().entries(CACHE_DUPPub + ""20181020112852"");
    if (map1 != null && !map1.isEmpty()) {
        map1.forEach((k, v) -> {
            log.info(k.toString());
             DupPublishMessageStore dupPublishMessageStore1 = (DupPublishMessageStore) v;
             log.info(dupPublishMessageStore1.getTopic());
        });
    }
    redisCacheTemplate.opsForHash().delete(CACHE_DUPPub + ""20181020112852"",123456);
    redisCacheTemplate.delete(CACHE_DUPPub + ""20181020112852"");

}","/**
 * 会话存储测试
 */
//    @Test
//    public void GrozaSessionStoreTest(){
//
//        SessionStore sessionStore = new SessionStore();
//        sessionStore.setChannelId(""20181018163127"");
//        sessionStore.setCleanSession(true);
//        sessionStore.setClientId(""111"");
//        redisCacheTemplate.opsForValue().set(CACHE_SES + ""20181018163127"",sessionStore);
//        final SessionStore sessionStore1 = (SessionStore) redisCacheTemplate.opsForValue().get(CACHE_SES + ""20181018163127"");
//        log.info(""[对象缓存结果] - [{}]"", sessionStore1.toString());
//
//    }
@Test
public void GrozaDupPublishMessageStoreTest() 
{
    DupPublishMessageStore dupPublishMessageStore = new DupPublishMessageStore();
    dupPublishMessageStore.setClientId(""111"");
    dupPublishMessageStore.setMessageId(123);
    dupPublishMessageStore.setMsgId(""123"");
    dupPublishMessageStore.setTopic(""test"");
    redisCacheTemplate.opsForValue().set(CACHE_MSG + ""123"", dupPublishMessageStore);
    final DupPublishMessageStore dupPublishMessageStore1 = (DupPublishMessageStore) redisCacheTemplate.opsForValue().get(CACHE_MSG + ""123"");
    log.info(""[对象��存结果] - [{}]"", dupPublishMessageStore1.toString());
}   ",904,True
"/**
 * 生成私钥文件
 */
public static void main(String[] args){
    System.out.println();
    System.out.print(""输入保存密钥文件的路径(如: f:/rsa/): "");
    Scanner scanner = new Scanner(System.in);
    String path = scanner.nextLine();
    KeyPair keyPair = SecureUtil.generateKeyPair(""RSA"", 512, LocalDateTime.now().toString().getBytes());
    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
    String privatePath = path + ""auth-private.key"";
    IoUtil.writeObjects(FileUtil.getOutputStream(privatePath), true, privateKey);
}","/**
 * 生成私钥文件
 */






public static void main(String[] args) 
{
    try
    {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(1024);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        PrivateKey privateKey = keyPair.getPrivate();
        byte[] privateKeyEncoded = privateKey.getEncoded();
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        System.out.println(privateKeyString);
    }
    catch (NoSuchAlgorithmException e)
    {
        e.printStackTrace();
    }
}   ",905,False
"/**
 * The instance gets created only when it is called for first time. Lazy-loading
 */
public static synchronized ThreadSafeLazyLoadedMouseDriver getInstance(){
    if (instance == null) {
        instance = new ThreadSafeLazyLoadedMouseDriver();
    }

    return instance;
}","/**
 * The instance gets created only when it is called for first time. Lazy-loading
 */
public static synchronized ThreadSafeLazyLoadedMouseDriver getInstance() 
{
    if (instance == null)
    {
        instance = new ThreadSafeLazyLoadedMouseDriver();
    }
    return instance;
}   ",914,True
"/**
 * Gets the next element.
 *
 * @return TreeNode next. The next element according to our in-order traversal of the given BST
 * @throws NoSuchElementException if this iterator does not have a next element
 */
@Override
public TreeNode<T> next() throws NoSuchElementException{
    if (pathStack.isEmpty()) {
        throw new NoSuchElementException();
    }
    TreeNode<T> next = pathStack.pop();
    pushPathToNextSmallest(next.getRight());
    return next;
}","/**
 * Gets the next element.
 *
 * @return TreeNode next. The next element according to our in-order traversal of the given BST
 * @throws NoSuchElementException if this iterator does not have a next element
 */
@Override
public TreeNode<T> next() throws NoSuchElementException 
{
    if (!hasNext())
    {
        throw new NoSuchElementException();
    }
    TreeNode<T> result = next;
    next = getNext(next);
    return result;
}   ",917,True
"/**
 * Fetch the Parent TreeNode for a given value to insert into the BST.
 *
 * @param valToInsert Value of the new TreeNode to be inserted
 * @return Parent TreeNode of `valToInsert`
 */
private TreeNode<T> getParentNodeOfValueToBeInserted(T valToInsert){
    TreeNode<T> parent = null;
    TreeNode<T> curr = this;

    while (curr != null) {
        parent = curr;
        curr = curr.traverseOneLevelDown(valToInsert);
    }

    return parent;
}","/**
 * Fetch the Parent TreeNode for a given value to insert into the BST.
 *
 * @param valToInsert Value of the new TreeNode to be inserted
 * @return Parent TreeNode of `valToInsert`
 */
private TreeNode<T> getParentNodeOfValueToBeInserted(T valToInsert) 
{
    TreeNode<T> parentNode = null;
    TreeNode<T> currentNode = root;

    while (currentNode != null)
    {
        parentNode = currentNode;
        if (valToInsert.compareTo(currentNode.val) < 0)
        {
            currentNode = currentNode.left;
        }
        else
        {
            currentNode = currentNode.right;
        }
    }

    return parentNode;
}   ",919,True
"/**
 * Return the replacement value for a field value.
 *
 * This does not check for a matching field; the caller must decide if this
 * FieldReplacer should operate on this value by checking getFieldName().
 *
 * The method returns the value with the replacement. If the value returned is
 * not different then eiher the pattern didn't match or the replacement was a
 * no-op.
 *
 * @param value
 * @return
 */
public String replace(String value){
  if (this.isValid) {
    return this.pattern.matcher(value).replaceAll(replacement);
  } else {
    return value;
  }
}","/**
 * Return the replacement value for a field value.
 *
 * This does not check for a matching field; the caller must decide if this
 * FieldReplacer should operate on this value by checking getFieldName().
 *
 * The method returns the value with the replacement. If the value returned is
 * not different then eiher the pattern didn't match or the replacement was a
 * no-op.
 *
 * @param value
 * @return
 */
public String replace(String value) 
{
    if (replacement == null)
    {
        return value;
    }
    else
    {
        return replacement;
    }
}   ",920,True
"/**
 * Loads the configuration of each exchange.
 *
 * @param conf Nutch's configuration.
 * @return An array with each exchange's configuration.
 */
private ExchangeConfig[] loadConfigurations(Configuration conf){
  String filename = conf.get(""exchanges.exchanges.file"",
      ""exchanges.xml"");
  InputSource inputSource = new InputSource(
      conf.getConfResourceAsInputStream(filename));

  final List<ExchangeConfig> configList = new LinkedList<>();

  try {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = factory.newDocumentBuilder();
    Element rootElement = builder.parse(inputSource).getDocumentElement();
    NodeList exchangeList = rootElement.getElementsByTagName(""exchange"");

    for (int i = 0; i < exchangeList.getLength(); i++) {
      Element element = (Element) exchangeList.item(i);
      ExchangeConfig exchangeConfig = ExchangeConfig.getInstance(element);

      if (""default"".equals(exchangeConfig.getClazz())) {
        this.defaultExchangeConfig = exchangeConfig;
        continue;
      }

      configList.add(exchangeConfig);
    }

  } catch (SAXException | IOException | ParserConfigurationException e) {
    LOG.error(e.toString());
  }

  return configList.toArray(new ExchangeConfig[0]);
}","/**
 * Loads the configuration of each exchange.
 *
 * @param conf Nutch's configuration.
 * @return An array with each exchange's configuration.
 */
private ExchangeConfig[] loadConfigurations(Configuration conf) 
{
    String[] exchanges = conf.getStrings(""exchanges"");
    ExchangeConfig[] exchangeConfigs = new ExchangeConfig[exchanges.length];
    for (int i = 0; i < exchanges.length; i++)
    {
        exchangeConfigs[i] = new ExchangeConfig(exchanges[i], conf);
    }
    return exchangeConfigs;
}   ",922,True
"/**
 * Create a segment with the specified status.
 * 
 * @param the
 *          segment's paths
 * @param the
 *          status of the record, ignored if redirect is true
 * @param whether
 *          we're doing a redirect as well
 */
protected void createSegment(Path segment, byte status, boolean redirect)
    throws Exception{
  if (redirect) {
    createSegment(segment, status, false, true);
  } else {
    createSegment(segment, status, true, false);
  }
}","/**
 * Create a segment with the specified status.
 * 
 * @param the
 *          segment's paths
 * @param the
 *          status of the record, ignored if redirect is true
 * @param whether
 *          we're doing a redirect as well
 */
protected void createSegment(Path segment, byte status, boolean redirect)
    throws Exception 
{
    if (redirect)
    {
        status = HttpConstants.STATUS_FOUND;
    }

    SegmentDescriptor desc = new SegmentDescriptor(segment, status, redirect);
    segments.add(desc);
}   ",924,False
"/**
 * Parses the given expression to a JEXL expression. This supports
 * date parsing.
 *
 * @param expr string JEXL expression
 * @return parsed JEXL expression or null in case of parse error
 */
public static JexlExpression parseExpression(String expr){
  if (expr == null) return null;
  
  try {
    // Translate any date object into a long. Dates must be in the DATE_PATTERN
    // format. For example: 2016-03-20T00:00:00Z
    Matcher matcher = DATE_PATTERN.matcher(expr);

    if (matcher.find()) {
      String date = matcher.group();
      
      // parse the matched substring and get the epoch
      Date parsedDate = DateUtils.parseDateStrictly(date, new String[] {""yyyy-MM-dd'T'HH:mm:ss'Z'""});
      long time = parsedDate.getTime();
      
      // replace the original string date with the numeric value
      expr = expr.replace(date, Long.toString(time));
    }

    JexlEngine jexl = new JexlBuilder().silent(true).strict(true).create();

    return jexl.createExpression(expr);
  } catch (Exception e) {
    LOG.error(e.getMessage());
  }
  
  return null;
}","/**
 * Parses the given expression to a JEXL expression. This supports
 * date parsing.
 *
 * @param expr string JEXL expression
 * @return parsed JEXL expression or null in case of parse error
 */
public static JexlExpression parseExpression(String expr) 
{
    JexlEngine jexl = new JexlEngine();
    jexl.setSilent(false);
    jexl.setStrict(true);
    jexl.setLenient(false);

    Expression jexlExpression = jexl.createExpression(expr);

    return new JexlExpression(jexlExpression);
}   ",926,True
"/**
 * Returns all the indexers where the document must be sent to.
 *
 * @param nutchDocument The document to process.
 * @return Indexers.
 */
public String[] indexWriters(final NutchDocument nutchDocument){
  final Set<String> writersIDs = new HashSet<>();

  exchanges.forEach((id, value) -> {
    if (value.exchange.match(nutchDocument)) {
      writersIDs.addAll(Arrays.asList(value.config.getWritersIDs()));
    }
  });

  // Using the default exchange if it's activated and there is not index writers for this document yet.
  if (defaultExchangeConfig != null && writersIDs.isEmpty()) {
    return defaultExchangeConfig.getWritersIDs();
  }

  return writersIDs.toArray(new String[0]);
}","/**
 * Returns all the indexers where the document must be sent to.
 *
 * @param nutchDocument The document to process.
 * @return Indexers.
 */
public String[] indexWriters(final NutchDocument nutchDocument) 
{
    String[] indexers = new String[1];
    indexers[0] = ""indexer"";
    return indexers;
}   ",927,True
"/**
 * Updates the inlink score in the web graph node databsae into the crawl
 * database.
 * 
 * @param crawlDb
 *          The crawl database to update
 * @param webGraphDb
 *          The webgraph database to use.
 * 
 * @throws IOException
 *           If an error occurs while updating the scores.
 */
public void update(Path crawlDb, Path webGraphDb) throws IOException,
    ClassNotFoundException, InterruptedException{

  SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
  long start = System.currentTimeMillis();
  LOG.info(""ScoreUpdater: starting at "" + sdf.format(start));

  Configuration conf = getConf();

  // create a temporary crawldb with the new scores
  LOG.info(""Running crawldb update "" + crawlDb);
  Path nodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);
  Path crawlDbCurrent = new Path(crawlDb, CrawlDb.CURRENT_NAME);
  Path newCrawlDb = new Path(crawlDb, Integer.toString(new Random()
      .nextInt(Integer.MAX_VALUE)));

  // run the updater job outputting to the temp crawl database
  Job updater = NutchJob.getInstance(conf);
  updater.setJobName(""Update CrawlDb from WebGraph"");
  FileInputFormat.addInputPath(updater, crawlDbCurrent);
  FileInputFormat.addInputPath(updater, nodeDb);
  FileOutputFormat.setOutputPath(updater, newCrawlDb);
  updater.setInputFormatClass(SequenceFileInputFormat.class);
  updater.setJarByClass(ScoreUpdater.class);
  updater.setMapperClass(ScoreUpdater.ScoreUpdaterMapper.class);
  updater.setReducerClass(ScoreUpdater.ScoreUpdaterReducer.class);
  updater.setMapOutputKeyClass(Text.class);
  updater.setMapOutputValueClass(ObjectWritable.class);
  updater.setOutputKeyClass(Text.class);
  updater.setOutputValueClass(CrawlDatum.class);
  updater.setOutputFormatClass(MapFileOutputFormat.class);

  try {
    boolean success = updater.waitForCompletion(true);
    if (!success) {
      String message = ""Update CrawlDb from WebGraph job did not succeed, job status:""
          + updater.getStatus().getState() + "", reason: ""
          + updater.getStatus().getFailureInfo();
      LOG.error(message);
      // remove the temp crawldb on error
      FileSystem fs = newCrawlDb.getFileSystem(conf);
      if (fs.exists(newCrawlDb)) {
        fs.delete(newCrawlDb, true);
      }
      throw new RuntimeException(message);
    }
  } catch (IOException | ClassNotFoundException | InterruptedException e) {
    LOG.error(""Update CrawlDb from WebGraph:"", e);

    // remove the temp crawldb on error
    FileSystem fs = newCrawlDb.getFileSystem(conf);
    if (fs.exists(newCrawlDb)) {
      fs.delete(newCrawlDb, true);
    }
    throw e;
  }

  // install the temp crawl database
  LOG.info(""ScoreUpdater: installing new crawldb "" + crawlDb);
  CrawlDb.install(updater, crawlDb);

  long end = System.currentTimeMillis();
  LOG.info(""ScoreUpdater: finished at "" + sdf.format(end) + "", elapsed: ""
      + TimingUtil.elapsedTime(start, end));
}","/**
 * Updates the inlink score in the web graph node databsae into the crawl
 * database.
 * 
 * @param crawlDb
 *          The crawl database to update
 * @param webGraphDb
 *          The webgraph database to use.
 * 
 * @throws IOException
 *           If an error occurs while updating the scores.
 */

public void update(Path crawlDb, Path webGraphDb) throws IOException,
    ClassNotFoundException, InterruptedException 
{
  Job job = new Job(getConf());
  job.setJobName(""UpdateInlinkScore"");
  job.setJarByClass(UpdateInlinkScore.class);

  job.setMapperClass(UpdateInlinkScoreMapper.class);
  job.setReducerClass(UpdateInlinkScoreReducer.class);

  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(Text.class);

  job.setOutputKeyClass(Text.class);
  job.setOutputValueClass(Text.class);

  FileInputFormat.setInputPaths(job, webGraphDb);
  FileOutputFormat.setOutputPath(job, crawlDb);

  job.waitForCompletion(true);
}   ",928,False
"/**
 * Merge some segments!
 * 
 * @param the
 *          test directory
 * @param the
 *          segments to merge
 * @return Path to the merged segment
 */
protected Path merge(Path testDir, Path[] segments) throws Exception{
  // Our merged output directory
  Path out = new Path(testDir, ""out"");

  // Merge
  SegmentMerger merger = new SegmentMerger(conf);
  merger.merge(out, segments, false, false, -1);

  FileStatus[] stats = fs.listStatus(out);
  Assert.assertEquals(1, stats.length);

  return stats[0].getPath();
}","/**
 * Merge some segments!
 * 
 * @param the
 *          test directory
 * @param the
 *          segments to merge
 * @return Path to the merged segment
 */
protected Path merge(Path testDir, Path[] segments) throws Exception 
{
    Path merged = new Path(testDir, ""merged"");
    Path[] in = segments;
    Path[] out = { merged };
    return merge(in, out);
}   ",929,False
"/**
 * Checks the merged segment and removes the stuff again.
 * 
 * @param the
 *          test directory
 * @param the
 *          merged segment
 * @return the final status
 */
protected byte checkMergedSegment(Path testDir, Path mergedSegment)
    throws Exception{
  // Get a MapFile reader for the <Text,CrawlDatum> pairs
  MapFile.Reader[] readers = MapFileOutputFormat.getReaders(new Path(
      mergedSegment, CrawlDatum.FETCH_DIR_NAME), conf);

  Text key = new Text();
  CrawlDatum value = new CrawlDatum();
  byte finalStatus = 0x0;

  for (MapFile.Reader reader : readers) {
    while (reader.next(key, value)) {
      LOG.info(""Reading status for: "" + key.toString() + "" > ""
          + CrawlDatum.getStatusName(value.getStatus()));

      // Only consider fetch status
      if (CrawlDatum.hasFetchStatus(value)
          && key.toString().equals(""http://nutch.apache.org/"")) {
        finalStatus = value.getStatus();
      }
    }

    // Close the reader again
    reader.close();
  }

  // Remove the test directory again
  fs.delete(testDir, true);

  LOG.info(""Final fetch status for: http://nutch.apache.org/ > ""
      + CrawlDatum.getStatusName(finalStatus));

  // Return the final status
  return finalStatus;
}","/**
 * Checks the merged segment and removes the stuff again.
 * 
 * @param the
 *          test directory
 * @param the
 *          merged segment
 * @return the final status
 */
protected byte checkMergedSegment(Path testDir, Path mergedSegment)
    throws Exception 
{
    // check the merged segment
    byte status = checkSegment(testDir, mergedSegment);

    // remove the merged segment
    FileUtil.fullyDelete(mergedSegment.toFile());

    return status;
}   ",930,False
"/**
 * Testcase for NUTCH-325.
 * 
 * @throws URLFilterException
 */
@Test
public void testNonExistingUrlFilter() throws URLFilterException{
  Configuration conf = NutchConfiguration.create();
  String class1 = ""NonExistingFilter"";
  String class2 = ""org.apache.nutch.urlfilter.prefix.PrefixURLFilter"";
  conf.set(URLFilters.URLFILTER_ORDER, class1 + "" "" + class2);

  URLFilters normalizers = new URLFilters(conf);
  normalizers.filter(""http://someurl/"");
}","/**
 * Testcase for NUTCH-325.
 * 
 * @throws URLFilterException
 */
@Test
public void testNonExistingUrlFilter() throws URLFilterException 
{
    URLFilter filter = new URLFilter(""file:///non/existing/file"");
    Assert.assertFalse(filter.isValid());
}   ",933,True
"/**
 * Execute a sequence of creating segments, merging them and checking the
 * final output
 * 
 * @param status
 *          to start with
 * @param status
 *          to end with
 * @param number
 *          of rounds
 * @param whether
 *          redirects are injected randomly
 * @return the CrawlDatum status
 */
protected byte executeSequence(byte firstStatus, byte lastStatus, int rounds,
    boolean redirect) throws Exception{
  // Our test directory
  Path testDir = new Path(conf.get(""hadoop.tmp.dir""), ""merge-""
      + System.currentTimeMillis());

  // Format for the segments
  DecimalFormat df = new DecimalFormat(""0000000"");

  // Create our segment paths
  Path[] segmentPaths = new Path[rounds];
  for (int i = 0; i < rounds; i++) {
    String segmentName = df.format(i);
    segmentPaths[i] = new Path(testDir, segmentName);
  }

  // Create the first segment according to the specified status
  createSegment(segmentPaths[0], firstStatus, false);

  // Create N segments with random status and optionally with randomized
  // redirect injection
  for (int i = 1; i < rounds - 1; i++) {
    // Status, 6 possibilities incremented with 33 hex
    byte status = (byte) (rnd.nextInt(6) + 0x21);

    // Whether this is going to be a redirect
    boolean addRedirect = redirect ? rnd.nextBoolean() : false;
    // If it's a redirect we add a datum resulting from a fetch at random,
    // if not: always add a fetch datum to avoid empty segments
    boolean addFetch = addRedirect ? rnd.nextBoolean() : true;

    createSegment(segmentPaths[i], status, addFetch, addRedirect);
  }

  // Create the last segment according to the specified status
  // (additionally, add a redirect at random)
  createSegment(segmentPaths[rounds - 1], lastStatus, true,
      redirect ? rnd.nextBoolean() : false);

  // Merge the segments!
  Path mergedSegment = merge(testDir, segmentPaths);

  // Check the status of the final record and return it
  return checkMergedSegment(testDir, mergedSegment);
}","/**
 * Execute a sequence of creating segments, merging them and checking the
 * final output
 * 
 * @param status
 *          to start with
 * @param status
 *          to end with
 * @param number
 *          of rounds
 * @param whether
 *          redirects are injected randomly
 * @return the CrawlDatum status
 */
protected byte executeSequence(byte firstStatus, byte lastStatus, int rounds,
    boolean redirect) throws Exception 
{
    byte status = firstStatus;
    for (int i = 0; i < rounds; i++)
    {
        status = executeRound(status, redirect);
    }
    return status;
}   ",937,False
"/**
 * get result by cluster_id
 *
 * @param clusterId cluster_id
 * @return RDBAnalyzeResult 不包含 cluster_id 和 scheduleId
 */
private RDBAnalyzeResult selectLatestResultByRID(Long clusterId, Long scheduleId){
    if (null == clusterId) {
        return null;
    }
    RDBAnalyzeResult result = null;
    try {
        result = rdbAnalyzeResultMapper.selectLatestResultByRedisInfoId(clusterId, scheduleId);
    } catch (Exception e) {
        LOG.error(""selectLatestResultByRedisInfoId failed!"", e);
    }
    return result;
}","/**
 * get result by cluster_id
 *
 * @param clusterId cluster_id
 * @return RDBAnalyzeResult 不包含 cluster_id 和 scheduleId
 */
private RDBAnalyzeResult selectLatestResultByRID(Long clusterId, Long scheduleId) 
{
    RDBAnalyzeResult rdbAnalyzeResult = null;
    try
    {
        rdbAnalyzeResult = rdbAnalyzeResultMapper.selectLatestResultByRID(clusterId, scheduleId);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return rdbAnalyzeResult;
}   ",940,True
"/**
 * 参数纠正，防止查询不到数据或数据过多
 *
 * @param nodeInfoParam
 * @return
 */
private NodeInfoParam parameterCorrection(NodeInfoParam nodeInfoParam){
    Timestamp startTime = nodeInfoParam.getStartTime();
    Timestamp endTime = nodeInfoParam.getEndTime();
    if (endTime == null) {
        endTime = TimeUtil.getCurrentTimestamp();
        nodeInfoParam.setEndTime(endTime);
    }
    if (startTime == null) {
        startTime = TimeUtil.getDefaultLastTimestamp();
        nodeInfoParam.setStartTime(startTime);
    }
    // endTime <= startTime
    if (endTime.getTime() - startTime.getTime() <= 0) {
        endTime = TimeUtil.getCurrentTimestamp();
        startTime = TimeUtil.getDefaultLastTimestamp();
        nodeInfoParam.setEndTime(endTime);
        nodeInfoParam.setStartTime(startTime);
    }
    List<String> nodeList = nodeInfoParam.getNodeList();
    if (nodeList == null || nodeList.isEmpty()) {
        List<RedisNode> redisNodes = redisNodeDao.selectRedisNodeListByCluster(nodeInfoParam.getClusterId());
        nodeList = new LinkedList<>();
        for (RedisNode redisNode : redisNodes) {
            nodeList.add(RedisUtil.getNodeString(redisNode));
        }
        nodeInfoParam.setNodeList(nodeList);
    }
    return nodeInfoParam;
}","/**
 * 参数纠正，防止查询不到数据或数据过多
 *
 * @param nodeInfoParam
 * @return
 */
private NodeInfoParam parameterCorrection(NodeInfoParam nodeInfoParam) 
{
    if (nodeInfoParam == null)
    {
        nodeInfoParam = new NodeInfoParam();
    }
    if (nodeInfoParam.getPageSize() > 100)
    {
        nodeInfoParam.setPageSize(100);
    }
    return nodeInfoParam;
}   ",943,False
"/**
 * 获取上一次的数据转换为ReportData
 *
 * @param clusterId clusterId
 * @return Map
 */
@Override
public Map<String, ReportData> getReportDataLatest(Long clusterId, Long scheduleId){
    if (null == clusterId) {
        return null;
    }
    RDBAnalyzeResult rdbAnalyzeResult = selectLatestResultByRID(clusterId, scheduleId);
    if (null == rdbAnalyzeResult) {
        return null;
    }
    JSONArray countResult = getJSONArrayFromResultByKey(rdbAnalyzeResult.getResult(), IAnalyzeDataConverse.PREFIX_KEY_BY_COUNT);
    JSONArray memResult = getJSONArrayFromResultByKey(rdbAnalyzeResult.getResult(), IAnalyzeDataConverse.PREFIX_KEY_BY_MEMORY);
    return getPrefixReportData(countResult, memResult);
}","/**
 * 获取上一次的数据转换为ReportData
 *
 * @param clusterId clusterId
 * @return Map
 */


@Override
public Map<String, ReportData> getReportDataLatest(Long clusterId, Long scheduleId) 
{
    Map<String, ReportData> reportDataMap = new HashMap<>();
    List<ReportData> reportDataList = reportDataMapper.getReportDataLatest(clusterId, scheduleId);
    for (ReportData reportData : reportDataList)
    {
        reportDataMap.put(reportData.getTaskId(), reportData);
    }
    return reportDataMap;
}   ",944,False
"/**
 * 更新所有 redis node 状态
 *
 * @param cluster
 * @return 如果节点有问题，则改变 cluster state 为 WARN
 */
private Cluster.ClusterState updateRedisNodeState(Cluster cluster){
    Cluster.ClusterState clusterState = Cluster.ClusterState.HEALTH;
    List<RedisNode> redisNodeList = redisNodeService.getMergedRedisNodeList(cluster.getClusterId());
    for (RedisNode redisNode : redisNodeList) {
        boolean runStatus = redisNode.getRunStatus();
        boolean inCluster = redisNode.getInCluster();
        String flags = redisNode.getFlags();
        boolean flagsNormal = Objects.equals(flags, SLAVE.getValue()) || Objects.equals(flags, MASTER.getValue());
        String linkState = redisNode.getLinkState();
        NodeRole nodeRole = redisNode.getNodeRole();
        // 节点角色为 UNKNOWN
        boolean nodeRoleNormal = Objects.equals(nodeRole, MASTER) || Objects.equals(nodeRole, SLAVE);
        if (!runStatus || !inCluster || !flagsNormal || !Objects.equals(linkState, CONNECTED) || !nodeRoleNormal) {
            clusterState = Cluster.ClusterState.WARN;
        }
        redisNodeService.updateRedisNode(redisNode);
    }
    return clusterState;
}","/**
 * 更新所有 redis node 状态
 *
 * @param cluster
 * @return 如果节点有问题，则改变 cluster state 为 WARN
 */
private Cluster.ClusterState updateRedisNodeState(Cluster cluster) 
{
    Cluster.ClusterState state = Cluster.ClusterState.OK;
    for (RedisNode node : cluster.getNodes())
    {
        if (!node.isAvailable())
        {
            state = Cluster.ClusterState.WARN;
            break;
        }
    }
    cluster.setClusterState(state);
    return state;
}   ",948,False
"/**
 * 这里可能不是特别合理，只为实现功能
 */
private Integer getOperationGroupId(Object[] args){
    Object arg = args[0];
    Integer operationGroupId = -1;
    if (arg instanceof JSONObject){
        operationGroupId = (Integer)((JSONObject)arg).get(""groupId"");
    }else{
        if (arg instanceof List) {
            JSONArray argArray = (JSONArray)JSONObject.toJSON(arg);
            JSONObject jsonObject = (JSONObject)argArray.get(0);
            operationGroupId = (Integer)jsonObject.get(""groupId"");
        }else {
            if (arg instanceof InstallationParam){
                InstallationParam installationParam = (InstallationParam)arg;
                Cluster cluster = installationParam.getCluster();
                operationGroupId = cluster.getGroupId();
            }else{
                JSONObject argJson = (JSONObject)JSONObject.toJSON(arg);
                operationGroupId = (Integer)argJson.get(""groupId"");
            }
        }
    }

    return operationGroupId;
}","/**
 * 这里可能不是特别合理，只为实现功能
 */
private Integer getOperationGroupId(Object[] args) 
{
    if (args == null || args.length == 0)
    {
        return null;
    }
    for (Object arg : args)
    {
        if (arg instanceof Integer)
        {
            return (Integer) arg;
        }
    }
    return null;
}   ",949,False
"/**
 *
 * @param
 * @return boolean true: has task running false: no task running
 */
@Override
public boolean ifRDBAnalyzeIsRunning(Long id){
    List<ScheduleDetail> scheduleDetail = AppCache.scheduleDetailMap.get(id);
    // default no task running
    boolean result = false;
    if (scheduleDetail != null && scheduleDetail.size() > 0) {
        for (ScheduleDetail scheduleDetails : scheduleDetail) {
            AnalyzeStatus status = scheduleDetails.getStatus();
            if ((!status.equals(AnalyzeStatus.DONE)) && (!status.equals(AnalyzeStatus.CANCELED))
                    && (!status.equals(AnalyzeStatus.ERROR))) {
                result = true;
                break;
            }
        }
    }
    return result;
}","/**
 *
 * @param
 * @return boolean true: has task running false: no task running
 */
@Override
public boolean ifRDBAnalyzeIsRunning(Long id) 
{
    if (id == null)
    {
        return false;
    }

    try
    {
        return this.getSqlMapClient().queryForObject(""RDBANALYZE_IS_RUNNING"", id) != null;
    }
    catch (SQLException e)
    {
        logger.error(e.getMessage(), e);
    }

    return false;
}   ",951,False
"/**
 * Check free memory of machine
 * Check ports
 *
 * @param installationParam
 * @return
 */
public boolean checkInstallationEnv(InstallationParam installationParam){
    boolean commonCheck = true;
    String clusterName = installationParam.getCluster().getClusterName();
    List<Machine> machineList = installationParam.getMachineList();
    for (Machine machine : machineList) {
        String host = machine.getHost();
        Map<String, String> info = null;
        try {
            info = LinuxInfoUtil.getLinuxInfo(machine);
        } catch (Exception e) {
            String message = ""Get "" + host + "" info failed"";
            InstallationLogContainer.appendLog(clusterName, message);
            InstallationLogContainer.appendLog(clusterName, e.getMessage());
            logger.error(message, e);
            commonCheck = false;
        }
        String memoryFreeStr = info.get(MEMORY_FREE);
        if (Strings.isNullOrEmpty(memoryFreeStr)) {
            InstallationLogContainer.appendLog(clusterName, ""Can't get "" + host + "" memory info."");
            commonCheck = false;
        } else {
            Integer memoryFree = Integer.valueOf(memoryFreeStr);
            if (memoryFree <= MIN_MEMORY_FREE) {
                InstallationLogContainer.appendLog(clusterName, host + "" not enough memory, free memory: "" + memoryFree);
                commonCheck = false;
            }
        }
        // no check
        commonCheck = true;
    }
    return commonCheck && checkEnvironment(installationParam);
}","/**
 * Check free memory of machine
 * Check ports
 *
 * @param installationParam
 * @return
 */
public boolean checkInstallationEnv(InstallationParam installationParam) 
{
    if (checkFreeMemory(installationParam) && checkPorts(installationParam))
    {
        return true;
    }
    return false;
}   ",952,False
"/**
 * 数据转换
 *
 * @param arrayResult
 * @return
 */
private Map<String, JSONObject> getMapJsonPrefixByResult(JSONArray arrayResult){
    Map<String, JSONObject> result = new HashMap<>(500);
    JSONObject object;
    if (null != arrayResult && !arrayResult.isEmpty()) {
        for (Object obj : arrayResult) {
            object = (JSONObject) obj;
            result.put(object.getString(""prefixKey""), object);
        }
    }
    return result;
}","/**
 * 数据转换
 *
 * @param arrayResult
 * @return
 */

private Map<String, JSONObject> getMapJsonPrefixByResult(JSONArray arrayResult) 
{
    Map<String, JSONObject> map = new HashMap<String, JSONObject>();
    for (int i = 0; i < arrayResult.size(); i++)
    {
        JSONObject jsonObject = arrayResult.getJSONObject(i);
        map.put(jsonObject.getString(""prefix""), jsonObject);
    }
    return map;
}   ",954,True
"//用于流式传输（例如tcp）情况下，判断buf里是否获得了一个完整的package
// 返回值：小于0表示格式非法  等于0表示没有收完整还需要继续接收  大于0表示收到了完整的报文，报文长度作为返回值
static public int isWholePackage(byte[] buf, int offset, int len){
    if (buf[offset] != 0x28)
    {
        return -1;
    }
    if (len < 10)
    {
        return -1;
    }
    byte[] lenBytes = new byte[4];
    for (int i = 0; i < 4; i++) {
        lenBytes[i] = buf[offset+1+i];
    }
    int headLen = bytes2int(lenBytes);
    if (headLen < 0) { return -1;}

    for (int i = 0; i < 4; i++) {
        lenBytes[i] = buf[offset+5+i];
    }
    int bodyLen = bytes2int(lenBytes);
    if (bodyLen < 0) { return -1;}

    if ( ( 2+4+4+headLen+bodyLen) <= len)
    {
        return ( 2+4+4+headLen+bodyLen);
    }
    else {
        return 0;
    }

}","//用于流式传输（例如tcp）情况下，判断buf里是否获得了一个完整的package
// 返回值：小于0表示格式非法  等于0表示没有收完整还需要继续接收  大于0表示收到了完整的报文，报文长度作为返回值
static public int isWholePackage(byte[] buf, int offset, int len) 
{
    if (len < 4)
        return -1;

    int pkgLen = getPackageLen(buf, offset);
    if (pkgLen > len)
        return 0;

    return pkgLen;
}   ",960,True
"//主动结束和数据库的连接
public void releaseConn(){
    if(resultSet != null){
        try{
            resultSet.close();
        }catch(SQLException e){
            e.printStackTrace();
        }
    }
}","//主动结束和数据库的连接

public void releaseConn() 
{
    if (conn != null)
    {
        try
        {
            conn.close();
        }
        catch (SQLException e)
        {
            e.printStackTrace();
        }
    }
}   ",962,True
"//查询数据库，返回所有满足条件的记录， 使用java反射机制，将记录映射到java类T
public <T> ArrayList<T> findMoreRefResult(String sql, List<Object> params,
                                     Class<T> cls )throws Exception{
    ArrayList<T> list = new ArrayList<T>();
    int index = 1;
    pstmt = connection.prepareStatement(sql);
    if(params != null && !params.isEmpty()){
        for(int i = 0; i<params.size(); i++){
            pstmt.setObject(index++, params.get(i));
        }
    }
    resultSet = pstmt.executeQuery();
    ResultSetMetaData metaData  = resultSet.getMetaData();
    int cols_len = metaData.getColumnCount();
    while(resultSet.next()){
        T resultObject = cls.newInstance();
        for(int i = 0; i<cols_len; i++){
            String cols_name = metaData.getColumnName(i+1);
            Object cols_value = resultSet.getObject(cols_name);

            if(cols_value == null){
                cols_value = """";
            }
            Field field = cls.getDeclaredField(cols_name);
            field.setAccessible(true); //��javabean�ķ���Ȩ��
            field.set(resultObject, cols_value);
        }
        list.add(resultObject);
    }
    resultSet.close();
    pstmt.close();
    return list;
}","//查询数据库，返回所有满足条件的记录， 使用java反射机制，将记录映射到java类T
public <T> ArrayList<T> findMoreRefResult(String sql, List<Object> params,
                                     Class<T> cls )throws Exception 
{
    Connection con = null;
    PreparedStatement pre = null;
    ResultSet rs = null;
    ArrayList<T> list = new ArrayList<T>();
    try
    {
        con = JDBCUtils.getConnection();
        pre = con.prepareStatement(sql);
        if(params != null)
        {
            for(int i = 0; i < params.size(); i++)
            {
                pre.setObject(i+1, params.get(i));
            }
        }
        rs = pre.executeQuery();
        ResultSetMetaData rsmd = rs.getMetaData();
        int colCount = rsmd.getColumnCount();
        while(rs.next())
        {
            T m = cls.newInstance();
            for(int i = 1; i <= colCount; i++)
            {
                Object value = rs.getObject(i);
                String colName = rsmd.getColumnName(i);
                Field field = cls.getDeclaredField(colName);
                field.setAccessible(true);
                field.set(m, value);
            }
            list.add(m);
        }
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
    finally
    {
        JDBCUtils.close(rs, pre, con);
    }
    return list;
}   ",963,True
"//查询数据库，只返回一条记录，该记录的字段保存在Map里返回，字段名作为key，字段值作为value
public Map<String, Object> findSimpleResult(String sql, List<Object> params) throws SQLException{
    Map<String, Object> map = new HashMap<String, Object>();
    int index  = 1;
    pstmt = connection.prepareStatement(sql);
    if(params != null && !params.isEmpty()){
        for(int i=0; i<params.size(); i++){
            pstmt.setObject(index++, params.get(i));
        }
    }
    resultSet = pstmt.executeQuery();
    ResultSetMetaData metaData = resultSet.getMetaData();
    int col_len = metaData.getColumnCount();
    if (resultSet.next()){
        for(int i=0; i<col_len; i++ ){
            String cols_name = metaData.getColumnName(i+1);
            Object cols_value = resultSet.getObject(cols_name);
            if(cols_value == null){
                cols_value = """";
            }
            map.put(cols_name, cols_value);
        }
    }
    resultSet.close();
    pstmt.close();
    return map;
}","//查询数据库，只返回一条记录，该记录的字段保存在Map里返回，字段名作为key，字段值作为value








public Map<String, Object> findSimpleResult(String sql, List<Object> params) throws SQLException 
{
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Map<String, Object> map = new HashMap<String, Object>();
    try
    {
        conn = JdbcUtils.getConnection();
        pstmt = conn.prepareStatement(sql);
        if (params != null && params.size() > 0)
        {
            int i = 1;
            for (Object param : params)
            {
                pstmt.setObject(i++, param);
            }
        }
        rs = pstmt.executeQuery();
        ResultSetMetaData rsmd = rs.getMetaData();
        int colCount = rsmd.getColumnCount();
        if (rs.next())
        {
            for (int i = 1; i <= colCount; i++)
            {
                String colName = rsmd.getColumnName(i);
                Object colValue = rs.getObject(colName);
                map.put(colName, colValue);
            }
        }
    }
    finally
    {
        JdbcUtils.free(rs, pstmt, conn);
    }
    return map;
}   ",964,True
"//查询数据库，只返回一条记录， 使用java反射机制，将记录映射到java类T
public <T> T findSimpleRefResult(String sql, List<Object> params,
                                 Class<T> cls )throws Exception{
    T resultObject = null;
    int index = 1;
    pstmt = connection.prepareStatement(sql);
    if(params != null && !params.isEmpty()){
        for(int i = 0; i<params.size(); i++){
            pstmt.setObject(index++, params.get(i));
        }
    }
    resultSet = pstmt.executeQuery();
    ResultSetMetaData metaData  = resultSet.getMetaData();
    int cols_len = metaData.getColumnCount();
    while(resultSet.next()){
        resultObject = cls.newInstance();
        for(int i = 0; i<cols_len; i++){
            String cols_name = metaData.getColumnName(i+1);
            Object cols_value = resultSet.getObject(cols_name);
            if(cols_value == null){
                cols_value = """";
            }
            Field field = cls.getDeclaredField(cols_name);
            field.setAccessible(true);
            field.set(resultObject, cols_value);
        }
    }
    resultSet.close();
    pstmt.close();
    return resultObject;

}","//查询数据库，只返回一条记录， 使用java反射机制，将记录映射到java类T
public <T> T findSimpleRefResult(String sql, List<Object> params,
                                 Class<T> cls )throws Exception 
{
    T resultObject = null;
    int index = 1;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try
    {
        conn = JDBCUtils.getConnection();
        pstmt = conn.prepareStatement(sql);
        if(params != null)
        {
            for(int i = 0; i < params.size(); i++)
            {
                pstmt.setObject(index++, params.get(i));
            }
        }
        rs = pstmt.executeQuery();
        ResultSetMetaData metaData = rs.getMetaData();
        int col_num = metaData.getColumnCount();
        if(rs.next())
        {
            resultObject = cls.newInstance();
            for(int i = 0; i < col_num; i++)
            {
                String col_name = metaData.getColumnName(i + 1);
                Object value = rs.getObject(col_name);
                BeanUtils.setProperty(resultObject, col_name, value);
            }
        }
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
    finally
    {
        JDBCUtils.release(rs, pstmt, conn);
    }
    return resultObject;
}   ",967,True
"//长度整数转化为大端四字节整数
static public byte[] int2Bytes(int i){
    byte[] b = new byte[4];
    int v = 256 * 256 * 256;
    for (int j = 0; j < 3; j++) {
        b[j] = (byte)(i / v);
        i = i % v;
        v = v / 256;
    }
    b[3] = (byte)i;

    return b;
}","//长度整数转化为大端四字节整数
static public byte[] int2Bytes(int i) 
{
    byte[] result = new byte[4];
    result[0] = (byte)((i >> 24) & 0xFF);
    result[1] = (byte)((i >> 16) & 0xFF);
    result[2] = (byte)((i >> 8) & 0xFF);
    result[3] = (byte)(i & 0xFF);
    return result;
}   ",968,True
"//增删改数据库，并返回影响的记录的条数
public int updateByPreparedStatement(String sql, List<Object>params)throws SQLException{
     boolean flag = false;
     int result = -1;
     pstmt = connection.prepareStatement(sql);
     int index = 1;
     if(params != null && !params.isEmpty()){
         for(int i=0; i<params.size(); i++){
             pstmt.setObject(index++, params.get(i));
         }
     }
     result = pstmt.executeUpdate();
     pstmt.close();
     return result;
 }","//增删改数据库，并返回影响的记录的条数
public int updateByPreparedStatement(String sql, List<Object>params)throws SQLException 
{
    pstmt = connection.prepareStatement(sql);
    if(params!=null){
        for(int i=0;i<params.size();i++){
            pstmt.setObject(i+1, params.get(i));
        }
    }
    return pstmt.executeUpdate();
}   ",973,True
"//查询数据库，返回满足条件的所有记录，每条记录保存一个map，字段名作为key，字段值作为value
public ArrayList<Map<String, Object>> findModeResult(String sql, List<Object> params) throws SQLException{
    ArrayList<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
    int index = 1;
    pstmt = connection.prepareStatement(sql);
    if(params != null && !params.isEmpty()){
        for(int i = 0; i<params.size(); i++){
            pstmt.setObject(index++, params.get(i));
        }
    }
    resultSet = pstmt.executeQuery();
    ResultSetMetaData metaData = resultSet.getMetaData();
    int cols_len = metaData.getColumnCount();
    while(resultSet.next()){
        Map<String, Object> map = new HashMap<String, Object>();
        for(int i=0; i<cols_len; i++){
            String cols_name = metaData.getColumnName(i+1);
            Object cols_value = resultSet.getObject(cols_name);
            if(cols_value == null){
                cols_value = """";
            }
            map.put(cols_name, cols_value);
        }
        list.add(map);
    }
    resultSet.close();
    pstmt.close();

    return list;
}","//查询数据库，返回满足条件的所有记录，每条记录保存一个map，字段名作为key，字段值作为value













public ArrayList<Map<String, Object>> findModeResult(String sql, List<Object> params) throws SQLException 
{
	ArrayList<Map<String, Object>> data = new ArrayList<Map<String, Object>>();
	Connection conn = null;
	PreparedStatement pstmt = null;
	ResultSet rs = null;
	try
	{
		conn = DBUtil.getConnection();
		pstmt = conn.prepareStatement(sql);
		if (params != null)
		{
			for (int i = 0; i < params.size(); i++)
			{
				pstmt.setObject(i + 1, params.get(i));
			}
		}
		rs = pstmt.executeQuery();
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		while (rs.next())
		{
			Map<String, Object> map = new HashMap<String, Object>();
			for (int i = 1; i <= columnCount; i++)
			{
				String columnName = rsmd.getColumnName(i);
				Object value = rs.getObject(columnName);
				map.put(columnName, value);
			}
			data.add(map);
		}
	}
	catch (SQLException e)
	{
		e.printStackTrace();
		throw e;
	}
	finally
	{
		DBUtil.closeAll(rs, pstmt, conn);
	}
	return data;
}   ",974,True
"//文件传输的根目录
@Override
    public void init(javax.servlet.ServletConfig config) throws ServletException{

        //System.out.println(""Log4JInitServlet 正在初始化 log4j日志设置信息"");
        String log4jLocation = config.getInitParameter(""log4j-properties-location"");
        fileServerRootDir = config.getInitParameter(""FileServerRootDir"");
        if (fileServerRootDir == null)
        {
            fileServerRootDir = ""/home/files"";
        }



        ServletContext sc = config.getServletContext();

        JsTea.context = sc;

        if (log4jLocation == null) {
            System.err.println(""*** 没有 log4j-properties-location 初始化的文件, 所以使用 BasicConfigurator初始化"");
            BasicConfigurator.configure();
        } else {
            String webAppPath = sc.getRealPath(""/"");
            String log4jProp = webAppPath + log4jLocation;
            File yoMamaYesThisSaysYoMama = new File(log4jProp);
            if (yoMamaYesThisSaysYoMama.exists()) {
                //System.out.println(""使用: "" + log4jProp+""初始化日志设置信息"");
                PropertyConfigurator.configure(log4jProp);
            } else {
                System.err.println(""*** "" + log4jProp + "" 文件没有找到， 所以使用 BasicConfigurator初始化"");
                BasicConfigurator.configure();
            }
        }





        super.init(config);
    }","//文件传输的根目录
@Override
    public void init(javax.servlet.ServletConfig config) throws ServletException 
{
    String tempPath = config.getInitParameter(""uploadPath"");
    if(tempPath != null && !tempPath.trim().equals(""""))
    {
        uploadPath = tempPath;
    }
}   ",975,True
"//������ֽ�bufת��Ϊ����int
static private int bytes2int(byte[] buf){
        int v = 0;
        int b0 = buf[0]; if (b0 < 0) { b0 += 256;}
        int b1 = buf[1]; if (b1 < 0) { b1 += 256;}
        int b2 = buf[2]; if (b2 < 0) { b2 += 256;}
        int b3 = buf[3]; if (b3 < 0) { b3 += 256;}
        v = b0 * (256*256*256) + b1 * (256*256) + b2*256 + b3;
        return v;
    }","//������ֽ�bufת��Ϊ����int
static private int bytes2int(byte[] buf) 
{
	int value = 0;
	for (int i = 0; i < 4; i++)
	{
		value |= (buf[i] & 0xff) << (8 * i);
	}
	return value;
}   ",977,True
"/**
 * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]
 *
 * @param rows desired number of text rows
 * @param cols desired numbor of text colums
 * @param width width of screen in pixels
 * @param height height of screen in pixels
 */
public synchronized void resizeComputed(int cols, int rows, int width, int height){
	float sizeDp = 8.0f;
	float step = 8.0f;
	float limit = 0.125f;

	int direction;

	while ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) < 0)
		sizeDp += step;

	if (direction == 0) {
		Log.d(""fontsize"", String.format(""Found match at %f"", sizeDp));
		return;
	}

	step /= 2.0f;
	sizeDp -= step;

	while ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) != 0
			&& step >= limit) {
		step /= 2.0f;
		if (direction > 0) {
			sizeDp -= step;
		} else {
			sizeDp += step;
		}
	}

	if (direction > 0)
		sizeDp -= step;

	this.columns = cols;
	this.rows = rows;
	setFontSize(sizeDp);
	forcedSize = true;
}","/**
 * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]
 *
 * @param rows desired number of text rows
 * @param cols desired numbor of text colums
 * @param width width of screen in pixels
 * @param height height of screen in pixels
 */
public synchronized void resizeComputed(int cols, int rows, int width, int height) 
{
    this.rows = rows;
    this.cols = cols;
    this.width = width;
    this.height = height;
    this.charWidth = width / cols;
    this.charHeight = height / rows;
    this.terminalWidth = width / charWidth;
    this.terminalHeight = height / charHeight;
    this.terminalSizeChanged = true;
}   ",984,False
"/** write data to our back end */
@Override
public void write(byte[] b) throws IOException{
	if (os != null)
		os.write(b);
}","/** write data to our back end */
@Override
public void write(byte[] b) throws IOException 
{
    if (this.closed)
    {
        throw new IOException(""Stream is closed"");
    }
    try
    {
        this.out.write(b);
    }
    catch (IOException e)
    {
        this.closed = true;
        throw e;
    }
}   ",985,True
"/**
 * Displays the child in the ViewPager at the requestedIndex and updates the prompts.
 *
 * @param requestedIndex the index of the terminal view to display
 */
private void setDisplayedTerminal(int requestedIndex){
	pager.setCurrentItem(requestedIndex);
	// set activity title
	setTitle(adapter.getPageTitle(requestedIndex));
	onTerminalChanged();
}","/**
 * Displays the child in the ViewPager at the requestedIndex and updates the prompts.
 *
 * @param requestedIndex the index of the terminal view to display
 */
private void setDisplayedTerminal(int requestedIndex) 
{
    if (mViewPager != null)
    {
        mViewPager.setCurrentItem(requestedIndex);
    }

    if (mPrompts != null)
    {
        mPrompts.setDisplayedPrompt(requestedIndex);
    }
}   ",987,True
"/**
 * Something changed in our parent {@link TerminalView}, maybe it's a new
 * parent, or maybe it's an updated font size. We should recalculate
 * terminal size information and request a PTY resize.
 */
public final synchronized void parentChanged(TerminalView parent){
	if (manager != null && !manager.isResizeAllowed()) {
		Log.d(TAG, ""Resize is not allowed now"");
		return;
	}

	this.parent = parent;
	final int width = parent.getWidth();
	final int height = parent.getHeight();

	// Something has gone wrong with our layout; we're 0 width or height!
	if (width <= 0 || height <= 0)
		return;

	ClipboardManager clipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE);
	keyListener.setClipboardManager(clipboard);

	if (!forcedSize) {
		// recalculate buffer size
		int newColumns, newRows;

		newColumns = width / charWidth;
		newRows = height / charHeight;

		// If nothing has changed in the terminal dimensions and not an intial
		// draw then don't blow away scroll regions and such.
		if (newColumns == columns && newRows == rows)
			return;

		columns = newColumns;
		rows = newRows;
		refreshOverlayFontSize();
	}

	// reallocate new bitmap if needed
	boolean newBitmap = (bitmap == null);
	if (bitmap != null)
		newBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height);

	if (newBitmap) {
		discardBitmap();
		bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
		canvas.setBitmap(bitmap);
	}

	// clear out any old buffer information
	defaultPaint.setColor(Color.BLACK);
	canvas.drawPaint(defaultPaint);

	// Stroke the border of the terminal if the size is being forced;
	if (forcedSize) {
		int borderX = (columns * charWidth) + 1;
		int borderY = (rows * charHeight) + 1;

		defaultPaint.setColor(Color.GRAY);
		defaultPaint.setStrokeWidth(0.0f);
		if (width >= borderX)
			canvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint);
		if (height >= borderY)
			canvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint);
	}

	try {
		// request a terminal pty resize
		synchronized (buffer) {
			buffer.setScreenSize(columns, rows, true);
		}

		if (transport != null)
			transport.setDimensions(columns, rows, width, height);
	} catch (Exception e) {
		Log.e(TAG, ""Problem while trying to resize screen or PTY"", e);
	}

	// redraw local output if we don't have a sesson to receive our resize request
	if (transport == null) {
		synchronized (localOutput) {
			((vt320) buffer).reset();

			for (String line : localOutput)
				((vt320) buffer).putString(line);
		}
	}

	// force full redraw with new buffer size
	fullRedraw = true;
	redraw();

	parent.notifyUser(String.format(""%d x %d"", columns, rows));

	Log.i(TAG, String.format(""parentChanged() now width=%d, height=%d"", columns, rows));
}","/**
 * Something changed in our parent {@link TerminalView}, maybe it's a new
 * parent, or maybe it's an updated font size. We should recalculate
 * terminal size information and request a PTY resize.
 */
public final synchronized void parentChanged(TerminalView parent) 
{
    if (parent != this.parent) {
        this.parent = parent;
        recalculateTerminalSize();
        requestPTYResize();
    }
}   ",988,True
"/**
 * @param bridge
 */
private void closeBridge(final TerminalBridge bridge){
	updateEmptyVisible();
	updatePromptVisible();

	// If we just closed the last bridge, go back to the previous activity.
	if (pager.getChildCount() == 0) {
		finish();
	}
}","/**
 * @param bridge
 */
private void closeBridge(final TerminalBridge bridge) 
{
    if (bridge != null)
    {
        bridge.close();
    }
}   ",989,True
"/**
 * Force disconnection of this terminal bridge.
 */
public void dispatchDisconnect(boolean immediate){
	// We don't need to do this multiple times.
	synchronized (this) {
		if (disconnected && !immediate)
			return;

		disconnected = true;
	}

	// Cancel any pending prompts.
	promptHelper.cancelPrompt();

	// disconnection request hangs if we havent really connected to a host yet
	// temporary fix is to just spawn disconnection into a thread
	Thread disconnectThread = new Thread(new Runnable() {
		@Override
		public void run() {
			if (transport != null && transport.isConnected())
				transport.close();
		}
	});
	disconnectThread.setName(""Disconnect"");
	disconnectThread.start();

	if (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) {
		awaitingClose = true;
		triggerDisconnectListener();
	} else {
		{
			final String line = manager.res.getString(R.string.alert_disconnect_msg);
			((vt320) buffer).putString(""\r\n"" + line + ""\r\n"");
		}
		if (host.getStayConnected()) {
			manager.requestReconnect(this);
			return;
		}
		Thread disconnectPromptThread = new Thread(new Runnable() {
			@Override
			public void run() {
				Boolean result = promptHelper.requestBooleanPrompt(null,
						manager.res.getString(R.string.prompt_host_disconnected));
				if (result == null || result) {
					awaitingClose = true;
					triggerDisconnectListener();
				}
			}
		});
		disconnectPromptThread.setName(""DisconnectPrompt"");
		disconnectPromptThread.setDaemon(true);
		disconnectPromptThread.start();
	}
}","/**
 * Force disconnection of this terminal bridge.
 */
public void dispatchDisconnect(boolean immediate) 
{
    if (immediate)
    {
        if (bridge != null)
        {
            bridge.disconnect();
        }
    }
    else
    {
        if (bridge != null)
        {
            bridge.scheduleDisconnect();
        }
    }
}   ",990,False
"/**
 * @param protocol
 * @return
 */
public static AbsTransport getTransport(String protocol){
	if (SSH.getProtocolName().equals(protocol)) {
		return new SSH();
	} else if (Telnet.getProtocolName().equals(protocol)) {
		return new Telnet();
	} else if (Local.getProtocolName().equals(protocol)) {
		return new Local();
	} else {
		return null;
	}
}","/**
 * @param protocol
 * @return
 */
public static AbsTransport getTransport(String protocol) 
{
    if (protocol.equalsIgnoreCase(""udp""))
    {
        return new UdpTransport();
    }
    else if (protocol.equalsIgnoreCase(""tcp""))
    {
        return new TcpTransport();
    }
    else
    {
        throw new IllegalArgumentException(""Invalid protocol: "" + protocol);
    }
}   ",992,False
"/* (non-Javadoc)
 * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)
 */
@Override
public void setColor(int index, int red, int green, int blue){
	// Don't allow the system colors to be overwritten for now. May violate specs.
	if (index < color.length && index >= 16)
		color[index] = 0xff000000 | red << 16 | green << 8 | blue;
}","/* (non-Javadoc)
 * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)
 */
@Override
public void setColor(int index, int red, int green, int blue) 
{
    if (index < 0 || index >= 16)
    {
        return;
    }

    if (red < 0 || red > 255 || green < 0 || green > 255 || blue < 0 || blue > 255)
    {
        return;
    }

    this.colorMap[index] = new Color(red, green, blue);
}   ",994,True
"/**
 * Somehow our parent {@link TerminalView} was destroyed. Now we don't need
 * to redraw anywhere, and we can recycle our internal bitmap.
 */
public synchronized void parentDestroyed(){
	parent = null;
	discardBitmap();
}","/**
 * Somehow our parent {@link TerminalView} was destroyed. Now we don't need
 * to redraw anywhere, and we can recycle our internal bitmap.
 */
public synchronized void parentDestroyed() 
{
    if (mBitmap != null)
    {
        mBitmap.recycle();
        mBitmap = null;
    }
}   ",996,True
"/**
 * @return
 */
public List<String> scanForURLs(){
	List<String> urls = new ArrayList<>();

	char[] visibleBuffer = new char[buffer.height * buffer.width];
	for (int l = 0; l < buffer.height; l++)
		System.arraycopy(buffer.charArray[buffer.windowBase + l], 0,
				visibleBuffer, l * buffer.width, buffer.width);

	Matcher urlMatcher = PatternHolder.urlPattern.matcher(new String(visibleBuffer));
	while (urlMatcher.find())
		urls.add(urlMatcher.group());

	return urls;
}","/**
 * @return
 */

public List<String> scanForURLs() 
{
    List<String> urls = new ArrayList<String>();
    String url = null;
    while (scanner.hasNextLine())
    {
        url = scanner.nextLine();
        urls.add(url);
    }
    return urls;
}   ",997,False
"/**
 * Called whenever the displayed terminal is changed.
 */
private void onTerminalChanged(){
	View terminalNameOverlay = findCurrentView(R.id.terminal_name_overlay);
	if (terminalNameOverlay != null)
		terminalNameOverlay.startAnimation(fade_out_delayed);
	updateDefault();
	updatePromptVisible();
	ActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);
}","/**
 * Called whenever the displayed terminal is changed.
 */
private void onTerminalChanged() 
{
    if (terminal != null)
    {
        terminal.removeTerminalListener(this);
    }

    terminal = getTerminal();
    if (terminal != null)
    {
        terminal.addTerminalListener(this);
    }
}   ",999,True
"/**
 * 考虑到Android 8.0在后台调用startService时会抛出IllegalStateException
 *
 * @param context
 * @param intent
 */
public static void startServiceSafely(Context context, Intent intent){
    if (null == context) {
        return;
    }
    try {
        context.startService(intent);
    } catch (IllegalStateException ex) {
        ex.printStackTrace();
    }
}","/**
 * 考虑到Android 8.0在后台调用startService时会抛出IllegalStateException
 *
 * @param context
 * @param intent
 */
public static void startServiceSafely(Context context, Intent intent) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
    {
        context.startForegroundService(intent);
    } else
    {
        context.startService(intent);
    }
}   ",1000,True
"//考虑到混淆，直接写类的完整路径名容易导致两边不一致，所以不推荐使用这种方式!
@Deprecated
public static void registerLocalService(String serviceCanonicalName, Object serviceImpl){
    if (TextUtils.isEmpty(serviceCanonicalName) || null == serviceImpl) {
        return;
    }
    LocalServiceHub.getInstance().registerService(serviceCanonicalName, serviceImpl);
}","//考虑到混淆，直接写类的完整路径名容易导致两边不一致，所以不推荐使用这种方式!
@Deprecated
public static void registerLocalService(String serviceCanonicalName, Object serviceImpl) 
{
    try
    {
        Class<?> serviceClass = Class.forName(serviceCanonicalName);
        registerLocalService(serviceClass, serviceImpl);
    }
    catch (ClassNotFoundException e)
    {
        e.printStackTrace();
    }
}   ",1002,True
"//使用方式一:只要实现BaseCallback这个抽象类即可，在主线程回调
private void useBuyAppleService(){
    //IBuyApple buyApple = IBuyApple.Stub.asInterface(Andromeda.getInstance().getRemoteService(IBuyApple.class));
    IBuyApple buyApple = IBuyApple.Stub.asInterface(Andromeda.with(this).getRemoteService(IBuyApple.class));
    try {
        //buyApple.buyApple(10, new MyCallback());
        buyApple.buyAppleOnNet(10, new BaseCallback() {
            @Override
            public void onSucceed(Bundle result) {
                Log.d(TAG, ""BuyApple-->onSuccess,thread:"" + Thread.currentThread().getName() + "",result:"" + result.getInt(""Result""));
            }

            @Override
            public void onFailed(String reason) {
                Log.d(TAG, ""BuyApple-->onFail,thread:"" + Thread.currentThread().getName() + "",reason:"" + reason);
            }
        });

    } catch (RemoteException ex) {
        ex.printStackTrace();
    }
}","//使用方式一:只要实现BaseCallback这个抽象类即可，在主线程回调
private void useBuyAppleService() 
{
    BuyAppleService buyAppleService = new BuyAppleService();
    buyAppleService.setCallback(new BaseCallback() {
        @Override
        public void onSuccess(Object obj) {
            System.out.println(""购����果成功"");
        }

        @Override
        public void onFail(Object obj) {
            System.out.println(""购����果失败"");
        }
    });
    buyAppleService.buyApple();
}   ",1003,False
"//这里不能按照serviceCanonicalName来区分，而是要按照target service来划分，如果targetService一样，那就没必要再绑定
public synchronized String bindAction(Context context, String serverProcessName){
    Logger.d(""ConnectionManager-->bindAction,serverProcessName:"" + serverProcessName);
    Intent intent = StubServiceMatcher.matchIntent(context, serverProcessName);
    if (null == intent) {
        Logger.d(""match intent is null"");
        return null;
    }

    final String commuStubServiceName = getCommuStubServiceName(intent);
    ConnectionBean bean = connectionCache.get(commuStubServiceName);
    ConnectionBean waitingBean = waitingFlightConnCache.get(commuStubServiceName);
    if (null == bean && waitingBean == null) {
        Logger.d(""first create ServiceConnectioin for "" + commuStubServiceName);
        final ServiceConnection connection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Logger.d(""onServiceConnected,name:"" + commuStubServiceName);
                ConnectionBean connectionBean = waitingFlightConnCache.remove(commuStubServiceName);
                if (connectionBean == null) {
                    //TODO 是否要直接throw RuntimeException呢?
                    Logger.e(""No ConnectionBean in waitingFlightCache!"");
                } else {
                    connectionCache.put(commuStubServiceName, connectionBean);
                }
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Logger.d(""onServiceDisconnected,name:"" + commuStubServiceName);
                //如果发生了这种情况，就要从缓存中移除掉!
                connectionCache.remove(commuStubServiceName);
                waitingFlightConnCache.remove(commuStubServiceName);
            }
        };
        bean = new ConnectionBean(connection);
        waitingFlightConnCache.put(commuStubServiceName, bean);
        context.bindService(intent, connection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT);
    } else if (waitingBean != null) {
        waitingBean.increaseRef();
    } else {
        bean.increaseRef();
    }
    return commuStubServiceName;
}","//这里不能按照serviceCanonicalName来区分，而是要按照target service来划分，如果targetService一样，那就没必要再绑定
public synchronized String bindAction(Context context, String serverProcessName) 
{
    if (isBinded)
    {
        return null;
    }
    isBinded = true;
    String action = ""com.leo.action."" + serverProcessName;
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(action);
    context.registerReceiver(receiver, intentFilter);
    return action;
}   ",1004,False
"//给同进程的DispatcherService调用的和远程调用
@Override
public synchronized void registerRemoteTransfer(int pid, IBinder transferBinder){
    if (pid < 0) {
        return;
    }
    eventDispatcher.registerRemoteTransferLocked(pid, transferBinder);
}","//给同进程的DispatcherService调用的和远程调用
@Override
public synchronized void registerRemoteTransfer(int pid, IBinder transferBinder) 
{
    if (mRemoteTransferMap == null) {
        mRemoteTransferMap = new HashMap<Integer, IBinder>();
    }
    mRemoteTransferMap.put(pid, transferBinder);
}   ",1005,True
"//TODO 这样做有个弊端，就是没做到懒加载
public static void init(Context context){
    getInstance().setContext(context);

    getInstance().sendRegisterInfo();
}","//TODO 这样做有个弊端，就是没做到懒加载
public static void init(Context context) 
{
    if (null == mInstance)
    {
        synchronized (ImageLoader.class)
        {
            if (null == mInstance)
            {
                mInstance = new ImageLoader(context);
            }
        }
    }
}   ",1007,True
"/**
 * Sets a hint for which fragment is our parent which allows fragment to return correct
 * information about its parents before pending fragment transactions have been executed.
 *
 * @param parentFragmentHint
 */
public void setParentFragmentHint(Fragment parentFragmentHint){
    Logger.d(""SupportRemoteManagerFragment-->setParentFragmentHint()"");
    this.parentFragmentHint = parentFragmentHint;
    if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
        registerFragmentWithRoot(parentFragmentHint.getActivity());
    }
}","/**
 * Sets a hint for which fragment is our parent which allows fragment to return correct
 * information about its parents before pending fragment transactions have been executed.
 *
 * @param parentFragmentHint
 */
public void setParentFragmentHint(Fragment parentFragmentHint) 
{
    if (parentFragmentHint == null)
    {
        mParentFragmentHint = null;
    }
    else
    {
        mParentFragmentHint = new WeakReference<>(parentFragmentHint);
    }
}   ",1010,True
"////////////////end of event///////////////////////////
@Override
public synchronized void registerDispatcher(IBinder dispatcherBinder) throws RemoteException{
    Logger.d(""RemoteTransfer-->registerDispatcher"");
    //一般从发出注册信息到这里回调就6ms左右，所以绝大部分时候走的都是这个逻辑。
    dispatcherBinder.linkToDeath(new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            Logger.d(""RemoteTransfer-->dispatcherBinder binderDied"");
            resetDispatcherProxy();
        }
    }, 0);
    dispatcherProxy = IDispatcher.Stub.asInterface(dispatcherBinder);
    notifyAll();
}","////////////////end of event///////////////////////////
@Override
public synchronized void registerDispatcher(IBinder dispatcherBinder) throws RemoteException 
{
    if (dispatcherBinder == null) {
        throw new NullPointerException(""null dispatcher"");
    }
    if (mDispatcher != null) {
        throw new IllegalStateException(""dispatcher already set"");
    }
    mDispatcher = IDispatcher.Stub.asInterface(dispatcherBinder);
    notifyAll();
}   ",1011,False
"/**
 * 要注销本进程的某个服务,注意它与unregisterRemoteService()的区别!
 * 这个方法表示要注销本进程的某个服务
 *
 * @param serviceCanonicalName
 */
@Override
public synchronized void unregisterStubService(String serviceCanonicalName){
    initDispatchProxyLocked();
    serviceTransfer.unregisterStubServiceLocked(serviceCanonicalName, context, dispatcherProxy);
}","/**
 * 要注销本进程的某个服务,注意它与unregisterRemoteService()的区别!
 * 这个方法表示要注销本进程的某个服务
 *
 * @param serviceCanonicalName
 */
@Override
public synchronized void unregisterStubService(String serviceCanonicalName) 
{
    if (mStubServiceMap.containsKey(serviceCanonicalName))
    {
        mStubServiceMap.remove(serviceCanonicalName);
    }
}   ",1012,True
"//考虑到混淆，不推荐使用这种方式
@Deprecated
public static <T extends IBinder> void registerRemoteService(String serviceCanonicalName, T stubBinder){
    if (TextUtils.isEmpty(serviceCanonicalName) || null == stubBinder) {
        return;
    }
    RemoteTransfer.getInstance().registerStubService(serviceCanonicalName, stubBinder);
}","//考虑到混淆，不推荐使用这种方式
@Deprecated
public static <T extends IBinder> void registerRemoteService(String serviceCanonicalName, T stubBinder) 
{
    if (mRemoteServiceMap == null)
    {
        mRemoteServiceMap = new HashMap<>();
    }
    mRemoteServiceMap.put(serviceCanonicalName, stubBinder);
}   ",1013,True
"//让ServiceDispatcher反向注册到当前进程
private synchronized void sendRegisterInfo(){
    if (dispatcherProxy == null) {
        //后面考虑还是采用""has-a""的方式会更好
        BinderWrapper wrapper = new BinderWrapper(this.asBinder());
        Intent intent = new Intent(context, DispatcherService.class);
        intent.setAction(Constants.DISPATCH_REGISTER_SERVICE_ACTION);
        intent.putExtra(Constants.KEY_REMOTE_TRANSFER_WRAPPER, wrapper);
        intent.putExtra(Constants.KEY_PID, android.os.Process.myPid());
        ServiceUtils.startServiceSafely(context, intent);
    }
}","//让ServiceDispatcher反向注册到当前进程
private synchronized void sendRegisterInfo() 
{
    if (mServiceDispatcher != null) {
        try {
            mServiceDispatcher.sendRegisterInfo();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}   ",1014,False
"/**
 * 这是最可靠的一种获取当前进程名称的方式
 *
 * @param context
 * @return
 */
public static String getProcessName(Context context){
    if (!TextUtils.isEmpty(sProcessName)) {
        return sProcessName;
    }
    int count = 0;
    do {
        String processName = getProcessNameImpl(context);
        if (!TextUtils.isEmpty(processName)) {
            sProcessName = processName;
            return processName;
        }
    } while (count++ < 3);

    return null;
}","/**
 * 这是最可靠的一种获取当前进程名称的方式
 *
 * @param context
 * @return
 */

public static String getProcessName(Context context) 
{
    int pid = android.os.Process.myPid();
    ActivityManager mActivityManager = (ActivityManager) context
            .getSystemService(Context.ACTIVITY_SERVICE);
    for (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager
            .getRunningAppProcesses())
    {
        if (appProcess.pid == pid)
        {
            return appProcess.processName;
        }
    }
    return null;
}   ",1016,False
"//TODO 注意:这个回调是在binder线程中!后续版本引入指定的threadMode!
@Override
public void onNotify(Event event){
    String name = event.getName();
    ToastUtil.postToast(this, ""get event whose name is "" + name);
    Logger.d(""MainActivity-->event name:"" + name);
    if (event.getData() == null) {
        return;
    }
    String result = event.getData().getString(""Result"");
    Logger.d(""MainActivity-->event result:"" + result);
}","//TODO 注意:这个回调是在binder线程中!后续版本引入指定的threadMode!
@Override
public void onNotify(Event event) 
{
    if (event.getEventType() == Event.EventType.ON_NOTIFY)
    {
        if (event.getEventId() == EventId.EVENT_ID_NOTIFY)
        {
            NotifyEvent notifyEvent = (NotifyEvent) event;
            String msg = notifyEvent.getMsg();
            Log.d(TAG, ""onNotify: "" + msg);
        }
    }
}   ",1018,False
"//在Fragment不可见时，回调的是onDestroyView()而不是onDestroy()，不过由于它仍旧在缓存中，所以此时确实不能释放连接，而是要等到onDestroy()时再释放
@Override
public void onDestroyView(){
    Logger.d(TAG + ""-->onDestroyView()"");
    super.onDestroyView();
}","//在Fragment不可见时，回调的是onDestroyView()而不是onDestroy()，不过由于它仍旧在缓存中，所以此时确实不能释放连接，而是要等到onDestroy()时再释放
@Override
public void onDestroyView() 
{
    super.onDestroyView();
    if (mUnbinder != null)
    {
        mUnbinder.unbind();
    }
}   ",1019,True
"/**
 * 设置状态
 *
 * @param status
 * @param showView 是否展示当前View
 */
public void setState(State status, boolean showView){
    if (mState == status) {
        return;
    }
    mState = status;

    switch (status) {
        case Normal:
            setOnClickListener(null);
            if (mLoadingView != null) {
                mLoadingView.setVisibility(GONE);
            }

            if (mTheEndView != null) {
                mTheEndView.setVisibility(GONE);
            }

            if (mNetworkErrorView != null) {
                mNetworkErrorView.setVisibility(GONE);
            }

            break;
        case Loading:
            setOnClickListener(null);
            if (mTheEndView != null) {
                mTheEndView.setVisibility(GONE);
            }

            if (mNetworkErrorView != null) {
                mNetworkErrorView.setVisibility(GONE);
            }

            if (mLoadingView == null) {
                ViewStub viewStub = (ViewStub) findViewById(R.id.loading_viewstub);
                mLoadingView = viewStub.inflate();

                mProgressView = (SimpleViewSwitcher) mLoadingView.findViewById(R.id.loading_progressbar);
                mLoadingText = (TextView) mLoadingView.findViewById(R.id.loading_text);
            }

            mLoadingView.setVisibility(showView ? VISIBLE : GONE);

            mProgressView.setVisibility(View.VISIBLE);
            mProgressView.removeAllViews();
            mProgressView.addView(initIndicatorView(style));

            mLoadingText.setText(TextUtils.isEmpty(loadingHint) ? getResources().getString(R.string.list_footer_loading) : loadingHint);
            mLoadingText.setTextColor(ContextCompat.getColor(getContext(), hintColor));

            break;
        case NoMore:
            setOnClickListener(null);
            if (mLoadingView != null) {
                mLoadingView.setVisibility(GONE);
            }

            if (mNetworkErrorView != null) {
                mNetworkErrorView.setVisibility(GONE);
            }

            if (mTheEndView == null) {
                ViewStub viewStub = (ViewStub) findViewById(R.id.end_viewstub);
                mTheEndView = viewStub.inflate();

                mNoMoreText = (TextView) mTheEndView.findViewById(R.id.loading_end_text);
            } else {
                mTheEndView.setVisibility(VISIBLE);
            }

            mTheEndView.setVisibility(showView ? VISIBLE : GONE);
            mNoMoreText.setText(TextUtils.isEmpty(noMoreHint) ? getResources().getString(R.string.list_footer_end) : noMoreHint);
            mNoMoreText.setTextColor(ContextCompat.getColor(getContext(), hintColor));
            break;
        case NetWorkError:
            if (mLoadingView != null) {
                mLoadingView.setVisibility(GONE);
            }

            if (mTheEndView != null) {
                mTheEndView.setVisibility(GONE);
            }

            if (mNetworkErrorView == null) {
                ViewStub viewStub = (ViewStub) findViewById(R.id.network_error_viewstub);
                mNetworkErrorView = viewStub.inflate();
                mNoNetWorkText = (TextView) mNetworkErrorView.findViewById(R.id.network_error_text);
            } else {
                mNetworkErrorView.setVisibility(VISIBLE);
            }

            mNetworkErrorView.setVisibility(showView ? VISIBLE : GONE);
            mNoNetWorkText.setText(TextUtils.isEmpty(noNetWorkHint) ? getResources().getString(R.string.list_footer_network_error) : noNetWorkHint);
            mNoNetWorkText.setTextColor(ContextCompat.getColor(getContext(), hintColor));
            break;
        default:
            break;
    }
}","/**
 * 设置状态
 *
 * @param status
 * @param showView 是否展示当前View
 */
public void setState(State status, boolean showView) 
{
    this.status = status;
    if (showView)
    {
        switch (status)
        {
            case LOADING:
                showLoadingView();
                break;
            case ERROR:
                showErrorView();
                break;
            case EMPTY:
                showEmptyView();
                break;
            case CONTENT:
                showContentView();
                break;
        }
    }
}   ",1022,False
"/**
 * make animation to start or end when target
 * view was be Visible or Gone or Invisible.
 * make animation to cancel when target view
 * be onDetachedFromWindow.
 * @param animStatus
 */
public void setAnimationStatus(AnimStatus animStatus){
    if (mAnimators==null){
        return;
    }
    int count=mAnimators.size();
    for (int i = 0; i < count; i++) {
        Animator animator=mAnimators.get(i);
        boolean isRunning=animator.isRunning();
        switch (animStatus){
            case START:
                if (!isRunning){
                    animator.start();
                }
                break;
            case END:
                if (isRunning){
                    animator.end();
                }
                break;
            case CANCEL:
                if (isRunning){
                    animator.cancel();
                }
                break;
        }
    }
}","/**
 * make animation to start or end when target
 * view was be Visible or Gone or Invisible.
 * make animation to cancel when target view
 * be onDetachedFromWindow.
 * @param animStatus
 */
public void setAnimationStatus(AnimStatus animStatus) 
{
    if (this.animStatus == animStatus)
    {
        return;
    }
    this.animStatus = animStatus;
    if (animStatus == AnimStatus.START)
    {
        startAnimation();
    }
    else if (animStatus == AnimStatus.END)
    {
        endAnimation();
    }
    else if (animStatus == AnimStatus.CANCEL)
    {
        cancelAnimation();
    }
}   ",1023,True
"/**
 * 本方法不再推荐使用，请使用自定义LoadingFooter的方式实现
 * 设置Footer文字颜色
 * @param indicatorColor
 * @param hintColor
 * @param backgroundColor
 */
@Deprecated
public void setFooterViewColor(int indicatorColor, int hintColor, int backgroundColor){
    if (mLoadMoreFooter instanceof LoadingFooter) {
        LoadingFooter loadingFooter = ((LoadingFooter) mLoadMoreFooter);
        loadingFooter.setIndicatorColor(ContextCompat.getColor(getContext(),indicatorColor));
        loadingFooter.setHintTextColor(hintColor);
        loadingFooter.setViewBackgroundColor(backgroundColor);
    }
}","/**
 * 本方法不再推荐使用，请使用自定义LoadingFooter的方式实现
 * 设置Footer文字颜色
 * @param indicatorColor
 * @param hintColor
 * @param backgroundColor
 */
@Deprecated
public void setFooterViewColor(int indicatorColor, int hintColor, int backgroundColor) 
{
    if (mFooterView != null)
    {
        mFooterView.setIndicatorColor(indicatorColor);
        mFooterView.setHintTextColor(hintColor);
        mFooterView.setBackgroundColor(backgroundColor);
    }
}   ",1026,False
"/**
 * 设置FooterView
 *
 * @param recyclerView
 * @param view
 */
@Deprecated
public static void setFooterView(RecyclerView recyclerView, View view){
    RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();

    if (outerAdapter == null || !(outerAdapter instanceof LuRecyclerViewAdapter)) {
        return;
    }

    LuRecyclerViewAdapter luRecyclerViewAdapter = (LuRecyclerViewAdapter) outerAdapter;

    if (luRecyclerViewAdapter.getFooterViewsCount() > 0) {
        luRecyclerViewAdapter.removeFooterView();
    }
    luRecyclerViewAdapter.addFooterView(view);
}","/**
 * 设置FooterView
 *
 * @param recyclerView
 * @param view
 */
@Deprecated
public static void setFooterView(RecyclerView recyclerView, View view) 
{
    RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();

    if (outerAdapter == null || !(outerAdapter instanceof RecyclerViewAdapter))
    {
        throw new RuntimeException(""must use RecyclerViewAdapter"");
    }

    RecyclerViewAdapter recyclerViewAdapter = (RecyclerViewAdapter) outerAdapter;
    if (recyclerViewAdapter.getFooterViewsCount() > 0)
    {
        recyclerViewAdapter.removeFooterView();
    }
    recyclerViewAdapter.addFooterView(view);
}   ",1027,False
"/**
 * 到底加载是否可用
 */
public void setLoadMoreEnabled(boolean enabled){
    if(mWrapAdapter == null){
        throw new NullPointerException(""LRecyclerViewAdapter cannot be null, please make sure the variable mWrapAdapter have been initialized."");
    }
    mLoadMoreEnabled = enabled;
    if (!enabled) {
        mWrapAdapter.removeFooterView();
    }
}","/**
 * 到底加载是否可用
 */
public void setLoadMoreEnabled(boolean enabled) 
{
    if (enabled)
    {
        mLoadMoreView.setVisibility(View.VISIBLE);
    }
    else
    {
        mLoadMoreView.setVisibility(View.GONE);
    }
}   ",1030,True
"/**
 * 此方法主要是为了满足数据不满一屏幕或者数据小于pageSize的情况下，是否显示footview
 * 在分页情况下使用refreshComplete(int pageSize, int total, boolean false)就相当于refreshComplete(int pageSize, int total)
 * @param pageSize 一页加载的数量
 * @param total 总数
 * @param isShowFootView  是否需要显示footview（前提条件是：getItemCount() < pageSize）
 */
public void refreshComplete(int pageSize, int total, boolean isShowFootView){
    this.mPageSize = pageSize;
    if (mRefreshing) {
        mRefreshing = false;
        mRefreshHeader.refreshComplete();
        if (isShowFootView) {
            mFootView.setVisibility(VISIBLE);
        } else {
            if(mWrapAdapter.getInnerAdapter().getItemCount() < pageSize) {
                mFootView.setVisibility(GONE);
                mWrapAdapter.removeFooterView();
            } else {
                if (mWrapAdapter.getFooterViewsCount() == 0) {
                    mWrapAdapter.addFooterView(mFootView);
                }
            }
        }
    } else if (mLoadingData) {
        mLoadingData = false;
        mLoadMoreFooter.onComplete();
    }
    if (pageSize < total) {
        isNoMore = false;
    }
    //处理特殊情况 最后一行显示出来了加载更多的view的一部分
    if (mWrapAdapter.getInnerAdapter().getItemCount() == mPageSize) {
        isCritical = true;
    } else {
        isCritical = false;
    }
}","/**
 * 此方法主要是为了满足数据不满一屏幕或者数据小于pageSize的情况下，是否显示footview
 * 在分页情况下使用refreshComplete(int pageSize, int total, boolean false)就相当于refreshComplete(int pageSize, int total)
 * @param pageSize 一页加载的数量
 * @param total 总数
 * @param isShowFootView  是否需要显示footview（前提条件是：getItemCount() < pageSize）
 */
public void refreshComplete(int pageSize, int total, boolean isShowFootView) 
{
    if (isShowFootView)
    {
        if (getItemCount() < pageSize)
        {
            isShowFootView = false;
        }
    }
    this.isShowFootView = isShowFootView;
    this.pageSize = pageSize;
    this.total = total;
    notifyDataSetChanged();
}   ",1033,False
"/**
 * Sets the divider colour
 *
 * @param resource the colour resource id
 * @return the current instance of the Builder
 */
public Builder setColorResource(@ColorRes int resource){
    setColor(ContextCompat.getColor(mContext, resource));
    return this;
}","/**
 * Sets the divider colour
 *
 * @param resource the colour resource id
 * @return the current instance of the Builder
 */
public Builder setColorResource(@ColorRes int resource) 
{
    this.mColor = ContextCompat.getColor(this.mContext, resource);
    return this;
}   ",1034,True
"/**
 * 移除FooterView
 *
 * @param recyclerView
 */
public static void removeFooterView(RecyclerView recyclerView){

    RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();

    if (outerAdapter != null && outerAdapter instanceof LuRecyclerViewAdapter) {

        int footerViewCounter = ((LuRecyclerViewAdapter) outerAdapter).getFooterViewsCount();
        if (footerViewCounter > 0) {
            ((LuRecyclerViewAdapter) outerAdapter).removeFooterView();
        }
    }
}","/**
 * 移除FooterView
 *
 * @param recyclerView
 */
public static void removeFooterView(RecyclerView recyclerView) 
{
    RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
    if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter)
    {
        HeaderAndFooterRecyclerViewAdapter headerAndFooterAdapter = (HeaderAndFooterRecyclerViewAdapter) outerAdapter;
        if (headerAndFooterAdapter.getFooterViewsCount() > 0)
        {
            headerAndFooterAdapter.removeFooterView();
        }
    }
}   ",1035,False
"//通过dp设置水平间距
public Builder setHorizontal(@DimenRes int horizontal){
    this.mHorizontal = mResources.getDimensionPixelSize(horizontal);
    return this;
}","//通过dp设置水平间距
public Builder setHorizontal(@DimenRes int horizontal) 
{
    if (horizontal > 0)
    {
        this.horizontal = context.getResources().getDimensionPixelSize(horizontal);
    }
    return this;
}   ",1039,True
"/**
 * @param crawlPath crawlPath is the path of the directory which maintains
 *                  information of this crawler
 * @param autoParse if autoParse is true,BreadthCrawler will auto extract
 *                  links which match regex rules from pag
 */
public DemoAnnotatedManualNewsCrawler(String crawlPath, boolean autoParse){
    super(crawlPath, autoParse);
    // add 5 start pages and set their type to ""list""
    //""list"" is not a reserved word, you can use other string instead
    this.addSeedAndReturn(""https://blog.github.com/"").type(""list"");
    for(int pageIndex = 2; pageIndex <= 5; pageIndex++) {
        String seedUrl = String.format(""https://blog.github.com/page/%d/"", pageIndex);
        this.addSeed(seedUrl, ""list"");
    }

    setThreads(50);
    getConf().setTopN(100);

    //enable resumable mode
    //setResumable(true);
}","/**
 * @param crawlPath crawlPath is the path of the directory which maintains
 *                  information of this crawler
 * @param autoParse if autoParse is true,BreadthCrawler will auto extract
 *                  links which match regex rules from pag
 */
public DemoAnnotatedManualNewsCrawler(String crawlPath, boolean autoParse) 
{
    super(crawlPath, autoParse);
    this.getConf().setTopN(50);
    this.getConf().setResumable(false);
}   ",1040,True
"/**
 * 添加一个正正则规则
 * @param positiveregex
 * @return 自身
 */
public RegexRule addPositive(String positiveregex){
    positive.add(positiveregex);
    return this;
}","/**
 * 添加一个正正则规则
 * @param positiveregex
 * @return 自身
 */
public RegexRule addPositive(String positiveregex) 
{
    if (positiveregex != null && positiveregex.length() > 0)
    {
        this.positiveRegex.add(positiveregex);
    }
    return this;
}   ",1042,True
"/**
 * construct the Bing Search url by the search keyword and the pageIndex
 * @param keyword
 * @param pageIndex
 * @return the constructed url
 * @throws Exception
 */
public static String createBingUrl(String keyword, int pageIndex) throws Exception{
    int first = pageIndex * 10 - 9;
    keyword = URLEncoder.encode(keyword, ""utf-8"");
    return String.format(""http://cn.bing.com/search?q=%s&first=%s"", keyword, first);
}","/**
 * construct the Bing Search url by the search keyword and the pageIndex
 * @param keyword
 * @param pageIndex
 * @return the constructed url
 * @throws Exception
 */
public static String createBingUrl(String keyword, int pageIndex) throws Exception 
{
    String encodedKeyword = URLEncoder.encode(keyword, ""UTF-8"");
    String url = String.format(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"", encodedKeyword, (pageIndex - 1) * 10);
    return url;
}   ",1044,True
"/*
    该例子利用正则控制爬虫的遍历，
    另一种常用遍历方法可参考DemoTypeCrawler
*/
public TutorialCrawler(String crawlPath, boolean autoParse){
    super(crawlPath, autoParse);
    
    addSeed(""https://blog.csdn.net/"");
    addRegex(""https://blog.csdn.net/.*/article/details/.*"");
    addRegex(""-.*#.*"");
    
    //需要抓取图片时设置为true，并加入图片的正则规则
//        setParseImg(true);
    
    //设置每个线程的抓取间隔（毫秒）
//        setExecuteInterval(1000);
    getConf().setExecuteInterval(1000);
    
    //设置线程数
    setThreads(30);
}","/*
    该例子利用正则控制爬虫的遍历，
    另一种常用遍历方法可参考DemoTypeCrawler
*/
public TutorialCrawler(String crawlPath, boolean autoParse) 
{
    super(crawlPath, autoParse);
}   ",1046,True
"/*
    该例子利用WebCollector 2.50新特性NextFilter过滤探测到的URL
 */
public DemoNextFilter(String crawlPath, boolean autoParse){
    super(crawlPath, autoParse);
    addSeed(""https://blog.csdn.net/"");
    addRegex("".*"");
    //设置线程数
    setThreads(30);
}","/*
    该例子利用WebCollector 2.50新特性NextFilter过滤探测到的URL
 */
public DemoNextFilter(String crawlPath, boolean autoParse) 
{
    super(crawlPath, autoParse);
    /*start pages*/
    for (int i = 0; i < 10; i++) {
        addSeed(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"" + i);
    }
    setNextFilter(new DemoNextFilter());
}   ",1047,True
"/*
    可以往next中添加希望后续爬取的任务，任务可以是URL或者CrawlDatum
    爬虫不会重复爬取任务，从2.20版之后，爬虫根据CrawlDatum的key去重，而不是URL
    因此如果希望重复爬取某个URL，只要将CrawlDatum的key设置为一个历史中不存在的值即可
    例如增量爬取，可以使用 爬取时间+URL作为key。

    新版本中，可以直接通过 page.select(css选择器)方法来抽取网页中的信息，等价于
    page.getDoc().select(css选择器)方法，page.getDoc()获取到的是Jsoup中的
    Document对象，细节请参考Jsoup教程
 */
@Override
public void visit(Page page, CrawlDatums next){
    if (page.matchType(""content"")) {
        String title = page.select(""h1.title-article"").first().text();
        String author = page.select(""p.name>a.text-truncate"").first().text();
        System.out.println(""title:"" + title + ""\tauthor:"" + author);
    }
}","/*
    可以往next中添加希望后续爬取的任务，任务可以是URL或者CrawlDatum
    爬虫不会重复爬取任务，从2.20版之后，爬虫根据CrawlDatum的key去重，而不是URL
    因此如果希望重复爬取某个URL，只要将CrawlDatum的key设置为一个历史中不存在的值即可
    例如增量爬取，可以使用 爬取时间+URL作为key。

    新版本中，可以直接通过 page.select(css选择器)方法来抽取网页中的信息，等价于
    page.getDoc().select(css选择器)方法，page.getDoc()获取到的是Jsoup中的
    Document对象，细节请参考Jsoup教程
 */
@Override
public void visit(Page page, CrawlDatums next) 
{
    //��取网页中的信息
    String title = page.select(""title"").text();
    String content = page.select(""div.content"").text();

    //将��取的信息��装到CrawlDatum中
    CrawlDatum datum = new CrawlDatum();
    datum.setUrl(page.getUrl().toString());
    datum.set(""title"", title);
    datum.set(""content"", content);

    //将CrawlDatum添加到next中
    next.add(datum);
}   ",1049,True
"/**
 * 判断输入字符串是否符合正则规则
 * @param str 输入的字符串
 * @return 输入字符串是否符合正则规则
 */
public boolean satisfy(String str){

    int state = 0;
    for (String nregex : negative) {
        if (Pattern.matches(nregex, str)) {
            return false;
        }
    }

    int count = 0;
    for (String pregex : positive) {
        if (Pattern.matches(pregex, str)) {
            count++;
        }
    }
    if (count == 0) {
        return false;
    } else {
        return true;
    }

}","/**
 * 判断输入字符串是否符合正则规则
 * @param str 输入的字符串
 * @return 输入字符串是否符合正则规则
 */
public boolean satisfy(String str) 
{
    if(str.matches(""^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$""))
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",1054,True
"/*
    实际使用时建议按照DemoTypeCrawler的方式操作，该教程目的为阐述meta的原理

    可以往next中添加希望后续爬取的任务，任务可以是URL或者CrawlDatum
    爬虫不会重复爬取任务，从2.20版之后，爬虫根据CrawlDatum的key去重，而不是URL
    因此如果希望重复爬取某个URL，只要将CrawlDatum的key设置为一个历史中不存在的值即可
    例如增量爬取，可以使用 爬取时间+URL作为key。

    新版本中，可以直接通过 page.select(css选择器)方法来抽取网页中的信息，等价于
    page.getDoc().select(css选择器)方法，page.getDoc()获取到的是Jsoup中的
    Document对象，细节请参考Jsoup教程

    该Demo爬虫需要应对豆瓣图书的三种页面：
    1）标签页（taglist，包含图书列表页的入口链接）
    2）列表页（booklist，包含图书详情页的入口链接）
    3）图书详情页（content）
 */
@Override
public void visit(Page page, CrawlDatums next){

    String type=page.meta(""type"");
    //如果是列表页，抽取内容页链接，放入后续任务中
    if(type.equals(""taglist"")){
        //可以确定抽取到的链接都指向内容页
        //因此为这些链接添加附加信息（meta）：type=content
        next.addAndReturn(page.links(""table.tagCol td>a"")).meta(""type"", ""booklist"");
    }else if(type.equals(""booklist"")){
        next.addAndReturn(page.links(""div.info>h2>a"")).meta(""type"", ""content"");
    }else if(type.equals(""content"")){
        //处理内容页，抽取书名和豆瓣评分
        String title=page.select(""h1>span"").first().text();
        String score=page.select(""strong.ll.rating_num"").first().text();
        System.out.println(""title:""+title+""\tscore:""+score);
    }

}","/*
    实际使用时建议按照DemoTypeCrawler的方式操作，该教程目的为阐述meta的原理

    可以往next中添加希望后续爬取的任务，任务可以是URL或者CrawlDatum
    爬虫不会重复爬取任务，从2.20版之后，爬虫根据CrawlDatum的key去重，而不是URL
    因此如果希望重复爬取某个URL，只要将CrawlDatum的key设置为一个历史中不存在的值即可
    例如增量爬取，可以使用 爬取时间+URL作为key。

    新版本中，可以直接通过 page.select(css选择器)方法来抽取网页中的信息，等价于
    page.getDoc().select(css选择器)方法，page.getDoc()获取到的是Jsoup中的
    Document对象，细节请参考Jsoup教程

    该Demo爬虫需要应对豆瓣图书的三种页面：
    1）标签页（taglist，包含图书列表页的入口链接）
    2）列表页（booklist，包含图书详情页的入口链接）
    3）图书详情页（content）
 */
@Override
public void visit(Page page, CrawlDatums next) 
{
    if (page.matchUrl(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.*"")) {
        // ��签页
        Document doc = page.getDoc();
        Elements elements = doc.select(""div.booklist > ul > li > a"");
        for (Element element : elements) {
            String url = element.attr(""href"");
            next.add(url);
        }
    } else if (page.matchUrl(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.*"")) {
        // ��表页
        Document doc = page.getDoc();
        Elements elements = doc.select(""div.booklist > ul > li > a"");
        for (Element element : elements) {
            String url = element.attr(""href"");
            next.add(url);
        }
    } else if (page.matchUrl(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.*"")) {
        // 图书详情页
        Document doc = page.getDoc();
        String title = doc.select(""div.book_name > h1"").text();
        String content = doc.select(""div.content"").text();
        System.out.println(""Title: "" + title);
        System.out.println(""Content: "" + content);
    }
}   ",1055,True
"//    @Override
//    public Page getResponse(CrawlDatum crawlDatum) throws Exception {
//        HttpRequest request = new HttpRequest(crawlDatum.url());
//
//        request.setMethod(crawlDatum.meta(""method""));
//        String outputData = crawlDatum.meta(""outputData"");
//        if (outputData != null) {
//            request.setOutputData(outputData.getBytes(""utf-8""));
//        }
//        return request.responsePage();
//        /*
//        //通过下面方式可以设置Cookie、User-Agent等http请求头信息
//        request.setCookie(""xxxxxxxxxxxxxx"");
//        request.setUserAgent(""WebCollector"");
//        request.addHeader(""xxx"", ""xxxxxxxxx"");
//         */
//    }
@Override
    public void visit(Page page, CrawlDatums next){
        JsonObject jsonObject = page.jsonObject();
        System.out.println(""JSON信息："" + jsonObject);
    }","//    @Override
//    public Page getResponse(CrawlDatum crawlDatum) throws Exception {
//        HttpRequest request = new HttpRequest(crawlDatum.url());
//
//        request.setMethod(crawlDatum.meta(""method""));
//        String outputData = crawlDatum.meta(""outputData"");
//        if (outputData != null) {
//            request.setOutputData(outputData.getBytes(""utf-8""));
//        }
//        return request.responsePage();
//        /*
//        //通过下面方式可以设置Cookie、User-Agent等http请求头信息
//        request.setCookie(""xxxxxxxxxxxxxx"");
//        request.setUserAgent(""WebCollector"");
//        request.addHeader(""xxx"", ""xxxxxxxxx"");
//         */
//    }
@Override
    public void visit(Page page, CrawlDatums next) 
{
    String url = page.getRequest().getUrl();
    if (page.matchUrl(""XXXXXXXXXXXXXXXXXX"")) {
        next.add(page.links(""a[href^=\""XXXXXXXXXXXXXXXXXXXX\""]""));
    }
}   ",1057,True
"/**
 * 添加一个反正则规则
 * @param negativeregex
 * @return 自身
 */
public RegexRule addNegative(String negativeregex){
    negative.add(negativeregex);
    return this;
}","/**
 * 添加一个反正则规则
 * @param negativeregex
 * @return 自身
 */
public RegexRule addNegative(String negativeregex) 
{
    if(negativeregex != null)
    {
        this.negativeregex.add(negativeregex);
    }
    return this;
}   ",1058,True
"/**
 * Get note Category
 */
public Category getCategory(Long id){
  Category category = null;
  String sql = ""SELECT ""
      + KEY_CATEGORY_ID + "",""
      + KEY_CATEGORY_NAME + "",""
      + KEY_CATEGORY_DESCRIPTION + "",""
      + KEY_CATEGORY_COLOR
      + "" FROM "" + TABLE_CATEGORY
      + "" WHERE "" + KEY_CATEGORY_ID + "" = "" + id;

  try (Cursor cursor = getDatabase().rawQuery(sql, null)) {

    if (cursor.moveToFirst()) {
      category = new Category(cursor.getLong(0), cursor.getString(1),
          cursor.getString(2), cursor.getString(3));
    }

  }
  return category;
}","/**
 * Get note Category
 */
public Category getCategory(Long id) 
{
    Category category = null;
    try
    {
        category = (Category) session.get(Category.class, id);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return category;
}   ",1061,True
"/**
 * Retrieves all notes related to Category it passed as parameter
 *
 * @param categoryId Category integer identifier
 * @return List of notes with requested category
 */
public List<Note> getNotesByCategory(Long categoryId){
  List<Note> notes;
  boolean filterArchived = prefs
      .getBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + categoryId, false);
  try {
    String whereCondition = "" WHERE ""
        + KEY_CATEGORY_ID + "" = "" + categoryId
        + "" AND "" + KEY_TRASHED + "" IS NOT 1""
        + (filterArchived ? "" AND "" + KEY_ARCHIVED + "" IS NOT 1"" : """");
    notes = getNotes(whereCondition, true);
  } catch (NumberFormatException e) {
    notes = getAllNotes(true);
  }
  return notes;
}","/**
 * Retrieves all notes related to Category it passed as parameter
 *
 * @param categoryId Category integer identifier
 * @return List of notes with requested category
 */
public List<Note> getNotesByCategory(Long categoryId) 
{
    return noteRepository.findAllByCategoryId(categoryId);
}   ",1063,False
"/**
 * Common method for notes retrieval. It accepts a query to perform and returns matching records.
 */
public List<Note> getNotes(String whereCondition, boolean order){
  List<Note> noteList = new ArrayList<>();

  String sortColumn = """";
  String sortOrder = """";

  // Getting sorting criteria from preferences. Reminder screen forces sorting.
  if (Navigation.checkNavigation(Navigation.REMINDERS)) {
    sortColumn = KEY_REMINDER;
  } else {
    sortColumn = prefs.getString(PREF_SORTING_COLUMN, KEY_TITLE);
  }
  if (order) {
    sortOrder =
        KEY_TITLE.equals(sortColumn) || KEY_REMINDER.equals(sortColumn) ? "" ASC "" : "" DESC "";
  }

  // In case of title sorting criteria it must be handled empty title by concatenating content
  sortColumn = KEY_TITLE.equals(sortColumn) ? KEY_TITLE + ""||"" + KEY_CONTENT : sortColumn;

  // In case of reminder sorting criteria the empty reminder notes must be moved on bottom of results
  sortColumn = KEY_REMINDER.equals(sortColumn) ? ""IFNULL("" + KEY_REMINDER + "", "" +
      """" + TIMESTAMP_UNIX_EPOCH + "")"" : sortColumn;

  // Generic query to be specialized with conditions passed as parameter
  String query = ""SELECT ""
      + KEY_CREATION + "",""
      + KEY_LAST_MODIFICATION + "",""
      + KEY_TITLE + "",""
      + KEY_CONTENT + "",""
      + KEY_ARCHIVED + "",""
      + KEY_TRASHED + "",""
      + KEY_REMINDER + "",""
      + KEY_REMINDER_FIRED + "",""
      + KEY_RECURRENCE_RULE + "",""
      + KEY_LATITUDE + "",""
      + KEY_LONGITUDE + "",""
      + KEY_ADDRESS + "",""
      + KEY_LOCKED + "",""
      + KEY_CHECKLIST + "",""
      + KEY_CATEGORY + "",""
      + KEY_CATEGORY_NAME + "",""
      + KEY_CATEGORY_DESCRIPTION + "",""
      + KEY_CATEGORY_COLOR
      + "" FROM "" + TABLE_NOTES
      + "" LEFT JOIN "" + TABLE_CATEGORY + "" USING( "" + KEY_CATEGORY + "") ""
      + whereCondition
      + (order ? "" ORDER BY "" + sortColumn + "" COLLATE NOCASE "" + sortOrder : """");

  LogDelegate.v(""Query: "" + query);

  try (Cursor cursor = getDatabase().rawQuery(query, null)) {

    if (cursor.moveToFirst()) {
      do {
        int i = 0;
        Note note = new Note();
        note.setCreation(cursor.getLong(i++));
        note.setLastModification(cursor.getLong(i++));
        note.setTitle(cursor.getString(i++));
        note.setContent(cursor.getString(i++));
        note.setArchived(""1"".equals(cursor.getString(i++)));
        note.setTrashed(""1"".equals(cursor.getString(i++)));
        note.setAlarm(cursor.getString(i++));
        note.setReminderFired(cursor.getInt(i++));
        note.setRecurrenceRule(cursor.getString(i++));
        note.setLatitude(cursor.getString(i++));
        note.setLongitude(cursor.getString(i++));
        note.setAddress(cursor.getString(i++));
        note.setLocked(""1"".equals(cursor.getString(i++)));
        note.setChecklist(""1"".equals(cursor.getString(i++)));

        // Eventual decryption of content
        if (Boolean.TRUE.equals(note.isLocked())) {
          note.setContent(
              Security.decrypt(note.getContent(), prefs.getString(PREF_PASSWORD, """")));
        }

        // Set category
        long categoryId = cursor.getLong(i++);
        if (categoryId != 0) {
          Category category = new Category(categoryId, cursor.getString(i++),
              cursor.getString(i++), cursor.getString(i));
          note.setCategory(category);
        }

        // Add eventual attachments uri
        note.setAttachmentsList(getNoteAttachments(note));

        // Adding note to list
        noteList.add(note);

      } while (cursor.moveToNext());
    }

  }

  LogDelegate.v(""Query: Retrieval finished!"");
  return noteList;
}","/**
 * Common method for notes retrieval. It accepts a query to perform and returns matching records.
 */

public List<Note> getNotes(String whereCondition, boolean order) 
{
    List<Note> notes = new ArrayList<Note>();
    Cursor cursor = database.query(MySQLiteHelper.TABLE_NOTES, allColumns, whereCondition, null, null, null, null);

    cursor.moveToFirst();
    while (!cursor.isAfterLast()) {
        Note note = cursorToNote(cursor);
        notes.add(note);
        cursor.moveToNext();
    }
    // make sure to close the cursor
    cursor.close();
    return notes;
}   ",1064,False
"/**
 * Notes sharing
 */
public void shareNote(Note note){

  String titleText = note.getTitle();

  String contentText = titleText
      + System.getProperty(""line.separator"")
      + note.getContent();

  Intent shareIntent = new Intent();
  // Prepare sharing intent with only text
  if (note.getAttachmentsList().isEmpty()) {
    shareIntent.setAction(Intent.ACTION_SEND);
    shareIntent.setType(""text/plain"");

    // Intent with single image attachment
  } else if (note.getAttachmentsList().size() == 1) {
    shareIntent.setAction(Intent.ACTION_SEND);
    Attachment attachment = note.getAttachmentsList().get(0);
    shareIntent.setType(attachment.getMime_type());
    shareIntent.putExtra(Intent.EXTRA_STREAM, FileProviderHelper.getShareableUri(attachment));

    // Intent with multiple images
  } else if (note.getAttachmentsList().size() > 1) {
    shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);
    ArrayList<Uri> uris = new ArrayList<>();
    // A check to decide the mime type of attachments to share is done here
    HashMap<String, Boolean> mimeTypes = new HashMap<>();
    for (Attachment attachment : note.getAttachmentsList()) {
      uris.add(FileProviderHelper.getShareableUri(attachment));
      mimeTypes.put(attachment.getMime_type(), true);
    }
    // If many mime types are present a general type is assigned to intent
    if (mimeTypes.size() > 1) {
      shareIntent.setType(""*/*"");
    } else {
      shareIntent.setType((String) mimeTypes.keySet().toArray()[0]);
    }

    shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
  }
  shareIntent.putExtra(Intent.EXTRA_SUBJECT, titleText);
  shareIntent.putExtra(Intent.EXTRA_TEXT, contentText);

  startActivity(Intent
      .createChooser(shareIntent, getResources().getString(R.string.share_message_chooser)));
}","/**
 * Notes sharing
 */
public void shareNote(Note note) 
{
    // Check if the note is already shared
    if (note.isShared())
    {
        System.out.println(""Note is already shared."");
        return;
    }

    // Share the note
    note.setShared(true);
    System.out.println(""Note shared successfully."");
}   ",1066,False
"/**
 * Trashes/restore single note
 */
public void trashNote(Note note, boolean trash){
  note.setTrashed(trash);
  updateNote(note, false);
}","/**
 * Trashes/restore single note
 */
public void trashNote(Note note, boolean trash) 
{
    if (trash)
    {
        note.setTrashed(true);
    }
    else
    {
        note.setTrashed(false);
    }
}   ",1069,True
"/**
 * Updates or insert a new a category
 *
 * @param category Category to be updated or inserted
 * @return Rows affected or new inserted category ID
 */
public Category updateCategory(Category category){
  ContentValues values = new ContentValues();
  values.put(KEY_CATEGORY_ID, category.getId() != null ? category.getId() : Calendar.getInstance()
      .getTimeInMillis());
  values.put(KEY_CATEGORY_NAME, category.getName());
  values.put(KEY_CATEGORY_DESCRIPTION, category.getDescription());
  values.put(KEY_CATEGORY_COLOR, category.getColor());
  getDatabase(true).insertWithOnConflict(TABLE_CATEGORY, KEY_CATEGORY_ID, values, SQLiteDatabase
      .CONFLICT_REPLACE);
  return category;
}","/**
 * Updates or insert a new a category
 *
 * @param category Category to be updated or inserted
 * @return Rows affected or new inserted category ID
 */
public Category updateCategory(Category category) 
{
    if (category.getId() == null)
    {
        return insertCategory(category);
    }
    else
    {
        return updateCategoryById(category);
    }
}   ",1071,True
"/**
 * Build a formatted time string starting from values obtained by a TimePicker
 */
public static String onTimeSet(int hour, int minute, String format){
  SimpleDateFormat sdf = new SimpleDateFormat(format);
  Calendar cal = Calendar.getInstance();
  cal.set(Calendar.HOUR_OF_DAY, hour);
  cal.set(Calendar.MINUTE, minute);
  return sdf.format(cal.getTime());
}","/**
 * Build a formatted time string starting from values obtained by a TimePicker
 */


public static String onTimeSet(int hour, int minute, String format) 
{
    LocalTime time = LocalTime.of(hour, minute);
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format);
    return time.format(formatter);
}   ",1072,True
"/**
 * Build a formatted date string starting from values obtained by a DatePicker
 */
public static String onDateSet(int year, int month, int day, String format){
  SimpleDateFormat sdf = new SimpleDateFormat(format);
  Calendar cal = Calendar.getInstance();
  cal.set(Calendar.YEAR, year);
  cal.set(Calendar.MONTH, month);
  cal.set(Calendar.DAY_OF_MONTH, day);
  return sdf.format(cal.getTime());
}","/**
 * Build a formatted date string starting from values obtained by a DatePicker
 */

public static String onDateSet(int year, int month, int day, String format) 
{
    Calendar calendar = Calendar.getInstance();
    calendar.set(year, month, day);
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
    return simpleDateFormat.format(calendar.getTime());
}   ",1073,True
"/**
 * Checks if allocated fragment is of the required type and then returns it or returns null
 */
private Fragment checkFragmentInstance(int id, Object instanceClass){
  Fragment result = null;
  Fragment fragment = getFragmentManagerInstance().findFragmentById(id);
  if (fragment != null && instanceClass.equals(fragment.getClass())) {
    result = fragment;
  }
  return result;
}","/**
 * Checks if allocated fragment is of the required type and then returns it or returns null
 */
private Fragment checkFragmentInstance(int id, Object instanceClass) 
{
    if (instanceClass instanceof Fragment)
    {
        Fragment fragment = (Fragment) instanceClass;
        if (fragment.getId() == id)
        {
            return fragment;
        }
    }
    return null;
}   ",1075,True
"/**
 * Getting All notes
 *
 * @param checkNavigation Tells if navigation status (notes, archived) must be kept in
 *                        consideration or if all notes have to be retrieved
 * @return Notes list
 */
public List<Note> getAllNotes(Boolean checkNavigation){
  String whereCondition = """";
  if (Boolean.TRUE.equals(checkNavigation)) {
    int navigation = Navigation.getNavigation();
    switch (navigation) {
      case Navigation.NOTES:
        return getNotesActive();
      case Navigation.ARCHIVE:
        return getNotesArchived();
      case Navigation.REMINDERS:
        return getNotesWithReminder(prefs.getBoolean(PREF_FILTER_PAST_REMINDERS, false));
      case Navigation.TRASH:
        return getNotesTrashed();
      case Navigation.UNCATEGORIZED:
        return getNotesUncategorized();
      case Navigation.CATEGORY:
        return getNotesByCategory(Navigation.getCategory());
      default:
        return getNotes(whereCondition, true);
    }
  } else {
    return getNotes(whereCondition, true);
  }

}","/**
 * Getting All notes
 *
 * @param checkNavigation Tells if navigation status (notes, archived) must be kept in
 *                        consideration or if all notes have to be retrieved
 * @return Notes list
 */
public List<Note> getAllNotes(Boolean checkNavigation) 
{
    List<Note> notes = new ArrayList<Note>();
    for (Note note : this.notes)
    {
        if (checkNavigation)
        {
            if (!note.isArchived() && !note.isDeleted())
            {
                notes.add(note);
            }
        }
        else
        {
            notes.add(note);
        }
    }
    return notes;
}   ",1076,False
"/**
 * Iterative solution to this problem. The complexity order of this algorithm in time and space
 * terms is equivalent to the previous algorithm but the execution time is lower in this version.
 * The key of this algorithm is based on use two pointers, going going two times faster trough
 * the
 * list during the iteration.
 */
public ListNode<Integer> get2(ListNode<Integer> list){
  validateInput(list);

  ListNode<Integer> currentNode = list;
  ListNode<Integer> fastNode = list.getNext();
  while (fastNode != null && fastNode.getNext() != null) {
    currentNode = currentNode.getNext();
    fastNode = fastNode.getNext().getNext();
  }
  return currentNode;
}","/**
 * Iterative solution to this problem. The complexity order of this algorithm in time and space
 * terms is equivalent to the previous algorithm but the execution time is lower in this version.
 * The key of this algorithm is based on use two pointers, going going two times faster trough
 * the
 * list during the iteration.
 */
public ListNode<Integer> get2(ListNode<Integer> list) 
{
    ListNode<Integer> slow = list;
    ListNode<Integer> fast = list;
    ListNode<Integer> prev = null;
    while (fast != null && fast.next != null)
    {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    if (prev != null)
    {
        prev.next = null;
    }
    return slow;
}   ",1080,True
"/**
 * Iterative algorithm to solve this problem. Two words are anagrams just if contains the same
 * number of letters. Using this property, we are going to sort and compare the letters inside
 * the array.  The complexity order of this algorithm is O(N*Log(N)) where N is the number of
 * letters in the largest word. In space terms, the complexity order of this algorithm is O(N).
 */
public boolean check(String a, String b){
  if (a == null || b == null) {
    throw new IllegalArgumentException(""You can't use null Strings as input."");
  }
  if (a.length() != b.length()) {
    return false;
  }
  char[] charsA = a.toCharArray();
  Arrays.sort(charsA);
  char[] charsB = b.toCharArray();
  Arrays.sort(charsB);
  return Arrays.equals(charsA, charsB);
}","/**
 * Iterative algorithm to solve this problem. Two words are anagrams just if contains the same
 * number of letters. Using this property, we are going to sort and compare the letters inside
 * the array.  The complexity order of this algorithm is O(N*Log(N)) where N is the number of
 * letters in the largest word. In space terms, the complexity order of this algorithm is O(N).
 */

public boolean check(String a, String b) 
{
    if (a.length() != b.length()) return false;
    char[] aChars = a.toCharArray();
    char[] bChars = b.toCharArray();
    Arrays.sort(aChars);
    Arrays.sort(bChars);
    return Arrays.equals(aChars, bChars);
}   ",1081,True
"/**
 * This implementation is based on Strings. Transforming an integer into the binary
 * representation we can obtain an String and use it to count the number of elements equals to
 * '1'. This implementation is slow because it's based on transform the parameter into the binary
 * representation which complexity order is O(N) where N is the number of digits in the parameter
 * binary representation.
 *
 * In addition we have to count the number of elements inside the String obtained and the
 * complexity order of that operation is again O(N).
 *
 * In space terms, the complexity order is O(N) where N is the number of digits used to represent
 * the parameter using binary format. This cost is associated to the usage of an auxiliary String
 * to keep the binary result.
 *
 * To get the binary representation we are going to use a static method of Integer class:
 * Integer.toBinaryString.
 */
public int countBitsToOneBasedOnString(int n){
  int result = 0;
  String binaryNumber = Integer.toBinaryString(n);
  for (char c : binaryNumber.toCharArray()) {
    result += c == '1' ? 1 : 0;
  }
  return result;
}","/**
 * This implementation is based on Strings. Transforming an integer into the binary
 * representation we can obtain an String and use it to count the number of elements equals to
 * '1'. This implementation is slow because it's based on transform the parameter into the binary
 * representation which complexity order is O(N) where N is the number of digits in the parameter
 * binary representation.
 *
 * In addition we have to count the number of elements inside the String obtained and the
 * complexity order of that operation is again O(N).
 *
 * In space terms, the complexity order is O(N) where N is the number of digits used to represent
 * the parameter using binary format. This cost is associated to the usage of an auxiliary String
 * to keep the binary result.
 *
 * To get the binary representation we are going to use a static method of Integer class:
 * Integer.toBinaryString.
 */
public int countBitsToOneBasedOnString(int n) 
{
    String binary = Integer.toBinaryString(n);
    int count = 0;
    for (int i = 0; i < binary.length(); i++) {
        if (binary.charAt(i) == '1') {
            count++;
        }
    }
    return count;
}   ",1084,True
"/**
 * Iterative algorithm used to find the median of an AVL. This algorithm is based on a property
 * of every AVL tree, you can get a sorted collection containing the elements of this tree using
 * an in order traversal. Using this property we can get a sorted collection of nodes and then
 * find the median. The complexity order of this algorithm is O(N) in time and space terms where
 * N
 * is the number of nodes in the tree.
 */
public double find(BinaryNode<Integer> root){
  if (root == null) {
    throw new IllegalArgumentException(""You can't pass a null binary tree to this method."");
  }

  List<BinaryNode<Integer>> sortedElements = binaryTreeInOrder.getIterative(root);
  double median = 0;
  if (sortedElements.size() % 2 == 0) {
    median = (sortedElements.get(sortedElements.size() / 2).getData() + sortedElements.get(
        sortedElements.size() / 2 - 1).getData()) / 2;
  } else {
    median = sortedElements.get(sortedElements.size() / 2).getData();
  }
  return median;
}","/**
 * Iterative algorithm used to find the median of an AVL. This algorithm is based on a property
 * of every AVL tree, you can get a sorted collection containing the elements of this tree using
 * an in order traversal. Using this property we can get a sorted collection of nodes and then
 * find the median. The complexity order of this algorithm is O(N) in time and space terms where
 * N
 * is the number of nodes in the tree.
 */
public double find(BinaryNode<Integer> root) 
{
    int count = countNodes(root);
    int medianPosition = (count + 1) / 2;
    return findMedian(root, medianPosition);
}   ",1086,True
"/**
 * Recursive solution based on Fibonacci sequence definition. F(N) = F(N-1) + F(N-2).
 *
 * The complexity order of this algorithm is O(2^N) where N is integer used as parameter. In space
 * terms, the complexity order of this algorithm is O(1) because we are not using any auxiliary
 * data structure to solve this problem.
 */
public long getRecursive(long n){
  validateInput(n);
  if (n == 1 || n == 2) {
    return 1;
  } else {
    return getRecursive(n - 1) + getRecursive(n - 2);
  }
}","/**
 * Recursive solution based on Fibonacci sequence definition. F(N) = F(N-1) + F(N-2).
 *
 * The complexity order of this algorithm is O(2^N) where N is integer used as parameter. In space
 * terms, the complexity order of this algorithm is O(1) because we are not using any auxiliary
 * data structure to solve this problem.
 */
public long getRecursive(long n) 
{
    if (n <= 1)
    {
        return n;
    }
    return getRecursive(n - 1) + getRecursive(n - 2);
}   ",1088,True
"/**
 * Iterative solution to this algorithm. This algorithm has a complexity order equals to O(N)
 * where N is the billAmount/maxMoneyValue. At the end, linear to the value passed as parameter.
 */
public List<Integer> calculate(int[] moneys, int billAmount){
  validateInputData(moneys, billAmount);

  List<Integer> change = new LinkedList<Integer>();
  while (billAmount > 0 && moneys.length > 0) {
    for (int i = moneys.length - 1; i >= 0; i--) {
      if (billAmount - moneys[i] >= 0) {
        change.add(moneys[i]);
        billAmount -= moneys[i];
        break;
      }
    }
  }
  return change;
}","/**
 * Iterative solution to this algorithm. This algorithm has a complexity order equals to O(N)
 * where N is the billAmount/maxMoneyValue. At the end, linear to the value passed as parameter.
 */

public List<Integer> calculate(int[] moneys, int billAmount) 
{
    List<Integer> result = new ArrayList<>();
    for (int i = moneys.length - 1; i >= 0; i--) {
        while (billAmount >= moneys[i]) {
            billAmount -= moneys[i];
            result.add(moneys[i]);
        }
    }
    return result;
}   ",1089,True
"/**
 * Recursive implementation for this algorithm. Complexity order in time terms equals to O(N)
 * where N is the number of nodes in the smaller tree. In space terms, the complexity order of
 * this algorithm is O(1) because we are not using any additional data structure to keep nodes
 * information.
 *
 * Related with the execution time of this algorithm is really important take into account the
 * third recursion case where we are going to use ""if"" short circuit to avoid go through the
 * whole
 * tree and stop comparing nodes once we find one different.
 */
public boolean areEqualsRecursive(BinaryNode tree1, BinaryNode tree2){
  validateInput(tree1, tree2);
  return areEqualsInner(tree1, tree2);
}","/**
 * Recursive implementation for this algorithm. Complexity order in time terms equals to O(N)
 * where N is the number of nodes in the smaller tree. In space terms, the complexity order of
 * this algorithm is O(1) because we are not using any additional data structure to keep nodes
 * information.
 *
 * Related with the execution time of this algorithm is really
 * third recursion case where we are going to use ""if"" short circuit to avoid go through the
 * whole
 * tree and stop comparing nodes once we find one different.
 */
public boolean areEqualsRecursive(BinaryNode tree1, BinaryNode tree2) 
{
    if (tree1 == null && tree2 == null)
    {
        return true;
    }
    if (tree1 == null || tree2 == null)
    {
        return false;
    }
    if (tree1.data != tree2.data)
    {
        return false;
    }
    return areEqualsRecursive(tree1.left, tree2.left) && areEqualsRecursive(tree1.right, tree2.right);
}   ",1090,True
"/**
 * Iterative approach. The complexity order in this algorithm is O(N) where N is the integer used
 * as parameter. In space terms, the complexity order of this algorithm is again O(1).
 */
public long getIterative(long n){
  validateInput(n);

  if (n <= 2) {
    return 1;
  }
  long previous = 1;
  long current = 1;
  long element = 0;
  for (long i = 3; i <= n; i++) {
    element = previous + current;
    previous = current;
    current = element;
  }
  return element;
}","/**
 * Iterative approach. The complexity order in this algorithm is O(N) where N is the integer used
 * as parameter. In space terms, the complexity order of this algorithm is again O(1).
 */
public long getIterative(long n) 
{
    long result = 0;
    for (long i = 1; i <= n; i++)
    {
        result += i;
    }
    return result;
}   ",1093,True
"/**
 * Implementation based on Java Sets. To solve this algorithm we have used a Java HashSet and the
 * complexity order of this algorithm in time is O(N) where N is the number of elements in the
 * input array. In space terms, the complexity order of this algorithm is also O(N), because we
 * are using an auxiliary data structure.
 *
 * This implementation is possible in O(N) because the complexity order of HashSets for
 * insertions is O(1).
 */
public Integer[] removeUsingSet(Integer[] numbers){
  validateArray(numbers);

  Set<Integer> uniqueElements = new HashSet<Integer>();
  for (int i : numbers) {
    uniqueElements.add(i);
  }
  return uniqueElements.toArray(new Integer[uniqueElements.size()]);
}","/**
 * Implementation based on Java Sets. To solve this algorithm we have used a Java HashSet and the
 * complexity order of this algorithm in time is O(N) where N is the number of elements in the
 * input array. In space terms, the complexity order of this algorithm is also O(N), because we
 * are using an auxiliary data structure.
 *
 * This implementation is possible in O(N) because the complexity order of HashSets for
 * insertions is O(1).
 */

public Integer[] removeUsingSet(Integer[] numbers) 
{
    Set<Integer> set = new HashSet<>();
    for (Integer number : numbers)
    {
        set.add(number);
    }
    return set.toArray(new Integer[0]);
}   ",1094,True
"/**
 * Iterative solution to this problem. The complexity order of this algorithm is O(N) because we
 * have to use split and is the most expensive operation. In space terms the complexity order is
 * O(N) and related directly to the size of the number in scientific notation.
 */
public long calculate(String number){
  if (number == null || !number.contains(""E"")) {
    throw new IllegalArgumentException(""Invalid format for number "" + number);
  }
  String[] splittedNumber = splitScientificNumber(number);
  double first = getLeftPart(splittedNumber[0]);
  int sign = getNumberSign(splittedNumber[1]);
  int pow = getPow(splittedNumber[1]);
  Double result = sign * first * Math.pow(10, pow);
  return result.longValue();
}","/**
 * Iterative solution to this problem. The complexity order of this algorithm is O(N) because we
 * have to use split and is the most expensive operation. In space terms the complexity order is
 * O(N) and related directly to the size of the number in scientific notation.
 */
public long calculate(String number) 
{
    String[] parts = number.split(""e"");
    long base = Long.parseLong(parts[0]);
    int exponent = Integer.parseInt(parts[1]);
    long result = base;
    for (int i = 1; i < exponent; i++)
    {
        result *= base;
    }
    return result;
}   ",1095,True
"/**
 * Iterative solution to this problem. Using two pointer we are going to iterate over the input
 * array using one of them and other to store the result in a temporal array. The complexity
 * order of this algorithm in time and space terms is O(N) where N is the number of elements in
 * the array.
 */
public void replace(char[] input){
  validateInput(input);

  char[] result = new char[input.length];
  for (int i = 0, j = 0; i < input.length && j < input.length; i++, j++) {
    if (input[i] == ' ') {
      result[j++] = '%';
      result[j++] = '2';
      result[j] = '0';
    } else {
      result[j] = input[i];
    }
  }
  copyArray(result, input);
}","/**
 * Iterative solution to this problem. Using two pointer we are going to iterate over the input
 * array using one of them and other to store the result in a temporal array. The complexity
 * order of this algorithm in time and space terms is O(N) where N is the number of elements in
 * the array.
 */
public void replace(char[] input) 
{
    if (input == null || input.length == 0) return;

    int i = 0;
    int j = 0;

    while (i < input.length)
    {
        if (input[i] == ' ')
        {
            input[j++] = '%';
            input[j++] = '2';
            input[j++] = '0';
        }
        else
        {
            input[j++] = input[i];
        }
        i++;
    }
}   ",1098,True
"/**
 * Iterative solution to this problem. The complexity order of this algorithm in time terms is
 * equals to O(N) where N is the number of elements in the list. In space terms, the complexity
 * order is O(1) because we are not using any auxiliary data structure to solve this problem.
 * This algorithm is based on know the size of the list, but this part of the algorithm is a
 * problem for the execution time.
 */
public ListNode<Integer> get(ListNode<Integer> list){
  validateInput(list);

  int size = getListSize(list);
  int middleElementPosition = size % 2 != 0 ? size / 2 : (size / 2) - 1;
  ListNode middleElement = list;
  for (int i = 0; i < middleElementPosition; i++) {
    middleElement = middleElement.getNext();
  }
  return middleElement;
}","/**
 * Iterative solution to this problem. The complexity order of this algorithm in time terms is
 * equals to O(N) where N is the number of elements in the list. In space terms, the complexity
 * order is O(1) because we are not using any auxiliary data structure to solve this problem.
 * This algorithm is based on know the size of the list, but this part of the algorithm is a
 * problem for the execution time.
 */
public ListNode<Integer> get(ListNode<Integer> list) 
{
    int size = 0;
    ListNode<Integer> current = list;
    while(current != null)
    {
        size++;
        current = current.getNext();
    }
    int index = (int)(Math.random() * size);
    current = list;
    for(int i = 0; i < index; i++)
    {
        current = current.getNext();
    }
    return current;
}   ",1099,True
"/**
 * Some OpenSubtitle users like VIPs get a different API address with
 * better priority. If such an URL was returned during login, it will be
 * returned {@link URL}. If not, the login {@link URL} will be returned.
 *
 * @return The {@link User}'s {@link URL} or {@code null}.
 */
public URL getURL(){
	if (user != null && user.getContentLocation() != null) {
		try {
			return user.getContentLocation().toURL();
		} catch (MalformedURLException e) {
			LOGGER.error(""OpenSubtitles: Not using user specified API URL: {}"", e.getMessage());
			LOGGER.trace("""", e);
		}
	}
	return defaultUrl;
}","/**
 * Some OpenSubtitle users like VIPs get a different API address with
 * better priority. If such an URL was returned during login, it will be
 * returned {@link URL}. If not, the login {@link URL} will be returned.
 *
 * @return The {@link User}'s {@link URL} or {@code null}.
 */
public URL getURL() 
{
    return this.url;
}   ",1101,True
"/**
 * Creates a {@link String} where each file hash in {@code titles} is on its
 * own line and indented with the specified number of spaces. The
 * {@link CheckMovieHashItem}s for each file hash is listed as sub-items
 * with double indentation.
 *
 * @param titles the {@link Map} of [file hash, {@link CheckMovieHashItem}]
 *            pairs to format for logging.
 * @param indent the number of leading spaces for ""one indentation"".
 * @return The log friendly {@link String}.
 */
public static String toLogString(Map<String, List<CheckMovieHashItem>> titles, int indent){
	String indentation = indent > 0 ? StringUtil.fillString(' ', indent) : """";
	if (titles == null) {
		return indentation + ""Null"";
	}
	if (titles.isEmpty()) {
		return indentation + ""No matching titles"";
	}
	StringBuilder sb = new StringBuilder();
	for (Entry<String, List<CheckMovieHashItem>> entry : titles.entrySet()) {
		sb.append(indentation).append(entry.getKey()).append("":\n"");
		sb.append(toLogStringTitles(entry.getValue(), 2 * indent));
	}
	return sb.toString();
}","/**
 * Creates a {@link String} where each file hash in {@code titles} is on its
 * own line and indented with the specified number of spaces. The
 * {@link CheckMovieHashItem}s for each file hash is listed as sub-items
 * with double indentation.
 *
 * @param titles the {@link Map} of [file hash, {@link CheckMovieHashItem}]
 *            pairs to format for logging.
 * @param indent the number of leading spaces for ""one indentation"".
 * @return The log friendly {@link String}.
 */
public static String toLogString(Map<String, List<CheckMovieHashItem>> titles, int indent) 
{
    StringBuilder sb = new StringBuilder();
    for (Map.Entry<String, List<CheckMovieHashItem>> entry : titles.entrySet())
    {
        sb.append(StringUtil.repeat(' ', indent)).append(entry.getKey()).append('\n');
        for (CheckMovieHashItem item : entry.getValue())
        {
            sb.append(StringUtil.repeat(' ', indent * 2)).append(item).append('\n');
        }
    }
    return sb.toString();
}   ",1102,True
"/**
 * Enhances existing metadata attached to this media by querying
 * OpenSubtitles.
 *
 * @param file
 * @param media
 */
public static void backgroundLookupAndAdd(final File file, final DLNAMediaInfo media){
	final boolean overTheTopLogging = false;
	if (!PMS.get().getDatabase().isOpenSubtitlesMetadataExists(file.getAbsolutePath(), file.lastModified())) {
		Runnable r = () -> {
			String[] metadataFromOpenSubtitles;
			try {
				metadataFromOpenSubtitles = getInfo(file, file.getName());

				if (metadataFromOpenSubtitles == null) {
					LOGGER.trace(""Failed lookup for "" + file.getName());
					return;
				}

				String titleFromFilename = media.getMovieOrShowName();
				String yearFromFilename = media.getYear();
				String tvSeasonFromFilename = media.getTVSeason();
				String tvEpisodeNumberFromFilename = media.getTVEpisodeNumber();

				String titleFromDatabase;
				String titleFromDatabaseSimplified;
				String titleFromOpenSubtitlesSimplified;

				String titleFromOpenSubtitles = metadataFromOpenSubtitles[2];
				titleFromOpenSubtitlesSimplified = FileUtil.getSimplifiedShowName(titleFromOpenSubtitles);
				String tvSeasonFromOpenSubtitles = metadataFromOpenSubtitles[3];
				String tvEpisodeNumberFromOpenSubtitles = metadataFromOpenSubtitles[4];
				if (tvEpisodeNumberFromOpenSubtitles.length() == 1) {
					tvEpisodeNumberFromOpenSubtitles = ""0"" + tvEpisodeNumberFromOpenSubtitles;
				}

				/**
				 * We have data from OpenSubtitles, but before storing it in
				 * our database we validate it against the data extracted
				 * from the filename. This is because sometimes
				 * OpenSubtitles reports incorrect data.
				 */
				if (overTheTopLogging) {
					LOGGER.trace(""Found "" + file.getName() + "" : "" + titleFromOpenSubtitles);
				}

				// Proceed if the years match, or if there is no year
				// then try the movie/show name.
				if ((StringUtils.isNotBlank(yearFromFilename) && yearFromFilename.equals(metadataFromOpenSubtitles[5]) &&
					StringUtils.isNotEmpty(titleFromFilename)) ||
					(StringUtils.isBlank(yearFromFilename) && StringUtils.isNotEmpty(titleFromFilename))) {
					/**
					 * Finally, sometimes OpenSubtitles returns the
					 * incorrect season or episode number, so we validate
					 * those as well. This check will pass if either we
					 * don't know what the season and episode numbers are
					 * from the filename, or we do and they match with our
					 * results from OpenSubtitles.
					 */
					if ((StringUtils.isNotBlank(tvSeasonFromFilename) && StringUtils.isNotBlank(tvSeasonFromOpenSubtitles) &&
						tvSeasonFromFilename.equals(tvSeasonFromOpenSubtitles) && StringUtils.isNotBlank(tvEpisodeNumberFromFilename) &&
						StringUtils.isNotBlank(tvEpisodeNumberFromOpenSubtitles) &&
						tvEpisodeNumberFromFilename.equals(tvEpisodeNumberFromOpenSubtitles)) ||
						(StringUtils.isBlank(tvSeasonFromFilename) && StringUtils.isBlank(tvEpisodeNumberFromFilename))) {
						titleFromDatabase = PMS.get().getSimilarTVSeriesName(titleFromOpenSubtitles);
						titleFromDatabaseSimplified = FileUtil.getSimplifiedShowName(titleFromDatabase);
						if (overTheTopLogging) {
							LOGGER.trace(""titleFromDatabase: "" + titleFromDatabase);
							LOGGER.trace(""titleFromOpenSubtitles: "" + titleFromOpenSubtitles);
						}

						/**
						 * If there is a title from the database and it is
						 * not exactly the same as the one from
						 * OpenSubtitles, continue to see if we want to
						 * change that to make them all consistent.
						 */
						if (!"""".equals(titleFromDatabase) && !titleFromOpenSubtitles.equals(titleFromDatabase) &&
							titleFromOpenSubtitlesSimplified.equals(titleFromDatabaseSimplified)) {
							// Replace our close-but-not-exact title in
							// the database with the title from
							// OpenSubtitles.
							PMS.get().getDatabase().updateMovieOrShowName(titleFromDatabase, titleFromOpenSubtitles);
						}

						media.setIMDbID(metadataFromOpenSubtitles[0]);
						media.setMovieOrShowName(titleFromOpenSubtitles);
						media.setSimplifiedMovieOrShowName(titleFromOpenSubtitlesSimplified);
						media.setYear(metadataFromOpenSubtitles[5]);

						// If the filename has indicated this is a TV
						// episode
						if (StringUtils.isNotBlank(tvSeasonFromFilename)) {
							media.setTVSeason(tvSeasonFromOpenSubtitles);
							media.setTVEpisodeNumber(tvEpisodeNumberFromOpenSubtitles);
							if (StringUtils.isNotBlank(metadataFromOpenSubtitles[1])) {
								media.setTVEpisodeName(metadataFromOpenSubtitles[1]);
							}

							if (overTheTopLogging) {
								LOGGER.trace(""Setting is TV episode true for "" + Arrays.toString(metadataFromOpenSubtitles));
							}

							media.setIsTVEpisode(true);
						}

						if (PMS.get().getConfiguration().getUseCache()) {
							try {
								PMS.get().getDatabase().insertVideoMetadata(file.getAbsolutePath(), file.lastModified(), media);
							} catch (SQLException e) {
								LOGGER.error(""Could not update the database with information from OpenSubtitles for \""{}\"": {}"",
									file.getAbsolutePath(), e.getMessage());
								LOGGER.trace("""", e);
							}
						}
					}
				}
			} catch (IOException ex) {
				// This will happen regularly so just log it in trace
				// mode
				LOGGER.trace(""Error in OpenSubtitles parsing:"", ex);
			}
		};
		BACKGROUND_EXECUTOR.execute(r);
	} else {
		if (overTheTopLogging) {
			LOGGER.trace(""Metadata already exists for {}"", file.getName());
		}
	}
}","/**
 * Enhances existing metadata attached to this media by querying
 * OpenSubtitles.
 *
 * @param file
 * @param media
 */

public static void backgroundLookupAndAdd(final File file, final DLNAMediaInfo media) 
{
    if (file == null || media == null)
    {
        return;
    }

    final List<DLNAMediaInfo> medias = new ArrayList<DLNAMediaInfo>();
    medias.add(media);

    backgroundLookupAndAdd(file, medias);
}   ",1105,False
"/**
 * Logs in to OpenSubtitles and stores the result in {@link #token}. Some
 * users might get a different API address in response, which will be
 * reflected in the {@link URL} returned by this method.
 * <p>
 * <b>All access to {@link #token} must be protected by
 * {@link #TOKEN_LOCK}</b>.
 *
 * @param url The API {@link URL} to use for login.
 * @return The URL to use if the login was a success, {@code null}
 *         otherwise.
 */
private static URL login(){
	TOKEN_LOCK.writeLock().lock();
	try {
		if (token != null && token.isYoung()) {
			return token.isValid() ? token.getURL() : null;
		}
		LOGGER.debug(""Trying to log in to OpenSubtitles"");

		CredMgr.Credential credentials = PMS.getCred(""opensubtitles"");
		String pword = """";
		String username = """";
		if (credentials != null) {
			// if we got credentials use them
			if (isNotBlank(credentials.password)) {
				pword = DigestUtils.md5Hex(credentials.password);
			}
			username = credentials.username;
		}

		// Setup connection
		URL url;
		try {
			url = new URL(OPENSUBS_URL);
		} catch (MalformedURLException e) {
			throw new AssertionError(""OpenSubtitles URL \"""" + OPENSUBS_URL + ""\"" is invalid"");
		}

		URLConnection urlConnection = url.openConnection();
		if (!(urlConnection instanceof HttpURLConnection)) {
			throw new OpenSubtitlesException(""Invalid URL: "" + OPENSUBS_URL);
		}
		HttpURLConnection connection = (HttpURLConnection) urlConnection;
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setRequestProperty(""Content-Type"", ""text/xml;charset=UTF-8"");
		connection.setRequestMethod(""POST"");
		connection.setConnectTimeout(2000);

		// Create request
		Params params = new Params();
		params.add(new ValueString(username));
		params.add(new ValueString(pword));
		params.add(new ValueString(null));
		params.add(new ValueString(UA));

		// Send request
		try (OutputStream out = LOGGER.isTraceEnabled() ?
				new LoggableOutputStream(connection.getOutputStream(), StandardCharsets.UTF_8) :
				connection.getOutputStream()
		) {
			XMLStreamWriter writer = createWriter(out);
			writeMethod(writer, ""LogIn"", params);
			writer.flush();
			if (out instanceof LoggableOutputStream) {
				LOGGER.trace(""Sending OpenSubtitles login request:\n{}"", toLogString((LoggableOutputStream) out));
			}
		} catch (XMLStreamException | FactoryConfigurationError e) {
			LOGGER.error(""An error occurred while generating OpenSubtitles login request: {}"", e.getMessage());
			LOGGER.trace("""", e);
		}

		// Parse reply
		params = null;
		try (InputStream reply = LOGGER.isTraceEnabled() ?
			new LoggableInputStream(sendXMLStream(connection, 5, 500), StandardCharsets.UTF_8) :
				sendXMLStream(connection, 5, 500)
		) {
			LOGGER.trace(""Parsing OpenSubtitles login response"");
			XMLStreamReader reader = null;
			try {
				reader = createReader(reply);
				params = readMethodResponse(reader);
			} finally {
				if (reader != null) {
					reader.close();
				}
			}
			if (reply instanceof LoggableInputStream) {
				LOGGER.trace(""Received OpenSubtitles login response:\n{}"", toLogString((LoggableInputStream) reply));
			}
		}

		if (params == null) {
			LOGGER.error(""Failed to parse Opensubtitles login response, aborting"");
			token = Token.createInvalidToken();
			return null;
		}
		if (params.size() != 1 || !(params.get(0).getValue() instanceof Struct)) {
			LOGGER.error(""Unexpected reply from OpenSubtitles:\n{}"", params);
			token = Token.createInvalidToken();
			return null;
		}

		// Handle status code
		if (!checkStatus(params)) {
			token = Token.createInvalidToken();
			LOGGER.error(""OpenSubtitles login was aborted"");
			return null;
		}

		Struct members = (Struct) params.get(0).getValue();

		// Check token
		String tokenString;
		Member<?, ?> member = members.get(""token"");
		if (!(member instanceof MemberString) || isBlank(((MemberString) member).getValue())) {
			LOGGER.error(""Failed to parse OpenSubtitles login token: {}"", member);
			token = Token.createInvalidToken();
			return null;
		}
		tokenString = ((MemberString) member).getValue();

		// Parse user
		User tokenUser = null;
		member = members.get(""data"");
		if (member != null) {
			tokenUser = User.createFromStruct((Struct) member.getValue());
		}

		// Create Token
		token = new Token(tokenString, tokenUser, url);
		if (!token.isValid()) {
			LOGGER.error(""Failed to log in to OpenSubtitles"");
			return null;
		}
		if (LOGGER.isDebugEnabled()) {
			if (token.getUser() != null) {
				// XXX If log anonymization is ever implemented, hide the
				// nickname.
				LOGGER.debug(""Successfully logged in to OpenSubtitles as {}"", token.getUser().getUserNickName());
			} else {
				LOGGER.debug(""Successfully logged in to OpenSubtitles anonymously"");
			}
		}
		return token.getURL();
	} catch (XMLStreamException | IOException e) {
		LOGGER.error(""An error occurred during OpenSubtitles login: {}"", e.getMessage());
		LOGGER.trace("""", e);
		token = Token.createInvalidToken();
		return null;
	} finally {
		TOKEN_LOCK.writeLock().unlock();
	}
}","/**
 * Logs in to OpenSubtitles and stores the result in {@link #token}. Some
 * users might get a different API address in response, which will be
 * reflected in the {@link URL} returned by this method.
 * <p>
 * <b>All access to {@link #token} must be protected by
 * {@link #TOKEN_LOCK}</b>.
 *
 * @param url The API {@link URL} to use for login.
 * @return The URL to use if the login was a success, {@code null}
 *         otherwise.
 */



private static URL login() 
{
    try
    {
        URL url = new URL(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"");
        XmlRpcClientConfigImpl config = new XmlRpcClientConfigImpl();
        config.setServerURL(url);
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);

        Object[] params = { """", """", ""en"", ""OpenSubtitlesPlayer v1.0"" };
        Object result = client.execute(""LogIn"", params);

        if (result instanceof Map)
        {
            Map<?, ?> response = (Map<?, ?>) result;
            if (response.containsKey(""token""))
            {
                TOKEN_LOCK.lock();
                try
                {
                    token = (String) response.get(""token"");
                    return url;
                }
                finally
                {
                    TOKEN_LOCK.unlock();
                }
            }
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }

    return null;
}   ",1107,False
"/**
 * Tries to find relevant OpenSubtitles subtitles for the specified
 * {@link DLNAResource} for the specified renderer.
 *
 * @param resource the {@link DLNAResource} for which to find OpenSubtitles
 *            subtitles.
 * @param renderer the {@link RendererConfiguration} or {@code null}.
 * @return The {@link List} of found {@link SubtitleItem}. If none are
 *         found, an empty {@link List} is returned.
 */
public static ArrayList<SubtitleItem> findSubtitles(DLNAResource resource, RendererConfiguration renderer){
	ArrayList<SubtitleItem> result = new ArrayList<>();
	if (resource == null) {
		return new ArrayList<>();
	}
	URL url = login();
	if (url == null) {
		LOGGER.error(""Couldn't find any live subtitles for {} since OpenSubtitles login failed"", resource.getName());
		return new ArrayList<>();
	}

	String languageCodes = getLanguageCodes(renderer);
	String primaryLanguageCode = getPrimaryLanguageCode(languageCodes);
	String imdbId = null;
	FileNamePrettifier prettifier = new FileNamePrettifier(resource);
	boolean satisfactory = false;
	if (resource instanceof RealFile) {
		Path file = ((RealFile) resource).getFile().toPath();
		LOGGER.info(""Looking for OpenSubtitles subtitles for \""{}\"""", file);

		// Query by hash
		long fileSize;
		try {
			fileSize = Files.size(file);
		} catch (IOException e) {
			LOGGER.error(
				""Can't read the size of \""{}\"", please check that it exists and that read permission is granted"",
				file.toAbsolutePath()
			);
			LOGGER.trace("""", e);
			fileSize = 0L;
		}
		String fileHash;
		try {
			fileHash = getHash(file);
		} catch (IOException e) {
			LOGGER.error(""Couldn't calculate OpenSubtitles hash for \""{}\"": {}"", file.getFileName(), e.getMessage());
			LOGGER.trace("""", e);
			fileHash = null;
		}

		if (isNotBlank(fileHash) && fileSize > 0L) {
			result.addAll(findSubtitlesByFileHash(resource, fileHash, fileSize, languageCodes, prettifier));
			satisfactory = isSubtitlesSatisfactory(result, primaryLanguageCode);
		}

		if (!satisfactory && isBlank(imdbId)) {
			imdbId = ImdbUtil.extractImdbId(file, true);
			if (isBlank(imdbId)) {
				imdbId = findImdbIdByFileHash(resource, fileHash, fileSize, prettifier);
			}
		}
	}

	if (!satisfactory) {
		if (isBlank(imdbId)) {
			imdbId = guessImdbIdByFileName(resource, prettifier);
		}
		if (isNotBlank(imdbId)) {
			// Query by IMDB id
			result.addAll(findSubtitlesByImdbId(resource, imdbId, languageCodes, prettifier));
			satisfactory = isSubtitlesSatisfactory(result, primaryLanguageCode);
		}
	}

	if (!satisfactory) {
		// Query by name
		result.addAll(findSubtitlesByName(resource, languageCodes, prettifier));
	}

	if (result.size() > 0) {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace(
				""Found {} OpenSubtitles subtitles ({}) for \""{}\"":\n{}"",
				result.size(),
				satisfactory ? ""satisfied"" : ""unsatisfied"",
				resource.getName(),
				toLogString(result, 2)
			);
		} else {
			LOGGER.info(""Found {} OpenSubtitles subtitles for \""{}\"""", result.size(), resource.getName());
		}
	} else {
		LOGGER.info(""Couldn't find any OpenSubtitles subtitles for \""{}\"""", resource.getName());
	}

	return result;
}","/**
 * Tries to find relevant OpenSubtitles subtitles for the specified
 * {@link DLNAResource} for the specified renderer.
 *
 * @param resource the {@link DLNAResource} for which to find OpenSubtitles
 *            subtitles.
 * @param renderer the {@link RendererConfiguration} or {@code null}.
 * @return The {@link List} of found {@link SubtitleItem}. If none are
 *         found, an empty {@link List} is returned.
 */
public static ArrayList<SubtitleItem> findSubtitles(DLNAResource resource, RendererConfiguration renderer) 
{
    ArrayList<SubtitleItem> items = new ArrayList<SubtitleItem>();
    String query = resource.getQuery();
    if (query != null && !query.isEmpty())
    {
        String language = null;
        if (renderer != null)
        {
            language = renderer.getAudioLanguage();
        }
        if (language == null)
        {
            language = ""eng"";
        }
        try
        {
            items = OpenSubtitles.findSubtitles(query, language);
        }
        catch (Exception e)
        {
            LOGGER.error(""Error finding OpenSubtitles subtitles"", e);
        }
    }
    return items;
}   ",1108,False
"/**
 * Calculates the <a href=
 * ""http://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes""
 * >OpenSubtitles hash</a> for the specified {@link Path}.
 *
 * @param file the {@link Path} for which to calculate the hash.
 * @return The calculated OpenSubtitles hash or {@code null}.
 * @throws IOException If an I/O error occurs during the operation.
 */
public static String computeHash(Path file) throws IOException{
	if (!Files.isRegularFile(file)) {
		return null;
	}

	long size = Files.size(file);
	long chunkSizeForFile = Math.min(HASH_CHUNK_SIZE, size);

	try (FileChannel fileChannel = FileChannel.open(file)) {
		long head = computeHashForChunk(fileChannel.map(MapMode.READ_ONLY, 0, chunkSizeForFile));
		long tail = computeHashForChunk(fileChannel.map(MapMode.READ_ONLY, Math.max(size - HASH_CHUNK_SIZE, 0), chunkSizeForFile));

		return String.format(""%016x"", size + head + tail);
	}
}","/**
 * Calculates the <a href=
 * ""http://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes""
 * >OpenSubtitles hash</a> for the specified {@link Path}.
 *
 * @param file the {@link Path} for which to calculate the hash.
 * @return The calculated OpenSubtitles hash or {@code null}.
 * @throws IOException If an I/O error occurs during the operation.
 */

public static String computeHash(Path file) throws IOException 
{
    try (InputStream is = Files.newInputStream(file))
    {
        return computeHash(is);
    }
}   ",1110,True
"/**
 * Queries OpenSubtitles for subtitles matching a file with the specified
 * name.
 *
 * @param resource the {@link DLNAResource} for which subtitles are to be
 *            searched.
 * @param languageCodes the comma separated list of subtitle language codes.
 * @param prettifier the {@link FileNamePrettifier} to use.
 * @return A {@link List} with the found {@link SubtitleItem}s (might be
 *         empty).
 */
protected static ArrayList<SubtitleItem> findSubtitlesByName(
	DLNAResource resource,
	String languageCodes,
	FileNamePrettifier prettifier
){
	if (resource == null) {
		return new ArrayList<>();
	}
	String fileName = null;
	if (resource instanceof RealFile) {
		File file = ((RealFile) resource).getFile();
		if (file != null) {
			fileName = file.getName();
		}
	}
	if (fileName == null) {
		fileName = resource.getSystemName();
	}

	Array queryArray = new Array();
	if (isNotBlank(fileName)) {
		Struct queryStruct = new Struct();
		queryStruct.put(new MemberString(""tag"", fileName));
		if (isNotBlank(languageCodes)) {
			queryStruct.put(new MemberString(""sublanguageid"", languageCodes));
		}
		if (prettifier != null && prettifier.getSeason() > 0 && prettifier.getEpisode() > 0) {
			queryStruct.put(new MemberInt(""season"", prettifier.getSeason()));
			queryStruct.put(new MemberInt(""episode"", prettifier.getEpisode()));
		}
		queryArray.add(new ValueStruct(queryStruct));
	}
	if (prettifier != null && isNotBlank(prettifier.getName())) {
		Struct queryStruct = new Struct();
		queryStruct.put(new MemberString(""query"", prettifier.getName()));
		if (isNotBlank(languageCodes)) {
			queryStruct.put(new MemberString(""sublanguageid"", languageCodes));
		}
		if (prettifier.getSeason() > 0 && prettifier.getEpisode() > 0) {
			queryStruct.put(new MemberInt(""season"", prettifier.getSeason()));
			queryStruct.put(new MemberInt(""episode"", prettifier.getEpisode()));
		}
		queryArray.add(new ValueStruct(queryStruct));
	}

	return searchSubtitles(queryArray, resource, prettifier, ""filename"", fileName, -1);
}","/**
 * Queries OpenSubtitles for subtitles matching a file with the specified
 * name.
 *
 * @param resource the {@link DLNAResource} for which subtitles are to be
 *            searched.
 * @param languageCodes the comma separated list of subtitle language codes.
 * @param prettifier the {@link FileNamePrettifier} to use.
 * @return A {@link List} with the found {@link SubtitleItem}s (might be
 *         empty).
 */
protected static ArrayList<SubtitleItem> findSubtitlesByName(
	DLNAResource resource,
	String languageCodes,
	FileNamePrettifier prettifier
) 
{
	ArrayList<SubtitleItem> foundSubtitles = new ArrayList<>();

	// get the file name
	String fileName = resource.getName();

	// prettify the file name
	fileName = prettifier.prettify(fileName);

	// search for subtitles
	SearchSubtitles search = new SearchSubtitles();
	ArrayList<SubtitleItem> subtitles = search.search(
		fileName,
		languageCodes
	);

	// add the found subtitles to the list
	foundSubtitles.addAll(subtitles);

	return foundSubtitles;
}	",1112,False
"/**
 * Creates a {@link String} where each {@link CheckMovieHashItem} in
 * {@code titles} is on its own line and indented with the specified number
 * of spaces.
 *
 * @param titles the {@link Collection} of {@link CheckMovieHashItem}s to
 *            format for logging.
 * @param indent the number of leading spaces on each line.
 * @return The log friendly {@link String}.
 */
public static String toLogStringTitles(Collection<CheckMovieHashItem> titles, int indent){
	String indentation = indent > 0 ? StringUtil.fillString(' ', indent) : """";
	if (titles == null) {
		return indentation + ""Null"";
	}
	if (titles.isEmpty()) {
		return indentation + ""No matching titles"";
	}
	StringBuilder sb = new StringBuilder();
	for (CheckMovieHashItem item : titles) {
		sb.append(indentation).append(item).append(""\n"");
	}
	return sb.toString();
}","/**
 * Creates a {@link String} where each {@link CheckMovieHashItem} in
 * {@code titles} is on its own line and indented with the specified number
 * of spaces.
 *
 * @param titles the {@link Collection} of {@link CheckMovieHashItem}s to
 *            format for logging.
 * @param indent the number of leading spaces on each line.
 * @return The log friendly {@link String}.
 */
public static String toLogStringTitles(Collection<CheckMovieHashItem> titles, int indent) 
{
    StringBuilder sb = new StringBuilder();
    for (CheckMovieHashItem title : titles)
    {
        sb.append(""\n"");
        for (int i = 0; i < indent; i++)
        {
            sb.append("" "");
        }
        sb.append(title);
    }
    return sb.toString();
}   ",1113,True
"/**
 * Creates a new instance with the specified parameters.
 *
 * @param score the score for this candidate.
 * @param guessItem the {@link GuessItem} for this candidate.
 */
public GuessCandidate(double score, GuessItem guessItem){
	this.score = score;
	this.guessItem = guessItem;
}","/**
 * Creates a new instance with the specified parameters.
 *
 * @param score the score for this candidate.
 * @param guessItem the {@link GuessItem} for this candidate.
 */
public GuessCandidate(double score, GuessItem guessItem) 
{
    this.score = score;
    this.guessItem = guessItem;
}   ",1116,True
"/**
 * Evaluates whether the found set of subtitles are satisfactory or if more
 * searches should be performed.
 *
 * @param subtitleItems the currently found {@link SubtitleItem}s.
 * @param primaryLanguageCode the primary language code.
 * @return {@code true} if the list of subtitles are considered good enough,
 *         {@code false} otherwise.
 */
protected static boolean isSubtitlesSatisfactory(List<SubtitleItem> subtitleItems, String primaryLanguageCode){
	if (subtitleItems == null || subtitleItems.isEmpty()) {
		return false;
	}
	if (isBlank(primaryLanguageCode)) {
		return true;
	}
	String languageCode = primaryLanguageCode.trim().toLowerCase(Locale.ROOT);
	for (SubtitleItem item : subtitleItems) {
		String itemLangaugeCode = item.getLanguageCode();
		if (isNotBlank(itemLangaugeCode) && languageCode.equals(itemLangaugeCode.trim().toLowerCase(Locale.ROOT))) {
			return true;
		}
	}
	return false;
}","/**
 * Evaluates whether the found set of subtitles are satisfactory or if more
 * searches should be performed.
 *
 * @param subtitleItems the currently found {@link SubtitleItem}s.
 * @param primaryLanguageCode the primary language code.
 * @return {@code true} if the list of subtitles are considered good enough,
 *         {@code false} otherwise.
 */
protected static boolean isSubtitlesSatisfactory(List<SubtitleItem> subtitleItems, String primaryLanguageCode) 
{
    if (subtitleItems.isEmpty())
    {
        return false;
    }

    for (SubtitleItem subtitleItem : subtitleItems)
    {
        if (subtitleItem.getLanguageCode().equals(primaryLanguageCode))
        {
            return true;
        }
    }

    return false;
}   ",1118,True
"/**
 * Creates a new instance using the specified values.
 *
 * @param videoClassification the video classification.
 * @param subCount the {@code SubCount}.
 * @param seenCount the {@code SeenCount}.
 * @param imdbId the {@code IMDB ID}.
 * @param movieYear the release year.
 * @param movieHash the video file hash.
 * @param seriesEpisode the episode number or {@code -1} if it doesn't
 *            apply.
 * @param movieName the movie name/title.
 * @param seriesSeason the season number or {@code -1} if it doesn't
 *            apply.
 */
public CheckMovieHashItem(
	String videoClassification,
	int subCount,
	int seenCount,
	String imdbId,
	String movieYear,
	String movieHash,
	int seriesEpisode,
	String movieName,
	int seriesSeason
){
	super(movieName, movieYear, videoClassification, imdbId);
	this.subCount = subCount;
	this.seenCount = seenCount;
	this.movieHash = movieHash;
	this.seriesEpisode = seriesEpisode;
	this.seriesSeason = seriesSeason;
}","/**
 * Creates a new instance using the specified values.
 *
 * @param videoClassification the video classification.
 * @param subCount the {@code SubCount}.
 * @param seenCount the {@code SeenCount}.
 * @param imdbId the {@code IMDB ID}.
 * @param movieYear the release year.
 * @param movieHash the video file hash.
 * @param seriesEpisode the episode number or {@code -1} if it doesn't
 *            apply.
 * @param movieName the movie name/title.
 * @param seriesSeason the season number or {@code -1} if it doesn't
 *            apply.
 */
public CheckMovieHashItem(
	String videoClassification,
	int subCount,
	int seenCount,
	String imdbId,
	String movieYear,
	String movieHash,
	int seriesEpisode,
	String movieName,
	int seriesSeason
) 
{
	this.videoClassification = videoClassification;
	this.subCount = subCount;
	this.seenCount = seenCount;
	this.imdbId = imdbId;
	this.movieYear = movieYear;
	this.movieHash = movieHash;
	this.seriesEpisode = seriesEpisode;
	this.movieName = movieName;
	this.seriesSeason = seriesSeason;
}	",1119,True
"/**
 * 添加摘要信息(Docket)
 */
@Bean
public Docket controllerApi(){
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(new ApiInfoBuilder()
                    .title(""标题：某公司_用户信息管理系统_接口文档"")
                    .description(""描述：用于管理集团旗下公司的人员信息,具体包括XXX,XXX模块..."")
                    .contact(new Contact(""一只袜子"",null,null))
                    .version(""版本号:1.0"")
                    .build())
            .select()
            .apis(RequestHandlerSelectors.basePackage(""com.hehe.controller""))
            .paths(PathSelectors.any())
            .build();
}","/**
 * 添加摘要信息(Docket)
 */




@Bean
public Docket controllerApi() 
{
    return new Docket(DocumentationType.SWAGGER_2)
            .groupName(""controller"")
            .select()
            .apis(RequestHandlerSelectors.basePackage(""com.example.demo.controller""))
            .paths(PathSelectors.any())
            .build()
            .apiInfo(apiInfo());
}   ",1122,False
"/**
 * XML消息处理器
 */
@Bean
public MappingJackson2XmlHttpMessageConverter mappingJackson2XmlHttpMessageConverter(){
    MappingJackson2XmlHttpMessageConverter xmlConverter = new MappingJackson2XmlHttpMessageConverter();
    //设置解析XML的工具类
    XmlMapper xmlMapper = new XmlMapper();
    //设置解析日期的工具类
    xmlMapper.setDateFormat(dateFormat);
    //忽略未知属性 防止解析报错
    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    xmlConverter.setObjectMapper(xmlMapper);
    return xmlConverter;
}","/**
 * XML消息处理器
 */
@Bean
public MappingJackson2XmlHttpMessageConverter mappingJackson2XmlHttpMessageConverter() 
{
    MappingJackson2XmlHttpMessageConverter converter = new MappingJackson2XmlHttpMessageConverter();
    return converter;
}   ",1124,True
"//根据实际业务支持各种复杂格式的日期字符串。
@Override
public Date parse(String source){
    try {
        return super.parse(source);//支持解析指定pattern类型。
    } catch (Exception e) {
        try {
            return new StdDateFormat().parse(source);//支持解析long类型的时间戳
        } catch (ParseException e1) {
            throw new RuntimeException(""日期格式非法："" + e);
        }
    }
}","//根据实际业务支持各种复杂格式的日期字符串。


@Override
public Date parse(String source) 
{
    try
    {
        return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"").parse(source);
    }
    catch (ParseException e)
    {
        throw new RuntimeException(e);
    }
}   ",1126,False
"/**
 * 构建错误信息.(ErrorInfo)
 */
public ErrorInfo getErrorInfo(HttpServletRequest request, Throwable error){
    ErrorInfo errorInfo = new ErrorInfo();
    errorInfo.setTime(LocalDateTime.now().toString());
    errorInfo.setUrl(request.getRequestURL().toString());
    errorInfo.setError(error.toString());
    errorInfo.setStatusCode(getHttpStatus(request).value());
    errorInfo.setReasonPhrase(getHttpStatus(request).getReasonPhrase());
    errorInfo.setStackTrace(getStackTraceInfo(error, isIncludeStackTrace(request)));
    return errorInfo;
}","/**
 * 构建错误信息.(ErrorInfo)
 */
public ErrorInfo getErrorInfo(HttpServletRequest request, Throwable error) 
{
    ErrorInfo info = new ErrorInfo();
    info.setUrl(request.getRequestURL().toString());
    info.setMessage(error.getMessage());
    info.setStackTrace(getStackTrace(error));
    return info;
}   ",1131,False
"/**
 * 获取堆栈轨迹(StackTrace)
 *
 * @see DefaultErrorAttributes  #addStackTrace
 */
public String getStackTraceInfo(Throwable error, boolean flag){
    if (!flag) {
        return ""omitted"";
    }
    StringWriter stackTrace = new StringWriter();
    error.printStackTrace(new PrintWriter(stackTrace));
    stackTrace.flush();
    return stackTrace.toString();
}","/**
 * 获取堆栈轨迹(StackTrace)
 *
 * @see DefaultErrorAttributes  #addStackTrace
 */

public String getStackTraceInfo(Throwable error, boolean flag) 
{
    if (flag)
    {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        error.printStackTrace(pw);
        return sw.toString();
    }
    return """";
}   ",1133,True
"/**
 * JSON消息处理器
 */
@Bean
public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(){
    MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();
    //设置解析JSON工具类
    ObjectMapper objectMapper = new ObjectMapper();
    //设置解析日期的工具类
    objectMapper.setDateFormat(dateFormat);
    //忽略未知属性 防止解析报错
    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    jsonConverter.setObjectMapper(objectMapper);
    List<MediaType> list = new ArrayList<>();
    list.add(MediaType.APPLICATION_JSON_UTF8);
    jsonConverter.setSupportedMediaTypes(list);
    return jsonConverter;
}","/**
 * JSON消息处理器
 */
@Bean
public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() 
{
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
    converter.setObjectMapper(objectMapper());
    return converter;
}   ",1134,True
"/**
 * 获取错误.(Error/Exception)
 * <p>
 * 获取方式：通过Request对象获取(Key=""javax.servlet.error.exception"").
 *
 * @see DefaultErrorAttributes #addErrorDetails
 */
public Throwable getError(HttpServletRequest request){
    //根据HandlerExceptionResolver接口方法来获取错误.
    Throwable error = (Throwable) request.getAttribute(ERROR_NAME);
    //根据Request对象获取错误.
    if (error == null) {
        error = (Throwable) request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE);
    }
    //当获取错误非空,取出RootCause.
    if (error != null) {
        while (error instanceof ServletException && error.getCause() != null) {
            error = error.getCause();
        }
    }//当获取错误为null,此时我们设置错误信息即可.
    else {
        String message = (String) request.getAttribute(WebUtils.ERROR_MESSAGE_ATTRIBUTE);
        if (StringUtils.isEmpty(message)) {
            HttpStatus status = getHttpStatus(request);
            message = ""Unknown Exception But "" + status.value() + "" "" + status.getReasonPhrase();
        }
        error = new Exception(message);
    }
    return error;
}","/**
 * 获取错误.(Error/Exception)
 * <p>
 * 获取方式：通过Request对象获取(Key=""javax.servlet.error.exception"").
 *
 * @see DefaultErrorAttributes #addErrorDetails
 */
public Throwable getError(HttpServletRequest request) 
{
    Throwable exception = null;
    Object obj = request.getAttribute(""javax.servlet.error.exception"");
    if (obj instanceof Throwable)
    {
        exception = (Throwable) obj;
    }
    return exception;
}   ",1136,False
"/**
 * Check if the time that has been typed so far is completely legal, as is.
 */
private boolean isTypedTimeFullyLegal(){
    if (mIs24HourMode) {
        // For 24-hour mode, the time is legal if the hours and minutes are each legal. Note:
        // getEnteredTime() will ONLY call isTypedTimeFullyLegal() when NOT in 24hour mode.
        int[] values = getEnteredTime(null);
        return (values[0] >= 0 && values[1] >= 0 && values[1] < 60);
    } else {
        // For AM/PM mode, the time is legal if it contains an AM or PM, as those can only be
        // legally added at specific times based on the tree's algorithm.
        return (mTypedTimes.contains(getAmOrPmKeyCode(AM)) ||
                mTypedTimes.contains(getAmOrPmKeyCode(PM)));
    }
}","/**
 * Check if the time that has been typed so far is completely legal, as is.
 */
private boolean isTypedTimeFullyLegal() 
{
    if (mTypedTime.length() == 0)
    {
        return false;
    }

    return isTimeLegal(mTypedTime);
}   ",1140,False
"/**
 * Using the trigonometric Unit Circle, calculate the positions that the text will need to be
 * drawn at based on the specified circle radius. Place the values in the textGridHeights and
 * textGridWidths parameters.
 */
private void calculateGridSizes(float numbersRadius, float xCenter, float yCenter,
                                float textSize, float[] textGridHeights, float[] textGridWidths){
    /*
     * The numbers need to be drawn in a 7x7 grid, representing the points on the Unit Circle.
     */
    float offset1 = numbersRadius;
    // cos(30) = a / r => r * cos(30) = a => r * sqrt(3)/2 = a
    float offset2 = numbersRadius * ((float) Math.sqrt(3)) / 2f;
    // sin(30) = o / r => r * sin(30) = o => r / 2 = a
    float offset3 = numbersRadius / 2f;
    mPaint.setTextSize(textSize);
    // We'll need yTextBase to be slightly lower to account for the text's baseline.
    yCenter -= (mPaint.descent() + mPaint.ascent()) / 2;

    textGridHeights[0] = yCenter - offset1;
    textGridWidths[0] = xCenter - offset1;
    textGridHeights[1] = yCenter - offset2;
    textGridWidths[1] = xCenter - offset2;
    textGridHeights[2] = yCenter - offset3;
    textGridWidths[2] = xCenter - offset3;
    textGridHeights[3] = yCenter;
    textGridWidths[3] = xCenter;
    textGridHeights[4] = yCenter + offset3;
    textGridWidths[4] = xCenter + offset3;
    textGridHeights[5] = yCenter + offset2;
    textGridWidths[5] = xCenter + offset2;
    textGridHeights[6] = yCenter + offset1;
    textGridWidths[6] = xCenter + offset1;
}","/**
 * Using the trigonometric Unit Circle, calculate the positions that the text will need to be
 * drawn at based on the specified circle radius. Place the values in the textGridHeights and
 * textGridWidths parameters.
 */
private void calculateGridSizes(float numbersRadius, float xCenter, float yCenter,
                                float textSize, float[] textGridHeights, float[] textGridWidths) 
{
    for (int i = 0; i < 360; i++)
    {
        double angle = Math.toRadians(i);
        double x = xCenter + numbersRadius * Math.cos(angle);
        double y = yCenter + numbersRadius * Math.sin(angle);

        textGridHeights[i] = (float) y - textSize / 2;
        textGridWidths[i] = (float) x - textSize / 2;
    }
}   ",1143,True
"/**
 * Calculates the day that the given x position is in, accounting for week
 * number. Returns a Time referencing that day or null if
 *
 * @param x The x position of the touch event
 * @return A time object for the tapped day or null if the position wasn't
 * in a day
 */
public CalendarDay getDayFromLocation(float x, float y){
    int dayStart = mPadding;
    if (x < dayStart || x > mWidth - mPadding) {
        return null;
    }
    // Selection is (x - start) / (pixels/day) == (x -s) * day / pixels
    int row = (int) (y - MONTH_HEADER_SIZE) / mRowHeight;
    int column = (int) ((x - dayStart) * mNumDays / (mWidth - dayStart - mPadding));

    int day = column - findDayOffset() + 1;
    day += row * mNumDays;
    if (day < 1 || day > mNumCells) {
        return null;
    }
    return new CalendarDay(mYear, mMonth, day);
}","/**
 * Calculates the day that the given x position is in, accounting for week
 * number. Returns a Time referencing that day or null if
 *
 * @param x The x position of the touch event
 * @return A time object for the tapped day or null if the position wasn't
 * in a day
 */
public CalendarDay getDayFromLocation(float x, float y) 
{
    int day = getDayFromLocation(x);
    if (day < 1 || day > 31)
    {
        return null;
    }

    int month = getMonthFromLocation(y);
    if (month < 0 || month > 11)
    {
        return null;
    }

    int year = getYearFromLocation(y);

    Time time = new Time();
    time.set(day, month, year);
    return new CalendarDay(time);
}   ",1145,False
"/**
 * Get the keycode value for AM and PM in the current language.
 */
private int getAmOrPmKeyCode(int amOrPm){
    // Cache the codes.
    if (mAmKeyCode == -1 || mPmKeyCode == -1) {
        // Find the first character in the AM/PM text that is unique.
        KeyCharacterMap kcm = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        char amChar;
        char pmChar;
        for (int i = 0; i < Math.max(mAmText.length(), mPmText.length()); i++) {
            amChar = mAmText.toLowerCase(Locale.getDefault()).charAt(i);
            pmChar = mPmText.toLowerCase(Locale.getDefault()).charAt(i);
            if (amChar != pmChar) {
                KeyEvent[] events = kcm.getEvents(new char[]{amChar, pmChar});
                // There should be 4 events: a down and up for both AM and PM.
                if (events != null && events.length == 4) {
                    mAmKeyCode = events[0].getKeyCode();
                    mPmKeyCode = events[2].getKeyCode();
                } else {
                    Log.e(TAG, ""Unable to find keycodes for AM and PM."");
                }
                break;
            }
        }
    }
    if (amOrPm == AM) {
        return mAmKeyCode;
    } else if (amOrPm == PM) {
        return mPmKeyCode;
    }

    return -1;
}","/**
 * Get the keycode value for AM and PM in the current language.
 */

private int getAmOrPmKeyCode(int amOrPm) 
{
    if (amOrPm == Calendar.AM)
    {
        return KeyEvent.VK_A;
    }
    else if (amOrPm == Calendar.PM)
    {
        return KeyEvent.VK_P;
    }
    else
    {
        return -1;
    }
}   ",1147,False
"/**
 * Try to start keyboard mode with the specified key, as long as the timepicker is not in the
 * middle of a touch-event.
 *
 * @param keyCode The key to use as the first press. Keyboard mode will not be started if the
 *                key is not legal to start with. Or, pass in -1 to get into keyboard mode without a starting
 *                key.
 */
private void tryStartingKbMode(int keyCode){
    if (mTimePicker.trySettingInputEnabled(false) &&
            (keyCode == -1 || addKeyIfLegal(keyCode))) {
        mInKbMode = true;
        mDoneButton.setEnabled(false);
        updateDisplay(false);
    }
}","/**
 * Try to start keyboard mode with the specified key, as long as the timepicker is not in the
 * middle of a touch-event.
 *
 * @param keyCode The key to use as the first press. Keyboard mode will not be started if the
 *                key is not legal to start with. Or, pass in -1 to get into keyboard mode without a starting
 *                key.
 */
private void tryStartingKbMode(int keyCode) 
{
    if (keyCode == -1)
    {
        getKeyboard().start();
    }
    else if (keyCode >= 0 && keyCode <= 7)
    {
        getKeyboard().start(keyCode);
    }
}   ",1148,True
"/**
 * Used by the animation to move the numbers in and out.
 */
public void setAnimationRadiusMultiplier(float animationRadiusMultiplier){
    mAnimationRadiusMultiplier = animationRadiusMultiplier;
    mTextGridValuesDirty = true;
}","/**
 * Used by the animation to move the numbers in and out.
 */
public void setAnimationRadiusMultiplier(float animationRadiusMultiplier) 
{
    this.animationRadiusMultiplier = animationRadiusMultiplier;
    for (int i = 0; i < numbers.length; i++)
    {
        numbers[i].setAnimationRadiusMultiplier(animationRadiusMultiplier);
    }
}   ",1149,True
"/**
 * Do not override this method. Use {@link #onPreInit(Holo, Bundle)} and
 * {@link #onPostInit(Holo, Bundle)}
 */
protected void onInit(Holo config, Bundle savedInstanceState){
    if (mInited) {
        throw new IllegalStateException(""This instance was already inited"");
    }
    mInited = true;
    if (config == null) {
        config = createConfig(savedInstanceState);
    }
    if (config == null) {
        config = Holo.defaultConfig();
    }
    onPreInit(config, savedInstanceState);
    if (!config.ignoreApplicationInstanceCheck && !(getApplication() instanceof Application)) {
        boolean throwError = true;
        if (config.allowMockApplicationInstance) {
            try {
                throwError = !(getApplication() instanceof MockApplication);
                if (!throwError) {
                    Log.w(""HoloEverywhere"", ""Application instance is MockApplication. Wow. Let's begin tests..."");
                }
            } catch (Exception e) {
            }
        }
        if (throwError) {
            String text = ""Application instance isn't HoloEverywhere.\n"";
            if (getApplication().getClass() == android.app.Application.class) {
                text += ""Put attr 'android:name=\""org.holoeverywhere.app.Application\""'"" +
                        "" in <application> tag of AndroidManifest.xml"";
            } else {
                text += ""Please sure that you extend "" + getApplication().getClass() +
                        "" from a org.holoeverywhere.app.Application"";
            }
            throw new IllegalStateException(text);
        }
    }
    getLayoutInflater().setFragmentActivity(this);
    if (this instanceof Activity) {
        final Activity activity = (Activity) this;
        ThemeManager.applyTheme(activity, mLastThemeResourceId == 0);
        if (!config.ignoreThemeCheck && ThemeManager.getThemeType(this) == ThemeManager.INVALID) {
            throw new HoloThemeException(activity);
        }
        TypedArray a = obtainStyledAttributes(new int[]{android.R.attr.windowActionBarOverlay, R.attr.windowActionBarOverlay});
        if (a.getBoolean(0, false) || a.getBoolean(1, false)) {
            supportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
        }
        a.recycle();
        a = obtainStyledAttributes(new int[]{android.R.attr.windowActionModeOverlay, R.attr.windowActionBarOverlay});
        if (a.getBoolean(0, false) || a.getBoolean(1, false)) {
            supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);
        }
        a.recycle();
    }
    onPostInit(config, savedInstanceState);
    lockAttaching();
}","/**
 * Do not override this method. Use {@link #onPreInit(Holo, Bundle)} and
 * {@link #onPostInit(Holo, Bundle)}
 */
protected void onInit(Holo config, Bundle savedInstanceState) 
{
    if (savedInstanceState == null)
    {
        onPreInit(config, savedInstanceState);
        onPostInit(config, savedInstanceState);
    }
}   ",1150,False
"/**
 * Render the animations for appearing and disappearing.
 */
private void renderAnimations(){
    Keyframe kf0, kf1;

    // Set up animator for disappearing.
    kf0 = Keyframe.ofFloat(0f, 1f);
    kf1 = Keyframe.ofFloat(1f, 0.8f);
    PropertyValuesHolder radius = PropertyValuesHolder.ofKeyframe(
            ""animationRadiusMultiplier"", kf0, kf1);

    kf0 = Keyframe.ofFloat(0f, 1f);
    kf1 = Keyframe.ofFloat(1f, 0f);
    PropertyValuesHolder fade = PropertyValuesHolder.ofKeyframe(""alpha"", kf0, kf1);

    kf0 = Keyframe.ofFloat(0f, 0f);
    kf1 = Keyframe.ofFloat(1f, 70f);
    PropertyValuesHolder rotation = PropertyValuesHolder.ofKeyframe(""rotation"", kf0, kf1);

    mDisappearAnimator = ObjectAnimator.ofPropertyValuesHolder(
            this, radius, fade, rotation).setDuration(300);
    mDisappearAnimator.addUpdateListener(mInvalidateUpdateListener);


    // Set up animator for reappearing.
    kf0 = Keyframe.ofFloat(0f, 0.8f);
    kf1 = Keyframe.ofFloat(1f, 1f);
    radius = PropertyValuesHolder.ofKeyframe(
            ""animationRadiusMultiplier"", kf0, kf1);

    kf0 = Keyframe.ofFloat(0f, 0f);
    kf1 = Keyframe.ofFloat(1f, 1f);
    fade = PropertyValuesHolder.ofKeyframe(""alpha"", kf0, kf1);

    kf0 = Keyframe.ofFloat(0f, -70f);
    kf1 = Keyframe.ofFloat(1f, 0f);
    rotation = PropertyValuesHolder.ofKeyframe(""rotation"", kf0, kf1);

    mReappearAnimator = ObjectAnimator.ofPropertyValuesHolder(
            this, radius, fade, rotation).setDuration(300);
    mReappearAnimator.addUpdateListener(mInvalidateUpdateListener);
}","/**
 * Render the animations for appearing and disappearing.
 */
private void renderAnimations() 
{
    if (appearAnimation != null)
    {
        if (appearAnimation.isDone())
        {
            appearAnimation = null;
        }
        else
        {
            appearAnimation.render();
        }
    }

    if (disappearAnimation != null)
    {
        if (disappearAnimation.isDone())
        {
            disappearAnimation = null;
        }
        else
        {
            disappearAnimation.render();
        }
    }
}   ",1153,False
"/**
 * Called when the user clicks on a day. Handles callbacks to the
 * {@link OnDayClickListener} if one is set.
 *
 * @param day A time object representing the day that was clicked
 */
private void onDayClick(CalendarDay day){
    if (mOnDayClickListener != null) {
        mOnDayClickListener.onDayClick(this, day);
    }

    // This is a no-op if accessibility is turned off.
    mNodeProvider.sendEventForItem(day, AccessibilityEvent.TYPE_VIEW_CLICKED);
}","/**
 * Called when the user clicks on a day. Handles callbacks to the
 * {@link OnDayClickListener} if one is set.
 *
 * @param day A time object representing the day that was clicked
 */
private void onDayClick(CalendarDay day) 
{
    if (mOnDayClickListener != null)
    {
        mOnDayClickListener.onDayClick(this, day);
    }
}   ",1155,False
"/**
 * Sets up the text and style properties for painting. Override this if you
 * want to use a different paint.
 */
protected void initView(){

    mMonthTitlePaint = new Paint();
    mMonthTitlePaint.setFakeBoldText(true);
    mMonthTitlePaint.setAntiAlias(true);
    mMonthTitlePaint.setTextSize(MONTH_LABEL_TEXT_SIZE);
    mMonthTitlePaint.setTypeface(FontLoader.ROBOTO_BOLD.getTypeface(getContext()));
    mMonthTitlePaint.setColor(mMonthTitleColor);
    mMonthTitlePaint.setTextAlign(Align.CENTER);
    mMonthTitlePaint.setStyle(Style.FILL);

    mSelectedCirclePaint = new Paint();
    mSelectedCirclePaint.setFakeBoldText(true);
    mSelectedCirclePaint.setAntiAlias(true);
    mSelectedCirclePaint.setColor(mSelectedCircleColor);
    mSelectedCirclePaint.setTextAlign(Align.CENTER);
    mSelectedCirclePaint.setStyle(Style.FILL);
    mSelectedCirclePaint.setAlpha(SELECTED_CIRCLE_ALPHA);

    mMonthDayLabelPaint = new Paint();
    mMonthDayLabelPaint.setAntiAlias(true);
    mMonthDayLabelPaint.setTextSize(MONTH_DAY_LABEL_TEXT_SIZE);
    mMonthDayLabelPaint.setColor(mDayTextColor);
    mMonthDayLabelPaint.setTypeface(FontLoader.ROBOTO_REGULAR.getTypeface(getContext()));
    mMonthDayLabelPaint.setStyle(Style.FILL);
    mMonthDayLabelPaint.setTextAlign(Align.CENTER);
    mMonthDayLabelPaint.setFakeBoldText(true);

    mMonthNumPaint = new Paint();
    mMonthNumPaint.setAntiAlias(true);
    mMonthNumPaint.setTextSize(MINI_DAY_NUMBER_TEXT_SIZE);
    mMonthNumPaint.setStyle(Style.FILL);
    mMonthNumPaint.setTextAlign(Align.CENTER);
    mMonthNumPaint.setFakeBoldText(false);
}","/**
 * Sets up the text and style properties for painting. Override this if you
 * want to use a different paint.
 */


protected void initView() 
{
    setPaintStyle(Paint.Style.FILL);
    setTextColor(Color.WHITE);
    setTextSize(12);
    setTypeface(Typeface.DEFAULT_BOLD);
}   ",1156,False
"/**
 * Generates a description for a given time object. Since this
 * description will be spoken, the components are ordered by descending
 * specificity as DAY MONTH YEAR.
 *
 * @param item The time object to generate a description for
 * @return A description of the time object
 */
private CharSequence getItemDescription(CalendarDay item){
    if (recycle == null) {
        recycle = Calendar.getInstance();
    }
    recycle.set(item.year, item.month, item.day);
    CharSequence date = DateFormat.format(""dd MMMM yyyy"", recycle.getTimeInMillis());

    if (item.day == mSelectedDay) {
        return getContext().getString(R.string.item_is_selected, date);
    }

    return date;
}","/**
 * Generates a description for a given time object. Since this
 * description will be spoken, the components are ordered by descending
 * specificity as DAY MONTH YEAR.
 *
 * @param item The time object to generate a description for
 * @return A description of the time object
 */
private CharSequence getItemDescription(CalendarDay item) 
{
    StringBuilder text = new StringBuilder();

    if (item.getDay() != null)
    {
        text.append(item.getDay());
        text.append("". "");
    }

    if (item.getMonth() != null)
    {
        text.append(item.getMonthName());
        text.append("" "");
    }

    if (item.getYear() != null)
    {
        text.append(item.getYear());
    }

    return text;
}   ",1157,True
"/**
 * Tokenizes a {@code CharSequence} into a list of Strings.
 *
 * @param input text to be tokenized
 * @return a list of tokens as String objects
 */
public List<String> tokenizeToStrings(CharSequence input){
  Preconditions.checkNotNull(input);
  TwitterTokenStream tokenizer = getDefaultTokenStream();
  tokenizer.reset(input);
  return tokenizer.toStringList();
}","/**
 * Tokenizes a {@code CharSequence} into a list of Strings.
 *
 * @param input text to be tokenized
 * @return a list of tokens as String objects
 */
public List<String> tokenizeToStrings(CharSequence input) 
{
    List<String> tokens = new ArrayList<String>();
    Tokenizer tokenizer = new Tokenizer(input);
    while (tokenizer.hasNext())
    {
        tokens.add(tokenizer.next());
    }
    return tokens;
}   ",1160,False
"/**
 * Creates a new static asset.
 *
 * @param inputSupplier Supplier of the input stream from which to load the asset.
 * @param contentType HTTP content type of the asset.
 * @param cacheLocally If {@code true} the asset will be loaded once and stored in memory, if
 *    {@code false} it will be loaded on each request.
 */
public StaticAsset(InputSupplier<? extends InputStream> inputSupplier,
    String contentType, boolean cacheLocally){
  this.inputSupplier = checkNotNull(inputSupplier);
  this.contentType = checkNotNull(contentType);
  this.cacheLocally = cacheLocally;
}","/**
 * Creates a new static asset.
 *
 * @param inputSupplier Supplier of the input stream from which to load the asset.
 * @param contentType HTTP content type of the asset.
 * @param cacheLocally If {@code true} the asset will be loaded once and stored in memory, if
 *    {@code false} it will be loaded on each request.
 */
public StaticAsset(InputSupplier<? extends InputStream> inputSupplier,
    String contentType, boolean cacheLocally) 
{
  this.inputSupplier = inputSupplier;
  this.contentType = contentType;
  this.cacheLocally = cacheLocally;
}   ",1164,True
"/**
 * Loads the {@literal @CmdLine} argument configuration data stored in the classpath.
 *
 * @return The {@literal @CmdLine} argument configuration materialized from the classpath.
 * @throws ConfigurationException if any configuration data is malformed.
 * @throws IOException if the configuration data can not be read from the classpath.
 */
public static Configuration load() throws ConfigurationException, IOException{
  Map<String, URL> resources = getLiveResources();
  if (resources.isEmpty()) {
    LOG.fine(""No @CmdLine arg resources found on the classpath"");
  } else {
    LOG.fine(""Loading @CmdLine config for: "" + resources.keySet());
  }
  CharSource input = CharSource.concat(Iterables.transform(resources.values(), URL_TO_READER));
  return input.readLines(new ConfigurationParser());
}","/**
 * Loads the {@literal @CmdLine} argument configuration data stored in the classpath.
 *
 * @return The {@literal @CmdLine} argument configuration materialized from the classpath.
 * @throws ConfigurationException if any configuration data is malformed.
 * @throws IOException if the configuration data can not be read from the classpath.
 */
public static Configuration load() throws ConfigurationException, IOException 
{
    final Configuration config = new Configuration();
    final ClassLoader loader = Thread.currentThread().getContextClassLoader();
    final Enumeration<URL> resources = loader.getResources(CMD_LINE_CONFIG_FILE);
    while (resources.hasMoreElements())
    {
        final URL url = resources.nextElement();
        try (final InputStream in = url.openStream())
        {
            config.load(in);
        }
    }
    return config;
}   ",1165,False
"/**
 * Creates and exports a new stat that maintains the difference between the tick time
 * and the time since it was last reset.  Upon export, the counter will act as though it were just
 * reset.
 * <br/>
 * @param name Name of stat to export
 * @param granularity Time unit granularity to export.
 * @param ticker Ticker implementation
 */
public Elapsed(String name, final Time granularity, final Ticker ticker){
 MorePreconditions.checkNotBlank(name);
 Preconditions.checkNotNull(granularity);
 this.ticker = Preconditions.checkNotNull(ticker);

 reset();

 Stats.export(new StatImpl<Long>(name) {
   @Override public Long read() {
     return Amount.of(ticker.read() - lastEventNs.get(), Time.NANOSECONDS).as(granularity);
   }
 });
  }","/**
 * Creates and exports a new stat that maintains the difference between the tick time
 * and the time since it was last reset.  Upon export, the counter will act as though it were just
 * reset.
 * <br/>
 * @param name Name of stat to export
 * @param granularity Time unit granularity to export.
 * @param ticker Ticker implementation
 */
public Elapsed(String name, final Time granularity, final Ticker ticker) 
{
    this(name, granularity, ticker, false);
}   ",1167,True
"/**
 * Construct a Histogram with default arguments except name.
 * @see #Histogram(String, Amount, int, Amount, Precision, double[], Clock, MetricRegistry)
 */
public Histogram(String name){
  this(name, DEFAULT_WINDOW, DEFAULT_SLICES,
      DEFAULT_MAX_MEMORY, null,
      DEFAULT_QUANTILES,
      Clock.SYSTEM_CLOCK,
      null);
}","/**
 * Construct a Histogram with default arguments except name.
 * @see #Histogram(String, Amount, int, Amount, Precision, double[], Clock, MetricRegistry)
 */
public Histogram(String name) 
{
    this(name, Amount.DEFAULT, 0, Amount.DEFAULT, Precision.DEFAULT, null, Clock.defaultClock(), new MetricRegistry());
}   ",1168,True
"/**
 * Construct a Histogram with default arguments except name.
 * @see #Histogram(String, Amount, int, Amount, Precision, double[], Clock, MetricRegistry)
 *
 * 12/11/2013: Remove this method after the next deprecation cycle.
 * @deprecated Prefer registry.createHistogram(String)
 */
@Deprecated
public Histogram(String name, MetricRegistry registry){
  this(name, DEFAULT_WINDOW, DEFAULT_SLICES,
      DEFAULT_MAX_MEMORY, null,
      DEFAULT_QUANTILES,
      Clock.SYSTEM_CLOCK,
      registry);
}","/**
 * Construct a Histogram with default arguments except name.
 * @see #Histogram(String, Amount, int, Amount, Precision, double[], Clock, MetricRegistry)
 *
 * 12/11/2013: Remove this method after the next deprecation cycle.
 * @deprecated Prefer registry.createHistogram(String)
 */
@Deprecated
public Histogram(String name, MetricRegistry registry) 
{
    this(name, Amount.DEFAULT, 1, Amount.DEFAULT, Precision.NORMAL, null, Clock.defaultClock(), registry);
}   ",1173,True
"///etc/hosts"";
@Override
  public String echo() throws IOException{
    Closer closer = Closer.create();
    try {
      Configuration conf = new Configuration();
      Path p = new Path(FILENAME);

      FileSystem fs = closer.register(p.getFileSystem(conf));
      FSDataInputStream fsDataInputStream = closer.register(fs.open(p));
      InputStreamReader inputStreamReader =
          closer.register(new InputStreamReader(fsDataInputStream));
      BufferedReader bufferedReader = closer.register(new BufferedReader(inputStreamReader));
      ByteArrayOutputStream byteArrayOutputStream = closer.register(new ByteArrayOutputStream());
      String line = bufferedReader.readLine();
      if (line == null) {
        throw new RuntimeException(""Failed reading line from "" + FILENAME);
      }
      byteArrayOutputStream.write(line.getBytes());
      return byteArrayOutputStream.toString();
    } finally {
      closer.close();
    }
  }","///etc/hosts"";
@Override
  public String echo() throws IOException 
{
  String result = null;
  try
  {
    result = read(""/etc/hosts"");
  }
  catch (IOException e)
  {
    e.printStackTrace();
  }
  return result;
} ",1175,False
"/**
 * Construct a Histogram.
 * This constructor only exists for backward compatibility reasons.
 * See #Histogram(String, Amount<Long, Time>, int, Amount<Long, Data>,
 *   Precision, double[], Clock)
 */
public Histogram(String name, Amount<Long, Time> window, int slices,
    @Nullable Amount<Long, Data> maxMemory, @Nullable Precision precision,
    double[] quantiles,
    Clock clock,
    @Nullable MetricRegistry registry){
  Preconditions.checkArgument(precision != null ^ maxMemory != null,
      ""You must specify either memory or precision constraint but not both!"");
  Preconditions.checkNotNull(window);
  Preconditions.checkArgument(0 < slices);
  for (double q: quantiles) {
    Preconditions.checkArgument(0.0 <= q && q <= 1.0);
  }
  Preconditions.checkNotNull(clock);

  this.name = MorePreconditions.checkNotBlank(name);
  this.quantiles = Preconditions.checkNotNull(quantiles);
  if (maxMemory != null) {
    this.histogram = new WindowedApproxHistogram(window, slices, maxMemory, clock);
  } else {
    this.histogram = new WindowedApproxHistogram(window, slices, precision, clock);
  }
  this.stats = new WindowedStatistics(window, slices, clock);

  if (registry != null) {
    registry.registerHistogram(this);
  }
}","/**
 * Construct a Histogram.
 * This constructor only exists for backward compatibility reasons.
 * See #Histogram(String, Amount<Long, Time>, int, Amount<Long, Data>,
 *   Precision, double[], Clock)
 */
public Histogram(String name, Amount<Long, Time> window, int slices,
    @Nullable Amount<Long, Data> maxMemory, @Nullable Precision precision,
    double[] quantiles,
    Clock clock,
    @Nullable MetricRegistry registry) 
{
  this(name, window, slices, maxMemory, precision, quantiles, clock, registry, false);
}   ",1176,True
"// Gauss's formula
public static void main(String[] args){
   System.out.println(CHECK);
   timeTest(""Sum Stream"", CHECK, () ->
     LongStream.rangeClosed(0, SZ).sum());
   timeTest(""Sum Stream Parallel"", CHECK, () ->
     LongStream.rangeClosed(0, SZ).parallel().sum());
   timeTest(""Sum Iterated"", CHECK, () ->
     LongStream.iterate(0, i -> i + 1)
       .limit(SZ+1).sum());
   // Slower & runs out of memory above 1_000_000:
   // timeTest(""Sum Iterated Parallel"", CHECK, () ->
   //   LongStream.iterate(0, i -> i + 1)
   //     .parallel()
   //     .limit(SZ+1).sum());
 }","// Gauss's formula
public static void main(String[] args) 
{
    int n = 100;
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        sum += i;
    }
    System.out.println(sum);
}   ",1182,False
"// Support methods:
private void showFullness(){
  assertTrue(queue.full());
  assertFalse(queue.empty());
  System.out.println(queue.dump());
}","// Support methods:
private void showFullness() 
{
    System.out.print(""Fullness: "");
    for (int i = 0; i < size; i++)
    {
        System.out.print(array[i] + "" "");
    }
    System.out.println();
}   ",1189,True
"// Test the new class:
public static void main(String[] args){
  Detergent x = new Detergent();
  x.dilute();
  x.apply();
  x.scrub();
  x.foam();
  System.out.println(x);
  System.out.println(""Testing base class:"");
  Cleanser.main(args);
}","// Test the new class:
public static void main(String[] args) 
{
    // Create a new instance of the class
    MyClass myObject = new MyClass();

    // Call the method
    myObject.myMethod();
}   ",1191,False
"// Demonstration:
public static void
main(String[] args) throws Exception{
  PathMatcher matcher = FileSystems.getDefault()
    .getPathMatcher(""glob:**/*.class"");
  // Walk the entire tree:
  Files.walk(Paths.get("".""))
    .filter(matcher::matches)
    .map(p -> {
        try {
          return thisClass(Files.readAllBytes(p));
        } catch(Exception e) {
          throw new RuntimeException(e);
        }
      })
    .filter(s -> s.startsWith(""public:""))
    // .filter(s -> s.indexOf('$') >= 0)
    .map(s -> s.split("":"")[1])
    .filter(s -> !s.startsWith(""enums.""))
    .filter(s -> s.contains("".""))
    .forEach(System.out::println);
}","// Demonstration:
public static void
main(String[] args) throws Exception 
{
    String s = ""Hello"";
    String t = ""World"";
    System.out.println(s + t);
    System.out.println(s.concat(t));
}   ",1193,False
"// Template method:
protected final void runAll(){
  while(changeState()) // Customizable
    currentState.run();
}","// Template method:
protected final void runAll() 
{
    for (int i = 0; i < 10; i++)
    {
        runOnce();
    }
}   ",1198,False
"// Argument must be final or ""effectively final""
// to use within the anonymous inner class:
public Destination destination(final String dest){
  return new Destination() {
    private String label = dest;
    @Override
    public String readLabel() { return label; }
  };
}","// Argument must be final or ""effectively final""
// to use within the anonymous inner class:
public Destination destination(final String dest) 
{
    return new Destination()
    {
        private String label = dest;
        public String readLabel()
        {
            return label;
        }
    };
}   ",1199,True
"/**
 * Remove a listener that was previously added via
 * {@link #addOnPageChangeListener(OnPageChangeListener)}.
 *
 * @param listener listener to remove
 */
public void removeOnPageChangeListener(OnPageChangeListener listener){
    if (mOnPageChangeListeners != null) {
        mOnPageChangeListeners.remove(listener);
    }
}","/**
 * Remove a listener that was previously added via
 * {@link #addOnPageChangeListener(OnPageChangeListener)}.
 *
 * @param listener listener to remove
 */
public void removeOnPageChangeListener(OnPageChangeListener listener) 
{
    synchronized (mListeners)
    {
        mListeners.remove(listener);
    }
}   ",1201,True
"/**
 * We only want the current page that is being shown to be focusable.
 */
@Override
public void addFocusables(ArrayList<View> views, int direction, int focusableMode){
    final int focusableCount = views.size();

    final int descendantFocusability = getDescendantFocusability();

    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        for (int i = 0; i < getChildCount(); i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == VISIBLE) {
                ItemInfo ii = infoForChild(child);
                if (ii != null && ii.position == mCurItem) {
                    child.addFocusables(views, direction, focusableMode);
                }
            }
        }
    }

    // we add ourselves (if focusable) in all cases except for when we are
    // FOCUS_AFTER_DESCENDANTS and there are some descendants focusable.  this is
    // to avoid the focus search finding layouts when a more precise search
    // among the focusable children would be more interesting.
    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS
            || (focusableCount == views.size())) { // No focusable descendants
        // Note that we can't call the superclass here, because it will
        // add all views in.  So we need to do the same thing View does.
        if (!isFocusable()) {
            return;
        }
        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE
                && isInTouchMode() && !isFocusableInTouchMode()) {
            return;
        }
        if (views != null) {
            views.add(this);
        }
    }
}","/**
 * We only want the current page that is being shown to be focusable.
 */
@Override
public void addFocusables(ArrayList<View> views, int direction, int focusableMode) 
{
    if (mCurrentPage != null)
    {
        mCurrentPage.addFocusables(views, direction);
    }
}   ",1203,False
"/**
 * This method will be invoked when the current page is scrolled, either as part
 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
 * If you override this method you must call through to the superclass implementation
 * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled
 * returns.
 *
 * @param position Position index of the first page currently being displayed.
 *                 Page position+1 will be visible if positionOffset is nonzero.
 * @param offset Value from [0, 1) indicating the offset from the page at position.
 * @param offsetPixels Value in pixels indicating the offset from position.
 */
@CallSuper
protected void onPageScrolled(int position, float offset, int offsetPixels){
    // Offset any decor views if needed - keep them on-screen at all times.
    if (mDecorChildCount > 0) {
        final int scrollX = getScrollX();
        int paddingLeft = getPaddingLeft();
        int paddingRight = getPaddingRight();
        final int width = getWidth();
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            if (!lp.isDecor) continue;

            final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
            int childLeft = 0;
            switch (hgrav) {
                default:
                    childLeft = paddingLeft;
                    break;
                case Gravity.LEFT:
                    childLeft = paddingLeft;
                    paddingLeft += child.getWidth();
                    break;
                case Gravity.CENTER_HORIZONTAL:
                    childLeft = Math.max((width - child.getMeasuredWidth()) / 2,
                            paddingLeft);
                    break;
                case Gravity.RIGHT:
                    childLeft = width - paddingRight - child.getMeasuredWidth();
                    paddingRight += child.getMeasuredWidth();
                    break;
            }
            childLeft += scrollX;

            final int childOffset = childLeft - child.getLeft();
            if (childOffset != 0) {
                child.offsetLeftAndRight(childOffset);
            }
        }
    }

    dispatchOnPageScrolled(position, offset, offsetPixels);

    if (mPageTransformer != null) {
        final int scrollX = getScrollX();
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            if (lp.isDecor) continue;
            final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth();
            mPageTransformer.transformPage(child, transformPos);
        }
    }

    mCalledSuper = true;
}","/**
 * This method will be invoked when the current page is scrolled, either as part
 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
 * If you override this method you must call through to the superclass implementation
 * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled
 * returns.
 *
 * @param position Position index of the first page currently being displayed.
 *                 Page position+1 will be visible if positionOffset is nonzero.
 * @param offset Value from [0, 1) indicating the offset from the page at position.
 * @param offsetPixels Value in pixels indicating the offset from position.
 */
@CallSuper
protected void onPageScrolled(int position, float offset, int offsetPixels) 
{
    if (mTabStrip != null)
    {
        mTabStrip.onViewPagerPageChanged(position, offset);

        int tabCount = mTabStrip.getTabCount();
        if ((position >= tabCount) && (tabCount != 0))
        {
            return;
        }

        int leftTab = mTabStrip.getLeftTab(position);
        int rightTab = 0;
        if (position < (tabCount - 1))
        {
            rightTab = mTabStrip.getLeftTab(position + 1);
        }

        if (leftTab != mCurrentLeftTab)
        {
            mCurrentLeftTab = leftTab;
            onLeftTabChanged(mCurrentLeftTab);
        }

        if (rightTab != mCurrentRightTab)
        {
            mCurrentRightTab = rightTab;
            onRightTabChanged(mCurrentRightTab);
        }

        if (mCurrentLeftTab == mCurrentRightTab)
        {
            onTabSelected(mCurrentLeftTab);
        }
    }
}   ",1205,True
"/**
 * Set the number of pages that should be retained to either side of the
 * current page in the view hierarchy in an idle state. Pages beyond this
 * limit will be recreated from the adapter when needed.
 *
 * <p>This is offered as an optimization. If you know in advance the number
 * of pages you will need to support or have lazy-loading mechanisms in place
 * on your pages, tweaking this setting can have benefits in perceived smoothness
 * of paging animations and interaction. If you have a small number of pages (3-4)
 * that you can keep active all at once, less time will be spent in layout for
 * newly created view subtrees as the user pages back and forth.</p>
 *
 * <p>You should keep this limit low, especially if your pages have complex layouts.
 * This setting defaults to 1.</p>
 *
 * @param limit How many pages will be kept offscreen in an idle state.
 */
public void setOffscreenPageLimit(int limit){
    if (limit < DEFAULT_OFFSCREEN_PAGES) {
        Log.w(TAG, ""Requested offscreen page limit "" + limit + "" too small; defaulting to ""
                + DEFAULT_OFFSCREEN_PAGES);
        limit = DEFAULT_OFFSCREEN_PAGES;
    }
    if (limit != mOffscreenPageLimit) {
        mOffscreenPageLimit = limit;
        populate();
    }
}","/**
 * Set the number of pages that should be retained to either side of the
 * current page in the view hierarchy in an idle state. Pages beyond this
 * limit will be recreated from the adapter when needed.
 *
 * <p>This is offered as an optimization. If you know in advance the number
 * of pages you will need to support or have lazy-loading mechanisms in place
 * on your pages, tweaking this setting can have benefits in perceived smoothness
 * of paging animations and interaction. If you have a small number of pages (3-4)
 * that you can keep active all at once, less time will be spent in layout for
 * newly created view subtrees as the user pages back and forth.</p>
 *
 * <p>You should keep this limit low, especially if your pages have complex layouts.
 * This setting defaults to 1.</p>
 *
 * @param limit How many pages will be kept offscreen in an idle state.
 */
public void setOffscreenPageLimit(int limit) 
{
    if (limit < DEFAULT_OFFSCREEN_PAGES_LIMIT) {
        throw new IllegalArgumentException(""Can't have a limit less than "" +
                DEFAULT_OFFSCREEN_PAGES_LIMIT);
    }
    mOffscreenPageLimit = limit;
    requestLayout();
}   ",1206,True
"/**
 * Check if this ViewPager can be scrolled horizontally in a certain direction.
 *
 * @param direction Negative to check scrolling left, positive to check scrolling right.
 * @return Whether this ViewPager can be scrolled in the specified direction. It will always
 *         return false if the specified direction is 0.
 */
public boolean canScrollHorizontally(int direction){
    if (mAdapter == null) {
        return false;
    }

    final int width = getClientWidth();
    final int scrollX = getScrollX();
    if (direction < 0) {
        return (scrollX > (int) (width * mFirstOffset));
    } else if (direction > 0) {
        return (scrollX < (int) (width * mLastOffset));
    } else {
        return false;
    }
}","/**
 * Check if this ViewPager can be scrolled horizontally in a certain direction.
 *
 * @param direction Negative to check scrolling left, positive to check scrolling right.
 * @return Whether this ViewPager can be scrolled in the specified direction. It will always
 *         return false if the specified direction is 0.
 */
public boolean canScrollHorizontally(int direction) 
{
    if (direction == 0)
    {
        return false;
    }

    return this.canScrollHorizontallyInternal(direction);
}   ",1208,True
"/**
 * Set the margin between pages.
 *
 * @param marginPixels Distance between adjacent pages in pixels
 * @see #getPageMargin()
 * @see #setPageMarginDrawable(Drawable)
 * @see #setPageMarginDrawable(int)
 */
public void setPageMargin(int marginPixels){
    final int oldMargin = mPageMargin;
    mPageMargin = marginPixels;

    final int width = getWidth();
    recomputeScrollPosition(width, width, marginPixels, oldMargin);

    requestLayout();
}","/**
 * Set the margin between pages.
 *
 * @param marginPixels Distance between adjacent pages in pixels
 * @see #getPageMargin()
 * @see #setPageMarginDrawable(Drawable)
 * @see #setPageMarginDrawable(int)
 */
public void setPageMargin(int marginPixels) 
{
    mPageMargin = marginPixels;
    requestLayout();
}   ",1209,True
"/**
 * Remove a listener that was previously added via
 * {@link #addOnAdapterChangeListener(OnAdapterChangeListener)}.
 *
 * @param listener listener to remove
 */
public void removeOnAdapterChangeListener(@NonNull OnAdapterChangeListener listener){
    if (mAdapterChangeListeners != null) {
        mAdapterChangeListeners.remove(listener);
    }
}","/**
 * Remove a listener that was previously added via
 * {@link #addOnAdapterChangeListener(OnAdapterChangeListener)}.
 *
 * @param listener listener to remove
 */
public void removeOnAdapterChangeListener(@NonNull OnAdapterChangeListener listener) 
{
    synchronized (mListeners)
    {
        mListeners.remove(listener);
    }
}   ",1211,True
"/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch (event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                handled = arrowScroll(FOCUS_LEFT);
                break;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                handled = arrowScroll(FOCUS_RIGHT);
                break;
            case KeyEvent.KEYCODE_TAB:
                if (Build.VERSION.SDK_INT >= 11) {
                    // The focus finder had a bug handling FOCUS_FORWARD and FOCUS_BACKWARD
                    // before Android 3.0. Ignore the tab key on those devices.
                    if (KeyEventCompat.hasNoModifiers(event)) {
                        handled = arrowScroll(FOCUS_FORWARD);
                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {
                        handled = arrowScroll(FOCUS_BACKWARD);
                    }
                }
                break;
        }
    }
    return handled;
}","/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event) 
{
    keyDown();
    switch (event.getAction()) {
        case KeyEvent.ACTION_DOWN:
            return onKeyDown(event.getKeyCode(), event);
        case KeyEvent.ACTION_UP:
            return onKeyUp(event.getKeyCode(), event);
        default:
            return false;
    }
}   ",1214,False
"/**
 * Add a listener that will be invoked whenever the page changes or is incrementally
 * scrolled. See {@link OnPageChangeListener}.
 *
 * <p>Components that add a listener should take care to remove it when finished.
 * Other components that take ownership of a view may call {@link #clearOnPageChangeListeners()}
 * to remove all attached listeners.</p>
 *
 * @param listener listener to add
 */
public void addOnPageChangeListener(OnPageChangeListener listener){
    if (mOnPageChangeListeners == null) {
        mOnPageChangeListeners = new ArrayList<>();
    }
    mOnPageChangeListeners.add(listener);
}","/**
 * Add a listener that will be invoked whenever the page changes or is incrementally
 * scrolled. See {@link OnPageChangeListener}.
 *
 * <p>Components that add a listener should take care to remove it when finished.
 * Other components that take ownership of a view may call {@link #clearOnPageChangeListeners()}
 * to remove all attached listeners.</p>
 *
 * @param listener listener to add
 */
public void addOnPageChangeListener(OnPageChangeListener listener) 
{
    if (mOnPageChangeListeners == null)
    {
        mOnPageChangeListeners = new ArrayList<>();
    }
    mOnPageChangeListeners.add(listener);
}   ",1217,True
"/**
 * Tests scrollability within child views of v given a delta of dx.
 *
 * @param v View to test for horizontal scrollability
 * @param checkV Whether the view v passed should itself be checked for scrollability (true),
 *               or just its children (false).
 * @param dx Delta scrolled in pixels
 * @param x X coordinate of the active touch point
 * @param y Y coordinate of the active touch point
 * @return true if child views of v can be scrolled by delta of dx.
 */
protected boolean canScroll(View v, boolean checkV, int dx, int x, int y){
    if (v instanceof ViewGroup) {
        final ViewGroup group = (ViewGroup) v;
        final int scrollX = v.getScrollX();
        final int scrollY = v.getScrollY();
        final int count = group.getChildCount();
        // Count backwards - let topmost views consume scroll distance first.
        for (int i = count - 1; i >= 0; i--) {
            // TODO: Add versioned support here for transformed views.
            // This will not work for transformed views in Honeycomb+
            final View child = group.getChildAt(i);
            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight()
                    && y + scrollY >= child.getTop() && y + scrollY < child.getBottom()
                    && canScroll(child, true, dx, x + scrollX - child.getLeft(),
                    y + scrollY - child.getTop())) {
                return true;
            }
        }
    }

    return checkV && ViewCompat.canScrollHorizontally(v, -dx);
}","/**
 * Tests scrollability within child views of v given a delta of dx.
 *
 * @param v View to test for horizontal scrollability
 * @param checkV Whether the view v passed should itself be checked for scrollability (true),
 *               or just its children (false).
 * @param dx Delta scrolled in pixels
 * @param x X coordinate of the active touch point
 * @param y Y coordinate of the active touch point
 * @return true if child views of v can be scrolled by delta of dx.
 */
protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) 
{
    if (v instanceof ScrollView)
    {
        ScrollView sv = (ScrollView) v;
        View child = sv.getChildAt(0);
        if (child != null)
        {
            int childWidth = child.getWidth();
            int scrollX = sv.getScrollX();
            int childRight = child.getWidth();
            int width = sv.getWidth();
            int right = sv.getScrollX() + width;

            if (childWidth > width)
            {
                if (dx < 0 && scrollX > 0)
                {
                    return true;
                }
                else if (dx > 0 && childRight > right)
                {
                    return true;
                }
            }
        }
    }
    return false;
}   ",1218,True
"/**
 * End a fake drag of the pager.
 *
 * @see #beginFakeDrag()
 * @see #fakeDragBy(float)
 */
public void endFakeDrag(){
    if (!mFakeDragging) {
        throw new IllegalStateException(""No fake drag in progress. Call beginFakeDrag first."");
    }

    if (mAdapter != null) {
        final VelocityTracker velocityTracker = mVelocityTracker;
        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
        int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
                velocityTracker, mActivePointerId);
        mPopulatePending = true;
        final int width = getClientWidth();
        final int scrollX = getScrollX();
        final ItemInfo ii = infoForCurrentScrollPosition();
        final int currentPage = ii.position;
        final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;
        final int totalDelta = (int) (mLastMotionX - mInitialMotionX);
        int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,
                totalDelta);
        setCurrentItemInternal(nextPage, true, true, initialVelocity);
    }
    endDrag();

    mFakeDragging = false;
}","/**
 * End a fake drag of the pager.
 *
 * @see #beginFakeDrag()
 * @see #fakeDragBy(float)
 */
public void endFakeDrag() 
{
    if (!mIsBeingDragged)
    {
        throw new IllegalStateException(""No fake drag in progress. Call beginFakeDrag() first."");
    }

    mScroller.computeScrollOffset();
    mLastMotionX = mScroller.getCurrX();
    mLastMotionY = mScroller.getCurrY();
    mIsBeingDragged = false;

    if (mVelocityTracker != null)
    {
        mVelocityTracker.recycle();
        mVelocityTracker = null;
    }
}   ",1219,False
"/**
 * 获取较纯净的手机号码<br />
 * 删除前缀、空格等
 *
 * @param phone
 * @return
 */
public static String getValidPhoneNumber(String phone){
	if (phone == null)
		return """";
	if (phone.startsWith(""0086"")) {
		phone = phone.substring(4);
	}
	if (phone.startsWith(""+86"")) {
		phone = phone.substring(3);
	}
	PhoneNumberUtils.stripSeparators(phone);
	phone = phone.replace(""-"", """").replace("" "", """").trim();
	return phone;
}","/**
 * 获取较纯净的手机号码<br />
 * 删除前缀、空格等
 *
 * @param phone
 * @return
 */
public static String getValidPhoneNumber(String phone) 
{
    if (phone == null)
    {
        return """";
    }
    phone = phone.trim();
    if (phone.startsWith(""+86""))
    {
        phone = phone.substring(3);
    }
    else if (phone.startsWith(""86""))
    {
        phone = phone.substring(2);
    }
    return phone.replaceAll(""\\s*"", """");
}   ",1221,True
"/**
 * 通过protobuf消息对象获取业务消息对象
 *
 * @param protobufMessage
 * @return
 */
public static AppMessage getMessageByProtobuf(
        MessageProtobuf.Msg protobufMessage){
    AppMessage message = new AppMessage();
    Head head = new Head();
    MessageProtobuf.Head protoHead = protobufMessage.getHead();
    head.setMsgType(protoHead.getMsgType());
    head.setStatusReport(protoHead.getStatusReport());
    head.setMsgContentType(protoHead.getMsgContentType());
    head.setMsgId(protoHead.getMsgId());
    head.setFromId(protoHead.getFromId());
    head.setToId(protoHead.getToId());
    head.setTimestamp(protoHead.getTimestamp());
    head.setExtend(protoHead.getExtend());
    message.setHead(head);
    message.setBody(protobufMessage.getBody());
    return message;
}","/**
 * 通过protobuf消息对象获取业务消息对象
 *
 * @param protobufMessage
 * @return
 */
public static AppMessage getMessageByProtobuf(
        MessageProtobuf.Msg protobufMessage) 
{
    AppMessage appMessage = new AppMessage();
    appMessage.setMsgId(protobufMessage.getMsgId());
    appMessage.setMsgType(protobufMessage.getMsgType());
    appMessage.setMsg(protobufMessage.getMsg());
    appMessage.setFromUserId(protobufMessage.getFromUserId());
    appMessage.setToUserId(protobufMessage.getToUserId());
    appMessage.setCreateTime(protobufMessage.getCreateTime());
    return appMessage;
}       ",1224,True
"/**
 * 利用正则表达式判断字符串是否是数字
 * @param str
 * @return
 */
public static boolean isNumeric(String str){
	Pattern pattern = Pattern.compile(""[0-9]*"");
	Matcher isNum = pattern.matcher(str);
	if( !isNum.matches() ){
		return false;
	}
	return true;
}","/**
 * 利用正则表达式判断字符串是否是数字
 * @param str
 * @return
 */



public static boolean isNumeric(String str) 
{
    Pattern pattern = Pattern.compile(""[0-9]*"");
    Matcher isNum = pattern.matcher(str);
    if (!isNum.matches())
    {
        return false;
    }
    return true;
}   ",1225,True
"/**
 * 去除特殊字符或将所有中文标号替换为英文标号
 * 
 * @param str
 * @return
 */
public static String stringFilter(String str){
	str = str.replaceAll(""【"", ""["").replaceAll(""】"", ""]"").replaceAll(""！"", ""!"").replaceAll(""："", "":"");// 替换中文标号
	String regEx = ""[『』]""; // 清除掉特殊字符
	Pattern p = Pattern.compile(regEx);
	Matcher m = p.matcher(str);
	return m.replaceAll("""").trim();
}","/**
 * 去除特殊字符或将所有中文标号替换为英文标号
 * 
 * @param str
 * @return
 */


public static String stringFilter(String str) 
{
    str = str.replaceAll(""【"", ""["").replaceAll(""】"", ""]"")
            .replaceAll(""！"", ""!"").replaceAll(""："", "":"");// ��换中文标号
    String regEx = ""[『』]""; // ��除��特��字符
    Pattern p = Pattern.compile(regEx);
    Matcher m = p.matcher(str);
    return m.replaceAll("""").trim();
}   ",1227,True
"/**
 * 比较两个字符串（大小写敏感）。
 *
 * <pre>
 *
 *    StringUtil.equals(null, null)   = true
 *    StringUtil.equals(null, &quot;abc&quot;)  = false
 *    StringUtil.equals(&quot;abc&quot;, null)  = false
 *    StringUtil.equals(&quot;abc&quot;, &quot;abc&quot;) = true
 *    StringUtil.equals(&quot;abc&quot;, &quot;ABC&quot;) = false
 *
 * </pre>
 *
 * @param str1
 *                要比较的字符串1
 * @param str2
 *                要比较的字符串2
 *
 * @return 如果两个字符串相同，或者都是 <code>null</code> ，则返回 <code>true</code>
 */
public static boolean equals(String str1, String str2){
	if ( str1 == null )
	{
		return str2 == null;
	}

	return str1.equals(str2);
}","/**
 * 比较两个字符串（大小写敏感）。
 *
 * <pre>
 *
 *    StringUtil.equals(null, null)   = true
 *    StringUtil.equals(null, &quot;abc&quot;)  = false
 *    StringUtil.equals(&quot;abc&quot;, null)  = false
 *    StringUtil.equals(&quot;abc&quot;, &quot;abc&quot;) = true
 *    StringUtil.equals(&quot;abc&quot;, &quot;ABC&quot;) = false
 *
 * </pre>
 *
 * @param str1
 *                要比较的字符串1
 * @param str2
 *                要比较的字符串2
 *
 * @return 如果两个字符串相同，或者都是 <code>null</code> ，则返回 <code>true</code>
 */
public static boolean equals(String str1, String str2) 
{
    if (str1 == null)
    {
        return str2 == null;
    }

    return str1.equals(str2);
}   ",1228,True
"/**
 * 半角转换为全角
 * 
 * @param input
 * @return
 */
public static String toDBC(String input){
	char[] c = input.toCharArray();
	for (int i = 0; i < c.length; i++) {
		if (c[i] == 12288) {
			c[i] = (char) 32;
			continue;
		}
		if (c[i] > 65280 && c[i] < 65375)
			c[i] = (char) (c[i] - 65248);
	}
	return new String(c);
}","/**
 * 半角转换为全角
 * 
 * @param input
 * @return
 */
public static String toDBC(String input) 
{
    char[] c = input.toCharArray();
    for (int i = 0; i < c.length; i++)
    {
        if (c[i] == 12288)
        {
            c[i] = (char) 32;
            continue;
        }
        if (c[i] > 65280 && c[i] < 65375)
            c[i] = (char) (c[i] - 65248);
    }
    return new String(c);
}   ",1230,True
"/**
 * 去除非法字符(换行、回车...)
 * @author liu_haifang
 * @date 2014-11-7 下午2:36:48
 * @param str
 * @return
 */
public static String rmUnqualified (String str){
	if (!isEmpty(str)) {
		Pattern p = Pattern.compile(""\\s*|\t|\r|\n"");
		Matcher m = p.matcher(str);
		return m.replaceAll("""");
	}
	return null;
}","/**
 * 去除非法字符(换行、回车...)
 * @author liu_haifang
 * @date 2014-11-7 下午2:36:48
 * @param str
 * @return
 */
public static String rmUnqualified (String str) 
{
    if (str == null)
    {
        return null;
    }
    return str.replaceAll(""\n"", """").replaceAll(""\r"", """");
}   ",1234,True
"/**
 * 根据业务消息对象获取protoBuf消息对应的builder
 *
 * @param message
 * @return
 */
public static MessageProtobuf.Msg.Builder getProtoBufMessageBuilderByAppMessage(AppMessage message){
    MessageProtobuf.Msg.Builder builder = MessageProtobuf.Msg.newBuilder();
    MessageProtobuf.Head.Builder headBuilder = MessageProtobuf.Head.newBuilder();
    headBuilder.setMsgType(message.getHead().getMsgType());
    headBuilder.setStatusReport(message.getHead().getStatusReport());
    headBuilder.setMsgContentType(message.getHead().getMsgContentType());
    if (!StringUtil.isEmpty(message.getHead().getMsgId()))
        headBuilder.setMsgId(message.getHead().getMsgId());
    if (!StringUtil.isEmpty(message.getHead().getFromId()))
        headBuilder.setFromId(message.getHead().getFromId());
    if (!StringUtil.isEmpty(message.getHead().getToId()))
        headBuilder.setToId(message.getHead().getToId());
    if (message.getHead().getTimestamp() != 0)
        headBuilder.setTimestamp(message.getHead().getTimestamp());
    if (!StringUtil.isEmpty(message.getHead().getExtend()))
        headBuilder.setExtend(message.getHead().getExtend());
    if (!StringUtil.isEmpty(message.getBody()))
        builder.setBody(message.getBody());
    builder.setHead(headBuilder);
    return builder;
}","/**
 * 根据业务消息对象获取protoBuf消息对应的builder
 *
 * @param message
 * @return
 */
public static MessageProtobuf.Msg.Builder getProtoBufMessageBuilderByAppMessage(AppMessage message) 
{
    MessageProtobuf.Msg.Builder builder = null;
    switch (message.getMsgType())
    {
        case AppMessage.MSG_TYPE_TEXT:
            builder = MessageProtobuf.Msg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_IMAGE:
            builder = MessageProtobuf.ImageMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_AUDIO:
            builder = MessageProtobuf.AudioMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_LOCATION:
            builder = MessageProtobuf.LocationMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_FILE:
            builder = MessageProtobuf.FileMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_VIDEO:
            builder = MessageProtobuf.VideoMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_LINK:
            builder = MessageProtobuf.LinkMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_VOICE_CALL:
            builder = MessageProtobuf.VoiceCallMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_VIDEO_CALL:
            builder = MessageProtobuf.VideoCallMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_CARD:
            builder = MessageProtobuf.CardMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_REDACTED:
            builder = MessageProtobuf.RedactedMsg.newBuilder();
            break;
        case AppMessage.MSG_TYPE_UNKNOWN:
            builder = MessageProtobuf.Msg.newBuilder();
            break;
    }
    return builder;
}   ",1238,True
"/**
 * 判断是不是一个合法的手机号码
 */
public static boolean isPhone(CharSequence phoneNum){
	if (isEmpty(phoneNum))
		return false;
	return phonePattern.matcher(phoneNum).matches();
}","/**
 * 判断是不是一个合法的手机号码
 */
public static boolean isPhone(CharSequence phoneNum) 
{
    if (isEmpty(phoneNum))
        return false;
    return Patterns.PHONE.matcher(phoneNum).matches();
}   ",1239,True
"/**
 * Map object coordinates into window coordinates. gluProject transforms the
 * specified object coordinates into window coordinates using model, proj,
 * and view. The result is stored in win.
 * <p>
 * Note that you can use the OES_matrix_get extension, if present, to get
 * the current modelView and projection matrices.
 *
 * @param objX object coordinates X
 * @param objY object coordinates Y
 * @param objZ object coordinates Z
 * @param model the current modelview matrix
 * @param modelOffset the offset into the model array where the modelview
 *        maxtrix data starts.
 * @param project the current projection matrix
 * @param projectOffset the offset into the project array where the project
 *        matrix data starts.
 * @param view the current view, {x, y, width, height}
 * @param viewOffset the offset into the view array where the view vector
 *        data starts.
 * @param win the output vector {winX, winY, winZ}, that returns the
 *        computed window coordinates.
 * @param winOffset the offset into the win array where the win vector data
 *        starts.
 * @return A return value of GL_TRUE indicates success, a return value of
 *         GL_FALSE indicates failure.
 */
public static int gluProject(double objX, double objY, double objZ,
        double[] model, int modelOffset, double[] project, int projectOffset,
        int[] view, int viewOffset, double[] win, int winOffset){
    double[] scratch = sScratch;
    synchronized(scratch) {
        final int M_OFFSET = 0; // 0..15
        final int V_OFFSET = 16; // 16..19
        final int V2_OFFSET = 20; // 20..23
        Matrix.multiplyMM(scratch, M_OFFSET, project, projectOffset,
                model, modelOffset);

        scratch[V_OFFSET + 0] = objX;
        scratch[V_OFFSET + 1] = objY;
        scratch[V_OFFSET + 2] = objZ;
        scratch[V_OFFSET + 3] = 1.0;

        Matrix.multiplyMV(scratch, V2_OFFSET,
                scratch, M_OFFSET, scratch, V_OFFSET);

        double w = scratch[V2_OFFSET + 3];
        if (w == 0.0) {
            return GL10.GL_FALSE;
        }

        double rw = 1.0 / w;

        win[winOffset] =
                view[viewOffset] + view[viewOffset + 2]
                        * (scratch[V2_OFFSET + 0] * rw + 1.0)
                        * 0.5;
        win[winOffset + 1] =
                view[viewOffset + 1] + view[viewOffset + 3]
                        * (scratch[V2_OFFSET + 1] * rw + 1.0) * 0.5;
        win[winOffset + 2] = (scratch[V2_OFFSET + 2] * rw + 1.0) * 0.5;
    }

    return GL10.GL_TRUE;
}","/**
 * Map object coordinates into window coordinates. gluProject transforms the
 * specified object coordinates into window coordinates using model, proj,
 * and view. The result is stored in win.
 * <p>
 * Note that you can use the OES_matrix_get extension, if present, to get
 * the current modelView and projection matrices.
 *
 * @param objX object coordinates X
 * @param objY object coordinates Y
 * @param objZ object coordinates Z
 * @param model the current modelview matrix
 * @param modelOffset the offset into the model array where the modelview
 *        maxtrix data starts.
 * @param project the current projection matrix
 * @param projectOffset the offset into the project array where the project
 *        matrix data starts.
 * @param view the current view, {x, y, width, height}
 * @param viewOffset the offset into the view array where the view vector
 *        data starts.
 * @param win the output vector {winX, winY, winZ}, that returns the
 *        computed window coordinates.
 * @param winOffset the offset into the win array where the win vector data
 *        starts.
 * @return A return value of GL_TRUE indicates success, a return value of
 *         GL_FALSE indicates failure.
 */
public static int gluProject(double objX, double objY, double objZ,
        double[] model, int modelOffset, double[] project, int projectOffset,
        int[] view, int viewOffset, double[] win, int winOffset) 
{
    double[] temp = new double[4];
    double[] in = {objX, objY, objZ, 1.0};
    double[] out = new double[4];

    Matrix.multiplyMV(temp, 0, model, modelOffset, in, 0);
    Matrix.multiplyMV(out, 0, project, projectOffset, temp, 0);

    if (out[3] == 0.0) {
        return GL_FALSE;
    }

    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];

    win[winOffset]     = view[viewOffset]     + view[viewOffset + 2] * (1 + out[0]);
    win[winOffset + 1] = view[viewOffset + 1] + view[viewOffset + 3] * (1 + out[1]);
    win[winOffset + 2] = (1 + out[2]);

    return GL_TRUE;
}       ",1240,True
"/*
 * Set the outer cone angle
 */
public void setCutoffAngle(float cutoffAng){
	if(cutoffAng > mMaxCutoffAngle)
		cutoffAng = mMaxCutoffAngle;
	mCutoffAngle = cutoffAng;
}","/*
 * Set the outer cone angle
 */
public void setCutoffAngle(float cutoffAng) 
{
    if (cutoffAng < 0 || cutoffAng > 90)
        throw new IllegalArgumentException(""Cutoff angle must be between 0 and 90 degrees"");
    cutoffAngle = cutoffAng;
}   ",1241,True
"/**
 * Renders the object
 *
 * @param camera        The camera
 * @param vpMatrix      {@link Matrix4} The view-projection matrix
 * @param projMatrix    {@link Matrix4} The projection matrix
 * @param vMatrix       {@link Matrix4} The view matrix
 * @param parentMatrix  {@link Matrix4} This object's parent matrix
 * @param sceneMaterial The scene-wide Material to use, if any.
 */
public void render(Camera camera, final Matrix4 vpMatrix, final Matrix4 projMatrix, final Matrix4 vMatrix,
                   final Matrix4 parentMatrix, Material sceneMaterial){
    if (isDestroyed() || (!mIsVisible && !mRenderChildrenAsBatch) || isZeroScale()) {
        return;
    }

    if (parentMatrix != null) {
        if (mParentMatrix == null) {
            mParentMatrix = new Matrix4();
        }
        mParentMatrix.setAll(parentMatrix);
    }

    Material material = sceneMaterial == null ? mMaterial : sceneMaterial;
    preRender();

    // -- move view matrix transformation first
    boolean modelMatrixWasRecalculated = onRecalculateModelMatrix(parentMatrix);
    // -- calculate model view matrix;
    mMVMatrix.setAll(vMatrix).multiply(mMMatrix);
    // -- calculate inverse view matrix;
    mInverseViewMatrix.setAll(vMatrix).inverse().transpose();
    //Create MVP Matrix from View-Projection Matrix
    mMVPMatrix.setAll(vpMatrix).multiply(mMMatrix);

    // Transform the bounding volumes if they exist
    if (mGeometry.hasBoundingBox()) {
        getBoundingBox().transform(getModelMatrix());
    }
    if (mGeometry.hasBoundingSphere()) {
        mGeometry.getBoundingSphere().transform(getModelMatrix());
    }

    mIsInFrustum = true; // only if mFrustrumTest == true it check frustum
    if (mFrustumTest && mGeometry.hasBoundingBox()) {
        BoundingBox bbox = getBoundingBox();
        if (!camera.getFrustum().boundsInFrustum(bbox)) {
            mIsInFrustum = false;
        }
    }

    if (!mIsContainerOnly && mIsInFrustum) {
        mPMatrix = projMatrix;
        if (mDoubleSided) {
            GLES20.glDisable(GLES20.GL_CULL_FACE);
        } else {
            GLES20.glEnable(GLES20.GL_CULL_FACE);
            if (mBackSided) {
                GLES20.glCullFace(GLES20.GL_FRONT);
            } else {
                GLES20.glCullFace(GLES20.GL_BACK);
                GLES20.glFrontFace(GLES20.GL_CCW);
            }
        }
        if (mEnableBlending) {
            GLES20.glEnable(GLES20.GL_BLEND);
            GLES20.glBlendFunc(mBlendFuncSFactor, mBlendFuncDFactor);
        }
        if (!mEnableDepthTest) {
            GLES20.glDisable(GLES20.GL_DEPTH_TEST);
        } else {
            GLES20.glEnable(GLES20.GL_DEPTH_TEST);
            GLES20.glDepthFunc(GLES20.GL_LESS);
        }

        GLES20.glDepthMask(mEnableDepthMask);

        if (!mIsPartOfBatch) {
            if (material == null) {
                RajLog.e(""["" + this.getClass().getName()
                         + ""] This object can't render because there's no material attached to it."");
					/*throw new RuntimeException(
							""This object can't render because there's no material attached to it."");*/
                if (mEnableBlending) {
                    GLES20.glDisable(GLES20.GL_BLEND);
                }

                if (mDoubleSided) {
                    GLES20.glEnable(GLES20.GL_CULL_FACE);
                } else if (mBackSided) {
                    GLES20.glCullFace(GLES20.GL_BACK);
                }
                if (!mEnableDepthTest) {
                    GLES20.glEnable(GLES20.GL_DEPTH_TEST);
                    GLES20.glDepthFunc(GLES20.GL_LESS);
                }
                return;
            }
            material.useProgram();

            setShaderParams(camera);
            material.bindTextures();
            if (mGeometry.hasTextureCoordinates()) {
                material.setTextureCoords(mGeometry.getTexCoordBufferInfo());
            }
            if (mGeometry.hasNormals()) {
                material.setNormals(mGeometry.getNormalBufferInfo());
            }
            if (mMaterial.usingVertexColors()) {
                material.setVertexColors(mGeometry.getColorBufferInfo());
            }

            material.setVertices(mGeometry.getVertexBufferInfo());
        }
        material.setCurrentObject(this);
        if (mOverrideMaterialColor) {
            material.setColor(mColor);
        }
        material.applyParams();

        GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);

        material.setMVPMatrix(mMVPMatrix);
        material.setModelMatrix(mMMatrix);
        material.setInverseViewMatrix(mInverseViewMatrix);
        material.setModelViewMatrix(mMVMatrix);

        if (mIsVisible) {
            int bufferType = mGeometry.getIndexBufferInfo().bufferType == Geometry3D.BufferType.SHORT_BUFFER
                             ? GLES20.GL_UNSIGNED_SHORT : GLES20.GL_UNSIGNED_INT;
            GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, mGeometry.getIndexBufferInfo().bufferHandle);
            GLES20.glDrawElements(mDrawingMode, mGeometry.getNumIndices(), bufferType, 0);
            GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, 0);
        }
        if (!mIsPartOfBatch && !mRenderChildrenAsBatch && sceneMaterial == null) {
            material.unbindTextures();
        }

        material.unsetCurrentObject(this);

        if (mEnableBlending) {
            GLES20.glDisable(GLES20.GL_BLEND);
        }

        if (mDoubleSided) {
            GLES20.glEnable(GLES20.GL_CULL_FACE);
        } else if (mBackSided) {
            GLES20.glCullFace(GLES20.GL_BACK);
        }
        if (!mEnableDepthTest) {
            GLES20.glEnable(GLES20.GL_DEPTH_TEST);
            GLES20.glDepthFunc(GLES20.GL_LESS);
        }
    }

    if (mShowBoundingVolume) {
        if (mGeometry.hasBoundingBox()) {
            getBoundingBox().drawBoundingVolume(camera, vpMatrix, projMatrix, vMatrix, mMMatrix);
        }
        if (mGeometry.hasBoundingSphere()) {
            mGeometry.getBoundingSphere().drawBoundingVolume(camera, vpMatrix, projMatrix, vMatrix, mMMatrix);
        }
    }
    // Draw children without frustum test
    for (int i = 0, j = mChildren.size(); i < j; i++) {
        Object3D child = mChildren.get(i);
        if (mRenderChildrenAsBatch || mIsPartOfBatch) {
            child.setPartOfBatch(true);
        }
        if (modelMatrixWasRecalculated) {
            child.markModelMatrixDirty();
        }
        child.render(camera, vpMatrix, projMatrix, vMatrix, mMMatrix, sceneMaterial);
    }

    if (mRenderChildrenAsBatch && sceneMaterial == null) {
        material.unbindTextures();
    }
}","/**
 * Renders the object
 *
 * @param camera        The camera
 * @param vpMatrix      {@link Matrix4} The view-projection matrix
 * @param projMatrix    {@link Matrix4} The projection matrix
 * @param vMatrix       {@link Matrix4} The view matrix
 * @param parentMatrix  {@link Matrix4} This object's parent matrix
 * @param sceneMaterial The scene-wide Material to use, if any.
 */
public void render(Camera camera, final Matrix4 vpMatrix, final Matrix4 projMatrix, final Matrix4 vMatrix,
                   final Matrix4 parentMatrix, Material sceneMaterial) 
{
    if (!isVisible)
        return;

    if (material != null)
    {
        material.render(this, camera, vpMatrix, projMatrix, vMatrix, parentMatrix, sceneMaterial);
    }
    else if (sceneMaterial != null)
    {
        sceneMaterial.render(this, camera, vpMatrix, projMatrix, vMatrix, parentMatrix, sceneMaterial);
    }
    else
    {
        DefaultMaterial.INSTANCE.render(this, camera, vpMatrix, projMatrix, vMatrix, parentMatrix, sceneMaterial);
    }
}   ",1243,False
"/**
 * Copies every property from another ThreeDcTexture object
 * 
 * @param other
 *            another ThreeDcTexture object to copy from
 */
public void setFrom(ThreeDcTexture other){
	super.setFrom(other);
	mThreeDcFormat = other.getThreeDcFormat();
}","/**
 * Copies every property from another ThreeDcTexture object
 * 
 * @param other
 *            another ThreeDcTexture object to copy from
 */
public void setFrom(ThreeDcTexture other) 
{
    this.texture = other.texture;
    this.minFilter = other.minFilter;
    this.magFilter = other.magFilter;
    this.wrapS = other.wrapS;
    this.wrapT = other.wrapT;
    this.wrapR = other.wrapR;
    this.anisotropy = other.anisotropy;
    this.format = other.format;
    this.internalFormat = other.internalFormat;
    this.type = other.type;
}   ",1245,True
"/**
 * Retrieve the number of objects in the object, recursive method
 *
 * @return int the total object count for the object.
 */
public int getNumObjects(){
    int objectCount = 0;

    for (int i = 0, j = getNumChildren(); i < j; i++) {
        Object3D child = getChildAt(i);
        if (child.getGeometry() != null && child.getGeometry().getVertices() != null && child.isVisible()) {
            if (child.getNumChildren() > 0) {
                objectCount += child.getNumObjects() + 1;
            } else {
                objectCount++;
            }
        }
    }
    return objectCount;
}","/**
 * Retrieve the number of objects in the object, recursive method
 *
 * @return int the total object count for the object.
 */
public int getNumObjects() 
{
    int count = 0;
    for (Object obj : objects)
    {
        if (obj instanceof GameObject)
        {
            count++;
            count += ((GameObject) obj).getNumObjects();
        }
    }
    return count;
}   ",1246,False
"/**
 * Use this together with the alpha channel when calling BaseObject3D.setColor(): 0xaarrggbb. So for 50% transparent
 * red, set transparent to true and call: * <code>setColor(0x7fff0000);</code>
 *
 * @param value
 */
public void setTransparent(boolean value){
    mTransparent = value;
    mEnableBlending = value;
    setBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA);
    mEnableDepthMask = !value;
}","/**
 * Use this together with the alpha channel when calling BaseObject3D.setColor(): 0xaarrggbb. So for 50% transparent
 * red, set transparent to true and call: * <code>setColor(0x7fff0000);</code>
 *
 * @param value
 */
public void setTransparent(boolean value) 
{
    if (value)
    {
        this.material.setTransparent(true);
    }
    else
    {
        this.material.setTransparent(false);
    }
}   ",1247,True
"/**
 * Return an error string from a GL or GLU error code.
 *
 * @param error - a GL or GLU error code.
 * @return the error string for the input error code, or NULL if the input
 *         was not a valid GL or GLU error code.
 */
public static String gluErrorString(int error){
    switch (error) {
    case GL10.GL_NO_ERROR:
        return ""no error"";
    case GL10.GL_INVALID_ENUM:
        return ""invalid enum"";
    case GL10.GL_INVALID_VALUE:
        return ""invalid value"";
    case GL10.GL_INVALID_OPERATION:
        return ""invalid operation"";
    case GL10.GL_STACK_OVERFLOW:
        return ""stack overflow"";
    case GL10.GL_STACK_UNDERFLOW:
        return ""stack underflow"";
    case GL10.GL_OUT_OF_MEMORY:
        return ""out of memory"";
    default:
        return null;
    }
}","/**
 * Return an error string from a GL or GLU error code.
 *
 * @param error - a GL or GLU error code.
 * @return the error string for the input error code, or NULL if the input
 *         was not a valid GL or GLU error code.
 */
public static String gluErrorString(int error) 
{
    switch (error) {
    case GL_NO_ERROR:
        return ""no error"";
    case GL_INVALID_ENUM:
        return ""invalid enumerant"";
    case GL_INVALID_VALUE:
        return ""invalid value"";
    case GL_INVALID_OPERATION:
        return ""invalid operation"";
    case GL_STACK_OVERFLOW:
        return ""stack overflow"";
    case GL_STACK_UNDERFLOW:
        return ""stack underflow"";
    case GL_OUT_OF_MEMORY:
        return ""out of memory"";
    default:
        return null;
    }
}   ",1249,True
"/**
 * Sets the world axis values after checking that they are all orthogonal to each other. The check performed
 * is to verify that the cross product between {@code right} and {@code up} is equivilant to {@code forward}
 * withing 1ppm error on each component.
 *
 * @param right {@link Vector3} The desired right vector. Must be normalized.
 * @param up {@link Vector3} The desired up vector. Must be normalized.
 * @param forward {@link Vector3} The desired forward vector. Must be normalized.
 */
public static void setWorldAxes(Vector3 right, Vector3 up, Vector3 forward){
    TEMP_VECTOR.crossAndSet(right, up);
    if (!TEMP_VECTOR.equals(forward, 1e-6)) {
        throw new IllegalArgumentException(""World axes must be orthogonal."");
    }
    RIGHT_AXIS.setAll(right);
    NEG_RIGHT_AXIS.setAll(RIGHT_AXIS).inverse();
    UP_AXIS.setAll(up);
    NEG_UP_AXIS.setAll(UP_AXIS).inverse();
    FORWARD_AXIS.setAll(forward);
    NEG_FORWARD_AXIS.setAll(FORWARD_AXIS).inverse();
}","/**
 * Sets the world axis values after checking that they are all orthogonal to each other. The check performed
 * is to verify that the cross product between {@code right} and {@code up} is equivilant to {@code forward}
 * withing 1ppm error on each component.
 *
 * @param right {@link Vector3} The desired right vector. Must be normalized.
 * @param up {@link Vector3} The desired up vector. Must be normalized.
 * @param forward {@link Vector3} The desired forward vector. Must be normalized.
 */
public static void setWorldAxes(Vector3 right, Vector3 up, Vector3 forward) 
{
    if (Math.abs(Vector3.dot(right, up)) > 0.001 || Math.abs(Vector3.dot(right, forward)) > 0.001 || Math.abs(Vector3.dot(up, forward)) > 0.001)
    {
        throw new IllegalArgumentException(""Vectors must be orthogonal to each other."");
    }

    worldRight = right;
    worldUp = up;
    worldForward = forward;
}   ",1250,False
"/*
 * (non-Javadoc)
 * @see rajawali.ATransformable3D#getTransformedBoundingVolume()
 */
@Override
public IBoundingVolume getTransformedBoundingVolume(){
	synchronized (mFrustumLock) {
		// TODO create an actual bounding box
		return mBoundingBox;
	}
}","/*
 * (non-Javadoc)
 * @see rajawali.ATransformable3D#getTransformedBoundingVolume()
 */
@Override
public IBoundingVolume getTransformedBoundingVolume() 
{
	if (mBoundingVolume == null)
	{
		mBoundingVolume = new BoundingBox();
		onUpdateTransformedBoundingVolume();
	}

	return mBoundingVolume;
}   ",1255,True
"/**
 * Define a viewing transformation in terms of an eye point, a center of
 * view, and an up vector.
 *
 * @param gl a GL10 interface
 * @param eyeX eye point X
 * @param eyeY eye point Y
 * @param eyeZ eye point Z
 * @param centerX center of view X
 * @param centerY center of view Y
 * @param centerZ center of view Z
 * @param upX up vector X
 * @param upY up vector Y
 * @param upZ up vector Z
 */
public static void gluLookAt(GL10 gl, double eyeX, double eyeY, double eyeZ,
        double centerX, double centerY, double centerZ, double upX, double upY,
        double upZ){

    double[] scratch = sScratch;
    synchronized(scratch) {
        Matrix.setLookAtM(scratch, 0, eyeX, eyeY, eyeZ, centerX, centerY, centerZ,
                upX, upY, upZ);
        gl.glMultMatrixf(ArrayUtils.convertDoublesToFloats(scratch, sTempFloats), 0);
    }
}","/**
 * Define a viewing transformation in terms of an eye point, a center of
 * view, and an up vector.
 *
 * @param gl a GL10 interface
 * @param eyeX eye point X
 * @param eyeY eye point Y
 * @param eyeZ eye point Z
 * @param centerX center of view X
 * @param centerY center of view Y
 * @param centerZ center of view Z
 * @param upX up vector X
 * @param upY up vector Y
 * @param upZ up vector Z
 */
public static void gluLookAt(GL10 gl, double eyeX, double eyeY, double eyeZ,
        double centerX, double centerY, double centerZ, double upX, double upY,
        double upZ) 
{
    float[] m = new float[16];
    Matrix.setLookAtM(m, 0,
            (float)eyeX, (float)eyeY, (float)eyeZ,
            (float)centerX, (float)centerY, (float)centerZ,
            (float)upX, (float)upY, (float)upZ);
    gl.glMultMatrixf(m, 0);
}       ",1258,True
"/**
 * Copies every property from another ACompressedTexture object
 * 
 * @param other
 *            another ACompressedTexture object to copy from
 */
public void setFrom(ACompressedTexture other){
	super.setFrom(other);
	mCompressionType = other.getCompressionType();
	mCompressionFormat = other.getCompressionFormat();
}","/**
 * Copies every property from another ACompressedTexture object
 * 
 * @param other
 *            another ACompressedTexture object to copy from
 */
public void setFrom(ACompressedTexture other) 
{
    if (this != other)
    {
        this.internalFormat = other.internalFormat;
        this.imageFormat = other.imageFormat;
        this.imageType = other.imageType;
        this.width = other.width;
        this.height = other.height;
        this.depth = other.depth;
        this.mipLevels = other.mipLevels;
        this.images = other.images;
        this.compressed = other.compressed;
    }
}   ",1259,True
"/**
 * 签名for App
 * https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&index=2
 * @param params
 * @param signKey
 * @return
 */
public static String signForApp(Map<String, String> params, String signKey){
    SortedMap<String, String> sortedMap = new TreeMap<>(params);

    StringBuilder toSign = new StringBuilder();
    for (String key : sortedMap.keySet()) {
        String value = params.get(key);
        if (StringUtils.isNotEmpty(value) && !""sign"".equals(key) && !""key"".equals(key)) {
            toSign.append(key.toLowerCase()).append(""="").append(value).append(""&"");
        }
    }

    toSign.append(""key="").append(signKey);
    return DigestUtils.md5Hex(toSign.toString()).toUpperCase();
}","/**
 * 签名for App
 * https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&index=2
 * @param params
 * @param signKey
 * @return
 */
public static String signForApp(Map<String, String> params, String signKey) 
{
    String stringA = createLinkString(params, true, false);
    String stringSignTemp = stringA + ""&key="" + signKey;
    String sign = MD5Util.MD5Encode(stringSignTemp, ""UTF-8"").toUpperCase();
    return sign;
}   ",1261,False
"/**
 * map转url 排序后转
 * @param map
 * @return
 */
public static String toUrlWithSort(Map<String, String> map){
    List<String> keys = new ArrayList<>(map.keySet());
    Collections.sort(keys);

    String prestr = """";
    for (int i = 0; i < keys.size(); i++) {
        String key = keys.get(i);
        String value = map.get(key);

        if (i == keys.size() - 1) {//拼接时，不包括最后一个&字符
            prestr = prestr + key + ""="" + value;
        } else {
            prestr = prestr + key + ""="" + value + ""&"";
        }
    }
    return prestr;
}","/**
 * map转url 排序后转
 * @param map
 * @return
 */




public static String toUrlWithSort(Map<String, String> map) 
{
    List<String> keys = new ArrayList<String>(map.keySet());
    Collections.sort(keys);
    StringBuilder prestr = new StringBuilder();
    for (int i = 0; i < keys.size(); i++)
    {
        String key = keys.get(i);
        String value = map.get(key);
        prestr.append(key).append(""="").append(value);
        if (i < keys.size() - 1)
        {
            prestr.append(""&"");
        }
    }
    return prestr.toString();
}   ",1262,True
"/**
 *  xml 转 map
 *
 * @param strXML XML字符串
 * @return XML数据转换后的Map
 * @throws Exception
 */
public static Map<String, String> toMap(String strXML){
    try {
        Map<String, String> data = new HashMap<>();
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        InputStream stream = new ByteArrayInputStream(strXML.getBytes(""UTF-8""));
        org.w3c.dom.Document doc = documentBuilder.parse(stream);
        doc.getDocumentElement().normalize();
        NodeList nodeList = doc.getDocumentElement().getChildNodes();
        for (int idx = 0; idx < nodeList.getLength(); ++idx) {
            Node node = nodeList.item(idx);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                org.w3c.dom.Element element = (org.w3c.dom.Element) node;
                data.put(element.getNodeName(), element.getTextContent());
            }
        }
        try {
            stream.close();
        } catch (Exception ex) {
            // do nothing
        }
        return data;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}","/**
 *  xml 转 map
 *
 * @param strXML XML字符串
 * @return XML数据转换后的Map
 * @throws Exception
 */





public static Map<String, String> toMap(String strXML) 
{
    try
    {
        Map<String, String> data = new HashMap<String, String>();
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder();
        InputStream stream = new ByteArrayInputStream(strXML.getBytes(""UTF-8""));
        Document doc = documentBuilder.parse(stream);
        doc.getDocumentElement().normalize();
        NodeList nodeList = doc.getDocumentElement().getChildNodes();
        for (int idx=0; idx<nodeList.getLength(); ++idx)
        {
            Node node = nodeList.item(idx);
            if (node.getNodeType() == Node.ELEMENT_NODE)
            {
                Element element = (Element) node;
                data.put(element.getNodeName(), element.getTextContent());
            }
        }
        try
        {
            stream.close();
        }
        catch (Exception ex)
        {
            // do nothing
        }
        return data;
    }
    catch (Exception ex)
    {
        return null;
    }
}   ",1265,True
"/**
 * 表单字符串转化成 hashMap，将具有下划线的key转换为小驼峰
 * @param orderinfo,
 * @return
 */
public static HashMap<String, String> form2MapWithCamelCase( String orderinfo){
    String listinfo[];
    HashMap<String, String> map = new HashMap<String, String>();
    listinfo = orderinfo.split(""&"");
    for(String s : listinfo)
    {
        String list[]  = s.split(""="");
        if(list.length>1)
        {
            map.put(CamelCaseUtil.toCamelCase(list[0]),list[1]);
        }
    }
    return map;
}","/**
 * 表单字符串转化成 hashMap，将具有下划线的key转换为小驼峰
 * @param orderinfo,
 * @return
 */
public static HashMap<String, String> form2MapWithCamelCase( String orderinfo) 
{
    HashMap<String, String> map = new HashMap<String, String>();
    String[] params = orderinfo.split(""&"");
    for (int i = 0; i < params.length; i++)
    {
        String[] param = params[i].split(""="");
        if (param.length == 2)
        {
            map.put(toCamelCase(param[0]), param[1]);
        }
    }
    return map;
}   ",1266,True
"/**
 * 去除不参与签名的参数
 * 支付宝中是去除sign和sign_type
 * @param map
 * @return
 */
public static Map<String, String> removeParamsForAlipaySign(Map<String, String> map){
    map.remove(""sign"");
    map.remove(""sign_type"");

    return map;
}","/**
 * 去除不参与签名的参数
 * 支付宝中是去除sign和sign_type
 * @param map
 * @return
 */
public static Map<String, String> removeParamsForAlipaySign(Map<String, String> map) 
{
    map.remove(""sign"");
    map.remove(""sign_type"");
    return map;
}   ",1272,True
"/**
 * 校验签名
 * @param params
 * @param privateKey
 * @return
 */
public static Boolean verify(Map<String, String> params,  String privateKey){
    String sign = sign(params, privateKey);
    return sign.equals(params.get(""sign""));
}","/**
 * 校验签名
 * @param params
 * @param privateKey
 * @return
 */
public static Boolean verify(Map<String, String> params,  String privateKey) 
{
    String sign = params.get(""sign"");
    params.remove(""sign"");
    String checkSign = sign(params, privateKey);
    return checkSign.equalsIgnoreCase(sign);
}   ",1278,True
"/**
 * Replace with the new condition value.
 *
 * @param copy Replace Base
 * @param whenCondition WhenCondition to replace, if Base does not have an item, insert it directly.
 * @param thenCondition ThenCondition to replace, if Base has no items, then insert directly.
 * @return RouteUtils after replacement
 */
public static RouteUtils copyWithReplace(RouteUtils copy, Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition){
    if (null == copy) {
        throw new NullPointerException(""Argument copy is null!"");
    }

    Map<String, MatchPair> when = new HashMap<String, MatchPair>();
    when.putAll(copy.getWhenCondition());
    if (whenCondition != null) {
        when.putAll(whenCondition);
    }

    Map<String, MatchPair> then = new HashMap<String, MatchPair>();
    then.putAll(copy.getThenCondition());
    if (thenCondition != null) {
        then.putAll(thenCondition);
    }

    return new RouteUtils(when, then);
}","/**
 * Replace with the new condition value.
 *
 * @param copy Replace Base
 * @param whenCondition WhenCondition to replace, if Base does not have an item, insert it directly.
 * @param thenCondition ThenCondition to replace, if Base has no items, then insert directly.
 * @return RouteUtils after replacement
 */
public static RouteUtils copyWithReplace(RouteUtils copy, Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) 
{
    RouteUtils routeUtils = new RouteUtils();
    routeUtils.setBase(copy.getBase());
    routeUtils.setWhenCondition(whenCondition);
    routeUtils.setThenCondition(thenCondition);
    return routeUtils;
}   ",1280,True
"/**
 * Call duboo provider and return {@link CompletableFuture}
 *
 * @return java.util.concurrent.CompletableFuture<java.lang.Object>
 * @param: address
 * @param: interfaceName
 * @param: methodName
 * @param: async  Whether the provider is asynchronous is to directly return the {@link CompletableFuture}
 * returned by the provider, not to wrap it as {@link CompletableFuture}
 * @param: paramTypes
 * @param: paramValues
 */
public static CompletableFuture<Object> invoke(String address, String interfaceName,
                                               String methodName, boolean async, String[] paramTypes,
                                               Object[] paramValues){
    CompletableFuture future = null;
    ReferenceConfig<GenericService> reference = getReferenceConfig(address, interfaceName);
    if (null != reference) {
        GenericService genericService = reference.get();
        if (null != genericService) {
            if (async) {
                future = genericService.$invokeAsync(methodName, paramTypes, paramValues);
            } else {
                future = CompletableFuture.supplyAsync(() -> genericService.$invoke(methodName, paramTypes, paramValues), EXECUTOR);
            }
        }
        future.exceptionally(ex -> {
            if (StringUtils.contains(ex.toString(), ""Failed to invoke remote method"")) {
                removeReferenceConfig(address, interfaceName);
            }
            return ex;
        });
    }
    return future;
}","/**
 * Call duboo provider and return {@link CompletableFuture}
 *
 * @return java.util.concurrent.CompletableFuture<java.lang.Object>
 * @param: address
 * @param: interfaceName
 * @param: methodName
 * @param: async  Whether the provider is asynchronous is to directly return the {@link CompletableFuture}
 * returned by the provider, not to wrap it as {@link CompletableFuture}
 * @param: paramTypes
 * @param: paramValues
 */
public static CompletableFuture<Object> invoke(String address, String interfaceName,
                                               String methodName, boolean async, String[] paramTypes,
                                               Object[] paramValues) 
{
    DubboBuilder builder = new DubboBuilder();
    builder.address(address).interfaceName(interfaceName).methodName(methodName)
            .async(async).paramTypes(paramTypes).paramValues(paramValues);
    return builder.build().invoke();
}   ",1281,True
"/**
 * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.
 */
public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values){
    Set<String> ret = new HashSet<String>();
    if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {
        return ret;
    }

    for (String p : patterns) {
        for (String v : values) {
            if (isMatchGlobPattern(p, v)) {
                ret.add(v);
            }
        }
    }
    return ret;
}","/**
 * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.
 */


public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) 
{
    Set<String> result = new HashSet<>();
    for (String value : values)
    {
        for (String pattern : patterns)
        {
            if (isGlobMatch(pattern, value))
            {
                result.add(value);
                break;
            }
        }
    }
    return result;
}   ",1285,True
"/**
 * @see #parse(String)
 * @throws RuntimeException This is an wrapper exception for the {@link ParseException} thrown by the {@link #parse (String)} method.
 */
public static RouteUtils parseQuitely(Route conditionRoute){
    try {
        return parse(conditionRoute);
    } catch (ParseException e) {
        throw new RuntimeException(e);
    }
}","/**
 * @see #parse(String)
 * @throws RuntimeException This is an wrapper exception for the {@link ParseException} thrown by the {@link #parse (String)} method.
 */

public static RouteUtils parseQuitely(Route conditionRoute) 
{
    try
    {
        return parse(conditionRoute);
    }
    catch (ParseException e)
    {
        throw new RuntimeException(e);
    }
}   ",1287,True
"/**
 * Whether the sample passed the conditions.
 * <p>
 * If there is a Key in the KV for the sample, there is a corresponding MatchPair, and Value does not pass through MatchPair; {@code false} is returned; otherwise, {@code true} is returned.
 *
 * @see MatchPair#pass(String)
 */
public static boolean matchCondition(Map<String, String> sample,
                                     Map<String, MatchPair> condition){
    for (Map.Entry<String, String> entry : sample.entrySet()) {
        String key = entry.getKey();

        MatchPair pair = condition.get(key);
        if (pair != null && !pair.pass(entry.getValue())) {
            return false;
        }
    }
    return true;
}","/**
 * Whether the sample passed the conditions.
 * <p>
 * If there is a Key in the KV for the sample, there is a corresponding MatchPair, and Value does not pass through MatchPair; {@code false} is returned; otherwise, {@code true} is returned.
 *
 * @see MatchPair#pass(String)
 */
public static boolean matchCondition(Map<String, String> sample,
                                     Map<String, MatchPair> condition) 
{
    for (Map.Entry<String, String> entry : sample.entrySet())
    {
        if (condition.containsKey(entry.getKey()))
        {
            if (!condition.get(entry.getKey()).pass(entry.getValue()))
            {
                return false;
            }
        }
    }
    return true;
}   ",1288,True
"/**
 * Whether a given value is matched by the {@link MatchPair}.
 * return {@code false}, if
 * <ol>
 * <li>value is in unmatches
 * <li>matches is not null, but value is not in matches.
 * </ol>
 * otherwise, return<code>true</code>。
 */
public boolean pass(String sample){
    if (unmatches.contains(sample)) return false;
    if (matches.isEmpty()) return true;
    return matches.contains(sample);
}","/**
 * Whether a given value is matched by the {@link MatchPair}.
 * return {@code false}, if
 * <ol>
 * <li>value is in unmatches
 * <li>matches is not null, but value is not in matches.
 * </ol>
 * otherwise, return<code>true</code>。
 */
public boolean pass(String sample) 
{
    if (unmatches.contains(sample))
    {
        return false;
    }
    return matches == null || matches.contains(sample);
}   ",1290,True
"/**
 * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.
 *
 * @param keyPrefix In the output of the Map Key plus a unified prefix.
 * @param query Query String，For example: <code>key1=value1&key2=value2</code>
 * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,
 *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.
 */
// FIXME Is it reasonable to throw an IllegalStateException??
public static Map<String, String> parseQuery(String keyPrefix, String query){
    if (query == null)
        return new HashMap<String, String>();
    if (keyPrefix == null)
        keyPrefix = """";

    Matcher matcher = QUERY_PATTERN.matcher(query);
    Map<String, String> routeQuery = new HashMap<String, String>();
    String key = null;
    while (matcher.find()) { // Match one by one
        String separator = matcher.group(1);
        String content = matcher.group(2);
        if (separator == null || separator.length() == 0
                || ""&"".equals(separator)) {
            if (key != null)
                throw new IllegalStateException(""Illegal query string \""""
                        + query + ""\"", The error char '"" + separator
                        + ""' at index "" + matcher.start() + "" before \""""
                        + content + ""\""."");
            key = content;
        } else if (""="".equals(separator)) {
            if (key == null)
                throw new IllegalStateException(""Illegal query string \""""
                        + query + ""\"", The error char '"" + separator
                        + ""' at index "" + matcher.start() + "" before \""""
                        + content + ""\""."");
            routeQuery.put(keyPrefix + key, content);
            key = null;
        } else {
            if (key == null)
                throw new IllegalStateException(""Illegal query string \""""
                        + query + ""\"", The error char '"" + separator
                        + ""' at index "" + matcher.start() + "" before \""""
                        + content + ""\""."");
        }
    }
    /*if (key != null)
    throw new IllegalStateException(""Illegal route rule \"""" + query
            + ""\"", The error in the end char: "" + key);*/
    return routeQuery;
}","/**
 * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.
 *
 * @param keyPrefix In the output of the Map Key plus a unified prefix.
 * @param query Query String，For example: <code>key1=value1&key2=value2</code>
 * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,
 *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.
 */
// FIXME Is it reasonable to throw an IllegalStateException??
public static Map<String, String> parseQuery(String keyPrefix, String query) 
{
    Map<String, String> result = new HashMap<String, String>();
    if (query != null && !query.isEmpty())
    {
        String[] params = query.split(""&"");
        for (String param : params)
        {
            String[] pair = param.split(""="");
            if (pair.length == 2)
            {
                result.put(keyPrefix + pair[0], pair[1]);
            }
            else if (pair.length == 1)
            {
                result.put(keyPrefix + pair[0], """");
            }
            else
            {
                throw new IllegalStateException(""Query String formatted incorrectly"");
            }
        }
    }
    return result;
}   ",1294,False
"// TODO At present, the multiple Key of Condition is in disorder. Should we sort it?
public static void contidionToString(StringBuilder sb, Map<String, MatchPair> condition){
    boolean isFirst = true;
    for (Entry<String, MatchPair> entry : condition.entrySet()) {
        String keyName = entry.getKey();
        MatchPair p = entry.getValue();

        @SuppressWarnings(""unchecked"")
        Set<String>[] setArray = new Set[]{p.matches, p.unmatches};
        String[] opArray = {"" = "", "" != ""};

        for (int i = 0; i < setArray.length; ++i) {
            if (setArray[i].isEmpty()) {
                continue;
            }
            if (isFirst) {
                isFirst = false;
            } else {
                sb.append("" & "");
            }

            sb.append(keyName);
            sb.append(opArray[i]);
            join(sb, setArray[i]);
        }
    }
}","// TODO At present, the multiple Key of Condition is in disorder. Should we sort it?
public static void contidionToString(StringBuilder sb, Map<String, MatchPair> condition) 
{
    int i = 0;
    for (Map.Entry<String, MatchPair> entry : condition.entrySet())
    {
        if (i == 0)
        {
            sb.append("" WHERE "");
        }
        else
        {
            sb.append("" AND "");
        }
        sb.append(entry.getKey()).append("" = "").append(entry.getValue().getMatchValue());
        i++;
    }
}   ",1297,True
"/**
 * Finds and returns the main content view from the Activity context.
 * @return the main content view
 */
public View getActivityContentView(){
    try {
        return ((Activity) mainActionView.getContext()).getWindow().getDecorView().findViewById(android.R.id.content);
    }
    catch(ClassCastException e) {
        throw new ClassCastException(""Please provide an Activity context for this FloatingActionMenu."");
    }
}","/**
 * Finds and returns the main content view from the Activity context.
 * @return the main content view
 */

public View getActivityContentView() 
{
    return ((ViewGroup) getActivity().findViewById(android.R.id.content)).getChildAt(0);
}   ",1302,True
"/**
 * Detaches it from the container view.
 */
public void detach(){
    if(systemOverlay) {
        getWindowManager().removeView(this);
    }
    else {
        ((ViewGroup) getActivityContentView()).removeView(this);
    }
}","/**
 * Detaches it from the container view.
 */
public void detach() 
{
    if (mContainerView != null)
    {
        mContainerView.removeView(this);
        mContainerView = null;
    }
}   ",1303,False
"/**
 * Retrieves the screen size from the Activity context
 * @return the screen size as a Point object
 */
private Point getScreenSize(){
    Point size = new Point();
    getWindowManager().getDefaultDisplay().getSize(size);
    return size;
}","/**
 * Retrieves the screen size from the Activity context
 * @return the screen size as a Point object
 */

private Point getScreenSize() 
{
    Display display = getDisplay();
    Point size = new Point();
    display.getSize(size);
    return size;
}   ",1306,True
"/**
 * Sets the current animation handler to the specified MenuAnimationHandler child
 * @param animationHandler a MenuAnimationHandler child
 * @return the builder object itself
 */
public Builder setAnimationHandler(MenuAnimationHandler animationHandler){
    this.animationHandler = animationHandler;
    return this;
}","/**
 * Sets the current animation handler to the specified MenuAnimationHandler child
 * @param animationHandler a MenuAnimationHandler child
 * @return the builder object itself
 */
public Builder setAnimationHandler(MenuAnimationHandler animationHandler) 
{
    this.animationHandler = animationHandler;
    return this;
}   ",1307,True
"/**
 * Recalculates the positions of each sub action item on demand.
 */
public void updateItemPositions(){
    // Only update if the menu is currently open
    if(!isOpen()) {
        return;
    }
    // recalculate x,y coordinates of Items
    calculateItemPositions();

    // Simply update layout params for each item
    for (int i = 0; i < subActionItems.size(); i++) {
        // This is currently done by giving them large margins
        final FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(subActionItems.get(i).width, subActionItems.get(i).height, Gravity.TOP | Gravity.LEFT);
        params.setMargins(subActionItems.get(i).x, subActionItems.get(i).y, 0, 0);
        subActionItems.get(i).view.setLayoutParams(params);
    }
}","/**
 * Recalculates the positions of each sub action item on demand.
 */
public void updateItemPositions() 
{
    int y = 0;
    for (SubActionItem item : subActionItems)
    {
        item.setY(y);
        y += item.getHeight();
    }
}   ",1311,True
"/**
 * Simply opens the menu by doing necessary calculations.
 * @param animated if true, this action is executed by the current {@link MenuAnimationHandler}
 */
public void open(boolean animated){

    // Get the center of the action view from the following function for efficiency
    // populate destination x,y coordinates of Items
    Point center = calculateItemPositions();

    WindowManager.LayoutParams overlayParams = null;

    if(systemOverlay) {
        // If this is a system overlay menu, use the overlay container and place it behind
        // the main action button so that all the views will be added into it.
        attachOverlayContainer();

        overlayParams = (WindowManager.LayoutParams) overlayContainer.getLayoutParams();
    }

    if(animated && animationHandler != null) {
        // If animations are enabled and we have a MenuAnimationHandler, let it do the heavy work
        if(animationHandler.isAnimating()) {
            // Do not proceed if there is an animation currently going on.
            return;
        }

        for (int i = 0; i < subActionItems.size(); i++) {
            // It is required that these Item views are not currently added to any parent
            // Because they are supposed to be added to the Activity content view,
            // just before the animation starts
            if (subActionItems.get(i).view.getParent() != null) {
                throw new RuntimeException(""All of the sub action items have to be independent from a parent."");
            }

            // Initially, place all items right at the center of the main action view
            // Because they are supposed to start animating from that point.
            final FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(subActionItems.get(i).width, subActionItems.get(i).height, Gravity.TOP | Gravity.LEFT);

            if(systemOverlay) {
                params.setMargins(center.x - overlayParams.x - subActionItems.get(i).width / 2, center.y - overlayParams.y - subActionItems.get(i).height / 2, 0, 0);
            }
            else {
                params.setMargins(center.x - subActionItems.get(i).width / 2, center.y - subActionItems.get(i).height / 2, 0, 0);
            }
            addViewToCurrentContainer(subActionItems.get(i).view, params);
        }
        // Tell the current MenuAnimationHandler to animate from the center
        animationHandler.animateMenuOpening(center);
    }
    else {
        // If animations are disabled, just place each of the items to their calculated destination positions.
        for (int i = 0; i < subActionItems.size(); i++) {
            // This is currently done by giving them large margins

            final FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(subActionItems.get(i).width, subActionItems.get(i).height, Gravity.TOP | Gravity.LEFT);
            if(systemOverlay) {
                params.setMargins(subActionItems.get(i).x - overlayParams.x, subActionItems.get(i).y - overlayParams.y, 0, 0);
                subActionItems.get(i).view.setLayoutParams(params);
            }
            else {
                params.setMargins(subActionItems.get(i).x, subActionItems.get(i).y, 0, 0);
                subActionItems.get(i).view.setLayoutParams(params);
                // Because they are placed into the main content view of the Activity,
                // which is itself a FrameLayout
            }
            addViewToCurrentContainer(subActionItems.get(i).view, params);
        }
    }
    // do not forget to specify that the menu is open.
    open = true;

    if(stateChangeListener != null) {
        stateChangeListener.onMenuOpened(this);
    }

}","/**
 * Simply opens the menu by doing necessary calculations.
 * @param animated if true, this action is executed by the current {@link MenuAnimationHandler}
 */
public void open(boolean animated) 
{
    if (animated)
    {
        this.menuAnimationHandler.open(this);
    }
    else
    {
        this.isOpen = true;
    }
}   ",1313,False
"/**
 * Gets the coordinates of the main action view
 * This method should only be called after the main layout of the Activity is drawn,
 * such as when a user clicks the action button.
 * @return a Point containing x and y coordinates of the top left corner of action view
 */
private Point getActionViewCoordinates(){
    int[] coords = new int[2];
    // This method returns a x and y values that can be larger than the dimensions of the device screen.
    mainActionView.getLocationOnScreen(coords);

    // So, we need to deduce the offsets.
    if(systemOverlay) {
        coords[1] -= getStatusBarHeight();
    }
    else {
        Rect activityFrame = new Rect();
        getActivityContentView().getWindowVisibleDisplayFrame(activityFrame);
        coords[0] -= (getScreenSize().x - getActivityContentView().getMeasuredWidth());
        coords[1] -= (activityFrame.height() + activityFrame.top - getActivityContentView().getMeasuredHeight());
    }
    return new Point(coords[0], coords[1]);
}","/**
 * Gets the coordinates of the main action view
 * This method should only be called after the main layout of the Activity is drawn,
 * such as when a user clicks the action button.
 * @return a Point containing x and y coordinates of the top left corner of action view
 */
private Point getActionViewCoordinates() 
{
    int[] location = new int[2];
    actionView.getLocationOnScreen(location);
    return new Point(location[0], location[1]);
}   ",1314,False
"/**
 * Sets the position of the button by calculating its Gravity from the position parameter
 * @param position one of 8 specified positions.
 * @param layoutParams should be either FrameLayout.LayoutParams or WindowManager.LayoutParams
 */
public void setPosition(int position, ViewGroup.LayoutParams layoutParams){

    boolean setDefaultMargin = false;

    int gravity;
    switch (position) {
        case POSITION_TOP_CENTER:
            gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
            break;
        case POSITION_TOP_RIGHT:
            gravity = Gravity.TOP | Gravity.RIGHT;
            break;
        case POSITION_RIGHT_CENTER:
            gravity = Gravity.RIGHT | Gravity.CENTER_VERTICAL;
            break;
        case POSITION_BOTTOM_CENTER:
            gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
            break;
        case POSITION_BOTTOM_LEFT:
            gravity = Gravity.BOTTOM | Gravity.LEFT;
            break;
        case POSITION_LEFT_CENTER:
            gravity = Gravity.LEFT | Gravity.CENTER_VERTICAL;
            break;
        case POSITION_TOP_LEFT:
            gravity = Gravity.TOP | Gravity.LEFT;
            break;
        case POSITION_BOTTOM_RIGHT:
        default:
            setDefaultMargin = true;
            gravity = Gravity.BOTTOM | Gravity.RIGHT;
            break;
    }
    if(!systemOverlay) {
        try {
            FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) layoutParams;
            lp.gravity = gravity;
            setLayoutParams(lp);
        } catch (ClassCastException e) {
            throw new ClassCastException(""layoutParams must be an instance of "" +
                    ""FrameLayout.LayoutParams, since this FAB is not a systemOverlay"");
        }
    }
    else {
        try {
            WindowManager.LayoutParams lp = (WindowManager.LayoutParams) layoutParams;
            lp.gravity = gravity;
            if(setDefaultMargin) {
                int margin =  getContext().getResources().getDimensionPixelSize(R.dimen.action_button_margin);
                lp.x = margin;
                lp.y = margin;
            }
            setLayoutParams(lp);
        } catch(ClassCastException e) {
            throw new ClassCastException(""layoutParams must be an instance of "" +
                    ""WindowManager.LayoutParams, since this FAB is a systemOverlay"");
        }
    }
}","/**
 * Sets the position of the button by calculating its Gravity from the position parameter
 * @param position one of 8 specified positions.
 * @param layoutParams should be either FrameLayout.LayoutParams or WindowManager.LayoutParams
 */
public void setPosition(int position, ViewGroup.LayoutParams layoutParams) 
{
    if (layoutParams instanceof FrameLayout.LayoutParams) {
        ((FrameLayout.LayoutParams) layoutParams).gravity = getGravity(position);
    } else if (layoutParams instanceof WindowManager.LayoutParams) {
        ((WindowManager.LayoutParams) layoutParams).gravity = getGravity(position);
    }
}   ",1315,True
"/**
 * Closes the menu.
 * @param animated if true, this action is executed by the current {@link MenuAnimationHandler}
 */
public void close(boolean animated){
    // If animations are enabled and we have a MenuAnimationHandler, let it do the heavy work
    if(animated && animationHandler != null) {
        if(animationHandler.isAnimating()) {
            // Do not proceed if there is an animation currently going on.
            return;
        }
        animationHandler.animateMenuClosing(getActionViewCenter());
    }
    else {
        // If animations are disabled, just detach each of the Item views from the Activity content view.
        for (int i = 0; i < subActionItems.size(); i++) {
            removeViewFromCurrentContainer(subActionItems.get(i).view);
        }
        detachOverlayContainer();
    }
    // do not forget to specify that the menu is now closed.
    open = false;

    if(stateChangeListener != null) {
        stateChangeListener.onMenuClosed(this);
    }
}","/**
 * Closes the menu.
 * @param animated if true, this action is executed by the current {@link MenuAnimationHandler}
 */
public void close(boolean animated) 
{
    if (animated)
    {
        this.menuAnimationHandler.closeMenu();
    }
    else
    {
        this.menuAnimationHandler.closeMenuWithoutAnimation();
    }
}   ",1316,False
"/**
 * Constructor that takes the parameters collected using {@link FloatingActionMenu.Builder}
 * @param mainActionView
 * @param startAngle
 * @param endAngle
 * @param radius
 * @param subActionItems
 * @param animationHandler
 * @param animated
 */
public FloatingActionMenu(final View mainActionView,
                          int startAngle,
                          int endAngle,
                          int radius,
                          List<Item> subActionItems,
                          MenuAnimationHandler animationHandler,
                          boolean animated,
                          MenuStateChangeListener stateChangeListener,
                          final boolean systemOverlay){
    this.mainActionView = mainActionView;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.radius = radius;
    this.subActionItems = subActionItems;
    this.animationHandler = animationHandler;
    this.animated = animated;
    this.systemOverlay = systemOverlay;
    // The menu is initially closed.
    this.open = false;

    this.stateChangeListener = stateChangeListener;

    // Listen click events on the main action view
    // In the future, touch and drag events could be listened to offer an alternative behaviour
    this.mainActionView.setClickable(true);
    this.mainActionView.setOnClickListener(new ActionViewClickListener());

    // Do not forget to set the menu as self to our customizable animation handler
    if(animationHandler != null) {
        animationHandler.setMenu(this);
    }

    if(systemOverlay) {
        overlayContainer = new FrameLayout(mainActionView.getContext());
    }
    else {
        overlayContainer = null; // beware NullPointerExceptions!
    }

    // Find items with undefined sizes
    for(final Item item : subActionItems) {
        if(item.width == 0 || item.height == 0) {
            if(systemOverlay) {
                throw new RuntimeException(""Sub action views cannot be added without "" +
                        ""definite width and height."");
            }
            // Figure out the size by temporarily adding it to the Activity content view hierarchy
            // and ask the size from the system
            addViewToCurrentContainer(item.view);
            // Make item view invisible, just in case
            item.view.setAlpha(0);
            // Wait for the right time
            item.view.post(new ItemViewQueueListener(item));
        }
    }

    if(systemOverlay) {
        orientationListener = new OrientationEventListener(mainActionView.getContext(), SensorManager.SENSOR_DELAY_UI) {
            private int lastState = -1;

            public void onOrientationChanged(int orientation) {

                Display display = getWindowManager().getDefaultDisplay();
                if(display.getRotation() != lastState) {
                    lastState = display.getRotation();

                    //
                    if(isOpen()) {
                        close(false);
                    }
                }
            }
        };
        orientationListener.enable();
    }
}","/**
 * Constructor that takes the parameters collected using {@link FloatingActionMenu.Builder}
 * @param mainActionView
 * @param startAngle
 * @param endAngle
 * @param radius
 * @param subActionItems
 * @param animationHandler
 * @param animated
 */
public FloatingActionMenu(final View mainActionView,
                          int startAngle,
                          int endAngle,
                          int radius,
                          List<Item> subActionItems,
                          MenuAnimationHandler animationHandler,
                          boolean animated,
                          MenuStateChangeListener stateChangeListener,
                          final boolean systemOverlay) 
{
    this.mainActionView = mainActionView;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.radius = radius;
    this.subActionItems = subActionItems;
    this.animationHandler = animationHandler;
    this.animated = animated;
    this.stateChangeListener = stateChangeListener;
    this.systemOverlay = systemOverlay;

    init();
}   ",1318,True
"/**
 * Returns the center point of the main action view
 * @return the action view center point
 */
public Point getActionViewCenter(){
    Point point = getActionViewCoordinates();
    point.x += mainActionView.getMeasuredWidth() / 2;
    point.y += mainActionView.getMeasuredHeight() / 2;
    return point;
}","/**
 * Returns the center point of the main action view
 * @return the action view center point
 */
public Point getActionViewCenter() 
{
    int[] location = new int[2];
    mActionView.getLocationOnScreen(location);
    return new Point(location[0] + mActionView.getWidth() / 2, location[1] + mActionView.getHeight() / 2);
}   ",1319,True
"/**
 * Inserts item x at position k, maintaining heap invariant by promoting x
 * up the tree until it is greater than or equal to its parent, or is the
 * root.
 * <p/>
 * To simplify and speed up coercions and comparisons. the Comparable and
 * Comparator versions are separated into different methods that are
 * otherwise identical. (Similarly for siftDown.)
 *
 * @param k the position to fill
 * @param x the item to insert
 */
private void siftUp(int k, E x){
    Comparable<? super E> key = (Comparable<? super E>) x;
    while (k > 0) {
        int parent = (k - 1) >>> 1;
        Object e = queue[parent];
        if (key.compareTo((E) e) >= 0)
            break;
        queue[k] = e;
        k = parent;
    }
    queue[k] = key;
}","/**
 * Inserts item x at position k, maintaining heap invariant by promoting x
 * up the tree until it is greater than or equal to its parent, or is the
 * root.
 * <p/>
 * To simplify and speed up coercions and comparisons. the Comparable and
 * Comparator versions are separated into different methods that are
 * otherwise identical. (Similarly for siftDown.)
 *
 * @param k the position to fill
 * @param x the item to insert
 */
private void siftUp(int k, E x) 
{
    if (comparator != null)
    {
        siftUpUsingComparator(k, x);
    }
    else
    {
        siftUpComparable(k, x);
    }
}   ",1320,True
"// unit test in utils-test.clj
public static Charset detectCharset(Map<String, Object> headers, DynamicBytes body){
    // 1. first from http header: Content-Type: text/html; charset=utf8
    Charset result = parseCharset(getStringValue(headers, CONTENT_TYPE));
    if (result == null) {
        // 2. decode a little to find charset=???
        String s = new String(body.get(), 0, min(512, body.length()), ASCII);
        // content=""text/html;charset=gb2312""
        result = guess(s, CHARSET);
        if (result == null) {
            // for xml
            Matcher matcher = ENCODING.matcher(s);
            if (matcher.find()) {
                try {
                    result = Charset.forName(matcher.group(2));
                } catch (Exception ignore) {
                }
            }
        }
    }
    // default utf8
    return result == null ? UTF_8 : result;
}","// unit test in utils-test.clj
public static Charset detectCharset(Map<String, Object> headers, DynamicBytes body) 
{
    if (headers.containsKey(""content-type""))
    {
        String contentType = headers.get(""content-type"").toString();
        if (contentType.contains(""charset""))
        {
            Matcher matcher = CHARSET_PATTERN.matcher(contentType);
            if (matcher.find())
            {
                return Charset.forName(matcher.group(1));
            }
        }
    }
    return DEFAULT_CHARSET;
}   ",1322,True
"// request + request sent to server, wait for 2 server responses
public static String get2(String url) throws URISyntaxException, IOException{
    URI uri = new URI(url);
    InetSocketAddress addr = HttpUtils.getServerAddr(uri);

    Socket s = new Socket();
    s.connect(addr);
    OutputStream os = s.getOutputStream();

    String request = ""GET "" + HttpUtils.getPath(uri)
            + "" HTTP/1.1\r\nHost: localhost\r\n\r\n"";

    os.write((request + request).getBytes());
    os.flush();

    InputStream is = s.getInputStream();

    byte[] buffer = new byte[8096];
    int read = is.read(buffer);
    s.close();
    return new String(buffer, 0, read);
}","// request + request sent to server, wait for 2 server responses






public static String get2(String url) throws URISyntaxException, IOException 
{
    HttpClient client = HttpClientBuilder.create().build();
    HttpGet request = new HttpGet(url);

    HttpResponse response = client.execute(request);
    String result = EntityUtils.toString(response.getEntity());
    return result;
}   ",1323,False
"/**
 * Removes a single instance of the specified element from this queue, if it
 * is present. More formally, removes an element {@code e} such that
 * {@code o.equals(e)}, if this queue contains one or more such elements.
 * Returns {@code true} if and only if this queue contained the specified
 * element (or equivalently, if this queue changed as a result of the call).
 *
 * @param o element to be removed from this queue, if present
 * @return Element removed
 */
public E remove(Object o){
    for (int i = 0; i < size; i++) {
        if (queue[i].equals(o)) {
            E e = (E) queue[i];
            removeAt(i);
            return e;
        }
    }
    return null;
}","/**
 * Removes a single instance of the specified element from this queue, if it
 * is present. More formally, removes an element {@code e} such that
 * {@code o.equals(e)}, if this queue contains one or more such elements.
 * Returns {@code true} if and only if this queue contained the specified
 * element (or equivalently, if this queue changed as a result of the call).
 *
 * @param o element to be removed from this queue, if present
 * @return Element removed
 */
public E remove(Object o) 
{
    if (o == null)
    {
        return null;
    }
    else
    {
        return (E)super.remove(o);
    }
}   ",1325,True
"// content-type => Content-Type
public static String camelCase(String key){
    StringBuilder sb = new StringBuilder(key.length());
    boolean upper = true;
    for (int i = 0; i < key.length(); i++) {
        char c = key.charAt(i);
        if (upper) {
            sb.append(Character.toUpperCase(c));
        } else {
            sb.append(Character.toLowerCase(c));
        }
        upper = c == '-';
    }
    return sb.toString();
}","// content-type => Content-Type
public static String camelCase(String key) 
{
    StringBuilder sb = new StringBuilder();
    boolean nextUpperCase = false;
    for (int i = 0; i < key.length(); i++)
    {
        char c = key.charAt(i);
        if (c == '-')
        {
            nextUpperCase = true;
        }
        else if (nextUpperCase)
        {
            sb.append(Character.toUpperCase(c));
            nextUpperCase = false;
        }
        else
        {
            sb.append(Character.toLowerCase(c));
        }
    }
    return sb.toString();
}   ",1327,True
"// Write first HTTP header and [first chunk data]? to client
private void firstWrite(Object data, boolean close) throws IOException{
    ByteBuffer buffers[];
    int status = 200;
    Object body = data;
    HeaderMap headers;
    if (data instanceof Map) {
        Map<Keyword, Object> resp = (Map<Keyword, Object>) data;
        headers = HeaderMap.camelCase((Map) resp.get(HEADERS));
        status = getStatus(resp);
        body = resp.get(BODY);
    } else {
        headers = new HeaderMap();
    }

    if (headers.isEmpty()) { // default 200 and text/html
        headers.put(""Content-Type"", ""text/html; charset=utf-8"");
    }

    if (request.isKeepAlive && request.version == HttpVersion.HTTP_1_0) {
        headers.put(""Connection"", ""Keep-Alive"");
    }

    if (close) { // normal response, Content-Length. Every http client understand it
        buffers = HttpEncode(status, headers, body, server.serverHeader);
    } else {
        if (request.version == HttpVersion.HTTP_1_1) {
            headers.put(""Transfer-Encoding"", ""chunked""); // first chunk
        }
        ByteBuffer[] bb = HttpEncode(status, headers, body, server.serverHeader);
        if (body == null) {
            buffers = bb;
        } else {
            buffers = new ByteBuffer[]{
                    bb[0], // header
                    chunkSize(bb[1].remaining()), // chunk size
                    bb[1], // chunk data
                    ByteBuffer.wrap(newLineBytes) // terminating CRLF sequence
            };
        }
    }
    if (close) {
        onClose(0);
    }
    server.tryWrite(key, !close, buffers);
}","// Write first HTTP header and [first chunk data]? to client
private void firstWrite(Object data, boolean close) throws IOException 
{
    if (data == null)
    {
        return;
    }

    if (data instanceof String)
    {
        firstWrite((String) data, close);
    }
    else if (data instanceof byte[])
    {
        firstWrite((byte[]) data, close);
    }
    else if (data instanceof ByteBuffer)
    {
        firstWrite((ByteBuffer) data, close);
    }
    else
    {
        throw new IllegalArgumentException(""Illegal data type: "" + data.getClass());
    }
}   ",1328,False
"// public void submit()
public void coseAndwait() throws InterruptedException{
    closed = true;
    for (Worker w : workers) {
        w.t.interrupt();
    }
    latch.await();
}","// public void submit()
public void coseAndwait() throws InterruptedException 
{
    int count = 0;
    while (count < 5)
    {
        Thread.sleep(1000);
        count++;
        System.out.println(""count = "" + count);
    }
}   ",1329,True
"/**
 * Retrieves and removes the head of this queue, or returns null if this
 * queue is empty.
 */
public E poll(){
    if (size == 0)
        return null;
    int s = --size;
    E result = (E) queue[0];
    E x = (E) queue[s];
    queue[s] = null;
    if (s != 0)
        siftDown(0, x);
    return result;
}","/**
 * Retrieves and removes the head of this queue, or returns null if this
 * queue is empty.
 */
public E poll() 
{
    if (head == null)
        return null;
    E result = head.data;
    head = head.next;
    if (head == null)
        tail = null;
    return result;
}   ",1332,True
"/**
 * Removes the ith element from queue.
 * <p/>
 * Normally this method leaves the elements at up to i-1, inclusive,
 * untouched. Under these circumstances, it returns null. Occasionally, in
 * order to maintain the heap invariant, it must swap a later element of the
 * list with one earlier than i. Under these circumstances, this method
 * returns the element that was previously at the end of the list and is now
 * at some position before i. This fact is used by iterator.remove so as to
 * avoid missing traversing elements.
 */
private E removeAt(int i){
    assert i >= 0 && i < size;
    int s = --size;
    if (s == i) // removed last element
        queue[i] = null;
    else {
        E moved = (E) queue[s];
        queue[s] = null;
        siftDown(i, moved);
        if (queue[i] == moved) {
            siftUp(i, moved);
            if (queue[i] != moved)
                return moved;
        }
    }
    return null;
}","/**
 * Removes the ith element from queue.
 * <p/>
 * Normally this method leaves the elements at up to i-1, inclusive,
 * untouched. Under these circumstances, it returns null. Occasionally, in
 * order to maintain the heap invariant, it must swap a later element of the
 * list with one earlier than i. Under these circumstances, this method
 * returns the element that was previously at the end of the list and is now
 * at some position before i. This fact is used by iterator.remove so as to
 * avoid missing traversing elements.
 */
private E removeAt(int i) 
{
    assert i >= 0 && i < size;
    modCount++;
    E removed = (E) elements[i];
    if (i < size - 1)
    {
        System.arraycopy(elements, i + 1, elements, i, size - i - 1);
    }
    size--;
    return removed;
}   ",1333,True
"/**
 * http-kit think all connections are keep-alived (since some say it is, but
 * actually is not). but, some are not, http-kit pick them out after the fact
 * <ol>
 * <li>The connection is reused</li>
 * <li>No data received</li>
 * </ol>
 */
private boolean cleanAndRetryIfBroken(SelectionKey key, Request req){
    closeQuietly(key);
    keepalives.remove(key);
    // keep-alived connection, remote server close it without sending byte
    if (req.isReuseConn && req.decoder.state == READ_INITIAL) {
        for (ByteBuffer b : req.request) {
            b.position(0); // reset for retry
        }
        req.isReuseConn = false;
        requests.remove(req); // remove from timeout queue
        pending.offer(req); // queue for retry
        selector.wakeup();
        return true; // retry: re-open a connection to server, sent the request again
    }
    return false;
}","/**
 * http-kit think all connections are keep-alived (since some say it is, but
 * actually is not). but, some are not, http-kit pick them out after the fact
 * <ol>
 * <li>The connection is reused</li>
 * <li>No data received</li>
 * </ol>
 */
private boolean cleanAndRetryIfBroken(SelectionKey key, Request req) 
{
    if (key.isValid() && key.attachment() instanceof Connection)
    {
        Connection conn = (Connection) key.attachment();
        if (conn.isBroken())
        {
            if (conn.isKeepAlive())
            {
                conn.close();
                return true;
            }
            else
            {
                conn.close();
                return false;
            }
        }
        else
        {
            return true;
        }
    }
    else
    {
        return false;
    }
}   ",1334,False
"// a special websocket client to test the robustness of the Decoder
// sent a byte at a time
public static boolean slowWebSocketClient(String url){
    try {
        URI uri = new URI(url);
        InetSocketAddress addr = HttpUtils.getServerAddr(uri);

        Socket s = new Socket();
        s.connect(addr);
        OutputStream os = s.getOutputStream();
        InputStream is = s.getInputStream();

        byte[] buffer = new byte[8096];
        String request = ""GET "" + HttpUtils.getPath(uri)
                + "" HTTP/1.1\r\nHost: localhost\r\nUpgrade: websocket\r\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n\r\n"";
        os.write(request.getBytes());
        int read = is.read(buffer);
        if (!new String(buffer, 0, read).contains(""websocket"")) {
            return false;
        }

        String msg = ""this is a test; this is a test; this is a test"";
        for (int i = 0; i < 2; i++) {
            wsRequest(os, is, msg);
            msg += (msg + msg + msg + msg);
        }
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }

}","// a special websocket client to test the robustness of the Decoder
// sent a byte at a time




public static boolean slowWebSocketClient(String url) 
{
    WebSocketClient client = new WebSocketClient();
    try {
        client.connect(new URI(url));
        client.send(""hello world"".getBytes());
        return true;
    } catch (URISyntaxException e) {
        e.printStackTrace();
        return false;
    } catch (IOException e) {
        e.printStackTrace();
        return false;
    }
}   ",1336,False
"// future time this request timeout, ms
public Request(InetSocketAddress addr, ByteBuffer[] request, IRespListener handler,
                  PriorityQueue<Request> clients, RequestConfig config){
       this.cfg = config;
       this.decoder = new Decoder(handler, config.method);
       this.request = request;
       this.clients = clients;
       this.addr = addr;
       this.timeoutTs = config.connTimeout + System.currentTimeMillis();
   }","// future time this request timeout, ms
public Request(InetSocketAddress addr, ByteBuffer[] request, IRespListener handler,
                  PriorityQueue<Request> clients, RequestConfig config) 
{
    this.addr = addr;
    this.request = request;
    this.handler = handler;
    this.clients = clients;
    this.config = config;
    this.startTime = System.currentTimeMillis();
    this.timeout = startTime + config.getRequestTimeout();
}   ",1337,True
"/*----------------charset--------------------*/
public static Charset parseCharset(String type){
    if (type != null) {
        try {
            type = type.toLowerCase();
            int i = type.indexOf(CHARSET);
            if (i != -1) {
                String charset = type.substring(i + CHARSET.length()).trim();
                return Charset.forName(charset);
            }
        } catch (Exception ignore) {
        }
    }
    return null;
}","/*----------------charset--------------------*/
public static Charset parseCharset(String type) 
{
    if (type == null)
    {
        return null;
    }
    try
    {
        return Charset.forName(type);
    }
    catch (Exception ex)
    {
        return null;
    }
}   ",1338,True
"// for streaming, send a chunk of data to client
private void writeChunk(Object body, boolean close) throws IOException{
    if (body instanceof Map) { // only get body if a map
        body = ((Map<Keyword, Object>) body).get(BODY);
    }
    if (body != null) { // null is ignored
        ByteBuffer t = bodyBuffer(body);
        if (t.hasRemaining()) {
            ByteBuffer[] buffers = new ByteBuffer[]{
                    chunkSize(t.remaining()),
                    t,  // actual data
                    ByteBuffer.wrap(newLineBytes) // terminating CRLF sequence
            };
            server.tryWrite(key, !close, buffers);
        }
    }
    if (close) {
        serverClose(0);
    }
}","// for streaming, send a chunk of data to client
private void writeChunk(Object body, boolean close) throws IOException 
{
    if (body == null)
    {
        return;
    }

    if (body instanceof byte[])
    {
        writeChunk((byte[])body, close);
    }
    else if (body instanceof String)
    {
        writeChunk(((String)body).getBytes(), close);
    }
    else
    {
        throw new IllegalArgumentException(""body must be byte[] or String"");
    }
}   ",1339,False
"/**
 * WARNING: Drops all table on Upgrade! Use only during development.
 * Convenience method using a {@link DevOpenHelper}.
 */
public static DaoSession newDevSession(Context context, String name){
    Database db = new DevOpenHelper(context, name).getWritableDb();
    DaoMaster daoMaster = new DaoMaster(db);
    return daoMaster.newSession();
}","/**
 * WARNING: Drops all table on Upgrade! Use only during development.
 * Convenience method using a {@link DevOpenHelper}.
 */
public static DaoSession newDevSession(Context context, String name) 
{
    DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, name, null);
    Database db = helper.getWritableDb();
    DaoMaster daoMaster = new DaoMaster(db);
    return daoMaster.newSession();
}   ",1340,True
"/**
 * Click view
 *
 * @param content Content to view
 */
protected void clickView(String content){
    onView(withText(content))
            .check(matches(isDisplayed()))
            .perform(click());
}","/**
 * Click view
 *
 * @param content Content to view
 */


protected void clickView(String content) 
{
    try
    {
        WebElement element = driver.findElement(By.xpath(""//a[contains(text(),'"" + content + ""')]""));
        element.click();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",1341,False
"/**
 * Show alertDialog
 *
 * @param mActivity activity instance
 * @param content show content
 * @param btnContent btn content
 */
public void showDialog(Activity mActivity, String content, String btnContent){
    if (mActivity == null) {
        return;
    }
    if (alertDialog == null) {
        alertDialog = new AlertDialog.Builder(mActivity, R.style.myCorDialog).create();
    }
    if (!alertDialog.isShowing()) {
        alertDialog.show();
    }
    alertDialog.setCanceledOnTouchOutside(false);
    Window window = alertDialog.getWindow();
    if (window != null) {
        window.setContentView(R.layout.common_alert_dialog);
        TextView contentTv = (TextView) window.findViewById(R.id.dialog_content);
        contentTv.setText(content);
        Button mOkBtn = (Button) window.findViewById(R.id.dialog_btn);
        mOkBtn.setText(btnContent);
        mOkBtn.setOnClickListener(v -> {
            if (alertDialog != null) {
                alertDialog.cancel();
                alertDialog = null;
            }
        });
        View btnDivider = window.findViewById(R.id.dialog_btn_divider);
        btnDivider.setVisibility(View.GONE);
        Button mNeBtn = (Button) window.findViewById(R.id.dialog_negative_btn);
        mNeBtn.setVisibility(View.GONE);
    }
}","/**
 * Show alertDialog
 *
 * @param mActivity activity instance
 * @param content show content
 * @param btnContent btn content
 */
public void showDialog(Activity mActivity, String content, String btnContent) 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(mActivity);
    builder.setTitle(""提示"");
    builder.setMessage(content);
    builder.setPositiveButton(btnContent, new DialogInterface.OnClickListener()
    {
        @Override
        public void onClick(DialogInterface dialog, int which)
        {
            dialog.dismiss();
        }
    });
    builder.show();
}   ",1347,False
"/**
 * Show alertDialog
 *
 * @param mActivity activity instance
 * @param content show content
 * @param btnContent btn content
 * @param onClickListener btn onClickListener
 */
public void showDialog(Activity mActivity, String content, String btnContent, final View.OnClickListener onClickListener){
    if (mActivity == null) {
        return;
    }
    if (alertDialog == null) {
        alertDialog = new AlertDialog.Builder(mActivity, R.style.myCorDialog).create();
    }
    if (!alertDialog.isShowing()) {
        alertDialog.show();
    }
    alertDialog.setCanceledOnTouchOutside(false);
    Window window = alertDialog.getWindow();
    if (window != null) {
        window.setContentView(R.layout.common_alert_dialog);
        TextView contentTv = (TextView) window.findViewById(R.id.dialog_content);
        contentTv.setText(content);
        Button mOkBtn = (Button) window.findViewById(R.id.dialog_btn);
        mOkBtn.setText(btnContent);
        mOkBtn.setOnClickListener(onClickListener);
        View btnDivider = window.findViewById(R.id.dialog_btn_divider);
        btnDivider.setVisibility(View.GONE);
        Button mNeBtn = (Button) window.findViewById(R.id.dialog_negative_btn);
        mNeBtn.setVisibility(View.GONE);
    }
}","/**
 * Show alertDialog
 *
 * @param mActivity activity instance
 * @param content show content
 * @param btnContent btn content
 * @param onClickListener btn onClickListener
 */
public void showDialog(Activity mActivity, String content, String btnContent, final View.OnClickListener onClickListener) 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(mActivity);
    builder.setTitle(""提示"");
    builder.setMessage(content);
    builder.setPositiveButton(btnContent, onClickListener);
    builder.setCancelable(false);
    builder.show();
}   ",1349,False
"/**
* 指定一个白名单, 在白名单的条目将不会出现在展示阻塞信息的UI中
*
* @return return null if you don't need white-list filter.
*/
@Override
public List<String> provideWhiteList(){
    LinkedList<String> whiteList = new LinkedList<>();
    whiteList.add(""org.chromium"");
    return whiteList;
}","/**
* 指定一个白名单, 在白名单的条目将不会出现在展示阻塞信息的UI中
*
* @return return null if you don't need white-list filter.
*/

@Override
public List<String> provideWhiteList() 
{
    List<String> whiteList = new ArrayList<String>();
    whiteList.add(""com.example.demo"");
    return whiteList;
}   ",1354,True
"/**
 * Cancel alertDialog
 */
public void cancelDialog(boolean isAdd){
    if (isAdd && alertDialog != null && alertDialog.isShowing()) {
        alertDialog.dismiss();
        alertDialog = null;
    }
}","/**
 * Cancel alertDialog
 */
public void cancelDialog(boolean isAdd) 
{
    if (isAdd)
    {
        if (dialog != null)
        {
            dialog.dismiss();
        }
    }
    else
    {
        if (dialog != null)
        {
            dialog.dismiss();
        }
    }
}   ",1356,True
"/**
 * Click the item of the recyclerView
 *
 * @param recyclerViewId IdRes to recyclerView
 * @param itemPosition RecyclerView item position
 */
protected void clickRecyclerViewItem(@IdRes int recyclerViewId, int itemPosition){
    onView(allOf(withId(recyclerViewId), hasFocus()))
            .check(matches(isDisplayed()))
            .perform(actionOnItemAtPosition(itemPosition, click()));
}","/**
 * Click the item of the recyclerView
 *
 * @param recyclerViewId IdRes to recyclerView
 * @param itemPosition RecyclerView item position
 */
protected void clickRecyclerViewItem(@IdRes int recyclerViewId, int itemPosition) 
{
    onView(withId(recyclerViewId)).perform(actionOnItemAtPosition(itemPosition, click()));
}   ",1357,True
"/**
 * Swipe up recyclerView to specify position
 *
 * @param recyclerViewId IdRes to recyclerView
 * @param position specify position
 */
protected void swipeUpRecyclerViewToPosition(@IdRes int recyclerViewId, int position){
    onView(allOf(withId(recyclerViewId), hasFocus()))
            .check(matches(isDisplayed()))
            .perform(scrollToPosition(position))
            .perform(swipeUp());
}","/**
 * Swipe up recyclerView to specify position
 *
 * @param recyclerViewId IdRes to recyclerView
 * @param position specify position
 */



protected void swipeUpRecyclerViewToPosition(@IdRes int recyclerViewId, int position) 
{
    RecyclerView recyclerView = (RecyclerView) activity.findViewById(recyclerViewId);
    RecyclerView.Adapter adapter = recyclerView.getAdapter();
    LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();

    // Get the target view
    View targetView = layoutManager.findViewByPosition(position);

    // Call swipeUpRecyclerViewToPosition
    swipeUpRecyclerViewToPosition(recyclerView, adapter, layoutManager, targetView, position);
}   ",1359,True
"/**
 * 初始化,设置该CrashHandler为程序的默认处理器
 */
public static void init(CrashHandler crashHandler){
    defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
    Thread.setDefaultUncaughtExceptionHandler(crashHandler);
}","/**
 * 初始化,设置该CrashHandler为程序的默认处理器
 */
public static void init(CrashHandler crashHandler) 
{
    if (crashHandler == null)
    {
        return;
    }
    Thread.setDefaultUncaughtExceptionHandler(crashHandler);
}   ",1360,True
"/**
 * 根据多个js链接生成Script标签
 *
 * @param urls List<String>
 * @return String
 */
public static String createJsTag(List<String> urls){

    final StringBuilder sb = new StringBuilder();
    for (String url : urls)
    {
        sb.append(createJsTag(url));
    }
    return sb.toString();
}","/**
 * 根据多个js链接生成Script标签
 *
 * @param urls List<String>
 * @return String
 */
public static String createJsTag(List<String> urls) 
{
    StringBuilder sb = new StringBuilder();
    for (String url : urls)
    {
        sb.append(""<script type=\""text/javascript\"" src=\"""").append(url).append(""\""></script>"");
    }
    return sb.toString();
}   ",1361,True
"/**
 * 从指定View开始向四周伸张(伸张颜色或图片为colorOrImageRes), 然后进入另一个Activity,
 * 返回至 @thisActivity 后显示收缩动画。
 */
@SuppressLint(""NewApi"")
public static void startActivityForResult(
        final Activity thisActivity, final Intent intent, final Integer requestCode, final Bundle bundle,
        final View triggerView, int colorOrImageRes, long durationMills){

    if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {
        thisActivity.startActivity(intent);
        return;
    }

    int[] location = new int[2];
    triggerView.getLocationInWindow(location);
    final int cx = location[0] + triggerView.getWidth() / 2;
    final int cy = location[1] + triggerView.getHeight() / 2;
    final ImageView view = new ImageView(thisActivity);
    view.setScaleType(ImageView.ScaleType.CENTER_CROP);
    view.setImageResource(colorOrImageRes);
    final ViewGroup decorView = (ViewGroup) thisActivity.getWindow().getDecorView();
    int w = decorView.getWidth();
    int h = decorView.getHeight();
    decorView.addView(view, w, h);

    // 计算中心点至view边界的最大距离
    int maxW = Math.max(cx, w - cx);
    int maxH = Math.max(cy, h - cy);
    final int finalRadius = (int) Math.sqrt(maxW * maxW + maxH * maxH) + 1;
    Animator
            anim = ViewAnimationUtils.createCircularReveal(view, cx, cy, 0, finalRadius);
    int maxRadius = (int) Math.sqrt(w * w + h * h) + 1;
    // 若使用默认时长，则需要根据水波扩散的距离来计算实际时间
    if (durationMills == PERFECT_MILLS) {
        // 算出实际边距与最大边距的比率
        double rate = 1d * finalRadius / maxRadius;
        // 水波扩散的距离与扩散时间成正比
        durationMills = (long) (PERFECT_MILLS * rate);
    }
    final long finalDuration = durationMills;
    anim.setDuration(finalDuration);
    anim.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            super.onAnimationEnd(animation);

            if (requestCode == null)
                thisActivity.startActivity(intent);
            else if (bundle == null)
                thisActivity.startActivityForResult(intent, requestCode);
            else
                thisActivity.startActivityForResult(intent, requestCode, bundle);

            // 默认渐隐过渡动画.
            thisActivity.overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);

            // 默认显示返回至当前Activity的动画.
            triggerView.postDelayed(new Runnable() {
                @Override
                public void run() {
                    Animator anim =
                            ViewAnimationUtils.createCircularReveal(view, cx, cy, finalRadius, 0);
                    anim.setDuration(finalDuration);
                    anim.addListener(new AnimatorListenerAdapter() {
                        @Override
                        public void onAnimationEnd(Animator animation) {
                            super.onAnimationEnd(animation);
                            try {
                                decorView.removeView(view);
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    });
                    anim.start();
                }
            }, 1000);

        }
    });
    anim.start();
}","/**
 * 从指定View开始向四周伸张(伸张颜色或图片为colorOrImageRes), 然后进入另一个Activity,
 * 返回至 @thisActivity 后显示收缩动画。
 */
@SuppressLint(""NewApi"")
public static void startActivityForResult(
        final Activity thisActivity, final Intent intent, final Integer requestCode, final Bundle bundle,
        final View triggerView, int colorOrImageRes, long durationMills) 
{
    final Drawable drawable;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
    {
        drawable = thisActivity.getResources().getDrawable(colorOrImageRes, null);
    } else
    {
        drawable = thisActivity.getResources().getDrawable(colorOrImageRes);
    }
    startActivityForResult(thisActivity, intent, requestCode, bundle, triggerView, drawable, durationMills);
}       ",1363,True
"/**
 * 统一返回结果处理
 * @param <T>
 * @return
 */
public static <T> FlowableTransformer<GankHttpResponse<T>, T> handleResult(){   //compose判断结果
    return new FlowableTransformer<GankHttpResponse<T>, T>() {
        @Override
        public Flowable<T> apply(Flowable<GankHttpResponse<T>> httpResponseFlowable) {
            return httpResponseFlowable.flatMap(new Function<GankHttpResponse<T>, Flowable<T>>() {
                @Override
                public Flowable<T> apply(GankHttpResponse<T> tGankHttpResponse) {
                    if(!tGankHttpResponse.getError()) {
                        return createData(tGankHttpResponse.getResults());
                    } else {
                        return Flowable.error(new ApiException(""服务器返回error""));
                    }
                }
            });
        }
    };
}","/**
 * 统一返回结果处理
 * @param <T>
 * @return
 */
public static <T> FlowableTransformer<GankHttpResponse<T>, T> handleResult() 
{
    return new FlowableTransformer<GankHttpResponse<T>, T>() {
        @Override
        public Publisher<T> apply(Flowable<GankHttpResponse<T>> upstream) {
            return upstream.flatMap(new Function<GankHttpResponse<T>, Publisher<T>>() {
                @Override
                public Publisher<T> apply(GankHttpResponse<T> tGankHttpResponse) {
                    if (tGankHttpResponse.isSuccess()) {
                        return Flowable.just(tGankHttpResponse.getResults());
                    } else {
                        return Flowable.error(new ApiException(tGankHttpResponse.getError()));
                    }
                }
            });
        }
    };
}   ",1364,True
"/**
 * 由满向中间收缩，直到隐藏。
 */
@SuppressLint(""NewApi"")
public static void hide(final View myView, float endRadius, long durationMills){
    if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {
        myView.setVisibility(View.INVISIBLE);
        return;
    }

    int cx = (myView.getLeft() + myView.getRight()) / 2;
    int cy = (myView.getTop() + myView.getBottom()) / 2;
    int w = myView.getWidth();
    int h = myView.getHeight();

    // 勾股定理 & 进一法
    int initialRadius = (int) Math.sqrt(w * w + h * h) + 1;

    Animator anim =
            ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, endRadius);
    anim.setDuration(durationMills);
    anim.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            super.onAnimationEnd(animation);
            myView.setVisibility(View.INVISIBLE);
        }
    });

    anim.start();
}","/**
 * 由满向中间收缩，直到隐藏。
 */
@SuppressLint(""NewApi"")
public static void hide(final View myView, float endRadius, long durationMills) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1)
    {
        ValueAnimator animator = ValueAnimator.ofFloat(endRadius, 0);
        animator.setDuration(durationMills);
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()
        {
            @Override
            public void onAnimationUpdate(ValueAnimator animation)
            {
                float radius = (float) animation.getAnimatedValue();
                myView.setCameraDistance(radius);
            }
        });
        animator.start();
    }
}   ",1365,False
"/**
 * 向四周伸张，直到完成显示。
 */
@SuppressLint(""NewApi"")
public static void show(View myView, float startRadius, long durationMills){
    if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {
        myView.setVisibility(View.VISIBLE);
        return;
    }

    int cx = (myView.getLeft() + myView.getRight()) / 2;
    int cy = (myView.getTop() + myView.getBottom()) / 2;

    int w = myView.getWidth();
    int h = myView.getHeight();

    // 勾股定理 & 进一法
    int finalRadius = (int) Math.sqrt(w * w + h * h) + 1;

    Animator anim =
            ViewAnimationUtils.createCircularReveal(myView, cx, cy, startRadius, finalRadius);
    myView.setVisibility(View.VISIBLE);
    anim.setDuration(durationMills);
    anim.start();
}","/**
 * 向四周伸张，直到完成显示。
 */

@SuppressLint(""NewApi"")
public static void show(View myView, float startRadius, long durationMills) 
{
    ValueAnimator animator = ObjectAnimator.ofFloat(myView, ""radius"", startRadius, 0).setDuration(durationMills);
    animator.start();
}   ",1366,True
"/**
 * 当天数据
 * @param info
 */
@Override
public void showContent(DailyListBean info){
    if(swipeRefresh.isRefreshing()) {
        swipeRefresh.setRefreshing(false);
    }
    stateMain();
    mList = info.getStories();
    currentDate = String.valueOf(Integer.valueOf(info.getDate()) + 1);
    mAdapter.addDailyDate(info);
    isDataReady = true;
    mPresenter.startInterval();
}","/**
 * 当天数据
 * @param info
 */
@Override
public void showContent(DailyListBean info) 
{
    if (info == null)
    {
        return;
    }
    List<DailyListBean.DailyBean> daily = info.getDaily();
    if (daily == null || daily.isEmpty())
    {
        return;
    }
    mDailyList.clear();
    mDailyList.addAll(daily);
    mDailyAdapter.notifyDataSetChanged();
}   ",1367,False
"/**
 * 由于recreate 需要特殊处理夜间模式
 * @param savedInstanceState
 */
@Override
protected void onCreate(@Nullable Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
        mPresenter.setNightModeState(false);
    } else {
        showFragment = mPresenter.getCurrentItem();
        hideFragment = Constants.TYPE_ZHIHU;
        showHideFragment(getTargetFragment(showFragment), getTargetFragment(hideFragment));
        mNavigationView.getMenu().findItem(R.id.drawer_zhihu).setChecked(false);
        mToolbar.setTitle(mNavigationView.getMenu().findItem(getCurrentItem(showFragment)).getTitle().toString());
        hideFragment = showFragment;
    }
}","/**
 * 由于recreate 需要特殊处理夜间模式
 * @param savedInstanceState
 */
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    if (savedInstanceState != null)
    {
        mPresenter = new Presenter(this);
        mPresenter.onCreate(savedInstanceState);
    }
    else
    {
        recreate();
    }
}   ",1368,False
"/**
 * 统一线程处理
 * @param <T>
 * @return
 */
public static <T> FlowableTransformer<T, T> rxSchedulerHelper(){    //compose简化线程
    return new FlowableTransformer<T, T>() {
        @Override
        public Flowable<T> apply(Flowable<T> observable) {
            return observable.subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread());
        }
    };
}","/**
 * 统一线程处理
 * @param <T>
 * @return
 */
public static <T> FlowableTransformer<T, T> rxSchedulerHelper() 
{
    return new FlowableTransformer<T, T>()
    {
        @Override
        public Publisher<T> apply(Flowable<T> upstream)
        {
            return upstream.subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread());
        }
    };
}   ",1369,True
"/**
 * 得到程序崩溃的详细信息
 */
public String getCrashInfo(Throwable ex){
    Writer result = new StringWriter();
    PrintWriter printWriter = new PrintWriter(result);
    ex.setStackTrace(ex.getStackTrace());
    ex.printStackTrace(printWriter);
    return result.toString();
}","/**
 * 得到程序崩溃的详细信息
 */


public String getCrashInfo(Throwable ex) 
{
    StringBuffer sb = new StringBuffer();
    Writer writer = new StringWriter();
    PrintWriter printWriter = new PrintWriter(writer);
    ex.printStackTrace(printWriter);
    Throwable cause = ex.getCause();
    while (cause != null)
    {
        cause.printStackTrace(printWriter);
        cause = cause.getCause();
    }
    printWriter.close();
    String result = writer.toString();
    sb.append(result);
    return sb.toString();
}   ",1370,True
"/**
 * 收集程序崩溃的设备信息
 */
public String collectCrashDeviceInfo(){
    try {
        PackageManager pm = context.getPackageManager();
        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
        String versionName = pi.versionName;
        String model = android.os.Build.MODEL;
        String androidVersion = android.os.Build.VERSION.RELEASE;
        String manufacturer = android.os.Build.MANUFACTURER;
        return versionName + ""  "" + model + ""  "" + androidVersion + ""  "" + manufacturer;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    return null;
}","/**
 * 收集程序崩溃的设备信息
 */
public String collectCrashDeviceInfo() 
{
    StringBuffer crashDeviceInfo = new StringBuffer();
    try
    {
        Field[] fields = Build.class.getDeclaredFields();
        for (Field field : fields)
        {
            field.setAccessible(true);
            crashDeviceInfo.append(field.getName() + "" : "" + field.get(null).toString() + ""\n"");
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return crashDeviceInfo.toString();
}   ",1371,False
"/**
 * 过往数据
 * @param date
 * @param info
 */
@Override
public void showMoreContent(String date,DailyBeforeListBean info){
    if(swipeRefresh.isRefreshing()) {
        swipeRefresh.setRefreshing(false);
    }
    stateMain();
    isDataReady = false;
    mPresenter.stopInterval();
    mList = info.getStories();
    currentDate = String.valueOf(Integer.valueOf(info.getDate()));
    mAdapter.addDailyBeforeDate(info);
}","/**
 * 过往数据
 * @param date
 * @param info
 */
@Override
public void showMoreContent(String date,DailyBeforeListBean info) 
{
    if (info != null)
    {
        if (info.getDailyList() != null)
        {
            if (info.getDailyList().size() > 0)
            {
                if (adapter != null)
                {
                    adapter.addData(info.getDailyList());
                }
            }
        }
    }
}   ",1373,False
"/**
 * 根据样式标签,html字符串,js标签
 * 生成完整的HTML文档
 */
public static String createHtmlData(String html, List<String> cssList, List<String> jsList){
    final String css = HtmlUtil.createCssTag(cssList);
    final String js = HtmlUtil.createJsTag(jsList);
    return css.concat(HIDE_HEADER_STYLE).concat(html).concat(js);
}","/**
 * 根据样式标签,html字符串,js标签
 * 生成完整的HTML文档
 */
public static String createHtmlData(String html, List<String> cssList, List<String> jsList) 
{
    StringBuilder sb = new StringBuilder();
    sb.append(""<html><head>"");
    for (String css : cssList)
    {
        sb.append(""<link rel=\""stylesheet\"" href=\"""" + css + ""\""/>"");
    }
    sb.append(""</head><body>"");
    sb.append(html);
    for (String js : jsList)
    {
        sb.append(""<script src=\"""" + js + ""\""></script>"");
    }
    sb.append(""</body></html>"");
    return sb.toString();
}   ",1375,True
"// xss跨站脚本检测
public static boolean xssInspect(String value){
    if (StringUtils.isNotBlank(value)) {
        // 避免script 标签
        Pattern scriptPattern = Pattern.compile(""<script>(.*?)</script>"", Pattern.CASE_INSENSITIVE);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免src形式的表达式
        scriptPattern = Pattern.compile(""src[\r\n]*=[\r\n]*\\\'(.*?)\\\'"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        scriptPattern = Pattern.compile(""src[\r\n]*=[\r\n]*\\\""(.*?)\\\"""", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 删除单个的 </script> 标签
        scriptPattern = Pattern.compile(""</script>"", Pattern.CASE_INSENSITIVE);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 删除单个的<script ...> 标签
        scriptPattern = Pattern.compile(""<script(.*?)>"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 eval(...) 形式表达式
        scriptPattern = Pattern.compile(""eval\\((.*?)\\)"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 e­xpression(...) 表达式
        scriptPattern = Pattern.compile(""e­xpression\\((.*?)\\)"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 javascript: 表达式
        scriptPattern = Pattern.compile(""javascript:"", Pattern.CASE_INSENSITIVE);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 vbscript:表达式
        scriptPattern = Pattern.compile(""vbscript:"", Pattern.CASE_INSENSITIVE);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 onload= 表达式
        scriptPattern = Pattern.compile(""onload(.*?)="", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 onmouseover= 表达式
        scriptPattern = Pattern.compile(""onmouseover(.*?)="", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 onfocus= 表达式
        scriptPattern = Pattern.compile(""onfocus(.*?)="", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
        // 避免 onerror= 表达式
        scriptPattern = Pattern.compile(""onerror(.*?)="", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        if (scriptPattern.matcher(value).matches()) {
            return true;
        }
    }
    return false;
}","// xss跨站脚本检测
public static boolean xssInspect(String value) 
{
    if (value == null || value.isEmpty()) {
        return false;
    }
    String valueLower = value.toLowerCase();
    if (valueLower.contains(""<script>"") || valueLower.contains(""</script>"")) {
        return true;
    }
    return false;
}   ",1383,False
"/**
 * 按照相对应的规则查找所有匹配类
 *
 * @param packages    包名
 * @param typeFilters 匹配规则
 * @param consumer    consumer lambda
 */
public static void scannerPackage(String[] packages, TypeFilter[] typeFilters, Consumer<Class<?>> consumer){
    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);
    for (TypeFilter filter : typeFilters) {
        scanner.addIncludeFilter(filter);
    }
    for (String pack : packages) {
        for (BeanDefinition bd : scanner.findCandidateComponents(pack)) {
            try {
                Class<?> clazz = Class.forName(bd.getBeanClassName());
                consumer.accept(clazz);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
}","/**
 * 按照相对应的规则查找所有匹配类
 *
 * @param packages    包名
 * @param typeFilters 匹配规则
 * @param consumer    consumer lambda
 */
public static void scannerPackage(String[] packages, TypeFilter[] typeFilters, Consumer<Class<?>> consumer) 
{
    if (packages == null || packages.length == 0)
    {
        return;
    }
    for (String basePackage : packages)
    {
        scannerPackage(basePackage, typeFilters, consumer);
    }
}   ",1385,False
"/**
 * 根据列获取相关数据
 *
 * @param eruptModel eruptModel
 * @param columns    列
 * @param query      查询对象
 * @return
 */
@Override
public Collection<Map<String, Object>> queryColumn(EruptModel eruptModel, List<Column> columns, EruptQuery query){
    StringBuilder hql = new StringBuilder();
    List<String> columnStrList = new ArrayList<>();
    for (Column column : columns) {
        columnStrList.add(EruptJpaUtils.completeHqlPath(eruptModel.getEruptName(), column.getName()) + "" as "" + column.getAlias());
    }
    hql.append(""select new map("").append(String.join("", "", columnStrList))
            .append("") from "").append(eruptModel.getEruptName()).append("" as "").append(eruptModel.getEruptName());
    ReflectUtil.findClassAllFields(eruptModel.getClazz(), field -> {
        if (null != field.getAnnotation(ManyToOne.class) || null != field.getAnnotation(OneToOne.class)) {
            hql.append("" left outer join "").append(eruptModel.getEruptName()).append(""."")
                    .append(field.getName()).append("" as "").append(field.getName());
        }
    });
    hql.append("" where 1 = 1 "");
    if (null != query.getConditions()) {
        for (Condition condition : query.getConditions()) {
            hql.append(EruptJpaUtils.AND).append(condition.getKey()).append('=').append(condition.getValue());
        }
    }
    if (null != query.getConditionStrings()) {
        for (String condition : query.getConditionStrings()) {
            hql.append(EruptJpaUtils.AND).append(condition);
        }
    }
    for (Filter filter : eruptModel.getErupt().filter()) {
        String filterStr = AnnotationUtil.switchFilterConditionToStr(filter);
        if (StringUtils.isNotBlank(filterStr)) {
            hql.append(EruptJpaUtils.AND).append(filterStr);
        }
    }
    if (StringUtils.isNotBlank(query.getOrderBy())) {
        hql.append("" order by "").append(query.getOrderBy());
    }
    EntityManager entityManager = entityManagerService.getEntityManager(eruptModel.getClazz());
    List list = entityManager.createQuery(hql.toString()).getResultList();
    if (entityManager.isOpen()) {
        entityManager.close();
    }
    return list;
}","/**
 * 根据列获取相关数据
 *
 * @param eruptModel eruptModel
 * @param columns    列
 * @param query      查询对象
 * @return
 */
@Override
public Collection<Map<String, Object>> queryColumn(EruptModel eruptModel, List<Column> columns, EruptQuery query) 
{
    if (columns == null || columns.size() == 0)
    {
        return null;
    }
    List<String> columnNames = columns.stream().map(Column::getCode).collect(Collectors.toList());
    return queryColumn(eruptModel, columnNames, query);
}   ",1386,False
"//递归查找类字段
public static Field findClassField(Class<?> clazz, String fieldName){
    Field field = null;
    while (clazz != null) {
        try {
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
            return field;
        } catch (NoSuchFieldException e) {
            if (Object.class.equals(clazz = clazz.getSuperclass())) {
                break;
            }
        }
    }
    return field;
}","//递归查找类字段
public static Field findClassField(Class<?> clazz, String fieldName) 
{
    Field field = null;
    try
    {
        field = clazz.getDeclaredField(fieldName);
    }
    catch (NoSuchFieldException e)
    {
        Class<?> superClass = clazz.getSuperclass();
        if (superClass != null)
        {
            field = findClassField(superClass, fieldName);
        }
    }
    return field;
}   ",1389,True
"//优化异常提示类
private void handlerException(Exception e, EruptModel eruptModel){
    if (e instanceof DataIntegrityViolationException) {
        if (e.getMessage().contains(""ConstraintViolationException"")) {
            throw new EruptWebApiRuntimeException(gcRepeatHint(eruptModel));
        } else if (e.getMessage().contains(""DataException"")) {
            throw new EruptWebApiRuntimeException(""内容超出数据库限制长度！"");
        } else {
            throw new EruptWebApiRuntimeException(e.getMessage());
        }
    } else {
        throw new EruptWebApiRuntimeException(e.getMessage());
    }
}","//优化异常提示类
private void handlerException(Exception e, EruptModel eruptModel) 
{
    if (e instanceof EruptFieldException) {
        EruptFieldException ex = (EruptFieldException) e;
        String message = ex.getMessage();
        if (StringUtils.isNotBlank(message)) {
            eruptModel.getErupt().alert(message);
        }
    } else {
        eruptModel.getErupt().alert(e.getMessage());
    }
}   ",1390,True
"/**
 * 根据要素生成树结构
 *
 * @param eruptModel eruptModel
 * @param id         id
 * @param label      label
 * @param pid        parent id
 * @param query      查询对象
 * @return 树对象
 */
public Collection<TreeModel> geneTree(EruptModel eruptModel, String id, String label, String pid, Expr rootId, EruptQuery query){
    List<Column> columns = new ArrayList<>();
    columns.add(new Column(id, AnnotationConst.ID));
    columns.add(new Column(label, AnnotationConst.LABEL));
    if (!AnnotationConst.EMPTY_STR.equals(pid)) {
        columns.add(new Column(pid, AnnotationConst.PID));
    }
    Collection<Map<String, Object>> result = this.createColumnQuery(eruptModel, columns, query);
    String root = AnnotationUtil.getExpr(rootId);
    List<TreeModel> treeModels = new ArrayList<>();
    for (Map<String, Object> map : result) {
        TreeModel treeModel = new TreeModel(map.get(AnnotationConst.ID), map.get(AnnotationConst.LABEL), map.get(AnnotationConst.PID), root);
        treeModels.add(treeModel);
    }
    if (StringUtils.isBlank(pid)) {
        return treeModels;
    } else {
        return DataHandlerUtil.treeModelToTree(treeModels);
    }
}","/**
 * 根据要素生成树结构
 *
 * @param eruptModel eruptModel
 * @param id         id
 * @param label      label
 * @param pid        parent id
 * @param query      查询对象
 * @return 树对象
 */

public Collection<TreeModel> geneTree(EruptModel eruptModel, String id, String label, String pid, Expr rootId, EruptQuery query) 
{
    Collection<TreeModel> treeModels = new ArrayList<>();
    List<EruptModel> eruptModels = eruptModel.getEruptFieldModels();
    for (EruptModel model : eruptModels) {
        if (model.getEruptFieldAnnotation().tree()) {
            TreeModel treeModel = new TreeModel();
            treeModel.setId(model.getColumnName());
            treeModel.setLabel(model.getViewTitle());
            treeModel.setPid(pid);
            treeModel.setQuery(query);
            treeModel.setRootId(rootId);
            treeModels.add(treeModel);
        }
    }
    return treeModels;
}   ",1392,True
"/**
 * 如果使用了@EruptDataSource多数据源，调用此方法必须手动关闭, close()
 *
 * @param eruptClass
 * @return
 */
public EntityManager getEntityManager(Class<?> eruptClass){
    EruptDataSource eruptDataSource = eruptClass.getAnnotation(EruptDataSource.class);
    if (null == eruptDataSource) {
        return entityManager;
    } else {
        return entityManagerMap.get(eruptDataSource.value()).createEntityManager();
    }
}","/**
 * 如果使用了@EruptDataSource多数据源，调用此方法必须手动关闭, close()
 *
 * @param eruptClass
 * @return
 */
public EntityManager getEntityManager(Class<?> eruptClass) 
{
    EntityManager entityManager = entityManagerMap.get(eruptClass);
    if (entityManager == null)
    {
        entityManager = entityManagerFactory.createEntityManager();
        entityManagerMap.put(eruptClass, entityManager);
    }
    return entityManager;
}   ",1394,True
"/**
 * @param projectName 标识名
 * @param first       bool回调，表示函数是否为第一次调用
 */
public void projectStartLoaded(String projectName, Consumer<Boolean> first){
    String userDir = System.getProperty(""user.dir"");
    File dirFile = new File(userDir, EruptConst.ERUPT_DIR);
    String warnTxt = ""项目加载标识文件无法创建，可能造成数据多次加载等问题"";
    if (!dirFile.exists()) {
        if (!dirFile.mkdirs()) {
            log.warn(dirFile.toString() + warnTxt);
        }
    }
    File file = new File(dirFile.getPath(), projectName + LOADED_EXT);
    if (file.exists()) {
        first.accept(false);
    } else {
        try {
            first.accept(true);
            if (!file.createNewFile()) {
                log.warn(dirFile.toString() + warnTxt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}","/**
 * @param projectName 标识名
 * @param first       bool回调，表示函数是否为第一次调用
 */
public void projectStartLoaded(String projectName, Consumer<Boolean> first) 
{
    if (projectStartLoaded.containsKey(projectName))
    {
        first.accept(false);
        return;
    }
    projectStartLoaded.put(projectName, true);
    first.accept(true);
}   ",1397,False
"//获取字段泛型名
public static List<String> getFieldGenericName(Field field){
    List<String> names = new ArrayList<>();
    Type gType = field.getGenericType();
    if (gType instanceof ParameterizedType) {
        Type[] typeArguments = ((ParameterizedType) gType).getActualTypeArguments();
        for (Type typeArgument : typeArguments) {
            String[] gArray = typeArgument.getTypeName().split(""\\."");
            names.add(gArray[gArray.length - 1]);
        }
    }
    return names;
}","//获取字段泛型名



public static List<String> getFieldGenericName(Field field) 
{
    List<String> list = new ArrayList<String>();
    Type type = field.getGenericType();
    if (type instanceof ParameterizedType)
    {
        ParameterizedType parameterizedType = (ParameterizedType) type;
        Type[] types = parameterizedType.getActualTypeArguments();
        for (Type t : types)
        {
            list.add(t.getTypeName());
        }
    }
    return list;
}   ",1398,True
"//生成数据重复的提示字符串
private String gcRepeatHint(EruptModel eruptModel){
    StringBuilder str = new StringBuilder();
    for (UniqueConstraint uniqueConstraint : eruptModel.getClazz().getAnnotation(Table.class).uniqueConstraints()) {
        for (String columnName : uniqueConstraint.columnNames()) {
            EruptFieldModel eruptFieldModel = eruptModel.getEruptFieldMap().get(columnName);
            if (null != eruptFieldModel) {
                str.append(eruptFieldModel.getEruptField().views()[0].title()).append(""、"");
            }
        }
    }
    String repeatTxt = ""数据重复"";
    if (StringUtils.isNotBlank(str)) {
        return str.substring(0, str.length() - 1) + repeatTxt;
    } else {
        return repeatTxt;
    }
}","//生成数据重复的提示字符串
private String gcRepeatHint(EruptModel eruptModel) 
{
    StringBuilder hint = new StringBuilder();
    List<EruptFieldModel> eruptFieldModels = eruptModel.getEruptFieldModels();
    for (EruptFieldModel eruptFieldModel : eruptFieldModels) {
        if (eruptFieldModel.isCollection()) {
            hint.append(eruptFieldModel.getName()).append("" "");
        }
    }
    return hint.toString();
}   ",1399,True
"/**
 * Call this method after you handle a keypress so that the meta state will be reset to
 * unshifted (if it is not still down) or primed to be reset to unshifted (once it is released).
 * Takes the current state, returns the new state.
 */
public static long adjustMetaAfterKeypress(long state){
    state = adjust(state, META_SHIFT_ON, META_SHIFT_MASK);
    state = adjust(state, META_ALT_ON, META_ALT_MASK);
    state = adjust(state, META_SYM_ON, META_SYM_MASK);
    return state;
}","/**
 * Call this method after you handle a keypress so that the meta state will be reset to
 * unshifted (if it is not still down) or primed to be reset to unshifted (once it is released).
 * Takes the current state, returns the new state.
 */
public static long adjustMetaAfterKeypress(long state) 
{
    if ((state & SHIFT_DOWN_MASK) != 0)
    {
        state |= SHIFT_PRIMED_MASK;
    }
    else
    {
        state &= ~SHIFT_PRIMED_MASK;
    }
    return state & ~SHIFT_DOWN_MASK;
}   ",1400,False
"// write out all current attributes
private void writeAttributes() throws IOException{
    this.writer.write(this.attrs.toString());
    this.attrs.setLength(0);
    this.empty = false;
}","// write out all current attributes
private void writeAttributes() throws IOException 
{
    for (Map.Entry<String, String> entry : attributes.entrySet())
    {
        writer.write("" "" + entry.getKey() + ""=\"""" + entry.getValue() + ""\"""");
    }
}   ",1401,True
"/** Output body text. Any xml characters are escaped. */
public XmlWriter writeText(String text) throws IOException{
    closeOpeningTag(false);
    this.empty = false;
    this.justWroteText = true;
    this.writer.write(escapeXml(text));
    return this;
}","/** Output body text. Any xml characters are escaped. */
public XmlWriter writeText(String text) throws IOException 
{
    if (text != null)
    {
        out.write(escapeXml(text));
    }
    return this;
}   ",1403,True
"// close off the opening tag
private void closeOpeningTag(final boolean newLine) throws IOException{
    if (!this.closed) {
        writeAttributes();
        this.closed = true;
        this.writer.write("">"");
        if (newLine) this.writer.write(""\n"");
    }
}","// close off the opening tag
private void closeOpeningTag(final boolean newLine) throws IOException 
{
    if (newLine)
    {
        writer.write(""\n"");
    }
    writer.write("">"");
}   ",1404,True
"/** Returns true if an implementation of Voice IME is installed. */
public static boolean isInstalled(InputMethodService inputMethodService){
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        return false;
    }

    InputMethodInfo inputMethodInfo =
            getVoiceImeInputMethodInfo(getInputMethodManager(inputMethodService));

    if (inputMethodInfo == null) {
        return false;
    }

    return inputMethodInfo.getSubtypeCount() > 0;
}","/** Returns true if an implementation of Voice IME is installed. */
public static boolean isInstalled(InputMethodService inputMethodService) 
{
    if (inputMethodService == null)
    {
        return false;
    }
    return inputMethodService.getInputMethodManager().getEnabledInputMethodList().size() > 0;
}   ",1407,True
"/**
 * Close this writer. It does not close the underlying writer, but does throw an exception if
 * there are as yet unclosed tags.
 *
 * @throws IOException
 */
public void close() throws IOException{
    if (!this.stack.empty()) {
        throw new InvalidObjectException(
                ""Tags are not all closed. ""
                        + ""Possibly, ""
                        + this.stack.pop()
                        + "" is unclosed. "");
    }
    if (thisIsWriterOwner) {
        this.writer.flush();
        this.writer.close();
    }
}","/**
 * Close this writer. It does not close the underlying writer, but does throw an exception if
 * there are as yet unclosed tags.
 *
 * @throws IOException
 */


public void close() throws IOException 
{
    if (this.tags.size() > 0)
    {
        throw new IOException(""Unclosed tags: "" + this.tags);
    }
}   ",1408,True
"// from XmlW
public static String escapeXml(String str){
    str = replaceString(str, ""&"", ""&amp;"");
    str = replaceString(str, ""<"", ""&lt;"");
    str = replaceString(str, "">"", ""&gt;"");
    str = replaceString(str, ""\"""", ""&quot;"");
    str = replaceString(str, ""'"", ""&apos;"");
    return str;
}","// from XmlW
public static String escapeXml(String str) 
{
    if (str == null)
    {
        return null;
    }

    return str.replaceAll(""&"", ""&amp;"").replaceAll(""<"", ""&lt;"").replaceAll("">"", ""&gt;"").replaceAll(""\"""", ""&quot;"").replaceAll(""'"", ""&apos;"");
}   ",1409,True
"/** Solves https://github.com/AnySoftKeyboard/AnySoftKeyboard/issues/719 */
@Test
public void testInvalidateCachedLayoutsWhenInputModeChanges(){
    mAnySoftKeyboardUnderTest.onFinishInputView(true);
    mAnySoftKeyboardUnderTest.onFinishInput();

    EditorInfo editorInfo =
            TestableAnySoftKeyboard.createEditorInfo(
                    EditorInfo.IME_ACTION_NONE,
                    EditorInfo.TYPE_CLASS_TEXT + EditorInfo.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
    mAnySoftKeyboardUnderTest.onStartInput(editorInfo, false);
    mAnySoftKeyboardUnderTest.onStartInputView(editorInfo, false);

    Assert.assertEquals(
            ""c7535083-4fe6-49dc-81aa-c5438a1a343a"",
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardId());
    Assert.assertEquals(
            Keyboard.KEYBOARD_ROW_MODE_EMAIL,
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardMode());

    mAnySoftKeyboardUnderTest.simulateKeyPress(KeyCodes.MODE_SYMOBLS);

    Assert.assertEquals(
            ""symbols_keyboard"",
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardId());
    Assert.assertEquals(
            Keyboard.KEYBOARD_ROW_MODE_EMAIL,
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardMode());

    mAnySoftKeyboardUnderTest.simulateKeyPress(KeyCodes.MODE_ALPHABET);

    Assert.assertEquals(
            ""c7535083-4fe6-49dc-81aa-c5438a1a343a"",
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardId());
    Assert.assertEquals(
            Keyboard.KEYBOARD_ROW_MODE_EMAIL,
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardMode());

    // switching input types
    mAnySoftKeyboardUnderTest.onFinishInputView(true);
    mAnySoftKeyboardUnderTest.onFinishInput();

    editorInfo =
            TestableAnySoftKeyboard.createEditorInfo(
                    EditorInfo.IME_ACTION_NONE,
                    EditorInfo.TYPE_CLASS_TEXT + EditorInfo.TYPE_TEXT_VARIATION_URI);
    mAnySoftKeyboardUnderTest.onStartInput(editorInfo, false);
    mAnySoftKeyboardUnderTest.onStartInputView(editorInfo, false);

    Assert.assertEquals(
            ""c7535083-4fe6-49dc-81aa-c5438a1a343a"",
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardId());
    Assert.assertEquals(
            Keyboard.KEYBOARD_ROW_MODE_URL,
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardMode());

    mAnySoftKeyboardUnderTest.simulateKeyPress(KeyCodes.MODE_SYMOBLS);

    Assert.assertEquals(
            ""symbols_keyboard"",
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardId());
    Assert.assertEquals(
            Keyboard.KEYBOARD_ROW_MODE_URL,
            mAnySoftKeyboardUnderTest.getCurrentKeyboardForTests().getKeyboardMode());
}","/** Solves https://github.com/AnySoftKeyboard/AnySoftKeyboard/issues/719 */
@Test
public void testInvalidateCachedLayoutsWhenInputModeChanges() 
{
    final AnySoftKeyboard keyboardUnderTest = createDefaultKeyboardUnderTest();
    keyboardUnderTest.onInitializeInterface();

    // Simulate input mode change
    keyboardUnderTest.onInputMethodChanged(newInputMethodDescriptor());

    // Verify that cached layouts are invalidated
    verify(keyboardUnderTest.getKeyboardSwitcher()).invalidateCachedLayouts();
}   ",1410,True
"/**
 * Will apply a ColorFilter on-top of the edge-effect drawables. Call this method after
 * inflating a view (e.g., ListView, ScrollView) which you want to brand
 *
 * @param activity The application's Context
 * @param brandColor The color you wish to apply.
 */
public static void brandGlowEffect(@NonNull Activity activity, int brandColor){
    try {
        // glow
        int glowDrawableId =
                activity.getResources().getIdentifier(""overscroll_glow"", ""drawable"", ""android"");
        if (glowDrawableId != 0) {
            Drawable androidGlow =
                    ResourcesCompat.getDrawable(
                            activity.getResources(), glowDrawableId, activity.getTheme());
            assert androidGlow
                    != null; // I know it can be null, since there is an Identifier with the
            // type and name
            androidGlow.setColorFilter(brandColor, PorterDuff.Mode.SRC_IN);
        }
        // edge
        int edgeDrawableId =
                activity.getResources().getIdentifier(""overscroll_edge"", ""drawable"", ""android"");
        if (edgeDrawableId != 0) {
            Drawable androidEdge =
                    ResourcesCompat.getDrawable(
                            activity.getResources(), edgeDrawableId, activity.getTheme());
            assert androidEdge
                    != null; // I know it can be null, since there is an Identifier with the
            // type and name
            androidEdge.setColorFilter(brandColor, PorterDuff.Mode.SRC_IN);
        }
    } catch (Exception e) {
        Logger.w(""EdgeEffectHacker"", ""Failed to set brandGlowEffect!"", e);
    }
}","/**
 * Will apply a ColorFilter on-top of the edge-effect drawables. Call this method after
 * inflating a view (e.g., ListView, ScrollView) which you want to brand
 *
 * @param activity The application's Context
 * @param brandColor The color you wish to apply.
 */
public static void brandGlowEffect(@NonNull Activity activity, int brandColor) 
{
    int glowDrawableId = activity.getResources().getIdentifier(""overscroll_glow"", ""drawable"", ""android"");
    if (glowDrawableId != 0)
    {
        Drawable androidGlow = activity.getResources().getDrawable(glowDrawableId);
        brandGlowEffect(activity, androidGlow, brandColor);
    }
}   ",1412,True
"/**
 * Download the emoji list from https://unicode.org/Public/emoji/11.0/emoji-test.txt
 *
 * @param sourceUnicodeEmojiListFile path to the file saved from
 *     http://unicode.org/emoji/charts/full-emoji-list.html
 * @param targetResourceFolder the app's resources folder
 */
public EmojiKeyboardsExtractor(File sourceUnicodeEmojiListFile, File targetResourceFolder){
    mSourceHtmlFile = sourceUnicodeEmojiListFile;
    mXmlResourceFolder = targetResourceFolder;
}","/**
 * Download the emoji list from https://unicode.org/Public/emoji/11.0/emoji-test.txt
 *
 * @param sourceUnicodeEmojiListFile path to the file saved from
 *     http://unicode.org/emoji/charts/full-emoji-list.html
 * @param targetResourceFolder the app's resources folder
 */
public EmojiKeyboardsExtractor(File sourceUnicodeEmojiListFile, File targetResourceFolder) 
{
    this.sourceUnicodeEmojiListFile = sourceUnicodeEmojiListFile;
    this.targetResourceFolder = targetResourceFolder;
}   ",1413,True
"/** Construct a CandidateView for showing suggested words for completion. */
public CandidateView(Context context, AttributeSet attrs, int defStyle){
    super(context, attrs, defStyle);
    mSelectionHighlight =
            ContextCompat.getDrawable(context, R.drawable.list_selector_background_pressed);

    mAddToDictionaryHint = context.getString(R.string.hint_add_to_dictionary);

    mPaint = new Paint();
    mTextPaint = new TextPaint(mPaint);
    final int minTouchableWidth =
            context.getResources()
                    .getDimensionPixelOffset(R.dimen.candidate_min_touchable_width);
    mGestureDetector =
            new GestureDetector(context, new CandidateStripGestureListener(minTouchableWidth));

    setWillNotDraw(false);
    setHorizontalScrollBarEnabled(false);
    setVerticalScrollBarEnabled(false);
    scrollTo(0, getScrollY());
}","/** Construct a CandidateView for showing suggested words for completion. */


public CandidateView(Context context, AttributeSet attrs, int defStyle) 
{
    super(context, attrs, defStyle);
    mScroller = new Scroller(context);
    mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener()
    {
        @Override
        public boolean onDown(MotionEvent e)
        {
            mScroller.forceFinished(true);
            return true;
        }
    });
    mGestureDetector.setIsLongpressEnabled(false);
}   ",1414,False
"/** Handles release of the meta keys. */
public static long handleKeyUp(long state, int keyCode, KeyEvent event){
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        return release(state, META_SHIFT_ON, META_SHIFT_MASK);
    }

    if (keyCode == KeyEvent.KEYCODE_ALT_LEFT
            || keyCode == KeyEvent.KEYCODE_ALT_RIGHT
            || keyCode == KeyEvent.KEYCODE_NUM) {
        return release(state, META_ALT_ON, META_ALT_MASK);
    }

    if (keyCode == KeyEvent.KEYCODE_SYM) {
        return release(state, META_SYM_ON, META_SYM_MASK);
    }

    return state;
}","/** Handles release of the meta keys. */
public static long handleKeyUp(long state, int keyCode, KeyEvent event) 
{
    switch (keyCode) {
        case KeyEvent.KEYCODE_META_LEFT:
        case KeyEvent.KEYCODE_META_RIGHT:
            state &= ~META_PRESSED;
            break;
    }
    return state;
}   ",1417,True
"/**
 * Automatically creates activity options with all of the transition views within view.
 */
public static ActivityOptionsCompat getActivityOptions(Activity activity, View view, boolean
    includeSystemUi){
  List<Pair<View, String>> transitionViews = new ArrayList<>();

  if (VERSION.SDK_INT >= TARGET_API) {
    ViewUtils.findTransitionViews(view, transitionViews);
    if (includeSystemUi) {
      addSystemUi(activity, transitionViews);
    }
  }

  //noinspection unchecked
  return ActivityOptionsCompat.makeSceneTransitionAnimation(activity, transitionViews.toArray
      (new Pair[transitionViews.size()]));
}","/**
 * Automatically creates activity options with all of the transition views within view.
 */
public static ActivityOptionsCompat getActivityOptions(Activity activity, View view, boolean
    includeSystemUi) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
    {
        Pair[] pairs = new Pair[1];
        pairs[0] = Pair.create(view, ""transition"");
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, pairs);
        return options;
    }
    else
    {
        return null;
    }
}   ",1420,True
"/**
 * Returns the result_code from the ReadableMap payload or RESULT_OK if none found. <p> Throws
 * IllegalArgumentException if the resultCode is not a number.
 */
private static int getResultCodeFromPayload(ReadableMap payload){
  if (payload == null) {
    return Activity.RESULT_OK;
  }
  if (!payload.hasKey(RESULT_CODE)) {
    return Activity.RESULT_OK;
  }
  if (payload.getType(RESULT_CODE) != ReadableType.Number) {
    throw new IllegalArgumentException(""Found non-integer resultCode."");
  }
  return payload.getInt(RESULT_CODE);
}","/**
 * Returns the result_code from the ReadableMap payload or RESULT_OK if none found. <p> Throws
 * IllegalArgumentException if the resultCode is not a number.
 */
private static int getResultCodeFromPayload(ReadableMap payload) 
{
    if (payload.hasKey(""resultCode""))
    {
        Object value = payload.get(""resultCode"");
        if (value instanceof Number)
        {
            return ((Number) value).intValue();
        }
        else
        {
            throw new IllegalArgumentException(""resultCode must be a number."");
        }
    }
    return RESULT_OK;
}   ",1426,True
"/**
 * Use empty string instead of null of subtype is not applicabale.
 */
public static String toString(
    @NonNull String type, long id, @NonNull String subtype, long subId){
  if (type.indexOf(DELIMETER) != -1) {
    throw new IllegalArgumentException(""Invalid type "" + type + "". Delimeter is "" + DELIMETER);
  } else if (subtype.indexOf(DELIMETER) != -1) {
    throw new IllegalArgumentException(
        ""Invalid subtype "" + subtype + "". Delimeter is "" + DELIMETER);
  }

  return type + DELIMETER + id + DELIMETER + subtype + DELIMETER + subId;
}","/**
 * Use empty string instead of null of subtype is not applicabale.
 */
public static String toString(
    @NonNull String type, long id, @NonNull String subtype, long subId) 
{
    return toString(type, id, subtype, subId, """");
}   ",1428,True
"/**
 * Iterates through all shared elements and all mapp shared elements. If there is a mapped shared
 * element that is only a partial match with its shared element then we will cross fade from the
 * shared element to the shared element snapshot which is a bitmap created by Activity A that
 * represents the appearance of the view that the shared element is transitioning back to.
 */
private void crossFadePartialMatchImageViews(List<String> sharedElementNames, List<View>
    sharedElements, List<View> sharedElementSnapshots, int duration){
  // Fixes a crash in which sharedElementNames and sharedElementSnapshots are different lengths.
  // According to the javadocs, these should be 1:1 but for some reason they are not sometimes.
  // I have no idea why or what it means when they are
  // different. However, the crossfading relies on the assumption that they are so we'll just
  // ignore that case.
  // https://bugsnag.com/airbnb/android-1/errors/563d370d8203f6a6502fe8fc?filters[event
  // .file][]=AutoSharedElementCallback.java&filters[event.since][]=7d
  // Also, either of these lists can be null ¯\_(ツ)_/¯
  if (sharedElementNames == null || sharedElementSnapshots == null ||
      sharedElementNames.size() != sharedElementSnapshots.size()) {
    return;
  }

  for (int i = sharedElementNames.size() - 1; i >= 0; i--) {
    View snapshotView = sharedElementSnapshots.get(i);
    if (snapshotView == null || !(snapshotView instanceof ImageView)) {
      continue;
    }

    TransitionName tn1 = TransitionName.parse(sharedElementNames.get(i));
    for (View se : sharedElements) {
      // We need to be able to get the drawable from the ImageView to do the crossfade so if
      // it's not an ImageView then there isn't much we can do.
      if (!(se instanceof ImageView)) {
        continue;
      }

      String transitionName = ViewCompat.getTransitionName(se);
      TransitionName tn2 = TransitionName.parse(transitionName);
      if (tn1.partialEquals(tn2) && tn1.subId() != tn2.subId()) {
        // If The views are the same except for the subId then we can attempt to crossfade them.
        Drawable sharedElementDrawable = ((ImageView) se).getDrawable();
        if (sharedElementDrawable == null) {
          sharedElementDrawable = new ColorDrawable(Color.TRANSPARENT);
        }
        Drawable sharedElementSnapshotDrawable = ((ImageView) snapshotView).getDrawable();
        if (sharedElementSnapshotDrawable == null) {
          sharedElementSnapshotDrawable = new ColorDrawable(Color.TRANSPARENT);
        }
        TransitionDrawable transitionDrawable =
            new TransitionDrawable(new Drawable[]{sharedElementDrawable,
                sharedElementSnapshotDrawable});
        ((ImageView) se).setImageDrawable(transitionDrawable);
        transitionDrawable.startTransition(duration);
      }
    }
  }
}","/**
 * Iterates through all shared elements and all mapp shared elements. If there is a mapped shared
 * element that is only a partial match with its shared element then we will cross fade from the
 * shared element to the shared element snapshot which is a bitmap created by Activity A that
 * represents the appearance of the view that the shared element is transitioning back to.
 */
private void crossFadePartialMatchImageViews(List<String> sharedElementNames, List<View>
    sharedElements, List<View> sharedElementSnapshots, int duration) 
{
    if (sharedElementNames != null && sharedElements != null && sharedElementSnapshots != null)
    {
        for (int i = 0; i < sharedElementNames.size(); i++)
        {
            String sharedElementName = sharedElementNames.get(i);
            View sharedElement = sharedElements.get(i);
            View sharedElementSnapshot = sharedElementSnapshots.get(i);

            if (sharedElementName.startsWith(MAPP_SHARED_ELEMENT_PREFIX))
            {
                String viewName = sharedElementName.substring(MAPP_SHARED_ELEMENT_PREFIX.length());
                View view = mappSharedElements.get(viewName);
                if (view != null)
                {
                    crossFadePartialMatchImageView(view, sharedElement, sharedElementSnapshot, duration);
                }
            }
            else
            {
                crossFadePartialMatchImageView(sharedElement, sharedElementSnapshot, duration);
            }
        }
    }
}   ",1429,False
"/**
 * Walks the given view group and adds all view with a set transition name to the fragment
 * transaction.
 */
public static void addSharedElementsToFragmentTransaction(
        FragmentTransaction ft, ViewGroup viewGroup){
  List<Pair<View, String>> transitionViews = new ArrayList<>();
  ViewUtils.findTransitionViews(viewGroup, transitionViews);

  for (Pair<View, String> tv : transitionViews) {
    ft.addSharedElement(tv.first, tv.second);
  }
}","/**
 * Walks the given view group and adds all view with a set transition name to the fragment
 * transaction.
 */





public static void addSharedElementsToFragmentTransaction(
        FragmentTransaction ft, ViewGroup viewGroup) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
    {
        Map<String, View> sharedElements = new HashMap<>();
        findNamedViews(sharedElements, viewGroup);
        for (Map.Entry<String, View> entry : sharedElements.entrySet())
        {
            ft.addSharedElement(entry.getValue(), entry.getKey());
        }
    }
}       ",1430,True
"/**
 * Trim a CharSequence (consisting of characters) in the same matter as {@link String#trim()}
 */
public static CharSequence trim(CharSequence input){
  int start = 0;
  int end = input.length() - 1;

  while (start <= end && input.charAt(start) <= ' ') {
    start++;
  }

  while (end >= start && input.charAt(end) <= ' ') {
    end--;
  }

  if (start > end) {
    return """";
  }

  return input.subSequence(start, end + 1);
}","/**
 * Trim a CharSequence (consisting of characters) in the same matter as {@link String#trim()}
 */
public static CharSequence trim(CharSequence input) 
{
    int start = 0;
    int end = input.length();

    while (start < end && input.charAt(start) <= ' ')
        start++;

    while (end > start && input.charAt(end - 1) <= ' ')
        end--;

    return input.subSequence(start, end);
}   ",1431,True
"/**
 * Sets an icon for a specific icon source. If the uri indicates an icon
 * to be somewhere remote (http/https) or on the local filesystem, it uses fresco to load it.
 * Otherwise it loads the Drawable from the Resources and directly returns it via a callback
 */
private void setIconSource(ReadableMap source, IconControllerListener controllerListener, DraweeHolder holder){

  String uri = source != null ? source.getString(PROP_ICON_URI) : null;

  if (uri == null) {
    controllerListener.setIconImageInfo(null);
    controllerListener.setDrawable(null);
  } else if (uri.startsWith(""http://"") || uri.startsWith(""https://"") || uri.startsWith(""file://"")) {
    controllerListener.setIconImageInfo(getIconImageInfo(source));
    DraweeController controller = Fresco.newDraweeControllerBuilder()
        .setUri(Uri.parse(uri))
        .setControllerListener(controllerListener)
        .setOldController(holder.getController())
        .build();
    holder.setController(controller);
    holder.getTopLevelDrawable().setVisible(true, true);
  } else {
    controllerListener.setDrawable(getDrawableByName(uri));
  }
}","/**
 * Sets an icon for a specific icon source. If the uri indicates an icon
 * to be somewhere remote (http/https) or on the local filesystem, it uses fresco to load it.
 * Otherwise it loads the Drawable from the Resources and directly returns it via a callback
 */


private void setIconSource(ReadableMap source, IconControllerListener controllerListener, DraweeHolder holder) 
{
    String uri = source.getString(""uri"");
    if (uri.startsWith(""http://"") || uri.startsWith(""https://"") || uri.startsWith(""file://""))
    {
        // load the icon from the web or the filesystem
        ImageRequest request = ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri)).build();
        ImagePipeline.getInstance().fetchDecodedImage(request, holder);
    }
    else
    {
        // load the icon from the resources
        Resources resources = mContext.getResources();
        int id = resources.getIdentifier(uri, ""drawable"", mContext.getPackageName());
        Drawable icon = resources.getDrawable(id);
        controllerListener.onIconLoaded(icon);
    }
}   ",1432,True
"/**
 * Scans all transition views for a partial match with all remaining async transition views.
 */
private void startPostponedTransitionsIfReady(){
  List<Pair<View, String>> transitionViewPairs = new ArrayList<>();
  ViewUtils.findTransitionViews(getDecorView(), transitionViewPairs);

  for (Pair<View, String> p : transitionViewPairs) {
    if (p.first.getParent() == null) {
      // Attempt to fix https://app.bugsnag
      // .com/airbnb/android-1/errors/57ed9a742f7103a1e02c9225?filters%5Berror
      // .status%5D%5B%5D=in%20progress&filters%5Bevent.since%5D%5B%5D=7d&filters%5Bevent
      // .severity%5D%5B%5D=error&filters%5Berror.assigned_to%5D%5B%5D=me
      return;
    }
  }

  for (Iterator<TransitionName> it = asyncTransitionViews.iterator(); it.hasNext(); ) {
    TransitionName tn = it.next();

    for (Pair<View, String> p : transitionViewPairs) {
      // We only look for a partial match which doesn't match on subid because we can crossfade
      // views that match everything
      // except for subid.
      if (tn.partialEquals(TransitionName.parse(ViewCompat.getTransitionName(p.first)))) {
        it.remove();
        break;
      }
    }
  }

  if (asyncTransitionViews.isEmpty()) {
    getDecorView().removeCallbacks(checkForAsyncViewsRunnable);
    getDecorView().removeCallbacks(cancelAsyncViewsRunnable);
    scheduleStartPostponedTransition();
  } else {
    getDecorView().postDelayed(checkForAsyncViewsRunnable, ASYNC_VIEW_POLL_MS);
  }
}","/**
 * Scans all transition views for a partial match with all remaining async transition views.
 */
private void startPostponedTransitionsIfReady() 
{
    if (mPostponedTransitions != null)
    {
        for (int i = mPostponedTransitions.size() - 1; i >= 0; i--)
        {
            final TransitionView transitionView = mPostponedTransitions.get(i);
            if (transitionView.isReady())
            {
                transitionView.startTransition();
                mPostponedTransitions.remove(i);
            }
        }
    }
}   ",1433,False
"/**
 * http://stackoverflow.com/questions/15746709/get-battery-level-only-once-using-android-sdk
 */
  /*@FloatRange(from=0f, to=100f)*/
public static float getBatteryLevel(Context context){
  Intent batteryIntent =
      context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
  if (batteryIntent == null) {
    return 50.0f;
  }
  int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
  int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);

  // Just in case.
  if (level == -1 || scale == -1 || scale == 0f) {
    return 50.0f;
  }

  return ((float) level / (float) scale) * 100.0f;
}","/**
 * http://stackoverflow.com/questions/15746709/get-battery-level-only-once-using-android-sdk
 */
  /*@FloatRange(from=0f, to=100f)*/




public static float getBatteryLevel(Context context) 
{
    Intent batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
    int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
    int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);

    if(level == -1 || scale == -1) {
        return 50.0f;
    }

    return ((float)level / (float)scale) * 100.0f; 
} ",1436,True
"/**
 * Returns a result Intent to be forwarded to the next Activity via onActivityResult(). Only set
 * EXTRA_IS_DISMISS to true if this Activity is not a modal, since they work as a navigation
 * boundary. That means a Navigation.dismiss call will finish all activities up to a modal,
 * including the modal.
 */
private Intent getResultIntent(Intent data){
  return new Intent()
          .putExtras(data.getExtras())
          .putExtra(ReactNativeIntents.EXTRA_IS_DISMISS, component.isDismissible());
}","/**
 * Returns a result Intent to be forwarded to the next Activity via onActivityResult(). Only set
 * EXTRA_IS_DISMISS to true if this Activity is not a modal, since they work as a navigation
 * boundary. That means a Navigation.dismiss call will finish all activities up to a modal,
 * including the modal.
 */
private Intent getResultIntent(Intent data) 
{
    Intent resultIntent = new Intent();
    resultIntent.putExtra(EXTRA_IS_DISMISS, !isModal());
    if (data != null)
    {
        resultIntent.putExtras(data);
    }
    return resultIntent;
}   ",1438,True
"/** Stub the last updated time of a file in Firebase Storage */
public void stubFirebaseStorageUpdatedTime(StorageReference reference, long time){
    StorageMetadata metadata = mock(StorageMetadata.class);
    when(metadata.getUpdatedTimeMillis()).thenReturn(time);

    when(reference.getMetadata()).thenReturn(Tasks.forResult(metadata));
}","/** Stub the last updated time of a file in Firebase Storage */
public void stubFirebaseStorageUpdatedTime(StorageReference reference, long time) 
{
    try {
        Method stubUpdatedTime = StorageReference.class.getDeclaredMethod(""stubUpdatedTime"", long.class);
        stubUpdatedTime.setAccessible(true);
        stubUpdatedTime.invoke(reference, time);
    } catch (Exception e) {
        e.printStackTrace();
    }
}   ",1441,True
"/**
 * Set the best distance for a game type. NOTE: it's expected for the client to figure out if it
 * is the best distance since some will want bigger and some will want smaller numbers.
 */
public void setBestDistance(GameType gameType, double distanceInMeters){
    try {
        JSONObject gameObject = getGameObject(gameType);
        gameObject.put(BEST_DISTANCE_METERS_KEY, distanceInMeters);
        history.put(gameType.toString(), gameObject);
    } catch (JSONException e) {
        SantaLog.e(TAG, ""error setting distance"", e);
    }
}","/**
 * Set the best distance for a game type. NOTE: it's expected for the client to figure out if it
 * is the best distance since some will want bigger and some will want smaller numbers.
 */
public void setBestDistance(GameType gameType, double distanceInMeters) 
{
    if (gameType == null)
    {
        throw new IllegalArgumentException(""gameType cannot be null"");
    }

    if (distanceInMeters < 0)
    {
        throw new IllegalArgumentException(""distanceInMeters cannot be negative"");
    }

    bestDistanceMap.put(gameType, distanceInMeters);
}   ",1444,True
"/** Returns the best distance so far. Null if no value has been given yet. */
public Double getBestDistance(GameType gameType){
    try {
        JSONObject gameObject = getGameObject(gameType);
        return gameObject.getDouble(BEST_DISTANCE_METERS_KEY);
    } catch (JSONException e) {
        return null;
    }
}","/** Returns the best distance so far. Null if no value has been given yet. */
public Double getBestDistance(GameType gameType) 
{
    if (bestDistanceMap.containsKey(gameType))
    {
        return bestDistanceMap.get(gameType);
    }
    return null;
}   ",1445,True
"/** Returns the best star count so far. Null if no value has been given yet. */
public Integer getBestStarCount(GameType gameType){
    try {
        JSONObject gameObject = getGameObject(gameType);
        return gameObject.getInt(BEST_STAR_COUNT_KEY);
    } catch (JSONException e) {
        return null;
    }
}","/** Returns the best star count so far. Null if no value has been given yet. */
public Integer getBestStarCount(GameType gameType) 
{
    if (bestStarCount == null)
    {
        return null;
    }
    return bestStarCount.get(gameType);
}   ",1446,True
"/** Sets an arbitrary jsonObject a game might want. */
public void setArbitraryData(GameType gameType, JSONObject data){
    try {
        JSONObject gameObject = getGameObject(gameType);
        gameObject.put(ARBITRARY_DATA_KEY, data);
        history.put(gameType.toString(), gameObject);
    } catch (JSONException e) {
        SantaLog.e(TAG, ""error setting distance"", e);
    }
}","/** Sets an arbitrary jsonObject a game might want. */
public void setArbitraryData(GameType gameType, JSONObject data) 
{
    if (gameType == null)
    {
        throw new IllegalArgumentException(""gameType cannot be null"");
    }

    if (data == null)
    {
        throw new IllegalArgumentException(""data cannot be null"");
    }

    arbitraryData.put(gameType, data);
}   ",1447,False
"/** Get a mocked storage reference for a file path. */
private StorageReference getMockStorageReference(String path){
    StorageReference reference = mock(StorageReference.class);
    when(mStorage.getReference(path)).thenReturn(reference);

    return reference;
}","/** Get a mocked storage reference for a file path. */

private StorageReference getMockStorageReference(String path) 
{
    StorageReference ref = mock(StorageReference.class);
    when(ref.getPath()).thenReturn(path);
    return ref;
}   ",1449,True
"/** Make getBytes() calls on a file immediate invoke failure listeners. */
private void stubFirebaseStorageError(StorageReference reference, Exception exception){
    final Task<byte[]> task = (Task<byte[]>) mock(Task.class);
    when(task.isComplete()).thenReturn(true);
    when(task.isSuccessful()).thenReturn(false);
    when(task.getException()).thenReturn(exception);

    when(task.addOnFailureListener(any(OnFailureListener.class)))
            .thenAnswer(
                    new Answer<Task<byte[]>>() {
                        @Override
                        public Task<byte[]> answer(InvocationOnMock invocation)
                                throws Throwable {
                            OnFailureListener listener =
                                    (OnFailureListener) invocation.getArguments()[0];
                            listener.onFailure(task.getException());

                            return task;
                        }
                    });

    when(reference.getBytes(anyLong())).thenReturn(task);
}","/** Make getBytes() calls on a file immediate invoke failure listeners. */

private void stubFirebaseStorageError(StorageReference reference, Exception exception) 
{
    doAnswer(new Answer()
    {
        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable
        {
            TaskSnapshot taskSnapshot = mock(TaskSnapshot.class);
            when(taskSnapshot.getBytes()).thenThrow(exception);
            return taskSnapshot;
        }
    }).when(reference).getBytes();
}   ",1450,True
"/** Wait for a task to be complete, avoids Tasks.await() main thread complaints. */
private <T> Task<T> waitForTask(final Task<T> task) throws Exception{
    final long startTime = System.currentTimeMillis();
    Thread thread =
            new Thread(
                    new Runnable() {
                        @Override
                        public void run() {
                            while (!task.isComplete()) {
                                if (System.currentTimeMillis() - startTime > TASK_TIMEOUT_MS) {
                                    throw new RuntimeException(""Timed out waiting for task."");
                                }

                                try {
                                    Thread.sleep(100);
                                } catch (InterruptedException e) {
                                    fail(""Error waiting for task: "" + e.getLocalizedMessage());
                                }
                            }
                        }
                    });

    thread.run();
    thread.join();

    return task;
}","/** Wait for a task to be complete, avoids Tasks.await() main thread complaints. */
private <T> Task<T> waitForTask(final Task<T> task) throws Exception 
{
    while (!task.isDone())
    {
        Thread.sleep(100);
    }
    return task;
}   ",1451,False
"/**
 * Set the best place (1st, 2nd, 3rd) for a game type. NOTE: It's expected for the client to
 * figure out if it is the best place.
 */
public void setBestPlace(GameType gameType, int place){
    try {
        JSONObject gameObject = getGameObject(gameType);
        gameObject.put(BEST_PLACE_KEY, place);
        history.put(gameType.toString(), gameObject);
    } catch (JSONException e) {
        SantaLog.e(TAG, ""error setting place"", e);
    }
}","/**
 * Set the best place (1st, 2nd, 3rd) for a game type. NOTE: It's expected for the client to
 * figure out if it is the best place.
 */
public void setBestPlace(GameType gameType, int place) 
{
    if (place == 1)
    {
        bestPlace1 = gameType;
    }
    else if (place == 2)
    {
        bestPlace2 = gameType;
    }
    else if (place == 3)
    {
        bestPlace3 = gameType;
    }
}   ",1452,True
"/** Returns the best score so far. Null if no value has been given yet. */
public Double getBestScore(GameType gameType){
    try {
        JSONObject gameObject = getGameObject(gameType);
        return gameObject.getDouble(BEST_SCORE_KEY);
    } catch (JSONException e) {
        return null;
    }
}","/** Returns the best score so far. Null if no value has been given yet. */
public Double getBestScore(GameType gameType) 
{
    if (bestScores.containsKey(gameType))
    {
        return bestScores.get(gameType);
    }
    return null;
}   ",1453,True
"/** Returns the best time so far. Null if no value has been given yet. */
public Long getBestTime(GameType gameType){
    try {
        JSONObject gameObject = getGameObject(gameType);
        return gameObject.getLong(BEST_TIME_MILLISECONDS_KEY);
    } catch (JSONException e) {
        return null;
    }
}","/** Returns the best time so far. Null if no value has been given yet. */
public Long getBestTime(GameType gameType) 
{
    if (bestTimes.containsKey(gameType))
    {
        return bestTimes.get(gameType);
    }
    else
    {
        return null;
    }
}   ",1454,True
"/** Gets the json object for a particular game type. */
private JSONObject getGameObject(GameType gameType) throws JSONException{
    if (history == null) {
        throw new JSONException(""null history"");
    }
    JSONObject gameObject = history.optJSONObject(gameType.toString());
    if (gameObject == null) {
        gameObject = new JSONObject();
    }
    return gameObject;
}","/** Gets the json object for a particular game type. */
private JSONObject getGameObject(GameType gameType) throws JSONException 
{
    JSONObject obj = new JSONObject();
    obj.put(""name"", gameType.getName());
    obj.put(""id"", gameType.getId());
    obj.put(""description"", gameType.getDescription());
    obj.put(""minPlayers"", gameType.getMinPlayers());
    obj.put(""maxPlayers"", gameType.getMaxPlayers());
    return obj;
}   ",1458,False
"/** Handles loading text from our resources, including interpreting <b> and <i> tags. */
public static CharSequence getText(Resources res, int id, Object... formatArgs){
    try {
        return Html.fromHtml(res.getString(id, formatArgs));
    } catch (java.util.MissingFormatArgumentException e) {
        SantaLog.e(TAG, ""unable to format string id: "" + id, e);
    }
    return """";
}","/** Handles loading text from our resources, including interpreting <b> and <i> tags. */
public static CharSequence getText(Resources res, int id, Object... formatArgs) 
{
    String text = res.getString(id);
    if (formatArgs.length > 0)
    {
        text = String.format(text, formatArgs);
    }
    return Html.fromHtml(text);
}   ",1459,False
"/**
 * Calls the specified consumer if the {@code applicationName} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */
public void ifApplicationNameChanged(ProjectDescription current, BiConsumer<String, String> consumer){
	if (!Objects.equals(this.original.getApplicationName(), current.getApplicationName())) {
		consumer.accept(this.original.getApplicationName(), current.getApplicationName());
	}
}","/**
 * Calls the specified consumer if the {@code applicationName} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */
public void ifApplicationNameChanged(ProjectDescription current, BiConsumer<String, String> consumer) 
{
	if (!Objects.equals(this.applicationName, current.getApplicationName()))
	{
		consumer.accept(this.applicationName, current.getApplicationName());
	}
}   ",1460,True
"/**
 * Return a {@link Build} repository from a {@link Repository repository metadata}.
 * @param id the repository id
 * @param repository a repository metadata
 * @return an equivalent build repository
 */
public static io.spring.initializr.generator.buildsystem.MavenRepository toRepository(String id,
		Repository repository){
	if (repository == null) {
		return null;
	}
	return io.spring.initializr.generator.buildsystem.MavenRepository
			.withIdAndUrl(id, repository.getUrl().toExternalForm()).name(repository.getName())
			.snapshotsEnabled(repository.isSnapshotsEnabled()).build();
}","/**
 * Return a {@link Build} repository from a {@link Repository repository metadata}.
 * @param id the repository id
 * @param repository a repository metadata
 * @return an equivalent build repository
 */
public static io.spring.initializr.generator.buildsystem.MavenRepository toRepository(String id,
		Repository repository) 
{
	return new io.spring.initializr.generator.buildsystem.MavenRepository(id,
			repository.getName(), repository.getUrl());
}	",1461,True
"/**
 * Calls the specified consumer if the {@code baseDirectory} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */
public void ifBaseDirectoryChanged(ProjectDescription current, BiConsumer<String, String> consumer){
	if (!Objects.equals(this.original.getBaseDirectory(), current.getBaseDirectory())) {
		consumer.accept(this.original.getBaseDirectory(), current.getBaseDirectory());
	}
}","/**
 * Calls the specified consumer if the {@code baseDirectory} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */
public void ifBaseDirectoryChanged(ProjectDescription current, BiConsumer<String, String> consumer) 
{
    if (!Objects.equals(baseDirectory, current.getBaseDirectory()))
    {
        consumer.accept(baseDirectory, current.getBaseDirectory());
    }
}   ",1462,True
"/**
 * Calls the specified consumer if the {@code packageName} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */
public void ifPackageNameChanged(ProjectDescription current, BiConsumer<String, String> consumer){
	if (!Objects.equals(this.original.getPackageName(), current.getPackageName())) {
		consumer.accept(this.original.getPackageName(), current.getPackageName());
	}
}","/**
 * Calls the specified consumer if the {@code packageName} is different on the
 * original source project description than the specified project description.
 * @param current the description to test against
 * @param consumer to call if the property has changed
 */

public void ifPackageNameChanged(ProjectDescription current, BiConsumer<String, String> consumer) 
{
    if (!Objects.equals(packageName, current.getPackageName()))
    {
        consumer.accept(packageName, current.getPackageName());
    }
}   ",1466,True
"/**
 * Expand the link using the specified parameters.
 * @param parameters the parameters value
 * @return an URI where all variables have been expanded
 */
public URI expand(Map<String, String> parameters){
	AtomicReference<String> result = new AtomicReference<>(this.href);
	this.templateVariables.forEach((var) -> {
		Object value = parameters.get(var);
		if (value == null) {
			throw new IllegalArgumentException(
					""Could not expand "" + this.href + "", missing value for '"" + var + ""'"");
		}
		result.set(result.get().replace(""{"" + var + ""}"", value.toString()));
	});
	try {
		return new URI(result.get());
	}
	catch (URISyntaxException ex) {
		throw new IllegalStateException(""Invalid URL"", ex);
	}
}","/**
 * Expand the link using the specified parameters.
 * @param parameters the parameters value
 * @return an URI where all variables have been expanded
 */
public URI expand(Map<String, String> parameters) 
{
    if (parameters == null)
    {
        throw new IllegalArgumentException(""parameters cannot be null"");
    }

    UriBuilder builder = UriBuilder.fromUri(this.uri);
    for (Map.Entry<String, String> entry : parameters.entrySet())
    {
        builder = builder.queryParam(entry.getKey(), entry.getValue());
    }

    return builder.build();
}   ",1468,False
"/**
 * Specify if this dependency is available for the specified Spring Boot version.
 * @param version the version the check
 * @return of the version matches
 */
public boolean match(Version version){
	if (this.range != null) {
		return this.range.match(version);
	}
	return true;
}","/**
 * Specify if this dependency is available for the specified Spring Boot version.
 * @param version the version the check
 * @return of the version matches
 */
public boolean match(Version version) 
{
    if (this.version == null)
    {
        return true;
    }
    return this.version.match(version);
}   ",1471,True
"/**
 * Lookup the item with the specified {@code id} and register it to this container.
 * @param id the id of an item
 */
public void add(I id){
	V item = this.itemResolver.apply(id);
	if (item == null) {
		throw new IllegalArgumentException(""No such value with id '"" + id + ""'"");
	}
	add(id, item);
}","/**
 * Lookup the item with the specified {@code id} and register it to this container.
 * @param id the id of an item
 */
public void add(I id) 
{
    Item item = Item.get(id);
    if (item != null)
    {
        items.add(item);
    }
}   ",1473,True
"/**
 * Return an {@link Build} dependency from a {@link Dependency dependency metadata}.
 * @param dependency a dependency metadata
 * @return an equivalent build dependency
 */
public static io.spring.initializr.generator.buildsystem.Dependency toDependency(Dependency dependency){
	if (dependency == null) {
		return null;
	}
	VersionReference versionReference = (dependency.getVersion() != null)
			? VersionReference.ofValue(dependency.getVersion()) : null;
	return io.spring.initializr.generator.buildsystem.Dependency
			.withCoordinates(dependency.getGroupId(), dependency.getArtifactId()).version(versionReference)
			.scope(toDependencyScope(dependency.getScope())).classifier(dependency.getClassifier())
			.type(dependency.getType()).build();
}","/**
 * Return an {@link Build} dependency from a {@link Dependency dependency metadata}.
 * @param dependency a dependency metadata
 * @return an equivalent build dependency
 */
public static io.spring.initializr.generator.buildsystem.Dependency toDependency(Dependency dependency) 
{
    return new io.spring.initializr.generator.buildsystem.Dependency(
            dependency.getGroupId(),
            dependency.getArtifactId(),
            dependency.getVersion(),
            dependency.getType(),
            dependency.getClassifier(),
            dependency.getScope(),
            dependency.isOptional()
    );
}   ",1474,True
"/**
 * Return a {@link Build} bom from a {@link BillOfMaterials bom metadata}.
 * @param bom a metadata bom
 * @return an equivalent build bom
 */
public static io.spring.initializr.generator.buildsystem.BillOfMaterials toBom(BillOfMaterials bom){
	if (bom == null) {
		return null;
	}
	VersionReference version = (bom.getVersionProperty() != null)
			? VersionReference.ofProperty(bom.getVersionProperty()) : VersionReference.ofValue(bom.getVersion());
	return io.spring.initializr.generator.buildsystem.BillOfMaterials
			.withCoordinates(bom.getGroupId(), bom.getArtifactId()).version(version).order(bom.getOrder()).build();
}","/**
 * Return a {@link Build} bom from a {@link BillOfMaterials bom metadata}.
 * @param bom a metadata bom
 * @return an equivalent build bom
 */
public static io.spring.initializr.generator.buildsystem.BillOfMaterials toBom(BillOfMaterials bom) 
{
    return new io.spring.initializr.generator.buildsystem.BillOfMaterials(
        bom.getGroupId(),
        bom.getArtifactId(),
        bom.getVersion(),
        bom.getScope(),
        bom.getType()
    );
}   ",1477,True
"/**
 * Validate the dependency and complete its state based on the available information.
 */
public void resolve(){
	if (getId() == null) {
		if (!hasCoordinates()) {
			throw new InvalidInitializrMetadataException(
					""Invalid dependency, should have at least an id or a groupId/artifactId pair."");
		}
		generateId();
	}
	else if (!hasCoordinates()) {
		// Let""s build the coordinates from the id
		StringTokenizer st = new StringTokenizer(getId(), "":"");
		if (st.countTokens() == 1) { // assume spring-boot-starter
			asSpringBootStarter(getId());
		}
		else if (st.countTokens() == 2 || st.countTokens() == 3) {
			this.groupId = st.nextToken();
			this.artifactId = st.nextToken();
			if (st.hasMoreTokens()) {
				this.version = st.nextToken();
			}
		}
		else {
			throw new InvalidInitializrMetadataException(
					""Invalid dependency, id should have the form groupId:artifactId[:version] but got "" + getId());
		}
	}
	this.links.forEach(Link::resolve);
	updateCompatibilityRange(VersionParser.DEFAULT);
}","/**
 * Validate the dependency and complete its state based on the available information.
 */
public void resolve() 
{
    if (this.resolved)
    {
        return;
    }

    if (this.dependency != null)
    {
        this.dependency.resolve();
    }

    this.resolved = true;
}   ",1478,False
"/** set divider height(ListView divider高度) */
public NormalListDialog dividerHeight(float dividerHeight_DP){
    mDividerHeight = dividerHeight_DP;
    return this;
}","/** set divider height(ListView divider高度) */
public NormalListDialog dividerHeight(float dividerHeight_DP) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)
    {
        this.dividerHeight = dividerHeight_DP;
    }
    return this;
}   ",1480,False
"/** set title textcolor(设置标题字体颜色) */
public NormalListDialog titleTextColor(int titleTextColor){
    mTitleTextColor = titleTextColor;
    return this;
}","/** set title textcolor(设置标题字体颜色) */
public NormalListDialog titleTextColor(int titleTextColor) 
{
    this.titleTextColor = titleTextColor;
    return this;
}   ",1481,True
"/** set divider color(ListView divider颜色) */
public NormalListDialog dividerColor(int dividerColor){
    mDividerColor = dividerColor;
    return this;
}","/** set divider color(ListView divider颜色) */
public NormalListDialog dividerColor(int dividerColor) 
{
    this.dividerColor = dividerColor;
    return this;
}   ",1485,True
"/**
 * set ListView item selector with corner drawable for the last position
 * (ListView的item点击效果,只处理最后一项圆角处理)
 */
public static StateListDrawable listItemSelector(float radius, int normalColor, int pressColor, boolean isLastPostion){
    StateListDrawable bg = new StateListDrawable();
    Drawable normal = null;
    Drawable pressed = null;

    if (!isLastPostion) {
        normal = new ColorDrawable(normalColor);
        pressed = new ColorDrawable(pressColor);
    } else {
        normal = cornerDrawable(normalColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
        pressed = cornerDrawable(pressColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
    }

    bg.addState(new int[]{-android.R.attr.state_pressed}, normal);
    bg.addState(new int[]{android.R.attr.state_pressed}, pressed);
    return bg;
}","/**
 * set ListView item selector with corner drawable for the last position
 * (ListView的item点击效果,只处理最后一项圆角处理)
 */
public static StateListDrawable listItemSelector(float radius, int normalColor, int pressColor, boolean isLastPostion) 
{
    StateListDrawable drawable = new StateListDrawable();
    if (isLastPostion)
    {
        drawable.addState(new int[] { android.R.attr.state_pressed }, new CornerDrawable(pressColor, radius));
        drawable.addState(new int[] { android.R.attr.state_focused }, new CornerDrawable(pressColor, radius));
        drawable.addState(new int[] { android.R.attr.state_selected }, new CornerDrawable(pressColor, radius));
    }
    drawable.addState(new int[] { }, new CornerDrawable(normalColor, radius));
    return drawable;
}   ",1486,True
"/** set item textsize(item字体大小) */
public NormalListDialog itemTextSize(float itemTextSize_SP){
    mItemTextSize = itemTextSize_SP;
    return this;
}","/** set item textsize(item字体大小) */
public NormalListDialog itemTextSize(float itemTextSize_SP) 
{
    this.itemTextSize_SP = itemTextSize_SP;
    return this;
}   ",1491,True
"/** set title underline height(设置标题下划线高度) */
public NormalDialog titleLineHeight(float titleLineHeight_DP){
    this.mTitleLineHeight = titleLineHeight_DP;
    return this;
}","/** set title underline height(设置标题下划线高度) */
public NormalDialog titleLineHeight(float titleLineHeight_DP) 
{
    if (titleLineHeight_DP > 0)
    {
        this.titleLineHeight = UiUtil.dp2px(mContext, titleLineHeight_DP);
    }
    return this;
}   ",1493,True
"/**
 * set ListView item selector with corner drawable for the first and the last position
 * (ListView的item点击效果,第一项和最后一项圆角处理)
 */
public static StateListDrawable listItemSelector(float radius, int normalColor, int pressColor, int itemTotalSize,
                                                 int itemPosition){
    StateListDrawable bg = new StateListDrawable();
    Drawable normal = null;
    Drawable pressed = null;

    if (itemPosition == 0 && itemPosition == itemTotalSize - 1) {// 只有一项
        normal = cornerDrawable(normalColor, new float[]{radius, radius, radius, radius, radius, radius, radius,
                radius});
        pressed = cornerDrawable(pressColor, new float[]{radius, radius, radius, radius, radius, radius, radius,
                radius});
    } else if (itemPosition == 0) {
        normal = cornerDrawable(normalColor, new float[]{radius, radius, radius, radius, 0, 0, 0, 0,});
        pressed = cornerDrawable(pressColor, new float[]{radius, radius, radius, radius, 0, 0, 0, 0});
    } else if (itemPosition == itemTotalSize - 1) {
        normal = cornerDrawable(normalColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
        pressed = cornerDrawable(pressColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
    } else {
        normal = new ColorDrawable(normalColor);
        pressed = new ColorDrawable(pressColor);
    }

    bg.addState(new int[]{-android.R.attr.state_pressed}, normal);
    bg.addState(new int[]{android.R.attr.state_pressed}, pressed);
    return bg;
}","/**
 * set ListView item selector with corner drawable for the first and the last position
 * (ListView的item点击效果,第一项和最后一项圆角处理)
 */
public static StateListDrawable listItemSelector(float radius, int normalColor, int pressColor, int itemTotalSize,
                                                 int itemPosition) 
{
    StateListDrawable bg = new StateListDrawable();
    Drawable normal = getDrawable(radius, normalColor, itemTotalSize, itemPosition);
    Drawable pressed = getDrawable(radius, pressColor, itemTotalSize, itemPosition);
    bg.addState(new int[] { android.R.attr.state_pressed, android.R.attr.state_enabled }, pressed);
    bg.addState(new int[] { android.R.attr.state_enabled }, normal);
    bg.addState(new int[] {}, normal);
    return bg;
}   ",1494,True
"/** show dialog and mAnimateView with inner show com.flyco.animation(设置dialog和animateView显示动画) */
protected void showWithAnim(){
    if (mInnerShowAnim != null) {
        mInnerShowAnim.setDuration(mInnerAnimDuration);
        mInnerShowAnim.setAnimationListener(new AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
                mIsInnerShowAnim = true;
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mIsInnerShowAnim = false;
            }
        });
        mLlControlHeight.startAnimation(mInnerShowAnim);
    }

    if (mAnimateView != null) {
        if (getWindowInAs() != null) {
            mWindowInAs = getWindowInAs();
        }
        mWindowInAs.duration(mInnerAnimDuration).playOn(mAnimateView);
    }
}","/** show dialog and mAnimateView with inner show com.flyco.animation(设置dialog和animateView显示动画) */
protected void showWithAnim() 
{
    if (mAnimateView != null)
    {
        mAnimateView.clearAnimation();
        mAnimateView.startAnimation(mInAnim);
    }
    if (mDialog != null)
    {
        mDialog.show();
    }
}   ",1495,True
"/**
 * set btn selector with corner drawable for special position
 */
public static StateListDrawable btnSelector(float radius, int normalColor, int pressColor, int postion){
    StateListDrawable bg = new StateListDrawable();
    Drawable normal = null;
    Drawable pressed = null;

    if (postion == 0) {// left btn
        normal = cornerDrawable(normalColor, new float[]{0, 0, 0, 0, 0, 0, radius, radius});
        pressed = cornerDrawable(pressColor, new float[]{0, 0, 0, 0, 0, 0, radius, radius});
    } else if (postion == 1) {// right btn
        normal = cornerDrawable(normalColor, new float[]{0, 0, 0, 0, radius, radius, 0, 0});
        pressed = cornerDrawable(pressColor, new float[]{0, 0, 0, 0, radius, radius, 0, 0});
    } else if (postion == -1) {// only one btn
        normal = cornerDrawable(normalColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
        pressed = cornerDrawable(pressColor, new float[]{0, 0, 0, 0, radius, radius, radius, radius});
    } else if (postion == -2) {// for material dialog
        normal = cornerDrawable(normalColor, radius);
        pressed = cornerDrawable(pressColor, radius);
    }

    bg.addState(new int[]{-android.R.attr.state_pressed}, normal);
    bg.addState(new int[]{android.R.attr.state_pressed}, pressed);
    return bg;
}","/**
 * set btn selector with corner drawable for special position
 */

public static StateListDrawable btnSelector(float radius, int normalColor, int pressColor, int postion) 
{
    StateListDrawable bg = new StateListDrawable();
    Drawable normal = shapeGenerator(radius, normalColor);
    Drawable pressed = shapeGenerator(radius, pressColor);
    bg.addState(new int[] { android.R.attr.state_pressed, android.R.attr.state_enabled }, pressed);
    bg.addState(new int[] { android.R.attr.state_focused, android.R.attr.state_enabled }, pressed);
    bg.addState(new int[] { android.R.attr.state_enabled }, normal);
    bg.addState(new int[] {}, normal);
    return bg;
}   ",1496,True
"/** set title text(设置标题内容) */
public NormalListDialog title(String title){
    mTitle = title;
    return this;
}","/** set title text(设置标题内容) */
public NormalListDialog title(String title) 
{
    this.title = title;
    return this;
}   ",1497,True
"/** set ListView background color(设置ListView背景) */
public NormalListDialog lvBgColor(int lvBgColor){
    mLvBgColor = lvBgColor;
    return this;
}","/** set ListView background color(设置ListView背景) */
public NormalListDialog lvBgColor(int lvBgColor) 
{
    this.lvBgColor = lvBgColor;
    return this;
}   ",1498,True
"/** set title underline color(设置标题下划线颜色) */
public NormalDialog titleLineColor(int titleLineColor){
    this.mTitleLineColor = titleLineColor;
    return this;
}","/** set title underline color(设置标题下划线颜色) */
public NormalDialog titleLineColor(int titleLineColor) 
{
    this.titleLineColor = titleLineColor;
    return this;
}   ",1499,True
"/**
 * Answers the receiver after sending aBinaryMessage to my channel with
 * aRoutingKey. This is a producer ignorance way to use an exchange
 * without requiring it to pass the exchange name. By answering
 * myself I allow for sending message bursts.
 * @param aRoutingKey the String routing key
 * @param aBinaryMessage the byte[] binary message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String aRoutingKey,
        byte[] aBinaryMessage,
        MessageParameters aMessageParameters){

    this.check(aMessageParameters);

    try {
        this.brokerChannel().channel().basicPublish(
                this.brokerChannel().exchangeName(),
                aRoutingKey,
                this.binaryDurability(),
                aBinaryMessage);

    } catch (IOException e) {
        throw new MessageException(""Failed to send message to channel."", e);
    }
    return this;
}","/**
 * Answers the receiver after sending aBinaryMessage to my channel with
 * aRoutingKey. This is a producer ignorance way to use an exchange
 * without requiring it to pass the exchange name. By answering
 * myself I allow for sending message bursts.
 * @param aRoutingKey the String routing key
 * @param aBinaryMessage the byte[] binary message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String aRoutingKey,
        byte[] aBinaryMessage,
        MessageParameters aMessageParameters) 
{
    return send(myChannel, aRoutingKey, aBinaryMessage, aMessageParameters);
}       ",1500,True
"/**
 * Constructs my default state.
 * @param aBrokerChannel the BrokerChannel to which I send messages
 */
protected MessageProducer(BrokerChannel aBrokerChannel){
    super();
    this.setBrokerChannel(aBrokerChannel);
}","/**
 * Constructs my default state.
 * @param aBrokerChannel the BrokerChannel to which I send messages
 */
protected MessageProducer(BrokerChannel aBrokerChannel) 
{
    super(aBrokerChannel);
}   ",1503,True
"/**
 * Constructs my default state.
 * @param aHostName the String name of the host server
 * @param aPort the int port number on the host server, or -1
 * @param aVirtualHost the String name of the virtual host
 * @param aUsername the String name of the user, or null
 * @param aPassword the String password of the user, or null
 */
protected ConnectionSettings(
        String aHostName,
        int aPort,
        String aVirtualHost,
        String aUsername,
        String aPassword){

    super();

    this.setHostName(aHostName);
    this.setPassword(aPassword);
    this.setPort(aPort);
    this.setUsername(aUsername);
    this.setVirtualHost(aVirtualHost);
}","/**
 * Constructs my default state.
 * @param aHostName the String name of the host server
 * @param aPort the int port number on the host server, or -1
 * @param aVirtualHost the String name of the virtual host
 * @param aUsername the String name of the user, or null
 * @param aPassword the String password of the user, or null
 */
protected ConnectionSettings(
        String aHostName,
        int aPort,
        String aVirtualHost,
        String aUsername,
        String aPassword) 
{
    hostName = aHostName;
    port = aPort;
    virtualHost = aVirtualHost;
    username = aUsername;
    password = aPassword;
}       ",1505,True
"/**
 * Ensure an equalization of message distribution
 * across all consumers of this queue.
 */
public void equalizeMessageDistribution(){
    try {
        this.queue().channel().basicQos(1);
    } catch (IOException e) {
        throw new MessageException(""Cannot equalize distribution."", e);
    }
}","/**
 * Ensure an equalization of message distribution
 * across all consumers of this queue.
 */



public void equalizeMessageDistribution() 
{
    // Get the current message count for all consumers
    List<Integer> messageCounts = new ArrayList<>();
    for (Consumer consumer : consumers)
    {
        messageCounts.add(consumer.getMessageCount());
    }

    // Calculate the average message count
    int totalMessages = messageCounts.stream().mapToInt(Integer::intValue).sum();
    int averageMessages = totalMessages / consumers.size();

    // Adjust the message count for each consumer
    for (Consumer consumer : consumers)
    {
        int currentCount = consumer.getMessageCount();
        int adjustment = averageMessages - currentCount;
        consumer.adjustMessageCount(adjustment);
    }
}   ",1508,True
"/**
 * Answers the receiver after sending aTextMessage to my channel
 * with anExchange and aRoutingKey. By answering myself I allow
 * for sending message bursts.
 * @param anExchange the String name of the exchange
 * @param aRoutingKey the String routing key
 * @param aTextMessage the String text message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String anExchange,
        String aRoutingKey,
        String aTextMessage,
        MessageParameters aMessageParameters){

    this.check(aMessageParameters);

    try {
        this.brokerChannel().channel().basicPublish(
                anExchange,
                aRoutingKey,
                aMessageParameters.properties(),
                aTextMessage.getBytes());

    } catch (IOException e) {
        throw new MessageException(""Failed to send message to channel."", e);
    }
    return this;
}","/**
 * Answers the receiver after sending aTextMessage to my channel
 * with anExchange and aRoutingKey. By answering myself I allow
 * for sending message bursts.
 * @param anExchange the String name of the exchange
 * @param aRoutingKey the String routing key
 * @param aTextMessage the String text message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String anExchange,
        String aRoutingKey,
        String aTextMessage,
        MessageParameters aMessageParameters) 
{
    return send(anExchange, aRoutingKey, aTextMessage, aMessageParameters, this);
}       ",1510,True
"/**
 * Constructs my default state.
 * @param aQueue the Queue from which I receive messages
 * @param isAutoAcknowledged the boolean indicating whether or not auto-acknowledgment is used
 */
protected MessageConsumer(
        Queue aQueue,
        boolean isAutoAcknowledged){

    super();

    this.setMessageTypes(new HashSet<String>(Arrays.asList(new String[0])));

    this.setQueue(aQueue);

    this.setAutoAcknowledged(isAutoAcknowledged);
}","/**
 * Constructs my default state.
 * @param aQueue the Queue from which I receive messages
 * @param isAutoAcknowledged the boolean indicating whether or not auto-acknowledgment is used
 */
protected MessageConsumer(
        Queue aQueue,
        boolean isAutoAcknowledged) 
{
    queue = aQueue;
    autoAcknowledged = isAutoAcknowledged;
}       ",1511,True
"/**
 * Answers the receiver after sending aBinaryMessage to my channel
 * with anExchange and aRoutingKey. By answering myself I allow
 * for sending message bursts.
 * @param anExchange the String name of the exchange
 * @param aRoutingKey the String routing key
 * @param aBinaryMessage the byte[] binary message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String anExchange,
        String aRoutingKey,
        byte[] aBinaryMessage,
        MessageParameters aMessageParameters){

    this.check(aMessageParameters);

    try {
        this.brokerChannel().channel().basicPublish(
                anExchange,
                aRoutingKey,
                this.binaryDurability(),
                aBinaryMessage);

    } catch (IOException e) {
        throw new MessageException(""Failed to send message to channel."", e);
    }
    return this;
}","/**
 * Answers the receiver after sending aBinaryMessage to my channel
 * with anExchange and aRoutingKey. By answering myself I allow
 * for sending message bursts.
 * @param anExchange the String name of the exchange
 * @param aRoutingKey the String routing key
 * @param aBinaryMessage the byte[] binary message to send
 * @param aMessageParameters the MessageParameters
 * @return MessageProducer
 */
public MessageProducer send(
        String anExchange,
        String aRoutingKey,
        byte[] aBinaryMessage,
        MessageParameters aMessageParameters) 
{
    return send(anExchange, aRoutingKey, aBinaryMessage, aMessageParameters, this);
}       ",1515,True
"/**
 * Receives only messages of types included in aMessageTypes
 * on a separate thread and dispatches them to aMessageListener
 * until I am closed or until the broker is shut down. The type
 * must be included in the message's basic properties. If the
 * message's type is null, the message is filtered out.
 * @param aMessageTypes the String[] indicating filtered message types
 * @param aMessageListener the MessageListener that handles messages
 */
public void receiveOnly(
        final String[] aMessageTypes,
        final MessageListener aMessageListener){
    String[] filterOutAllBut = aMessageTypes;

    if (filterOutAllBut == null) {
        filterOutAllBut = new String[0];
    }
    this.setMessageTypes(new HashSet<String>(Arrays.asList(filterOutAllBut)));

    this.receiveFor(aMessageListener);
}","/**
 * Receives only messages of types included in aMessageTypes
 * on a separate thread and dispatches them to aMessageListener
 * until I am closed or until the broker is shut down. The type
 * must be included in the message's basic properties. If the
 * message's type is null, the message is filtered out.
 * @param aMessageTypes the String[] indicating filtered message types
 * @param aMessageListener the MessageListener that handles messages
 */
public void receiveOnly(
        final String[] aMessageTypes,
        final MessageListener aMessageListener) 
{
    final Thread t = new Thread()
    {
        @Override
        public void run()
        {
            while (!isClosed())
            {
                try
                {
                    Message message = receive();
                    if (message != null)
                    {
                        String type = message.getJMSType();
                        if (type != null)
                        {
                            for (String messageType : aMessageTypes)
                            {
                                if (messageType.equals(type))
                                {
                                    aMessageListener.onMessage(message);
                                    break;
                                }
                            }
                        }
                    }
                }
                catch (JMSException e)
                {
                    // Handle the exception appropriately
                    e.printStackTrace();
                }
            }
        }
    };
    t.start();
}       ",1517,False
"/**
 * @param solverFactory never null, the {@link SolverFactory} of which you want to test the constraints.
 * @param expectedScoreClass never null, used to fail fast if a {@link SolverFactory} with another {@link Score} type is
 *        used.
 */
public AbstractScoreVerifier(SolverFactory<Solution_> solverFactory, Class<? extends Score<?>> expectedScoreClass){
    if (solverFactory == null) {
        throw new IllegalStateException(""The solverFactory ("" + solverFactory + "") cannot be null."");
    }
    scoreDirectorFactory = ((DefaultSolverFactory<Solution_>) solverFactory).getScoreDirectorFactory();
    SolutionDescriptor<Solution_> solutionDescriptor = scoreDirectorFactory.getSolutionDescriptor();
    Class<? extends Score<?>> scoreClass = solutionDescriptor.getScoreDefinition().getScoreClass();
    if (expectedScoreClass != scoreClass) {
        throw new IllegalStateException(""The solution's scoreClass ("" + scoreClass
                + "") differs from the test's expectedScoreClass ("" + expectedScoreClass + "")."");
    }
}","/**
 * @param solverFactory never null, the {@link SolverFactory} of which you want to test the constraints.
 * @param expectedScoreClass never null, used to fail fast if a {@link SolverFactory} with another {@link Score} type is
 *        used.
 */
public AbstractScoreVerifier(SolverFactory<Solution_> solverFactory, Class<? extends Score<?>> expectedScoreClass) 
{
    this.solverFactory = solverFactory;
    this.expectedScoreClass = expectedScoreClass;
}   ",1520,True
"// ************************************************************************
// Write methods
// ************************************************************************
@Override
public void writeGraphFiles(BenchmarkReport benchmarkReport){
    List<Map<String, XYIntervalSeries>> moveTypeToSeriesMapList = new ArrayList<>(BenchmarkReport.CHARTED_SCORE_LEVEL_SIZE);
    for (PickedMoveTypeBestScoreDiffStatisticPoint point : getPointList()) {
        long timeMillisSpent = point.getTimeMillisSpent();
        String moveType = point.getMoveType();
        double[] levelValues = ScoreUtils.extractLevelDoubles(point.getBestScoreDiff());
        for (int i = 0; i < levelValues.length && i < BenchmarkReport.CHARTED_SCORE_LEVEL_SIZE; i++) {
            if (i >= moveTypeToSeriesMapList.size()) {
                moveTypeToSeriesMapList.add(new LinkedHashMap<>());
            }
            Map<String, XYIntervalSeries> moveTypeToSeriesMap = moveTypeToSeriesMapList.get(i);
            XYIntervalSeries series = moveTypeToSeriesMap.computeIfAbsent(moveType,
                    k -> new XYIntervalSeries(moveType));
            double yValue = levelValues[i];
            // In an XYInterval the yLow must be lower than yHigh
            series.add(timeMillisSpent, timeMillisSpent, timeMillisSpent,
                    yValue, (yValue > 0.0) ? 0.0 : yValue, (yValue > 0.0) ? yValue : 0.0);
        }
    }
    graphFileList = new ArrayList<>(moveTypeToSeriesMapList.size());
    for (int scoreLevelIndex = 0; scoreLevelIndex < moveTypeToSeriesMapList.size(); scoreLevelIndex++) {
        XYPlot plot = createPlot(benchmarkReport, scoreLevelIndex);
        XYItemRenderer renderer = new YIntervalRenderer();
        plot.setRenderer(renderer);
        XYIntervalSeriesCollection seriesCollection = new XYIntervalSeriesCollection();
        for (XYIntervalSeries series : moveTypeToSeriesMapList.get(scoreLevelIndex).values()) {
            seriesCollection.addSeries(series);
        }
        plot.setDataset(seriesCollection);
        String scoreLevelLabel = subSingleBenchmarkResult.getSingleBenchmarkResult().getProblemBenchmarkResult()
                .findScoreLevelLabel(scoreLevelIndex);
        JFreeChart chart = new JFreeChart(subSingleBenchmarkResult.getName()
                + "" picked move type best "" + scoreLevelLabel + "" diff statistic"",
                JFreeChart.DEFAULT_TITLE_FONT, plot, true);
        graphFileList.add(writeChartToImageFile(chart,
                ""PickedMoveTypeBestScoreDiffStatisticLevel"" + scoreLevelIndex));
    }
}","// ************************************************************************
// Write methods
// ************************************************************************

@Override
public void writeGraphFiles(BenchmarkReport benchmarkReport) 
{
    try
    {
        // Write the graph file
        this.writeGraphFile(benchmarkReport);

        // Write the summary file
        this.writeSummaryFile(benchmarkReport);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1521,True
"/**
 * @return a positive number, the distance multiplied by 1000 to avoid floating point arithmetic rounding errors
 */
public long getDistanceFromPreviousStandstill(){
    if (previousStandstill == null) {
        throw new IllegalStateException(""This method must not be called when the previousStandstill (""
                + previousStandstill + "") is not initialized yet."");
    }
    return getDistanceFrom(previousStandstill);
}","/**
 * @return a positive number, the distance multiplied by 1000 to avoid floating point arithmetic rounding errors
 */
public long getDistanceFromPreviousStandstill() 
{
    long distance = 0;
    if (previousStandstill != null)
    {
        distance = previousStandstill.getDistanceFromPreviousStandstill();
        distance += previousStandstill.getDistanceToNextStandstill();
    }
    return distance * 1000;
}   ",1522,True
"// ************************************************************************
// With methods
// ************************************************************************
public Room withId(long id){
    this.setId(id);
    return this;
}","// ************************************************************************
// With methods
// ************************************************************************
public Room withId(long id) 
{
    this.id = id;
    return this;
}   ",1524,True
"/**
 * @param scoreDirector never null
 * @param allocation never null
 * @return true if the startDate changed
 */
protected boolean updatePredecessorsDoneDate(ScoreDirector<Schedule> scoreDirector, Allocation allocation){
    // For the source the doneDate must be 0.
    Integer doneDate = 0;
    for (Allocation predecessorAllocation : allocation.getPredecessorAllocationList()) {
        int endDate = predecessorAllocation.getEndDate();
        doneDate = Math.max(doneDate, endDate);
    }
    if (Objects.equals(doneDate, allocation.getPredecessorsDoneDate())) {
        return false;
    }
    scoreDirector.beforeVariableChanged(allocation, ""predecessorsDoneDate"");
    allocation.setPredecessorsDoneDate(doneDate);
    scoreDirector.afterVariableChanged(allocation, ""predecessorsDoneDate"");
    return true;
}","/**
 * @param scoreDirector never null
 * @param allocation never null
 * @return true if the startDate changed
 */
protected boolean updatePredecessorsDoneDate(ScoreDirector<Schedule> scoreDirector, Allocation allocation) 
{
    boolean startDateChanged = false;
    for (Allocation predecessor : allocation.getPredecessors())
    {
        if (predecessor.getEndDate().isBefore(allocation.getStartDate()))
        {
            scoreDirector.beforeVariableChanged(predecessor, ""endDate"");
            predecessor.setEndDate(allocation.getStartDate());
            scoreDirector.afterVariableChanged(predecessor, ""endDate"");
            startDateChanged = true;
        }
    }
    return startDateChanged;
}   ",1526,True
"// in gigabyte per hour
public static void main(String[] args){
       CloudBalancingGenerator generator = new CloudBalancingGenerator();
       generator.writeCloudBalance(2, 6);
       generator.writeCloudBalance(3, 9);
       generator.writeCloudBalance(4, 12);
       //        generator.writeCloudBalance(5, 15);
       //        generator.writeCloudBalance(6, 18);
       //        generator.writeCloudBalance(7, 21);
       //        generator.writeCloudBalance(8, 24);
       //        generator.writeCloudBalance(9, 27);
       //        generator.writeCloudBalance(10, 30);
       //        generator.writeCloudBalance(11, 33);
       //        generator.writeCloudBalance(12, 36);
       //        generator.writeCloudBalance(13, 39);
       //        generator.writeCloudBalance(14, 42);
       //        generator.writeCloudBalance(15, 45);
       //        generator.writeCloudBalance(16, 48);
       //        generator.writeCloudBalance(17, 51);
       //        generator.writeCloudBalance(18, 54);
       //        generator.writeCloudBalance(19, 57);
       //        generator.writeCloudBalance(20, 60);
       generator.writeCloudBalance(100, 300);
       generator.writeCloudBalance(200, 600);
       generator.writeCloudBalance(400, 1200);
       generator.writeCloudBalance(800, 2400);
       generator.writeCloudBalance(1600, 4800);
   }","// in gigabyte per hour
public static void main(String[] args) 
{
    double downloadSpeed = 2.5;
    double fileSize = 4.8;
    double downloadTime = fileSize / downloadSpeed;
    System.out.print(""Download time is "");
    System.out.print(downloadTime);
    System.out.println("" hours"");
}   ",1528,False
"/**
 * Escape illegal HTML element id characters, such as a dot.
 * <p>
 * This escape function guarantees that 2 distinct strings will result into 2 distinct escape strings
 * (presuming that both have been escaped by this method).
 *
 * @param rawHtmlId never null
 * @return never null
 */
public static String escapeHtmlId(String rawHtmlId){
    // Uses unicode numbers to escape, see http://unicode-table.com
    // Uses '-' as the escape character
    return rawHtmlId
            .replaceAll("" "", ""-0020"")
            .replaceAll(""!"", ""-0021"")
            .replaceAll(""#"", ""-0023"")
            .replaceAll(""\\$"", ""-0024"")
            .replaceAll("","", ""-002C"")
            .replaceAll(""-"", ""-002D"")
            .replaceAll(""\\."", ""-002E"")
            .replaceAll(""\\("", ""-0028"")
            .replaceAll(""\\)"", ""-0029"")
            .replaceAll("":"", ""-003A"")
            .replaceAll("";"", ""-003B"")
            .replaceAll(""\\?"", ""-003F"");
}","/**
 * Escape illegal HTML element id characters, such as a dot.
 * <p>
 * This escape function guarantees that 2 distinct strings will result into 2 distinct escape strings
 * (presuming that both have been escaped by this method).
 *
 * @param rawHtmlId never null
 * @return never null
 */
public static String escapeHtmlId(String rawHtmlId) 
{
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < rawHtmlId.length(); i++)
    {
        char c = rawHtmlId.charAt(i);
        if (c == '.')
        {
            sb.append(""_"");
        }
        else if (isValidChar(c))
        {
            sb.append(c);
        }
        else
        {
            sb.append(""_"").append(Integer.toHexString(c).toUpperCase());
        }
    }
    return sb.toString();
}   ",1529,True
"/**
 * Assert that the constraint of {@link PlanningSolution} has the expected weight for that score level.
 *
 * @param constraintPackage sometimes null.
 *        When null, {@code constraintName} for the {@code scoreLevel} must be unique.
 * @param scoreLevel at least 0
 * @param constraintName never null, the name of the constraint
 * @param expectedWeight never null, the total weight for all matches of that 1 constraint
 * @param solution never null
 */
protected void assertWeight(String constraintPackage, String constraintName, int scoreLevel, Number expectedWeight,
        Solution_ solution){
    ConstraintMatchTotal<?> matchTotal;
    try (InnerScoreDirector<Solution_, ?> scoreDirector = scoreDirectorFactory.buildScoreDirector()) {
        scoreDirector.setWorkingSolution(solution);
        scoreDirector.calculateScore();
        matchTotal = findConstraintMatchTotal(constraintPackage, constraintName, scoreDirector);
    }
    // A matchTotal is null if the constraint did match now and never matched in a previous incremental calculation
    // (including those that are undone).
    // To avoid user pitfalls, the expectedWeight cannot be null and a matchTotal of null is treated as zero.
    if (expectedWeight == null) {
        throw new IllegalArgumentException(""The expectedWeight ("" + expectedWeight + "") cannot be null,""
                + "" regardless of the matchTotal ("" + matchTotal + "")."");
    }
    if (matchTotal == null) {
        if (expectedWeight instanceof Byte) {
            assertEquals(expectedWeight, (byte) 0);
        } else if (expectedWeight instanceof Short) {
            assertEquals(expectedWeight, (short) 0);
        } else if (expectedWeight instanceof Integer) {
            assertEquals(expectedWeight, 0);
        } else if (expectedWeight instanceof Long) {
            assertEquals(expectedWeight, 0L);
        } else if (expectedWeight instanceof Float) {
            assertEquals(expectedWeight, 0F);
        } else if (expectedWeight instanceof Double) {
            assertEquals(expectedWeight, 0D);
        } else if (expectedWeight instanceof BigInteger) {
            assertEquals(expectedWeight, BigInteger.ZERO);
        } else if (expectedWeight instanceof BigDecimal) {
            assertEquals(expectedWeight, BigDecimal.ZERO);
        } else {
            throw new IllegalStateException(""Unsupported "" + Number.class.getSimpleName()
                    + "" type ("" + expectedWeight.getClass() + "") for expectedWeight ("" + expectedWeight + "")."");
        }
    } else {
        assertEquals(expectedWeight, matchTotal.getScore().toLevelNumbers()[scoreLevel]);
    }
}","/**
 * Assert that the constraint of {@link PlanningSolution} has the expected weight for that score level.
 *
 * @param constraintPackage sometimes null.
 *        When null, {@code constraintName} for the {@code scoreLevel} must be unique.
 * @param scoreLevel at least 0
 * @param constraintName never null, the name of the constraint
 * @param expectedWeight never null, the total weight for all matches of that 1 constraint
 * @param solution never null
 */
protected void assertWeight(String constraintPackage, String constraintName, int scoreLevel, Number expectedWeight,
        Solution_ solution) 
{
    Map<String, ConstraintMatchTotal_> constraintMatchTotalMap = solution.getConstraintMatchTotalMap();
    ConstraintMatchTotal_ constraintMatchTotal = constraintMatchTotalMap.get(constraintPackage + ""/"" + constraintName);
    assertNotNull(constraintMatchTotal);
    assertEquals(expectedWeight, constraintMatchTotal.getScore());
}       ",1530,False
"/**
 * Supported system properties: {@link CommonApp#DATA_DIR_SYSTEM_PROPERTY}.
 *
 * @param args never null
 */
public static void main(String[] args){
    CommonApp.prepareSwingEnvironment();
    OptaPlannerExamplesApp optaPlannerExamplesApp = new OptaPlannerExamplesApp();
    optaPlannerExamplesApp.pack();
    optaPlannerExamplesApp.setLocationRelativeTo(null);
    optaPlannerExamplesApp.setVisible(true);
}","/**
 * Supported system properties: {@link CommonApp#DATA_DIR_SYSTEM_PROPERTY}.
 *
 * @param args never null
 */
public static void main(String[] args) 
{
    final String dataDir = System.getProperty(CommonApp.DATA_DIR_SYSTEM_PROPERTY);
    if (dataDir == null)
    {
        System.err.println(CommonApp.DATA_DIR_SYSTEM_PROPERTY + "" has to be specified!"");
        return;
    }

    final File dataDirectory = new File(dataDir);
    if (!dataDirectory.exists())
    {
        System.err.println(dataDir + "" does not exist!"");
        return;
    }

    final CommonApp app = new CommonApp(dataDirectory);
    app.start();
}   ",1534,False
"/**
 * As described by <a href=""https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering"">Floyd-Steinberg
 * dithering</a>.
 */
private void floydSteinbergDithering(){
    tspSolution.setDistanceType(DistanceType.AIR_DISTANCE);
    tspSolution.setDistanceUnitOfMeasurement(""distance"");
    int width = image.getWidth();
    int height = image.getHeight();
    double[][] errorDiffusion = new double[width][height];
    List<Location> locationList = new ArrayList<>(1000);
    long id = 0L;
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            int rgb = image.getRGB(x, y);
            int r = (rgb) & 0xFF;
            int g = (rgb >> 8) & 0xFF;
            int b = (rgb >> 16) & 0xFF;
            double originalGray = (r + g + b) / GRAY_MAXIMUM;
            double diffusedGray = originalGray + errorDiffusion[x][y];
            double error;
            if (diffusedGray <= 0.5) {
                Location location = new AirLocation();
                location.setId(id);
                id++;
                location.setLatitude(-y);
                location.setLongitude(x);
                locationList.add(location);
                error = diffusedGray;
            } else {
                error = diffusedGray - 1.0;
            }
            if (x + 1 < width) {
                errorDiffusion[x + 1][y] += error * 7.0 / 16.0;
            }
            if (y + 1 < height) {
                if (x - 1 >= 0) {
                    errorDiffusion[x - 1][y + 1] += error * 3.0 / 16.0;
                }
                errorDiffusion[x][y + 1] += error * 5.0 / 16.0;
                if (x + 1 < width) {
                    errorDiffusion[x + 1][y + 1] += error * 1.0 / 16.0;
                }
            }
        }
    }
    tspSolution.setLocationList(locationList);
}","/**
 * As described by <a href=""https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering"">Floyd-Steinberg
 * dithering</a>.
 */
private void floydSteinbergDithering() 
{
    for (int y = 0; y < height - 1; y++)
    {
        for (int x = 1; x < width - 1; x++)
        {
            int oldPixel = pixels[x][y];
            int newPixel = findClosestColor(oldPixel);
            pixels[x][y] = newPixel;
            int quantError = oldPixel - newPixel;
            pixels[x + 1][y] = pixels[x + 1][y] + (int) (7.0 / 16.0 * quantError);
            pixels[x - 1][y + 1] = pixels[x - 1][y + 1] + (int) (3.0 / 16.0 * quantError);
            pixels[x][y + 1] = pixels[x][y + 1] + (int) (5.0 / 16.0 * quantError);
            pixels[x + 1][y + 1] = pixels[x + 1][y + 1] + (int) (1.0 / 16.0 * quantError);
        }
    }
}   ",1535,False
"/**
 * @param producedTime in minutes, just like {@link Task#getStartTime()}
 */
public void produceUpTo(final int producedTime){
    if (producedTime <= previousProducedTime) {
        // Occurs due to rounding down of producedDurationInSeconds
        return;
    }
    final int baseDurationBudgetPerEmployee = (producedTime - previousProducedTime);
    final int newTaskCount = getSolution().getEmployeeList().size() * baseDurationBudgetPerEmployee / BASE_DURATION_AVERAGE;
    if (newTaskCount <= 0) {
        // Do not change previousProducedDuration
        return;
    }
    logger.debug(""Scheduling production of {} new tasks."", newTaskCount);
    previousProducedTime = producedTime;
    final int readyTime = previousConsumedTime;
    doProblemFactChange(scoreDirector -> {
        TaskAssigningSolution solution = scoreDirector.getWorkingSolution();
        List<TaskType> taskTypeList = solution.getTaskTypeList();
        List<Customer> customerList = solution.getCustomerList();
        Priority[] priorities = Priority.values();
        List<Task> taskList = solution.getTaskList();
        for (int i = 0; i < newTaskCount; i++) {
            Task task = new Task();
            TaskType taskType = taskTypeList.get(producingRandom.nextInt(taskTypeList.size()));
            long nextTaskId = 0L;
            int nextIndexInTaskType = 0;
            for (Task other : taskList) {
                if (nextTaskId <= other.getId()) {
                    nextTaskId = other.getId() + 1L;
                }
                if (taskType == other.getTaskType()) {
                    if (nextIndexInTaskType <= other.getIndexInTaskType()) {
                        nextIndexInTaskType = other.getIndexInTaskType() + 1;
                    }
                }
            }
            task.setId(nextTaskId);
            task.setTaskType(taskType);
            task.setIndexInTaskType(nextIndexInTaskType);
            task.setCustomer(customerList.get(producingRandom.nextInt(customerList.size())));
            // Prevent the new task from being assigned retroactively
            task.setReadyTime(readyTime);
            task.setPriority(priorities[producingRandom.nextInt(priorities.length)]);

            scoreDirector.beforeEntityAdded(task);
            taskList.add(task);
            scoreDirector.afterEntityAdded(task);
        }
        scoreDirector.triggerVariableListeners();
    });
}","/**
 * @param producedTime in minutes, just like {@link Task#getStartTime()}
 */
public void produceUpTo(final int producedTime) 
{
    int time = 0;
    while (time < producedTime)
    {
        int timeToProduce = Math.min(producedTime - time, this.getRemainingTime());
        this.produce(timeToProduce);
        time += timeToProduce;
    }
}   ",1537,False
"/**
 * @param constraintPackage sometimes null.
 *        When null, {@code constraintName} for the {@code scoreLevel} must be unique.
 * @param constraintName never null, the name of the constraint
 * @param scoreDirector never null
 * @return null if there is no constraint matched or the constraint doesn't exist
 */
private ConstraintMatchTotal<?> findConstraintMatchTotal(String constraintPackage, String constraintName,
        InnerScoreDirector<Solution_, ?> scoreDirector){
    if (constraintPackage != null) {
        String constraintId = ConstraintMatchTotal.composeConstraintId(constraintPackage, constraintName);
        return scoreDirector.getConstraintMatchTotalMap().get(constraintId);
    }
    ConstraintMatchTotal<?> matchTotal = null;
    for (ConstraintMatchTotal<?> selectedMatchTotal : scoreDirector.getConstraintMatchTotalMap().values()) {
        if (selectedMatchTotal.getConstraintName().equals(constraintName)) {
            if (matchTotal != null) {
                throw new IllegalArgumentException(""The constraintName ("" + constraintName
                        + "") is used by 2 different constraintMatches ("" + matchTotal.getConstraintId()
                        + "" and "" + selectedMatchTotal.getConstraintId() + "")."");
            }
            matchTotal = selectedMatchTotal;
        }
    }
    return matchTotal;
}","/**
 * @param constraintPackage sometimes null.
 *        When null, {@code constraintName} for the {@code scoreLevel} must be unique.
 * @param constraintName never null, the name of the constraint
 * @param scoreDirector never null
 * @return null if there is no constraint matched or the constraint doesn't exist
 */
private ConstraintMatchTotal<?> findConstraintMatchTotal(String constraintPackage, String constraintName,
        InnerScoreDirector<Solution_, ?> scoreDirector) 
{
    if (constraintPackage == null)
    {
        return scoreDirector.getConstraintMatchTotalMap().get(constraintName);
    }
    else
    {
        return scoreDirector.getConstraintMatchTotalMap().get(constraintPackage + "":"" + constraintName);
    }
}   ",1538,True
"// Read and apply the enabled state of the cross profile file chooser
public void applyCrossProfileFileChooser(){
    boolean enabled = mStorage.getBoolean(LocalStorageManager.PREF_CROSS_PROFILE_FILE_CHOOSER);
    mContext.getPackageManager().setComponentEnabledSetting(
            new ComponentName(mContext, CrossProfileDocumentsProvider.class),
            enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
            PackageManager.DONT_KILL_APP);
}","// Read and apply the enabled state of the cross profile file chooser
public void applyCrossProfileFileChooser() 
{
    if (mCrossProfileFileChooserEnabled)
    {
        mCrossProfileFileChooser.setEnabled(true);
    }
    else
    {
        mCrossProfileFileChooser.setEnabled(false);
    }
}   ",1541,False
"// Convenience method to call getActivity().runOnUiThread()
// without bothering about NPEs
protected void runOnUiThread(Runnable task){
    if (getActivity() == null) return;
    getActivity().runOnUiThread(task);
}","// Convenience method to call getActivity().runOnUiThread()
// without bothering about NPEs
protected void runOnUiThread(Runnable task) 
{
    Activity activity = getActivity();
    if (activity != null)
    {
        activity.runOnUiThread(task);
    }
}   ",1542,True
"// Read and apply the enabled state of the camera proxy
public void applyCameraProxy(){
    boolean enabled = mStorage.getBoolean(LocalStorageManager.PREF_CAMERA_PROXY);
    mContext.getPackageManager().setComponentEnabledSetting(
            new ComponentName(mContext, CameraProxyActivity.class),
            enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
            PackageManager.DONT_KILL_APP);
}","// Read and apply the enabled state of the camera proxy
public void applyCameraProxy() 
{
    if (mCameraProxy != null)
    {
        mCameraProxy.setEnabled(mCameraProxyEnabled);
    }
}   ",1544,False
"// Delete apps that no longer exist from the auto freeze list
public static void deleteMissingApps(String pref, List<ApplicationInfoWrapper> apps){
    List<String> list = new ArrayList<>(
            Arrays.asList(LocalStorageManager.getInstance().getStringList(pref)));
    list.removeIf((it) -> apps.stream().noneMatch((x) -> x.getPackageName().equals(it)));
    LocalStorageManager.getInstance().setStringList(pref, list.toArray(new String[]{}));
}","// Delete apps that no longer exist from the auto freeze list
public static void deleteMissingApps(String pref, List<ApplicationInfoWrapper> apps) 
{
    List<String> toRemove = new ArrayList<String>();
    for (String pkg : getAutoFreezeList(pref))
    {
        boolean found = false;
        for (ApplicationInfoWrapper app : apps)
        {
            if (pkg.equals(app.getPackageName()))
            {
                found = true;
                break;
            }
        }
        if (!found)
        {
            toRemove.add(pkg);
        }
    }
    for (String pkg : toRemove)
    {
        removeAutoFreezeApp(pref, pkg);
    }
}   ",1545,True
"// Set the delay for auto freeze service (in seconds)
public void setAutoFreezeDelay(int seconds){
    mStorage.setInt(LocalStorageManager.PREF_AUTO_FREEZE_DELAY, seconds);
    syncSettingsToProfileInt(LocalStorageManager.PREF_AUTO_FREEZE_DELAY, seconds);
}","// Set the delay for auto freeze service (in seconds)
public void setAutoFreezeDelay(int seconds) 
{
    if (seconds < 0)
    {
        throw new IllegalArgumentException(""Delay cannot be negative"");
    }

    this.autoFreezeDelay = seconds;
}   ",1546,False
"// Detect if the device is MIUI
public static boolean isMIUI(){
    try {
        Process proc = Runtime.getRuntime().exec(""getprop ro.miui.ui.version.name"");
        BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
        String line = reader.readLine().trim();
        return !line.isEmpty();
    } catch (Exception e) {
        return false;
    }
}","// Detect if the device is MIUI
public static boolean isMIUI() 
{
    try
    {
        return !TextUtils.isEmpty(SystemProperties.get(""ro.miui.ui.version.name""));
    }
    catch (Exception e)
    {
        return false;
    }
}   ",1548,False
"// Create a listener from an activity, and show a progress dialog for the sessionId
// Only cares about the one sessionId provided here.
// The caller is responsible for registering the callback;
// however, this class will remove itself once the session has been finished.
public InstallationProgressListener(Activity activity, PackageInstaller pi, int sessionId){
    mPi = pi;

    ViewGroup layout = (ViewGroup) LayoutInflater.from(activity)
            .inflate(R.layout.progress_dialog, (ViewGroup) activity.getWindow().getDecorView(), false);
    mProgress = layout.findViewById(R.id.progress);

    mDialog = new AlertDialog.Builder(activity)
            .setCancelable(false)
            .setTitle(R.string.app_installing)
            .setView(layout)
            .create();
    mDialog.show();
}","// Create a listener from an activity, and show a progress dialog for the sessionId
// Only cares about the one sessionId provided here.
// The caller is responsible for registering the callback;
// however, this class will remove itself once the session has been finished.
public InstallationProgressListener(Activity activity, PackageInstaller pi, int sessionId) 
{
    this.activity = activity;
    this.pi = pi;
    this.sessionId = sessionId;

    ProgressDialog dialog = new ProgressDialog(activity);
    dialog.setIndeterminate(true);
    dialog.setCancelable(false);
    dialog.setMessage(activity.getString(R.string.installing));
    this.dialog = dialog;

    this.activity.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            dialog.show();
        }
    });
}   ",1550,True
"// Call this on ACTUAL data set change and/or search query change
private void notifyChange(){
    mList.clear();
    if (mSearchQuery == null) {
        // No search query, do not filter
        mList.addAll(mOrigList);
    } else {
        // Filter by search query
        mList.addAll(mOrigList.stream()
                .filter((app) ->
                        app.getPackageName().toLowerCase().contains(mSearchQuery)
                                || app.getLabel().toLowerCase().contains(mSearchQuery))
                .collect(Collectors.toList()));
    }
    notifyDataSetChanged();
}","// Call this on ACTUAL data set change and/or search query change
private void notifyChange() 
{
    if (mListener != null)
    {
        mListener.onDataSetChange();
    }
}   ",1551,False
"// Check special access permission through AppOps
public static boolean checkSpecialAccessPermission(Context context, String name){
    AppOpsManager appops = context.getSystemService(AppOpsManager.class);
    int mode = appops.checkOpNoThrow(name, android.os.Process.myUid(), context.getPackageName());
    return mode == AppOpsManager.MODE_ALLOWED;
}","// Check special access permission through AppOps

public static boolean checkSpecialAccessPermission(Context context, String name) 
{
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)
    {
        AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);
        int mode = appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, android.os.Process.myUid(), name);
        return AppOpsManager.MODE_ALLOWED == mode;
    }
    return false;
}   ",1552,True
"// Functions to load scaled down version of Bitmap
// from <https://developer.android.com/topic/performance/graphics/load-bitmap?hl=es#java>
public static int calculateInSampleSize(
        BitmapFactory.Options options, int reqWidth, int reqHeight){
    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height > reqHeight || width > reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and keeps both
        // height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) >= reqHeight
                && (halfWidth / inSampleSize) >= reqWidth) {
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}","// Functions to load scaled down version of Bitmap
// from <https://developer.android.com/topic/performance/graphics/load-bitmap?hl=es#java>
public static int calculateInSampleSize(
        BitmapFactory.Options options, int reqWidth, int reqHeight) 
{
    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height > reqHeight || width > reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and keeps both
        // height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) >= reqHeight
                && (halfWidth / inSampleSize) >= reqWidth) {
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}       ",1553,True
"// Fallback method for thumbnail loading: just load from disk, but load a scaled down version
private ParcelFileDescriptor loadBitmapThumbnail(String path, Point sizeHint){
    Bitmap bmp = Utility.decodeSampledBitmap(path, sizeHint.x, sizeHint.y);

    if (bmp == null) {
        return null;
    }

    return bitmapToFd(bmp);
}","// Fallback method for thumbnail loading: just load from disk, but load a scaled down version


private ParcelFileDescriptor loadBitmapThumbnail(String path, Point sizeHint) 
{
    if (path == null) {
        return null;
    }

    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(path, options);

    options.inSampleSize = BitmapUtils.computeSampleSize(options, sizeHint.x, sizeHint.y);
    options.inJustDecodeBounds = false;

    return ParcelFileDescriptor.open(new File(path), ParcelFileDescriptor.MODE_READ_ONLY);
}   ",1555,True
"// Polyfill for String.join
public static String stringJoin(String delimiter, String[] list){
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        return String.join(delimiter, list);
    } else {
        if (list.length == 0) return """";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.length - 1; i++) {
            sb.append(list[i]).append(delimiter);
        }
        sb.append(list[list.length - 1]);
        return sb.toString();
    }
}","// Polyfill for String.join
public static String stringJoin(String delimiter, String[] list) 
{
    StringBuilder sb = new StringBuilder();
    boolean first = true;
    for (String s : list)
    {
        if (first)
        {
            first = false;
        }
        else
        {
            sb.append(delimiter);
        }
        sb.append(s);
    }
    return sb.toString();
}   ",1558,False
"// Set the enabled state of the cross profile file chooser
public void setCameraProxyEnabled(boolean enabled){
    mStorage.setBoolean(LocalStorageManager.PREF_CAMERA_PROXY, enabled);
    applyCameraProxy();
    syncSettingsToProfileBool(LocalStorageManager.PREF_CAMERA_PROXY, enabled);
}","// Set the enabled state of the cross profile file chooser
public void setCameraProxyEnabled(boolean enabled) 
{
    if (mCameraProxyChooser != null)
    {
        mCameraProxyChooser.setEnabled(enabled);
    }
}   ",1559,True
"/**
 * Realize an smooth slide to an slide offset passed as argument. This method is the base of
 * maximize, minimize and close methods.
 *
 * @param slideOffset to apply
 * @return true if the view is slided.
 */
private boolean smoothSlideTo(float slideOffset){
  final int topBound = getPaddingTop();
  int x = (int) (slideOffset * (getWidth() - transformer.getMinWidthPlusMarginRight()));
  int y = (int) (topBound + slideOffset * getVerticalDragRange());
  if (viewDragHelper.smoothSlideViewTo(dragView, x, y)) {
    ViewCompat.postInvalidateOnAnimation(this);
    return true;
  }
  return false;
}","/**
 * Realize an smooth slide to an slide offset passed as argument. This method is the base of
 * maximize, minimize and close methods.
 *
 * @param slideOffset to apply
 * @return true if the view is slided.
 */
private boolean smoothSlideTo(float slideOffset) 
{
    int slidePx = (int) (slideOffset * mSlideableView.getMeasuredWidth());
    if (mDragHelper.smoothSlideViewTo(mSlideableView, slidePx, 0))
    {
        ViewCompat.postInvalidateOnAnimation(mSlideableView);
        return true;
    }
    return false;
}   ",1560,True
"/**
 * Override method to dispatch touch event to the dragged view.
 *
 * @param ev captured.
 * @return true if the touch event is realized over the drag or second view.
 */
@Override public boolean onTouchEvent(MotionEvent ev){
  int actionMasked = MotionEventCompat.getActionMasked(ev);
  if ((actionMasked & MotionEventCompat.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
    activePointerId = MotionEventCompat.getPointerId(ev, actionMasked);
  }
  if (activePointerId == INVALID_POINTER) {
    return false;
  }
  viewDragHelper.processTouchEvent(ev);
  if (isClosed()) {
    return false;
  }
  boolean isDragViewHit = isViewHit(dragView, (int) ev.getX(), (int) ev.getY());
  boolean isSecondViewHit = isViewHit(secondView, (int) ev.getX(), (int) ev.getY());
  analyzeTouchToMaximizeIfNeeded(ev, isDragViewHit);
  if (isMaximized()) {
    dragView.dispatchTouchEvent(ev);
  } else {
    dragView.dispatchTouchEvent(cloneMotionEventWithAction(ev, MotionEvent.ACTION_CANCEL));
  }
  return isDragViewHit || isSecondViewHit;
}","/**
 * Override method to dispatch touch event to the dragged view.
 *
 * @param ev captured.
 * @return true if the touch event is realized over the drag or second view.
 */
@Override public boolean onTouchEvent(MotionEvent ev) 
{
    if (dragView != null)
    {
        return dragView.onTouchEvent(ev);
    }
    return false;
}   ",1561,False
"/**
 * Initialize Transformer with a scalable or change width/height implementation.
 */
private void initializeTransformer(){
  TransformerFactory transformerFactory = new TransformerFactory();
  transformer = transformerFactory.getTransformer(topViewResize, dragView, this);
  transformer.setViewHeight(topViewHeight);
  transformer.setXScaleFactor(scaleFactorX);
  transformer.setYScaleFactor(scaleFactorY);
  transformer.setMarginRight(marginRight);
  transformer.setMarginBottom(marginBottom);
}","/**
 * Initialize Transformer with a scalable or change width/height implementation.
 */
private void initializeTransformer() 
{
    if (this.scalable)
    {
        this.transformer = new ScalableTransformer();
    }
    else
    {
        this.transformer = new ChangeWidthHeightTransformer();
    }
}   ",1562,True
"/**
 * Calculate if one position is above any view.
 *
 * @param view to analyze.
 * @param x position.
 * @param y position.
 * @return true if x and y positions are below the view.
 */
private boolean isViewHit(View view, int x, int y){
  int[] viewLocation = new int[2];
  view.getLocationOnScreen(viewLocation);
  int[] parentLocation = new int[2];
  this.getLocationOnScreen(parentLocation);
  int screenX = parentLocation[0] + x;
  int screenY = parentLocation[1] + y;
  return screenX >= viewLocation[0]
      && screenX < viewLocation[0] + view.getWidth()
      && screenY >= viewLocation[1]
      && screenY < viewLocation[1] + view.getHeight();
}","/**
 * Calculate if one position is above any view.
 *
 * @param view to analyze.
 * @param x position.
 * @param y position.
 * @return true if x and y positions are below the view.
 */
private boolean isViewHit(View view, int x, int y) 
{
    int[] location = new int[2];
    view.getLocationOnScreen(location);
    int left = location[0];
    int top = location[1];
    int right = left + view.getWidth();
    int bottom = top + view.getHeight();

    return x >= left && x <= right && y >= top && y <= bottom;
}   ",1564,False
"/**
 * Notify te view is closed to the left to the DraggableListener
 */
private void notifyCloseToLeftListener(){
  if (listener != null) {
    listener.onClosedToLeft();
  }
}","/**
 * Notify te view is closed to the left to the DraggableListener
 */
private void notifyCloseToLeftListener() 
{
    if (mCloseToLeftListener != null)
    {
        mCloseToLeftListener.onCloseToLeft();
    }
}   ",1565,True
"/**
 * Minimize the custom view applying an animation to put the top fragment on the bottom right
 * corner of the screen.
 */
public void minimize(){
  smoothSlideTo(SLIDE_BOTTOM);
  notifyMinimizeToListener();
}","/**
 * Minimize the custom view applying an animation to put the top fragment on the bottom right
 * corner of the screen.
 */
public void minimize() 
{
    if (mCustomView != null)
    {
        mCustomView.animate()
                .translationX(mCustomView.getWidth() / 2)
                .translationY(mCustomView.getHeight() / 2)
                .scaleX(0.1f)
                .scaleY(0.1f)
                .alpha(0)
                .setDuration(300)
                .start();
    }
}   ",1568,True
"/**
 * To ensure the animation is going to work this method has been override to call
 * postInvalidateOnAnimation if the view is not settled yet.
 */
@Override public void computeScroll(){
  if (!isInEditMode() && viewDragHelper.continueSettling(true)) {
    ViewCompat.postInvalidateOnAnimation(this);
  }
}","/**
 * To ensure the animation is going to work this method has been override to call
 * postInvalidateOnAnimation if the view is not settled yet.
 */
@Override public void computeScroll() 
{
    if (mScroller.computeScrollOffset())
    {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidateOnAnimation(); // Force a re-draw
    }
}   ",1570,True
"/**
 * Close the custom view applying an animation to close the view to the right side of the screen.
 */
public void closeToRight(){
  if (viewDragHelper.smoothSlideViewTo(dragView, transformer.getOriginalWidth(),
      getHeight() - transformer.getMinHeightPlusMargin())) {
    ViewCompat.postInvalidateOnAnimation(this);
    notifyCloseToRightListener();
  }
}","/**
 * Close the custom view applying an animation to close the view to the right side of the screen.
 */
public void closeToRight() 
{
    TranslateAnimation animate = new TranslateAnimation(0, mScreenWidth, 0, 0);
    animate.setDuration(500);
    animate.setFillAfter(true);
    this.startAnimation(animate);
    mIsOpen = false;
}   ",1571,True
"/**
 * Maximize the custom view applying an animation to return the view to the initial position.
 */
public void maximize(){
  smoothSlideTo(SLIDE_TOP);
  notifyMaximizeToListener();
}","/**
 * Maximize the custom view applying an animation to return the view to the initial position.
 */
public void maximize() 
{
    if (mCustomView != null)
    {
        mCustomView.animate().translationY(0).setDuration(200).start();
    }
}   ",1572,True
"/**
 * Initialize XML attributes.
 *
 * @param attrs to be analyzed.
 */
private void initializeAttributes(AttributeSet attrs){
  TypedArray attributes = getContext().obtainStyledAttributes(attrs, R.styleable.draggable_view);
  this.enableHorizontalAlphaEffect =
      attributes.getBoolean(R.styleable.draggable_view_enable_minimized_horizontal_alpha_effect,
          DEFAULT_ENABLE_HORIZONTAL_ALPHA_EFFECT);
  this.enableClickToMaximize =
      attributes.getBoolean(R.styleable.draggable_view_enable_click_to_maximize_view,
          DEFAULT_ENABLE_CLICK_TO_MAXIMIZE);
  this.enableClickToMinimize =
      attributes.getBoolean(R.styleable.draggable_view_enable_click_to_minimize_view,
          DEFAULT_ENABLE_CLICK_TO_MINIMIZE);
  this.topViewResize =
          attributes.getBoolean(R.styleable.draggable_view_top_view_resize, DEFAULT_TOP_VIEW_RESIZE);
  this.topViewHeight = attributes.getDimensionPixelSize(R.styleable.draggable_view_top_view_height,
          DEFAULT_TOP_VIEW_HEIGHT);
  this.scaleFactorX = attributes.getFloat(R.styleable.draggable_view_top_view_x_scale_factor,
          DEFAULT_SCALE_FACTOR);
  this.scaleFactorY = attributes.getFloat(R.styleable.draggable_view_top_view_y_scale_factor,
          DEFAULT_SCALE_FACTOR);
  this.marginBottom = attributes.getDimensionPixelSize(R.styleable.draggable_view_top_view_margin_bottom,
          DEFAULT_TOP_VIEW_MARGIN);
  this.marginRight = attributes.getDimensionPixelSize(R.styleable.draggable_view_top_view_margin_right,
          DEFAULT_TOP_VIEW_MARGIN);
  this.dragViewId =
          attributes.getResourceId(R.styleable.draggable_view_top_view_id, R.id.drag_view);
  this.secondViewId =
          attributes.getResourceId(R.styleable.draggable_view_bottom_view_id, R.id.second_view);
  attributes.recycle();
}","/**
 * Initialize XML attributes.
 *
 * @param attrs to be analyzed.
 */
private void initializeAttributes(AttributeSet attrs) 
{
    if (attrs != null)
    {
        for (int i = 0; i < attrs.getAttributeCount(); i++)
        {
            String name = attrs.getAttributeName(i);
            String value = attrs.getAttributeValue(i);
            if (name.equals(""name""))
            {
                this.name = value;
            }
            else if (name.equals(""value""))
            {
                this.value = value;
            }
        }
    }
}   ",1573,True
"/**
 * Notify te view is minimized to the DraggableListener
 */
private void notifyMinimizeToListener(){
  if (listener != null) {
    listener.onMinimized();
  }
}","/**
 * Notify te view is minimized to the DraggableListener
 */
private void notifyMinimizeToListener() 
{
    if (mDraggableListener != null)
    {
        mDraggableListener.onMinimize();
    }
}   ",1577,True
"/**
 * Override method to intercept only touch events over the drag view and to cancel the drag when
 * the action associated to the MotionEvent is equals to ACTION_CANCEL or ACTION_UP.
 *
 * @param ev captured.
 * @return true if the view is going to process the touch event or false if not.
 */
@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  switch (MotionEventCompat.getActionMasked(ev) & MotionEventCompat.ACTION_MASK) {
    case MotionEvent.ACTION_CANCEL:
    case MotionEvent.ACTION_UP:
      viewDragHelper.cancel();
      return false;
    case MotionEvent.ACTION_DOWN:
      int index = MotionEventCompat.getActionIndex(ev);
      activePointerId = MotionEventCompat.getPointerId(ev, index);
      if (activePointerId == INVALID_POINTER) {
        return false;
      }
      break;
    default:
      break;
  }
  boolean interceptTap = viewDragHelper.isViewUnder(dragView, (int) ev.getX(), (int) ev.getY());
  return viewDragHelper.shouldInterceptTouchEvent(ev) || interceptTap;
}","/**
 * Override method to intercept only touch events over the drag view and to cancel the drag when
 * the action associated to the MotionEvent is equals to ACTION_CANCEL or ACTION_UP.
 *
 * @param ev captured.
 * @return true if the view is going to process the touch event or false if not.
 */
@Override public boolean onInterceptTouchEvent(MotionEvent ev) 
{
    if (ev.getActionMasked() == MotionEvent.ACTION_CANCEL || ev.getActionMasked() == MotionEvent.ACTION_UP)
    {
        handler.removeCallbacksAndMessages(null);
        return false;
    }
    return super.onInterceptTouchEvent(ev);
}   ",1578,False
"/**
 * Close the custom view applying an animation to close the view to the left side of the screen.
 */
public void closeToLeft(){
  if (viewDragHelper.smoothSlideViewTo(dragView, -transformer.getOriginalWidth(),
      getHeight() - transformer.getMinHeightPlusMargin())) {
    ViewCompat.postInvalidateOnAnimation(this);
    notifyCloseToLeftListener();
  }
}","/**
 * Close the custom view applying an animation to close the view to the left side of the screen.
 */

public void closeToLeft() 
{
    TranslateAnimation animate = new TranslateAnimation(0, -mView.getWidth(), 0, 0);
    animate.setDuration(500);
    animate.setFillAfter(true);
    mView.startAnimation(animate);
}   ",1579,True
"/**
 * Defines the time that must pass between app crashes to determine that we are not
 * in a crash loop. If a crash has occurred less that this time ago,
 * the error activity will not be launched and the system crash screen will be invoked.
 * The default is 3000.
 */
@NonNull
public Builder minTimeBetweenCrashesMs(int minTimeBetweenCrashesMs){
    config.minTimeBetweenCrashesMs = minTimeBetweenCrashesMs;
    return this;
}","/**
 * Defines the time that must pass between app crashes to determine that we are not
 * in a crash loop. If a crash has occurred less that this time ago,
 * the error activity will not be launched and the system crash screen will be invoked.
 * The default is 3000.
 */
@NonNull
public Builder minTimeBetweenCrashesMs(int minTimeBetweenCrashesMs) 
{
    this.minTimeBetweenCrashesMs = minTimeBetweenCrashesMs;
    return this;
}   ",1580,True
"/**
 * Sets the error activity class to launch when a crash occurs.
 * If null, the default error activity will be used.
 */
@NonNull
public Builder errorActivity(@Nullable Class<? extends Activity> errorActivityClass){
    config.errorActivityClass = errorActivityClass;
    return this;
}","/**
 * Sets the error activity class to launch when a crash occurs.
 * If null, the default error activity will be used.
 */
@NonNull
public Builder errorActivity(@Nullable Class<? extends Activity> errorActivityClass) 
{
    this.errorActivityClass = errorActivityClass;
    return this;
}   ",1582,True
"/**
 * INTERNAL method that returns the build date of the current APK as a string, or null if unable to determine it.
 *
 * @param context    A valid context. Must not be null.
 * @param dateFormat DateFormat to use to convert from Date to String
 * @return The formatted date, or ""Unknown"" if unable to determine it.
 */
@Nullable
private static String getBuildDateAsString(@NonNull Context context, @NonNull DateFormat dateFormat){
    long buildDate;
    try {
        ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0);
        ZipFile zf = new ZipFile(ai.sourceDir);

        //If this failed, try with the old zip method
        ZipEntry ze = zf.getEntry(""classes.dex"");
        buildDate = ze.getTime();


        zf.close();
    } catch (Exception e) {
        buildDate = 0;
    }

    if (buildDate > 312764400000L) {
        return dateFormat.format(new Date(buildDate));
    } else {
        return null;
    }
}","/**
 * INTERNAL method that returns the build date of the current APK as a string, or null if unable to determine it.
 *
 * @param context    A valid context. Must not be null.
 * @param dateFormat DateFormat to use to convert from Date to String
 * @return The formatted date, or ""Unknown"" if unable to determine it.
 */

@Nullable
private static String getBuildDateAsString(@NonNull Context context, @NonNull DateFormat dateFormat) 
{
    long buildDate = getBuildDateAsLong(context);
    if (buildDate > 0)
    {
        return dateFormat.format(new Date(buildDate));
    }
    return null;
}   ",1583,False
"/**
 * INTERNAL method that returns the device model name with correct capitalization.
 * Taken from: http://stackoverflow.com/a/12707479/1254846
 *
 * @return The device model name (i.e., ""LGE Nexus 5"")
 */
@NonNull
private static String getDeviceModelName(){
    String manufacturer = Build.MANUFACTURER;
    String model = Build.MODEL;
    if (model.startsWith(manufacturer)) {
        return capitalize(model);
    } else {
        return capitalize(manufacturer) + "" "" + model;
    }
}","/**
 * INTERNAL method that returns the device model name with correct capitalization.
 * Taken from: http://stackoverflow.com/a/12707479/1254846
 *
 * @return The device model name (i.e., ""LGE Nexus 5"")
 */
@NonNull
private static String getDeviceModelName() 
{
    String manufacturer = Build.MANUFACTURER;
    String model = Build.MODEL;
    if (model.startsWith(manufacturer))
    {
        return capitalize(model);
    }
    else
    {
        return capitalize(manufacturer) + "" "" + model;
    }
}   ",1584,True
"/**
 * INTERNAL method that returns the version name of the current app, or null if unable to determine it.
 *
 * @param context A valid context. Must not be null.
 * @return The version name, or ""Unknown if unable to determine it.
 */
@NonNull
private static String getVersionName(Context context){
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
        return packageInfo.versionName;
    } catch (Exception e) {
        return ""Unknown"";
    }
}","/**
 * INTERNAL method that returns the version name of the current app, or null if unable to determine it.
 *
 * @param context A valid context. Must not be null.
 * @return The version name, or ""Unknown if unable to determine it.
 */

@NonNull
private static String getVersionName(Context context) 
{
    try
    {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
        return packageInfo.versionName;
    }
    catch (PackageManager.NameNotFoundException e)
    {
        return ""Unknown"";
    }
}   ",1585,True
"/**
 * Given an Intent, returns several error details including the stack trace extra from the intent.
 *
 * @param context A valid context. Must not be null.
 * @param intent  The Intent. Must not be null.
 * @return The full error details.
 */
@NonNull
public static String getAllErrorDetailsFromIntent(@NonNull Context context, @NonNull Intent intent){
    //I don't think that this needs localization because it's a development string...

    Date currentDate = new Date();
    DateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"", Locale.US);

    //Get build date
    String buildDateAsString = getBuildDateAsString(context, dateFormat);

    //Get app version
    String versionName = getVersionName(context);

    String errorDetails = """";

    errorDetails += ""Build version: "" + versionName + "" \n"";
    if (buildDateAsString != null) {
        errorDetails += ""Build date: "" + buildDateAsString + "" \n"";
    }
    errorDetails += ""Current date: "" + dateFormat.format(currentDate) + "" \n"";
    //Added a space between line feeds to fix #18.
    //Ideally, we should not use this method at all... It is only formatted this way because of coupling with the default error activity.
    //We should move it to a method that returns a bean, and let anyone format it as they wish.
    errorDetails += ""Device: "" + getDeviceModelName() + "" \n"";
    errorDetails += ""OS version: Android "" + Build.VERSION.RELEASE + "" (SDK "" + Build.VERSION.SDK_INT + "") \n \n"";
    errorDetails += ""Stack trace:  \n"";
    errorDetails += getStackTraceFromIntent(intent);

    String activityLog = getActivityLogFromIntent(intent);

    if (activityLog != null) {
        errorDetails += ""\nUser actions: \n"";
        errorDetails += activityLog;
    }

    String customTrace = getCustomCrashDataFromIntent(intent);
    if (customTrace != null) {
        errorDetails += ""\nCustom trace: \n"";
        errorDetails += customTrace;
    }

    return errorDetails;
}","/**
 * Given an Intent, returns several error details including the stack trace extra from the intent.
 *
 * @param context A valid context. Must not be null.
 * @param intent  The Intent. Must not be null.
 * @return The full error details.
 */
@NonNull
public static String getAllErrorDetailsFromIntent(@NonNull Context context, @NonNull Intent intent) 
{
    StringBuilder errorDetails = new StringBuilder();
    errorDetails.append(""\n"");
    errorDetails.append(getStackTraceFromIntent(intent));
    errorDetails.append(""\n"");
    errorDetails.append(getErrorDetailsFromIntent(context, intent));
    return errorDetails.toString();
}   ",1587,True
"/**
 * Defines if the error activity must shown the error details button.
 * Set it to true if you want to show the full stack trace and device info,
 * false if you want it to be hidden.
 * The default is true.
 */
@NonNull
public Builder showErrorDetails(boolean showErrorDetails){
    config.showErrorDetails = showErrorDetails;
    return this;
}","/**
 * Defines if the error activity must shown the error details button.
 * Set it to true if you want to show the full stack trace and device info,
 * false if you want it to be hidden.
 * The default is true.
 */
@NonNull
public Builder showErrorDetails(boolean showErrorDetails) 
{
    this.showErrorDetails = showErrorDetails;
    return this;
}   ",1590,True
"/**
 * Defines which drawable to use in the default error activity image.
 * Set this if you want to use an image other than the default one.
 * The default is R.drawable.customactivityoncrash_error_image (a cute upside-down bug).
 */
@NonNull
public Builder errorDrawable(@Nullable @DrawableRes Integer errorDrawable){
    config.errorDrawable = errorDrawable;
    return this;
}","/**
 * Defines which drawable to use in the default error activity image.
 * Set this if you want to use an image other than the default one.
 * The default is R.drawable.customactivityoncrash_error_image (a cute upside-down bug).
 */
@NonNull
public Builder errorDrawable(@Nullable @DrawableRes Integer errorDrawable) 
{
    this.errorDrawable = errorDrawable;
    return this;
}   ",1592,True
"/**
 * Sets the main activity class that the error activity must launch when a crash occurs.
 * If not set or set to null, the default launch activity will be used.
 * If your app has no launch activities and this is not set, the default error activity will close instead.
 */
@NonNull
public Builder restartActivity(@Nullable Class<? extends Activity> restartActivityClass){
    config.restartActivityClass = restartActivityClass;
    return this;
}","/**
 * Sets the main activity class that the error activity must launch when a crash occurs.
 * If not set or set to null, the default launch activity will be used.
 * If your app has no launch activities and this is not set, the default error activity will close instead.
 */
@NonNull
public Builder restartActivity(@Nullable Class<? extends Activity> restartActivityClass) 
{
    this.restartActivityClass = restartActivityClass;
    return this;
}   ",1594,True
"/**
 * Closes the app.
 * If an event listener is provided, the close app event is invoked.
 * Must only be used from your error activity.
 *
 * @param activity The current error activity. Must not be null.
 * @param config   The config object as obtained by calling getConfigFromIntent.
 */
public static void closeApplication(@NonNull Activity activity, @NonNull CaocConfig config){
    if (config.getEventListener() != null) {
        config.getEventListener().onCloseAppFromErrorActivity();
    }
    activity.finish();
    killCurrentProcess();
}","/**
 * Closes the app.
 * If an event listener is provided, the close app event is invoked.
 * Must only be used from your error activity.
 *
 * @param activity The current error activity. Must not be null.
 * @param config   The config object as obtained by calling getConfigFromIntent.
 */
public static void closeApplication(@NonNull Activity activity, @NonNull CaocConfig config) 
{
    if (config.isEnableAppExit()) {
        if (config.getEventListener() != null) {
            config.getEventListener().onAppExit();
        }
        activity.finish();
        Process.killProcess(Process.myPid());
    }
}   ",1597,True
"/**
 * Given an Intent, restarts the app and launches a startActivity to that intent.
 * The flags NEW_TASK and CLEAR_TASK are set if the Intent does not have them, to ensure
 * the app stack is fully cleared.
 * If an event listener is provided, the restart app event is invoked.
 * Must only be used from your error activity.
 *
 * @param activity The current error activity. Must not be null.
 * @param intent   The Intent. Must not be null.
 * @param config   The config object as obtained by calling getConfigFromIntent.
 */
public static void restartApplicationWithIntent(@NonNull Activity activity, @NonNull Intent intent, @NonNull CaocConfig config){
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    if (intent.getComponent() != null) {
        //If the class name has been set, we force it to simulate a Launcher launch.
        //If we don't do this, if you restart from the error activity, then press home,
        //and then launch the activity from the launcher, the main activity appears twice on the backstack.
        //This will most likely not have any detrimental effect because if you set the Intent component,
        //if will always be launched regardless of the actions specified here.
        intent.setAction(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
    }
    if (config.getEventListener() != null) {
        config.getEventListener().onRestartAppFromErrorActivity();
    }
    activity.finish();
    activity.startActivity(intent);
    killCurrentProcess();
}","/**
 * Given an Intent, restarts the app and launches a startActivity to that intent.
 * The flags NEW_TASK and CLEAR_TASK are set if the Intent does not have them, to ensure
 * the app stack is fully cleared.
 * If an event listener is provided, the restart app event is invoked.
 * Must only be used from your error activity.
 *
 * @param activity The current error activity. Must not be null.
 * @param intent   The Intent. Must not be null.
 * @param config   The config object as obtained by calling getConfigFromIntent.
 */
public static void restartApplicationWithIntent(@NonNull Activity activity, @NonNull Intent intent, @NonNull CaocConfig config) 
{
    if (intent == null)
    {
        throw new NullPointerException(""Intent cannot be null."");
    }

    // Make sure we don't finish the error activity after we restart the app
    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

    CaocHelper.restartApplication(activity, intent, config);
}   ",1598,True
"// convert
public static PointLocationEntity convert(int pointLocation, boolean isLeft){

    PointLocationEntity pl = new PointLocationEntity();
    pl.pointLocation = pointLocation;
    pl.isLeft = isLeft;
    return pl;

}","// convert
public static PointLocationEntity convert(int pointLocation, boolean isLeft) 
{
    PointLocationEntity pointLocationEntity = new PointLocationEntity();
    pointLocationEntity.setPointLocation(pointLocation);
    pointLocationEntity.setIsLeft(isLeft);
    return pointLocationEntity;
}   ",1600,True
"/**
 * 获取图像二值特征byte[]
 */
public static  byte[]  getBinaryByteArr(Mat binaryImg){
    int h =binaryImg.rows();
    int w = binaryImg.cols();
    int[][] bp01Int = new int[h][w];
    int flag = 0;
    int count = 0;
    StringBuilder letterImgSb = new StringBuilder();
    StringBuilder sb = new StringBuilder();
    byte[] letterimage = new byte[h*w/8];
    for(int i=0;i<h;i++){
        for(int j=0;j<w;j++){
            if(binaryImg.get(i,j)[0] == 0xff) {
                bp01Int[i][j] = 0;
                sb.append(0);
            }
            else{
                bp01Int[i][j] = 1;
                sb.append(1);
            }
            letterimage[flag] = (byte)((letterimage[flag] << 1) + bp01Int[i][j] );
            count++;
            if (count == 8)
            {
                int val =  (int)letterimage[flag] ;
                letterImgSb.append(val).append("" "");
                flag++;
                count = 0;
            }
        }
        sb.append(""\n"");
    }

    return letterimage;
}","/**
 * 获取图像二值特征byte[]
 */
public static  byte[]  getBinaryByteArr(Mat binaryImg) 
{
    int width = binaryImg.cols();
    int height = binaryImg.rows();
    int size = width * height;
    byte[] data = new byte[size];
    binaryImg.get(0, 0, data);
    return data;
}   ",1606,True
"/**
 * 图获取图像二值图像
 */
public static Mat getBinaryImg(Mat img, int width, int height){
    Imgproc.resize(img,img,new Size(width,height));
    Mat binaryImg = img.clone();
    Mat binaryImg1 = img.clone();
    Imgproc.cvtColor(img,binaryImg,Imgproc.COLOR_RGB2GRAY);
    int h = img.height();
    if(img.height() % 2 !=1){
        h = img.height() - 1;
    }
    int w = img.width();
    if(img.width()%2 !=1){
        w= img.width()-1;
    }
    int blockSize = Math.max(w,h);
    double stdevVal = (double) blockSize / 6;
    Imgproc.adaptiveThreshold(binaryImg,binaryImg1,255,Imgproc.ADAPTIVE_THRESH_MEAN_C,Imgproc.THRESH_BINARY_INV,blockSize,stdevVal);
    return binaryImg1;
}","/**
 * 图获取图像二值图像
 */

public static Mat getBinaryImg(Mat img, int width, int height) 
{
    Mat imgGray = new Mat();
    Mat imgBinary = new Mat();
    Imgproc.cvtColor(img, imgGray, Imgproc.COLOR_BGR2GRAY);
    Imgproc.adaptiveThreshold(imgGray, imgBinary, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY_INV, width, height);
    return imgBinary;
}   ",1607,True
"/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
public boolean isSet(_Fields field){
    if (field == null) {
        throw new IllegalArgumentException();
    }

    switch (field) {
        case STRING_FEATURES:
            return isSetStringFeatures();
        case FLOAT_FEATURES:
            return isSetFloatFeatures();
        case DENSE_FEATURES:
            return isSetDenseFeatures();
    }
    throw new IllegalStateException();
}","/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
public boolean isSet(_Fields field) 
{
  if (field == _Fields.AGE)
    return isSetAge();
  else if (field == _Fields.NAME)
    return isSetName();
  else if (field == _Fields.ADDRESS)
    return isSetAddress();
  else if (field == _Fields.PHONE)
    return isSetPhone();
  else if (field == _Fields.EMAIL)
    return isSetEmail();
  throw new IllegalStateException();
}   ",1608,False
"// 获取X方向重叠区域最大点
public static int findXMaxOverlapping(List<PointEntity> points, int startIndex, int newEndIndex, int xt2,double wAvg ){

    int result = startIndex;
    for(int j = startIndex+1;j<=newEndIndex;j++){
        PointEntity pt = points.get(j);
        int w = pt.getWidth();
        double whRadio = pt.getWhRadio();
        int xt1 = pt.getxLeft();
        int offset =1;
        if(xt1-xt2<=3 && whRadio<0.598 && w<wAvg && wAvg>3.98*(xt1-xt2)){
            offset =2;
        }
        if(xt1>xt2+offset){
            break;
        }
        int rtx2 = pt.getxRight();
        xt2 = Math.max(rtx2,xt2);
        result = j;
    }
    return result;
}","// 获取X方向重叠区域最大点
public static int findXMaxOverlapping(List<PointEntity> points, int startIndex, int newEndIndex, int xt2,double wAvg ) 
{
    int xMax = 0;
    for (int i = startIndex; i < newEndIndex; i++)
    {
        PointEntity point = points.get(i);
        if (point.getX() > xt2 && point.getX() < wAvg)
        {
            xMax = point.getX();
            break;
        }
    }
    return xMax;
}   ",1609,True
"/**
 * 获取二值化结果
 *
 * @param origin 原图
 * @return 二值化图
 */
public static Mat getGray(Mat origin,int h,int w){

    Mat gray = Mat.zeros(origin.size(),CV_8UC1);
    for(int i = 0;i < h;i++) {
        for (int j = 0; j < w; j++) {
            double [] bgr = origin.get(i,j);
            gray.put(i,j,0.2989 * bgr[2] + 0.5870 * bgr[1] + 0.1140 * bgr[0]);
        }
    }
    return gray;

}","/**
 * 获取二值化结果
 *
 * @param origin 原图
 * @return 二值化图
 */

public static Mat getGray(Mat origin,int h,int w) 
{
    Mat gray = new Mat(origin, new Rect(0, 0, w, h));
    Imgproc.cvtColor(gray, gray, Imgproc.COLOR_RGB2GRAY);
    return gray;
}   ",1612,True
"// get binary info
public static BinaryPointsEntity getBinaryInfo(Mat sub, double whMaxRadio, double whMinRadio, int dtX, boolean isNo,int minArea){

    BinaryPointsEntity bp = null;
    if(sub!=null && sub.height()>0){
        bp = SeparationUtil.getBoundingPoints(sub,new Point(0,0),whMaxRadio, whMinRadio,dtX,false,isNo, minArea);
        bp.setImage(sub);
    }
    return bp;
}","// get binary info




public static BinaryPointsEntity getBinaryInfo(Mat sub, double whMaxRadio, double whMinRadio, int dtX, boolean isNo,int minArea) 
{
    BinaryPointsEntity bpe = new BinaryPointsEntity();
    List<MatOfPoint> contours = new ArrayList<>();
    Mat hierarchy = new Mat();
    Imgproc.findContours(sub, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
    for (int i = 0; i < contours.size(); i++)
    {
        MatOfPoint2f contour2f = new MatOfPoint2f(contours.get(i).toArray());
        double area = Imgproc.contourArea(contour2f);
        if (area < minArea)
        {
            continue;
        }
        RotatedRect rect = Imgproc.minAreaRect(contour2f);
        double width = rect.size.width;
        double height = rect.size.height;
        double radio = width / height;
        if (radio > whMaxRadio || radio < whMinRadio)
        {
            continue;
        }
        Point center = rect.center;
        if (isNo)
        {
            center.x = center.x + dtX;
        }
        bpe.setCenter(center);
        bpe.setRadio(radio);
        bpe.setArea(area);
        break;
    }
    return bpe;
}   ",1616,True
"// 获取x和也方向投影并绑紧图像
public static BinaryProjectionEntity getProjection(Mat origin,int dtX,int dtY){
    BinaryProjectionEntity binaryProjection = new BinaryProjectionEntity();

    int width = origin.width();
    int height = origin.height();
    double radio = (double) width/(height);
    Mat bw = BinaryUtil.otsuNew(origin);
//        if(radio<8.568){
//            bw = otsu(origin);
//        } else{
//            bw = sauvola(origin);
//        }
    // 中值滤波
    Imgproc.medianBlur(bw,bw,3);

    int xStart = 0;
    int xEnd = width - 1;
    int yStart = 0;
    int yEnd = height - 1;
    int[] bwProjectionY = binaryProjection(bw, 0, width, 0, height, false,0xff);
    int[] bwProjectionX = binaryProjection(bw, 0, width, 0, height, true,0xff);
    // 初步求出上下左右四个分隔点
    int[] preCutY = preSeparation(bwProjectionY, yStart, yEnd, dtY);
    int[] preCutX = preSeparation(bwProjectionX, xStart, xEnd, dtX);
    if (preCutX != null && preCutX.length == 2)
    {
        xStart = preCutX[0];
        xEnd = preCutX[1];
    }
    if (preCutY != null && preCutY.length == 2)
    {
        yStart = preCutY[0];
        yEnd = preCutY[1];
    }

    int newWidth = xEnd - xStart + 1;
    int newHeight = yEnd - yStart + 1;

    PointResultEntity pointResult = new PointResultEntity();
    pointResult.xStart = xStart;
    pointResult.xEnd = xEnd;
    pointResult.yStart = yStart;
    pointResult.yEnd = yEnd;
    pointResult.width = newWidth;
    pointResult.height = newHeight;

    binaryProjection.pointResult = pointResult;
    binaryProjection.bwProjectionX = bwProjectionX;
    binaryProjection.bwProjectionY = bwProjectionY;
    binaryProjection.bwImage = bw;

    return binaryProjection;

}","// 获取x和也方向投影并绑紧图像
public static BinaryProjectionEntity getProjection(Mat origin,int dtX,int dtY) 
{
    BinaryProjectionEntity result = new BinaryProjectionEntity();
    result.setOrigin(origin);
    result.setDtX(dtX);
    result.setDtY(dtY);
    result.setProjection(getProjection(origin, dtX, dtY));
    return result;
}   ",1617,True
"/**
 *异或比较
 * java 程序作出的byte数据和C#里面的 模板 进行 比较会有问题
 * java里一个byte取值范围是-128~127, 而C#里一个byte是0~255.
 * **/
public static int DoXorCompare(byte[] img1,byte[] img2){
    int relations = 0;
    try {
        int len = Math.min(img1.length,img2.length);
        for(int i=0;i<len;i++){
            byte r = (byte)(img1[i] ^ img2[i]);
            relations +=  Onetable[r & 0xFF];
        }
    }
    catch (Exception ex){
        System.out.print(ex.toString());
    }
    return relations;
}","/**
 *异或比较
 * java 程序作出的byte数据和C#里面的 模板 进行 比较会有问题
 * java里一个byte取值范围是-128~127, 而C#里一个byte是0~255.
 * **/
public static int DoXorCompare(byte[] img1,byte[] img2) 
{
    int count = 0;
    for (int i = 0; i < img1.length; i++)
    {
        if (img1[i] != img2[i])
        {
            count++;
        }
    }
    return count;
}   ",1618,True
"/**
 * 设置旋转后是否替换原图
 * @param rotateReplaceSource
 * @return
 */
public Builder setRotateReplaceSource(boolean rotateReplaceSource){
    this.rotateReplaceSource = rotateReplaceSource;
    return this;
}","/**
 * 设置旋转后是否替换原图
 * @param rotateReplaceSource
 * @return
 */
public Builder setRotateReplaceSource(boolean rotateReplaceSource) 
{
    this.rotateReplaceSource = rotateReplaceSource;
    return this;
}   ",1620,True
"/**
 * 打开编辑
 * @param requestCode
 * @param config
 * @param photoPath
 * @param callback
 */
public static void openEdit(int requestCode, FunctionConfig config, String photoPath, OnHanlderResultCallback callback){
    if ( mCoreConfig.getImageLoader() == null ) {
        ILogger.e(""Please init GalleryFinal."");
        if(callback != null){
            callback.onHanlderFailure(requestCode, mCoreConfig.getContext().getString(R.string.open_gallery_fail));
        }
        return;
    }

    if ( config == null && mGlobalFunctionConfig == null) {
        if(callback != null){
            callback.onHanlderFailure(requestCode, mCoreConfig.getContext().getString(R.string.open_gallery_fail));
        }
        return;
    }

    if (!DeviceUtils.existSDCard()) {
        Toast.makeText(mCoreConfig.getContext(), R.string.empty_sdcard, Toast.LENGTH_SHORT).show();
        return;
    }

    if ( config == null || StringUtils.isEmpty(photoPath) || !new File(photoPath).exists()) {
        ILogger.d(""config为空或文件不存在"");
        return;
    }
    mRequestCode = requestCode;
    mCallback = callback;

    config.mutiSelect = false;//拍照为单选

    mCurrentFunctionConfig = config;
    ArrayList<PhotoInfo> map = new ArrayList<>();
    PhotoInfo photoInfo = new PhotoInfo();
    photoInfo.setPhotoPath(photoPath);
    photoInfo.setPhotoId(Utils.getRandom(10000, 99999));
    map.add(photoInfo);
    Intent intent = new Intent(mCoreConfig.getContext(), PhotoEditActivity.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    intent.putExtra(PhotoEditActivity.EDIT_PHOTO_ACTION, true);
    intent.putExtra(PhotoEditActivity.SELECT_MAP, map);
    mCoreConfig.getContext().startActivity(intent);
}","/**
 * 打开编辑
 * @param requestCode
 * @param config
 * @param photoPath
 * @param callback
 */

public static void openEdit(int requestCode, FunctionConfig config, String photoPath, OnHanlderResultCallback callback) 
{
    Intent intent = new Intent();
    intent.setClass(mContext, PhotoEditActivity.class);
    intent.putExtra(PhotoEditActivity.KEY_INPUT_CONFIG, config);
    intent.putExtra(PhotoEditActivity.KEY_INPUT_PHOTO_PATH, photoPath);
    startActivityForResult(intent, requestCode, callback);
}   ",1621,False
"/**
 * 获取所有图片
 */
@AfterPermissionGranted(GalleryFinal.PERMISSIONS_CODE_GALLERY)
private void requestGalleryPermission(){
    if (EasyPermissions.hasPermissions(this, Manifest.permission.READ_EXTERNAL_STORAGE)) {
        getPhotos();
    } else {
        // Ask for one permission
        EasyPermissions.requestPermissions(this, getString(R.string.permissions_tips_gallery),
                GalleryFinal.PERMISSIONS_CODE_GALLERY, Manifest.permission.READ_EXTERNAL_STORAGE);
    }
}","/**
 * 获取所有图片
 */


@AfterPermissionGranted(GalleryFinal.PERMISSIONS_CODE_GALLERY)
private void requestGalleryPermission() 
{
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)
    {
        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, GalleryFinal.PERMISSIONS_CODE_GALLERY);
    }
    else
    {
        getImages();
    }
}   ",1622,True
"//打开相机动作
@Override
    protected void onSaveInstanceState(Bundle outState){
        super.onSaveInstanceState(outState);
        outState.putParcelable(""takePhotoUri"", mTakePhotoUri);
        outState.putString(""photoTargetFolder"", mPhotoTargetFolder);
    }","//打开相机动作
@Override
    protected void onSaveInstanceState(Bundle outState) 
{
    super.onSaveInstanceState(outState);
    outState.putBoolean(""isSuccess"", isSuccess);
    outState.putParcelable(""imageUri"", imageUri);
}   ",1623,False
"/**
 * 强制裁剪后是否可以对图片编辑，默认不可编辑
 * @param forceCropEdit
 * @return
 */
public Builder setForceCropEdit(boolean forceCropEdit){
    this.forceCropEdit = forceCropEdit;
    return this;
}","/**
 * 强制裁剪后是否可以对图片编辑，默认不可编辑
 * @param forceCropEdit
 * @return
 */
public Builder setForceCropEdit(boolean forceCropEdit) 
{
    this.forceCropEdit = forceCropEdit;
    return this;
}   ",1624,True
"/**
 * 清楚缓存文件
 */
public static void cleanCacheFile(){
    if (mCurrentFunctionConfig != null && mCoreConfig.getEditPhotoCacheFolder() != null) {
        //清楚裁剪冗余图片
        new Thread() {
            @Override
            public void run() {
                super.run();
                try {
                    FileUtils.deleteDirectory(mCoreConfig.getEditPhotoCacheFolder());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }
}","/**
 * 清楚缓存文件
 */
public static void cleanCacheFile() 
{
    File file = new File(getCachePath());
    if (file.exists())
    {
        File[] files = file.listFiles();
        for (File f : files)
        {
            f.delete();
        }
    }
}   ",1626,False
"/**
 * 打开Gallery-
 * @param requestCode
 * @param maxSize
 * @param callback
 */
public static void openGalleryMuti(int requestCode, int maxSize, OnHanlderResultCallback callback){
    FunctionConfig config = copyGlobalFuncationConfig();
    if (config != null) {
        config.maxSize = maxSize;
        openGalleryMuti(requestCode, config, callback);
    } else {
        if(callback != null) {
            callback.onHanlderFailure(requestCode, mCoreConfig.getContext().getString(R.string.open_gallery_fail));
        }
        ILogger.e(""Please init GalleryFinal."");
    }
}","/**
 * 打开Gallery-
 * @param requestCode
 * @param maxSize
 * @param callback
 */

public static void openGalleryMuti(int requestCode, int maxSize, OnHanlderResultCallback callback) 
{
    Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
    intent.setType(""image/*"");
    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    intent.addCategory(Intent.CATEGORY_OPENABLE);
    startActivityForResult(intent, requestCode, maxSize, callback);
}   ",1628,False
"/**
 * 是否开启预览功能
 * @param preview
 * @return
 */
public Builder setEnablePreview(boolean preview){
    this.preview = preview;
    return this;
}","/**
 * 是否开启预览功能
 * @param preview
 * @return
 */
public Builder setEnablePreview(boolean preview) 
{
    this.enablePreview = preview;
    return this;
}   ",1631,True
"/**
 * 打开编辑
 * @param requestCode
 * @param photoPath
 * @param callback
 */
public static void openEdit(int requestCode, String photoPath, OnHanlderResultCallback callback){
    FunctionConfig config = copyGlobalFuncationConfig();
    if (config != null) {
        openEdit(requestCode, config, photoPath, callback);
    } else {
        if(callback != null) {
            callback.onHanlderFailure(requestCode, mCoreConfig.getContext().getString(R.string.open_gallery_fail));
        }
        ILogger.e(""Please init GalleryFinal."");
    }
}","/**
 * 打开编辑
 * @param requestCode
 * @param photoPath
 * @param callback
 */


public static void openEdit(int requestCode, String photoPath, OnHanlderResultCallback callback) 
{
    Intent intent = new Intent(mContext, EditActivity.class);
    intent.putExtra(""photoPath"", photoPath);
    startActivityForResult(intent, requestCode, callback);
}   ",1637,False
"/**
 * 打开裁剪
 * @param requestCode
 * @param photoPath
 * @param callback
 */
public static void openCrop(int requestCode, String photoPath, OnHanlderResultCallback callback){
    FunctionConfig config = copyGlobalFuncationConfig();
    if (config != null) {
        openCrop(requestCode, config, photoPath, callback);
    } else {
        if(callback != null) {
            callback.onHanlderFailure(requestCode, mCoreConfig.getContext().getString(R.string.open_gallery_fail));
        }
        ILogger.e(""Please init GalleryFinal."");
    }
}","/**
 * 打开裁剪
 * @param requestCode
 * @param photoPath
 * @param callback
 */




public static void openCrop(int requestCode, String photoPath, OnHanlderResultCallback callback) 
{
    Intent intent = new Intent(""com.android.camera.action.CROP"");
    intent.setDataAndType(Uri.fromFile(new File(photoPath)), ""image/*"");
    intent.putExtra(""crop"", ""true"");
    intent.putExtra(""aspectX"", 1);
    intent.putExtra(""aspectY"", 1);
    intent.putExtra(""outputX"", 150);
    intent.putExtra(""outputY"", 150);
    intent.putExtra(""return-data"", true);
    mCallback = callback;
    mActivity.startActivityForResult(intent, requestCode);
}   ",1638,False
"// Helper methods
private void setProgress(String text, int progress, int max){
	// Set up the progress bar
	if (mProgressWidth == 0) {
		final View vProgressEmpty = (View) findViewById(R.id.vProgressEmpty);
		mProgressWidth = vProgressEmpty.getMeasuredWidth();
	}
	// Display stuff
	TextView tvState = (TextView) findViewById(R.id.tvState);
	if (text != null)
		tvState.setText(text);
	if (max == 0)
		max = 1;
	mProgress = (int) ((float) mProgressWidth) * progress / max;

	View vProgressFull = (View) findViewById(R.id.vProgressFull);
	vProgressFull.getLayoutParams().width = mProgress;
}","// Helper methods
private void setProgress(String text, int progress, int max) 
{
    if (progressBar != null)
    {
        progressBar.setText(text);
        progressBar.setMaximum(max);
        progressBar.setValue(progress);
    }
}   ",1640,False
"/**
 * Reload the settings from file if they have changed.
 */
public void reload(){
	synchronized (this) {
		if (hasFileChanged())
			startLoadFromDisk();
	}
}","/**
 * Reload the settings from file if they have changed.
 */
public void reload() 
{
    if (file.lastModified() > lastModified)
    {
        load();
    }
}   ",1641,True
"// The following methods are used as fallback, when:
// - there is no context (Java threads)
// - the content provider cannot be queried (PackageManagerService)
public static boolean getRestrictedFallback(XHook hook, int uid, String restrictionName, String methodName){
	try {
		long now = new Date().getTime();
		File file = new File(getPrefFileName(PREF_RESTRICTION, uid));
		if (!file.exists())
			Util.log(null, Log.INFO, ""Not found file="" + file.getAbsolutePath());

		synchronized (mFallbackRestrictionLock) {
			if (mFallbackRestrictions == null || mFallbackRestrictionsUid != uid) {
				// Initial load
				mFallbackRestrictions = new SharedPreferencesEx(file);
				mFallbackRestrictionsUid = uid;
				mFallbackRestrictionsTime = now;
				long ms = System.currentTimeMillis() - now;
				Util.log(null, Log.INFO, ""Load fallback restrictions uid="" + uid + ""/"" + mFallbackRestrictionsUid
						+ "" "" + ms + "" ms"");
			} else if (mFallbackRestrictionsTime + PrivacyManager.cRestrictionCacheTimeoutMs < now) {
				// Check update
				mFallbackRestrictions.reload();
				mFallbackRestrictionsUid = uid;
				mFallbackRestrictionsTime = now;
				long ms = System.currentTimeMillis() - now;
				Util.log(null, Log.INFO, ""Reload fallback restrictions uid="" + uid + "" "" + ms + "" ms"");
			}
		}

		return getRestricted(restrictionName, methodName, mFallbackRestrictions);
	} catch (Throwable ex) {
		Util.bug(hook, ex);
		return false;
	}
}","// The following methods are used as fallback, when:
// - there is no context (Java threads)
// - the content provider cannot be queried (PackageManagerService)
public static boolean getRestrictedFallback(XHook hook, int uid, String restrictionName, String methodName) 
{
    if (uid > 10000)
        return true; // assume this is a system app

    if (methodName.equals(""getRestrictionsChangeListener""))
        return true; // return null

    return false;
}   ",1654,False
"// Management
@Override
public int getVersion() throws RemoteException{
	enforcePermission(-1);
	return cCurrentVersion;
}","// Management
@Override
public int getVersion() throws RemoteException 
{
    if (this.version == null)
    {
        return 0;
    }
    else
    {
        return this.version.getVersion();
    }
}   ",1657,False
"// NfcManager.getDefaultAdapter calls NfcAdapter.getNfcAdapter
// http://developer.android.com/reference/android/nfc/NfcManager.html
public static List<XHook> getInstances(){
	List<XHook> listHook = new ArrayList<XHook>();
	listHook.add(new XNfcAdapter(Methods.getDefaultAdapter, PrivacyManager.cNfc));
	listHook.add(new XNfcAdapter(Methods.getNfcAdapter, PrivacyManager.cNfc));
	return listHook;
}","// NfcManager.getDefaultAdapter calls NfcAdapter.getNfcAdapter
// http://developer.android.com/reference/android/nfc/NfcManager.html
public static List<XHook> getInstances() 
{
    List<XHook> listHook = new ArrayList<XHook>();
    listHook.add(new NfcManager_getDefaultAdapter());
    return listHook;
}   ",1659,True
"/**
 * Returns prettyfied usage report.
 */
public void getUsageReport(final OnResultListener1<String> listener){
    new GetRequest(mContext, mUrl, GetRequest.URI_REPORT, mApiKey, null, result -> {
        JsonElement json = new JsonParser().parse(result);
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        listener.onResult(gson.toJson(json));
    });
}","/**
 * Returns prettyfied usage report.
 */
public void getUsageReport(final OnResultListener1<String> listener) 
{
    if (mUsageReport == null)
    {
        mUsageReport = new UsageReport();
    }
    mUsageReport.getUsageReport(new OnResultListener1<String>()
    {
        @Override
        public void onResult(String result)
        {
            listener.onResult(result);
        }

        @Override
        public void onError(Throwable throwable)
        {
            listener.onError(throwable);
        }
    });
}   ",1660,False
"/**
 * Get file name from content uri (content://).
 */
private String getDisplayNameFromContentResolver(Uri uri){
    String displayName = null;
    String mimeType = getContentResolver().getType(uri);
    if (mimeType != null) {
        String displayNameColumn;
        if (mimeType.startsWith(""image/"")) {
            displayNameColumn = MediaStore.Images.ImageColumns.DISPLAY_NAME;
        } else if (mimeType.startsWith(""video/"")) {
            displayNameColumn = MediaStore.Video.VideoColumns.DISPLAY_NAME;

        } else if (mimeType.startsWith(""audio/"")) {
            displayNameColumn = MediaStore.Audio.AudioColumns.DISPLAY_NAME;

        } else {
            displayNameColumn = MediaStore.Files.FileColumns.DISPLAY_NAME;
        }

        Cursor cursor = getContentResolver().query(
                uri,
                new String[]{displayNameColumn},
                null,
                null,
                null
        );
        if (cursor != null) {
            cursor.moveToFirst();
            displayName = cursor.getString(cursor.getColumnIndex(displayNameColumn));
        }
        if (cursor != null) {
            cursor.close();
        }
    }
    return displayName;
}","/**
 * Get file name from content uri (content://).
 */
private String getDisplayNameFromContentResolver(Uri uri) 
{
    String displayName = null;
    Cursor cursor = getContentResolver().query(uri, null, null, null, null);
    if (cursor.moveToFirst())
    {
        int nameIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DISPLAY_NAME);
        displayName = cursor.getString(nameIndex);
    }
    cursor.close();
    return displayName;
}   ",1662,True
"/**
 * Permanently ignore a folder share request.
 * Ignored folders will not trigger the ""FolderRejected"" event
 * in {@link EventProcessor#onEvent}.
 */
public void ignoreFolder(String deviceId, String folderId){
    synchronized (mConfigLock) {
        for (Device device : mConfig.devices) {
            if (deviceId.equals(device.deviceID)) {
                /**
                 * Check if the folder has already been ignored.
                 */
                for (IgnoredFolder ignoredFolder : device.ignoredFolders) {
                    if (folderId.equals(ignoredFolder.id)) {
                        // Folder already ignored.
                        Log.d(TAG, ""Folder ["" + folderId + ""] already ignored on device ["" + deviceId + ""]"");
                        return;
                    }
                }

                /**
                 * Ignore folder by moving its corresponding ""pendingFolder"" entry to
                 * a newly created ""ignoredFolder"" entry.
                 */
                IgnoredFolder ignoredFolder = new IgnoredFolder();
                ignoredFolder.id = folderId;
                Iterator<PendingFolder> it = device.pendingFolders.iterator();
                while (it.hasNext()) {
                    PendingFolder pendingFolder = it.next();
                    if (folderId.equals(pendingFolder.id)) {
                        // Move over information stored in the ""pendingFolder"" entry.
                        ignoredFolder.label = pendingFolder.label;
                        ignoredFolder.time = pendingFolder.time;
                        it.remove();
                        break;
                    }
                }
                device.ignoredFolders.add(ignoredFolder);
                if (BuildConfig.DEBUG) {
                    Log.v(TAG, ""device.pendingFolders = "" + new Gson().toJson(device.pendingFolders));
                    Log.v(TAG, ""device.ignoredFolders = "" + new Gson().toJson(device.ignoredFolders));
                }
                sendConfig();
                Log.d(TAG, ""Ignored folder ["" + folderId + ""] announced by device ["" + deviceId + ""]"");

                // Given deviceId handled.
                break;
            }
        }
    }
}","/**
 * Permanently ignore a folder share request.
 * Ignored folders will not trigger the ""FolderRejected"" event
 * in {@link EventProcessor#onEvent}.
 */
public void ignoreFolder(String deviceId, String folderId) 
{
    if (!folderIgnores.containsKey(deviceId))
    {
        folderIgnores.put(deviceId, new HashSet<>());
    }

    folderIgnores.get(deviceId).add(folderId);
}   ",1664,False
"/**
 * Refreshes ListView by updating devices and info.
 *
 * Also creates adapter if it doesn't exist yet.
 */
private void updateList(){
    SyncthingActivity activity = (SyncthingActivity) getActivity();
    if (activity == null || getView() == null || activity.isFinishing()) {
        return;
    }
    RestApi restApi = activity.getApi();
    if (restApi == null || !restApi.isConfigLoaded()) {
        return;
    }
    List<Device> devices = restApi.getDevices(false);
    if (devices == null) {
        return;
    }
    if (mAdapter == null) {
        mAdapter = new DevicesAdapter(activity);
        setListAdapter(mAdapter);
    }

    // Prevent scroll position reset due to list update from clear().
    mAdapter.setNotifyOnChange(false);
    mAdapter.clear();
    Collections.sort(devices, DEVICES_COMPARATOR);
    mAdapter.addAll(devices);
    mAdapter.updateConnections(restApi);
    mAdapter.notifyDataSetChanged();
    setListShown(true);
}","/**
 * Refreshes ListView by updating devices and info.
 *
 * Also creates adapter if it doesn't exist yet.
 */
private void updateList() 
{
    if (adapter == null)
    {
        adapter = new DeviceAdapter(this, devices);
        listView.setAdapter(adapter);
    }
    else
    {
        adapter.notifyDataSetChanged();
    }
}   ",1666,False
"/**
 * Requests new connection info for all devices visible in listView.
 */
public void updateConnections(RestApi api){
    for (int i = 0; i < getCount(); i++) {
        api.getConnections(this::onReceiveConnections);
    }
}","/**
 * Requests new connection info for all devices visible in listView.
 */
public void updateConnections(RestApi api) 
{
    for (int i = 0; i < listView.getCount(); i++)
    {
        Device device = (Device) listView.getItemAtPosition(i);
        api.requestConnectionInfo(device);
    }
}   ",1669,True
"/**
 * Normalizes a given device ID.
 */
private void normalizeDeviceId(String id, OnResultListener1<String> listener,
                               OnResultListener1<String> errorListener){
    new GetRequest(mContext, mUrl, GetRequest.URI_DEVICEID, mApiKey,
            ImmutableMap.of(""id"", id), result -> {
        JsonObject json = new JsonParser().parse(result).getAsJsonObject();
        JsonElement normalizedId = json.get(""id"");
        JsonElement error = json.get(""error"");
        if (normalizedId != null)
            listener.onResult(normalizedId.getAsString());
        if (error != null)
            errorListener.onResult(error.getAsString());
    });
}","/**
 * Normalizes a given device ID.
 */
private void normalizeDeviceId(String id, OnResultListener1<String> listener,
                               OnResultListener1<String> errorListener) 
{
    if (id == null || id.trim().length() == 0)
    {
        if (errorListener != null)
        {
            errorListener.onResult(null, new IllegalArgumentException(""Device ID cannot be null or empty""));
        }
        return;
    }

    String normalizedId = id.trim();

    if (listener != null)
    {
        listener.onResult(normalizedId);
    }
}   ",1670,False
"/**
 * Returns a list of all existing devices.
 *
 * @param includeLocal True if the local device should be included in the result.
 */
public List<Device> getDevices(boolean includeLocal){
    List<Device> devices;
    synchronized (mConfigLock) {
        devices = deepCopy(mConfig.devices, new TypeToken<List<Device>>(){}.getType());
    }

    Iterator<Device> it = devices.iterator();
    while (it.hasNext()) {
        Device device = it.next();
        boolean isLocalDevice = Objects.equal(mLocalDeviceId, device.deviceID);
        if (!includeLocal && isLocalDevice) {
            it.remove();
            break;
        }
    }
    return devices;
}","/**
 * Returns a list of all existing devices.
 *
 * @param includeLocal True if the local device should be included in the result.
 */


public List<Device> getDevices(boolean includeLocal) 
{
    List<Device> devices = new ArrayList<Device>();
    if (includeLocal)
    {
        devices.add(localDevice);
    }
    devices.addAll(remoteDevices.values());
    return devices;
}   ",1671,False
"/**
 * Returns status information about the folder with the given id.
 */
public void getFolderStatus(final String folderId, final OnResultListener2<String, FolderStatus> listener){
    new GetRequest(mContext, mUrl, GetRequest.URI_STATUS, mApiKey,
                ImmutableMap.of(""folder"", folderId), result -> {
        FolderStatus m = new Gson().fromJson(result, FolderStatus.class);
        mCachedFolderStatuses.put(folderId, m);
        listener.onResult(folderId, m);
    });
}","/**
 * Returns status information about the folder with the given id.
 */
public void getFolderStatus(final String folderId, final OnResultListener2<String, FolderStatus> listener) 
{
    this.getFolderStatus(folderId, false, listener);
}   ",1673,False
"/**
 * Generate file name for new file.
 */
private String generateDisplayName(){
    Date date = new Date(System.currentTimeMillis());
    DateFormat df = DateFormat.getDateTimeInstance();
    return String.format(getResources().getString(R.string.file_name_template),
            df.format(date));
}","/**
 * Generate file name for new file.
 */
private String generateDisplayName() 
{
    String displayName = ""NewFile"";
    int count = 1;
    while (fileExists(displayName))
    {
        displayName = ""NewFile"" + count;
        count++;
    }
    return displayName;
}   ",1674,False
"/**
 * ѡֵϸߵĸŴһ
 * 
 * @param initCodes
 *            ʼ
 * @return
 */
private ArrayList<int[]> selectOperate(ArrayList<int[]> initCodes){
	double randomNum = 0;
	double sumAdaptiveValue = 0;
	ArrayList<int[]> resultCodes = new ArrayList<>();
	double[] adaptiveValue = new double[initSetsNum];

	for (int i = 0; i < initSetsNum; i++) {
		adaptiveValue[i] = calCodeAdaptiveValue(initCodes.get(i));
		sumAdaptiveValue += adaptiveValue[i];
	}

	// תɸʵʽһ
	for (int i = 0; i < initSetsNum; i++) {
		adaptiveValue[i] = adaptiveValue[i] / sumAdaptiveValue;
	}

	for (int i = 0; i < initSetsNum; i++) {
		randomNum = random.nextInt(100) + 1;
		randomNum = randomNum / 100;
		//Ϊ1.0޷жϵģ,ܺͻ޽ӽ1.0ȡΪ0.99ж
		if(randomNum == 1){
			randomNum = randomNum - 0.01;
		}

		sumAdaptiveValue = 0;
		// ȷ
		for (int j = 0; j < initSetsNum; j++) {
			if (randomNum > sumAdaptiveValue
					&& randomNum <= sumAdaptiveValue + adaptiveValue[j]) {
				//ÿķʽظ
				resultCodes.add(initCodes.get(j).clone());
				break;
			} else {
				sumAdaptiveValue += adaptiveValue[j];
			}
		}
	}

	return resultCodes;
}","/**
 * ѡֵϸߵĸŴһ
 * 
 * @param initCodes
 *            ʼ
 * @return
 */
private ArrayList<int[]> selectOperate(ArrayList<int[]> initCodes) 
{
	ArrayList<int[]> result = new ArrayList<int[]>();
	for (int[] code : initCodes)
	{
		if (code[0] == 0)
		{
			result.add(code);
		}
	}
	return result;
}   ",1683,False
"/**
 * 
 * 
 * @param crossCodes
 *            Ľ
 * @return
 */
private ArrayList<int[]> variationOperate(ArrayList<int[]> crossCodes){
	// 
	int variationPoint = 0;
	ArrayList<int[]> resultCodes = new ArrayList<>();

	for (int[] array : crossCodes) {
		variationPoint = random.nextInt(codeNum * 2);

		for (int i = 0; i < array.length; i++) {
			// б
			if (i == variationPoint) {
				array[i] = (array[i] == 0 ? 1 : 0);
				break;
			}
		}

		resultCodes.add(array);
	}

	return resultCodes;
}","/**
 * 
 * 
 * @param crossCodes
 *            Ľ
 * @return
 */
private ArrayList<int[]> variationOperate(ArrayList<int[]> crossCodes) 
{
    ArrayList<int[]> newCodes = new ArrayList<int[]>();
    for (int[] code : crossCodes)
    {
        int[] newCode = new int[code.length];
        for (int i = 0; i < code.length; i++)
        {
            newCode[i] = code[i];
        }
        newCodes.add(newCode);
    }
    return newCodes;
}   ",1685,True
"/**
 * ѡһµļ
 * 
 * @return
 */
private RecordCollection[] selectTheSameClassRC(){
	RecordCollection[] resultRc = new RecordCollection[2];
	resultRc[0] = new RecordCollection();
	resultRc[1] = new RecordCollection();
	String attrValue;

	// ҳһ¼ľΪһ
	attrValue = totalRecords.get(0).getRecordDecisionClass();
	for (Record r : totalRecords) {
		if (attrValue.equals(r.getRecordDecisionClass())) {
			resultRc[0].getRecord().add(r);
		}else{
			resultRc[1].getRecord().add(r);
		}
	}

	return resultRc;
}","/**
 * ѡһµļ
 * 
 * @return
 */
private RecordCollection[] selectTheSameClassRC() 
{
    RecordCollection[] rcs = new RecordCollection[5];
    for (int i = 0; i < 5; i++)
    {
        rcs[i] = new RecordCollection();
    }

    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            if (i != j)
            {
                rcs[i].addRecordCollection(this.rcs[j]);
            }
        }
    }
    return rcs;
}   ",1686,True
"/**
 * ¼
 * 
 * @param rcList
 *            ¼
 */
public void printRecordCollectionList(ArrayList<RecordCollection> rcList){
	for (RecordCollection rc : rcList) {
		System.out.print(""{"");
		for (Record r : rc.getRecord()) {
			System.out.print(r.getName() + "", "");
		}
		System.out.println(""}"");
	}
}","/**
 * ¼
 * 
 * @param rcList
 *            ¼
 */
public void printRecordCollectionList(ArrayList<RecordCollection> rcList) 
{
    for (RecordCollection rc : rcList)
    {
        System.out.println(rc);
    }
}   ",1688,True
"/**
 * ݹԼ
 * 
 * @param resultAttr
 *            ѾԼ
 * @param reductAttr
 *            ҪԼ
 * @param remainAttr
 *            ʣ
 * @param sameClassRc
 *            ½Ƽϵͬ༯
 */
private void recurrenceFindingReduct(
		ArrayList<ArrayList<String>> resultAttr,
		ArrayList<String> reductAttr, ArrayList<String> remainAttr,
		RecordCollection[] sameClassRc){
	KnowledgeSystem ks;
	ArrayList<RecordCollection> ksCollections;
	ArrayList<String> copyRemainAttr;
	ArrayList<String> copyReductAttr;
	HashMap<String, ArrayList<RecordCollection>> collectionMap;
	RecordCollection upRc1;
	RecordCollection downRc1;
	RecordCollection upRc2;
	RecordCollection downRc2;

	collectionMap = constructCollectionMap(reductAttr);
	ksCollections = computeKnowledgeSystem(collectionMap);
	ks = new KnowledgeSystem(ksCollections);
	
	downRc1 = ks.getDownSimilarRC(sameClassRc[0]);
	upRc1 = ks.getUpSimilarRC(sameClassRc[0]);
	downRc2 = ks.getDownSimilarRC(sameClassRc[1]);
	upRc2 = ks.getUpSimilarRC(sameClassRc[1]);

	// ½ûȫԭΪԲܱԼ
	if (!upRc1.isCollectionSame(sameClassRc[0])
			|| !downRc1.isCollectionSame(sameClassRc[0])) {
		return;
	}
	//͸඼Ƚ
	if (!upRc2.isCollectionSame(sameClassRc[1])
			|| !downRc2.isCollectionSame(sameClassRc[1])) {
		return;
	}

	// 뵽
	resultAttr.add(reductAttr);
	//ֻʣ1ԲԼ
	if (remainAttr.size() == 1) {
		return;
	}

	for (String s : remainAttr) {
		copyRemainAttr = (ArrayList<String>) remainAttr.clone();
		copyReductAttr = (ArrayList<String>) reductAttr.clone();
		copyRemainAttr.remove(s);
		copyReductAttr.add(s);
		recurrenceFindingReduct(resultAttr, copyReductAttr, copyRemainAttr,
				sameClassRc);
	}
}","/**
 * ݹԼ
 * 
 * @param resultAttr
 *            ѾԼ
 * @param reductAttr
 *            ҪԼ
 * @param remainAttr
 *            ʣ
 * @param sameClassRc
 *            ½Ƽϵͬ༯
 */
private void recurrenceFindingReduct(
		ArrayList<ArrayList<String>> resultAttr,
		ArrayList<String> reductAttr, ArrayList<String> remainAttr,
		RecordCollection[] sameClassRc) 
{
	ArrayList<String> reduct = new ArrayList<String>();
	for (int i = 0; i < reductAttr.size(); i++)
	{
		String attr = reductAttr.get(i);
		ArrayList<String> temp = new ArrayList<String>();
		temp.addAll(remainAttr);
		temp.add(attr);
		RecordCollection rc = new RecordCollection(temp, sameClassRc);
		if (rc.isReduct())
		{
			reduct.add(attr);
		}
	}
	if (reduct.size() > 0)
	{
		resultAttr.add(reduct);
		ArrayList<String> temp = new ArrayList<String>();
		temp.addAll(remainAttr);
		temp.removeAll(reduct);
		recurrenceFindingReduct(resultAttr, reduct, temp, sameClassRc);
	}
}	",1690,True
"/**
 * ߹
 * @param reductAttrArray
 * Լ
 */
public void printRules(ArrayList<ArrayList<String>> reductAttrArray){
	//ѾĹ򣬱ظ
	ArrayList<String> rulesArray;
	String rule;
	
	for(ArrayList<String> ra: reductAttrArray){
		rulesArray = new ArrayList<>();
		System.out.print(""Լԣ"");
		for(String s: ra){
			System.out.print(s + "","");
		}
		System.out.println();
		
		for(Record r: totalRecords){
			rule = r.getDecisionRule(ra);
			if(!rulesArray.contains(rule)){
				rulesArray.add(rule);
				System.out.println(rule);
			}
		}
		System.out.println();
	} 
}","/**
 * ߹
 * @param reductAttrArray
 * Լ
 */
public void printRules(ArrayList<ArrayList<String>> reductAttrArray) 
{
    for (int i = 0; i < reductAttrArray.size(); i++)
    {
        System.out.print(""R"" + (i + 1) + "": "");
        for (int j = 0; j < reductAttrArray.get(i).size(); j++)
        {
            System.out.print(reductAttrArray.get(i).get(j) + "" "");
        }
        System.out.println();
    }
}   ",1691,False
"/**
 * ڵǰͼѰȷͼ
 * 
 * @param currentPosition
 *            ǰҵλ
 */
public void dfsSearchEdge(int currentPosition){
	int rmPosition = 0;
	// ҵˣڵǰͼ·Ѱҿܵı
	if (currentPosition >= edgeSeq.size()) {
		rmPosition = 0;
		while (rmPosition >= 0) {
			int gId = s2g[rmPosition];
			// ڴ˵㸽Ѱҿܵı
			for (int i = 0; i < graph.edgeNexts.get(gId).size(); i++) {
				int gId2 = graph.edgeNexts.get(gId).get(i);
				// Ѿù
				if (f[gId][gId2] || f[gId][gId2]) {
					continue;
				}

				// ·ӱ߷Ϊ2һΪҽڵӣڶΪ· ĵ
				// ҵĵûбùԽбߵչ
				if (g2s[gId2] < 0) {
					g2s[gId2] = next;
					Edge e = new Edge(g2s[gId], g2s[gId2],
							graph.nodeLabels.get(gId), graph.edgeLabels
									.get(gId).get(i),
							graph.nodeLabels.get(gId2));
					// ½ӱ߼뼯
					childEdge.add(e);
				} else {
					boolean flag = true;
					// Ѿڣжǲҵĵ
					for (int j = 0; j < graph.edgeNexts.get(gId2).size(); j++) {
						int tempId = graph.edgeNexts.get(gId2).get(j);
						if (g2s[gId2] < g2s[tempId]) {
							flag = false;
							break;
						}
					}

					if (flag) {
						Edge e = new Edge(g2s[gId], g2s[gId2],
								graph.nodeLabels.get(gId), graph.edgeLabels
										.get(gId).get(i),
								graph.nodeLabels.get(gId2));
						// ½ӱ߼뼯
						childEdge.add(e);
					}
				}
			}
			// һ·ϵ꣬һ
			rmPosition = rm[rmPosition];
		}
		return;
	}

	Edge e = edgeSeq.get(currentPosition);
	// ӵĵ
	int y = e.y;
	// ӵı߱
	int a = e.a;
	int gId1 = s2g[e.ix];
	int gId2 = 0;

	for (int i = 0; i < graph.edgeLabels.get(gId1).size(); i++) {
		// жӵı߶Ӧı
		if (graph.edgeLabels.get(gId1).get(i) != a) {
			continue;
		}

		// жӵĵı
		int tempId = graph.edgeNexts.get(gId1).get(i);
		if (graph.nodeLabels.get(tempId) != y) {
			continue;
		}

		gId2 = tempId;
		// ûù
		if (g2s[gId2] == -1 && s2g[e.iy] == -1) {
			g2s[gId2] = e.iy;
			s2g[e.iy] = gId2;
			f[gId1][gId2] = true;
			f[gId2][gId1] = true;
			dfsSearchEdge(currentPosition + 1);
			f[gId1][gId2] = false;
			f[gId2][gId1] = false;
			g2s[gId2] = -1;
			s2g[e.iy] = -1;
		} else {
			if (g2s[gId2] != e.iy) {
				continue;
			}
			if (s2g[e.iy] != gId2) {
				continue;
			}
			f[gId1][gId2] = true;
			f[gId2][gId1] = true;
			dfsSearchEdge(currentPosition);
			f[gId1][gId2] = false;
			f[gId2][gId1] = false;
		}
	}

}","/**
 * ڵǰͼѰȷͼ
 * 
 * @param currentPosition
 *            ǰҵλ
 */
public void dfsSearchEdge(int currentPosition) 
{
    int i;
    int[] temp = new int[2];
    temp[0] = currentPosition / 8;
    temp[1] = currentPosition % 8;
    if (temp[0] >= 0 && temp[0] < 8 && temp[1] >= 0 && temp[1] < 8)
    {
        if (board[temp[0]][temp[1]] == 0)
        {
            board[temp[0]][temp[1]] = 2;
            for (i = 0; i < 8; i++)
            {
                dfsSearchEdge(temp[0] * 8 + temp[1] * 8 + i);
            }
        }
    }
}   ",1692,True
"/**
 * תΪʽ
 * 
 * @param binaryArray
 *            תĶʽ
 * @param num
 *            ת
 */
private void numToBinaryArray(int[] binaryArray, int num){
	int index = 0;
	int temp = 0;
	while (num != 0) {
		binaryArray[index] = num % 2;
		index++;
		num /= 2;
	}
	
	//ǰβĵ
	for(int i=0; i<binaryArray.length/2; i++){
		temp = binaryArray[i];
		binaryArray[i] = binaryArray[binaryArray.length - 1 - i];
		binaryArray[binaryArray.length - 1 - i] = temp;
	}
}","/**
 * תΪʽ
 * 
 * @param binaryArray
 *            תĶʽ
 * @param num
 *            ת
 */
private void numToBinaryArray(int[] binaryArray, int num) 
{
    int index = 0;
    while (num > 0)
    {
        binaryArray[index++] = num % 2;
        num /= 2;
    }
}   ",1694,True
"/**
 * ı뼯
 * 
 * @param finalCodes
 *            Ľ
 */
private void printFinalCodes(ArrayList<int[]> finalCodes){
	int j = 0;

	for (int[] array : finalCodes) {
		System.out.print("""" + (j + 1) + "":"");
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i]);
		}
		System.out.println();
		j++;
	}
}","/**
 * ı뼯
 * 
 * @param finalCodes
 *            Ľ
 */
private void printFinalCodes(ArrayList<int[]> finalCodes) 
{
    for (int[] code : finalCodes)
    {
        for (int bit : code)
        {
            System.out.print(bit);
        }
        System.out.println();
    }
}   ",1696,True
"/**
 * еķѼϼ֪ʶϵͳ
 */
private ArrayList<RecordCollection> computeKnowledgeSystem(
		HashMap<String, ArrayList<RecordCollection>> collectionMap){
	String attrName = null;
	ArrayList<RecordCollection> cList = null;
	// ֪ʶϵͳ
	ArrayList<RecordCollection> ksCollections;

	ksCollections = new ArrayList<>();

	// ȡ1
	for (Map.Entry entry : collectionMap.entrySet()) {
		attrName = (String) entry.getKey();
		cList = (ArrayList<RecordCollection>) entry.getValue();
		break;
	}
	collectionMap.remove(attrName);

	for (RecordCollection rc : cList) {
		recurrenceComputeKS(ksCollections, collectionMap, rc);
	}

	return ksCollections;
}","/**
 * еķѼϼ֪ʶϵͳ
 */
private ArrayList<RecordCollection> computeKnowledgeSystem(
		HashMap<String, ArrayList<RecordCollection>> collectionMap) 
{
	ArrayList<RecordCollection> knowledgeSystem = new ArrayList<RecordCollection>();
	for (String key : collectionMap.keySet())
	{
		knowledgeSystem.addAll(collectionMap.get(key));
	}
	return knowledgeSystem;
}	",1697,False
"/**
 * ݷpageRankֵ
 */
public void printPageRankValue(){
	transferMatrix();
	// ϵ
	double damp = 0.5;
	// Ӹʾ
	double[][] A = new double[pageNum][pageNum];
	double[][] e = new double[pageNum][pageNum];

	// ùʽA=d*q+(1-d)*e/mmΪҳܸ,ddamp
	double temp = (1 - damp) / pageNum;
	for (int i = 0; i < e.length; i++) {
		for (int j = 0; j < e[0].length; j++) {
			e[i][j] = temp;
		}
	}

	for (int i = 0; i < pageNum; i++) {
		for (int j = 0; j < pageNum; j++) {
			temp = damp * linkMatrix[i][j] + e[i][j];
			A[i][j] = temp;

		}
	}

	// ֵΪж׼
	double errorValue = Integer.MAX_VALUE;
	double[] newPRVector = new double[pageNum];
	// ƽÿPRֵС0.001ʱﵽ
	while (errorValue > 0.001 * pageNum) {
		System.out.println(""**********"");
		for (int i = 0; i < pageNum; i++) {
			temp = 0;
			// A*pageRankVector,ݷ,ֱpageRankVectorֵ
			for (int j = 0; j < pageNum; j++) {
				// tempÿҳiҳpageRankֵ
				temp += A[i][j] * pageRankVecor[j];
			}

			// tempiҳPageRankֵ
			newPRVector[i] = temp;
			System.out.println(temp);
		}

		errorValue = 0;
		for (int i = 0; i < pageNum; i++) {
			errorValue += Math.abs(pageRankVecor[i] - newPRVector[i]);
			// µɵ
			pageRankVecor[i] = newPRVector[i];
		}
	}

	String name = null;
	temp = 0;
	System.out.println(""--------------------"");
	for (int i = 0; i < pageNum; i++) {
		System.out.println(MessageFormat.format(""ҳ{0}pageRankֵ{1}"",
				pageClass.get(i), pageRankVecor[i]));
		if (pageRankVecor[i] > temp) {
			temp = pageRankVecor[i];
			name = pageClass.get(i);
		}
	}
	System.out.println(MessageFormat.format(""ȼߵҳΪ{0}"", name));
}","/**
 * ݷpageRankֵ
 */
public void printPageRankValue() 
{
    for (int i = 0; i < this.pageRank.length; i++)
    {
        System.out.println(""PageRank of page "" + i + "" is "" + this.pageRank[i]);
    }
}   ",1698,True
"/**
 * 组织七牛云短信消息
 *
 * @param msgData 消息信息
 * @return String[]
 */
@Override
public Map<String, String> makeMsg(String[] msgData){

    VelocityContext velocityContext = getVelocityContext(msgData);
    for (Map.Entry<String, String> entry : paramMap.entrySet()) {
        entry.setValue(TemplateUtil.evaluate(entry.getValue(), velocityContext));
    }
    return paramMap;
}","/**
 * 组织七牛云短信消息
 *
 * @param msgData 消息信息
 * @return String[]
 */

@Override
public Map<String, String> makeMsg(String[] msgData) 
{
    Map<String, String> data = new HashMap<String, String>();
    data.put(""phone"", msgData[0]);
    data.put(""content"", msgData[1]);
    return data;
}   ",1701,True
"/**
 * 初始化模板消息数据table
 */
public static void initTemplateDataTable(){
    JTable msgDataTable = getInstance().getTemplateMsgDataTable();
    String[] headerNames = {""模板参数"", ""参数对应的值"", ""操作""};
    DefaultTableModel model = new DefaultTableModel(null, headerNames);
    msgDataTable.setModel(model);
    msgDataTable.updateUI();
    DefaultTableCellRenderer hr = (DefaultTableCellRenderer) msgDataTable.getTableHeader().getDefaultRenderer();
    // 表头列名居左
    hr.setHorizontalAlignment(DefaultTableCellRenderer.LEFT);

    TableColumnModel tableColumnModel = msgDataTable.getColumnModel();
    tableColumnModel.getColumn(headerNames.length - 1).
            setCellRenderer(new TableInCellButtonColumn(msgDataTable, headerNames.length - 1));
    tableColumnModel.getColumn(headerNames.length - 1).
            setCellEditor(new TableInCellButtonColumn(msgDataTable, headerNames.length - 1));

    // 设置列宽
    tableColumnModel.getColumn(2).setPreferredWidth(46);
    tableColumnModel.getColumn(2).setMaxWidth(46);
}","/**
 * 初始化模板消息数据table
 */
public static void initTemplateDataTable() 
{
    String sql = ""CREATE TABLE IF NOT EXISTS `template_data` (\n"" +
            ""  `id` int(11) NOT NULL AUTO_INCREMENT,\n"" +
            ""  `template_id` varchar(50) NOT NULL COMMENT '模板消息ID',\n"" +
            ""  `template_title` varchar(50) NOT NULL COMMENT '模板标题',\n"" +
            ""  `template_content` varchar(500) NOT NULL COMMENT '模板内容',\n"" +
            ""  `template_example` varchar(500) NOT NULL COMMENT '模板示例',\n"" +
            ""  `create_time` datetime NOT NULL COMMENT '创建时间',\n"" +
            ""  `update_time` datetime NOT NULL COMMENT '更新时间',\n"" +
            ""  PRIMARY KEY (`id`)\n"" +
            "") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='模板消息数据表';"";
    JdbcUtil.execute(sql);
}   ",1702,False
"/**
 * 初始化消息tab
 */
public static void init(String selectedMsgName){
    messageEditForm = getInstance();
    // 设置滚动条速度
    messageEditForm.getMsgEditScrollPane().getVerticalScrollBar().setUnitIncrement(15);
    messageEditForm.getMsgEditScrollPane().getVerticalScrollBar().setDoubleBuffered(true);

    MsgFormFactory.getMsgForm().init(selectedMsgName);
}","/**
 * 初始化消息tab
 */
public static void init(String selectedMsgName) 
{
    if (selectedMsgName == null)
    {
        selectedMsgName = ""msg"";
    }

    if (selectedMsgName.equals(""msg""))
    {
        msgTab.setSelected(true);
    }
    else if (selectedMsgName.equals(""notice""))
    {
        noticeTab.setSelected(true);
    }
    else if (selectedMsgName.equals(""private""))
    {
        privateTab.setSelected(true);
    }
    else if (selectedMsgName.equals(""group""))
    {
        groupTab.setSelected(true);
    }
    else if (selectedMsgName.equals(""system""))
    {
        systemTab.setSelected(true);
    }
}   ",1703,False
"/**
 * 清空所有界面字段
 */
public static void clearAllField(){
    getInstance().getMailTitleTextField().setText("""");
    getInstance().getMailCcTextField().setText("""");
    getInstance().getMailFilesTextField().setText("""");
    getInstance().getMailContentPane().setText("""");
}","/**
 * 清空所有界面字段
 */
public static void clearAllField() 
{
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            field[i][j] = 0;
        }
    }
}   ",1704,False
"/**
 * @noinspection ALL
 */
private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont){
    if (currentFont == null) return null;
    String resultName;
    if (fontName == null) {
        resultName = currentFont.getName();
    } else {
        Font testFont = new Font(fontName, Font.PLAIN, 10);
        if (testFont.canDisplay('a') && testFont.canDisplay('1')) {
            resultName = fontName;
        } else {
            resultName = currentFont.getName();
        }
    }
    Font font = new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
    boolean isMac = System.getProperty(""os.name"", """").toLowerCase(Locale.ENGLISH).startsWith(""mac"");
    Font fontWithFallback = isMac ? new Font(font.getFamily(), font.getStyle(), font.getSize()) : new StyleContext().getFont(font.getFamily(), font.getStyle(), font.getSize());
    return fontWithFallback instanceof FontUIResource ? fontWithFallback : new FontUIResource(fontWithFallback);
}","/**
 * @noinspection ALL
 */
private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont) 
{
    if (currentFont == null) return null;
    String resultName;
    if (fontName == null)
    {
        resultName = currentFont.getName();
    }
    else
    {
        Font testFont = new Font(fontName, Font.PLAIN, 10);
        if (testFont.canDisplay('a') && testFont.canDisplay('1'))
        {
            resultName = fontName;
        }
        else
        {
            resultName = currentFont.getName();
        }
    }
    return new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
}   ",1706,False
"/**
 * 保存消息类型
 */
private static void saveType(){
    App.config.save();
    MessageTypeForm.init();
}","/**
 * 保存消息类型
 */
private static void saveType() 
{
    try
    {
        String sql = ""INSERT INTO `message_type` (`type_name`, `type_code`, `type_desc`, `create_time`, `update_time`) VALUES ('系统消息', 'system', '系统消息', NOW(), NOW());"";
        jdbcTemplate.update(sql);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",1716,False
"/**
 * 根据消息类型转换界面显示
 *
 * @param msgType
 */
public static void switchMsgType(int msgType){
    messageEditForm = getInstance();
    messageEditForm.getMsgEditorPanel().removeAll();
    GridConstraints gridConstraintsRow0 = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false);
    GridConstraints gridConstraintsRow1 = new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false);

    MsgFormFactory.getMsgForm().init(null);
    switch (msgType) {
        case MessageTypeEnum.MP_TEMPLATE_CODE:
            messageEditForm.getMsgEditorPanel().add(MpTemplateMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.MA_TEMPLATE_CODE:
        case MessageTypeEnum.MA_SUBSCRIBE_CODE:
            messageEditForm.getMsgEditorPanel().add(MaSubscribeMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.KEFU_CODE:
            messageEditForm.getMsgEditorPanel().add(KefuMsgForm.getInstance().getKefuMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.KEFU_PRIORITY_CODE:
            messageEditForm.getMsgEditorPanel().setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
            messageEditForm.getMsgEditorPanel().add(KefuMsgForm.getInstance().getKefuMsgPanel(), gridConstraintsRow0);
            messageEditForm.getMsgEditorPanel().add(MpTemplateMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow1);
            break;
        case MessageTypeEnum.WX_UNIFORM_MESSAGE_CODE:
            messageEditForm.getMsgEditorPanel().setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
            messageEditForm.getMsgEditorPanel().add(MaSubscribeMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            messageEditForm.getMsgEditorPanel().add(MpTemplateMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow1);
            break;
        case MessageTypeEnum.ALI_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(AliYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.TX_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(TxYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.QI_NIU_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(QiNiuYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.UP_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(UpYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.HW_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(HwYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.YUN_PIAN_CODE:
            messageEditForm.getMsgEditorPanel().add(YunpianMsgForm.getInstance().getYunpianMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.EMAIL_CODE:
            messageEditForm.getMsgEditorPanel().add(MailMsgForm.getInstance().getMailPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.WX_CP_CODE:
            messageEditForm.getMsgEditorPanel().add(WxCpMsgForm.getInstance().getWxCpMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.HTTP_CODE:
            messageEditForm.getMsgEditorPanel().add(HttpMsgForm.getInstance().getHttpPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.DING_CODE:
            messageEditForm.getMsgEditorPanel().add(DingMsgForm.getInstance().getDingMsgPanel(), gridConstraintsRow0);
            break;
        case MessageTypeEnum.BD_YUN_CODE:
            messageEditForm.getMsgEditorPanel().add(BdYunMsgForm.getInstance().getTemplateMsgPanel(), gridConstraintsRow0);
            break;
        default:
            break;
    }
}","/**
 * 根据消息类型转换界面显示
 *
 * @param msgType
 */
public static void switchMsgType(int msgType) 
{
    switch (msgType)
    {
        case 0:
            // ����消息
            break;
        case 1:
            // �����消息
            break;
        case 2:
            // ���天消息
            break;
        case 3:
            // 通知消息
            break;
    }
}   ",1718,False
"/**
 * In this test case we verify that the subscription is really created upon deployment
 * and thus messages are waiting for the job even before the first run of it.
 *
 * The subscription is not deleted even after the application is undeployed, because
 * the physical topic and its subscription in the message broker still exist,
 * even after the application scoped managed objects are deleted.
 *
 * Following method is used to generate the payload:
 *
 * include::JmsItemReaderTest#sendMessages[]
 *
 * So we send 10 random numbers, and verify that summing integers works exactly the
 * same way on both ends. Or that the job really picked up all the numbers submitted
 * for the computation.
 */
@InSequence(1)
@Test
public void worksAfterDeployment() throws InterruptedException{
    int sum = sendMessages(10);
    runJob();
    assertEquals(10, collector.getLastItemCount());
    assertEquals(sum, collector.getLastSum());
    assertEquals(1, collector.getNumberOfJobs());
}","/**
 * In this test case we verify that the subscription is really created upon deployment
 * and thus messages are waiting for the job even before the first run of it.
 *
 * The subscription is not deleted even after the application is undeployed, because
 * the physical topic and its subscription in the message broker still exist,
 * even after the application scoped managed objects are deleted.
 *
 * Following method is used to generate the payload:
 *
 * include::JmsItemReaderTest#sendMessages[]
 *
 * So we send 10 random numbers, and verify that summing integers works exactly the
 * same way on both ends. Or that the job really picked up all the numbers submitted
 * for the computation.
 */
@InSequence(1)
@Test
public void worksAfterDeployment() throws InterruptedException 
{
    // Send 10 random numbers
    sendMessages();

    // Wait for the job to finish
    Thread.sleep(5000);

    // Verify the result
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
        sum += i;
    }
    Assert.assertEquals(sum, result);
}   ",1722,True
"/**
 * Test of getItems method, of class CartBean
 *
 * @throws Exception
 */
@Test
public void shouldBeEmpty() throws Exception{
    // given

    // when
    final List<String> actual = sut.getItems();

    // then
    assertThat(actual.isEmpty(), is(true));
}","/**
 * Test of getItems method, of class CartBean
 *
 * @throws Exception
 */



@Test
public void shouldBeEmpty() throws Exception 
{
    CartBean cart = new CartBean();
    List<Item> items = cart.getItems();
    assertTrue(items.isEmpty());
}   ",1723,True
"/**
 * Processes requests for HTTP <code>GET</code>
 *
 * @param request servlet request
 * @param response servlet response
 * @throws ServletException if a servlet-specific error occurs
 * @throws IOException if an I/O error occurs
 */
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{
    String requestedUpgrade = request.getHeader(""Upgrade"");
    if (""echo"".equals(requestedUpgrade)) {
        response.setStatus(SC_SWITCHING_PROTOCOLS);
        response.setHeader(""Connection"", ""Upgrade"");
        response.setHeader(""Upgrade"", ""echo"");
        request.upgrade(MyProtocolHandler.class);

        System.out.println(""Request upgraded to MyProtocolHandler"");
    } else {
        response.sendError(SC_BAD_REQUEST, ""unknown upgrade "" + requestedUpgrade);
    }
}","/**
 * Processes requests for HTTP <code>GET</code>
 *
 * @param request servlet request
 * @param response servlet response
 * @throws ServletException if a servlet-specific error occurs
 * @throws IOException if an I/O error occurs
 */
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
{
    try
    {
        processRequest(request, response);
    }
    catch (Exception ex)
    {
        Logger.getLogger(UploadServlet.class.getName()).log(Level.SEVERE, null, ex);
    }
}   ",1724,False
"/**
 * A small variation on the testProtectedServletWithLoginCallingEJB that tests if for authentication that happened for
 * public resources the security context also propagates to EJB.
 * 
 */
@Test
public void publicServletCallingProtectedEJB() throws IOException, SAXException{

    String response = getFromServerPath(""public/servlet-protected-ejb?doLogin=true"");

    // Both the web (HttpServletRequest) and EJB (EJBContext) should see the same
    // user name.
    assertTrue(
        ""User should have been authenticated in the web layer and given name \""test\"", "" + 
        "" but does not appear to have this name"",
        response.contains(""web username: test"")
    );
    assertTrue(
        ""Web has user principal set, but EJB not."", 
        response.contains(""EJB username: test"")
    );

    // Both the web (HttpServletRequest) and EJB (EJBContext) should see that the
    // user has the role ""architect"".
    assertTrue(response.contains(""web user has role \""architect\"": true""));
    assertTrue(""Web user principal has role \""architect\"", but one in EJB doesn't."",
        response.contains(""EJB user has role \""architect\"": true""));
}","/**
 * A small variation on the testProtectedServletWithLoginCallingEJB that tests if for authentication that happened for
 * public resources the security context also propagates to EJB.
 * 
 */


@Test
public void publicServletCallingProtectedEJB() throws IOException, SAXException 
{
    URL url = new URL(getBaseURL().toString() + ""publicServletCallingProtectedEJB"");
    HttpURLConnection con = (HttpURLConnection) url.openConnection();
    con.setRequestMethod(""GET"");
    con.connect();

    assertEquals(200, con.getResponseCode());
    String response = readStream(con.getInputStream());
    assertEquals(""true"", response);
}   ",1725,False
"//    @Resource(name = ""DefaultManagedThreadFactory"")
//    ManagedThreadFactory threadFactory;
@GET
public void getList(@Suspended final AsyncResponse ar) throws NamingException{
    ar.setTimeoutHandler(new TimeoutHandler() {

        @Override
        public void handleTimeout(AsyncResponse ar) {
            ar.resume(""Operation timed out"");
        }
    });
    ar.setTimeout(4000, TimeUnit.MILLISECONDS);

    ar.register(new MyCompletionCallback());
    ar.register(new MyConnectionCallback());

    ManagedThreadFactory threadFactory = (ManagedThreadFactory) new InitialContext()
        .lookup(""java:comp/DefaultManagedThreadFactory"");

    Executors.newSingleThreadExecutor(threadFactory).submit(new Runnable() {

        @Override
        public void run() {
            try {
                Thread.sleep(3000);
                ar.resume(response[0]);
            } catch (InterruptedException ex) {

            }
        }

    });
}","//    @Resource(name = ""DefaultManagedThreadFactory"")
//    ManagedThreadFactory threadFactory;

@GET
public void getList(@Suspended final AsyncResponse ar) throws NamingException 
{
    final List<String> list = new ArrayList<String>();
    list.add(""one"");
    list.add(""two"");
    list.add(""three"");
    new Thread()
    {
        public void run()
        {
            ar.resume(list);
        }
    }.start();
}   ",1731,True
"// Both process and process2 are valid method signatures
public void process(ComponentSystemEvent event) throws AbortProcessingException{
    System.out.println(""process called"");
    name = name.toUpperCase();
}","// Both process and process2 are valid method signatures
public void process(ComponentSystemEvent event) throws AbortProcessingException 
{
    if (event instanceof ComponentSystemEvent)
    {
        process2((ComponentSystemEvent) event);
    }
    else
    {
        throw new AbortProcessingException(""Invalid event type"");
    }
}   ",1739,True
"/**
 * You can provide your own {@link BackOffPolicy} via this method.
 * @param backOffPolicy will be directly set to resulting {@link RetryTemplate}
 * @return this
 */
public RetryTemplateBuilder customBackoff(BackOffPolicy backOffPolicy){
	Assert.isNull(this.backOffPolicy, ""You have already selected backoff policy"");
	Assert.notNull(backOffPolicy, ""You should provide non null custom policy"");
	this.backOffPolicy = backOffPolicy;
	return this;
}","/**
 * You can provide your own {@link BackOffPolicy} via this method.
 * @param backOffPolicy will be directly set to resulting {@link RetryTemplate}
 * @return this
 */

public RetryTemplateBuilder customBackoff(BackOffPolicy backOffPolicy) 
{
    Assert.notNull(backOffPolicy, ""'backOffPolicy' must not be null"");
    this.backOffPolicy = backOffPolicy;
    return this;
}   ",1742,True
"/**
 * Allows retry if there is no more than {@code timeout} millis since first attempt.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param timeout whole execution timeout in milliseconds
 * @return this
 * @see TimeoutRetryPolicy
 */
public RetryTemplateBuilder withinMillis(long timeout){
	Assert.isTrue(timeout > 0, ""Timeout should be positive"");
	Assert.isNull(this.baseRetryPolicy, ""You have already selected another retry policy"");
	TimeoutRetryPolicy timeoutRetryPolicy = new TimeoutRetryPolicy();
	timeoutRetryPolicy.setTimeout(timeout);
	this.baseRetryPolicy = timeoutRetryPolicy;
	return this;
}","/**
 * Allows retry if there is no more than {@code timeout} millis since first attempt.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param timeout whole execution timeout in milliseconds
 * @return this
 * @see TimeoutRetryPolicy
 */
public RetryTemplateBuilder withinMillis(long timeout) 
{
    this.withinMillis = timeout;
    return this;
}   ",1743,True
"/**
 * @return the longest total time slept by a retry sequence.
 */
public SleepSequence getLongestTotalSleepSequence(){
	SleepSequence longest = null;
	for (SleepSequence sequence : sleepSequences) {
		if (longest == null || sequence.getTotalSleep() > longest.getTotalSleep()) {
			longest = sequence;
		}
	}
	return longest;
}","/**
 * @return the longest total time slept by a retry sequence.
 */

public SleepSequence getLongestTotalSleepSequence() 
{
    if (retrySequences.size() == 0)
    {
        return null;
    }
    SleepSequence longestSequence = retrySequences.get(0);
    for (SleepSequence sequence : retrySequences)
    {
        if (sequence.getTotalSleepTime() > longestSequence.getTotalSleepTime())
        {
            longestSequence = sequence;
        }
    }
    return longestSequence;
}   ",1744,True
"/**
 * If flexibility of this builder is not enough for you, you can provide your own
 * {@link RetryPolicy} via this method.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param policy will be directly set to resulting {@link RetryTemplate}
 * @return this
 */
public RetryTemplateBuilder customPolicy(RetryPolicy policy){
	Assert.notNull(policy, ""Policy should not be null"");
	Assert.isNull(this.baseRetryPolicy, ""You have already selected another retry policy"");
	this.baseRetryPolicy = policy;
	return this;
}","/**
 * If flexibility of this builder is not enough for you, you can provide your own
 * {@link RetryPolicy} via this method.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param policy will be directly set to resulting {@link RetryTemplate}
 * @return this
 */
public RetryTemplateBuilder customPolicy(RetryPolicy policy) 
{
    this.policy = policy;
    return this;
}   ",1745,True
"/**
 * Use exponential backoff policy. The formula of backoff period (without randomness):
 * <p>
 * {@code currentInterval = Math.min(initialInterval * Math.pow(multiplier, retryNum), maxInterval)}
 * <p>
 * (for first attempt retryNum = 0)
 * @param initialInterval in milliseconds
 * @param multiplier see the formula above
 * @param maxInterval in milliseconds
 * @param withRandom adds some randomness to backoff intervals. For details, see
 * {@link ExponentialRandomBackOffPolicy}
 * @return this
 * @see ExponentialBackOffPolicy
 * @see ExponentialRandomBackOffPolicy
 */
public RetryTemplateBuilder exponentialBackoff(long initialInterval, double multiplier, long maxInterval,
		boolean withRandom){
	Assert.isNull(this.backOffPolicy, ""You have already selected backoff policy"");
	Assert.isTrue(initialInterval >= 1, ""Initial interval should be >= 1"");
	Assert.isTrue(multiplier > 1, ""Multiplier should be > 1"");
	Assert.isTrue(maxInterval > initialInterval, ""Max interval should be > than initial interval"");
	ExponentialBackOffPolicy policy = withRandom ? new ExponentialRandomBackOffPolicy()
			: new ExponentialBackOffPolicy();
	policy.setInitialInterval(initialInterval);
	policy.setMultiplier(multiplier);
	policy.setMaxInterval(maxInterval);
	this.backOffPolicy = policy;
	return this;
}","/**
 * Use exponential backoff policy. The formula of backoff period (without randomness):
 * <p>
 * {@code currentInterval = Math.min(initialInterval * Math.pow(multiplier, retryNum), maxInterval)}
 * <p>
 * (for first attempt retryNum = 0)
 * @param initialInterval in milliseconds
 * @param multiplier see the formula above
 * @param maxInterval in milliseconds
 * @param withRandom adds some randomness to backoff intervals. For details, see
 * {@link ExponentialRandomBackOffPolicy}
 * @return this
 * @see ExponentialBackOffPolicy
 * @see ExponentialRandomBackOffPolicy
 */
public RetryTemplateBuilder exponentialBackoff(long initialInterval, double multiplier, long maxInterval,
		boolean withRandom) 
{
	this.backOffPolicy = new ExponentialBackOffPolicy();
	this.backOffPolicy.setInitialInterval(initialInterval);
	this.backOffPolicy.setMultiplier(multiplier);
	this.backOffPolicy.setMaxInterval(maxInterval);
	if (withRandom)
	{
		this.backOffPolicy = new ExponentialRandomBackOffPolicy(this.backOffPolicy);
	}
	return this;
}	",1746,True
"/**
 * Suppose throwing a {@code new MyLogicException(new IOException())}. This template
 * will not retry on it: <pre>{@code
 * RetryTemplate.builder()
 *          .retryOn(IOException.class)
 *          .build()
 * }</pre> but this will retry: <pre>{@code
 * RetryTemplate.builder()
 *          .retryOn(IOException.class)
 *          .traversingCauses()
 *          .build()
 * }</pre>
 * @return this
 * @see BinaryExceptionClassifier
 */
public RetryTemplateBuilder traversingCauses(){
	classifierBuilder().traversingCauses();
	return this;
}","/**
 * Suppose throwing a {@code new MyLogicException(new IOException())}. This template
 * will not retry on it: <pre>{@code
 * RetryTemplate.builder()
 *          .retryOn(IOException.class)
 *          .build()
 * }</pre> but this will retry: <pre>{@code
 * RetryTemplate.builder()
 *          .retryOn(IOException.class)
 *          .traversingCauses()
 *          .build()
 * }</pre>
 * @return this
 * @see BinaryExceptionClassifier
 */
public RetryTemplateBuilder traversingCauses() 
{
    this.traversingCauses = true;
    return this;
}   ",1750,True
"/**
 * Use {@link UniformRandomBackOffPolicy}, see it's doc for details.
 * @param minInterval in milliseconds
 * @param maxInterval in milliseconds
 * @return this
 * @see UniformRandomBackOffPolicy
 */
public RetryTemplateBuilder uniformRandomBackoff(long minInterval, long maxInterval){
	Assert.isNull(this.backOffPolicy, ""You have already selected backoff policy"");
	Assert.isTrue(minInterval >= 1, ""Min interval should be >= 1"");
	Assert.isTrue(maxInterval >= 1, ""Max interval should be >= 1"");
	Assert.isTrue(maxInterval > minInterval, ""Max interval should be > than min interval"");
	UniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();
	policy.setMinBackOffPeriod(minInterval);
	policy.setMaxBackOffPeriod(maxInterval);
	this.backOffPolicy = policy;
	return this;
}","/**
 * Use {@link UniformRandomBackOffPolicy}, see it's doc for details.
 * @param minInterval in milliseconds
 * @param maxInterval in milliseconds
 * @return this
 * @see UniformRandomBackOffPolicy
 */
public RetryTemplateBuilder uniformRandomBackoff(long minInterval, long maxInterval) 
{
    this.backOffPolicy = new UniformRandomBackOffPolicy();
    ((UniformRandomBackOffPolicy) this.backOffPolicy).setMinInterval(minInterval);
    ((UniformRandomBackOffPolicy) this.backOffPolicy).setMaxInterval(maxInterval);
    return this;
}   ",1751,True
"/**
 * Appends provided {@code listener} to {@link RetryTemplate}'s listener list.
 * @param listener to be appended
 * @return this
 * @see RetryTemplate
 * @see RetryListener
 */
public RetryTemplateBuilder withListener(RetryListener listener){
	Assert.notNull(listener, ""Listener should not be null"");
	listenersList().add(listener);
	return this;
}","/**
 * Appends provided {@code listener} to {@link RetryTemplate}'s listener list.
 * @param listener to be appended
 * @return this
 * @see RetryTemplate
 * @see RetryListener
 */
public RetryTemplateBuilder withListener(RetryListener listener) 
{
    if (listener != null)
    {
        this.listeners.add(listener);
    }
    return this;
}   ",1752,True
"/**
 * Allows infinite retry, do not limit attempts by number or time.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @return this
 * @see TimeoutRetryPolicy
 */
public RetryTemplateBuilder infiniteRetry(){
	Assert.isNull(this.baseRetryPolicy, ""You have already selected another retry policy"");
	this.baseRetryPolicy = new AlwaysRetryPolicy();
	return this;
}","/**
 * Allows infinite retry, do not limit attempts by number or time.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @return this
 * @see TimeoutRetryPolicy
 */
public RetryTemplateBuilder infiniteRetry() 
{
    this.retryPolicy = new AlwaysRetryPolicy();
    return this;
}   ",1753,True
"/**
 * Limits maximum number of attempts to provided value.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param maxAttempts includes initial attempt and all retries. E.g: maxAttempts = 3
 * means one initial attempt and two retries.
 * @return this
 * @see MaxAttemptsRetryPolicy
 */
public RetryTemplateBuilder maxAttempts(int maxAttempts){
	Assert.isTrue(maxAttempts > 0, ""Number of attempts should be positive"");
	Assert.isNull(this.baseRetryPolicy, ""You have already selected another retry policy"");
	this.baseRetryPolicy = new MaxAttemptsRetryPolicy(maxAttempts);
	return this;
}","/**
 * Limits maximum number of attempts to provided value.
 * <p>
 * Invocation of this method does not discard default exception classification rule,
 * that is ""retry only on {@link Exception} and it's subclasses"".
 * @param maxAttempts includes initial attempt and all retries. E.g: maxAttempts = 3
 * means one initial attempt and two retries.
 * @return this
 * @see MaxAttemptsRetryPolicy
 */
public RetryTemplateBuilder maxAttempts(int maxAttempts) 
{
    this.maxAttempts = maxAttempts;
    return this;
}   ",1754,True
"/**
 * Finish configuration and build resulting {@link RetryTemplate}. For default
 * behaviour and concurrency note see class-level doc of {@link RetryTemplateBuilder}.
 * The {@code retryPolicy} of the returned {@link RetryTemplate} is always an instance
 * of {@link CompositeRetryPolicy}, that consists of one base policy, and of
 * {@link BinaryExceptionClassifierRetryPolicy}. The motivation is: whatever base
 * policy we use, exception classification is extremely recommended.
 * @return new instance of {@link RetryTemplate}
 */
public RetryTemplate build(){
	RetryTemplate retryTemplate = new RetryTemplate();

	// Exception classifier

	BinaryExceptionClassifier exceptionClassifier = this.classifierBuilder != null ? this.classifierBuilder.build()
			: BinaryExceptionClassifier.defaultClassifier();

	// Retry policy

	if (this.baseRetryPolicy == null) {
		this.baseRetryPolicy = new MaxAttemptsRetryPolicy();
	}

	CompositeRetryPolicy finalPolicy = new CompositeRetryPolicy();
	finalPolicy.setPolicies(new RetryPolicy[] { this.baseRetryPolicy,
			new BinaryExceptionClassifierRetryPolicy(exceptionClassifier) });
	retryTemplate.setRetryPolicy(finalPolicy);

	// Backoff policy

	if (this.backOffPolicy == null) {
		this.backOffPolicy = new NoBackOffPolicy();
	}
	retryTemplate.setBackOffPolicy(this.backOffPolicy);

	// Listeners

	if (this.listeners != null) {
		retryTemplate.setListeners(this.listeners.toArray(new RetryListener[0]));
	}

	return retryTemplate;
}","/**
 * Finish configuration and build resulting {@link RetryTemplate}. For default
 * behaviour and concurrency note see class-level doc of {@link RetryTemplateBuilder}.
 * The {@code retryPolicy} of the returned {@link RetryTemplate} is always an instance
 * of {@link CompositeRetryPolicy}, that consists of one base policy, and of
 * {@link BinaryExceptionClassifierRetryPolicy}. The motivation is: whatever base
 * policy we use, exception classification is extremely recommended.
 * @return new instance of {@link RetryTemplate}
 */
public RetryTemplate build() 
{
    final RetryPolicy retryPolicy = new CompositeRetryPolicy(
            new BinaryExceptionClassifierRetryPolicy(exceptionClassifier), baseRetryPolicy);
    return new RetryTemplate(retryPolicy, backoffPolicy);
}   ",1757,True
"/**
 * Appends all provided {@code listeners} to {@link RetryTemplate}'s listener list.
 * @param listeners to be appended
 * @return this
 * @see RetryTemplate
 * @see RetryListener
 */
public RetryTemplateBuilder withListeners(List<RetryListener> listeners){
	for (final RetryListener listener : listeners) {
		Assert.notNull(listener, ""Listener should not be null"");
	}
	listenersList().addAll(listeners);
	return this;
}","/**
 * Appends all provided {@code listeners} to {@link RetryTemplate}'s listener list.
 * @param listeners to be appended
 * @return this
 * @see RetryTemplate
 * @see RetryListener
 */
public RetryTemplateBuilder withListeners(List<RetryListener> listeners) 
{
    this.listeners.addAll(listeners);
    return this;
}   ",1758,True
"/**
 * 从字符串解码公钥
 *
 * @param publicKey 公钥
 * @return 公钥
 * @throws Exception Exception
 */
public static PublicKey decodePublicKey(String publicKey) throws Exception{
    byte[] keyBytes = Base64Utils.decode(publicKey);
    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    return keyFactory.generatePublic(x509KeySpec);
}","/**
 * 从字符串解码公钥
 *
 * @param publicKey 公钥
 * @return 公钥
 * @throws Exception Exception
 */



public static PublicKey decodePublicKey(String publicKey) throws Exception 
{
    byte[] keyBytes = Base64.decodeBase64(publicKey.getBytes());
    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    return keyFactory.generatePublic(keySpec);
}   ",1762,True
"/**
 * 生成公钥和私钥
 *
 * @param rsaKeySize key size
 *
 * @return 公钥和私钥
 */
public static Pair<RSAPublicKey, RSAPrivateKey> genKeyPair(int rsaKeySize){
    try {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM);
        keyPairGen.initialize(rsaKeySize);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        return Pair.of(publicKey, privateKey);
    } catch (NoSuchAlgorithmException e) {
        LOGGER.error(""getKeys ex "", e);
    }
    return null;
}","/**
 * 生成公钥和私钥
 *
 * @param rsaKeySize key size
 *
 * @return 公钥和私钥
 */








public static Pair<RSAPublicKey, RSAPrivateKey> genKeyPair(int rsaKeySize) 
{
    try
    {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(rsaKeySize, new SecureRandom());
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
        return new Pair<>(rsaPublicKey, rsaPrivateKey);
    }
    catch (NoSuchAlgorithmException e)
    {
        e.printStackTrace();
    }
    return null;
}   ",1763,True
"/**
 * 私钥加密
 *
 * @param data       源数据
 * @param privateKey 私钥(BASE64编码)
 * @return 加密后的值
 * @throws Exception Exception
 */
public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception{
    PrivateKey key = decodePrivateKey(privateKey);
    Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_PADDING);
    cipher.init(Cipher.ENCRYPT_MODE, key);
    return doFinal(cipher, data, MAX_ENCRYPT_BLOCK);
}","/**
 * 私钥加密
 *
 * @param data       源数据
 * @param privateKey 私钥(BASE64编码)
 * @return 加密后的值
 * @throws Exception Exception
 */


public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception 
{
    byte[] keyBytes = Base64Utils.decode(privateKey);
    PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);
    Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
    cipher.init(Cipher.ENCRYPT_MODE, privateK);
    return cipher.doFinal(data);
}   ",1767,True
"/**
 * 获取内网IP地址
 *
 * @return 内网IP地址
 */
public static String getLocalIp(){
    if (CC.mp.net.local_ip.length() > 0) {
        return CC.mp.net.local_ip;
    }
    return Utils.lookupLocalIp();
}","/**
 * 获取内网IP地址
 *
 * @return 内网IP地址
 */







public static String getLocalIp() 
{
    try
    {
        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
        while (networkInterfaces.hasMoreElements())
        {
            NetworkInterface networkInterface = networkInterfaces.nextElement();
            Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
            while (inetAddresses.hasMoreElements())
            {
                InetAddress inetAddress = inetAddresses.nextElement();
                if (inetAddress.isSiteLocalAddress())
                {
                    return inetAddress.getHostAddress();
                }
            }
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return """";
}   ",1768,False
"/**
 * 检查本地路由，如果存在并且链接可用直接推送
 * 否则要检查下远程路由
 *
 * @param message message
 * @return true/false true:success
 */
private boolean checkLocal(IPushMessage message){
    String userId = message.getUserId();
    int clientType = message.getClientType();
    LocalRouter localRouter = mPushServer.getRouterCenter().getLocalRouterManager().lookup(userId, clientType);

    //1.如果本机不存在，再查下远程，看用户是否登陆到其他机器
    if (localRouter == null) return false;

    Connection connection = localRouter.getRouteValue();

    //2.如果链接失效，先删除本地失效的路由，再查下远程路由，看用户是否登陆到其他机器
    if (!connection.isConnected()) {

        Logs.PUSH.warn(""[SingleUserPush] find local router but conn disconnected, message={}, conn={}"", message, connection);

        //删除已经失效的本地路由
        mPushServer.getRouterCenter().getLocalRouterManager().unRegister(userId, clientType);

        return false;
    }

    //3.检测TCP缓冲区是否已满且写队列超过最高阀值
    if (!connection.getChannel().isWritable()) {
        mPushServer.getPushCenter().getPushListener().onFailure(message, timeLine.failureEnd().getTimePoints());

        Logs.PUSH.error(""[SingleUserPush] push message to client failure, tcp sender too busy, message={}, conn={}"", message, connection);
        return true;
    }

    //4. 检测qps, 是否超过流控限制，如果超过则进队列延后发送
    if (flowControl.checkQps()) {
        timeLine.addTimePoint(""before-send"");
        //5.链接可用，直接下发消息到手机客户端
        PushMessage pushMessage = PushMessage.build(connection).setContent(message.getContent());
        pushMessage.getPacket().addFlag(message.getFlags());
        messageId = pushMessage.getSessionId();
        pushMessage.send(this);
    } else {//超过流控限制, 进队列延后发送
        mPushServer.getPushCenter().delayTask(flowControl.getDelay(), this);
    }
    return true;
}","/**
 * 检查本地路由，如果存在并且链接可用直接推送
 * 否则要检查下远程路由
 *
 * @param message message
 * @return true/false true:success
 */
private boolean checkLocal(IPushMessage message) 
{
    String localRoute = getLocalRoute(message);
    if (localRoute != null)
    {
        return pushToLocal(message, localRoute);
    }
    else
    {
        return pushToRemote(message);
    }
}   ",1770,False
"/**
 * 使用模和指数生成RSA公钥
 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，
 * 不同JDK默认的补位方式可能不同，如Android默认是RSA
 * /None/NoPadding】
 *
 * @param modulus  模
 * @param exponent 指数
 * @return 公钥
 */
public static RSAPublicKey getPublicKey(String modulus, String exponent){
    try {
        BigInteger b1 = new BigInteger(modulus);
        BigInteger b2 = new BigInteger(exponent);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2);
        return (RSAPublicKey) keyFactory.generatePublic(keySpec);
    } catch (Exception e) {
        LOGGER.error(""getPublicKey ex modulus={}, exponent={}"", modulus, exponent, e);
        throw new CryptoException(""Get PublicKey ex"", e);
    }
}","/**
 * 使用模和指数生成RSA公钥
 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，
 * 不同JDK默认的补位方式可能不同，如Android默认是RSA
 * /None/NoPadding】
 *
 * @param modulus  模
 * @param exponent 指数
 * @return 公钥
 */




public static RSAPublicKey getPublicKey(String modulus, String exponent) 
{
    try
    {
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(new BigInteger(modulus), new BigInteger(exponent));
        return (RSAPublicKey) keyFactory.generatePublic(keySpec);
    }
    catch (Exception e)
    {
        e.printStackTrace();
        return null;
    }
}   ",1771,True
"/**
 * 检测远程路由，
 * 如果不存在直接返回用户已经下线
 * 如果是本机直接删除路由信息
 * 如果是其他机器让PushClient重推
 *
 * @param message message
 */
private void checkRemote(IPushMessage message){
    String userId = message.getUserId();
    int clientType = message.getClientType();
    RemoteRouter remoteRouter = mPushServer.getRouterCenter().getRemoteRouterManager().lookup(userId, clientType);

    // 1.如果远程路由信息也不存在, 说明用户此时不在线，
    if (remoteRouter == null || remoteRouter.isOffline()) {

        mPushServer.getPushCenter().getPushListener().onOffline(message, timeLine.end(""offline-end"").getTimePoints());

        Logs.PUSH.info(""[SingleUserPush] remote router not exists user offline, message={}"", message);

        return;
    }

    //2.如果查出的远程机器是当前机器，说明路由已经失效，此时用户已下线，需要删除失效的缓存
    if (remoteRouter.getRouteValue().isThisMachine(mPushServer.getGatewayServerNode().getHost(), mPushServer.getGatewayServerNode().getPort())) {

        mPushServer.getPushCenter().getPushListener().onOffline(message, timeLine.end(""offline-end"").getTimePoints());

        //删除失效的远程缓存
        mPushServer.getRouterCenter().getRemoteRouterManager().unRegister(userId, clientType);

        Logs.PUSH.info(""[SingleUserPush] find remote router in this pc, but local router not exists, userId={}, clientType={}, router={}""
                , userId, clientType, remoteRouter);

        return;
    }

    //3.否则说明用户已经跑到另外一台机器上了；路由信息发生更改，让PushClient重推
    mPushServer.getPushCenter().getPushListener().onRedirect(message, timeLine.end(""redirect-end"").getTimePoints());

    Logs.PUSH.info(""[SingleUserPush] find router in another pc, userId={}, clientType={}, router={}"", userId, clientType, remoteRouter);

}","/**
 * 检测远程路由，
 * 如果不存在直接返回用户已经下线
 * 如果是本机直接删除路由信息
 * 如果是其他机器让PushClient重推
 *
 * @param message message
 */
private void checkRemote(IPushMessage message) 
{
    if (!this.isRemote())
    {
        return;
    }
    if (this.isLocal(message))
    {
        this.removeRoute(message);
    }
    else
    {
        this.pushClient.push(message);
    }
}   ",1773,False
"/**
 * 从字符串解码私钥
 *
 * @param key 密钥
 * @return base64后的字符串
 * @throws Exception Exception
 */
public static PrivateKey decodePrivateKey(String key) throws Exception{
    byte[] keyBytes = Base64Utils.decode(key);
    PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    return keyFactory.generatePrivate(pkcs8KeySpec);
}","/**
 * 从字符串解码私钥
 *
 * @param key 密钥
 * @return base64后的字符串
 * @throws Exception Exception
 */



public static PrivateKey decodePrivateKey(String key) throws Exception 
{
    byte[] keyBytes = Base64.getDecoder().decode(key);
    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    return keyFactory.generatePrivate(keySpec);
}   ",1775,True
"/**
 * 添加ACK任务到队列, 等待客户端响应
 *
 * @param messageId 下发到客户端待ack的消息的sessionId
 */
private void addAckTask(int messageId){
    timeLine.addTimePoint(""waiting-ack"");

    //因为要进队列，可以提前释放一些比较占用内存的字段，便于垃圾回收
    message.finalized();

    AckTask task = AckTask
            .from(messageId)
            .setCallback(new PushAckCallback(message, timeLine, mPushServer.getPushCenter()));

    mPushServer.getPushCenter().getAckTaskQueue().add(task, message.getTimeoutMills() - (int) (System.currentTimeMillis() - start));
}","/**
 * 添加ACK任务到队列, 等待客户端响应
 *
 * @param messageId 下发到客户端待ack的消息的sessionId
 */



private void addAckTask(int messageId) 
{
    if (this.ackTaskQueue == null)
    {
        this.ackTaskQueue = new ConcurrentLinkedQueue<>();
    }
    this.ackTaskQueue.add(messageId);
}   ",1778,True
"/**
 * 私钥解密
 *
 * @param data       待加密数据
 * @param privateKey 私钥
 * @return 解密后的值
 */
public static byte[] decryptByPrivateKey(byte[] data, RSAPrivateKey privateKey){
    try {
        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_PADDING);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        //模长
        int key_len = privateKey.getModulus().bitLength() / 8;
        //如果密文长度大于模长则要分组解密
        return doFinal(cipher, data, key_len);
    } catch (Exception e) {
        LOGGER.error(""decryptByPrivateKey ex"", e);
        throw new CryptoException(""RSA decrypt ex"", e);
    }
}","/**
 * 私钥解密
 *
 * @param data       待加密数据
 * @param privateKey 私钥
 * @return 解密后的值
 */
public static byte[] decryptByPrivateKey(byte[] data, RSAPrivateKey privateKey) 
{
    try
    {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(data);
    }
    catch (Exception e)
    {
        throw new RuntimeException(""解密字符串["" + data + ""]时��到异常"", e);
    }
}   ",1779,True
"/**
 * Creates a new action object.
 *
 * @param graph The graph whose node selection is expanded up.
 */
public CActionExpandSelectionUp(final ZyGraph graph){
  super(""Expand Selection Up"");

  m_graph = graph;
}","/**
 * Creates a new action object.
 *
 * @param graph The graph whose node selection is expanded up.
 */
public CActionExpandSelectionUp(final ZyGraph graph) 
{
    super(graph, ""Expand Selection Up"");
}   ",1781,True
"/**
 * Creates a new REIL register object.
 * 
 * @param register Name of the register
 * @param size Size of the register
 * @param value Value of the register
 */
public ReilRegister(final String register, final OperandSize size, final BigInteger value){
  this.register = Preconditions.checkNotNull(register, ""Error: Argument register can't be null"");
  this.size = Preconditions.checkNotNull(size, ""Error: Argument size can't be null"");
  this.value = value;
}","/**
 * Creates a new REIL register object.
 * 
 * @param register Name of the register
 * @param size Size of the register
 * @param value Value of the register
 */
public ReilRegister(final String register, final OperandSize size, final BigInteger value) 
{
    this.register = register;
    this.size = size;
    this.value = value;
}   ",1782,True
"/**
 * Creates a new action object.
 *
 * @param treeNode The operand to display.
 */
public CDisplayOperandAction(final COperandTreeNode treeNode,
    final OperandDisplayStyle displayStyle, final String displayName){
  super(displayName);
  this.treeNode = treeNode;
  this.displayStyle = displayStyle;
}","/**
 * Creates a new action object.
 *
 * @param treeNode The operand to display.
 */
public CDisplayOperandAction(final COperandTreeNode treeNode,
    final OperandDisplayStyle displayStyle, final String displayName) 
{
    super(treeNode, displayName);
    this.treeNode = treeNode;
    this.displayStyle = displayStyle;
    this.displayName = displayName;
}   ",1783,True
"/**
 * Creates a new remote file browser.
 *
 * @param parent Parent window of the dialog.
 * @param debugger Debugger that provides information about the remote file system.
 * @param fileSystem Remote file system object that contains information about the remote file
 *        system.
 */
public CRemoteFileBrowser(final Window parent, final IDebugger debugger,
    final RemoteFileSystem fileSystem){
  super(new CRemoteFileSystemView(fileSystem));
  this.parent = Preconditions.checkNotNull(parent, ""IE01494: Parent argument can not be null"");
  this.debugger =
      Preconditions.checkNotNull(debugger, ""IE01495: Debugger argument can not be null"");

  setFileView(new CRemoteFileView());
  final String lastDir = ConfigManager.instance().getGeneralSettings().getLastDirectory();
  if (!lastDir.isEmpty()) {
    setCurrentDirectory(new CRemoteFile(lastDir, true /* is directory */));
  }
}","/**
 * Creates a new remote file browser.
 *
 * @param parent Parent window of the dialog.
 * @param debugger Debugger that provides information about the remote file system.
 * @param fileSystem Remote file system object that contains information about the remote file
 *        system.
 */
public CRemoteFileBrowser(final Window parent, final IDebugger debugger,
    final RemoteFileSystem fileSystem) 
{
    super(parent, SWT.APPLICATION_MODAL | SWT.DIALOG_TRIM | SWT.RESIZE);

    this.debugger = debugger;
    this.fileSystem = fileSystem;

    createContents();
}   ",1784,False
"/**
 * Removes the bookmark at the given index.
 *
 * @param bookmark The bookmark to remove.
 */
public void removeBookmark(final CBookmark bookmark){
  Preconditions.checkNotNull(bookmark, ""IE00385: Bookmark can not be null"");
  Preconditions.checkArgument(
      m_bookmarks.remove(bookmark), ""IE00386: Bookmark is not managed by this manager"");

  for (final IBookmarkManagerListener listener : m_listeners) {
    try {
      listener.removedBookmark(this, bookmark);
    } catch (final Exception exception) {
      CUtilityFunctions.logException(exception);
    }
  }
}","/**
 * Removes the bookmark at the given index.
 *
 * @param bookmark The bookmark to remove.
 */
public void removeBookmark(final CBookmark bookmark) 
{
    if (bookmark == null)
    {
        return;
    }

    if (this.bookmarks.contains(bookmark))
    {
        this.bookmarks.remove(bookmark);
    }
}   ",1787,False
"/**
 * Generates code for the Below condition.
 * 
 * @param environment A valid translation environment
 * @param offset Next usable REIL offset
 * 
 * @throws InternalTranslationException if the argument environment is null or the argument offset
 *         is less than 0.
 * 
 * @return The result of the translation including the generated code and the register that holds
 *         the result of the condition.
 */
@Override
public Pair<OperandSize, String> generate(final ITranslationEnvironment environment,
    final long offset, final List<ReilInstruction> instructions)
    throws InternalTranslationException{
  Preconditions.checkNotNull(environment, ""Error: Argument environment can't be null"");
  Preconditions.checkNotNull(instructions, ""Error: Argument instructions can't be null"");
  Preconditions.checkArgument(offset >= 0, ""Error: Argument offset can't be less than 0"");

  // Below: CF
  return new Pair<OperandSize, String>(OperandSize.BYTE, Helpers.CARRY_FLAG);
}","/**
 * Generates code for the Below condition.
 * 
 * @param environment A valid translation environment
 * @param offset Next usable REIL offset
 * 
 * @throws InternalTranslationException if the argument environment is null or the argument offset
 *         is less than 0.
 * 
 * @return The result of the translation including the generated code and the register that holds
 *         the result of the condition.
 */
@Override
public Pair<OperandSize, String> generate(final ITranslationEnvironment environment,
    final long offset, final List<ReilInstruction> instructions)
    throws InternalTranslationException 
{
  // Check if the environment is null
  Helper.checkTranslationEnvironment(environment);
  // Check if the offset is less than 0
  Helper.checkOffset(offset);

  // Get the operands
  final OperandSize operandSize1 = getOperandSize1(environment, offset, instructions);
  final OperandSize operandSize2 = getOperandSize2(environment, offset, instructions);

  // Generate the code for the condition
  final String conditionCode = generateConditionCode(environment, offset, instructions);

  // Generate the code for the result
  final String resultCode = generateResultCode(environment, offset, instructions);

  // Return the result
  return new Pair<OperandSize, String>(operandSize1, conditionCode + resultCode);
}   ",1788,True
"// / @cond INTERNAL
/**
 * Converts an internal operand type value into an API operand type value.
 *
 * @param type The operand type value to convert.
 *
 * @return The converted operand type value.
 */
// / @endcond
public static OperandType valueOf(final com.google.security.zynamics.reil.OperandType type){
  switch (type) {
    case EMPTY:
      return EMPTY;
    case INTEGER_LITERAL:
      return INTEGER_LITERAL;
    case REGISTER:
      return REGISTER;
    case SUB_ADDRESS:
      return SUB_ADDRESS;
    default:
      throw new IllegalArgumentException(""Error: Unknown type"");
  }
}","// / @cond INTERNAL
/**
 * Converts an internal operand type value into an API operand type value.
 *
 * @param type The operand type value to convert.
 *
 * @return The converted operand type value.
 */
// / @endcond
public static OperandType valueOf(final com.google.security.zynamics.reil.OperandType type) 
{
  switch (type)
  {
    case REGISTER:
      return OperandType.REGISTER;
    case IMMEDIATE_INTEGER:
      return OperandType.IMMEDIATE_INTEGER;
    case IMMEDIATE_FLOAT:
      return OperandType.IMMEDIATE_FLOAT;
    case MEMORY:
      return OperandType.MEMORY;
    case SYMBOL:
      return OperandType.SYMBOL;
    case EMPTY:
      return OperandType.EMPTY;
    case OPERATOR:
      return OperandType.OPERATOR;
    default:
      throw new IllegalArgumentException(""Invalid operand type: "" + type);
  }
}   ",1789,True
"/**
 * Adds a hint icon to a component.
 * 
 * @param component The component the hint icon is added to.
 * @param message The message shown by the hint icon when the cursor hovers over it.
 * 
 * @return The new component that contains both the passed component and the hint icon.
 */
public static Component createHintPanel(final Component component, final String message){
  Preconditions.checkNotNull(component, ""IE01256: Component argument can not be null"");

  Preconditions.checkNotNull(message, ""IE01257: Message argument can not be null"");

  final JPanel panel = new JPanel(new BorderLayout());

  panel.add(component, BorderLayout.CENTER);

  final JHintIcon hintPopup = new JHintIcon(message);
  hintPopup.setBorder(new EmptyBorder(0, 3, 0, 0));
  panel.add(hintPopup, BorderLayout.EAST);

  return panel;
}","/**
 * Adds a hint icon to a component.
 * 
 * @param component The component the hint icon is added to.
 * @param message The message shown by the hint icon when the cursor hovers over it.
 * 
 * @return The new component that contains both the passed component and the hint icon.
 */



public static Component createHintPanel(final Component component, final String message) 
{
    final JPanel panel = new JPanel(new BorderLayout());
    panel.add(component, BorderLayout.CENTER);
    final HintIcon hintIcon = new HintIcon(message);
    panel.add(hintIcon, BorderLayout.EAST);
    return panel;
}   ",1790,True
"/**
 * Creates a new action object.
 *
 * @param tree Tree where the criterium is inserted.
 * @param parent Parent node of the new criterium node.
 */
public CAppendNotOperatorAction(final CCriteriumTree tree, final CCriteriumTreeNode parent){
  super(""Append NOT"");

  m_tree = tree;
  m_parent = parent;
}","/**
 * Creates a new action object.
 *
 * @param tree Tree where the criterium is inserted.
 * @param parent Parent node of the new criterium node.
 */
public CAppendNotOperatorAction(final CCriteriumTree tree, final CCriteriumTreeNode parent) 
{
    super(tree, parent);
}   ",1791,True
"/**
 * Iterates over all invisible nodes in the graph.
 * 
 * @param callback Callback object that is invoked once for each invisible node in the graph.
 */
public static <NodeType extends ZyGraphNode<?> & ISelectableNode & IViewableNode & IYNode & IRawNodeAccessible> void iterateInvisible(
    final AbstractZyGraph<NodeType, ?> graph, final INodeCallback<NodeType> callback){
  Preconditions.checkNotNull(callback, ""Error: Callback argument can't be null"");

  graph.iterate(new INodeCallback<NodeType>() {
    @Override
    public IterationMode next(final NodeType node) {
      if (node.isVisible()) {
        return IterationMode.CONTINUE;
      }

      return callback.next(node);
    }
  });
}","/**
 * Iterates over all invisible nodes in the graph.
 * 
 * @param callback Callback object that is invoked once for each invisible node in the graph.
 */
public static <NodeType extends ZyGraphNode<?> & ISelectableNode & IViewableNode & IYNode & IRawNodeAccessible> void iterateInvisible(
    final AbstractZyGraph<NodeType, ?> graph, final INodeCallback<NodeType> callback) 
{
    for (final NodeType node : graph.getNodes())
    {
        if (!node.isVisible())
        {
            callback.accept(node);
        }
    }
}   ",1792,True
"/**
 * Adds a bookmark to the list of active bookmarks.
 *
 * @param bookmark The bookmark to add to the list.
 */
public void addBookmark(final CBookmark bookmark){
  Preconditions.checkNotNull(bookmark, ""IE00382: Bookmark can not be null"");
  Preconditions.checkArgument(getBookmark(bookmark.getAddress()) == null,
      ""IE00383: Bookmark already exists at offset %s"", bookmark.getAddress().toHexString());

  m_bookmarks.add(bookmark);

  for (final IBookmarkManagerListener listener : m_listeners) {
    try {
      listener.addedBookmark(this, bookmark);
    } catch (final Exception exception) {
      CUtilityFunctions.logException(exception);
    }
  }
}","/**
 * Adds a bookmark to the list of active bookmarks.
 *
 * @param bookmark The bookmark to add to the list.
 */
public void addBookmark(final CBookmark bookmark) 
{
    if (bookmark != null)
    {
        this.bookmarks.add(bookmark);
    }
}   ",1793,False
"/**
 * Creates a new action object.
 *
 * @param parent Window where the new view is shown.
 * @param view View to be cloned.
 * @param container Container where the new view is stored.
 */
public CActionClone(
    final CGraphWindow parent, final INaviView view, final IViewContainer container){
  super(""Clone View"");

  m_parent = Preconditions.checkNotNull(parent, ""IE01641: Parent can't be null"");
  m_view = Preconditions.checkNotNull(view, ""IE01642: View argument can not be null"");
  m_container =
      Preconditions.checkNotNull(container, ""IE01643: Container argument can not be null"");
}","/**
 * Creates a new action object.
 *
 * @param parent Window where the new view is shown.
 * @param view View to be cloned.
 * @param container Container where the new view is stored.
 */
public CActionClone(
    final CGraphWindow parent, final INaviView view, final IViewContainer container) 
{
    super(parent, ""Clone"", container);

    this.view = view;
    this.container = container;
}   ",1795,True
"// Inheriting & Overriding
@Test
public void default_method_inherited_from_interface(){
    DefaultMethods obj = new DefaultMethods() {
    };
    assertThat(obj.foo(), is(""original""));
}","// Inheriting & Overriding
@Test
public void default_method_inherited_from_interface() 
{
    final var actual = new ClassWithDefaultMethod().method();
    Assert.assertEquals(""default"", actual);
}   ",1801,True
"/**
 * Because the constructor is private, an access method must be generated for it
 * and also the NEW instruction must be done inside the access method.
 */
@Test
public void method_references_to_private_constructors() throws Exception{
    Callable<HasPrivateConstructor> factory = HasPrivateConstructor.factory();
    assertThat(factory.call(), is(instanceOf(HasPrivateConstructor.class)));

    HasPrivateConstructorWithArgs.Factory factoryArgs = HasPrivateConstructorWithArgs.factory();
    assertThat(factoryArgs.create(""args""), is(instanceOf(HasPrivateConstructorWithArgs.class)));
    assertThat(factoryArgs.create(""args"").args, is(""args""));
}","/**
 * Because the constructor is private, an access method must be generated for it
 * and also the NEW instruction must be done inside the access method.
 */


@Test
public void method_references_to_private_constructors() throws Exception 
{
    final Constructor<PrivateConstructor> constructor = PrivateConstructor.class.getDeclaredConstructor();
    constructor.setAccessible(true);
    final PrivateConstructor newInstance = constructor.newInstance();
    assertNotNull(newInstance);
}   ",1804,True
"/**
 * A naive method for removing method bodies would easily also remove their annotations,
 * because in ASM method annotations are expressed as calls on the MethodVisitor.
 */
@Test
@SuppressWarnings(""unchecked"")
public void keeps_annotations_on_interface_methods() throws Exception{
    assertThat(""interface"", AnnotatedInterface.class.getAnnotations(),
            arrayContaining(someAnnotation(1)));

    assertThat(""abstract method"", AnnotatedInterface.class.getMethod(""annotatedAbstractMethod"").getAnnotations(),
            arrayContaining(someAnnotation(2)));

    assertThat(""default method"", AnnotatedInterface.class.getMethod(""annotatedDefaultMethod"").getAnnotations(),
            arrayContaining(someAnnotation(3)));

    assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));
    assertThat(""static method"", companionOf(AnnotatedInterface.class).getMethod(""annotatedStaticMethod"").getAnnotations(),
            arrayContaining(someAnnotation(4)));
}","/**
 * A naive method for removing method bodies would easily also remove their annotations,
 * because in ASM method annotations are expressed as calls on the MethodVisitor.
 */
@Test
@SuppressWarnings(""unchecked"")
public void keeps_annotations_on_interface_methods() throws Exception 
{
    ClassNode node = ASMifier.getClassNode(InterfaceWithAnnotations.class.getName());
    ClassNode expectedNode = ASMifier.getClassNode(InterfaceWithAnnotations.class.getName());
    removeMethodBodies(node);
    assertEquals(expectedNode, node);
}   ",1807,True
"// Method relocations
@Test
public void abstract_methods_on_interfaces_are_not_relocated(){
    analyze(InterfaceMethodTypes.class);

    MethodRef source = new MethodRef(H_INVOKEINTERFACE, InterfaceMethodTypes.class, ""abstractMethod"", voidMethod());
    MethodRef target = analyzer.getMethodCallTarget(source);

    assertThat(target, is(source));
}","// Method relocations



@Test
public void abstract_methods_on_interfaces_are_not_relocated() 
{
    final ClassPool pool = ClassPool.getDefault();
    final CtClass cc = pool.get(""java.lang.String"");
    final CtClass[] interfaces = cc.getInterfaces();
    final CtClass[] newInterfaces = new CtClass[interfaces.length];
    for (int i = 0; i < interfaces.length; i++) {
        newInterfaces[i] = interfaces[i];
    }
    cc.setInterfaces(newInterfaces);
    try {
        cc.toBytecode();
        Assert.fail(""Should have thrown an exception"");
    } catch (CannotCompileException e) {
        Assert.assertTrue(e.getMessage().contains(""java.lang.String""));
    }
}   ",1808,False
"// other helpers
private static String voidMethod(Class<?>... argumentTypes){
    return Type.getMethodDescriptor(Type.VOID_TYPE,
            Stream.of(argumentTypes)
                    .map(Type::getType)
                    .toArray(Type[]::new));
}","// other helpers
private static String voidMethod(Class<?>... argumentTypes) 
{
    StringBuilder sb = new StringBuilder();
    sb.append(""("");
    for (Class<?> argumentType : argumentTypes)
    {
        sb.append(typeDescriptor(argumentType));
    }
    sb.append("")"");
    sb.append(""V"");
    return sb.toString();
}   ",1812,True
"/**
 * If the lambda impl method is generated as a private instance method,
 * we cannot just make it package-private for the lambda class to call them,
 * because a subclass may override the lambda by overriding its enclosing method
 * and declaring another lambda expression there.
 */
@Test
public void will_not_cause_lambda_expressions_to_be_overridable(){
    List<String> spy = new ArrayList<>();
    class Parent {
        @SuppressWarnings(""unused"")
        private int i;

        public void foo() {
            Runnable lambda = () -> { // generates a private ""lambda$foo$0"" method
                i++; // causes this lambda to be generated as an instance method
                spy.add(""parent"");
            };
            lambda.run();
        }
    }
    class Child extends Parent {
        @SuppressWarnings(""unused"")
        private int i;

        @Override
        public void foo() {
            super.foo();
            Runnable lambda = () -> { // generates a private ""lambda$foo$0"" method
                i++; // causes this lambda to be generated as an instance method
                spy.add(""child"");
            };
            lambda.run();
        }
    }

    Child c = new Child();
    c.foo();

    assertThat(spy, is(Arrays.asList(""parent"", ""child"")));
}","/**
 * If the lambda impl method is generated as a private instance method,
 * we cannot just make it package-private for the lambda class to call them,
 * because a subclass may override the lambda by overriding its enclosing method
 * and declaring another lambda expression there.
 */
@Test
public void will_not_cause_lambda_expressions_to_be_overridable() 
{
    class Super
    {
        public void m()
        {
            Runnable r = () -> {};
        }
    }

    class Sub extends Super
    {
        void m()
        {
            Runnable r = () -> {};
        }
    }
}   ",1813,False
"/**
 * We cannot just make the private methods package-private for the
 * lambda class to call them, because that may cause a method in subclass
 * to override them.
 */
@Test
public void will_not_cause_private_methods_to_be_overridable() throws Exception{
    class Parent {
        private String privateMethod() {
            return ""parent version"";
        }

        Callable<String> parentRef() {
            return this::privateMethod;
        }
    }
    class Child extends Parent {
        private String privateMethod() { // would override if were not private
            return ""child version"";
        }

        Callable<String> childRef() {
            return this::privateMethod;
        }
    }

    Child child = new Child();

    // Our test assumes that there exists a private method with
    // the same name and signature in super and sub classes.
    String name = ""privateMethod"";
    assertThat(child.getClass().getDeclaredMethod(name), is(notNullValue()));
    assertThat(child.getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));

    assertThat(child.privateMethod(), is(""child version""));
    assertThat(child.childRef().call(), is(""child version""));

    assertThat(((Parent) child).privateMethod(), is(""parent version""));
    assertThat(child.parentRef().call(), is(""parent version""));
}","/**
 * We cannot just make the private methods package-private for the
 * lambda class to call them, because that may cause a method in subclass
 * to override them.
 */
@Test
public void will_not_cause_private_methods_to_be_overridable() throws Exception 
{
    Class<?> lambdaClass = new Lambda().getClass();
    Method privateMethod = lambdaClass.getDeclaredMethod(""privateMethod"");
    assertFalse(Modifier.isPrivate(privateMethod.getModifiers()));
}   ",1815,False
"// Method inheritance
@Test
public void abstract_interface_method_inherited_and_implemented(){
    analyze(Interface.class,
            ChildInterface.class,
            InterfaceImplementer.class);

    assertThat(""original"", analyzer.getMethods(Type.getType(Interface.class)),
            hasItem(new MethodInfo(""abstractMethod"", ""()V"", Interface.class, new MethodKind.Abstract())));

    assertThat(""inherits unchanged"", analyzer.getMethods(Type.getType(ChildInterface.class)),
            hasItem(new MethodInfo(""abstractMethod"", ""()V"", Interface.class, new MethodKind.Abstract())));

    assertThat(""implements"", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),
            hasItem(new MethodInfo(""abstractMethod"", ""()V"", InterfaceImplementer.class, new MethodKind.Implemented())));
}","// Method inheritance

@Test
public void abstract_interface_method_inherited_and_implemented() 
{
    final String expected = ""abstract_interface_method_inherited_and_implemented"";
    final String actual = new AbstractInterfaceMethodInheritedAndImplemented().call();
    Assert.assertEquals(expected, actual);
}   ",1819,False
"/**
 * Destroy the file.
 */
public void destroy(){
    this.writeLock.lock();
    try {
        shutdown();
        FileUtils.deleteQuietly(new File(this.path));
        LOG.info(""Deleted segment file {}."", this.path);
    } finally {
        this.writeLock.unlock();
    }
}","/**
 * Destroy the file.
 */


public void destroy() 
{
    try
    {
        if (mFile != null)
        {
            mFile.close();
        }
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1822,False
"/**
 * Returns true when the segment file contains the log index.
 *
 * @param logIndex the log index
 * @return true if the segment file contains the log index, otherwise return false
 */
public boolean contains(final long logIndex){
    this.readLock.lock();
    try {
        return logIndex >= this.header.firstLogIndex && logIndex <= this.lastLogIndex;
    } finally {
        this.readLock.unlock();
    }
}","/**
 * Returns true when the segment file contains the log index.
 *
 * @param logIndex the log index
 * @return true if the segment file contains the log index, otherwise return false
 */
public boolean contains(final long logIndex) 
{
    if (logIndex < this.startIndex)
    {
        return false;
    }
    else if (logIndex > this.lastIndex)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",1827,False
"/**
 * Ensures the truth of an expression involving one or more parameters
 * to the calling method.
 *
 * @param expression a boolean expression
 * @throws IllegalArgumentException if {@code expression} is false
 */
public static void requireTrue(boolean expression){
    if (!expression) {
        throw new IllegalArgumentException();
    }
}","/**
 * Ensures the truth of an expression involving one or more parameters
 * to the calling method.
 *
 * @param expression a boolean expression
 * @throws IllegalArgumentException if {@code expression} is false
 */
public static void requireTrue(boolean expression) 
{
    if (!expression)
    {
        throw new IllegalArgumentException();
    }
}   ",1831,True
"/**
 * Checks that the specified object reference is not {@code null} and
 * throws a customized {@link NullPointerException} if it is.
 *
 * @param obj     the object reference to check for nullity
 * @param message detail message to be used in the event that a {@code
 *                NullPointerException} is thrown
 * @param <T>     the type of the reference
 * @return {@code obj} if not {@code null}
 * @throws NullPointerException if {@code obj} is {@code null}
 */
public static <T> T requireNonNull(T obj, String message){
    if (obj == null) {
        throw new NullPointerException(message);
    }
    return obj;
}","/**
 * Checks that the specified object reference is not {@code null} and
 * throws a customized {@link NullPointerException} if it is.
 *
 * @param obj     the object reference to check for nullity
 * @param message detail message to be used in the event that a {@code
 *                NullPointerException} is thrown
 * @param <T>     the type of the reference
 * @return {@code obj} if not {@code null}
 * @throws NullPointerException if {@code obj} is {@code null}
 */
public static <T> T requireNonNull(T obj, String message) 
{
    if (obj == null)
    {
        throw new NullPointerException(message);
    }
    return obj;
}   ",1834,True
"/**
 * Registers user signal handlers.
 *
 * @param signalName a signal name
 * @param handlers   user signal handlers
 * @return true if support on current platform
 */
public static boolean addSignal(final String signalName, final List<JRaftSignalHandler> handlers){
    if (SIGNAL_ACCESSOR != null) {
        SIGNAL_ACCESSOR.addSignal(signalName, handlers);
        return true;
    }
    return false;
}","/**
 * Registers user signal handlers.
 *
 * @param signalName a signal name
 * @param handlers   user signal handlers
 * @return true if support on current platform
 */
public static boolean addSignal(final String signalName, final List<JRaftSignalHandler> handlers) 
{
    if (signalHandlers.containsKey(signalName))
    {
        return false;
    }

    signalHandlers.put(signalName, handlers);
    return true;
}   ",1838,True
"/**
 * Updates the display name of the {@link Team}.
 *
 * @param displayName The new display name
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamDisplayName(JsonMessage displayName){
    this.team.updateTeamDisplayName(displayName);
    return this;
}","/**
 * Updates the display name of the {@link Team}.
 *
 * @param displayName The new display name
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamDisplayName(JsonMessage displayName) 
{
    this.displayName = displayName;
    return this;
}   ",1840,True
"/**
 * Updates the color of the {@link Team}.
 *
 * @param color The new color
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamColor(ChatColor color){
    this.team.updateTeamColor(color);
    return this;
}","/**
 * Updates the color of the {@link Team}.
 *
 * @param color The new color
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamColor(ChatColor color) 
{
    if (color != null)
    {
        this.color = color;
    }
    return this;
}   ",1842,True
"/**
 * Creates an team builder.
 *
 * @param team        The new team
 * @param teamManager The manager for the team
 */
private TeamBuilder(Team team, TeamManager teamManager){
    this.team = team;
    this.teamManager = teamManager;
    this.updateTeam = false;
}","/**
 * Creates an team builder.
 *
 * @param team        The new team
 * @param teamManager The manager for the team
 */
private TeamBuilder(Team team, TeamManager teamManager) 
{
    this.team = team;
    this.teamManager = teamManager;
}   ",1845,True
"/**
 * Create a DoNothing goal
 *
 * @param entityCreature the entity
 * @param time           the time in milliseconds where nothing happen
 * @param chance         the chance to do nothing (0-1)
 */
public DoNothingGoal(EntityCreature entityCreature, long time, float chance){
    super(entityCreature);
    this.time = time;
    this.chance = MathUtils.clampFloat(chance, 0, 1);
}","/**
 * Create a DoNothing goal
 *
 * @param entityCreature the entity
 * @param time           the time in milliseconds where nothing happen
 * @param chance         the chance to do nothing (0-1)
 */
public DoNothingGoal(EntityCreature entityCreature, long time, float chance) 
{
    this.entityCreature = entityCreature;
    this.time = time;
    this.chance = chance;
}   ",1846,True
"/**
 * Writes data into the {@link BinaryWriter}
 *
 * @param writer The writer to writes
 */
@Override
public void write(@NotNull BinaryWriter writer){
    writer.writeSizedString(this.teamName);
    writer.writeByte((byte) this.action.ordinal());

    switch (action) {
        case CREATE_TEAM:
        case UPDATE_TEAM_INFO:
            writer.writeSizedString(this.teamDisplayName.toString());
            writer.writeByte(this.friendlyFlags);
            writer.writeSizedString(this.nameTagVisibility.getIdentifier());
            writer.writeSizedString(this.collisionRule.getIdentifier());
            writer.writeVarInt(this.teamColor);
            writer.writeSizedString(this.teamPrefix.toString());
            writer.writeSizedString(this.teamSuffix.toString());
            break;
        case REMOVE_TEAM:

            break;
    }

    if (action == Action.CREATE_TEAM || action == Action.ADD_PLAYERS_TEAM || action == Action.REMOVE_PLAYERS_TEAM) {
        writer.writeStringArray(entities);
    }

}","/**
 * Writes data into the {@link BinaryWriter}
 *
 * @param writer The writer to writes
 */
@Override
public void write(@NotNull BinaryWriter writer) 
{
    writer.writeInt(this.x);
    writer.writeInt(this.y);
    writer.writeInt(this.z);
}   ",1847,False
"/**
 * Changes the friendly flags of the {@link Team} without an update packet.
 * <br><br>
 * <b>Warning: </b> If you do not call {@link #updateTeamPacket()}, this is only changed of the <b>server side</b>.
 *
 * @param flag The new flag
 * @return this builder, for chaining
 */
public TeamBuilder friendlyFlags(byte flag){
    this.team.setFriendlyFlags(flag);
    return this;
}","/**
 * Changes the friendly flags of the {@link Team} without an update packet.
 * <br><br>
 * <b>Warning: </b> If you do not call {@link #updateTeamPacket()}, this is only changed of the <b>server side</b>.
 *
 * @param flag The new flag
 * @return this builder, for chaining
 */
public TeamBuilder friendlyFlags(byte flag) 
{
    this.friendlyFlags = flag;
    return this;
}   ",1850,True
"/**
 * Allows to send an update packet when the team is built.
 *
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamPacket(){
    this.updateTeam = true;
    return this;
}","/**
 * Allows to send an update packet when the team is built.
 *
 * @return this builder, for chaining
 */
public TeamBuilder updateTeamPacket() 
{
    this.updateTeamPacket = true;
    return this;
}   ",1852,True
"/**
 * Executes an optional {@link Runnable}.
 *
 * @param callback the optional runnable, can be null
 */
public static void execute(@Nullable Runnable callback){
    if (callback != null) {
        callback.run();
    }
}","/**
 * Executes an optional {@link Runnable}.
 *
 * @param callback the optional runnable, can be null
 */
public static void execute(@Nullable Runnable callback) 
{
    if (callback != null)
    {
        callback.run();
    }
}   ",1853,True
"/**
 * Builds the packet which build the whole advancement tab.
 *
 * @return the packet adding this advancement tab and all its advancements
 */
@NotNull
protected AdvancementsPacket createPacket(){
    AdvancementsPacket advancementsPacket = new AdvancementsPacket();
    advancementsPacket.resetAdvancements = false;

    List<AdvancementsPacket.AdvancementMapping> mappings = new ArrayList<>();
    List<AdvancementsPacket.ProgressMapping> progressMappings = new ArrayList<>();

    for (Advancement advancement : advancementMap.keySet()) {
        mappings.add(advancement.toMapping());
        progressMappings.add(advancement.toProgressMapping());
    }

    advancementsPacket.identifiersToRemove = new String[]{};
    advancementsPacket.advancementMappings = mappings.toArray(new AdvancementsPacket.AdvancementMapping[0]);
    advancementsPacket.progressMappings = progressMappings.toArray(new AdvancementsPacket.ProgressMapping[0]);

    return advancementsPacket;
}","/**
 * Builds the packet which build the whole advancement tab.
 *
 * @return the packet adding this advancement tab and all its advancements
 */
@NotNull
protected AdvancementsPacket createPacket() 
{
    AdvancementsPacket packet = new AdvancementsPacket();
    packet.reset = true;
    packet.additions.addAll(this.advancements.values());
    packet.removals.addAll(this.removals);
    return packet;
}   ",1856,True
"/**
 * Finds a target based on the entity {@link TargetSelector}.
 *
 * @return the target entity, null if not found
 */
@Nullable
public Entity findTarget(){
    for (TargetSelector targetSelector : entityCreature.getTargetSelectors()) {
        final Entity entity = targetSelector.findTarget();
        if (entity != null) {
            return entity;
        }
    }
    return null;
}","/**
 * Finds a target based on the entity {@link TargetSelector}.
 *
 * @return the target entity, null if not found
 */
@Nullable
public Entity findTarget() 
{
    if (this.targetSelector == null)
    {
        return null;
    }
    else
    {
        return this.targetSelector.findTarget();
    }
}   ",1857,True
"/**
 * Updates the prefix of the {@link Team}.
 *
 * @param prefix The new prefix
 * @return this builder, for chaining
 */
public TeamBuilder updatePrefix(JsonMessage prefix){
    this.team.updatePrefix(prefix);
    return this;
}","/**
 * Updates the prefix of the {@link Team}.
 *
 * @param prefix The new prefix
 * @return this builder, for chaining
 */
public TeamBuilder updatePrefix(JsonMessage prefix) 
{
    this.prefix = prefix;
    return this;
}   ",1858,True
"// Public API (can be overridden)
protected void onLongPress(@NonNull MotionEvent event){
       if (settings.isEnabled()) {
           targetView.performLongClick();

           if (gestureListener != null) {
               gestureListener.onLongPress(event);
           }
       }
   }","// Public API (can be overridden)
protected void onLongPress(@NonNull MotionEvent event) 
{
    if (!mScaleDetector.isInProgress()) {
        mScaleDetector.onTouchEvent(event);
    }
}   ",1860,True
"// Public API
public void stopStateAnimation(){
       if (isAnimatingState()) {
           stateScroller.forceFinished();
           onStateAnimationFinished(true);
       }
   }","// Public API
public void stopStateAnimation() 
{
    if (mStateAnimationHandler != null)
    {
        mStateAnimationHandler.stop();
        mStateAnimationHandler = null;
    }
}   ",1865,True
"/**
 * Resets to initial state (default position, min zoom level) and notifies
 * {@link OnStateChangeListener} listeners.
 * <p>
 * Should be called when image size is changed.
 * <p>
 * See {@link Settings#setImage(int, int)}.
 */
public void resetState(){
    stopAllAnimations();
    boolean reset = stateController.resetState(state);
    if (reset) {
        notifyStateReset();
    } else {
        notifyStateUpdated();
    }
}","/**
 * Resets to initial state (default position, min zoom level) and notifies
 * {@link OnStateChangeListener} listeners.
 * <p>
 * Should be called when image size is changed.
 * <p>
 * See {@link Settings#setImage(int, int)}.
 */
public void resetState() 
{
    if (mState != null)
    {
        mState.reset();
        notifyOnStateChangeListener();
    }
}   ",1868,True
"/**
 * Scale detector is a little buggy when first time scale is occurred.
 * So we will feed it with fake motion event to warm it up.
 */
private void warmUpScaleDetector(){
    long time = System.currentTimeMillis();
    MotionEvent event = MotionEvent.obtain(time, time, MotionEvent.ACTION_CANCEL, 0f, 0f, 0);
    onTouchEvent(event);
    event.recycle();
}","/**
 * Scale detector is a little buggy when first time scale is occurred.
 * So we will feed it with fake motion event to warm it up.
 */

private void warmUpScaleDetector() 
{
    MotionEvent motionEvent = MotionEvent.obtain(0, 0, MotionEvent.ACTION_MOVE, 0, 0, 0);
    mScaleDetector.onTouchEvent(motionEvent);
    motionEvent.recycle();
}   ",1870,True
"/**
 * Applies state restrictions and notifies {@link OnStateChangeListener} listeners.
 */
public void updateState(){
    // Applying zoom patch (needed in case if image size is changed)
    stateController.applyZoomPatch(state);
    stateController.applyZoomPatch(prevState);
    stateController.applyZoomPatch(stateStart);
    stateController.applyZoomPatch(stateEnd);
    exitController.applyZoomPatch();

    boolean reset = stateController.updateState(state);
    if (reset) {
        notifyStateReset();
    } else {
        notifyStateUpdated();
    }
}","/**
 * Applies state restrictions and notifies {@link OnStateChangeListener} listeners.
 */
public void updateState() 
{
    if (mState == STATE_ENABLED)
    {
        if (mStateRestrictions != null)
        {
            mStateRestrictions.applyRestrictions();
        }
    }

    notifyOnStateChangeListener();
}   ",1875,False
"/**
 * Interpolates from start rect to the end rect by given factor (from 0 to 1),
 * storing result into out rect.
 *
 * @param out Interpolated rectangle (output)
 * @param start Start rectangle
 * @param end End rectangle
 * @param factor Factor
 */
public static void interpolate(
        @NonNull RectF out,
        @NonNull RectF start,
        @NonNull RectF end,
        float factor
){
    out.left = interpolate(start.left, end.left, factor);
    out.top = interpolate(start.top, end.top, factor);
    out.right = interpolate(start.right, end.right, factor);
    out.bottom = interpolate(start.bottom, end.bottom, factor);
}","/**
 * Interpolates from start rect to the end rect by given factor (from 0 to 1),
 * storing result into out rect.
 *
 * @param out Interpolated rectangle (output)
 * @param start Start rectangle
 * @param end End rectangle
 * @param factor Factor
 */
public static void interpolate(
        @NonNull RectF out,
        @NonNull RectF start,
        @NonNull RectF end,
        float factor
) 
{
    out.left = start.left + (end.left - start.left) * factor;
    out.top = start.top + (end.top - start.top) * factor;
    out.right = start.right + (end.right - start.right) * factor;
    out.bottom = start.bottom + (end.bottom - start.bottom) * factor;
}       ",1876,True
"// performClick is called in gestures callbacks
@Override
   public boolean onTouch(@NonNull View view, @NonNull MotionEvent event){
       if (!isInterceptTouchCalled) { // Preventing duplicate events
           onTouchInternal(view, event);
       }
       isInterceptTouchCalled = false;
       return settings.isEnabled();
   }","// performClick is called in gestures callbacks
@Override
   public boolean onTouch(@NonNull View view, @NonNull MotionEvent event) 
{
    if (event.getAction() == MotionEvent.ACTION_DOWN)
    {
        performClick();
    }
    return true;
}  ",1878,True
"/**
 * on not active finger up
 *
 * @param ev
 */
private void onSecondaryPointerUp(MotionEvent ev){
    final int pointerIndex = MotionEventCompat.getActionIndex(ev);
    final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
    if (pointerId == mActivePointerId) {
        // This was our active pointer going up. Choose a new
        // active pointer and adjust accordingly.
        final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
        mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
    }
}","/**
 * on not active finger up
 *
 * @param ev
 */
private void onSecondaryPointerUp(MotionEvent ev) 
{
    final int pointerIndex = ev.getActionIndex();
    final int pointerId = ev.getPointerId(pointerIndex);
    if (pointerId == mActivePointerId)
    {
        // This was our active pointer going up. Choose a new
        // active pointer and adjust accordingly.
        final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
        mActivePointerId = ev.getPointerId(newPointerIndex);
        mLastTouchX = ev.getX(newPointerIndex);
        mLastTouchY = ev.getY(newPointerIndex);
    }
}   ",1881,True
"/**
 * Update the background color of the mBgCircle image view.
 */
public void setBackgroundColor(@ColorRes int colorRes){
    if (getBackground() instanceof ShapeDrawable) {
        final Resources res = getResources();
        ((ShapeDrawable) getBackground()).getPaint().setColor(res.getColor(colorRes));
    }
}","/**
 * Update the background color of the mBgCircle image view.
 */
public void setBackgroundColor(@ColorRes int colorRes) 
{
    if (mBgCircle != null)
    {
        mBgCircle.setBackgroundColor(getResources().getColor(colorRes));
    }
}   ",1886,True
"/**
 * copy from {@link android.support.v4.widget.SwipeRefreshLayout#canChildScrollUp()}
 *
 * @return Whether it is possible for the child view of this layout to
 * scroll up. Override this if the child view is a custom view.
 */
protected boolean canChildScrollUp(){
    if (android.os.Build.VERSION.SDK_INT < 14) {
        if (mTargetView instanceof AbsListView) {
            final AbsListView absListView = (AbsListView) mTargetView;
            return absListView.getChildCount() > 0
                    && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)
                    .getTop() < absListView.getPaddingTop());
        } else {
            return ViewCompat.canScrollVertically(mTargetView, -1) || mTargetView.getScrollY() > 0;
        }
    } else {
        return ViewCompat.canScrollVertically(mTargetView, -1);
    }
}","/**
 * copy from {@link android.support.v4.widget.SwipeRefreshLayout#canChildScrollUp()}
 *
 * @return Whether it is possible for the child view of this layout to
 * scroll up. Override this if the child view is a custom view.
 */
protected boolean canChildScrollUp() 
{
    if (android.os.Build.VERSION.SDK_INT < 14)
    {
        if (mTarget instanceof AbsListView)
        {
            final AbsListView absListView = (AbsListView) mTarget;
            return absListView.getChildCount() > 0
                    && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)
                    .getTop() < absListView.getPaddingTop());
        } else
        {
            return ViewCompat.canScrollVertically(mTarget, -1);
        }
    } else
    {
        return ViewCompat.canScrollVertically(mTarget, -1);
    }
}   ",1888,True
"/**
 * Set the current status for better control
 *
 * @param status
 */
private void setStatus(int status){
    mStatus = status;
    if (mDebug) {
        STATUS.printStatus(status);
    }
}","/**
 * Set the current status for better control
 *
 * @param status
 */
private void setStatus(int status) 
{
    this.status = status;
    if (status == STATUS_CONNECTING)
    {
        this.status = STATUS_CONNECTED;
    }
}   ",1890,True
"/**
 * set the style of the refresh header
 *
 * @param style
 */
public void setSwipeStyle(int style){
    this.mStyle = style;
    requestLayout();
}","/**
 * set the style of the refresh header
 *
 * @param style
 */
public void setSwipeStyle(int style) 
{
    if (style == 0)
    {
        mRefreshView.setSwipeStyle(SwipeRefreshLayoutStyle.SwipeRefresh);
    }
    else
    {
        mRefreshView.setSwipeStyle(SwipeRefreshLayoutStyle.SwipeRefresh);
    }
}   ",1891,True
"/**
 * The param yScrolled here isn't final pos of y.
 * It's just like the yScrolled param in the
 * {@link #updateScroll(float yScrolled)}
 *
 * @param yScrolled
 * @param duration
 */
private void autoScroll(int yScrolled, int duration){
    removeCallbacks(this);
    mmLastY = 0;
    if (!mScroller.isFinished()) {
        mScroller.forceFinished(true);
    }
    mScroller.startScroll(0, 0, 0, yScrolled, duration);
    post(this);
    mRunning = true;
}","/**
 * The param yScrolled here isn't final pos of y.
 * It's just like the yScrolled param in the
 * {@link #updateScroll(float yScrolled)}
 *
 * @param yScrolled
 * @param duration
 */
private void autoScroll(int yScrolled, int duration) 
{
    if (mScroller.isFinished())
    {
        mScroller.startScroll(0, mScroller.getCurrY(), 0, yScrolled, duration);
    }
}   ",1892,False
"/**
 * set refresh header view, the view must at lease be an implement of {@code SwipeRefreshTrigger}.
 * the view can also implement {@code SwipeTrigger} for more extension functions
 *
 * @param view
 */
public void setRefreshHeaderView(View view){
    if (view instanceof SwipeRefreshTrigger) {
        if (mHeaderView != null && mHeaderView != view) {
            removeView(mHeaderView);
        }
        if (mHeaderView != view) {
            this.mHeaderView = view;
            addView(view);
        }
    } else {
        Log.e(TAG, ""Refresh header view must be an implement of SwipeRefreshTrigger"");
    }
}","/**
 * set refresh header view, the view must at lease be an implement of {@code SwipeRefreshTrigger}.
 * the view can also implement {@code SwipeTrigger} for more extension functions
 *
 * @param view
 */
public void setRefreshHeaderView(View view) 
{
    if (view instanceof SwipeRefreshTrigger)
    {
        mRefreshTrigger = (SwipeRefreshTrigger) view;
    } else
    {
        throw new IllegalArgumentException(""Refresh header view must implement SwipeRefreshTrigger"");
    }
}   ",1894,True
"/**
 * start loop
 */
public void start(){
    if (!mRunning) {
        post();
        mRunning = true;
    }
}","/**
 * start loop
 */
public void start() 
{
    if (running)
    {
        return;
    }
    running = true;
    thread = new Thread(this);
    thread.start();
}   ",1896,False
"/**
 * no-brainer, used O(n) space
 */
public int findDuplicate(int[] nums){
    Set<Integer> set = new HashSet<>();
    int dup = 0;
    for (int i = 0; i < nums.length; i++) {
        if (!set.add(nums[i])) {
            dup = nums[i];
            break;
        }
    }
    return dup;
}","/**
 * no-brainer, used O(n) space
 */

public int findDuplicate(int[] nums) 
{
    Set<Integer> set = new HashSet<>();
    for(int num : nums)
    {
        if(set.contains(num))
            return num;
        set.add(num);
    }
    return -1;
}   ",1901,True
"/**
 * credit: https://discuss.leetcode.com/topic/28719/short-java-solution-using-dp-o-n-log-n
 * The idea is that as you iterate the sequence,
 * you keep track of the minimum value a subsequence of given length might end with,
 * for all so far possible subsequence lengths.
 * So dp[i] is the minimum value a subsequence of length i+1 might end with.
 * Having this info, for each new number we iterate to,
 * we can determine the longest subsequence where it can be appended using binary search.
 * The final answer is the length of the longest subsequence we found so far.
 */
public int lengthOfLIS(int[] nums){
    int[] dp = new int[nums.length];
    int len = 0;
    for (int x : nums) {
        /**Java Doc of this binarySearch API:
         * @return index of the search key, if it is contained in the array
         *         within the specified range;
         *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         *         <i>insertion point</i> is defined as the point at which the
         *         key would be inserted into the array: the index of the first
         *         element in the range greater than the key,
         *         or <tt>toIndex</tt> if all
         *         elements in the range are less than the specified key.  Note
         *         that this guarantees that the return value will be &gt;= 0 if
         *         and only if the key is found.*/
        int index = Arrays.binarySearch(dp, 0, len, x);
        if (index < 0) {
            index = -(index + 1);
        }
        dp[index] = x;
        if (index == len) {
            len++;
        }
    }
    return len;
}","/**
 * credit: https://discuss.leetcode.com/topic/28719/short-java-solution-using-dp-o-n-log-n
 * The idea is that as you iterate the sequence,
 * you keep track of the minimum value a subsequence of given length might end with,
 * for all so far possible subsequence lengths.
 * So dp[i] is the minimum value a subsequence of length i+1 might end with.
 * Having this info, for each new number we iterate to,
 * we can determine the longest subsequence where it can be appended using binary search.
 * The final answer is the length of the longest subsequence we found so far.
 */

public int lengthOfLIS(int[] nums) 
{
    int[] dp = new int[nums.length];
    int len = 0;

    for(int x : nums)
    {
        int i = Arrays.binarySearch(dp, 0, len, x);
        if(i < 0) i = -(i + 1);
        dp[i] = x;
        if(i == len) len++;
    }

    return len;
}   ",1905,True
"/**
 * reference: https://discuss.leetcode.com/topic/28308/java-ac-solution-using-bfs
 */
public String alienOrder(String[] words){
    Map<Character, Set<Character>> map = new HashMap();
    Map<Character, Integer> degree = new HashMap<>();
    String result = """";
    if (words == null || words.length == 0) {
        return result;
    }
    for (String s : words) {
        for (char c : s.toCharArray()) {
            degree.put(c, 0);//keeps overwriting it, the purpose is to create one entry
            //for each letter in the degree map
        }
    }
    for (int i = 0; i < words.length - 1; i++) {
        String cur = words[i];
        String next = words[i + 1];
        int length = Math.min(cur.length(), next.length());
        for (int j = 0; j < length; j++) {
            char c1 = cur.charAt(j);
            char c2 = next.charAt(j);
            if (c1 != c2) {
                Set<Character> set = new HashSet<>();
                if (map.containsKey(c1)) {
                    set = map.get(c1);
                }
                if (!set.contains(c2)) {
                    set.add(c2);
                    map.put(c1, set);
                    degree.put(c2, degree.get(c2) + 1);
                }
                break;
            }
        }
    }
    Queue<Character> queue = new LinkedList<>();
    for (char c : degree.keySet()) {
        if (degree.get(c) == 0) {
            queue.add(c);
        }
    }
    while (!queue.isEmpty()) {
        char c = queue.remove();
        result += c;
        if (map.containsKey(c)) {
            for (char c2 : map.get(c)) {
                degree.put(c2, degree.get(c2) - 1);
                if (degree.get(c2) == 0) {
                    queue.add(c2);
                }
            }
        }
    }
    if (result.length() != degree.size()) {
        return """";
    }
    return result;
}","/**
 * reference: https://discuss.leetcode.com/topic/28308/java-ac-solution-using-bfs
 */


public String alienOrder(String[] words) 
{
    Map<Character, Set<Character>> graph = new HashMap<>();
    int[] indegree = new int[26];
    buildGraph(graph, words, indegree);
    return bfs(graph, indegree);
}   ",1907,False
"/**
 * credit: https://discuss.leetcode.com/topic/89282/java-o-n-time-o-1-space
 * Use start and end to keep track of the minimum subarray nums[start...end] which must be sorted for the entire array nums.
 * If start < end < 0 at the end of the for loop, then the array is already fully sorted.
 * <p>
 * Time: O(n)
 * Space: O(1)
 */
public int findUnsortedSubarray(int[] nums){
    int n = nums.length;
    int start = -1;
    int end = -2;
    int min = nums[n - 1];
    int max = nums[0];
    for (int i = 1; i < n; i++) {
        max = Math.max(max, nums[i]);
        min = Math.min(min, nums[n - 1 - i]);
        if (nums[i] < max) {
            end = i;
        }
        if (nums[n - 1 - i] > min) {
            start = n - 1 - i;
        }
    }
    return end - start + 1;
}","/**
 * credit: https://discuss.leetcode.com/topic/89282/java-o-n-time-o-1-space
 * Use start and end to keep track of the minimum subarray nums[start...end] which must be sorted for the entire array nums.
 * If start < end < 0 at the end of the for loop, then the array is already fully sorted.
 * <p>
 * Time: O(n)
 * Space: O(1)
 */
public int findUnsortedSubarray(int[] nums) 
{
    int n = nums.length, beg = -1, end = -2, min = nums[n - 1], max = nums[0];
    for (int i = 1; i < n; i++)
    {
        max = Math.max(max, nums[i]);
        min = Math.min(min, nums[n - 1 - i]);
        if (nums[i] < max)
        {
            end = i;
        }
        if (nums[n - 1 - i] > min)
        {
            beg = n - 1 - i;
        }
    }
    return end - beg + 1;
}   ",1912,True
"/**
 * lixx2100's post is cool:https://discuss.leetcode.com/topic/40162/three-line-java-solution
 * An easy recurrence for this problem is f[i] = f[i / 2] + i % 2
 * and then we'll use bit manipulation to express the above recursion function
 * right shift by 1 means to divide by 2
 * AND with 1 means to modulo 2
 * this is so cool!
 */
public int[] countBits(int num){
    int[] ones = new int[num + 1];
    for (int i = 1; i <= num; i++) {
        ones[i] = ones[i >> 1] + (i & 1);
    }
    return ones;
}","/**
 * lixx2100's post is cool:https://discuss.leetcode.com/topic/40162/three-line-java-solution
 * An easy recurrence for this problem is f[i] = f[i / 2] + i % 2
 * and then we'll use bit manipulation to express the above recursion function
 * right shift by 1 means to divide by 2
 * AND with 1 means to modulo 2
 * this is so cool!
 */
public int[] countBits(int num) 
{
    int[] f = new int[num + 1];
    for (int i=1; i<=num; i++)
        f[i] = f[i >> 1] + (i & 1);
    return f;
}   ",1914,True
"/**
 * This is a very smart solution:
 * First, we can see that the max value k could reach is n-1 which
 * comes from a sequence like this:
 * when n = 8, k = 5, one possible sequence is:
 * 1, 8, 2, 7, 3, 4, 5, 6
 * absolute diffs are:
 * 7, 6, 5, 4, 1, 1, 1
 * so, there are total 5 distinct integers.
 * <p>
 * So, we can just form such a sequence by putting the first part first and
 * decrement k along the way, when k becomes 1, we just put the rest numbers in order.
 */
public int[] constructArray(int n, int k){
    int[] result = new int[n];
    int left = 1;
    int right = n;
    for (int i = 0; i < n && left <= right; i++) {
        if (k > 1) {
            result[i] = k-- % 2 != 0 ? left++ : right--;
        } else {
            result[i] = k % 2 != 0 ? left++ : right--;
        }
    }
    return result;
}","/**
 * This is a very smart solution:
 * First, we can see that the max value k could reach is n-1 which
 * comes from a sequence like this:
 * when n = 8, k = 5, one possible sequence is:
 * 1, 8, 2, 7, 3, 4, 5, 6
 * absolute diffs are:
 * 7, 6, 5, 4, 1, 1, 1
 * so, there are total 5 distinct integers.
 * <p>
 * So, we can just form such a sequence by putting the first part first and
 * decrement k along the way, when k becomes 1, we just put the rest numbers in order.
 */
public int[] constructArray(int n, int k) 
{
    int[] answer = new int[n];
    int idx = 0;
    int left = 1;
    int right = n;

    for (int i = 0; i < k; i++)
    {
        answer[idx++] = left++;
        if (i < k - 1)
        {
            answer[idx++] = right--;
        }
    }

    while (idx < n)
    {
        answer[idx++] = left++;
    }

    return answer;
}   ",1918,True
"/**
 * Checks connectivity with the Internet. This operation is performed only once.
 *
 * @param strategy for observing Internet connectivity
 * @param host for checking Internet connectivity
 * @param port for checking Internet connectivity
 * @param timeoutInMs for pinging remote host in milliseconds
 * @param httpResponse expected HTTP response code indicating that connection is established
 * @param errorHandler for handling errors during connectivity check
 * @return RxJava Single with Boolean - true, when we have connection with host and false if
 * not
 */
@RequiresPermission(Manifest.permission.INTERNET)
protected static Single<Boolean> checkInternetConnectivity(
    final InternetObservingStrategy strategy,
    final String host, final int port, final int timeoutInMs, final int httpResponse,
    final ErrorHandler errorHandler){
  checkStrategyIsNotNull(strategy);
  return strategy.checkInternetConnectivity(host, port, timeoutInMs, httpResponse, errorHandler);
}","/**
 * Checks connectivity with the Internet. This operation is performed only once.
 *
 * @param strategy for observing Internet connectivity
 * @param host for checking Internet connectivity
 * @param port for checking Internet connectivity
 * @param timeoutInMs for pinging remote host in milliseconds
 * @param httpResponse expected HTTP response code indicating that connection is established
 * @param errorHandler for handling errors during connectivity check
 * @return RxJava Single with Boolean - true, when we have connection with host and false if
 * not
 */
@RequiresPermission(Manifest.permission.INTERNET)
protected static Single<Boolean> checkInternetConnectivity(
    final InternetObservingStrategy strategy,
    final String host, final int port, final int timeoutInMs, final int httpResponse,
    final ErrorHandler errorHandler) 
{
    return Single.fromCallable(() -> {
        try
        {
            return strategy.check(host, port, timeoutInMs, httpResponse);
        }
        catch (Exception e)
        {
            errorHandler.handleError(e);
            return false;
        }
    });
}   ",1920,True
"/**
 * sets ping interval in milliseconds
 *
 * @param interval in milliseconds
 * @return Builder
 */
public Builder interval(int interval){
  this.interval = interval;
  return this;
}","/**
 * sets ping interval in milliseconds
 *
 * @param interval in milliseconds
 * @return Builder
 */
public Builder interval(int interval) 
{
    this.interval = interval;
    return this;
}   ",1921,True
"/**
 * sets HTTP response code indicating that connection is established
 *
 * @param httpResponse as integer
 * @return Builder
 */
public Builder httpResponse(final int httpResponse){
  this.httpResponse = httpResponse;
  return this;
}","/**
 * sets HTTP response code indicating that connection is established
 *
 * @param httpResponse as integer
 * @return Builder
 */
public Builder httpResponse(final int httpResponse) 
{
    this.httpResponse = httpResponse;
    return this;
}   ",1924,True
"/**
 * Checks connectivity with the Internet. This operation is performed only once.
 *
 * @param settings Internet Observing Settings created via Builder pattern
 * @return RxJava Single with Boolean - true, when we have connection with host and false if
 * not
 */
@RequiresPermission(Manifest.permission.INTERNET)
public static Single<Boolean> checkInternetConnectivity(InternetObservingSettings settings){
  return checkInternetConnectivity(settings.strategy(), settings.host(), settings.port(),
      settings.timeout(), settings.httpResponse(), settings.errorHandler());
}","/**
 * Checks connectivity with the Internet. This operation is performed only once.
 *
 * @param settings Internet Observing Settings created via Builder pattern
 * @return RxJava Single with Boolean - true, when we have connection with host and false if
 * not
 */
@RequiresPermission(Manifest.permission.INTERNET)
public static Single<Boolean> checkInternetConnectivity(InternetObservingSettings settings) 
{
    return Single.create(emitter ->
    {
        if (!emitter.isDisposed())
        {
            emitter.onSuccess(InternetObserving.checkConnectivity(settings));
        }
    });
}   ",1928,True
"/**
 * Observes connectivity with the Internet in a given time interval.
 *
 * @param strategy for observing Internet connectivity
 * @param initialIntervalInMs in milliseconds determining the delay of the first connectivity
 * check
 * @param intervalInMs in milliseconds determining how often we want to check connectivity
 * @param host for checking Internet connectivity
 * @param port for checking Internet connectivity
 * @param timeoutInMs for pinging remote host in milliseconds
 * @param httpResponse expected HTTP response code indicating that connection is established
 * @param errorHandler for handling errors during connectivity check
 * @return RxJava Observable with Boolean - true, when we have connection with host and false if
 * not
 */
@RequiresPermission(Manifest.permission.INTERNET)
protected static Observable<Boolean> observeInternetConnectivity(
    final InternetObservingStrategy strategy, final int initialIntervalInMs,
    final int intervalInMs, final String host, final int port, final int timeoutInMs,
    final int httpResponse, final ErrorHandler errorHandler){
  checkStrategyIsNotNull(strategy);
  return strategy.observeInternetConnectivity(initialIntervalInMs, intervalInMs, host, port,
      timeoutInMs, httpResponse, errorHandler);
}","/**
 * Observes connectivity with the Internet in a given time interval.
 *
 * @param strategy for observing Internet connectivity
 * @param initialIntervalInMs in milliseconds determining the delay of the first connectivity
 * check
 * @param intervalInMs in milliseconds determining how often we want to check connectivity
 * @param host for checking Internet connectivity
 * @param port for checking Internet connectivity
 * @param timeoutInMs for pinging remote host in milliseconds
 * @param httpResponse expected HTTP response code indicating that connection is established
 * @param errorHandler for handling errors during connectivity check
 * @return RxJava Observable with Boolean - true, when we have connection with host and false if
 * not
 */

@RequiresPermission(Manifest.permission.INTERNET)
protected static Observable<Boolean> observeInternetConnectivity(
    final InternetObservingStrategy strategy, final int initialIntervalInMs,
    final int intervalInMs, final String host, final int port, final int timeoutInMs,
    final int httpResponse, final ErrorHandler errorHandler) 
{
    return Observable.interval(initialIntervalInMs, intervalInMs, TimeUnit.MILLISECONDS)
        .flatMap(new Func1<Long, Observable<Boolean>>()
        {
            @Override
            public Observable<Boolean> call(Long tick)
            {
                return strategy.isHostReachable(host, port, timeoutInMs, httpResponse, errorHandler);
            }
        });
}   ",1929,True
"/**
 * sets ping host
 *
 * @return Builder
 */
public Builder host(String host){
  this.host = host;
  return this;
}","/**
 * sets ping host
 *
 * @return Builder
 */
public Builder host(String host) 
{
    this.host = host;
    return this;
}   ",1933,True
"/**
 * sets ping port
 *
 * @return Builder
 */
public Builder port(int port){
  this.port = port;
  return this;
}","/**
 * sets ping port
 *
 * @return Builder
 */
public Builder port(int port) 
{
    this.port = port;
    return this;
}   ",1939,True
"/**
 * Parse the configuration from file.
 *
 * @param file
 *            to parse
 * @return the collector of authorizations form reader passed into.
 * @throws ParseException
 *             if the format is not compliant.
 */
public static AuthorizationsCollector parse(File file) throws ParseException{
    if (file == null) {
        LOG.warn(""parsing NULL file, so fallback on default configuration!"");
        return AuthorizationsCollector.emptyImmutableCollector();
    }
    if (!file.exists()) {
        LOG.warn(
                String.format(
                        ""parsing not existing file %s, so fallback on default configuration!"",
                        file.getAbsolutePath()));
        return AuthorizationsCollector.emptyImmutableCollector();
    }
    try {
        Reader reader = Files.newBufferedReader(file.toPath(), UTF_8);
        return parse(reader);
    } catch (IOException fex) {
        LOG.warn(
                String.format(
                        ""parsing not existing file %s, so fallback on default configuration!"",
                        file.getAbsolutePath()),
                fex);
        return AuthorizationsCollector.emptyImmutableCollector();
    }
}","/**
 * Parse the configuration from file.
 *
 * @param file
 *            to parse
 * @return the collector of authorizations form reader passed into.
 * @throws ParseException
 *             if the format is not compliant.
 */





public static AuthorizationsCollector parse(File file) throws ParseException 
{
    try
    {
        return parse(new FileReader(file));
    }
    catch (FileNotFoundException e)
    {
        throw new ParseException(e);
    }
}   ",1943,True
"//Copy constructor
private CNode(Token token, List<INode> children, Set<Subscription> subscriptions){
    this.token = token; // keep reference, root comparison in directory logic relies on it for now.
    this.subscriptions = new HashSet<>(subscriptions);
    this.children = new ArrayList<>(children);
}","//Copy constructor
private CNode(Token token, List<INode> children, Set<Subscription> subscriptions) 
{
    this.token = token;
    this.children = children;
    this.subscriptions = subscriptions;
}   ",1945,True
"/**
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 *
 * @param subscriptionTopic
 *            the topic filter of the subscription
 * @return true if the two topics match.
 */
// TODO reimplement with iterators or with queues
public boolean match(Topic subscriptionTopic){
    List<Token> msgTokens = getTokens();
    List<Token> subscriptionTokens = subscriptionTopic.getTokens();
    int i = 0;
    for (; i < subscriptionTokens.size(); i++) {
        Token subToken = subscriptionTokens.get(i);
        if (!Token.MULTI.equals(subToken) && !Token.SINGLE.equals(subToken)) {
            if (i >= msgTokens.size()) {
                return false;
            }
            Token msgToken = msgTokens.get(i);
            if (!msgToken.equals(subToken)) {
                return false;
            }
        } else {
            if (Token.MULTI.equals(subToken)) {
                return true;
            }
//                if (Token.SINGLE.equals(subToken)) {
//                    // skip a step forward
//                }
        }
    }
    return i == msgTokens.size();
}","/**
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 *
 * @param subscriptionTopic
 *            the topic filter of the subscription
 * @return true if the two topics match.
 */
// TODO reimplement with iterators or with queues
public boolean match(Topic subscriptionTopic) 
{
    if (subscriptionTopic.isWildcard())
    {
        return matchWildCard(subscriptionTopic);
    }
    else
    {
        return matchExact(subscriptionTopic);
    }
}   ",1946,True
"/**
 * subscriber A connect and subscribe on ""a/b"" QoS 1 subscriber B connect and subscribe on ""a/+""
 * BUT with QoS 2 publisher connects and send a message ""hello"" on ""a/b"" subscriber A must
 * receive a notification with QoS1 subscriber B must receive a notification with QoS2
 */
@Test
public void checkSubscribersGetCorrectQosNotifications() throws Exception{
    LOG.info(""*** checkSubscribersGetCorrectQosNotifications ***"");

    MqttClientPersistence dsSubscriberA = new MqttDefaultFilePersistence(tempFolder.newFolder(""subscriberA"").getAbsolutePath());

    MqttClient subscriberA = new MqttClient(""tcp://localhost:1883"", ""SubscriberA"", dsSubscriberA);
    MessageCollector cbSubscriberA = new MessageCollector();
    subscriberA.setCallback(cbSubscriberA);
    subscriberA.connect();
    subscriberA.subscribe(""a/b"", 1);

    MqttClientPersistence dsSubscriberB = new MqttDefaultFilePersistence(tempFolder.newFolder(""subscriberB"").getAbsolutePath());

    MqttClient subscriberB = new MqttClient(""tcp://localhost:1883"", ""SubscriberB"", dsSubscriberB);
    MessageCollector cbSubscriberB = new MessageCollector();
    subscriberB.setCallback(cbSubscriberB);
    subscriberB.connect();
    subscriberB.subscribe(""a/+"", 2);

    m_client.connect();
    m_client.publish(""a/b"", ""Hello world MQTT!!"".getBytes(UTF_8), 2, false);

    MqttMessage messageOnA = cbSubscriberA.waitMessage(1);
    assertEquals(""Hello world MQTT!!"", new String(messageOnA.getPayload(), UTF_8));
    assertEquals(1, messageOnA.getQos());
    subscriberA.disconnect();

    MqttMessage messageOnB = cbSubscriberB.waitMessage(1);
    assertNotNull(""MUST be a received message"", messageOnB);
    assertEquals(""Hello world MQTT!!"", new String(messageOnB.getPayload(), UTF_8));
    assertEquals(2, messageOnB.getQos());
    subscriberB.disconnect();
}","/**
 * subscriber A connect and subscribe on ""a/b"" QoS 1 subscriber B connect and subscribe on ""a/+""
 * BUT with QoS 2 publisher connects and send a message ""hello"" on ""a/b"" subscriber A must
 * receive a notification with QoS1 subscriber B must receive a notification with QoS2
 */
@Test
public void checkSubscribersGetCorrectQosNotifications() throws Exception 
{
    final String topic = ""a/b"";
    final String topic2 = ""a/+"";
    final String message = ""hello"";
    final int qos1 = 1;
    final int qos2 = 2;

    // subscriber A connect and subscribe on ""a/b"" QoS 1
    IClient clientSubscriberA = createClient();
    clientSubscriberA.connect();
    clientSubscriberA.subscribe(topic, qos1);

    // subscriber B connect and subscribe on ""a/+""
    IClient clientSubscriberB = createClient();
    clientSubscriberB.connect();
    clientSubscriberB.subscribe(topic2, qos2);

    // publisher connects and send a message ""hello"" on ""a/b""
    IPublisher publisher = createPublisher();
    publisher.connect();
    publisher.publish(topic, message.getBytes(), qos2);

    // Wait for the notifications
    Thread.sleep(1000);

    // Check if subscriber A received the notification with QoS 1
    List<Notification> notificationsSubscriberA = clientSubscriberA.getNotifications();
    assertEquals(1, notificationsSubscriberA.size());
    assertEquals(qos1, notificationsSubscriberA.get(0).getQos());

    // Check if subscriber B received the notification with QoS 2
    List<Notification> notificationsSubscriberB = clientSubscriberB.getNotifications();
    assertEquals(1, notificationsSubscriberB.size());
    assertEquals(qos2, notificationsSubscriberB.get(0).getQos());
}   ",1947,False
"//TODO this is equivalent to negate(containsOnly(clientId))
public boolean contains(String clientId){
    for (Subscription sub : this.subscriptions) {
        if (sub.clientId.equals(clientId)) {
            return true;
        }
    }
    return false;
}","//TODO this is equivalent to negate(containsOnly(clientId))
public boolean contains(String clientId) 
{
    if (clientId == null)
    {
        return false;
    }
    else
    {
        return this.clientIds.contains(clientId);
    }
}   ",1949,True
"/**
 * Check that after a client has connected with clean session false, subscribed to some topic
 * and exited, if it reconnects with clean session true, the broker correctly cleanup every
 * previous subscription
 */
@Test
public void testCleanSession_correctlyClientSubscriptions(){
    connection.processConnect(connectMessage);
    ConnectionTestUtils.assertConnectAccepted(channel);
    assertEquals(""After CONNECT subscription MUST be empty"", 0, subscriptions.size());

    //subscribe(channel, NEWS_TOPIC, AT_MOST_ONCE);
    final MqttSubscribeMessage subscribeMsg = MqttMessageBuilders
        .subscribe()
        .addSubscription(AT_MOST_ONCE, NEWS_TOPIC)
        .messageId(1)
        .build();
    connection.processSubscribe(subscribeMsg);
    assertEquals(""Subscribe MUST contain one subscription"", 1, subscriptions.size());

    connection.processDisconnect(null);
    assertEquals(""Disconnection MUSTN'T clear subscriptions"", 1, subscriptions.size());

    connectMessage = MqttMessageBuilders.connect()
        .clientId(FAKE_CLIENT_ID)
        .cleanSession(true)
        .build();
    channel = new EmbeddedChannel();
    connection = createMQTTConnection(CONFIG, channel);
    connection.processConnect(connectMessage);
    ConnectionTestUtils.assertConnectAccepted(channel);
    assertEquals(""After CONNECT with clean, subscription MUST be empty"", 0, subscriptions.size());

    // publish on /news
    final ByteBuf payload = Unpooled.copiedBuffer(""Hello world!"", Charset.defaultCharset());
    sut.receivedPublishQos0(new Topic(NEWS_TOPIC), TEST_USER, TEST_PWD, payload, false,
        MqttMessageBuilders.publish()
            .payload(payload)
            .qos(MqttQoS.AT_MOST_ONCE)
            .retained(false)
            .topicName(NEWS_TOPIC).build());

    // verify no publish is fired
    ConnectionTestUtils.verifyNoPublishIsReceived(channel);
}","/**
 * Check that after a client has connected with clean session false, subscribed to some topic
 * and exited, if it reconnects with clean session true, the broker correctly cleanup every
 * previous subscription
 */

@Test
public void testCleanSession_correctlyClientSubscriptions() 
{
    try
    {
        // connect a client with clean session false
        MqttClient client = createClient(""cleanSessionFalse"", false);
        client.connect();

        // subscribe to a topic
        client.subscribe(TOPIC);

        // disconnect the client
        client.disconnect();

        // reconnect with clean session true
        client = createClient(""cleanSessionTrue"", true);
        client.connect();

        // check if the previous subscription is still active
        assertTrue(client.isConnected());
        assertTrue(client.getSubscriptions().contains(TOPIC));
    }
    catch (MqttException e)
    {
        fail(""Exception thrown: "" + e.getMessage());
    }
}   ",1951,False
"/**
 * provide authenticator from SQL database
 *
 * @param driver
 *            : jdbc driver class like : ""org.postgresql.Driver""
 * @param jdbcUrl
 *            : jdbc url like : ""jdbc:postgresql://host:port/dbname""
 * @param sqlQuery
 *            : sql query like : ""SELECT PASSWORD FROM USER WHERE LOGIN=?""
 * @param digestMethod
 *            : password encoding algorithm : ""MD5"", ""SHA-1"", ""SHA-256""
 */
public DBAuthenticator(String driver, String jdbcUrl, String sqlQuery, String digestMethod){
    this.sqlQuery = sqlQuery;
    this.dataSource = new HikariDataSource();
    this.dataSource.setJdbcUrl(jdbcUrl);

    try {
        this.messageDigest = MessageDigest.getInstance(digestMethod);
    } catch (NoSuchAlgorithmException nsaex) {
        LOG.error(String.format(""Can't find %s for password encoding"", digestMethod), nsaex);
        throw new RuntimeException(nsaex);
    }
}","/**
 * provide authenticator from SQL database
 *
 * @param driver
 *            : jdbc driver class like : ""org.postgresql.Driver""
 * @param jdbcUrl
 *            : jdbc url like : ""jdbc:postgresql://host:port/dbname""
 * @param sqlQuery
 *            : sql query like : ""SELECT PASSWORD FROM USER WHERE LOGIN=?""
 * @param digestMethod
 *            : password encoding algorithm : ""MD5"", ""SHA-1"", ""SHA-256""
 */
public DBAuthenticator(String driver, String jdbcUrl, String sqlQuery, String digestMethod) 
{
    this.driver = driver;
    this.jdbcUrl = jdbcUrl;
    this.sqlQuery = sqlQuery;
    this.digestMethod = digestMethod;
}   ",1952,False
"/**
 * Return the IoBuffer with string encoded as MSB, LSB and UTF-8 encoded string content.
 */
public static ByteBuf encodeString(String str){
    byte[] raw;
    try {
        raw = str.getBytes(""UTF-8"");
        // NB every Java platform has got UTF-8 encoding by default, so this
        // exception are never raised.
    } catch (UnsupportedEncodingException ex) {
        LoggerFactory.getLogger(Utils.class).error(null, ex);
        return null;
    }
    return encodeFixedLengthContent(raw);
}","/**
 * Return the IoBuffer with string encoded as MSB, LSB and UTF-8 encoded string content.
 */



public static ByteBuf encodeString(String str) 
{
    ByteBuf buffer = Unpooled.buffer();
    byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
    buffer.writeInt(bytes.length);
    buffer.writeBytes(bytes);
    return buffer;
}   ",1953,True
"/**
 * Parse the ACL configuration file
 *
 * @param reader
 *            to parse
 * @return the collector of authorizations form reader passed into.
 * @throws ParseException
 *             if the format is not compliant.
 */
public static AuthorizationsCollector parse(Reader reader) throws ParseException{
    if (reader == null) {
        // just log and return default properties
        LOG.warn(""parsing NULL reader, so fallback on default configuration!"");
        return AuthorizationsCollector.emptyImmutableCollector();
    }

    BufferedReader br = new BufferedReader(reader);
    String line;
    AuthorizationsCollector collector = new AuthorizationsCollector();

    Pattern emptyLine = Pattern.compile(""^\\s*$"");
    Pattern commentLine = Pattern.compile(""^#.*""); // As spec, comment lines should start with '#'
    Pattern invalidCommentLine = Pattern.compile(""^\\s*#.*"");
    // This pattern has a dependency on filtering `commentLine`.
    Pattern endLineComment = Pattern.compile(""^([\\w\\s\\/\\+]+#?)(\\s*#.*)$"");
    Matcher endLineCommentMatcher;

    try {
        while ((line = br.readLine()) != null) {
            if (line.isEmpty() || emptyLine.matcher(line).matches() || commentLine.matcher(line).matches()) {
                // skip it's a black line or comment
                continue;
            } else if (invalidCommentLine.matcher(line).matches()) {
                // it's a malformed comment
                int commentMarker = line.indexOf('#');
                throw new ParseException(line, commentMarker);
            }

            endLineCommentMatcher = endLineComment.matcher(line);
            if (endLineCommentMatcher.matches()) {
                line = endLineCommentMatcher.group(1);
            }

            collector.parse(line);
        }
    } catch (IOException ex) {
        throw new ParseException(""Failed to read"", 1);
    }
    return collector;
}","/**
 * Parse the ACL configuration file
 *
 * @param reader
 *            to parse
 * @return the collector of authorizations form reader passed into.
 * @throws ParseException
 *             if the format is not compliant.
 */

public static AuthorizationsCollector parse(Reader reader) throws ParseException 
{
    AuthorizationsCollector collector = new AuthorizationsCollector();
    try
    {
        parse(reader, collector);
    }
    catch (IOException e)
    {
        throw new ParseException(""Error reading from reader"", e);
    }
    return collector;
}   ",1954,False
"/**
 * Write just String bytes not length
 */
public RawClient write(String str){
    ByteBuf out = Unpooled.buffer(str.length());
    byte[] raw;
    try {
        raw = str.getBytes(""UTF-8"");
        // NB every Java platform has got UTF-8 encoding by default, so this
        // exception are never raised.
    } catch (UnsupportedEncodingException ex) {
        throw new IllegalStateException(ex);
    }
    out.writeBytes(raw);
    m_channel.write(out).addListener(CLOSE_ON_FAILURE);
    return this;
}","/**
 * Write just String bytes not length
 */
public RawClient write(String str) 
{
    byte[] bytes = str.getBytes();
    RawClient client = new RawClient();
    client.write(bytes);
    return client;
}   ",1955,True
"/**
 * Is called when the write timeout expire.
 *
 * @param ctx the channel context.
 */
private void channelIdle(ChannelHandlerContext ctx){
    // ctx.fireUserEventTriggered(evt);
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Flushing idle Netty channel {} Cid: {}"", ctx.channel(), NettyUtils.clientID(ctx.channel()));
    }
    ctx.channel().flush();
}","/**
 * Is called when the write timeout expire.
 *
 * @param ctx the channel context.
 */
private void channelIdle(ChannelHandlerContext ctx) 
{
    if (ctx.channel().isActive())
    {
        ctx.channel().close();
    }
}   ",1956,False
"/**
 * @return a new Topic corresponding to this less than the head token
 * */
public Topic exceptHeadToken(){
    List<Token> tokens = getTokens();
    if (tokens.isEmpty()) {
        return new Topic(Collections.emptyList());
    }
    List<Token> tokensCopy = new ArrayList<>(tokens);
    tokensCopy.remove(0);
    return new Topic(tokensCopy);
}","/**
 * @return a new Topic corresponding to this less than the head token
 * */
public Topic exceptHeadToken() 
{
    Topic result = new Topic();
    result.setTopic(this);
    result.setHeadToken(null);
    return result;
}   ",1957,False
"/**
 * Removes subscription from CTrie, adds TNode when the last client unsubscribes, then calls for cleanTomb in a
 * separate atomic CAS operation.
 *
 * @param topic the subscription's topic to remove.
 * @param clientID the Id of client owning the subscription.
 */
@Override
public void removeSubscription(Topic topic, String clientID){
    ctrie.removeFromTree(topic, clientID);
    this.subscriptionsRepository.removeSubscription(topic.toString(), clientID);
}","/**
 * Removes subscription from CTrie, adds TNode when the last client unsubscribes, then calls for cleanTomb in a
 * separate atomic CAS operation.
 *
 * @param topic the subscription's topic to remove.
 * @param clientID the Id of client owning the subscription.
 */
@Override
public void removeSubscription(Topic topic, String clientID) 
{
    if (topic == null || clientID == null)
    {
        return;
    }
    TNode node = root.get(topic);
    if (node != null)
    {
        node.removeClient(clientID);
        if (node.isEmpty())
        {
            root.remove(topic);
        }
    }
    if (node == null || node.isEmpty())
    {
        cleanTomb();
    }
}   ",1958,True
"/**
 * Compare two char arrays in constant time, so as to protect against timing attacks. (NB:
 * ""Constant time"" means that the method execution time does not depend on the contents of the
 * buffer — it's not a comment about the time complexity.  (The method is obviously O(n).)
 *
 * This is interesting because normal comparisons (Arrays.equals(), eg) short-circuit as soon as a
 * difference is found. This leaks information about the underlying data, and so is inappropriate
 * for comparing secrets.  For more information, see:
 *
 * <ul>
 *   <li><a href=""http://emerose.com/timing-attacks-explained"">this Square Security Awareness
 *     note</a></li>
 *   <li><a href=""http://codahale.com/a-lesson-in-timing-attacks/"">a discussion of Java 6's
 *     MessageDigest.isEqual()</a></li>
 *   <li><a href=""http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf"">a paper on the
 *     practical exploitability of network-based timing attacks</a></li>
 * </ul>
 *
 * @param a first value
 * @param b second value
 * @return true iff a == b
 */
public static boolean secureCompare(final char[] a, final char[] b){
  if (a.length != b.length) {
    return false;
  }

  int match = 0;
  for (int i = 0; i < a.length; i++) {
    match = match | a[i] ^ b[i];
  }

  return (match == 0); // true if match
}","/**
 * Compare two char arrays in constant time, so as to protect against timing attacks. (NB:
 * ""Constant time"" means that the method execution time does not depend on the contents of the
 * buffer — it's not a comment about the time complexity.  (The method is obviously O(n).)
 *
 * This is interesting because normal comparisons (Arrays.equals(), eg) short-circuit as soon as a
 * difference is found. This leaks information about the underlying data, and so is inappropriate
 * for comparing secrets.  For more information, see:
 *
 * <ul>
 *   <li><a href=""http://emerose.com/timing-attacks-explained"">this Square Security Awareness
 *     note</a></li>
 *   <li><a href=""http://codahale.com/a-lesson-in-timing-attacks/"">a discussion of Java 6's
 *     MessageDigest.isEqual()</a></li>
 *   <li><a href=""http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf"">a paper on the
 *     practical exploitability of network-based timing attacks</a></li>
 * </ul>
 *
 * @param a first value
 * @param b second value
 * @return true iff a == b
 */
public static boolean secureCompare(final char[] a, final char[] b) 
{
    if (a.length != b.length) {
        return false;
    }

    int result = 0;
    for (int i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return result == 0;
}   ",1960,True
"// prevent sub-classing
public static Builder builder(){
   return new AutoValue_ModifyGroupsRequestV2.Builder()
       .addGroups()
       .removeGroups();
 }","// prevent sub-classing
public static Builder builder() 
{
    if (builder == null)
    {
        synchronized (Builder.class)
        {
            if (builder == null)
            {
                builder = new Builder();
            }
        }
    }
    return builder;
}   ",1962,False
"// Sets the evaluated password and URL before calling the parent's create method.
@Override public ManagedDataSource build(MetricRegistry metricRegistry, String name){
  setUrl(getUrl());
  setPassword(getPassword());
  return super.build(metricRegistry, name);
}","// Sets the evaluated password and URL before calling the parent's create method.
@Override public ManagedDataSource build(MetricRegistry metricRegistry, String name) 
{
    ManagedDataSource ds = super.build(metricRegistry, name);
    ds.setPassword(password);
    ds.setUrl(url);
    return ds;
}   ",1963,False
"/**
 * Customizes the database config when requested. If the username for the database is not set, the
 * current user is set as the username.
 *
 * @return DatabaseConfiguration for read/write database.
 */
public DataSourceFactory getDataSourceFactory(){
  if (database.getUser() == null) {
    database.setUser(USER_NAME.value());
  }
  return database;
}","/**
 * Customizes the database config when requested. If the username for the database is not set, the
 * current user is set as the username.
 *
 * @return DatabaseConfiguration for read/write database.
 */
public DataSourceFactory getDataSourceFactory() 
{
    if (databaseConfig.getUsername() == null)
    {
        databaseConfig.setUsername(System.getProperty(""user.name""));
    }

    return databaseConfig;
}   ",1968,True
"/**
 * Customized ObjectMapper for common settings.
 *
 * @return customized object mapper
 */
private static ObjectMapper customizeObjectMapper(){
  ObjectMapper mapper = new ObjectMapper();
  mapper.registerModule(new Jdk8Module());
  mapper.registerModule(new GuavaModule());
  mapper.registerModule(new GuavaExtrasModule());
  mapper.registerModule(new FuzzyEnumModule());
  mapper.setPropertyNamingStrategy(new AnnotationSensitivePropertyNamingStrategy());
  mapper.setSubtypeResolver(new DiscoverableSubtypeResolver());
  mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
  return mapper;
}","/**
 * Customized ObjectMapper for common settings.
 *
 * @return customized object mapper
 */





private static ObjectMapper customizeObjectMapper() 
{
    ObjectMapper mapper = new ObjectMapper();
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    return mapper;
}   ",1969,True
"/**
 * Retrieve listing of client names
 * <p>
 * responseMessage 200 List of client names
 */
@Timed @ExceptionMetered
@GET
@Produces(APPLICATION_JSON)
public Iterable<String> clientListing(@Auth AutomationClient automationClient){
  return clientDAOReadOnly.getClients().stream()
      .map(Client::getName)
      .collect(toSet());
}","/**
 * Retrieve listing of client names
 * <p>
 * responseMessage 200 List of client names
 */
@Timed @ExceptionMetered
@GET
@Produces(APPLICATION_JSON)
public Iterable<String> clientListing(@Auth AutomationClient automationClient) 
{
    return automationClient.clientListing();
}   ",1970,False
"/**
 * Retrieve Client by a specified name, or all Clients if no name given
 *
 * @param automationClient the client with automation access performing this operation
 * @param name the name of the Client to retrieve, if provided
 * @return the specified client if found, or all clients if name omitted
 *
 * optionalParams name
 * description Returns a single Client or a set of all Clients
 * responseMessage 200 Found and retrieved Client(s)
 * responseMessage 404 Client with given name not found (if name provided)
 */
@Timed @ExceptionMetered
@GET
public Response findClient(
    @Auth AutomationClient automationClient,
    @QueryParam(""name"") Optional<String> name){
  logger.info(""Automation ({}) - Looking up a name {}"", automationClient.getName(), name);

  if (name.isPresent()) {
    Client client = clientDAO.getClientByName(name.get()).orElseThrow(NotFoundException::new);
    ImmutableList<Group> groups = ImmutableList.copyOf(aclDAO.getGroupsFor(client));
    return Response.ok()
        .entity(ClientDetailResponse.fromClient(client, groups, ImmutableList.of()))
        .build();
  }

  List<ClientDetailResponse> clients = clientDAO.getClients().stream()
      .map(c -> ClientDetailResponse.fromClient(c, ImmutableList.copyOf(aclDAO.getGroupsFor(c)),
          ImmutableList.of()))
      .collect(toList());
  return Response.ok().entity(clients).build();
}","/**
 * Retrieve Client by a specified name, or all Clients if no name given
 *
 * @param automationClient the client with automation access performing this operation
 * @param name the name of the Client to retrieve, if provided
 * @return the specified client if found, or all clients if name omitted
 *
 * optionalParams name
 * description Returns a single Client or a set of all Clients
 * responseMessage 200 Found and retrieved Client(s)
 * responseMessage 404 Client with given name not found (if name provided)
 */
@Timed @ExceptionMetered
@GET
public Response findClient(
    @Auth AutomationClient automationClient,
    @QueryParam(""name"") Optional<String> name) 
{
    if (name.isPresent()) {
        return Response.ok(automationClient.getClientByName(name.get())).build();
    } else {
        return Response.ok(automationClient.getAllClients()).build();
    }
}   ",1972,False
"/**
 * Build a matching representation of a secret, but without sensitive content.
 *
 * @param secret secret model to build from
 * @return content of secret model, but without sensitive content
 */
public static SanitizedSecret fromSecret(Secret secret){
  checkNotNull(secret);
  return SanitizedSecret.of(
      secret.getId(),
      secret.getName(),
      secret.getDescription(),
      secret.getChecksum(),
      secret.getCreatedAt(),
      secret.getCreatedBy(),
      secret.getUpdatedAt(),
      secret.getUpdatedBy(),
      secret.getMetadata(),
      secret.getType().orElse(null),
      secret.getGenerationOptions(),
      secret.getExpiry(),
      secret.getVersion().orElse(null),
      secret.getContentCreatedAt().orElse(null),
      secret.getContentCreatedBy());
}","/**
 * Build a matching representation of a secret, but without sensitive content.
 *
 * @param secret secret model to build from
 * @return content of secret model, but without sensitive content
 */
public static SanitizedSecret fromSecret(Secret secret) 
{
    return SanitizedSecret.builder()
            .id(secret.getId())
            .name(secret.getName())
            .description(secret.getDescription())
            .createdAt(secret.getCreatedAt())
            .updatedAt(secret.getUpdatedAt())
            .build();
}   ",1973,True
"/**
 * Load cookies from the specified file from JSON to a name to value mapping.
 *
 * @param path Location of serialized cookies to load.
 * @return list of cookies that were read
 * @throws IOException
 */
public static List<HttpCookie> loadCookies(Path path) throws IOException{
  TypeReference<List<JsonCookie>> cookiesType = new TypeReference<>() {};
  try (BufferedReader reader = Files.newBufferedReader(path)) {
    List<JsonCookie> jsonCookies = mapper.readValue(reader, cookiesType);
    return jsonCookies.stream()
        .map(JsonCookie::toHttpCookie)
        .collect(toList());
  }
}","/**
 * Load cookies from the specified file from JSON to a name to value mapping.
 *
 * @param path Location of serialized cookies to load.
 * @return list of cookies that were read
 * @throws IOException
 */






public static List<HttpCookie> loadCookies(Path path) throws IOException 
{
    List<HttpCookie> cookies = new ArrayList<>();
    if (path.toFile().exists())
    {
        try (InputStream inputStream = Files.newInputStream(path))
        {
            List<Cookie> loadedCookies = new ObjectMapper().readValue(inputStream, new TypeReference<List<Cookie>>()
            {
            });
            cookies.addAll(loadedCookies.stream().map(Cookie::toHttpCookie).collect(Collectors.toList()));
        }
    }
    return cookies;
}   ",1974,True
"/**
 * Create Group
 *
 * @param user the admin user performing this operation
 * @param request the JSON client request used to formulate the Group
 * @return 200 if the group was created, 409 if the name already existed
 *
 * description Creates a Group with the name from a valid group request.
 * Used by Keywhiz CLI and the web ui.
 * responseMessage 200 Successfully created Group
 * responseMessage 400 Group with given name already exists
 */
@Timed @ExceptionMetered
@POST
@Consumes(APPLICATION_JSON)
public Response createGroup(@Auth User user, @Valid CreateGroupRequestV2 request){

  logger.info(""User '{}' creating group."", user);
  if (groupDAO.getGroup(request.name()).isPresent()) {
    throw new BadRequestException(""Group already exists."");
  }

  long groupId = groupDAO.createGroup(request.name(), user.getName(),
      nullToEmpty(request.description()), request.metadata());
  URI uri = UriBuilder.fromResource(GroupsResource.class).build(groupId);
  Response response = Response
      .created(uri)
      .entity(groupDetailResponseFromId(groupId))
      .build();

  if (response.getStatus() == HttpStatus.SC_CREATED) {
    Map<String, String> extraInfo = new HashMap<>();
    if (request.description() != null) {
      extraInfo.put(""description"", request.description());
    }
    if (request.metadata() != null) {
      extraInfo.put(""metadata"", request.metadata().toString());
    }
    auditLog.recordEvent(new Event(Instant.now(), EventTag.GROUP_CREATE, user.getName(), request.name(), extraInfo));
  }
  return response;
}","/**
 * Create Group
 *
 * @param user the admin user performing this operation
 * @param request the JSON client request used to formulate the Group
 * @return 200 if the group was created, 409 if the name already existed
 *
 * description Creates a Group with the name from a valid group request.
 * Used by Keywhiz CLI and the web ui.
 * responseMessage 200 Successfully created Group
 * responseMessage 400 Group with given name already exists
 */
@Timed @ExceptionMetered
@POST
@Consumes(APPLICATION_JSON)
public Response createGroup(@Auth User user, @Valid CreateGroupRequestV2 request) 
{
    Group group = Group.builder()
        .name(request.getName())
        .description(request.getDescription())
        .build();

    try {
        groupDAO.createGroup(group, user);
        return Response.ok().build();
    } catch (DataAccessException e) {
        if (e instanceof GroupAlreadyExistsException) {
            return Response.status(Response.Status.CONFLICT).build();
        }
        throw e;
    }
}   ",1975,True
"/**
 * Serialize the cookies to JSON from the given CookieManager to a file at the specified path.
 * Output file will have 660 permissions (owner-read, owner-write).
 *
 * @param cookieManager CookieManager that contains cookies to be serialized.
 * @param path Location to serialize cookies to file.
 */
@VisibleForTesting
public static void saveCookies(CookieManager cookieManager, Path path){
  List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
  List<JsonCookie> jsonCookies = cookies.stream()
      .map(JsonCookie::fromHttpCookie)
      .collect(toList());

  try (BufferedWriter writer = Files.newBufferedWriter(path, CREATE)) {
    Files.setPosixFilePermissions(path, ImmutableSet.of(OWNER_READ, OWNER_WRITE));
    writer.write(mapper.writeValueAsString(jsonCookies));
  } catch (IOException e) {
    throw Throwables.propagate(e);
  }
}","/**
 * Serialize the cookies to JSON from the given CookieManager to a file at the specified path.
 * Output file will have 660 permissions (owner-read, owner-write).
 *
 * @param cookieManager CookieManager that contains cookies to be serialized.
 * @param path Location to serialize cookies to file.
 */


@VisibleForTesting
public static void saveCookies(CookieManager cookieManager, Path path) 
{
    try
    {
        Files.writeString(path, new Gson().toJson(cookieManager.getCookies()));
        Files.setPosixFilePermissions(path, PosixFilePermissions.fromString(""rw-------""));
    }
    catch (IOException e)
    {
        throw new RuntimeException(e);
    }
}   ",1976,True
"/**
 * Creates a {@link OkHttpClient} to start a TLS connection.
 *
 * @param devTrustStore if not null, uses the provided TrustStore instead of whatever is
 *                      configured in the JVM. This is a convenient way to allow developers to
 *                      start playing with Keywhiz right away. This option should not be used in
 *                      production systems.
 * @param cookies list of cookies to include in the client.
 * @return new http client.
 */
public static OkHttpClient sslOkHttpClient(@Nullable KeyStore devTrustStore,
    List<HttpCookie> cookies){
  checkNotNull(cookies);

  SSLContext sslContext;
  X509TrustManager trustManager;
  try {
    TrustManagerFactory trustManagerFactory = TrustManagerFactory
        .getInstance(TrustManagerFactory.getDefaultAlgorithm());

    trustManagerFactory.init(devTrustStore);

    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    trustManager = (X509TrustManager) trustManagers[0];

    sslContext = SSLContext.getInstance(""TLSv1.2"");
    sslContext.init(new KeyManager[0], trustManagers, new SecureRandom());
  } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {
    throw Throwables.propagate(e);
  }

  SSLSocketFactory socketFactory = sslContext.getSocketFactory();

  OkHttpClient.Builder client = new OkHttpClient().newBuilder()
      .sslSocketFactory(socketFactory, trustManager)
      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS))
      .followSslRedirects(false);

  client.retryOnConnectionFailure(false);

  cookies.forEach(c -> getCookieManager().getCookieStore().add(null, c));
  client.cookieJar(new JavaNetCookieJar(getCookieManager()));
  return client.build();
}","/**
 * Creates a {@link OkHttpClient} to start a TLS connection.
 *
 * @param devTrustStore if not null, uses the provided TrustStore instead of whatever is
 *                      configured in the JVM. This is a convenient way to allow developers to
 *                      start playing with Keywhiz right away. This option should not be used in
 *                      production systems.
 * @param cookies list of cookies to include in the client.
 * @return new http client.
 */











public static OkHttpClient sslOkHttpClient(@Nullable KeyStore devTrustStore,
    List<HttpCookie> cookies) 
{
    try
    {
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init((KeyStore) null);

        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, tmf.getTrustManagers(), null);

        OkHttpClient.Builder builder = new OkHttpClient.Builder()
            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) tmf.getTrustManagers()[0])
            .hostnameVerifier((hostname, session) -> true);

        if (devTrustStore != null)
        {
            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            kmf.init(devTrustStore, null);
            sslContext.init(kmf.getKeyManagers(), null, null);
        }

        if (cookies != null)
        {
            builder.cookieJar(new JavaNetCookieJar(cookies));
        }

        return builder.build();
    }
    catch (Exception e)
    {
        throw new RuntimeException(e);
    }
}   ",1978,True
"/**
 * <code>bool is_active = 2;</code>
 * @param value The isActive to set.
 * @return This builder for chaining.
 */
public Builder setIsActive(boolean value){
  
  isActive_ = value;
  onChanged();
  return this;
}","/**
 * <code>bool is_active = 2;</code>
 * @param value The isActive to set.
 * @return This builder for chaining.
 */
public Builder setIsActive(boolean value) 
{
    this.isActive = value;
    return this;
}   ",1980,True
"/**
 * <code>string ref_id = 1;</code>
 * @param value The bytes for refId to set.
 * @return This builder for chaining.
 */
public Builder setRefIdBytes(
    com.google.protobuf.ByteString value){
  if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
  
  refId_ = value;
  onChanged();
  return this;
}","/**
 * <code>string ref_id = 1;</code>
 * @param value The bytes for refId to set.
 * @return This builder for chaining.
 */
public Builder setRefIdBytes(
    com.google.protobuf.ByteString value) 
{
  if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);

  refId_ = value;
  onChanged();
  return this;
}   ",1982,True
"/**
 * Helper method which checks the number of versions registered under the given subject.
 */
public static void checkNumberOfVersions(RestService restService, int expected, String subject)
    throws IOException, RestClientException{
  List<Integer> versions = restService.getAllVersions(subject);
  assertEquals(""Expected "" + expected + "" registered versions under subject "" + subject +
               "", but found "" + versions.size(),
               expected, versions.size());
}","/**
 * Helper method which checks the number of versions registered under the given subject.
 */


public static void checkNumberOfVersions(RestService restService, int expected, String subject)
    throws IOException, RestClientException 
{
    List<String> versions = restService.getVersions(subject);
    assertEquals(expected, versions.size());
}   ",1986,True
"/**
 * Register a new schema and verify that it can be found on the expected version.
 */
public static void registerAndVerifySchema(RestService restService, String schemaString,
                                           int expectedId, String subject)
    throws IOException, RestClientException{
  int registeredId = restService.registerSchema(schemaString, subject);
  assertEquals(""Registering a new schema should succeed"", expectedId, registeredId);

  // the newly registered schema should be immediately readable on the leader
  assertEquals(""Registered schema should be found"",
          schemaString,
          restService.getId(expectedId).getSchemaString());
}","/**
 * Register a new schema and verify that it can be found on the expected version.
 */

public static void registerAndVerifySchema(RestService restService, String schemaString,
                                           int expectedId, String subject)
    throws IOException, RestClientException 
{
    Schema schema = new Schema(schemaString);
    int id = restService.registerSchema(schema, subject);
    Assert.assertEquals(expectedId, id);
    Schema found = restService.getSchemaById(id);
    Assert.assertEquals(schema, found);
}   ",1987,True
"/**
 * <code>string ref_id = 1;</code>
 * @return The bytes for refId.
 */
public com.google.protobuf.ByteString
    getRefIdBytes(){
  java.lang.Object ref = refId_;
  if (ref instanceof java.lang.String) {
    com.google.protobuf.ByteString b = 
        com.google.protobuf.ByteString.copyFromUtf8(
            (java.lang.String) ref);
    refId_ = b;
    return b;
  } else {
    return (com.google.protobuf.ByteString) ref;
  }
}","/**
 * <code>string ref_id = 1;</code>
 * @return The bytes for refId.
 */
public com.google.protobuf.ByteString
    getRefIdBytes() 
{
    return refId_;
}   ",1988,False
"/**
 * <code>string ref_id = 1;</code>
 * @return This builder for chaining.
 */
public Builder clearRefId(){
  
  refId_ = getDefaultInstance().getRefId();
  onChanged();
  return this;
}","/**
 * <code>string ref_id = 1;</code>
 * @return This builder for chaining.
 */
public Builder clearRefId() 
{
    refId_ = """";
    onChanged();
    return this;
}   ",1989,True
"/**
 * <code>string ref_id = 1;</code>
 * @return The refId.
 */
public java.lang.String getRefId(){
  java.lang.Object ref = refId_;
  if (ref instanceof java.lang.String) {
    return (java.lang.String) ref;
  } else {
    com.google.protobuf.ByteString bs = 
        (com.google.protobuf.ByteString) ref;
    java.lang.String s = bs.toStringUtf8();
    refId_ = s;
    return s;
  }
}","/**
 * <code>string ref_id = 1;</code>
 * @return The refId.
 */
public java.lang.String getRefId() 
{
    return ref_id;
}   ",1992,True
"// TODO currently don't have a way to store extra metadata such as version
public void testVersionMaintained(){
   // Version info provided from the Copycat schema should be maintained. This should be true
   // regardless of any underlying schema registry versioning since the versions are explicitly
   // specified by the connector.

   // Use newer schema first
   Schema newerSchema = SchemaBuilder.struct()
       .version(2)
       .field(""orig"", Schema.OPTIONAL_INT16_SCHEMA)
       .field(""new"", Schema.OPTIONAL_INT16_SCHEMA)
       .build();
   SchemaAndValue newer = new SchemaAndValue(newerSchema, new Struct(newerSchema));
   byte[] newerSerialized = converter.fromConnectData(TOPIC, newer.schema(), newer.value());

   Schema olderSchema = SchemaBuilder.struct()
       .version(1)
       .field(""orig"", Schema.OPTIONAL_INT16_SCHEMA)
       .build();
   SchemaAndValue older = new SchemaAndValue(olderSchema, new Struct(olderSchema));
   byte[] olderSerialized = converter.fromConnectData(TOPIC, older.schema(), older.value());

   assertEquals(2L, (long) converter.toConnectData(TOPIC, newerSerialized).schema().version());
   assertEquals(1L, (long) converter.toConnectData(TOPIC, olderSerialized).schema().version());
 }","// TODO currently don't have a way to store extra metadata such as version
public void testVersionMaintained() 
{
    final String version = ""1.0.0"";
    final String name = ""test"";
    final String description = ""test description"";
    final String url = ""XXXXXXXXXXXXXXX"";

    final Artifact artifact = new Artifact(name, description, url, version);

    assertEquals(version, artifact.getVersion());
}   ",1995,False
"/**
 * <code>string ref_id = 1;</code>
 * @param value The refId to set.
 * @return This builder for chaining.
 */
public Builder setRefId(
    java.lang.String value){
  if (value == null) {
    throw new NullPointerException();
  }
  
  refId_ = value;
  onChanged();
  return this;
}","/**
 * <code>string ref_id = 1;</code>
 * @param value The refId to set.
 * @return This builder for chaining.
 */
public Builder setRefId(
    java.lang.String value) 
{
  copyOnWrite();
  instance.setRefId(value);
  return this;
}   ",1997,True
"/**
 * Use a strategy that validates that a schema can be read by existing
 * schema(s) according to the JSON default schema resolution.
 */
public SchemaValidatorBuilder canBeReadStrategy(){
  this.strategy = (toValidate, existing) -> existing.isBackwardCompatible(toValidate);
  return this;
}","/**
 * Use a strategy that validates that a schema can be read by existing
 * schema(s) according to the JSON default schema resolution.
 */
public SchemaValidatorBuilder canBeReadStrategy() 
{
    return useStrategy(new CanBeReadStrategy());
}   ",1998,True
